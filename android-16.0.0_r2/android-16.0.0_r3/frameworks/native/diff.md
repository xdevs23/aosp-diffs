```diff
diff --git a/OWNERS b/OWNERS
new file mode 100644
index 0000000000..cceba2068e
--- /dev/null
+++ b/OWNERS
@@ -0,0 +1,4 @@
+# See frameworks/base/OWNERS.md
+jiyong@google.com #{LAST_RESORT_SUGGESTION}
+michaelwr@google.com #{LAST_RESORT_SUGGESTION}
+smoreland@google.com #{LAST_RESORT_SUGGESTION}
diff --git a/PREUPLOAD.cfg b/PREUPLOAD.cfg
index df1ef297bf..8156db3aa9 100644
--- a/PREUPLOAD.cfg
+++ b/PREUPLOAD.cfg
@@ -35,12 +35,3 @@ clang_format = --commit ${PREUPLOAD_COMMIT} --style file --extensions c,h,cc,cpp
                services/vr/
                vulkan/
 bpfmt = -d
-
-[Hook Scripts]
-owners_hook = ${REPO_ROOT}/frameworks/base/tools/aosp/aosp_sha.sh ${PREUPLOAD_COMMIT} "OWNERS$"
-installd_hook = ${REPO_ROOT}/frameworks/base/tools/aosp/aosp_sha.sh ${PREUPLOAD_COMMIT} "^cmds/installd/"
-dumpstate_hook = ${REPO_ROOT}/frameworks/base/tools/aosp/aosp_sha.sh ${PREUPLOAD_COMMIT} "^cmds/dumpstate/"
-dumpsys_hook = ${REPO_ROOT}/frameworks/base/tools/aosp/aosp_sha.sh ${PREUPLOAD_COMMIT} "^cmds/dumpsys/"
-# bugreports matches both cmds/bugreport and cmds/bugreportz
-bugreports_hook = ${REPO_ROOT}/frameworks/base/tools/aosp/aosp_sha.sh ${PREUPLOAD_COMMIT} "^cmds/bugreport"
-binder_hook = ${REPO_ROOT}/frameworks/base/tools/aosp/aosp_sha.sh ${PREUPLOAD_COMMIT} "^libs/binder/"
diff --git a/TEST_MAPPING b/TEST_MAPPING
index a4a22a0f1d..b7356f4cb6 100644
--- a/TEST_MAPPING
+++ b/TEST_MAPPING
@@ -28,10 +28,6 @@
       "name": "SurfaceFlinger_test",
       "keywords": [ "primary-device" ],
       "options": [
-	// TODO(b/328119950) Known to be broken.
-        {
-          "exclude-filter": "LayerCallbackTest#SetNullBuffer"
-        },
 	// TODO(b/398306512) Flaky on real device.
         {
           "exclude-filter": "LayerRenderTypeTransactionTests/LayerRenderTypeTransactionTest#SetRelativeZBasic_BufferQueue/*"
diff --git a/cmds/atrace/atrace.rc b/cmds/atrace/atrace.rc
index 316f04cb27..9f2fd3fe2e 100644
--- a/cmds/atrace/atrace.rc
+++ b/cmds/atrace/atrace.rc
@@ -63,10 +63,6 @@ on late-init
     chmod 0666 /sys/kernel/tracing/events/cpuhp/cpuhp_exit/enable
     chmod 0666 /sys/kernel/debug/tracing/events/cpuhp/cpuhp_pause/enable
     chmod 0666 /sys/kernel/tracing/events/cpuhp/cpuhp_pause/enable
-    chmod 0666 /sys/kernel/debug/tracing/events/power/gpu_frequency/enable
-    chmod 0666 /sys/kernel/tracing/events/power/gpu_frequency/enable
-    chmod 0666 /sys/kernel/debug/tracing/events/power/gpu_work_period/enable
-    chmod 0666 /sys/kernel/tracing/events/power/gpu_work_period/enable
     chmod 0666 /sys/kernel/debug/tracing/events/power/suspend_resume/enable
     chmod 0666 /sys/kernel/tracing/events/power/suspend_resume/enable
     chmod 0666 /sys/kernel/debug/tracing/events/cpufreq_interactive/enable
@@ -439,6 +435,13 @@ on late-init && property:ro.boot.hypervisor.vm.supported=1
     chmod 0440 /sys/kernel/debug/tracing/hyp/events/hyp/host_mem_abort/id
     chmod 0440 /sys/kernel/tracing/hyp/events/hyp/host_mem_abort/id
 
+# Ensure correct permissions on GPU related events
+on late-fs
+    chmod 0666 /sys/kernel/debug/tracing/events/power/gpu_frequency/enable
+    chmod 0666 /sys/kernel/tracing/events/power/gpu_frequency/enable
+    chmod 0666 /sys/kernel/debug/tracing/events/power/gpu_work_period/enable
+    chmod 0666 /sys/kernel/tracing/events/power/gpu_work_period/enable
+
 on property:persist.debug.atrace.boottrace=1
     start boottrace
 
diff --git a/cmds/bugreport/OWNERS b/cmds/bugreport/OWNERS
index 41bfd26774..f68f93207d 100644
--- a/cmds/bugreport/OWNERS
+++ b/cmds/bugreport/OWNERS
@@ -1,5 +1,5 @@
 set noparent
 
-ronish@google.com
+himanshuz@google.com
 nandana@google.com
 jsharkey@android.com
diff --git a/cmds/bugreportz/OWNERS b/cmds/bugreportz/OWNERS
index 41bfd26774..f68f93207d 100644
--- a/cmds/bugreportz/OWNERS
+++ b/cmds/bugreportz/OWNERS
@@ -1,5 +1,5 @@
 set noparent
 
-ronish@google.com
+himanshuz@google.com
 nandana@google.com
 jsharkey@android.com
diff --git a/cmds/dumpstate/Android.bp b/cmds/dumpstate/Android.bp
index fdb032b285..be2e41cb46 100644
--- a/cmds/dumpstate/Android.bp
+++ b/cmds/dumpstate/Android.bp
@@ -89,6 +89,7 @@ cc_defaults {
         "android.hardware.dumpstate@1.0",
         "android.hardware.dumpstate@1.1",
         "android.hardware.dumpstate-V1-ndk",
+        "android.os.flags-aconfig-cc-host",
         "libziparchive",
         "libbase",
         "libbinder", // BAD: dumpstate should not link code directly, should only exec binaries
@@ -99,6 +100,7 @@ cc_defaults {
         "libdumpstateaidl",
         "libdumpstateutil",
         "libdumputils",
+        "libgui",
         "libhardware_legacy",
         "libhidlbase", // BAD: dumpstate should not link code directly, should only exec binaries
         "liblog",
diff --git a/cmds/dumpstate/DumpPool.h b/cmds/dumpstate/DumpPool.h
index 9fb0fcc83c..104318b428 100644
--- a/cmds/dumpstate/DumpPool.h
+++ b/cmds/dumpstate/DumpPool.h
@@ -17,6 +17,7 @@
 #ifndef FRAMEWORK_NATIVE_CMD_DUMPPOOL_H_
 #define FRAMEWORK_NATIVE_CMD_DUMPPOOL_H_
 
+#include <functional>
 #include <future>
 #include <queue>
 #include <string>
diff --git a/cmds/dumpstate/OWNERS b/cmds/dumpstate/OWNERS
index c24bf39ad7..bbec1c61db 100644
--- a/cmds/dumpstate/OWNERS
+++ b/cmds/dumpstate/OWNERS
@@ -1,6 +1,6 @@
 set noparent
 
-ronish@google.com
+himanshuz@google.com
 nandana@google.com
 jsharkey@android.com
 smoreland@google.com
\ No newline at end of file
diff --git a/cmds/dumpstate/TaskQueue.h b/cmds/dumpstate/TaskQueue.h
index b7e72f1c26..93fccd8853 100644
--- a/cmds/dumpstate/TaskQueue.h
+++ b/cmds/dumpstate/TaskQueue.h
@@ -17,6 +17,7 @@
 #ifndef FRAMEWORK_NATIVE_CMD_TASKQUEUE_H_
 #define FRAMEWORK_NATIVE_CMD_TASKQUEUE_H_
 
+#include <functional>
 #include <mutex>
 #include <queue>
 
diff --git a/cmds/dumpstate/binder/android/os/IDumpstate.aidl b/cmds/dumpstate/binder/android/os/IDumpstate.aidl
index 3b8fde9f51..1b1ec291be 100644
--- a/cmds/dumpstate/binder/android/os/IDumpstate.aidl
+++ b/cmds/dumpstate/binder/android/os/IDumpstate.aidl
@@ -61,6 +61,9 @@ interface IDumpstate {
     // Keep bugreport stored after retrieval.
     const int BUGREPORT_FLAG_KEEP_BUGREPORT_ON_RETRIEVAL = 0x4;
 
+    // Capture multi-display screenshots.
+    const int BUGREPORT_FLAG_CAPTURE_MULTI_DISPLAY_SCREENSHOT = 0x8;
+
     /**
      * Speculatively pre-dumps UI data for a bugreport request that might come later.
      *
diff --git a/cmds/dumpstate/dumpstate.cpp b/cmds/dumpstate/dumpstate.cpp
index f5d95b3229..938a163843 100644
--- a/cmds/dumpstate/dumpstate.cpp
+++ b/cmds/dumpstate/dumpstate.cpp
@@ -35,6 +35,7 @@
 #include <android/hidl/manager/1.0/IServiceManager.h>
 #include <android/os/IIncidentCompanion.h>
 #include <android_app_admin_flags.h>
+#include <android_os.h>
 #include <android_tracing.h>
 #include <binder/IServiceManager.h>
 #include <cutils/multiuser.h>
@@ -48,6 +49,7 @@
 #include <dumputils/dump_utils.h>
 #include <errno.h>
 #include <fcntl.h>
+#include <gui/SurfaceComposerClient.h>
 #include <hardware_legacy/power.h>
 #include <hidl/ServiceManagement.h>
 #include <inttypes.h>
@@ -113,10 +115,12 @@ using android::Dumpsys;
 using android::INVALID_OPERATION;
 using android::IServiceManager;
 using android::OK;
+using android::PhysicalDisplayId;
 using android::sp;
 using android::status_t;
 using android::String16;
 using android::String8;
+using android::SurfaceComposerClient;
 using android::TIMED_OUT;
 using android::UNKNOWN_ERROR;
 using android::Vector;
@@ -212,6 +216,11 @@ static const std::string SHUTDOWN_CHECKPOINTS_FILE_PREFIX = "checkpoints-";
 // File path to default screenshot image, that used when failed to capture the real screenshot.
 static const std::string DEFAULT_SCREENSHOT_PATH = "/system/etc/default_screenshot.png";
 
+// File path of the persistent ring buffer perfetto trace. This always exists when persistent ring
+// buffer trace feature is enabled.
+static const std::string PREV_BOOT_TRACE_PATH =
+    std::string(SYSTEM_TRACE_DIR) + "/prev_boot_dump.trace";
+
 // TODO: temporary variables and functions used during C++ refactoring
 
 #define RETURN_IF_USER_DENIED_CONSENT()                                                        \
@@ -798,6 +807,9 @@ android::binder::Status Dumpstate::ConsentCallback::onReportApproved() {
                                                     ds.options_->screenshot_fd.get());
     if (copy_succeeded) {
         android::os::UnlinkAndLogOnError(ds.screenshot_path_);
+        for (auto& [_, path] : ds.screenshot_path_by_display_id_) {
+            android::os::UnlinkAndLogOnError(path);
+        }
     } else {
         MYLOGE("Failed to copy screenshot to a permanent file.\n");
         copy_succeeded = android::os::CopyFileToFd(DEFAULT_SCREENSHOT_PATH,
@@ -883,6 +895,12 @@ static const std::set<std::string> PROBLEMATIC_FILE_EXTENSIONS = {
 
 status_t Dumpstate::AddZipEntryFromFd(const std::string& entry_name, int fd,
                                       std::chrono::milliseconds timeout = 0ms) {
+    return AddZipEntryFromFd(zip_writer_, entry_name, fd, timeout);
+}
+
+status_t Dumpstate::AddZipEntryFromFd(const std::unique_ptr<ZipWriter>& zip_writer,
+                                      const std::string& entry_name, int fd,
+                                      std::chrono::milliseconds timeout = 0ms) {
     std::string valid_name = entry_name;
 
     // Rename extension if necessary.
@@ -899,21 +917,20 @@ status_t Dumpstate::AddZipEntryFromFd(const std::string& entry_name, int fd,
     // Logging statement  below is useful to time how long each entry takes, but it's too verbose.
     // MYLOGD("Adding zip entry %s\n", entry_name.c_str());
     size_t flags = ZipWriter::kCompress | ZipWriter::kDefaultCompression;
-    int32_t err = zip_writer_->StartEntryWithTime(valid_name.c_str(), flags,
-                                                  get_mtime(fd, ds.now_));
+    int32_t err = zip_writer->StartEntryWithTime(valid_name.c_str(), flags, get_mtime(fd, ds.now_));
     if (err != 0) {
-        MYLOGE("zip_writer_->StartEntryWithTime(%s): %s\n", valid_name.c_str(),
+        MYLOGE("zip_writer->StartEntryWithTime(%s): %s\n", valid_name.c_str(),
                ZipWriter::ErrorCodeString(err));
         return UNKNOWN_ERROR;
     }
     bool finished_entry = false;
-    auto finish_entry = [this, &finished_entry] {
+    auto finish_entry = [&zip_writer, &finished_entry] {
         if (!finished_entry) {
             // This should only be called when we're going to return an earlier error,
             // which would've been logged. This may imply the file is already corrupt
             // and any further logging from FinishEntry is more likely to mislead than
             // not.
-            this->zip_writer_->FinishEntry();
+            zip_writer->FinishEntry();
         }
     };
     auto scope_guard = android::base::make_scope_guard(finish_entry);
@@ -950,17 +967,17 @@ status_t Dumpstate::AddZipEntryFromFd(const std::string& entry_name, int fd,
             MYLOGE("read(%s): %s\n", entry_name.c_str(), strerror(errno));
             return -errno;
         }
-        err = zip_writer_->WriteBytes(buffer.data(), bytes_read);
+        err = zip_writer->WriteBytes(buffer.data(), bytes_read);
         if (err) {
-            MYLOGE("zip_writer_->WriteBytes(): %s\n", ZipWriter::ErrorCodeString(err));
+            MYLOGE("zip_writer->WriteBytes(): %s\n", ZipWriter::ErrorCodeString(err));
             return UNKNOWN_ERROR;
         }
     }
 
-    err = zip_writer_->FinishEntry();
+    err = zip_writer->FinishEntry();
     finished_entry = true;
     if (err != 0) {
-        MYLOGE("zip_writer_->FinishEntry(): %s\n", ZipWriter::ErrorCodeString(err));
+        MYLOGE("zip_writer->FinishEntry(): %s\n", ZipWriter::ErrorCodeString(err));
         return UNKNOWN_ERROR;
     }
 
@@ -968,6 +985,11 @@ status_t Dumpstate::AddZipEntryFromFd(const std::string& entry_name, int fd,
 }
 
 bool Dumpstate::AddZipEntry(const std::string& entry_name, const std::string& entry_path) {
+    return AddZipEntry(zip_writer_, entry_name, entry_path);
+}
+
+bool Dumpstate::AddZipEntry(const std::unique_ptr<ZipWriter>& zip_writer,
+                            const std::string& entry_name, const std::string& entry_path) {
     android::base::unique_fd fd(
         TEMP_FAILURE_RETRY(open(entry_path.c_str(), O_RDONLY | O_NONBLOCK | O_CLOEXEC)));
     if (fd == -1) {
@@ -975,7 +997,7 @@ bool Dumpstate::AddZipEntry(const std::string& entry_name, const std::string& en
         return false;
     }
 
-    return (AddZipEntryFromFd(entry_name, fd.get()) == OK);
+    return (AddZipEntryFromFd(zip_writer, entry_name, fd.get()) == OK);
 }
 
 /* adds a file to the existing zipped bugreport */
@@ -1129,6 +1151,9 @@ static void MaybeAddSystemTraceToZip() {
     // tracing was happening.
     size_t traces_found = android::os::ForEachTrace([&](const std::string& trace_path) {
         ds.AddZipEntry(ZIP_ROOT_DIR + trace_path, trace_path);
+        if (trace_path == PREV_BOOT_TRACE_PATH) {
+            return;
+        }
         android::os::UnlinkAndLogOnError(trace_path);
     });
 
@@ -1752,6 +1777,7 @@ Dumpstate::RunStatus Dumpstate::dumpstate() {
     DumpFile("ZONEINFO", "/proc/zoneinfo");
     DumpFile("PAGETYPEINFO", "/proc/pagetypeinfo");
     DumpFile("BUDDYINFO", "/proc/buddyinfo");
+    DumpFile("MGLRU", "/sys/kernel/mm/lru_gen/enabled");
     DumpExternalFragmentationInfo();
 
     DumpFile("KERNEL CPUFREQ", "/sys/devices/system/cpu/cpu0/cpufreq/stats/time_in_state");
@@ -2764,17 +2790,18 @@ void Dumpstate::DumpstateBoard(int out_fd) {
 
 static void ShowUsage() {
     fprintf(stderr,
-            "usage: dumpstate [-h] [-b soundfile] [-e soundfile] [-o directory] [-p] "
+            "usage: dumpstate [-h] [-b soundfile] [-e soundfile] [-o directory] [-p] [-m] "
             "[-s] [-S] [-q] [-P] [-R] [-L] [-V version]\n"
             "  -h: display this help message\n"
             "  -b: play sound file instead of vibrate, at beginning of job\n"
             "  -e: play sound file instead of vibrate, at end of job\n"
             "  -o: write to custom directory (only in limited mode)\n"
             "  -p: capture screenshot to filename.png\n"
+            "  -m: capture screenshots of all displays to filename.zip\n"
             "  -s: write zipped file to control socket (for init)\n"
             "  -S: write file location to control socket (for init)\n"
             "  -q: disable vibrate\n"
-            "  -P: send broadcast when started and do progress updates\n"
+            "  -P: send broadcast when started and finished and do progress updates\n"
             "  -R: take bugreport in remote mode (shouldn't be used with -P)\n"
             "  -w: start binder service and make it wait for a call to startBugreport\n"
             "  -L: output limited information that is safe for submission in feedback reports\n"
@@ -2898,7 +2925,20 @@ static bool PrepareToWriteToFile() {
     }
 
     if (ds.options_->do_screenshot) {
-        ds.screenshot_path_ = ds.GetPath(ds.CalledByApi() ? "-png.tmp" : ".png");
+        if (android::os::bugreport_multi_display_screenshot_enabled() &&
+            ds.options_->multi_display_screenshot) {
+            ds.screenshot_path_ =
+                ds.GetPath(ds.CalledByApi() ? "-screenshots-zip.tmp" : "-screenshots.zip");
+
+            std::vector<PhysicalDisplayId> ids = SurfaceComposerClient::getPhysicalDisplayIds();
+            for (PhysicalDisplayId display_id : ids) {
+                std::string id = android::to_string(display_id);
+                std::string path = ds.GetPath("-" + id + ".png");
+                ds.screenshot_path_by_display_id_.insert(std::make_pair(id, path));
+            }
+        } else {
+            ds.screenshot_path_ = ds.GetPath(ds.CalledByApi() ? "-png.tmp" : ".png");
+        }
     }
     ds.tmp_path_ = ds.GetPath(".tmp");
     ds.log_path_ = ds.GetPath("-dumpstate_log-" + std::to_string(ds.pid_) + ".txt");
@@ -3033,15 +3073,14 @@ static void SetOptionsFromMode(Dumpstate::BugreportMode mode, Dumpstate::DumpOpt
 static void LogDumpOptions(const Dumpstate::DumpOptions& options) {
     MYLOGI(
         "do_vibrate: %d stream_to_socket: %d progress_updates_to_socket: %d do_screenshot: %d "
-        "is_remote_mode: %d show_header_only: %d telephony_only: %d "
+        "multi_display_screenshot: %d is_remote_mode: %d show_header_only: %d telephony_only: %d "
         "wifi_only: %d do_progress_updates: %d fd: %d bugreport_mode: %s "
         "limited_only: %d args: %s\n",
         options.do_vibrate, options.stream_to_socket, options.progress_updates_to_socket,
-        options.do_screenshot, options.is_remote_mode, options.show_header_only,
-        options.telephony_only, options.wifi_only,
+        options.do_screenshot, options.multi_display_screenshot, options.is_remote_mode,
+        options.show_header_only, options.telephony_only, options.wifi_only,
         options.do_progress_updates, options.bugreport_fd.get(),
-        options.bugreport_mode_string.c_str(),
-        options.limited_only, options.args.c_str());
+        options.bugreport_mode_string.c_str(), options.limited_only, options.args.c_str());
 }
 
 void Dumpstate::DumpOptions::Initialize(BugreportMode bugreport_mode,
@@ -3052,6 +3091,8 @@ void Dumpstate::DumpOptions::Initialize(BugreportMode bugreport_mode,
                                         bool skip_user_consent) {
     this->use_predumped_ui_data = bugreport_flags & BugreportFlag::BUGREPORT_USE_PREDUMPED_UI_DATA;
     this->is_consent_deferred = bugreport_flags & BugreportFlag::BUGREPORT_FLAG_DEFER_CONSENT;
+    this->multi_display_screenshot =
+        bugreport_flags & BugreportFlag::BUGREPORT_FLAG_CAPTURE_MULTI_DISPLAY_SCREENSHOT;
     this->skip_user_consent = skip_user_consent;
     // Duplicate the fds because the passed in fds don't outlive the binder transaction.
     bugreport_fd.reset(fcntl(bugreport_fd_in.get(), F_DUPFD_CLOEXEC, 0));
@@ -3063,7 +3104,7 @@ void Dumpstate::DumpOptions::Initialize(BugreportMode bugreport_mode,
 Dumpstate::RunStatus Dumpstate::DumpOptions::Initialize(int argc, char* argv[]) {
     RunStatus status = RunStatus::OK;
     int c;
-    while ((c = getopt(argc, argv, "dho:svqzpLPBRSV:w")) != -1) {
+    while ((c = getopt(argc, argv, "dho:svqzpmLPBRSV:w")) != -1) {
         switch (c) {
             // clang-format off
             case 'o': out_dir = optarg;              break;
@@ -3072,6 +3113,7 @@ Dumpstate::RunStatus Dumpstate::DumpOptions::Initialize(int argc, char* argv[])
             case 'v': show_header_only = true;       break;
             case 'q': do_vibrate = false;            break;
             case 'p': do_screenshot = true;          break;
+            case 'm': multi_display_screenshot = true;      break;
             case 'P': do_progress_updates = true;    break;
             case 'R': is_remote_mode = true;         break;
             case 'L': limited_only = true;           break;
@@ -3358,14 +3400,16 @@ Dumpstate::RunStatus Dumpstate::RunInternal(int32_t calling_uid,
         return ERROR;
     }
 
+
+    // clang-format off
+    std::vector<std::string> am_args = {
+            "--receiver-permission", "android.permission.DUMP",
+    };
+    // clang-format on
+
     // Interactive, wear & telephony modes are default to true.
     // and may enable from cli option or when using control socket
     if (options_->do_progress_updates) {
-        // clang-format off
-        std::vector<std::string> am_args = {
-                "--receiver-permission", "android.permission.DUMP",
-        };
-        // clang-format on
         // Send STARTED broadcast for apps that listen to bugreport generation events
         SendBroadcast("com.android.internal.intent.action.BUGREPORT_STARTED",
                       am_args, multiuser_get_user_id(calling_uid));
@@ -3459,6 +3503,7 @@ Dumpstate::RunStatus Dumpstate::RunInternal(int32_t calling_uid,
     }
 
     MaybeTakeEarlyScreenshot();
+    MaybeSavePlaceholderScreenshot();
     MaybeWaitForSnapshotSystemTrace(std::move(snapshot_system_trace));
     onUiIntensiveBugreportDumpsFinished(calling_uid);
     MaybeCheckUserConsent(calling_uid, calling_package);
@@ -3519,6 +3564,14 @@ Dumpstate::RunStatus Dumpstate::RunInternal(int32_t calling_uid,
         }
     }
 
+     if (options_->do_progress_updates) {
+        // Send COMPLETED broadcast to notify corresponding apps.
+        // Compare to the deprecated `BUGREPORT_FINISHED` action, this does not contain any
+        // bugreport information. This acts solely for notification only.
+        SendBroadcast("com.android.internal.intent.action.BUGREPORT_COMPLETED",
+                      am_args, multiuser_get_user_id(calling_uid));
+     }
+
     /* vibrate a few but shortly times to let user know it's finished */
     if (options_->do_vibrate) {
         for (int i = 0; i < 3; i++) {
@@ -3558,6 +3611,26 @@ void Dumpstate::MaybeTakeEarlyScreenshot() {
     TakeScreenshot();
 }
 
+void Dumpstate::MaybeSavePlaceholderScreenshot() {
+    if (options_->do_screenshot) {
+        // No need to save a placeholder screenshot if a real one will be taken.
+        return;
+    }
+    if (!options_->is_consent_deferred) {
+        return;
+    }
+
+    // When consent is deferred, a screenshot used to be taken even when one
+    // was not requested. The screenshot is not taken any more but a placeholder
+    // is saved for backwards compatibility.
+    std::string path = ds.GetPath(ds.CalledByApi() ? "-png.tmp" : ".png");
+    if (android::os::CopyFileToFile(DEFAULT_SCREENSHOT_PATH, path)) {
+        MYLOGD("Saved fallback screenshot on %s\n", path.c_str());
+    } else {
+        MYLOGE("Failed to save fallback screenshot on %s\n", path.c_str());
+    };
+}
+
 std::future<std::string> Dumpstate::MaybeSnapshotSystemTraceAsync() {
     // When capturing traces via bugreport handler (BH), this function will be invoked twice:
     // 1) When BH invokes IDumpstate::PreDumpUiData()
@@ -3582,7 +3655,12 @@ std::future<std::string> Dumpstate::MaybeSnapshotSystemTraceAsync() {
     }
 
     // If a stale file exists already, remove it.
-    android::os::ForEachTrace([&](const std::string& trace_path) { unlink(trace_path.c_str()); });
+    android::os::ForEachTrace([&](const std::string& trace_path) {
+        if (trace_path == PREV_BOOT_TRACE_PATH) {
+            return;
+        }
+        unlink(trace_path.c_str());
+    });
 
     MYLOGI("Launching async '%s'", SERIALIZE_PERFETTO_TRACE_TASK.c_str())
 
@@ -3628,18 +3706,6 @@ void Dumpstate::MaybeSnapshotUiTraces() {
         {"cmd", "window", "shell", "tracing", "save-for-bugreport"},
     };
 
-    if (!android_tracing_perfetto_transition_tracing()) {
-        dumpTracesForBugReportCommands.push_back({"dumpsys", "activity", "service",
-                                                  "SystemUIService", "WMShell", "transitions",
-                                                  "tracing", "save-for-bugreport"});
-    }
-
-    if (!android_tracing_perfetto_protolog_tracing()) {
-        dumpTracesForBugReportCommands.push_back({"dumpsys", "activity", "service",
-                                                  "SystemUIService", "WMShell", "protolog",
-                                                  "save-for-bugreport"});
-    }
-
     for (const auto& command : dumpTracesForBugReportCommands) {
         RunCommand(
             // Empty name because it's not intended to be classified as a bugreport section.
@@ -3707,6 +3773,9 @@ bool Dumpstate::CalledByApi() const {
 void Dumpstate::CleanupTmpFiles() {
     android::os::UnlinkAndLogOnError(tmp_path_);
     android::os::UnlinkAndLogOnError(screenshot_path_);
+    for (auto& [_, path] : screenshot_path_by_display_id_) {
+        android::os::UnlinkAndLogOnError(path);
+    }
     android::os::UnlinkAndLogOnError(path_);
     if (dump_traces_path != nullptr) {
         android::os::UnlinkAndLogOnError(dump_traces_path);
@@ -4670,7 +4739,7 @@ void Dumpstate::UpdateProgress(int32_t delta_sec) {
     // Always update progess so stats can be tuned...
     progress_->Inc(delta_sec);
 
-    // ...but only notifiy listeners when necessary.
+    // ...but only notify listeners when necessary.
     if (!options_->do_progress_updates) return;
 
     int progress = progress_->Get();
@@ -4702,6 +4771,15 @@ void Dumpstate::UpdateProgress(int32_t delta_sec) {
 }
 
 void Dumpstate::TakeScreenshot(const std::string& path) {
+    if (android::os::bugreport_multi_display_screenshot_enabled() &&
+        ds.options_->multi_display_screenshot) {
+        TakeMultiDisplayScreenshots(path);
+    } else {
+        TakeSingleDisplayScreenshot(path);
+    }
+}
+
+void Dumpstate::TakeSingleDisplayScreenshot(const std::string& path) {
     const std::string& real_path = path.empty() ? screenshot_path_ : path;
     int status =
         RunCommand("", {"screencap", "-p", real_path},
@@ -4718,6 +4796,44 @@ void Dumpstate::TakeScreenshot(const std::string& path) {
     }
 }
 
+void Dumpstate::TakeMultiDisplayScreenshots(const std::string& path) {
+    const std::string& real_path = path.empty() ? screenshot_path_ : path;
+
+    FILE* zipFile = fopen(real_path.c_str(), "wb");
+    std::unique_ptr<ZipWriter> zip_writer = std::make_unique<ZipWriter>(zipFile);
+
+    bool success = false;
+
+    for (auto& [display_id, screenshot_path] : ds.screenshot_path_by_display_id_) {
+        int status = RunCommand(
+            "", {"/system/bin/screencap", "-p", screenshot_path, "-d", display_id},
+            CommandOptions::WithTimeout(10).Always().DropRoot().RedirectStderr().Build());
+
+        if (status == 0) {
+            MYLOGD("Screenshot for display id %s saved on %s\n", display_id.c_str(),
+                   screenshot_path.c_str());
+
+            size_t flags = ZipWriter::kCompress | ZipWriter::kDefaultCompression;
+            std::filesystem::path p(screenshot_path);
+            std::string filename = p.filename().string();
+            AddZipEntry(zip_writer, filename, screenshot_path);
+            success = true;
+        } else {
+            MYLOGE("Failed to take screenshot for display id %s on %s\n", display_id.c_str(),
+                   screenshot_path.c_str());
+        }
+    }
+
+    zip_writer->Finish();
+    fclose(zipFile);
+
+    if (listener_ != nullptr) {
+        // Show a visual indication to indicate screenshot is taken via
+        // IDumpstateListener.onScreenshotTaken()
+        listener_->onScreenshotTaken(success);
+    }
+}
+
 bool is_dir(const char* pathname) {
     struct stat info;
     if (stat(pathname, &info) == -1) {
diff --git a/cmds/dumpstate/dumpstate.h b/cmds/dumpstate/dumpstate.h
index fcb8cf3c07..7f6c1fc60d 100644
--- a/cmds/dumpstate/dumpstate.h
+++ b/cmds/dumpstate/dumpstate.h
@@ -208,11 +208,12 @@ class Dumpstate {
     // The flags used to customize bugreport requests.
     enum BugreportFlag {
         BUGREPORT_USE_PREDUMPED_UI_DATA =
-          android::os::IDumpstate::BUGREPORT_FLAG_USE_PREDUMPED_UI_DATA,
-        BUGREPORT_FLAG_DEFER_CONSENT =
-          android::os::IDumpstate::BUGREPORT_FLAG_DEFER_CONSENT,
-          BUGREPORT_FLAG_KEEP_BUGREPORT_ON_RETRIEVAL =
-                    android::os::IDumpstate::BUGREPORT_FLAG_KEEP_BUGREPORT_ON_RETRIEVAL
+            android::os::IDumpstate::BUGREPORT_FLAG_USE_PREDUMPED_UI_DATA,
+        BUGREPORT_FLAG_DEFER_CONSENT = android::os::IDumpstate::BUGREPORT_FLAG_DEFER_CONSENT,
+        BUGREPORT_FLAG_KEEP_BUGREPORT_ON_RETRIEVAL =
+            android::os::IDumpstate::BUGREPORT_FLAG_KEEP_BUGREPORT_ON_RETRIEVAL,
+        BUGREPORT_FLAG_CAPTURE_MULTI_DISPLAY_SCREENSHOT =
+            android::os::IDumpstate::BUGREPORT_FLAG_CAPTURE_MULTI_DISPLAY_SCREENSHOT
     };
 
     static android::os::dumpstate::CommandOptions DEFAULT_DUMPSYS;
@@ -410,6 +411,7 @@ class Dumpstate {
         // Writes generation progress updates to a socket.
         bool progress_updates_to_socket = false;
         bool do_screenshot = false;
+        bool multi_display_screenshot = false;
         bool is_screenshot_copied = false;
         bool is_consent_deferred = false;
         bool skip_user_consent = false;
@@ -513,6 +515,9 @@ class Dumpstate {
     // Full path of the file containing the screenshot (when requested).
     std::string screenshot_path_;
 
+    // Full paths of the files containing the screenshots for multi displays (when requested).
+    std::map<std::string, std::string> screenshot_path_by_display_id_;
+
     // Pointer to the zipped file.
     std::unique_ptr<FILE, int (*)(FILE*)> zip_file{nullptr, fclose};
 
@@ -572,7 +577,17 @@ class Dumpstate {
     RunStatus DumpstateDefaultAfterCritical();
     RunStatus dumpstate();
 
+    bool AddZipEntry(const std::unique_ptr<ZipWriter>& zip_writer, const std::string& entry_name,
+                     const std::string& entry_path);
+    android::status_t AddZipEntryFromFd(const std::unique_ptr<ZipWriter>& zip_writer,
+                                        const std::string& entry_name, int fd,
+                                        std::chrono::milliseconds timeout);
+
+    void TakeSingleDisplayScreenshot(const std::string& path = "");
+    void TakeMultiDisplayScreenshots(const std::string& path = "");
+
     void MaybeTakeEarlyScreenshot();
+    void MaybeSavePlaceholderScreenshot();
     std::future<std::string> MaybeSnapshotSystemTraceAsync();
     void MaybeWaitForSnapshotSystemTrace(std::future<std::string> task);
     void MaybeSnapshotUiTraces();
diff --git a/cmds/dumpstate/tests/dumpstate_test.cpp b/cmds/dumpstate/tests/dumpstate_test.cpp
index 18c2f94432..3e5267f7bd 100644
--- a/cmds/dumpstate/tests/dumpstate_test.cpp
+++ b/cmds/dumpstate/tests/dumpstate_test.cpp
@@ -1001,13 +1001,6 @@ TEST_F(DumpstateTest, DumpPool_withParallelRunDisabled_isNull) {
 TEST_F(DumpstateTest, PreDumpUiData) {
     // These traces are always enabled, i.e. they are always pre-dumped
     std::vector<std::filesystem::path> uiTraces;
-    if (!android_tracing_perfetto_transition_tracing()) {
-        uiTraces.push_back(
-            std::filesystem::path{"/data/misc/wmtrace/wm_transition_trace.winscope"});
-        uiTraces.push_back(
-            std::filesystem::path{"/data/misc/wmtrace/shell_transition_trace.winscope"});
-    }
-
     for (const auto traceFile : uiTraces) {
         std::system(("rm -f " + traceFile.string()).c_str());
         EXPECT_FALSE(std::filesystem::exists(traceFile)) << traceFile << " was not deleted.";
@@ -1082,6 +1075,78 @@ TEST_F(ZippedBugReportStreamTest, DISABLED_StreamLimitedOnlyReport) {
     VerifyEntry(handle_, bugreport_txt_name, &entry);
 }
 
+TEST_F(ZippedBugReportStreamTest, ScreenShotFileCreated) {
+    std::string out_path = kTestDataPath + "ScreenShotCapturedOut.zip";
+    android::base::unique_fd out_fd;
+    CreateFd(out_path, &out_fd);
+    ds_.options_->limited_only = true;
+    ds_.options_->stream_to_socket = true;
+    ds_.options_->do_screenshot = false;
+    ds_.options_->is_consent_deferred = true;
+    RedirectOutputToFd(out_fd);
+
+    GenerateBugreport();
+
+    std::string screenshot = ds_.GetPath(ds_.CalledByApi() ? "-png.tmp" : ".png");
+    EXPECT_TRUE(std::filesystem::exists(screenshot)) << screenshot << " was not created.";
+    android::base::RemoveFileIfExists(screenshot);
+}
+
+TEST_F(ZippedBugReportStreamTest, ScreenShotFileIsNotCreated) {
+    std::string out_path = kTestDataPath + "ScreenShotCapturedOut.zip";
+    android::base::unique_fd out_fd;
+    CreateFd(out_path, &out_fd);
+    ds_.options_->limited_only = true;
+    ds_.options_->stream_to_socket = true;
+    ds_.options_->do_screenshot = false;
+    ds_.options_->is_consent_deferred = false;
+    RedirectOutputToFd(out_fd);
+
+    GenerateBugreport();
+
+    std::string screenshot = ds_.GetPath(ds_.CalledByApi() ? "-png.tmp" : ".png");
+    EXPECT_FALSE(std::filesystem::exists(screenshot)) << screenshot << " was created.";
+}
+
+TEST_F(ZippedBugReportStreamTest, ScreenShotZipFileCreated) {
+    std::string out_path = kTestDataPath + "ScreenShotCapturedOut.zip";
+    android::base::unique_fd out_fd;
+    CreateFd(out_path, &out_fd);
+    ds_.options_->limited_only = true;
+    ds_.options_->stream_to_socket = true;
+    ds_.options_->do_screenshot = false;
+    ds_.options_->multi_display_screenshot = true;
+    RedirectOutputToFd(out_fd);
+
+    GenerateBugreport();
+
+    std::string screenshot = ds_.GetPath(ds_.CalledByApi() ? "-screenshots-zip.tmp" : ".zip");
+    EXPECT_TRUE(std::filesystem::exists(screenshot)) << screenshot << " was not created.";
+    android::base::RemoveFileIfExists(screenshot);
+}
+
+TEST_F(ZippedBugReportStreamTest, ScreenShotsAreIncludedInScreenShotZipFile) {
+    std::string out_path = kTestDataPath + "ScreenShotCapturedOut.zip";
+    android::base::unique_fd out_fd;
+    CreateFd(out_path, &out_fd);
+    ds_.options_->limited_only = true;
+    ds_.options_->stream_to_socket = true;
+    ds_.options_->do_screenshot = false;
+    ds_.options_->multi_display_screenshot = true;
+    RedirectOutputToFd(out_fd);
+
+    GenerateBugreport();
+    std::string screenshot_path = ds_.GetPath(ds_.CalledByApi() ? "-screenshots-zip.tmp" : ".zip");
+    OpenArchive(screenshot_path.c_str(), &handle_);
+
+    ZipEntry entry;
+    for (auto& [_, path] : ds_.screenshot_path_by_display_id_) {
+        std::filesystem::path p(path);
+        VerifyEntry(handle_, p.filename().string(), &entry);
+    }
+    android::base::RemoveFileIfExists(screenshot_path);
+}
+
 class ProgressTest : public DumpstateBaseTest {
   public:
     Progress GetInstance(int32_t max, double growth_factor, const std::string& path = "") {
diff --git a/cmds/dumpsys/OWNERS b/cmds/dumpsys/OWNERS
index 03143ae659..194b75f288 100644
--- a/cmds/dumpsys/OWNERS
+++ b/cmds/dumpsys/OWNERS
@@ -1,6 +1,6 @@
 set noparent
 
-ronish@google.com
+himanshuz@google.com
 nandana@google.com
 jsharkey@android.com
 
diff --git a/cmds/dumpsys/tests/dumpsys_test.cpp b/cmds/dumpsys/tests/dumpsys_test.cpp
index 17ae0aa2bf..5574240876 100644
--- a/cmds/dumpsys/tests/dumpsys_test.cpp
+++ b/cmds/dumpsys/tests/dumpsys_test.cpp
@@ -68,6 +68,7 @@ class ServiceManagerMock : public IServiceManager {
                                              const sp<LocalRegistrationCallback>&));
     MOCK_METHOD0(getServiceDebugInfo, std::vector<ServiceDebugInfo>());
     MOCK_METHOD1(enableAddServiceCache, void(bool));
+    MOCK_METHOD5(checkServiceAccess, bool(const String16&, pid_t, uid_t, const String16&, const String16&));
 
   protected:
     MOCK_METHOD0(onAsBinder, IBinder*());
diff --git a/cmds/idlcli/utils.h b/cmds/idlcli/utils.h
index dc52c57987..e7eb18aaf6 100644
--- a/cmds/idlcli/utils.h
+++ b/cmds/idlcli/utils.h
@@ -19,6 +19,8 @@
 
 #include <android/binder_enums.h>
 
+#include <algorithm>
+#include <functional>
 #include <iomanip>
 #include <iostream>
 #include <map>
diff --git a/cmds/installd/Android.bp b/cmds/installd/Android.bp
index 334bae44e3..a995bc51e5 100644
--- a/cmds/installd/Android.bp
+++ b/cmds/installd/Android.bp
@@ -7,6 +7,20 @@ package {
     default_applicable_licenses: ["frameworks_native_license"],
 }
 
+aconfig_declarations {
+    name: "installd_flags",
+    package: "android.installd.flags",
+    container: "system",
+    srcs: [
+        "installd_flags.aconfig",
+    ],
+}
+
+cc_aconfig_library {
+    name: "installd_flags_c_lib",
+    aconfig_declarations: "installd_flags",
+}
+
 cc_defaults {
     name: "installd_defaults",
 
@@ -50,6 +64,7 @@ cc_defaults {
         "server_configurable_flags",
     ],
     static_libs: [
+        "installd_flags_c_lib",
         "libasync_safe",
         "libext2_uuid",
     ],
diff --git a/cmds/installd/CacheTracker.cpp b/cmds/installd/CacheTracker.cpp
index a61f6bf87b..1c5ab461e7 100644
--- a/cmds/installd/CacheTracker.cpp
+++ b/cmds/installd/CacheTracker.cpp
@@ -22,6 +22,8 @@
 #include <sys/xattr.h>
 #include <utils/Trace.h>
 
+#include <algorithm>
+
 #include <android-base/logging.h>
 #include <android-base/stringprintf.h>
 
diff --git a/cmds/installd/InstalldNativeService.cpp b/cmds/installd/InstalldNativeService.cpp
index db565513c9..4bc9908697 100644
--- a/cmds/installd/InstalldNativeService.cpp
+++ b/cmds/installd/InstalldNativeService.cpp
@@ -77,6 +77,8 @@
 #include "QuotaUtils.h"
 #include "SysTrace.h"
 
+#include <android_installd_flags.h>
+
 #ifndef LOG_TAG
 #define LOG_TAG "installd"
 #endif
@@ -89,6 +91,7 @@ using android::base::StringPrintf;
 using android::base::unique_fd;
 using android::os::ParcelFileDescriptor;
 using std::endl;
+namespace flags = android::installd::flags;
 
 namespace android {
 namespace installd {
@@ -882,6 +885,11 @@ binder::Status InstalldNativeService::createAppDataLocked(
             chown_app_profile_dir(packageName, appId, userId);
         }
 
+        if (flags::enable_set_inode_quotas() &&
+            !PrepareAppInodeQuota(uuid ? uuid->c_str() : "", uid)) {
+            PLOG(ERROR) << "Failed to set hard quota " + path;
+        }
+
         if (!prepare_app_profile_dir(packageName, appId, userId)) {
             return error("Failed to prepare profiles for " + packageName);
         }
diff --git a/cmds/installd/QuotaUtils.cpp b/cmds/installd/QuotaUtils.cpp
index 60271392e9..28bfea60f2 100644
--- a/cmds/installd/QuotaUtils.cpp
+++ b/cmds/installd/QuotaUtils.cpp
@@ -17,9 +17,11 @@
 #include "QuotaUtils.h"
 
 #include <fstream>
+#include <mutex>
 #include <unordered_map>
 
 #include <sys/quota.h>
+#include <sys/statvfs.h>
 
 #include <android-base/logging.h>
 
@@ -142,5 +144,69 @@ int64_t GetOccupiedSpaceForGid(const std::string& uuid, gid_t gid) {
 
 }
 
+bool PrepareAppInodeQuota(const std::string& uuid, uid_t uid) {
+    const std::string device = FindQuotaDeviceForUuid(uuid);
+    // Skip when device has no quotas present
+    if (device.empty()) {
+        return true;
+    }
+
+#if APPLY_HARD_QUOTAS
+    struct dqblk dq;
+    if (quotactl(QCMD(Q_GETQUOTA, USRQUOTA), device.c_str(), uid, reinterpret_cast<char*>(&dq)) !=
+        0) {
+        PLOG(WARNING) << "Failed to find quota for " << uid;
+        return false;
+    }
+
+    if (dq.dqb_ihardlimit == 0) {
+        auto path = create_data_path(uuid.empty() ? nullptr : uuid.c_str());
+        struct statvfs stat;
+        if (statvfs(path.c_str(), &stat) != 0) {
+            PLOG(WARNING) << "Failed to statvfs " << path;
+            return false;
+        }
+
+        dq.dqb_valid |= QIF_ILIMITS;
+        // limiting the app to only 50% of the inodes available,
+        // reducing the limit will be too restrictive especially for apps with valid use cases
+        dq.dqb_ihardlimit = (stat.f_files / 2);
+
+        if (quotactl(QCMD(Q_SETQUOTA, USRQUOTA), device.c_str(), uid,
+                     reinterpret_cast<char*>(&dq)) != 0) {
+            PLOG(WARNING) << "Failed to set hard quota for " << uid;
+            return false;
+        } else {
+            LOG(DEBUG) << "Applied hard quotas for " << uid;
+            return true;
+        }
+    } else {
+        // Hard quota already set; assume it's reasonable
+        return true;
+    }
+#else
+    // Hard quotas disabled
+    return true;
+#endif
+}
+
+int64_t GetInodesQuotaHardLimitsForUid(const std::string& uuid, uid_t uid) {
+    const std::string device = FindQuotaDeviceForUuid(uuid);
+    if (device.empty()) {
+        return 0;
+    }
+
+    struct dqblk dq;
+    if (quotactl(QCMD(Q_GETQUOTA, USRQUOTA), device.c_str(), uid, reinterpret_cast<char*>(&dq)) !=
+        0) {
+        if (errno != ESRCH) {
+            PLOG(ERROR) << "Failed to quotactl " << device << " for UID " << uid;
+        }
+        return -1;
+    } else {
+        return dq.dqb_ihardlimit;
+    }
+}
+
 }  // namespace installd
 }  // namespace android
diff --git a/cmds/installd/QuotaUtils.h b/cmds/installd/QuotaUtils.h
index 96aca0448e..1a4739ce7a 100644
--- a/cmds/installd/QuotaUtils.h
+++ b/cmds/installd/QuotaUtils.h
@@ -37,6 +37,16 @@ int64_t GetOccupiedSpaceForGid(const std::string& uuid, gid_t gid);
 
 /* Get the current occupied space in bytes for a project id or -1 if fails */
 int64_t GetOccupiedSpaceForProjectId(const std::string& uuid, int projectId);
+
+/**
+ * Ensure that we have a hard-limit quota to protect against abusive apps;
+ * they should never use more than 50% of inodes.
+ */
+bool PrepareAppInodeQuota(const std::string& uuid, uid_t uid);
+
+/* Get the inode quota hard limits for a uid or -1 if fails */
+int64_t GetInodesQuotaHardLimitsForUid(const std::string& uuid, uid_t uid);
+
 }  // namespace installd
 }  // namespace android
 
diff --git a/cmds/installd/installd_flags.aconfig b/cmds/installd/installd_flags.aconfig
new file mode 100644
index 0000000000..4ad6a33235
--- /dev/null
+++ b/cmds/installd/installd_flags.aconfig
@@ -0,0 +1,10 @@
+package: "android.installd.flags"
+container: "system"
+
+flag {
+  name: "enable_set_inode_quotas"
+  namespace: "mediaprovider"
+  description: "This flag controls setting inode quota limits for apps"
+  bug: "293301664"
+  is_fixed_read_only: true
+}
\ No newline at end of file
diff --git a/cmds/installd/tests/Android.bp b/cmds/installd/tests/Android.bp
index f3e024c5dc..e0f991f06e 100644
--- a/cmds/installd/tests/Android.bp
+++ b/cmds/installd/tests/Android.bp
@@ -95,6 +95,7 @@ cc_defaults {
         "server_configurable_flags",
     ],
     static_libs: [
+        "installd_flags_c_lib",
         "libasync_safe",
         "libdiskusage",
         "libext2_uuid",
diff --git a/cmds/installd/tests/installd_service_test.cpp b/cmds/installd/tests/installd_service_test.cpp
index 023491fc10..217270915d 100644
--- a/cmds/installd/tests/installd_service_test.cpp
+++ b/cmds/installd/tests/installd_service_test.cpp
@@ -36,8 +36,10 @@
 #include <fstream>
 
 #include <android/content/pm/IPackageManagerNative.h>
+#include <android_installd_flags.h>
 #include <binder/IServiceManager.h>
 #include "InstalldNativeService.h"
+#include "QuotaUtils.h"
 #include "binder/Status.h"
 #include "binder_test_utils.h"
 #include "dexopt.h"
@@ -49,6 +51,7 @@ using android::base::StringPrintf;
 using android::base::unique_fd;
 using android::os::ParcelFileDescriptor;
 using std::filesystem::is_empty;
+namespace flags = android::installd::flags;
 
 namespace android {
 std::string get_package_name(uid_t uid) {
@@ -228,6 +231,27 @@ protected:
     }
 };
 
+TEST_F(ServiceTest, CreateAppData_QuotaEnforcementSet) {
+    LOG(INFO) << "CreateAppData_QuotaEnforcementSet";
+    if (!flags::enable_set_inode_quotas()) {
+        return;
+    }
+    android::os::CreateAppDataResult result;
+    android::os::CreateAppDataArgs args;
+    args.uuid = std::nullopt;
+    args.packageName = "com.foo";
+    args.userId = kTestUserId;
+    args.appId = kTestAppId;
+    args.seInfo = "default";
+    args.flags = FLAG_STORAGE_DE;
+
+    // initialise the mounts
+    service->invalidateMounts();
+    ASSERT_BINDER_SUCCESS(service->createAppData(args, &result));
+
+    EXPECT_LT(0, GetInodesQuotaHardLimitsForUid("", kTestAppId));
+}
+
 TEST_F(ServiceTest, FixupAppData_Upgrade) {
     LOG(INFO) << "FixupAppData_Upgrade";
 
diff --git a/cmds/installd/utils.h b/cmds/installd/utils.h
index c43fdbd547..baa5752ce2 100644
--- a/cmds/installd/utils.h
+++ b/cmds/installd/utils.h
@@ -38,6 +38,8 @@
 #define BYPASS_QUOTA 0
 #define BYPASS_SDCARDFS 0
 
+#define APPLY_HARD_QUOTAS 1
+
 namespace android {
 namespace installd {
 
diff --git a/cmds/servicemanager/ServiceManager.cpp b/cmds/servicemanager/ServiceManager.cpp
index 59c4d53bc0..57a0817c19 100644
--- a/cmds/servicemanager/ServiceManager.cpp
+++ b/cmds/servicemanager/ServiceManager.cpp
@@ -1179,6 +1179,65 @@ Status ServiceManager::getServiceDebugInfo(std::vector<ServiceDebugInfo>* outRet
     return Status::ok();
 }
 
+Status ServiceManager::checkServiceAccessImpl(const Access::CallingContext& ctx,
+                                              const std::string& name,
+                                              const std::string& permission, bool* outReturn) {
+    *outReturn = false;
+    if (permission == "find") {
+        std::optional<std::string> _accessor;
+        if (auto status = canFindService(ctx, name, &_accessor); !status.isOk()) {
+            return Status::fromExceptionCode(Status::EX_SECURITY, "SELinux denied.");
+        }
+    } else if (permission == "add") {
+        std::optional<std::string> _accessor;
+        if (auto status = canAddService(ctx, name, &_accessor); !status.isOk()) {
+            return Status::fromExceptionCode(Status::EX_SECURITY, "SELinux denied.");
+        }
+    } else if (permission == "list") {
+        if (!mAccess->canList(ctx)) {
+            return Status::fromExceptionCode(Status::EX_SECURITY, "SELinux denied.");
+        }
+    } else {
+        ALOGE("Unknown service_manager permission: %s", permission.c_str());
+        return Status::fromExceptionCode(Status::EX_ILLEGAL_ARGUMENT, "Invalid permission");
+    }
+
+    *outReturn = true;
+    return Status::ok();
+}
+
+Status ServiceManager::checkServiceAccess(const IServiceManager::CallerContext& callerCtx,
+                                          const std::string& name, const std::string& permission,
+                                          bool* outReturn) {
+    if (callerCtx.sidName.empty() || name.empty() || permission.empty()) {
+        return Status::
+                fromExceptionCode(Status::EX_SECURITY,
+                                  String8::format("Call to checkServiceAccess has incomplete "
+                                                  "arguments. "
+                                                  "the caller security context (sid): \"%s\", "
+                                                  "name: \"%s\", permission: \"%s\".",
+                                                  callerCtx.sidName.c_str(), name.c_str(),
+                                                  permission.c_str()));
+    }
+    // The caller must have check_access permission
+    Access::CallingContext directCallerCtx = mAccess->getCallingContext();
+    // TODO add check_access permission in system/sepolicy/private/access_vectors
+    // For now, the only user of this, virtmgr, already has access to these
+    // services because it needs to proxy them.
+    auto status = checkServiceAccessImpl(directCallerCtx, name, permission, outReturn);
+    if (!status.isOk() || !*outReturn) {
+        return Status::fromExceptionCode(Status::EX_SECURITY,
+                                         "Caller is not allowed to delegate this check to "
+                                         "servicemanager.");
+    }
+
+    Access::CallingContext callingCtx;
+    callingCtx.debugPid = callerCtx.debugPid;
+    callingCtx.uid = callerCtx.uid;
+    callingCtx.sid = callerCtx.sidName;
+    return checkServiceAccessImpl(callingCtx, name, permission, outReturn);
+}
+
 void ServiceManager::clear() {
     mNameToService.clear();
     mNameToRegistrationCallback.clear();
diff --git a/cmds/servicemanager/ServiceManager.h b/cmds/servicemanager/ServiceManager.h
index 5c4d891218..30f3349536 100644
--- a/cmds/servicemanager/ServiceManager.h
+++ b/cmds/servicemanager/ServiceManager.h
@@ -68,6 +68,9 @@ public:
                                           const sp<IClientCallback>& cb) override;
     binder::Status tryUnregisterService(const std::string& name, const sp<IBinder>& binder) override;
     binder::Status getServiceDebugInfo(std::vector<ServiceDebugInfo>* outReturn) override;
+    binder::Status checkServiceAccess(const os::IServiceManager::CallerContext& callerCtx,
+                                      const std::string& name, const std::string& permission,
+                                      bool* outReturn) override;
     void binderDied(const wp<IBinder>& who) override;
     void handleClientCallbacks();
 
@@ -120,7 +123,9 @@ private:
                                  std::optional<std::string>* accessor);
     binder::Status canFindService(const Access::CallingContext& ctx, const std::string& name,
                                   std::optional<std::string>* accessor);
-
+    binder::Status checkServiceAccessImpl(const Access::CallingContext& ctx,
+                                          const std::string& name, const std::string& permission,
+                                          bool* outReturn);
     ServiceMap mNameToService;
     ServiceCallbackMap mNameToRegistrationCallback;
     ClientCallbackMap mNameToClientCallback;
diff --git a/cmds/servicemanager/rpc_servicemanager/Android.bp b/cmds/servicemanager/rpc_servicemanager/Android.bp
new file mode 100644
index 0000000000..8872caa06c
--- /dev/null
+++ b/cmds/servicemanager/rpc_servicemanager/Android.bp
@@ -0,0 +1,26 @@
+package {
+    // See: http://go/android-license-faq
+    // A large-scale-change added 'default_applicable_licenses' to import
+    // all of the 'license_kinds' from "frameworks_native_license"
+    // to get the below license kinds:
+    //   SPDX-license-identifier-Apache-2.0
+    default_applicable_licenses: ["frameworks_native_license"],
+}
+
+rust_library {
+    name: "librpc_servicemanager",
+    crate_name: "rpc_servicemanager",
+    srcs: ["rpc_servicemanager.rs"],
+    rustlibs: [
+        "android.system.virtualmachineservice-rust",
+        "libanyhow",
+        "libbinder_rs",
+        "liblibc",
+        "liblog_rust",
+        "librpcbinder_rs",
+        "librustutils",
+        "libvsock",
+        "rpc_servicemanager_aidl-rust",
+        "servicemanager_aidl-rust",
+    ],
+}
diff --git a/cmds/servicemanager/rpc_servicemanager/rpc_servicemanager.rs b/cmds/servicemanager/rpc_servicemanager/rpc_servicemanager.rs
new file mode 100644
index 0000000000..702dbeda56
--- /dev/null
+++ b/cmds/servicemanager/rpc_servicemanager/rpc_servicemanager.rs
@@ -0,0 +1,181 @@
+// Copyright 2025, The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! Implementation of the AIDL interface `IServiceManager`.
+
+use anyhow::Result;
+use binder::{Accessor, BinderFeatures, Interface, Strong};
+use libc::{sa_family_t, sockaddr_vm, AF_VSOCK};
+use log::{error, info};
+use rpc_servicemanager_aidl::aidl::android::os::IRpcProvider::{
+    IRpcProvider, ServiceConnectionInfo::ServiceConnectionInfo,
+};
+use rpcbinder::{FileDescriptorTransportMode, RpcServer};
+use rustutils::sockets::android_get_control_socket;
+use servicemanager_aidl::aidl::android::os::IServiceManager::{
+    BnServiceManager, CallerContext::CallerContext, IServiceManager,
+};
+use servicemanager_aidl::aidl::android::os::{
+    ConnectionInfo::ConnectionInfo, IClientCallback::IClientCallback,
+    IServiceCallback::IServiceCallback, Service::Service, ServiceDebugInfo::ServiceDebugInfo,
+};
+use vsock::VMADDR_CID_HOST;
+
+// Name of the socket that libbinder is expecting IServiceManager to be served from
+const RPC_SERVICEMANAGER_UDS_NAME: &str = "rpc_servicemanager";
+
+/// Implementation of `IServiceManager`.
+pub struct RpcServiceManager {
+    provider_service: Strong<dyn IRpcProvider>,
+}
+
+impl IServiceManager for RpcServiceManager {
+    fn getService(&self, _name: &str) -> binder::Result<Option<binder::SpIBinder>> {
+        Err(binder::ExceptionCode::UNSUPPORTED_OPERATION.into())
+    }
+    fn getService2(&self, name: &str) -> binder::Result<Service> {
+        let provider_service = self.provider_service.clone();
+
+        let get_connection_info = move |inst: &str| {
+            let connection_info = provider_service.getServiceConnectionInfo(inst).unwrap();
+            match connection_info {
+                ServiceConnectionInfo::Vsock(info) => {
+                    let addr = sockaddr_vm {
+                        svm_family: AF_VSOCK as sa_family_t,
+                        svm_reserved1: 0,
+                        svm_port: info.port as u32,
+                        svm_cid: VMADDR_CID_HOST,
+                        svm_zero: [0u8; 4],
+                    };
+                    Some(binder::ConnectionInfo::Vsock(addr))
+                }
+                #[allow(unreachable_patterns)]
+                _ => {
+                    error!("Unexpected ServiceConnectionInfo type!");
+                    None
+                }
+            }
+        };
+
+        let accessor = Accessor::new(name, get_connection_info);
+
+        Ok(Service::Accessor(accessor.as_binder()))
+    }
+    fn checkService(&self, _name: &str) -> binder::Result<Option<binder::SpIBinder>> {
+        Err(binder::ExceptionCode::UNSUPPORTED_OPERATION.into())
+    }
+    fn checkService2(&self, _name: &str) -> binder::Result<Service> {
+        Err(binder::ExceptionCode::UNSUPPORTED_OPERATION.into())
+    }
+    fn addService(
+        &self,
+        _name: &str,
+        _service: &binder::SpIBinder,
+        _allow_isolated: bool,
+        _dump_priority: i32,
+    ) -> binder::Result<()> {
+        Err(binder::ExceptionCode::UNSUPPORTED_OPERATION.into())
+    }
+    fn listServices(&self, _dump_priority: i32) -> binder::Result<Vec<String>> {
+        Err(binder::ExceptionCode::UNSUPPORTED_OPERATION.into())
+    }
+    fn registerForNotifications(
+        &self,
+        _name: &str,
+        _callback: &binder::Strong<dyn IServiceCallback>,
+    ) -> binder::Result<()> {
+        Err(binder::ExceptionCode::UNSUPPORTED_OPERATION.into())
+    }
+    fn unregisterForNotifications(
+        &self,
+        _name: &str,
+        _callback: &binder::Strong<dyn IServiceCallback>,
+    ) -> binder::Result<()> {
+        Err(binder::ExceptionCode::UNSUPPORTED_OPERATION.into())
+    }
+    fn isDeclared(&self, _name: &str) -> binder::Result<bool> {
+        Err(binder::ExceptionCode::UNSUPPORTED_OPERATION.into())
+    }
+    fn getDeclaredInstances(&self, _iface: &str) -> binder::Result<Vec<String>> {
+        Err(binder::ExceptionCode::UNSUPPORTED_OPERATION.into())
+    }
+    fn updatableViaApex(&self, _name: &str) -> binder::Result<Option<String>> {
+        Err(binder::ExceptionCode::UNSUPPORTED_OPERATION.into())
+    }
+    fn getUpdatableNames(&self, _apex_name: &str) -> binder::Result<Vec<String>> {
+        Err(binder::ExceptionCode::UNSUPPORTED_OPERATION.into())
+    }
+    fn getConnectionInfo(&self, _name: &str) -> binder::Result<Option<ConnectionInfo>> {
+        Err(binder::ExceptionCode::UNSUPPORTED_OPERATION.into())
+    }
+    fn registerClientCallback(
+        &self,
+        _name: &str,
+        _service: &binder::SpIBinder,
+        _callback: &binder::Strong<dyn IClientCallback>,
+    ) -> binder::Result<()> {
+        Err(binder::ExceptionCode::UNSUPPORTED_OPERATION.into())
+    }
+    fn tryUnregisterService(
+        &self,
+        _name: &str,
+        _service: &binder::SpIBinder,
+    ) -> binder::Result<()> {
+        Err(binder::ExceptionCode::UNSUPPORTED_OPERATION.into())
+    }
+    fn getServiceDebugInfo(&self) -> binder::Result<Vec<ServiceDebugInfo>> {
+        Err(binder::ExceptionCode::UNSUPPORTED_OPERATION.into())
+    }
+    fn checkServiceAccess(&self, _: &CallerContext, _: &str, _: &str) -> binder::Result<bool> {
+        Err(binder::ExceptionCode::UNSUPPORTED_OPERATION.into())
+    }
+}
+
+impl Interface for RpcServiceManager {}
+
+impl RpcServiceManager {
+    /// Creates a new `RpcServiceManager` instance from the `IServiceManager` reference.
+    fn new(provider_service: Strong<dyn IRpcProvider>) -> RpcServiceManager {
+        Self { provider_service }
+    }
+}
+
+/// Registers the `IServiceManager` service.
+///
+/// servicemanager_fd is an optional argument to provide the Unix Domain Socked file
+/// descriptor to use for the server. If None is provided, then it will use the default
+/// of RPC_SERVICEMANAGER_UDS_NAME to get the FD.
+pub fn register_rpc_servicemanager(provider_service: Strong<dyn IRpcProvider>) -> Result<()> {
+    let rpc_servicemanager_binder = BnServiceManager::new_binder(
+        RpcServiceManager::new(provider_service),
+        BinderFeatures::default(),
+    );
+    let server = RpcServer::new_bound_socket(
+        rpc_servicemanager_binder.as_binder(),
+        android_get_control_socket(RPC_SERVICEMANAGER_UDS_NAME)?,
+    )?;
+    // Required for the FD being passed through libbinder's accessor binder
+    server.set_supported_file_descriptor_transport_modes(&[FileDescriptorTransportMode::Unix]);
+
+    info!("The RPC server '{}' is running.", RPC_SERVICEMANAGER_UDS_NAME);
+    if let Err(e) = rustutils::system_properties::write("servicemanager.ready", "true") {
+        error!("failed to set ro.servicemanager.ready {:?}", e);
+    }
+
+    // Move server reference into a background thread and run it forever.
+    std::thread::spawn(move || {
+        server.join();
+    });
+    Ok(())
+}
diff --git a/data/etc/Android.bp b/data/etc/Android.bp
index f320504551..7dcd23c159 100644
--- a/data/etc/Android.bp
+++ b/data/etc/Android.bp
@@ -334,6 +334,18 @@ prebuilt_etc {
     defaults: ["frameworks_native_data_etc_defaults"],
 }
 
+prebuilt_etc {
+    name: "android.hardware.telephony.euicc.prebuilt.xml",
+    src: "android.hardware.telephony.euicc.xml",
+    defaults: ["frameworks_native_data_etc_defaults"],
+}
+
+prebuilt_etc {
+    name: "android.hardware.telephony.euicc.mep.prebuilt.xml",
+    src: "android.hardware.telephony.euicc.mep.xml",
+    defaults: ["frameworks_native_data_etc_defaults"],
+}
+
 prebuilt_etc {
     name: "android.hardware.thread_network.prebuilt.xml",
     src: "android.hardware.thread_network.xml",
diff --git a/data/etc/android.hardware.type.automotive.xml b/data/etc/android.hardware.type.automotive.xml
index 8605d18d19..572639656b 100644
--- a/data/etc/android.hardware.type.automotive.xml
+++ b/data/etc/android.hardware.type.automotive.xml
@@ -18,5 +18,11 @@
 <permissions>
     <feature name="android.hardware.type.automotive" />
 
+    <unavailable-feature name="android.hardware.type.embedded" />
+    <unavailable-feature name="android.hardware.type.pc" />
+    <unavailable-feature name="android.hardware.type.television" />
+    <unavailable-feature name="android.hardware.type.watch" />
+    <unavailable-feature name="android.software.leanback" />
+    <unavailable-feature name="android.software.leanback_only" />
     <unavailable-feature name="android.software.picture_in_picture"/>
 </permissions>
diff --git a/include/android/configuration.h b/include/android/configuration.h
index a291db0ecd..bb3bc4fda1 100644
--- a/include/android/configuration.h
+++ b/include/android/configuration.h
@@ -133,10 +133,14 @@ enum {
      * resource qualifier.
      */
     ACONFIGURATION_DENSITY_XXXHIGH = 640,
+    // If adding additional special density values, also update ACONFIGURATION_MAX_SUPPORTED_DENSITY
+    // in CursorInputMapper.
+    // LINT.IfChange
     /** Density: any density. */
     ACONFIGURATION_DENSITY_ANY = 0xfffe,
     /** Density: no density specified. */
     ACONFIGURATION_DENSITY_NONE = 0xffff,
+    // LINT.ThenChange(/services/inputflinger/reader/mapper/CursorInputMapper.cpp)
 
     /** Keyboard: not specified. */
     ACONFIGURATION_KEYBOARD_ANY  = 0x0000,
diff --git a/include/android/display_luts.h b/include/android/display_luts.h
index eae2bfd351..70d7faeccd 100644
--- a/include/android/display_luts.h
+++ b/include/android/display_luts.h
@@ -60,13 +60,29 @@ typedef struct ADisplayLuts ADisplayLuts;
 /**
  * Creates a \a ADisplayLutsEntry entry.
  *
- * You are responsible for mamanging the memory of the returned object.
+ * You are responsible for managing the memory of the returned object.
  * Always call \a ADisplayLutsEntry_destroy to release it after use.
  *
  * Functions like \a ADisplayLuts_set create their own copies of entries,
  * therefore they don't take the ownership of the instance created by
  * \a ADisplayLutsEntry_create.
  *
+ * 1D Lut(s) are treated as gain curves.
+ *
+ * 3D Lut(s) are used for direct color manipulations.
+ * For 3D Lut(s), the values should be normalized to the range 0.0
+ * to 1.0 , inclusive. And 1.0 is the maximum panel luminance.
+ * And If N is the size of each dimension, the data is arranged in RGB order:
+ * R(0, 0, 0), R(0, 0, 1), ..., R(0, 0, N - 1),
+ * R(0, 1, 0), ..., R(0, 1, N - 1), ..., R(0, N - 1, N - 1),
+ * R(1, 0, 0), ..., R(1, 0, N - 1), ..., R(1, N - 1, N - 1), ..., R(N - 1, N - 1, N - 1),
+ * G(0, 0, 0), ..., G(N - 1, N - 1, N - 1),
+ * B(0, 0, 0), ..., B(N - 1, N - 1, N - 1).
+ *
+ * When a GPU shader samples 3D Lut data, it's accessed in a flat, one-dimensional arrangement.
+ * Assuming that we have a 3D array ORIGINAL[N][N][N],
+ * then ORIGINAL[x][y][z] is mapped to FLAT[z + N * (y + N * x)].
+ *
  * @param buffer The lut raw buffer. The function creates a copy of it and does not need to
  * outlive the life of the ADisplayLutsEntry.
  * @param length The length of lut raw buffer
@@ -79,7 +95,7 @@ ADisplayLutsEntry* _Nonnull ADisplayLutsEntry_createEntry(float* _Nonnull buffer
     __INTRODUCED_IN(36);
 
 /**
- * Destroy the \a ADisplayLutsEntry instance.
+ * Destroys the \a ADisplayLutsEntry instance.
  *
  * @param entry The entry to be destroyed
  */
@@ -132,7 +148,7 @@ const float* _Nonnull ADisplayLutsEntry_getBuffer(const ADisplayLutsEntry* _Nonn
 /**
  * Creates a \a ADisplayLuts instance.
  *
- * You are responsible for mamanging the memory of the returned object.
+ * You are responsible for managing the memory of the returned object.
  * Always call \a ADisplayLuts_destroy to release it after use. E.g., after calling
  * the function \a ASurfaceTransaction_setLuts.
  *
diff --git a/include/android/sensor.h b/include/android/sensor.h
index e3c1ccfc6c..1e439c22a3 100644
--- a/include/android/sensor.h
+++ b/include/android/sensor.h
@@ -321,6 +321,13 @@ enum {
      * relative to true north in degrees.
      */
     ASENSOR_TYPE_HEADING = 42,
+    /**
+     * {@link ASENSOR_TYPE_MOISTURE_INTRUSION}
+     * reporting-mode: on-change
+     *
+     * A moisture sensor that detects water intrusion within the chassis of a device
+     */
+    ASENSOR_TYPE_MOISTURE_INTRUSION = 43,
 };
 
 /**
@@ -349,7 +356,7 @@ enum {
     AREPORTING_MODE_CONTINUOUS = 0,
     /** reporting on change */
     AREPORTING_MODE_ON_CHANGE = 1,
-    /** on shot reporting */
+    /** one shot reporting */
     AREPORTING_MODE_ONE_SHOT = 2,
     /** special trigger reporting */
     AREPORTING_MODE_SPECIAL_TRIGGER = 3
diff --git a/include/ftl/details/future.h b/include/ftl/details/future.h
index 8d82e0ffd2..8e096e8063 100644
--- a/include/ftl/details/future.h
+++ b/include/ftl/details/future.h
@@ -48,12 +48,8 @@ using future_result_t = typename future_result<T>::type;
 
 struct ValueTag {};
 
-template <typename, typename T, template <typename> class>
-class BaseFuture;
-
-template <typename Self, typename T>
-class BaseFuture<Self, T, std::future> {
-  using Impl = std::future<T>;
+template <typename Self, typename T, template <typename> class FutureImpl = std::future>
+class BaseFuture {
 
  public:
   Future<T, std::shared_future> share() {
@@ -61,7 +57,7 @@ class BaseFuture<Self, T, std::future> {
       return {ValueTag{}, std::move(*value)};
     }
 
-    return std::get<Impl>(self()).share();
+    return std::get<FutureImpl<T>>(self()).share();
   }
 
  protected:
@@ -70,7 +66,7 @@ class BaseFuture<Self, T, std::future> {
       return std::move(*value);
     }
 
-    return std::get<Impl>(self()).get();
+    return std::get<FutureImpl<T>>(self()).get();
   }
 
   template <class Rep, class Period>
@@ -79,7 +75,7 @@ class BaseFuture<Self, T, std::future> {
       return std::future_status::ready;
     }
 
-    return std::get<Impl>(self()).wait_for(timeout_duration);
+    return std::get<FutureImpl<T>>(self()).wait_for(timeout_duration);
   }
 
  private:
diff --git a/include/ftl/static_vector.h b/include/ftl/static_vector.h
index eb83b85bfe..658e8cf5bd 100644
--- a/include/ftl/static_vector.h
+++ b/include/ftl/static_vector.h
@@ -28,6 +28,11 @@
 
 namespace android::ftl {
 
+template <typename T>
+constexpr T* unconst(const T* __from) {
+  return const_cast<T*>(__from);
+}
+
 constexpr struct IteratorRangeTag {
 } kIteratorRange;
 
@@ -162,7 +167,7 @@ class StaticVector final : details::ArrayTraits<T>,
     static_assert(N >= M, "Insufficient capacity");
 
     // Same logic as swap<true>, though M need not be equal to N.
-    std::uninitialized_move(other.begin(), other.end(), begin());
+    std::uninitialized_move(other.begin(), other.end(), unconst(begin()));
     std::destroy(other.begin(), other.end());
     std::swap(size_, other.size_);
   }
@@ -412,7 +417,7 @@ void StaticVector<T, N>::swap(StaticVector& other) {
 
   // Move elements [min, max) and destroy their source for destructor side effects.
   const auto [first, last] = std::make_pair(from->begin() + min, from->begin() + max);
-  std::uninitialized_move(first, last, to->begin() + min);
+  std::uninitialized_move(first, last, unconst(to->begin() + min));
   std::destroy(first, last);
 
   std::swap(size_, other.size_);
diff --git a/include/input/DisplayTopologyGraph.h b/include/input/DisplayTopologyGraph.h
index 9fc080d6f8..f0c35e51bd 100644
--- a/include/input/DisplayTopologyGraph.h
+++ b/include/input/DisplayTopologyGraph.h
@@ -16,7 +16,9 @@
 
 #pragma once
 
+#include <android-base/result.h>
 #include <ftl/enum.h>
+#include <ui/FloatRect.h>
 #include <ui/LogicalDisplayId.h>
 
 #include <cinttypes>
@@ -54,12 +56,27 @@ struct DisplayTopologyAdjacentDisplay {
  * Directed Graph representation of Display Topology.
  */
 struct DisplayTopologyGraph {
+    struct Properties {
+        std::vector<DisplayTopologyAdjacentDisplay> adjacentDisplays;
+        int32_t density;
+        FloatRect boundsInGlobalDp;
+    };
+
     ui::LogicalDisplayId primaryDisplayId = ui::LogicalDisplayId::INVALID;
-    std::unordered_map<ui::LogicalDisplayId, std::vector<DisplayTopologyAdjacentDisplay>> graph;
-    std::unordered_map<ui::LogicalDisplayId, int> displaysDensity;
+    std::unordered_map<ui::LogicalDisplayId, Properties> graph;
 
-    bool isValid() const;
+    DisplayTopologyGraph() = default;
     std::string dump() const;
+
+    // Builds the topology graph from components.
+    // Returns error if a valid graph cannot be built from the supplied components.
+    static base::Result<const DisplayTopologyGraph> create(
+            ui::LogicalDisplayId primaryDisplay,
+            std::unordered_map<ui::LogicalDisplayId, Properties>&& topologyGraph);
+
+private:
+    DisplayTopologyGraph(ui::LogicalDisplayId primaryDisplay,
+                         std::unordered_map<ui::LogicalDisplayId, Properties>&& topologyGraph);
 };
 
 } // namespace android
diff --git a/include/input/DisplayViewport.h b/include/input/DisplayViewport.h
index 56294dd91a..18fe6fd76b 100644
--- a/include/input/DisplayViewport.h
+++ b/include/input/DisplayViewport.h
@@ -17,6 +17,7 @@
 #pragma once
 
 #include <android-base/stringprintf.h>
+#include <android/configuration.h>
 #include <ftl/enum.h>
 #include <ftl/string.h>
 #include <input/Input.h>
@@ -64,6 +65,7 @@ struct DisplayViewport {
     // Not all viewports will have this specified.
     std::optional<uint8_t> physicalPort;
     ViewportType type;
+    int32_t densityDpi;
 
     DisplayViewport()
           : displayId(ui::LogicalDisplayId::INVALID),
@@ -81,7 +83,8 @@ struct DisplayViewport {
             isActive(false),
             uniqueId(),
             physicalPort(std::nullopt),
-            type(ViewportType::INTERNAL) {}
+            type(ViewportType::INTERNAL),
+            densityDpi(ACONFIGURATION_DENSITY_NONE) {}
 
     bool operator==(const DisplayViewport& other) const {
         return displayId == other.displayId && orientation == other.orientation &&
@@ -121,6 +124,7 @@ struct DisplayViewport {
 
     std::string toString() const {
         return StringPrintf("Viewport %s: displayId=%s, uniqueId=%s, port=%s, orientation=%d, "
+                            "densityDpi=%d "
                             "logicalFrame=[%d, %d, %d, %d], "
                             "physicalFrame=[%d, %d, %d, %d], "
                             "deviceSize=[%d, %d], "
@@ -128,9 +132,9 @@ struct DisplayViewport {
                             ftl::enum_string(type).c_str(), displayId.toString().c_str(),
                             uniqueId.c_str(),
                             physicalPort ? ftl::to_string(*physicalPort).c_str() : "<none>",
-                            static_cast<int>(orientation), logicalLeft, logicalTop, logicalRight,
-                            logicalBottom, physicalLeft, physicalTop, physicalRight, physicalBottom,
-                            deviceWidth, deviceHeight, isActive);
+                            static_cast<int>(orientation), densityDpi, logicalLeft, logicalTop,
+                            logicalRight, logicalBottom, physicalLeft, physicalTop, physicalRight,
+                            physicalBottom, deviceWidth, deviceHeight, isActive);
     }
 };
 
diff --git a/include/input/Input.h b/include/input/Input.h
index 002b3a7d15..03197c5052 100644
--- a/include/input/Input.h
+++ b/include/input/Input.h
@@ -28,6 +28,7 @@
 #include <android/os/MotionEventFlag.h>
 #endif
 #include <android/os/PointerIconType.h>
+#include <ftl/flags.h>
 #include <math.h>
 #include <stdint.h>
 #include <ui/LogicalDisplayId.h>
@@ -57,6 +58,7 @@ enum {
     AKEY_EVENT_FLAG_TAINTED = android::os::IInputConstants::INPUT_EVENT_FLAG_TAINTED,
 };
 
+// TODO(b/245989146): Remove these definitions and use MotionFlag enum directly.
 enum {
     // AMOTION_EVENT_FLAG_WINDOW_IS_OBSCURED is defined in include/android/input.h
     /**
@@ -128,20 +130,6 @@ enum {
             AMOTION_EVENT_PRIVATE_FLAG_SUPPORTS_DIRECTIONAL_ORIENTATION,
 };
 
-/**
- * Allowed VerifiedKeyEvent flags. All other flags from KeyEvent do not get verified.
- * These values must be kept in sync with VerifiedKeyEvent.java
- */
-constexpr int32_t VERIFIED_KEY_EVENT_FLAGS =
-        AKEY_EVENT_FLAG_CANCELED | AKEY_EVENT_FLAG_IS_ACCESSIBILITY_EVENT;
-
-/**
- * Allowed VerifiedMotionEventFlags. All other flags from MotionEvent do not get verified.
- * These values must be kept in sync with VerifiedMotionEvent.java
- */
-constexpr int32_t VERIFIED_MOTION_EVENT_FLAGS = AMOTION_EVENT_FLAG_WINDOW_IS_OBSCURED |
-        AMOTION_EVENT_FLAG_WINDOW_IS_PARTIALLY_OBSCURED | AMOTION_EVENT_FLAG_IS_ACCESSIBILITY_EVENT;
-
 /**
  * This flag indicates that the point up event has been canceled.
  * Typically this is used for palm event when the user has accidental touches.
@@ -232,6 +220,39 @@ struct AInputDevice {
 
 namespace android {
 
+enum class MotionFlag : uint32_t {
+    // clang-format off
+    CANCELED = android::os::IInputConstants::INPUT_EVENT_FLAG_CANCELED,
+    WINDOW_IS_OBSCURED = static_cast<uint32_t>(android::os::MotionEventFlag::WINDOW_IS_OBSCURED),
+    WINDOW_IS_PARTIALLY_OBSCURED = static_cast<uint32_t>(android::os::MotionEventFlag::WINDOW_IS_PARTIALLY_OBSCURED),
+    HOVER_EXIT_PENDING = static_cast<uint32_t>(android::os::MotionEventFlag::HOVER_EXIT_PENDING),
+    IS_GENERATED_GESTURE = static_cast<uint32_t>(android::os::MotionEventFlag::IS_GENERATED_GESTURE),
+    NO_FOCUS_CHANGE = static_cast<uint32_t>(android::os::MotionEventFlag::NO_FOCUS_CHANGE),
+    IS_ACCESSIBILITY_EVENT = static_cast<uint32_t>(android::os::MotionEventFlag::IS_ACCESSIBILITY_EVENT),
+    INJECTED_FROM_ACCESSIBILITY_TOOL = static_cast<uint32_t>(android::os::MotionEventFlag::INJECTED_FROM_ACCESSIBILITY_TOOL),
+    TARGET_ACCESSIBILITY_FOCUS = static_cast<uint32_t>(android::os::MotionEventFlag::TARGET_ACCESSIBILITY_FOCUS),
+    TAINTED = static_cast<uint32_t>(android::os::MotionEventFlag::TAINTED),
+    SUPPORTS_ORIENTATION = static_cast<uint32_t>(android::os::MotionEventFlag::PRIVATE_FLAG_SUPPORTS_ORIENTATION),
+    SUPPORTS_DIRECTIONAL_ORIENTATION = static_cast<uint32_t>(android::os::MotionEventFlag::PRIVATE_FLAG_SUPPORTS_DIRECTIONAL_ORIENTATION),
+    // clang-format on
+};
+
+/**
+ * Allowed VerifiedKeyEvent flags. All other flags from KeyEvent do not get verified.
+ * These values must be kept in sync with VerifiedKeyEvent.java
+ */
+constexpr int32_t VERIFIED_KEY_EVENT_FLAGS =
+        AKEY_EVENT_FLAG_CANCELED | AKEY_EVENT_FLAG_IS_ACCESSIBILITY_EVENT;
+
+/**
+ * Allowed VerifiedMotionEventFlags. All other flags from MotionEvent do not get verified.
+ * These values must be kept in sync with VerifiedMotionEvent.java
+ */
+constexpr ftl::Flags<MotionFlag>
+        VERIFIED_MOTION_EVENT_FLAGS{MotionFlag::WINDOW_IS_OBSCURED,
+                                    MotionFlag::WINDOW_IS_PARTIALLY_OBSCURED,
+                                    MotionFlag::IS_ACCESSIBILITY_EVENT};
+
 class Parcel;
 
 /*
@@ -702,9 +723,9 @@ public:
 
     inline void setAction(int32_t action) { mAction = action; }
 
-    inline int32_t getFlags() const { return mFlags; }
+    inline ftl::Flags<MotionFlag> getFlags() const { return mFlags; }
 
-    inline void setFlags(int32_t flags) { mFlags = flags; }
+    inline void setFlags(ftl::Flags<MotionFlag> flags) { mFlags = flags; }
 
     inline int32_t getEdgeFlags() const { return mEdgeFlags; }
 
@@ -919,12 +940,13 @@ public:
 
     void initialize(int32_t id, DeviceId deviceId, uint32_t source, ui::LogicalDisplayId displayId,
                     std::array<uint8_t, 32> hmac, int32_t action, int32_t actionButton,
-                    int32_t flags, int32_t edgeFlags, int32_t metaState, int32_t buttonState,
-                    MotionClassification classification, const ui::Transform& transform,
-                    float xPrecision, float yPrecision, float rawXCursorPosition,
-                    float rawYCursorPosition, const ui::Transform& rawTransform, nsecs_t downTime,
-                    nsecs_t eventTime, size_t pointerCount,
-                    const PointerProperties* pointerProperties, const PointerCoords* pointerCoords);
+                    ftl::Flags<MotionFlag> flags, int32_t edgeFlags, int32_t metaState,
+                    int32_t buttonState, MotionClassification classification,
+                    const ui::Transform& transform, float xPrecision, float yPrecision,
+                    float rawXCursorPosition, float rawYCursorPosition,
+                    const ui::Transform& rawTransform, nsecs_t downTime, nsecs_t eventTime,
+                    size_t pointerCount, const PointerProperties* pointerProperties,
+                    const PointerCoords* pointerCoords);
 
     void copyFrom(const MotionEvent* other, bool keepHistory);
 
@@ -986,19 +1008,22 @@ public:
 
     static std::tuple<int32_t /*action*/, std::vector<PointerProperties>,
                       std::vector<PointerCoords>>
-    split(int32_t action, int32_t flags, int32_t historySize, const std::vector<PointerProperties>&,
-          const std::vector<PointerCoords>&, std::bitset<MAX_POINTER_ID + 1> splitPointerIds);
+    split(int32_t action, ftl::Flags<MotionFlag> flags, int32_t historySize,
+          const std::vector<PointerProperties>&, const std::vector<PointerCoords>&,
+          std::bitset<MAX_POINTER_ID + 1> splitPointerIds);
 
     // MotionEvent will transform various axes in different ways, based on the source. For
     // example, the x and y axes will not have any offsets/translations applied if it comes from a
     // relative mouse device (since SOURCE_RELATIVE_MOUSE is a non-pointer source). These methods
     // are used to apply these transformations for different axes.
     static vec2 calculateTransformedXY(uint32_t source, const ui::Transform&, const vec2& xy);
-    static float calculateTransformedAxisValue(int32_t axis, uint32_t source, int32_t flags,
-                                               const ui::Transform&, const PointerCoords&);
+    static float calculateTransformedAxisValue(int32_t axis, uint32_t source,
+                                               ftl::Flags<MotionFlag> flags, const ui::Transform&,
+                                               const PointerCoords&);
     static void calculateTransformedCoordsInPlace(PointerCoords& coords, uint32_t source,
-                                                  int32_t flags, const ui::Transform&);
-    static PointerCoords calculateTransformedCoords(uint32_t source, int32_t flags,
+                                                  ftl::Flags<MotionFlag> flags,
+                                                  const ui::Transform&);
+    static PointerCoords calculateTransformedCoords(uint32_t source, ftl::Flags<MotionFlag> flags,
                                                     const ui::Transform&, const PointerCoords&);
     // The rounding precision for transformed motion events.
     static constexpr float ROUNDING_PRECISION = 0.001f;
@@ -1009,7 +1034,7 @@ public:
 protected:
     int32_t mAction;
     int32_t mActionButton;
-    int32_t mFlags;
+    ftl::Flags<MotionFlag> mFlags;
     int32_t mEdgeFlags;
     int32_t mMetaState;
     int32_t mButtonState;
@@ -1158,7 +1183,7 @@ struct __attribute__((__packed__)) VerifiedMotionEvent : public VerifiedInputEve
     float rawX;
     float rawY;
     int32_t actionMasked;
-    int32_t flags;
+    ftl::Flags<MotionFlag> flags;
     nsecs_t downTimeNanos;
     int32_t metaState;
     int32_t buttonState;
diff --git a/include/input/InputConsumer.h b/include/input/InputConsumer.h
index 611478cbeb..4a12d8293b 100644
--- a/include/input/InputConsumer.h
+++ b/include/input/InputConsumer.h
@@ -135,6 +135,7 @@ private:
         BitSet32 idBits;
         int32_t idToIndex[MAX_POINTER_ID + 1];
         PointerCoords pointers[MAX_POINTERS];
+        int32_t displayId;
 
         void initializeFrom(const InputMessage& msg) {
             eventTime = msg.body.motion.eventTime;
@@ -145,6 +146,7 @@ private:
                 idToIndex[id] = i;
                 pointers[i].copyFrom(msg.body.motion.pointers[i].coords);
             }
+            displayId = msg.body.motion.displayId;
         }
 
         void initializeFrom(const History& other) {
@@ -157,6 +159,7 @@ private:
                 pointers[index].copyFrom(other.pointers[index]);
             }
             idBits = other.idBits; // final copy
+            displayId = other.displayId;
         }
 
         const PointerCoords& getPointerById(uint32_t id) const { return pointers[idToIndex[id]]; }
diff --git a/include/input/InputConsumerNoResampling.h b/include/input/InputConsumerNoResampling.h
index 70d00d16f4..724ebe754c 100644
--- a/include/input/InputConsumerNoResampling.h
+++ b/include/input/InputConsumerNoResampling.h
@@ -260,6 +260,11 @@ private:
      * the batched MotionEvent that it received.
      */
     std::map<uint32_t, std::vector<uint32_t>> mBatchedSequenceNumbers;
+
+    /**
+     * Checks if a given input event is okay to be added to an existing batch or not.
+     */
+    bool isBatchableEvent(const InputMessage& message) const;
 };
 
 } // namespace android
diff --git a/include/input/InputDevice.h b/include/input/InputDevice.h
index ea1e4aee01..af2d903cc9 100644
--- a/include/input/InputDevice.h
+++ b/include/input/InputDevice.h
@@ -329,9 +329,6 @@ public:
     inline void setHasBattery(bool hasBattery) { mHasBattery = hasBattery; }
     inline bool hasBattery() const { return mHasBattery; }
 
-    inline void setButtonUnderPad(bool hasButton) { mHasButtonUnderPad = hasButton; }
-    inline bool hasButtonUnderPad() const { return mHasButtonUnderPad; }
-
     inline void setHasSensor(bool hasSensor) { mHasSensor = hasSensor; }
     inline bool hasSensor() const { return mHasSensor; }
 
@@ -371,7 +368,6 @@ private:
 
     bool mHasVibrator;
     bool mHasBattery;
-    bool mHasButtonUnderPad;
     bool mHasSensor;
 
     std::vector<MotionRange> mMotionRanges;
diff --git a/include/input/InputEventBuilders.h b/include/input/InputEventBuilders.h
index 1696a62693..d17d2274f9 100644
--- a/include/input/InputEventBuilders.h
+++ b/include/input/InputEventBuilders.h
@@ -18,6 +18,7 @@
 
 #include <android/input.h>
 #include <attestation/HmacKeyManager.h>
+#include <ftl/flags.h>
 #include <input/Input.h>
 #include <input/InputTransport.h>
 #include <ui/LogicalDisplayId.h>
@@ -251,7 +252,7 @@ public:
     MotionEventBuilder(int32_t action, int32_t source) {
         mAction = action;
         if (mAction == AMOTION_EVENT_ACTION_CANCEL) {
-            mFlags |= AMOTION_EVENT_FLAG_CANCELED;
+            mFlags |= MotionFlag::CANCELED;
         }
         mSource = source;
         mEventTime = systemTime(SYSTEM_TIME_MONOTONIC);
@@ -303,7 +304,7 @@ public:
         return *this;
     }
 
-    MotionEventBuilder& addFlag(uint32_t flags) {
+    MotionEventBuilder& addFlag(ftl::Flags<MotionFlag> flags) {
         mFlags |= flags;
         return *this;
     }
@@ -354,7 +355,7 @@ private:
     ui::LogicalDisplayId mDisplayId{ui::LogicalDisplayId::DEFAULT};
     int32_t mActionButton{0};
     int32_t mButtonState{0};
-    int32_t mFlags{0};
+    ftl::Flags<MotionFlag> mFlags{};
     float mRawXCursorPosition{AMOTION_EVENT_INVALID_CURSOR_POSITION};
     float mRawYCursorPosition{AMOTION_EVENT_INVALID_CURSOR_POSITION};
     ui::Transform mTransform;
diff --git a/include/input/InputFlags.h b/include/input/InputFlags.h
index 16e754e210..2ac9e85a8f 100644
--- a/include/input/InputFlags.h
+++ b/include/input/InputFlags.h
@@ -42,8 +42,26 @@ public:
 
     /**
      * Check if both connectedDisplaysCursor and associatedDisplayCursorBugfix is enabled.
+     * This setting can be overridden with the dev option similar to the
+     * connectedDisplaysCursorEnabled flag.
      */
     static bool connectedDisplaysCursorAndAssociatedDisplayCursorBugfixEnabled();
+
+    /**
+     * Check if display density based cursor scaling is enabled.
+     * This setting can be overridden with the dev option similar to the
+     * connectedDisplaysCursorEnabled flag.
+     */
+    static bool scaleCursorSpeedWithDisplayDensity();
+
+    /**
+     * This is a temporary fix that removes the SKIP_SCREENSHOT flag for the Mouse cursor. This is
+     * only intended to be temporarily used as workaround only when connected displays dev option
+     * is enabled.
+     *
+     * This will make mouse cursor visible on recordings and screenshots of secure windows.
+     */
+    static bool doNotUseSkipScreenshotFlagForMouseCursor();
 };
 
 } // namespace android
diff --git a/include/input/InputVerifier.h b/include/input/InputVerifier.h
index 7d3fb469c6..1c2ff7dc7a 100644
--- a/include/input/InputVerifier.h
+++ b/include/input/InputVerifier.h
@@ -51,6 +51,7 @@ public:
                                                 const PointerProperties* pointerProperties,
                                                 const PointerCoords* pointerCoords, int32_t flags,
                                                 int32_t buttonState);
+    std::string dump() const;
 
     void resetDevice(int32_t deviceId);
 
diff --git a/include/input/KeyboardClassifier.h b/include/input/KeyboardClassifier.h
index 457d474ee7..507cdd73f0 100644
--- a/include/input/KeyboardClassifier.h
+++ b/include/input/KeyboardClassifier.h
@@ -47,7 +47,6 @@ public:
 private:
     std::optional<rust::Box<android::input::keyboardClassifier::KeyboardClassifier>>
             mRustClassifier;
-    std::unordered_map<DeviceId, KeyboardType> mKeyboardTypeMap;
 };
 
 } // namespace android
diff --git a/include/input/PropertyMap.h b/include/input/PropertyMap.h
index 2e44142927..fdeca15a67 100644
--- a/include/input/PropertyMap.h
+++ b/include/input/PropertyMap.h
@@ -75,7 +75,7 @@ public:
     std::optional<double> getDouble(const std::string& key) const;
 
     /* Adds all values from the specified property map. */
-    void addAll(const PropertyMap* map);
+    void addAll(const PropertyMap& map);
 
     /* Loads a property map from a file. */
     static android::base::Result<std::unique_ptr<PropertyMap>> load(const char* filename);
diff --git a/include/input/RingBuffer.h b/include/input/RingBuffer.h
index d2747d6fad..bf383f19de 100644
--- a/include/input/RingBuffer.h
+++ b/include/input/RingBuffer.h
@@ -24,6 +24,8 @@
 #include <type_traits>
 #include <utility>
 
+#include <stdlib.h>
+
 #include <android-base/stringprintf.h>
 
 namespace android {
diff --git a/include/private/performance_hint_private.h b/include/private/performance_hint_private.h
index a468313341..c11b012a66 100644
--- a/include/private/performance_hint_private.h
+++ b/include/private/performance_hint_private.h
@@ -164,6 +164,11 @@ void APerformanceHint_setUseNewLoadHintBehaviorForTesting(bool newBehavior);
  */
 void APerformanceHint_setUseGraphicsPipelineForTesting(bool enabled);
 
+/*
+ * Set the reporting duration max batch size cap. Passing -1 removes the cap.
+ */
+void APerformanceHint_setReportBatchSizeCapForTesting(int cap);
+
 __END_DECLS
 
 #endif // ANDROID_PRIVATE_NATIVE_PERFORMANCE_HINT_PRIVATE_H
diff --git a/libs/adbd_auth/Android.bp b/libs/adbd_auth/Android.bp
index 16cded8141..1755141155 100644
--- a/libs/adbd_auth/Android.bp
+++ b/libs/adbd_auth/Android.bp
@@ -19,6 +19,7 @@ package {
     // to get the below license kinds:
     //   SPDX-license-identifier-Apache-2.0
     default_applicable_licenses: ["frameworks_native_license"],
+    default_team: "trendy_team_android_developer_tools",
 }
 
 cc_library {
@@ -45,7 +46,7 @@ cc_library {
     target: {
         darwin: {
             enabled: false,
-        }
+        },
     },
 
     static_libs: [
@@ -54,3 +55,20 @@ cc_library {
         "liblog",
     ],
 }
+
+cc_test {
+    name: "libadbd_auth_test",
+    srcs: [
+        "adbd_auth_test.cpp",
+    ],
+    static_libs: [
+        "libadbd_auth",
+        "libbase",
+        "libcutils",
+        "liblog",
+    ],
+    test_suites: [
+        "cts",
+        "general-tests",
+    ],
+}
diff --git a/libs/adbd_auth/OWNERS b/libs/adbd_auth/OWNERS
new file mode 100644
index 0000000000..b97f7956d1
--- /dev/null
+++ b/libs/adbd_auth/OWNERS
@@ -0,0 +1 @@
+include platform/packages/modules/adb:/OWNERS
diff --git a/libs/adbd_auth/adbd_auth.cpp b/libs/adbd_auth/adbd_auth.cpp
index d31cb3dff0..a294e6223d 100644
--- a/libs/adbd_auth/adbd_auth.cpp
+++ b/libs/adbd_auth/adbd_auth.cpp
@@ -18,573 +18,563 @@
 
 #include "include/adbd_auth.h"
 
-#include <inttypes.h>
-#include <sys/epoll.h>
-#include <sys/eventfd.h>
-#include <sys/uio.h>
-
-#include <atomic>
-#include <chrono>
-#include <deque>
-#include <optional>
-#include <string>
-#include <string_view>
-#include <tuple>
-#include <unordered_map>
-#include <utility>
-#include <variant>
-#include <vector>
-
-#include <android-base/file.h>
-#include <android-base/logging.h>
-#include <android-base/macros.h>
-#include <android-base/strings.h>
-#include <android-base/thread_annotations.h>
-#include <android-base/unique_fd.h>
-#include <cutils/sockets.h>
+#include "adbd_auth_internal.h"
 
 using android::base::unique_fd;
 
-static constexpr uint32_t kAuthVersion = 1;
-
-struct AdbdAuthPacketAuthenticated {
-    std::string public_key;
-};
-
-struct AdbdAuthPacketDisconnected {
-    std::string public_key;
-};
-
-struct AdbdAuthPacketRequestAuthorization {
-    std::string public_key;
-};
-
-struct AdbdPacketTlsDeviceConnected {
-    uint8_t transport_type;
-    std::string public_key;
-};
-
-struct AdbdPacketTlsDeviceDisconnected {
-    uint8_t transport_type;
-    std::string public_key;
-};
-
-using AdbdAuthPacket = std::variant<AdbdAuthPacketAuthenticated,
-                                    AdbdAuthPacketDisconnected,
-                                    AdbdAuthPacketRequestAuthorization,
-                                    AdbdPacketTlsDeviceConnected,
-                                    AdbdPacketTlsDeviceDisconnected>;
-
-struct AdbdAuthContext {
-    static constexpr uint64_t kEpollConstSocket = 0;
-    static constexpr uint64_t kEpollConstEventFd = 1;
-    static constexpr uint64_t kEpollConstFramework = 2;
-
-public:
-    explicit AdbdAuthContext(AdbdAuthCallbacksV1* callbacks) : next_id_(0), callbacks_(*callbacks) {
-        InitFrameworkHandlers();
-        epoll_fd_.reset(epoll_create1(EPOLL_CLOEXEC));
-        if (epoll_fd_ == -1) {
-            PLOG(FATAL) << "adbd_auth: failed to create epoll fd";
-        }
-
-        event_fd_.reset(eventfd(0, EFD_CLOEXEC | EFD_NONBLOCK));
-        if (event_fd_ == -1) {
-            PLOG(FATAL) << "adbd_auth: failed to create eventfd";
-        }
-
-        sock_fd_.reset(android_get_control_socket("adbd"));
-        if (sock_fd_ == -1) {
-            PLOG(ERROR) << "adbd_auth: failed to get adbd authentication socket";
-        } else {
-            if (fcntl(sock_fd_.get(), F_SETFD, FD_CLOEXEC) != 0) {
-                PLOG(FATAL) << "adbd_auth: failed to make adbd authentication socket cloexec";
-            }
-
-            if (fcntl(sock_fd_.get(), F_SETFL, O_NONBLOCK) != 0) {
-                PLOG(FATAL) << "adbd_auth: failed to make adbd authentication socket nonblocking";
-            }
-
-            if (listen(sock_fd_.get(), 4) != 0) {
-                PLOG(FATAL) << "adbd_auth: failed to listen on adbd authentication socket";
-            }
-        }
+static constexpr uint32_t kAuthVersion = 2;
+
+static std::set<AdbdAuthFeature> supported_features = {
+    AdbdAuthFeature::WifiLifeCycle};
+
+AdbdAuthContext::AdbdAuthContext(AdbdAuthCallbacksV1* callbacks)
+    : next_id_(0), callbacks_(*callbacks) {
+  epoll_fd_.reset(epoll_create1(EPOLL_CLOEXEC));
+  if (epoll_fd_ == -1) {
+    PLOG(FATAL) << "adbd_auth: failed to create epoll fd";
+  }
+
+  event_fd_.reset(eventfd(0, EFD_CLOEXEC | EFD_NONBLOCK));
+  if (event_fd_ == -1) {
+    PLOG(FATAL) << "adbd_auth: failed to create eventfd";
+  }
+
+  sock_fd_.reset(android_get_control_socket("adbd"));
+  if (sock_fd_ == -1) {
+    PLOG(ERROR) << "adbd_auth: failed to get adbd authentication socket";
+  } else {
+    if (fcntl(sock_fd_.get(), F_SETFD, FD_CLOEXEC) != 0) {
+      PLOG(FATAL)
+          << "adbd_auth: failed to make adbd authentication socket cloexec";
     }
 
-    AdbdAuthContext(const AdbdAuthContext& copy) = delete;
-    AdbdAuthContext(AdbdAuthContext&& move) = delete;
-    AdbdAuthContext& operator=(const AdbdAuthContext& copy) = delete;
-    AdbdAuthContext& operator=(AdbdAuthContext&& move) = delete;
-
-    uint64_t NextId() { return next_id_++; }
-
-    void DispatchPendingPrompt() REQUIRES(mutex_) {
-        if (dispatched_prompt_) {
-            LOG(INFO) << "adbd_auth: prompt currently pending, skipping";
-            return;
-        }
-
-        if (pending_prompts_.empty()) {
-            LOG(INFO) << "adbd_auth: no prompts to send";
-            return;
-        }
-
-        LOG(INFO) << "adbd_auth: prompting user for adb authentication";
-        auto [id, public_key, arg] = std::move(pending_prompts_.front());
-        pending_prompts_.pop_front();
-
-        this->output_queue_.emplace_back(
-                AdbdAuthPacketRequestAuthorization{.public_key = public_key});
-
-        Interrupt();
-        dispatched_prompt_ = std::make_tuple(id, public_key, arg);
+    if (fcntl(sock_fd_.get(), F_SETFL, O_NONBLOCK) != 0) {
+      PLOG(FATAL)
+          << "adbd_auth: failed to make adbd authentication socket nonblocking";
     }
 
-    void UpdateFrameworkWritable() REQUIRES(mutex_) {
-        // This might result in redundant calls to EPOLL_CTL_MOD if, for example, we get notified
-        // at the same time as a framework connection, but that's unlikely and this doesn't need to
-        // be fast anyway.
-        if (framework_fd_ != -1) {
-            struct epoll_event event;
-            event.events = EPOLLIN;
-            if (!output_queue_.empty()) {
-                LOG(INFO) << "adbd_auth: marking framework writable";
-                event.events |= EPOLLOUT;
-            }
-            event.data.u64 = kEpollConstFramework;
-            CHECK_EQ(0, epoll_ctl(epoll_fd_.get(), EPOLL_CTL_MOD, framework_fd_.get(), &event));
-        }
+    if (listen(sock_fd_.get(), 4) != 0) {
+      PLOG(FATAL)
+          << "adbd_auth: failed to listen on adbd authentication socket";
     }
+  }
+}
 
-    void ReplaceFrameworkFd(unique_fd new_fd) REQUIRES(mutex_) {
-        LOG(INFO) << "adbd_auth: received new framework fd " << new_fd.get()
-                  << " (current = " << framework_fd_.get() << ")";
+void AdbdAuthContext::DispatchPendingPrompt() REQUIRES(mutex_) {
+  if (dispatched_prompt_) {
+    LOG(INFO) << "adbd_auth: prompt currently pending, skipping";
+    return;
+  }
 
-        // If we already had a framework fd, clean up after ourselves.
-        if (framework_fd_ != -1) {
-            output_queue_.clear();
-            dispatched_prompt_.reset();
-            CHECK_EQ(0, epoll_ctl(epoll_fd_.get(), EPOLL_CTL_DEL, framework_fd_.get(), nullptr));
-            framework_fd_.reset();
-        }
+  if (pending_prompts_.empty()) {
+    LOG(INFO) << "adbd_auth: no prompts to send";
+    return;
+  }
 
-        if (new_fd != -1) {
-            struct epoll_event event;
-            event.events = EPOLLIN;
-            if (!output_queue_.empty()) {
-                LOG(INFO) << "adbd_auth: marking framework writable";
-                event.events |= EPOLLOUT;
-            }
-            event.data.u64 = kEpollConstFramework;
-            CHECK_EQ(0, epoll_ctl(epoll_fd_.get(), EPOLL_CTL_ADD, new_fd.get(), &event));
-            framework_fd_ = std::move(new_fd);
-        }
-    }
+  LOG(INFO) << "adbd_auth: prompting user for adb authentication";
+  auto [id, public_key, arg] = std::move(pending_prompts_.front());
+  pending_prompts_.pop_front();
 
-    void HandlePacket(std::string_view packet) EXCLUDES(mutex_) {
-        LOG(INFO) << "adbd_auth: received packet: " << packet;
+  this->output_queue_.emplace_back(
+      AdbdAuthPacketRequestAuthorization{.public_key = public_key});
 
-        if (packet.size() < 2) {
-            LOG(ERROR) << "adbd_auth: received packet of invalid length";
-            std::lock_guard<std::mutex> lock(mutex_);
-            ReplaceFrameworkFd(unique_fd());
-        }
+  Interrupt();
+  dispatched_prompt_ = std::make_tuple(id, public_key, arg);
+}
 
-        bool handled_packet = false;
-        for (size_t i = 0; i < framework_handlers_.size(); ++i) {
-            if (android::base::ConsumePrefix(&packet, framework_handlers_[i].code)) {
-                framework_handlers_[i].cb(packet);
-                handled_packet = true;
-                break;
-            }
-        }
-        if (!handled_packet) {
-            LOG(ERROR) << "adbd_auth: unhandled packet: " << packet;
-            std::lock_guard<std::mutex> lock(mutex_);
-            ReplaceFrameworkFd(unique_fd());
-        }
+void AdbdAuthContext::UpdateFrameworkWritable() REQUIRES(mutex_) {
+  // This might result in redundant calls to EPOLL_CTL_MOD if, for example, we
+  // get notified at the same time as a framework connection, but that's
+  // unlikely and this doesn't need to be fast anyway.
+  if (framework_fd_ != -1) {
+    struct epoll_event event;
+    event.events = EPOLLIN;
+    if (!output_queue_.empty()) {
+      LOG(INFO) << "adbd_auth: marking framework writable";
+      event.events |= EPOLLOUT;
     }
+    event.data.u64 = kEpollConstFramework;
+    CHECK_EQ(0, epoll_ctl(epoll_fd_.get(), EPOLL_CTL_MOD, framework_fd_.get(),
+                          &event));
+  }
+}
 
-    void AllowUsbDevice(std::string_view buf) EXCLUDES(mutex_) {
-        std::lock_guard<std::mutex> lock(mutex_);
-        CHECK(buf.empty());
-
-        if (dispatched_prompt_.has_value()) {
-            // It's possible for the framework to send us a response without our having sent a
-            // request to it: e.g. if adbd restarts while we have a pending request.
-            auto& [id, key, arg] = *dispatched_prompt_;
-            keys_.emplace(id, std::move(key));
-
-            callbacks_.key_authorized(arg, id);
-            dispatched_prompt_ = std::nullopt;
-        } else {
-            LOG(WARNING) << "adbd_auth: received authorization for unknown prompt, ignoring";
-        }
-
-        // We need to dispatch pending prompts here upon success as well,
-        // since we might have multiple queued prompts.
-        DispatchPendingPrompt();
+void AdbdAuthContext::ReplaceFrameworkFd(unique_fd new_fd) REQUIRES(mutex_) {
+  LOG(INFO) << "adbd_auth: received new framework fd " << new_fd.get()
+            << " (current = " << framework_fd_.get() << ")";
+
+  // If we already had a framework fd, clean up after ourselves.
+  if (framework_fd_ != -1) {
+    output_queue_.clear();
+    dispatched_prompt_.reset();
+    CHECK_EQ(0, epoll_ctl(epoll_fd_.get(), EPOLL_CTL_DEL, framework_fd_.get(),
+                          nullptr));
+    framework_fd_.reset();
+  }
+
+  if (new_fd != -1) {
+    struct epoll_event event;
+    event.events = EPOLLIN;
+    if (!output_queue_.empty()) {
+      LOG(INFO) << "adbd_auth: marking framework writable";
+      event.events |= EPOLLOUT;
     }
+    event.data.u64 = kEpollConstFramework;
+    CHECK_EQ(0,
+             epoll_ctl(epoll_fd_.get(), EPOLL_CTL_ADD, new_fd.get(), &event));
+    framework_fd_ = std::move(new_fd);
+  }
+}
 
-    void DenyUsbDevice(std::string_view buf) EXCLUDES(mutex_) {
-        std::lock_guard<std::mutex> lock(mutex_);
-        CHECK(buf.empty());
-        // TODO: Do we want a callback if the key is denied?
-        dispatched_prompt_ = std::nullopt;
-        DispatchPendingPrompt();
+void AdbdAuthContext::HandlePacket(std::string_view packet) EXCLUDES(mutex_) {
+  LOG(INFO) << "adbd_auth: received packet: " << packet;
+
+  if (packet.size() < 2) {
+    LOG(ERROR) << "adbd_auth: received packet of invalid length";
+    std::lock_guard<std::mutex> lock(mutex_);
+    ReplaceFrameworkFd(unique_fd());
+  }
+
+  bool handled_packet = false;
+  for (size_t i = 0; i < framework_handlers_.size(); ++i) {
+    if (android::base::ConsumePrefix(&packet, framework_handlers_[i].code)) {
+      framework_handlers_[i].cb(packet);
+      handled_packet = true;
+      break;
     }
+  }
+  if (!handled_packet) {
+    LOG(ERROR) << "adbd_auth: unhandled packet: " << packet;
+    std::lock_guard<std::mutex> lock(mutex_);
+    ReplaceFrameworkFd(unique_fd());
+  }
+}
 
-    void KeyRemoved(std::string_view buf) EXCLUDES(mutex_) {
-        CHECK(!buf.empty());
-        callbacks_.key_removed(buf.data(), buf.size());
-    }
+void AdbdAuthContext::AllowUsbDevice(std::string_view buf) EXCLUDES(mutex_) {
+  std::lock_guard<std::mutex> lock(mutex_);
+  CHECK(buf.empty());
+
+  if (dispatched_prompt_.has_value()) {
+    // It's possible for the framework to send us a response without our having
+    // sent a request to it: e.g. if adbd restarts while we have a pending
+    // request.
+    auto& [id, key, arg] = *dispatched_prompt_;
+    keys_.emplace(id, std::move(key));
+
+    callbacks_.key_authorized(arg, id);
+    dispatched_prompt_ = std::nullopt;
+  } else {
+    LOG(WARNING)
+        << "adbd_auth: received authorization for unknown prompt, ignoring";
+  }
+
+  // We need to dispatch pending prompts here upon success as well,
+  // since we might have multiple queued prompts.
+  DispatchPendingPrompt();
+}
 
-    bool SendPacket() REQUIRES(mutex_) {
-        if (output_queue_.empty()) {
-            return false;
-        }
+void AdbdAuthContext::DenyUsbDevice(std::string_view buf) EXCLUDES(mutex_) {
+  std::lock_guard<std::mutex> lock(mutex_);
+  CHECK(buf.empty());
+  // TODO: Do we want a callback if the key is denied?
+  dispatched_prompt_ = std::nullopt;
+  DispatchPendingPrompt();
+}
 
-        CHECK_NE(-1, framework_fd_.get());
-
-        auto& packet = output_queue_.front();
-        struct iovec iovs[3];
-        int iovcnt = 2;
-        if (auto* p = std::get_if<AdbdAuthPacketAuthenticated>(&packet)) {
-            iovs[0].iov_base = const_cast<char*>("CK");
-            iovs[0].iov_len = 2;
-            iovs[1].iov_base = p->public_key.data();
-            iovs[1].iov_len = p->public_key.size();
-        } else if (auto* p = std::get_if<AdbdAuthPacketDisconnected>(&packet)) {
-            iovs[0].iov_base = const_cast<char*>("DC");
-            iovs[0].iov_len = 2;
-            iovs[1].iov_base = p->public_key.data();
-            iovs[1].iov_len = p->public_key.size();
-        } else if (auto* p = std::get_if<AdbdAuthPacketRequestAuthorization>(&packet)) {
-            iovs[0].iov_base = const_cast<char*>("PK");
-            iovs[0].iov_len = 2;
-            iovs[1].iov_base = p->public_key.data();
-            iovs[1].iov_len = p->public_key.size();
-        } else if (auto* p = std::get_if<AdbdPacketTlsDeviceConnected>(&packet)) {
-            iovcnt = 3;
-            iovs[0].iov_base = const_cast<char*>("WE");
-            iovs[0].iov_len = 2;
-            iovs[1].iov_base = &p->transport_type;
-            iovs[1].iov_len = 1;
-            iovs[2].iov_base = p->public_key.data();
-            iovs[2].iov_len = p->public_key.size();
-        } else if (auto* p = std::get_if<AdbdPacketTlsDeviceDisconnected>(&packet)) {
-            iovcnt = 3;
-            iovs[0].iov_base = const_cast<char*>("WF");
-            iovs[0].iov_len = 2;
-            iovs[1].iov_base = &p->transport_type;
-            iovs[1].iov_len = 1;
-            iovs[2].iov_base = p->public_key.data();
-            iovs[2].iov_len = p->public_key.size();
-        } else {
-            LOG(FATAL) << "adbd_auth: unhandled packet type?";
-        }
+void AdbdAuthContext::KeyRemoved(std::string_view buf) EXCLUDES(mutex_) {
+  CHECK(!buf.empty());
+  callbacks_.key_removed(buf.data(), buf.size());
+}
 
-        ssize_t rc = writev(framework_fd_.get(), iovs, iovcnt);
-        output_queue_.pop_front();
-        if (rc == -1 && errno != EAGAIN && errno != EWOULDBLOCK) {
-            PLOG(ERROR) << "adbd_auth: failed to write to framework fd";
-            ReplaceFrameworkFd(unique_fd());
-            return false;
-        }
+bool AdbdAuthContext::SendPacket() REQUIRES(mutex_) {
+  if (output_queue_.empty()) {
+    return false;
+  }
+
+  CHECK_NE(-1, framework_fd_.get());
+
+  auto& packet = output_queue_.front();
+  struct iovec iovs[3];
+  int iovcnt = 2;
+
+  if (auto* p = std::get_if<AdbdAuthPacketAuthenticated>(&packet)) {
+    iovs[0].iov_base = const_cast<char*>("CK");
+    iovs[0].iov_len = 2;
+    iovs[1].iov_base = p->public_key.data();
+    iovs[1].iov_len = p->public_key.size();
+  } else if (auto* p = std::get_if<AdbdAuthPacketDisconnected>(&packet)) {
+    iovs[0].iov_base = const_cast<char*>("DC");
+    iovs[0].iov_len = 2;
+    iovs[1].iov_base = p->public_key.data();
+    iovs[1].iov_len = p->public_key.size();
+  } else if (auto* p =
+                 std::get_if<AdbdAuthPacketRequestAuthorization>(&packet)) {
+    iovs[0].iov_base = const_cast<char*>("PK");
+    iovs[0].iov_len = 2;
+    iovs[1].iov_base = p->public_key.data();
+    iovs[1].iov_len = p->public_key.size();
+  } else if (auto* p = std::get_if<AdbdPacketTlsDeviceConnected>(&packet)) {
+    iovcnt = 3;
+    iovs[0].iov_base = const_cast<char*>("WE");
+    iovs[0].iov_len = 2;
+    iovs[1].iov_base = &p->transport_type;
+    iovs[1].iov_len = 1;
+    iovs[2].iov_base = p->public_key.data();
+    iovs[2].iov_len = p->public_key.size();
+  } else if (auto* p = std::get_if<AdbdPacketTlsDeviceDisconnected>(&packet)) {
+    iovcnt = 3;
+    iovs[0].iov_base = const_cast<char*>("WF");
+    iovs[0].iov_len = 2;
+    iovs[1].iov_base = &p->transport_type;
+    iovs[1].iov_len = 1;
+    iovs[2].iov_base = p->public_key.data();
+    iovs[2].iov_len = p->public_key.size();
+  } else if (auto* p = std::get_if<AdbdPacketTlsServerPort>(&packet)) {
+    iovcnt = 2;
+    iovs[0].iov_base = const_cast<char*>("TP");
+    iovs[0].iov_len = 2;
+    iovs[1].iov_base = &p->port;
+    iovs[1].iov_len = 2;
+  } else {
+    LOG(FATAL) << "adbd_auth: unhandled packet type?";
+  }
+
+  LOG(INFO) << "adbd_auth: sending packet: "
+            << std::string((const char*)iovs[0].iov_base, 2);
+
+  ssize_t rc = writev(framework_fd_.get(), iovs, iovcnt);
+  output_queue_.pop_front();
+  if (rc == -1 && errno != EAGAIN && errno != EWOULDBLOCK) {
+    PLOG(ERROR) << "adbd_auth: failed to write to framework fd";
+    ReplaceFrameworkFd(unique_fd());
+    return false;
+  }
+
+  return true;
+}
 
-        return true;
+void AdbdAuthContext::Run() {
+  if (sock_fd_ == -1) {
+    LOG(ERROR) << "adbd_auth: socket unavailable, disabling user prompts";
+  } else {
+    struct epoll_event event;
+    event.events = EPOLLIN;
+    event.data.u64 = kEpollConstSocket;
+    CHECK_EQ(0,
+             epoll_ctl(epoll_fd_.get(), EPOLL_CTL_ADD, sock_fd_.get(), &event));
+  }
+
+  {
+    struct epoll_event event;
+    event.events = EPOLLIN;
+    event.data.u64 = kEpollConstEventFd;
+    CHECK_EQ(
+        0, epoll_ctl(epoll_fd_.get(), EPOLL_CTL_ADD, event_fd_.get(), &event));
+  }
+
+  while (true) {
+    struct epoll_event events[3];
+    int rc = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd_.get(), events, 3, -1));
+    if (rc == -1) {
+      PLOG(FATAL) << "adbd_auth: epoll_wait failed";
+    } else if (rc == 0) {
+      LOG(FATAL) << "adbd_auth: epoll_wait returned 0";
     }
 
-    void Run() {
-        if (sock_fd_ == -1) {
-            LOG(ERROR) << "adbd_auth: socket unavailable, disabling user prompts";
-        } else {
-            struct epoll_event event;
-            event.events = EPOLLIN;
-            event.data.u64 = kEpollConstSocket;
-            CHECK_EQ(0, epoll_ctl(epoll_fd_.get(), EPOLL_CTL_ADD, sock_fd_.get(), &event));
+    bool restart = false;
+    for (int i = 0; i < rc; ++i) {
+      if (restart) {
+        break;
+      }
+
+      struct epoll_event& event = events[i];
+      switch (event.data.u64) {
+        case kEpollConstSocket: {
+          unique_fd new_framework_fd(accept4(sock_fd_.get(), nullptr, nullptr,
+                                             SOCK_CLOEXEC | SOCK_NONBLOCK));
+          if (new_framework_fd == -1) {
+            PLOG(FATAL) << "adbd_auth: failed to accept framework fd";
+          }
+
+          LOG(INFO) << "adbd_auth: received a new framework connection";
+          std::lock_guard<std::mutex> lock(mutex_);
+          ReplaceFrameworkFd(std::move(new_framework_fd));
+
+          // Stop iterating over events: one of the later ones might be the old
+          // framework fd.
+          restart = false;
+          break;
         }
 
-        {
-            struct epoll_event event;
-            event.events = EPOLLIN;
-            event.data.u64 = kEpollConstEventFd;
-            CHECK_EQ(0, epoll_ctl(epoll_fd_.get(), EPOLL_CTL_ADD, event_fd_.get(), &event));
+        case kEpollConstEventFd: {
+          // We were woken up to write something.
+          uint64_t dummy;
+          int rc =
+              TEMP_FAILURE_RETRY(read(event_fd_.get(), &dummy, sizeof(dummy)));
+          if (rc != 8) {
+            PLOG(FATAL) << "adbd_auth: failed to read from eventfd (rc = " << rc
+                        << ")";
+          }
+
+          std::lock_guard<std::mutex> lock(mutex_);
+          UpdateFrameworkWritable();
+          break;
         }
 
-        while (true) {
-            struct epoll_event events[3];
-            int rc = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd_.get(), events, 3, -1));
+        case kEpollConstFramework: {
+          char buf[4096];
+          if (event.events & EPOLLIN) {
+            int rc =
+                TEMP_FAILURE_RETRY(read(framework_fd_.get(), buf, sizeof(buf)));
             if (rc == -1) {
-                PLOG(FATAL) << "adbd_auth: epoll_wait failed";
+              PLOG(FATAL) << "adbd_auth: failed to read from framework fd";
             } else if (rc == 0) {
-                LOG(FATAL) << "adbd_auth: epoll_wait returned 0";
+              LOG(INFO) << "adbd_auth: hit EOF on framework fd";
+              std::lock_guard<std::mutex> lock(mutex_);
+              ReplaceFrameworkFd(unique_fd());
+            } else {
+              HandlePacket(std::string_view(buf, rc));
             }
+          }
 
-            bool restart = false;
-            for (int i = 0; i < rc; ++i) {
-                if (restart) {
-                    break;
-                }
-
-                struct epoll_event& event = events[i];
-                switch (event.data.u64) {
-                    case kEpollConstSocket: {
-                        unique_fd new_framework_fd(accept4(sock_fd_.get(), nullptr, nullptr,
-                                                           SOCK_CLOEXEC | SOCK_NONBLOCK));
-                        if (new_framework_fd == -1) {
-                            PLOG(FATAL) << "adbd_auth: failed to accept framework fd";
-                        }
-
-                        LOG(INFO) << "adbd_auth: received a new framework connection";
-                        std::lock_guard<std::mutex> lock(mutex_);
-                        ReplaceFrameworkFd(std::move(new_framework_fd));
-
-                        // Stop iterating over events: one of the later ones might be the old
-                        // framework fd.
-                        restart = false;
-                        break;
-                    }
-
-                    case kEpollConstEventFd: {
-                        // We were woken up to write something.
-                        uint64_t dummy;
-                        int rc = TEMP_FAILURE_RETRY(read(event_fd_.get(), &dummy, sizeof(dummy)));
-                        if (rc != 8) {
-                            PLOG(FATAL)
-                                    << "adbd_auth: failed to read from eventfd (rc = " << rc << ")";
-                        }
-
-                        std::lock_guard<std::mutex> lock(mutex_);
-                        UpdateFrameworkWritable();
-                        break;
-                    }
-
-                    case kEpollConstFramework: {
-                        char buf[4096];
-                        if (event.events & EPOLLIN) {
-                            int rc = TEMP_FAILURE_RETRY(read(framework_fd_.get(), buf, sizeof(buf)));
-                            if (rc == -1) {
-                                PLOG(FATAL) << "adbd_auth: failed to read from framework fd";
-                            } else if (rc == 0) {
-                                LOG(INFO) << "adbd_auth: hit EOF on framework fd";
-                                std::lock_guard<std::mutex> lock(mutex_);
-                                ReplaceFrameworkFd(unique_fd());
-                            } else {
-                                HandlePacket(std::string_view(buf, rc));
-                            }
-                        }
-
-                        if (event.events & EPOLLOUT) {
-                            std::lock_guard<std::mutex> lock(mutex_);
-                            while (SendPacket()) {
-                                continue;
-                            }
-                            UpdateFrameworkWritable();
-                        }
-
-                        break;
-                    }
-                }
+          if (event.events & EPOLLOUT) {
+            std::lock_guard<std::mutex> lock(mutex_);
+            while (SendPacket()) {
+              continue;
             }
-        }
-    }
+            UpdateFrameworkWritable();
+          }
 
-    static constexpr std::pair<const char*, bool> key_paths[] = {
-        {"/adb_keys",               true  /* follow symlinks */       },
-        {"/data/misc/adb/adb_keys", false /* don't follow symlinks */ },
-    };
-    void IteratePublicKeys(bool (*callback)(void*, const char*, size_t), void* opaque) {
-        for (const auto& [path, follow_symlinks] : key_paths) {
-            if (access(path, R_OK) == 0) {
-                LOG(INFO) << "adbd_auth: loading keys from " << path;
-                std::string content;
-                if (!android::base::ReadFileToString(path, &content, follow_symlinks)) {
-                    PLOG(ERROR) << "adbd_auth: couldn't read " << path;
-                    continue;
-                }
-                for (const auto& line : android::base::Split(content, "\n")) {
-                    if (!callback(opaque, line.data(), line.size())) {
-                        return;
-                    }
-                }
-            }
+          break;
         }
+      }
     }
+  }
+}
 
-    uint64_t PromptUser(std::string_view public_key, void* arg) EXCLUDES(mutex_) {
-        uint64_t id = NextId();
-
-        std::lock_guard<std::mutex> lock(mutex_);
-        LOG(INFO) << "adbd_auth: sending prompt with id " << id;
-        pending_prompts_.emplace_back(id, public_key, arg);
-        DispatchPendingPrompt();
-        return id;
+static constexpr std::pair<const char*, bool> key_paths[] = {
+    {"/adb_keys", true /* follow symlinks */},
+    {"/data/misc/adb/adb_keys", false /* don't follow symlinks */},
+};
+void AdbdAuthContext::IteratePublicKeys(bool (*callback)(void*, const char*,
+                                                         size_t),
+                                        void* opaque) {
+  for (const auto& [path, follow_symlinks] : key_paths) {
+    if (access(path, R_OK) == 0) {
+      LOG(INFO) << "adbd_auth: loading keys from " << path;
+      std::string content;
+      if (!android::base::ReadFileToString(path, &content, follow_symlinks)) {
+        PLOG(ERROR) << "adbd_auth: couldn't read " << path;
+        continue;
+      }
+      for (const auto& line : android::base::Split(content, "\n")) {
+        if (!callback(opaque, line.data(), line.size())) {
+          return;
+        }
+      }
     }
+  }
+}
 
-    uint64_t NotifyAuthenticated(std::string_view public_key) EXCLUDES(mutex_) {
-        uint64_t id = NextId();
-        std::lock_guard<std::mutex> lock(mutex_);
-        keys_.emplace(id, public_key);
-        output_queue_.emplace_back(
-                AdbdAuthPacketAuthenticated{.public_key = std::string(public_key)});
-        return id;
-    }
+uint64_t AdbdAuthContext::PromptUser(std::string_view public_key, void* arg)
+    EXCLUDES(mutex_) {
+  uint64_t id = NextId();
 
-    void NotifyDisconnected(uint64_t id) EXCLUDES(mutex_) {
-        std::lock_guard<std::mutex> lock(mutex_);
-        auto it = keys_.find(id);
-        if (it == keys_.end()) {
-            LOG(DEBUG) << "adbd_auth: couldn't find public key to notify disconnection, skipping";
-            return;
-        }
-        output_queue_.emplace_back(AdbdAuthPacketDisconnected{.public_key = std::move(it->second)});
-        keys_.erase(it);
-    }
+  std::lock_guard<std::mutex> lock(mutex_);
+  LOG(INFO) << "adbd_auth: sending prompt with id " << id;
+  pending_prompts_.emplace_back(id, public_key, arg);
+  DispatchPendingPrompt();
+  return id;
+}
 
-    uint64_t NotifyTlsDeviceConnected(AdbTransportType type,
-                                      std::string_view public_key) EXCLUDES(mutex_) {
-        uint64_t id = NextId();
-        std::lock_guard<std::mutex> lock(mutex_);
-        keys_.emplace(id, public_key);
-        output_queue_.emplace_back(AdbdPacketTlsDeviceConnected{
-                .transport_type = static_cast<uint8_t>(type),
-                .public_key = std::string(public_key)});
-        Interrupt();
-        return id;
-    }
+uint64_t AdbdAuthContext::NotifyAuthenticated(std::string_view public_key)
+    EXCLUDES(mutex_) {
+  uint64_t id = NextId();
+  std::lock_guard<std::mutex> lock(mutex_);
+  keys_.emplace(id, public_key);
+  output_queue_.emplace_back(
+      AdbdAuthPacketAuthenticated{.public_key = std::string(public_key)});
+  return id;
+}
 
-    void NotifyTlsDeviceDisconnected(AdbTransportType type, uint64_t id) EXCLUDES(mutex_) {
-        std::lock_guard<std::mutex> lock(mutex_);
-        auto it = keys_.find(id);
-        if (it == keys_.end()) {
-            LOG(DEBUG) << "adbd_auth: couldn't find public key to notify disconnection of tls "
-                          "device, skipping";
-            return;
-        }
-        output_queue_.emplace_back(AdbdPacketTlsDeviceDisconnected{
-                .transport_type = static_cast<uint8_t>(type),
-                .public_key = std::move(it->second)});
-        keys_.erase(it);
-        Interrupt();
-    }
+void AdbdAuthContext::NotifyDisconnected(uint64_t id) EXCLUDES(mutex_) {
+  std::lock_guard<std::mutex> lock(mutex_);
+  auto it = keys_.find(id);
+  if (it == keys_.end()) {
+    LOG(DEBUG) << "adbd_auth: couldn't find public key to notify "
+                  "disconnection, skipping";
+    return;
+  }
+  output_queue_.emplace_back(
+      AdbdAuthPacketDisconnected{.public_key = std::move(it->second)});
+  keys_.erase(it);
+}
 
-    // Interrupt the worker thread to do some work.
-    void Interrupt() {
-        uint64_t value = 1;
-        ssize_t rc = write(event_fd_.get(), &value, sizeof(value));
-        if (rc == -1) {
-            PLOG(FATAL) << "adbd_auth: write to eventfd failed";
-        } else if (rc != sizeof(value)) {
-            LOG(FATAL) << "adbd_auth: write to eventfd returned short (" << rc << ")";
-        }
-    }
+uint64_t AdbdAuthContext::NotifyTlsDeviceConnected(AdbTransportType type,
+                                                   std::string_view public_key)
+    EXCLUDES(mutex_) {
+  uint64_t id = NextId();
+  std::lock_guard<std::mutex> lock(mutex_);
+  keys_.emplace(id, public_key);
+  output_queue_.emplace_back(
+      AdbdPacketTlsDeviceConnected{.transport_type = static_cast<uint8_t>(type),
+                                   .public_key = std::string(public_key)});
+  Interrupt();
+  return id;
+}
 
-    void InitFrameworkHandlers() {
-        // Framework wants to disconnect from a secured wifi device
-        framework_handlers_.emplace_back(
-                FrameworkPktHandler{
-                    .code = "DD",
-                    .cb = std::bind(&AdbdAuthContext::KeyRemoved, this, std::placeholders::_1)});
-        // Framework allows USB debugging for the device
-        framework_handlers_.emplace_back(
-                FrameworkPktHandler{
-                    .code = "OK",
-                    .cb = std::bind(&AdbdAuthContext::AllowUsbDevice, this, std::placeholders::_1)});
-        // Framework denies USB debugging for the device
-        framework_handlers_.emplace_back(
-                FrameworkPktHandler{
-                    .code = "NO",
-                    .cb = std::bind(&AdbdAuthContext::DenyUsbDevice, this, std::placeholders::_1)});
-    }
+void AdbdAuthContext::NotifyTlsDeviceDisconnected(AdbTransportType type,
+                                                  uint64_t id)
+    EXCLUDES(mutex_) {
+  std::lock_guard<std::mutex> lock(mutex_);
+  auto it = keys_.find(id);
+  if (it == keys_.end()) {
+    LOG(DEBUG)
+        << "adbd_auth: couldn't find public key to notify disconnection of tls "
+           "device, skipping";
+    return;
+  }
+  output_queue_.emplace_back(AdbdPacketTlsDeviceDisconnected{
+      .transport_type = static_cast<uint8_t>(type),
+      .public_key = std::move(it->second)});
+  keys_.erase(it);
+  Interrupt();
+}
 
-    unique_fd epoll_fd_;
-    unique_fd event_fd_;
-    unique_fd sock_fd_;
-    unique_fd framework_fd_;
+void AdbdAuthContext::SendTLSServerPort(uint16_t port) {
+  std::lock_guard<std::mutex> lock(mutex_);
+  output_queue_.emplace_back(AdbdPacketTlsServerPort{.port = port});
+  Interrupt();
+}
 
-    std::atomic<uint64_t> next_id_;
-    AdbdAuthCallbacksV1 callbacks_;
+// Interrupt the worker thread to do some work.
+void AdbdAuthContext::Interrupt() {
+  uint64_t value = 1;
+  ssize_t rc = write(event_fd_.get(), &value, sizeof(value));
+  if (rc == -1) {
+    PLOG(FATAL) << "adbd_auth: write to eventfd failed";
+  } else if (rc != sizeof(value)) {
+    LOG(FATAL) << "adbd_auth: write to eventfd returned short (" << rc << ")";
+  }
+}
 
-    std::mutex mutex_;
-    std::unordered_map<uint64_t, std::string> keys_ GUARDED_BY(mutex_);
+void AdbdAuthContext::InitFrameworkHandlers() {
+  // Framework wants to disconnect from a secured wifi device
+  framework_handlers_.emplace_back(
+      FrameworkPktHandler{.code = "DD",
+                          .cb = std::bind(&AdbdAuthContext::KeyRemoved, this,
+                                          std::placeholders::_1)});
+  // Framework allows USB debugging for the device
+  framework_handlers_.emplace_back(
+      FrameworkPktHandler{.code = "OK",
+                          .cb = std::bind(&AdbdAuthContext::AllowUsbDevice,
+                                          this, std::placeholders::_1)});
+  // Framework denies USB debugging for the device
+  framework_handlers_.emplace_back(
+      FrameworkPktHandler{.code = "NO",
+                          .cb = std::bind(&AdbdAuthContext::DenyUsbDevice, this,
+                                          std::placeholders::_1)});
+}
 
-    // We keep two separate queues: one to handle backpressure from the socket (output_queue_)
-    // and one to make sure we only dispatch one authrequest at a time (pending_prompts_).
-    std::deque<AdbdAuthPacket> output_queue_ GUARDED_BY(mutex_);
+AdbdAuthContextV2::AdbdAuthContextV2(AdbdAuthCallbacksV2* callbacks)
+    : AdbdAuthContext(callbacks), callbacks_v2_(*callbacks) {}
+
+void AdbdAuthContextV2::InitFrameworkHandlers() {
+  AdbdAuthContext::InitFrameworkHandlers();
+  // Framework requires ADB Wifi to start
+  framework_handlers_.emplace_back(
+      FrameworkPktHandler{.code = "W1",
+                          .cb = std::bind(&AdbdAuthContextV2::StartAdbWifi,
+                                          this, std::placeholders::_1)});
+
+  // Framework requires ADB Wifi to stop
+  framework_handlers_.emplace_back(
+      FrameworkPktHandler{.code = "W0",
+                          .cb = std::bind(&AdbdAuthContextV2::StopAdbWifi, this,
+                                          std::placeholders::_1)});
+}
 
-    std::optional<std::tuple<uint64_t, std::string, void*>> dispatched_prompt_ GUARDED_BY(mutex_);
-    std::deque<std::tuple<uint64_t, std::string, void*>> pending_prompts_ GUARDED_BY(mutex_);
+void AdbdAuthContextV2::StartAdbWifi(std::string_view buf) EXCLUDES(mutex_) {
+  CHECK(buf.empty());
+  callbacks_v2_.start_adbd_wifi();
+}
 
-    // This is a list of commands that the framework could send to us.
-    using FrameworkHandlerCb = std::function<void(std::string_view)>;
-    struct FrameworkPktHandler {
-        const char* code;
-        FrameworkHandlerCb cb;
-    };
-    std::vector<FrameworkPktHandler> framework_handlers_;
-};
+void AdbdAuthContextV2::StopAdbWifi(std::string_view buf) EXCLUDES(mutex_) {
+  CHECK(buf.empty());
+  callbacks_v2_.stop_adbd_wifi();
+}
 
 AdbdAuthContext* adbd_auth_new(AdbdAuthCallbacks* callbacks) {
-    if (callbacks->version == 1) {
-        return new AdbdAuthContext(reinterpret_cast<AdbdAuthCallbacksV1*>(callbacks));
-    } else {
-        LOG(ERROR) << "adbd_auth: received unknown AdbdAuthCallbacks version "
-                   << callbacks->version;
-        return nullptr;
+  switch (callbacks->version) {
+    case 1: {
+      AdbdAuthContext* ctx = new AdbdAuthContext(
+          reinterpret_cast<AdbdAuthCallbacksV1*>(callbacks));
+      ctx->InitFrameworkHandlers();
+      return ctx;
+    }
+    case kAuthVersion: {
+      AdbdAuthContextV2* ctx2 = new AdbdAuthContextV2(
+          reinterpret_cast<AdbdAuthCallbacksV2*>(callbacks));
+      ctx2->InitFrameworkHandlers();
+      return ctx2;
+    }
+    default: {
+      LOG(ERROR) << "adbd_auth: received unknown AdbdAuthCallbacks version "
+                 << callbacks->version;
+      return nullptr;
     }
+  }
 }
 
-void adbd_auth_delete(AdbdAuthContext* ctx) {
-    delete ctx;
-}
+void adbd_auth_delete(AdbdAuthContext* ctx) { delete ctx; }
 
-void adbd_auth_run(AdbdAuthContext* ctx) {
-    return ctx->Run();
-}
+void adbd_auth_run(AdbdAuthContext* ctx) { return ctx->Run(); }
 
 void adbd_auth_get_public_keys(AdbdAuthContext* ctx,
-                               bool (*callback)(void* opaque, const char* public_key, size_t len),
+                               bool (*callback)(void* opaque,
+                                                const char* public_key,
+                                                size_t len),
                                void* opaque) {
-    ctx->IteratePublicKeys(callback, opaque);
+  ctx->IteratePublicKeys(callback, opaque);
 }
 
-uint64_t adbd_auth_notify_auth(AdbdAuthContext* ctx, const char* public_key, size_t len) {
-    return ctx->NotifyAuthenticated(std::string_view(public_key, len));
+uint64_t adbd_auth_notify_auth(AdbdAuthContext* ctx, const char* public_key,
+                               size_t len) {
+  return ctx->NotifyAuthenticated(std::string_view(public_key, len));
 }
 
 void adbd_auth_notify_disconnect(AdbdAuthContext* ctx, uint64_t id) {
-    return ctx->NotifyDisconnected(id);
+  return ctx->NotifyDisconnected(id);
 }
 
-void adbd_auth_prompt_user(AdbdAuthContext* ctx, const char* public_key, size_t len,
-                           void* opaque) {
-    adbd_auth_prompt_user_with_id(ctx, public_key, len, opaque);
+void adbd_auth_prompt_user(AdbdAuthContext* ctx, const char* public_key,
+                           size_t len, void* opaque) {
+  adbd_auth_prompt_user_with_id(ctx, public_key, len, opaque);
 }
 
-uint64_t adbd_auth_prompt_user_with_id(AdbdAuthContext* ctx, const char* public_key, size_t len,
+uint64_t adbd_auth_prompt_user_with_id(AdbdAuthContext* ctx,
+                                       const char* public_key, size_t len,
                                        void* opaque) {
-    return ctx->PromptUser(std::string_view(public_key, len), opaque);
+  return ctx->PromptUser(std::string_view(public_key, len), opaque);
 }
 
 uint64_t adbd_auth_tls_device_connected(AdbdAuthContext* ctx,
                                         AdbTransportType type,
-                                        const char* public_key,
-                                        size_t len) {
-    return ctx->NotifyTlsDeviceConnected(type, std::string_view(public_key, len));
+                                        const char* public_key, size_t len) {
+  return ctx->NotifyTlsDeviceConnected(type, std::string_view(public_key, len));
 }
 
 void adbd_auth_tls_device_disconnected(AdbdAuthContext* ctx,
-                                       AdbTransportType type,
-                                       uint64_t id) {
-    ctx->NotifyTlsDeviceDisconnected(type, id);
+                                       AdbTransportType type, uint64_t id) {
+  ctx->NotifyTlsDeviceDisconnected(type, id);
 }
 
-uint32_t adbd_auth_get_max_version() {
-    return kAuthVersion;
-}
+uint32_t adbd_auth_get_max_version() { return kAuthVersion; }
 
 bool adbd_auth_supports_feature(AdbdAuthFeature f) {
-    UNUSED(f);
-    return false;
+  return supported_features.contains(f);
+}
+
+void adbd_auth_send_tls_server_port(AdbdAuthContext* ctx, uint16_t port) {
+  ctx->SendTLSServerPort(port);
 }
diff --git a/libs/adbd_auth/adbd_auth_internal.h b/libs/adbd_auth/adbd_auth_internal.h
new file mode 100644
index 0000000000..b7f2e060e4
--- /dev/null
+++ b/libs/adbd_auth/adbd_auth_internal.h
@@ -0,0 +1,151 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <android-base/file.h>
+#include <android-base/logging.h>
+#include <android-base/macros.h>
+#include <android-base/strings.h>
+#include <android-base/thread_annotations.h>
+#include <android-base/unique_fd.h>
+#include <cutils/sockets.h>
+#include <inttypes.h>
+#include <sys/epoll.h>
+#include <sys/eventfd.h>
+#include <sys/uio.h>
+
+#include <atomic>
+#include <chrono>
+#include <deque>
+#include <optional>
+#include <set>
+#include <string>
+#include <string_view>
+#include <tuple>
+#include <unordered_map>
+#include <utility>
+#include <variant>
+#include <vector>
+
+struct AdbdAuthPacketAuthenticated {
+  std::string public_key;
+};
+
+struct AdbdAuthPacketDisconnected {
+  std::string public_key;
+};
+
+struct AdbdAuthPacketRequestAuthorization {
+  std::string public_key;
+};
+
+struct AdbdPacketTlsDeviceConnected {
+  uint8_t transport_type;
+  std::string public_key;
+};
+
+struct AdbdPacketTlsDeviceDisconnected {
+  uint8_t transport_type;
+  std::string public_key;
+};
+
+struct AdbdPacketTlsServerPort {
+  uint16_t port;
+};
+
+using AdbdAuthPacket =
+    std::variant<AdbdAuthPacketAuthenticated, AdbdAuthPacketDisconnected,
+                 AdbdAuthPacketRequestAuthorization,
+                 AdbdPacketTlsDeviceConnected, AdbdPacketTlsDeviceDisconnected,
+                 AdbdPacketTlsServerPort>;
+
+struct AdbdAuthContext {
+  static constexpr uint64_t kEpollConstSocket = 0;
+  static constexpr uint64_t kEpollConstEventFd = 1;
+  static constexpr uint64_t kEpollConstFramework = 2;
+
+ public:
+  explicit AdbdAuthContext(AdbdAuthCallbacksV1* callbacks);
+  virtual ~AdbdAuthContext() {}
+
+  AdbdAuthContext(const AdbdAuthContext& copy) = delete;
+  AdbdAuthContext(AdbdAuthContext&& move) = delete;
+  AdbdAuthContext& operator=(const AdbdAuthContext& copy) = delete;
+  AdbdAuthContext& operator=(AdbdAuthContext&& move) = delete;
+
+  uint64_t NextId() { return next_id_++; }
+
+  void DispatchPendingPrompt() REQUIRES(mutex_);
+  void UpdateFrameworkWritable() REQUIRES(mutex_);
+  void ReplaceFrameworkFd(android::base::unique_fd new_fd) REQUIRES(mutex_);
+  void HandlePacket(std::string_view packet) EXCLUDES(mutex_);
+  void AllowUsbDevice(std::string_view buf) EXCLUDES(mutex_);
+  void DenyUsbDevice(std::string_view buf) EXCLUDES(mutex_);
+  void KeyRemoved(std::string_view buf) EXCLUDES(mutex_);
+  bool SendPacket() REQUIRES(mutex_);
+  void Run();
+  void IteratePublicKeys(bool (*callback)(void*, const char*, size_t), void* opaque);
+  uint64_t PromptUser(std::string_view public_key, void* arg) EXCLUDES(mutex_);
+  uint64_t NotifyAuthenticated(std::string_view public_key) EXCLUDES(mutex_);
+  void NotifyDisconnected(uint64_t id) EXCLUDES(mutex_);
+  uint64_t NotifyTlsDeviceConnected(AdbTransportType type, std::string_view public_key)
+      EXCLUDES(mutex_);
+  void NotifyTlsDeviceDisconnected(AdbTransportType type, uint64_t id)
+      EXCLUDES(mutex_);
+  void SendTLSServerPort(uint16_t port);
+  void Interrupt();
+  virtual void InitFrameworkHandlers();
+
+ protected:
+  android::base::unique_fd epoll_fd_;
+  android::base::unique_fd event_fd_;
+  android::base::unique_fd sock_fd_;
+  android::base::unique_fd framework_fd_;
+
+  std::atomic<uint64_t> next_id_;
+  AdbdAuthCallbacksV1 callbacks_;
+
+  std::mutex mutex_;
+  std::unordered_map<uint64_t, std::string> keys_ GUARDED_BY(mutex_);
+
+  // We keep two separate queues: one to handle backpressure from the socket
+  // (output_queue_) and one to make sure we only dispatch one authrequest at a
+  // time (pending_prompts_).
+  std::deque<AdbdAuthPacket> output_queue_ GUARDED_BY(mutex_);
+
+  std::optional<std::tuple<uint64_t, std::string, void*>> dispatched_prompt_ GUARDED_BY(mutex_);
+  std::deque<std::tuple<uint64_t, std::string, void*>> pending_prompts_ GUARDED_BY(mutex_);
+
+  // This is a list of commands that the framework could send to us.
+  using FrameworkHandlerCb = std::function<void(std::string_view)>;
+  struct FrameworkPktHandler {
+    const char* code;
+    FrameworkHandlerCb cb;
+  };
+  std::vector<FrameworkPktHandler> framework_handlers_;
+};
+
+class AdbdAuthContextV2 : public AdbdAuthContext {
+ public:
+  explicit AdbdAuthContextV2(AdbdAuthCallbacksV2* callbacks);
+  virtual void InitFrameworkHandlers();
+  void StartAdbWifi(std::string_view buf) EXCLUDES(mutex_);
+  void StopAdbWifi(std::string_view buf) EXCLUDES(mutex_);
+
+ protected:
+  AdbdAuthCallbacksV2 callbacks_v2_;
+};
diff --git a/libs/adbd_auth/adbd_auth_test.cpp b/libs/adbd_auth/adbd_auth_test.cpp
new file mode 100644
index 0000000000..00a72c18ca
--- /dev/null
+++ b/libs/adbd_auth/adbd_auth_test.cpp
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <gtest/gtest.h>
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include "adbd_auth.h"
+
+void start_wifi() {}
+void stop_wifi() {}
+
+class AdbAuthTest: public ::testing::Test {
+   public:
+    void SetUp() {
+        AdbdAuthCallbacksV2 callbacks;
+        callbacks.version = 2;
+        callbacks.start_adbd_wifi = start_wifi;
+        callbacks.stop_adbd_wifi = stop_wifi;
+        context = adbd_auth_new(&callbacks);
+    }
+
+    void TearDown() {
+      adbd_auth_delete(context);
+    }
+
+ protected:
+  AdbdAuthContext* context;
+};
+
+TEST_F(AdbAuthTest, SendTcpPort) {
+  adbd_auth_send_tls_server_port(context, 1);
+}
diff --git a/libs/adbd_auth/include/adbd_auth.h b/libs/adbd_auth/include/adbd_auth.h
index 1dcf540cf3..306e7f4809 100644
--- a/libs/adbd_auth/include/adbd_auth.h
+++ b/libs/adbd_auth/include/adbd_auth.h
@@ -28,9 +28,11 @@
 __BEGIN_DECLS
 
 // The transport type of the device connection.
+// must be in sync with frameworks/base/core/java/android/debug/AdbTransportType.aidl
 enum AdbTransportType : int32_t {
     kAdbTransportTypeUsb = 0,
     kAdbTransportTypeWifi,
+    kAdbTransportTypeVsock,
 };
 static_assert(sizeof(AdbTransportType) == sizeof(int32_t), "Unexpected AdbTransportType size");
 
@@ -47,6 +49,14 @@ struct AdbdAuthCallbacksV1 : AdbdAuthCallbacks {
     void (*key_removed)(const char* public_key, size_t length);
 };
 
+struct AdbdAuthCallbacksV2 : AdbdAuthCallbacksV1 {
+    // The framework wants adbd to start adb wifi (TCP / TLS)
+    void (*start_adbd_wifi)();
+
+    // The framework wants adbd to stop adb wifi (TCP / TLS)
+    void (*stop_adbd_wifi)();
+};
+
 struct AdbdAuthContext;
 typedef struct AdbdAuthContext AdbdAuthContext;
 
@@ -175,6 +185,7 @@ void adbd_auth_tls_device_disconnected(AdbdAuthContext* ctx,
 uint32_t adbd_auth_get_max_version(void) __INTRODUCED_IN(30);
 
 enum AdbdAuthFeature : int32_t {
+  WifiLifeCycle, // Framework can request ADB Wifi TLS server to start/stop.
 };
 
 /**
@@ -185,4 +196,12 @@ enum AdbdAuthFeature : int32_t {
  */
 bool adbd_auth_supports_feature(AdbdAuthFeature feature);
 
+/**
+ * Advertise the port number the TLS server is running on. 0 = not running.
+ *
+ * @param ctx the AdbdAuthContext
+ * @param port the port number the TLS server is running on.
+ */
+void adbd_auth_send_tls_server_port(AdbdAuthContext* ctx, uint16_t port) __INTRODUCED_IN(37);
+
 __END_DECLS
diff --git a/libs/adbd_auth/libadbd_auth.map.txt b/libs/adbd_auth/libadbd_auth.map.txt
index f9f042ef5d..aa9c9442eb 100644
--- a/libs/adbd_auth/libadbd_auth.map.txt
+++ b/libs/adbd_auth/libadbd_auth.map.txt
@@ -12,6 +12,7 @@ LIBADBD_AUTH {
     adbd_auth_tls_device_disconnected; # systemapi introduced=30
     adbd_auth_get_max_version; # systemapi introduced=30
     adbd_auth_supports_feature; # systemapi introduced=30
+    adbd_auth_send_tls_server_port; # systemapi introduced=37
   local:
     *;
 };
diff --git a/libs/binder/ActivityManager.cpp b/libs/binder/ActivityManager.cpp
index 98349c6ab3..fd832727a5 100644
--- a/libs/binder/ActivityManager.cpp
+++ b/libs/binder/ActivityManager.cpp
@@ -17,6 +17,8 @@
 #include <mutex>
 #include <unistd.h>
 
+#include <android/app/IProcessObserver.h>
+#include <android/app/RunningAppProcessInfo.h>
 #include <android/permission_manager.h>
 #include <binder/ActivityManager.h>
 #include <binder/Binder.h>
@@ -160,6 +162,31 @@ status_t ActivityManager::checkPermission(const String16& permission,
     return DEAD_OBJECT;
 }
 
+status_t ActivityManager::registerProcessObserver(const sp<app::IProcessObserver> observer) {
+    sp<IActivityManager> service = getService();
+    if (service != nullptr) {
+        return service->registerProcessObserver(observer);
+    }
+    return INVALID_OPERATION;
+}
+
+status_t ActivityManager::unregisterProcessObserver(const sp<app::IProcessObserver> observer) {
+    sp<IActivityManager> service = getService();
+    if (service != nullptr) {
+        return service->unregisterProcessObserver(observer);
+    }
+    return INVALID_OPERATION;
+}
+
+status_t ActivityManager::getRunningAppProcesses(
+        ::std::vector<app::RunningAppProcessInfo>* output) {
+    sp<IActivityManager> service = getService();
+    if (service != nullptr) {
+        return service->getRunningAppProcesses(output);
+    }
+    return INVALID_OPERATION;
+}
+
 status_t ActivityManager::linkToDeath(const sp<IBinder::DeathRecipient>& recipient) {
     sp<IActivityManager> service = getService();
     if (service != nullptr) {
diff --git a/libs/binder/Android.bp b/libs/binder/Android.bp
index a3499c1963..10be979fdf 100644
--- a/libs/binder/Android.bp
+++ b/libs/binder/Android.bp
@@ -230,6 +230,17 @@ filegroup {
     ],
 }
 
+filegroup {
+    name: "libbinder_observer_sources",
+    srcs: [
+        "BinderObserver.cpp",
+        "BinderStatsPusher.cpp",
+    ],
+    visibility: [
+        ":__subpackages__",
+    ],
+}
+
 cc_defaults {
     name: "libbinder_common_defaults",
     host_supported: true,
@@ -270,13 +281,18 @@ cc_defaults {
         "-Wreorder-init-list",
         "-Wunused-const-variable",
         "-Wunused-result",
+        "-Wexit-time-destructors",
         "-DANDROID_BASE_UNIQUE_FD_DISABLE_IMPLICIT_CONVERSION",
         "-DANDROID_UTILS_REF_BASE_DISABLE_IMPLICIT_CONSTRUCTION",
         // Hide symbols by default and set the BUILDING_LIBBINDER macro so that
         // the code knows to export them.
         "-fvisibility=hidden",
         "-DBUILDING_LIBBINDER",
-    ],
+    ] + select(release_flag("RELEASE_LIBBINDER_BINDER_OBSERVER"), {
+        true: ["-DLIBBINDER_BINDER_OBSERVER"],
+        false: ["-DNO_LIBBINDER_BINDER_OBSERVER"],
+        default: ["-DNO_LIBBINDER_BINDER_OBSERVER"],
+    }),
 }
 
 cc_defaults {
@@ -356,13 +372,29 @@ cc_defaults {
         "android-*",
         "bugprone-*",
         "-bugprone-branch-clone", // b/155034972
+        "-bugprone-forwarding-reference-overload",
+        "-bugprone-switch-missing-default-case",
         "cert-*",
         "clang-analyzer-*",
+        "-clang-analyzer-deadcode.DeadStores",
+        "-clang-analyzer-security.cert.env.InvalidPtr",
+        "-clang-analyzer-unix.BlockInCriticalSection",
+        "-clang-analyzer-unix.StdCLibraryFunctions",
+        "-clang-diagnostic-error",
         "google-*",
+        "-google-explicit-constructor",
         "misc-*",
+        "-misc-header-include-cycle",
+        "-misc-include-cleaner",
+        "-misc-use-internal-linkage",
+        "-modernize-use-override",
         "performance*",
+        "-performance-enum-size",
         "-performance-move-const-arg", // b/273486801
+        "-performance-unnecessary-copy-initialization",
+        "-performance-unnecessary-value-param",
         "portability*",
+        "-readability-redundant-smartptr-get",
     ],
 }
 
@@ -531,6 +563,8 @@ cc_defaults {
         ":libbinder_aidl",
         ":libbinder_accessor_aidl",
         ":libbinder_device_interface_sources",
+        ":android-os-statsbootstrap-aidl",
+        ":libbinder_observer_sources",
     ],
     target: {
         vendor: {
@@ -564,7 +598,11 @@ cc_defaults {
     },
     cflags: [
         "-DBINDER_WITH_KERNEL_IPC",
-    ],
+    ] + select(release_flag("RELEASE_LIBBINDER_BINDER_OBSERVER"), {
+        true: ["-DLIBBINDER_BINDER_OBSERVER"],
+        false: ["-DNO_LIBBINDER_BINDER_OBSERVER"],
+        default: ["-DNO_LIBBINDER_BINDER_OBSERVER"],
+    }),
 }
 
 cc_library {
@@ -833,7 +871,7 @@ cc_library_static {
     ],
 }
 
-// AIDL interface between libbinder and framework.jar
+// ServiceManager AIDL interface between libbinder and framework.jar
 filegroup {
     name: "libbinder_aidl",
     srcs: [
@@ -857,6 +895,15 @@ filegroup {
     visibility: [":__subpackages__"],
 }
 
+filegroup {
+    name: "libbinder_rpc_aidl",
+    srcs: [
+        "aidl/android/os/IRpcProvider.aidl",
+    ],
+    path: "aidl",
+    visibility: [":__subpackages__"],
+}
+
 aidl_interface {
     name: "packagemanager_aidl",
     unstable: true,
@@ -880,12 +927,44 @@ aidl_interface {
 }
 
 aidl_interface {
-    name: "libbinder_aidl_test_stub",
+    name: "servicemanager_aidl",
     unstable: true,
     local_include_dir: "aidl",
     srcs: [":libbinder_aidl"],
     vendor_available: true,
     backend: {
+        cpp: {
+            // libbinder exports this type itself so use that
+            enabled: false,
+        },
+        rust: {
+            enabled: true,
+        },
+        java: {
+            enabled: false,
+        },
+    },
+    visibility: [
+        ":__subpackages__",
+        "//system/tools/aidl:__subpackages__",
+        "//frameworks/native/cmds/servicemanager/rpc_servicemanager",
+    ],
+}
+
+aidl_interface {
+    name: "rpc_servicemanager_aidl",
+    unstable: true,
+    local_include_dir: "aidl",
+    srcs: [":libbinder_rpc_aidl"],
+    vendor_available: true,
+    backend: {
+        rust: {
+            enabled: true,
+            apex_available: [
+                "com.android.virt",
+                "com.android.compos",
+            ],
+        },
         java: {
             enabled: false,
         },
@@ -893,6 +972,8 @@ aidl_interface {
     visibility: [
         ":__subpackages__",
         "//system/tools/aidl:__subpackages__",
+        "//frameworks/native/cmds/servicemanager/rpc_servicemanager",
+        "//packages/modules/Virtualization:__subpackages__",
     ],
 }
 
@@ -971,6 +1052,8 @@ cc_library {
         "IActivityManager.cpp",
         "IUidObserver.cpp",
         ":activity_manager_procstate_aidl",
+        ":activity_manager_iprocessobserver_aidl",
+        ":activity_manager_runningappprocessinfo_aidl",
     ],
     export_include_dirs: ["include_activitymanager"],
     shared_libs: [
diff --git a/libs/binder/BackendUnifiedServiceManager.cpp b/libs/binder/BackendUnifiedServiceManager.cpp
index b1c8994b05..371321cea6 100644
--- a/libs/binder/BackendUnifiedServiceManager.cpp
+++ b/libs/binder/BackendUnifiedServiceManager.cpp
@@ -19,6 +19,9 @@
 #include <android/os/IAccessor.h>
 #include <android/os/IServiceManager.h>
 #include <binder/RpcSession.h>
+#include <cutils/sockets.h>
+#include <sys/socket.h>
+#include <sys/un.h>
 
 #if defined(__BIONIC__) && !defined(__ANDROID_VNDK__)
 #include <android-base/properties.h>
@@ -26,6 +29,10 @@
 
 namespace android {
 
+// This is similar to the kernel binder servicemanager's context 0. It's the
+// known socket that we expect the Unix Domain Socket servicemanager to be listening on.
+const char kUdsServiceManagerName[] = ANDROID_SOCKET_DIR "/rpc_servicemanager";
+
 #ifdef LIBBINDER_CLIENT_CACHE
 constexpr bool kUseCache = true;
 #else
@@ -128,7 +135,7 @@ os::ServiceWithMetadata createServiceWithMetadata(const sp<IBinder>& service, bo
     return out;
 }
 
-bool BinderCacheWithInvalidation::isClientSideCachingEnabled(const std::string& serviceName) {
+bool BinderCacheWithInvalidation::isClientSideCachingEnabled(const std::string& serviceName) const {
     sp<ProcessState> self = ProcessState::selfOrNull();
     // Should not cache if process state could not be found, or if thread pool
     // max could is not greater than zero.
@@ -473,19 +480,44 @@ Status BackendUnifiedServiceManager::getServiceDebugInfo(
                                      kUnsupportedOpNoServiceManager);
 }
 
+Status BackendUnifiedServiceManager::checkServiceAccess(
+        const AidlServiceManager::CallerContext& callerCtx, const std::string& name,
+        const std::string& permission, bool* _aidl_return) {
+    if (mTheRealServiceManager) {
+        return mTheRealServiceManager->checkServiceAccess(callerCtx, name, permission,
+                                                          _aidl_return);
+    }
+    return Status::fromExceptionCode(Status::EX_UNSUPPORTED_OPERATION,
+                                     kUnsupportedOpNoServiceManager);
+}
+
 [[clang::no_destroy]] static std::once_flag gUSmOnce;
 [[clang::no_destroy]] static sp<BackendUnifiedServiceManager> gUnifiedServiceManager;
 
 static bool hasOutOfProcessServiceManager() {
-#ifndef BINDER_WITH_KERNEL_IPC
+// We don't currently support kernel binder service management or UDS
+// service management on host or when libbinder is compiled without any
+// kernel binder suport. Please use setDefaultServiceManager for host
+// processes that want to use service manager APIs.
+#if !defined(BINDER_WITH_KERNEL_IPC) || !defined(__BIONIC__)
     return false;
 #else
-#if defined(__BIONIC__) && !defined(__ANDROID_VNDK__)
-    return android::base::GetBoolProperty("servicemanager.installed", true);
-#else
+#ifdef __ANDROID_VNDK__
     return true;
+#else
+    return android::base::GetBoolProperty("servicemanager.installed", true);
+#endif
 #endif
-#endif // BINDER_WITH_KERNEL_IPC
+}
+
+static sp<AidlServiceManager> getUdsServiceManager() {
+    auto session = RpcSession::make();
+    session->setFileDescriptorTransportMode(RpcSession::FileDescriptorTransportMode::UNIX);
+    auto status = session->setupUnixDomainClient(kUdsServiceManagerName);
+    if (status == OK) {
+        return interface_cast<AidlServiceManager>(session->getRootObject());
+    }
+    return nullptr;
 }
 
 sp<BackendUnifiedServiceManager> getBackendUnifiedServiceManager() {
@@ -503,11 +535,22 @@ sp<BackendUnifiedServiceManager> getBackendUnifiedServiceManager() {
 
         sp<AidlServiceManager> sm = nullptr;
         while (hasOutOfProcessServiceManager() && sm == nullptr) {
-            sm = interface_cast<AidlServiceManager>(
-                    ProcessState::self()->getContextObject(nullptr));
+            // There is either a kernel binder service manager, or an RPC binder
+            // service manager
+            sp<ProcessState> ps = ProcessState::selfIfKernelBinderEnabled();
+            if (ps) {
+                // Service management over kernel binder
+                sm = interface_cast<AidlServiceManager>(ps->getContextObject(nullptr));
+            } else {
+                // Check for service management over Unix Domain Sockets
+                sm = getUdsServiceManager();
+            }
+
             if (sm == nullptr) {
-                ALOGE("Waiting 1s on context object on %s.",
-                      ProcessState::self()->getDriverName().c_str());
+                std::string contextObjectName = ps
+                        ? ps->getDriverName() + ", " + kUdsServiceManagerName
+                        : kUdsServiceManagerName;
+                ALOGE("Waiting 1s on context object(s) on %s.", contextObjectName.c_str());
                 sleep(1);
             }
         }
diff --git a/libs/binder/BackendUnifiedServiceManager.h b/libs/binder/BackendUnifiedServiceManager.h
index c14f28063f..55a7f19a76 100644
--- a/libs/binder/BackendUnifiedServiceManager.h
+++ b/libs/binder/BackendUnifiedServiceManager.h
@@ -29,7 +29,7 @@ class BinderCacheWithInvalidation
     class BinderInvalidation : public IBinder::DeathRecipient {
     public:
         BinderInvalidation(std::weak_ptr<BinderCacheWithInvalidation> cache, const std::string& key)
-              : mCache(cache), mKey(key) {}
+              : mCache(std::move(cache)), mKey(key) {}
 
         void binderDied(const wp<IBinder>& who) override {
             sp<IBinder> binder = who.promote();
@@ -73,7 +73,7 @@ public:
                 if (result != DEAD_OBJECT) {
                     ALOGW("Unlinking to dead binder resulted in: %d", result);
                 }
-                mCache.erase(key);
+                mCache.erase(it);
                 return true;
             }
         }
@@ -105,14 +105,14 @@ public:
         binder::ScopedTrace aidlTrace(ATRACE_TAG_AIDL,
                                       "BinderCacheWithInvalidation::setItem Successfully Cached");
         std::lock_guard<std::mutex> lock(mCacheMutex);
-        mCache[key] = {.service = item, .deathRecipient = deathRecipient};
+        mCache[key] = {.service = item, .deathRecipient = std::move(deathRecipient)};
         return binder::Status::ok();
     }
 
-    bool isClientSideCachingEnabled(const std::string& serviceName);
+    bool isClientSideCachingEnabled(const std::string& serviceName) const;
 
 private:
-    std::map<std::string, Entry> mCache;
+    std::map<std::string, Entry, std::less<>> mCache;
     mutable std::mutex mCacheMutex;
 };
 
@@ -147,13 +147,23 @@ public:
                                         const sp<IBinder>& service) override;
     binder::Status getServiceDebugInfo(::std::vector<os::ServiceDebugInfo>* _aidl_return) override;
 
+    binder::Status checkServiceAccess(const os::IServiceManager::CallerContext& callerCtx,
+                                      const ::std::string& name, const ::std::string& permission,
+                                      bool* _aidl_return) override;
+
     void enableAddServiceCache(bool value) { mEnableAddServiceCache = value; }
     // for legacy ABI
     const String16& getInterfaceDescriptor() const override {
+        if (mTheRealServiceManager == nullptr) return mNullInterfaceDescriptor;
         return mTheRealServiceManager->getInterfaceDescriptor();
     }
 
 private:
+    // Empty descriptor in case there is no mTheRealServiceManager. We need an
+    // object to return a String& reference and there is only expected to be a
+    // single BackendUnifiedServiceManager per-process, so this is a member
+    // variable.
+    const String16 mNullInterfaceDescriptor;
     bool mEnableAddServiceCache = true;
     std::shared_ptr<BinderCacheWithInvalidation> mCacheForGetService;
     sp<os::IServiceManager> mTheRealServiceManager;
diff --git a/libs/binder/Binder.cpp b/libs/binder/Binder.cpp
index 9883eb2672..eb02f8143a 100644
--- a/libs/binder/Binder.cpp
+++ b/libs/binder/Binder.cpp
@@ -28,7 +28,6 @@
 #include <binder/RecordedTransaction.h>
 #include <binder/RpcServer.h>
 #include <binder/unique_fd.h>
-#include <pthread.h>
 
 #include <inttypes.h>
 #include <stdio.h>
@@ -365,7 +364,7 @@ status_t BBinder::stopRecordingTransactions() {
 
 const String16& BBinder::getInterfaceDescriptor() const
 {
-    static StaticString16 sBBinder(u"BBinder");
+    [[clang::no_destroy]] static StaticString16 sBBinder(u"BBinder");
     ALOGW("Reached BBinder::getInterfaceDescriptor (this=%p). Override?", this);
     return sBBinder;
 }
@@ -417,7 +416,7 @@ status_t BBinder::transact(
         }
     }
 
-    if (kEnableKernelIpc && mRecordingOn && code != START_RECORDING_TRANSACTION) [[unlikely]] {
+    if (kEnableKernelIpc && kEnableRecording && mRecordingOn && code != START_RECORDING_TRANSACTION) [[unlikely]] {
         Extras* e = mExtras.load(std::memory_order_acquire);
         RpcMutexUniqueLock lock(e->mLock);
         if (mRecordingOn) {
@@ -428,7 +427,7 @@ status_t BBinder::transact(
                     fromDetails(getInterfaceDescriptor(), code, flags, ts, data,
                                 reply ? *reply : emptyReply, err);
             if (transaction) {
-                if (status_t err = transaction->dumpToFile(e->mRecordingFd); err != NO_ERROR) {
+                if (err = transaction->dumpToFile(e->mRecordingFd); err != NO_ERROR) {
                     ALOGI("Failed to dump RecordedTransaction to file with error %d", err);
                 }
             } else {
@@ -594,8 +593,9 @@ int BBinder::getMinSchedulerPriority() {
 
 bool BBinder::isInheritRt() {
     Extras* e = mExtras.load(std::memory_order_acquire);
-
-    return e && e->mInheritRt;
+    // Return configured default value if it has not been overridden
+    if (e == nullptr) return sGlobalInheritRt.load(std::memory_order_acquire);
+    return e->mInheritRt;
 }
 
 void BBinder::setInheritRt(bool inheritRt) {
@@ -617,6 +617,12 @@ void BBinder::setInheritRt(bool inheritRt) {
     e->mInheritRt = inheritRt;
 }
 
+std::atomic<bool> BBinder::sGlobalInheritRt(false);
+
+void BBinder::setGlobalInheritRt(bool enabled) {
+    sGlobalInheritRt.store(enabled, std::memory_order_release);
+}
+
 pid_t BBinder::getDebugPid() {
 #ifdef __linux__
     return getpid();
@@ -745,7 +751,7 @@ BBinder::~BBinder()
         if (isRequestingSid()) {
             ALOGW("Binder %p destroyed when requesting SID before being parceled.", this);
         }
-        if (isInheritRt()) {
+        if (sGlobalInheritRt.load(std::memory_order_acquire) != isInheritRt()) {
             ALOGW("Binder %p destroyed after setInheritRt before being parceled.", this);
         }
 #ifdef __linux__
diff --git a/libs/binder/BinderObserver.cpp b/libs/binder/BinderObserver.cpp
new file mode 100644
index 0000000000..e313e67c84
--- /dev/null
+++ b/libs/binder/BinderObserver.cpp
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include "BinderObserver.h"
+#include <mutex>
+
+#include <binder/IServiceManager.h>
+#include <utils/SystemClock.h>
+#include "BinderStatsUtils.h"
+
+namespace android {
+constexpr int kSendIntervalSec = 5;
+bool BinderObserver::isFlushRequired(int64_t nowSec) {
+    int64_t previousFlushTimeSec = mLastFlushTimeSec.load();
+    return nowSec - previousFlushTimeSec >= kSendIntervalSec;
+}
+
+void BinderObserver::addStatMaybeFlush(const std::shared_ptr<BinderStatsSpscQueue>& queue,
+                                       const BinderCallData& stat) {
+    // If write fails, then buffer is full.
+    int64_t nowSec = stat.endTimeNanos / 1000'000'000;
+    if (!queue->push(stat)) {
+        flushStats(nowSec);
+        // If write fails again, we drop the stat.
+        // TODO(b/299356196): Track dropped stats separately.
+        queue->push(stat);
+        return;
+    }
+    if (isFlushRequired(nowSec)) {
+        flushStats(nowSec);
+    }
+}
+
+void BinderObserver::flushStats(int64_t nowSec) {
+    std::unique_lock<std::mutex> lock(mFlushLock, std::defer_lock);
+    // skip flushing if flushing is already in progress
+    if (!lock.try_lock()) {
+        return;
+    }
+    // flush
+    mLastFlushTimeSec = nowSec;
+    std::vector<BinderCallData> data = mBinderStatsCollector.consumeData();
+    mPusher.pushLocked(data, nowSec);
+}
+} // namespace android
\ No newline at end of file
diff --git a/libs/binder/BinderObserver.h b/libs/binder/BinderObserver.h
new file mode 100644
index 0000000000..a25b666384
--- /dev/null
+++ b/libs/binder/BinderObserver.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#include <mutex>
+#include "BinderStatsPusher.h"
+#include "BinderStatsSpscQueue.h"
+#include "BinderStatsUtils.h"
+
+namespace android {
+
+/**
+ * Collects and manages binder transaction statistics from IPC threads.
+ *
+ * Gathers BinderCallData from BinderStatsSpscQueue instances associated
+ * with each IPCThreadState. It periodically flushes these queues, aggregates
+ * data using BinderStatsCollector, and sends statistics via BinderStatsPusher.
+ *
+ * How it is used:
+ * - An instance is typically owned by ProcessState.
+ * - IPCThreadState instances register their BinderStatsSpscQueue with the
+ *   BinderObserver.
+ * - IPCThreadState pushes BinderCallData to its local queue and calls
+ *   addStatMaybeFlush on the BinderObserver.
+ * - flushStats (or flushIfRequired) periodically collects data from all
+ *   registered queues and passes it to BinderStatsPusher.
+ *
+ * Threading Requirements:
+ * - addStatMaybeFlush: thread-safe
+ * - registerQueue, deregisterQueue: thread-safe
+ */
+class BinderObserver {
+public:
+    // Add stats to the local queue, flush if queue is full.
+    void addStatMaybeFlush(const std::shared_ptr<BinderStatsSpscQueue>& queue,
+                           const BinderCallData& stat);
+    void registerQueue(std::shared_ptr<BinderStatsSpscQueue>& queue) {
+        mBinderStatsCollector.registerQueue(queue);
+    }
+    void deregisterQueue(std::shared_ptr<BinderStatsSpscQueue>& queue) {
+        mBinderStatsCollector.deregisterQueue(queue);
+    }
+
+private:
+    void flushStats(int64_t nowMillis);
+    bool isFlushRequired(int64_t nowMillis);
+    // Time since last flush time. Used to trigger a flush if more than kSendTimeoutSec
+    // has elapsed since last flush.
+    std::atomic<int64_t> mLastFlushTimeSec;
+    // BinderStatsCollector stores shared ptrs to queues in IPCThreadState and pulls data from them.
+    BinderStatsCollector mBinderStatsCollector;
+    // BinderStatsPusher aggregates Stats and pushes them to data store.
+    BinderStatsPusher mPusher;
+    // Lock used to ensure that only one thread is running a flush and push at a time.
+    std::mutex mFlushLock;
+};
+} // namespace android
diff --git a/libs/binder/BinderStatsPusher.cpp b/libs/binder/BinderStatsPusher.cpp
new file mode 100644
index 0000000000..f86d4555ac
--- /dev/null
+++ b/libs/binder/BinderStatsPusher.cpp
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include "BinderStatsPusher.h"
+#include <android-base/properties.h>
+#include <android/os/IStatsBootstrapAtomService.h>
+#include <binder/IServiceManager.h>
+#include <utils/SystemClock.h>
+#include "BinderStatsUtils.h"
+#include "JvmUtils.h"
+
+namespace android {
+// defined in stats/atoms/framework/framework_extension_atoms.proto
+constexpr int32_t kBinderSpamAtomId = 1064;
+[[clang::no_destroy]] static const StaticString16 kStatsBootstrapServiceName(u"statsbootstrap");
+
+sp<os::IStatsBootstrapAtomService> BinderStatsPusher::getBootstrapAtomServiceLocked(
+        const int64_t nowSec) {
+    // When this is removed, the device does not get past the boot animation
+    // TODO(b/299356196): This might result in dropped stats for high usage apps like
+    // servicemanager.
+    if (!mLastServiceCheckSucceeded && (mServiceCheckTimeSec + kCheckServiceTimeoutSec > nowSec)) {
+        return nullptr;
+    };
+    if (!mBootComplete) {
+        // TODO(b/299356196): use gSystemBootCompleted instead
+        if (android::base::GetIntProperty("sys.boot_completed", 0) == 0) {
+            return nullptr;
+        }
+    }
+    // store a boolean to reduce GetProperty calls
+    mBootComplete = true;
+    auto sm = defaultServiceManager();
+    if (!sm) {
+        LOG_ALWAYS_FATAL("defaultServiceManager() returned nullptr.");
+    }
+    auto service = interface_cast<os::IStatsBootstrapAtomService>(
+            defaultServiceManager()->checkService(kStatsBootstrapServiceName));
+    mServiceCheckTimeSec = nowSec;
+    if (service == nullptr) {
+        mLastServiceCheckSucceeded = false;
+    } else {
+        mLastServiceCheckSucceeded = true;
+    }
+    return service;
+}
+
+void BinderStatsPusher::aggregateBinderSpamLocked(const std::vector<BinderCallData>& data,
+                                                  const sp<os::IStatsBootstrapAtomService>& service,
+                                                  const int64_t nowSec) {
+    for (const auto& datum : data) {
+        int64_t timeSec = static_cast<int64_t>(datum.startTimeNanos) / 1000'000'000;
+        mSpamStatsBuffer[datum][timeSec]++;
+    }
+    // Ensure that if this is a local binder and this thread isn't attached
+    // to the VM then skip pushing. This is required since StatsBootstrap is
+    // a Java service and needs a JNI interface to be called from native code.
+    // TODO(b/299356196): Ensure that mSpamStatsBuffer doesn't grow indefinitely.
+    if (!service || (IInterface::asBinder(service)->localBinder() && getJavaVM() == nullptr)) {
+        return;
+    }
+
+    for (auto outerIt = mSpamStatsBuffer.begin(); outerIt != mSpamStatsBuffer.end();
+         /* no increment */) {
+        bool hasSpam = false;
+        int32_t secondsWithAtLeast125Calls = 0;
+        int32_t secondsWithAtLeast250Calls = 0;
+        const BinderCallData& datum = outerIt->first;
+        std::unordered_map<int64_t, uint32_t>& innerMap = outerIt->second;
+        for (auto innerIt = innerMap.begin(); innerIt != innerMap.end(); /* no increment */) {
+            int64_t startTimeSec = innerIt->first;
+            uint32_t count = innerIt->second;
+
+            // Check if the delay period has passed.
+            if (nowSec - startTimeSec >= kSpamAggregationWindowSec) {
+                if (count >= kSpamFirstWatermark) {
+                    hasSpam = true;
+                    secondsWithAtLeast125Calls++;
+                    if (count >= kSpamSecondWatermark) {
+                        secondsWithAtLeast250Calls++;
+                    }
+                }
+                innerIt = innerMap.erase(innerIt);
+            } else {
+                ++innerIt;
+            }
+        }
+        if (hasSpam) {
+            auto atom = os::StatsBootstrapAtom();
+            atom.atomId = kBinderSpamAtomId;
+            std::vector<os::StatsBootstrapAtomValue> values;
+            atom.values.push_back(createPrimitiveValue(static_cast<int64_t>(datum.senderUid)));
+            atom.values.push_back(createPrimitiveValue(static_cast<int64_t>(getuid()))); // host uid
+            atom.values.push_back(createPrimitiveValue(datum.interfaceDescriptor));
+            // TODO (b/299356196): get actual method name.
+            atom.values.push_back(
+                    createPrimitiveValue(std::to_string(datum.transactionCode))); // aidl method
+            atom.values.push_back(
+                    createPrimitiveValue(static_cast<int32_t>(secondsWithAtLeast125Calls)));
+            atom.values.push_back(
+                    createPrimitiveValue(static_cast<int32_t>(secondsWithAtLeast250Calls)));
+            // TODO(b/414551350): combine multiple binder calls into one.
+            service->reportBootstrapAtom(atom);
+        }
+        // If the inner map is now empty after removing expired entries, remove the outer entry.
+        if (innerMap.empty()) {
+            outerIt = mSpamStatsBuffer.erase(outerIt);
+        } else {
+            ++outerIt;
+        }
+    }
+}
+
+void BinderStatsPusher::pushLocked(const std::vector<BinderCallData>& data, const int64_t nowSec) {
+    auto service = getBootstrapAtomServiceLocked(nowSec);
+    aggregateBinderSpamLocked(data, service, nowSec);
+}
+
+} // namespace android
diff --git a/libs/binder/BinderStatsPusher.h b/libs/binder/BinderStatsPusher.h
new file mode 100644
index 0000000000..d20e784985
--- /dev/null
+++ b/libs/binder/BinderStatsPusher.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+
+#include <vector>
+#include "BinderStatsUtils.h"
+
+class BinderStatsPusherTest_GetBootstrapService_Test;
+
+namespace android {
+/**
+ * Processes and pushes binder transaction statistics to the StatsBootstrapAtomService.
+ *
+ * This class is responsible for aggregating collected BinderCallData
+ * such as binder spam which are then reported as atoms.
+ * It manages the interaction with the StatsBootstrapAtomService, including
+ * handling boot completion and service availability checks.
+ *
+ * This class is not Thread-safe.
+ */
+class BinderStatsPusher {
+public:
+    // Pushes binder transaction data to the StatsBootstrapAtomService.
+    void pushLocked(const std::vector<BinderCallData>& data, const int64_t nowSec);
+
+private:
+    friend ::BinderStatsPusherTest_GetBootstrapService_Test;
+    sp<os::IStatsBootstrapAtomService> getBootstrapAtomServiceLocked(const int64_t nowSec);
+
+    // timeout for checking the service.
+    static const int32_t kCheckServiceTimeoutSec = 5;
+    static const int32_t kSpamFirstWatermark = 125;
+    static const int32_t kSpamSecondWatermark = 250;
+    // Time window to aggregate the data in. Once the data point's startTime
+    // is older than the Aggregation window, we will allow the data to be sent.
+    static const int64_t kSpamAggregationWindowSec = 5;
+
+    // KeyEqual function for Binder Spam aggregation of BinderCallData
+    struct SpamStatsKeyEqual {
+        bool operator()(const BinderCallData& lhs, const BinderCallData& rhs) const {
+            return lhs.transactionCode == rhs.transactionCode && lhs.senderUid == rhs.senderUid &&
+                    lhs.interfaceDescriptor == rhs.interfaceDescriptor;
+        }
+    };
+    // Custom Hash for Binder Spam aggregation of BinderCallData in std::unordered_map.
+    struct SpamStatsKeyHash {
+        size_t operator()(const BinderCallData& bcd) const {
+            size_t h = std::hash<uid_t>{}(bcd.senderUid); // uid_t is usually uint32_t or uint64_t
+            h = std::__hash_combine(h, std::hash<std::u16string_view>{}(bcd.interfaceDescriptor));
+            h = std::__hash_combine(h, std::hash<uint32_t>{}(bcd.transactionCode));
+            return h;
+        }
+    };
+
+    using SpamStatsMap =
+            std::unordered_map<BinderCallData,
+                               std::unordered_map<int64_t /*startTimeSec*/, uint32_t /*count*/>,
+                               SpamStatsKeyHash,   // Hash
+                               SpamStatsKeyEqual>; // KeyEqual
+
+    // TODO(b/299356196): replace with gSystemBootCompleted
+    bool mBootComplete = false;
+    // If last service check was a success.
+    bool mLastServiceCheckSucceeded = true;
+    // time of last check
+    int64_t mServiceCheckTimeSec = -kCheckServiceTimeoutSec - 1;
+    // Aggregates binder transaction data into BinderSpamReport objects.
+    void aggregateBinderSpamLocked(const std::vector<BinderCallData>& data,
+                                   const sp<os::IStatsBootstrapAtomService>& service,
+                                   const int64_t nowSec);
+    // The stats which are not sent to StatsBootStrap
+    SpamStatsMap mSpamStatsBuffer;
+};
+
+} // namespace android
diff --git a/libs/binder/BinderStatsSpscQueue.h b/libs/binder/BinderStatsSpscQueue.h
new file mode 100644
index 0000000000..644450151e
--- /dev/null
+++ b/libs/binder/BinderStatsSpscQueue.h
@@ -0,0 +1,179 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <array>
+#include <atomic>
+#include "BinderStatsUtils.h"
+
+namespace android {
+
+/**
+ * Single producer Single consumer concurrent queue.
+ * This is made to collect and store binder transaction data for Binder metrics.
+ *
+ * Each IPCThreadState has one of these and will push all collected data to this queue.
+ *
+ * Each IPCThreadState, in its constructor, should register this queue with the
+ * BinderStatsCollector.
+ *
+ * The push and tryPop can be called concurrently from two threads.
+ * The push should be called from a single thread at all times or be behind a lock.
+ * The tryPop should be called from a single thread at all times or be behind a lock.
+ *
+ * Length is best effort and can be called from any thread.
+ */
+class BinderStatsSpscQueue {
+public:
+    static constexpr size_t kQueueSize = 128;
+private:
+    static_assert((kQueueSize & (kQueueSize - 1)) == 0, "Size must be a power of 2");
+    static constexpr size_t CAPACITY = kQueueSize;
+
+    // Cache-line aligned array of items
+    alignas(64) std::array<BinderCallData, CAPACITY> mBuffer{};
+
+    // Cache-line aligned counters to prevent false sharing
+    alignas(64) std::atomic<uint64_t> mHead{0};
+    alignas(64) std::atomic<uint64_t> mTail{0};
+
+public:
+    /**
+     * @brief Attempts to push an item into the queue
+     *
+     * @param item The item to push (will be moved into the queue)
+     * @return true if the item was successfully pushed
+     * @return false if the queue was full
+     */
+    __attribute__((no_sanitize("unsigned-integer-overflow")))
+    bool push(const BinderCallData& item) {
+        const uint64_t head = mHead.load(std::memory_order_acquire);
+        const uint64_t tail = mTail.load(std::memory_order_relaxed);
+
+        // Check if full using distance
+        if (tail - head == CAPACITY) {
+            return false;
+        }
+
+        mBuffer.at(tail % CAPACITY) = item;
+        mTail.store(tail + 1, std::memory_order_release);
+
+        return true;
+    }
+
+    /**
+     * @brief Best effort length of the queue. Best used for knowing if a lazy
+     * consumer should start consuming.
+     * @return approximate size of queue
+     */
+    __attribute__((no_sanitize("unsigned-integer-overflow")))
+    size_t length() {
+        const uint64_t head = mHead.load(std::memory_order_acquire);
+        const uint64_t tail = mTail.load(std::memory_order_acquire);
+        return tail - head;
+    }
+
+    /**
+     * @brief Pops an item from the queue if available
+     * @return std::optional<BinderCallData> The popped item
+     */
+    __attribute__((no_sanitize("unsigned-integer-overflow")))
+    std::optional<BinderCallData> tryPop() {
+        const uint64_t tail = mTail.load(std::memory_order_acquire);
+        const uint64_t head = mHead.load(std::memory_order_relaxed);
+
+        if (head != tail) {
+            BinderCallData item = std::move(mBuffer.at(head % CAPACITY));
+            mHead.store(head + 1, std::memory_order_release);
+            return item;
+        }
+        return std::nullopt;
+    }
+};
+
+/**
+ * Keeps track of SpscQueues corresponding to threads producing binder stats
+ * and allows the data from them to be consumed.
+ * Each binder thread must register its queue at creation time and deregister it
+ * before it is being destroyed
+ */
+class BinderStatsCollector {
+public:
+    /**
+     * @brief Consumes all data in the registered queues
+     *
+     * This is a thread safe operation
+     */
+    std::vector<BinderCallData> consumeData() {
+        std::vector<BinderCallData> data;
+        std::vector<std::shared_ptr<BinderStatsSpscQueue>> queuesCopy;
+        std::vector<std::shared_ptr<BinderStatsSpscQueue>> deregisteredQueuesCopy;
+        {
+            std::lock_guard<std::mutex> lock(mMutex);
+            queuesCopy = mQueues;
+            deregisteredQueuesCopy.swap(mDeregisteredQueues);
+        }
+        // reserving some amount to reduce number of allocations.
+        data.reserve(BinderStatsSpscQueue::kQueueSize);
+        for (auto& queue : queuesCopy) {
+            LOG_ALWAYS_FATAL_IF(queue == nullptr, "queue pointer null");
+            while (auto item = queue->tryPop()) {
+                data.emplace_back(std::move(*item));
+            }
+        }
+        for (auto& queue : deregisteredQueuesCopy) {
+            LOG_ALWAYS_FATAL_IF(queue == nullptr, "queue pointer null");
+            while (auto item = queue->tryPop()) {
+                data.emplace_back(std::move(*item));
+            }
+            queue.reset();
+        }
+        return data;
+    }
+
+    /**
+     * @brief Register queue
+     *
+     * This is a thread safe operation
+     */
+    void registerQueue(std::shared_ptr<BinderStatsSpscQueue> spscQueue) {
+        LOG_ALWAYS_FATAL_IF(spscQueue == nullptr, "queue pointer null");
+        std::lock_guard<std::mutex> lock(mMutex);
+        mQueues.push_back(spscQueue);
+    }
+    /**
+     * @brief Deregister queue
+     *
+     * This is a thread safe operation
+     */
+    void deregisterQueue(std::shared_ptr<BinderStatsSpscQueue> spscQueue) {
+        LOG_ALWAYS_FATAL_IF(spscQueue == nullptr, "queue pointer null");
+        std::lock_guard<std::mutex> lock(mMutex);
+        mDeregisteredQueues.push_back(spscQueue);
+        auto it = std::find(mQueues.begin(), mQueues.end(), spscQueue);
+        if (it != mQueues.end()) {
+            mQueues.erase(it);
+        }
+    }
+
+private:
+    std::vector<std::shared_ptr<BinderStatsSpscQueue>> mQueues;
+    std::vector<std::shared_ptr<BinderStatsSpscQueue>> mDeregisteredQueues;
+    std::mutex mMutex;
+};
+
+} // namespace android
\ No newline at end of file
diff --git a/libs/binder/BinderStatsUtils.h b/libs/binder/BinderStatsUtils.h
new file mode 100644
index 0000000000..51e8617939
--- /dev/null
+++ b/libs/binder/BinderStatsUtils.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#pragma once
+#include <android/os/IStatsBootstrapAtomService.h>
+
+namespace android {
+// Helper functions to create a StatsBootstrapAtomValue for a primitive
+inline os::StatsBootstrapAtomValue createPrimitiveValue(bool value) {
+    os::StatsBootstrapAtomValue atomValue;
+    atomValue.value.set<os::StatsBootstrapAtomValue::Primitive::boolValue>(value);
+    return atomValue;
+}
+
+inline os::StatsBootstrapAtomValue createPrimitiveValue(int32_t value) {
+    os::StatsBootstrapAtomValue atomValue;
+    atomValue.value.set<os::StatsBootstrapAtomValue::Primitive::intValue>(value);
+    return atomValue;
+}
+
+inline os::StatsBootstrapAtomValue createPrimitiveValue(int64_t value) {
+    os::StatsBootstrapAtomValue atomValue;
+    atomValue.value.set<os::StatsBootstrapAtomValue::Primitive::longValue>(value);
+    return atomValue;
+}
+
+inline os::StatsBootstrapAtomValue createPrimitiveValue(float value) {
+    os::StatsBootstrapAtomValue atomValue;
+    atomValue.value.set<os::StatsBootstrapAtomValue::Primitive::floatValue>(value);
+    return atomValue;
+}
+
+inline os::StatsBootstrapAtomValue createPrimitiveValue(const std::string& value) {
+    os::StatsBootstrapAtomValue atomValue;
+    atomValue.value.set<os::StatsBootstrapAtomValue::Primitive::stringValue>(
+            String16(value.c_str()));
+    return atomValue;
+}
+
+inline os::StatsBootstrapAtomValue createPrimitiveValue(const String16& value) {
+    os::StatsBootstrapAtomValue atomValue;
+    atomValue.value.set<os::StatsBootstrapAtomValue::Primitive::stringValue>(value);
+    return atomValue;
+}
+
+// Data for a monitored binder transaction.
+struct BinderCallData {
+    // TODO(b/299356196): Use the receiver binder object instead and resolve interface lazily
+    String16 interfaceDescriptor;
+    uint32_t transactionCode;
+    int64_t startTimeNanos;
+    int64_t endTimeNanos;
+    uid_t senderUid;
+};
+
+} // namespace android
\ No newline at end of file
diff --git a/libs/binder/BpBinder.cpp b/libs/binder/BpBinder.cpp
index c13e0f9e9c..96722ae9eb 100644
--- a/libs/binder/BpBinder.cpp
+++ b/libs/binder/BpBinder.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "BpBinder"
+#define LOG_TAG "libbinder.BpBinder"
 //#define LOG_NDEBUG 0
 
 #include <binder/BpBinder.h>
@@ -40,16 +40,16 @@ using android::binder::unique_fd;
 
 // ---------------------------------------------------------------------------
 
-RpcMutex BpBinder::sTrackingLock;
-std::unordered_map<int32_t, uint32_t> BpBinder::sTrackingMap;
-std::unordered_map<int32_t, uint32_t> BpBinder::sLastLimitCallbackMap;
+[[clang::no_destroy]] RpcMutex BpBinder::sTrackingLock;
+[[clang::no_destroy]] std::unordered_map<int32_t, uint32_t> BpBinder::sTrackingMap;
+[[clang::no_destroy]] std::unordered_map<int32_t, uint32_t> BpBinder::sLastLimitCallbackMap;
 int BpBinder::sNumTrackedUids = 0;
 std::atomic_bool BpBinder::sCountByUidEnabled(false);
-binder_proxy_limit_callback BpBinder::sLimitCallback;
-binder_proxy_warning_callback BpBinder::sWarningCallback;
+[[clang::no_destroy]] binder_proxy_limit_callback BpBinder::sLimitCallback;
+[[clang::no_destroy]] binder_proxy_warning_callback BpBinder::sWarningCallback;
 bool BpBinder::sBinderProxyThrottleCreate = false;
 
-static StaticString16 kDescriptorUninit(u"");
+[[clang::no_destroy]] static StaticString16 kDescriptorUninit(u"");
 
 // Arbitrarily high value that probably distinguishes a bad behaving app
 uint32_t BpBinder::sBinderProxyCountHighWatermark = 2500;
@@ -164,28 +164,28 @@ sp<BpBinder> BpBinder::create(int32_t handle, std::function<void()>* postTask) {
     if (sCountByUidEnabled) {
         trackedUid = IPCThreadState::self()->getCallingUid();
         RpcMutexUniqueLock _l(sTrackingLock);
-        uint32_t trackedValue = sTrackingMap[trackedUid];
+        const uint32_t trackedValue = sTrackingMap[trackedUid];
+        const uint32_t currentValue = trackedValue & COUNTING_VALUE_MASK;
+
         if (trackedValue & LIMIT_REACHED_MASK) [[unlikely]] {
             if (sBinderProxyThrottleCreate) {
                 return nullptr;
             }
-            trackedValue = trackedValue & COUNTING_VALUE_MASK;
             uint32_t lastLimitCallbackAt = sLastLimitCallbackMap[trackedUid];
 
-            if (trackedValue > lastLimitCallbackAt &&
-                (trackedValue - lastLimitCallbackAt > sBinderProxyCountHighWatermark)) {
+            if (currentValue > lastLimitCallbackAt &&
+                (currentValue - lastLimitCallbackAt > sBinderProxyCountHighWatermark)) {
                 ALOGE("Still too many binder proxy objects sent to uid %d from uid %d (%d proxies "
                       "held)",
-                      getuid(), trackedUid, trackedValue);
+                      getuid(), trackedUid, currentValue);
 
                 if (sLimitCallback) {
                     *postTask = [=]() { sLimitCallback(trackedUid); };
                 }
 
-                sLastLimitCallbackMap[trackedUid] = trackedValue;
+                sLastLimitCallbackMap[trackedUid] = currentValue;
             }
         } else {
-            uint32_t currentValue = trackedValue & COUNTING_VALUE_MASK;
             if (currentValue >= sBinderProxyCountWarningWatermark
                     && currentValue < sBinderProxyCountHighWatermark
                     && ((trackedValue & WARNING_REACHED_MASK) == 0)) [[unlikely]] {
@@ -195,14 +195,14 @@ sp<BpBinder> BpBinder::create(int32_t handle, std::function<void()>* postTask) {
                 }
             } else if (currentValue >= sBinderProxyCountHighWatermark) {
                 ALOGE("Too many binder proxy objects sent to uid %d from uid %d (%d proxies held)",
-                      getuid(), trackedUid, trackedValue);
+                      getuid(), trackedUid, currentValue);
                 sTrackingMap[trackedUid] |= LIMIT_REACHED_MASK;
 
                 if (sLimitCallback) {
                     *postTask = [=]() { sLimitCallback(trackedUid); };
                 }
 
-                sLastLimitCallbackMap[trackedUid] = trackedValue & COUNTING_VALUE_MASK;
+                sLastLimitCallbackMap[trackedUid] = currentValue;
                 if (sBinderProxyThrottleCreate) {
                     ALOGI("Throttling binder proxy creates from uid %d in uid %d until binder proxy"
                           " count drops below %d",
diff --git a/libs/binder/BufferedTextOutput.cpp b/libs/binder/BufferedTextOutput.cpp
index a90bfd29ba..c2053fda4b 100644
--- a/libs/binder/BufferedTextOutput.cpp
+++ b/libs/binder/BufferedTextOutput.cpp
@@ -48,9 +48,18 @@ struct BufferedTextOutput::BufferState : public RefBase
     }
     
     status_t append(const char* txt, size_t len) {
-        if (len > SIZE_MAX - bufferPos) return NO_MEMORY; // overflow
+        if (len > SIZE_MAX - bufferPos) {
+            ALOGE("%s: expanding buffer length by %zu exceeds max size (bufferPos: %zu)\n",
+                  __FUNCTION__, len, bufferPos);
+            return NO_MEMORY; // overflow
+        }
         if ((len+bufferPos) > bufferSize) {
-            if ((len + bufferPos) > SIZE_MAX / 3) return NO_MEMORY; // overflow
+            if ((len + bufferPos) > SIZE_MAX / 3) {
+                ALOGE("%s: cannot realloc to increase buffer size. Total length: %zu (len: %zu, "
+                      "bufferPos: %zu)",
+                      __FUNCTION__, len + bufferPos, len, bufferPos);
+                return NO_MEMORY; // overflow
+            }
             size_t newSize = ((len+bufferPos)*3)/2;
             void* b = realloc(buffer, newSize);
             if (!b) return NO_MEMORY;
@@ -249,7 +258,10 @@ void BufferedTextOutput::popBundle()
 BufferedTextOutput::BufferState* BufferedTextOutput::getBuffer() const
 {
     if ((mFlags&MULTITHREADED) != 0) {
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wexit-time-destructors"
         thread_local ThreadState ts;
+#pragma clang diagnostic pop
         while (ts.states.size() <= (size_t)mIndex) ts.states.add(nullptr);
         BufferState* bs = ts.states[mIndex].get();
         if (bs != nullptr && bs->seq == mSeq) return bs;
diff --git a/libs/binder/Debug.cpp b/libs/binder/Debug.cpp
index 7ae616e2b0..34f326d7ac 100644
--- a/libs/binder/Debug.cpp
+++ b/libs/binder/Debug.cpp
@@ -185,9 +185,9 @@ void printHexData(int32_t indent, const void *buf, size_t length,
 
     if ((int32_t)length < 0) {
         if (singleLineBytesCutoff < 0) func(cookie, "\n");
-        char buf[64];
-        sprintf(buf, "(bad length: %zu)", length);
-        func(cookie, buf);
+        char bufLocal[64];
+        sprintf(bufLocal, "(bad length: %zu)", length);
+        func(cookie, bufLocal);
         return;
     }
 
diff --git a/libs/binder/FdTrigger.cpp b/libs/binder/FdTrigger.cpp
index 7263e236fc..f39420cc19 100644
--- a/libs/binder/FdTrigger.cpp
+++ b/libs/binder/FdTrigger.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "FdTrigger"
+#define LOG_TAG "libbinder.FdTrigger"
 #include <log/log.h>
 
 #include "FdTrigger.h"
@@ -23,7 +23,9 @@
 
 #include <binder/Functional.h>
 
+#ifndef BINDER_RPC_SINGLE_THREADED
 #include "FdUtils.h"
+#endif // BINDER_RPC_SINGLE_THREADED
 #include "RpcState.h"
 #include "Utils.h"
 
diff --git a/libs/binder/IActivityManager.cpp b/libs/binder/IActivityManager.cpp
index 83f4719de2..1ff3736542 100644
--- a/libs/binder/IActivityManager.cpp
+++ b/libs/binder/IActivityManager.cpp
@@ -17,6 +17,8 @@
 #include <unistd.h>
 #include <fcntl.h>
 
+#include <android/app/IProcessObserver.h>
+#include <android/app/RunningAppProcessInfo.h>
 #include <android/permission_manager.h>
 #include <binder/ActivityManager.h>
 #include <binder/IActivityManager.h>
@@ -232,6 +234,41 @@ public:
         }
         return NO_ERROR;
     }
+
+    virtual status_t registerProcessObserver(const sp<app::IProcessObserver>& observer) {
+        Parcel data;
+        Parcel reply;
+        data.writeInterfaceToken(IActivityManager::getInterfaceDescriptor());
+        data.writeStrongBinder(observer);
+        status_t err = remote()->transact(REGISTER_PROCESS_OBSERVER, data, &reply, 0);
+        if (err != NO_ERROR || ((err = reply.readExceptionCode()) != NO_ERROR)) {
+            return err;
+        }
+        return OK;
+    }
+
+    virtual status_t unregisterProcessObserver(const sp<app::IProcessObserver>& observer) {
+        Parcel data;
+        Parcel reply;
+        data.writeInterfaceToken(IActivityManager::getInterfaceDescriptor());
+        data.writeStrongBinder(observer);
+        status_t err = remote()->transact(UNREGISTER_PROCESS_OBSERVER, data, &reply, 0);
+        if (err != NO_ERROR || ((err = reply.readExceptionCode()) != NO_ERROR)) {
+            return err;
+        }
+        return OK;
+    }
+
+    virtual status_t getRunningAppProcesses(::std::vector<app::RunningAppProcessInfo>* output) {
+        Parcel data;
+        Parcel reply;
+        data.writeInterfaceToken(IActivityManager::getInterfaceDescriptor());
+        status_t err = remote()->transact(GET_RUNNING_APP_PROCESSES, data, &reply, 0);
+        if (err != NO_ERROR || ((err = reply.readExceptionCode()) != NO_ERROR)) {
+            return err;
+        }
+        return reply.readParcelableVector(output);
+    }
 };
 
 // ------------------------------------------------------------------------------------
diff --git a/libs/binder/IInterface.cpp b/libs/binder/IInterface.cpp
index dea26038cf..e7c8342428 100644
--- a/libs/binder/IInterface.cpp
+++ b/libs/binder/IInterface.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "IInterface"
+#define LOG_TAG "libbinder.IInterface"
 #include <binder/IInterface.h>
 
 namespace android {
diff --git a/libs/binder/IMemory.cpp b/libs/binder/IMemory.cpp
index bb03e89c9d..10fe6b56b8 100644
--- a/libs/binder/IMemory.cpp
+++ b/libs/binder/IMemory.cpp
@@ -14,10 +14,9 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "IMemory"
+#define LOG_TAG "libbinder.IMemory"
 
 #include <atomic>
-#include <stdatomic.h>
 
 #include <fcntl.h>
 #include <stdint.h>
@@ -69,7 +68,7 @@ private:
     // TODO: Reimplemement based on standard C++ container?
 };
 
-static sp<HeapCache> gHeapCache = sp<HeapCache>::make();
+[[clang::no_destroy]] static sp<HeapCache> gHeapCache = sp<HeapCache>::make();
 
 /******************************************************************************/
 
@@ -261,7 +260,7 @@ BpMemoryHeap::BpMemoryHeap(const sp<IBinder>& impl)
 }
 
 BpMemoryHeap::~BpMemoryHeap() {
-    int32_t heapId = mHeapId.load(memory_order_relaxed);
+    int32_t heapId = mHeapId.load(std::memory_order_relaxed);
     if (heapId != -1) {
         close(heapId);
         if (mRealHeap) {
@@ -286,21 +285,21 @@ BpMemoryHeap::~BpMemoryHeap() {
 
 void BpMemoryHeap::assertMapped() const
 {
-    int32_t heapId = mHeapId.load(memory_order_acquire);
+    int32_t heapId = mHeapId.load(std::memory_order_acquire);
     if (heapId == -1) {
         sp<IBinder> binder(IInterface::asBinder(const_cast<BpMemoryHeap*>(this)));
         sp<BpMemoryHeap> heap = sp<BpMemoryHeap>::cast(find_heap(binder));
         heap->assertReallyMapped();
         if (heap->mBase != MAP_FAILED) {
             Mutex::Autolock _l(mLock);
-            if (mHeapId.load(memory_order_relaxed) == -1) {
+            if (mHeapId.load(std::memory_order_relaxed) == -1) {
                 mBase   = heap->mBase;
                 mSize   = heap->mSize;
                 mOffset = heap->mOffset;
-                int fd = fcntl(heap->mHeapId.load(memory_order_relaxed), F_DUPFD_CLOEXEC, 0);
-                ALOGE_IF(fd==-1, "cannot dup fd=%d",
-                        heap->mHeapId.load(memory_order_relaxed));
-                mHeapId.store(fd, memory_order_release);
+                int fd = fcntl(heap->mHeapId.load(std::memory_order_relaxed), F_DUPFD_CLOEXEC, 0);
+                ALOGE_IF(fd == -1, "cannot dup fd=%d",
+                         heap->mHeapId.load(std::memory_order_relaxed));
+                mHeapId.store(fd, std::memory_order_release);
             }
         } else {
             // something went wrong
@@ -311,7 +310,7 @@ void BpMemoryHeap::assertMapped() const
 
 void BpMemoryHeap::assertReallyMapped() const
 {
-    int32_t heapId = mHeapId.load(memory_order_acquire);
+    int32_t heapId = mHeapId.load(std::memory_order_acquire);
     if (heapId == -1) {
 
         // remote call without mLock held, worse case scenario, we end up
@@ -336,7 +335,7 @@ void BpMemoryHeap::assertReallyMapped() const
         }
 
         Mutex::Autolock _l(mLock);
-        if (mHeapId.load(memory_order_relaxed) == -1) {
+        if (mHeapId.load(std::memory_order_relaxed) == -1) {
             int fd = fcntl(parcel_fd, F_DUPFD_CLOEXEC, 0);
             ALOGE_IF(fd == -1, "cannot dup fd=%d, size=%zu, err=%d (%s)",
                     parcel_fd, size, err, strerror(errno));
@@ -355,7 +354,7 @@ void BpMemoryHeap::assertReallyMapped() const
                 mSize = size;
                 mFlags = flags;
                 mOffset = offset;
-                mHeapId.store(fd, memory_order_release);
+                mHeapId.store(fd, std::memory_order_release);
             }
         }
     }
@@ -364,7 +363,7 @@ void BpMemoryHeap::assertReallyMapped() const
 int BpMemoryHeap::getHeapID() const {
     assertMapped();
     // We either stored mHeapId ourselves, or loaded it with acquire semantics.
-    return mHeapId.load(memory_order_relaxed);
+    return mHeapId.load(std::memory_order_relaxed);
 }
 
 void* BpMemoryHeap::getBase() const {
@@ -438,13 +437,11 @@ sp<IMemoryHeap> HeapCache::find_heap(const sp<IBinder>& binder)
     auto i = mHeapCache.find(binder);
     if (i != mHeapCache.end()) {
         heap_info_t& info = i->second;
-        ALOGD_IF(VERBOSE,
-                "found binder=%p, heap=%p, size=%zu, fd=%d, count=%d",
-                binder.get(), info.heap.get(),
-                static_cast<BpMemoryHeap*>(info.heap.get())->mSize,
-                static_cast<BpMemoryHeap*>(info.heap.get())
-                    ->mHeapId.load(memory_order_relaxed),
-                info.count);
+        ALOGD_IF(VERBOSE, "found binder=%p, heap=%p, size=%zu, fd=%d, count=%d", binder.get(),
+                 info.heap.get(), static_cast<BpMemoryHeap*>(info.heap.get())->mSize,
+                 static_cast<BpMemoryHeap*>(info.heap.get())
+                         ->mHeapId.load(std::memory_order_relaxed),
+                 info.count);
         ++info.count;
         return info.heap;
     } else {
@@ -471,13 +468,12 @@ void HeapCache::free_heap(const wp<IBinder>& binder)
         if (i != mHeapCache.end()) {
             heap_info_t& info = i->second;
             if (--info.count == 0) {
-                ALOGD_IF(VERBOSE,
-                        "removing binder=%p, heap=%p, size=%zu, fd=%d, count=%d",
-                        binder.unsafe_get(), info.heap.get(),
-                        static_cast<BpMemoryHeap*>(info.heap.get())->mSize,
-                        static_cast<BpMemoryHeap*>(info.heap.get())
-                            ->mHeapId.load(memory_order_relaxed),
-                        info.count);
+                ALOGD_IF(VERBOSE, "removing binder=%p, heap=%p, size=%zu, fd=%d, count=%d",
+                         binder.unsafe_get(), info.heap.get(),
+                         static_cast<BpMemoryHeap*>(info.heap.get())->mSize,
+                         static_cast<BpMemoryHeap*>(info.heap.get())
+                                 ->mHeapId.load(std::memory_order_relaxed),
+                         info.count);
                 rel = i->second.heap;
                 mHeapCache.erase(i);
             }
@@ -506,7 +502,7 @@ void HeapCache::dump_heaps()
         const heap_info_t& info = i.second;
         BpMemoryHeap const* h(static_cast<BpMemoryHeap const *>(info.heap.get()));
         ALOGD("hey=%p, heap=%p, count=%d, (fd=%d, base=%p, size=%zu)", i.first.unsafe_get(),
-              info.heap.get(), info.count, h->mHeapId.load(memory_order_relaxed), h->mBase,
+              info.heap.get(), info.count, h->mHeapId.load(std::memory_order_relaxed), h->mBase,
               h->mSize);
     }
 }
diff --git a/libs/binder/IPCThreadState.cpp b/libs/binder/IPCThreadState.cpp
index 1c1b6f30a4..0df74e0b4c 100644
--- a/libs/binder/IPCThreadState.cpp
+++ b/libs/binder/IPCThreadState.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "IPCThreadState"
+#define LOG_TAG "libbinder.IPCThreadState"
 
 #include <binder/IPCThreadState.h>
 
@@ -23,6 +23,7 @@
 #include <binder/TextOutput.h>
 
 #include <utils/CallStack.h>
+#include <utils/SystemClock.h>
 
 #include <atomic>
 #include <errno.h>
@@ -37,6 +38,9 @@
 
 #include "Utils.h"
 #include "binder_module.h"
+#include "BinderObserver.h"
+#include "BinderStatsSpscQueue.h"
+#include "BinderStatsUtils.h"
 
 #if (defined(__ANDROID__) || defined(__Fuchsia__)) && !defined(BINDER_WITH_KERNEL_IPC)
 #error Android and Fuchsia are expected to have BINDER_WITH_KERNEL_IPC
@@ -62,7 +66,6 @@
 #define LOG_ONEWAY(...) ALOG(LOG_DEBUG, "ipc", __VA_ARGS__)
 
 #endif
-
 // ---------------------------------------------------------------------------
 
 namespace android {
@@ -334,7 +337,6 @@ static pthread_mutex_t gTLSMutex = PTHREAD_MUTEX_INITIALIZER;
 LIBBINDER_IGNORE_END()
 static std::atomic<bool> gHaveTLS(false);
 static pthread_key_t gTLS = 0;
-static std::atomic<bool> gShutdown = false;
 static std::atomic<bool> gDisableBackgroundScheduling = false;
 
 IPCThreadState* IPCThreadState::self()
@@ -347,12 +349,6 @@ restart:
         return new IPCThreadState;
     }
 
-    // Racey, heuristic test for simultaneous shutdown.
-    if (gShutdown.load(std::memory_order_relaxed)) {
-        ALOGW("Calling IPCThreadState::self() during shutdown is dangerous, expect a crash.\n");
-        return nullptr;
-    }
-
     pthread_mutex_lock(&gTLSMutex);
     if (!gHaveTLS.load(std::memory_order_relaxed)) {
         int key_create_value = pthread_key_create(&gTLS, threadDestructor);
@@ -378,21 +374,24 @@ IPCThreadState* IPCThreadState::selfOrNull()
     return nullptr;
 }
 
-void IPCThreadState::shutdown()
-{
-    gShutdown.store(true, std::memory_order_relaxed);
-
-    if (gHaveTLS.load(std::memory_order_acquire)) {
-        // XXX Need to wait for all thread pool threads to exit!
-        IPCThreadState* st = (IPCThreadState*)pthread_getspecific(gTLS);
-        if (st) {
-            delete st;
-            pthread_setspecific(gTLS, nullptr);
-        }
-        pthread_key_delete(gTLS);
-        gHaveTLS.store(false, std::memory_order_release);
-    }
-}
+// This code used to be responsible for deleting the TLS, but we keep it
+// forever, since binder threads would often race process destruction.
+// b/77934844. Keeping a few lines here for visibility of the history.
+// IPCThreadState is actually stored in threadDestructor.
+//
+// void IPCThreadState::shutdown()
+// {
+//     if (gHaveTLS.load(std::memory_order_acquire)) {
+//         // XXX Need to wait for all thread pool threads to exit!
+//         IPCThreadState* st = (IPCThreadState*)pthread_getspecific(gTLS);
+//         if (st) {
+//             delete st;
+//             pthread_setspecific(gTLS, nullptr);
+//         }
+//         pthread_key_delete(gTLS);
+//         gHaveTLS.store(false, std::memory_order_release);
+//     }
+// }
 
 void IPCThreadState::disableBackgroundScheduling(bool disable)
 {
@@ -626,8 +625,7 @@ void IPCThreadState::clearCaller()
     mCallingUid = getuid();
 }
 
-void IPCThreadState::flushCommands()
-{
+void IPCThreadState::flushCommands() {
     if (mProcess->mDriverFD < 0)
         return;
 
@@ -1055,10 +1053,17 @@ IPCThreadState::IPCThreadState()
     mHasExplicitIdentity = false;
     mIn.setDataCapacity(256);
     mOut.setDataCapacity(256);
+#ifdef BINDER_WITH_OBSERVERS
+    mBinderStatsQueue = std::make_shared<BinderStatsSpscQueue>();
+    ProcessState::self()->mBinderObserver->registerQueue(mBinderStatsQueue);
+#endif
 }
 
 IPCThreadState::~IPCThreadState()
 {
+#ifdef BINDER_WITH_OBSERVERS
+    ProcessState::self()->mBinderObserver->deregisterQueue(mBinderStatsQueue);
+#endif
 }
 
 status_t IPCThreadState::sendReply(const Parcel& reply, uint32_t flags)
@@ -1331,7 +1336,7 @@ status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags,
     return NO_ERROR;
 }
 
-sp<BBinder> the_context_object;
+[[clang::no_destroy]] sp<BBinder> the_context_object;
 
 void IPCThreadState::setTheContextObject(const sp<BBinder>& obj)
 {
@@ -1481,13 +1486,22 @@ status_t IPCThreadState::executeCommand(int32_t cmd)
                 std::string message = logStream.str();
                 ALOGI("%s", message.c_str());
             }
+#ifdef BINDER_WITH_OBSERVERS
+            int64_t startTimeNanos = uptimeNanos();
+            String16 interfaceDescriptor;
+            // TODO (b/299356196): collect aidl method name. Ensure this is performant.
+#endif
             if (tr.target.ptr) {
                 // We only have a weak reference on the target object, so we must first try to
                 // safely acquire a strong reference before doing anything else with it.
-                if (reinterpret_cast<RefBase::weakref_type*>(
-                        tr.target.ptr)->attemptIncStrong(this)) {
-                    error = reinterpret_cast<BBinder*>(tr.cookie)->transact(tr.code, buffer,
-                            &reply, tr.flags);
+                if (reinterpret_cast<RefBase::weakref_type*>(tr.target.ptr)
+                            ->attemptIncStrong(this)) {
+                    error = reinterpret_cast<BBinder*>(tr.cookie)->transact(tr.code, buffer, &reply,
+                                                                            tr.flags);
+#ifdef BINDER_WITH_OBSERVERS
+                    interfaceDescriptor =
+                            reinterpret_cast<BBinder*>(tr.cookie)->getInterfaceDescriptor();
+#endif
                     reinterpret_cast<BBinder*>(tr.cookie)->decStrong(this);
                 } else {
                     error = UNKNOWN_TRANSACTION;
@@ -1495,8 +1509,13 @@ status_t IPCThreadState::executeCommand(int32_t cmd)
 
             } else {
                 error = the_context_object->transact(tr.code, buffer, &reply, tr.flags);
+#ifdef BINDER_WITH_OBSERVERS
+                interfaceDescriptor = the_context_object->getInterfaceDescriptor();
+#endif
             }
-
+#ifdef BINDER_WITH_OBSERVERS
+            int64_t endTimeNanos = uptimeNanos();
+#endif
             //ALOGI("<<<< TRANSACT from pid %d restore pid %d sid %s uid %d\n",
             //     mCallingPid, origPid, (origSid ? origSid : "<N/A>"), origUid);
 
@@ -1540,7 +1559,17 @@ status_t IPCThreadState::executeCommand(int32_t cmd)
                 }
                 LOG_ONEWAY("NOT sending reply to %d!", mCallingPid);
             }
-
+#ifdef BINDER_WITH_OBSERVERS
+            BinderCallData observerData = {
+                    .interfaceDescriptor = interfaceDescriptor,
+                    .transactionCode = tr.code,
+                    .startTimeNanos = startTimeNanos,
+                    .endTimeNanos = endTimeNanos,
+                    .senderUid = tr.sender_euid,
+            };
+            ProcessState::self()->mBinderObserver->addStatMaybeFlush(mBinderStatsQueue,
+                                                                     observerData);
+#endif
             mServingStackPointer = origServingStackPointer;
             mCallingPid = origPid;
             mCallingSid = origSid;
diff --git a/libs/binder/IPermissionController.cpp b/libs/binder/IPermissionController.cpp
index f94f413d8b..b70ee58b47 100644
--- a/libs/binder/IPermissionController.cpp
+++ b/libs/binder/IPermissionController.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "PermissionController"
+#define LOG_TAG "libbinder.PermissionController"
 
 #include <binder/IPermissionController.h>
 
diff --git a/libs/binder/IResultReceiver.cpp b/libs/binder/IResultReceiver.cpp
index 60ece7269c..da071efd8c 100644
--- a/libs/binder/IResultReceiver.cpp
+++ b/libs/binder/IResultReceiver.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "ResultReceiver"
+#define LOG_TAG "libbinder.ResultReceiver"
 
 #include <binder/IResultReceiver.h>
 
diff --git a/libs/binder/IServiceManager.cpp b/libs/binder/IServiceManager.cpp
index c9ca646472..0a1db181a7 100644
--- a/libs/binder/IServiceManager.cpp
+++ b/libs/binder/IServiceManager.cpp
@@ -15,7 +15,7 @@
  */
 
 #include <sys/socket.h>
-#define LOG_TAG "ServiceManagerCppClient"
+#define LOG_TAG "libbinder.ServiceManagerCppClient"
 
 #include <binder/IServiceManager.h>
 #include <binder/IServiceManagerUnitTestHelper.h>
@@ -133,6 +133,9 @@ public:
 
     void enableAddServiceCache(bool value) { mUnifiedServiceManager->enableAddServiceCache(value); }
 
+    bool checkServiceAccess(const String16& callerSid, pid_t callerDebugPid, uid_t callerUid,
+                            const String16& name, const String16& permission) override;
+
 protected:
     sp<BackendUnifiedServiceManager> mUnifiedServiceManager;
     // AidlRegistrationCallback -> services that its been registered for
@@ -476,7 +479,7 @@ bool checkCallingPermission(const String16& permission)
     return checkCallingPermission(permission, nullptr, nullptr);
 }
 
-static StaticString16 _permission(u"permission");
+[[clang::no_destroy]] static StaticString16 _permission(u"permission");
 
 bool checkCallingPermission(const String16& permission, int32_t* outPid, int32_t* outUid)
 {
@@ -489,8 +492,8 @@ bool checkCallingPermission(const String16& permission, int32_t* outPid, int32_t
 }
 
 bool checkPermission(const String16& permission, pid_t pid, uid_t uid, bool logPermissionFailure) {
-    static std::mutex gPermissionControllerLock;
-    static sp<IPermissionController> gPermissionController;
+    [[clang::no_destroy]] static std::mutex gPermissionControllerLock;
+    [[clang::no_destroy]] static sp<IPermissionController> gPermissionController;
 
     sp<IPermissionController> pc;
     gPermissionControllerLock.lock();
@@ -906,6 +909,26 @@ std::vector<IServiceManager::ServiceDebugInfo> CppBackendShim::getServiceDebugIn
     return ret;
 }
 
+bool CppBackendShim::checkServiceAccess(const String16& callerSid, pid_t callerDebugPid,
+                                        uid_t callerUid, const String16& name,
+                                        const String16& permission) {
+    bool res = false;
+    os::IServiceManager::CallerContext callerCtx;
+    callerCtx.sidName = String8(callerSid).c_str();
+    callerCtx.debugPid = callerDebugPid;
+    callerCtx.uid = callerUid;
+
+    if (Status status =
+                mUnifiedServiceManager->checkServiceAccess(callerCtx, String8(name).c_str(),
+                                                           String8(permission).c_str(), &res);
+        !status.isOk()) {
+        ALOGW("%s Failed to check callers access to service %s for permission %s", __FUNCTION__,
+              String8(name).c_str(), String8(permission).c_str());
+        return false;
+    }
+    return res;
+}
+
 #if defined(BINDER_SERVICEMANAGEMENT_DELEGATION_SUPPORT)
 // CppBackendShim for host. Implements the old libbinder android::IServiceManager API.
 // The internal implementation of the AIDL interface android::os::IServiceManager calls into
diff --git a/libs/binder/IShellCallback.cpp b/libs/binder/IShellCallback.cpp
index 1d6852a9e4..57230ffa8e 100644
--- a/libs/binder/IShellCallback.cpp
+++ b/libs/binder/IShellCallback.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "ShellCallback"
+#define LOG_TAG "libbinder.ShellCallback"
 
 #include <unistd.h>
 #include <fcntl.h>
diff --git a/libs/binder/JvmUtils.h b/libs/binder/JvmUtils.h
new file mode 100644
index 0000000000..1c3b5f770e
--- /dev/null
+++ b/libs/binder/JvmUtils.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#if defined(__ANDROID__) && !defined(__ANDROID_RECOVERY__)
+#include <dlfcn.h>
+#include <jni.h>
+extern "C" JavaVM* AndroidRuntimeGetJavaVM();
+#endif
+namespace {
+#if !defined(__ANDROID__) || defined(__ANDROID_RECOVERY__)
+static void* getJavaVM() {
+    return nullptr;
+}
+#else
+static JavaVM* getJavaVM() {
+    static auto fn = reinterpret_cast<decltype(&AndroidRuntimeGetJavaVM)>(
+            dlsym(RTLD_DEFAULT, "AndroidRuntimeGetJavaVM"));
+    if (fn == nullptr) return nullptr;
+    return fn();
+}
+#endif
+} // namespace
diff --git a/libs/binder/LazyServiceRegistrar.cpp b/libs/binder/LazyServiceRegistrar.cpp
index 27cfe0cf21..4684631775 100644
--- a/libs/binder/LazyServiceRegistrar.cpp
+++ b/libs/binder/LazyServiceRegistrar.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "AidlLazyServiceRegistrar"
+#define LOG_TAG "libbinder.AidlLazyServiceRegistrar"
 
 #include <android/os/BnClientCallback.h>
 #include <android/os/IServiceManager.h>
diff --git a/libs/binder/MemoryDealer.cpp b/libs/binder/MemoryDealer.cpp
index 95bdbb4b65..277d00b74e 100644
--- a/libs/binder/MemoryDealer.cpp
+++ b/libs/binder/MemoryDealer.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "MemoryDealer"
+#define LOG_TAG "libbinder.MemoryDealer"
 
 #include <binder/MemoryDealer.h>
 #include <binder/IPCThreadState.h>
@@ -374,6 +374,7 @@ ssize_t SimpleBestFitAllocator::alloc(size_t size, uint32_t flags)
         }
         return (free_chunk->start)*kMemoryAlign;
     }
+    ALOGE("%s: no free chunk", __FUNCTION__);
     return NO_MEMORY;
 }
 
diff --git a/libs/binder/MemoryHeapBase.cpp b/libs/binder/MemoryHeapBase.cpp
index fc273e0367..4a280a9f85 100644
--- a/libs/binder/MemoryHeapBase.cpp
+++ b/libs/binder/MemoryHeapBase.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "MemoryHeapBase"
+#define LOG_TAG "libbinder.MemoryHeapBase"
 
 #include <errno.h>
 #include <fcntl.h>
diff --git a/libs/binder/OS_unix_base.cpp b/libs/binder/OS_unix_base.cpp
index ca998d46d3..790e04ce2c 100644
--- a/libs/binder/OS_unix_base.cpp
+++ b/libs/binder/OS_unix_base.cpp
@@ -101,7 +101,7 @@ ssize_t sendMessageOnSocket(const RpcTransportFd& socket, iovec* iovs, int niovs
         memcpy(CMSG_DATA(cmsg), fds, fdsByteSize);
 
         msg.msg_controllen = CMSG_SPACE(fdsByteSize);
-        return TEMP_FAILURE_RETRY(sendmsg(socket.fd.get(), &msg, MSG_NOSIGNAL | MSG_CMSG_CLOEXEC));
+        return TEMP_FAILURE_RETRY(sendmsg(socket.fd.get(), &msg, MSG_NOSIGNAL));
     }
 
     msghdr msg{
@@ -125,7 +125,8 @@ ssize_t receiveMessageFromSocket(const RpcTransportFd& socket, iovec* iovs, int
                 .msg_control = msgControlBuf,
                 .msg_controllen = sizeof(msgControlBuf),
         };
-        ssize_t processSize = TEMP_FAILURE_RETRY(recvmsg(socket.fd.get(), &msg, MSG_NOSIGNAL));
+        ssize_t processSize =
+                TEMP_FAILURE_RETRY(recvmsg(socket.fd.get(), &msg, MSG_NOSIGNAL | MSG_CMSG_CLOEXEC));
         if (processSize < 0) {
             return -1;
         }
diff --git a/libs/binder/OWNERS b/libs/binder/OWNERS
index a70b55826f..8cc5408299 100644
--- a/libs/binder/OWNERS
+++ b/libs/binder/OWNERS
@@ -1,5 +1,8 @@
 # Bug component: 32456
 
 smoreland@google.com
+devinmoore@google.com
+fmayle@google.com
+
 tkjos@google.com # kernel
 maco@google.com # historical
diff --git a/libs/binder/Parcel.cpp b/libs/binder/Parcel.cpp
index 2c37624304..eba10c1432 100644
--- a/libs/binder/Parcel.cpp
+++ b/libs/binder/Parcel.cpp
@@ -14,14 +14,13 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "Parcel"
+#define LOG_TAG "libbinder.Parcel"
 //#define LOG_NDEBUG 0
 
 #include <endian.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <inttypes.h>
-#include <pthread.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -542,6 +541,11 @@ status_t Parcel::appendFrom(const Parcel* parcel, size_t offset, size_t len) {
         return BAD_VALUE;
     }
 
+    // Make sure we aren't appending over objects.
+    if (status_t status = validateReadData(mDataPos + len); status != OK) {
+        return status;
+    }
+
     if ((mDataPos + len) > mDataCapacity) {
         // grow data
         err = growData(len);
@@ -565,27 +569,37 @@ status_t Parcel::appendFrom(const Parcel* parcel, size_t offset, size_t len) {
         const binder_size_t* objects = otherKernelFields->mObjects;
         size_t size = otherKernelFields->mObjectsSize;
         // Count objects in range
-        int firstIndex = -1, lastIndex = -2;
+        int numObjects = 0;
         for (int i = 0; i < (int)size; i++) {
-            size_t off = objects[i];
-            if ((off >= offset) && (off + sizeof(flat_binder_object) <= offset + len)) {
-                if (firstIndex == -1) {
-                    firstIndex = i;
-                }
-                lastIndex = i;
+            size_t pos = objects[i];
+            if ((pos >= offset) && (pos + sizeof(flat_binder_object) <= offset + len)) {
+                numObjects++;
             }
         }
-        int numObjects = lastIndex - firstIndex + 1;
         if (numObjects > 0) {
             const sp<ProcessState> proc(ProcessState::self());
             // grow objects
             if (kernelFields->mObjectsCapacity < kernelFields->mObjectsSize + numObjects) {
-                if ((size_t)numObjects > SIZE_MAX - kernelFields->mObjectsSize)
-                    return NO_MEMORY; // overflow
-                if (kernelFields->mObjectsSize + numObjects > SIZE_MAX / 3)
+                if ((size_t)numObjects > SIZE_MAX - kernelFields->mObjectsSize) {
+                    ALOGE("%s: binder objects buffer overflow (newObjects: %d, currentObjects: "
+                          "%zu) - max size reached",
+                          __FUNCTION__, numObjects, kernelFields->mObjectsSize);
+                    return NO_MEMORY; // overflosw
+                }
+                if (kernelFields->mObjectsSize + numObjects > SIZE_MAX / 3) {
+                    ALOGE("%s: cannot realloc to handle additional binder objects (newObjects: %d, "
+                          "currentObjects: %zu) - overflow",
+                          __FUNCTION__, numObjects, kernelFields->mObjectsSize);
                     return NO_MEMORY; // overflow
+                }
                 size_t newSize = ((kernelFields->mObjectsSize + numObjects) * 3) / 2;
-                if (newSize > SIZE_MAX / sizeof(binder_size_t)) return NO_MEMORY; // overflow
+                if (newSize > SIZE_MAX / sizeof(binder_size_t)) {
+                    ALOGE("%s: cannot realloc to handle additional binder objects for new size "
+                          "(newObjects: %d currentObjects: %zu) - "
+                          "overflow",
+                          __FUNCTION__, numObjects, kernelFields->mObjectsSize);
+                    return NO_MEMORY; // overflow
+                }
                 binder_size_t* objects = (binder_size_t*)realloc(kernelFields->mObjects,
                                                                  newSize * sizeof(binder_size_t));
                 if (objects == (binder_size_t*)nullptr) {
@@ -597,8 +611,12 @@ status_t Parcel::appendFrom(const Parcel* parcel, size_t offset, size_t len) {
 
             // append and acquire objects
             int idx = kernelFields->mObjectsSize;
-            for (int i = firstIndex; i <= lastIndex; i++) {
-                size_t off = objects[i] - offset + startPos;
+            for (int i = 0; i < (int)size; i++) {
+                size_t pos = objects[i];
+                if (!(pos >= offset) || !(pos + sizeof(flat_binder_object) <= offset + len)) {
+                    continue;
+                }
+                size_t off = pos - offset + startPos;
                 kernelFields->mObjects[idx++] = off;
                 kernelFields->mObjectsSize++;
 
@@ -618,6 +636,9 @@ status_t Parcel::appendFrom(const Parcel* parcel, size_t offset, size_t len) {
 
                 acquire_object(proc, *flat, this, true /*tagFds*/);
             }
+            // Always clear sorted flag. It is tricky to infer if the append
+            // result maintains the sort or not.
+            kernelFields->mObjectsSorted = false;
         }
 #else
         LOG_ALWAYS_FATAL("Binder kernel driver disabled at build time");
@@ -649,7 +670,10 @@ status_t Parcel::appendFrom(const Parcel* parcel, size_t offset, size_t len) {
             const binder_size_t objPos = otherRpcFields->mObjectPositions[i];
             if (offset <= objPos && objPos < offset + len) {
                 size_t newDataPos = objPos - offset + startPos;
-                rpcFields->mObjectPositions.push_back(newDataPos);
+                rpcFields->mObjectPositions
+                        .insert(std::upper_bound(rpcFields->mObjectPositions.begin(),
+                                                 rpcFields->mObjectPositions.end(), newDataPos),
+                                newDataPos);
 
                 mDataPos = newDataPos;
                 int32_t objectType;
@@ -1151,14 +1175,12 @@ status_t Parcel::finishWrite(size_t len)
         return BAD_VALUE;
     }
 
-    //printf("Finish write of %d\n", len);
     mDataPos += len;
     ALOGV("finishWrite Setting data pos of %p to %zu", this, mDataPos);
     if (mDataPos > mDataSize) {
         mDataSize = mDataPos;
         ALOGV("finishWrite Setting data size of %p to %zu", this, mDataSize);
     }
-    //printf("New pos=%d, size=%d\n", mDataPos, mDataSize);
     return NO_ERROR;
 }
 
@@ -1183,6 +1205,7 @@ void* Parcel::writeInplace(size_t len)
     if (len > INT32_MAX) {
         // don't accept size_t values which may have come from an
         // inadvertent conversion from a negative int.
+        ALOGI("%s: len %zu exceeds INT32_MAX (%d)", __FUNCTION__, len, INT32_MAX);
         return nullptr;
     }
 
@@ -1190,6 +1213,7 @@ void* Parcel::writeInplace(size_t len)
 
     // check for integer overflow
     if (mDataPos+padded < mDataPos) {
+        ALOGI("%s: integer overflow (mDataPos: %zu padded: %zu)", __FUNCTION__, mDataPos, padded);
         return nullptr;
     }
 
@@ -1199,6 +1223,7 @@ restart_write:
         uint8_t* const data = mData+mDataPos;
 
         if (status_t status = validateReadData(mDataPos + padded); status != OK) {
+            ALOGI("%s: validateReadData failed", __FUNCTION__);
             return nullptr; // drops status
         }
 
@@ -1586,6 +1611,7 @@ status_t Parcel::writeFileDescriptor(int fd, bool takeOwnership) {
                 }
                 size_t dataPos = mDataPos;
                 if (dataPos > UINT32_MAX) {
+                    ALOGE("%s: dataPos %zu larger than MAX %u", __FUNCTION__, dataPos, UINT32_MAX);
                     return NO_MEMORY;
                 }
                 if (status_t err = writeInt32(RpcFields::TYPE_NATIVE_FILE_DESCRIPTOR); err != OK) {
@@ -1594,7 +1620,10 @@ status_t Parcel::writeFileDescriptor(int fd, bool takeOwnership) {
                 if (status_t err = writeInt32(rpcFields->mFds->size()); err != OK) {
                     return err;
                 }
-                rpcFields->mObjectPositions.push_back(dataPos);
+                rpcFields->mObjectPositions
+                        .insert(std::upper_bound(rpcFields->mObjectPositions.begin(),
+                                                 rpcFields->mObjectPositions.end(), dataPos),
+                                dataPos);
                 rpcFields->mFds->push_back(std::move(fdVariant));
                 return OK;
             }
@@ -1682,7 +1711,10 @@ status_t Parcel::writeBlob(size_t len, bool mutableCopy, WritableBlob* outBlob)
 
     ALOGV("writeBlob: write to ashmem");
     int fd = ashmem_create_region("Parcel Blob", len);
-    if (fd < 0) return NO_MEMORY;
+    if (fd < 0) {
+        ALOGE("%s: failed to create ashmem", __FUNCTION__);
+        return NO_MEMORY;
+    }
 
     int result = ashmem_set_prot_region(fd, PROT_READ | PROT_WRITE);
     if (result < 0) {
@@ -1802,6 +1834,8 @@ restart_write:
             kernelFields->mObjects[kernelFields->mObjectsSize] = mDataPos;
             acquire_object(ProcessState::self(), val, this, true /*tagFds*/);
             kernelFields->mObjectsSize++;
+            // Clear sorted flag if we aren't appending to the end.
+            kernelFields->mObjectsSorted &= mDataPos == mDataSize;
         }
 
         return finishWrite(sizeof(flat_binder_object));
@@ -1821,10 +1855,23 @@ restart_write:
         if (err != NO_ERROR) return err;
     }
     if (!enoughObjects) {
-        if (kernelFields->mObjectsSize > SIZE_MAX - 2) return NO_MEMORY;       // overflow
-        if ((kernelFields->mObjectsSize + 2) > SIZE_MAX / 3) return NO_MEMORY; // overflow
+        if (kernelFields->mObjectsSize > SIZE_MAX - 2) {
+            ALOGE("%s: kernel binder objects overflow (objectsSize: %zu)", __FUNCTION__,
+                  kernelFields->mObjectsSize);
+            return NO_MEMORY; // overflow
+        }
+        if ((kernelFields->mObjectsSize + 2) > SIZE_MAX / 3) {
+            ALOGE("%s: cannot resize to handle additional kernel binder objects (objectsSize: %zu)",
+                  __FUNCTION__, kernelFields->mObjectsSize);
+            return NO_MEMORY; // overflow
+        }
         size_t newSize = ((kernelFields->mObjectsSize + 2) * 3) / 2;
-        if (newSize > SIZE_MAX / sizeof(binder_size_t)) return NO_MEMORY; // overflow
+        if (newSize > SIZE_MAX / sizeof(binder_size_t)) {
+            ALOGE("%s: cannot resize to handle additional kernel binder objects with new size "
+                  "(objectsSize: %zu)",
+                  __FUNCTION__, newSize);
+            return NO_MEMORY; // overflow
+        }
         binder_size_t* objects =
                 (binder_size_t*)realloc(kernelFields->mObjects, newSize * sizeof(binder_size_t));
         if (objects == nullptr) return NO_MEMORY;
@@ -1987,13 +2034,18 @@ status_t Parcel::readOutVectorSizeWithCheck(size_t elmSize, int32_t* size) const
     // allocations)
     static_assert(sizeof(int) == sizeof(int32_t), "Android is LP64");
     int32_t allocationSize;
-    if (__builtin_smul_overflow(elmSize, *size, &allocationSize)) return NO_MEMORY;
+    if (__builtin_smul_overflow(elmSize, *size, &allocationSize)) {
+        ALOGE("%s: smul_overflow failed (elmSize: %zu, size: %d)", __FUNCTION__, elmSize, *size);
+        return NO_MEMORY;
+    }
 
     // High limit of 1MB since something this big could never be returned. Could
     // probably scope this down, but might impact very specific usecases.
     constexpr int32_t kMaxAllocationSize = 1 * 1000 * 1000;
 
     if (allocationSize >= kMaxAllocationSize) {
+        ALOGE("%s: allocation size %d larger than max allowed %d", __FUNCTION__, allocationSize,
+              kMaxAllocationSize);
         return NO_MEMORY;
     }
 
@@ -2550,7 +2602,10 @@ status_t Parcel::readBlob(size_t len, ReadableBlob* outBlob) const
     }
     void* ptr = ::mmap(nullptr, len, isMutable ? PROT_READ | PROT_WRITE : PROT_READ,
             MAP_SHARED, fd, 0);
-    if (ptr == MAP_FAILED) return NO_MEMORY;
+    if (ptr == MAP_FAILED) {
+        ALOGE("%s: mmap failed", __FUNCTION__);
+        return NO_MEMORY;
+    }
 
     outBlob->init(fd, ptr, len, isMutable);
     return NO_ERROR;
@@ -3024,9 +3079,22 @@ status_t Parcel::growData(size_t len)
         return BAD_VALUE;
     }
 
-    if (len > SIZE_MAX - mDataSize) return NO_MEMORY; // overflow
-    if (mDataSize + len > SIZE_MAX / 3) return NO_MEMORY; // overflow
+    if (len > SIZE_MAX - mDataSize) {
+        ALOGE("%s: attempt to grow data past the max size (len: %zu mDataSize: %zu)", __FUNCTION__,
+              len, mDataSize);
+        return NO_MEMORY; // overflow
+    }
+    if (mDataSize + len > SIZE_MAX / 3) {
+        ALOGE("%s: cannot resize to grow data (len: %zu, mDataSize: %zu)", __FUNCTION__, len,
+              mDataSize);
+        return NO_MEMORY; // overflow
+    }
     size_t newSize = ((mDataSize+len)*3)/2;
+    if (newSize <= mDataSize) {
+        ALOGE("%s: cannot resize to grow data even with newSize: %zu (mDataSize: %zu)",
+              __FUNCTION__, newSize, mDataSize);
+    }
+
     return (newSize <= mDataSize)
             ? (status_t) NO_MEMORY
             : continueWrite(std::max(newSize, (size_t) 128));
@@ -3064,7 +3132,8 @@ status_t Parcel::restartWrite(size_t desired)
 
     uint8_t* data = reallocZeroFree(mData, mDataCapacity, desired, mDeallocZero);
     if (!data && desired > mDataCapacity) {
-        LOG_ALWAYS_FATAL("out of memory");
+        LOG_ALWAYS_FATAL("%s: realloc failed as desired size %zu is larger than capacity %zu", __FUNCTION__,
+              desired, mDataCapacity);
         mError = NO_MEMORY;
         return NO_MEMORY;
     }
diff --git a/libs/binder/PermissionCache.cpp b/libs/binder/PermissionCache.cpp
index 658686d2db..69cee1a1f9 100644
--- a/libs/binder/PermissionCache.cpp
+++ b/libs/binder/PermissionCache.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "PermissionCache"
+#define LOG_TAG "libbinder.PermissionCache"
 
 #include <stdint.h>
 #include <utils/Log.h>
diff --git a/libs/binder/PersistableBundle.cpp b/libs/binder/PersistableBundle.cpp
index 99f9726c5e..7641b444b0 100644
--- a/libs/binder/PersistableBundle.cpp
+++ b/libs/binder/PersistableBundle.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "PersistableBundle"
+#define LOG_TAG "libbinder.PersistableBundle"
 
 #include <binder/PersistableBundle.h>
 
diff --git a/libs/binder/ProcessState.cpp b/libs/binder/ProcessState.cpp
index 0bec37999b..c4a54c96fd 100644
--- a/libs/binder/ProcessState.cpp
+++ b/libs/binder/ProcessState.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "ProcessState"
+#define LOG_TAG "libbinder.ProcessState"
 
 #include <binder/ProcessState.h>
 
@@ -28,6 +28,7 @@
 #include <utils/String8.h>
 #include <utils/Thread.h>
 
+#include "BinderObserver.h"
 #include "Static.h"
 #include "Utils.h"
 #include "binder_module.h"
@@ -117,6 +118,11 @@ sp<ProcessState> ProcessState::selfOrNull()
     return init(nullptr, false /*requireDefault*/);
 }
 
+sp<ProcessState> ProcessState::selfIfKernelBinderEnabled() {
+    if (access(kDefaultDriver, R_OK) == -1) return nullptr;
+    return init(kDefaultDriver, false /*requireDefault*/);
+}
+
 [[clang::no_destroy]] static sp<ProcessState> gProcess;
 [[clang::no_destroy]] static std::mutex gProcessMutex;
 
@@ -621,11 +627,19 @@ ProcessState::ProcessState(const char* driver)
     LOG_ALWAYS_FATAL_IF(!opened.ok(),
                         "Binder driver '%s' could not be opened. Error: %s. Terminating.",
                         driver, error.c_str());
+#else
+    if (!opened.ok()) {
+        ALOGE("Binder driver '%s' could not be opened. Error: %s. There may be future issues.",
+              driver, error.c_str());
+    }
 #endif
 
     if (opened.ok()) {
         mDriverFD = opened.release();
     }
+#ifdef BINDER_WITH_OBSERVERS
+    mBinderObserver = std::make_unique<BinderObserver>();
+#endif
 }
 
 ProcessState::~ProcessState()
diff --git a/libs/binder/RpcServer.cpp b/libs/binder/RpcServer.cpp
index c7851dc3fb..348fecfc20 100644
--- a/libs/binder/RpcServer.cpp
+++ b/libs/binder/RpcServer.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "RpcServer"
+#define LOG_TAG "libbinder.RpcServer"
 
 #include <inttypes.h>
 #include <netinet/tcp.h>
@@ -340,7 +340,7 @@ bool RpcServer::shutdown() {
     }
 
     while (mJoinThreadRunning || !mConnectingThreads.empty() || !mSessions.empty()) {
-        if (std::cv_status::timeout == mShutdownCv.wait_for(_l, std::chrono::seconds(1))) {
+        if (mShutdownCv.wait_for(_l, std::chrono::seconds(1)) == RpcCvStatus::timeout) {
             ALOGE("Waiting for RpcServer to shut down (1s w/o progress). Join thread running: %d, "
                   "Connecting threads: "
                   "%zu, Sessions: %zu. Is your server deadlocked?",
@@ -535,11 +535,7 @@ void RpcServer::establishConnection(
                 }
             }
 
-            if (!session->setForServer(server,
-                                       sp<RpcServer::EventListener>::fromExisting(
-                                               static_cast<RpcServer::EventListener*>(
-                                                       server.get())),
-                                       sessionId, sessionSpecificRoot)) {
+            if (!session->setForServer(server, server, sessionId, sessionSpecificRoot)) {
                 ALOGE("Failed to attach server to session");
                 return;
             }
diff --git a/libs/binder/RpcSession.cpp b/libs/binder/RpcSession.cpp
index 1f3a45a6df..bfc94ce366 100644
--- a/libs/binder/RpcSession.cpp
+++ b/libs/binder/RpcSession.cpp
@@ -14,11 +14,10 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "RpcSession"
+#define LOG_TAG "libbinder.RpcSession"
 
 #include <binder/RpcSession.h>
 
-#include <dlfcn.h>
 #include <inttypes.h>
 #include <netinet/tcp.h>
 #include <poll.h>
@@ -36,6 +35,9 @@
 
 #include "BuildFlags.h"
 #include "FdTrigger.h"
+#if defined(__ANDROID__) && !defined(__ANDROID_RECOVERY__)
+#include "JvmUtils.h"
+#endif
 #include "OS.h"
 #include "RpcSocketAddress.h"
 #include "RpcState.h"
@@ -43,11 +45,6 @@
 #include "RpcWireFormat.h"
 #include "Utils.h"
 
-#if defined(__ANDROID__) && !defined(__ANDROID_RECOVERY__)
-#include <jni.h>
-extern "C" JavaVM* AndroidRuntimeGetJavaVM();
-#endif
-
 namespace android {
 
 using namespace android::binder::impl;
@@ -324,7 +321,7 @@ void RpcSession::WaitForShutdownListener::onSessionIncomingThreadEnded() {
 void RpcSession::WaitForShutdownListener::waitForShutdown(RpcMutexUniqueLock& lock,
                                                           const sp<RpcSession>& session) {
     while (mShutdownCount < session->mConnections.mMaxIncoming) {
-        if (std::cv_status::timeout == mCv.wait_for(lock, std::chrono::seconds(1))) {
+        if (mCv.wait_for(lock, std::chrono::seconds(1)) == RpcCvStatus::timeout) {
             ALOGE("Waiting for RpcSession to shut down (1s w/o progress): %zu incoming connections "
                   "still %zu/%zu fully shutdown.",
                   session->mConnections.mIncoming.size(), mShutdownCount.load(),
@@ -414,13 +411,6 @@ private:
     void operator=(const JavaThreadAttacher&) = delete;
 
     bool mAttached = false;
-
-    static JavaVM* getJavaVM() {
-        static auto fn = reinterpret_cast<decltype(&AndroidRuntimeGetJavaVM)>(
-                dlsym(RTLD_DEFAULT, "AndroidRuntimeGetJavaVM"));
-        if (fn == nullptr) return nullptr;
-        return fn();
-    }
 };
 #endif
 } // namespace
@@ -441,8 +431,9 @@ void RpcSession::join(sp<RpcSession>&& session, PreJoinSetupResult&& setupResult
             }
         }
     } else {
-        ALOGE("Connection failed to init, closing with status %s",
+        ALOGE("Connection failed to init, closing with status %s. Terminating!",
               statusToString(setupResult.status).c_str());
+        (void)session->shutdownAndWait(false);
     }
 
     sp<RpcSession::EventListener> listener;
@@ -462,6 +453,12 @@ void RpcSession::join(sp<RpcSession>&& session, PreJoinSetupResult&& setupResult
                             "bad state: connection object guaranteed to be in list");
     }
 
+    // If you are hitting this, it's likely because whatever caused the thread to exit
+    // in getAndExecuteCommand did not terminate the thread. We abort here, to make
+    // this discoverable instead of potentially causing a deadlock.
+    LOG_ALWAYS_FATAL_IF(!session->mShutdownTrigger->isTriggered(),
+                        "If a thread exits, we only support shutting down the entire RpcSession.");
+
     session = nullptr;
 
     if (listener != nullptr) {
diff --git a/libs/binder/RpcState.cpp b/libs/binder/RpcState.cpp
index 03d974d186..1653cfd91d 100644
--- a/libs/binder/RpcState.cpp
+++ b/libs/binder/RpcState.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "RpcState"
+#define LOG_TAG "libbinder.RpcState"
 
 #include "RpcState.h"
 
@@ -25,6 +25,7 @@
 
 #include "Constants.h"
 #include "Debug.h"
+#include "FdTrigger.h"
 #include "RpcWireFormat.h"
 #include "Utils.h"
 
@@ -44,7 +45,7 @@ using android::binder::borrowed_fd;
 using android::binder::unique_fd;
 
 #if RPC_FLAKE_PRONE
-void rpcMaybeWaitToFlake() {
+static unsigned rpcFlakeUnsigned() {
     [[clang::no_destroy]] static std::random_device r;
     [[clang::no_destroy]] static RpcMutex m;
     unsigned num;
@@ -52,6 +53,14 @@ void rpcMaybeWaitToFlake() {
         RpcMutexLockGuard lock(m);
         num = r();
     }
+    return num;
+}
+bool rpcMaybeFlake() {
+    return rpcFlakeUnsigned() % 10 == 0; // flake 10%
+    // return rpcFlakeUnsigned() % 4 != 0; // flake 75%
+}
+void rpcMaybeWaitToFlake() {
+    unsigned num = rpcFlakeUnsigned();
     if (num % 10 == 0) usleep(num % 1000);
 }
 #endif
@@ -121,6 +130,7 @@ status_t RpcState::onBinderLeaving(const sp<RpcSession>& session, const sp<IBind
     // arbitrary limit for maximum number of nodes in a process (otherwise we
     // might run out of addresses)
     if (mNodeForAddress.size() > 100000) {
+        ALOGE("%s: too many nodes in the process (%zu)", __FUNCTION__, mNodeForAddress.size());
         return NO_MEMORY;
     }
 
@@ -357,9 +367,43 @@ RpcState::CommandData::CommandData(size_t size) : mSize(size) {
     } else if (size > binder::kLogTransactionsOverBytes) {
         ALOGW("Transaction too large: inefficient and in danger of breaking: %zu bytes.", size);
     }
-    mData.reset(new (std::nothrow) uint8_t[size]);
+
+    // must always be written over
+    uint8_t* data = new (std::nothrow) uint8_t[size];
+
+    if (!data) {
+        // For helping debug b/404210068. If we are running out of memory,
+        // then, as Android is today, it's going down no matter what we do.
+        // However, if we can get data out of this process, go ahead and log
+        // to help us debug this bug.
+        ALOGE("Failed to allocate %zu data.", size);
+    }
+
+    mData.reset(data);
+}
+
+// all transport errors should pass through here
+static inline status_t handleRpcError(const std::unique_ptr<RpcTransport>& transport,
+                                      const sp<RpcSession>& session, status_t status,
+                                      const char* stateContext, const char* what, int niovs) {
+    if (status == DEAD_OBJECT || status == -ECONNRESET) {
+        LOG_RPC_DETAIL("Failed to %s %s (%d iovs) on RpcTransport %p, error: %s", stateContext,
+                       what, niovs, transport.get(), statusToString(status).c_str());
+    } else {
+        ALOGE("Failed to %s %s (%d iovs) on RpcTransport %p, error: %s", stateContext, what, niovs,
+              transport.get(), statusToString(status).c_str());
+    }
+    (void)session->shutdownAndWait(false);
+
+    if (status == -ECONNRESET) {
+        LOG_RPC_DETAIL("Converting -ECONNRESET to DEAD_OBJECT.");
+        status = DEAD_OBJECT;
+    }
+
+    return status;
 }
 
+// MUST ALWAYS SHUTDOWN ON ERROR, DUE TO CALLER CONSTRAITS
 status_t RpcState::rpcSend(const sp<RpcSession::RpcConnection>& connection,
                            const sp<RpcSession>& session, const char* what, iovec* iovs, int niovs,
                            const std::optional<SmallFunction<status_t()>>& altPoll,
@@ -375,15 +419,13 @@ status_t RpcState::rpcSend(const sp<RpcSession::RpcConnection>& connection,
                                                                   iovs, niovs, altPoll,
                                                                   ancillaryFds);
         status != OK) {
-        LOG_RPC_DETAIL("Failed to write %s (%d iovs) on RpcTransport %p, error: %s", what, niovs,
-                       connection->rpcTransport.get(), statusToString(status).c_str());
-        (void)session->shutdownAndWait(false);
-        return status;
+        return handleRpcError(connection->rpcTransport, session, status, "write", what, niovs);
     }
 
     return OK;
 }
 
+// MUST ALWAYS SHUTDOWN ON ERROR, DUE TO CALLER CONSTRAITS
 status_t RpcState::rpcRec(const sp<RpcSession::RpcConnection>& connection,
                           const sp<RpcSession>& session, const char* what, iovec* iovs, int niovs,
                           std::vector<std::variant<unique_fd, borrowed_fd>>* ancillaryFds) {
@@ -392,10 +434,7 @@ status_t RpcState::rpcRec(const sp<RpcSession::RpcConnection>& connection,
                                                                  iovs, niovs, std::nullopt,
                                                                  ancillaryFds);
         status != OK) {
-        LOG_RPC_DETAIL("Failed to read %s (%d iovs) on RpcTransport %p, error: %s", what, niovs,
-                       connection->rpcTransport.get(), statusToString(status).c_str());
-        (void)session->shutdownAndWait(false);
-        return status;
+        return handleRpcError(connection->rpcTransport, session, status, "read", what, niovs);
     }
 
     for (int i = 0; i < niovs; i++) {
@@ -537,7 +576,16 @@ status_t RpcState::transact(const sp<RpcSession::RpcConnection>& connection,
     uint64_t address;
     if (status_t status = onBinderLeaving(session, binder, &address); status != OK) return status;
 
-    return transactAddress(connection, address, code, data, session, reply, flags);
+    if (status_t status = transactAddress(connection, address, code, data, session, reply, flags);
+        status != OK) {
+        // TODO(b/414720799): this log is added to debug this bug, but it could be a bit noisy, and
+        // we may only want to log it from some cases moving forward.
+        ALOGE("RPC protocol error during call to binder: %p code: %" PRIu32 " transaction: %s",
+              binder.get(), code, statusToString(status).c_str());
+        return status;
+    }
+
+    return OK;
 }
 
 status_t RpcState::transactAddress(const sp<RpcSession::RpcConnection>& connection,
@@ -546,6 +594,11 @@ status_t RpcState::transactAddress(const sp<RpcSession::RpcConnection>& connecti
     LOG_ALWAYS_FATAL_IF(!data.isForRpc());
     LOG_ALWAYS_FATAL_IF(data.objectsCount() != 0);
 
+    if (!(flags & IBinder::FLAG_ONEWAY)) {
+        LOG_ALWAYS_FATAL_IF(reply == nullptr,
+                            "Reply parcel must be used for synchronous transaction.");
+    }
+
     uint64_t asyncNumber = 0;
 
     if (address != 0) {
@@ -637,8 +690,8 @@ status_t RpcState::transactAddress(const sp<RpcSession::RpcConnection>& connecti
         return OK;
     }
 
-    LOG_ALWAYS_FATAL_IF(reply == nullptr, "Reply parcel must be used for synchronous transaction.");
-
+    // b/416734088
+    // NOW THAT WE'VE SENT TRANSACTION, WE MUST READ FULL RESULT FOR PROTOCOL TO BE IN SYNC
     return waitForReply(connection, session, reply);
 }
 
@@ -661,14 +714,14 @@ status_t RpcState::waitForReply(const sp<RpcSession::RpcConnection>& connection,
                                              ? &ancillaryFds
                                              : nullptr);
             status != OK)
-            return status;
+            return status; // rpcRec failure calls shutdown
 
         if (command.command == RPC_COMMAND_REPLY) break;
 
         if (status_t status = processCommand(connection, session, command, CommandType::ANY,
                                              std::move(ancillaryFds));
             status != OK)
-            return status;
+            return status; // processCommand must shutdown on failure
 
         // Reset to avoid spurious use-after-move warning from clang-tidy.
         ancillaryFds = decltype(ancillaryFds)();
@@ -687,15 +740,25 @@ status_t RpcState::waitForReply(const sp<RpcSession::RpcConnection>& connection,
     memset(&rpcReply, 0, sizeof(RpcWireReply)); // zero because of potential short read
 
     CommandData data(command.bodySize - rpcReplyWireSize);
-    if (!data.valid()) return NO_MEMORY;
+    if (!data.valid()) {
+        // b/404210068 - if we run out of memory, the wire protocol gets messed up.
+        // so shutdown. We would need to read all the transaction data anyway and
+        // send a reply still to gracefully recover.
+        (void)session->shutdownAndWait(false);
+        return NO_MEMORY;
+    }
 
     iovec iovs[]{
             {&rpcReply, rpcReplyWireSize},
             {data.data(), data.size()},
     };
     if (status_t status = rpcRec(connection, session, "reply body", iovs, countof(iovs), nullptr);
-        status != OK)
+        status != OK) {
+        // rpcRec shuts down connection on failure
         return status;
+    }
+
+    // NOW THAT WE'VE READ RESPONSE, WE CAN RETURN WITHOUT SHUTTING DOWN THE CONNECTION.
 
     if (rpcReply.status != OK) return rpcReply.status;
 
@@ -718,6 +781,7 @@ status_t RpcState::waitForReply(const sp<RpcSession::RpcConnection>& connection,
                   " sizeofHeader=%zu parcelSize=%" PRId32 " objectTableBytesSize=%zu. Terminating!",
                   command.bodySize, rpcReplyWireSize, rpcReply.parcelDataSize,
                   objectTableBytes->size);
+            (void)session->shutdownAndWait(false);
             return BAD_VALUE;
         }
         objectTableSpan = *maybeSpan;
@@ -777,9 +841,13 @@ status_t RpcState::getAndExecuteCommand(const sp<RpcSession::RpcConnection>& con
                 rpcRec(connection, session, "command header (for server)", &iov, 1,
                        enableAncillaryFds(session->getFileDescriptorTransportMode()) ? &ancillaryFds
                                                                                      : nullptr);
-        status != OK)
+        status != OK) {
         return status;
+    }
 
+    // b/416734088
+    // NOW THAT WE'VE READ HEADER WE MUST READ THE REST AND WRITE FULL RESPONSE, OR OTHERWISE
+    // SHUTDOWN THE SERVICE
     return processCommand(connection, session, command, type, std::move(ancillaryFds));
 }
 
@@ -796,6 +864,9 @@ status_t RpcState::drainCommands(const sp<RpcSession::RpcConnection>& connection
     return OK;
 }
 
+// THIS FUNCTION MUST SHUTDOWN IF IT ERRORS, ACCORDING TO waitForReply.
+// THIS FUNCTION MUST ALWAYS READ THE FULL COMMAND, ACCORDING TO getAndExecuteCommand and
+// waitForReply.
 status_t RpcState::processCommand(
         const sp<RpcSession::RpcConnection>& connection, const sp<RpcSession>& session,
         const RpcWireHeader& command, CommandType type,
@@ -819,23 +890,40 @@ status_t RpcState::processCommand(
     });
 #endif // BINDER_WITH_KERNEL_IPC
 
+    status_t result = NO_INIT;
+
     switch (command.command) {
         case RPC_COMMAND_TRANSACT:
             if (type != CommandType::ANY) return BAD_TYPE;
-            return processTransact(connection, session, command, std::move(ancillaryFds));
+            result = processTransact(connection, session, command, std::move(ancillaryFds));
+            break;
         case RPC_COMMAND_DEC_STRONG:
-            return processDecStrong(connection, session, command);
+            result = processDecStrong(connection, session, command);
+            break;
+        default:
+            // We should always know the version of the opposing side, and since the
+            // RPC-binder-level wire protocol is not self synchronizing, we have no way
+            // to understand where the current command ends and the next one begins. We
+            // also can't consider it a fatal error because this would allow any client
+            // to kill us, so ending the session for misbehaving client.
+            ALOGE("Unknown RPC command %d - terminating session. Header: %s. CommandType: %d. "
+                  "numFds: %zu",
+                  command.command, HexString(&command, sizeof(command)).c_str(),
+                  static_cast<int>(type), ancillaryFds.size());
+            (void)session->shutdownAndWait(false);
+            return DEAD_OBJECT;
     }
 
-    // We should always know the version of the opposing side, and since the
-    // RPC-binder-level wire protocol is not self synchronizing, we have no way
-    // to understand where the current command ends and the next one begins. We
-    // also can't consider it a fatal error because this would allow any client
-    // to kill us, so ending the session for misbehaving client.
-    ALOGE("Unknown RPC command %d - terminating session", command.command);
-    (void)session->shutdownAndWait(false);
-    return DEAD_OBJECT;
+    if (result != OK) {
+        LOG_ALWAYS_FATAL_IF(!session->mShutdownTrigger->isTriggered(),
+                            "Error during processing command must trigger shutdown! %s",
+                            statusToString(result).c_str());
+    }
+    return result;
 }
+
+// THIS FUNCTION MUST SHUTDOWN IF IT ERRORS, ACCORDING TO processCommand.
+// THIS FUNCTION MUST ALWAYS READ THE FULL COMMAND, ACCORDING TO processCommand.
 status_t RpcState::processTransact(
         const sp<RpcSession::RpcConnection>& connection, const sp<RpcSession>& session,
         const RpcWireHeader& command,
@@ -844,13 +932,21 @@ status_t RpcState::processTransact(
 
     CommandData transactionData(command.bodySize);
     if (!transactionData.valid()) {
+        // b/404210068 - if we run out of memory, the wire protocol gets messed up.
+        // so shutdown. We would need to read all the transaction data anyway and
+        // send a reply still to gracefully recover.
+        (void)session->shutdownAndWait(false);
         return NO_MEMORY;
     }
     iovec iov{transactionData.data(), transactionData.size()};
     if (status_t status = rpcRec(connection, session, "transaction body", &iov, 1, nullptr);
-        status != OK)
-        return status;
+        status != OK) {
+        return status; // rpcRec always shuts down on error
+    }
 
+    // ACCORDING TO RPC BINDER PROTOCOL:
+    // - if the transaction is oneway, we must not write a response
+    // - if the transaction is twoway, we must ALWAYS write a response
     return processTransactInternal(connection, session, std::move(transactionData),
                                    std::move(ancillaryFds));
 }
@@ -863,6 +959,11 @@ static void do_nothing_to_transact_data(const uint8_t* data, size_t dataSize,
     (void)objectsCount;
 }
 
+// ACCORDING TO RPC BINDER PROTOCOL:
+// - if the transaction is oneway, we must not write a response
+// - if the transaction is twoway, we must ALWAYS write a response
+// DUE TO CLIENT CONSTRAINTS, WE CANNOT RETURN AN ERROR WITHOUT SHUTTING DOWN THE CONNECTION
+// UNTIL THE FULL RESPONSE HAS BEEN WRITTEN.
 status_t RpcState::processTransactInternal(
         const sp<RpcSession::RpcConnection>& connection, const sp<RpcSession>& session,
         CommandData transactionData,
@@ -919,7 +1020,8 @@ processTransactInternalTailCall:
                 // we need to process some other asynchronous transaction
                 // first
                 it->second.asyncTodo.push(BinderNode::AsyncTodo{
-                        .ref = target,
+                        // checked above
+                        .ref = sp<BBinder>::fromExisting(target->localBinder()),
                         .data = std::move(transactionData),
                         .ancillaryFds = std::move(ancillaryFds),
                         .asyncNumber = transaction->asyncNumber,
@@ -946,6 +1048,8 @@ processTransactInternalTailCall:
                               target.get(), numPending);
                     }
                 }
+
+                // This is a oneway transaction (scheduled later), no response is required.
                 return OK;
             }
         }
@@ -977,6 +1081,7 @@ processTransactInternalTailCall:
                       " objectTableBytesSize=%zu. Terminating!",
                       transactionData.size(), sizeof(RpcWireTransaction),
                       transaction->parcelDataSize, objectTableBytes->size);
+                (void)session->shutdownAndWait(false);
                 return BAD_VALUE;
             }
             objectTableSpan = *maybeSpan;
@@ -1004,6 +1109,8 @@ processTransactInternalTailCall:
                 connection->allowNested = origAllowNested;
             } else {
                 LOG_RPC_DETAIL("Got special transaction %u", transaction->code);
+                LOG_ALWAYS_FATAL_IF(addr != 0,
+                                    "!target && replyStatus == OK should imply addr == 0");
 
                 switch (transaction->code) {
                     case RPC_SPECIAL_TRANSACT_GET_MAX_THREADS: {
@@ -1093,17 +1200,24 @@ processTransactInternalTailCall:
 
         // done processing all the async commands on this binder that we can, so
         // write decstrongs on the binder
-        if (addr != 0 && replyStatus == OK) {
+        if (addr != 0 && target != nullptr) {
             return flushExcessBinderRefs(session, addr, target);
         }
 
         return OK;
     }
 
+    // No refcounts for root object - it's always held. If an error results
+    // in us not having the binder so that we can't flush refs, then there may
+    // be a leak, but the more fundamental problem is the error.
     // Binder refs are flushed for oneway calls only after all calls which are
     // built up are executed. Otherwise, they fill up the binder buffer.
-    if (addr != 0 && replyStatus == OK) {
-        replyStatus = flushExcessBinderRefs(session, addr, target);
+    if (addr != 0 && target != nullptr) {
+        // if this fails, we are broken out of the protocol, so just shutdown. There
+        // is no chance we could write the status to the other side.
+        if (status_t status = flushExcessBinderRefs(session, addr, target); status != OK) {
+            return status;
+        }
     }
 
     std::string errorMsg;
@@ -1112,9 +1226,23 @@ processTransactInternalTailCall:
         // Forward the error to the client of the transaction.
         reply.freeData();
         reply.markForRpc(session);
+
+        if (replyStatus != OK) {
+            ALOGE("Dropping error from transaction (%s) due to more serious error in "
+                  "validateParcel (%s)",
+                  statusToString(replyStatus).c_str(), statusToString(status).c_str());
+        }
         replyStatus = status;
     }
 
+    // b/404210068 - we see this case with no logs in the VM. Make sure we always log in this
+    // case, so if the bug repros again, we prove that there are missing logs. Try the negative
+    // as well to be extra careful. TODO - delete this code anytime in the future.
+    if (replyStatus == NO_MEMORY || replyStatus == ENOMEM) {
+        ALOGE("Replying to transaction code: %" PRIo32 " error: %s.", transaction->code,
+              statusToString(replyStatus).c_str());
+    }
+
     auto* rpcFields = reply.maybeRpcFields();
     LOG_ALWAYS_FATAL_IF(rpcFields == nullptr);
 
@@ -1150,6 +1278,8 @@ processTransactInternalTailCall:
                    rpcFields->mFds.get());
 }
 
+// THIS FUNCTION MUST SHUTDOWN IF IT ERRORS, ACCORDING TO processCommand.
+// THIS FUNCTION MUST ALWAYS READ THE FULL COMMAND, ACCORDING TO processCommand.
 status_t RpcState::processDecStrong(const sp<RpcSession::RpcConnection>& connection,
                                     const sp<RpcSession>& session, const RpcWireHeader& command) {
     LOG_ALWAYS_FATAL_IF(command.command != RPC_COMMAND_DEC_STRONG, "command: %d", command.command);
@@ -1164,15 +1294,23 @@ status_t RpcState::processDecStrong(const sp<RpcSession::RpcConnection>& connect
     RpcDecStrong body;
     iovec iov{&body, sizeof(RpcDecStrong)};
     if (status_t status = rpcRec(connection, session, "dec ref body", &iov, 1, nullptr);
-        status != OK)
-        return status;
+        status != OK) {
+        return status; // rpcRec shutsdown if it fails
+    }
+
+    // AT THIS POINT, WE HAVE READ THE FULL TRANSACTION, SO WE CAN RETURN WITHOUT MESSING
+    // UP THE PROTOCOL
 
     uint64_t addr = RpcWireAddress::toRaw(body.address);
+
     RpcMutexUniqueLock _l(mNodeMutex);
+    if (mTerminated) return DEAD_OBJECT;
+
     auto it = mNodeForAddress.find(addr);
     if (it == mNodeForAddress.end()) {
-        ALOGE("Unknown binder address %" PRIu64 " for dec strong.", addr);
-        return OK;
+        ALOGE("Unknown binder address %" PRIu64 " for dec strong. Terminating!", addr);
+        (void)session->shutdownAndWait(false);
+        return BAD_VALUE;
     }
 
     sp<IBinder> target = it->second.binder.promote();
@@ -1230,36 +1368,18 @@ status_t RpcState::validateParcel(const sp<RpcSession>& session, const Parcel& p
     }
 
     if (rpcFields->mFds && !rpcFields->mFds->empty()) {
-        switch (session->getFileDescriptorTransportMode()) {
-            case RpcSession::FileDescriptorTransportMode::NONE:
-                *errorMsg =
-                        "Parcel has file descriptors, but no file descriptor transport is enabled";
-                return FDS_NOT_ALLOWED;
-            case RpcSession::FileDescriptorTransportMode::UNIX: {
-                constexpr size_t kMaxFdsPerMsg = 253;
-                if (rpcFields->mFds->size() > kMaxFdsPerMsg) {
-                    std::stringstream ss;
-                    ss << "Too many file descriptors in Parcel for unix domain socket: "
-                       << rpcFields->mFds->size() << " (max is " << kMaxFdsPerMsg << ")";
-                    *errorMsg = ss.str();
-                    return BAD_VALUE;
-                }
-                break;
-            }
-            case RpcSession::FileDescriptorTransportMode::TRUSTY: {
-                // Keep this in sync with trusty_ipc.h!!!
-                // We could import that file here on Trusty, but it's not
-                // available on Android
-                constexpr size_t kMaxFdsPerMsg = 8;
-                if (rpcFields->mFds->size() > kMaxFdsPerMsg) {
-                    std::stringstream ss;
-                    ss << "Too many file descriptors in Parcel for Trusty IPC connection: "
-                       << rpcFields->mFds->size() << " (max is " << kMaxFdsPerMsg << ")";
-                    *errorMsg = ss.str();
-                    return BAD_VALUE;
-                }
-                break;
-            }
+        auto fileDescriptorTransportMode = session->getFileDescriptorTransportMode();
+        size_t maxFdsPerMsg = getRpcTransportModeMaxFds(fileDescriptorTransportMode);
+        if (RpcSession::FileDescriptorTransportMode::NONE == fileDescriptorTransportMode) {
+            *errorMsg = "Parcel has file descriptors, but no file descriptor transport is enabled";
+            return FDS_NOT_ALLOWED;
+        }
+        if (rpcFields->mFds->size() > maxFdsPerMsg) {
+            std::stringstream ss;
+            ss << "Too many file descriptors in Parcel: " << rpcFields->mFds->size() << " (max is "
+               << maxFdsPerMsg << ")";
+            *errorMsg = ss.str();
+            return BAD_VALUE;
         }
     }
 
diff --git a/libs/binder/RpcState.h b/libs/binder/RpcState.h
index 94013cc952..60631bd68e 100644
--- a/libs/binder/RpcState.h
+++ b/libs/binder/RpcState.h
@@ -38,7 +38,9 @@ struct RpcWireHeader;
  * a specific subset of logs to debug, this could be broken up like
  * IPCThreadState's.
  */
+// DO NOT ENABLE IN PRODUCTION
 #define SHOULD_LOG_RPC_DETAIL false
+// DO NOT ENABLE IN PRODUCTION
 
 #if SHOULD_LOG_RPC_DETAIL
 #define LOG_RPC_DETAIL(...) ALOGI(__VA_ARGS__)
@@ -46,12 +48,17 @@ struct RpcWireHeader;
 #define LOG_RPC_DETAIL(...) ALOGV(__VA_ARGS__) // for type checking
 #endif
 
+// DO NOT ENABLE IN PRODUCTION
 #define RPC_FLAKE_PRONE false
+// DO NOT ENABLE IN PRODUCTION
 
 #if RPC_FLAKE_PRONE
-void rpcMaybeWaitToFlake();
+LIBBINDER_INTERNAL_EXPORTED bool rpcMaybeFlake();
+LIBBINDER_INTERNAL_EXPORTED void rpcMaybeWaitToFlake();
+#define MAYBE_TRUE_IN_FLAKE_MODE rpcMaybeFlake()
 #define MAYBE_WAIT_IN_FLAKE_MODE rpcMaybeWaitToFlake()
 #else
+#define MAYBE_TRUE_IN_FLAKE_MODE false
 #define MAYBE_WAIT_IN_FLAKE_MODE do {} while (false)
 #endif
 
@@ -251,9 +258,9 @@ private:
         // CASE A - local binder we are serving
         //
 
-        // async transaction queue, _only_ for local binder
         struct AsyncTodo {
-            sp<IBinder> ref;
+            // any transaction, including async, can only be on local binders
+            sp<BBinder> ref;
             CommandData data;
             std::vector<std::variant<binder::unique_fd, binder::borrowed_fd>> ancillaryFds;
             uint64_t asyncNumber = 0;
diff --git a/libs/binder/RpcTlsUtils.cpp b/libs/binder/RpcTlsUtils.cpp
index d5c86d7227..41bb8df957 100644
--- a/libs/binder/RpcTlsUtils.cpp
+++ b/libs/binder/RpcTlsUtils.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "RpcTlsUtils"
+#define LOG_TAG "libbinder.RpcTlsUtils"
 #include <log/log.h>
 
 #include <binder/RpcTlsUtils.h>
diff --git a/libs/binder/RpcTransportRaw.cpp b/libs/binder/RpcTransportRaw.cpp
index aa3a6e506d..79fe785974 100644
--- a/libs/binder/RpcTransportRaw.cpp
+++ b/libs/binder/RpcTransportRaw.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "RpcRawTransport"
+#define LOG_TAG "libbinder.RpcRawTransport"
 #include <log/log.h>
 
 #include <poll.h>
diff --git a/libs/binder/RpcTransportTipcAndroid.cpp b/libs/binder/RpcTransportTipcAndroid.cpp
index 14c0bde7c5..3f3456faea 100644
--- a/libs/binder/RpcTransportTipcAndroid.cpp
+++ b/libs/binder/RpcTransportTipcAndroid.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "RpcTransportTipcAndroid"
+#define LOG_TAG "libbinder.RpcTransportTipcAndroid"
 
 #include <binder/RpcSession.h>
 #include <binder/RpcTransportTipcAndroid.h>
@@ -190,6 +190,7 @@ private:
                 if (savedErrno == EMSGSIZE) {
                     // Buffer was too small, double it and retry
                     if (__builtin_mul_overflow(mReadBufferCapacity, 2, &mReadBufferCapacity)) {
+                        ALOGE("%s: read buffer mul_overflow", __FUNCTION__);
                         return NO_MEMORY;
                     }
                     mReadBuffer.reset(new (std::nothrow) uint8_t[mReadBufferCapacity]);
diff --git a/libs/binder/RpcTransportTls.cpp b/libs/binder/RpcTransportTls.cpp
index 579694c321..9bd955ecff 100644
--- a/libs/binder/RpcTransportTls.cpp
+++ b/libs/binder/RpcTransportTls.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "RpcTransportTls"
+#define LOG_TAG "libbinder.RpcTransportTls"
 #include <log/log.h>
 
 #include <poll.h>
diff --git a/libs/binder/RpcTransportUtils.h b/libs/binder/RpcTransportUtils.h
index fcf6675588..124f5e3c1e 100644
--- a/libs/binder/RpcTransportUtils.h
+++ b/libs/binder/RpcTransportUtils.h
@@ -21,6 +21,10 @@
 #include "FdTrigger.h"
 #include "RpcState.h"
 
+// For just this file:
+// #undef LOG_RPC_DETAIL
+// #define LOG_RPC_DETAIL ALOGE
+
 namespace android {
 
 template <typename SendOrReceive>
@@ -40,6 +44,7 @@ status_t interruptableReadOrWrite(
         return DEAD_OBJECT;
     }
 
+    // EMPTY IOVEC ISSUE
     // If iovs has one or more empty vectors at the end and
     // we somehow advance past all the preceding vectors and
     // pass some or all of the empty ones to sendmsg/recvmsg,
@@ -55,21 +60,135 @@ status_t interruptableReadOrWrite(
         return OK;
     }
 
+    // size to break up message - this is not reset for this read/write operation.
+    constexpr size_t kChunkMax = 65536;
+    const size_t kChunkMin = getpagesize(); // typical allocated granularity for sockets
+    size_t chunkSize = kChunkMax;
+
+    // b/419364025 - we have confirmed vhost-vsock ENOMEM for non-blocking sockets,
+    //   but more analysis is needed to see how this affects other settings/impls.
+    // These are how long we are waiting on repeated enomems for memory to be available.
+    constexpr size_t kEnomemWaitStartUs = 20'000;
+    constexpr size_t kEnomemWaitMaxUs = 1'000'000;       // don't risk ANR
+    constexpr size_t kEnomemWaitTotalMaxUs = 30'000'000; // ANR at 30s anyway, so avoid hang
+    size_t enomemWaitUs = 0;
+    size_t enomemTotalUs = 0;
+
     bool havePolled = false;
     while (true) {
-        ssize_t processSize = sendOrReceiveFun(iovs, niovs);
+        ssize_t processSize = -1;
+        bool skipPollingAndContinue = false; // set when we should retry immediately
+
+        // This block dynamically adjusts packet sizes down to work around a
+        // limitation in the vsock driver where large packets are sometimes
+        // dropped (b/419364025 b/399469406 b/421244320).
+        // TODO: only apply this workaround on vsock ???
+        // TODO: fix vsock
+        {
+            size_t chunkRemaining = chunkSize;
+            int i = 0;
+            for (i = 0; i < niovs; i++) {
+                if (iovs[i].iov_len >= chunkRemaining) {
+                    break;
+                }
+                chunkRemaining -= iovs[i].iov_len;
+            }
+            bool canSendFullTransaction = i == niovs;
+
+            int old_niovs = niovs;
+            size_t old_len = 0xDEADBEEF;
+
+            if (!canSendFullTransaction) {
+                // pretend like we have fewer iovecs
+                niovs = i + 1; // to restore (A)
+                old_len = iovs[i].iov_len;
+                // only send up to remaining chunkRemaining from this iovec
+                iovs[i].iov_len = chunkRemaining; // to restore (B)
+                LOG_ALWAYS_FATAL_IF(chunkRemaining == 0,
+                                    "chunkRemaining never zero - see EMPTY IOVEC ISSUE above");
+            }
+
+            // MAIN ACTION
+            if (MAYBE_TRUE_IN_FLAKE_MODE) {
+                LOG_RPC_DETAIL("Injecting ENOMEM.");
+                processSize = -1;
+                errno = ENOMEM;
+            } else {
+                processSize = sendOrReceiveFun(iovs, niovs);
+            }
+            // MAIN ACTION
+
+            if (!canSendFullTransaction) {
+                // Now put the iovecs back. As far as the following logic
+                // is concerned, this just looks like a partial read, up
+                // to limit.
+                niovs = old_niovs;         // (A) - restored
+                iovs[i].iov_len = old_len; // (B) - restored
+            }
+
+            // altPoll may introduce long waiting since it assumes if it cannot write
+            // data, that it needs to wait to send more to give time for the producer
+            // consumer problem to be solved - otherwise it will busy loop. However,
+            // for this workaround, we are breaking up the transaction intentionally,
+            // not because the transaction won't fit, but to avoid a bug in the kernel
+            // for how it combines messages. So, when we artificially simulate a
+            // limited send, don't poll and just keep on sending data.
+            skipPollingAndContinue = !canSendFullTransaction;
+        }
+
+        // HANDLE RESULT OF SEND OR RECEIVE
         if (processSize < 0) {
             int savedErrno = errno;
 
-            // Still return the error on later passes, since it would expose
-            // a problem with polling
-            if (havePolled || (savedErrno != EAGAIN && savedErrno != EWOULDBLOCK)) {
+            if (savedErrno == ENOMEM) {
+                LOG_RPC_DETAIL("RpcTransport %s(): %s", funName, strerror(savedErrno));
+
+                // Since this is the limit only for this call to send this packet
+                // we don't ever restore this. Assume it will be hard to get more
+                // memory if we're already having difficulty sending this out.
+                chunkSize = std::max(chunkSize / 2, kChunkMin);
+                LOG_RPC_DETAIL("Chunk size is now %zu due to ENOMEM.", chunkSize);
+
+                // When we've gotten down to the minimum send size, add a timer
+                // to give time for more memory to be freed up. This means even
+                // a single page is not available, so we have to wait.
+                if (chunkSize <= kChunkMin) {
+                    if (enomemWaitUs == 0) {
+                        enomemWaitUs = kEnomemWaitStartUs;
+                    } else {
+                        enomemWaitUs = std::min(enomemWaitUs * 2, kEnomemWaitMaxUs);
+                    }
+                    enomemTotalUs += enomemWaitUs;
+
+                    if (enomemTotalUs > kEnomemWaitTotalMaxUs) {
+                        // by this time WatchDog should be kicking in
+                        return -ENOMEM;
+                    }
+
+                    LOG_RPC_DETAIL("Sleeping %zuus due to ENOMEM.", enomemWaitUs);
+                    usleep(enomemWaitUs);
+                }
+
+                // Need to survey socket code to see if polling in this situation is
+                // guaranteed to be non-blocking.
+                // NOTE: if the other side needs to deallocate memory, and that is the
+                // only deallocatable memory in the entire system, but we need altPoll
+                // to drain commands to unstick it so it can do that, then this could
+                // cause a deadlock, but this is not realistic on Android.
+                skipPollingAndContinue = true;
+            } else if (havePolled || (savedErrno != EAGAIN && savedErrno != EWOULDBLOCK)) {
+                // Still return the error on later passes, since it would expose
+                // a problem with polling
                 LOG_RPC_DETAIL("RpcTransport %s(): %s", funName, strerror(savedErrno));
                 return -savedErrno;
             }
         } else if (processSize == 0) {
             return DEAD_OBJECT;
         } else {
+            // success - reset error exponential backoffs
+            enomemWaitUs = 0;
+            enomemTotalUs = 0;
+
             while (processSize > 0 && niovs > 0) {
                 auto& iov = iovs[0];
                 if (static_cast<size_t>(processSize) < iov.iov_len) {
@@ -93,11 +212,19 @@ status_t interruptableReadOrWrite(
             }
         }
 
-        if (altPoll) {
-            if (status_t status = (*altPoll)(); status != OK) return status;
+        // METHOD OF POLLING
+        if (skipPollingAndContinue) {
+            // Since we aren't polling, manually check if we should shutdown. This ensures any bug
+            // leading to an infinite loop can still be recovered from.
             if (fdTrigger->isTriggered()) {
                 return DEAD_OBJECT;
             }
+            // continue;
+        } else if (altPoll) {
+            if (status_t status = (*altPoll)(); status != OK) return status;
+            if (fdTrigger->isTriggered()) { // altPoll may not check this
+                return DEAD_OBJECT;
+            }
         } else {
             if (status_t status = fdTrigger->triggerablePoll(socket, event); status != OK)
                 return status;
diff --git a/libs/binder/RpcTrusty.cpp b/libs/binder/RpcTrusty.cpp
index a445196ca9..f85795ca54 100644
--- a/libs/binder/RpcTrusty.cpp
+++ b/libs/binder/RpcTrusty.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "RpcTrusty"
+#define LOG_TAG "libbinder.RpcTrusty"
 
 #include <binder/RpcSession.h>
 #include <binder/RpcTransportTipcAndroid.h>
diff --git a/libs/binder/RpcWireFormat.h b/libs/binder/RpcWireFormat.h
index ff1b01a213..5ddb437c4e 100644
--- a/libs/binder/RpcWireFormat.h
+++ b/libs/binder/RpcWireFormat.h
@@ -15,6 +15,8 @@
  */
 #pragma once
 
+#include <binder/RpcSession.h>
+
 namespace android {
 
 #pragma clang diagnostic push
@@ -167,4 +169,18 @@ static_assert(sizeof(RpcWireReply) == 20);
 
 #pragma clang diagnostic pop
 
+static inline size_t getRpcTransportModeMaxFds(RpcSession::FileDescriptorTransportMode mode) {
+    switch (mode) {
+        case RpcSession::FileDescriptorTransportMode::NONE:
+            return 0;
+        case RpcSession::FileDescriptorTransportMode::UNIX:
+            return 253;
+        case RpcSession::FileDescriptorTransportMode::TRUSTY:
+            // Keep this in sync with trusty_ipc.h!!!
+            // We could import that file here on Trusty, but it's not
+            // available on Android
+            return 8;
+    }
+}
+
 } // namespace android
diff --git a/libs/binder/Stability.cpp b/libs/binder/Stability.cpp
index 4fb8fa08bc..e952605f4f 100644
--- a/libs/binder/Stability.cpp
+++ b/libs/binder/Stability.cpp
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-#define LOG_TAG "Stability"
+#define LOG_TAG "libbinder.Stability"
 
 #include <binder/Stability.h>
 
diff --git a/libs/binder/Static.cpp b/libs/binder/Static.cpp
index 565f2e25f3..58bec72def 100644
--- a/libs/binder/Static.cpp
+++ b/libs/binder/Static.cpp
@@ -27,7 +27,7 @@ namespace android {
 
 // ------------ Text output streams
 
-Vector<int32_t> gTextBuffers;
+[[clang::no_destroy]] Vector<int32_t> gTextBuffers;
 
 class LogTextOutput : public BufferedTextOutput
 {
diff --git a/libs/binder/TEST_MAPPING b/libs/binder/TEST_MAPPING
index 4332f8ae79..32ad8dc902 100644
--- a/libs/binder/TEST_MAPPING
+++ b/libs/binder/TEST_MAPPING
@@ -95,6 +95,9 @@
     },
     {
       "name": "binderCacheUnitTest"
+    },
+    {
+      "name": "binderStatsPusherUnitTest"
     }
   ],
   "presubmit-large": [
diff --git a/libs/binder/Utils.cpp b/libs/binder/Utils.cpp
index d9a96af80a..35dfe91b9a 100644
--- a/libs/binder/Utils.cpp
+++ b/libs/binder/Utils.cpp
@@ -20,10 +20,6 @@
 
 namespace android {
 
-void zeroMemory(uint8_t* data, size_t size) {
-    memset(data, 0, size);
-}
-
 std::string HexString(const void* bytes, size_t len) {
     LOG_ALWAYS_FATAL_IF(len > 0 && bytes == nullptr, "%p %zu", bytes, len);
 
diff --git a/libs/binder/Utils.h b/libs/binder/Utils.h
index 881cdf3f4c..440a5442a1 100644
--- a/libs/binder/Utils.h
+++ b/libs/binder/Utils.h
@@ -85,7 +85,16 @@ constexpr size_t countof(T (&)[N]) {
 }
 
 // avoid optimizations
-void zeroMemory(uint8_t* data, size_t size);
+inline void zeroMemory(uint8_t* data, size_t size) {
+#ifdef __BIONIC__
+    memset_explicit(data, 0, size);
+#else
+    // Assembly marking to prevent any optimizing compiler from not actually clearing the buffer,
+    // this matches what exactly what memset_explicit does.
+    memset(data, 0, size);
+    __asm__ __volatile__("" : : "r"(data) : "memory");
+#endif
+}
 
 // View of contiguous sequence. Similar to std::span.
 template <typename T>
diff --git a/libs/binder/aidl/android/os/IRpcProvider.aidl b/libs/binder/aidl/android/os/IRpcProvider.aidl
new file mode 100644
index 0000000000..cb5cd4c027
--- /dev/null
+++ b/libs/binder/aidl/android/os/IRpcProvider.aidl
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.os;
+
+/**
+ * Interface for providing RPC service connection information to a
+ * centralized servicemanager instance.
+ *
+ * This is useful when remote services are known/managed by some other
+ * process, possibly on another device. That process can implement this
+ * interface and it can be used by a servicemanager instance on the local
+ * device to allow clients to connect to the remote services over sockets.
+ */
+interface IRpcProvider {
+    /**
+     * Connection info for a service
+     */
+    @RustDerive(Clone=true, Eq=true, PartialEq=true)
+    parcelable Vsock {
+        int cid;
+        int port;
+    }
+    @RustDerive(Clone=true, Eq=true, PartialEq=true)
+    union ServiceConnectionInfo {
+        Vsock vsock;
+    }
+
+    /**
+     * Request VSOCK connection info for a specific host service.
+     */
+    ServiceConnectionInfo getServiceConnectionInfo(in String name);
+}
diff --git a/libs/binder/aidl/android/os/IServiceManager.aidl b/libs/binder/aidl/android/os/IServiceManager.aidl
index 6539238ce7..723b2479bb 100644
--- a/libs/binder/aidl/android/os/IServiceManager.aidl
+++ b/libs/binder/aidl/android/os/IServiceManager.aidl
@@ -166,4 +166,27 @@ interface IServiceManager {
      * Get debug information for all currently registered services.
      */
     ServiceDebugInfo[] getServiceDebugInfo();
+
+    /**
+     * Caller context used when delegating access checks to service manager.
+     * This may not be the same context as the caller of this method.
+     */
+    parcelable CallerContext {
+        @utf8InCpp String sidName;
+        int debugPid;
+        int uid;
+    }
+
+    /**
+     * Check if this 'callerCtx' has access for the 'permission' for a given service 'name'.
+     *
+     * This is useful when a process will be making calls to servicemanager on behalf of another
+     * process (callerCtx).
+     *
+     * @param callerCtx - context of the process that is being checked.
+     * @param name - name of the service that the caller wants to interact with
+     * @param permission - the servicemanager SELinux permission that the process is
+     *                     interested in for the service. This is either "find", "list", or "add".
+     */
+    boolean checkServiceAccess(in CallerContext callerCtx, @utf8InCpp String name, @utf8InCpp String permission);
 }
diff --git a/libs/binder/include/binder/Binder.h b/libs/binder/include/binder/Binder.h
index 135be89c6c..2ad479a604 100644
--- a/libs/binder/include/binder/Binder.h
+++ b/libs/binder/include/binder/Binder.h
@@ -91,6 +91,11 @@ public:
     // This must be called before the object is sent to another process. Not thread safe.
     LIBBINDER_EXPORTED void setInheritRt(bool inheritRt);
 
+    // Set default, overridden by setInheritRt. You must set this default early.
+    // Any binder objects sent out of the process before this is called will
+    // not use the updated value.
+    LIBBINDER_EXPORTED static void setGlobalInheritRt(bool enabled);
+
     LIBBINDER_EXPORTED pid_t getDebugPid();
 
     // Whether this binder has been sent to another process.
@@ -124,6 +129,8 @@ private:
     [[nodiscard]] status_t startRecordingTransactions(const Parcel& data);
     [[nodiscard]] status_t stopRecordingTransactions();
 
+    static std::atomic<bool> sGlobalInheritRt;
+
     std::atomic<Extras*> mExtras;
 
     friend ::android::internal::Stability;
diff --git a/libs/binder/include/binder/IInterface.h b/libs/binder/include/binder/IInterface.h
index 993ad82b96..d5214e71c3 100644
--- a/libs/binder/include/binder/IInterface.h
+++ b/libs/binder/include/binder/IInterface.h
@@ -102,7 +102,7 @@ public:
     static const ::android::sp<I##INTERFACE>& getDefaultImpl();                                   \
                                                                                                   \
 private:                                                                                          \
-    static ::android::sp<I##INTERFACE> default_impl;                                              \
+    [[clang::no_destroy]] static ::android::sp<I##INTERFACE> default_impl;                        \
                                                                                                   \
 public:
 
@@ -157,10 +157,11 @@ public:
     ITYPE::~INAME() {}
 
 // Macro for an interface type.
-#define DO_NOT_DIRECTLY_USE_ME_IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                        \
-    const ::android::StaticString16 I##INTERFACE##_descriptor_static_str16(                     \
-            __IINTF_CONCAT(u, NAME));                                                           \
-    const ::android::String16 I##INTERFACE::descriptor(I##INTERFACE##_descriptor_static_str16); \
+#define DO_NOT_DIRECTLY_USE_ME_IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                          \
+    [[clang::no_destroy]] const ::android::StaticString16 I##INTERFACE##_descriptor_static_str16( \
+            __IINTF_CONCAT(u, NAME));                                                             \
+    [[clang::no_destroy]] const ::android::String16 I##INTERFACE::descriptor(                     \
+            I##INTERFACE##_descriptor_static_str16);                                              \
     DO_NOT_DIRECTLY_USE_ME_IMPLEMENT_META_INTERFACE0(I##INTERFACE, I##INTERFACE, Bp##INTERFACE)
 
 // Macro for "nested" interface type.
diff --git a/libs/binder/include/binder/IPCThreadState.h b/libs/binder/include/binder/IPCThreadState.h
index f7465e2c1a..5b6cb07567 100644
--- a/libs/binder/include/binder/IPCThreadState.h
+++ b/libs/binder/include/binder/IPCThreadState.h
@@ -29,6 +29,8 @@ typedef  int  uid_t;
 // ---------------------------------------------------------------------------
 namespace android {
 
+class BinderStatsSpscQueue;
+
 /**
  * Kernel binder thread state. All operations here refer to kernel binder. This
  * object is allocated per-thread.
@@ -180,8 +182,6 @@ public:
     [[nodiscard]] status_t addFrozenStateChangeCallback(int32_t handle, BpBinder* proxy);
     [[nodiscard]] status_t removeFrozenStateChangeCallback(int32_t handle, BpBinder* proxy);
 
-    LIBBINDER_EXPORTED static void shutdown();
-
     // Call this to disable switching threads to background scheduling when
     // receiving incoming IPC calls.  This is specifically here for the
     // Android system process, since it expects to have background apps calling
@@ -257,6 +257,9 @@ private:
             int32_t             mStrictModePolicy;
             int32_t             mLastTransactionBinderFlags;
             CallRestriction     mCallRestriction;
+#ifdef BINDER_WITH_OBSERVERS
+            std::shared_ptr<BinderStatsSpscQueue> mBinderStatsQueue;
+#endif
 };
 
 } // namespace android
diff --git a/libs/binder/include/binder/IServiceManager.h b/libs/binder/include/binder/IServiceManager.h
index d248f22e89..713bddfe91 100644
--- a/libs/binder/include/binder/IServiceManager.h
+++ b/libs/binder/include/binder/IServiceManager.h
@@ -164,6 +164,25 @@ public:
      * Only used for testing. This is enabled by default.
      */
     virtual void enableAddServiceCache(bool value) = 0;
+
+    /**
+     * Check if this 'callerSid' has access for the 'permission' for a given service 'name'.
+     *
+     * This is useful when a process will be making calls to servicemanager on behalf of another
+     * process (callerCtx).
+     *
+     * @param callerSid - SELinux context of the process that is being checked.
+     * @param callerDebugPid - Debug PID of the process that is being checked.
+     *                         Used for logging denials.
+     * @param callerUid - UID process that is being checked. Used for logging
+     *                    denials
+     * @param name - name of the service that the caller wants to interact with
+     * @param permission - the servicemanager SELinux permission that the process is
+     *                     interested in for the service. This is either "find", "list", or "add".
+     */
+    virtual bool checkServiceAccess(const String16& callererSid, pid_t callererDebugPid,
+                                    uid_t callererUid, const String16& name,
+                                    const String16& permission) = 0;
 };
 
 LIBBINDER_EXPORTED sp<IServiceManager> defaultServiceManager();
diff --git a/libs/binder/include/binder/ProcessState.h b/libs/binder/include/binder/ProcessState.h
index ced49c19c2..7c647d902b 100644
--- a/libs/binder/include/binder/ProcessState.h
+++ b/libs/binder/include/binder/ProcessState.h
@@ -31,8 +31,14 @@
 // ---------------------------------------------------------------------------
 namespace android {
 
-class IPCThreadState;
+#if defined(LIBBINDER_BINDER_OBSERVER) && defined(BINDER_WITH_KERNEL_IPC)
+#define BINDER_WITH_OBSERVERS
+#endif
 
+class IPCThreadState;
+#ifdef BINDER_WITH_OBSERVERS
+class BinderObserver;
+#endif
 /**
  * Kernel binder process state. All operations here refer to kernel binder. This
  * object is allocated per process.
@@ -40,6 +46,10 @@ class IPCThreadState;
 class ProcessState : public virtual RefBase {
 public:
     LIBBINDER_EXPORTED static sp<ProcessState> self();
+    // The behavior is the same as self() if kernel binder is enabled for this
+    // process (can it reach the binder device node). If not, this returns null
+    // and does not create a ProcessState object.
+    LIBBINDER_EXPORTED static sp<ProcessState> selfIfKernelBinderEnabled();
     LIBBINDER_EXPORTED static sp<ProcessState> selfOrNull();
 
     LIBBINDER_EXPORTED static bool isVndservicemanagerEnabled();
@@ -195,6 +205,9 @@ private:
     std::atomic_int32_t mThreadPoolSeq;
 
     CallRestriction mCallRestriction;
+#ifdef BINDER_WITH_OBSERVERS
+    std::unique_ptr<BinderObserver> mBinderObserver;
+#endif
 };
 
 } // namespace android
diff --git a/libs/binder/include/binder/RpcServer.h b/libs/binder/include/binder/RpcServer.h
index c241d31623..ff93cfcd1a 100644
--- a/libs/binder/include/binder/RpcServer.h
+++ b/libs/binder/include/binder/RpcServer.h
@@ -25,13 +25,11 @@
 #include <utils/RefBase.h>
 
 #include <bitset>
-#include <mutex>
-#include <thread>
 
 namespace android {
 
 class FdTrigger;
-class RpcServerTrusty;
+class RpcServerTrusty; // TODO(b/387305736) remove. Move functionality into RpcServer.
 class RpcSocketAddress;
 
 /**
@@ -249,8 +247,9 @@ public:
     LIBBINDER_EXPORTED ~RpcServer();
 
 private:
-    friend RpcServerTrusty;
+    friend RpcServerTrusty; // TODO(b/387305736): remove. Move functionality into RpcServer.
     friend sp<RpcServer>;
+    friend wp<EventListener>;
     explicit RpcServer(std::unique_ptr<RpcTransportCtx> ctx);
 
     void onSessionAllIncomingThreadsEnded(const sp<RpcSession>& session) override;
diff --git a/libs/binder/include/binder/RpcThreads.h b/libs/binder/include/binder/RpcThreads.h
index 51b9716bb1..fe4d6c95ef 100644
--- a/libs/binder/include/binder/RpcThreads.h
+++ b/libs/binder/include/binder/RpcThreads.h
@@ -15,19 +15,26 @@
  */
 #pragma once
 
-#include <pthread.h>
-
-#include <condition_variable>
 #include <functional>
 #include <memory>
+#include <tuple>
+#include <type_traits>
+#include <utility>
+
+#ifndef BINDER_RPC_SINGLE_THREADED
+#include <condition_variable>
 #include <mutex>
 #include <thread>
+#endif // BINDER_RPC_SINGLE_THREADED
 
 #include <binder/Common.h>
 
 namespace android {
 
 #ifdef BINDER_RPC_SINGLE_THREADED
+
+enum class LIBBINDER_EXPORTED RpcCvStatus { no_timeout, timeout };
+
 class LIBBINDER_EXPORTED RpcMutex {
 public:
     void lock() {}
@@ -58,8 +65,8 @@ public:
     }
 
     template <typename Duration>
-    std::cv_status wait_for(RpcMutexUniqueLock&, const Duration&) {
-        return std::cv_status::no_timeout;
+    RpcCvStatus wait_for(RpcMutexUniqueLock&, const Duration&) {
+        return RpcCvStatus::no_timeout;
     }
 
     template <typename Duration, typename Predicate>
@@ -132,6 +139,7 @@ using RpcMutexLockGuard = std::lock_guard<std::mutex>;
 using RpcConditionVariable = std::condition_variable;
 using RpcMaybeThread = std::thread;
 namespace rpc_this_thread = std::this_thread;
+using RpcCvStatus = std::cv_status;
 
 static inline void rpcJoinIfSingleThreaded(RpcMaybeThread&) {}
 #endif // BINDER_RPC_SINGLE_THREADED
diff --git a/libs/binder/include_activitymanager/binder/ActivityManager.h b/libs/binder/include_activitymanager/binder/ActivityManager.h
index 9c634c7238..69cbb9ebec 100644
--- a/libs/binder/include_activitymanager/binder/ActivityManager.h
+++ b/libs/binder/include_activitymanager/binder/ActivityManager.h
@@ -25,6 +25,11 @@
 // ---------------------------------------------------------------------------
 namespace android {
 
+namespace app {
+class IProcessObserver;
+class RunningAppProcessInfo;
+} // namespace app
+
 #define DECLARE_PROCESS_STATE(name) \
     PROCESS_STATE_##name = (int32_t) app::ProcessStateEnum::name
 
@@ -95,6 +100,10 @@ public:
     int getUidProcessState(const uid_t uid, const String16& callingPackage);
     status_t checkPermission(const String16& permission, const pid_t pid, const uid_t uid, int32_t* outResult);
 
+    status_t registerProcessObserver(const sp<app::IProcessObserver> observer);
+    status_t unregisterProcessObserver(const sp<app::IProcessObserver> observer);
+    status_t getRunningAppProcesses(::std::vector<app::RunningAppProcessInfo>* output);
+
     status_t linkToDeath(const sp<IBinder::DeathRecipient>& recipient);
     status_t unlinkToDeath(const sp<IBinder::DeathRecipient>& recipient);
 
diff --git a/libs/binder/include_activitymanager/binder/IActivityManager.h b/libs/binder/include_activitymanager/binder/IActivityManager.h
index 07450c6af9..7edbd7e420 100644
--- a/libs/binder/include_activitymanager/binder/IActivityManager.h
+++ b/libs/binder/include_activitymanager/binder/IActivityManager.h
@@ -18,11 +18,19 @@
 
 #ifndef __ANDROID_VNDK__
 
-#include <binder/IUidObserver.h>
 #include <binder/IInterface.h>
+#include <binder/IUidObserver.h>
+#include <binder/Parcelable.h>
+
+#include <vector>
 
 namespace android {
 
+namespace app {
+class IProcessObserver;
+class RunningAppProcessInfo;
+} // namespace app
+
 // ------------------------------------------------------------------------------------
 
 class IActivityManager : public IInterface
@@ -55,6 +63,9 @@ public:
     virtual status_t logFgsApiEnd(int32_t apiType, int32_t appUid, int32_t appPid) = 0;
     virtual status_t logFgsApiStateChanged(int32_t apiType, int32_t state, int32_t appUid,
                                            int32_t appPid) = 0;
+    virtual status_t registerProcessObserver(const sp<app::IProcessObserver>& observer) = 0;
+    virtual status_t unregisterProcessObserver(const sp<app::IProcessObserver>& observer) = 0;
+    virtual status_t getRunningAppProcesses(::std::vector<app::RunningAppProcessInfo>* output) = 0;
 
     enum {
         OPEN_CONTENT_URI_TRANSACTION = IBinder::FIRST_CALL_TRANSACTION,
@@ -68,7 +79,10 @@ public:
         CHECK_PERMISSION_TRANSACTION,
         LOG_FGS_API_BEGIN_TRANSACTION,
         LOG_FGS_API_END_TRANSACTION,
-        LOG_FGS_API_STATE_CHANGED_TRANSACTION
+        LOG_FGS_API_STATE_CHANGED_TRANSACTION,
+        REGISTER_PROCESS_OBSERVER,
+        UNREGISTER_PROCESS_OBSERVER,
+        GET_RUNNING_APP_PROCESSES,
     };
 };
 
diff --git a/libs/binder/ndk/Android.bp b/libs/binder/ndk/Android.bp
index 5710bbfa9f..73c73ff2b0 100644
--- a/libs/binder/ndk/Android.bp
+++ b/libs/binder/ndk/Android.bp
@@ -150,23 +150,33 @@ cc_library {
         "android-*",
         "bugprone-*",
         "-bugprone-branch-clone", // b/155034972
+        "-bugprone-forwarding-reference-overload",
         "cert-*",
         "clang-analyzer-*",
         "-clang-analyzer-core.CallAndMessage",
         "-clang-analyzer-core.uninitialized.Assign",
-        "-clang-analyzer-unix.Malloc",
         "-clang-analyzer-deadcode.DeadStores",
+        "-clang-analyzer-nullability.NullableDereferenced",
         "-clang-analyzer-optin.cplusplus.UninitializedObject",
+        "-clang-analyzer-optin.cplusplus.VirtualCall",
+        "-clang-analyzer-unix.Malloc",
         "google-*",
         "-google-readability-*",
         "-google-runtime-references",
         "misc-*",
-        "-misc-no-recursion",
+        "-misc-header-include-cycle",
+        "-misc-include-cleaner",
         "-misc-non-private-member-variables-in-classes",
+        "-misc-no-recursion",
         "-misc-redundant-expression",
         "-misc-unused-parameters",
         "-misc-unused-using-decls",
+        "-misc-unused-using-decls",
+        "-misc-use-internal-linkage",
         "performance*",
+        "-performance-enum-size",
+        "-performance-unnecessary-copy-initialization",
+        "-performance-unnecessary-value-param",
         "portability*",
     ],
     afdo: true,
diff --git a/libs/binder/ndk/binder_rpc.cpp b/libs/binder/ndk/binder_rpc.cpp
index bb5989dec8..ada96bab0c 100644
--- a/libs/binder/ndk/binder_rpc.cpp
+++ b/libs/binder/ndk/binder_rpc.cpp
@@ -44,7 +44,7 @@ struct ABinderRpc_ConnectionInfo {
     std::variant<sockaddr_vm, sockaddr_un, sockaddr_in> addr;
 };
 
-struct ABinderRpc_Accessor final : public ::android::RefBase {
+struct ABinderRpc_Accessor final {
     static ABinderRpc_Accessor* make(const char* instance, const sp<IBinder>& binder) {
         LOG_ALWAYS_FATAL_IF(binder == nullptr, "ABinderRpc_Accessor requires a non-null binder");
         status_t status = android::validateAccessor(String16(instance), binder);
@@ -61,7 +61,7 @@ struct ABinderRpc_Accessor final : public ::android::RefBase {
     ~ABinderRpc_Accessor() { LOG_ACCESSOR_DEBUG("ABinderRpc_Accessor dtor"); }
 
    private:
-    ABinderRpc_Accessor(sp<IBinder> accessor) : mAccessorBinder(accessor) {}
+    ABinderRpc_Accessor(const sp<IBinder>& accessor) : mAccessorBinder(accessor) {}
     ABinderRpc_Accessor() = delete;
     sp<IBinder> mAccessorBinder;
 };
diff --git a/libs/binder/ndk/ibinder.cpp b/libs/binder/ndk/ibinder.cpp
index ff31dd0193..3bd6d1e010 100644
--- a/libs/binder/ndk/ibinder.cpp
+++ b/libs/binder/ndk/ibinder.cpp
@@ -58,7 +58,7 @@ static const char* kNdkTrace = "AIDL::ndk::";
 static const char* kServerTrace = "::server";
 static const char* kClientTrace = "::client";
 static const char* kSeparator = "::";
-static const char* kUnknownCode = "Unknown_Transaction_Code:";
+static const char* kUnknownCode = "name=?_code=";
 
 namespace ABBinderTag {
 
diff --git a/libs/binder/ndk/include_cpp/android/binder_auto_utils.h b/libs/binder/ndk/include_cpp/android/binder_auto_utils.h
index 8c62924beb..052dc21835 100644
--- a/libs/binder/ndk/include_cpp/android/binder_auto_utils.h
+++ b/libs/binder/ndk/include_cpp/android/binder_auto_utils.h
@@ -335,7 +335,6 @@ class ScopedAStatus : public impl::ScopedAResource<AStatus*, AStatus_delete, nul
 
 static inline std::ostream& operator<<(std::ostream& os, const ScopedAStatus& status) {
     return os << status.getDescription();
-    return os;
 }
 
 /**
diff --git a/libs/binder/ndk/include_cpp/android/binder_parcel_utils.h b/libs/binder/ndk/include_cpp/android/binder_parcel_utils.h
index 95eee26eed..174fc9445f 100644
--- a/libs/binder/ndk/include_cpp/android/binder_parcel_utils.h
+++ b/libs/binder/ndk/include_cpp/android/binder_parcel_utils.h
@@ -1419,7 +1419,10 @@ static inline binder_status_t AParcel_resizeVector(const AParcel* parcel, std::v
     if (size < 0) return STATUS_UNEXPECTED_NULL;
 
     // TODO(b/188215728): delegate to libbinder_ndk
-    if (size > 1000000) return STATUS_NO_MEMORY;
+    if (size > 1000000) {
+        syslog(LOG_ERR, "Parcel vector size too large");
+        return STATUS_NO_MEMORY;
+    }
 
     vec->resize(static_cast<size_t>(size));
     return STATUS_OK;
@@ -1443,7 +1446,10 @@ static inline binder_status_t AParcel_resizeVector(const AParcel* parcel,
     }
 
     // TODO(b/188215728): delegate to libbinder_ndk
-    if (size > 1000000) return STATUS_NO_MEMORY;
+    if (size > 1000000) {
+        syslog(LOG_ERR, "Parcel vector size too large");
+        return STATUS_NO_MEMORY;
+    }
 
     *vec = std::optional<std::vector<T>>(std::vector<T>{});
     (*vec)->resize(static_cast<size_t>(size));
diff --git a/libs/binder/ndk/include_platform/android/binder_manager.h b/libs/binder/ndk/include_platform/android/binder_manager.h
index 2c2e2c8856..02fdbf73c7 100644
--- a/libs/binder/ndk/include_platform/android/binder_manager.h
+++ b/libs/binder/ndk/include_platform/android/binder_manager.h
@@ -14,6 +14,15 @@
  * limitations under the License.
  */
 
+/*
+ * This file defines the AServiceManager LLNDK APIs that vendor and system
+ * processes use to interact with the Binder servicemanager process in /system.
+ * It provides a stable API for most of the functionality of the libbinder
+ * IServiceManager APIs in
+ * `frameworks/native/libs/binder/include/binder/IServiceManager.h`.
+ *
+ * All strings are expected be UTF-8.
+ */
 #pragma once
 
 #include <android/binder_ibinder.h>
@@ -41,6 +50,28 @@ enum AServiceManager_AddServiceFlag : uint32_t {
     // All other bits are reserved for internal usage
 };
 
+/**
+ * These are the different SELinux permissions that processes need to have for
+ * different operations with servicemanager.
+ */
+enum AServiceManager_PermissionType : uint32_t {
+    /**
+     * Permission for a process to "find" this service through ServiceManager
+     * APIs like AServiceManager_getService or AServiceManager_waitForService
+     */
+    CHECK_ACCESS_PERMISSION_FIND,
+    /**
+     * Permission for a process to "list" services with
+     * libbinder's IServiceManager::listServices
+     */
+    CHECK_ACCESS_PERMISSION_LIST,
+    /**
+     * Permission for a process to "add", or register, a service with
+     * servicemanager through AServiceManager_addService
+     */
+    CHECK_ACCESS_PERMISSION_ADD,
+};
+
 /**
  * This registers the service with the default service manager under this instance name. This does
  * not take ownership of binder.
@@ -315,4 +346,32 @@ bool AServiceManager_tryUnregister() __INTRODUCED_IN(31);
  */
 void AServiceManager_reRegister() __INTRODUCED_IN(31);
 
+/**
+ * Check if this 'callerSid' has access for the 'permission' for a given service 'name'.
+ *
+ * This is useful when a process will be making calls to servicemanager on behalf of another
+ * process (callerCtx).
+ * The direct caller of this function also needs to have the permissions it is
+ * checking on behalf of the other process.
+ *
+ * \param caller_sid - UTF-8 encoded string. SELinux context of the process that is being checked.
+ * \param caller_debug_pid - PID of the process that is being checked. This can
+ *                           only be used in logging for debugging because PIDs are
+ *                           reused. Servicemanager uses it for logging denials.
+ * \param caller_uid - UID of the process that is being checked. Servicemanager
+ *                     only uses this for logging denials for better debugging.
+ * \param instance - UTF-8 encoded string. Instance name of the service that the caller
+ *                   wants to interact with.
+ * \param permission - The servicemanager SELinux permission that the process
+ *                     is interested in for the service.
+ *
+ * \return True if the process with `caller_sid` has the SELinux `permission`
+ *         for the given service `instance`. False if it does not have
+ *         permission or some error occurred.
+ */
+bool AServiceManager_checkServiceAccess(const char* caller_sid, pid_t caller_debug_pid,
+                                        uid_t caller_uid, const char* instance,
+                                        AServiceManager_PermissionType permission)
+        __INTRODUCED_IN(37);
+
 __END_DECLS
diff --git a/libs/binder/ndk/libbinder_ndk.map.txt b/libs/binder/ndk/libbinder_ndk.map.txt
index d4eb8c7579..5736f4966a 100644
--- a/libs/binder/ndk/libbinder_ndk.map.txt
+++ b/libs/binder/ndk/libbinder_ndk.map.txt
@@ -222,6 +222,11 @@ LIBBINDER_NDK36 { # introduced=36
     ABinderRpc_ConnectionInfo_delete; # systemapi
 };
 
+LIBBINDER_NDK37 { # introduced=37
+  global:
+    AServiceManager_checkServiceAccess; # systemapi llndk
+};
+
 LIBBINDER_NDK_PLATFORM {
   global:
     AParcel_getAllowFds;
diff --git a/libs/binder/ndk/parcel.cpp b/libs/binder/ndk/parcel.cpp
index 88ce5f4d9b..e638bc375b 100644
--- a/libs/binder/ndk/parcel.cpp
+++ b/libs/binder/ndk/parcel.cpp
@@ -74,7 +74,11 @@ static binder_status_t ReadAndValidateArraySize(const AParcel* parcel, int32_t*
 
     if (*length < -1) return STATUS_BAD_VALUE;  // libbinder_ndk reserves these
     if (*length <= 0) return STATUS_OK;         // null
-    if (static_cast<size_t>(*length) > parcel->get()->dataAvail()) return STATUS_NO_MEMORY;
+    if (static_cast<size_t>(*length) > parcel->get()->dataAvail()) {
+        ALOGI("%s: parcel length %zu larger than available buffer size %zu", __FUNCTION__,
+              static_cast<size_t>(*length), parcel->get()->dataAvail());
+        return STATUS_NO_MEMORY;
+    }
 
     return STATUS_OK;
 }
@@ -86,7 +90,10 @@ binder_status_t WriteArray(AParcel* parcel, const T* array, int32_t length) {
     if (length <= 0) return STATUS_OK;
 
     int32_t size = 0;
-    if (__builtin_smul_overflow(sizeof(T), length, &size)) return STATUS_NO_MEMORY;
+    if (__builtin_smul_overflow(sizeof(T), length, &size)) {
+        ALOGI("%s: smul_overflow (array size: %zu, length: %d)", __FUNCTION__, sizeof(T), length);
+        return STATUS_NO_MEMORY;
+    }
 
     void* const data = parcel->get()->writeInplace(size);
     if (data == nullptr) return STATUS_NO_MEMORY;
@@ -104,7 +111,10 @@ binder_status_t WriteArray<char16_t>(AParcel* parcel, const char16_t* array, int
     if (length <= 0) return STATUS_OK;
 
     int32_t size = 0;
-    if (__builtin_smul_overflow(sizeof(char16_t), length, &size)) return STATUS_NO_MEMORY;
+    if (__builtin_smul_overflow(sizeof(char16_t), length, &size)) {
+        ALOGI("%s: smul_overflow (size: %zu, length: %d)", __FUNCTION__, sizeof(char16_t), length);
+        return STATUS_NO_MEMORY;
+    }
 
     Parcel* rawParcel = parcel->get();
 
@@ -140,10 +150,16 @@ binder_status_t ReadArray(const AParcel* parcel, void* arrayData,
     if (array == nullptr) return STATUS_NO_MEMORY;
 
     int32_t size = 0;
-    if (__builtin_smul_overflow(sizeof(T), length, &size)) return STATUS_NO_MEMORY;
+    if (__builtin_smul_overflow(sizeof(T), length, &size)) {
+        ALOGI("%s: smul_overflow (size: %zu, length: %d)", __FUNCTION__, sizeof(T), length);
+        return STATUS_NO_MEMORY;
+    }
 
     const void* data = rawParcel->readInplace(size);
-    if (data == nullptr) return STATUS_NO_MEMORY;
+    if (data == nullptr) {
+        ALOGI("%s: parcel readInplace returned a nullptr", __FUNCTION__);
+        return STATUS_NO_MEMORY;
+    }
 
     memcpy(array, data, size);
 
@@ -174,7 +190,10 @@ binder_status_t ReadArray<char16_t>(const AParcel* parcel, void* arrayData,
     if (array == nullptr) return STATUS_NO_MEMORY;
 
     int32_t size = 0;
-    if (__builtin_smul_overflow(sizeof(char16_t), length, &size)) return STATUS_NO_MEMORY;
+    if (__builtin_smul_overflow(sizeof(char16_t), length, &size)) {
+        ALOGI("%s: smul_overflow (size: %zu, length: %d)", __FUNCTION__, sizeof(char16_t), length);
+        return STATUS_NO_MEMORY;
+    }
 
     for (int32_t i = 0; i < length; i++) {
         status_t status = rawParcel->readChar(array + i);
diff --git a/libs/binder/ndk/service_manager.cpp b/libs/binder/ndk/service_manager.cpp
index 14bc5d2b75..31bb7b3194 100644
--- a/libs/binder/ndk/service_manager.cpp
+++ b/libs/binder/ndk/service_manager.cpp
@@ -250,3 +250,28 @@ void AServiceManager_reRegister() {
     auto serviceRegistrar = android::binder::LazyServiceRegistrar::getInstance();
     serviceRegistrar.reRegister();
 }
+
+bool AServiceManager_checkServiceAccess(const char* caller_sid, pid_t caller_debug_pid,
+                                        uid_t caller_uid, const char* instance,
+                                        AServiceManager_PermissionType permission) {
+    LOG_ALWAYS_FATAL_IF(caller_sid == nullptr, "caller_sid == nullptr");
+    LOG_ALWAYS_FATAL_IF(instance == nullptr, "instance == nullptr");
+    String16 permissionString;
+    switch (permission) {
+        case AServiceManager_PermissionType::CHECK_ACCESS_PERMISSION_FIND:
+            permissionString = String16("find");
+            break;
+        case AServiceManager_PermissionType::CHECK_ACCESS_PERMISSION_LIST:
+            permissionString = String16("list");
+            break;
+        case AServiceManager_PermissionType::CHECK_ACCESS_PERMISSION_ADD:
+            permissionString = String16("add");
+            break;
+        default:
+            LOG_ALWAYS_FATAL("Unknown value for permission argument! permission: %d", permission);
+    }
+
+    sp<IServiceManager> sm = defaultServiceManager();
+    return sm->checkServiceAccess(String16(caller_sid), caller_debug_pid, caller_uid,
+                                  String16(instance), permissionString);
+}
diff --git a/libs/binder/ndk/tests/Android.bp b/libs/binder/ndk/tests/Android.bp
index c61a16413b..643a1014fd 100644
--- a/libs/binder/ndk/tests/Android.bp
+++ b/libs/binder/ndk/tests/Android.bp
@@ -116,7 +116,7 @@ cc_test {
     static_libs: [
         "IBinderVendorDoubleLoadTest-cpp",
         "IBinderVendorDoubleLoadTest-ndk",
-        "libbinder_aidl_test_stub-ndk",
+        "servicemanager_aidl-ndk",
     ],
     // critical that libbinder/libbinder_ndk are shared for VTS
     shared_libs: [
diff --git a/libs/binder/ndk/tests/libbinder_ndk_unit_test.cpp b/libs/binder/ndk/tests/libbinder_ndk_unit_test.cpp
index e5a3da460e..19b7676843 100644
--- a/libs/binder/ndk/tests/libbinder_ndk_unit_test.cpp
+++ b/libs/binder/ndk/tests/libbinder_ndk_unit_test.cpp
@@ -1085,6 +1085,39 @@ TEST(NdkBinder, GetClassInterfaceDescriptor) {
     ASSERT_STREQ(IFoo::kIFooDescriptor, AIBinder_Class_getDescriptor(IFoo::kClass));
 }
 
+TEST(NdkBinder, CheckServiceAccessOk) {
+    // This test case runs as su which has access to all services
+    EXPECT_TRUE(AServiceManager_checkServiceAccess(
+            "u:r:su:s0", 0, 0, "adb",
+            AServiceManager_PermissionType::CHECK_ACCESS_PERMISSION_FIND));
+    EXPECT_TRUE(AServiceManager_checkServiceAccess(
+            "u:r:su:s0", 0, 0, "adb",
+            AServiceManager_PermissionType::CHECK_ACCESS_PERMISSION_LIST));
+    EXPECT_TRUE(AServiceManager_checkServiceAccess(
+            "u:r:su:s0", 0, 0, "adb", AServiceManager_PermissionType::CHECK_ACCESS_PERMISSION_ADD));
+}
+
+TEST(NdkBinder, CheckServiceAccessNotOk) {
+    EXPECT_FALSE(AServiceManager_checkServiceAccess(
+            "u:r:some_unknown_sid:s0", 0, 0, "adb",
+            AServiceManager_PermissionType::CHECK_ACCESS_PERMISSION_FIND));
+}
+
+TEST(NdkBinder, InvalidCheckServiceAccessArgs) {
+    constexpr AServiceManager_PermissionType kUnknownPermission =
+            static_cast<AServiceManager_PermissionType>(8000);
+    EXPECT_DEATH(AServiceManager_checkServiceAccess(nullptr, 0, 0, nullptr, kUnknownPermission),
+                 "nullptr");
+    EXPECT_DEATH(AServiceManager_checkServiceAccess("u:r:su:s0", 0, 0, nullptr, kUnknownPermission),
+                 "nullptr");
+    EXPECT_DEATH(AServiceManager_checkServiceAccess("u:r:su:s0", 0, 0, "adb", kUnknownPermission),
+                 "Unknown value for permission argument! permission: 8000");
+    EXPECT_DEATH(AServiceManager_checkServiceAccess(
+                         "u:r:su:s0", 0, 0, nullptr,
+                         AServiceManager_PermissionType::CHECK_ACCESS_PERMISSION_FIND),
+                 "nullptr");
+}
+
 static void addOne(int* to) {
     if (!to) return;
     ++(*to);
diff --git a/libs/binder/rust/Android.bp b/libs/binder/rust/Android.bp
index adef9ea64b..a3f620e67b 100644
--- a/libs/binder/rust/Android.bp
+++ b/libs/binder/rust/Android.bp
@@ -21,6 +21,7 @@ rust_library {
     host_supported: true,
     vendor_available: true,
     product_available: true,
+    recovery_available: true,
     target: {
         darwin: {
             enabled: false,
@@ -87,6 +88,7 @@ rust_library {
     host_supported: true,
     vendor_available: true,
     product_available: true,
+    recovery_available: true,
     target: {
         darwin: {
             enabled: false,
@@ -152,6 +154,7 @@ rust_bindgen {
     host_supported: true,
     vendor_available: true,
     product_available: true,
+    recovery_available: true,
 
     // Currently necessary for host builds
     // TODO(b/31559095): bionic on host should define this
diff --git a/libs/binder/rust/rpcbinder/Android.bp b/libs/binder/rust/rpcbinder/Android.bp
index 46651ceb48..f9641e0424 100644
--- a/libs/binder/rust/rpcbinder/Android.bp
+++ b/libs/binder/rust/rpcbinder/Android.bp
@@ -26,6 +26,7 @@ rust_library {
     ],
     visibility: [
         "//device/google/cuttlefish/shared/minidroid/sample",
+        "//frameworks/native/cmds/servicemanager/rpc_servicemanager",
         "//hardware/interfaces/security/see:__subpackages__",
         "//packages/modules/Virtualization:__subpackages__",
     ],
diff --git a/libs/binder/rust/rpcbinder/src/server/trusty.rs b/libs/binder/rust/rpcbinder/src/server/trusty.rs
index 54d82d5bd0..8e0d6fe512 100644
--- a/libs/binder/rust/rpcbinder/src/server/trusty.rs
+++ b/libs/binder/rust/rpcbinder/src/server/trusty.rs
@@ -14,14 +14,28 @@
  * limitations under the License.
  */
 
+use alloc::boxed::Box;
 use binder::{unstable_api::AsNative, SpIBinder};
 use libc::size_t;
+use log::error;
 use std::ffi::{c_char, c_void};
 use std::ptr;
-use tipc::{ConnectResult, Handle, MessageResult, PortCfg, TipcError, UnbufferedService, Uuid};
-
-pub trait PerSessionCallback: Fn(Uuid) -> Option<SpIBinder> + Send + Sync + 'static {}
-impl<T> PerSessionCallback for T where T: Fn(Uuid) -> Option<SpIBinder> + Send + Sync + 'static {}
+use tipc::{
+    ClientIdentifier, ConnectResult, Handle, MessageResult, PortCfg, TipcError, UnbufferedService,
+    Uuid,
+};
+
+/// Trait alias for the callback passed into the per-session constructor of the RpcServer.
+/// Note: this is used in this file only, although it is marked as pub to be able to be used in
+/// the definition of the pub constructor.
+pub trait PerSessionCallback:
+    Fn(ClientIdentifier) -> Option<SpIBinder> + Send + Sync + 'static
+{
+}
+impl<T> PerSessionCallback for T where
+    T: Fn(ClientIdentifier) -> Option<SpIBinder> + Send + Sync + 'static
+{
+}
 
 pub struct RpcServer {
     inner: *mut binder_rpc_server_bindgen::ARpcServerTrusty,
@@ -52,7 +66,7 @@ impl RpcServer {
     /// Allocates a new per-session RpcServer object.
     ///
     /// Per-session objects take a closure that gets called once
-    /// for every new connection. The closure gets the UUID of
+    /// for every new connection. The closure gets the `ClientIdentifier` of
     /// the peer and can accept or reject that connection.
     pub fn new_per_session<F: PerSessionCallback>(f: F) -> RpcServer {
         // SAFETY: Takes ownership of the returned handle, which has correct refcount.
@@ -68,25 +82,35 @@ impl RpcServer {
 }
 
 unsafe extern "C" fn per_session_callback_wrapper<F: PerSessionCallback>(
-    uuid_ptr: *const c_void,
+    client_id_ptr: *const c_void,
     len: size_t,
     cb_ptr: *mut c_char,
 ) -> *mut binder_rpc_server_bindgen::AIBinder {
     // SAFETY: This callback should only get called while the RpcServer is alive.
     let cb = unsafe { &mut *cb_ptr.cast::<F>() };
 
-    if len != std::mem::size_of::<Uuid>() {
+    if len < 1 {
         return ptr::null_mut();
     }
-
-    // SAFETY: On the previous lines we check that we got exactly the right amount of bytes.
-    let uuid = unsafe {
-        let mut uuid = std::mem::MaybeUninit::<Uuid>::uninit();
-        uuid.as_mut_ptr().copy_from(uuid_ptr.cast(), 1);
-        uuid.assume_init()
+    // SAFETY: We have checked that the length is at least 1
+    // We know that the pointer has not been freed at this point, because:
+    // 1) The pointer is allocated in the call to: `on_connect` or `on_new_connection` in the
+    //    implementation of the `UnbufferredService` trait for `RpcServer`.
+    // 2) `on_connect` and `on_new_connection` invokes `ARpcServerTrusty_handleConnect`, immediately
+    //    after the allocation.
+    // 3) this callback is invoked in the callpath of `ARpcServerTrusty_handleConnect`.
+    // We know that there is no concurrent mutable access to the pointer because it is allocated
+    // and accessed in the same (single) process as per the callpath described above.
+    let client_id_data = unsafe { std::slice::from_raw_parts(client_id_ptr.cast(), len) };
+    let client_id = match ClientIdentifier::from_tagged_bytes(client_id_data) {
+        Ok(c) => c,
+        Err(_) => {
+            error!("error in reconstructing the ClientIdentifier from pointer and length");
+            return ptr::null_mut();
+        }
     };
 
-    cb(uuid).map_or_else(ptr::null_mut, |b| {
+    cb(client_id).map_or_else(ptr::null_mut, |b| {
         // Prevent AIBinder_decStrong from being called before AIBinder_toPlatformBinder.
         // The per-session callback in C++ is supposed to call AIBinder_decStrong on the
         // pointer we return here.
@@ -129,11 +153,21 @@ impl UnbufferedService for RpcServer {
         peer: &Uuid,
     ) -> tipc::Result<ConnectResult<Self::Connection>> {
         let mut conn = RpcServerConnection { ctx: std::ptr::null_mut() };
+        let client_identifier = ClientIdentifier::UUID(peer.clone());
+        let mut data = client_identifier.as_tagged_bytes();
+        let len = data.len();
+        // SAFETY: This unsafe block calls into a C++ function, which is considered safe, i.e. it
+        // does not cause undefined behavior for valid inputs (see below), returns an integer which
+        // indicates success or error, does not allocate or deallocate memory that Rust owns.
+        // The inputs passed into the C++ function are valid: Trusty is single threaded, so there is
+        // no concurrent access to `sef.inner`` and other inputs are not freed/deallocated until the
+        // function returns. Correct length of the data pointed to by the pointer is passed in.
         let rc = unsafe {
             binder_rpc_server_bindgen::ARpcServerTrusty_handleConnect(
                 self.inner,
                 handle.as_raw_fd(),
-                peer.as_ptr().cast(),
+                data.as_mut_ptr() as *const c_void,
+                len,
                 &mut conn.ctx,
             )
         };
@@ -148,9 +182,8 @@ impl UnbufferedService for RpcServer {
         &self,
         conn: &Self::Connection,
         _handle: &Handle,
-        buffer: &mut [u8],
+        _buffer: &mut [u8],
     ) -> tipc::Result<MessageResult> {
-        assert!(buffer.is_empty());
         let rc = unsafe { binder_rpc_server_bindgen::ARpcServerTrusty_handleMessage(conn.ctx) };
         if rc < 0 {
             Err(TipcError::from_uapi(rc.into()))
@@ -162,4 +195,35 @@ impl UnbufferedService for RpcServer {
     fn on_disconnect(&self, conn: &Self::Connection) {
         unsafe { binder_rpc_server_bindgen::ARpcServerTrusty_handleDisconnect(conn.ctx) };
     }
+
+    fn on_new_connection(
+        &self,
+        _port: &PortCfg,
+        handle: &Handle,
+        client_identifier: &ClientIdentifier,
+    ) -> tipc::Result<ConnectResult<Self::Connection>> {
+        let mut conn = RpcServerConnection { ctx: std::ptr::null_mut() };
+        let mut data = client_identifier.as_tagged_bytes();
+        let len = data.len();
+        // SAFETY: This unsafe block calls into a C++ function, which is considered safe, i.e. it
+        // does not cause undefined behavior for valid inputs (see below), returns an integer which
+        // indicates success or error, does not allocate or deallocate memory that Rust owns.
+        // The inputs passed into the C++ function are valid: Trusty is single threaded, so there is
+        // no concurrent access to `sef.inner`` and other inputs are not freed/deallocated until the
+        // function returns. Correct length of the data pointed to by the pointer is passed in.
+        let rc = unsafe {
+            binder_rpc_server_bindgen::ARpcServerTrusty_handleConnect(
+                self.inner,
+                handle.as_raw_fd(),
+                data.as_mut_ptr() as *const c_void,
+                len,
+                &mut conn.ctx,
+            )
+        };
+        if rc < 0 {
+            Err(TipcError::from_uapi(rc.into()))
+        } else {
+            Ok(ConnectResult::Accept(conn))
+        }
+    }
 }
diff --git a/libs/binder/rust/src/lib.rs b/libs/binder/rust/src/lib.rs
index 0026f213f2..8ab36a6799 100644
--- a/libs/binder/rust/src/lib.rs
+++ b/libs/binder/rust/src/lib.rs
@@ -124,6 +124,14 @@ pub use service::{
     get_declared_instances, is_declared, is_handling_transaction, register_lazy_service,
     wait_for_interface, wait_for_service, LazyServiceGuard,
 };
+// TODO(b/402766978) Once LLDNK symbols are supported in rust, this can be along with the rest
+// of the service symbols in vendor variants.
+#[cfg(not(any(trusty, android_ndk, android_vendor, android_vndk)))]
+pub use service::{
+    check_service_access, CHECK_ACCESS_PERMISSION_ADD, CHECK_ACCESS_PERMISSION_FIND,
+    CHECK_ACCESS_PERMISSION_LIST,
+};
+
 #[cfg(not(any(trusty, android_ndk)))]
 #[allow(deprecated)]
 pub use service::{get_interface, get_service};
diff --git a/libs/binder/rust/src/parcel.rs b/libs/binder/rust/src/parcel.rs
index 2d40ced2fd..b6979a225d 100644
--- a/libs/binder/rust/src/parcel.rs
+++ b/libs/binder/rust/src/parcel.rs
@@ -100,6 +100,24 @@ impl Parcel {
         NonNull::new(ptr).map(|ptr| Self { ptr })
     }
 
+    /// Create a new `Parcel` with the raw bytes from the buffer.
+    pub fn unmarshal(buffer: &[u8]) -> Parcel {
+        let parcel = Self::new();
+
+        // Safety: The validity of the raw pointer to an `AParcel` is verified in the
+        // constructor `new`. Providing the raw byte array pointer is also safe since
+        // `AParcel_unmarshal` only borrows the data buffer (it accepts only a const
+        // pointer and deep copies all the data internally). Also, by specifying the
+        // array length with `.len()`, this ensures that `AParcel_unmarshal` only
+        // accesses a valid memory area.
+        status_result(unsafe {
+            sys::AParcel_unmarshal(parcel.ptr.as_ptr(), buffer.as_ptr(), buffer.len())
+        })
+        .expect("AParcel_unmarshal failed");
+
+        parcel
+    }
+
     /// Consume the parcel, transferring ownership to the caller.
     pub(crate) fn into_raw(self) -> *mut sys::AParcel {
         let ptr = self.ptr.as_ptr();
@@ -646,6 +664,30 @@ impl Parcel {
     ) -> Result<()> {
         self.borrowed_ref().resize_nullable_out_vec(out_vec)
     }
+
+    /// Marshals the raw bytes of the Parcel to a buffer.
+    ///
+    /// The parcel must not contain any binders or file descriptors.
+    ///
+    /// The data you retrieve here must not be placed in any kind of persistent
+    /// storage. (on local disk, across a network, etc). For that, you should
+    /// use standard serialization or another kind of general serialization
+    /// mechanism. The Parcel marshalled representation is highly optimized for
+    /// local IPC, and as such does not attempt to maintain compatibility with
+    /// data created in different versions of the platform.
+    pub fn marshal(&self) -> Vec<u8> {
+        let mut buffer = vec![0u8; self.get_data_size() as usize];
+
+        // Safety: `Parcel` always contains a valid pointer to an `AParcel`, by
+        // specifying the length length `.len()`, `AParcel_marshal` ensures it
+        // only writes to an expected, valid memory area.
+        status_result(unsafe {
+            sys::AParcel_marshal(self.ptr.as_ptr(), buffer.as_mut_ptr(), 0, buffer.len())
+        })
+        .expect("Failed to marshal");
+
+        buffer
+    }
 }
 
 // Internal APIs
@@ -959,3 +1001,45 @@ fn test_append_from() {
     assert_eq!(Err(StatusCode::BAD_VALUE), parcel2.append_from(&parcel1, -1, 4));
     assert_eq!(Err(StatusCode::BAD_VALUE), parcel2.append_from(&parcel1, 2, -1));
 }
+
+#[test]
+fn test_marshal() {
+    let mut parcel1 = Parcel::new();
+    parcel1.write(&42i32).unwrap();
+    parcel1.write(&52i32).unwrap();
+    parcel1.write(&62i32).unwrap();
+    parcel1.write(&72i32).unwrap();
+    let buffer = parcel1.marshal();
+
+    assert_eq!(16, buffer.len());
+    assert_eq!(Vec::from("\x2a\0\0\0\x34\0\0\0\x3e\0\0\0\x48\0\0\0"), buffer);
+}
+
+#[test]
+fn test_unmarshal() {
+    // arrange
+    let mut parcel1 = Parcel::new();
+    parcel1.write(&42i32).unwrap();
+    parcel1.write(&52i32).unwrap();
+    parcel1.write(&62i32).unwrap();
+    parcel1.write(&72i32).unwrap();
+
+    let buffer = parcel1.marshal();
+
+    // action
+    let parcel2 = Parcel::unmarshal(&buffer);
+    assert_eq!(16, parcel2.get_data_size());
+
+    // SAFETY: 0 is less than the current size of the parcel data buffer, because the parcel is not
+    // empty.
+    unsafe {
+        parcel2.set_data_position(0).unwrap();
+    }
+    drop(buffer); // Make sure the new parcel does not depend on this.
+
+    // assert
+    assert_eq!(Ok(42i32), parcel2.read::<i32>());
+    assert_eq!(Ok(52i32), parcel2.read::<i32>());
+    assert_eq!(Ok(62i32), parcel2.read::<i32>());
+    assert_eq!(Ok(72i32), parcel2.read::<i32>());
+}
diff --git a/libs/binder/rust/src/parcel/parcelable.rs b/libs/binder/rust/src/parcel/parcelable.rs
index 7f70396882..794edb7ad4 100644
--- a/libs/binder/rust/src/parcel/parcelable.rs
+++ b/libs/binder/rust/src/parcel/parcelable.rs
@@ -607,7 +607,7 @@ impl SerializeOption for str {
                 status_result(sys::AParcel_writeString(
                     parcel.as_native_mut(),
                     s.as_ptr() as *const c_char,
-                    s.as_bytes().len().try_into().or(Err(StatusCode::BAD_VALUE))?,
+                    s.len().try_into().or(Err(StatusCode::BAD_VALUE))?,
                 ))
             },
         }
diff --git a/libs/binder/rust/src/service.rs b/libs/binder/rust/src/service.rs
index f4fdcf51c0..0337397164 100644
--- a/libs/binder/rust/src/service.rs
+++ b/libs/binder/rust/src/service.rs
@@ -18,11 +18,29 @@ use crate::binder::{AsNative, FromIBinder, Strong};
 use crate::error::{status_result, Result, StatusCode};
 use crate::proxy::SpIBinder;
 use crate::sys;
-
+// TODO(b/402766978) Add this back into vendor variants when the LLNDK symbols are supported
+// with something like __builtin_available
+#[cfg(not(any(trusty, android_ndk, android_vendor, android_vndk)))]
+use libc::{pid_t, uid_t};
 use std::ffi::{c_void, CStr, CString};
 use std::os::raw::c_char;
 use std::sync::Mutex;
 
+/// Value to use with check_service_access for permission to "find" a service
+#[cfg(not(any(trusty, android_ndk, android_vendor, android_vndk)))]
+pub const CHECK_ACCESS_PERMISSION_FIND: u32 =
+    sys::AServiceManager_PermissionType::CHECK_ACCESS_PERMISSION_FIND as u32;
+
+/// Value to use with check_service_access for permission to "list" services
+#[cfg(not(any(trusty, android_ndk, android_vendor, android_vndk)))]
+pub const CHECK_ACCESS_PERMISSION_LIST: u32 =
+    sys::AServiceManager_PermissionType::CHECK_ACCESS_PERMISSION_LIST as u32;
+
+/// Value to use with check_service_access for permission to "add" a service
+#[cfg(not(any(trusty, android_ndk, android_vendor, android_vndk)))]
+pub const CHECK_ACCESS_PERMISSION_ADD: u32 =
+    sys::AServiceManager_PermissionType::CHECK_ACCESS_PERMISSION_ADD as u32;
+
 /// Register a new service with the default service manager.
 ///
 /// Registers the given binder object with the given identifier. If successful,
@@ -246,3 +264,55 @@ pub fn get_declared_instances(interface: &str) -> Result<Vec<String>> {
             StatusCode::BAD_VALUE
         })
 }
+
+/// Check if this 'caller_sid' has access for the 'permission' for a given service 'name'.
+///
+/// This is useful when a process will be making calls to servicemanager on behalf of another
+/// process.
+/// caller_sid - SELinux context of the process that is being checked.
+/// caller_debug_pid - Debug PID of the process that is being checked.
+///                    Used for logging denials.
+/// callerUid - UID process that is being checked. Used for logging denials
+/// name - name of the service that the caller wants to interact with
+/// permission - the servicemanager SELinux permission that the process is
+///              interested in for the service. This is one of:
+///                 CHECK_ACCESS_PERMISSION_FIND,
+///                 CHECK_ACCESS_PERMISSION_LIST,
+///                 CHECK_ACCESS_PERMISSION_ADD
+// TODO(b/402766978) Add this back into vendor variants when the LLNDK symbols are supported
+// with something like __builtin_available
+#[cfg(not(any(trusty, android_ndk, android_vendor, android_vndk)))]
+pub fn check_service_access(
+    caller_sid: &str,
+    caller_debug_pid: pid_t,
+    caller_uid: uid_t,
+    name: &str,
+    permission: u32,
+) -> Result<bool> {
+    let caller_sid = CString::new(caller_sid).or(Err(StatusCode::UNEXPECTED_NULL))?;
+    let name = CString::new(name).or(Err(StatusCode::UNEXPECTED_NULL))?;
+    let permission = match permission {
+        CHECK_ACCESS_PERMISSION_FIND => {
+            sys::AServiceManager_PermissionType::CHECK_ACCESS_PERMISSION_FIND
+        }
+        CHECK_ACCESS_PERMISSION_LIST => {
+            sys::AServiceManager_PermissionType::CHECK_ACCESS_PERMISSION_LIST
+        }
+        CHECK_ACCESS_PERMISSION_ADD => {
+            sys::AServiceManager_PermissionType::CHECK_ACCESS_PERMISSION_ADD
+        }
+        _ => return Err(StatusCode::BAD_TYPE),
+    };
+
+    // Safety: The CStrings are valid at this point and are only used during the duration
+    // of the call.
+    unsafe {
+        Ok(sys::AServiceManager_checkServiceAccess(
+            caller_sid.as_ptr(),
+            caller_debug_pid,
+            caller_uid,
+            name.as_ptr(),
+            permission,
+        ))
+    }
+}
diff --git a/libs/binder/servicedispatcher.cpp b/libs/binder/servicedispatcher.cpp
index 78fe2a8714..a992b49c7a 100644
--- a/libs/binder/servicedispatcher.cpp
+++ b/libs/binder/servicedispatcher.cpp
@@ -190,6 +190,11 @@ public:
             std::vector<android::os::ServiceDebugInfo>* _aidl_return) override {
         return mImpl->getServiceDebugInfo(_aidl_return);
     }
+    android::binder::Status checkServiceAccess(
+            const android::os::IServiceManager::CallerContext& callerCtx, const std::string& name,
+            const std::string& permission, bool* _aidl_return) override {
+        return mImpl->checkServiceAccess(callerCtx, name, permission, _aidl_return);
+    }
 
 private:
     sp<android::os::IServiceManager> mImpl;
diff --git a/libs/binder/tests/Android.bp b/libs/binder/tests/Android.bp
index f412dfb6f4..6a98a4ad66 100644
--- a/libs/binder/tests/Android.bp
+++ b/libs/binder/tests/Android.bp
@@ -34,7 +34,10 @@ cc_defaults {
         "-Wsign-compare",
         "-Wunused-result",
         "-Wzero-as-null-pointer-constant",
-    ],
+    ] + select(release_flag("RELEASE_LIBBINDER_BINDER_OBSERVER"), {
+        true: ["-DLIBBINDER_BINDER_OBSERVER"],
+        default: [],
+    }),
 }
 
 cc_test {
@@ -79,6 +82,35 @@ cc_test {
     require_root: true,
 }
 
+cc_test {
+    name: "binderStatsPusherUnitTest",
+    target: {
+        darwin: {
+            enabled: false,
+        },
+    },
+    srcs: [
+        "binderStatsPusherTest.cpp",
+        ":libbinder_observer_sources",
+    ],
+    shared_libs: [
+        "liblog",
+        "libbinder",
+        "libcutils",
+        "libutils",
+    ],
+    static_libs: [
+        "libfakeservicemanager",
+        "libgmock",
+    ],
+    header_libs: [
+        "jni_headers",
+    ],
+    test_suites: ["general-tests"],
+    host_supported: false,
+    require_root: true,
+}
+
 // unit test only, which can run on host and doesn't use /dev/binder
 cc_test {
     name: "binderUnitTest",
@@ -95,11 +127,17 @@ cc_test {
         "binderMemoryHeapBaseUnitTest.cpp",
         "binderRecordedTransactionTest.cpp",
         "binderPersistableBundleTest.cpp",
+        "binderStatsSpscQueueTest.cpp",
     ],
     shared_libs: [
         "libbinder",
         "libcutils",
         "libutils",
+        "liblog",
+    ],
+    static_libs: [
+        "libgmock",
+        "libfakeservicemanager",
     ],
     test_suites: ["general-tests"],
 }
@@ -163,6 +201,7 @@ cc_test {
     ],
     static_libs: [
         "libgmock",
+        "libselinux",
     ],
     test_suites: [
         "general-tests",
@@ -305,6 +344,9 @@ cc_defaults {
         android: {
             test_suites: ["vts"],
         },
+        host: {
+            cflags: ["-DBINDER_NO_KERNEL_IPC_TESTING"],
+        },
     },
     defaults: [
         "binderRpcTest_common_defaults",
@@ -316,11 +358,7 @@ cc_defaults {
         "binderRpcUniversalTests.cpp",
     ],
 
-    // This test uses a lot of resources and takes a long time. Due to
-    // design of several tests, it is also very sensitive to resource
-    // contention on the device. b/276820894
     test_options: {
-        unit_test: false,
         test_runner_options: [
             {
                 name: "native-test-timeout",
@@ -925,6 +963,10 @@ cc_defaults {
         "libbinder_random_parcel",
         "libcutils",
     ],
+    exclude_shared_libs: [
+        "libbase",
+        "libcutils",
+    ],
     target: {
         android: {
             shared_libs: [
@@ -939,6 +981,11 @@ cc_defaults {
                 "libbinder",
                 "libutils",
             ],
+            exclude_shared_libs: [
+                "libbinder_ndk",
+                "libbinder",
+                "libutils",
+            ],
         },
         darwin: {
             enabled: false,
diff --git a/libs/binder/tests/RpcTlsTestUtils.cpp b/libs/binder/tests/RpcTlsTestUtils.cpp
index 6119313e78..630ff376b0 100644
--- a/libs/binder/tests/RpcTlsTestUtils.cpp
+++ b/libs/binder/tests/RpcTlsTestUtils.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "RpcTlsTestUtils"
+#define LOG_TAG "libbinder.RpcTlsTestUtils"
 #include <log/log.h>
 
 #include <binder/RpcTlsTestUtils.h>
diff --git a/libs/binder/tests/binderLibTest.cpp b/libs/binder/tests/binderLibTest.cpp
index 891c0a290c..85626889ee 100644
--- a/libs/binder/tests/binderLibTest.cpp
+++ b/libs/binder/tests/binderLibTest.cpp
@@ -42,6 +42,7 @@
 #include <binder/unique_fd.h>
 #include <input/BlockingQueue.h>
 #include <processgroup/processgroup.h>
+#include <selinux/selinux.h>
 #include <utils/Flattenable.h>
 #include <utils/SystemClock.h>
 #include "binder/IServiceManagerUnitTestHelper.h"
@@ -136,7 +137,8 @@ enum BinderLibTestTranscationCode {
     BINDER_LIB_TEST_LOCK_UNLOCK,
     BINDER_LIB_TEST_PROCESS_LOCK,
     BINDER_LIB_TEST_UNLOCK_AFTER_MS,
-    BINDER_LIB_TEST_PROCESS_TEMPORARY_LOCK
+    BINDER_LIB_TEST_PROCESS_TEMPORARY_LOCK,
+    BINDER_LIB_TEST_BINDER_SPAM,
 };
 
 pid_t start_server_process(int arg2, bool usePoll = false)
@@ -366,6 +368,8 @@ class BinderLibTest : public ::testing::Test {
                     ProcessState::DriverFeature::FREEZE_NOTIFICATION);
         }
 
+        bool checkSelinuxPermissive() { return (security_getenforce() == 0); }
+
         bool getBinderPid(int32_t* pid, sp<IBinder> server) {
             Parcel data, replypid;
             if (server->transact(BINDER_LIB_TEST_GETPID, data, &replypid) != NO_ERROR) {
@@ -610,6 +614,35 @@ TEST_F(BinderLibTest, UnregisterForNotificationsFailure) {
     EXPECT_EQ(BAD_VALUE, sm->unregisterForNotifications(String16("InvalidName!!!"), cb));
 }
 
+TEST_F(BinderLibTest, CheckServiceAccessOk) {
+    // this test runs as su which has access to all services
+    auto sm = defaultServiceManager();
+    EXPECT_TRUE(
+            sm->checkServiceAccess(String16("u:r:su:s0"), 0, 0, String16("adb"), String16("find")));
+}
+
+TEST_F(BinderLibTest, CheckServiceAccessNotOk) {
+    auto sm = defaultServiceManager();
+    if (!checkSelinuxPermissive()) {
+        EXPECT_FALSE(sm->checkServiceAccess(String16("u:r:some_unknown_sid:s0"), 0, 0,
+                                            String16("adb"), String16("find")));
+    } else {
+        GTEST_SKIP() << "Skipping test for disabled SELinux config";
+    }
+}
+
+TEST_F(BinderLibTest, CheckServiceAccessBadArgs) {
+    auto sm = defaultServiceManager();
+    EXPECT_FALSE(sm->checkServiceAccess(String16(""), 0, 0, String16(""), String16("")));
+    EXPECT_FALSE(sm->checkServiceAccess(String16("u:r:su:s0"), 0, 0, String16(""), String16("")));
+    EXPECT_FALSE(
+            sm->checkServiceAccess(String16("u:r:su:s0"), 0, 0, String16("adb"), String16("")));
+    EXPECT_FALSE(
+            sm->checkServiceAccess(String16("u:r:su:s0"), 0, 0, String16(""), String16("find")));
+    EXPECT_FALSE(sm->checkServiceAccess(String16("u:r:su:s"), 0, 0, String16("adb"),
+                                        String16("unknown")));
+}
+
 TEST_F(BinderLibTest, WasParceled) {
     auto binder = sp<BBinder>::make();
     EXPECT_FALSE(binder->wasParceled());
@@ -2103,6 +2136,109 @@ TEST_P(BinderLibRpcTestP, SetRpcClientDebugNoKeepAliveBinder) {
     EXPECT_THAT(binder->setRpcClientDebug(std::move(socket), nullptr),
                 Debuggable(StatusEq(UNEXPECTED_NULL)));
 }
+bool runCommandGetInt(const std::string& command, int& outputValue) {
+    std::string result = "";
+    char buffer[128];
+    FILE* pipe = nullptr;
+
+    pipe = popen(command.c_str(), "r");
+    if (!pipe) {
+        std::cerr << "Error: popen() failed!" << std::endl;
+        return false;
+    }
+
+    while (fgets(buffer, sizeof(buffer), pipe) != nullptr) {
+        result += buffer;
+    }
+
+    if (pclose(pipe) == -1) {
+        std::cerr << "Error: pclose() failed!" << std::endl;
+        return false;
+    }
+
+    // Remove trailing newline characters
+    size_t endPos = result.find_last_not_of("\n\r");
+    if (std::string::npos != endPos) {
+        result = result.substr(0, endPos + 1);
+    } else {
+        result.clear();
+    }
+
+    if (result.empty()) {
+        std::cerr << "Warning: Command output is empty." << std::endl;
+        outputValue = 0;
+        return true;
+    }
+
+    char* endptr;
+    long long convertedValue = std::strtoll(result.c_str(), &endptr, 10);
+
+    // Check for conversion errors
+    if (*endptr != '\0') {
+        std::cerr << "Error: Non-numeric characters found in command output: \"" << result << "\""
+                  << std::endl;
+        outputValue = 0;
+        return false;
+    }
+
+    // Check for integer overflow/underflow
+    if (convertedValue > static_cast<long long>(INT_MAX) ||
+        convertedValue < static_cast<long long>(INT_MIN)) {
+        std::cerr << "Error: Command output value is out of the range of an int: \"" << result
+                  << "\"" << std::endl;
+        outputValue = 0;
+        return false;
+    }
+
+    outputValue = static_cast<int>(convertedValue);
+    return true; // success
+}
+
+// Ensure that this works only for non-recovery android
+#if defined(LIBBINDER_BINDER_OBSERVER) && defined(__ANDROID__) && \
+        !defined(__ANDROID_RECOVERY__) && defined(BINDER_WITH_KERNEL_IPC)
+constexpr bool kEnableBinderObserver = true;
+#else
+constexpr bool kEnableBinderObserver = false;
+#endif
+
+TEST_F(BinderLibRpcTest, BinderObserverIntegrationTest) {
+    if (!kEnableBinderObserver) {
+        GTEST_SKIP() << "Skipping test as BinderObserver isn't enabled";
+        return;
+    }
+
+    // get current count of spam calls made
+    int previousCount;
+    EXPECT_TRUE(
+            runCommandGetInt("cmd stats print-stats | grep \"Atom 1064\" | awk -F '[(),]' '{print "
+                             "$3}'",
+                             previousCount));
+    std::cerr << "previous count: " << previousCount << std::endl;
+
+    // spam calls
+    for (int i = 0; i < 250; i++) {
+        Parcel data, reply;
+        data.writeInt32(i);
+        EXPECT_THAT(m_server->transact(BINDER_LIB_TEST_BINDER_SPAM, data, &reply), NO_ERROR);
+    }
+    std::this_thread::sleep_for(8s);
+    for (int i = 0; i < 250; i++) {
+        Parcel data, reply;
+        data.writeInt32(i);
+        EXPECT_THAT(m_server->transact(BINDER_LIB_TEST_BINDER_SPAM, data, &reply), NO_ERROR);
+    }
+
+    // get latest count and confirm it is higher than previous count.
+    int latestCount;
+    EXPECT_TRUE(runCommandGetInt("cmd stats print-stats | grep \"Atom 1064\" | awk -F '[(),]' "
+                                 "'{print $3}'",
+                                 latestCount));
+    std::cerr << "previous count: " << previousCount << std::endl;
+    std::cerr << "latest count: " << latestCount << std::endl;
+    EXPECT_GT(latestCount, previousCount);
+}
+
 INSTANTIATE_TEST_SUITE_P(BinderLibTest, BinderLibRpcTestP, testing::Bool(),
                          BinderLibRpcTestP::ParamToString);
 
@@ -2527,6 +2663,10 @@ public:
                 t.detach();
                 return NO_ERROR;
             }
+            case BINDER_LIB_TEST_BINDER_SPAM: {
+                // Do nothing. This is supposed to be spammed.
+                return NO_ERROR;
+            }
             default:
                 return UNKNOWN_TRANSACTION;
         };
diff --git a/libs/binder/tests/binderParcelUnitTest.cpp b/libs/binder/tests/binderParcelUnitTest.cpp
index a71da3f384..c4b3299428 100644
--- a/libs/binder/tests/binderParcelUnitTest.cpp
+++ b/libs/binder/tests/binderParcelUnitTest.cpp
@@ -26,6 +26,7 @@ using android::IPCThreadState;
 using android::NO_ERROR;
 using android::OK;
 using android::Parcel;
+using android::PERMISSION_DENIED;
 using android::sp;
 using android::status_t;
 using android::String16;
@@ -356,6 +357,16 @@ TEST(Parcel, AppendWithFdPartial) {
     ASSERT_NE(-1, p1.readFileDescriptor());
 }
 
+TEST(Parcel, AppendOverObject) {
+    Parcel p1;
+    p1.writeDupFileDescriptor(0);
+    Parcel p2;
+    p2.writeInt32(2);
+
+    p1.setDataPosition(8);
+    ASSERT_EQ(PERMISSION_DENIED, p1.appendFrom(&p2, 0, p2.dataSize()));
+}
+
 // Tests a second operation results in a parcel at the same location as it
 // started.
 void parcelOpSameLength(const std::function<void(Parcel*)>& a, const std::function<void(Parcel*)>& b) {
diff --git a/libs/binder/tests/binderRpcTest.cpp b/libs/binder/tests/binderRpcTest.cpp
index 7c9c452c01..f0542cc64b 100644
--- a/libs/binder/tests/binderRpcTest.cpp
+++ b/libs/binder/tests/binderRpcTest.cpp
@@ -42,6 +42,7 @@
 #include <trusty/tipc.h>
 #endif // BINDER_RPC_TO_TRUSTY_TEST
 
+#include "../RpcWireFormat.h"
 #include "../Utils.h"
 #include "binderRpcTestCommon.h"
 #include "binderRpcTestFixture.h"
@@ -733,8 +734,7 @@ TEST_P(BinderRpc, SendTooLargeVector) {
     std::vector<uint8_t> result;
     status_t res = rootIface2->repeatBytes(kTestValue, &result).transactionError();
 
-    // TODO(b/392717039): consistent error results always
-    EXPECT_TRUE(res == -ECONNRESET || res == DEAD_OBJECT) << statusToString(res);
+    EXPECT_EQ(res, DEAD_OBJECT) << statusToString(res);
 
     // died, so remove it for checks in destructor of proc
     proc.proc->sessions.erase(proc.proc->sessions.begin() + 1);
@@ -1061,14 +1061,15 @@ TEST_P(BinderRpc, SendMaxFiles) {
         GTEST_SKIP() << "Would fail trivially (which is tested by BinderRpc::SendFiles)";
     }
 
+    auto transportMode = RpcSession::FileDescriptorTransportMode::UNIX;
     auto proc = createRpcTestSocketServerProcess({
-            .clientFileDescriptorTransportMode = RpcSession::FileDescriptorTransportMode::UNIX,
-            .serverSupportedFileDescriptorTransportModes =
-                    {RpcSession::FileDescriptorTransportMode::UNIX},
+            .clientFileDescriptorTransportMode = transportMode,
+            .serverSupportedFileDescriptorTransportModes = {transportMode},
     });
 
+    size_t maxFds = getRpcTransportModeMaxFds(transportMode);
     std::vector<android::os::ParcelFileDescriptor> files;
-    for (int i = 0; i < 253; i++) {
+    for (size_t i = 0; i < maxFds; i++) {
         files.emplace_back(android::os::ParcelFileDescriptor(mockFileDescriptor("a")));
     }
 
@@ -1078,7 +1079,7 @@ TEST_P(BinderRpc, SendMaxFiles) {
 
     std::string result;
     EXPECT_TRUE(ReadFdToString(out.get(), &result));
-    EXPECT_EQ(result, std::string(253, 'a'));
+    EXPECT_EQ(result, std::string(maxFds, 'a'));
 }
 
 TEST_P(BinderRpc, SendTooManyFiles) {
@@ -1086,14 +1087,15 @@ TEST_P(BinderRpc, SendTooManyFiles) {
         GTEST_SKIP() << "Would fail trivially (which is tested by BinderRpc::SendFiles)";
     }
 
+    auto transportMode = RpcSession::FileDescriptorTransportMode::UNIX;
     auto proc = createRpcTestSocketServerProcess({
-            .clientFileDescriptorTransportMode = RpcSession::FileDescriptorTransportMode::UNIX,
-            .serverSupportedFileDescriptorTransportModes =
-                    {RpcSession::FileDescriptorTransportMode::UNIX},
+            .clientFileDescriptorTransportMode = transportMode,
+            .serverSupportedFileDescriptorTransportModes = {transportMode},
     });
 
+    size_t maxFds = getRpcTransportModeMaxFds(transportMode);
     std::vector<android::os::ParcelFileDescriptor> files;
-    for (int i = 0; i < 254; i++) {
+    for (size_t i = 0; i < maxFds + 1; i++) {
         files.emplace_back(android::os::ParcelFileDescriptor(mockFileDescriptor("a")));
     }
 
@@ -1721,6 +1723,11 @@ TEST_F(BinderARpcNdk, ARpcDelegateAccessorWrongInstance) {
 }
 
 TEST_F(BinderARpcNdk, ARpcDelegateNonAccessor) {
+    // TODO: test in environments we can get a proxied service?
+#ifndef __BIONIC__
+    GTEST_SKIP() << "Can only get AIDL services on device.";
+#endif
+
     auto service = defaultServiceManager()->checkService(String16(kKnownAidlService));
     ASSERT_NE(nullptr, service);
     ndk::SpAIBinder binder = ndk::SpAIBinder(AIBinder_fromPlatformBinder(service));
diff --git a/libs/binder/tests/binderRpcTestTrusty.cpp b/libs/binder/tests/binderRpcTestTrusty.cpp
index 31c0eba1c1..9a6231f47b 100644
--- a/libs/binder/tests/binderRpcTestTrusty.cpp
+++ b/libs/binder/tests/binderRpcTestTrusty.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "binderRpcTest"
+#define LOG_TAG "libbinder.binderRpcTest"
 
 #include <binder/RpcTransportTipcTrusty.h>
 #include <trusty-gtest.h>
@@ -22,6 +22,8 @@
 
 #include "binderRpcTestFixture.h"
 
+#include <algorithm>
+
 using android::binder::unique_fd;
 
 namespace android {
diff --git a/libs/binder/tests/binderStatsPusherTest.cpp b/libs/binder/tests/binderStatsPusherTest.cpp
new file mode 100644
index 0000000000..8e83595556
--- /dev/null
+++ b/libs/binder/tests/binderStatsPusherTest.cpp
@@ -0,0 +1,341 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include <android/os/BnStatsBootstrapAtomService.h> // For mock implementation
+#include <android/os/StatsBootstrapAtom.h>
+#include <android/os/StatsBootstrapAtomValue.h>
+#include <dlfcn.h>
+#include <gmock/gmock.h>
+#include <gtest/gtest.h>
+#include <utils/SystemClock.h>
+
+#include <../BinderStatsPusher.h>
+#include <../BinderStatsUtils.h>
+#include <../JvmUtils.h>
+#include "fakeservicemanager/FakeServiceManager.h"
+
+#include <jni.h>
+
+using android::FakeServiceManager;
+using namespace android;
+using namespace testing;
+
+// --- Mocks ---
+constexpr int64_t kSpamAggregationWindowSec = 5;
+// Mock for IStatsBootstrapAtomService
+class MockStatsBootstrapAtomService : public os::BnStatsBootstrapAtomService {
+public:
+    MOCK_METHOD(binder::Status, reportBootstrapAtom, (const os::StatsBootstrapAtom& atom),
+                (override));
+    MOCK_METHOD(BBinder*, localBinder, (), (override));
+};
+
+// Mock for IServiceManager to control service lookup
+class MockServiceManager : public FakeServiceManager {
+public:
+    MOCK_METHOD(sp<IBinder>, checkService, (const String16& name), (const, override));
+};
+
+// --- Test Fixture ---
+void initServiceManagerOnce() {
+    static std::once_flag gSmOnce;
+    std::call_once(gSmOnce, [] {
+        sp<NiceMock<MockServiceManager>> mockServiceManager =
+                sp<NiceMock<MockServiceManager>>::make();
+        setDefaultServiceManager(mockServiceManager);
+    });
+}
+
+// Helper function to create BinderCallData for tests
+BinderCallData createStatsData(uid_t uid, uint32_t code, const char* desc, int64_t startNanos) {
+    return {.interfaceDescriptor = String16(desc),
+            .transactionCode = code,
+            .startTimeNanos = startNanos,
+            .endTimeNanos = startNanos + 1000,
+            .senderUid = uid};
+}
+
+// Helper function to create a StatsBootstrapAtom for comparison
+os::StatsBootstrapAtom createExpectedAtom(const BinderCallData& datum, int count125, int count250) {
+    auto atom = os::StatsBootstrapAtom();
+    // TODO: use directly from stats/atoms/framework/framework_extension_atoms.proto
+    atom.atomId = 1064; // kBinderSpamAtomId
+    atom.values.push_back(createPrimitiveValue((int64_t)datum.senderUid));
+    atom.values.push_back(createPrimitiveValue((int64_t)getuid())); // host uid
+    atom.values.push_back(createPrimitiveValue(datum.interfaceDescriptor));
+    atom.values.push_back(createPrimitiveValue(std::to_string(datum.transactionCode)));
+    atom.values.push_back(createPrimitiveValue((int32_t)count125));
+    atom.values.push_back(createPrimitiveValue((int32_t)count250));
+    return atom;
+}
+
+// Matcher for StatsBootstrapAtom
+MATCHER_P(StatsAtomEq, expectedAtom, "") {
+    if (arg.atomId != expectedAtom.atomId) return false;
+    if (arg.values.size() != expectedAtom.values.size()) return false;
+    for (size_t i = 0; i < arg.values.size(); ++i) {
+        if (arg.values[i].value.getTag() != expectedAtom.values[i].value.getTag()) return false;
+    }
+    return true;
+}
+
+class BinderStatsPusherTest : public Test {
+protected:
+    sp<StrictMock<MockStatsBootstrapAtomService>> mockStatsService;
+    sp<NiceMock<MockServiceManager>> mockServiceManager;
+    BinderStatsPusher pusher;
+
+    void SetUp() override {
+        mockStatsService = sp<StrictMock<MockStatsBootstrapAtomService>>::make();
+        initServiceManagerOnce();
+        mockServiceManager = sp<NiceMock<MockServiceManager>>::cast(defaultServiceManager());
+        ASSERT_NE(mockServiceManager, nullptr)
+                << "Default service manager is not the expected mock type";
+        // Default behavior: Service Manager returns the mock Stats Service
+        ON_CALL(*mockServiceManager.get(), checkService(String16("statsbootstrap")))
+                .WillByDefault(Return(IInterface::asBinder(mockStatsService)));
+        ON_CALL(*mockStatsService.get(), localBinder()).WillByDefault(Return(nullptr));
+    }
+
+    void TearDown() override { testing::Mock::VerifyAndClear(defaultServiceManager().get()); }
+};
+
+// --- Test Cases ---
+
+TEST_F(BinderStatsPusherTest, GetBootstrapService) {
+    EXPECT_CALL(*mockServiceManager, checkService(String16("statsbootstrap")))
+            .Times(1)
+            .WillOnce(Return(IInterface::asBinder(mockStatsService)));
+
+    auto service = pusher.getBootstrapAtomServiceLocked(15);
+    ASSERT_EQ(service, mockStatsService);
+}
+
+TEST_F(BinderStatsPusherTest, AggregateSpamNoSpamBelowThreshold) {
+    std::vector<BinderCallData> data;
+    int64_t currentTimeSec = 14;
+    // Create data within the delay window (kDelaySeconds = 2)
+    for (int i = 0; i < 50; ++i) { // Less than kMinSpamCount (125)
+        data.push_back(createStatsData(1001, 1, "IFoo", (currentTimeSec - 5) * 1000000000LL));
+    }
+
+    // Expect no calls to reportBootstrapAtom
+    EXPECT_CALL(*mockStatsService, reportBootstrapAtom(_)).Times(0);
+    EXPECT_CALL(*mockStatsService, localBinder()).Times(1);
+
+    pusher.pushLocked(data, currentTimeSec); //  pushLocked calls aggregateBinderSpamLocked
+}
+
+TEST_F(BinderStatsPusherTest, AggregateSpamOneSecondSpam) {
+    std::vector<BinderCallData> data;
+
+    int64_t currentTimeNanos = 9'100'000'000;
+    // Create enough data in the *same second* to trigger spam, far enough in the past
+    for (int i = 0; i < 150; ++i) { // More than kMinSpamCount (125)
+        data.push_back(createStatsData(1001, 1, "IFoo", currentTimeNanos - 8000'000'000));
+    }
+
+    auto expectedAtom = createExpectedAtom(data[0], 1, 0); // 1 second with >= 125 calls
+    EXPECT_CALL(*mockStatsService, reportBootstrapAtom(StatsAtomEq(expectedAtom))).Times(1);
+    EXPECT_CALL(*mockStatsService, localBinder()).Times(1);
+
+    pusher.pushLocked(data, currentTimeNanos / 1000'000'000);
+}
+
+TEST_F(BinderStatsPusherTest, AggregateSpamDelayedSpam) {
+    std::vector<BinderCallData> data;
+    int64_t currentTimeNanos = 9'100'000'000;
+
+    // Create spam data within the delay window (kDelaySeconds = 2)
+    for (int i = 0; i < 150; ++i) {
+        data.push_back(createStatsData(1002, 2, "IBar", currentTimeNanos - 1000'000'000));
+    }
+
+    // Expect no calls, data is delayed
+    EXPECT_CALL(*mockStatsService, reportBootstrapAtom(_)).Times(0);
+    EXPECT_CALL(*mockStatsService, localBinder()).Times(1);
+    pusher.pushLocked(data, currentTimeNanos / 1000'000'000);
+}
+
+TEST_F(BinderStatsPusherTest, AggregateSpamMixedOlderAndDelayed) {
+    std::vector<BinderCallData> data;
+    int64_t currentTimeNanos = 9'100'000'000;
+
+    for (int i = 0; i < 130; ++i) {
+        data.push_back(createStatsData(1003, 3, "IBaz", currentTimeNanos - 8000'000'000));
+    }
+    // Delayed spam data (within kDelaySeconds)
+    for (int i = 0; i < 140; ++i) {
+        data.push_back(createStatsData(1004, 4, "IQux", currentTimeNanos - 1000'000'000));
+    }
+
+    // Expect immediate spam to be reported now
+    auto expectedImmediateAtom = createExpectedAtom(data[0], 1, 0);
+    EXPECT_CALL(*mockStatsService, reportBootstrapAtom(StatsAtomEq(expectedImmediateAtom)))
+            .Times(1);
+    EXPECT_CALL(*mockStatsService, localBinder()).Times(1);
+    pusher.pushLocked(data, currentTimeNanos / 1000'000'000);
+}
+
+TEST_F(BinderStatsPusherTest, AggregateSpamSecondWatermark) {
+    std::vector<BinderCallData> data;
+    int64_t spamTimeNanos = 2'000'000'000LL;
+    int64_t currentTimeSec = (spamTimeNanos / 1000'000'000LL) + kSpamAggregationWindowSec + 1;
+
+    // Create data exceeding the second watermark (250 calls/sec)
+    for (int i = 0; i < 300; ++i) {
+        data.push_back(createStatsData(1005, 5, "IHighVolume", spamTimeNanos));
+    }
+
+    auto expectedAtom = createExpectedAtom(data[0], 1, 1);
+    EXPECT_CALL(*mockStatsService, reportBootstrapAtom(StatsAtomEq(expectedAtom))).Times(1);
+    EXPECT_CALL(*mockStatsService, localBinder()).Times(1);
+
+    pusher.pushLocked(data, currentTimeSec);
+}
+
+TEST_F(BinderStatsPusherTest, AggregateSpamAcrossMultipleSeconds) {
+    std::vector<BinderCallData> data;
+    int64_t firstSpamSecondNanos = 2'000'000'000LL;  // 2s
+    int64_t secondSpamSecondNanos = 3'000'000'000LL; // 3s
+    int64_t currentTimeSec = (secondSpamSecondNanos / 1000'000'000LL) + kSpamAggregationWindowSec +
+            1; // 3 + 5 + 1 = 9s
+
+    // Spam for the first second
+    for (int i = 0; i < 150; ++i) {
+        data.push_back(createStatsData(1006, 6, "IMultiSecond", firstSpamSecondNanos));
+    }
+    // Spam for the second second
+    for (int i = 0; i < 160; ++i) {
+        // Use the same UID, code, desc for aggregation
+        data.push_back(createStatsData(1006, 6, "IMultiSecond", secondSpamSecondNanos));
+    }
+
+    // Expect one atom representing spam across 2 seconds
+    auto expectedAtom = createExpectedAtom(data[0], 2, 0); // 2 seconds with >= 125 calls
+    EXPECT_CALL(*mockStatsService, reportBootstrapAtom(StatsAtomEq(expectedAtom))).Times(1);
+    EXPECT_CALL(*mockStatsService, localBinder()).Times(1);
+
+    pusher.pushLocked(data, currentTimeSec);
+}
+
+TEST_F(BinderStatsPusherTest, AggregateSpamProcessesDelayedDataOnSubsequentCall) {
+    std::vector<BinderCallData> callData1;
+    int64_t callTimeSec1 = 10;
+    int64_t spamDataTimeNanos = (callTimeSec1 - 2) * 1000'000'000LL; // 8s, will be delayed
+
+    for (int i = 0; i < 150; ++i) {
+        callData1.push_back(createStatsData(1007, 7, "IDelayed", spamDataTimeNanos));
+    }
+
+    // First push: data should be buffered as it's too recent
+    EXPECT_CALL(*mockStatsService, reportBootstrapAtom(_)).Times(0);
+    EXPECT_CALL(*mockStatsService, localBinder()).Times(1); // For the first push
+    pusher.pushLocked(callData1, callTimeSec1);
+
+    // Second push: advance time so the previous data is now outside the aggregation window
+    std::vector<BinderCallData> callData2; // Can be empty or contain new data
+    int64_t call2_time_sec = callTimeSec1 + kSpamAggregationWindowSec + 1; // 10 + 5 + 1 = 16s
+
+    auto expectedAtom = createExpectedAtom(callData1[0], 1, 0);
+    EXPECT_CALL(*mockStatsService, reportBootstrapAtom(StatsAtomEq(expectedAtom))).Times(1);
+    EXPECT_CALL(*mockStatsService, localBinder()).Times(1); // For the second push
+
+    pusher.pushLocked(callData2, call2_time_sec);
+}
+
+TEST_F(BinderStatsPusherTest, AggregateSpamForDifferentMethodsSimultaneously) {
+    std::vector<BinderCallData> data;
+    int64_t spamTimeNanos = 4'000'000'000LL; // 4s
+    int64_t currentTimeSec =
+            (spamTimeNanos / 1000'000'000LL) + kSpamAggregationWindowSec + 1; // 4 + 5 + 1 = 10s
+
+    // Spam for method 1
+    BinderCallData method1Spam = createStatsData(1008, 8, "IMultiMethod", spamTimeNanos);
+    for (int i = 0; i < 200; ++i) {
+        data.push_back(method1Spam);
+    }
+
+    // Spam for method 2 (different transaction code)
+    BinderCallData method2Spam = createStatsData(1008, 9, "IMultiMethod", spamTimeNanos);
+    for (int i = 0; i < 200; ++i) {
+        data.push_back(method2Spam);
+    }
+
+    auto expectedAtom1 = createExpectedAtom(method1Spam, 1, 0);
+    auto expectedAtom2 = createExpectedAtom(method2Spam, 1, 0);
+
+    EXPECT_CALL(*mockStatsService, reportBootstrapAtom(_)).Times(2);
+    EXPECT_CALL(*mockStatsService, localBinder()).Times(1);
+
+    pusher.pushLocked(data, currentTimeSec);
+}
+
+TEST_F(BinderStatsPusherTest, SkipPushForLocalBinderWithoutJvm) {
+    // Simulate a local binder service
+    sp<BBinder> localBinderInstance = sp<BBinder>::make();
+    ON_CALL(*mockStatsService.get(), localBinder())
+            .WillByDefault(Return(localBinderInstance.get()));
+    // getJavaVM() is expected to return nullptr in the test environment (JvmUtils.h)
+
+    std::vector<BinderCallData> data;
+    int64_t spamTimeNanos = 2'000'000'000LL;                                                   // 2s
+    int64_t currentTimeSec = (spamTimeNanos / 1000'000'000LL) + kSpamAggregationWindowSec + 1; // 8s
+
+    for (int i = 0; i < 150; ++i) {
+        data.push_back(createStatsData(1009, 10, "ILocalSkipped", spamTimeNanos));
+    }
+
+    EXPECT_CALL(*mockStatsService, reportBootstrapAtom(_)).Times(0); // Should be skipped
+    EXPECT_CALL(*mockStatsService, localBinder()).Times(1);
+
+    pusher.pushLocked(data, currentTimeSec);
+}
+
+TEST_F(BinderStatsPusherTest, DataNotDroppedWhenPushIsSkippedThenSucceeds) {
+    std::vector<BinderCallData> spamCallData1;
+    int64_t timeSec1 = 20;
+    // Data old enough to be processed immediately
+    int64_t spamDataTimeNanos = (timeSec1 - kSpamAggregationWindowSec) * 1000'000'000LL;
+
+    for (int i = 0; i < 150; ++i) { // Enough to trigger kSpamFirstWatermark
+        spamCallData1.push_back(createStatsData(1010, 11, "IServiceSkipped", spamDataTimeNanos));
+    }
+
+    // First push: Service is unavailable
+    EXPECT_CALL(*mockServiceManager, checkService(String16("statsbootstrap")))
+            .Times(1)
+            .WillOnce(Return(nullptr));
+    // localBinder() shouldn't be called if service is null in aggregateBinderSpamLocked
+    EXPECT_CALL(*mockStatsService, localBinder()).Times(0);
+    EXPECT_CALL(*mockStatsService, reportBootstrapAtom(_)).Times(0);
+
+    pusher.pushLocked(spamCallData1, timeSec1);
+    Mock::VerifyAndClearExpectations(mockServiceManager.get());
+    Mock::VerifyAndClearExpectations(mockStatsService.get());
+
+    // Second push: Service becomes available. Advance time beyond service check timeout.
+    std::vector<BinderCallData> spamCallData2; // Empty data for the second call
+    int64_t timeSec2 = timeSec1 + 6;
+
+    EXPECT_CALL(*mockServiceManager, checkService(String16("statsbootstrap")))
+            .Times(1)
+            .WillOnce(Return(IInterface::asBinder(mockStatsService)));
+    EXPECT_CALL(*mockStatsService, localBinder()).Times(1); // Called when service is not null
+    auto expectedAtom = createExpectedAtom(spamCallData1[0], 1, 0);
+    EXPECT_CALL(*mockStatsService, reportBootstrapAtom(StatsAtomEq(expectedAtom))).Times(1);
+
+    pusher.pushLocked(spamCallData2, timeSec2);
+}
diff --git a/libs/binder/tests/binderStatsSpscQueueTest.cpp b/libs/binder/tests/binderStatsSpscQueueTest.cpp
new file mode 100644
index 0000000000..1529b70769
--- /dev/null
+++ b/libs/binder/tests/binderStatsSpscQueueTest.cpp
@@ -0,0 +1,427 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include <gtest/gtest.h>
+#include <log/log.h>
+#include <algorithm>
+#include <atomic>
+#include <latch>
+#include <string>
+#include <thread>
+#include <tuple>
+#include <vector>
+
+#include <../BinderStatsSpscQueue.h>
+#include <../BinderStatsUtils.h> // Include the definition of BinderCallData
+
+using namespace android;
+
+namespace android {
+// Comparison operators for BinderCallData, used in tests.
+bool operator<(const BinderCallData& lhs, const BinderCallData& rhs) {
+    return std::tie(lhs.transactionCode, lhs.senderUid, lhs.interfaceDescriptor, lhs.startTimeNanos,
+                    lhs.endTimeNanos) < std::tie(rhs.transactionCode, rhs.senderUid,
+                                                 rhs.interfaceDescriptor, rhs.startTimeNanos,
+                                                 rhs.endTimeNanos);
+}
+
+bool operator==(const BinderCallData& lhs, const BinderCallData& rhs) {
+    return lhs.transactionCode == rhs.transactionCode && lhs.senderUid == rhs.senderUid &&
+            lhs.interfaceDescriptor == rhs.interfaceDescriptor &&
+            lhs.startTimeNanos == rhs.startTimeNanos && lhs.endTimeNanos == rhs.endTimeNanos;
+}
+} // namespace android
+namespace {
+
+// Test fixture for BinderStatsSpscQueue
+class SpscQueueTest : public ::testing::Test {
+protected:
+    BinderStatsSpscQueue queue;
+};
+
+// Test pushing and popping a single item
+TEST_F(SpscQueueTest, SinglePushPop) {
+    BinderCallData data = {.interfaceDescriptor = String16("IFoo"),
+                           .transactionCode = 1,
+                           .startTimeNanos = 1000,
+                           .endTimeNanos = 2000,
+                           .senderUid = 1001};
+    ASSERT_TRUE(queue.push(data));
+    ASSERT_EQ(queue.length(), 1);
+    std::optional<BinderCallData> popped = queue.tryPop();
+    ASSERT_TRUE(popped.has_value());
+    ASSERT_EQ(popped.value(), data);
+    ASSERT_EQ(queue.length(), 0);
+}
+
+// Test pushing and popping multiple items
+TEST_F(SpscQueueTest, MultiplePushPop) {
+    std::vector<BinderCallData> data_vec;
+    for (int i = 0; i < BinderStatsSpscQueue::kQueueSize; ++i) {
+        BinderCallData data = {.interfaceDescriptor =
+                                       String16(("Iface" + std::to_string(i)).c_str()),
+                               .transactionCode = static_cast<uint32_t>(i),
+                               .startTimeNanos = i * 100,
+                               .endTimeNanos = (i + 1) * 100,
+                               .senderUid = static_cast<uid_t>(1000 + i)};
+        data_vec.push_back(data);
+        ASSERT_TRUE(queue.push(data));
+    }
+    ASSERT_EQ(queue.length(), BinderStatsSpscQueue::kQueueSize);
+
+    for (int i = 0; i < BinderStatsSpscQueue::kQueueSize; ++i) {
+        std::optional<BinderCallData> popped = queue.tryPop();
+        ASSERT_TRUE(popped.has_value());
+        ASSERT_EQ(popped.value(), data_vec[i]);
+    }
+    ASSERT_EQ(queue.length(), 0);
+}
+
+// Test pushing to a full queue
+TEST_F(SpscQueueTest, FullQueue) {
+    for (int i = 0; i < BinderStatsSpscQueue::kQueueSize; ++i) {
+        BinderCallData data = {.transactionCode = static_cast<uint32_t>(i)};
+        ASSERT_TRUE(queue.push(data));
+    }
+    BinderCallData extra_data = {.transactionCode = BinderStatsSpscQueue::kQueueSize + 1};
+    ASSERT_FALSE(queue.push(extra_data)); // Should fail as queue is full
+    ASSERT_EQ(queue.length(), BinderStatsSpscQueue::kQueueSize);
+}
+
+// Test popping from an empty queue
+TEST_F(SpscQueueTest, EmptyQueue) {
+    std::optional<BinderCallData> popped = queue.tryPop();
+    ASSERT_FALSE(popped.has_value());
+}
+
+// Test concurrent push and non-blocking pop
+TEST_F(SpscQueueTest, ConcurrentPushNonBlockingPop) {
+    std::vector<BinderCallData> pushed_values;
+    std::vector<BinderCallData> popped_values;
+    // Latch to synchronize the producer and consumer threads
+    std::latch startTest{2};
+
+    // Start with some data in the queue
+    for (int i = 0; i < BinderStatsSpscQueue::kQueueSize / 2; ++i) {
+        BinderCallData data = {.transactionCode = static_cast<uint32_t>(i)};
+        queue.push(data);
+        pushed_values.push_back(data);
+    }
+
+    std::thread producer([this, &pushed_values, &startTest]() {
+        startTest.count_down();
+        startTest.wait();
+        for (int i = BinderStatsSpscQueue::kQueueSize / 2; i < BinderStatsSpscQueue::kQueueSize;
+             ++i) {
+            BinderCallData data = {.transactionCode = static_cast<uint32_t>(i)};
+            while (!queue.push(data)) {
+                // Spin-wait if push fails (queue is temporarily full)
+                std::this_thread::yield();
+            }
+            pushed_values.push_back(data);
+        }
+    });
+
+    // Capture producer by reference to check its state.
+    std::thread consumer([this, &popped_values, &startTest, &producer]() {
+        startTest.count_down();
+        startTest.wait();
+        size_t popped_count = 0;
+        // Try to pop BinderStatsSpscQueue::kQueueSize items, but stop if the queue becomes empty
+        while (popped_count < BinderStatsSpscQueue::kQueueSize) {
+            std::optional<BinderCallData> popped = queue.tryPop();
+            if (popped.has_value()) {
+                popped_values.push_back(popped.value());
+                popped_count++;
+            } else {
+                // Queue might be temporarily empty, yield and retry
+                std::this_thread::yield();
+            }
+        }
+    });
+
+    producer.join(); // Wait for producer to finish
+    consumer.join(); // Wait for consumer to finish
+
+    ALOGI("Size of pushed_values: %zu", pushed_values.size());
+    ALOGI("Size of popped_values: %zu", popped_values.size());
+
+    ASSERT_EQ(popped_values.size(), pushed_values.size());
+    ASSERT_EQ(popped_values, pushed_values);
+}
+
+// Helper function to create dummy BinderCallData
+BinderCallData createDummyData(int id) {
+    return {.interfaceDescriptor = String16(("ITest" + std::to_string(id)).c_str()),
+            .transactionCode = static_cast<uint32_t>(id),
+            .startTimeNanos = id * 100,
+            .endTimeNanos = (id + 1) * 100,
+            .senderUid = static_cast<uid_t>(1000 + id)};
+}
+
+// Test fixture for BinderStatsCollector
+class BinderStatsCollectorTest : public ::testing::Test {
+protected:
+    BinderStatsCollector collector;
+};
+
+// Test registering a single queue and consuming data from it
+TEST_F(BinderStatsCollectorTest, RegisterSingleQueueAndConsume) {
+    auto queue = std::make_shared<BinderStatsSpscQueue>();
+    ASSERT_NE(queue, nullptr);
+
+    BinderCallData data1 = createDummyData(1);
+    BinderCallData data2 = createDummyData(2);
+
+    ASSERT_TRUE(queue->push(data1));
+    ASSERT_TRUE(queue->push(data2));
+    ASSERT_EQ(queue->length(), 2);
+
+    collector.registerQueue(queue);
+
+    std::vector<BinderCallData> consumedData = collector.consumeData();
+
+    ASSERT_EQ(consumedData.size(), 2);
+    // consumeData doesn't guarantee order if multiple queues exist,
+    // but with one queue, the order should be preserved.
+    EXPECT_EQ(consumedData[0], data1);
+    EXPECT_EQ(consumedData[1], data2);
+
+    // Verify the queue is now empty
+    EXPECT_EQ(queue->length(), 0);
+    EXPECT_FALSE(queue->tryPop().has_value());
+}
+
+// Test registering multiple queues and consuming data
+TEST_F(BinderStatsCollectorTest, RegisterMultipleQueuesAndConsume) {
+    auto queue1 = std::make_shared<BinderStatsSpscQueue>();
+    auto queue2 = std::make_shared<BinderStatsSpscQueue>();
+    ASSERT_NE(queue1, nullptr);
+    ASSERT_NE(queue2, nullptr);
+
+    BinderCallData data1 = createDummyData(1);
+    BinderCallData data2 = createDummyData(2);
+    BinderCallData data3 = createDummyData(3);
+
+    ASSERT_TRUE(queue1->push(data1));
+    ASSERT_TRUE(queue2->push(data2));
+    ASSERT_TRUE(queue1->push(data3));
+
+    ASSERT_EQ(queue1->length(), 2);
+    ASSERT_EQ(queue2->length(), 1);
+
+    collector.registerQueue(queue1);
+    collector.registerQueue(queue2);
+
+    std::vector<BinderCallData> consumedData = collector.consumeData();
+
+    ASSERT_EQ(consumedData.size(), 3);
+
+    // Verify the queues are now empty
+    EXPECT_EQ(queue1->length(), 0);
+    EXPECT_EQ(queue2->length(), 0);
+    EXPECT_FALSE(queue1->tryPop().has_value());
+    EXPECT_FALSE(queue2->tryPop().has_value());
+
+    std::vector<BinderCallData> expected = {data1, data2, data3};
+    std::sort(expected.begin(), expected.end());
+    std::sort(consumedData.begin(), consumedData.end());
+    EXPECT_EQ(consumedData, expected);
+}
+
+// Test consuming data when no queues are registered
+TEST_F(BinderStatsCollectorTest, ConsumeWithNoQueues) {
+    std::vector<BinderCallData> consumedData = collector.consumeData();
+    EXPECT_TRUE(consumedData.empty());
+}
+
+// Test consuming data from empty queues
+TEST_F(BinderStatsCollectorTest, ConsumeFromEmptyQueues) {
+    auto queue1 = std::make_shared<BinderStatsSpscQueue>();
+    auto queue2 = std::make_shared<BinderStatsSpscQueue>();
+    ASSERT_NE(queue1, nullptr);
+    ASSERT_NE(queue2, nullptr);
+
+    collector.registerQueue(queue1);
+    collector.registerQueue(queue2);
+
+    std::vector<BinderCallData> consumedData = collector.consumeData();
+    EXPECT_TRUE(consumedData.empty());
+    EXPECT_EQ(queue1->length(), 0);
+    EXPECT_EQ(queue2->length(), 0);
+}
+
+// Test deregistering a queue
+TEST_F(BinderStatsCollectorTest, DeregisterQueue) {
+    auto queue1 = std::make_shared<BinderStatsSpscQueue>();
+    auto queue2 = std::make_shared<BinderStatsSpscQueue>();
+    ASSERT_NE(queue1, nullptr);
+    ASSERT_NE(queue2, nullptr);
+
+    BinderCallData data1 = createDummyData(1);
+    BinderCallData data2 = createDummyData(2);
+    BinderCallData data3 = createDummyData(3); // Will be added after deregister
+    BinderCallData data4 = createDummyData(4); // Will be added after deregister
+
+    // Register both queues
+    collector.registerQueue(queue1);
+    collector.registerQueue(queue2);
+
+    // Add initial data
+    ASSERT_TRUE(queue1->push(data1));
+    ASSERT_TRUE(queue2->push(data2));
+    ASSERT_EQ(queue1->length(), 1);
+    ASSERT_EQ(queue2->length(), 1);
+
+    // Deregister queue1
+    collector.deregisterQueue(queue1);
+
+    // Consume data - this should consume data1 and data2, and mark queue1 for deletion
+    std::vector<BinderCallData> consumedData1 = collector.consumeData();
+    ASSERT_EQ(consumedData1.size(), 2);
+    EXPECT_EQ(queue1->length(), 0); // queue1 should be empty now
+    EXPECT_EQ(queue2->length(), 0);
+
+    // Add new data *after* deregistering and consuming once
+    ASSERT_TRUE(queue1->push(data3)); // Data pushed to the deregistered queue
+    ASSERT_TRUE(queue2->push(data4)); // Data pushed to the still registered queue
+    ASSERT_EQ(queue1->length(), 1);
+    ASSERT_EQ(queue2->length(), 1);
+
+    // Consume data again - this should only consume data4 from queue2
+    // because queue1 should have been removed during the cleanup phase
+    // of the previous consumeData call.
+    std::vector<BinderCallData> consumedData2 = collector.consumeData();
+    ASSERT_EQ(consumedData2.size(), 1);
+
+    // Verify only data4 was consumed
+    bool found4 = false;
+    for (const auto& item : consumedData2) {
+        if (item == data4) found4 = true;
+    }
+    EXPECT_TRUE(found4);
+
+    // Verify queue1 still contains data3 (it wasn't consumed) and queue2 is empty
+    EXPECT_EQ(queue1->length(), 1);
+    EXPECT_EQ(queue2->length(), 0);
+    auto remainingInQueue1 = queue1->tryPop();
+    ASSERT_TRUE(remainingInQueue1.has_value());
+    EXPECT_EQ(remainingInQueue1.value(), data3);
+}
+
+// Test deregistering a queue that was never registered
+TEST_F(BinderStatsCollectorTest, DeregisterNonExistentQueue) {
+    auto queue1 = std::make_shared<BinderStatsSpscQueue>();
+    auto queue2 = std::make_shared<BinderStatsSpscQueue>();
+    ASSERT_NE(queue1, nullptr);
+    ASSERT_NE(queue2, nullptr);
+
+    collector.registerQueue(queue1);
+    // Attempt to deregister queue2 which was never registered
+    collector.deregisterQueue(queue2);
+
+    // Add data to queue1
+    BinderCallData data1 = createDummyData(1);
+    ASSERT_TRUE(queue1->push(data1));
+
+    // Consume data - should still get data from queue1
+    std::vector<BinderCallData> consumedData = collector.consumeData();
+    ASSERT_EQ(consumedData.size(), 1);
+    EXPECT_EQ(consumedData[0], data1);
+    EXPECT_EQ(queue1->length(), 0);
+}
+
+// Test concurrent push from multiple queues and a single consumer
+TEST_F(BinderStatsCollectorTest, ConcurrentMultiQueuePushAndConsume) {
+    const int numProducerThreads = 4;
+    const int itemsPerThread = 1000 * BinderStatsSpscQueue::kQueueSize;
+    const int totalItems = numProducerThreads * itemsPerThread;
+
+    std::vector<std::shared_ptr<BinderStatsSpscQueue>> queues;
+    for (int i = 0; i < numProducerThreads; ++i) {
+        auto queue = std::make_shared<BinderStatsSpscQueue>();
+        ASSERT_NE(queue, nullptr);
+        queues.push_back(queue);
+    }
+
+    std::vector<std::thread> producers;
+    std::vector<BinderCallData> allPushedItems;
+    allPushedItems.reserve(totalItems);
+    // populate allPushedItems
+    for (int i = 0; i < numProducerThreads; ++i) {
+        for (int j = 0; j < itemsPerThread; ++j) {
+            // Create unique data for each item from each thread
+            BinderCallData data = createDummyData(i * itemsPerThread + j);
+            allPushedItems.push_back(data);
+        }
+    }
+
+    // Latch to synchronize the start of all threads
+    std::latch startTestLatch(numProducerThreads + 1);
+
+    for (int i = 0; i < numProducerThreads; ++i) {
+        producers.emplace_back([&, i]() {
+            startTestLatch.count_down();
+            startTestLatch.wait();
+            collector.registerQueue(queues[i]);
+            std::vector<BinderCallData> threadPushedItems;
+            for (int j = 0; j < itemsPerThread; ++j) {
+                // Create unique data for each item from each thread
+                BinderCallData data = createDummyData(i * itemsPerThread + j);
+                while (!queues[i]->push(data)) {
+                    std::this_thread::yield();
+                }
+                threadPushedItems.push_back(data);
+            }
+            collector.deregisterQueue(queues[i]);
+        });
+    }
+
+    std::vector<BinderCallData> consumedItems;
+    consumedItems.reserve(totalItems);
+
+    std::thread consumer([&]() {
+        startTestLatch.count_down();
+        startTestLatch.wait();
+        while (consumedItems.size() < totalItems) {
+            std::vector<BinderCallData> batch = collector.consumeData();
+            consumedItems.insert(consumedItems.end(), batch.begin(), batch.end());
+            if (batch.empty() && consumedItems.size() < totalItems) {
+                std::this_thread::yield(); // Avoid busy-waiting if consumer is faster
+            }
+        }
+    });
+
+    for (auto& producer : producers) {
+        producer.join();
+    }
+    consumer.join();
+
+    ASSERT_EQ(consumedItems.size(), totalItems);
+    ASSERT_EQ(allPushedItems.size(), totalItems);
+
+    // The order of items from different queues isn't guaranteed by consumeData,
+    // so we sort both lists before comparing.
+    std::sort(allPushedItems.begin(), allPushedItems.end());
+    std::sort(consumedItems.begin(), consumedItems.end());
+    EXPECT_EQ(consumedItems, allPushedItems);
+
+    // Verify all queues are empty
+    for (const auto& q : queues) {
+        EXPECT_EQ(q->length(), 0);
+    }
+}
+
+} // namespace
diff --git a/libs/binder/tests/binderThroughputTest.cpp b/libs/binder/tests/binderThroughputTest.cpp
index f912348689..f40062ab16 100644
--- a/libs/binder/tests/binderThroughputTest.cpp
+++ b/libs/binder/tests/binderThroughputTest.cpp
@@ -7,6 +7,7 @@
 #include <cstdlib>
 #include <cstdio>
 
+#include <algorithm>
 #include <fstream>
 #include <iostream>
 #include <tuple>
diff --git a/libs/binder/tests/parcel_fuzzer/Android.bp b/libs/binder/tests/parcel_fuzzer/Android.bp
index 457eaa5a76..a8ff9d5658 100644
--- a/libs/binder/tests/parcel_fuzzer/Android.bp
+++ b/libs/binder/tests/parcel_fuzzer/Android.bp
@@ -13,8 +13,8 @@ aidl_interface {
     unstable: true,
     srcs: [
         "parcelables/EmptyParcelable.aidl",
-        "parcelables/SingleDataParcelable.aidl",
         "parcelables/GenericDataParcelable.aidl",
+        "parcelables/SingleDataParcelable.aidl",
     ],
     flags: [
         "-Werror",
@@ -52,27 +52,28 @@ cc_fuzz {
         "random_parcel.cpp",
     ],
     static_libs: [
+        "binderReadParcelIface-cpp",
+        "binderReadParcelIface-ndk",
         "libbase",
         "libbinder_random_parcel",
         "libcutils",
         "libhidlbase",
-        "liblog",
-        "binderReadParcelIface-cpp",
-        "binderReadParcelIface-ndk",
     ],
 
     target: {
         android: {
             shared_libs: [
-                "libbinder_ndk",
                 "libbinder",
+                "libbinder_ndk",
+                "liblog",
                 "libutils",
             ],
         },
         host: {
             static_libs: [
-                "libbinder_ndk",
                 "libbinder",
+                "libbinder_ndk",
+                "liblog",
                 "libutils",
             ],
         },
@@ -96,11 +97,11 @@ cc_library_static {
         },
     },
     srcs: [
+        "libbinder_driver.cpp",
+        "libbinder_ndk_driver.cpp",
         "random_binder.cpp",
         "random_fd.cpp",
         "random_parcel.cpp",
-        "libbinder_driver.cpp",
-        "libbinder_ndk_driver.cpp",
     ],
     shared_libs: [
         "libbase",
@@ -163,7 +164,7 @@ cc_binary_host {
     shared_libs: [
         "libbase",
         "libbinder",
-        "libutils",
         "libcutils",
+        "libutils",
     ],
 }
diff --git a/libs/binder/tests/parcel_fuzzer/binder.cpp b/libs/binder/tests/parcel_fuzzer/binder.cpp
index b2ba1ae38d..342c3d014d 100644
--- a/libs/binder/tests/parcel_fuzzer/binder.cpp
+++ b/libs/binder/tests/parcel_fuzzer/binder.cpp
@@ -62,13 +62,17 @@ public:
         FUZZ_LOG() << "should not reach";
         abort();
     }
-    status_t unflatten(void const*& buffer, size_t& size, int const*& /*fds*/, size_t& /*count*/) {
+    status_t unflatten(void const*& buffer, size_t& size, int const*& fds, size_t& count) {
+        for (size_t i = 0; i < count; i++) {
+            close(fds[i]);
+        }
         if (size < sizeof(mValue)) {
             return android::NO_MEMORY;
         }
         android::FlattenableUtils::read(buffer, size, mValue);
         return android::OK;
     }
+
 private:
     int32_t mValue = 0xFEEDBEEF;
 };
diff --git a/libs/binder/tests/parcel_fuzzer/main.cpp b/libs/binder/tests/parcel_fuzzer/main.cpp
index d06b2d9020..294195c988 100644
--- a/libs/binder/tests/parcel_fuzzer/main.cpp
+++ b/libs/binder/tests/parcel_fuzzer/main.cpp
@@ -25,13 +25,17 @@
 #include <android-base/logging.h>
 #include <android/binder_auto_utils.h>
 #include <android/binder_libbinder.h>
+#include <binder/ProcessState.h>
+#include <binder/Trace.h>
 #include <fuzzbinder/random_parcel.h>
 #include <fuzzer/FuzzedDataProvider.h>
+#include <hwbinder/ProcessState.h>
 
-#include <cstdlib>
-#include <ctime>
 #include <sys/resource.h>
 #include <sys/time.h>
+#include <cstdlib>
+#include <ctime>
+#include <filesystem>
 
 #include "../../Utils.h"
 
@@ -39,6 +43,7 @@ using android::fillRandomParcel;
 using android::RandomParcelOptions;
 using android::sp;
 using android::HexString;
+std::once_flag gOpenFds;
 
 void fillRandomParcel(::android::hardware::Parcel* p, FuzzedDataProvider&& provider,
                       RandomParcelOptions* options) {
@@ -157,11 +162,27 @@ static AIBinder_Class* kNothingClass =
         AIBinder_Class_define("nothing", NothingClass_onCreate, NothingClass_onDestroy,
                               NothingClass_onTransact);
 
+static long numFds() {
+    return std::distance(std::filesystem::directory_iterator("/proc/self/fd"),
+                         std::filesystem::directory_iterator{});
+}
 extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
     if (size <= 1) return 0;  // no use
 
     // avoid timeouts, see b/142617274, b/142473153
     if (size > 50000) return 0;
+    std::call_once(gOpenFds, []() {
+        // Cause the known FDs to be created before we track them.
+        android::binder::ScopedTrace openYourFds(ATRACE_TAG_AIDL, "Open FDs");
+        (void)android::ProcessState::self();
+        (void)android::hardware::ProcessState::self();
+        ALOGE("Logging creates a socked + a pmsg FD");
+    });
+
+    struct rlimit limit{};
+    CHECK_EQ(0, getrlimit(RLIMIT_NOFILE, &limit));
+    uint64_t maxFds = limit.rlim_cur;
+    int initialFds = numFds();
 
     FuzzedDataProvider provider = FuzzedDataProvider(data, size);
 
@@ -209,5 +230,6 @@ extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
 
     provider.PickValueInArray(fuzzBackend)(std::move(provider));
 
+    CHECK_EQ(initialFds, numFds()) << "FDs are being leaked";
     return 0;
 }
diff --git a/libs/binder/tests/parcel_fuzzer/random_binder.cpp b/libs/binder/tests/parcel_fuzzer/random_binder.cpp
index f41c35bfbe..8980adb466 100644
--- a/libs/binder/tests/parcel_fuzzer/random_binder.cpp
+++ b/libs/binder/tests/parcel_fuzzer/random_binder.cpp
@@ -76,13 +76,16 @@ sp<IBinder> getRandomBinder(FuzzedDataProvider* provider) {
 
                 return new RandomBinder(String16(str.c_str()), std::move(bytes));
             },
+#ifdef __ANDROID__
             []() {
                 // this is the easiest remote binder to get ahold of, and it
                 // should be able to handle anything thrown at it, and
                 // essentially every process can talk to it, so it's a good
                 // candidate for checking usage of an actual BpBinder
+                // This only works on an Android device with binder enabled
                 return IInterface::asBinder(defaultServiceManager());
             },
+#endif
             [&]() -> sp<IBinder> { return nullptr; },
     });
     return makeFunc();
diff --git a/libs/binder/tests/parcel_fuzzer/random_fd.cpp b/libs/binder/tests/parcel_fuzzer/random_fd.cpp
index c7d15337b5..070079e044 100644
--- a/libs/binder/tests/parcel_fuzzer/random_fd.cpp
+++ b/libs/binder/tests/parcel_fuzzer/random_fd.cpp
@@ -55,7 +55,8 @@ std::vector<unique_fd> getRandomFds(FuzzedDataProvider* provider) {
                  // TODO(b/236812909): also test blocking
                  if (true) flags |= O_NONBLOCK;
 
-                 CHECK_EQ(0, pipe2(pipefds, flags)) << flags;
+                 CHECK_EQ(0, pipe2(pipefds, flags))
+                         << "flags: " << flags << ", errno: " << strerror(errno);
 
                  if (provider->ConsumeBool()) std::swap(pipefds[0], pipefds[1]);
 
diff --git a/libs/binder/tests/rpc_fuzzer/Android.bp b/libs/binder/tests/rpc_fuzzer/Android.bp
index ab72bfd2b5..b27bedc35a 100644
--- a/libs/binder/tests/rpc_fuzzer/Android.bp
+++ b/libs/binder/tests/rpc_fuzzer/Android.bp
@@ -23,16 +23,16 @@ cc_fuzz {
     // Not using libbinder_tls_shared_deps to use deterministic boringssl libraries.
     static_libs: [
         "libbase",
-        "libcutils",
-        "liblog",
         "libbinder_test_utils",
         "libbinder_tls_static",
         "libbinder_tls_test_utils",
-        "libssl_fuzz_unsafe",
         "libcrypto_fuzz_unsafe",
+        "libcutils",
+        "liblog",
+        "libssl_fuzz_unsafe",
     ],
     cflags: [
-        "-DBORINGSSL_UNSAFE_DETERMINISTIC_MODE", // for RAND_reset_for_fuzzing
+        "-DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION", // for RAND_reset_for_fuzzing
     ],
     target: {
         android: {
diff --git a/libs/binder/trusty/RpcServerTrusty.cpp b/libs/binder/trusty/RpcServerTrusty.cpp
index 05800464ac..78e751bcda 100644
--- a/libs/binder/trusty/RpcServerTrusty.cpp
+++ b/libs/binder/trusty/RpcServerTrusty.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "RpcServerTrusty"
+#define LOG_TAG "libbinder.RpcServerTrusty"
 
 #include <binder/Parcel.h>
 #include <binder/RpcServer.h>
@@ -97,11 +97,13 @@ RpcServerTrusty::RpcServerTrusty(std::unique_ptr<RpcTransportCtx> ctx, std::stri
 int RpcServerTrusty::handleConnect(const tipc_port* port, handle_t chan, const uuid* peer,
                                    void** ctx_p) {
     auto* server = reinterpret_cast<RpcServerTrusty*>(const_cast<void*>(port->priv));
-    return handleConnectInternal(server->mRpcServer.get(), chan, peer, ctx_p);
+    const void* uuid_ptr = static_cast<const void*>(peer);
+    constexpr size_t uuidLen = sizeof(*peer);
+    return handleConnectInternal(server->mRpcServer.get(), chan, uuid_ptr, uuidLen, ctx_p);
 }
 
-int RpcServerTrusty::handleConnectInternal(RpcServer* rpcServer, handle_t chan, const uuid* peer,
-                                           void** ctx_p) {
+int RpcServerTrusty::handleConnectInternal(RpcServer* rpcServer, handle_t chan,
+                                           const void* addrData, size_t addrDataLen, void** ctx_p) {
     rpcServer->mShutdownTrigger = FdTrigger::make();
     rpcServer->mConnectingThreads[rpc_this_thread::get_id()] = RpcMaybeThread();
 
@@ -137,10 +139,12 @@ int RpcServerTrusty::handleConnectInternal(RpcServer* rpcServer, handle_t chan,
     android::RpcTransportFd transportFd(std::move(clientFd));
 
     std::array<uint8_t, RpcServer::kRpcAddressSize> addr;
-    constexpr size_t addrLen = sizeof(*peer);
-    memcpy(addr.data(), peer, addrLen);
+    if (addrDataLen > RpcServer::kRpcAddressSize) {
+        return ERR_BAD_LEN;
+    }
+    memcpy(addr.data(), addrData, addrDataLen);
     RpcServer::establishConnection(sp<RpcServer>::fromExisting(rpcServer), std::move(transportFd),
-                                   addr, addrLen, joinFn);
+                                   addr, addrDataLen, joinFn);
 
     return rc;
 }
diff --git a/libs/binder/trusty/RpcTransportTipcTrusty.cpp b/libs/binder/trusty/RpcTransportTipcTrusty.cpp
index 65ad896026..0b60ce9618 100644
--- a/libs/binder/trusty/RpcTransportTipcTrusty.cpp
+++ b/libs/binder/trusty/RpcTransportTipcTrusty.cpp
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "RpcTransportTipcTrusty"
+#define LOG_TAG "libbinder.RpcTransportTipcTrusty"
 
 #include <inttypes.h>
 #include <trusty_ipc.h>
diff --git a/libs/binder/trusty/include/binder/ARpcServerTrusty.h b/libs/binder/trusty/include/binder/ARpcServerTrusty.h
index c82268b47b..6983bc0806 100644
--- a/libs/binder/trusty/include/binder/ARpcServerTrusty.h
+++ b/libs/binder/trusty/include/binder/ARpcServerTrusty.h
@@ -28,7 +28,7 @@ struct ARpcServerTrusty* ARpcServerTrusty_newPerSession(struct AIBinder* (*)(con
                                                                              char*),
                                                         char*, void (*)(char*));
 void ARpcServerTrusty_delete(struct ARpcServerTrusty*);
-int ARpcServerTrusty_handleConnect(struct ARpcServerTrusty*, handle_t, const struct uuid*, void**);
+int ARpcServerTrusty_handleConnect(struct ARpcServerTrusty*, handle_t, const void*, size_t, void**);
 int ARpcServerTrusty_handleMessage(void*);
 void ARpcServerTrusty_handleDisconnect(void*);
 void ARpcServerTrusty_handleChannelCleanup(void*);
diff --git a/libs/binder/trusty/include/binder/RpcServerTrusty.h b/libs/binder/trusty/include/binder/RpcServerTrusty.h
index 1ac00ca13f..cd6ae1a635 100644
--- a/libs/binder/trusty/include/binder/RpcServerTrusty.h
+++ b/libs/binder/trusty/include/binder/RpcServerTrusty.h
@@ -100,7 +100,7 @@ private:
         // The default behavior in trusty is to allow handles to be passed with tipc IPC.
         // We add mode NONE so that servers do not reject connections from clients who do
         // not change their default transport mode.
-        static const std::vector<RpcSession::FileDescriptorTransportMode>
+        [[clang::no_destroy]] static const std::vector<RpcSession::FileDescriptorTransportMode>
                 TRUSTY_SERVER_SUPPORTED_FD_MODES = {RpcSession::FileDescriptorTransportMode::TRUSTY,
                                                     RpcSession::FileDescriptorTransportMode::NONE};
 
@@ -114,7 +114,19 @@ private:
                                                                                 char*),
                                                                 char*, void (*)(char*));
     friend void ::ARpcServerTrusty_delete(::ARpcServerTrusty*);
-    friend int ::ARpcServerTrusty_handleConnect(::ARpcServerTrusty*, handle_t, const uuid*, void**);
+    /**
+     * @brief Handle the binder RPC connection.
+     *
+     * @param rstr  - RpcServer object
+     * @param chan - handle to the connection
+     * @param clientId - identifier of the client as tagged data
+     * @param clientIdLen - length of the client identifier
+     * @param ctx_p - connection context
+     * @return int - error code
+     */
+    friend int ::ARpcServerTrusty_handleConnect(struct ARpcServerTrusty* rstr, handle_t chan,
+                                                const void* clientId, size_t clientIdLen,
+                                                void** ctx_p);
     friend int ::ARpcServerTrusty_handleMessage(void*);
     friend void ::ARpcServerTrusty_handleDisconnect(void*);
     friend void ::ARpcServerTrusty_handleChannelCleanup(void*);
@@ -130,8 +142,8 @@ private:
     static void handleDisconnect(const tipc_port* port, handle_t chan, void* ctx);
     static void handleChannelCleanup(void* ctx);
 
-    static int handleConnectInternal(RpcServer* rpcServer, handle_t chan, const uuid* peer,
-                                     void** ctx_p);
+    static int handleConnectInternal(RpcServer* rpcServer, handle_t chan, const void* addrData,
+                                     size_t addrDataLen, void** ctx_p);
     static int handleMessageInternal(void* ctx);
     static void handleDisconnectInternal(void* ctx);
 
diff --git a/libs/binder/trusty/include_mock/trusty_ipc.h b/libs/binder/trusty/include_mock/trusty_ipc.h
index db044c2c04..01f01b7162 100644
--- a/libs/binder/trusty/include_mock/trusty_ipc.h
+++ b/libs/binder/trusty/include_mock/trusty_ipc.h
@@ -33,6 +33,8 @@
 #define IPC_HANDLE_POLL_MSG 0x2
 #define IPC_HANDLE_POLL_SEND_UNBLOCKED 0x4
 
+#define VIRTIO_VSOCK_MSG_SIZE_LIMIT 4096
+
 typedef int handle_t;
 
 typedef struct ipc_msg {
diff --git a/libs/binder/trusty/rust/binder_rpc_server_bindgen/cpp/ARpcServerTrusty.cpp b/libs/binder/trusty/rust/binder_rpc_server_bindgen/cpp/ARpcServerTrusty.cpp
index 451383a90a..33708df36a 100644
--- a/libs/binder/trusty/rust/binder_rpc_server_bindgen/cpp/ARpcServerTrusty.cpp
+++ b/libs/binder/trusty/rust/binder_rpc_server_bindgen/cpp/ARpcServerTrusty.cpp
@@ -72,9 +72,10 @@ void ARpcServerTrusty_delete(ARpcServerTrusty* rstr) {
     delete rstr;
 }
 
-int ARpcServerTrusty_handleConnect(ARpcServerTrusty* rstr, handle_t chan, const uuid* peer,
-                                   void** ctx_p) {
-    return RpcServerTrusty::handleConnectInternal(rstr->mRpcServer.get(), chan, peer, ctx_p);
+int ARpcServerTrusty_handleConnect(ARpcServerTrusty* rstr, handle_t chan, const void* clientId,
+                                   size_t clientIdLen, void** ctx_p) {
+    return RpcServerTrusty::handleConnectInternal(rstr->mRpcServer.get(), chan, clientId,
+                                                  clientIdLen, ctx_p);
 }
 
 int ARpcServerTrusty_handleMessage(void* ctx) {
diff --git a/libs/debugstore/rust/src/core.rs b/libs/debugstore/rust/src/core.rs
index 16147dd092..032c6da30e 100644
--- a/libs/debugstore/rust/src/core.rs
+++ b/libs/debugstore/rust/src/core.rs
@@ -38,7 +38,7 @@ impl DebugStore {
     /// The default limit for the number of events that can be stored.
     ///
     /// This limit is used to initialize the storage for debug events.
-    const DEFAULT_EVENT_LIMIT: usize = 16;
+    const DEFAULT_EVENT_LIMIT: usize = 32;
     /// A designated identifier used for events that cannot be closed.
     ///
     /// This ID is used for point/instantaneous events, or events do not have
diff --git a/libs/fakeservicemanager/FakeServiceManager.cpp b/libs/fakeservicemanager/FakeServiceManager.cpp
index 08f30de637..a6a31474f1 100644
--- a/libs/fakeservicemanager/FakeServiceManager.cpp
+++ b/libs/fakeservicemanager/FakeServiceManager.cpp
@@ -121,6 +121,11 @@ std::vector<IServiceManager::ServiceDebugInfo> FakeServiceManager::getServiceDeb
     return ret;
 }
 
+bool FakeServiceManager::checkServiceAccess(const String16&, pid_t, uid_t,
+                                    const String16&, const String16&) {
+    return true;
+}
+
 void FakeServiceManager::clear() {
     std::map<String16, sp<IBinder>> backup;
 
diff --git a/libs/fakeservicemanager/include/fakeservicemanager/FakeServiceManager.h b/libs/fakeservicemanager/include/fakeservicemanager/FakeServiceManager.h
index f2b2aa78fc..fef928ce89 100644
--- a/libs/fakeservicemanager/include/fakeservicemanager/FakeServiceManager.h
+++ b/libs/fakeservicemanager/include/fakeservicemanager/FakeServiceManager.h
@@ -66,6 +66,9 @@ public:
     std::vector<IServiceManager::ServiceDebugInfo> getServiceDebugInfo() override;
 
     void enableAddServiceCache(bool /*value*/) override {}
+
+    bool checkServiceAccess(const String16& callerSid, pid_t callerDebugPid, uid_t callerUid,
+                                    const String16& name, const String16& permission) override;
     // Clear all of the registered services
     void clear();
 
diff --git a/libs/gralloc/types/Android.bp b/libs/gralloc/types/Android.bp
index f9f304a812..71c9206d30 100644
--- a/libs/gralloc/types/Android.bp
+++ b/libs/gralloc/types/Android.bp
@@ -56,7 +56,7 @@ cc_library {
     ],
 
     export_shared_lib_headers: [
-        "android.hardware.graphics.common-V6-ndk",
+        "android.hardware.graphics.common-V7-ndk",
         "android.hardware.graphics.mapper@4.0",
         "libhidlbase",
     ],
diff --git a/libs/graphicsenv/Android.bp b/libs/graphicsenv/Android.bp
index dce7778229..fff6f6eae7 100644
--- a/libs/graphicsenv/Android.bp
+++ b/libs/graphicsenv/Android.bp
@@ -66,10 +66,6 @@ cc_library_shared {
         "server_configurable_flags",
     ],
 
-    header_libs: [
-        "libnativeloader-headers",
-    ],
-
     export_include_dirs: ["include"],
 
     product_variables: {
diff --git a/libs/graphicsenv/GraphicsEnv.cpp b/libs/graphicsenv/GraphicsEnv.cpp
index 03e6456ea6..4697409852 100644
--- a/libs/graphicsenv/GraphicsEnv.cpp
+++ b/libs/graphicsenv/GraphicsEnv.cpp
@@ -29,14 +29,13 @@
 #include <android-base/strings.h>
 #include <android/dlext.h>
 #include <binder/IServiceManager.h>
+#include <bionic/dlext_namespaces.h>
 #include <com_android_graphics_graphicsenv_flags.h>
 #include <graphicsenv/IGpuService.h>
 #include <log/log.h>
-#include <nativeloader/dlext_namespaces.h>
 #include <sys/prctl.h>
 #include <utils/Trace.h>
 
-#include <memory>
 #include <string>
 #include <thread>
 
@@ -91,49 +90,48 @@ static const char* kLlndkLibrariesTxtPath = "/system/etc/llndk.libraries.txt";
 // On modern devices that lack the VNDK APEX, the device no longer
 // contains a helpful list of these libraries on the filesystem as above.
 // See system/sepolicy/vendor/file_contexts
-static const char* kFormerlyVndkspLibrariesList =
-    "android.hardware.common-V2-ndk.so:"
-    "android.hardware.common.fmq-V1-ndk.so:"
-    "android.hardware.graphics.allocator-V2-ndk.so:"
-    "android.hardware.graphics.common-V6-ndk.so:"
-    "android.hardware.graphics.common@1.0.so:"
-    "android.hardware.graphics.common@1.1.so:"
-    "android.hardware.graphics.common@1.2.so:"
-    "android.hardware.graphics.composer3-V1-ndk.so:"
-    "android.hardware.graphics.mapper@2.0.so:"
-    "android.hardware.graphics.mapper@2.1.so:"
-    "android.hardware.graphics.mapper@3.0.so:"
-    "android.hardware.graphics.mapper@4.0.so:"
-    "android.hardware.renderscript@1.0.so:"
-    "android.hidl.memory.token@1.0.so:"
-    "android.hidl.memory@1.0-impl.so:"
-    "android.hidl.memory@1.0.so:"
-    "android.hidl.safe_union@1.0.so:"
-    "libRSCpuRef.so:"
-    "libRSDriver.so:"
-    "libRS_internal.so:"
-    "libbacktrace.so:"
-    "libbase.so:"
-    "libbcinfo.so:"
-    "libblas.so:"
-    "libc++.so:"
-    "libcompiler_rt.so:"
-    "libcutils.so:"
-    "libdmabufheap.so:"
-    "libft2.so:"
-    "libgralloctypes.so:"
-    "libhardware.so:"
-    "libhidlbase.so:"
-    "libhidlmemory.so:"
-    "libion.so:"
-    "libjsoncpp.so:"
-    "liblzma.so:"
-    "libpng.so:"
-    "libprocessgroup.so:"
-    "libunwindstack.so:"
-    "libutils.so:"
-    "libutilscallstack.so:"
-    "libz.so";
+static const char* kFormerlyVndkspLibrariesList = "android.hardware.common-V2-ndk.so:"
+                                                  "android.hardware.common.fmq-V1-ndk.so:"
+                                                  "android.hardware.graphics.allocator-V2-ndk.so:"
+                                                  "android.hardware.graphics.common-V7-ndk.so:"
+                                                  "android.hardware.graphics.common@1.0.so:"
+                                                  "android.hardware.graphics.common@1.1.so:"
+                                                  "android.hardware.graphics.common@1.2.so:"
+                                                  "android.hardware.graphics.composer3-V1-ndk.so:"
+                                                  "android.hardware.graphics.mapper@2.0.so:"
+                                                  "android.hardware.graphics.mapper@2.1.so:"
+                                                  "android.hardware.graphics.mapper@3.0.so:"
+                                                  "android.hardware.graphics.mapper@4.0.so:"
+                                                  "android.hardware.renderscript@1.0.so:"
+                                                  "android.hidl.memory.token@1.0.so:"
+                                                  "android.hidl.memory@1.0-impl.so:"
+                                                  "android.hidl.memory@1.0.so:"
+                                                  "android.hidl.safe_union@1.0.so:"
+                                                  "libRSCpuRef.so:"
+                                                  "libRSDriver.so:"
+                                                  "libRS_internal.so:"
+                                                  "libbacktrace.so:"
+                                                  "libbase.so:"
+                                                  "libbcinfo.so:"
+                                                  "libblas.so:"
+                                                  "libc++.so:"
+                                                  "libcompiler_rt.so:"
+                                                  "libcutils.so:"
+                                                  "libdmabufheap.so:"
+                                                  "libft2.so:"
+                                                  "libgralloctypes.so:"
+                                                  "libhardware.so:"
+                                                  "libhidlbase.so:"
+                                                  "libhidlmemory.so:"
+                                                  "libion.so:"
+                                                  "libjsoncpp.so:"
+                                                  "liblzma.so:"
+                                                  "libpng.so:"
+                                                  "libprocessgroup.so:"
+                                                  "libunwindstack.so:"
+                                                  "libutils.so:"
+                                                  "libutilscallstack.so:"
+                                                  "libz.so";
 
 static std::string vndkVersionStr() {
 #ifdef __BIONIC__
@@ -746,6 +744,18 @@ void GraphicsEnv::nativeToggleAngleAsSystemDriver(bool enabled) {
     gpuService->toggleAngleAsSystemDriver(enabled);
 }
 
+std::string GraphicsEnv::nativeGetPersistGraphicsEgl() {
+    if (!graphicsenv_flags::query_persist_graphics_egl()) {
+        return "";
+    }
+    const sp<IGpuService> gpuService = getGpuService();
+    if (!gpuService) {
+        ALOGE("No GPU service");
+        return "";
+    }
+    return gpuService->getPersistGraphicsEgl();
+}
+
 bool GraphicsEnv::shouldUseSystemAngle() {
     return mShouldUseSystemAngle;
 }
diff --git a/libs/graphicsenv/IGpuService.cpp b/libs/graphicsenv/IGpuService.cpp
index 9a34aff299..2efdc713f2 100644
--- a/libs/graphicsenv/IGpuService.cpp
+++ b/libs/graphicsenv/IGpuService.cpp
@@ -108,6 +108,18 @@ public:
                            IBinder::FLAG_ONEWAY);
     }
 
+    std::string getPersistGraphicsEgl() override {
+        Parcel data, reply;
+        data.writeInterfaceToken(IGpuService::getInterfaceDescriptor());
+
+        status_t error = remote()->transact(BnGpuService::GET_PERSIST_GRAPHICS_EGL, data, &reply);
+        std::string persistGraphicsEgl;
+        if (error == OK) {
+            error = reply.readUtf8FromUtf16(&persistGraphicsEgl);
+        }
+        return persistGraphicsEgl;
+    }
+
     std::string getUpdatableDriverPath() override {
         Parcel data, reply;
         data.writeInterfaceToken(IGpuService::getInterfaceDescriptor());
@@ -286,6 +298,12 @@ status_t BnGpuService::onTransact(uint32_t code, const Parcel& data, Parcel* rep
             toggleAngleAsSystemDriver(enableAngleAsSystemDriver);
             return OK;
         }
+        case GET_PERSIST_GRAPHICS_EGL: {
+            CHECK_INTERFACE(IGpuService, data, reply);
+
+            std::string persistGraphicsEgl = getPersistGraphicsEgl();
+            return reply->writeUtf8AsUtf16(persistGraphicsEgl);
+        }
         case GET_FEATURE_CONFIG_OVERRIDES: {
             CHECK_INTERFACE(IGpuService, data, reply);
 
diff --git a/libs/graphicsenv/graphicsenv_flags.aconfig b/libs/graphicsenv/graphicsenv_flags.aconfig
index efa4bca892..dd8e6a3724 100644
--- a/libs/graphicsenv/graphicsenv_flags.aconfig
+++ b/libs/graphicsenv/graphicsenv_flags.aconfig
@@ -7,3 +7,10 @@ flag {
   description: "This flag controls the ANGLE Feature Overrides in GraphicsEnv."
   bug: "372694741"
 }
+
+flag {
+  name: "query_persist_graphics_egl"
+  namespace: "gpu"
+  description: "This flag controls the ability to query persist.graphics.egl through GpuService"
+  bug: "408439360"
+}
diff --git a/libs/graphicsenv/include/graphicsenv/GraphicsEnv.h b/libs/graphicsenv/include/graphicsenv/GraphicsEnv.h
index 68219008e8..3275073fce 100644
--- a/libs/graphicsenv/include/graphicsenv/GraphicsEnv.h
+++ b/libs/graphicsenv/include/graphicsenv/GraphicsEnv.h
@@ -126,6 +126,8 @@ public:
                                   std::vector<const char*>& disabled);
     // Set the persist.graphics.egl system property value.
     void nativeToggleAngleAsSystemDriver(bool enabled);
+    // Get the persist.graphics.egl system property value.
+    std::string nativeGetPersistGraphicsEgl();
     bool shouldUseSystemAngle();
     bool shouldUseNativeDriver();
 
diff --git a/libs/graphicsenv/include/graphicsenv/IGpuService.h b/libs/graphicsenv/include/graphicsenv/IGpuService.h
index 442683a3e9..a73f7975c8 100644
--- a/libs/graphicsenv/include/graphicsenv/IGpuService.h
+++ b/libs/graphicsenv/include/graphicsenv/IGpuService.h
@@ -57,6 +57,9 @@ public:
     // sets ANGLE as system GLES driver if enabled==true by setting persist.graphics.egl to true.
     virtual void toggleAngleAsSystemDriver(bool enabled) = 0;
 
+    // gets persist.graphics.egl value
+    virtual std::string getPersistGraphicsEgl() = 0;
+
     // Get the list of features to override.
     virtual FeatureOverrides getFeatureOverrides() = 0;
 };
@@ -72,6 +75,7 @@ public:
         SET_TARGET_STATS_ARRAY,
         ADD_VULKAN_ENGINE_NAME,
         GET_FEATURE_CONFIG_OVERRIDES,
+        GET_PERSIST_GRAPHICS_EGL,
         // Always append new enum to the end.
     };
 
diff --git a/libs/gui/Android.bp b/libs/gui/Android.bp
index 2117c987e4..aec9109851 100644
--- a/libs/gui/Android.bp
+++ b/libs/gui/Android.bp
@@ -89,11 +89,13 @@ cc_library_headers {
 filegroup {
     name: "guiconstants_aidl",
     srcs: [
+        "android/gui/BorderSettings.aidl",
+        "android/gui/BoxShadowSettings.aidl",
         "android/gui/DropInputMode.aidl",
+        "android/gui/EarlyWakeupInfo.aidl",
         "android/gui/StalledTransactionInfo.aidl",
         "android/**/TouchOcclusionMode.aidl",
         "android/gui/TrustedOverlay.aidl",
-        "android/gui/BorderSettings.aidl",
     ],
 }
 
@@ -296,6 +298,11 @@ filegroup {
 cc_defaults {
     name: "libgui-defaults",
     defaults: ["libgui_bufferqueue-defaults"],
+    tidy: true,
+    tidy_flags: [
+        // Only check our headers
+        "--header-filter=^.*frameworks/native/libs/gui/.*.h$",
+    ],
     static_libs: [
         "libgui_aidl_static",
         "libgui_window_info_static",
@@ -350,6 +357,10 @@ cc_library_shared {
         "libsurfaceflingerflags",
     ],
 
+    shared_libs: [
+        "libaconfig_storage_read_api_cc",
+    ],
+
     afdo: true,
 
     lto: {
@@ -396,17 +407,21 @@ filegroup {
     srcs: [
         "BatchBufferOps.cpp",
         "BufferItem.cpp",
+        "BufferItemConsumer.cpp",
         "BufferQueue.cpp",
         "BufferQueueConsumer.cpp",
         "BufferQueueCore.cpp",
         "BufferQueueProducer.cpp",
         "BufferQueueThreadState.cpp",
         "BufferSlot.cpp",
+        "ConsumerBase.cpp",
+        "FenceMonitor.cpp",
         "FrameRateUtils.cpp",
         "FrameTimestamps.cpp",
         "GLConsumerUtils.cpp",
         "HdrMetadata.cpp",
         "IGraphicBufferProducerFlattenables.cpp",
+        "Surface.cpp",
         "bufferqueue/1.0/Conversion.cpp",
         "bufferqueue/1.0/H2BProducerListener.cpp",
         "bufferqueue/1.0/WProducerListener.cpp",
diff --git a/libs/gui/BLASTBufferQueue.cpp b/libs/gui/BLASTBufferQueue.cpp
index 5b0f21de91..f273178a67 100644
--- a/libs/gui/BLASTBufferQueue.cpp
+++ b/libs/gui/BLASTBufferQueue.cpp
@@ -172,7 +172,6 @@ void BLASTBufferItemConsumer::onSidebandStreamChanged() {
     }
 }
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(BQ_SETFRAMERATE)
 void BLASTBufferItemConsumer::onSetFrameRate(float frameRate, int8_t compatibility,
                                              int8_t changeFrameRateStrategy) {
     sp<BLASTBufferQueue> bbq = mBLASTBufferQueue.promote();
@@ -180,44 +179,28 @@ void BLASTBufferItemConsumer::onSetFrameRate(float frameRate, int8_t compatibili
         bbq->setFrameRate(frameRate, compatibility, changeFrameRateStrategy);
     }
 }
-#endif
 
 void BLASTBufferItemConsumer::resizeFrameEventHistory(size_t newSize) {
     Mutex::Autolock lock(mMutex);
     mFrameEventHistory.resize(newSize);
 }
 
-BLASTBufferQueue::BLASTBufferQueue(const std::string& name, bool updateDestinationFrame)
-      : mSurfaceControl(nullptr),
-        mSize(1, 1),
-        mRequestedSize(mSize),
-        mFormat(PIXEL_FORMAT_RGBA_8888),
-        mTransactionReadyCallback(nullptr),
-        mSyncTransaction(nullptr),
-        mUpdateDestinationFrame(updateDestinationFrame) {
+void BLASTBufferQueue::initialize() {
+    std::lock_guard _lock{mMutex};
     createBufferQueue(&mProducer, &mConsumer);
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
-    mBufferItemConsumer = sp<BLASTBufferItemConsumer>::make(mProducer, mConsumer,
-                                                            GraphicBuffer::USAGE_HW_COMPOSER |
-                                                                    GraphicBuffer::USAGE_HW_TEXTURE,
-                                                            1, false, this);
-#else
-    mBufferItemConsumer = sp<BLASTBufferItemConsumer>::make(mConsumer,
-                                                            GraphicBuffer::USAGE_HW_COMPOSER |
-                                                                    GraphicBuffer::USAGE_HW_TEXTURE,
-                                                            1, false, this);
-#endif //  COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
+    mBufferItemConsumer =
+            sp<BLASTBufferItemConsumer>::make(mProducer, mConsumer,
+                                              GraphicBuffer::USAGE_HW_COMPOSER |
+                                                      GraphicBuffer::USAGE_HW_TEXTURE,
+                                              1, false, wp<BLASTBufferQueue>::fromExisting(this));
     // since the adapter is in the client process, set dequeue timeout
     // explicitly so that dequeueBuffer will block
     mProducer->setDequeueTimeout(std::numeric_limits<int64_t>::max());
 
-    static std::atomic<uint32_t> nextId = 0;
-    mProducerId = nextId++;
-    mName = name + "#" + std::to_string(mProducerId);
     auto consumerName = mName + "(BLAST Consumer)" + std::to_string(mProducerId);
     mQueuedBufferTrace = "QueuedBuffer - " + mName + "BLAST#" + std::to_string(mProducerId);
     mBufferItemConsumer->setName(String8(consumerName.c_str()));
-    mBufferItemConsumer->setFrameAvailableListener(this);
+    mBufferItemConsumer->setFrameAvailableListener(wp<BLASTBufferQueue>::fromExisting(this));
 
     ComposerServiceAIDL::getComposerService()->getMaxAcquiredBufferCount(&mMaxAcquiredBuffers);
     mBufferItemConsumer->setMaxAcquiredBufferCount(mMaxAcquiredBuffers);
@@ -234,14 +217,25 @@ BLASTBufferQueue::BLASTBufferQueue(const std::string& name, bool updateDestinati
             },
             this);
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(BUFFER_RELEASE_CHANNEL)
-    gui::BufferReleaseChannel::open(mName, mBufferReleaseConsumer, mBufferReleaseProducer);
-    mBufferReleaseReader.emplace(*this);
-#endif
+    // safe default, most producers are expected to override this
+    mProducer->setMaxDequeuedBufferCount(2);
 
     BQA_LOGV("BLASTBufferQueue created");
 }
 
+BLASTBufferQueue::BLASTBufferQueue(const std::string& name, bool updateDestinationFrame)
+      : mSurfaceControl(nullptr),
+        mSize(1, 1),
+        mRequestedSize(mSize),
+        mFormat(PIXEL_FORMAT_RGBA_8888),
+        mTransactionReadyCallback(nullptr),
+        mSyncTransaction(nullptr),
+        mUpdateDestinationFrame(updateDestinationFrame) {
+    static std::atomic<uint32_t> nextId = 0;
+    mProducerId = nextId++;
+    mName = name + "#" + std::to_string(mProducerId);
+}
+
 BLASTBufferQueue::~BLASTBufferQueue() {
     TransactionCompletedListener::getInstance()->removeQueueStallListener(this);
     if (mPendingTransactions.empty()) {
@@ -260,8 +254,7 @@ BLASTBufferQueue::~BLASTBufferQueue() {
 }
 
 void BLASTBufferQueue::onFirstRef() {
-    // safe default, most producers are expected to override this
-    mProducer->setMaxDequeuedBufferCount(2);
+    initialize();
 }
 
 void BLASTBufferQueue::update(const sp<SurfaceControl>& surface, uint32_t width, uint32_t height,
@@ -709,7 +702,10 @@ status_t BLASTBufferQueue::acquireNextBufferLocked(
     mergePendingTransactions(t, bufferItem.mFrameNumber);
     if (applyTransaction) {
         // All transactions on our apply token are one-way. See comment on mAppliedLastTransaction
-        t->setApplyToken(mApplyToken).apply(false, true);
+        status_t status = t->setApplyToken(mApplyToken).apply(false, true);
+        LOG_ALWAYS_FATAL_IF(status != OK,
+                            "[%s] acquireNextBufferLocked failed to apply transaction. status=%d",
+                            mName.c_str(), status);
         mAppliedLastTransaction = true;
         mLastAppliedFrameNumber = bufferItem.mFrameNumber;
     } else {
@@ -943,11 +939,9 @@ public:
         auto gbp = getIGraphicBufferProducer();
         std::thread allocateThread([reqWidth, reqHeight, gbp = getIGraphicBufferProducer(),
                                     reqFormat = mReqFormat, reqUsage = mReqUsage]() {
-            if (com_android_graphics_libgui_flags_allocate_buffer_priority()) {
-                androidSetThreadName("allocateBuffers");
-                pid_t tid = gettid();
-                androidSetThreadPriority(tid, ANDROID_PRIORITY_DISPLAY);
-            }
+            androidSetThreadName("allocateBuffers");
+            pid_t tid = gettid();
+            androidSetThreadPriority(tid, ANDROID_PRIORITY_DISPLAY);
 
             gbp->allocateBuffers(reqWidth, reqHeight,
                                  reqFormat, reqUsage);
@@ -955,23 +949,6 @@ public:
         allocateThread.detach();
     }
 
-    status_t setFrameRate(float frameRate, int8_t compatibility,
-                          int8_t changeFrameRateStrategy) override {
-        if (flags::bq_setframerate()) {
-            return Surface::setFrameRate(frameRate, compatibility, changeFrameRateStrategy);
-        }
-
-        std::lock_guard _lock{mMutex};
-        if (mDestroyed) {
-            return DEAD_OBJECT;
-        }
-        if (!ValidateFrameRate(frameRate, compatibility, changeFrameRateStrategy,
-                               "BBQSurface::setFrameRate")) {
-            return BAD_VALUE;
-        }
-        return mBbq->setFrameRate(frameRate, compatibility, changeFrameRateStrategy);
-    }
-
     status_t setFrameTimelineInfo(uint64_t frameNumber,
                                   const FrameTimelineInfo& frameTimelineInfo) override {
         std::lock_guard _lock{mMutex};
@@ -1022,7 +999,8 @@ sp<Surface> BLASTBufferQueue::getSurface(bool includeSurfaceControlHandle) {
     if (includeSurfaceControlHandle && mSurfaceControl) {
         scHandle = mSurfaceControl->getHandle();
     }
-    return sp<BBQSurface>::make(mProducer, true, scHandle, this);
+    return sp<BBQSurface>::make(mProducer, true, scHandle,
+                                sp<BLASTBufferQueue>::fromExisting(this));
 }
 
 void BLASTBufferQueue::mergeWithNextTransaction(SurfaceComposerClient::Transaction* t,
@@ -1032,7 +1010,7 @@ void BLASTBufferQueue::mergeWithNextTransaction(SurfaceComposerClient::Transacti
         // Apply the transaction since we have already acquired the desired frame.
         t->setApplyToken(mApplyToken).apply();
     } else {
-        mPendingTransactions.emplace_back(frameNumber, std::move(*t));
+        mPendingTransactions.emplace_back(frameNumber, *t);
         // Clear the transaction so it can't be applied elsewhere.
         t->clear();
     }
@@ -1050,8 +1028,8 @@ void BLASTBufferQueue::applyPendingTransactions(uint64_t frameNumber) {
 void BLASTBufferQueue::mergePendingTransactions(SurfaceComposerClient::Transaction* t,
                                                 uint64_t frameNumber) {
     auto mergeTransaction =
-            [t, currentFrameNumber = frameNumber](
-                    std::pair<uint64_t, SurfaceComposerClient::Transaction>& pendingTransaction) {
+            [&t, currentFrameNumber = frameNumber](
+                    std::tuple<uint64_t, SurfaceComposerClient::Transaction> pendingTransaction) {
                 auto& [targetFrameNumber, transaction] = pendingTransaction;
                 if (currentFrameNumber < targetFrameNumber) {
                     return false;
@@ -1154,20 +1132,50 @@ public:
 };
 
 #if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(BUFFER_RELEASE_CHANNEL)
+
+// BufferReleaseReader is used to do blocking but interruptible reads from the buffer
+// release channel. To implement this, BufferReleaseReader owns an epoll file descriptor that
+// is configured to wake up when either the BufferReleaseReader::ConsumerEndpoint or an eventfd
+// becomes readable. Interrupts are necessary because a free buffer may become available for
+// reasons other than a buffer release from the producer.
+class BufferReleaseReader {
+public:
+    explicit BufferReleaseReader(std::unique_ptr<gui::BufferReleaseChannel::ConsumerEndpoint>);
+
+    BufferReleaseReader(const BufferReleaseReader&) = delete;
+    BufferReleaseReader& operator=(const BufferReleaseReader&) = delete;
+
+    // Block until we can read a buffer release message.
+    //
+    // Returns:
+    // * OK if a ReleaseCallbackId and Fence were successfully read.
+    // * WOULD_BLOCK if the blocking read was interrupted by interruptBlockingRead.
+    // * TIMED_OUT if the blocking read timed out.
+    // * UNKNOWN_ERROR if something went wrong.
+    status_t readBlocking(ReleaseCallbackId& outId, sp<Fence>& outReleaseFence,
+                          uint32_t& outMaxAcquiredBufferCount, nsecs_t timeout);
+
+    status_t readNonBlocking(ReleaseCallbackId& outId, sp<Fence>& outReleaseFence,
+                             uint32_t& outMaxAcquiredBufferCount);
+
+    void interruptBlockingRead();
+    void clearInterrupts();
+
+private:
+    std::unique_ptr<gui::BufferReleaseChannel::ConsumerEndpoint> mConsumerEndpoint;
+    android::base::unique_fd mEpollFd;
+    android::base::unique_fd mEventFd;
+};
+
 class BBQBufferQueueCore : public BufferQueueCore {
 public:
-    explicit BBQBufferQueueCore(const wp<BLASTBufferQueue>& bbq) : mBLASTBufferQueue{bbq} {}
+    explicit BBQBufferQueueCore(std::shared_ptr<BufferReleaseReader> bufferReleaseReader)
+          : mBufferReleaseReader{std::move(bufferReleaseReader)} {}
 
-    void notifyBufferReleased() const override {
-        sp<BLASTBufferQueue> bbq = mBLASTBufferQueue.promote();
-        if (!bbq) {
-            return;
-        }
-        bbq->mBufferReleaseReader->interruptBlockingRead();
-    }
+    void notifyBufferReleased() const override { mBufferReleaseReader->interruptBlockingRead(); }
 
 private:
-    wp<BLASTBufferQueue> mBLASTBufferQueue;
+    std::shared_ptr<BufferReleaseReader> mBufferReleaseReader;
 };
 #endif
 
@@ -1175,9 +1183,17 @@ private:
 // can be non-blocking when the producer is in the client process.
 class BBQBufferQueueProducer : public BufferQueueProducer {
 public:
+#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(BUFFER_RELEASE_CHANNEL)
+    BBQBufferQueueProducer(const sp<BufferQueueCore>& core, const wp<BLASTBufferQueue>& bbq,
+                           std::shared_ptr<BufferReleaseReader> bufferReleaseReader)
+          : BufferQueueProducer(core, false /* consumerIsSurfaceFlinger*/),
+            mBLASTBufferQueue(bbq),
+            mBufferReleaseReader(std::move(bufferReleaseReader)) {}
+#else
     BBQBufferQueueProducer(const sp<BufferQueueCore>& core, const wp<BLASTBufferQueue>& bbq)
           : BufferQueueProducer(core, false /* consumerIsSurfaceFlinger*/),
             mBLASTBufferQueue(bbq) {}
+#endif
 
     status_t connect(const sp<IProducerListener>& listener, int api, bool producerControlledByApp,
                      QueueBufferOutput* output) override {
@@ -1225,24 +1241,20 @@ public:
 #if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(BUFFER_RELEASE_CHANNEL)
     status_t waitForBufferRelease(std::unique_lock<std::mutex>& bufferQueueLock,
                                   nsecs_t timeout) const override {
+        ATRACE_CALL();
         const auto startTime = std::chrono::steady_clock::now();
-        sp<BLASTBufferQueue> bbq = mBLASTBufferQueue.promote();
-        if (!bbq) {
-            return OK;
-        }
 
         // BufferQueue has already checked if we have a free buffer. If there's an unread interrupt,
         // we want to ignore it. This must be done before unlocking the BufferQueue lock to ensure
         // we don't miss an interrupt.
-        bbq->mBufferReleaseReader->clearInterrupts();
+        mBufferReleaseReader->clearInterrupts();
         UnlockGuard unlockGuard{bufferQueueLock};
 
-        ATRACE_FORMAT("waiting for free buffer");
         ReleaseCallbackId id;
         sp<Fence> fence;
         uint32_t maxAcquiredBufferCount;
         status_t status =
-                bbq->mBufferReleaseReader->readBlocking(id, fence, maxAcquiredBufferCount, timeout);
+                mBufferReleaseReader->readBlocking(id, fence, maxAcquiredBufferCount, timeout);
         if (status == TIMED_OUT) {
             return TIMED_OUT;
         } else if (status != OK) {
@@ -1251,6 +1263,11 @@ public:
             return OK;
         }
 
+        sp<BLASTBufferQueue> bbq = mBLASTBufferQueue.promote();
+        if (!bbq) {
+            return OK;
+        }
+
         bbq->releaseBufferCallback(id, fence, maxAcquiredBufferCount);
         const nsecs_t durationNanos = std::chrono::duration_cast<std::chrono::nanoseconds>(
                                               std::chrono::steady_clock::now() - startTime)
@@ -1266,6 +1283,7 @@ public:
 
 private:
     const wp<BLASTBufferQueue> mBLASTBufferQueue;
+    std::shared_ptr<BufferReleaseReader> mBufferReleaseReader;
 };
 
 // Similar to BufferQueue::createBufferQueue but creates an adapter specific bufferqueue producer.
@@ -1278,13 +1296,23 @@ void BLASTBufferQueue::createBufferQueue(sp<IGraphicBufferProducer>* outProducer
     LOG_ALWAYS_FATAL_IF(outConsumer == nullptr, "BLASTBufferQueue: outConsumer must not be NULL");
 
 #if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(BUFFER_RELEASE_CHANNEL)
-    auto core = sp<BBQBufferQueueCore>::make(this);
+    std::unique_ptr<gui::BufferReleaseChannel::ConsumerEndpoint> bufferReleaseConsumer;
+    gui::BufferReleaseChannel::open(mName, bufferReleaseConsumer, mBufferReleaseProducer);
+    mBufferReleaseReader = std::make_shared<BufferReleaseReader>(std::move(bufferReleaseConsumer));
+
+    auto core = sp<BBQBufferQueueCore>::make(mBufferReleaseReader);
 #else
     auto core = sp<BufferQueueCore>::make();
 #endif
     LOG_ALWAYS_FATAL_IF(core == nullptr, "BLASTBufferQueue: failed to create BufferQueueCore");
 
-    auto producer = sp<BBQBufferQueueProducer>::make(core, this);
+#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(BUFFER_RELEASE_CHANNEL)
+    auto producer = sp<BBQBufferQueueProducer>::make(core, wp<BLASTBufferQueue>::fromExisting(this),
+                                                     mBufferReleaseReader);
+#else
+    auto producer =
+            sp<BBQBufferQueueProducer>::make(core, wp<BLASTBufferQueue>::fromExisting(this));
+#endif
     LOG_ALWAYS_FATAL_IF(producer == nullptr,
                         "BLASTBufferQueue: failed to create BBQBufferQueueProducer");
 
@@ -1384,8 +1412,7 @@ void BLASTBufferQueue::drainBufferReleaseConsumer() {
         ReleaseCallbackId id;
         sp<Fence> fence;
         uint32_t maxAcquiredBufferCount;
-        status_t status =
-                mBufferReleaseConsumer->readReleaseFence(id, fence, maxAcquiredBufferCount);
+        status_t status = mBufferReleaseReader->readNonBlocking(id, fence, maxAcquiredBufferCount);
         if (status != OK) {
             return;
         }
@@ -1393,7 +1420,9 @@ void BLASTBufferQueue::drainBufferReleaseConsumer() {
     }
 }
 
-BLASTBufferQueue::BufferReleaseReader::BufferReleaseReader(BLASTBufferQueue& bbq) : mBbq{bbq} {
+BufferReleaseReader::BufferReleaseReader(
+        std::unique_ptr<gui::BufferReleaseChannel::ConsumerEndpoint> consumerEndpoint)
+      : mConsumerEndpoint{std::move(consumerEndpoint)} {
     mEpollFd = android::base::unique_fd{epoll_create1(EPOLL_CLOEXEC)};
     LOG_ALWAYS_FATAL_IF(!mEpollFd.ok(),
                         "Failed to create buffer release epoll file descriptor. errno=%d "
@@ -1402,8 +1431,8 @@ BLASTBufferQueue::BufferReleaseReader::BufferReleaseReader(BLASTBufferQueue& bbq
 
     epoll_event registerEndpointFd{};
     registerEndpointFd.events = EPOLLIN;
-    registerEndpointFd.data.fd = mBbq.mBufferReleaseConsumer->getFd();
-    status_t status = epoll_ctl(mEpollFd.get(), EPOLL_CTL_ADD, mBbq.mBufferReleaseConsumer->getFd(),
+    registerEndpointFd.data.fd = mConsumerEndpoint->getFd();
+    status_t status = epoll_ctl(mEpollFd.get(), EPOLL_CTL_ADD, mConsumerEndpoint->getFd(),
                                 &registerEndpointFd);
     LOG_ALWAYS_FATAL_IF(status == -1,
                         "Failed to register buffer release consumer file descriptor with epoll. "
@@ -1426,10 +1455,8 @@ BLASTBufferQueue::BufferReleaseReader::BufferReleaseReader(BLASTBufferQueue& bbq
                         errno, strerror(errno));
 }
 
-status_t BLASTBufferQueue::BufferReleaseReader::readBlocking(ReleaseCallbackId& outId,
-                                                             sp<Fence>& outFence,
-                                                             uint32_t& outMaxAcquiredBufferCount,
-                                                             nsecs_t timeout) {
+status_t BufferReleaseReader::readBlocking(ReleaseCallbackId& outId, sp<Fence>& outFence,
+                                           uint32_t& outMaxAcquiredBufferCount, nsecs_t timeout) {
     // TODO(b/363290953) epoll_wait only has millisecond timeout precision. If timeout is less than
     // 1ms, then we round timeout up to 1ms. Otherwise, we round timeout to the nearest
     // millisecond. Once epoll_pwait2 can be used in libgui, we can specify timeout with nanosecond
@@ -1469,17 +1496,21 @@ status_t BLASTBufferQueue::BufferReleaseReader::readBlocking(ReleaseCallbackId&
         return WOULD_BLOCK;
     }
 
-    return mBbq.mBufferReleaseConsumer->readReleaseFence(outId, outFence,
-                                                         outMaxAcquiredBufferCount);
+    return mConsumerEndpoint->readReleaseFence(outId, outFence, outMaxAcquiredBufferCount);
+}
+
+status_t BufferReleaseReader::readNonBlocking(ReleaseCallbackId& outId, sp<Fence>& outFence,
+                                              uint32_t& outMaxAcquiredBufferCount) {
+    return mConsumerEndpoint->readReleaseFence(outId, outFence, outMaxAcquiredBufferCount);
 }
 
-void BLASTBufferQueue::BufferReleaseReader::interruptBlockingRead() {
+void BufferReleaseReader::interruptBlockingRead() {
     if (eventfd_write(mEventFd.get(), 1) == -1) {
         ALOGE("failed to notify dequeue event. errno=%d message='%s'", errno, strerror(errno));
     }
 }
 
-void BLASTBufferQueue::BufferReleaseReader::clearInterrupts() {
+void BufferReleaseReader::clearInterrupts() {
     eventfd_t value;
     if (eventfd_read(mEventFd.get(), &value) == -1 && errno != EWOULDBLOCK) {
         ALOGE("error while reading from eventfd. errno=%d message='%s'", errno, strerror(errno));
diff --git a/libs/gui/BufferItemConsumer.cpp b/libs/gui/BufferItemConsumer.cpp
index 4926ceb619..b8c24cba9a 100644
--- a/libs/gui/BufferItemConsumer.cpp
+++ b/libs/gui/BufferItemConsumer.cpp
@@ -40,19 +40,10 @@ namespace android {
 std::tuple<sp<BufferItemConsumer>, sp<Surface>> BufferItemConsumer::create(
         uint64_t consumerUsage, int bufferCount, bool controlledByApp,
         bool isConsumerSurfaceFlinger) {
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
     sp<BufferItemConsumer> bufferItemConsumer =
             sp<BufferItemConsumer>::make(consumerUsage, bufferCount, controlledByApp,
                                          isConsumerSurfaceFlinger);
     return {bufferItemConsumer, bufferItemConsumer->getSurface()};
-#else
-    sp<IGraphicBufferProducer> igbp;
-    sp<IGraphicBufferConsumer> igbc;
-    BufferQueue::createBufferQueue(&igbp, &igbc, isConsumerSurfaceFlinger);
-    sp<BufferItemConsumer> bufferItemConsumer =
-            sp<BufferItemConsumer>::make(igbc, consumerUsage, bufferCount, controlledByApp);
-    return {bufferItemConsumer, sp<Surface>::make(igbp, controlledByApp)};
-#endif
 }
 
 sp<BufferItemConsumer> BufferItemConsumer::create(const sp<IGraphicBufferConsumer>& consumer,
@@ -61,7 +52,6 @@ sp<BufferItemConsumer> BufferItemConsumer::create(const sp<IGraphicBufferConsume
     return sp<BufferItemConsumer>::make(consumer, consumerUsage, bufferCount, controlledByApp);
 }
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
 BufferItemConsumer::BufferItemConsumer(uint64_t consumerUsage, int bufferCount,
                                        bool controlledByApp, bool isConsumerSurfaceFlinger)
       : ConsumerBase(controlledByApp, isConsumerSurfaceFlinger) {
@@ -75,7 +65,6 @@ BufferItemConsumer::BufferItemConsumer(const sp<IGraphicBufferProducer>& produce
       : ConsumerBase(producer, consumer, controlledByApp) {
     initialize(consumerUsage, bufferCount);
 }
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
 
 BufferItemConsumer::BufferItemConsumer(
         const sp<IGraphicBufferConsumer>& consumer, uint64_t consumerUsage,
diff --git a/libs/gui/BufferQueue.cpp b/libs/gui/BufferQueue.cpp
index f21ac18f3c..2e7aa9fa8f 100644
--- a/libs/gui/BufferQueue.cpp
+++ b/libs/gui/BufferQueue.cpp
@@ -98,7 +98,6 @@ void BufferQueue::ProxyConsumerListener::addAndGetFrameTimestamps(
     }
 }
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(BQ_SETFRAMERATE)
 void BufferQueue::ProxyConsumerListener::onSetFrameRate(float frameRate, int8_t compatibility,
                                                         int8_t changeFrameRateStrategy) {
     sp<ConsumerListener> listener(mConsumerListener.promote());
@@ -106,7 +105,6 @@ void BufferQueue::ProxyConsumerListener::onSetFrameRate(float frameRate, int8_t
         listener->onSetFrameRate(frameRate, compatibility, changeFrameRateStrategy);
     }
 }
-#endif
 
 #if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_UNLIMITED_SLOTS)
 void BufferQueue::ProxyConsumerListener::onSlotCountChanged(int slotCount) {
diff --git a/libs/gui/BufferQueueConsumer.cpp b/libs/gui/BufferQueueConsumer.cpp
index 4681c9ecbe..93e9615ac9 100644
--- a/libs/gui/BufferQueueConsumer.cpp
+++ b/libs/gui/BufferQueueConsumer.cpp
@@ -789,7 +789,8 @@ status_t BufferQueueConsumer::setMaxAcquiredBufferCount(
                 BufferQueueCore::MAX_MAX_ACQUIRED_BUFFERS;
 #endif
         if (maxAcquiredBuffers < 1 || maxAcquiredBuffers > maxMaxAcquiredBuffers) {
-            BQ_LOGE("setMaxAcquiredBufferCount: invalid count %d", maxAcquiredBuffers);
+            BQ_LOGE("setMaxAcquiredBufferCount: invalid count %d allowed maxCount is %d",
+                    maxAcquiredBuffers, maxMaxAcquiredBuffers);
             return BAD_VALUE;
         }
 
diff --git a/libs/gui/BufferQueueProducer.cpp b/libs/gui/BufferQueueProducer.cpp
index bcf61e45de..d42425aa3c 100644
--- a/libs/gui/BufferQueueProducer.cpp
+++ b/libs/gui/BufferQueueProducer.cpp
@@ -364,10 +364,8 @@ status_t BufferQueueProducer::waitForFreeSlotThenRelock(FreeSlotCaller caller,
         // Producers are not allowed to dequeue more than
         // mMaxDequeuedBufferCount buffers.
         // This check is only done if a buffer has already been queued
-        using namespace com::android::graphics::libgui::flags;
-        bool flagGatedBufferHasBeenQueued =
-                bq_always_use_max_dequeued_buffer_count() || mCore->mBufferHasBeenQueued;
-        if (flagGatedBufferHasBeenQueued && dequeuedCount >= mCore->mMaxDequeuedBufferCount) {
+        if (mCore->mBufferHasBeenQueued &&
+                dequeuedCount >= mCore->mMaxDequeuedBufferCount) {
             // Supress error logs when timeout is non-negative.
             if (mDequeueTimeout < 0) {
                 BQ_LOGE("%s: attempting to exceed the max dequeued buffer "
@@ -1952,7 +1950,6 @@ status_t BufferQueueProducer::setAutoPrerotation(bool autoPrerotation) {
     return NO_ERROR;
 }
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(BQ_SETFRAMERATE)
 status_t BufferQueueProducer::setFrameRate(float frameRate, int8_t compatibility,
                                            int8_t changeFrameRateStrategy) {
     ATRACE_CALL();
@@ -1973,7 +1970,6 @@ status_t BufferQueueProducer::setFrameRate(float frameRate, int8_t compatibility
     }
     return NO_ERROR;
 }
-#endif
 
 #if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(BQ_EXTENDEDALLOCATE)
 status_t BufferQueueProducer::setAdditionalOptions(
diff --git a/libs/gui/BufferStuffing.md b/libs/gui/BufferStuffing.md
index 6ed8ad988b..305fc4836b 100644
--- a/libs/gui/BufferStuffing.md
+++ b/libs/gui/BufferStuffing.md
@@ -2,6 +2,6 @@
 
 Buffer stuffing happens on the client side when SurfaceFlinger misses a frame, but the client continues producing buffers at the same rate. This could occur anytime when SurfaceFlinger does not meet the expected timelines deadline to finish composing a frame. As a result, SurfaceFlinger cannot yet release the buffer for the frame that it missed and the client has one less buffer to render into. The client may then run out of buffers or have to wait for buffer release callbacks, increasing the chances of janking when clients render multiple windows.
 
-Recovery is implemented by first detecting when buffer stuffing occurs and ensuring that the elevated buffer counts in the server are from a relevant SurfaceControl (is a ViewRootImpl). Other SurfaceControl buffer producers such as games, media, and camera have other reasons for expectedly increased buffer counts, which do not need buffer stuffing recovery.
+Buffer stuffing is first detected through a callback when RenderThread is blocked in BlastBufferQueue#dequeueBuffer, where an app may wait for a buffer to become available. When RenderThread is blocked on dequeueBuffer, the system is maximally stuffed as there are no available buffers and is vulnerable to additional jank. The callback provides the duration spent blocked in dequeueBuffer, which is used to guard against potential false positives that might result from slight variations in buffer release timing. As there is one BlastBufferQueue associated with the SurfaceControl on the root window, waiting for the buffer release callback here also filters out other SurfaceControl buffer producers that do not require buffer stuffing recovery, such as games, media, and camera. These other buffer producers may have expectedly higher buffer counts because they can queue up more buffers in advance to meet high throughput, low latency requirements. For example, a video might queue up as many buffers as possible in preparation for the upcoming frames. It would be considered acceptable for it to be stuffed in this case because it is not affecting other CUJs and the stuffing helps prepare the rendering pipeline.
 
-The actual recovery adjusts the animation timeline in the Choreographer so that the client deadlines for subsequent frames are moved forward in time by one frame. This approach adjusts the client buffer production timeline such that SurfaceFlinger does not fall behind when it misses a frame because the client will simply match its frame production rate with SurfaceFlinger. Ordinarily, buffer stuffing is problematic because the client continues producing buffers when SurfaceFlinger is behind. However, if the client delays producing its buffers to match SurfaceFlingers rate, the animation has new frame deadlines that can be reasonably met. The animation is effectively paused for one frame longer than originally intended, and continues the remainder of the animation normally.
\ No newline at end of file
+The actual recovery adjusts the animation timeline in the Choreographer so that the client deadlines for subsequent frames are moved forward in time by one frame. This approach adjusts the client buffer production timeline such that SurfaceFlinger does not fall behind when it misses a frame because the client will simply match its frame production rate with SurfaceFlinger. Ordinarily, buffer stuffing is problematic because the client continues producing buffers when SurfaceFlinger is behind. However, if the client delays producing its buffers to match SurfaceFlingers rate, the animation has new frame deadlines that can be reasonably met. The animation is effectively paused for one frame longer than originally intended, and continues the remainder of the animation normally. At most one frame (and one buffer) is delayed per stuffing event, meaning that if the client janks again after recovery has started and before its animation ends, no additional recovery attempts are made.
\ No newline at end of file
diff --git a/libs/gui/Choreographer.cpp b/libs/gui/Choreographer.cpp
index 80a35435cb..37f7161247 100644
--- a/libs/gui/Choreographer.cpp
+++ b/libs/gui/Choreographer.cpp
@@ -349,7 +349,15 @@ void Choreographer::dispatchHotplugConnectionError(nsecs_t, int32_t connectionEr
           this, connectionError);
 }
 
-void Choreographer::dispatchModeChanged(nsecs_t, PhysicalDisplayId, int32_t, nsecs_t) {
+void Choreographer::dispatchModeChangedWithFrameRateOverrides(nsecs_t, PhysicalDisplayId, int32_t,
+                                                              nsecs_t, nsecs_t, nsecs_t,
+                                                              std::vector<FrameRateOverride>) {
+    LOG_ALWAYS_FATAL(
+            "dispatchModeChangedWithFrameRateOverrides was called but was never registered");
+}
+
+void Choreographer::dispatchModeChanged(nsecs_t, PhysicalDisplayId, int32_t, nsecs_t, nsecs_t,
+                                        nsecs_t) {
     LOG_ALWAYS_FATAL("dispatchModeChanged was called but was never registered");
 }
 
diff --git a/libs/gui/ConsumerBase.cpp b/libs/gui/ConsumerBase.cpp
index 1a975de08d..7362602e47 100644
--- a/libs/gui/ConsumerBase.cpp
+++ b/libs/gui/ConsumerBase.cpp
@@ -31,9 +31,12 @@
 #include <gui/BufferItem.h>
 #include <gui/BufferQueue.h>
 #include <gui/ConsumerBase.h>
+#ifndef NO_BINDER
+#include <gui/IConsumerListener.h>
 #include <gui/ISurfaceComposer.h>
-#include <gui/Surface.h>
 #include <gui/SurfaceComposerClient.h>
+#endif
+#include <gui/Surface.h>
 
 #include <private/gui/ComposerService.h>
 
@@ -72,7 +75,6 @@ ConsumerBase::ConsumerBase(const sp<IGraphicBufferConsumer>& bufferQueue, bool c
     initialize(controlledByApp);
 }
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
 ConsumerBase::ConsumerBase(bool controlledByApp, bool consumerIsSurfaceFlinger)
       :
 #if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_UNLIMITED_SLOTS)
@@ -99,8 +101,6 @@ ConsumerBase::ConsumerBase(const sp<IGraphicBufferProducer>& producer,
     initialize(controlledByApp);
 }
 
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
-
 void ConsumerBase::initialize(bool controlledByApp) {
     // Choose a name using the PID and a process-unique ID.
     mName = String8::format("unnamed-%d-%d", getpid(), createProcessUniqueId());
@@ -366,7 +366,6 @@ status_t ConsumerBase::detachBuffer(int slot) {
     return detachBufferLocked(slot);
 }
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
 status_t ConsumerBase::detachBuffer(const sp<GraphicBuffer>& buffer) {
     CB_LOGV("detachBuffer");
     Mutex::Autolock lock(mMutex);
@@ -386,7 +385,6 @@ status_t ConsumerBase::detachBuffer(const sp<GraphicBuffer>& buffer) {
 
     return detachBufferLocked(slotIndex);
 }
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
 
 status_t ConsumerBase::addReleaseFence(const sp<GraphicBuffer> buffer, const sp<Fence>& fence) {
     CB_LOGV("addReleaseFence");
@@ -454,7 +452,6 @@ status_t ConsumerBase::setTransformHint(uint32_t hint) {
     return mConsumer->setTransformHint(hint);
 }
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
 status_t ConsumerBase::setMaxBufferCount(int bufferCount) {
     Mutex::Autolock lock(mMutex);
     if (mAbandoned) {
@@ -472,7 +469,6 @@ status_t ConsumerBase::setMaxBufferCount(int bufferCount) {
 
     return mConsumer->setMaxBufferCount(bufferCount);
 }
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
 
 status_t ConsumerBase::setMaxAcquiredBufferCount(int maxAcquiredBuffers) {
     Mutex::Autolock lock(mMutex);
@@ -570,7 +566,6 @@ void ConsumerBase::dumpLocked(String8& result, const char* prefix) const {
     }
 }
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
 sp<Surface> ConsumerBase::getSurface() const {
     LOG_ALWAYS_FATAL_IF(mSurface == nullptr,
                         "It's illegal to get the surface of a Consumer that does not own it. This "
@@ -581,7 +576,6 @@ sp<Surface> ConsumerBase::getSurface() const {
 sp<IGraphicBufferConsumer> ConsumerBase::getIGraphicBufferConsumer() const {
     return mConsumer;
 }
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
 
 status_t ConsumerBase::acquireBufferLocked(BufferItem *item,
         nsecs_t presentWhen, uint64_t maxFrameNumber) {
diff --git a/libs/gui/CpuConsumer.cpp b/libs/gui/CpuConsumer.cpp
index ecbceb7a79..687b422b20 100644
--- a/libs/gui/CpuConsumer.cpp
+++ b/libs/gui/CpuConsumer.cpp
@@ -38,18 +38,9 @@ namespace android {
 std::tuple<sp<CpuConsumer>, sp<Surface>> CpuConsumer::create(size_t maxLockedBuffers,
                                                              bool controlledByApp,
                                                              bool isConsumerSurfaceFlinger) {
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
     sp<CpuConsumer> consumer =
             sp<CpuConsumer>::make(maxLockedBuffers, controlledByApp, isConsumerSurfaceFlinger);
     return {consumer, consumer->getSurface()};
-#else
-    sp<IGraphicBufferProducer> igbp;
-    sp<IGraphicBufferConsumer> igbc;
-    BufferQueue::createBufferQueue(&igbp, &igbc, isConsumerSurfaceFlinger);
-
-    return {sp<CpuConsumer>::make(igbc, maxLockedBuffers, controlledByApp),
-            sp<Surface>::make(igbp, controlledByApp)};
-#endif
 }
 
 sp<CpuConsumer> CpuConsumer::create(const sp<IGraphicBufferConsumer>& bq, size_t maxLockedBuffers,
@@ -57,7 +48,6 @@ sp<CpuConsumer> CpuConsumer::create(const sp<IGraphicBufferConsumer>& bq, size_t
     return sp<CpuConsumer>::make(bq, maxLockedBuffers, controlledByApp);
 }
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
 CpuConsumer::CpuConsumer(size_t maxLockedBuffers, bool controlledByApp,
                          bool isConsumerSurfaceFlinger)
       : ConsumerBase(controlledByApp, isConsumerSurfaceFlinger),
@@ -65,11 +55,7 @@ CpuConsumer::CpuConsumer(size_t maxLockedBuffers, bool controlledByApp,
         mCurrentLockedBuffers(0) {
     // Create tracking entries for locked buffers
     mAcquiredBuffers.insertAt(0, maxLockedBuffers);
-
-    mConsumer->setConsumerUsageBits(GRALLOC_USAGE_SW_READ_OFTEN);
-    mConsumer->setMaxAcquiredBufferCount(static_cast<int32_t>(maxLockedBuffers));
 }
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
 
 CpuConsumer::CpuConsumer(const sp<IGraphicBufferConsumer>& bq, size_t maxLockedBuffers,
                          bool controlledByApp)
@@ -78,9 +64,16 @@ CpuConsumer::CpuConsumer(const sp<IGraphicBufferConsumer>& bq, size_t maxLockedB
         mCurrentLockedBuffers(0) {
     // Create tracking entries for locked buffers
     mAcquiredBuffers.insertAt(0, maxLockedBuffers);
+}
 
+void CpuConsumer::initializeConsumer() {
     mConsumer->setConsumerUsageBits(GRALLOC_USAGE_SW_READ_OFTEN);
-    mConsumer->setMaxAcquiredBufferCount(static_cast<int32_t>(maxLockedBuffers));
+    mConsumer->setMaxAcquiredBufferCount(static_cast<int32_t>(mMaxLockedBuffers));
+}
+
+void CpuConsumer::onFirstRef() {
+    ConsumerBase::onFirstRef();
+    initializeConsumer();
 }
 
 size_t CpuConsumer::findAcquiredBufferLocked(uintptr_t id) const {
diff --git a/libs/gui/DisplayEventDispatcher.cpp b/libs/gui/DisplayEventDispatcher.cpp
index 6f238859a4..97f6d245cc 100644
--- a/libs/gui/DisplayEventDispatcher.cpp
+++ b/libs/gui/DisplayEventDispatcher.cpp
@@ -27,10 +27,10 @@
 #include <utils/Timers.h>
 #include <utils/Trace.h>
 
-#include <com_android_graphics_libgui_flags.h>
+#include <com_android_graphics_surfaceflinger_flags.h>
 
 namespace android {
-using namespace com::android::graphics::libgui;
+using namespace com::android::graphics::surfaceflinger;
 
 // Number of events to read at a time from the DisplayEventDispatcher pipe.
 // The value should be large enough that we can quickly drain the pipe
@@ -177,7 +177,7 @@ bool DisplayEventDispatcher::processPendingEvents(nsecs_t* outTimestamp,
                     *outVsyncEventData = ev.vsync.vsyncData;
 
                     // Trace the RenderRate for this app
-                    if (ATRACE_ENABLED() && flags::trace_frame_rate_override()) {
+                    if (ATRACE_ENABLED()) {
                         const auto frameInterval = ev.vsync.vsyncData.frameInterval;
                         int fps = frameInterval > 0 ? 1e9f / frameInterval : 0;
                         ATRACE_INT("RenderRate", fps);
@@ -193,8 +193,22 @@ bool DisplayEventDispatcher::processPendingEvents(nsecs_t* outTimestamp,
                     }
                     break;
                 case DisplayEventType::DISPLAY_EVENT_MODE_CHANGE:
+                    LOG_ALWAYS_FATAL_IF(flags::unify_refresh_rate_callbacks(),
+                                        "dispatchModeChanged should not be sent when"
+                                        " refresh rate callbacks are unified");
                     dispatchModeChanged(ev.header.timestamp, ev.header.displayId,
-                                        ev.modeChange.modeId, ev.modeChange.vsyncPeriod);
+                                        ev.modeChange.modeId, ev.modeChange.vsyncPeriod,
+                                        ev.modeChange.appVsyncOffset,
+                                        ev.modeChange.presentationDeadline);
+                    break;
+                case DisplayEventType::DISPLAY_EVENT_MODE_AND_FRAME_RATE_CHANGE:
+                    dispatchModeChangedWithFrameRateOverrides(ev.header.timestamp,
+                                                              ev.header.displayId,
+                                                              ev.modeChange.modeId,
+                                                              ev.modeChange.vsyncPeriod,
+                                                              ev.modeChange.appVsyncOffset,
+                                                              ev.modeChange.presentationDeadline,
+                                                              std::move(mFrameRateOverrides));
                     break;
                 case DisplayEventType::DISPLAY_EVENT_NULL:
                     dispatchNullEvent(ev.header.timestamp, ev.header.displayId);
@@ -203,6 +217,9 @@ bool DisplayEventDispatcher::processPendingEvents(nsecs_t* outTimestamp,
                     mFrameRateOverrides.emplace_back(ev.frameRateOverride);
                     break;
                 case DisplayEventType::DISPLAY_EVENT_FRAME_RATE_OVERRIDE_FLUSH:
+                    LOG_ALWAYS_FATAL_IF(flags::unify_refresh_rate_callbacks(),
+                                        "dispatchFrameRateOverrides should not be sent when"
+                                        " refresh rate callbacks are unified");
                     dispatchFrameRateOverrides(ev.header.timestamp, ev.header.displayId,
                                                std::move(mFrameRateOverrides));
                     break;
diff --git a/libs/gui/Flags.cpp b/libs/gui/Flags.cpp
index ee2802f706..9612f9b5dd 100644
--- a/libs/gui/Flags.cpp
+++ b/libs/gui/Flags.cpp
@@ -76,6 +76,71 @@ sp<SurfaceType> convertParcelableSurfaceTypeToSurface(const ParcelableSurfaceTyp
     return surface;
 #endif
 }
-
 } // namespace flagtools
+namespace mediaflagtools {
+sp<MediaSurfaceType> igbpToSurfaceType(const sp<IGraphicBufferProducer>& igbp) {
+    if (igbp == nullptr) {
+        return nullptr;
+    }
+#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_MEDIA_MIGRATION)
+    return new Surface(igbp);
+#else
+    return igbp;
+#endif
+}
+
+sp<IGraphicBufferProducer> surfaceTypeToIGBP(const sp<MediaSurfaceType>& mst) {
+    if (mst == nullptr) {
+        return nullptr;
+    }
+#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_MEDIA_MIGRATION)
+    return mst->getIGraphicBufferProducer();
+#else
+    return mst;
+#endif
+}
+
+sp<SurfaceType> mediaSurfaceToCameraSurfaceType(const sp<MediaSurfaceType>& mst,
+                                                [[maybe_unused]] bool controlledByApp) {
+    if (mst == nullptr) {
+        return nullptr;
+    }
+#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_MEDIA_MIGRATION)
+#if WB_LIBCAMERASERVICE_WITH_DEPENDENCIES
+    return mst;
+#else
+    return mst->getGraphicBufferProducer();
+#endif
+#else
+#if WB_LIBCAMERASERVICE_WITH_DEPENDENCIES
+    return sp<Surface>::make(mst, controlledByApp);
+#else
+    return mst;
+#endif
+#endif
+}
+
+sp<Surface> surfaceTypeToSurface(const sp<MediaSurfaceType>& mst,
+                                 [[maybe_unused]] bool controlledByApp) {
+    if (mst == nullptr) {
+        return nullptr;
+    }
+#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_MEDIA_MIGRATION)
+    return mst;
+#else
+    return sp<Surface>::make(mst, controlledByApp);
+#endif
+}
+
+sp<MediaSurfaceType> surfaceToSurfaceType(const sp<Surface>& surface) {
+    if (surface == nullptr) {
+        return nullptr;
+    }
+#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_MEDIA_MIGRATION)
+    return surface;
+#else
+    return surface->getIGraphicBufferProducer();
+#endif
+}
+} // namespace mediaflagtools
 } // namespace android
\ No newline at end of file
diff --git a/libs/gui/FrameRateUtils.cpp b/libs/gui/FrameRateUtils.cpp
index 1b2354e942..5a64bf7369 100644
--- a/libs/gui/FrameRateUtils.cpp
+++ b/libs/gui/FrameRateUtils.cpp
@@ -56,9 +56,7 @@ bool ValidateFrameRate(float frameRate, int8_t compatibility, int8_t changeFrame
             changeFrameRateStrategy != ANATIVEWINDOW_CHANGE_FRAME_RATE_ALWAYS) {
             ALOGE("%s failed - invalid change frame rate strategy value %d", functionName,
                   changeFrameRateStrategy);
-            if (flags::bq_setframerate()) {
-                return false;
-            }
+            return false;
         }
     }
 
diff --git a/libs/gui/GLConsumer.cpp b/libs/gui/GLConsumer.cpp
index 2c5770d4c6..a38a3c8db1 100644
--- a/libs/gui/GLConsumer.cpp
+++ b/libs/gui/GLConsumer.cpp
@@ -105,34 +105,16 @@ static bool hasEglProtectedContent() {
 std::tuple<sp<GLConsumer>, sp<Surface>> GLConsumer::create(uint32_t tex, uint32_t textureTarget,
                                                            bool useFenceSync,
                                                            bool isControlledByApp) {
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
     sp<GLConsumer> consumer =
             sp<GLConsumer>::make(tex, textureTarget, useFenceSync, isControlledByApp);
     return {consumer, consumer->getSurface()};
-#else
-    sp<IGraphicBufferProducer> igbp;
-    sp<IGraphicBufferConsumer> igbc;
-    BufferQueue::createBufferQueue(&igbp, &igbc);
-
-    return {sp<GLConsumer>::make(igbc, tex, textureTarget, useFenceSync, isControlledByApp),
-            sp<Surface>::make(igbp, isControlledByApp)};
-#endif
 }
 
 std::tuple<sp<GLConsumer>, sp<Surface>> GLConsumer::create(uint32_t textureTarget,
                                                            bool useFenceSync,
                                                            bool isControlledByApp) {
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
     sp<GLConsumer> consumer = sp<GLConsumer>::make(textureTarget, useFenceSync, isControlledByApp);
     return {consumer, consumer->getSurface()};
-#else
-    sp<IGraphicBufferProducer> igbp;
-    sp<IGraphicBufferConsumer> igbc;
-    BufferQueue::createBufferQueue(&igbp, &igbc);
-
-    return {sp<GLConsumer>::make(igbc, textureTarget, useFenceSync, isControlledByApp),
-            sp<Surface>::make(igbp, isControlledByApp)};
-#endif
 }
 
 sp<GLConsumer> GLConsumer::create(const sp<IGraphicBufferConsumer>& bq, uint32_t tex,
@@ -146,7 +128,6 @@ sp<GLConsumer> GLConsumer::create(const sp<IGraphicBufferConsumer>& bq, uint32_t
     return sp<GLConsumer>::make(bq, textureTarget, useFenceSync, isControlledByApp);
 }
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
 GLConsumer::GLConsumer(uint32_t tex, uint32_t texTarget, bool useFenceSync, bool isControlledByApp)
       : ConsumerBase(isControlledByApp, /* isConsumerSurfaceFlinger */ false),
         mCurrentCrop(Rect::EMPTY_RECT),
@@ -175,7 +156,6 @@ GLConsumer::GLConsumer(uint32_t tex, uint32_t texTarget, bool useFenceSync, bool
 
     mConsumer->setConsumerUsageBits(DEFAULT_USAGE_FLAGS);
 }
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
 
 GLConsumer::GLConsumer(const sp<IGraphicBufferConsumer>& bq, uint32_t tex, uint32_t texTarget,
                        bool useFenceSync, bool isControlledByApp)
@@ -208,7 +188,6 @@ GLConsumer::GLConsumer(const sp<IGraphicBufferConsumer>& bq, uint32_t tex, uint3
     mConsumer->setConsumerUsageBits(DEFAULT_USAGE_FLAGS);
 }
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
 GLConsumer::GLConsumer(uint32_t texTarget, bool useFenceSync, bool isControlledByApp)
       : ConsumerBase(isControlledByApp, /* isConsumerSurfaceFlinger */ false),
         mCurrentCrop(Rect::EMPTY_RECT),
@@ -237,7 +216,6 @@ GLConsumer::GLConsumer(uint32_t texTarget, bool useFenceSync, bool isControlledB
 
     mConsumer->setConsumerUsageBits(DEFAULT_USAGE_FLAGS);
 }
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
 
 GLConsumer::GLConsumer(const sp<IGraphicBufferConsumer>& bq, uint32_t texTarget, bool useFenceSync,
                        bool isControlledByApp)
diff --git a/libs/gui/IGraphicBufferProducer.cpp b/libs/gui/IGraphicBufferProducer.cpp
index 1d1910eb08..5f373af0b1 100644
--- a/libs/gui/IGraphicBufferProducer.cpp
+++ b/libs/gui/IGraphicBufferProducer.cpp
@@ -779,7 +779,7 @@ public:
         }
         return result;
     }
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(BQ_SETFRAMERATE)
+
     virtual status_t setFrameRate(float frameRate, int8_t compatibility,
                                   int8_t changeFrameRateStrategy) override {
         Parcel data, reply;
@@ -793,7 +793,7 @@ public:
         }
         return result;
     }
-#endif
+
 #if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(BQ_EXTENDEDALLOCATE)
     virtual status_t setAdditionalOptions(const std::vector<gui::AdditionalOptions>& options) {
         Parcel data, reply;
@@ -1016,13 +1016,11 @@ status_t IGraphicBufferProducer::setAutoPrerotation(bool autoPrerotation) {
     return INVALID_OPERATION;
 }
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(BQ_SETFRAMERATE)
 status_t IGraphicBufferProducer::setFrameRate(float /*frameRate*/, int8_t /*compatibility*/,
                                               int8_t /*changeFrameRateStrategy*/) {
     // No-op for IGBP other than BufferQueue.
     return INVALID_OPERATION;
 }
-#endif
 
 #if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(BQ_EXTENDEDALLOCATE)
 status_t IGraphicBufferProducer::setAdditionalOptions(const std::vector<gui::AdditionalOptions>&) {
@@ -1572,7 +1570,6 @@ status_t BnGraphicBufferProducer::onTransact(
             reply->writeInt32(result);
             return NO_ERROR;
         }
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(BQ_SETFRAMERATE)
         case SET_FRAME_RATE: {
             CHECK_INTERFACE(IGraphicBuffer, data, reply);
             float frameRate = data.readFloat();
@@ -1582,7 +1579,6 @@ status_t BnGraphicBufferProducer::onTransact(
             reply->writeInt32(result);
             return NO_ERROR;
         }
-#endif
 #if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(BQ_EXTENDEDALLOCATE)
         case SET_ADDITIONAL_OPTIONS: {
             CHECK_INTERFACE(IGraphicBuffer, data, reply);
diff --git a/libs/gui/ISurfaceComposer.cpp b/libs/gui/ISurfaceComposer.cpp
index ae4b74e03b..7121104eed 100644
--- a/libs/gui/ISurfaceComposer.cpp
+++ b/libs/gui/ISurfaceComposer.cpp
@@ -26,6 +26,7 @@
 #include <gui/ISurfaceComposer.h>
 #include <gui/LayerState.h>
 #include <gui/SchedulingPolicy.h>
+#include <gui/SimpleTransactionState.h>
 #include <gui/TransactionState.h>
 #include <private/gui/ParcelUtils.h>
 #include <stdint.h>
@@ -51,27 +52,29 @@ using gui::IWindowInfosListener;
 using gui::LayerCaptureArgs;
 using ui::ColorMode;
 
-class BpSurfaceComposer : public BpInterface<ISurfaceComposer>
-{
+class BpSurfaceComposer : public BpInterface<ISurfaceComposer> {
 public:
-    explicit BpSurfaceComposer(const sp<IBinder>& impl)
-        : BpInterface<ISurfaceComposer>(impl)
-    {
-    }
+    explicit BpSurfaceComposer(const sp<IBinder>& impl) : BpInterface<ISurfaceComposer>(impl) {}
 
     virtual ~BpSurfaceComposer();
 
-    status_t setTransactionState(TransactionState&& state) override {
+    status_t setTransactionState(const SimpleTransactionState simpleState,
+                                 const ComplexTransactionState& complexState,
+                                 MutableTransactionState& mutableState,
+                                 const sp<IBinder>& applyToken) override {
         Parcel data, reply;
         data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());
-        SAFE_PARCEL(state.writeToParcel, &data);
 
-        if (state.mFlags & ISurfaceComposer::eOneWay) {
-            return remote()->transact(BnSurfaceComposer::SET_TRANSACTION_STATE,
-                    data, &reply, IBinder::FLAG_ONEWAY);
+        SAFE_PARCEL(mutableState.writeToParcel, &data);
+        SAFE_PARCEL(simpleState.writeToParcel, &data);
+        SAFE_PARCEL(complexState.writeToParcel, &data);
+        SAFE_PARCEL(data.writeStrongBinder, applyToken);
+
+        if (simpleState.mFlags & ISurfaceComposer::eOneWay) {
+            return remote()->transact(BnSurfaceComposer::SET_TRANSACTION_STATE, data, &reply,
+                                      IBinder::FLAG_ONEWAY);
         } else {
-            return remote()->transact(BnSurfaceComposer::SET_TRANSACTION_STATE,
-                    data, &reply);
+            return remote()->transact(BnSurfaceComposer::SET_TRANSACTION_STATE, data, &reply);
         }
     }
 };
@@ -84,16 +87,23 @@ IMPLEMENT_META_INTERFACE(SurfaceComposer, "android.ui.ISurfaceComposer");
 
 // ----------------------------------------------------------------------
 
-status_t BnSurfaceComposer::onTransact(
-    uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
-{
+status_t BnSurfaceComposer::onTransact(uint32_t code, const Parcel& data, Parcel* reply,
+                                       uint32_t flags) {
     switch (code) {
         case SET_TRANSACTION_STATE: {
             CHECK_INTERFACE(ISurfaceComposer, data, reply);
 
-            TransactionState state;
-            SAFE_PARCEL(state.readFromParcel, &data);
-            return setTransactionState(std::move(state));
+            MutableTransactionState mutableState;
+            SAFE_PARCEL(mutableState.readFromParcel, &data);
+            SimpleTransactionState simpleState;
+            SAFE_PARCEL(simpleState.readFromParcel, &data);
+            ComplexTransactionState complexState;
+            SAFE_PARCEL(complexState.readFromParcel, &data);
+
+            sp<IBinder> applyToken;
+            SAFE_PARCEL(data.readStrongBinder, &applyToken);
+
+            return setTransactionState(simpleState, complexState, mutableState, applyToken);
         }
         case GET_SCHEDULING_POLICY: {
             gui::SchedulingPolicy policy;
diff --git a/libs/gui/LayerState.cpp b/libs/gui/LayerState.cpp
index 86bc97e9d3..5c0cad92f4 100644
--- a/libs/gui/LayerState.cpp
+++ b/libs/gui/LayerState.cpp
@@ -90,6 +90,7 @@ layer_state_t::layer_state_t()
         cornerRadius(0.0f),
         clientDrawnCornerRadius(0.0f),
         backgroundBlurRadius(0),
+        backgroundBlurScale{1.0f},
         color(0),
         bufferTransform(0),
         transformToDisplayInverse(false),
@@ -166,6 +167,7 @@ status_t layer_state_t::write(Parcel& output) const
     SAFE_PARCEL(output.writeFloat, cornerRadius);
     SAFE_PARCEL(output.writeFloat, clientDrawnCornerRadius);
     SAFE_PARCEL(output.writeUint32, backgroundBlurRadius);
+    SAFE_PARCEL(output.writeFloat, backgroundBlurScale);
     SAFE_PARCEL(output.writeParcelable, metadata);
     SAFE_PARCEL(output.writeFloat, bgColor.r);
     SAFE_PARCEL(output.writeFloat, bgColor.g);
@@ -181,6 +183,7 @@ status_t layer_state_t::write(Parcel& output) const
     }
     SAFE_PARCEL(output.writeFloat, shadowRadius);
     SAFE_PARCEL(output.writeParcelable, borderSettings);
+    SAFE_PARCEL(output.writeParcelable, boxShadowSettings);
     SAFE_PARCEL(output.writeInt32, frameRateSelectionPriority);
     SAFE_PARCEL(output.writeFloat, frameRate);
     SAFE_PARCEL(output.writeByte, frameRateCompatibility);
@@ -304,6 +307,7 @@ status_t layer_state_t::read(const Parcel& input)
     SAFE_PARCEL(input.readFloat, &cornerRadius);
     SAFE_PARCEL(input.readFloat, &clientDrawnCornerRadius);
     SAFE_PARCEL(input.readUint32, &backgroundBlurRadius);
+    SAFE_PARCEL(input.readFloat, &backgroundBlurScale);
     SAFE_PARCEL(input.readParcelable, &metadata);
 
     SAFE_PARCEL(input.readFloat, &tmpFloat);
@@ -330,6 +334,7 @@ status_t layer_state_t::read(const Parcel& input)
     }
     SAFE_PARCEL(input.readFloat, &shadowRadius);
     SAFE_PARCEL(input.readParcelable, &borderSettings);
+    SAFE_PARCEL(input.readParcelable, &boxShadowSettings);
 
     SAFE_PARCEL(input.readInt32, &frameRateSelectionPriority);
     SAFE_PARCEL(input.readFloat, &frameRate);
@@ -635,6 +640,10 @@ void layer_state_t::merge(const layer_state_t& other) {
         what |= eBackgroundBlurRadiusChanged;
         backgroundBlurRadius = other.backgroundBlurRadius;
     }
+    if (other.what & eBackgroundBlurScaleChanged) {
+        what |= eBackgroundBlurScaleChanged;
+        backgroundBlurScale = other.backgroundBlurScale;
+    }
     if (other.what & eBlurRegionsChanged) {
         what |= eBlurRegionsChanged;
         blurRegions = other.blurRegions;
@@ -734,6 +743,10 @@ void layer_state_t::merge(const layer_state_t& other) {
         what |= eBorderSettingsChanged;
         borderSettings = other.borderSettings;
     }
+    if (other.what & eBoxShadowSettingsChanged) {
+        what |= eBoxShadowSettingsChanged;
+        boxShadowSettings = other.boxShadowSettings;
+    }
     if (other.what & eLutsChanged) {
         what |= eLutsChanged;
         luts = other.luts;
@@ -854,6 +867,7 @@ uint64_t layer_state_t::diff(const layer_state_t& other) const {
     CHECK_DIFF(diff, eCornerRadiusChanged, other, cornerRadius);
     CHECK_DIFF(diff, eClientDrawnCornerRadiusChanged, other, clientDrawnCornerRadius);
     CHECK_DIFF(diff, eBackgroundBlurRadiusChanged, other, backgroundBlurRadius);
+    CHECK_DIFF(diff, eBackgroundBlurScaleChanged, other, backgroundBlurScale);
     if (other.what & eBlurRegionsChanged) diff |= eBlurRegionsChanged;
     if (other.what & eRelativeLayerChanged) {
         diff |= eRelativeLayerChanged;
@@ -889,6 +903,7 @@ uint64_t layer_state_t::diff(const layer_state_t& other) const {
     if (other.what & eMetadataChanged) diff |= eMetadataChanged;
     CHECK_DIFF(diff, eShadowRadiusChanged, other, shadowRadius);
     CHECK_DIFF(diff, eBorderSettingsChanged, other, borderSettings);
+    CHECK_DIFF(diff, eBoxShadowSettingsChanged, other, boxShadowSettings);
     CHECK_DIFF(diff, eDefaultFrameRateCompatibilityChanged, other, defaultFrameRateCompatibility);
     CHECK_DIFF(diff, eFrameRateSelectionPriority, other, frameRateSelectionPriority);
     CHECK_DIFF3(diff, eFrameRateChanged, other, frameRate, frameRateCompatibility,
@@ -912,6 +927,7 @@ uint64_t layer_state_t::diff(const layer_state_t& other) const {
     if (other.what & eLutsChanged) diff |= eLutsChanged;
     CHECK_DIFF(diff, ePictureProfileHandleChanged, other, pictureProfileHandle);
     CHECK_DIFF(diff, eAppContentPriorityChanged, other, appContentPriority);
+    if (other.what & eStopLayerChanged) diff |= eStopLayerChanged;
 
     return diff;
 }
diff --git a/libs/gui/Surface.cpp b/libs/gui/Surface.cpp
index 83c6b57289..402576d210 100644
--- a/libs/gui/Surface.cpp
+++ b/libs/gui/Surface.cpp
@@ -29,39 +29,65 @@
 
 #include <inttypes.h>
 
+#ifndef NO_BINDER
 #include <android/gui/DisplayStatInfo.h>
+#include <gui/AidlUtil.h>
+#include <gui/ISurfaceComposer.h>
+#include <gui/LayerState.h>
+#include <private/gui/ComposerService.h>
+#include <private/gui/ComposerServiceAIDL.h>
+#endif
+
 #include <android/native_window.h>
 
+#include <android-base/strings.h>
 #include <gui/FenceMonitor.h>
 #include <gui/TraceUtils.h>
+#include <utils/Errors.h>
 #include <utils/Log.h>
 #include <utils/NativeHandle.h>
 #include <utils/Trace.h>
 
 #include <ui/BufferQueueDefs.h>
 #include <ui/DynamicDisplayInfo.h>
+#include <ui/FatVector.h>
 #include <ui/Fence.h>
 #include <ui/GraphicBuffer.h>
 #include <ui/Region.h>
 
-#include <gui/AidlUtil.h>
 #include <gui/BufferItem.h>
 
-#include <gui/ISurfaceComposer.h>
-#include <gui/LayerState.h>
-#include <private/gui/ComposerService.h>
-#include <private/gui/ComposerServiceAIDL.h>
-
 #include <com_android_graphics_libgui_flags.h>
 
 namespace android {
 
 using namespace com::android::graphics::libgui;
-using gui::aidl_utils::statusTFromBinderStatus;
 using ui::Dataspace;
 
 namespace {
 
+#define SURF_LOG_BASE(MACRO, x, ...)                                              \
+    {                                                                             \
+        std::scoped_lock _l(mDebugMutex);                                         \
+        MACRO("[%s](id:%" PRIx64 ") " x, mDebugName.c_str(), mId, ##__VA_ARGS__); \
+    }
+#define SURF_LOG_IF_BASE(MACRO, cond, x, ...)                                           \
+    {                                                                                   \
+        std::scoped_lock _l(mDebugMutex);                                               \
+        MACRO(cond, "[%s](id:%" PRIx64 ") " x, mDebugName.c_str(), mId, ##__VA_ARGS__); \
+    }
+
+#define SURF_LOGV(x, ...) SURF_LOG_BASE(ALOGV, x, ##__VA_ARGS__)
+#define SURF_LOGD(x, ...) SURF_LOG_BASE(ALOGD, x, ##__VA_ARGS__)
+#define SURF_LOGI(x, ...) SURF_LOG_BASE(ALOGI, x, ##__VA_ARGS__)
+#define SURF_LOGW(x, ...) SURF_LOG_BASE(ALOGW, x, ##__VA_ARGS__)
+#define SURF_LOGE(x, ...) SURF_LOG_BASE(ALOGE, x, ##__VA_ARGS__)
+
+#define SURF_LOGE_IF(cond, x, ...) SURF_LOG_IF_BASE(ALOGE_IF, cond, x, ##__VA_ARGS__)
+#define SURF_LOGW_IF(cond, x, ...) SURF_LOG_IF_BASE(ALOGW_IF, cond, x, ##__VA_ARGS__)
+#define SURF_LOG_ALWAYS_FATAL_IF(cond, x, ...) \
+    SURF_LOG_IF_BASE(LOG_ALWAYS_FATAL_IF, cond, x, ##__VA_ARGS__)
+
 enum {
     // moved from nativewindow/include/system/window.h, to be removed
     NATIVE_WINDOW_GET_WIDE_COLOR_SUPPORT = 28,
@@ -78,7 +104,6 @@ bool isInterceptorRegistrationOp(int op) {
 
 } // namespace
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
 Surface::ProducerDeathListenerProxy::ProducerDeathListenerProxy(wp<SurfaceListener> surfaceListener)
       : mSurfaceListener(surfaceListener) {}
 
@@ -92,14 +117,11 @@ void Surface::ProducerDeathListenerProxy::binderDied(const wp<IBinder>&) {
         surfaceListener->onRemoteDied();
     }
 }
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
 
 Surface::Surface(const sp<IGraphicBufferProducer>& bufferProducer, bool controlledByApp,
                  const sp<IBinder>& surfaceControlHandle)
       : mGraphicBufferProducer(bufferProducer),
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
         mSurfaceDeathListener(nullptr),
-#endif
 #if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_UNLIMITED_SLOTS)
         mSlots(NUM_BUFFER_SLOTS),
 #endif
@@ -115,6 +137,8 @@ Surface::Surface(const sp<IGraphicBufferProducer>& bufferProducer, bool controll
         mFrameTimestampsSupportsPresent(false),
         mEnableFrameTimestamps(false),
         mFrameEventHistory(std::make_unique<ProducerFrameEventHistory>()) {
+    LOG_ALWAYS_FATAL_IF(!mGraphicBufferProducer); // it will crash anyway
+
     // Initialize the ANativeWindow function pointers.
     ANativeWindow::setSwapInterval  = hook_setSwapInterval;
     ANativeWindow::dequeueBuffer    = hook_dequeueBuffer;
@@ -157,14 +181,15 @@ Surface::~Surface() {
     if (mConnectedToCpu) {
         Surface::disconnect(NATIVE_WINDOW_API_CPU);
     }
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
+#if !defined(NO_BINDER)
     if (mSurfaceDeathListener != nullptr) {
         IInterface::asBinder(mGraphicBufferProducer)->unlinkToDeath(mSurfaceDeathListener);
         mSurfaceDeathListener = nullptr;
     }
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
+#endif // !defined(NO_BINDER)
 }
 
+#ifndef NO_BINDER
 sp<ISurfaceComposer> Surface::composerService() const {
     return ComposerService::getComposerService();
 }
@@ -172,6 +197,7 @@ sp<ISurfaceComposer> Surface::composerService() const {
 sp<gui::ISurfaceComposer> Surface::composerServiceAIDL() const {
     return ComposerServiceAIDL::getComposerService();
 }
+#endif
 
 nsecs_t Surface::now() const {
     return systemTime();
@@ -192,11 +218,9 @@ void Surface::allocateBuffers() {
             mReqFormat, mReqUsage);
 }
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
 status_t Surface::allowAllocation(bool allowAllocation) {
     return mGraphicBufferProducer->allowAllocation(allowAllocation);
 }
-#endif
 
 status_t Surface::setGenerationNumber(uint32_t generation) {
     status_t result = mGraphicBufferProducer->setGenerationNumber(generation);
@@ -228,6 +252,12 @@ status_t Surface::getLastQueuedBuffer(sp<GraphicBuffer>* outBuffer,
 status_t Surface::getDisplayRefreshCycleDuration(nsecs_t* outRefreshDuration) {
     ATRACE_CALL();
 
+#ifdef NO_BINDER
+    (void)outRefreshDuration;
+    return INVALID_OPERATION;
+#else
+    using gui::aidl_utils::statusTFromBinderStatus;
+
     gui::DisplayStatInfo stats;
     binder::Status status = composerServiceAIDL()->getDisplayStats(nullptr, &stats);
     if (!status.isOk()) {
@@ -237,6 +267,7 @@ status_t Surface::getDisplayRefreshCycleDuration(nsecs_t* outRefreshDuration) {
     *outRefreshDuration = stats.vsyncPeriod;
 
     return NO_ERROR;
+#endif
 }
 
 void Surface::enableFrameTimestamps(bool enable) {
@@ -453,13 +484,21 @@ int Surface::hook_dequeueBuffer(ANativeWindow* window,
             return interceptor(window, Surface::dequeueBufferInternal, data, buffer, fenceFd);
         }
     }
-    return c->dequeueBuffer(buffer, fenceFd);
+
+    sp<GraphicBuffer> graphicBuffer;
+    status_t result = c->dequeueBuffer(&graphicBuffer, fenceFd);
+    *buffer = graphicBuffer.get();
+    return result;
 }
 
 int Surface::dequeueBufferInternal(ANativeWindow* window, ANativeWindowBuffer** buffer,
                                    int* fenceFd) {
     Surface* c = getSelf(window);
-    return c->dequeueBuffer(buffer, fenceFd);
+
+    sp<GraphicBuffer> graphicBuffer;
+    status_t result = c->dequeueBuffer(&graphicBuffer, fenceFd);
+    *buffer = graphicBuffer.get();
+    return result;
 }
 
 int Surface::hook_cancelBuffer(ANativeWindow* window,
@@ -473,12 +512,13 @@ int Surface::hook_cancelBuffer(ANativeWindow* window,
             return interceptor(window, Surface::cancelBufferInternal, data, buffer, fenceFd);
         }
     }
-    return c->cancelBuffer(buffer, fenceFd);
+    return c->cancelBuffer(GraphicBuffer::from(buffer), fenceFd);
 }
 
 int Surface::cancelBufferInternal(ANativeWindow* window, ANativeWindowBuffer* buffer, int fenceFd) {
     Surface* c = getSelf(window);
-    return c->cancelBuffer(buffer, fenceFd);
+    sp<GraphicBuffer> graphicBuffer = GraphicBuffer::from(buffer);
+    return c->cancelBuffer(GraphicBuffer::from(buffer), fenceFd);
 }
 
 int Surface::hook_queueBuffer(ANativeWindow* window,
@@ -492,18 +532,18 @@ int Surface::hook_queueBuffer(ANativeWindow* window,
             return interceptor(window, Surface::queueBufferInternal, data, buffer, fenceFd);
         }
     }
-    return c->queueBuffer(buffer, fenceFd);
+    return c->queueBuffer(GraphicBuffer::from(buffer), fenceFd);
 }
 
 int Surface::queueBufferInternal(ANativeWindow* window, ANativeWindowBuffer* buffer, int fenceFd) {
     Surface* c = getSelf(window);
-    return c->queueBuffer(buffer, fenceFd);
+    return c->queueBuffer(GraphicBuffer::from(buffer), fenceFd);
 }
 
 int Surface::hook_dequeueBuffer_DEPRECATED(ANativeWindow* window,
         ANativeWindowBuffer** buffer) {
     Surface* c = getSelf(window);
-    ANativeWindowBuffer* buf;
+    sp<GraphicBuffer> buf;
     int fenceFd = -1;
     int result = c->dequeueBuffer(&buf, &fenceFd);
     if (result != OK) {
@@ -514,29 +554,29 @@ int Surface::hook_dequeueBuffer_DEPRECATED(ANativeWindow* window,
     if (waitResult != OK) {
         ALOGE("dequeueBuffer_DEPRECATED: Fence::wait returned an error: %d",
                 waitResult);
-        c->cancelBuffer(buf, -1);
+        c->cancelBuffer(std::move(buf), -1);
         return waitResult;
     }
-    *buffer = buf;
+    *buffer = buf.get();
     return result;
 }
 
 int Surface::hook_cancelBuffer_DEPRECATED(ANativeWindow* window,
         ANativeWindowBuffer* buffer) {
     Surface* c = getSelf(window);
-    return c->cancelBuffer(buffer, -1);
+    return c->cancelBuffer(GraphicBuffer::from(buffer), -1);
 }
 
 int Surface::hook_lockBuffer_DEPRECATED(ANativeWindow* window,
         ANativeWindowBuffer* buffer) {
     Surface* c = getSelf(window);
-    return c->lockBuffer_DEPRECATED(buffer);
+    return c->lockBuffer_DEPRECATED(GraphicBuffer::from(buffer));
 }
 
 int Surface::hook_queueBuffer_DEPRECATED(ANativeWindow* window,
         ANativeWindowBuffer* buffer) {
     Surface* c = getSelf(window);
-    return c->queueBuffer(buffer, -1);
+    return c->queueBuffer(GraphicBuffer::from(buffer), -1);
 }
 
 int Surface::hook_perform(ANativeWindow* window, int operation, ...) {
@@ -619,9 +659,12 @@ void Surface::getDequeueBufferInputLocked(
     dequeueInput->getTimestamps = mEnableFrameTimestamps;
 }
 
-int Surface::dequeueBuffer(android_native_buffer_t** buffer, int* fenceFd) {
-    ATRACE_FORMAT("dequeueBuffer - %s", getDebugName());
-    ALOGV("Surface::dequeueBuffer");
+int Surface::dequeueBuffer(sp<GraphicBuffer>* buffer, int* fenceFd) {
+    {
+        std::scoped_lock _dl(mDebugMutex);
+        ATRACE_FORMAT("dequeueBuffer - %s", mDebugName.c_str());
+    }
+    SURF_LOGV("Surface::dequeueBuffer");
 
     IGraphicBufferProducer::DequeueBufferInput dqInput;
     {
@@ -636,7 +679,7 @@ int Surface::dequeueBuffer(android_native_buffer_t** buffer, int* fenceFd) {
                 BufferItem::INVALID_BUFFER_SLOT) {
             sp<GraphicBuffer>& gbuf(mSlots[mSharedBufferSlot].buffer);
             if (gbuf != nullptr) {
-                *buffer = gbuf.get();
+                *buffer = gbuf;
                 *fenceFd = -1;
                 return OK;
             }
@@ -656,9 +699,9 @@ int Surface::dequeueBuffer(android_native_buffer_t** buffer, int* fenceFd) {
     mLastDequeueDuration = systemTime() - startTime;
 
     if (result < 0) {
-        ALOGV("dequeueBuffer: IGraphicBufferProducer::dequeueBuffer"
-                "(%d, %d, %d, %#" PRIx64 ") failed: %d",
-                dqInput.width, dqInput.height, dqInput.format, dqInput.usage, result);
+        SURF_LOGV("dequeueBuffer: IGraphicBufferProducer::dequeueBuffer"
+                  "(%d, %d, %d, %#" PRIx64 ") failed: %d",
+                  dqInput.width, dqInput.height, dqInput.format, dqInput.usage, result);
         return result;
     }
 
@@ -667,7 +710,7 @@ int Surface::dequeueBuffer(android_native_buffer_t** buffer, int* fenceFd) {
 #else
     if (buf < 0 || buf >= NUM_BUFFER_SLOTS) {
 #endif
-        ALOGE("dequeueBuffer: IGraphicBufferProducer returned invalid slot number %d", buf);
+        SURF_LOGE("dequeueBuffer: IGraphicBufferProducer returned invalid slot number %d", buf);
         android_errorWriteLog(0x534e4554, "36991414"); // SafetyNet logging
         return FAILED_TRANSACTION;
     }
@@ -680,7 +723,7 @@ int Surface::dequeueBuffer(android_native_buffer_t** buffer, int* fenceFd) {
     sp<GraphicBuffer>& gbuf(mSlots[buf].buffer);
 
     // this should never happen
-    ALOGE_IF(fence == nullptr, "Surface::dequeueBuffer: received null Fence! buf=%d", buf);
+    SURF_LOGE_IF(fence == nullptr, "Surface::dequeueBuffer: received null Fence! buf=%d", buf);
 
     if (CC_UNLIKELY(atrace_is_tag_enabled(ATRACE_TAG_GRAPHICS))) {
         static gui::FenceMonitor hwcReleaseThread("HWC release");
@@ -701,7 +744,7 @@ int Surface::dequeueBuffer(android_native_buffer_t** buffer, int* fenceFd) {
         }
         result = mGraphicBufferProducer->requestBuffer(buf, &gbuf);
         if (result != NO_ERROR) {
-            ALOGE("dequeueBuffer: IGraphicBufferProducer::requestBuffer failed: %d", result);
+            SURF_LOGE("dequeueBuffer: IGraphicBufferProducer::requestBuffer failed: %d", result);
             mGraphicBufferProducer->cancelBuffer(buf, fence);
             return result;
         }
@@ -710,7 +753,7 @@ int Surface::dequeueBuffer(android_native_buffer_t** buffer, int* fenceFd) {
     if (fence->isValid()) {
         *fenceFd = fence->dup();
         if (*fenceFd == -1) {
-            ALOGE("dequeueBuffer: error duping fence: %d", errno);
+            SURF_LOGE("dequeueBuffer: error duping fence: %d", errno);
             // dup() should never fail; something is badly wrong. Soldier on
             // and hope for the best; the worst that should happen is some
             // visible corruption that lasts until the next frame.
@@ -719,7 +762,7 @@ int Surface::dequeueBuffer(android_native_buffer_t** buffer, int* fenceFd) {
         *fenceFd = -1;
     }
 
-    *buffer = gbuf.get();
+    *buffer = gbuf;
 
     if (mSharedBufferMode && mAutoRefresh) {
         mSharedBufferSlot = buf;
@@ -734,17 +777,20 @@ int Surface::dequeueBuffer(android_native_buffer_t** buffer, int* fenceFd) {
     return OK;
 }
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
-
 status_t Surface::dequeueBuffer(sp<GraphicBuffer>* buffer, sp<Fence>* outFence) {
     if (buffer == nullptr || outFence == nullptr) {
         return BAD_VALUE;
     }
 
-    android_native_buffer_t* anb;
+    sp<GraphicBuffer> tmpBuffer;
     int fd = -1;
-    status_t res = dequeueBuffer(&anb, &fd);
-    *buffer = GraphicBuffer::from(anb);
+    status_t res = dequeueBuffer(&tmpBuffer, &fd);
+    if (res != NO_ERROR) {
+        SURF_LOGV("dequeueBuffer() returned %d", res);
+        return res;
+    }
+
+    *buffer = tmpBuffer;
     *outFence = sp<Fence>::make(fd);
     return res;
 }
@@ -781,8 +827,6 @@ status_t Surface::detachBuffer(const sp<GraphicBuffer>& buffer) {
     return BAD_VALUE;
 }
 
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
-
 int Surface::dequeueBuffers(std::vector<BatchBuffer>* buffers) {
     using DequeueBufferInput = IGraphicBufferProducer::DequeueBufferInput;
     using DequeueBufferOutput = IGraphicBufferProducer::DequeueBufferOutput;
@@ -790,16 +834,15 @@ int Surface::dequeueBuffers(std::vector<BatchBuffer>* buffers) {
     using RequestBufferOutput = IGraphicBufferProducer::RequestBufferOutput;
 
     ATRACE_CALL();
-    ALOGV("Surface::dequeueBuffers");
+    SURF_LOGV("Surface::dequeueBuffers");
 
     if (buffers->size() == 0) {
-        ALOGE("%s: must dequeue at least 1 buffer!", __FUNCTION__);
+        SURF_LOGE("%s: must dequeue at least 1 buffer!", __FUNCTION__);
         return BAD_VALUE;
     }
 
     if (mSharedBufferMode) {
-        ALOGE("%s: batch operation is not supported in shared buffer mode!",
-                __FUNCTION__);
+        SURF_LOGE("%s: batch operation is not supported in shared buffer mode!", __FUNCTION__);
         return INVALID_OPERATION;
     }
 
@@ -825,9 +868,9 @@ int Surface::dequeueBuffers(std::vector<BatchBuffer>* buffers) {
     mLastDequeueDuration = systemTime() - startTime;
 
     if (result < 0) {
-        ALOGV("%s: IGraphicBufferProducer::dequeueBuffers"
-                "(%d, %d, %d, %#" PRIx64 ") failed: %d",
-                __FUNCTION__, input.width, input.height, input.format, input.usage, result);
+        SURF_LOGV("%s: IGraphicBufferProducer::dequeueBuffers"
+                  "(%d, %d, %d, %#" PRIx64 ") failed: %d",
+                  __FUNCTION__, input.width, input.height, input.format, input.usage, result);
         return result;
     }
 
@@ -845,10 +888,10 @@ int Surface::dequeueBuffers(std::vector<BatchBuffer>* buffers) {
     for (const auto& output : dequeueOutput) {
         if (output.result < 0) {
             mGraphicBufferProducer->cancelBuffers(cancelBufferInputs, &cancelBufferOutputs);
-            ALOGV("%s: IGraphicBufferProducer::dequeueBuffers"
-                    "(%d, %d, %d, %#" PRIx64 ") failed: %d",
-                    __FUNCTION__, input.width, input.height, input.format, input.usage,
-                    output.result);
+            SURF_LOGV("%s: IGraphicBufferProducer::dequeueBuffers"
+                      "(%d, %d, %d, %#" PRIx64 ") failed: %d",
+                      __FUNCTION__, input.width, input.height, input.format, input.usage,
+                      output.result);
             return output.result;
         }
 
@@ -858,21 +901,21 @@ int Surface::dequeueBuffers(std::vector<BatchBuffer>* buffers) {
         if (output.slot < 0 || output.slot >= NUM_BUFFER_SLOTS) {
 #endif
             mGraphicBufferProducer->cancelBuffers(cancelBufferInputs, &cancelBufferOutputs);
-            ALOGE("%s: IGraphicBufferProducer returned invalid slot number %d",
-                    __FUNCTION__, output.slot);
+            SURF_LOGE("%s: IGraphicBufferProducer returned invalid slot number %d", __FUNCTION__,
+                      output.slot);
             android_errorWriteLog(0x534e4554, "36991414"); // SafetyNet logging
             return FAILED_TRANSACTION;
         }
 
         if (input.getTimestamps && !output.timestamps.has_value()) {
             mGraphicBufferProducer->cancelBuffers(cancelBufferInputs, &cancelBufferOutputs);
-            ALOGE("%s: no frame timestamp returns!", __FUNCTION__);
+            SURF_LOGE("%s: no frame timestamp returns!", __FUNCTION__);
             return FAILED_TRANSACTION;
         }
 
         // this should never happen
-        ALOGE_IF(output.fence == nullptr,
-                "%s: received null Fence! slot=%d", __FUNCTION__, output.slot);
+        SURF_LOGE_IF(output.fence == nullptr, "%s: received null Fence! slot=%d", __FUNCTION__,
+                     output.slot);
     }
 
     Mutex::Autolock lock(mMutex);
@@ -885,7 +928,7 @@ int Surface::dequeueBuffers(std::vector<BatchBuffer>* buffers) {
     // handle release all buffers and request buffers
     for (const auto& output : dequeueOutput) {
         if (output.result & IGraphicBufferProducer::RELEASE_ALL_BUFFERS) {
-            ALOGV("%s: RELEASE_ALL_BUFFERS during batch operation", __FUNCTION__);
+            SURF_LOGV("%s: RELEASE_ALL_BUFFERS during batch operation", __FUNCTION__);
             freeAllBuffers();
             break;
         }
@@ -907,8 +950,8 @@ int Surface::dequeueBuffers(std::vector<BatchBuffer>* buffers) {
     if (requestBufferSlots.size() > 0) {
         result = mGraphicBufferProducer->requestBuffers(requestBufferSlots, &reqBufferOutput);
         if (result != NO_ERROR) {
-            ALOGE("%s: IGraphicBufferProducer::requestBuffers failed: %d",
-                    __FUNCTION__, result);
+            SURF_LOGE("%s: IGraphicBufferProducer::requestBuffers failed: %d", __FUNCTION__,
+                      result);
             mGraphicBufferProducer->cancelBuffers(cancelBufferInputs, &cancelBufferOutputs);
             return result;
         }
@@ -916,8 +959,9 @@ int Surface::dequeueBuffers(std::vector<BatchBuffer>* buffers) {
         // Check if we have any single failure
         for (size_t i = 0; i < requestBufferSlots.size(); i++) {
             if (reqBufferOutput[i].result != OK) {
-                ALOGE("%s: IGraphicBufferProducer::requestBuffers failed at %zu-th buffer, slot %d",
-                        __FUNCTION__, i, requestBufferSlots[i]);
+                SURF_LOGE("%s: IGraphicBufferProducer::requestBuffers failed at %zu-th buffer, "
+                          "slot %d",
+                          __FUNCTION__, i, requestBufferSlots[i]);
                 mGraphicBufferProducer->cancelBuffers(cancelBufferInputs, &cancelBufferOutputs);
                 return reqBufferOutput[i].result;
             }
@@ -946,7 +990,7 @@ int Surface::dequeueBuffers(std::vector<BatchBuffer>* buffers) {
         if (output.fence->isValid()) {
             buffers->at(batchIdx).fenceFd = output.fence->dup();
             if (buffers->at(batchIdx).fenceFd == -1) {
-                ALOGE("%s: error duping fence: %d", __FUNCTION__, errno);
+                SURF_LOGE("%s: error duping fence: %d", __FUNCTION__, errno);
                 // dup() should never fail; something is badly wrong. Soldier on
                 // and hope for the best; the worst that should happen is some
                 // visible corruption that lasts until the next frame.
@@ -961,10 +1005,9 @@ int Surface::dequeueBuffers(std::vector<BatchBuffer>* buffers) {
     return OK;
 }
 
-int Surface::cancelBuffer(android_native_buffer_t* buffer,
-        int fenceFd) {
+int Surface::cancelBuffer(sp<GraphicBuffer>&& buffer, int fenceFd) {
     ATRACE_CALL();
-    ALOGV("Surface::cancelBuffer");
+    SURF_LOGV("Surface::cancelBuffer");
     Mutex::Autolock lock(mMutex);
     int i = getSlotFromBufferLocked(buffer);
     if (i < 0) {
@@ -994,11 +1037,10 @@ int Surface::cancelBuffer(android_native_buffer_t* buffer,
 int Surface::cancelBuffers(const std::vector<BatchBuffer>& buffers) {
     using CancelBufferInput = IGraphicBufferProducer::CancelBufferInput;
     ATRACE_CALL();
-    ALOGV("Surface::cancelBuffers");
+    SURF_LOGV("Surface::cancelBuffers");
 
     if (mSharedBufferMode) {
-        ALOGE("%s: batch operation is not supported in shared buffer mode!",
-                __FUNCTION__);
+        SURF_LOGE("%s: batch operation is not supported in shared buffer mode!", __FUNCTION__);
         return INVALID_OPERATION;
     }
 
@@ -1008,13 +1050,14 @@ int Surface::cancelBuffers(const std::vector<BatchBuffer>& buffers) {
     size_t numBuffersCancelled = 0;
     int badSlotResult = 0;
     for (size_t i = 0; i < numBuffers; i++) {
-        int slot = getSlotFromBufferLocked(buffers[i].buffer);
+        sp<GraphicBuffer> buffer = GraphicBuffer::from(buffers[i].buffer);
+        int slot = getSlotFromBufferLocked(buffer);
         int fenceFd = buffers[i].fenceFd;
         if (slot < 0) {
             if (fenceFd >= 0) {
                 close(fenceFd);
             }
-            ALOGE("%s: cannot find slot number for cancelled buffer", __FUNCTION__);
+            SURF_LOGE("%s: cannot find slot number for cancelled buffer", __FUNCTION__);
             badSlotResult = slot;
         } else {
             sp<Fence> fence(fenceFd >= 0 ? sp<Fence>::make(fenceFd) : Fence::NO_FENCE);
@@ -1036,42 +1079,55 @@ int Surface::cancelBuffers(const std::vector<BatchBuffer>& buffers) {
     return OK;
 }
 
-int Surface::getSlotFromBufferLocked(
-        android_native_buffer_t* buffer) const {
+int Surface::getSlotFromBufferLocked(const sp<GraphicBuffer>& buffer) const {
     if (buffer == nullptr) {
-        ALOGE("%s: input buffer is null!", __FUNCTION__);
+        SURF_LOGE("%s: input buffer is null!", __FUNCTION__);
         return BAD_VALUE;
     }
 
+    FatVector<int> slots; // FatVector (default size 4) to prevent heap allocations most of the time
 #if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_UNLIMITED_SLOTS)
     for (int i = 0; i < (int)mSlots.size(); i++) {
 #else
     for (int i = 0; i < NUM_BUFFER_SLOTS; i++) {
 #endif
-        if (mSlots[i].buffer != nullptr &&
-                mSlots[i].buffer->handle == buffer->handle) {
-            return i;
+        const sp<GraphicBuffer>& slotBuffer = mSlots[i].buffer;
+        if (slotBuffer != nullptr &&
+            ((slotBuffer == buffer) || (slotBuffer->handle == buffer->handle) ||
+             (slotBuffer->getId() == buffer->getId()))) {
+            slots.push_back(i);
         }
     }
-    ALOGE("%s: unknown buffer: %p", __FUNCTION__, buffer->handle);
+
+    if (slots.size() >= 1) {
+        SURF_LOGE_IF(slots.size() != 1,
+                     "%s: More than one slot found for buffer handle=%p id=%" PRIu64 " slots=[%s]",
+                     __FUNCTION__, buffer->handle, buffer->getId(),
+                     base::Join(slots, ", ").c_str());
+
+        return slots[0];
+    }
+
+    SURF_LOGE("%s: unknown buffer: handle=%p id=%" PRIu64, __FUNCTION__, buffer->handle,
+              buffer->getId());
     return BAD_VALUE;
 }
 
-int Surface::lockBuffer_DEPRECATED(android_native_buffer_t* buffer __attribute__((unused))) {
-    ALOGV("Surface::lockBuffer");
+int Surface::lockBuffer_DEPRECATED(const sp<GraphicBuffer>& buffer __attribute__((unused))) {
+    SURF_LOGV("Surface::lockBuffer");
     Mutex::Autolock lock(mMutex);
     return OK;
 }
 
-void Surface::getQueueBufferInputLocked(android_native_buffer_t* buffer, int fenceFd,
-        nsecs_t timestamp, IGraphicBufferProducer::QueueBufferInput* out) {
+void Surface::getQueueBufferInputLocked(const sp<GraphicBuffer>& buffer, int fenceFd,
+                                        nsecs_t timestamp,
+                                        IGraphicBufferProducer::QueueBufferInput* out) {
     bool isAutoTimestamp = false;
 
     if (timestamp == NATIVE_WINDOW_TIMESTAMP_AUTO) {
         timestamp = systemTime(SYSTEM_TIME_MONOTONIC);
         isAutoTimestamp = true;
-        ALOGV("Surface::queueBuffer making up timestamp: %.2f ms",
-            timestamp / 1000000.0);
+        SURF_LOGV("Surface::queueBuffer making up timestamp: %.2f ms", timestamp / 1000000.0);
     }
 
     // Make sure the crop rectangle is entirely inside the buffer.
@@ -1153,7 +1209,7 @@ void Surface::getQueueBufferInputLocked(android_native_buffer_t* buffer, int fen
 }
 
 void Surface::applyGrallocMetadataLocked(
-        android_native_buffer_t* buffer,
+        const sp<GraphicBuffer>& buffer,
         const IGraphicBufferProducer::QueueBufferInput& queueBufferInput) {
     ATRACE_CALL();
     auto& mapper = GraphicBufferMapper::get();
@@ -1214,12 +1270,10 @@ void Surface::onBufferQueuedLocked(int slot, sp<Fence> fence,
     }
 }
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
-
-int Surface::queueBuffer(android_native_buffer_t* buffer, int fenceFd,
+int Surface::queueBuffer(sp<GraphicBuffer>&& buffer, int fenceFd,
                          SurfaceQueueBufferOutput* surfaceOutput) {
     ATRACE_CALL();
-    ALOGV("Surface::queueBuffer");
+    SURF_LOGV("Surface::queueBuffer");
 
     IGraphicBufferProducer::QueueBufferOutput output;
     IGraphicBufferProducer::QueueBufferInput input;
@@ -1253,7 +1307,7 @@ int Surface::queueBuffer(android_native_buffer_t* buffer, int fenceFd,
     //    Surface::queueBuffer
     // -> IConsumerListener::onFrameAvailable callback triggers automatically
     // ->   implementation calls IGraphicBufferConsumer::acquire/release immediately
-    // -> SurfaceListener::onBufferRelesed callback triggers automatically
+    // -> SurfaceListener::onBufferReleased callback triggers automatically
     // ->   implementation calls Surface::dequeueBuffer
     status_t err = mGraphicBufferProducer->queueBuffer(slot, input, &output);
     {
@@ -1261,7 +1315,7 @@ int Surface::queueBuffer(android_native_buffer_t* buffer, int fenceFd,
 
         mLastQueueDuration = systemTime() - now;
         if (err != OK) {
-            ALOGE("queueBuffer: error queuing buffer, %d", err);
+            SURF_LOGE("queueBuffer: error queuing buffer, %d", err);
         }
 
         onBufferQueuedLocked(slot, fence, output);
@@ -1274,15 +1328,10 @@ int Surface::queueBuffer(android_native_buffer_t* buffer, int fenceFd,
     return err;
 }
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
 int Surface::queueBuffers(const std::vector<BatchQueuedBuffer>& buffers,
-                          std::vector<SurfaceQueueBufferOutput>* queueBufferOutputs)
-#else
-int Surface::queueBuffers(const std::vector<BatchQueuedBuffer>& buffers)
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
-{
+                          std::vector<SurfaceQueueBufferOutput>* queueBufferOutputs) {
     ATRACE_CALL();
-    ALOGV("Surface::queueBuffers");
+    SURF_LOGV("Surface::queueBuffers");
 
     size_t numBuffers = buffers.size();
     std::vector<IGraphicBufferProducer::QueueBufferInput> igbpQueueBufferInputs(numBuffers);
@@ -1295,12 +1344,13 @@ int Surface::queueBuffers(const std::vector<BatchQueuedBuffer>& buffers)
         Mutex::Autolock lock(mMutex);
 
         if (mSharedBufferMode) {
-            ALOGE("%s: batched operation is not supported in shared buffer mode", __FUNCTION__);
+            SURF_LOGE("%s: batched operation is not supported in shared buffer mode", __FUNCTION__);
             return INVALID_OPERATION;
         }
 
         for (size_t batchIdx = 0; batchIdx < numBuffers; batchIdx++) {
-            int i = getSlotFromBufferLocked(buffers[batchIdx].buffer);
+            sp<GraphicBuffer> buffer = GraphicBuffer::from(buffers[batchIdx].buffer);
+            int i = getSlotFromBufferLocked(buffer);
             if (i < 0) {
                 if (buffers[batchIdx].fenceFd >= 0) {
                     close(buffers[batchIdx].fenceFd);
@@ -1310,7 +1360,7 @@ int Surface::queueBuffers(const std::vector<BatchQueuedBuffer>& buffers)
             bufferSlots[batchIdx] = i;
 
             IGraphicBufferProducer::QueueBufferInput input;
-            getQueueBufferInputLocked(buffers[batchIdx].buffer, buffers[batchIdx].fenceFd,
+            getQueueBufferInputLocked(buffer, buffers[batchIdx].fenceFd,
                                       buffers[batchIdx].timestamp, &input);
             input.slot = i;
             bufferFences[batchIdx] = input.fence;
@@ -1323,7 +1373,7 @@ int Surface::queueBuffers(const std::vector<BatchQueuedBuffer>& buffers)
         Mutex::Autolock lock(mMutex);
         mLastQueueDuration = systemTime() - now;
         if (err != OK) {
-            ALOGE("%s: error queuing buffer, %d", __FUNCTION__, err);
+            SURF_LOGE("%s: error queuing buffer, %d", __FUNCTION__, err);
         }
 
         for (size_t batchIdx = 0; batchIdx < numBuffers; batchIdx++) {
@@ -1332,7 +1382,6 @@ int Surface::queueBuffers(const std::vector<BatchQueuedBuffer>& buffers)
         }
     }
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
     if (queueBufferOutputs != nullptr) {
         queueBufferOutputs->clear();
         queueBufferOutputs->resize(numBuffers);
@@ -1341,103 +1390,14 @@ int Surface::queueBuffers(const std::vector<BatchQueuedBuffer>& buffers)
                     igbpQueueBufferOutputs[batchIdx].bufferReplaced;
         }
     }
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
 
     return err;
 }
 
-#else
-
-int Surface::queueBuffer(android_native_buffer_t* buffer, int fenceFd) {
-    ATRACE_CALL();
-    ALOGV("Surface::queueBuffer");
-    Mutex::Autolock lock(mMutex);
-
-    int i = getSlotFromBufferLocked(buffer);
-    if (i < 0) {
-        if (fenceFd >= 0) {
-            close(fenceFd);
-        }
-        return i;
-    }
-    if (mSharedBufferSlot == i && mSharedBufferHasBeenQueued) {
-        if (fenceFd >= 0) {
-            close(fenceFd);
-        }
-        return OK;
-    }
-
-    IGraphicBufferProducer::QueueBufferOutput output;
-    IGraphicBufferProducer::QueueBufferInput input;
-    getQueueBufferInputLocked(buffer, fenceFd, mTimestamp, &input);
-    applyGrallocMetadataLocked(buffer, input);
-    sp<Fence> fence = input.fence;
-
-    nsecs_t now = systemTime();
-
-    status_t err = mGraphicBufferProducer->queueBuffer(i, input, &output);
-    mLastQueueDuration = systemTime() - now;
-    if (err != OK)  {
-        ALOGE("queueBuffer: error queuing buffer, %d", err);
-    }
-
-    onBufferQueuedLocked(i, fence, output);
-    return err;
-}
-
-int Surface::queueBuffers(const std::vector<BatchQueuedBuffer>& buffers) {
-    ATRACE_CALL();
-    ALOGV("Surface::queueBuffers");
-    Mutex::Autolock lock(mMutex);
-
-    if (mSharedBufferMode) {
-        ALOGE("%s: batched operation is not supported in shared buffer mode", __FUNCTION__);
-        return INVALID_OPERATION;
-    }
-
-    size_t numBuffers = buffers.size();
-    std::vector<IGraphicBufferProducer::QueueBufferInput> queueBufferInputs(numBuffers);
-    std::vector<IGraphicBufferProducer::QueueBufferOutput> queueBufferOutputs;
-    std::vector<int> bufferSlots(numBuffers, -1);
-    std::vector<sp<Fence>> bufferFences(numBuffers);
-
-    for (size_t batchIdx = 0; batchIdx < numBuffers; batchIdx++) {
-        int i = getSlotFromBufferLocked(buffers[batchIdx].buffer);
-        if (i < 0) {
-            if (buffers[batchIdx].fenceFd >= 0) {
-                close(buffers[batchIdx].fenceFd);
-            }
-            return i;
-        }
-        bufferSlots[batchIdx] = i;
-
-        IGraphicBufferProducer::QueueBufferInput input;
-        getQueueBufferInputLocked(
-                buffers[batchIdx].buffer, buffers[batchIdx].fenceFd, buffers[batchIdx].timestamp,
-                &input);
-        bufferFences[batchIdx] = input.fence;
-        queueBufferInputs[batchIdx] = input;
-    }
-
-    nsecs_t now = systemTime();
-    status_t err = mGraphicBufferProducer->queueBuffers(queueBufferInputs, &queueBufferOutputs);
-    mLastQueueDuration = systemTime() - now;
-    if (err != OK)  {
-        ALOGE("%s: error queuing buffer, %d", __FUNCTION__, err);
-    }
-
-
-    for (size_t batchIdx = 0; batchIdx < numBuffers; batchIdx++) {
-        onBufferQueuedLocked(bufferSlots[batchIdx], bufferFences[batchIdx],
-                queueBufferOutputs[batchIdx]);
-    }
-
-    return err;
-}
-
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
-
 void Surface::querySupportedTimestampsLocked() const {
+#ifdef NO_BINDER
+    LOG_ALWAYS_FATAL("Surface::querySupportedTimestampsLocked not supported in NO_BINDER mode");
+#else
     // mMutex must be locked when calling this method.
 
     if (mQueriedSupportedTimestamps) {
@@ -1458,11 +1418,12 @@ void Surface::querySupportedTimestampsLocked() const {
             mFrameTimestampsSupportsPresent = true;
         }
     }
+#endif
 }
 
 int Surface::query(int what, int* value) const {
     ATRACE_CALL();
-    ALOGV("Surface::query");
+    SURF_LOGV("Surface::query");
     { // scope for the lock
         Mutex::Autolock lock(mMutex);
         switch (what) {
@@ -1477,6 +1438,9 @@ int Surface::query(int what, int* value) const {
                 if (err == NO_ERROR) {
                     return NO_ERROR;
                 }
+#ifdef NO_BINDER
+                return -EPERM;
+#else
                 sp<gui::ISurfaceComposer> surfaceComposer = composerServiceAIDL();
                 if (surfaceComposer == nullptr) {
                     return -EPERM; // likely permissions error
@@ -1484,6 +1448,7 @@ int Surface::query(int what, int* value) const {
                 // ISurfaceComposer no longer supports authenticateSurfaceTexture
                 *value = 0;
                 return NO_ERROR;
+#endif
             }
             case NATIVE_WINDOW_CONCRETE_TYPE:
                 *value = NATIVE_WINDOW_SURFACE;
@@ -2051,8 +2016,12 @@ int Surface::dispatchGetLastQueuedBuffer2(va_list args) {
 }
 
 int Surface::dispatchSetFrameTimelineInfo(va_list args) {
+#ifdef NO_BINDER
+    (void)args;
+    LOG_ALWAYS_FATAL("Surface::dispatchSetFrameTimelineInfo not supported in NO_BINDER mode");
+#else
     ATRACE_CALL();
-    ALOGV("Surface::%s", __func__);
+    SURF_LOGV("Surface::%s", __func__);
 
     const auto nativeWindowFtlInfo = static_cast<ANativeWindowFrameTimelineInfo>(
             va_arg(args, ANativeWindowFrameTimelineInfo));
@@ -2066,6 +2035,7 @@ int Surface::dispatchSetFrameTimelineInfo(va_list args) {
     ftlInfo.skippedFrameStartTimeNanos = nativeWindowFtlInfo.skippedFrameStartTimeNanos;
 
     return setFrameTimelineInfo(nativeWindowFtlInfo.frameNumber, ftlInfo);
+#endif
 }
 
 int Surface::dispatchSetAdditionalOptions(va_list args) {
@@ -2098,7 +2068,7 @@ int Surface::connect(int api) {
 
 int Surface::connect(int api, const sp<SurfaceListener>& listener, bool reportBufferRemoval) {
     ATRACE_CALL();
-    ALOGV("Surface::connect");
+    SURF_LOGV("Surface::connect");
     Mutex::Autolock lock(mMutex);
     IGraphicBufferProducer::QueueBufferOutput output;
     mReportRemovedBuffers = reportBufferRemoval;
@@ -2127,12 +2097,20 @@ int Surface::connect(int api, const sp<SurfaceListener>& listener, bool reportBu
 
         mConsumerRunningBehind = (output.numPendingBuffers >= 2);
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
+#if !defined(NO_BINDER)
         if (listener && listener->needsDeathNotify()) {
             mSurfaceDeathListener = sp<ProducerDeathListenerProxy>::make(listener);
             IInterface::asBinder(mGraphicBufferProducer)->linkToDeath(mSurfaceDeathListener);
         }
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
+#endif // !defined(NO_BINDER)
+
+        status_t idErr = NO_ERROR;
+        {
+            std::scoped_lock _dl(mDebugMutex);
+            mDebugName = mGraphicBufferProducer->getConsumerName();
+            mGraphicBufferProducer->getUniqueId(&mId);
+        }
+        SURF_LOGE_IF(idErr != NO_ERROR, "Unable to get ID from IGBP: %d", idErr);
     }
     if (!err && api == NATIVE_WINDOW_API_CPU) {
         mConnectedToCpu = true;
@@ -2148,7 +2126,7 @@ int Surface::connect(int api, const sp<SurfaceListener>& listener, bool reportBu
 
 int Surface::disconnect(int api, IGraphicBufferProducer::DisconnectMode mode) {
     ATRACE_CALL();
-    ALOGV("Surface::disconnect");
+    SURF_LOGV("Surface::disconnect");
     Mutex::Autolock lock(mMutex);
     mRemovedBuffers.clear();
     mSharedBufferSlot = BufferItem::INVALID_BUFFER_SLOT;
@@ -2172,14 +2150,19 @@ int Surface::disconnect(int api, IGraphicBufferProducer::DisconnectMode mode) {
         if (api == NATIVE_WINDOW_API_CPU) {
             mConnectedToCpu = false;
         }
+
+        std::scoped_lock _dl(mDebugMutex);
+        // Keep the old name in case we get subsequent calls, for logging.
+        mDebugName = mDebugName + "-DISCONNECTED";
+        mId = 0;
     }
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
+#if !defined(NO_BINDER)
     if (mSurfaceDeathListener != nullptr) {
         IInterface::asBinder(mGraphicBufferProducer)->unlinkToDeath(mSurfaceDeathListener);
         mSurfaceDeathListener = nullptr;
     }
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
+#endif // !defined(NO_BINDER)
 
     return err;
 }
@@ -2187,7 +2170,7 @@ int Surface::disconnect(int api, IGraphicBufferProducer::DisconnectMode mode) {
 int Surface::detachNextBuffer(sp<GraphicBuffer>* outBuffer,
         sp<Fence>* outFence) {
     ATRACE_CALL();
-    ALOGV("Surface::detachNextBuffer");
+    SURF_LOGV("Surface::detachNextBuffer");
 
     if (outBuffer == nullptr || outFence == nullptr) {
         return BAD_VALUE;
@@ -2234,23 +2217,24 @@ int Surface::isBufferOwned(const sp<GraphicBuffer>& buffer, bool* outIsOwned) co
     ATRACE_CALL();
 
     if (buffer == nullptr) {
-        ALOGE("%s: Bad input, buffer was null", __FUNCTION__);
+        SURF_LOGE("%s: Bad input, buffer was null", __FUNCTION__);
         return BAD_VALUE;
     }
     if (outIsOwned == nullptr) {
-        ALOGE("%s: Bad input, output was null", __FUNCTION__);
+        SURF_LOGE("%s: Bad input, output was null", __FUNCTION__);
         return BAD_VALUE;
     }
 
     Mutex::Autolock lock(mMutex);
 
-    int slot = this->getSlotFromBufferLocked(buffer->getNativeBuffer());
+    int slot = this->getSlotFromBufferLocked(buffer);
     if (slot == BAD_VALUE) {
-        ALOGV("%s: Buffer %" PRIu64 " is not owned", __FUNCTION__, buffer->getId());
+        SURF_LOGV("%s: Buffer %" PRIu64 " is not owned", __FUNCTION__, buffer->getId());
         *outIsOwned = false;
         return NO_ERROR;
     } else if (slot < 0) {
-        ALOGV("%s: Buffer %" PRIu64 " look up failed (%d)", __FUNCTION__, buffer->getId(), slot);
+        SURF_LOGV("%s: Buffer %" PRIu64 " look up failed (%d)", __FUNCTION__, buffer->getId(),
+                  slot);
         *outIsOwned = false;
         return slot;
     }
@@ -2264,7 +2248,7 @@ int Surface::attachBuffer(ANativeWindowBuffer* buffer)
     ATRACE_CALL();
     sp<GraphicBuffer> graphicBuffer(static_cast<GraphicBuffer*>(buffer));
 
-    ALOGV("Surface::attachBuffer bufferId=%" PRIu64, graphicBuffer->getId());
+    SURF_LOGV("Surface::attachBuffer bufferId=%" PRIu64, graphicBuffer->getId());
 
     Mutex::Autolock lock(mMutex);
     if (mReportRemovedBuffers) {
@@ -2276,7 +2260,7 @@ int Surface::attachBuffer(ANativeWindowBuffer* buffer)
     int32_t attachedSlot = -1;
     status_t result = mGraphicBufferProducer->attachBuffer(&attachedSlot, graphicBuffer);
     if (result != NO_ERROR) {
-        ALOGE("attachBuffer: IGraphicBufferProducer call failed (%d)", result);
+        SURF_LOGE("attachBuffer: IGraphicBufferProducer call failed (%d)", result);
         graphicBuffer->mGenerationNumber = priorGeneration;
         return result;
     }
@@ -2291,7 +2275,7 @@ int Surface::attachBuffer(ANativeWindowBuffer* buffer)
 
 int Surface::setUsage(uint64_t reqUsage)
 {
-    ALOGV("Surface::setUsage");
+    SURF_LOGV("Surface::setUsage");
     Mutex::Autolock lock(mMutex);
     if (reqUsage != mReqUsage) {
         mSharedBufferSlot = BufferItem::INVALID_BUFFER_SLOT;
@@ -2311,8 +2295,8 @@ int Surface::setCrop(Rect const* rect)
         realRect = *rect;
     }
 
-    ALOGV("Surface::setCrop rect=[%d %d %d %d]",
-            realRect.left, realRect.top, realRect.right, realRect.bottom);
+    SURF_LOGV("Surface::setCrop rect=[%d %d %d %d]", realRect.left, realRect.top, realRect.right,
+              realRect.bottom);
 
     Mutex::Autolock lock(mMutex);
     mCrop = realRect;
@@ -2322,7 +2306,7 @@ int Surface::setCrop(Rect const* rect)
 int Surface::setBufferCount(int bufferCount)
 {
     ATRACE_CALL();
-    ALOGV("Surface::setBufferCount");
+    SURF_LOGV("Surface::setBufferCount");
     Mutex::Autolock lock(mMutex);
 
     status_t err = NO_ERROR;
@@ -2338,15 +2322,15 @@ int Surface::setBufferCount(int bufferCount)
         }
     }
 
-    ALOGE_IF(err, "IGraphicBufferProducer::setBufferCount(%d) returned %s",
-             bufferCount, strerror(-err));
+    SURF_LOGE_IF(err, "IGraphicBufferProducer::setBufferCount(%d) returned %s", bufferCount,
+                 strerror(-err));
 
     return err;
 }
 
 int Surface::setMaxDequeuedBufferCount(int maxDequeuedBuffers) {
     ATRACE_CALL();
-    ALOGV("Surface::setMaxDequeuedBufferCount");
+    SURF_LOGV("Surface::setMaxDequeuedBufferCount");
     Mutex::Autolock lock(mMutex);
 
 #if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_UNLIMITED_SLOTS)
@@ -2358,8 +2342,8 @@ int Surface::setMaxDequeuedBufferCount(int maxDequeuedBuffers) {
     status_t err = mGraphicBufferProducer->query(NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS,
                                                  &minUndequeuedBuffers);
     if (err != OK) {
-        ALOGE("IGraphicBufferProducer::query(NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS) returned %s",
-              strerror(-err));
+        SURF_LOGE("IGraphicBufferProducer::query(NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS) returned %s",
+                  strerror(-err));
         return err;
     }
 
@@ -2367,8 +2351,8 @@ int Surface::setMaxDequeuedBufferCount(int maxDequeuedBuffers) {
         int newSlotCount = minUndequeuedBuffers + maxDequeuedBuffers;
         err = mGraphicBufferProducer->extendSlotCount(newSlotCount);
         if (err != OK) {
-            ALOGE("IGraphicBufferProducer::extendSlotCount(%d) returned %s", newSlotCount,
-                  strerror(-err));
+            SURF_LOGE("IGraphicBufferProducer::extendSlotCount(%d) returned %s", newSlotCount,
+                      strerror(-err));
             return err;
         }
 
@@ -2378,27 +2362,29 @@ int Surface::setMaxDequeuedBufferCount(int maxDequeuedBuffers) {
 #else
     status_t err = mGraphicBufferProducer->setMaxDequeuedBufferCount(maxDequeuedBuffers);
 #endif
-    ALOGE_IF(err, "IGraphicBufferProducer::setMaxDequeuedBufferCount(%d) "
-            "returned %s", maxDequeuedBuffers, strerror(-err));
+    SURF_LOGE_IF(err,
+                 "IGraphicBufferProducer::setMaxDequeuedBufferCount(%d) "
+                 "returned %s",
+                 maxDequeuedBuffers, strerror(-err));
 
     return err;
 }
 
 int Surface::setAsyncMode(bool async) {
     ATRACE_CALL();
-    ALOGV("Surface::setAsyncMode");
+    SURF_LOGV("Surface::setAsyncMode");
     Mutex::Autolock lock(mMutex);
 
     status_t err = mGraphicBufferProducer->setAsyncMode(async);
-    ALOGE_IF(err, "IGraphicBufferProducer::setAsyncMode(%d) returned %s",
-            async, strerror(-err));
+    SURF_LOGE_IF(err, "IGraphicBufferProducer::setAsyncMode(%d) returned %s", async,
+                 strerror(-err));
 
     return err;
 }
 
 int Surface::setSharedBufferMode(bool sharedBufferMode) {
     ATRACE_CALL();
-    ALOGV("Surface::setSharedBufferMode (%d)", sharedBufferMode);
+    SURF_LOGV("Surface::setSharedBufferMode (%d)", sharedBufferMode);
     Mutex::Autolock lock(mMutex);
 
     status_t err = mGraphicBufferProducer->setSharedBufferMode(
@@ -2406,30 +2392,32 @@ int Surface::setSharedBufferMode(bool sharedBufferMode) {
     if (err == NO_ERROR) {
         mSharedBufferMode = sharedBufferMode;
     }
-    ALOGE_IF(err, "IGraphicBufferProducer::setSharedBufferMode(%d) returned"
-            "%s", sharedBufferMode, strerror(-err));
+    SURF_LOGE_IF(err,
+                 "IGraphicBufferProducer::setSharedBufferMode(%d) returned"
+                 "%s",
+                 sharedBufferMode, strerror(-err));
 
     return err;
 }
 
 int Surface::setAutoRefresh(bool autoRefresh) {
     ATRACE_CALL();
-    ALOGV("Surface::setAutoRefresh (%d)", autoRefresh);
+    SURF_LOGV("Surface::setAutoRefresh (%d)", autoRefresh);
     Mutex::Autolock lock(mMutex);
 
     status_t err = mGraphicBufferProducer->setAutoRefresh(autoRefresh);
     if (err == NO_ERROR) {
         mAutoRefresh = autoRefresh;
     }
-    ALOGE_IF(err, "IGraphicBufferProducer::setAutoRefresh(%d) returned %s",
-            autoRefresh, strerror(-err));
+    SURF_LOGE_IF(err, "IGraphicBufferProducer::setAutoRefresh(%d) returned %s", autoRefresh,
+                 strerror(-err));
     return err;
 }
 
 int Surface::setBuffersDimensions(uint32_t width, uint32_t height)
 {
     ATRACE_CALL();
-    ALOGV("Surface::setBuffersDimensions");
+    SURF_LOGV("Surface::setBuffersDimensions");
 
     if ((width && !height) || (!width && height))
         return BAD_VALUE;
@@ -2446,7 +2434,7 @@ int Surface::setBuffersDimensions(uint32_t width, uint32_t height)
 int Surface::setBuffersUserDimensions(uint32_t width, uint32_t height)
 {
     ATRACE_CALL();
-    ALOGV("Surface::setBuffersUserDimensions");
+    SURF_LOGV("Surface::setBuffersUserDimensions");
 
     if ((width && !height) || (!width && height))
         return BAD_VALUE;
@@ -2462,7 +2450,7 @@ int Surface::setBuffersUserDimensions(uint32_t width, uint32_t height)
 
 int Surface::setBuffersFormat(PixelFormat format)
 {
-    ALOGV("Surface::setBuffersFormat");
+    SURF_LOGV("Surface::setBuffersFormat");
 
     Mutex::Autolock lock(mMutex);
     if (format != mReqFormat) {
@@ -2475,7 +2463,7 @@ int Surface::setBuffersFormat(PixelFormat format)
 int Surface::setScalingMode(int mode)
 {
     ATRACE_CALL();
-    ALOGV("Surface::setScalingMode(%d)", mode);
+    SURF_LOGV("Surface::setScalingMode(%d)", mode);
 
     switch (mode) {
         case NATIVE_WINDOW_SCALING_MODE_FREEZE:
@@ -2484,7 +2472,7 @@ int Surface::setScalingMode(int mode)
         case NATIVE_WINDOW_SCALING_MODE_NO_SCALE_CROP:
             break;
         default:
-            ALOGE("unknown scaling mode: %d", mode);
+            SURF_LOGE("unknown scaling mode: %d", mode);
             return BAD_VALUE;
     }
 
@@ -2496,7 +2484,7 @@ int Surface::setScalingMode(int mode)
 int Surface::setBuffersTransform(uint32_t transform)
 {
     ATRACE_CALL();
-    ALOGV("Surface::setBuffersTransform");
+    SURF_LOGV("Surface::setBuffersTransform");
     Mutex::Autolock lock(mMutex);
     // Ensure NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY is sticky. If the client sets the flag, do not
     // override it until the surface is disconnected. This is a temporary workaround for camera
@@ -2512,7 +2500,7 @@ int Surface::setBuffersTransform(uint32_t transform)
 int Surface::setBuffersStickyTransform(uint32_t transform)
 {
     ATRACE_CALL();
-    ALOGV("Surface::setBuffersStickyTransform");
+    SURF_LOGV("Surface::setBuffersStickyTransform");
     Mutex::Autolock lock(mMutex);
     mStickyTransform = transform;
     return NO_ERROR;
@@ -2520,7 +2508,7 @@ int Surface::setBuffersStickyTransform(uint32_t transform)
 
 int Surface::setBuffersTimestamp(int64_t timestamp)
 {
-    ALOGV("Surface::setBuffersTimestamp");
+    SURF_LOGV("Surface::setBuffersTimestamp");
     Mutex::Autolock lock(mMutex);
     mTimestamp = timestamp;
     return NO_ERROR;
@@ -2528,14 +2516,14 @@ int Surface::setBuffersTimestamp(int64_t timestamp)
 
 int Surface::setBuffersDataSpace(Dataspace dataSpace)
 {
-    ALOGV("Surface::setBuffersDataSpace");
+    SURF_LOGV("Surface::setBuffersDataSpace");
     Mutex::Autolock lock(mMutex);
     mDataSpace = dataSpace;
     return NO_ERROR;
 }
 
 int Surface::setBuffersSmpte2086Metadata(const android_smpte2086_metadata* metadata) {
-    ALOGV("Surface::setBuffersSmpte2086Metadata");
+    SURF_LOGV("Surface::setBuffersSmpte2086Metadata");
     Mutex::Autolock lock(mMutex);
     mHdrMetadataIsSet |= HdrMetadata::SMPTE2086;
     if (metadata) {
@@ -2548,7 +2536,7 @@ int Surface::setBuffersSmpte2086Metadata(const android_smpte2086_metadata* metad
 }
 
 int Surface::setBuffersCta8613Metadata(const android_cta861_3_metadata* metadata) {
-    ALOGV("Surface::setBuffersCta8613Metadata");
+    SURF_LOGV("Surface::setBuffersCta8613Metadata");
     Mutex::Autolock lock(mMutex);
     mHdrMetadataIsSet |= HdrMetadata::CTA861_3;
     if (metadata) {
@@ -2561,7 +2549,7 @@ int Surface::setBuffersCta8613Metadata(const android_cta861_3_metadata* metadata
 }
 
 int Surface::setBuffersHdr10PlusMetadata(const size_t size, const uint8_t* metadata) {
-    ALOGV("Surface::setBuffersBlobMetadata");
+    SURF_LOGV("Surface::setBuffersBlobMetadata");
     Mutex::Autolock lock(mMutex);
     mHdrMetadataIsSet |= HdrMetadata::HDR10PLUS;
     if (size > 0) {
@@ -2575,15 +2563,15 @@ int Surface::setBuffersHdr10PlusMetadata(const size_t size, const uint8_t* metad
 }
 
 Dataspace Surface::getBuffersDataSpace() {
-    ALOGV("Surface::getBuffersDataSpace");
+    SURF_LOGV("Surface::getBuffersDataSpace");
     Mutex::Autolock lock(mMutex);
     return mDataSpace;
 }
 
 void Surface::freeAllBuffers() {
     if (!mDequeuedSlots.empty()) {
-        ALOGE("%s: %zu buffers were freed while being dequeued!",
-                __FUNCTION__, mDequeuedSlots.size());
+        SURF_LOGE("%s: %zu buffers were freed while being dequeued!", __FUNCTION__,
+                  mDequeuedSlots.size());
     }
 #if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_UNLIMITED_SLOTS)
     for (int i = 0; i < (int)mSlots.size(); i++) {
@@ -2596,14 +2584,14 @@ void Surface::freeAllBuffers() {
 
 status_t Surface::getAndFlushBuffersFromSlots(const std::vector<int32_t>& slots,
         std::vector<sp<GraphicBuffer>>* outBuffers) {
-    ALOGV("Surface::getAndFlushBuffersFromSlots");
+    SURF_LOGV("Surface::getAndFlushBuffersFromSlots");
     for (int32_t i : slots) {
 #if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_UNLIMITED_SLOTS)
         if (i < 0 || i >= (int)mSlots.size()) {
 #else
         if (i < 0 || i >= NUM_BUFFER_SLOTS) {
 #endif
-            ALOGE("%s: Invalid slotIndex: %d", __FUNCTION__, i);
+            SURF_LOGE("%s: Invalid slotIndex: %d", __FUNCTION__, i);
             return BAD_VALUE;
         }
     }
@@ -2611,7 +2599,7 @@ status_t Surface::getAndFlushBuffersFromSlots(const std::vector<int32_t>& slots,
     Mutex::Autolock lock(mMutex);
     for (int32_t i : slots) {
         if (mSlots[i].buffer == nullptr) {
-            ALOGW("%s: Discarded slot %d doesn't contain buffer!", __FUNCTION__, i);
+            SURF_LOGW("%s: Discarded slot %d doesn't contain buffer!", __FUNCTION__, i);
             continue;
         }
         // Don't flush currently dequeued buffers
@@ -2626,7 +2614,7 @@ status_t Surface::getAndFlushBuffersFromSlots(const std::vector<int32_t>& slots,
 
 void Surface::setSurfaceDamage(android_native_rect_t* rects, size_t numRects) {
     ATRACE_CALL();
-    ALOGV("Surface::setSurfaceDamage");
+    SURF_LOGV("Surface::setSurfaceDamage");
     Mutex::Autolock lock(mMutex);
 
     if (mConnectedToCpu || numRects == 0) {
@@ -2714,7 +2702,7 @@ status_t Surface::lock(
         ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)
 {
     if (mLockedBuffer != nullptr) {
-        ALOGE("Surface::lock failed, already locked");
+        SURF_LOGE("Surface::lock failed, already locked");
         return INVALID_OPERATION;
     }
 
@@ -2723,16 +2711,16 @@ status_t Surface::lock(
         if (err) {
             return err;
         }
-        // we're intending to do software rendering from this point
-        setUsage(GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN);
     }
+    // we're intending to do software rendering from this point.
+    setUsage(GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN |
+             (mIsForCursor ? GRALLOC_USAGE_CURSOR : 0));
 
-    ANativeWindowBuffer* out;
+    sp<GraphicBuffer> backBuffer;
     int fenceFd = -1;
-    status_t err = dequeueBuffer(&out, &fenceFd);
-    ALOGE_IF(err, "dequeueBuffer failed (%s)", strerror(-err));
+    status_t err = dequeueBuffer(&backBuffer, &fenceFd);
+    SURF_LOGE_IF(err, "dequeueBuffer failed (%s)", strerror(-err));
     if (err == NO_ERROR) {
-        sp<GraphicBuffer> backBuffer(GraphicBuffer::getSelf(out));
         const Rect bounds(backBuffer->width, backBuffer->height);
 
         Region newDirtyRegion;
@@ -2774,7 +2762,7 @@ status_t Surface::lock(
 
         { // scope for the lock
             Mutex::Autolock lock(mMutex);
-            int backBufferSlot(getSlotFromBufferLocked(backBuffer.get()));
+            int backBufferSlot(getSlotFromBufferLocked(backBuffer));
             if (backBufferSlot >= 0) {
                 Region& dirtyRegion(mSlots[backBufferSlot].dirtyRegion);
                 mDirtyRegion.subtract(dirtyRegion);
@@ -2792,8 +2780,7 @@ status_t Surface::lock(
                 GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN,
                 newDirtyRegion.bounds(), &vaddr, fenceFd);
 
-        ALOGW_IF(res, "failed locking buffer (handle = %p)",
-                backBuffer->handle);
+        SURF_LOGW_IF(res, "failed locking buffer (handle = %p)", backBuffer->handle);
 
         if (res != 0) {
             err = INVALID_OPERATION;
@@ -2812,17 +2799,16 @@ status_t Surface::lock(
 status_t Surface::unlockAndPost()
 {
     if (mLockedBuffer == nullptr) {
-        ALOGE("Surface::unlockAndPost failed, no locked buffer");
+        SURF_LOGE("Surface::unlockAndPost failed, no locked buffer");
         return INVALID_OPERATION;
     }
 
     int fd = -1;
     status_t err = mLockedBuffer->unlockAsync(&fd);
-    ALOGE_IF(err, "failed unlocking buffer (%p)", mLockedBuffer->handle);
+    SURF_LOGE_IF(err, "failed unlocking buffer (%p)", mLockedBuffer->handle);
 
     err = queueBuffer(mLockedBuffer.get(), fd);
-    ALOGE_IF(err, "queueBuffer (handle=%p) failed (%s)",
-            mLockedBuffer->handle, strerror(-err));
+    SURF_LOGE_IF(err, "queueBuffer (handle=%p) failed (%s)", mLockedBuffer->handle, strerror(-err));
 
     mPostedBuffer = mLockedBuffer;
     mLockedBuffer = nullptr;
@@ -2849,7 +2835,7 @@ int Surface::getConsumerUsage(uint64_t* outUsage) const {
 
 status_t Surface::getAndFlushRemovedBuffers(std::vector<sp<GraphicBuffer>>* out) {
     if (out == nullptr) {
-        ALOGE("%s: out must not be null!", __FUNCTION__);
+        SURF_LOGE("%s: out must not be null!", __FUNCTION__);
         return BAD_VALUE;
     }
 
@@ -2892,7 +2878,7 @@ status_t Surface::attachAndQueueBufferWithDataspace(Surface* surface, sp<Graphic
 
 int Surface::setAutoPrerotation(bool autoPrerotation) {
     ATRACE_CALL();
-    ALOGV("Surface::setAutoPrerotation (%d)", autoPrerotation);
+    SURF_LOGV("Surface::setAutoPrerotation (%d)", autoPrerotation);
     Mutex::Autolock lock(mMutex);
 
     if (mAutoPrerotation == autoPrerotation) {
@@ -2903,8 +2889,8 @@ int Surface::setAutoPrerotation(bool autoPrerotation) {
     if (err == NO_ERROR) {
         mAutoPrerotation = autoPrerotation;
     }
-    ALOGE_IF(err, "IGraphicBufferProducer::setAutoPrerotation(%d) returned %s", autoPrerotation,
-             strerror(-err));
+    SURF_LOGE_IF(err, "IGraphicBufferProducer::setAutoPrerotation(%d) returned %s", autoPrerotation,
+                 strerror(-err));
     return err;
 }
 
@@ -2928,25 +2914,11 @@ void Surface::ProducerListenerProxy::onBuffersDiscarded(const std::vector<int32_
 
 status_t Surface::setFrameRate(float frameRate, int8_t compatibility,
                                int8_t changeFrameRateStrategy) {
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(BQ_SETFRAMERATE)
-    if (flags::bq_setframerate()) {
-        status_t err = mGraphicBufferProducer->setFrameRate(frameRate, compatibility,
-                                                            changeFrameRateStrategy);
-        ALOGE_IF(err, "IGraphicBufferProducer::setFrameRate(%.2f) returned %s", frameRate,
+    status_t err = mGraphicBufferProducer->setFrameRate(frameRate, compatibility,
+                                                        changeFrameRateStrategy);
+    SURF_LOGE_IF(err, "IGraphicBufferProducer::setFrameRate(%.2f) returned %s", frameRate,
                  strerror(-err));
-        return err;
-    }
-#else
-    static_cast<void>(frameRate);
-    static_cast<void>(compatibility);
-    static_cast<void>(changeFrameRateStrategy);
-#endif
-
-    ALOGI("Surface::setFrameRate is deprecated, setFrameRate hint is dropped as destination is not "
-          "SurfaceFlinger");
-    // ISurfaceComposer no longer supports setFrameRate, we will return NO_ERROR when the api is
-    // called to avoid apps crashing, as BAD_VALUE can generate fatal exception in apps.
-    return NO_ERROR;
+    return err;
 }
 
 status_t Surface::setFrameTimelineInfo(uint64_t /*frameNumber*/,
@@ -2976,12 +2948,17 @@ void Surface::destroy() {
     mSurfaceControlHandle = nullptr;
 }
 
-const char* Surface::getDebugName() {
-    std::unique_lock lock{mNameMutex};
-    if (mName.empty()) {
-        mName = getConsumerName();
+bool Surface::IsCursorPlaneCompatibilitySupported() {
+    if (com::android::graphics::libgui::flags::cursor_plane_compatibility()) {
+        const AHardwareBuffer_Desc testDesc{.width = 64,
+                                            .height = 64,
+                                            .layers = 1,
+                                            .format = AHARDWAREBUFFER_FORMAT_B8G8R8A8_UNORM,
+                                            .usage = GRALLOC_USAGE_CURSOR};
+        return AHardwareBuffer_isSupported(&testDesc);
     }
-    return mName.c_str();
+
+    return false;
 }
 
 }; // namespace android
diff --git a/libs/gui/SurfaceComposerClient.cpp b/libs/gui/SurfaceComposerClient.cpp
index 786bc06f64..fe1219a4be 100644
--- a/libs/gui/SurfaceComposerClient.cpp
+++ b/libs/gui/SurfaceComposerClient.cpp
@@ -32,8 +32,10 @@
 #include <gui/DisplayLuts.h>
 #include <gui/FrameRateUtils.h>
 #include <gui/TraceUtils.h>
+#include <gui/TransactionState.h>
 #include <utils/Errors.h>
 #include <utils/Log.h>
+#include <utils/Mutex.h>
 #include <utils/SortedVector.h>
 #include <utils/String8.h>
 #include <utils/threads.h>
@@ -98,8 +100,7 @@ const constexpr char* LOG_SURFACE_CONTROL_REGISTRY = "SurfaceControlRegistry";
 
 const std::string SurfaceComposerClient::kEmpty{};
 
-ComposerService::ComposerService()
-: Singleton<ComposerService>() {
+ComposerService::ComposerService() : Singleton<ComposerService>() {
     Mutex::Autolock _l(mLock);
     connectLocked();
 }
@@ -115,12 +116,12 @@ bool ComposerService::connectLocked() {
     class DeathObserver : public IBinder::DeathRecipient {
         ComposerService& mComposerService;
         virtual void binderDied(const wp<IBinder>& who) {
-            ALOGW("ComposerService remote (surfaceflinger) died [%p]",
-                  who.unsafe_get());
+            ALOGW("ComposerService remote (surfaceflinger) died [%p]", who.unsafe_get());
             mComposerService.composerServiceDied();
         }
-     public:
-        explicit DeathObserver(ComposerService& mgr) : mComposerService(mgr) { }
+
+    public:
+        explicit DeathObserver(ComposerService& mgr) : mComposerService(mgr) {}
     };
 
     mDeathObserver = sp<DeathObserver>::make(*const_cast<ComposerService*>(this));
@@ -139,8 +140,7 @@ bool ComposerService::connectLocked() {
     return instance.mComposerService;
 }
 
-void ComposerService::composerServiceDied()
-{
+void ComposerService::composerServiceDied() {
     Mutex::Autolock _l(mLock);
     mComposerService = nullptr;
     mDeathObserver = nullptr;
@@ -193,10 +193,11 @@ void ComposerServiceAIDL::composerServiceDied() {
     mDeathObserver = nullptr;
 }
 
-class DefaultComposerClient: public Singleton<DefaultComposerClient> {
+class DefaultComposerClient : public Singleton<DefaultComposerClient> {
     Mutex mLock;
     sp<SurfaceComposerClient> mClient;
     friend class Singleton<ComposerService>;
+
 public:
     static sp<SurfaceComposerClient> getComposerClient() {
         DefaultComposerClient& dc = DefaultComposerClient::getInstance();
@@ -209,15 +210,13 @@ public:
 };
 ANDROID_SINGLETON_STATIC_INSTANCE(DefaultComposerClient);
 
-
 sp<SurfaceComposerClient> SurfaceComposerClient::getDefault() {
     return DefaultComposerClient::getComposerClient();
 }
 
 // ---------------------------------------------------------------------------
 
-JankDataListener::~JankDataListener() {
-}
+JankDataListener::~JankDataListener() {}
 
 status_t JankDataListener::flushJankData() {
     if (mLayerId == -1) {
@@ -442,7 +441,8 @@ void TransactionCompletedListener::setReleaseBufferCallback(const ReleaseCallbac
 }
 
 void TransactionCompletedListener::addSurfaceStatsListener(void* context, void* cookie,
-        sp<SurfaceControl> surfaceControl, SurfaceStatsCallback listener) {
+                                                           sp<SurfaceControl> surfaceControl,
+                                                           SurfaceStatsCallback listener) {
     std::scoped_lock<std::recursive_mutex> lock(mSurfaceStatsListenerMutex);
     mSurfaceStatsListeners.insert(
             {surfaceControl->getLayerId(), SurfaceStatsCallbackEntry(context, cookie, listener)});
@@ -606,7 +606,7 @@ void TransactionCompletedListener::onTransactionCompleted(ListenerStats listener
                 for (auto it = listenerRange.first; it != listenerRange.second; it++) {
                     auto entry = it->second;
                     entry.callback(entry.context, transactionStats.latchTime,
-                        transactionStats.presentFence, surfaceStats);
+                                   transactionStats.presentFence, surfaceStats);
                 }
             }
         }
@@ -824,24 +824,29 @@ void removeDeadBufferCallback(void* /*context*/, uint64_t graphicBufferId) {
 // ---------------------------------------------------------------------------
 
 SurfaceComposerClient::Transaction::Transaction() {
-    mState.mId = generateId();
+    mSimpleState.mId = generateId();
     mTransactionCompletedListener = TransactionCompletedListener::getInstance();
 }
 
-SurfaceComposerClient::Transaction::Transaction(Transaction&& other)
-      : mTransactionCompletedListener(TransactionCompletedListener::getInstance()),
-        mState(std::move(other.mState)),
-        mListenerCallbacks(std::move(other.mListenerCallbacks)) {}
+SurfaceComposerClient::Transaction::Transaction(const Transaction& other)
+      : mSimpleState(other.mSimpleState),
+        mComplexState(other.mComplexState),
+        mMutableState(other.mMutableState),
+        mMayContainBuffer(other.mMayContainBuffer),
+        mApplyToken(other.mApplyToken) {
+    mListenerCallbacks = other.mListenerCallbacks;
+    mTransactionCompletedListener = TransactionCompletedListener::getInstance();
+}
 
 void SurfaceComposerClient::Transaction::sanitize(int pid, int uid) {
     uint32_t permissions = LayerStatePermissions::getTransactionPermissions(pid, uid);
-    for (auto& composerState : mState.mComposerStates) {
+    for (auto& composerState : mMutableState.mComposerStates) {
         composerState.state.sanitize(permissions);
     }
-    if (!mState.mInputWindowCommands.empty() &&
+    if (!mComplexState.mInputWindowCommands.empty() &&
         (permissions & layer_state_t::Permission::ACCESS_SURFACE_FLINGER) == 0) {
         ALOGE("Only privileged callers are allowed to send input commands.");
-        mState.mInputWindowCommands.clear();
+        mComplexState.mInputWindowCommands.clear();
     }
 }
 
@@ -854,11 +859,17 @@ SurfaceComposerClient::Transaction::createFromParcel(const Parcel* parcel) {
     return nullptr;
 }
 
-
 status_t SurfaceComposerClient::Transaction::readFromParcel(const Parcel* parcel) {
-    TransactionState tmpState;
-    SAFE_PARCEL(tmpState.readFromParcel, parcel);
-
+    SimpleTransactionState simpleState;
+    SAFE_PARCEL(simpleState.readFromParcel, parcel);
+    ComplexTransactionState complexState;
+    SAFE_PARCEL(complexState.readFromParcel, parcel);
+    MutableTransactionState mutableState;
+    SAFE_PARCEL(mutableState.readFromParcel, parcel);
+    const bool logCallPoints = parcel->readBool();
+
+    sp<IBinder> applyToken;
+    parcel->readNullableStrongBinder(&applyToken);
     size_t count = static_cast<size_t>(parcel->readUint32());
     if (count > parcel->dataSize()) {
         return BAD_VALUE;
@@ -888,8 +899,12 @@ status_t SurfaceComposerClient::Transaction::readFromParcel(const Parcel* parcel
         }
     }
 
-    mState = std::move(tmpState);
-    mListenerCallbacks = std::move(listenerCallbacks);
+    // Parsing was successful. Update the object.
+    mSimpleState = std::move(simpleState);
+    mComplexState = std::move(complexState);
+    mMutableState = std::move(mutableState);
+    mListenerCallbacks = listenerCallbacks;
+    mApplyToken = applyToken;
     return NO_ERROR;
 }
 
@@ -907,7 +922,11 @@ status_t SurfaceComposerClient::Transaction::writeToParcel(Parcel* parcel) const
 
     const_cast<SurfaceComposerClient::Transaction*>(this)->cacheBuffers();
 
-    SAFE_PARCEL(mState.writeToParcel, parcel);
+    SAFE_PARCEL(mSimpleState.writeToParcel, parcel);
+    SAFE_PARCEL(mComplexState.writeToParcel, parcel);
+    SAFE_PARCEL(mMutableState.writeToParcel, parcel);
+    parcel->writeBool(mLogCallPoints);
+    parcel->writeStrongBinder(mApplyToken);
 
     parcel->writeUint32(static_cast<uint32_t>(mListenerCallbacks.size()));
     for (auto const& [listener, callbackInfo] : mListenerCallbacks) {
@@ -946,8 +965,6 @@ void SurfaceComposerClient::Transaction::releaseBufferIfOverwriting(const layer_
 }
 
 SurfaceComposerClient::Transaction& SurfaceComposerClient::Transaction::merge(Transaction&& other) {
-    mState.merge(std::move(other.mState),
-                 std::bind(&Transaction::releaseBufferIfOverwriting, this, std::placeholders::_1));
     for (const auto& [listener, callbackInfo] : other.mListenerCallbacks) {
         auto& [callbackIds, surfaceControls] = callbackInfo;
         mListenerCallbacks[listener].callbackIds.insert(std::make_move_iterator(
@@ -971,36 +988,59 @@ SurfaceComposerClient::Transaction& SurfaceComposerClient::Transaction::merge(Tr
         }
     }
 
+    mSimpleState.merge(other.mSimpleState);
+    mComplexState.merge(other.mComplexState);
+    mComplexState.mMergedTransactionIds.insert(mComplexState.mMergedTransactionIds.begin(),
+                                               other.mSimpleState.mId);
+    mMutableState.merge(other.mMutableState,
+                        [this](const auto& state) { releaseBufferIfOverwriting(state); });
+    mMayContainBuffer |= other.mMayContainBuffer;
+    mApplyToken = other.mApplyToken;
+
+    mLogCallPoints |= other.mLogCallPoints;
+    if (mLogCallPoints) {
+        ALOG(LOG_DEBUG, LOG_SURFACE_CONTROL_REGISTRY,
+             "Transaction %" PRIu64 " merged with transaction %" PRIu64, other.getId(),
+             mSimpleState.mId);
+    }
+
     other.clear();
+
     return *this;
 }
 
 void SurfaceComposerClient::Transaction::clear() {
-    mState.clear();
+    mSimpleState.clear();
+    mComplexState.clear();
+    mMutableState.clear();
     mListenerCallbacks.clear();
+    mMayContainBuffer = false;
+    mApplyToken = nullptr;
+    mLogCallPoints = false;
 }
 
-uint64_t SurfaceComposerClient::Transaction::getId() const {
-    return mState.mId;
+uint64_t SurfaceComposerClient::Transaction::getId() {
+    return mSimpleState.mId;
 }
 
 std::vector<uint64_t> SurfaceComposerClient::Transaction::getMergedTransactionIds() {
-    return mState.mMergedTransactionIds;
+    return mComplexState.mMergedTransactionIds;
 }
 
 void SurfaceComposerClient::doUncacheBufferTransaction(uint64_t cacheId) {
     sp<ISurfaceComposer> sf(ComposerService::getComposerService());
 
+    ComplexTransactionState complexState;
     client_cache_t uncacheBuffer;
     uncacheBuffer.token = BufferCache::getInstance().getToken();
     uncacheBuffer.id = cacheId;
-    TransactionState state;
-    state.mId = generateId();
-    state.mApplyToken = Transaction::getDefaultApplyToken();
-    state.mUncacheBuffers.emplace_back(std::move(uncacheBuffer));
-    state.mFlags = ISurfaceComposer::eOneWay;
-    state.mDesiredPresentTime = systemTime();
-    status_t status = sf->setTransactionState(std::move(state));
+    complexState.mUncacheBuffers.emplace_back(std::move(uncacheBuffer));
+    MutableTransactionState mutableState;
+    status_t status =
+            sf->setTransactionState(SimpleTransactionState(generateId(), ISurfaceComposer::eOneWay,
+                                                           systemTime(), true),
+                                    complexState, mutableState,
+                                    Transaction::getDefaultApplyToken());
     if (status != NO_ERROR) {
         ALOGE_AND_TRACE("SurfaceComposerClient::doUncacheBufferTransaction - %s",
                         strerror(-status));
@@ -1008,12 +1048,12 @@ void SurfaceComposerClient::doUncacheBufferTransaction(uint64_t cacheId) {
 }
 
 void SurfaceComposerClient::Transaction::cacheBuffers() {
-    if (!mState.mMayContainBuffer) {
+    if (!mMayContainBuffer) {
         return;
     }
 
     size_t count = 0;
-    for (auto& cs : mState.mComposerStates) {
+    for (auto& cs : mMutableState.mComposerStates) {
         layer_state_t* s = &cs.state;
         if (!(s->what & layer_state_t::eBufferChanged)) {
             continue;
@@ -1041,7 +1081,7 @@ void SurfaceComposerClient::Transaction::cacheBuffers() {
             std::optional<client_cache_t> uncacheBuffer;
             cacheId = BufferCache::getInstance().cache(s->bufferData->buffer, uncacheBuffer);
             if (uncacheBuffer) {
-                mState.mUncacheBuffers.emplace_back(*uncacheBuffer);
+                mComplexState.mUncacheBuffers.push_back(*uncacheBuffer);
             }
         }
         s->bufferData->flags |= BufferData::BufferDataChange::cachedBufferChanged;
@@ -1110,7 +1150,9 @@ status_t SurfaceComposerClient::Transaction::apply(bool synchronous, bool oneWay
                                         /*callbackContext=*/nullptr);
     }
 
-    mState.mHasListenerCallbacks = !mListenerCallbacks.empty();
+    TransactionListenerCallbacks& listenerCallbacks = mComplexState.mCallbacks;
+    listenerCallbacks.clear();
+    listenerCallbacks.mHasListenerCallbacks = !mListenerCallbacks.empty();
     // For every listener with registered callbacks
     for (const auto& [listener, callbackInfo] : mListenerCallbacks) {
         auto& [callbackIds, surfaceControls] = callbackInfo;
@@ -1119,8 +1161,9 @@ status_t SurfaceComposerClient::Transaction::apply(bool synchronous, bool oneWay
         }
 
         if (surfaceControls.empty()) {
-            mState.mListenerCallbacks.emplace_back(IInterface::asBinder(listener),
-                                                   std::move(callbackIds));
+            listenerCallbacks.mFlattenedListenerCallbacks.emplace_back(IInterface::asBinder(
+                                                                               listener),
+                                                                       std::move(callbackIds));
         } else {
             // If the listener has any SurfaceControls set on this Transaction update the surface
             // state
@@ -1132,7 +1175,7 @@ status_t SurfaceComposerClient::Transaction::apply(bool synchronous, bool oneWay
                 }
                 std::vector<CallbackId> callbacks(callbackIds.begin(), callbackIds.end());
                 s->what |= layer_state_t::eHasListenerCallbacksChanged;
-                s->listeners.emplace_back(IInterface::asBinder(listener), std::move(callbacks));
+                s->listeners.emplace_back(IInterface::asBinder(listener), callbacks);
             }
         }
     }
@@ -1144,21 +1187,22 @@ status_t SurfaceComposerClient::Transaction::apply(bool synchronous, bool oneWay
             ALOGE("Transaction attempted to set synchronous and one way at the same time"
                   " this is an invalid request. Synchronous will win for safety");
         } else {
-            mState.mFlags |= ISurfaceComposer::eOneWay;
+            mSimpleState.mFlags |= ISurfaceComposer::eOneWay;
         }
     }
 
     // If both ISurfaceComposer::eEarlyWakeupStart and ISurfaceComposer::eEarlyWakeupEnd are set
     // it is equivalent for none
     uint32_t wakeupFlags = ISurfaceComposer::eEarlyWakeupStart | ISurfaceComposer::eEarlyWakeupEnd;
-    if ((mState.mFlags & wakeupFlags) == wakeupFlags) {
-        mState.mFlags &= ~(wakeupFlags);
+    if ((mSimpleState.mFlags & wakeupFlags) == wakeupFlags) {
+        mSimpleState.mFlags &= ~(wakeupFlags);
     }
-    if (!mState.mApplyToken) mState.mApplyToken = getDefaultApplyToken();
+    sp<IBinder> applyToken = mApplyToken ? mApplyToken : getDefaultApplyToken();
 
     sp<ISurfaceComposer> sf(ComposerService::getComposerService());
-    status_t binderStatus = sf->setTransactionState(std::move(mState));
-    mState.mId = generateId();
+    status_t binderStatus =
+            sf->setTransactionState(mSimpleState, mComplexState, mMutableState, applyToken);
+    mSimpleState.mId = generateId();
 
     // Clear the current states and flags
     clear();
@@ -1167,8 +1211,9 @@ status_t SurfaceComposerClient::Transaction::apply(bool synchronous, bool oneWay
         syncCallback->wait();
     }
 
-    if (mState.mLogCallPoints) {
-        ALOG(LOG_DEBUG, LOG_SURFACE_CONTROL_REGISTRY, "Transaction %" PRIu64 " applied", getId());
+    if (mLogCallPoints) {
+        ALOG(LOG_DEBUG, LOG_SURFACE_CONTROL_REGISTRY, "Transaction %" PRIu64 " applied",
+             mSimpleState.mId);
     }
 
     mStatus = NO_ERROR;
@@ -1203,7 +1248,7 @@ status_t SurfaceComposerClient::Transaction::sendSurfaceFlushJankDataTransaction
 }
 
 void SurfaceComposerClient::Transaction::enableDebugLogCallPoints() {
-    mState.mLogCallPoints = true;
+    mLogCallPoints = true;
 }
 
 // ---------------------------------------------------------------------------
@@ -1261,19 +1306,23 @@ std::optional<gui::StalledTransactionInfo> SurfaceComposerClient::getStalledTran
 }
 
 void SurfaceComposerClient::Transaction::setAnimationTransaction() {
-    mState.mFlags |= ISurfaceComposer::eAnimation;
+    mSimpleState.mFlags |= ISurfaceComposer::eAnimation;
 }
 
-void SurfaceComposerClient::Transaction::setEarlyWakeupStart() {
-    mState.mFlags |= ISurfaceComposer::eEarlyWakeupStart;
+void SurfaceComposerClient::Transaction::setEarlyWakeupStart(gui::EarlyWakeupInfo earlyWakeupInfo) {
+    earlyWakeupInfo.isStartRequest = true;
+    mComplexState.mEarlyWakeupInfos.push_back(std::move(earlyWakeupInfo));
+    mSimpleState.mFlags |= ISurfaceComposer::eEarlyWakeupStart;
 }
 
-void SurfaceComposerClient::Transaction::setEarlyWakeupEnd() {
-    mState.mFlags |= ISurfaceComposer::eEarlyWakeupEnd;
+void SurfaceComposerClient::Transaction::setEarlyWakeupEnd(gui::EarlyWakeupInfo earlyWakeupInfo) {
+    earlyWakeupInfo.isStartRequest = false;
+    mComplexState.mEarlyWakeupInfos.push_back(std::move(earlyWakeupInfo));
+    mSimpleState.mFlags |= ISurfaceComposer::eEarlyWakeupEnd;
 }
 
 layer_state_t* SurfaceComposerClient::Transaction::getLayerState(const sp<SurfaceControl>& sc) {
-    return mState.getLayerState(sc);
+    return mMutableState.getLayerState(sc);
 }
 
 void SurfaceComposerClient::Transaction::registerSurfaceControlForCallback(
@@ -1337,8 +1386,7 @@ SurfaceComposerClient::Transaction& SurfaceComposerClient::Transaction::setRelat
 }
 
 SurfaceComposerClient::Transaction& SurfaceComposerClient::Transaction::setFlags(
-        const sp<SurfaceControl>& sc, uint32_t flags,
-        uint32_t mask) {
+        const sp<SurfaceControl>& sc, uint32_t flags, uint32_t mask) {
     layer_state_t* s = getLayerState(sc);
     if (!s) {
         mStatus = BAD_INDEX;
@@ -1354,8 +1402,7 @@ SurfaceComposerClient::Transaction& SurfaceComposerClient::Transaction::setFlags
 }
 
 SurfaceComposerClient::Transaction& SurfaceComposerClient::Transaction::setTransparentRegionHint(
-        const sp<SurfaceControl>& sc,
-        const Region& transparentRegion) {
+        const sp<SurfaceControl>& sc, const Region& transparentRegion) {
     layer_state_t* s = getLayerState(sc);
     if (!s) {
         mStatus = BAD_INDEX;
@@ -1427,8 +1474,7 @@ SurfaceComposerClient::Transaction& SurfaceComposerClient::Transaction::setMetad
 }
 
 SurfaceComposerClient::Transaction& SurfaceComposerClient::Transaction::setMatrix(
-        const sp<SurfaceControl>& sc, float dsdx, float dtdx,
-        float dtdy, float dsdy) {
+        const sp<SurfaceControl>& sc, float dsdx, float dtdx, float dtdy, float dsdy) {
     layer_state_t* s = getLayerState(sc);
     if (!s) {
         mStatus = BAD_INDEX;
@@ -1501,6 +1547,18 @@ SurfaceComposerClient::Transaction& SurfaceComposerClient::Transaction::setBackg
     return *this;
 }
 
+SurfaceComposerClient::Transaction& SurfaceComposerClient::Transaction::setBackgroundBlurScale(
+        const sp<SurfaceControl>& sc, float backgroundBlurScale) {
+    layer_state_t* s = getLayerState(sc);
+    if (!s) {
+        mStatus = BAD_INDEX;
+        return *this;
+    }
+    s->what |= layer_state_t::eBackgroundBlurScaleChanged;
+    s->backgroundBlurScale = backgroundBlurScale;
+    return *this;
+}
+
 SurfaceComposerClient::Transaction& SurfaceComposerClient::Transaction::setBlurRegions(
         const sp<SurfaceControl>& sc, const std::vector<BlurRegion>& blurRegions) {
     layer_state_t* s = getLayerState(sc);
@@ -1529,8 +1587,7 @@ SurfaceComposerClient::Transaction& SurfaceComposerClient::Transaction::reparent
 }
 
 SurfaceComposerClient::Transaction& SurfaceComposerClient::Transaction::setColor(
-        const sp<SurfaceControl>& sc,
-        const half3& color) {
+        const sp<SurfaceControl>& sc, const half3& color) {
     layer_state_t* s = getLayerState(sc);
     if (!s) {
         mStatus = BAD_INDEX;
@@ -1649,8 +1706,8 @@ SurfaceComposerClient::Transaction& SurfaceComposerClient::Transaction::setBuffe
         setReleaseBufferCallback(bufferData.get(), callback);
     }
 
-    if (mState.mIsAutoTimestamp) {
-        mState.mDesiredPresentTime = systemTime();
+    if (mSimpleState.mIsAutoTimestamp) {
+        mSimpleState.mDesiredPresentTime = systemTime();
     }
     s->what |= layer_state_t::eBufferChanged;
     s->bufferData = std::move(bufferData);
@@ -1668,7 +1725,7 @@ SurfaceComposerClient::Transaction& SurfaceComposerClient::Transaction::setBuffe
                                        const std::vector<SurfaceControlStats>&) {},
                                     nullptr);
 
-    mState.mMayContainBuffer = true;
+    mMayContainBuffer = true;
     return *this;
 }
 
@@ -1844,8 +1901,8 @@ SurfaceComposerClient::Transaction& SurfaceComposerClient::Transaction::setSideb
 
 SurfaceComposerClient::Transaction& SurfaceComposerClient::Transaction::setDesiredPresentTime(
         nsecs_t desiredPresentTime) {
-    mState.mDesiredPresentTime = desiredPresentTime;
-    mState.mIsAutoTimestamp = false;
+    mSimpleState.mDesiredPresentTime = desiredPresentTime;
+    mSimpleState.mIsAutoTimestamp = false;
     return *this;
 }
 
@@ -1934,19 +1991,19 @@ SurfaceComposerClient::Transaction& SurfaceComposerClient::Transaction::setInput
 
 SurfaceComposerClient::Transaction& SurfaceComposerClient::Transaction::setFocusedWindow(
         const FocusRequest& request) {
-    mState.mInputWindowCommands.addFocusRequest(request);
+    mComplexState.mInputWindowCommands.addFocusRequest(request);
     return *this;
 }
 
 SurfaceComposerClient::Transaction&
 SurfaceComposerClient::Transaction::addWindowInfosReportedListener(
         sp<gui::IWindowInfosReportedListener> windowInfosReportedListener) {
-    mState.mInputWindowCommands.addWindowInfosReportedListener(windowInfosReportedListener);
+    mComplexState.mInputWindowCommands.addWindowInfosReportedListener(windowInfosReportedListener);
     return *this;
 }
 
 SurfaceComposerClient::Transaction& SurfaceComposerClient::Transaction::setColorTransform(
-    const sp<SurfaceControl>& sc, const mat3& matrix, const vec3& translation) {
+        const sp<SurfaceControl>& sc, const mat3& matrix, const vec3& translation) {
     layer_state_t* s = getLayerState(sc);
     if (!s) {
         mStatus = BAD_INDEX;
@@ -1975,34 +2032,46 @@ SurfaceComposerClient::Transaction& SurfaceComposerClient::Transaction::setGeome
 
     switch (transform) {
         case NATIVE_WINDOW_TRANSFORM_FLIP_H:
-            matrix[0] = -xScale; matrix[1] = 0;
-            matrix[2] = 0; matrix[3] = yScale;
+            matrix[0] = -xScale;
+            matrix[1] = 0;
+            matrix[2] = 0;
+            matrix[3] = yScale;
             x += source.getWidth();
             break;
         case NATIVE_WINDOW_TRANSFORM_FLIP_V:
-            matrix[0] = xScale; matrix[1] = 0;
-            matrix[2] = 0; matrix[3] = -yScale;
+            matrix[0] = xScale;
+            matrix[1] = 0;
+            matrix[2] = 0;
+            matrix[3] = -yScale;
             y += source.getHeight();
             break;
         case NATIVE_WINDOW_TRANSFORM_ROT_90:
-            matrix[0] = 0; matrix[1] = -yScale;
-            matrix[2] = xScale; matrix[3] = 0;
+            matrix[0] = 0;
+            matrix[1] = -yScale;
+            matrix[2] = xScale;
+            matrix[3] = 0;
             x += source.getHeight();
             break;
         case NATIVE_WINDOW_TRANSFORM_ROT_180:
-            matrix[0] = -xScale; matrix[1] = 0;
-            matrix[2] = 0; matrix[3] = -yScale;
+            matrix[0] = -xScale;
+            matrix[1] = 0;
+            matrix[2] = 0;
+            matrix[3] = -yScale;
             x += source.getWidth();
             y += source.getHeight();
             break;
         case NATIVE_WINDOW_TRANSFORM_ROT_270:
-            matrix[0] = 0; matrix[1] = yScale;
-            matrix[2] = -xScale; matrix[3] = 0;
+            matrix[0] = 0;
+            matrix[1] = yScale;
+            matrix[2] = -xScale;
+            matrix[3] = 0;
             y += source.getWidth();
             break;
         default:
-            matrix[0] = xScale; matrix[1] = 0;
-            matrix[2] = 0; matrix[3] = yScale;
+            matrix[0] = xScale;
+            matrix[1] = 0;
+            matrix[2] = 0;
+            matrix[3] = yScale;
             break;
     }
     setMatrix(sc, matrix[0], matrix[1], matrix[2], matrix[3]);
@@ -2038,6 +2107,19 @@ SurfaceComposerClient::Transaction& SurfaceComposerClient::Transaction::setBorde
     return *this;
 }
 
+SurfaceComposerClient::Transaction& SurfaceComposerClient::Transaction::setBoxShadowSettings(
+        const sp<SurfaceControl>& sc, gui::BoxShadowSettings settings) {
+    layer_state_t* s = getLayerState(sc);
+    if (!s) {
+        mStatus = BAD_INDEX;
+        return *this;
+    }
+
+    s->what |= layer_state_t::eBoxShadowSettingsChanged;
+    s->boxShadowSettings = settings;
+    return *this;
+}
+
 SurfaceComposerClient::Transaction& SurfaceComposerClient::Transaction::setFrameRate(
         const sp<SurfaceControl>& sc, float frameRate, int8_t compatibility,
         int8_t changeFrameRateStrategy) {
@@ -2118,7 +2200,7 @@ SurfaceComposerClient::Transaction& SurfaceComposerClient::Transaction::setFixed
 
 SurfaceComposerClient::Transaction& SurfaceComposerClient::Transaction::setFrameTimelineInfo(
         const FrameTimelineInfo& frameTimelineInfo) {
-    mState.mergeFrameTimelineInfo(frameTimelineInfo);
+    mComplexState.mergeFrameTimelineInfo(frameTimelineInfo);
     return *this;
 }
 
@@ -2157,12 +2239,12 @@ SurfaceComposerClient::Transaction& SurfaceComposerClient::Transaction::setTrust
 
 SurfaceComposerClient::Transaction& SurfaceComposerClient::Transaction::setApplyToken(
         const sp<IBinder>& applyToken) {
-    mState.mApplyToken = applyToken;
+    mApplyToken = applyToken;
     return *this;
 }
 
 SurfaceComposerClient::Transaction& SurfaceComposerClient::Transaction::setStretchEffect(
-    const sp<SurfaceControl>& sc, const StretchEffect& stretchEffect) {
+        const sp<SurfaceControl>& sc, const StretchEffect& stretchEffect) {
     layer_state_t* s = getLayerState(sc);
     if (!s) {
         mStatus = BAD_INDEX;
@@ -2285,19 +2367,20 @@ SurfaceComposerClient::Transaction& SurfaceComposerClient::Transaction::setConte
 // ---------------------------------------------------------------------------
 
 DisplayState& SurfaceComposerClient::Transaction::getDisplayState(const sp<IBinder>& token) {
-    return mState.getDisplayState(token);
+    return mMutableState.getDisplayState(token);
 }
 
-status_t SurfaceComposerClient::Transaction::setDisplaySurface(const sp<IBinder>& token,
-        const sp<IGraphicBufferProducer>& bufferProducer) {
+status_t SurfaceComposerClient::Transaction::setDisplaySurface(
+        const sp<IBinder>& token, const sp<IGraphicBufferProducer>& bufferProducer) {
     if (bufferProducer.get() != nullptr) {
         // Make sure that composition can never be stalled by a virtual display
         // consumer that isn't processing buffers fast enough.
         status_t err = bufferProducer->setAsyncMode(true);
         if (err != NO_ERROR) {
             ALOGE("Composer::setDisplaySurface Failed to enable async mode on the "
-                    "BufferQueue. This BufferQueue cannot be used for virtual "
-                    "display. (%d)", err);
+                  "BufferQueue. This BufferQueue cannot be used for virtual "
+                  "display. (%d)",
+                  err);
             return err;
         }
     }
@@ -2331,13 +2414,28 @@ void SurfaceComposerClient::Transaction::setDisplayProjection(const sp<IBinder>&
     s.what |= DisplayState::eDisplayProjectionChanged;
 }
 
-void SurfaceComposerClient::Transaction::setDisplaySize(const sp<IBinder>& token, uint32_t width, uint32_t height) {
+void SurfaceComposerClient::Transaction::setDisplaySize(const sp<IBinder>& token, uint32_t width,
+                                                        uint32_t height) {
     DisplayState& s(getDisplayState(token));
     s.width = width;
     s.height = height;
     s.what |= DisplayState::eDisplaySizeChanged;
 }
 
+// copied from FrameTimelineInfo::merge()
+void SurfaceComposerClient::Transaction::mergeFrameTimelineInfo(FrameTimelineInfo& t,
+                                                                const FrameTimelineInfo& other) {
+    // When merging vsync Ids we take the oldest valid one
+    if (t.vsyncId != FrameTimelineInfo::INVALID_VSYNC_ID &&
+        other.vsyncId != FrameTimelineInfo::INVALID_VSYNC_ID) {
+        if (other.vsyncId > t.vsyncId) {
+            t = other;
+        }
+    } else if (t.vsyncId == FrameTimelineInfo::INVALID_VSYNC_ID) {
+        t = other;
+    }
+}
+
 SurfaceComposerClient::Transaction&
 SurfaceComposerClient::Transaction::setTrustedPresentationCallback(
         const sp<SurfaceControl>& sc, TrustedPresentationCallback cb,
@@ -2386,12 +2484,16 @@ SurfaceComposerClient::SurfaceComposerClient(const sp<ISurfaceComposerClient>& c
 
 void SurfaceComposerClient::onFirstRef() {
     sp<gui::ISurfaceComposer> sf(ComposerServiceAIDL::getComposerService());
+    Mutex::Autolock _lm(mLock);
     if (sf != nullptr && mStatus == NO_INIT) {
         sp<ISurfaceComposerClient> conn;
         binder::Status status = sf->createConnection(&conn);
         if (status.isOk() && conn != nullptr) {
             mClient = conn;
             mStatus = NO_ERROR;
+        } else {
+            ALOGE("SurfaceComposerClient::onFirstRef unable to create client connection, error: %s",
+                  status.toString8().c_str());
         }
     }
 }
@@ -2401,16 +2503,17 @@ SurfaceComposerClient::~SurfaceComposerClient() {
 }
 
 status_t SurfaceComposerClient::initCheck() const {
+    Mutex::Autolock _lm(mLock);
     return mStatus;
 }
 
 sp<IBinder> SurfaceComposerClient::connection() const {
+    Mutex::Autolock _lm(mLock);
     return IInterface::asBinder(mClient);
 }
 
-status_t SurfaceComposerClient::linkToComposerDeath(
-        const sp<IBinder::DeathRecipient>& recipient,
-        void* cookie, uint32_t flags) {
+status_t SurfaceComposerClient::linkToComposerDeath(const sp<IBinder::DeathRecipient>& recipient,
+                                                    void* cookie, uint32_t flags) {
     sp<ISurfaceComposer> sf(ComposerService::getComposerService());
     return IInterface::asBinder(sf)->linkToDeath(recipient, cookie, flags);
 }
@@ -2453,6 +2556,7 @@ status_t SurfaceComposerClient::createSurfaceChecked(const String8& name, uint32
                                                      const sp<IBinder>& parentHandle,
                                                      LayerMetadata metadata,
                                                      uint32_t* outTransformHint) {
+    Mutex::Autolock _lm(mLock);
     status_t err = mStatus;
 
     if (mStatus == NO_ERROR) {
@@ -2473,14 +2577,18 @@ status_t SurfaceComposerClient::createSurfaceChecked(const String8& name, uint32
     return err;
 }
 
-sp<SurfaceControl> SurfaceComposerClient::mirrorSurface(SurfaceControl* mirrorFromSurface) {
+sp<SurfaceControl> SurfaceComposerClient::mirrorSurface(SurfaceControl* mirrorFromSurface,
+                                                        SurfaceControl* stopAt) {
     if (mirrorFromSurface == nullptr) {
         return nullptr;
     }
 
+    Mutex::Autolock _lm(mLock);
+
     sp<IBinder> mirrorFromHandle = mirrorFromSurface->getHandle();
+    sp<IBinder> stopAtHandle = stopAt ? stopAt->getHandle() : nullptr;
     gui::CreateSurfaceResult result;
-    const binder::Status status = mClient->mirrorSurface(mirrorFromHandle, &result);
+    const binder::Status status = mClient->mirrorSurface(mirrorFromHandle, stopAtHandle, &result);
     const status_t err = statusTFromBinderStatus(status);
     if (err == NO_ERROR) {
         return sp<SurfaceControl>::make(this, result.handle, result.layerId,
@@ -2490,6 +2598,8 @@ sp<SurfaceControl> SurfaceComposerClient::mirrorSurface(SurfaceControl* mirrorFr
 }
 
 sp<SurfaceControl> SurfaceComposerClient::mirrorDisplay(DisplayId displayId) {
+    Mutex::Autolock _lm(mLock);
+
     gui::CreateSurfaceResult result;
     const binder::Status status = mClient->mirrorDisplay(displayId.value, &result);
     const status_t err = statusTFromBinderStatus(status);
@@ -2501,6 +2611,8 @@ sp<SurfaceControl> SurfaceComposerClient::mirrorDisplay(DisplayId displayId) {
 }
 
 status_t SurfaceComposerClient::clearLayerFrameStats(const sp<IBinder>& token) const {
+    Mutex::Autolock _lm(mLock);
+
     if (mStatus != NO_ERROR) {
         return mStatus;
     }
@@ -2509,10 +2621,12 @@ status_t SurfaceComposerClient::clearLayerFrameStats(const sp<IBinder>& token) c
 }
 
 status_t SurfaceComposerClient::getLayerFrameStats(const sp<IBinder>& token,
-        FrameStats* outStats) const {
+    FrameStats* outStats) const {
+    Mutex::Autolock _lm(mLock);
     if (mStatus != NO_ERROR) {
         return mStatus;
     }
+
     gui::FrameStats stats;
     const binder::Status status = mClient->getLayerFrameStats(token, &stats);
     if (status.isOk()) {
@@ -2721,7 +2835,7 @@ status_t SurfaceComposerClient::getDesiredDisplayModeSpecs(const sp<IBinder>& di
 }
 
 status_t SurfaceComposerClient::getDisplayNativePrimaries(const sp<IBinder>& display,
-        ui::DisplayPrimaries& outPrimaries) {
+                                                          ui::DisplayPrimaries& outPrimaries) {
     gui::DisplayPrimaries primaries;
     binder::Status status =
             ComposerServiceAIDL::getComposerService()->getDisplayNativePrimaries(display,
@@ -2747,7 +2861,7 @@ status_t SurfaceComposerClient::getDisplayNativePrimaries(const sp<IBinder>& dis
 }
 
 status_t SurfaceComposerClient::setActiveColorMode(const sp<IBinder>& display,
-        ColorMode colorMode) {
+                                                   ColorMode colorMode) {
     binder::Status status = ComposerServiceAIDL::getComposerService()
                                     ->setActiveColorMode(display, static_cast<int>(colorMode));
     return statusTFromBinderStatus(status);
@@ -2835,8 +2949,7 @@ void SurfaceComposerClient::setGameContentType(const sp<IBinder>& display, bool
     ComposerServiceAIDL::getComposerService()->setGameContentType(display, on);
 }
 
-void SurfaceComposerClient::setDisplayPowerMode(const sp<IBinder>& token,
-        int mode) {
+void SurfaceComposerClient::setDisplayPowerMode(const sp<IBinder>& token, int mode) {
     ComposerServiceAIDL::getComposerService()->setPowerMode(token, mode);
 }
 
@@ -3007,6 +3120,20 @@ status_t SurfaceComposerClient::addRegionSamplingListener(
     return statusTFromBinderStatus(status);
 }
 
+status_t SurfaceComposerClient::addRegionSamplingListenerWithStopLayerId(
+        const Rect& samplingArea, const int32_t stopLayerId,
+        const sp<IRegionSamplingListener>& listener) {
+    gui::ARect rect;
+    rect.left = samplingArea.left;
+    rect.top = samplingArea.top;
+    rect.right = samplingArea.right;
+    rect.bottom = samplingArea.bottom;
+    binder::Status status =
+            ComposerServiceAIDL::getComposerService()
+                    ->addRegionSamplingListenerWithStopLayerId(rect, stopLayerId, listener);
+    return statusTFromBinderStatus(status);
+}
+
 status_t SurfaceComposerClient::removeRegionSamplingListener(
         const sp<IRegionSamplingListener>& listener) {
     binder::Status status =
@@ -3014,6 +3141,13 @@ status_t SurfaceComposerClient::removeRegionSamplingListener(
     return statusTFromBinderStatus(status);
 }
 
+status_t SurfaceComposerClient::getRegionSamplingListeners(
+        std::vector<gui::RegionSamplingDescriptor>* listeners) {
+    binder::Status status =
+            ComposerServiceAIDL::getComposerService()->getRegionSamplingListeners(listeners);
+    return statusTFromBinderStatus(status);
+}
+
 status_t SurfaceComposerClient::addFpsListener(int32_t taskId,
                                                const sp<gui::IFpsListener>& listener) {
     binder::Status status =
@@ -3119,14 +3253,14 @@ std::optional<DisplayDecorationSupport> SurfaceComposerClient::getDisplayDecorat
                                                                                    &gsupport);
     std::optional<DisplayDecorationSupport> support;
     if (status.isOk() && gsupport.has_value()) {
-        support.emplace(DisplayDecorationSupport{
-          .format =
-                static_cast<aidl::android::hardware::graphics::common::PixelFormat>(
-                gsupport->format),
-          .alphaInterpretation =
-                static_cast<aidl::android::hardware::graphics::common::AlphaInterpretation>(
-                        gsupport->alphaInterpretation)
-        });
+        support.emplace(
+                DisplayDecorationSupport{.format = static_cast<aidl::android::hardware::graphics::
+                                                                       common::PixelFormat>(
+                                                 gsupport->format),
+                                         .alphaInterpretation =
+                                                 static_cast<aidl::android::hardware::graphics::
+                                                                     common::AlphaInterpretation>(
+                                                         gsupport->alphaInterpretation)});
     }
     return support;
 }
@@ -3143,12 +3277,11 @@ int SurfaceComposerClient::getGpuContextPriority() {
     return priority;
 }
 
-status_t SurfaceComposerClient::addWindowInfosListener(
-        const sp<WindowInfosListener>& windowInfosListener,
-        std::pair<std::vector<gui::WindowInfo>, std::vector<gui::DisplayInfo>>* outInitialInfo) {
+android::base::Result<gui::WindowInfosUpdate> SurfaceComposerClient::addWindowInfosListener(
+        sp<WindowInfosListener> windowInfosListener) {
     return WindowInfosListenerReporter::getInstance()
-            ->addWindowInfosListener(windowInfosListener, ComposerServiceAIDL::getComposerService(),
-                                     outInitialInfo);
+            ->addWindowInfosListener(std::move(windowInfosListener),
+                                     ComposerServiceAIDL::getComposerService());
 }
 
 status_t SurfaceComposerClient::removeWindowInfosListener(
diff --git a/libs/gui/SurfaceControl.cpp b/libs/gui/SurfaceControl.cpp
index 1eb9b87c3c..a6a4ffa77e 100644
--- a/libs/gui/SurfaceControl.cpp
+++ b/libs/gui/SurfaceControl.cpp
@@ -147,6 +147,9 @@ sp<Surface> SurfaceControl::generateSurfaceLocked()
     // This surface is always consumed by SurfaceFlinger, so the
     // producerControlledByApp value doesn't matter; using false.
     mSurfaceData = mBbq->getSurface(true);
+    if (Surface::IsCursorPlaneCompatibilitySupported()) {
+        mSurfaceData->setIsForCursor(flags & ISurfaceComposerClient::eCursorWindow);
+    }
 
     return mSurfaceData;
 }
diff --git a/libs/gui/TransactionState.cpp b/libs/gui/TransactionState.cpp
index 9e09bc2644..98a891a248 100644
--- a/libs/gui/TransactionState.cpp
+++ b/libs/gui/TransactionState.cpp
@@ -16,6 +16,7 @@
 
 #define LOG_TAG "TransactionState"
 #include <gui/LayerState.h>
+#include <gui/SimpleTransactionState.h>
 #include <gui/SurfaceComposerClient.h>
 #include <gui/TransactionState.h>
 #include <private/gui/ParcelUtils.h>
@@ -23,53 +24,175 @@
 
 namespace android {
 
-status_t TransactionState::writeToParcel(Parcel* parcel) const {
+void SimpleTransactionState::clear() {
+    *this = SimpleTransactionState();
+}
+
+void SimpleTransactionState::merge(const SimpleTransactionState& other) {
+    // TODO(b/385156191) Consider merging desired present time.
+    mFlags |= other.mFlags;
+}
+
+status_t SimpleTransactionState::writeToParcel(Parcel* parcel) const {
     SAFE_PARCEL(parcel->writeUint64, mId);
     SAFE_PARCEL(parcel->writeUint32, mFlags);
     SAFE_PARCEL(parcel->writeInt64, mDesiredPresentTime);
     SAFE_PARCEL(parcel->writeBool, mIsAutoTimestamp);
-    SAFE_PARCEL(parcel->writeParcelable, mFrameTimelineInfo);
-    SAFE_PARCEL(parcel->writeStrongBinder, mApplyToken);
-    SAFE_PARCEL(parcel->writeBool, mMayContainBuffer);
-    SAFE_PARCEL(parcel->writeBool, mLogCallPoints);
 
-    SAFE_PARCEL(parcel->writeUint32, static_cast<uint32_t>(mDisplayStates.size()));
-    for (auto const& displayState : mDisplayStates) {
-        displayState.write(*parcel);
+    return NO_ERROR;
+}
+
+status_t SimpleTransactionState::readFromParcel(const Parcel* parcel) {
+    SAFE_PARCEL(parcel->readUint64, &mId);
+    SAFE_PARCEL(parcel->readUint32, &mFlags);
+    SAFE_PARCEL(parcel->readInt64, &mDesiredPresentTime);
+    SAFE_PARCEL(parcel->readBool, &mIsAutoTimestamp);
+
+    return NO_ERROR;
+}
+
+void TransactionListenerCallbacks::clear() {
+    *this = TransactionListenerCallbacks();
+}
+
+status_t TransactionListenerCallbacks::writeToParcel(Parcel* parcel) const {
+    SAFE_PARCEL(parcel->writeBool, mHasListenerCallbacks);
+    SAFE_PARCEL(parcel->writeUint32, static_cast<uint32_t>(mFlattenedListenerCallbacks.size()));
+    for (const auto& [listener, callbackIds] : mFlattenedListenerCallbacks) {
+        SAFE_PARCEL(parcel->writeStrongBinder, listener);
+        SAFE_PARCEL(parcel->writeParcelableVector, callbackIds);
     }
-    SAFE_PARCEL(parcel->writeUint32, static_cast<uint32_t>(mComposerStates.size()));
-    for (auto const& composerState : mComposerStates) {
-        composerState.write(*parcel);
+
+    return NO_ERROR;
+}
+
+status_t TransactionListenerCallbacks::readFromParcel(const Parcel* parcel) {
+    SAFE_PARCEL(parcel->readBool, &mHasListenerCallbacks);
+    uint32_t count;
+    SAFE_PARCEL_READ_SIZE(parcel->readUint32, &count, parcel->dataSize());
+    mFlattenedListenerCallbacks.clear();
+    mFlattenedListenerCallbacks.reserve(count);
+    for (uint32_t i = 0; i < count; i++) {
+        sp<IBinder> tmpBinder;
+        SAFE_PARCEL(parcel->readStrongBinder, &tmpBinder);
+        std::vector<CallbackId> callbackIds;
+        SAFE_PARCEL(parcel->readParcelableVector, &callbackIds);
+        mFlattenedListenerCallbacks.emplace_back(tmpBinder, callbackIds);
     }
 
-    mInputWindowCommands.write(*parcel);
+    return NO_ERROR;
+}
+
+status_t ComplexTransactionState::writeToParcel(Parcel* parcel) const {
+    SAFE_PARCEL(parcel->writeParcelable, mFrameTimelineInfo);
+
     SAFE_PARCEL(parcel->writeUint32, static_cast<uint32_t>(mUncacheBuffers.size()));
     for (const client_cache_t& uncacheBuffer : mUncacheBuffers) {
         SAFE_PARCEL(parcel->writeStrongBinder, uncacheBuffer.token.promote());
         SAFE_PARCEL(parcel->writeUint64, uncacheBuffer.id);
     }
 
-    SAFE_PARCEL(parcel->writeUint32, static_cast<uint32_t>(mMergedTransactionIds.size()));
-    for (auto mergedTransactionId : mMergedTransactionIds) {
-        SAFE_PARCEL(parcel->writeUint64, mergedTransactionId);
+    SAFE_PARCEL(parcel->writeUint64Vector, mMergedTransactionIds);
+    SAFE_PARCEL(mCallbacks.writeToParcel, parcel);
+    SAFE_PARCEL(mInputWindowCommands.write, *parcel);
+    SAFE_PARCEL(parcel->writeUint32, static_cast<uint32_t>(mEarlyWakeupInfos.size()));
+    for (const auto& e : mEarlyWakeupInfos) {
+        e.writeToParcel(parcel);
     }
 
-    SAFE_PARCEL(parcel->writeBool, mHasListenerCallbacks);
-    SAFE_PARCEL(parcel->writeUint32, static_cast<uint32_t>(mListenerCallbacks.size()));
-    for (const auto& [listener, callbackIds] : mListenerCallbacks) {
-        SAFE_PARCEL(parcel->writeStrongBinder, listener);
-        SAFE_PARCEL(parcel->writeParcelableVector, callbackIds);
+    return NO_ERROR;
+}
+
+status_t ComplexTransactionState::readFromParcel(const Parcel* parcel) {
+    SAFE_PARCEL(parcel->readParcelable, &mFrameTimelineInfo);
+
+    uint32_t count;
+    SAFE_PARCEL_READ_SIZE(parcel->readUint32, &count, parcel->dataSize())
+    mUncacheBuffers.clear();
+    mUncacheBuffers.reserve(count);
+    for (size_t i = 0; i < count; i++) {
+        client_cache_t client_cache;
+        sp<IBinder> tmpBinder;
+        SAFE_PARCEL(parcel->readStrongBinder, &tmpBinder);
+        client_cache.token = tmpBinder;
+        SAFE_PARCEL(parcel->readUint64, &client_cache.id);
+        mUncacheBuffers.emplace_back(std::move(client_cache));
+    }
+
+    SAFE_PARCEL(parcel->readUint64Vector, &mMergedTransactionIds);
+    SAFE_PARCEL(mCallbacks.readFromParcel, parcel);
+    SAFE_PARCEL(mInputWindowCommands.read, *parcel);
+    count = 0;
+    SAFE_PARCEL_READ_SIZE(parcel->readUint32, &count, parcel->dataSize());
+    std::vector<gui::EarlyWakeupInfo> earlyWakeupInfos;
+    earlyWakeupInfos.reserve(count);
+    for (size_t i = 0; i < count; i++) {
+        gui::EarlyWakeupInfo e;
+        e.readFromParcel(parcel);
+        earlyWakeupInfos.push_back(std::move(e));
+    }
+    mEarlyWakeupInfos = std::move(earlyWakeupInfos);
+
+    return NO_ERROR;
+}
+
+status_t MutableTransactionState::writeToParcel(Parcel* parcel) const {
+    SAFE_PARCEL(parcel->writeUint32, static_cast<uint32_t>(mComposerStates.size()));
+    for (const auto& s : mComposerStates) {
+        SAFE_PARCEL(s.write, *parcel);
+    }
+
+    SAFE_PARCEL(parcel->writeUint32, static_cast<uint32_t>(mDisplayStates.size()));
+    for (const auto& d : mDisplayStates) {
+        SAFE_PARCEL(d.write, *parcel);
+    }
+
+    return NO_ERROR;
+}
+
+status_t MutableTransactionState::readFromParcel(const Parcel* parcel) {
+    uint32_t count = 0;
+    SAFE_PARCEL_READ_SIZE(parcel->readUint32, &count, parcel->dataSize());
+    mComposerStates.setCapacity(count);
+    for (size_t i = 0; i < count; i++) {
+        ComposerState s;
+        SAFE_PARCEL(s.read, *parcel);
+        mComposerStates.add(s);
+    }
+
+    SAFE_PARCEL_READ_SIZE(parcel->readUint32, &count, parcel->dataSize());
+    DisplayState d;
+    mDisplayStates.setCapacity(count);
+    for (size_t i = 0; i < count; i++) {
+        SAFE_PARCEL(d.read, *parcel);
+        mDisplayStates.add(d);
+    }
+
+    return NO_ERROR;
+}
+
+status_t TransactionState::writeToParcel(Parcel* parcel) const {
+    SAFE_PARCEL(mSimpleState.writeToParcel, parcel);
+    SAFE_PARCEL(mComplexState.writeToParcel, parcel);
+    SAFE_PARCEL(parcel->writeStrongBinder, mApplyToken);
+    SAFE_PARCEL(parcel->writeBool, mMayContainBuffer);
+    SAFE_PARCEL(parcel->writeBool, mLogCallPoints);
+
+    SAFE_PARCEL(parcel->writeUint32, static_cast<uint32_t>(mDisplayStates.size()));
+    for (auto const& displayState : mDisplayStates) {
+        displayState.write(*parcel);
+    }
+    SAFE_PARCEL(parcel->writeUint32, static_cast<uint32_t>(mComposerStates.size()));
+    for (auto const& composerState : mComposerStates) {
+        composerState.write(*parcel);
     }
 
     return NO_ERROR;
 }
 
 status_t TransactionState::readFromParcel(const Parcel* parcel) {
-    SAFE_PARCEL(parcel->readUint64, &mId);
-    SAFE_PARCEL(parcel->readUint32, &mFlags);
-    SAFE_PARCEL(parcel->readInt64, &mDesiredPresentTime);
-    SAFE_PARCEL(parcel->readBool, &mIsAutoTimestamp);
-    SAFE_PARCEL(parcel->readParcelable, &mFrameTimelineInfo);
+    SAFE_PARCEL(mSimpleState.readFromParcel, parcel);
+    SAFE_PARCEL(mComplexState.readFromParcel, parcel);
     SAFE_PARCEL(parcel->readNullableStrongBinder, &mApplyToken);
     SAFE_PARCEL(parcel->readBool, &mMayContainBuffer);
     SAFE_PARCEL(parcel->readBool, &mLogCallPoints);
@@ -97,46 +220,10 @@ status_t TransactionState::readFromParcel(const Parcel* parcel) {
         mComposerStates.emplace_back(std::move(composerState));
     }
 
-    if (status_t status = mInputWindowCommands.read(*parcel) != NO_ERROR) {
-        return status;
-    }
-
-    SAFE_PARCEL_READ_SIZE(parcel->readUint32, &count, parcel->dataSize())
-    mUncacheBuffers.clear();
-    mUncacheBuffers.reserve(count);
-    for (size_t i = 0; i < count; i++) {
-        client_cache_t client_cache;
-        sp<IBinder> tmpBinder;
-        SAFE_PARCEL(parcel->readStrongBinder, &tmpBinder);
-        client_cache.token = tmpBinder;
-        SAFE_PARCEL(parcel->readUint64, &client_cache.id);
-        mUncacheBuffers.emplace_back(std::move(client_cache));
-    }
-
-    SAFE_PARCEL_READ_SIZE(parcel->readUint32, &count, parcel->dataSize())
-    mMergedTransactionIds.clear();
-    mMergedTransactionIds.resize(count);
-    for (size_t i = 0; i < count; i++) {
-        SAFE_PARCEL(parcel->readUint64, &mMergedTransactionIds[i]);
-    }
-
-    SAFE_PARCEL(parcel->readBool, &mHasListenerCallbacks);
-    SAFE_PARCEL_READ_SIZE(parcel->readUint32, &count, parcel->dataSize());
-    mListenerCallbacks.clear();
-    mListenerCallbacks.reserve(count);
-    for (uint32_t i = 0; i < count; i++) {
-        sp<IBinder> tmpBinder;
-        SAFE_PARCEL(parcel->readStrongBinder, &tmpBinder);
-        std::vector<CallbackId> callbackIds;
-        SAFE_PARCEL(parcel->readParcelableVector, &callbackIds);
-        mListenerCallbacks.emplace_back(tmpBinder, callbackIds);
-    }
-
     return NO_ERROR;
 }
 
-void TransactionState::merge(TransactionState&& other,
-                             const std::function<void(layer_state_t&)>& onBufferOverwrite) {
+void ComplexTransactionState::merge(ComplexTransactionState& other) {
     while (mMergedTransactionIds.size() + other.mMergedTransactionIds.size() >
                    MAX_MERGE_HISTORY_LENGTH - 1 &&
            mMergedTransactionIds.size() > 0) {
@@ -151,8 +238,23 @@ void TransactionState::merge(TransactionState&& other,
                                      other.mMergedTransactionIds.begin(),
                                      other.mMergedTransactionIds.end());
     }
-    mMergedTransactionIds.insert(mMergedTransactionIds.begin(), other.mId);
 
+    for (auto& cacheId : other.mUncacheBuffers) {
+        mUncacheBuffers.emplace_back(std::move(cacheId));
+    }
+
+    mergeFrameTimelineInfo(other.mFrameTimelineInfo);
+
+    mInputWindowCommands.merge(other.mInputWindowCommands);
+
+    for (gui::EarlyWakeupInfo& op : other.mEarlyWakeupInfos) {
+        mEarlyWakeupInfos.emplace_back(std::move(op));
+    }
+}
+
+void MutableTransactionState::merge(
+        const MutableTransactionState& other,
+        const std::function<void(const layer_state_t&)>& onBufferOverwrite) {
     for (auto const& otherState : other.mComposerStates) {
         if (auto it = std::find_if(mComposerStates.begin(), mComposerStates.end(),
                                    [&otherState](const auto& composerState) {
@@ -165,7 +267,7 @@ void TransactionState::merge(TransactionState&& other,
             }
             it->state.merge(otherState.state);
         } else {
-            mComposerStates.push_back(otherState);
+            mComposerStates.add(otherState);
         }
     }
 
@@ -177,28 +279,56 @@ void TransactionState::merge(TransactionState&& other,
             it != mDisplayStates.end()) {
             it->merge(state);
         } else {
-            mDisplayStates.push_back(state);
+            mDisplayStates.add(state);
         }
     }
+}
+
+void TransactionState::merge(TransactionState&& other,
+                             const std::function<void(layer_state_t&)>& onBufferOverwrite) {
+    mSimpleState.merge(other.mSimpleState);
+    mComplexState.merge(other.mComplexState);
+    mComplexState.mMergedTransactionIds.insert(mComplexState.mMergedTransactionIds.begin(),
+                                               other.mSimpleState.mId);
 
-    for (const auto& cacheId : other.mUncacheBuffers) {
-        mUncacheBuffers.push_back(cacheId);
+    for (auto const& otherState : other.mComposerStates) {
+        if (auto it = std::find_if(mComposerStates.begin(), mComposerStates.end(),
+                                   [&otherState](const auto& composerState) {
+                                       return composerState.state.surface ==
+                                               otherState.state.surface;
+                                   });
+            it != mComposerStates.end()) {
+            if (otherState.state.what & layer_state_t::eBufferChanged) {
+                onBufferOverwrite(it->state);
+            }
+            it->state.merge(otherState.state);
+        } else {
+            mComposerStates.push_back(otherState);
+        }
+    }
+
+    for (auto const& state : other.mDisplayStates) {
+        if (auto it = std::find_if(mDisplayStates.begin(), mDisplayStates.end(),
+                                   [&state](const auto& displayState) {
+                                       return displayState.token == state.token;
+                                   });
+            it != mDisplayStates.end()) {
+            it->merge(state);
+        } else {
+            mDisplayStates.push_back(state);
+        }
     }
 
-    mInputWindowCommands.merge(other.mInputWindowCommands);
-    // TODO(b/385156191) Consider merging desired present time.
-    mFlags |= other.mFlags;
     mMayContainBuffer |= other.mMayContainBuffer;
     mLogCallPoints |= other.mLogCallPoints;
 
     // mApplyToken is explicitly not merged. Token should be set before applying the transactions to
     // make synchronization decisions a bit simpler.
-    mergeFrameTimelineInfo(other.mFrameTimelineInfo);
     other.clear();
 }
 
 // copied from FrameTimelineInfo::merge()
-void TransactionState::mergeFrameTimelineInfo(const FrameTimelineInfo& other) {
+void ComplexTransactionState::mergeFrameTimelineInfo(const FrameTimelineInfo& other) {
     // When merging vsync Ids we take the oldest valid one
     if (mFrameTimelineInfo.vsyncId != FrameTimelineInfo::INVALID_VSYNC_ID &&
         other.vsyncId != FrameTimelineInfo::INVALID_VSYNC_ID) {
@@ -210,23 +340,49 @@ void TransactionState::mergeFrameTimelineInfo(const FrameTimelineInfo& other) {
     }
 }
 
+void ComplexTransactionState::clear() {
+    mCallbacks.clear();
+    mUncacheBuffers.clear();
+    mFrameTimelineInfo = {};
+    mMergedTransactionIds.clear();
+    mInputWindowCommands.clear();
+    mEarlyWakeupInfos.clear();
+}
+
+void MutableTransactionState::clear() {
+    mComposerStates.clear();
+    mDisplayStates.clear();
+}
+
 void TransactionState::clear() {
+    mSimpleState.clear();
+    mComplexState.clear();
     mComposerStates.clear();
     mDisplayStates.clear();
-    mListenerCallbacks.clear();
-    mHasListenerCallbacks = false;
-    mInputWindowCommands.clear();
-    mUncacheBuffers.clear();
-    mDesiredPresentTime = 0;
-    mIsAutoTimestamp = true;
     mApplyToken = nullptr;
-    mFrameTimelineInfo = {};
-    mMergedTransactionIds.clear();
-    mFlags = 0;
     mMayContainBuffer = false;
     mLogCallPoints = false;
 }
 
+layer_state_t* MutableTransactionState::getLayerState(const sp<SurfaceControl>& sc) {
+    auto handle = sc->getLayerStateHandle();
+    if (auto it = std::find_if(mComposerStates.begin(), mComposerStates.end(),
+                               [&handle](const auto& composerState) {
+                                   return composerState.state.surface == handle;
+                               });
+        it != mComposerStates.end()) {
+        return &it->state;
+    }
+
+    // we don't have it, add an initialized layer_state to our list
+    ComposerState s;
+    s.state.surface = handle;
+    s.state.layerId = sc->getLayerId();
+    mComposerStates.add(s);
+
+    return &mComposerStates.editItemAt(mComposerStates.size() - 1).state;
+}
+
 layer_state_t* TransactionState::getLayerState(const sp<SurfaceControl>& sc) {
     auto handle = sc->getLayerStateHandle();
     if (auto it = std::find_if(mComposerStates.begin(), mComposerStates.end(),
@@ -246,6 +402,20 @@ layer_state_t* TransactionState::getLayerState(const sp<SurfaceControl>& sc) {
     return &mComposerStates.back().state;
 }
 
+DisplayState& MutableTransactionState::getDisplayState(const sp<IBinder>& token) {
+    if (auto it = std::find_if(mDisplayStates.begin(), mDisplayStates.end(),
+                               [token](const auto& display) { return display.token == token; });
+        it != mDisplayStates.end()) {
+        return *it;
+    }
+
+    // If display state doesn't exist, add a new one.
+    DisplayState s;
+    s.token = token;
+    mDisplayStates.add(s);
+    return mDisplayStates.editItemAt(mDisplayStates.size() - 1);
+}
+
 DisplayState& TransactionState::getDisplayState(const sp<IBinder>& token) {
     if (auto it = std::find_if(mDisplayStates.begin(), mDisplayStates.end(),
                                [token](const auto& display) { return display.token == token; });
diff --git a/libs/gui/WindowInfosListenerReporter.cpp b/libs/gui/WindowInfosListenerReporter.cpp
index d633f9f15e..eed9d41467 100644
--- a/libs/gui/WindowInfosListenerReporter.cpp
+++ b/libs/gui/WindowInfosListenerReporter.cpp
@@ -14,6 +14,7 @@
  * limitations under the License.
  */
 
+#include <android-base/logging.h>
 #include <android/gui/ISurfaceComposer.h>
 #include <android/gui/IWindowInfosListener.h>
 #include <gui/AidlUtil.h>
@@ -32,84 +33,68 @@ sp<WindowInfosListenerReporter> WindowInfosListenerReporter::getInstance() {
     return sInstance;
 }
 
-status_t WindowInfosListenerReporter::addWindowInfosListener(
-        const sp<WindowInfosListener>& windowInfosListener,
-        const sp<gui::ISurfaceComposer>& surfaceComposer,
-        std::pair<std::vector<gui::WindowInfo>, std::vector<gui::DisplayInfo>>* outInitialInfo) {
-    status_t status = OK;
-    {
-        std::scoped_lock lock(mListenersMutex);
-        if (mWindowInfosListeners.empty()) {
-            gui::WindowInfosListenerInfo listenerInfo;
-            binder::Status s = surfaceComposer->addWindowInfosListener(this, &listenerInfo);
-            status = statusTFromBinderStatus(s);
-            if (status == OK) {
-                mWindowInfosPublisher = std::move(listenerInfo.windowInfosPublisher);
-                mListenerId = listenerInfo.listenerId;
-            }
-        }
-
-        if (status == OK) {
-            mWindowInfosListeners.insert(windowInfosListener);
-        }
+android::base::Result<gui::WindowInfosUpdate> WindowInfosListenerReporter::addWindowInfosListener(
+        sp<WindowInfosListener> windowInfosListener,
+        const sp<gui::ISurfaceComposer>& surfaceComposer) {
+    std::scoped_lock lock(mListenersMutex);
+    if (mWindowInfosListeners.empty()) {
+        gui::WindowInfosListenerInfo listenerInfo;
+        binder::Status status = surfaceComposer->addWindowInfosListener(this, &listenerInfo);
+        LOG_IF(FATAL, !status.isOk()) << "Can't register window infos listener for pid " << getpid()
+                                      << ". Device won't be usable";
 
-        if (outInitialInfo != nullptr) {
-            outInitialInfo->first = mLastWindowInfos;
-            outInitialInfo->second = mLastDisplayInfos;
-        }
+        mWindowInfosPublisher = std::move(listenerInfo.windowInfosPublisher);
+        mListenerId = listenerInfo.listenerId;
     }
+    mWindowInfosListeners.emplace(std::move(windowInfosListener));
 
-    return status;
+    return mLastUpdate;
 }
 
 status_t WindowInfosListenerReporter::removeWindowInfosListener(
         const sp<WindowInfosListener>& windowInfosListener,
         const sp<gui::ISurfaceComposer>& surfaceComposer) {
-    status_t status = OK;
-    {
-        std::scoped_lock lock(mListenersMutex);
-        if (mWindowInfosListeners.find(windowInfosListener) == mWindowInfosListeners.end()) {
-            return status;
-        }
-
-        if (mWindowInfosListeners.size() == 1) {
-            binder::Status s = surfaceComposer->removeWindowInfosListener(this);
-            status = statusTFromBinderStatus(s);
-            // Clear the last stored state since we're disabling updates and don't want to hold
-            // stale values
-            mLastWindowInfos.clear();
-            mLastDisplayInfos.clear();
-        }
+    std::scoped_lock lock(mListenersMutex);
+    mWindowInfosListeners.erase(windowInfosListener);
+    if (!mWindowInfosListeners.empty()) {
+        return OK;
+    }
 
-        if (status == OK) {
-            mWindowInfosListeners.erase(windowInfosListener);
-        }
+    if (binder::Status status = surfaceComposer->removeWindowInfosListener(this); !status.isOk()) {
+        ALOGW("Failed to remove window infos listener from SurfaceFlinger");
+        return statusTFromBinderStatus(status);
     }
 
-    return status;
+    // Clear the last stored state since we're disabling updates and don't want to hold
+    // stale values
+    mLastUpdate = gui::WindowInfosUpdate();
+    mWindowInfosPublisher.clear();
+    mListenerId = UNASSIGNED_LISTENER_ID;
+
+    return OK;
 }
 
 binder::Status WindowInfosListenerReporter::onWindowInfosChanged(
         const gui::WindowInfosUpdate& update) {
-    std::unordered_set<sp<WindowInfosListener>, gui::SpHash<WindowInfosListener>>
-            windowInfosListeners;
-
+    ListenerSet listeners;
+    int64_t id;
+    sp<gui::IWindowInfosPublisher> publisher;
     {
         std::scoped_lock lock(mListenersMutex);
-        for (auto listener : mWindowInfosListeners) {
-            windowInfosListeners.insert(listener);
-        }
-
-        mLastWindowInfos = update.windowInfos;
-        mLastDisplayInfos = update.displayInfos;
+        listeners = mWindowInfosListeners;
+        publisher = mWindowInfosPublisher;
+        id = mListenerId;
+        mLastUpdate = update;
     }
-
-    for (auto listener : windowInfosListeners) {
+    // Publisher may be null if we've removed the last window infos listener before handling all
+    // in-flight onWindowInfosChanged calls.
+    if (!publisher) {
+        return binder::Status::ok();
+    }
+    for (auto listener : listeners) {
         listener->onWindowInfosChanged(update);
     }
-
-    mWindowInfosPublisher->ackWindowInfosReceived(update.vsyncId, mListenerId);
-
+    publisher->ackWindowInfosReceived(update.vsyncId, id);
     return binder::Status::ok();
 }
 
diff --git a/libs/gui/aidl/android/gui/ISurfaceComposer.aidl b/libs/gui/aidl/android/gui/ISurfaceComposer.aidl
index 9b2f089665..37544a06e5 100644
--- a/libs/gui/aidl/android/gui/ISurfaceComposer.aidl
+++ b/libs/gui/aidl/android/gui/ISurfaceComposer.aidl
@@ -47,6 +47,7 @@ import android.gui.IJankListener;
 import android.gui.LayerCaptureArgs;
 import android.gui.OverlayProperties;
 import android.gui.PullAtomData;
+import android.gui.RegionSamplingDescriptor;
 import android.gui.ScreenCaptureResults;
 import android.gui.ARect;
 import android.gui.SchedulingPolicy;
@@ -350,19 +351,42 @@ interface ISurfaceComposer {
      * The sampling area is bounded by both samplingArea and the given stopLayerHandle
      * (i.e., only layers behind the stop layer will be captured and sampled).
      *
-     * Multiple listeners may be provided so long as they have independent listeners.
-     * If multiple listeners are provided, the effective sampling region for each listener will
-     * be bounded by whichever stop layer has a lower Z value.
+     * Multiple listeners for the same sampling region may be provided so long as they have
+     * independent IRegionSamplingListener objects. If multiple listeners are provided, the
+     * effective sampling region for each listener will be bounded by whichever stop layer has
+     * a lower Z-value.
      *
      * Requires the same permissions as captureLayers and captureScreen.
      */
     void addRegionSamplingListener(in ARect samplingArea, @nullable IBinder stopLayerHandle, IRegionSamplingListener listener);
 
+    /**
+     * Registers a listener by stopLayerId to stream median luma updates from SurfaceFlinger.
+     *
+     * The sampling area is bounded by both samplingArea and the given stopLayerId
+     * (i.e., only layers behind the stop layer will be captured and sampled).
+     *
+     * Multiple listeners for the same sampling region may be provided so long as they have
+     * independent IRegionSamplingListener objects. If multiple listeners are provided, the
+     * effective sampling region for each listener will be bounded by whichever stop layer has
+     * a lower Z-value.
+     *
+     * Requires the ACCESS_SURFACE_FLINGER permission.
+     */
+    void addRegionSamplingListenerWithStopLayerId(in ARect samplingArea, int stopLayerId, IRegionSamplingListener listener);
+
     /**
      * Removes a listener that was streaming median luma updates from SurfaceFlinger.
      */
     void removeRegionSamplingListener(IRegionSamplingListener listener);
 
+    /**
+     * Gets all listeners that are streaming median luma updates from SurfaceFlinger.
+     *
+     * Requires the ACCESS_SURFACE_FLINGER permission.
+     */
+    List<RegionSamplingDescriptor> getRegionSamplingListeners();
+
     /**
      * Registers a listener that streams fps updates from SurfaceFlinger.
      *
@@ -479,7 +503,7 @@ interface ISurfaceComposer {
      * lightRadius
      *      Radius of the light casting the shadow.
      */
-    oneway void setGlobalShadowSettings(in Color ambientColor, in Color spotColor, float lightPosY, float lightPosZ, float lightRadius);
+    void setGlobalShadowSettings(in Color ambientColor, in Color spotColor, float lightPosY, float lightPosZ, float lightRadius);
 
     /**
      * Gets whether a display supports DISPLAY_DECORATION layers.
diff --git a/libs/gui/aidl/android/gui/ISurfaceComposerClient.aidl b/libs/gui/aidl/android/gui/ISurfaceComposerClient.aidl
index 920257c449..edbacf634e 100644
--- a/libs/gui/aidl/android/gui/ISurfaceComposerClient.aidl
+++ b/libs/gui/aidl/android/gui/ISurfaceComposerClient.aidl
@@ -58,7 +58,7 @@ interface ISurfaceComposerClient {
      */
     FrameStats getLayerFrameStats(IBinder handle);
 
-    CreateSurfaceResult mirrorSurface(IBinder mirrorFromHandle);
+    CreateSurfaceResult mirrorSurface(IBinder mirrorFromHandle, @nullable IBinder stopAtHandle);
 
     CreateSurfaceResult mirrorDisplay(long displayId);
 
diff --git a/libs/gui/aidl/android/gui/RegionSamplingDescriptor.aidl b/libs/gui/aidl/android/gui/RegionSamplingDescriptor.aidl
new file mode 100644
index 0000000000..2950038d6c
--- /dev/null
+++ b/libs/gui/aidl/android/gui/RegionSamplingDescriptor.aidl
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+ package android.gui;
+
+ import android.gui.ARect;
+ import android.gui.IRegionSamplingListener;
+
+ /** @hide */
+parcelable RegionSamplingDescriptor {
+    // Sampling area region
+    ARect area;
+
+    // All layers under this layer ID will be sampled from
+    int stopLayerId;
+
+    // Listener receiving median luma notifications
+    IRegionSamplingListener listener;
+}
diff --git a/libs/gui/aidl/android/gui/StaticDisplayInfo.aidl b/libs/gui/aidl/android/gui/StaticDisplayInfo.aidl
index 7ff332c29e..6a44744f82 100644
--- a/libs/gui/aidl/android/gui/StaticDisplayInfo.aidl
+++ b/libs/gui/aidl/android/gui/StaticDisplayInfo.aidl
@@ -28,4 +28,6 @@ parcelable StaticDisplayInfo {
     boolean secure;
     @nullable DeviceProductInfo deviceProductInfo;
     Rotation installOrientation = Rotation.Rotation0;
+    /* this comes from composer HAL's screenPartStatus.aidl file */
+    int screenPartStatus;
 }
diff --git a/libs/gui/android/gui/BoxShadowSettings.aidl b/libs/gui/android/gui/BoxShadowSettings.aidl
new file mode 100644
index 0000000000..59364ae65a
--- /dev/null
+++ b/libs/gui/android/gui/BoxShadowSettings.aidl
@@ -0,0 +1,32 @@
+/**
+ * Copyright (c) 2025, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.gui;
+
+/** @hide */
+parcelable BoxShadowSettings {
+    parcelable BoxShadowParams
+    {
+        float blurRadius;
+        float spreadRadius;
+        // Space is sRGB, not premultiplied, bit pattern is 0xAARRGGBB.
+        int color;
+        float offsetX;
+        float offsetY;
+    }
+
+    BoxShadowParams []boxShadows = {};
+}
diff --git a/libs/gui/android/gui/EarlyWakeupInfo.aidl b/libs/gui/android/gui/EarlyWakeupInfo.aidl
new file mode 100644
index 0000000000..3c46417356
--- /dev/null
+++ b/libs/gui/android/gui/EarlyWakeupInfo.aidl
@@ -0,0 +1,26 @@
+/**
+ * Copyright (c) 2025, The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.gui;
+
+import android.os.IBinder;
+
+/** @hide */
+parcelable EarlyWakeupInfo {
+    @nullable IBinder token;
+    @utf8InCpp String trace;
+    boolean isStartRequest;
+}
diff --git a/libs/gui/include/gui/BLASTBufferQueue.h b/libs/gui/include/gui/BLASTBufferQueue.h
index c69b0a79ad..63fde1e4a4 100644
--- a/libs/gui/include/gui/BLASTBufferQueue.h
+++ b/libs/gui/include/gui/BLASTBufferQueue.h
@@ -43,6 +43,7 @@ constexpr size_t kDequeueTimestampsMapSizeHint = 32;
 
 class BLASTBufferQueue;
 class BufferItemConsumer;
+class BufferReleaseReader;
 
 class BLASTBufferItemConsumer : public BufferItemConsumer {
 public:
@@ -60,26 +61,17 @@ public:
 
 protected:
     void onSidebandStreamChanged() override EXCLUDES(mMutex);
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(BQ_SETFRAMERATE)
     void onSetFrameRate(float frameRate, int8_t compatibility,
                         int8_t changeFrameRateStrategy) override;
-#endif
 
 private:
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
     BLASTBufferItemConsumer(const sp<IGraphicBufferProducer>& producer,
                             const sp<IGraphicBufferConsumer>& consumer, uint64_t consumerUsage,
                             int bufferCount, bool controlledByApp, wp<BLASTBufferQueue> bbq)
           : BufferItemConsumer(producer, consumer, consumerUsage, bufferCount, controlledByApp),
-#else
-    BLASTBufferItemConsumer(const sp<IGraphicBufferConsumer>& consumer, uint64_t consumerUsage,
-                            int bufferCount, bool controlledByApp, wp<BLASTBufferQueue> bbq)
-          : BufferItemConsumer(consumer, consumerUsage, bufferCount, controlledByApp),
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
             mBLASTBufferQueue(std::move(bbq)),
             mCurrentlyConnected(false),
-            mPreviouslyConnected(false) {
-    }
+            mPreviouslyConnected(false) {}
 
     friend class sp<BLASTBufferItemConsumer>;
 
@@ -155,7 +147,7 @@ public:
 
     virtual ~BLASTBufferQueue();
 
-    void onFirstRef() override;
+    void onFirstRef() override final;
 
 private:
     // Not public to ensure construction via sp<>::make().
@@ -175,6 +167,7 @@ private:
     void createBufferQueue(sp<IGraphicBufferProducer>* outProducer,
                            sp<IGraphicBufferConsumer>* outConsumer);
 
+    void initialize();
     void resizeFrameEventHistory(size_t newSize);
 
     status_t acquireNextBufferLocked(
@@ -284,7 +277,7 @@ private:
     std::function<void(SurfaceComposerClient::Transaction*)> mTransactionReadyCallback
             GUARDED_BY(mMutex);
     SurfaceComposerClient::Transaction* mSyncTransaction GUARDED_BY(mMutex);
-    std::vector<std::pair<uint64_t /* framenumber */, SurfaceComposerClient::Transaction>>
+    std::vector<std::tuple<uint64_t /* framenumber */, SurfaceComposerClient::Transaction>>
             mPendingTransactions GUARDED_BY(mMutex);
 
     std::queue<std::pair<uint64_t, FrameTimelineInfo>> mPendingFrameTimelines GUARDED_BY(mMutex);
@@ -344,45 +337,12 @@ private:
 #if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(BUFFER_RELEASE_CHANNEL)
     // BufferReleaseChannel is used to communicate buffer releases from SurfaceFlinger to the
     // client.
-    std::unique_ptr<gui::BufferReleaseChannel::ConsumerEndpoint> mBufferReleaseConsumer;
     std::shared_ptr<gui::BufferReleaseChannel::ProducerEndpoint> mBufferReleaseProducer;
 
     void updateBufferReleaseProducer() REQUIRES(mMutex);
     void drainBufferReleaseConsumer();
 
-    // BufferReleaseReader is used to do blocking but interruptible reads from the buffer
-    // release channel. To implement this, BufferReleaseReader owns an epoll file descriptor that
-    // is configured to wake up when either the BufferReleaseReader::ConsumerEndpoint or an eventfd
-    // becomes readable. Interrupts are necessary because a free buffer may become available for
-    // reasons other than a buffer release from the producer.
-    class BufferReleaseReader {
-    public:
-        explicit BufferReleaseReader(BLASTBufferQueue&);
-
-        BufferReleaseReader(const BufferReleaseReader&) = delete;
-        BufferReleaseReader& operator=(const BufferReleaseReader&) = delete;
-
-        // Block until we can read a buffer release message.
-        //
-        // Returns:
-        // * OK if a ReleaseCallbackId and Fence were successfully read.
-        // * WOULD_BLOCK if the blocking read was interrupted by interruptBlockingRead.
-        // * TIMED_OUT if the blocking read timed out.
-        // * UNKNOWN_ERROR if something went wrong.
-        status_t readBlocking(ReleaseCallbackId& outId, sp<Fence>& outReleaseFence,
-                              uint32_t& outMaxAcquiredBufferCount, nsecs_t timeout);
-
-        void interruptBlockingRead();
-        void clearInterrupts();
-
-    private:
-        BLASTBufferQueue& mBbq;
-
-        android::base::unique_fd mEpollFd;
-        android::base::unique_fd mEventFd;
-    };
-
-    std::optional<BufferReleaseReader> mBufferReleaseReader;
+    std::shared_ptr<BufferReleaseReader> mBufferReleaseReader;
 #endif
 };
 
diff --git a/libs/gui/include/gui/BufferItemConsumer.h b/libs/gui/include/gui/BufferItemConsumer.h
index fc31f4636c..de94b04603 100644
--- a/libs/gui/include/gui/BufferItemConsumer.h
+++ b/libs/gui/include/gui/BufferItemConsumer.h
@@ -47,6 +47,12 @@ class BufferItemConsumer: public ConsumerBase
     enum { INVALID_BUFFER_SLOT = BufferQueue::INVALID_BUFFER_SLOT };
     enum { NO_BUFFER_AVAILABLE = BufferQueue::NO_BUFFER_AVAILABLE };
 
+    // Create a new buffer item consumer. The consumerUsage parameter determines
+    // the consumer usage flags passed to the graphics allocator. The
+    // bufferCount parameter specifies how many buffers can be locked for user
+    // access at the same time.
+    // controlledByApp tells whether this consumer is controlled by the
+    // application.
     static std::tuple<sp<BufferItemConsumer>, sp<Surface>> create(
             uint64_t consumerUsage, int bufferCount = DEFAULT_MAX_BUFFERS,
             bool controlledByApp = false, bool isConsumerSurfaceFlinger = false);
@@ -57,24 +63,6 @@ class BufferItemConsumer: public ConsumerBase
                                          bool controlledByApp = false)
             __attribute((deprecated("Prefer ctors that create their own surface and consumer.")));
 
-    // Create a new buffer item consumer. The consumerUsage parameter determines
-    // the consumer usage flags passed to the graphics allocator. The
-    // bufferCount parameter specifies how many buffers can be locked for user
-    // access at the same time.
-    // controlledByApp tells whether this consumer is controlled by the
-    // application.
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
-    BufferItemConsumer(uint64_t consumerUsage, int bufferCount = DEFAULT_MAX_BUFFERS,
-                       bool controlledByApp = false, bool isConsumerSurfaceFlinger = false);
-    BufferItemConsumer(const sp<IGraphicBufferConsumer>& consumer, uint64_t consumerUsage,
-                       int bufferCount = DEFAULT_MAX_BUFFERS, bool controlledByApp = false)
-            __attribute((deprecated("Prefer ctors that create their own surface and consumer.")));
-#else
-    BufferItemConsumer(const sp<IGraphicBufferConsumer>& consumer,
-            uint64_t consumerUsage, int bufferCount = DEFAULT_MAX_BUFFERS,
-            bool controlledByApp = false);
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
-
     ~BufferItemConsumer() override;
 
     // setBufferFreedListener sets the listener object that will be notified
@@ -117,14 +105,20 @@ class BufferItemConsumer: public ConsumerBase
                            const sp<Fence>& releaseFence = Fence::NO_FENCE);
 
 protected:
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
     // This should only be used by BLASTBufferQueue:
     BufferItemConsumer(const sp<IGraphicBufferProducer>& producer,
                        const sp<IGraphicBufferConsumer>& consumer, uint64_t consumerUsage,
                        int bufferCount = DEFAULT_MAX_BUFFERS, bool controlledByApp = false);
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
+
+    BufferItemConsumer(uint64_t consumerUsage, int bufferCount = DEFAULT_MAX_BUFFERS,
+                       bool controlledByApp = false, bool isConsumerSurfaceFlinger = false);
+    BufferItemConsumer(const sp<IGraphicBufferConsumer>& consumer, uint64_t consumerUsage,
+                       int bufferCount = DEFAULT_MAX_BUFFERS, bool controlledByApp = false)
+            __attribute((deprecated("Prefer ctors that create their own surface and consumer.")));
 
 private:
+    friend sp<BufferItemConsumer>;
+
     void initialize(uint64_t consumerUsage, int bufferCount);
 
     status_t releaseBufferSlotLocked(int slotIndex, const sp<GraphicBuffer>& buffer,
diff --git a/libs/gui/include/gui/BufferQueue.h b/libs/gui/include/gui/BufferQueue.h
index 7b97e13649..b26d78460c 100644
--- a/libs/gui/include/gui/BufferQueue.h
+++ b/libs/gui/include/gui/BufferQueue.h
@@ -72,10 +72,8 @@ public:
         void addAndGetFrameTimestamps(
                 const NewFrameEventsEntry* newTimestamps,
                 FrameEventHistoryDelta* outDelta) override;
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(BQ_SETFRAMERATE)
         void onSetFrameRate(float frameRate, int8_t compatibility,
                             int8_t changeFrameRateStrategy) override;
-#endif
 #if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_UNLIMITED_SLOTS)
         void onSlotCountChanged(int slotCount) override;
 #endif
diff --git a/libs/gui/include/gui/BufferQueueCore.h b/libs/gui/include/gui/BufferQueueCore.h
index 7f92a46053..95c552a244 100644
--- a/libs/gui/include/gui/BufferQueueCore.h
+++ b/libs/gui/include/gui/BufferQueueCore.h
@@ -51,11 +51,17 @@ namespace android {
 
 class IConsumerListener;
 class IProducerListener;
+#ifdef ENABLE_BQC_TESTING
+class MockBufferQueueCore;
+#endif
 
 class BufferQueueCore : public virtual RefBase {
 
     friend class BufferQueueProducer;
     friend class BufferQueueConsumer;
+#ifdef ENABLE_BQC_TESTING
+    friend class TestableBufferQueueCore;
+#endif
 
 public:
     // Used as a placeholder slot number when the value isn't pointing to an
diff --git a/libs/gui/include/gui/BufferQueueProducer.h b/libs/gui/include/gui/BufferQueueProducer.h
index 6a1e9f6f03..2491cd93bc 100644
--- a/libs/gui/include/gui/BufferQueueProducer.h
+++ b/libs/gui/include/gui/BufferQueueProducer.h
@@ -206,11 +206,9 @@ public:
 
     // See IGraphicBufferProducer::setAutoPrerotation
     virtual status_t setAutoPrerotation(bool autoPrerotation);
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(BQ_SETFRAMERATE)
     // See IGraphicBufferProducer::setFrameRate
     status_t setFrameRate(float frameRate, int8_t compatibility,
                           int8_t changeFrameRateStrategy) override;
-#endif
 
 #if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(BQ_EXTENDEDALLOCATE)
     status_t setAdditionalOptions(const std::vector<gui::AdditionalOptions>& options) override;
diff --git a/libs/gui/include/gui/Choreographer.h b/libs/gui/include/gui/Choreographer.h
index c632098fb9..091010f569 100644
--- a/libs/gui/include/gui/Choreographer.h
+++ b/libs/gui/include/gui/Choreographer.h
@@ -121,8 +121,13 @@ private:
                            nsecs_t timestamp);
     void dispatchHotplug(nsecs_t timestamp, PhysicalDisplayId displayId, bool connected) override;
     void dispatchHotplugConnectionError(nsecs_t timestamp, int32_t connectionError) override;
+    void dispatchModeChangedWithFrameRateOverrides(
+            nsecs_t timestamp, PhysicalDisplayId displayId, int32_t modeId, nsecs_t vsyncPeriod,
+            nsecs_t appVsyncOffset, nsecs_t presentationDeadline,
+            std::vector<FrameRateOverride> overrides) override;
     void dispatchModeChanged(nsecs_t timestamp, PhysicalDisplayId displayId, int32_t modeId,
-                             nsecs_t vsyncPeriod) override;
+                             nsecs_t vsyncPeriod, nsecs_t appVsyncOffset,
+                             nsecs_t presentationDeadline) override;
     void dispatchNullEvent(nsecs_t, PhysicalDisplayId) override;
     void dispatchFrameRateOverrides(nsecs_t timestamp, PhysicalDisplayId displayId,
                                     std::vector<FrameRateOverride> overrides) override;
diff --git a/libs/gui/include/gui/ConsumerBase.h b/libs/gui/include/gui/ConsumerBase.h
index 63c1ef3132..aaae196c49 100644
--- a/libs/gui/include/gui/ConsumerBase.h
+++ b/libs/gui/include/gui/ConsumerBase.h
@@ -75,7 +75,6 @@ public:
     void dumpState(String8& result) const;
     void dumpState(String8& result, const char* prefix) const;
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
     // Returns a Surface that can be used as the producer for this consumer.
     sp<Surface> getSurface() const;
 
@@ -83,7 +82,6 @@ public:
     // that backs this ConsumerBase.
     sp<IGraphicBufferConsumer> getIGraphicBufferConsumer() const
             __attribute((deprecated("DO NOT USE: Temporary hack for refactoring")));
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
 
     // setFrameAvailableListener sets the listener object that will be notified
     // when a new frame becomes available.
@@ -93,10 +91,8 @@ public:
     status_t detachBuffer(int slot) __attribute((
             deprecated("Please use the GraphicBuffer variant--slots are deprecated.")));
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
     // See IGraphicBufferConsumer::detachBuffer
     status_t detachBuffer(const sp<GraphicBuffer>& buffer);
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
 
     status_t addReleaseFence(const sp<GraphicBuffer> buffer, const sp<Fence>& fence);
 
@@ -115,10 +111,8 @@ public:
     // See IGraphicBufferConsumer::setTransformHint
     status_t setTransformHint(uint32_t hint);
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
     // See IGraphicBufferConsumer::setMaxBufferCount
     status_t setMaxBufferCount(int bufferCount);
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
 
     // See IGraphicBufferConsumer::setMaxAcquiredBufferCount
     status_t setMaxAcquiredBufferCount(int maxAcquiredBuffers);
@@ -146,7 +140,6 @@ protected:
     // buffers from the given IGraphicBufferConsumer.
     // The controlledByApp flag indicates that this consumer is under the application's
     // control.
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
     explicit ConsumerBase(bool controlledByApp = false, bool consumerIsSurfaceFlinger = false);
     explicit ConsumerBase(const sp<IGraphicBufferProducer>& producer,
                           const sp<IGraphicBufferConsumer>& consumer, bool controlledByApp = false);
@@ -154,9 +147,6 @@ protected:
     explicit ConsumerBase(const sp<IGraphicBufferConsumer>& consumer, bool controlledByApp = false)
             __attribute((deprecated("ConsumerBase should own its own producer, and constructing it "
                                     "without one is fragile! This method is going away soon.")));
-#else
-    explicit ConsumerBase(const sp<IGraphicBufferConsumer>& consumer, bool controlledByApp = false);
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
 
     // onLastStrongRef gets called by RefBase just before the dtor of the most
     // derived class.  It is used to clean up the buffers so that ConsumerBase
@@ -319,11 +309,9 @@ protected:
     // objects if not supplied.
     sp<IGraphicBufferConsumer> mConsumer;
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
     // This Surface wraps the IGraphicBufferConsumer created for this
     // ConsumerBase.
     sp<Surface> mSurface;
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
 
     // The final release fence of the most recent buffer released by
     // releaseBufferLocked.
diff --git a/libs/gui/include/gui/CpuConsumer.h b/libs/gui/include/gui/CpuConsumer.h
index 995cdfb53d..ffd1e19dd5 100644
--- a/libs/gui/include/gui/CpuConsumer.h
+++ b/libs/gui/include/gui/CpuConsumer.h
@@ -100,18 +100,6 @@ class CpuConsumer : public ConsumerBase
                                   bool controlledByApp = false)
             __attribute((deprecated("Prefer ctors that create their own surface and consumer.")));
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
-    CpuConsumer(size_t maxLockedBuffers, bool controlledByApp = false,
-                bool isConsumerSurfaceFlinger = false);
-
-    CpuConsumer(const sp<IGraphicBufferConsumer>& bq, size_t maxLockedBuffers,
-                bool controlledByApp = false)
-            __attribute((deprecated("Prefer ctors that create their own surface and consumer.")));
-#else
-    CpuConsumer(const sp<IGraphicBufferConsumer>& bq, size_t maxLockedBuffers,
-                bool controlledByApp = false);
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
-
     // Gets the next graphics buffer from the producer and locks it for CPU use,
     // filling out the passed-in locked buffer structure with the native pointer
     // and metadata. Returns BAD_VALUE if no new buffer is available, and
@@ -130,6 +118,19 @@ class CpuConsumer : public ConsumerBase
     status_t unlockBuffer(const LockedBuffer &nativeBuffer);
 
   private:
+    friend class sp<CpuConsumer>;
+
+    CpuConsumer(size_t maxLockedBuffers, bool controlledByApp = false,
+                bool isConsumerSurfaceFlinger = false);
+
+    CpuConsumer(const sp<IGraphicBufferConsumer>& bq, size_t maxLockedBuffers,
+                bool controlledByApp = false)
+            __attribute((deprecated("Prefer ctors that create their own surface and consumer.")));
+
+    void initializeConsumer();
+
+    void onFirstRef() override;
+
     // Maximum number of buffers that can be locked at a time
     const size_t mMaxLockedBuffers;
 
@@ -144,10 +145,7 @@ class CpuConsumer : public ConsumerBase
         sp<GraphicBuffer> mGraphicBuffer;
         uintptr_t mLockedBufferId;
 
-        AcquiredBuffer() :
-                mSlot(BufferQueue::INVALID_BUFFER_SLOT),
-                mLockedBufferId(kUnusedId) {
-        }
+        AcquiredBuffer() : mSlot(BufferQueue::INVALID_BUFFER_SLOT), mLockedBufferId(kUnusedId) {}
 
         void reset() {
             mSlot = BufferQueue::INVALID_BUFFER_SLOT;
diff --git a/libs/gui/include/gui/DisplayEventDispatcher.h b/libs/gui/include/gui/DisplayEventDispatcher.h
index cdf216c945..bf49068765 100644
--- a/libs/gui/include/gui/DisplayEventDispatcher.h
+++ b/libs/gui/include/gui/DisplayEventDispatcher.h
@@ -58,8 +58,13 @@ private:
 
     virtual void dispatchHotplugConnectionError(nsecs_t timestamp, int32_t connectionError) = 0;
 
+    virtual void dispatchModeChangedWithFrameRateOverrides(
+            nsecs_t timestamp, PhysicalDisplayId displayId, int32_t modeId, nsecs_t renderPeriod,
+            nsecs_t appVsyncOffset, nsecs_t presentationDeadline,
+            std::vector<FrameRateOverride> overrides) = 0;
     virtual void dispatchModeChanged(nsecs_t timestamp, PhysicalDisplayId displayId, int32_t modeId,
-                                     nsecs_t vsyncPeriod) = 0;
+                                     nsecs_t vsyncPeriod, nsecs_t appVsyncOffset,
+                                     nsecs_t presentationDeadline) = 0;
     // AChoreographer-specific hook for processing null-events so that looper
     // can be properly poked.
     virtual void dispatchNullEvent(nsecs_t timestamp, PhysicalDisplayId displayId) = 0;
diff --git a/libs/gui/include/gui/DisplayEventReceiver.h b/libs/gui/include/gui/DisplayEventReceiver.h
index f51390a0d8..4d8e7b4b9b 100644
--- a/libs/gui/include/gui/DisplayEventReceiver.h
+++ b/libs/gui/include/gui/DisplayEventReceiver.h
@@ -58,10 +58,15 @@ static inline constexpr uint32_t fourcc(char c1, char c2, char c3, char c4) {
 enum class DisplayEventType : uint32_t {
     DISPLAY_EVENT_VSYNC = fourcc('v', 's', 'y', 'n'),
     DISPLAY_EVENT_HOTPLUG = fourcc('p', 'l', 'u', 'g'),
+    // TODO(b/399482301) Cleanup the DISPLAY_EVENT_MODE_CHANGE event
+    // with flag cleanup.
     DISPLAY_EVENT_MODE_CHANGE = fourcc('m', 'o', 'd', 'e'),
+    DISPLAY_EVENT_MODE_AND_FRAME_RATE_CHANGE = fourcc('m', 'o', 'f', 'r'),
     DISPLAY_EVENT_MODE_REJECTION = fourcc('r', 'e', 'j', 'e'),
     DISPLAY_EVENT_NULL = fourcc('n', 'u', 'l', 'l'),
     DISPLAY_EVENT_FRAME_RATE_OVERRIDE = fourcc('r', 'a', 't', 'e'),
+    // TODO(b/399482301) Cleanup the DISPLAY_EVENT_FRAME_RATE_OVERRIDE_FLUSH event
+    // with the flag cleanup.
     DISPLAY_EVENT_FRAME_RATE_OVERRIDE_FLUSH = fourcc('f', 'l', 's', 'h'),
     DISPLAY_EVENT_HDCP_LEVELS_CHANGE = fourcc('h', 'd', 'c', 'p'),
 };
@@ -95,6 +100,8 @@ public:
         struct ModeChange {
             int32_t modeId;
             nsecs_t vsyncPeriod __attribute__((aligned(8)));
+            nsecs_t appVsyncOffset __attribute__((aligned(8)));
+            nsecs_t presentationDeadline __attribute__((aligned(8)));
         };
 
         struct ModeRejection {
diff --git a/libs/gui/include/gui/Flags.h b/libs/gui/include/gui/Flags.h
index 446841bcd2..b639f92464 100644
--- a/libs/gui/include/gui/Flags.h
+++ b/libs/gui/include/gui/Flags.h
@@ -27,15 +27,10 @@ namespace view {
 class Surface;
 }
 
-#define WB_CAMERA3_AND_PROCESSORS_WITH_DEPENDENCIES                  \
-    (COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CAMERA3_AND_PROCESSORS) && \
-     COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ) &&  \
-     COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS))
-
-#define WB_LIBCAMERASERVICE_WITH_DEPENDENCIES       \
-    (WB_CAMERA3_AND_PROCESSORS_WITH_DEPENDENCIES && \
-     COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_LIBCAMERASERVICE))
+#define WB_LIBCAMERASERVICE_WITH_DEPENDENCIES \
+    (COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_LIBCAMERASERVICE))
 
+// Camera
 #if WB_LIBCAMERASERVICE_WITH_DEPENDENCIES
 typedef android::Surface SurfaceType;
 typedef android::view::Surface ParcelableSurfaceType;
@@ -54,4 +49,21 @@ ParcelableSurfaceType convertSurfaceTypeToParcelable(sp<SurfaceType> surface);
 sp<SurfaceType> convertParcelableSurfaceTypeToSurface(const ParcelableSurfaceType& surface);
 } // namespace flagtools
 
+// Media
+#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_MEDIA_MIGRATION)
+typedef android::Surface MediaSurfaceType;
+typedef android::view::Surface MediaParcelableSurfaceType;
+#else
+typedef android::IGraphicBufferProducer MediaSurfaceType;
+typedef android::sp<android::IGraphicBufferProducer> MediaParcelableSurfaceType;
+#endif
+
+namespace mediaflagtools {
+sp<MediaSurfaceType> igbpToSurfaceType(const sp<IGraphicBufferProducer>& igbp);
+sp<IGraphicBufferProducer> surfaceTypeToIGBP(const sp<MediaSurfaceType>& mst);
+sp<SurfaceType> mediaSurfaceToCameraSurfaceType(const sp<MediaSurfaceType>& mst,
+                                                bool controlledByApp = false);
+sp<Surface> surfaceTypeToSurface(const sp<MediaSurfaceType>& mst, bool controlledByApp = false);
+sp<MediaSurfaceType> surfaceToSurfaceType(const sp<Surface>& surface);
+} // namespace mediaflagtools
 } // namespace android
diff --git a/libs/gui/include/gui/GLConsumer.h b/libs/gui/include/gui/GLConsumer.h
index 254d8ac79c..3d6c197209 100644
--- a/libs/gui/include/gui/GLConsumer.h
+++ b/libs/gui/include/gui/GLConsumer.h
@@ -97,26 +97,6 @@ public:
             __attribute((deprecated(
                     "Prefer create functions that create their own surface and consumer.")));
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
-    GLConsumer(uint32_t tex, uint32_t textureTarget, bool useFenceSync, bool isControlledByApp);
-
-    GLConsumer(uint32_t textureTarget, bool useFenceSync, bool isControlledByApp);
-
-    GLConsumer(const sp<IGraphicBufferConsumer>& bq, uint32_t tex, uint32_t textureTarget,
-               bool useFenceSync, bool isControlledByApp)
-            __attribute((deprecated("Prefer ctors that create their own surface and consumer.")));
-
-    GLConsumer(const sp<IGraphicBufferConsumer>& bq, uint32_t textureTarget, bool useFenceSync,
-               bool isControlledByApp)
-            __attribute((deprecated("Prefer ctors that create their own surface and consumer.")));
-#else
-    GLConsumer(const sp<IGraphicBufferConsumer>& bq, uint32_t tex, uint32_t textureTarget,
-               bool useFenceSync, bool isControlledByApp);
-
-    GLConsumer(const sp<IGraphicBufferConsumer>& bq, uint32_t textureTarget, bool useFenceSync,
-               bool isControlledByApp);
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
-
     // updateTexImage acquires the most recently queued buffer, and sets the
     // image contents of the target texture to it.
     //
@@ -327,6 +307,20 @@ protected:
     status_t checkAndUpdateEglStateLocked(bool contextCheck = false);
 
 private:
+    friend class sp<GLConsumer>;
+
+    GLConsumer(uint32_t tex, uint32_t textureTarget, bool useFenceSync, bool isControlledByApp);
+
+    GLConsumer(uint32_t textureTarget, bool useFenceSync, bool isControlledByApp);
+
+    GLConsumer(const sp<IGraphicBufferConsumer>& bq, uint32_t tex, uint32_t textureTarget,
+               bool useFenceSync, bool isControlledByApp)
+            __attribute((deprecated("Prefer ctors that create their own surface and consumer.")));
+
+    GLConsumer(const sp<IGraphicBufferConsumer>& bq, uint32_t textureTarget, bool useFenceSync,
+               bool isControlledByApp)
+            __attribute((deprecated("Prefer ctors that create their own surface and consumer.")));
+
     // EglImage is a utility class for tracking and creating EGLImageKHRs. There
     // is primarily just one image per slot, but there is also special cases:
     //  - For releaseTexImage, we use a debug image (mReleasedTexImage)
diff --git a/libs/gui/include/gui/IConsumerListener.h b/libs/gui/include/gui/IConsumerListener.h
index 95e66c778e..b5837b9abc 100644
--- a/libs/gui/include/gui/IConsumerListener.h
+++ b/libs/gui/include/gui/IConsumerListener.h
@@ -90,11 +90,9 @@ public:
     virtual void addAndGetFrameTimestamps(const NewFrameEventsEntry* /*newTimestamps*/,
                                           FrameEventHistoryDelta* /*outDelta*/) {}
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(BQ_SETFRAMERATE)
     // Notifies the consumer of a setFrameRate call from the producer side.
     virtual void onSetFrameRate(float /*frameRate*/, int8_t /*compatibility*/,
                                 int8_t /*changeFrameRateStrategy*/) {}
-#endif
 
 #if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_UNLIMITED_SLOTS)
     // Notifies the consumer that IGraphicBufferProducer::extendSlotCount has
diff --git a/libs/gui/include/gui/IGraphicBufferProducer.h b/libs/gui/include/gui/IGraphicBufferProducer.h
index 7accca6298..57478a0ba3 100644
--- a/libs/gui/include/gui/IGraphicBufferProducer.h
+++ b/libs/gui/include/gui/IGraphicBufferProducer.h
@@ -723,11 +723,9 @@ public:
     // the width and height used for dequeueBuffer will be additionally swapped.
     virtual status_t setAutoPrerotation(bool autoPrerotation);
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(BQ_SETFRAMERATE)
     // Sets the apps intended frame rate.
     virtual status_t setFrameRate(float frameRate, int8_t compatibility,
                                   int8_t changeFrameRateStrategy);
-#endif
 
 #if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(BQ_EXTENDEDALLOCATE)
     virtual status_t setAdditionalOptions(const std::vector<gui::AdditionalOptions>& options);
diff --git a/libs/gui/include/gui/ISurfaceComposer.h b/libs/gui/include/gui/ISurfaceComposer.h
index de553aef72..109ab7eb53 100644
--- a/libs/gui/include/gui/ISurfaceComposer.h
+++ b/libs/gui/include/gui/ISurfaceComposer.h
@@ -19,6 +19,7 @@
 #include <android/gui/CachingHint.h>
 #include <android/gui/DisplayBrightness.h>
 #include <android/gui/DisplayCaptureArgs.h>
+#include <android/gui/EarlyWakeupInfo.h>
 #include <android/gui/FrameTimelineInfo.h>
 #include <android/gui/IDisplayEventConnection.h>
 #include <android/gui/IFpsListener.h>
@@ -65,7 +66,9 @@ struct DisplayState;
 struct InputWindowCommands;
 class HdrCapabilities;
 class Rect;
-class TransactionState;
+struct SimpleTransactionState;
+struct ComplexTransactionState;
+struct MutableTransactionState;
 
 using gui::FrameTimelineInfo;
 using gui::IDisplayEventConnection;
@@ -106,7 +109,10 @@ public:
     };
 
     /* open/close transactions. requires ACCESS_SURFACE_FLINGER permission */
-    virtual status_t setTransactionState(TransactionState&& state) = 0;
+    virtual status_t setTransactionState(SimpleTransactionState simpleState,
+                                         const ComplexTransactionState& complexState,
+                                         MutableTransactionState& mutableState,
+                                         const sp<IBinder>& applyToken) = 0;
 };
 
 // ----------------------------------------------------------------------------
diff --git a/libs/gui/include/gui/LayerState.h b/libs/gui/include/gui/LayerState.h
index e2d27ac464..d54f2455d8 100644
--- a/libs/gui/include/gui/LayerState.h
+++ b/libs/gui/include/gui/LayerState.h
@@ -22,6 +22,7 @@
 #include <span>
 
 #include <android/gui/BorderSettings.h>
+#include <android/gui/BoxShadowSettings.h>
 #include <android/gui/DisplayCaptureArgs.h>
 #include <android/gui/IWindowInfosReportedListener.h>
 #include <android/gui/LayerCaptureArgs.h>
@@ -252,6 +253,9 @@ struct layer_state_t {
         eAppContentPriorityChanged = 0x100000'00000000,
         eClientDrawnCornerRadiusChanged = 0x200000'00000000,
         eBorderSettingsChanged = 0x400000'00000000,
+        eBoxShadowSettingsChanged = 0x800000'00000000,
+        eStopLayerChanged = 0x1000000'00000000,
+        eBackgroundBlurScaleChanged = 0x2000000'00000000,
     };
 
     layer_state_t();
@@ -290,13 +294,15 @@ struct layer_state_t {
     // Content updates.
     static constexpr uint64_t CONTENT_CHANGES = layer_state_t::BUFFER_CHANGES |
             layer_state_t::eAlphaChanged | layer_state_t::eAutoRefreshChanged |
-            layer_state_t::eBackgroundBlurRadiusChanged | layer_state_t::eBackgroundColorChanged |
+            layer_state_t::eBackgroundBlurRadiusChanged |
+            layer_state_t::eBackgroundBlurScaleChanged | layer_state_t::eBackgroundColorChanged |
             layer_state_t::eBlurRegionsChanged | layer_state_t::eColorChanged |
             layer_state_t::eColorSpaceAgnosticChanged | layer_state_t::eColorTransformChanged |
             layer_state_t::eCornerRadiusChanged | layer_state_t::eDimmingEnabledChanged |
             layer_state_t::eHdrMetadataChanged | layer_state_t::eShadowRadiusChanged |
             layer_state_t::eStretchChanged | layer_state_t::ePictureProfileHandleChanged |
-            layer_state_t::eAppContentPriorityChanged | layer_state_t::eBorderSettingsChanged;
+            layer_state_t::eAppContentPriorityChanged | layer_state_t::eBorderSettingsChanged |
+            layer_state_t::eBoxShadowSettingsChanged;
 
     // Changes which invalidates the layer's visible region in CE.
     static constexpr uint64_t CONTENT_DIRTY = layer_state_t::CONTENT_CHANGES |
@@ -305,7 +311,8 @@ struct layer_state_t {
     // Changes affecting child states.
     static constexpr uint64_t AFFECTS_CHILDREN = layer_state_t::GEOMETRY_CHANGES |
             layer_state_t::HIERARCHY_CHANGES | layer_state_t::eAlphaChanged |
-            layer_state_t::eBackgroundBlurRadiusChanged | layer_state_t::eBlurRegionsChanged |
+            layer_state_t::eBackgroundBlurRadiusChanged |
+            layer_state_t::eBackgroundBlurScaleChanged | layer_state_t::eBlurRegionsChanged |
             layer_state_t::eColorTransformChanged | layer_state_t::eCornerRadiusChanged |
             layer_state_t::eFlagsChanged | layer_state_t::eTrustedOverlayChanged |
             layer_state_t::eFrameRateChanged | layer_state_t::eFrameRateCategoryChanged |
@@ -323,9 +330,10 @@ struct layer_state_t {
 
     // Changes that force GPU composition.
     static constexpr uint64_t COMPOSITION_EFFECTS = layer_state_t::eBackgroundBlurRadiusChanged |
-            layer_state_t::eBlurRegionsChanged | layer_state_t::eCornerRadiusChanged |
-            layer_state_t::eShadowRadiusChanged | layer_state_t::eStretchChanged |
-            layer_state_t::eBorderSettingsChanged;
+            layer_state_t::eBackgroundBlurScaleChanged | layer_state_t::eBlurRegionsChanged |
+            layer_state_t::eCornerRadiusChanged | layer_state_t::eShadowRadiusChanged |
+            layer_state_t::eStretchChanged | layer_state_t::eBorderSettingsChanged |
+            layer_state_t::eBoxShadowSettingsChanged;
 
     bool hasValidBuffer() const;
     void sanitize(int32_t permissions);
@@ -383,6 +391,7 @@ struct layer_state_t {
     float cornerRadius;
     float clientDrawnCornerRadius;
     uint32_t backgroundBlurRadius;
+    float backgroundBlurScale;
 
     half4 color;
 
@@ -417,6 +426,9 @@ struct layer_state_t {
     // Draws an outline around the layer.
     gui::BorderSettings borderSettings;
 
+    // Draws a sequence of box shadows under the layer.
+    gui::BoxShadowSettings boxShadowSettings;
+
     // Priority of the layer assigned by Window Manager.
     int32_t frameRateSelectionPriority;
 
@@ -614,6 +626,11 @@ static inline int compare_type(const DisplayState& lhs, const DisplayState& rhs)
     return compare_type(lhs.token, rhs.token);
 }
 
+static inline bool isFrameBarrierNewer(uint32_t producerIdA, uint64_t frameNumberA,
+                                       uint32_t producerIdB, uint64_t frameNumberB) {
+    return producerIdA > producerIdB || (producerIdA == producerIdB && frameNumberA > frameNumberB);
+}
+
 }; // namespace android
 
 #endif // ANDROID_SF_LAYER_STATE_H
diff --git a/libs/gui/include/gui/SimpleTransactionState.h b/libs/gui/include/gui/SimpleTransactionState.h
new file mode 100644
index 0000000000..08a8b2ae31
--- /dev/null
+++ b/libs/gui/include/gui/SimpleTransactionState.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <cstdint>
+
+#include <gui/LayerState.h>
+
+namespace android {
+
+// Defined in its own header to avoid circular dependencies in includes.
+struct SimpleTransactionState {
+    uint64_t mId = 0;
+    uint32_t mFlags = 0;
+    // mDesiredPresentTime is the time in nanoseconds that the client would like the transaction
+    // to be presented. When it is not possible to present at exactly that time, it will be
+    // presented after the time has passed.
+    //
+    // If the client didn't pass a desired presentation time, mDesiredPresentTime will be
+    // populated to the time setBuffer was called, and mIsAutoTimestamp will be set to true.
+    //
+    // Desired present times that are more than 1 second in the future may be ignored.
+    // When a desired present time has already passed, the transaction will be presented as soon
+    // as possible.
+    //
+    // Transactions from the same process are presented in the same order that they are applied.
+    // The desired present time does not affect this ordering.
+    int64_t mDesiredPresentTime = 0;
+    bool mIsAutoTimestamp = true;
+
+    SimpleTransactionState() = default;
+    SimpleTransactionState(uint64_t id, uint32_t flags, int64_t desiredPresentTime,
+                           bool isAutoTimestamp)
+          : mId(id),
+            mFlags(flags),
+            mDesiredPresentTime(desiredPresentTime),
+            mIsAutoTimestamp(isAutoTimestamp) {}
+    bool operator==(const SimpleTransactionState& rhs) const = default;
+    bool operator!=(const SimpleTransactionState& rhs) const = default;
+
+    status_t writeToParcel(Parcel* parcel) const;
+    status_t readFromParcel(const Parcel* parcel);
+    void merge(const SimpleTransactionState& other);
+    void clear();
+};
+
+} // namespace android
diff --git a/libs/gui/include/gui/Surface.h b/libs/gui/include/gui/Surface.h
index 3cfbed11bf..cf02c07812 100644
--- a/libs/gui/include/gui/Surface.h
+++ b/libs/gui/include/gui/Surface.h
@@ -17,7 +17,6 @@
 #ifndef ANDROID_GUI_SURFACE_H
 #define ANDROID_GUI_SURFACE_H
 
-#include <android/gui/FrameTimelineInfo.h>
 #include <com_android_graphics_libgui_flags.h>
 #include <gui/BufferQueueDefs.h>
 #include <gui/HdrMetadata.h>
@@ -30,6 +29,7 @@
 #include <utils/Condition.h>
 #include <utils/Mutex.h>
 #include <utils/RefBase.h>
+#include <utils/String8.h>
 
 #include <shared_mutex>
 #include <unordered_set>
@@ -39,6 +39,7 @@ namespace android {
 class GraphicBuffer;
 
 namespace gui {
+class FrameTimelineInfo;
 class ISurfaceComposer;
 } // namespace gui
 
@@ -65,7 +66,6 @@ public:
     virtual bool needsAttachNotify() { return false; }
 #endif
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
     // Called if this Surface is connected to a remote implementation and it
     // dies or becomes unavailable.
     virtual void onRemoteDied() {}
@@ -73,7 +73,6 @@ public:
     // Clients will overwrite this if they want to receive a notification
     // via onRemoteDied. This should return a constant value.
     virtual bool needsDeathNotify() { return false; }
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
 };
 
 class StubSurfaceListener : public SurfaceListener {
@@ -85,14 +84,12 @@ public:
     virtual void onBufferDetached(int /*slot*/) override {}
 };
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
 // Contains additional data from the queueBuffer operation.
 struct SurfaceQueueBufferOutput {
     // True if this queueBuffer caused a buffer to be replaced in the queue
     // (and therefore not will not be acquired)
     bool bufferReplaced = false;
 };
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
 
 /*
  * An implementation of ANativeWindow that feeds graphics buffers into a
@@ -190,10 +187,8 @@ public:
      */
     virtual void allocateBuffers();
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
     // See IGraphicBufferProducer::allowAllocation
     status_t allowAllocation(bool allowAllocation);
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
 
     /* Sets the generation number on the IGraphicBufferProducer and updates the
      * generation number on any buffers attached to the Surface after this call.
@@ -263,6 +258,12 @@ public:
     virtual status_t setFrameRate(float frameRate, int8_t compatibility,
                                   int8_t changeFrameRateStrategy);
     virtual status_t setFrameTimelineInfo(uint64_t frameNumber, const FrameTimelineInfo& info);
+    // Returns whether this surface holds the mouse cursor.
+    bool isForCursor() const { return mIsForCursor; }
+    // Sets whether this surface holds the mouse cursor.
+    void setIsForCursor(bool isForCursor) { mIsForCursor = isForCursor; }
+
+    static bool IsCursorPlaneCompatibilitySupported();
 
 #if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(BQ_EXTENDEDALLOCATE)
     /**
@@ -277,9 +278,11 @@ public:
 protected:
     virtual ~Surface();
 
+#ifndef NO_BINDER
     // Virtual for testing.
     virtual sp<ISurfaceComposer> composerService() const;
     virtual sp<gui::ISurfaceComposer> composerServiceAIDL() const;
+#endif
     virtual nsecs_t now() const;
 
 private:
@@ -363,23 +366,15 @@ private:
     int dispatchSetFrameTimelineInfo(va_list args);
     int dispatchSetAdditionalOptions(va_list args);
 
-    std::mutex mNameMutex;
-    std::string mName;
-    const char* getDebugName();
-
 protected:
-    virtual int dequeueBuffer(ANativeWindowBuffer** buffer, int* fenceFd);
-    virtual int cancelBuffer(ANativeWindowBuffer* buffer, int fenceFd);
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
-    virtual int queueBuffer(ANativeWindowBuffer* buffer, int fenceFd,
+    virtual int dequeueBuffer(sp<GraphicBuffer>* buffer, int* fenceFd);
+    virtual int cancelBuffer(sp<GraphicBuffer>&& buffer, int fenceFd);
+    virtual int queueBuffer(sp<GraphicBuffer>&& buffer, int fenceFd,
                             SurfaceQueueBufferOutput* surfaceOutput = nullptr);
-#else
-    virtual int queueBuffer(ANativeWindowBuffer* buffer, int fenceFd);
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
     virtual int perform(int operation, va_list args);
     virtual int setSwapInterval(int interval);
 
-    virtual int lockBuffer_DEPRECATED(ANativeWindowBuffer* buffer);
+    virtual int lockBuffer_DEPRECATED(const sp<GraphicBuffer>& buffer);
 
     virtual int connect(int api);
     virtual int setBufferCount(int bufferCount);
@@ -427,7 +422,6 @@ public:
     static status_t attachAndQueueBufferWithDataspace(Surface* surface, sp<GraphicBuffer> buffer,
                                                       ui::Dataspace dataspace);
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
     // Dequeues a buffer and its outFence, which must be signalled before the buffer can be used.
     status_t dequeueBuffer(sp<GraphicBuffer>* buffer, sp<Fence>* outFence);
 
@@ -440,7 +434,6 @@ public:
     // Detaches this buffer, dissociating it from this Surface. This buffer must have been returned
     // by queueBuffer or associated with this Surface via an attachBuffer operation.
     status_t detachBuffer(const sp<GraphicBuffer>& buffer);
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
 
     // Sets outIsOwned to true if the given buffer is currently known to be owned by this Surface.
     status_t isBufferOwned(const sp<GraphicBuffer>& buffer, bool* outIsOwned) const;
@@ -459,13 +452,8 @@ public:
         int fenceFd = -1;
         nsecs_t timestamp = NATIVE_WINDOW_TIMESTAMP_AUTO;
     };
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
     virtual int queueBuffers(const std::vector<BatchQueuedBuffer>& buffers,
                              std::vector<SurfaceQueueBufferOutput>* queueBufferOutputs = nullptr);
-#else
-    virtual int queueBuffers(
-            const std::vector<BatchQueuedBuffer>& buffers);
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
 
 protected:
     enum { NUM_BUFFER_SLOTS = BufferQueueDefs::NUM_BUFFER_SLOTS };
@@ -502,7 +490,6 @@ protected:
         sp<SurfaceListener> mSurfaceListener;
     };
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
     class ProducerDeathListenerProxy : public IBinder::DeathRecipient {
     public:
         ProducerDeathListenerProxy(wp<SurfaceListener> surfaceListener);
@@ -515,23 +502,22 @@ protected:
         wp<SurfaceListener> mSurfaceListener;
     };
     friend class ProducerDeathListenerProxy;
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
 
     void querySupportedTimestampsLocked() const;
 
     void freeAllBuffers();
-    int getSlotFromBufferLocked(android_native_buffer_t* buffer) const;
+    int getSlotFromBufferLocked(const sp<GraphicBuffer>& buffer) const;
 
     void getDequeueBufferInputLocked(IGraphicBufferProducer::DequeueBufferInput* dequeueInput);
 
-    void getQueueBufferInputLocked(android_native_buffer_t* buffer, int fenceFd, nsecs_t timestamp,
-            IGraphicBufferProducer::QueueBufferInput* out);
+    void getQueueBufferInputLocked(const sp<GraphicBuffer>& buffer, int fenceFd, nsecs_t timestamp,
+                                   IGraphicBufferProducer::QueueBufferInput* out);
 
     // For easing in adoption of gralloc4 metadata by vendor components, as well as for supporting
     // the public ANativeWindow api, allow setting relevant metadata when queueing a buffer through
     // a native window
     void applyGrallocMetadataLocked(
-            android_native_buffer_t* buffer,
+            const sp<GraphicBuffer>& buffer,
             const IGraphicBufferProducer::QueueBufferInput& queueBufferInput);
 
     void onBufferQueuedLocked(int slot, sp<Fence> fence,
@@ -548,12 +534,10 @@ protected:
     // TODO: rename to mBufferProducer
     sp<IGraphicBufferProducer> mGraphicBufferProducer;
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
     // mSurfaceDeathListener gets registered as mGraphicBufferProducer's
     // DeathRecipient when SurfaceListener::needsDeathNotify returns true and
     // gets notified when it dies.
     sp<ProducerDeathListenerProxy> mSurfaceDeathListener;
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
 
     // mSlots stores the buffers that have been allocated for each buffer slot.
     // It is initialized to null pointers, and gets filled in with the result of
@@ -598,7 +582,7 @@ protected:
     HdrMetadata mHdrMetadata;
 
     // mHdrMetadataIsSet is a bitfield to track which HDR metadata has been set.
-    // Prevent Surface from resetting HDR metadata that was set on a bufer when
+    // Prevent Surface from resetting HDR metadata that was set on a buffer when
     // HDR metadata is not set on this Surface.
     uint32_t mHdrMetadataIsSet{0};
 
@@ -753,6 +737,15 @@ protected:
 
     // Buffers that are successfully dequeued/attached and handed to clients
     std::unordered_set<int> mDequeuedSlots;
+
+    // Indicates whether this surface holds the mouse cursor, and subsequently determines whether
+    // the GRALLOC_USAGE_CURSOR usage flag should be set on the buffer created when this surface is
+    // locked.
+    bool mIsForCursor = false;
+
+    mutable std::mutex mDebugMutex;
+    String8 mDebugName GUARDED_BY(mDebugMutex) = String8("not-connected");
+    uint64_t mId GUARDED_BY(mDebugMutex) = 0;
 };
 
 } // namespace android
diff --git a/libs/gui/include/gui/SurfaceComposerClient.h b/libs/gui/include/gui/SurfaceComposerClient.h
index 5c348cb9c7..44961c0efe 100644
--- a/libs/gui/include/gui/SurfaceComposerClient.h
+++ b/libs/gui/include/gui/SurfaceComposerClient.h
@@ -24,10 +24,12 @@
 #include <unordered_map>
 #include <unordered_set>
 
+#include <android-base/result.h>
 #include <binder/IBinder.h>
 
 #include <utils/Errors.h>
 #include <utils/RefBase.h>
+#include <utils/Mutex.h>
 #include <utils/Singleton.h>
 #include <utils/SortedVector.h>
 #include <utils/threads.h>
@@ -45,12 +47,14 @@
 
 #include <android/gui/BnJankListener.h>
 #include <android/gui/ISurfaceComposerClient.h>
+#include <android/gui/RegionSamplingDescriptor.h>
 
 #include <gui/BufferReleaseChannel.h>
 #include <gui/CpuConsumer.h>
 #include <gui/ISurfaceComposer.h>
 #include <gui/ITransactionCompletedListener.h>
 #include <gui/LayerState.h>
+#include <gui/SimpleTransactionState.h>
 #include <gui/SurfaceControl.h>
 #include <gui/TransactionState.h>
 #include <gui/WindowInfosListenerReporter.h>
@@ -389,7 +393,19 @@ public:
     //      A               A'
     //      |               |
     //      B               B'
-    sp<SurfaceControl> mirrorSurface(SurfaceControl* mirrorFromSurface);
+    //
+    // The mirrored hierarchy will exclude all layers z-ordered above the layer specified by
+    // stopAt. With stopAt specified as B:
+    //
+    //  Real Hierarchy    Mirror
+    //                      SC (value that's returned)
+    //                      |
+    //      A               A'
+    //      |
+    //      B
+    //
+    sp<SurfaceControl> mirrorSurface(SurfaceControl* mirrorFromSurface,
+                                     SurfaceControl* stopAt = nullptr);
 
     sp<SurfaceControl> mirrorDisplay(DisplayId displayId);
 
@@ -443,16 +459,35 @@ public:
         virtual ~PresentationCallbackRAII();
     };
 
-    class Transaction {
+    class Transaction : public Parcelable {
     private:
         static sp<IBinder> sApplyToken;
         static std::mutex sApplyTokenMutex;
         void releaseBufferIfOverwriting(const layer_state_t& state);
+        static void mergeFrameTimelineInfo(FrameTimelineInfo& t, const FrameTimelineInfo& other);
+
+        SimpleTransactionState mSimpleState;
+        ComplexTransactionState mComplexState;
         // Tracks registered callbacks
         sp<TransactionCompletedListener> mTransactionCompletedListener = nullptr;
+        // Prints debug logs when enabled.
+        bool mLogCallPoints = false;
+
+    protected:
+        MutableTransactionState mMutableState;
+        std::unordered_map<sp<ITransactionCompletedListener>, CallbackInfo, TCLHash>
+                mListenerCallbacks;
+
+        // Indicates that the Transaction may contain buffers that should be cached. The reason this
+        // is only a guess is that buffers can be removed before cache is called. This is only a
+        // hint that at some point a buffer was added to this transaction before apply was called.
+        bool mMayContainBuffer = false;
 
-        TransactionState mState;
+        // If not null, transactions will be queued up using this token otherwise a common token
+        // per process will be used.
+        sp<IBinder> mApplyToken = nullptr;
 
+        InputWindowCommands mInputWindowCommands;
         int mStatus = NO_ERROR;
 
         layer_state_t* getLayerState(const sp<SurfaceControl>& sc);
@@ -462,29 +497,23 @@ public:
         void registerSurfaceControlForCallback(const sp<SurfaceControl>& sc);
         void setReleaseBufferCallback(BufferData*, ReleaseBufferCallback);
 
-    protected:
-        // Accessed in tests.
-        explicit Transaction(Transaction const& other) = default;
-        std::unordered_map<sp<ITransactionCompletedListener>, CallbackInfo, TCLHash>
-                mListenerCallbacks;
-
     public:
         Transaction();
-        Transaction(Transaction&& other);
-        Transaction& operator=(Transaction&& other) = default;
+        virtual ~Transaction() = default;
+        Transaction(Transaction const& other);
 
         // Factory method that creates a new Transaction instance from the parcel.
         static std::unique_ptr<Transaction> createFromParcel(const Parcel* parcel);
 
-        status_t writeToParcel(Parcel* parcel) const;
-        status_t readFromParcel(const Parcel* parcel);
+        status_t writeToParcel(Parcel* parcel) const override;
+        status_t readFromParcel(const Parcel* parcel) override;
 
         // Clears the contents of the transaction without applying it.
         void clear();
 
         // Returns the current id of the transaction.
         // The id is updated every time the transaction is applied.
-        uint64_t getId() const;
+        uint64_t getId();
 
         std::vector<uint64_t> getMergedTransactionIds();
 
@@ -532,6 +561,8 @@ public:
                                                 float clientDrawnCornerRadius);
         Transaction& setBackgroundBlurRadius(const sp<SurfaceControl>& sc,
                                              int backgroundBlurRadius);
+        Transaction& setBackgroundBlurScale(const sp<SurfaceControl>& sc,
+                                             float backgroundBlurScale);
         Transaction& setBlurRegions(const sp<SurfaceControl>& sc,
                                     const std::vector<BlurRegion>& regions);
         Transaction& setLayerStack(const sp<SurfaceControl>&, ui::LayerStack);
@@ -681,6 +712,9 @@ public:
 
         Transaction& setBorderSettings(const sp<SurfaceControl>& sc, gui::BorderSettings settings);
 
+        Transaction& setBoxShadowSettings(const sp<SurfaceControl>& sc,
+                                          gui::BoxShadowSettings settings);
+
         Transaction& setFrameRate(const sp<SurfaceControl>& sc, float frameRate,
                                   int8_t compatibility, int8_t changeFrameRateStrategy);
 
@@ -789,9 +823,10 @@ public:
         void setDisplayProjection(const sp<IBinder>& token, ui::Rotation orientation,
                                   const Rect& layerStackRect, const Rect& displayRect);
         void setDisplaySize(const sp<IBinder>& token, uint32_t width, uint32_t height);
+
         void setAnimationTransaction();
-        void setEarlyWakeupStart();
-        void setEarlyWakeupEnd();
+        void setEarlyWakeupStart(gui::EarlyWakeupInfo token);
+        void setEarlyWakeupEnd(gui::EarlyWakeupInfo token);
 
         /**
          * Strip the transaction of all permissioned requests, required when
@@ -821,7 +856,10 @@ public:
     static void setDisplayProjection(const sp<IBinder>& token, ui::Rotation orientation,
                                      const Rect& layerStackRect, const Rect& displayRect);
 
-    inline sp<ISurfaceComposerClient> getClient() { return mClient; }
+    inline sp<ISurfaceComposerClient> getClient() {
+      Mutex::Autolock _lm(mLock);
+      return mClient;
+    }
 
     static status_t getDisplayedContentSamplingAttributes(const sp<IBinder>& display,
                                                           ui::PixelFormat* outFormat,
@@ -835,7 +873,11 @@ public:
     static status_t addRegionSamplingListener(const Rect& samplingArea,
                                               const sp<IBinder>& stopLayerHandle,
                                               const sp<IRegionSamplingListener>& listener);
+    static status_t addRegionSamplingListenerWithStopLayerId(
+            const Rect& samplingArea, const int32_t stopLayerId,
+            const sp<IRegionSamplingListener>& listener);
     static status_t removeRegionSamplingListener(const sp<IRegionSamplingListener>& listener);
+    static status_t getRegionSamplingListeners(std::vector<gui::RegionSamplingDescriptor>*);
     static status_t addFpsListener(int32_t taskId, const sp<gui::IFpsListener>& listener);
     static status_t removeFpsListener(const sp<gui::IFpsListener>& listener);
     static status_t addTunnelModeEnabledListener(
@@ -843,10 +885,8 @@ public:
     static status_t removeTunnelModeEnabledListener(
             const sp<gui::ITunnelModeEnabledListener>& listener);
 
-    status_t addWindowInfosListener(
-            const sp<gui::WindowInfosListener>& windowInfosListener,
-            std::pair<std::vector<gui::WindowInfo>, std::vector<gui::DisplayInfo>>* outInitialInfo =
-                    nullptr);
+    android::base::Result<gui::WindowInfosUpdate> addWindowInfosListener(
+            sp<gui::WindowInfosListener> windowInfosListener);
     status_t removeWindowInfosListener(const sp<gui::WindowInfosListener>& windowInfosListener);
 
     static void notifyShutdown();
@@ -864,8 +904,8 @@ private:
     virtual void onFirstRef();
 
     mutable     Mutex                       mLock;
-                status_t                    mStatus;
-                sp<ISurfaceComposerClient>  mClient;
+                status_t                    mStatus GUARDED_BY(mLock);
+                sp<ISurfaceComposerClient>  mClient GUARDED_BY(mLock);
 };
 
 // ---------------------------------------------------------------------------
diff --git a/libs/gui/include/gui/TransactionState.h b/libs/gui/include/gui/TransactionState.h
index 79124f3ed7..c467d503eb 100644
--- a/libs/gui/include/gui/TransactionState.h
+++ b/libs/gui/include/gui/TransactionState.h
@@ -19,15 +19,71 @@
 #include <android/gui/FrameTimelineInfo.h>
 #include <binder/Parcelable.h>
 #include <gui/LayerState.h>
+#include <gui/SimpleTransactionState.h>
 
 namespace android {
 
+struct TransactionListenerCallbacks {
+    std::vector<ListenerCallbacks> mFlattenedListenerCallbacks;
+    // Note: mHasListenerCallbacks can be true even if mFlattenedListenerCallbacks is
+    // empty because it reflects the unflattened map.
+    bool mHasListenerCallbacks = false;
+
+    status_t writeToParcel(Parcel* parcel) const;
+    status_t readFromParcel(const Parcel* parcel);
+    void clear();
+    bool operator==(const TransactionListenerCallbacks& rhs) const = default;
+    bool operator!=(const TransactionListenerCallbacks& rhs) const = default;
+};
+
+// State components that are containers or aggregates and are passed by const ref to
+// setTransactionState.
+struct ComplexTransactionState {
+    // The vsync id provided by Choreographer.getVsyncId and the input event id
+    gui::FrameTimelineInfo mFrameTimelineInfo = {};
+    std::vector<client_cache_t> mUncacheBuffers = {};
+    std::vector<uint64_t> mMergedTransactionIds = {};
+    TransactionListenerCallbacks mCallbacks = TransactionListenerCallbacks();
+    InputWindowCommands mInputWindowCommands = {};
+    // Tracks the client setting the early wakeup request
+    std::vector<gui::EarlyWakeupInfo> mEarlyWakeupInfos = {};
+
+    ComplexTransactionState() = default;
+    status_t writeToParcel(Parcel* parcel) const;
+    status_t readFromParcel(const Parcel* parcel);
+
+    void clear();
+    void merge(ComplexTransactionState& other);
+    bool operator==(const ComplexTransactionState& rhs) const = default;
+    bool operator!=(const ComplexTransactionState& rhs) const = default;
+
+    // copied from FrameTimelineInfo::merge()
+    void mergeFrameTimelineInfo(const FrameTimelineInfo& other);
+
+private:
+    // We keep track of the last MAX_MERGE_HISTORY_LENGTH merged transaction ids.
+    // Ordered most recently merged to least recently merged.
+    static constexpr size_t MAX_MERGE_HISTORY_LENGTH = 10u;
+};
+
+struct MutableTransactionState {
+    Vector<ComposerState> mComposerStates;
+    Vector<DisplayState> mDisplayStates;
+
+    void clear();
+    status_t writeToParcel(Parcel* parcel) const;
+    status_t readFromParcel(const Parcel* parcel);
+    void merge(const MutableTransactionState& other,
+               const std::function<void(const layer_state_t&)>& onBufferOverwrite);
+    layer_state_t* getLayerState(const sp<SurfaceControl>& sc);
+    DisplayState& getDisplayState(const sp<IBinder>& token);
+};
+
 // Class to store all the transaction data and the parcelling logic
 class TransactionState {
 public:
     explicit TransactionState() = default;
-    TransactionState(TransactionState&& other) = default;
-    TransactionState& operator=(TransactionState&& other) = default;
+    TransactionState(TransactionState const& other) = default;
     status_t writeToParcel(Parcel* parcel) const;
     status_t readFromParcel(const Parcel* parcel);
     layer_state_t* getLayerState(const sp<SurfaceControl>& sc);
@@ -35,38 +91,21 @@ public:
 
     // Returns the current id of the transaction.
     // The id is updated every time the transaction is applied.
-    uint64_t getId() const { return mId; }
-    std::vector<uint64_t> getMergedTransactionIds() const { return mMergedTransactionIds; }
+    uint64_t getId() const { return mSimpleState.mId; }
+    std::vector<uint64_t> getMergedTransactionIds() const {
+        return mComplexState.mMergedTransactionIds;
+    }
     void enableDebugLogCallPoints() { mLogCallPoints = true; }
     void merge(TransactionState&& other,
                const std::function<void(layer_state_t&)>& onBufferOverwrite);
 
-    // copied from FrameTimelineInfo::merge()
-    void mergeFrameTimelineInfo(const FrameTimelineInfo& other);
     void clear();
     bool operator==(const TransactionState& rhs) const = default;
     bool operator!=(const TransactionState& rhs) const = default;
 
-    uint64_t mId = 0;
-    std::vector<uint64_t> mMergedTransactionIds;
-    uint32_t mFlags = 0;
-    // The vsync id provided by Choreographer.getVsyncId and the input event id
-    gui::FrameTimelineInfo mFrameTimelineInfo;
-    // mDesiredPresentTime is the time in nanoseconds that the client would like the transaction
-    // to be presented. When it is not possible to present at exactly that time, it will be
-    // presented after the time has passed.
-    //
-    // If the client didn't pass a desired presentation time, mDesiredPresentTime will be
-    // populated to the time setBuffer was called, and mIsAutoTimestamp will be set to true.
-    //
-    // Desired present times that are more than 1 second in the future may be ignored.
-    // When a desired present time has already passed, the transaction will be presented as soon
-    // as possible.
-    //
-    // Transactions from the same process are presented in the same order that they are applied.
-    // The desired present time does not affect this ordering.
-    int64_t mDesiredPresentTime = 0;
-    bool mIsAutoTimestamp = true;
+    SimpleTransactionState mSimpleState;
+    ComplexTransactionState mComplexState;
+
     // If not null, transactions will be queued up using this token otherwise a common token
     // per process will be used.
     sp<IBinder> mApplyToken;
@@ -79,20 +118,6 @@ public:
 
     std::vector<DisplayState> mDisplayStates;
     std::vector<ComposerState> mComposerStates;
-    InputWindowCommands mInputWindowCommands;
-    std::vector<client_cache_t> mUncacheBuffers;
-    // Note: mHasListenerCallbacks can be true even if mListenerCallbacks is
-    // empty.
-    bool mHasListenerCallbacks = false;
-    std::vector<ListenerCallbacks> mListenerCallbacks;
-
-private:
-    explicit TransactionState(TransactionState const& other) = default;
-    friend class TransactionApplicationTest;
-    friend class SurfaceComposerClient;
-    // We keep track of the last MAX_MERGE_HISTORY_LENGTH merged transaction ids.
-    // Ordered most recently merged to least recently merged.
-    static constexpr size_t MAX_MERGE_HISTORY_LENGTH = 10u;
 };
 
 }; // namespace android
diff --git a/libs/gui/include/gui/WindowInfo.h b/libs/gui/include/gui/WindowInfo.h
index 9ac49c0fb6..b2dff48b8f 100644
--- a/libs/gui/include/gui/WindowInfo.h
+++ b/libs/gui/include/gui/WindowInfo.h
@@ -178,6 +178,10 @@ struct WindowInfo : public Parcelable {
                 static_cast<uint32_t>(os::InputConfig::GLOBAL_STYLUS_BLOCKS_TOUCH),
         SENSITIVE_FOR_PRIVACY =
                 static_cast<uint32_t>(os::InputConfig::SENSITIVE_FOR_PRIVACY),
+        DISPLAY_TOPOLOGY_AWARE =
+                static_cast<uint32_t>(os::InputConfig::DISPLAY_TOPOLOGY_AWARE),
+        DO_NOT_PILFER =
+                static_cast<uint32_t>(os::InputConfig::DO_NOT_PILFER),
         // clang-format on
     };
 
diff --git a/libs/gui/include/gui/WindowInfosListenerReporter.h b/libs/gui/include/gui/WindowInfosListenerReporter.h
index f9a3acee41..39944fbf67 100644
--- a/libs/gui/include/gui/WindowInfosListenerReporter.h
+++ b/libs/gui/include/gui/WindowInfosListenerReporter.h
@@ -16,6 +16,7 @@
 
 #pragma once
 
+#include <android-base/result.h>
 #include <android/gui/BnWindowInfosListener.h>
 #include <android/gui/ISurfaceComposer.h>
 #include <android/gui/IWindowInfosPublisher.h>
@@ -31,10 +32,8 @@ class WindowInfosListenerReporter : public gui::BnWindowInfosListener {
 public:
     static sp<WindowInfosListenerReporter> getInstance();
     binder::Status onWindowInfosChanged(const gui::WindowInfosUpdate& update) override;
-    status_t addWindowInfosListener(
-            const sp<gui::WindowInfosListener>& windowInfosListener,
-            const sp<gui::ISurfaceComposer>&,
-            std::pair<std::vector<gui::WindowInfo>, std::vector<gui::DisplayInfo>>* outInitialInfo);
+    android::base::Result<gui::WindowInfosUpdate> addWindowInfosListener(
+            sp<gui::WindowInfosListener> windowInfosListener, const sp<gui::ISurfaceComposer>&);
     status_t removeWindowInfosListener(const sp<gui::WindowInfosListener>& windowInfosListener,
                                        const sp<gui::ISurfaceComposer>& surfaceComposer);
     void reconnect(const sp<gui::ISurfaceComposer>&);
@@ -43,14 +42,15 @@ private:
     WindowInfosListenerReporter() = default;
     friend class sp<WindowInfosListenerReporter>;
 
-    std::mutex mListenersMutex;
-    std::unordered_set<sp<gui::WindowInfosListener>, gui::SpHash<gui::WindowInfosListener>>
-            mWindowInfosListeners GUARDED_BY(mListenersMutex);
+    using ListenerSet =
+            std::unordered_set<sp<gui::WindowInfosListener>, gui::SpHash<gui::WindowInfosListener>>;
 
-    std::vector<gui::WindowInfo> mLastWindowInfos GUARDED_BY(mListenersMutex);
-    std::vector<gui::DisplayInfo> mLastDisplayInfos GUARDED_BY(mListenersMutex);
+    static constexpr int64_t UNASSIGNED_LISTENER_ID = -1;
 
-    sp<gui::IWindowInfosPublisher> mWindowInfosPublisher;
-    int64_t mListenerId;
+    std::mutex mListenersMutex;
+    ListenerSet mWindowInfosListeners GUARDED_BY(mListenersMutex);
+    gui::WindowInfosUpdate mLastUpdate GUARDED_BY(mListenersMutex);
+    sp<gui::IWindowInfosPublisher> mWindowInfosPublisher GUARDED_BY(mListenersMutex);
+    int64_t mListenerId GUARDED_BY(mListenersMutex);
 };
 } // namespace android
diff --git a/libs/gui/include/gui/test/CallbackUtils.h b/libs/gui/include/gui/test/CallbackUtils.h
index 1c900e9da5..cf3e14e060 100644
--- a/libs/gui/include/gui/test/CallbackUtils.h
+++ b/libs/gui/include/gui/test/CallbackUtils.h
@@ -18,6 +18,7 @@
 #include <gtest/gtest.h>
 #include <gui/SurfaceComposerClient.h>
 #include <gui/SurfaceControl.h>
+#include <private/gui/SyncFeatures.h>
 #include <ui/Fence.h>
 #include <utils/Timers.h>
 #include <chrono>
@@ -95,18 +96,21 @@ public:
         if (mTransactionResult == ExpectedResult::Transaction::PRESENTED) {
             ASSERT_GE(latchTime, 0) << "bad latch time";
             ASSERT_NE(presentFence, nullptr);
-            if (mExpectedPresentTime >= 0) {
-                ASSERT_EQ(presentFence->wait(3000), NO_ERROR);
-                ASSERT_GE(presentFence->getSignalTime(), mExpectedPresentTime - nsecs_t(5 * 1e6));
-                // if the panel is running at 30 hz, at the worst case, our expected time just
-                // misses vsync and we have to wait another 33.3ms
-                ASSERT_LE(presentFence->getSignalTime(),
-                          mExpectedPresentTime + nsecs_t(66.666666 * 1e6));
-            } else if (mExpectedPresentTimeForVsyncId >= 0) {
-                ASSERT_EQ(presentFence->wait(3000), NO_ERROR);
-                // We give 4ms for prediction error
-                ASSERT_GE(presentFence->getSignalTime(),
-                          mExpectedPresentTimeForVsyncId - 4'000'000);
+            if (SyncFeatures::getInstance().useNativeFenceSync()) {
+                if (mExpectedPresentTime >= 0) {
+                    ASSERT_EQ(presentFence->wait(3000), NO_ERROR);
+                    ASSERT_GE(presentFence->getSignalTime(),
+                            mExpectedPresentTime - nsecs_t(5 * 1e6));
+                    // if the panel is running at 30 hz, at the worst case, our expected time just
+                    // misses vsync and we have to wait another 33.3ms
+                    ASSERT_LE(presentFence->getSignalTime(),
+                              mExpectedPresentTime + nsecs_t(66.666666 * 1e6));
+                } else if (mExpectedPresentTimeForVsyncId >= 0) {
+                    ASSERT_EQ(presentFence->wait(3000), NO_ERROR);
+                    // We give 4ms for prediction error
+                    ASSERT_GE(presentFence->getSignalTime(),
+                              mExpectedPresentTimeForVsyncId - 4'000'000);
+                }
             }
         } else {
             ASSERT_EQ(presentFence, nullptr) << "transaction shouldn't have been presented";
@@ -150,12 +154,16 @@ private:
                 }
             }
 
-            if (mBufferResult == ExpectedResult::Buffer::ACQUIRED) {
-                ASSERT_GT(acquireTime, 0) << "acquire time should be valid";
-            } else {
-                ASSERT_LE(acquireTime, 0) << "acquire time should not be valid";
+            // If the device doesn't have native fence support, skip validating the acquire time.
+            // Cuttlefish uses a fence with a signal time of -1 to indicate completion.
+            if (SyncFeatures::getInstance().useNativeFenceSync()) {
+                if (mBufferResult == ExpectedResult::Buffer::ACQUIRED) {
+                    ASSERT_GT(acquireTime, 0) << "acquire time should be valid";
+                } else {
+                    ASSERT_LE(acquireTime, 0) << "acquire time should not be valid";
+                }
+                ASSERT_EQ(acquireTime > 0, mBufferResult == ExpectedResult::Buffer::ACQUIRED);
             }
-            ASSERT_EQ(acquireTime > 0, mBufferResult == ExpectedResult::Buffer::ACQUIRED);
 
             if (mPreviousBufferResult == ExpectedResult::PreviousBuffer::RELEASED) {
                 ASSERT_NE(previousReleaseFence, nullptr)
diff --git a/libs/gui/include/gui/view/Surface.h b/libs/gui/include/gui/view/Surface.h
index bd8704ddc7..69c6dc151c 100644
--- a/libs/gui/include/gui/view/Surface.h
+++ b/libs/gui/include/gui/view/Surface.h
@@ -48,10 +48,9 @@ class Surface : public Parcelable {
     sp<IGraphicBufferProducer> graphicBufferProducer;
     sp<IBinder> surfaceControlHandle;
 
-#if WB_LIBCAMERASERVICE_WITH_DEPENDENCIES
     // functions used to convert to a parcelable Surface so it can be passed over binder.
     static Surface fromSurface(const sp<android::Surface>& surface);
-    sp<android::Surface> toSurface() const;
+    sp<android::Surface> toSurface(bool controlledByApp = false) const;
 
     status_t getUniqueId(/* out */ uint64_t* id) const;
 
@@ -70,7 +69,6 @@ class Surface : public Parcelable {
         return graphicBufferProducer < other.graphicBufferProducer;
     }
     bool operator>(const Surface& other) const { return other < *this; }
-#endif
 
     virtual status_t writeToParcel(Parcel* parcel) const override;
     virtual status_t readFromParcel(const Parcel* parcel) override;
diff --git a/libs/gui/libgui_flags.aconfig b/libs/gui/libgui_flags.aconfig
index ce1bc9512c..53b2677e07 100644
--- a/libs/gui/libgui_flags.aconfig
+++ b/libs/gui/libgui_flags.aconfig
@@ -9,14 +9,6 @@ flag {
   is_fixed_read_only: true
 } # apply_picture_profiles
 
-flag {
-  name: "bq_setframerate"
-  namespace: "core_graphics"
-  description: "This flag controls plumbing setFrameRate thru BufferQueue"
-  bug: "281695725"
-  is_fixed_read_only: true
-} # bq_setframerate
-
 flag {
   name: "bq_consumer_attach_callback"
   namespace: "core_graphics"
@@ -25,6 +17,13 @@ flag {
   is_fixed_read_only: true
 } # bq_consumer_attach_callback
 
+flag {
+  name: "cursor_plane_compatibility"
+  namespace: "desktop_display"
+  description: "configure cursor surface to meet cursor plane buffer requirements"
+  bug: "352067404"
+} # cursor_plane_compatibility
+
 flag {
   name: "frametimestamps_previousrelease"
   namespace: "core_graphics"
@@ -41,17 +40,6 @@ flag {
   is_fixed_read_only: true
 } # bq_extendedallocate
 
-flag {
-  name: "trace_frame_rate_override"
-  namespace: "core_graphics"
-  description: "Trace FrameRateOverride fps"
-  bug: "347314033"
-  is_fixed_read_only: true
-  metadata {
-    purpose: PURPOSE_BUGFIX
-  }
-} # trace_frame_rate_override
-
 flag {
   name: "wb_consumer_base_owns_bq"
   namespace: "core_graphics"
@@ -92,14 +80,6 @@ flag {
   is_fixed_read_only: true
 } # wb_ring_buffer
 
-flag {
-  name: "wb_camera3_and_processors"
-  namespace: "core_graphics"
-  description: "Remove usage of IGBPs in the *Processor and Camera3*"
-  bug: "342199002"
-  is_fixed_read_only: true
-} # wb_camera3_and_processors
-
 flag {
   name: "wb_libcameraservice"
   namespace: "core_graphics"
@@ -139,25 +119,3 @@ flag {
   bug: "340934031"
   is_fixed_read_only: true
 } # wb_media_migration
-
-flag {
-  name: "allocate_buffer_priority"
-  namespace: "wear_system_health"
-  description: "Boost priority for buffer allocation"
-  bug: "399701430"
-  metadata {
-    purpose: PURPOSE_BUGFIX
-  }
-  is_fixed_read_only: true
-} # allocate_buffer_priority
-
-flag {
-  name: "bq_always_use_max_dequeued_buffer_count"
-  namespace: "core_graphics"
-  description: "BufferQueueProducer::dequeue's respects setMaxDequeuedBufferCount even before a buffer is dequeued."
-  bug: "399328309"
-  metadata {
-    purpose: PURPOSE_BUGFIX
-  }
-  is_fixed_read_only: true
-} # bq_always_use_max_dequeued_buffer_count
diff --git a/libs/gui/tests/Android.bp b/libs/gui/tests/Android.bp
index bd53031e79..b638ba2f61 100644
--- a/libs/gui/tests/Android.bp
+++ b/libs/gui/tests/Android.bp
@@ -51,12 +51,15 @@ cc_test {
         "-Werror",
         "-Wextra",
         "-Wthread-safety",
+        // Allow access to buffer queue core private members
+        "-DENABLE_BQC_TESTING",
     ],
 
     srcs: [
         "BLASTBufferQueue_test.cpp",
         "BufferItemConsumer_test.cpp",
         "BufferQueue_test.cpp",
+        "BufferQueueConsumer_test.cpp",
         "BufferReleaseChannel_test.cpp",
         "Choreographer_test.cpp",
         "CompositorTiming_test.cpp",
diff --git a/libs/gui/tests/BLASTBufferQueue_test.cpp b/libs/gui/tests/BLASTBufferQueue_test.cpp
index 4e4c8a2b63..303d900935 100644
--- a/libs/gui/tests/BLASTBufferQueue_test.cpp
+++ b/libs/gui/tests/BLASTBufferQueue_test.cpp
@@ -79,10 +79,11 @@ private:
 
 class TestBLASTBufferQueue : public BLASTBufferQueue {
 public:
-    TestBLASTBufferQueue(const std::string& name, const sp<SurfaceControl>& surface, int width,
-                         int height, int32_t format)
-          : BLASTBufferQueue(name) {
-        update(surface, width, height, format);
+    static sp<TestBLASTBufferQueue> create(const sp<SurfaceControl>& surface, int width,
+                                           int height) {
+        auto blastBufferQueueAdapter = sp<TestBLASTBufferQueue>::make("TestBLASTBufferQueue");
+        blastBufferQueueAdapter->update(surface, width, height, PIXEL_FORMAT_RGBA_8888);
+        return blastBufferQueueAdapter;
     }
 
     void transactionCallback(nsecs_t latchTime, const sp<Fence>& presentFence,
@@ -106,6 +107,9 @@ public:
     }
 
 private:
+    friend class sp<TestBLASTBufferQueue>;
+    TestBLASTBufferQueue(const std::string& name) : BLASTBufferQueue(name) {}
+
     std::mutex frameNumberMutex;
     std::condition_variable mWaitForCallbackCV;
     int64_t mLastTransactionFrameNumber = -1;
@@ -114,8 +118,7 @@ private:
 class BLASTBufferQueueHelper {
 public:
     BLASTBufferQueueHelper(const sp<SurfaceControl>& sc, int width, int height) {
-        mBlastBufferQueueAdapter = sp<TestBLASTBufferQueue>::make("TestBLASTBufferQueue", sc, width,
-                                                                  height, PIXEL_FORMAT_RGBA_8888);
+        mBlastBufferQueueAdapter = TestBLASTBufferQueue::create(sc, width, height);
     }
 
     void update(const sp<SurfaceControl>& sc, int width, int height) {
@@ -192,6 +195,8 @@ public:
         mBlastBufferQueueAdapter->setApplyToken(std::move(applyToken));
     }
 
+    void dropBbq() { mBlastBufferQueueAdapter.clear(); }
+
 private:
     sp<TestBLASTBufferQueue> mBlastBufferQueueAdapter;
 };
@@ -1418,25 +1423,69 @@ TEST_F(BLASTBufferQueueTest, TransformHint) {
     ASSERT_EQ(ui::Transform::ROT_90, static_cast<ui::Transform::RotationFlags>(transformHint));
 
     ANativeWindow_Buffer buffer;
-    surface->lock(&buffer, nullptr /* inOutDirtyBounds */);
+    ASSERT_EQ(NO_ERROR, surface->lock(&buffer, nullptr /* inOutDirtyBounds */));
 
     // Transform hint is updated via callbacks or surface control updates
     mSurfaceControl->setTransformHint(ui::Transform::ROT_0);
     adapter.update(mSurfaceControl, mDisplayWidth, mDisplayHeight);
 
     // The hint does not change and matches the value used when dequeueing the buffer.
-    surface->query(NATIVE_WINDOW_TRANSFORM_HINT, &transformHint);
+    ASSERT_EQ(NO_ERROR, surface->query(NATIVE_WINDOW_TRANSFORM_HINT, &transformHint));
     ASSERT_EQ(ui::Transform::ROT_90, static_cast<ui::Transform::RotationFlags>(transformHint));
 
-    surface->unlockAndPost();
+    ASSERT_EQ(NO_ERROR, surface->unlockAndPost());
 
     // After queuing the buffer, we get the updated transform hint
-    surface->query(NATIVE_WINDOW_TRANSFORM_HINT, &transformHint);
+    ASSERT_EQ(NO_ERROR, surface->query(NATIVE_WINDOW_TRANSFORM_HINT, &transformHint));
     ASSERT_EQ(ui::Transform::ROT_0, static_cast<ui::Transform::RotationFlags>(transformHint));
 
     adapter.waitForCallbacks();
 }
 
+// Verifies that we don't deadlock if BufferQueueProducer::cancelBuffer is called on a thread
+// right before the owner of BBQ drops its strong pointer (b/410458641). This test is
+// non-deterministic and sensitive to timings. The owning BBQ pointer may be dropped before,
+// during, or after notifyBufferReleased is called. This test could be improved by mocking
+// the BufferReleaseReader, forcing it to wait until after we drop the BBQ pointer. Doing so
+// would require injecting a mock BufferReleaseReader into BBQ which is difficult to do with the
+// current code structure.
+TEST_F(BLASTBufferQueueTest, CancelBuffer_NoDeadlock) {
+    for (int i = 0; i < 100; i++) {
+        BLASTBufferQueueHelper adapter(mSurfaceControl, mDisplayWidth, mDisplayHeight);
+        sp<IGraphicBufferProducer> producer;
+        setUpProducer(adapter, producer);
+
+        int slot;
+        sp<Fence> fence;
+        sp<GraphicBuffer> buf;
+        status_t status = producer->dequeueBuffer(&slot, &fence, mDisplayWidth, mDisplayHeight,
+                                                  PIXEL_FORMAT_RGBA_8888,
+                                                  GRALLOC_USAGE_SW_WRITE_OFTEN, nullptr, nullptr);
+        ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION, status);
+        ASSERT_EQ(OK, producer->requestBuffer(slot, &buf));
+
+        bool threadComplete = false;
+        std::mutex threadCompleteMutex;
+        std::condition_variable threadCompleteCondition;
+
+        std::thread thread([&]() {
+            producer->cancelBuffer(slot, fence);
+            std::lock_guard lock{threadCompleteMutex};
+            threadComplete = true;
+            threadCompleteCondition.notify_one();
+        });
+
+        // Give the background thread some time to start up before dropping the BBQ pointer.
+        std::this_thread::sleep_for(1ms);
+
+        adapter.dropBbq();
+        std::unique_lock lock{threadCompleteMutex};
+        ASSERT_TRUE(threadCompleteCondition.wait_for(lock, 5s, [&]() { return threadComplete; }))
+                << "Failed to join background thread, likely indicates deadlock";
+        thread.join();
+    }
+}
+
 class BLASTBufferQueueTransformTest : public BLASTBufferQueueTest {
 public:
     void test(uint32_t tr) {
diff --git a/libs/gui/tests/BufferItemConsumer_test.cpp b/libs/gui/tests/BufferItemConsumer_test.cpp
index 80eea267bf..f32caf3802 100644
--- a/libs/gui/tests/BufferItemConsumer_test.cpp
+++ b/libs/gui/tests/BufferItemConsumer_test.cpp
@@ -268,7 +268,6 @@ TEST_F(BufferItemConsumerTest, AttachBuffer) {
     EXPECT_EQ(OK, mBIC->releaseBuffer(newBuffer2, Fence::NO_FENCE));
 }
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
 // Test that delete BufferItemConsumer triggers onBufferFreed.
 TEST_F(BufferItemConsumerTest, DetachBufferWithBuffer) {
     int slot;
@@ -281,7 +280,6 @@ TEST_F(BufferItemConsumerTest, DetachBufferWithBuffer) {
     EXPECT_EQ(OK, mBIC->detachBuffer(buffer));
     EXPECT_THAT(mDetachedBufferSlots, testing::ElementsAre(slot));
 }
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
 
 #if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_UNLIMITED_SLOTS)
 TEST_F(BufferItemConsumerTest, UnlimitedSlots_AcquireReleaseAll) {
diff --git a/libs/gui/tests/BufferQueueConsumer_test.cpp b/libs/gui/tests/BufferQueueConsumer_test.cpp
new file mode 100644
index 0000000000..1f44b989b7
--- /dev/null
+++ b/libs/gui/tests/BufferQueueConsumer_test.cpp
@@ -0,0 +1,161 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ENABLE_BQC_TESTING
+#define ENABLE_BQC_TESTING
+#endif
+
+#define LOG_TAG "BufferQueueConsumer_test"
+
+#include <gui/BufferItem.h>
+#include <gui/BufferQueueConsumer.h>
+#include <gui/BufferQueueCore.h>
+#include <gui/BufferQueueProducer.h>
+#include <gui/IConsumerListener.h>
+#include <ui/GraphicTypes.h>
+#include <ui/Rect.h>
+#include <utils/Timers.h>
+
+#include <mutex>
+#include <vector>
+
+#include <gtest/gtest.h>
+
+namespace android {
+
+class TestableBufferQueueCore : public BufferQueueCore {
+public:
+    TestableBufferQueueCore() = default;
+    ~TestableBufferQueueCore() override = default;
+
+    void ConfigureQueueStateViaFriend(const std::vector<android::BufferItem>& initialQueue) {
+        this->mQueue.clear();
+        for (const auto& item : initialQueue) {
+            this->mQueue.push_back(item);
+        }
+    }
+
+    size_t getQueueSizeForTest() { return this->mQueue.size(); }
+
+    android::BufferItem getQueueFrontForTest() {
+        return this->mQueue.empty() ? android::BufferItem() : this->mQueue.itemAt(0);
+    }
+};
+
+class BufferQueueConsumerVkTimingTest : public ::testing::Test {
+protected:
+    sp<TestableBufferQueueCore> mTestableCore;
+    sp<BufferQueueConsumer> mConsumer;
+
+    virtual void SetUp() override {
+        mTestableCore = sp<TestableBufferQueueCore>::make();
+        mConsumer = sp<BufferQueueConsumer>::make(mTestableCore);
+    }
+
+    virtual void TearDown() override {
+        mConsumer.clear();
+        mTestableCore.clear();
+    }
+
+    android::BufferItem CreateBufferItem(int slot, uint64_t frameNum, nsecs_t timestamp,
+                                         bool isReady = true, bool isAutoTimestamp = true,
+                                         bool isStale = false, bool isDroppable = true) {
+        android::BufferItem item;
+        item.mSlot = slot;
+        item.mFrameNumber = frameNum;
+        item.mTimestamp = timestamp;
+        item.mGraphicBuffer = nullptr;
+        item.mFence = isReady ? Fence::NO_FENCE : new Fence();
+        item.mIsStale = isStale;
+        item.mIsDroppable = isDroppable;
+        item.mAcquireCalled = false;
+        item.mIsAutoTimestamp = isAutoTimestamp;
+        item.mCrop = Rect::INVALID_RECT;
+        item.mTransform = 0;
+        //            item.mScalingMode = NATIVE_WINDOW_SCALING_MODE_FREEZE;
+        item.mDataSpace = HAL_DATASPACE_UNKNOWN;
+        item.mSurfaceDamage = Region::INVALID_REGION;
+        item.mQueuedBuffer = true;
+        item.mAutoRefresh = false;
+        item.mApi = 0;
+        item.mTransformToDisplayInverse = false;
+        return item;
+    }
+
+    void runBufferTest(nsecs_t expectedPresentTime, int expectedAcquiredSlotNum,
+                       size_t expectedAcquiredFrameNum, size_t expectedNumberOfDroppedBuffers,
+                       uint64_t maxFrameNumber = 99) {
+        std::vector<BufferItem> queue = {CreateBufferItem(0, 0, 10000, true /*isReady*/,
+                                                          false /*isAutoGeneratedTimestamp*/),
+                                         CreateBufferItem(1, 1, 20000, true, false),
+                                         CreateBufferItem(2, 2, 30000, true, true),
+                                         CreateBufferItem(3, 3, 40000, true, true),
+                                         CreateBufferItem(4, 4, 50000, true, false),
+                                         CreateBufferItem(5, 5, 60000, true, false),
+                                         CreateBufferItem(6, 6, 70000, true, true),
+                                         CreateBufferItem(7, 7, 80000, false, true),
+                                         CreateBufferItem(8, 8, 90000, false, true)};
+        mTestableCore->ConfigureQueueStateViaFriend(queue);
+
+        BufferItem acquiredBuffer;
+        status_t result =
+                mConsumer->acquireBuffer(&acquiredBuffer, expectedPresentTime, maxFrameNumber);
+
+        EXPECT_EQ(result, android::OK);
+        EXPECT_EQ(acquiredBuffer.mSlot, expectedAcquiredSlotNum);
+        EXPECT_EQ(acquiredBuffer.mFrameNumber, expectedAcquiredFrameNum);
+
+        EXPECT_EQ(mTestableCore->getQueueSizeForTest(), (size_t)9 - expectedNumberOfDroppedBuffers);
+        if (mTestableCore->getQueueSizeForTest() > 0) {
+            android::BufferItem frontItem = mTestableCore->getQueueFrontForTest();
+            EXPECT_EQ(frontItem.mSlot, expectedAcquiredSlotNum + 1);
+        }
+    }
+};
+
+TEST_F(BufferQueueConsumerVkTimingTest, FifoLatestReadyTestZeroExpectPresent) {
+    // Verify that we dequeue and acquire only the first frame when expected present is 0
+    nsecs_t expectedPresentTime = 0;
+    int expectedAcquiredSlotNum = 0;
+    size_t expectedAcquiredFrameNum = 0;
+    size_t expectedNumberOfDroppedBuffers = 1;
+    runBufferTest(expectedPresentTime, expectedAcquiredSlotNum, expectedAcquiredFrameNum,
+                  expectedNumberOfDroppedBuffers);
+}
+
+TEST_F(BufferQueueConsumerVkTimingTest, FifoLatestReadyTestBasicTimestamp) {
+    // Verify that we dequeue the first frame (with timestamp 1000) and acquire the second frame
+    // based on  it's timestamp of 2000
+    nsecs_t expectedPresentTime = 21000;
+    int expectedAcquiredSlotNum = 1;
+    size_t expectedAcquiredFrameNum = 1;
+    size_t expectedNumberOfDroppedBuffers = 2;
+    runBufferTest(expectedPresentTime, expectedAcquiredSlotNum, expectedAcquiredFrameNum,
+                  expectedNumberOfDroppedBuffers);
+}
+
+TEST_F(BufferQueueConsumerVkTimingTest, FifoLatestReadyTestBasicLaterTimestamp) {
+    // Verify that we dequeue up until the 3rd frame with timestamp of 3000. We don't dequeue the
+    // next frame even though it's timestamp is in the past because
+    nsecs_t expectedPresentTime = 41000;
+    int expectedAcquiredSlotNum = 2;
+    size_t expectedAcquiredFrameNum = 2;
+    size_t expectedNumberOfDroppedBuffers = 3;
+    runBufferTest(expectedPresentTime, expectedAcquiredSlotNum, expectedAcquiredFrameNum,
+                  expectedNumberOfDroppedBuffers);
+}
+
+} // namespace android
diff --git a/libs/gui/tests/BufferQueue_test.cpp b/libs/gui/tests/BufferQueue_test.cpp
index e22f57e43e..2962b4487d 100644
--- a/libs/gui/tests/BufferQueue_test.cpp
+++ b/libs/gui/tests/BufferQueue_test.cpp
@@ -15,7 +15,7 @@
  */
 
 #define LOG_TAG "BufferQueue_test"
-//#define LOG_NDEBUG 0
+// #define LOG_NDEBUG 0
 
 #include "Constants.h"
 #include "MockConsumer.h"
@@ -30,6 +30,7 @@
 
 #include <ui/GraphicBuffer.h>
 #include <ui/PictureProfileHandle.h>
+#include <ui/PixelFormat.h>
 
 #include <android-base/properties.h>
 #include <android-base/unique_fd.h>
@@ -385,7 +386,8 @@ TEST_F(BufferQueueTest, DetachAndReattachOnProducerSide) {
     sp<Fence> fence;
     sp<GraphicBuffer> buffer;
     ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, GRALLOC_USAGE_SW_WRITE_OFTEN,
+              mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0,
+                                       GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN,
                                        nullptr, nullptr));
     ASSERT_EQ(BAD_VALUE, mProducer->detachBuffer(slot)); // Not requested
     ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buffer));
@@ -434,7 +436,8 @@ TEST_F(BufferQueueTest, DetachAndReattachOnConsumerSide) {
     sp<Fence> fence;
     sp<GraphicBuffer> buffer;
     ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, GRALLOC_USAGE_SW_WRITE_OFTEN,
+              mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0,
+                                       GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN,
                                        nullptr, nullptr));
     ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buffer));
     IGraphicBufferProducer::QueueBufferInput input(0, false,
@@ -492,7 +495,8 @@ TEST_F(BufferQueueTest, MoveFromConsumerToProducer) {
     sp<Fence> fence;
     sp<GraphicBuffer> buffer;
     ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, GRALLOC_USAGE_SW_WRITE_OFTEN,
+              mProducer->dequeueBuffer(&slot, &fence, 0, 0, 0,
+                                       GRALLOC_USAGE_SW_WRITE_OFTEN | GRALLOC_USAGE_SW_READ_OFTEN,
                                        nullptr, nullptr));
     ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buffer));
 
diff --git a/libs/gui/tests/Constants.h b/libs/gui/tests/Constants.h
index 85c0f9faab..68111195e9 100644
--- a/libs/gui/tests/Constants.h
+++ b/libs/gui/tests/Constants.h
@@ -19,4 +19,5 @@
 #include <hardware/gralloc.h>
 
 // Arbitrary non-zero usage flag.
-constexpr uint64_t TEST_PRODUCER_USAGE_BITS = GRALLOC_USAGE_SW_READ_RARELY;
+constexpr uint64_t TEST_PRODUCER_USAGE_BITS =
+        GRALLOC_USAGE_SW_READ_RARELY | GRALLOC_USAGE_SW_WRITE_RARELY;
diff --git a/libs/gui/tests/DisplayEventStructLayout_test.cpp b/libs/gui/tests/DisplayEventStructLayout_test.cpp
index 791f471a1d..73cee11738 100644
--- a/libs/gui/tests/DisplayEventStructLayout_test.cpp
+++ b/libs/gui/tests/DisplayEventStructLayout_test.cpp
@@ -64,6 +64,8 @@ TEST(DisplayEventStructLayoutTest, TestEventAlignment) {
 
     CHECK_OFFSET(DisplayEventReceiver::Event::ModeChange, modeId, 0);
     CHECK_OFFSET(DisplayEventReceiver::Event::ModeChange, vsyncPeriod, 8);
+    CHECK_OFFSET(DisplayEventReceiver::Event::ModeChange, appVsyncOffset, 16);
+    CHECK_OFFSET(DisplayEventReceiver::Event::ModeChange, presentationDeadline, 24);
 
     CHECK_OFFSET(DisplayEventReceiver::Event::FrameRateOverride, uid, 0);
     CHECK_OFFSET(DisplayEventReceiver::Event::FrameRateOverride, frameRateHz, 8);
diff --git a/libs/gui/tests/EndToEndNativeInputTest.cpp b/libs/gui/tests/EndToEndNativeInputTest.cpp
index 5a5067b2b9..a62fd09348 100644
--- a/libs/gui/tests/EndToEndNativeInputTest.cpp
+++ b/libs/gui/tests/EndToEndNativeInputTest.cpp
@@ -206,17 +206,17 @@ public:
         EXPECT_EQ(AMOTION_EVENT_ACTION_DOWN, mev->getAction());
         EXPECT_NEAR(x, mev->getX(0), EPSILON);
         EXPECT_NEAR(y, mev->getY(0), EPSILON);
-        EXPECT_EQ(0, mev->getFlags() & VERIFIED_MOTION_EVENT_FLAGS);
+        EXPECT_EQ(ftl::Flags<MotionFlag>{}, mev->getFlags() & VERIFIED_MOTION_EVENT_FLAGS);
 
         ev = consumeEvent();
         ASSERT_NE(ev, nullptr);
         ASSERT_EQ(InputEventType::MOTION, ev->getType());
         mev = static_cast<MotionEvent*>(ev);
         EXPECT_EQ(AMOTION_EVENT_ACTION_UP, mev->getAction());
-        EXPECT_EQ(0, mev->getFlags() & VERIFIED_MOTION_EVENT_FLAGS);
+        EXPECT_EQ(ftl::Flags<MotionFlag>{}, mev->getFlags() & VERIFIED_MOTION_EVENT_FLAGS);
     }
 
-    void expectTapWithFlag(int x, int y, int32_t flags) {
+    void expectTapWithFlag(int x, int y, ftl::Flags<MotionFlag> flags) {
         InputEvent* ev = consumeEvent();
         ASSERT_NE(ev, nullptr);
         ASSERT_EQ(InputEventType::MOTION, ev->getType());
@@ -243,14 +243,14 @@ public:
         const PointerCoords& coords = *mev->getRawPointerCoords(0 /*pointerIndex*/);
         EXPECT_NEAR(displayX, coords.getX(), EPSILON);
         EXPECT_NEAR(displayY, coords.getY(), EPSILON);
-        EXPECT_EQ(0, mev->getFlags() & VERIFIED_MOTION_EVENT_FLAGS);
+        EXPECT_EQ(ftl::Flags<MotionFlag>{}, mev->getFlags() & VERIFIED_MOTION_EVENT_FLAGS);
 
         ev = consumeEvent();
         ASSERT_NE(ev, nullptr);
         ASSERT_EQ(InputEventType::MOTION, ev->getType());
         mev = static_cast<MotionEvent*>(ev);
         EXPECT_EQ(AMOTION_EVENT_ACTION_UP, mev->getAction());
-        EXPECT_EQ(0, mev->getFlags() & VERIFIED_MOTION_EVENT_FLAGS);
+        EXPECT_EQ(ftl::Flags<MotionFlag>{}, mev->getFlags() & VERIFIED_MOTION_EVENT_FLAGS);
     }
 
     void expectKey(int32_t keycode) {
@@ -863,7 +863,7 @@ TEST_F(InputSurfacesTest, touch_flag_obscured) {
     nonTouchableSurface->showAt(100, 100);
 
     injectTap(190, 199);
-    surface->expectTapWithFlag(90, 99, AMOTION_EVENT_FLAG_WINDOW_IS_OBSCURED);
+    surface->expectTapWithFlag(90, 99, MotionFlag::WINDOW_IS_OBSCURED);
 }
 
 TEST_F(InputSurfacesTest, touch_flag_partially_obscured_with_crop) {
@@ -891,7 +891,7 @@ TEST_F(InputSurfacesTest, touch_flag_partially_obscured_with_crop) {
     });
 
     injectTap(190, 199);
-    surface->expectTapWithFlag(90, 99, AMOTION_EVENT_FLAG_WINDOW_IS_PARTIALLY_OBSCURED);
+    surface->expectTapWithFlag(90, 99, MotionFlag::WINDOW_IS_PARTIALLY_OBSCURED);
 }
 
 TEST_F(InputSurfacesTest, touch_not_obscured_with_crop) {
diff --git a/libs/gui/tests/FrameRateUtilsTest.cpp b/libs/gui/tests/FrameRateUtilsTest.cpp
index c5025331e1..a1117c0fc4 100644
--- a/libs/gui/tests/FrameRateUtilsTest.cpp
+++ b/libs/gui/tests/FrameRateUtilsTest.cpp
@@ -65,12 +65,10 @@ TEST(FrameRateUtilsTest, ValidateFrameRate) {
     EXPECT_FALSE(ValidateFrameRate(60.0f, 3, ANATIVEWINDOW_CHANGE_FRAME_RATE_ONLY_IF_SEAMLESS, ""));
 
     // Invalid change frame rate strategy.
-    if (flags::bq_setframerate()) {
-        EXPECT_FALSE(
-                ValidateFrameRate(60.0f, ANATIVEWINDOW_FRAME_RATE_COMPATIBILITY_DEFAULT, -1, ""));
-        EXPECT_FALSE(
-                ValidateFrameRate(60.0f, ANATIVEWINDOW_FRAME_RATE_COMPATIBILITY_DEFAULT, 2, ""));
-    }
+    EXPECT_FALSE(
+            ValidateFrameRate(60.0f, ANATIVEWINDOW_FRAME_RATE_COMPATIBILITY_DEFAULT, -1, ""));
+    EXPECT_FALSE(
+            ValidateFrameRate(60.0f, ANATIVEWINDOW_FRAME_RATE_COMPATIBILITY_DEFAULT, 2, ""));
 }
 
 } // namespace android
diff --git a/libs/gui/tests/RegionSampling_test.cpp b/libs/gui/tests/RegionSampling_test.cpp
index d80d223f49..b7e1c4258c 100644
--- a/libs/gui/tests/RegionSampling_test.cpp
+++ b/libs/gui/tests/RegionSampling_test.cpp
@@ -212,6 +212,23 @@ protected:
                 .setPosition(mTopLayer, 0, 0)
                 .show(mBackgroundLayer)
                 .apply();
+
+        // Cache any existing listeners that could impact luma sampling test results
+        sp<gui::ISurfaceComposer> composer = ComposerServiceAIDL::getComposerService();
+        composer->getRegionSamplingListeners(&mExistingListeners);
+        for (const auto& descriptor : mExistingListeners) {
+            composer->removeRegionSamplingListener(descriptor.listener);
+        }
+    }
+
+    void TearDown() override {
+        // Restore device state by re-adding listeners that were present prior to the test run
+        sp<gui::ISurfaceComposer> composer = ComposerServiceAIDL::getComposerService();
+        for (const auto& descriptor : mExistingListeners) {
+            composer->addRegionSamplingListenerWithStopLayerId(descriptor.area,
+                                                               descriptor.stopLayerId,
+                                                               descriptor.listener);
+        }
     }
 
     void fill_render(uint32_t rgba_value) {
@@ -234,6 +251,7 @@ protected:
     sp<SurfaceControl> mBackgroundLayer;
     sp<SurfaceControl> mContentLayer;
     sp<SurfaceControl> mTopLayer;
+    std::vector<gui::RegionSamplingDescriptor> mExistingListeners;
 
     uint32_t const rgba_green = 0xFF00FF00;
     float const luma_green = 0.7152;
diff --git a/libs/gui/tests/StreamSplitter_test.cpp b/libs/gui/tests/StreamSplitter_test.cpp
index 9570a369bd..55d36e82b4 100644
--- a/libs/gui/tests/StreamSplitter_test.cpp
+++ b/libs/gui/tests/StreamSplitter_test.cpp
@@ -67,7 +67,9 @@ TEST_F(StreamSplitterTest, OneInputOneOutput) {
     sp<Fence> fence;
     sp<GraphicBuffer> buffer;
     ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              inputProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, GRALLOC_USAGE_SW_WRITE_OFTEN,
+              inputProducer->dequeueBuffer(&slot, &fence, 0, 0, 0,
+                                           GRALLOC_USAGE_SW_READ_OFTEN |
+                                                   GRALLOC_USAGE_SW_WRITE_OFTEN,
                                            nullptr, nullptr));
     ASSERT_EQ(OK, inputProducer->requestBuffer(slot, &buffer));
 
@@ -138,7 +140,9 @@ TEST_F(StreamSplitterTest, OneInputMultipleOutputs) {
     sp<Fence> fence;
     sp<GraphicBuffer> buffer;
     ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-              inputProducer->dequeueBuffer(&slot, &fence, 0, 0, 0, GRALLOC_USAGE_SW_WRITE_OFTEN,
+              inputProducer->dequeueBuffer(&slot, &fence, 0, 0, 0,
+                                           GRALLOC_USAGE_SW_READ_OFTEN |
+                                                   GRALLOC_USAGE_SW_WRITE_OFTEN,
                                            nullptr, nullptr));
     ASSERT_EQ(OK, inputProducer->requestBuffer(slot, &buffer));
 
diff --git a/libs/gui/tests/SurfaceTextureGL_test.cpp b/libs/gui/tests/SurfaceTextureGL_test.cpp
index b22b85332c..1e995a36e0 100644
--- a/libs/gui/tests/SurfaceTextureGL_test.cpp
+++ b/libs/gui/tests/SurfaceTextureGL_test.cpp
@@ -48,9 +48,9 @@ TEST_F(SurfaceTextureGLTest, TexturingFromCpuFilledYV12BufferNpot) {
 
     // Fill the buffer with the a checkerboard pattern
     uint8_t* img = nullptr;
-    buf->lock(GRALLOC_USAGE_SW_WRITE_OFTEN, (void**)(&img));
+    ASSERT_EQ(NO_ERROR, buf->lock(GRALLOC_USAGE_SW_WRITE_OFTEN, (void**)(&img)));
     fillYV12Buffer(img, texWidth, texHeight, buf->getStride());
-    buf->unlock();
+    ASSERT_EQ(NO_ERROR, buf->unlock());
     ASSERT_EQ(NO_ERROR, mANW->queueBuffer(mANW.get(), buf->getNativeBuffer(),
             -1));
 
@@ -98,9 +98,9 @@ TEST_F(SurfaceTextureGLTest, TexturingFromCpuFilledYV12BufferPow2) {
 
     // Fill the buffer with the a checkerboard pattern
     uint8_t* img = nullptr;
-    buf->lock(GRALLOC_USAGE_SW_WRITE_OFTEN, (void**)(&img));
+    ASSERT_EQ(NO_ERROR, buf->lock(GRALLOC_USAGE_SW_WRITE_OFTEN, (void**)(&img)));
     fillYV12Buffer(img, texWidth, texHeight, buf->getStride());
-    buf->unlock();
+    ASSERT_EQ(NO_ERROR, buf->unlock());
     ASSERT_EQ(NO_ERROR, mANW->queueBuffer(mANW.get(), buf->getNativeBuffer(),
             -1));
 
@@ -163,9 +163,9 @@ TEST_F(SurfaceTextureGLTest, TexturingFromCpuFilledYV12BufferWithCrop) {
         sp<GraphicBuffer> buf(GraphicBuffer::from(anb));
 
         uint8_t* img = nullptr;
-        buf->lock(GRALLOC_USAGE_SW_WRITE_OFTEN, (void**)(&img));
+        ASSERT_EQ(NO_ERROR, buf->lock(GRALLOC_USAGE_SW_WRITE_OFTEN, (void**)(&img)));
         fillYV12BufferRect(img, texWidth, texHeight, buf->getStride(), crop);
-        buf->unlock();
+        ASSERT_EQ(NO_ERROR, buf->unlock());
         ASSERT_EQ(NO_ERROR, mANW->queueBuffer(mANW.get(),
                 buf->getNativeBuffer(), -1));
 
@@ -737,7 +737,6 @@ TEST_F(SurfaceTextureGLTest, InvalidWidthOrHeightFails) {
     ASSERT_NE(NO_ERROR, mST->updateTexImage());
 }
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
 TEST_F(SurfaceTextureGLTest, TestUnlimitedSlots) {
     ASSERT_EQ(OK, mSTC->connect(NATIVE_WINDOW_API_CPU, sp<StubSurfaceListener>::make()));
     ASSERT_EQ(OK, mSTC->setMaxDequeuedBufferCount(256));
@@ -755,12 +754,11 @@ TEST_F(SurfaceTextureGLTest, TestUnlimitedSlots) {
         ASSERT_EQ(OK, graphicBuffer->lock(AHARDWAREBUFFER_USAGE_CPU_WRITE_OFTEN, &buf));
         fillRGBA8Buffer((uint8_t*)buf, graphicBuffer->getWidth(), graphicBuffer->getHeight(),
                         graphicBuffer->getStride(), i, i, i, i);
-        graphicBuffer->unlock();
+        ASSERT_EQ(NO_ERROR, graphicBuffer->unlock());
 
         ASSERT_EQ(OK, mSTC->queueBuffer(graphicBuffer, fence));
         ASSERT_EQ(OK, mST->updateTexImage());
         checkPixel(0, 0, i, i, i, i);
     }
 }
-#endif
 } // namespace android
diff --git a/libs/gui/tests/Surface_test.cpp b/libs/gui/tests/Surface_test.cpp
index 4fee11c2cb..6764f679be 100644
--- a/libs/gui/tests/Surface_test.cpp
+++ b/libs/gui/tests/Surface_test.cpp
@@ -37,6 +37,7 @@
 #include <gui/Surface.h>
 #include <gui/SurfaceComposerClient.h>
 #include <gui/SyncScreenCaptureListener.h>
+#include <gui/TransactionState.h>
 #include <gui/view/Surface.h>
 #include <nativebase/nativebase.h>
 #include <private/gui/ComposerService.h>
@@ -61,6 +62,7 @@
 
 #include "Constants.h"
 #include "MockConsumer.h"
+#include "hardware/gralloc.h"
 #include "testserver/TestServerClient.h"
 
 namespace android {
@@ -129,36 +131,8 @@ private:
 
 class SurfaceTest : public ::testing::Test {
 protected:
-    SurfaceTest() {
-        ProcessState::self()->startThreadPool();
-    }
-
-    virtual void SetUp() {
-        mComposerClient = sp<SurfaceComposerClient>::make();
-        ASSERT_EQ(NO_ERROR, mComposerClient->initCheck());
-
-        // TODO(brianderson): The following sometimes fails and is a source of
-        //   test flakiness.
-        mSurfaceControl = mComposerClient->createSurface(
-                String8("Test Surface"), 32, 32, PIXEL_FORMAT_RGBA_8888, 0);
-        SurfaceComposerClient::Transaction().apply(true);
-
-        ASSERT_TRUE(mSurfaceControl != nullptr);
-        ASSERT_TRUE(mSurfaceControl->isValid());
-
-        Transaction t;
-        ASSERT_EQ(NO_ERROR, t.setLayer(mSurfaceControl, 0x7fffffff).show(mSurfaceControl).apply());
-
-        mSurface = mSurfaceControl->getSurface();
-        ASSERT_TRUE(mSurface != nullptr);
-    }
-
-    virtual void TearDown() {
-        mComposerClient->dispose();
-    }
-
     void testSurfaceListener(bool hasSurfaceListener, bool enableReleasedCb,
-            int32_t extraDiscardedBuffers) {
+                             int32_t extraDiscardedBuffers) {
         sp<IGraphicBufferProducer> producer;
         sp<IGraphicBufferConsumer> consumer;
         BufferQueue::createBufferQueue(&producer, &consumer);
@@ -192,7 +166,7 @@ protected:
 
         ANativeWindowBuffer* buffer;
         // Fill BUFFER_COUNT-1 buffers
-        for (int i = 0; i < BUFFER_COUNT-1; i++) {
+        for (int i = 0; i < BUFFER_COUNT - 1; i++) {
             ASSERT_EQ(NO_ERROR, native_window_dequeue_buffer_and_wait(window.get(), &buffer));
             ASSERT_EQ(NO_ERROR, window->queueBuffer(window.get(), buffer, -1));
         }
@@ -202,7 +176,7 @@ protected:
 
         // Acquire and free 1+extraDiscardedBuffers buffer, check onBufferReleased is called.
         std::vector<BufferItem> releasedItems;
-        releasedItems.resize(1+extraDiscardedBuffers);
+        releasedItems.resize(1 + extraDiscardedBuffers);
         for (size_t i = 0; i < releasedItems.size(); i++) {
             ASSERT_EQ(NO_ERROR, consumer->acquireBuffer(&releasedItems[i], 0));
             ASSERT_EQ(NO_ERROR,
@@ -237,13 +211,46 @@ protected:
         // Disconnect the surface
         ASSERT_EQ(NO_ERROR, surface->disconnect(NATIVE_WINDOW_API_CPU));
     }
+};
+
+class SurfaceComposerSurfaceTest : public SurfaceTest {
+protected:
+    SurfaceComposerSurfaceTest() { ProcessState::self()->startThreadPool(); }
+
+    virtual void SetUp() override {
+        SurfaceTest::SetUp();
+
+        mComposerClient = sp<SurfaceComposerClient>::make();
+        ASSERT_EQ(NO_ERROR, mComposerClient->initCheck());
+
+        // TODO(brianderson): The following sometimes fails and is a source of
+        //   test flakiness.
+        mSurfaceControl = mComposerClient->createSurface(String8("Test Surface"), 32, 32,
+                                                         PIXEL_FORMAT_RGBA_8888, 0);
+        SurfaceComposerClient::Transaction().apply(true);
+
+        ASSERT_TRUE(mSurfaceControl != nullptr);
+        ASSERT_TRUE(mSurfaceControl->isValid());
+
+        Transaction t;
+        ASSERT_EQ(NO_ERROR, t.setLayer(mSurfaceControl, 0x7fffffff).show(mSurfaceControl).apply());
+
+        mSurface = mSurfaceControl->getSurface();
+        ASSERT_TRUE(mSurface != nullptr);
+    }
+
+    virtual void TearDown() {
+        SurfaceTest::TearDown();
+
+        mComposerClient->dispose();
+    }
 
     sp<Surface> mSurface;
     sp<SurfaceComposerClient> mComposerClient;
     sp<SurfaceControl> mSurfaceControl;
 };
 
-TEST_F(SurfaceTest, CreateSurfaceReturnsErrorBadClient) {
+TEST_F(SurfaceComposerSurfaceTest, CreateSurfaceReturnsErrorBadClient) {
     mComposerClient->dispose();
     ASSERT_EQ(NO_INIT, mComposerClient->initCheck());
 
@@ -253,7 +260,7 @@ TEST_F(SurfaceTest, CreateSurfaceReturnsErrorBadClient) {
     ASSERT_EQ(NO_INIT, err);
 }
 
-TEST_F(SurfaceTest, QueuesToWindowComposerIsTrueWhenVisible) {
+TEST_F(SurfaceComposerSurfaceTest, QueuesToWindowComposerIsTrueWhenVisible) {
     sp<ANativeWindow> anw(mSurface);
     int result = -123;
     int err = anw->query(anw.get(), NATIVE_WINDOW_QUEUES_TO_WINDOW_COMPOSER,
@@ -262,7 +269,7 @@ TEST_F(SurfaceTest, QueuesToWindowComposerIsTrueWhenVisible) {
     EXPECT_EQ(1, result);
 }
 
-TEST_F(SurfaceTest, QueuesToWindowComposerIsTrueWhenPurgatorized) {
+TEST_F(SurfaceComposerSurfaceTest, QueuesToWindowComposerIsTrueWhenPurgatorized) {
     mSurfaceControl.clear();
     // Wait for the async clean-up to complete.
     std::this_thread::sleep_for(50ms);
@@ -275,7 +282,7 @@ TEST_F(SurfaceTest, QueuesToWindowComposerIsTrueWhenPurgatorized) {
     EXPECT_EQ(1, result);
 }
 
-TEST_F(SurfaceTest, ConcreteTypeIsSurface) {
+TEST_F(SurfaceComposerSurfaceTest, ConcreteTypeIsSurface) {
     sp<ANativeWindow> anw(mSurface);
     int result = -123;
     int err = anw->query(anw.get(), NATIVE_WINDOW_CONCRETE_TYPE, &result);
@@ -283,7 +290,7 @@ TEST_F(SurfaceTest, ConcreteTypeIsSurface) {
     EXPECT_EQ(NATIVE_WINDOW_SURFACE, result);
 }
 
-TEST_F(SurfaceTest, LayerCountIsOne) {
+TEST_F(SurfaceComposerSurfaceTest, LayerCountIsOne) {
     sp<ANativeWindow> anw(mSurface);
     int result = -123;
     int err = anw->query(anw.get(), NATIVE_WINDOW_LAYER_COUNT, &result);
@@ -291,7 +298,7 @@ TEST_F(SurfaceTest, LayerCountIsOne) {
     EXPECT_EQ(1, result);
 }
 
-TEST_F(SurfaceTest, QueryConsumerUsage) {
+TEST_F(SurfaceComposerSurfaceTest, QueryConsumerUsage) {
     const int TEST_USAGE_FLAGS =
             GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_HW_RENDER;
     auto [c, s] = BufferItemConsumer::create(TEST_USAGE_FLAGS);
@@ -304,7 +311,7 @@ TEST_F(SurfaceTest, QueryConsumerUsage) {
     ASSERT_EQ(TEST_USAGE_FLAGS, flags);
 }
 
-TEST_F(SurfaceTest, QueryDefaultBuffersDataSpace) {
+TEST_F(SurfaceComposerSurfaceTest, QueryDefaultBuffersDataSpace) {
     const android_dataspace TEST_DATASPACE = HAL_DATASPACE_V0_SRGB;
 
     auto [cpuConsumer, s] = CpuConsumer::create(1);
@@ -582,7 +589,7 @@ TEST_F(SurfaceTest, SurfaceListenerTest) {
     testSurfaceListener(/*hasListener*/true, /*enableReleasedCb*/true, /*extraDiscardedBuffers*/2);
 }
 
-TEST_F(SurfaceTest, TestGetLastDequeueStartTime) {
+TEST_F(SurfaceComposerSurfaceTest, TestGetLastDequeueStartTime) {
     sp<ANativeWindow> anw(mSurface);
     ASSERT_EQ(NO_ERROR, native_window_api_connect(anw.get(), NATIVE_WINDOW_API_CPU));
 
@@ -598,6 +605,27 @@ TEST_F(SurfaceTest, TestGetLastDequeueStartTime) {
     ASSERT_GE(after, lastDequeueTime);
 }
 
+TEST_F(SurfaceComposerSurfaceTest, SurfaceIsForCursor) {
+    sp<SurfaceControl> control;
+    ASSERT_EQ(NO_ERROR,
+              mComposerClient->createSurfaceChecked(String8("Test Surface"), 32, 32,
+                                                    PIXEL_FORMAT_BGRA_8888, &control, 0));
+    sp<Surface> surface = control->getSurface();
+    sp<ANativeWindow> anw(surface);
+
+    surface->setIsForCursor(true);
+
+    ANativeWindow_Buffer b;
+    ASSERT_EQ(NO_ERROR, surface->lock(&b, nullptr));
+    ASSERT_EQ(NO_ERROR, surface->unlockAndPost());
+
+    int fence;
+    ANativeWindowBuffer* buffer;
+    ASSERT_EQ(NO_ERROR, anw->dequeueBuffer(anw.get(), &buffer, &fence));
+
+    EXPECT_TRUE(buffer->usage & GRALLOC_USAGE_CURSOR);
+}
+
 class FakeConsumer : public IConsumerListener {
 public:
     void onFrameAvailable(const BufferItem& /*item*/) override {}
@@ -648,7 +676,13 @@ public:
         mSupportsPresent = supportsPresent;
     }
 
-    status_t setTransactionState(TransactionState&&) override { return NO_ERROR; }
+    status_t setTransactionState(SimpleTransactionState /*podState*/,
+                                 const ComplexTransactionState& /*complexState*/,
+                                 MutableTransactionState& /*mutableState*/,
+                                 const sp<IBinder>& /*applyToken*/
+                                 ) override {
+        return NO_ERROR;
+    }
 
 protected:
     IBinder* onAsBinder() override { return nullptr; }
@@ -858,11 +892,22 @@ public:
         return binder::Status::ok();
     }
 
+    binder::Status addRegionSamplingListenerWithStopLayerId(
+            const gui::ARect& /*samplingArea*/, const int32_t /*stopLayerId*/,
+            const sp<gui::IRegionSamplingListener>& /*listener*/) override {
+        return binder::Status::ok();
+    }
+
     binder::Status removeRegionSamplingListener(
             const sp<gui::IRegionSamplingListener>& /*listener*/) override {
         return binder::Status::ok();
     }
 
+    binder::Status getRegionSamplingListeners(
+            std::vector<gui::RegionSamplingDescriptor>*) override {
+        return binder::Status::ok();
+    }
+
     binder::Status addFpsListener(int32_t /*taskId*/,
                                   const sp<gui::IFpsListener>& /*listener*/) override {
         return binder::Status::ok();
@@ -2237,54 +2282,6 @@ TEST_F(SurfaceTest, BatchIllegalOperations) {
     ASSERT_EQ(NO_ERROR, surface->disconnect(NATIVE_WINDOW_API_CPU));
 }
 
-TEST_F(SurfaceTest, setMaxDequeuedBufferCount_setMaxAcquiredBufferCount_allocations) {
-    //
-    // Set up the consumer and producer--nothing fancy.
-    //
-    auto [consumer, surface] =
-            BufferItemConsumer::create(GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_HW_RENDER);
-    sp<SurfaceListener> surfaceListener = sp<StubSurfaceListener>::make();
-    surface->connect(NATIVE_WINDOW_API_CPU, surfaceListener);
-    sp<GraphicBuffer> buffer;
-    sp<Fence> fence;
-
-    //
-    // These values are independent. The consumer can dequeue 3 and the consumer can acquire 3 at
-    // the same time.
-    //
-    ASSERT_EQ(OK, consumer->setMaxAcquiredBufferCount(3));
-    ASSERT_EQ(OK, surface->setMaxDequeuedBufferCount(3));
-
-    //
-    // Take all three buffers out of the queue--a fourth can't be retrieved. Then queue them.
-    //
-    std::vector<Surface::BatchBuffer> dequeuedBuffers(3);
-    EXPECT_EQ(OK, surface->dequeueBuffers(&dequeuedBuffers));
-    if (::com::android::graphics::libgui::flags::bq_always_use_max_dequeued_buffer_count()) {
-        EXPECT_EQ(INVALID_OPERATION, surface->dequeueBuffer(&buffer, &fence));
-    }
-
-    for (auto& batchBuffer : dequeuedBuffers) {
-        EXPECT_EQ(OK,
-                  surface->queueBuffer(GraphicBuffer::from(batchBuffer.buffer),
-                                       sp<Fence>::make(batchBuffer.fenceFd)));
-    }
-    dequeuedBuffers.assign(3, {});
-
-    //
-    // Acquire all three, then we should be able to dequeue 3 more.
-    //
-    std::vector<BufferItem> acquiredBuffers(3);
-    for (auto& bufferItem : acquiredBuffers) {
-        EXPECT_EQ(OK, consumer->acquireBuffer(&bufferItem, 0));
-    }
-
-    EXPECT_EQ(OK, surface->dequeueBuffers(&dequeuedBuffers));
-    EXPECT_EQ(INVALID_OPERATION, surface->dequeueBuffer(&buffer, &fence));
-}
-
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
-
 TEST_F(SurfaceTest, PlatformBufferMethods) {
     sp<CpuConsumer> cpuConsumer = sp<CpuConsumer>::make(1);
     sp<Surface> surface = cpuConsumer->getSurface();
@@ -2299,9 +2296,7 @@ TEST_F(SurfaceTest, PlatformBufferMethods) {
     // Verify nullptrs are handled safely:
     //
 
-    EXPECT_EQ(BAD_VALUE, surface->dequeueBuffer((sp<GraphicBuffer>*)nullptr, nullptr));
     EXPECT_EQ(BAD_VALUE, surface->dequeueBuffer((sp<GraphicBuffer>*)nullptr, &fence));
-    EXPECT_EQ(BAD_VALUE, surface->dequeueBuffer(&buffer, nullptr));
     EXPECT_EQ(BAD_VALUE, surface->queueBuffer(nullptr, nullptr));
     EXPECT_EQ(BAD_VALUE, surface->detachBuffer(nullptr));
 
@@ -2429,6 +2424,28 @@ TEST_F(SurfaceTest, QueueAcquireReleaseDequeue_CalledInStack_DoesNotDeadlock) {
     EXPECT_EQ(OK, surface->disconnect(NATIVE_WINDOW_API_CPU));
 }
 
+// See: b/414442592
+TEST_F(SurfaceTest, DequeueBuffer_WithDeadConsumer_DoesNotCrash) {
+    auto [consumer, surface] = BufferItemConsumer::create(GRALLOC_USAGE_SW_READ_OFTEN);
+
+    sp<SurfaceListener> surfaceListener = sp<StubSurfaceListener>::make();
+    EXPECT_EQ(OK, surface->connect(NATIVE_WINDOW_API_CPU, surfaceListener, false));
+
+    sp<GraphicBuffer> buffer;
+    sp<Fence> fence;
+    EXPECT_EQ(OK, surface->dequeueBuffer(&buffer, &fence));
+    EXPECT_EQ(OK, surface->queueBuffer(buffer, fence));
+
+    consumer->abandon();
+
+    auto beforeBuffer = buffer;
+    auto beforeFence = fence;
+
+    EXPECT_NE(OK, surface->dequeueBuffer(&buffer, &fence));
+    EXPECT_EQ(buffer, beforeBuffer);
+    EXPECT_EQ(fence, beforeFence);
+}
+
 TEST_F(SurfaceTest, ViewSurface_toString) {
     view::Surface surface{};
     EXPECT_EQ("", surface.toString());
@@ -2564,7 +2581,6 @@ TEST_F(SurfaceTest, QueueBufferOutput_TracksReplacements_Plural) {
     EXPECT_TRUE(outputs[0].bufferReplaced);
     EXPECT_TRUE(outputs[1].bufferReplaced);
 }
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_PLATFORM_API_IMPROVEMENTS)
 
 #if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_UNLIMITED_SLOTS)
 TEST_F(SurfaceTest, UnlimitedSlots_FailsOnIncompatibleConsumer) {
@@ -2743,4 +2759,58 @@ TEST_F(SurfaceTest, isBufferOwned) {
     EXPECT_EQ(OK, surface->isBufferOwned(consumerAttachableBuffer, &isOwned));
     EXPECT_FALSE(isOwned);
 }
+
+TEST_F(SurfaceTest, isBufferOwned_SameBufferBufferWithDifferentHandles) {
+    //
+    // Surface setup:
+    //
+    auto [consumer, surface] = BufferItemConsumer::create(GRALLOC_USAGE_SW_READ_OFTEN);
+    ASSERT_EQ(OK, surface->connect(NATIVE_WINDOW_API_CPU, sp<StubSurfaceListener>::make(), false));
+
+    //
+    // Buffer setup:
+    //
+    sp<GraphicBuffer> originalBuffer =
+            sp<GraphicBuffer>::make(10, 10, PIXEL_FORMAT_RGBA_8888, 1, GRALLOC_USAGE_SW_READ_OFTEN);
+    sp<GraphicBuffer> copiedBuffer = sp<GraphicBuffer>::make();
+
+    // Copy all the data from one buffer to the other. At time of writing, this will clone and
+    // duplicate the native handle, making them different, while the rest of the aspects of the
+    // buffers remain the same.
+    std::vector<uint8_t> bufferData(originalBuffer->getFlattenedSize());
+    std::vector<int> fdCount(originalBuffer->getFdCount());
+
+    void* data = bufferData.data();
+    size_t size = bufferData.size();
+    int* fds = fdCount.data();
+    size_t count = fdCount.size();
+    ASSERT_EQ(OK, originalBuffer->flatten(data, size, fds, count));
+
+    void const* inData = bufferData.data();
+    size = bufferData.size();
+    int const* inFds = fdCount.data();
+    count = fdCount.size();
+    ASSERT_EQ(OK, copiedBuffer->unflatten(inData, size, inFds, count));
+
+    // Double check our expectations about a flattened/unflattened buffer:
+    ASSERT_NE(originalBuffer, copiedBuffer);
+    ASSERT_EQ(originalBuffer->getId(), copiedBuffer->getId());
+
+    ASSERT_EQ(originalBuffer->handle->numFds, copiedBuffer->handle->numFds);
+    for (int i = 0; i < originalBuffer->handle->numFds; i++) {
+        ASSERT_NE(originalBuffer->handle->data[i], copiedBuffer->handle->data[i]);
+    }
+
+    //
+    // Test:
+    //
+    EXPECT_EQ(OK, surface->attachBuffer(originalBuffer->getNativeBuffer()));
+
+    bool isOwned;
+    ASSERT_EQ(OK, surface->isBufferOwned(originalBuffer, &isOwned));
+    EXPECT_TRUE(isOwned);
+
+    ASSERT_EQ(OK, surface->isBufferOwned(copiedBuffer, &isOwned));
+    EXPECT_TRUE(isOwned);
+}
 } // namespace android
diff --git a/libs/gui/tests/TransactionState_test.cpp b/libs/gui/tests/TransactionState_test.cpp
index 179b264dbf..6cd9ce1cbd 100644
--- a/libs/gui/tests/TransactionState_test.cpp
+++ b/libs/gui/tests/TransactionState_test.cpp
@@ -25,6 +25,7 @@
 #include "gui/LayerState.h"
 #include "gui/WindowInfo.h"
 
+#include "gui/SimpleTransactionState.h"
 #include "gui/TransactionState.h"
 
 namespace android {
@@ -59,8 +60,8 @@ constexpr std::string dump_struct(auto& x) {
 
 void PrintTo(const TransactionState& state, ::std::ostream* os) {
     *os << dump_struct(state);
-    *os << state.mFrameTimelineInfo.toString();
-    for (auto mergedId : state.mMergedTransactionIds) {
+    *os << state.mComplexState.mFrameTimelineInfo.toString();
+    for (auto mergedId : state.mComplexState.mMergedTransactionIds) {
         *os << mergedId << ",";
     }
 }
@@ -70,15 +71,32 @@ void PrintTo(const ComposerState& state, ::std::ostream* os) {
     *os << state.state.getWindowInfo();
 }
 
-// In case EXPECT_EQ fails, this function is useful to pinpoint exactly which
-// field did not compare ==.
-void Compare(const TransactionState& s1, const TransactionState& s2) {
+void Compare(const SimpleTransactionState& s1, const SimpleTransactionState& s2) {
     EXPECT_EQ(s1.mId, s2.mId);
-    EXPECT_EQ(s1.mMergedTransactionIds, s2.mMergedTransactionIds);
     EXPECT_EQ(s1.mFlags, s2.mFlags);
-    EXPECT_EQ(s1.mFrameTimelineInfo, s2.mFrameTimelineInfo);
     EXPECT_EQ(s1.mDesiredPresentTime, s2.mDesiredPresentTime);
     EXPECT_EQ(s1.mIsAutoTimestamp, s2.mIsAutoTimestamp);
+}
+
+void Compare(const TransactionListenerCallbacks& s1, const TransactionListenerCallbacks& s2) {
+    EXPECT_EQ(s1.mHasListenerCallbacks, s2.mHasListenerCallbacks);
+    EXPECT_EQ(s1.mFlattenedListenerCallbacks.size(), s2.mFlattenedListenerCallbacks.size());
+    EXPECT_EQ(s1.mFlattenedListenerCallbacks, s2.mFlattenedListenerCallbacks);
+}
+
+void Compare(const ComplexTransactionState& s1, const ComplexTransactionState& s2) {
+    EXPECT_EQ(s1.mMergedTransactionIds, s2.mMergedTransactionIds);
+    EXPECT_EQ(s1.mFrameTimelineInfo, s2.mFrameTimelineInfo);
+    EXPECT_EQ(s1.mUncacheBuffers, s2.mUncacheBuffers);
+    EXPECT_EQ(s1.mCallbacks, s2.mCallbacks);
+    EXPECT_EQ(s1.mInputWindowCommands, s2.mInputWindowCommands);
+}
+
+// In case EXPECT_EQ fails, this function is useful to pinpoint exactly which
+// field did not compare ==.
+void Compare(const TransactionState& s1, const TransactionState& s2) {
+    Compare(s1.mSimpleState, s2.mSimpleState);
+    Compare(s1.mComplexState, s2.mComplexState);
     EXPECT_EQ(s1.mApplyToken, s2.mApplyToken);
     EXPECT_EQ(s1.mMayContainBuffer, s2.mMayContainBuffer);
     EXPECT_EQ(s1.mLogCallPoints, s2.mLogCallPoints);
@@ -86,11 +104,6 @@ void Compare(const TransactionState& s1, const TransactionState& s2) {
     EXPECT_THAT(s1.mDisplayStates, ::testing::ContainerEq(s2.mDisplayStates));
     EXPECT_EQ(s1.mComposerStates.size(), s2.mComposerStates.size());
     EXPECT_EQ(s1.mComposerStates, s2.mComposerStates);
-    EXPECT_EQ(s1.mInputWindowCommands, s2.mInputWindowCommands);
-    EXPECT_EQ(s1.mUncacheBuffers, s2.mUncacheBuffers);
-    EXPECT_EQ(s1.mHasListenerCallbacks, s2.mHasListenerCallbacks);
-    EXPECT_EQ(s1.mListenerCallbacks.size(), s2.mListenerCallbacks.size());
-    EXPECT_EQ(s1.mListenerCallbacks, s2.mListenerCallbacks);
 }
 
 std::unique_ptr<std::unordered_map<int, sp<BBinder>>> createTokenMap(size_t maxSize) {
@@ -124,30 +137,20 @@ DisplayState createDisplayStateForTest(size_t i) {
     return displayState;
 }
 
-TransactionState createTransactionStateForTest() {
-    static sp<BBinder> sApplyToken = sp<BBinder>::make();
-
-    TransactionState state;
+SimpleTransactionState createSimpleTransactionStateForTest() {
+    SimpleTransactionState state;
     state.mId = 123;
+    state.mFlags = 1;
+    state.mDesiredPresentTime = 11;
+    state.mIsAutoTimestamp = true;
+    return state;
+}
+
+ComplexTransactionState createComplexTransactionStateForTest() {
+    ComplexTransactionState state;
     state.mMergedTransactionIds.push_back(15);
     state.mMergedTransactionIds.push_back(0);
     state.mFrameTimelineInfo.vsyncId = 14;
-    state.mDesiredPresentTime = 11;
-    state.mIsAutoTimestamp = true;
-    state.mApplyToken = sApplyToken;
-    for (size_t i = 0; i < kMaxDisplayStates; i++) {
-        state.mDisplayStates.push_back(createDisplayStateForTest(i));
-    }
-    for (size_t i = 0; i < kMaxComposerStates; i++) {
-        state.mComposerStates.push_back(createComposerStateForTest(i));
-    }
-    static const auto* const sFocusRequestTokens = createTokenMap(5).release();
-    for (int i = 0; i < 5; i++) {
-        gui::FocusRequest request;
-        request.token = sFocusRequestTokens->at(i);
-        request.timestamp = i;
-        state.mInputWindowCommands.addFocusRequest(request);
-    }
     static const auto* const sCacheToken = createTokenMap(5).release();
     for (int i = 0; i < 5; i++) {
         client_cache_t cache;
@@ -163,17 +166,51 @@ TransactionState createTransactionStateForTest() {
         }
         return callbacks;
     }();
-    state.mHasListenerCallbacks = true;
-    state.mListenerCallbacks = *sListenerCallbacks;
+    state.mCallbacks.mHasListenerCallbacks = true;
+    state.mCallbacks.mFlattenedListenerCallbacks = *sListenerCallbacks;
+    static const auto* const sFocusRequestTokens = createTokenMap(5).release();
+    for (int i = 0; i < 5; i++) {
+        gui::FocusRequest request;
+        request.token = sFocusRequestTokens->at(i);
+        request.timestamp = i;
+        state.mInputWindowCommands.addFocusRequest(request);
+    }
+
+    return state;
+}
+
+TransactionState createTransactionStateForTest() {
+    static sp<BBinder> sApplyToken = sp<BBinder>::make();
+
+    TransactionState state;
+    state.mSimpleState = createSimpleTransactionStateForTest();
+    state.mComplexState = createComplexTransactionStateForTest();
+    state.mApplyToken = sApplyToken;
+    for (size_t i = 0; i < kMaxDisplayStates; i++) {
+        state.mDisplayStates.push_back(createDisplayStateForTest(i));
+    }
+    for (size_t i = 0; i < kMaxComposerStates; i++) {
+        state.mComposerStates.push_back(createComposerStateForTest(i));
+    }
     return state;
 }
 
 TransactionState createEmptyTransaction(uint64_t id) {
     TransactionState state;
-    state.mId = id;
+    state.mSimpleState.mId = id;
     return state;
 }
 
+TEST(SimpleTransactionStateTest, parcel) {
+    SimpleTransactionState state = createSimpleTransactionStateForTest();
+    Parcel p;
+    EXPECT_EQ(state.writeToParcel(&p), NO_ERROR);
+    p.setDataPosition(0);
+    SimpleTransactionState parcelledState;
+    EXPECT_EQ(parcelledState.readFromParcel(&p), NO_ERROR);
+    EXPECT_EQ(state, parcelledState);
+};
+
 TEST(TransactionStateTest, parcel) {
     TransactionState state = createTransactionStateForTest();
     Parcel p;
@@ -229,6 +266,27 @@ TEST(TransactionStateTest, mergeLayerState) {
     EXPECT_EQ(composerState, expectedMergedState);
 };
 
+TEST(SimpleTransactionStateTest, merge) {
+    // Setup.
+    static constexpr uint64_t kUpdateTransactionId = 200;
+    SimpleTransactionState state = createSimpleTransactionStateForTest();
+    SimpleTransactionState update;
+    update.mId = kUpdateTransactionId;
+    update.mFlags = state.mFlags + 1;
+
+    // Mutation.
+    state.merge(update);
+
+    // Assertions.
+    SimpleTransactionState expectedMergedState = createSimpleTransactionStateForTest();
+    expectedMergedState.mFlags = state.mFlags | update.mFlags;
+
+    EXPECT_EQ(state.mFlags, expectedMergedState.mFlags);
+
+    // desired present time is not merged.
+    expectedMergedState.mDesiredPresentTime = state.mDesiredPresentTime;
+}
+
 TEST(TransactionStateTest, merge) {
     // Setup.
     static constexpr uint64_t kUpdateTransactionId = 200;
@@ -236,7 +294,7 @@ TEST(TransactionStateTest, merge) {
     TransactionState state = createTransactionStateForTest();
 
     TransactionState update;
-    update.mId = kUpdateTransactionId;
+    update.mSimpleState.mId = kUpdateTransactionId;
     {
         ComposerState composerState;
         composerState.state.surface = state.mComposerStates[0].state.surface;
@@ -259,18 +317,20 @@ TEST(TransactionStateTest, merge) {
     EXPECT_EQ(update, createEmptyTransaction(update.getId()));
 
     TransactionState expectedMergedState = createTransactionStateForTest();
-    expectedMergedState.mMergedTransactionIds
-            .insert(expectedMergedState.mMergedTransactionIds.begin(), kUpdateTransactionId);
+    expectedMergedState.mComplexState.mMergedTransactionIds
+            .insert(expectedMergedState.mComplexState.mMergedTransactionIds.begin(),
+                    kUpdateTransactionId);
     expectedMergedState.mComposerStates.at(0).state.what |= layer_state_t::eAlphaChanged;
     expectedMergedState.mComposerStates.at(0).state.color.a = .42;
     expectedMergedState.mComposerStates.at(1).state.what |= layer_state_t::eBufferChanged;
-    auto inputCommands = expectedMergedState.mInputWindowCommands;
+    auto inputCommands = expectedMergedState.mComplexState.mInputWindowCommands;
 
     // desired present time is not merged.
-    expectedMergedState.mDesiredPresentTime = state.mDesiredPresentTime;
+    expectedMergedState.mSimpleState.mDesiredPresentTime = state.mSimpleState.mDesiredPresentTime;
 
     EXPECT_EQ(state.mComposerStates[0], expectedMergedState.mComposerStates[0]);
-    EXPECT_EQ(state.mInputWindowCommands, expectedMergedState.mInputWindowCommands);
+    EXPECT_EQ(state.mComplexState.mInputWindowCommands,
+              expectedMergedState.mComplexState.mInputWindowCommands);
     EXPECT_EQ(state, expectedMergedState);
 };
 
diff --git a/libs/gui/view/Surface.cpp b/libs/gui/view/Surface.cpp
index 2cf7081ede..c52d433597 100644
--- a/libs/gui/view/Surface.cpp
+++ b/libs/gui/view/Surface.cpp
@@ -121,7 +121,6 @@ String16 Surface::readMaybeEmptyString16(const Parcel* parcel) {
     return str.value_or(String16());
 }
 
-#if WB_LIBCAMERASERVICE_WITH_DEPENDENCIES
 Surface Surface::fromSurface(const sp<android::Surface>& surface) {
     if (surface == nullptr) {
         ALOGE("%s: Error: view::Surface::fromSurface failed due to null surface.", __FUNCTION__);
@@ -131,12 +130,13 @@ Surface Surface::fromSurface(const sp<android::Surface>& surface) {
     s.name = String16(surface->getConsumerName());
     s.graphicBufferProducer = surface->getIGraphicBufferProducer();
     s.surfaceControlHandle = surface->getSurfaceControlHandle();
+    ALOGW_IF(surface->isForCursor(), "%s: Unexpectedly encountered cursor surface.", __FUNCTION__);
     return s;
 }
 
-sp<android::Surface> Surface::toSurface() const {
+sp<android::Surface> Surface::toSurface(bool controlledByApp) const {
     if (graphicBufferProducer == nullptr) return nullptr;
-    return new android::Surface(graphicBufferProducer, false, surfaceControlHandle);
+    return new android::Surface(graphicBufferProducer, controlledByApp, surfaceControlHandle);
 }
 
 status_t Surface::getUniqueId(uint64_t* out_id) const {
@@ -155,7 +155,6 @@ status_t Surface::getUniqueId(uint64_t* out_id) const {
 bool Surface::isEmpty() const {
     return graphicBufferProducer == nullptr;
 }
-#endif
 
 std::string Surface::toString() const {
     std::stringstream out;
diff --git a/libs/input/Android.bp b/libs/input/Android.bp
index 52e0276cad..4b2636e6f5 100644
--- a/libs/input/Android.bp
+++ b/libs/input/Android.bp
@@ -182,7 +182,6 @@ cc_library_static {
 // Contains methods to help access C++ code from rust
 cc_library_static {
     name: "libinput_from_rust_to_cpp",
-    cpp_std: "c++20",
     host_supported: true,
     cflags: [
         "-Wall",
@@ -209,7 +208,6 @@ cc_library_static {
 
 cc_library {
     name: "libinput",
-    cpp_std: "c++20",
     host_supported: true,
     cflags: [
         "-DANDROID_UTILS_REF_BASE_DISABLE_IMPLICIT_CONSTRUCTION",
@@ -222,6 +220,7 @@ cc_library {
         "-Wshadow-uncaptured-local",
         "-Wthread-safety",
     ],
+    afdo: true,
     srcs: [
         "AccelerationCurve.cpp",
         "CoordinateFilter.cpp",
@@ -379,7 +378,6 @@ genrule {
 
 cc_defaults {
     name: "libinput_fuzz_defaults",
-    cpp_std: "c++20",
     host_supported: true,
     shared_libs: [
         "libbase",
diff --git a/libs/input/DisplayTopologyGraph.cpp b/libs/input/DisplayTopologyGraph.cpp
index 934f2e8135..b026fd3b5f 100644
--- a/libs/input/DisplayTopologyGraph.cpp
+++ b/libs/input/DisplayTopologyGraph.cpp
@@ -18,6 +18,7 @@
 
 #include <android-base/logging.h>
 #include <android-base/stringprintf.h>
+#include <com_android_input_flags.h>
 #include <ftl/enum.h>
 #include <input/DisplayTopologyGraph.h>
 #include <input/PrintTools.h>
@@ -27,10 +28,40 @@
 
 #define INDENT "  "
 
+namespace input_flags = com::android::input::flags;
+
 namespace android {
 
 namespace {
 
+std::string logicalDisplayIdToString(const ui::LogicalDisplayId& displayId) {
+    return base::StringPrintf("displayId(%d)", displayId.val());
+}
+
+std::string adjacentDisplayToString(const DisplayTopologyAdjacentDisplay& adjacentDisplay) {
+    return adjacentDisplay.dump();
+}
+
+std::string floatRectToString(const FloatRect& floatRect) {
+    std::string dump;
+    dump += base::StringPrintf("FloatRect(%f, %f, %f, %f)", floatRect.left, floatRect.top,
+                               floatRect.right, floatRect.bottom);
+    return dump;
+}
+
+std::string displayPropertiesToString(const DisplayTopologyGraph::Properties& displayProperties) {
+    std::string dump;
+    dump += "AdjacentDisplays: ";
+    dump += dumpVector(displayProperties.adjacentDisplays, adjacentDisplayToString);
+    dump += '\n';
+    dump += base::StringPrintf("Density: %d", displayProperties.density);
+    dump += '\n';
+    dump += "Bounds: ";
+    dump += floatRectToString(displayProperties.boundsInGlobalDp);
+    dump += '\n';
+    return dump;
+}
+
 DisplayTopologyPosition getOppositePosition(DisplayTopologyPosition position) {
     switch (position) {
         case DisplayTopologyPosition::LEFT:
@@ -44,27 +75,50 @@ DisplayTopologyPosition getOppositePosition(DisplayTopologyPosition position) {
     }
 }
 
-bool validatePrimaryDisplay(const android::DisplayTopologyGraph& displayTopologyGraph) {
-    return displayTopologyGraph.primaryDisplayId != ui::LogicalDisplayId::INVALID &&
-            displayTopologyGraph.graph.contains(displayTopologyGraph.primaryDisplayId);
+bool validatePrimaryDisplay(
+        ui::LogicalDisplayId primaryDisplayId,
+        const std::unordered_map<ui::LogicalDisplayId, DisplayTopologyGraph::Properties>&
+                topologyGraph) {
+    return primaryDisplayId != ui::LogicalDisplayId::INVALID &&
+            topologyGraph.contains(primaryDisplayId);
 }
 
-bool validateTopologyGraph(const android::DisplayTopologyGraph& displayTopologyGraph) {
-    for (const auto& [sourceDisplay, adjacentDisplays] : displayTopologyGraph.graph) {
-        for (const DisplayTopologyAdjacentDisplay& adjacentDisplay : adjacentDisplays) {
-            const auto adjacentGraphIt = displayTopologyGraph.graph.find(adjacentDisplay.displayId);
-            if (adjacentGraphIt == displayTopologyGraph.graph.end()) {
+bool validateTopologyGraph(
+        const std::unordered_map<ui::LogicalDisplayId, DisplayTopologyGraph::Properties>&
+                topologyGraph) {
+    for (const auto& [sourceDisplay, displayProperties] : topologyGraph) {
+        if (!sourceDisplay.isValid()) {
+            LOG(ERROR) << "Invalid display in topology graph: " << sourceDisplay;
+            return false;
+        }
+        if (displayProperties.boundsInGlobalDp.getHeight() <= 0 ||
+            displayProperties.boundsInGlobalDp.getWidth() <= 0) {
+            LOG(ERROR) << "Invalid display-bounds for " << logicalDisplayIdToString(sourceDisplay)
+                       << " in topology graph: "
+                       << floatRectToString(displayProperties.boundsInGlobalDp);
+            return false;
+        }
+        if (displayProperties.density <= 0) {
+            LOG(ERROR) << "Invalid density for " << logicalDisplayIdToString(sourceDisplay)
+                       << "in topology graph: " << displayProperties.density;
+            return false;
+        }
+        for (const DisplayTopologyAdjacentDisplay& adjacentDisplay :
+             displayProperties.adjacentDisplays) {
+            const auto adjacentGraphIt = topologyGraph.find(adjacentDisplay.displayId);
+            if (adjacentGraphIt == topologyGraph.end()) {
                 LOG(ERROR) << "Missing adjacent display in topology graph: "
                            << adjacentDisplay.displayId << " for source " << sourceDisplay;
                 return false;
             }
             const auto reverseEdgeIt =
-                    std::find_if(adjacentGraphIt->second.begin(), adjacentGraphIt->second.end(),
+                    std::find_if(adjacentGraphIt->second.adjacentDisplays.begin(),
+                                 adjacentGraphIt->second.adjacentDisplays.end(),
                                  [sourceDisplay](const DisplayTopologyAdjacentDisplay&
                                                          reverseAdjacentDisplay) {
                                      return sourceDisplay == reverseAdjacentDisplay.displayId;
                                  });
-            if (reverseEdgeIt == adjacentGraphIt->second.end()) {
+            if (reverseEdgeIt == adjacentGraphIt->second.adjacentDisplays.end()) {
                 LOG(ERROR) << "Missing reverse edge in topology graph for: " << sourceDisplay
                            << " -> " << adjacentDisplay.displayId;
                 return false;
@@ -90,27 +144,29 @@ bool validateTopologyGraph(const android::DisplayTopologyGraph& displayTopologyG
     return true;
 }
 
-bool validateDensities(const android::DisplayTopologyGraph& displayTopologyGraph) {
-    for (const auto& [sourceDisplay, adjacentDisplays] : displayTopologyGraph.graph) {
-        if (!displayTopologyGraph.displaysDensity.contains(sourceDisplay)) {
-            LOG(ERROR) << "Missing density value in topology graph for display: " << sourceDisplay;
-            return false;
-        }
+bool areTopologyGraphComponentsValid(
+        ui::LogicalDisplayId primaryDisplayId,
+        const std::unordered_map<ui::LogicalDisplayId, DisplayTopologyGraph::Properties>&
+                topologyGraph) {
+    if (!input_flags::enable_display_topology_validation()) {
+        return true;
     }
-    return true;
+    return validatePrimaryDisplay(primaryDisplayId, topologyGraph) &&
+            validateTopologyGraph(topologyGraph);
 }
 
-std::string logicalDisplayIdToString(const ui::LogicalDisplayId& displayId) {
-    return base::StringPrintf("displayId(%d)", displayId.val());
-}
-
-std::string adjacentDisplayToString(const DisplayTopologyAdjacentDisplay& adjacentDisplay) {
-    return adjacentDisplay.dump();
-}
-
-std::string adjacentDisplayVectorToString(
-        const std::vector<DisplayTopologyAdjacentDisplay>& adjacentDisplays) {
-    return dumpVector(adjacentDisplays, adjacentDisplayToString);
+std::string dumpTopologyGraphComponents(
+        ui::LogicalDisplayId primaryDisplayId,
+        const std::unordered_map<ui::LogicalDisplayId, DisplayTopologyGraph::Properties>&
+                topologyGraph) {
+    std::string dump;
+    dump += base::StringPrintf("PrimaryDisplayId: %d\n", primaryDisplayId.val());
+    dump += base::StringPrintf("TopologyGraph:\n");
+    dump += addLinePrefix(dumpMap(topologyGraph, logicalDisplayIdToString,
+                                  displayPropertiesToString),
+                          INDENT);
+    dump += "\n";
+    return dump;
 }
 
 } // namespace
@@ -123,22 +179,23 @@ std::string DisplayTopologyAdjacentDisplay::dump() const {
     return dump;
 }
 
-bool DisplayTopologyGraph::isValid() const {
-    return validatePrimaryDisplay(*this) && validateTopologyGraph(*this) &&
-            validateDensities(*this);
-}
+DisplayTopologyGraph::DisplayTopologyGraph(
+        ui::LogicalDisplayId primaryDisplay,
+        std::unordered_map<ui::LogicalDisplayId, Properties>&& topologyGraph)
+      : primaryDisplayId(primaryDisplay), graph(std::move(topologyGraph)) {}
 
 std::string DisplayTopologyGraph::dump() const {
-    std::string dump;
-    dump += base::StringPrintf("PrimaryDisplayId: %d\n", primaryDisplayId.val());
-    dump += base::StringPrintf("TopologyGraph:\n");
-    dump += addLinePrefix(dumpMap(graph, logicalDisplayIdToString, adjacentDisplayVectorToString),
-                          INDENT);
-    dump += "\n";
-    dump += base::StringPrintf("DisplaysDensity:\n");
-    dump += addLinePrefix(dumpMap(displaysDensity, logicalDisplayIdToString), INDENT);
-    dump += "\n";
-    return dump;
+    return dumpTopologyGraphComponents(primaryDisplayId, graph);
+}
+
+base::Result<const DisplayTopologyGraph> DisplayTopologyGraph::create(
+        ui::LogicalDisplayId primaryDisplay,
+        std::unordered_map<ui::LogicalDisplayId, Properties>&& topologyGraph) {
+    if (areTopologyGraphComponentsValid(primaryDisplay, topologyGraph)) {
+        return DisplayTopologyGraph(primaryDisplay, std::move(topologyGraph));
+    }
+    return base::Error() << "Invalid display topology components: "
+                         << dumpTopologyGraphComponents(primaryDisplay, topologyGraph);
 }
 
 } // namespace android
diff --git a/libs/input/Input.cpp b/libs/input/Input.cpp
index 155ea000e3..ab9cfed4f7 100644
--- a/libs/input/Input.cpp
+++ b/libs/input/Input.cpp
@@ -58,7 +58,8 @@ bool shouldDisregardOffset(uint32_t source) {
 }
 
 int32_t resolveActionForSplitMotionEvent(
-        int32_t action, int32_t flags, const std::vector<PointerProperties>& pointerProperties,
+        int32_t action, ftl::Flags<MotionFlag> flags,
+        const std::vector<PointerProperties>& pointerProperties,
         const std::vector<PointerProperties>& splitPointerProperties) {
     LOG_ALWAYS_FATAL_IF(splitPointerProperties.empty());
     const auto maskedAction = MotionEvent::getActionMasked(action);
@@ -90,20 +91,20 @@ int32_t resolveActionForSplitMotionEvent(
     }
 
     if (maskedAction == AMOTION_EVENT_ACTION_POINTER_UP) {
-        return ((flags & AMOTION_EVENT_FLAG_CANCELED) != 0) ? AMOTION_EVENT_ACTION_CANCEL
-                                                            : AMOTION_EVENT_ACTION_UP;
+        return flags.test(MotionFlag::CANCELED) ? AMOTION_EVENT_ACTION_CANCEL
+                                                : AMOTION_EVENT_ACTION_UP;
     }
     return AMOTION_EVENT_ACTION_DOWN;
 }
 
 float transformOrientation(const ui::Transform& transform, const PointerCoords& coords,
-                           int32_t motionEventFlags) {
-    if ((motionEventFlags & AMOTION_EVENT_PRIVATE_FLAG_SUPPORTS_ORIENTATION) == 0) {
+                           ftl::Flags<MotionFlag> motionEventFlags) {
+    if (!motionEventFlags.test(MotionFlag::SUPPORTS_ORIENTATION)) {
         return 0;
     }
 
     const bool isDirectionalAngle =
-            (motionEventFlags & AMOTION_EVENT_PRIVATE_FLAG_SUPPORTS_DIRECTIONAL_ORIENTATION) != 0;
+            motionEventFlags.test(MotionFlag::SUPPORTS_DIRECTIONAL_ORIENTATION);
 
     return transformAngle(transform, coords.getAxisValue(AMOTION_EVENT_AXIS_ORIENTATION),
                           isDirectionalAngle);
@@ -452,8 +453,8 @@ std::ostream& operator<<(std::ostream& out, const KeyEvent& event) {
         out << ", metaState=" << event.getMetaState();
     }
 
-    out << ", eventTime=" << event.getEventTime();
-    out << ", downTime=" << event.getDownTime();
+    out << ", eventTime=" << event.getEventTime() << "ns";
+    out << ", downTime=" << event.getDownTime() << "ns";
     out << ", flags=" << std::hex << event.getFlags() << std::dec;
     out << ", repeatCount=" << event.getRepeatCount();
     out << ", deviceId=" << event.getDeviceId();
@@ -582,8 +583,8 @@ bool PointerCoords::operator==(const PointerCoords& other) const {
 
 void MotionEvent::initialize(int32_t id, int32_t deviceId, uint32_t source,
                              ui::LogicalDisplayId displayId, std::array<uint8_t, 32> hmac,
-                             int32_t action, int32_t actionButton, int32_t flags, int32_t edgeFlags,
-                             int32_t metaState, int32_t buttonState,
+                             int32_t action, int32_t actionButton, ftl::Flags<MotionFlag> flags,
+                             int32_t edgeFlags, int32_t metaState, int32_t buttonState,
                              MotionClassification classification, const ui::Transform& transform,
                              float xPrecision, float yPrecision, float rawXCursorPosition,
                              float rawYCursorPosition, const ui::Transform& rawTransform,
@@ -871,7 +872,7 @@ status_t MotionEvent::readFromParcel(Parcel* parcel) {
     std::move(hmac.begin(), hmac.begin() + hmac.size(), mHmac.begin());
     mAction = parcel->readInt32();
     mActionButton = parcel->readInt32();
-    mFlags = parcel->readInt32();
+    mFlags = ftl::Flags<MotionFlag>(parcel->readUint32());
     mEdgeFlags = parcel->readInt32();
     mMetaState = parcel->readInt32();
     mButtonState = parcel->readInt32();
@@ -935,7 +936,7 @@ status_t MotionEvent::writeToParcel(Parcel* parcel) const {
     parcel->writeByteVector(hmac);
     parcel->writeInt32(mAction);
     parcel->writeInt32(mActionButton);
-    parcel->writeInt32(mFlags);
+    parcel->writeUint32(mFlags.get());
     parcel->writeInt32(mEdgeFlags);
     parcel->writeInt32(mMetaState);
     parcel->writeInt32(mButtonState);
@@ -1034,7 +1035,7 @@ std::string MotionEvent::actionToString(int32_t action) {
 }
 
 std::tuple<int32_t, std::vector<PointerProperties>, std::vector<PointerCoords>> MotionEvent::split(
-        int32_t action, int32_t flags, int32_t historySize,
+        int32_t action, ftl::Flags<MotionFlag> flags, int32_t historySize,
         const std::vector<PointerProperties>& pointerProperties,
         const std::vector<PointerCoords>& pointerCoords,
         std::bitset<MAX_POINTER_ID + 1> splitPointerIds) {
@@ -1090,7 +1091,8 @@ vec2 MotionEvent::calculateTransformedXY(uint32_t source, const ui::Transform& t
 }
 
 // Keep in sync with calculateTransformedCoords.
-float MotionEvent::calculateTransformedAxisValue(int32_t axis, uint32_t source, int32_t flags,
+float MotionEvent::calculateTransformedAxisValue(int32_t axis, uint32_t source,
+                                                 ftl::Flags<MotionFlag> flags,
                                                  const ui::Transform& transform,
                                                  const PointerCoords& coords) {
     if (shouldDisregardTransformation(source)) {
@@ -1121,7 +1123,8 @@ float MotionEvent::calculateTransformedAxisValue(int32_t axis, uint32_t source,
 // Keep in sync with calculateTransformedAxisValue. This is an optimization of
 // calculateTransformedAxisValue for all PointerCoords axes.
 void MotionEvent::calculateTransformedCoordsInPlace(PointerCoords& coords, uint32_t source,
-                                                    int32_t flags, const ui::Transform& transform) {
+                                                    ftl::Flags<MotionFlag> flags,
+                                                    const ui::Transform& transform) {
     if (shouldDisregardTransformation(source)) {
         return;
     }
@@ -1141,7 +1144,7 @@ void MotionEvent::calculateTransformedCoordsInPlace(PointerCoords& coords, uint3
                         transformOrientation(transform, coords, flags));
 }
 
-PointerCoords MotionEvent::calculateTransformedCoords(uint32_t source, int32_t flags,
+PointerCoords MotionEvent::calculateTransformedCoords(uint32_t source, ftl::Flags<MotionFlag> flags,
                                                       const ui::Transform& transform,
                                                       const PointerCoords& coords) {
     PointerCoords out = coords;
@@ -1193,13 +1196,13 @@ std::string MotionEvent::safeDump() const {
     if (mMetaState != 0) {
         out << ", mMetaState=" << mMetaState;
     }
-    if (mFlags != 0) {
-        out << ", mFlags=0x" << std::hex << mFlags << std::dec;
+    if (mFlags.any()) {
+        out << ", mFlags=" << mFlags.string();
     }
     if (mEdgeFlags != 0) {
         out << ", mEdgeFlags=" << mEdgeFlags;
     }
-    out << ", mDownTime=" << mDownTime;
+    out << ", mDownTime=" << mDownTime << "ns";
     out << ", mDeviceId=" << mDeviceId;
     out << ", mSource=" << inputEventSourceToString(mSource);
     out << ", mDisplayId=" << mDisplayId;
@@ -1253,8 +1256,8 @@ std::ostream& operator<<(std::ostream& out, const MotionEvent& event) {
     if (event.getMetaState() != 0) {
         out << ", metaState=" << event.getMetaState();
     }
-    if (event.getFlags() != 0) {
-        out << ", flags=0x" << std::hex << event.getFlags() << std::dec;
+    if (event.getFlags().any()) {
+        out << ", flags=" << event.getFlags().string();
     }
     if (event.getEdgeFlags() != 0) {
         out << ", edgeFlags=" << event.getEdgeFlags();
@@ -1265,8 +1268,8 @@ std::ostream& operator<<(std::ostream& out, const MotionEvent& event) {
     if (event.getHistorySize() != 0) {
         out << ", historySize=" << event.getHistorySize();
     }
-    out << ", eventTime=" << event.getEventTime();
-    out << ", downTime=" << event.getDownTime();
+    out << ", eventTime=" << event.getEventTime() << "ns";
+    out << ", downTime=" << event.getDownTime() << "ns";
     out << ", deviceId=" << event.getDeviceId();
     out << ", source=" << inputEventSourceToString(event.getSource());
     out << ", displayId=" << event.getDisplayId();
diff --git a/libs/input/InputConsumer.cpp b/libs/input/InputConsumer.cpp
index 1eeb4e678c..9b51d39d38 100644
--- a/libs/input/InputConsumer.cpp
+++ b/libs/input/InputConsumer.cpp
@@ -118,13 +118,13 @@ void initializeMotionEvent(MotionEvent& event, const InputMessage& msg) {
                           0, 0, 1});
     event.initialize(msg.body.motion.eventId, msg.body.motion.deviceId, msg.body.motion.source,
                      ui::LogicalDisplayId{msg.body.motion.displayId}, msg.body.motion.hmac,
-                     msg.body.motion.action, msg.body.motion.actionButton, msg.body.motion.flags,
-                     msg.body.motion.edgeFlags, msg.body.motion.metaState,
-                     msg.body.motion.buttonState, msg.body.motion.classification, transform,
-                     msg.body.motion.xPrecision, msg.body.motion.yPrecision,
-                     msg.body.motion.xCursorPosition, msg.body.motion.yCursorPosition,
-                     displayTransform, msg.body.motion.downTime, msg.body.motion.eventTime,
-                     pointerCount, pointerProperties, pointerCoords);
+                     msg.body.motion.action, msg.body.motion.actionButton,
+                     ftl::Flags<MotionFlag>(msg.body.motion.flags), msg.body.motion.edgeFlags,
+                     msg.body.motion.metaState, msg.body.motion.buttonState,
+                     msg.body.motion.classification, transform, msg.body.motion.xPrecision,
+                     msg.body.motion.yPrecision, msg.body.motion.xCursorPosition,
+                     msg.body.motion.yCursorPosition, displayTransform, msg.body.motion.downTime,
+                     msg.body.motion.eventTime, pointerCount, pointerProperties, pointerCoords);
 }
 
 void addSample(MotionEvent& event, const InputMessage& msg) {
@@ -658,6 +658,11 @@ void InputConsumer::resampleTouchState(nsecs_t sampleTime, MotionEvent* event,
         }
     }
 
+    if (current->displayId != other->displayId) {
+        ALOGD_IF(debugResampling(), "Not resampled, the other is on a different display");
+        return;
+    }
+
     // Resample touch coordinates.
     History oldLastResample;
     oldLastResample.initializeFrom(touchState.lastResample);
@@ -840,9 +845,11 @@ bool InputConsumer::canAddSample(const Batch& batch, const InputMessage* msg) {
     const InputMessage& head = batch.samples[0];
     uint32_t pointerCount = msg->body.motion.pointerCount;
     if (head.body.motion.pointerCount != pointerCount ||
-        head.body.motion.action != msg->body.motion.action) {
+        head.body.motion.action != msg->body.motion.action ||
+        head.body.motion.displayId != msg->body.motion.displayId) {
         return false;
     }
+
     for (size_t i = 0; i < pointerCount; i++) {
         if (head.body.motion.pointers[i].properties != msg->body.motion.pointers[i].properties) {
             return false;
diff --git a/libs/input/InputConsumerNoResampling.cpp b/libs/input/InputConsumerNoResampling.cpp
index 9578639e2b..d53edc6819 100644
--- a/libs/input/InputConsumerNoResampling.cpp
+++ b/libs/input/InputConsumerNoResampling.cpp
@@ -97,13 +97,14 @@ std::unique_ptr<MotionEvent> createMotionEvent(const InputMessage& msg) {
                           0, 0, 1});
     event->initialize(msg.body.motion.eventId, msg.body.motion.deviceId, msg.body.motion.source,
                       ui::LogicalDisplayId{msg.body.motion.displayId}, msg.body.motion.hmac,
-                      msg.body.motion.action, msg.body.motion.actionButton, msg.body.motion.flags,
-                      msg.body.motion.edgeFlags, msg.body.motion.metaState,
-                      msg.body.motion.buttonState, msg.body.motion.classification, transform,
-                      msg.body.motion.xPrecision, msg.body.motion.yPrecision,
-                      msg.body.motion.xCursorPosition, msg.body.motion.yCursorPosition,
-                      displayTransform, msg.body.motion.downTime, msg.body.motion.eventTime,
-                      pointerCount, pointerProperties.data(), pointerCoords.data());
+                      msg.body.motion.action, msg.body.motion.actionButton,
+                      ftl::Flags<MotionFlag>(msg.body.motion.flags), msg.body.motion.edgeFlags,
+                      msg.body.motion.metaState, msg.body.motion.buttonState,
+                      msg.body.motion.classification, transform, msg.body.motion.xPrecision,
+                      msg.body.motion.yPrecision, msg.body.motion.xCursorPosition,
+                      msg.body.motion.yCursorPosition, displayTransform, msg.body.motion.downTime,
+                      msg.body.motion.eventTime, pointerCount, pointerProperties.data(),
+                      pointerCoords.data());
     return event;
 }
 
@@ -348,10 +349,7 @@ void InputConsumerNoResampling::handleMessages(std::vector<InputMessage>&& messa
             const int32_t action = msg.body.motion.action;
             const DeviceId deviceId = msg.body.motion.deviceId;
             const int32_t source = msg.body.motion.source;
-            const bool batchableEvent = (action == AMOTION_EVENT_ACTION_MOVE ||
-                                         action == AMOTION_EVENT_ACTION_HOVER_MOVE) &&
-                    (isFromSource(source, AINPUT_SOURCE_CLASS_POINTER) ||
-                     isFromSource(source, AINPUT_SOURCE_CLASS_JOYSTICK));
+            const bool batchableEvent = isBatchableEvent(msg);
 
             const bool canResample = (mResamplerCreator != nullptr) &&
                     (isFromSource(source, AINPUT_SOURCE_CLASS_POINTER));
@@ -624,4 +622,25 @@ std::string InputConsumerNoResampling::dump() const {
     return out;
 }
 
+bool InputConsumerNoResampling::isBatchableEvent(const InputMessage& message) const {
+    const int32_t action = message.body.motion.action;
+    const int32_t source = message.body.motion.source;
+    const bool batchableEventTypeAndSource =
+            (action == AMOTION_EVENT_ACTION_MOVE || action == AMOTION_EVENT_ACTION_HOVER_MOVE) &&
+            (isFromSource(source, AINPUT_SOURCE_CLASS_POINTER) ||
+             isFromSource(source, AINPUT_SOURCE_CLASS_JOYSTICK));
+    if (!batchableEventTypeAndSource) {
+        return false;
+    }
+
+    const DeviceId deviceId = message.body.motion.deviceId;
+    const auto& it = mBatches.find(deviceId);
+    // If there is no pending event from the device, it's okay to add the event to the batch.
+    if (it == mBatches.end() || it->second.size() == 0) {
+        return true;
+    }
+    // It's okay to add the event to the existing batch if it's on the same display.
+    return it->second.front().body.motion.displayId == message.body.motion.displayId;
+}
+
 } // namespace android
diff --git a/libs/input/InputDevice.cpp b/libs/input/InputDevice.cpp
index 4a6f66e058..3fe2d02fc8 100644
--- a/libs/input/InputDevice.cpp
+++ b/libs/input/InputDevice.cpp
@@ -20,6 +20,7 @@
 #include <unistd.h>
 #include <ctype.h>
 
+#include <android-base/file.h>
 #include <android-base/logging.h>
 #include <android-base/properties.h>
 #include <android-base/stringprintf.h>
@@ -112,9 +113,13 @@ std::string getInputDeviceConfigurationFilePathByName(
         pathPrefixes.push_back("/apex/" + apex + "/etc/usr/");
     }
     // ANDROID_ROOT may not be set on host
-    if (auto android_root = getenv("ANDROID_ROOT"); android_root != nullptr) {
-        pathPrefixes.push_back(std::string(android_root) + "/usr/");
+    if (auto androidRoot = getenv("ANDROID_ROOT"); androidRoot != nullptr) {
+        pathPrefixes.push_back(std::string(androidRoot) + "/usr/");
+    } else {
+        // To support host-based tests, use the data contained near the executable test binary.
+        pathPrefixes.push_back(base::GetExecutableDirectory() + "/system/usr/");
     }
+
     for (const auto& prefix : pathPrefixes) {
         path = prefix;
         appendInputDeviceConfigurationFileRelativePath(path, name, type);
@@ -199,7 +204,6 @@ InputDeviceInfo::InputDeviceInfo(const InputDeviceInfo& other)
         mEnabled(other.mEnabled),
         mHasVibrator(other.mHasVibrator),
         mHasBattery(other.mHasBattery),
-        mHasButtonUnderPad(other.mHasButtonUnderPad),
         mHasSensor(other.mHasSensor),
         mMotionRanges(other.mMotionRanges),
         mSensors(other.mSensors),
@@ -225,7 +229,6 @@ InputDeviceInfo& InputDeviceInfo::operator=(const InputDeviceInfo& other) {
     mEnabled = other.mEnabled;
     mHasVibrator = other.mHasVibrator;
     mHasBattery = other.mHasBattery;
-    mHasButtonUnderPad = other.mHasButtonUnderPad;
     mHasSensor = other.mHasSensor;
     mMotionRanges = other.mMotionRanges;
     mSensors = other.mSensors;
@@ -255,7 +258,6 @@ void InputDeviceInfo::initialize(int32_t id, int32_t generation, int32_t control
     mEnabled = enabled;
     mHasVibrator = false;
     mHasBattery = false;
-    mHasButtonUnderPad = false;
     mHasSensor = false;
     mViewBehavior = viewBehavior;
     mUsiVersion.reset();
diff --git a/libs/input/InputFlags.cpp b/libs/input/InputFlags.cpp
index 6aa9ae6b16..b13aad5a29 100644
--- a/libs/input/InputFlags.cpp
+++ b/libs/input/InputFlags.cpp
@@ -25,9 +25,13 @@
 
 namespace android {
 
-bool InputFlags::connectedDisplaysCursorEnabled() {
-    if (!com::android::window::flags::enable_desktop_mode_through_dev_option()) {
-        return com::android::input::flags::connected_displays_cursor();
+namespace {
+
+// Returns the cached dev option value if available.
+// This check is only required for connected-displays related features.
+std::optional<bool> getConnectedDisplaysDevOptionValue() {
+    if (!com::android::window::flags::show_desktop_experience_dev_option()) {
+        return std::nullopt;
     }
     static std::optional<bool> cachedDevOption;
     if (!cachedDevOption.has_value()) {
@@ -37,15 +41,35 @@ bool InputFlags::connectedDisplaysCursorEnabled() {
                 property_get(sysprop_name, value, nullptr) > 0 ? std::atoi(value) : 0;
         cachedDevOption = devOptionEnabled == 1;
     }
-    if (cachedDevOption.value_or(false)) {
+    return cachedDevOption;
+}
+
+} // namespace
+
+bool InputFlags::connectedDisplaysCursorEnabled() {
+    if (getConnectedDisplaysDevOptionValue().value_or(false)) {
         return true;
     }
     return com::android::input::flags::connected_displays_cursor();
 }
 
 bool InputFlags::connectedDisplaysCursorAndAssociatedDisplayCursorBugfixEnabled() {
+    if (getConnectedDisplaysDevOptionValue().value_or(false)) {
+        return true;
+    }
     return connectedDisplaysCursorEnabled() &&
             com::android::input::flags::connected_displays_associated_display_cursor_bugfix();
 }
 
-} // namespace android
\ No newline at end of file
+bool InputFlags::scaleCursorSpeedWithDisplayDensity() {
+    if (getConnectedDisplaysDevOptionValue().value_or(false)) {
+        return true;
+    }
+    return com::android::input::flags::scale_cursor_speed_with_dpi();
+}
+
+bool InputFlags::doNotUseSkipScreenshotFlagForMouseCursor() {
+    return getConnectedDisplaysDevOptionValue().value_or(false);
+}
+
+} // namespace android
diff --git a/libs/input/InputTransport.cpp b/libs/input/InputTransport.cpp
index cb6f7f0707..a6ab86dd05 100644
--- a/libs/input/InputTransport.cpp
+++ b/libs/input/InputTransport.cpp
@@ -553,8 +553,8 @@ status_t InputPublisher::publishKeyEvent(uint32_t seq, int32_t eventId, int32_t
                                 KeyEvent::getLabel(keyCode)));
     ALOGD_IF(debugTransportPublisher(),
              "channel '%s' publisher ~ %s: seq=%u, id=%d, deviceId=%d, source=%s, "
-             "action=%s, flags=0x%x, keyCode=%s, scanCode=%d, metaState=0x%x, repeatCount=%d,"
-             "downTime=%" PRId64 ", eventTime=%" PRId64,
+             "action=%s, flags=0x%x, keyCode=%s, scanCode=%d, metaState=0x%x, repeatCount=%d, "
+             "downTime=%" PRId64 "ns, eventTime=%" PRId64 "ns",
              mChannel->getName().c_str(), __func__, seq, eventId, deviceId,
              inputEventSourceToString(source).c_str(), KeyEvent::actionToString(action), flags,
              KeyEvent::getLabel(keyCode), scanCode, metaState, repeatCount, downTime, eventTime);
@@ -602,8 +602,8 @@ status_t InputPublisher::publishMotionEvent(
         ALOGD("channel '%s' publisher ~ %s: seq=%u, id=%d, deviceId=%d, source=%s, "
               "displayId=%s, "
               "action=%s, actionButton=0x%08x, flags=0x%x, edgeFlags=0x%x, "
-              "metaState=0x%x, buttonState=0x%x, classification=%s,"
-              "xPrecision=%f, yPrecision=%f, downTime=%" PRId64 ", eventTime=%" PRId64 ", "
+              "metaState=0x%x, buttonState=0x%x, classification=%s, "
+              "xPrecision=%f, yPrecision=%f, downTime=%" PRId64 "ns, eventTime=%" PRId64 "ns, "
               "pointerCount=%" PRIu32 "\n%s",
               mChannel->getName().c_str(), __func__, seq, eventId, deviceId,
               inputEventSourceToString(source).c_str(), displayId.toString().c_str(),
diff --git a/libs/input/InputVerifier.cpp b/libs/input/InputVerifier.cpp
index 7811acefd0..c26a696529 100644
--- a/libs/input/InputVerifier.cpp
+++ b/libs/input/InputVerifier.cpp
@@ -19,6 +19,7 @@
 #include <android-base/logging.h>
 #include <com_android_input_flags.h>
 #include <input/InputVerifier.h>
+#include <input/PrintTools.h>
 #include "input_cxx_bridge.rs.h"
 
 using android::base::Error;
@@ -61,6 +62,11 @@ Result<void> InputVerifier::processMovement(DeviceId deviceId, int32_t source, i
     }
 }
 
+std::string InputVerifier::dump() const {
+    const rust::String out = android::input::verifier::dump(*mVerifier);
+    return streamableToString(out);
+}
+
 void InputVerifier::resetDevice(DeviceId deviceId) {
     android::input::verifier::reset_device(*mVerifier, deviceId);
 }
diff --git a/libs/input/KeyboardClassifier.cpp b/libs/input/KeyboardClassifier.cpp
index 2a83919283..4ec62a72f5 100644
--- a/libs/input/KeyboardClassifier.cpp
+++ b/libs/input/KeyboardClassifier.cpp
@@ -17,70 +17,42 @@
 #define LOG_TAG "KeyboardClassifier"
 
 #include <android-base/logging.h>
-#include <com_android_input_flags.h>
 #include <ftl/flags.h>
 #include <input/KeyboardClassifier.h>
 
 #include "input_cxx_bridge.rs.h"
 
-namespace input_flags = com::android::input::flags;
-
 using android::input::RustInputDeviceIdentifier;
 
 namespace android {
 
 KeyboardClassifier::KeyboardClassifier() {
-    if (input_flags::enable_keyboard_classifier()) {
-        mRustClassifier = android::input::keyboardClassifier::create();
-    }
+    mRustClassifier = android::input::keyboardClassifier::create();
 }
 
 KeyboardType KeyboardClassifier::getKeyboardType(DeviceId deviceId) {
-    if (mRustClassifier) {
-        return static_cast<KeyboardType>(
-                android::input::keyboardClassifier::getKeyboardType(**mRustClassifier, deviceId));
-    } else {
-        auto it = mKeyboardTypeMap.find(deviceId);
-        if (it == mKeyboardTypeMap.end()) {
-            return KeyboardType::NONE;
-        }
-        return it->second;
-    }
+    return static_cast<KeyboardType>(
+            android::input::keyboardClassifier::getKeyboardType(**mRustClassifier, deviceId));
 }
 
-// Copied from EventHub.h
-const uint32_t DEVICE_CLASS_KEYBOARD = android::os::IInputConstants::DEVICE_CLASS_KEYBOARD;
-const uint32_t DEVICE_CLASS_ALPHAKEY = android::os::IInputConstants::DEVICE_CLASS_ALPHAKEY;
-
 void KeyboardClassifier::notifyKeyboardChanged(DeviceId deviceId,
                                                const InputDeviceIdentifier& identifier,
                                                uint32_t deviceClasses) {
-    if (mRustClassifier) {
-        RustInputDeviceIdentifier rustIdentifier;
-        rustIdentifier.name = rust::String::lossy(identifier.name);
-        rustIdentifier.location = rust::String::lossy(identifier.location);
-        rustIdentifier.unique_id = rust::String::lossy(identifier.uniqueId);
-        rustIdentifier.bus = identifier.bus;
-        rustIdentifier.vendor = identifier.vendor;
-        rustIdentifier.product = identifier.product;
-        rustIdentifier.version = identifier.version;
-        rustIdentifier.descriptor = rust::String::lossy(identifier.descriptor);
-        android::input::keyboardClassifier::notifyKeyboardChanged(**mRustClassifier, deviceId,
-                                                                  rustIdentifier, deviceClasses);
-    } else {
-        bool isKeyboard = (deviceClasses & DEVICE_CLASS_KEYBOARD) != 0;
-        bool hasAlphabeticKey = (deviceClasses & DEVICE_CLASS_ALPHAKEY) != 0;
-        mKeyboardTypeMap.insert_or_assign(deviceId,
-                                          isKeyboard ? (hasAlphabeticKey
-                                                                ? KeyboardType::ALPHABETIC
-                                                                : KeyboardType::NON_ALPHABETIC)
-                                                     : KeyboardType::NONE);
-    }
+    RustInputDeviceIdentifier rustIdentifier;
+    rustIdentifier.name = rust::String::lossy(identifier.name);
+    rustIdentifier.location = rust::String::lossy(identifier.location);
+    rustIdentifier.unique_id = rust::String::lossy(identifier.uniqueId);
+    rustIdentifier.bus = identifier.bus;
+    rustIdentifier.vendor = identifier.vendor;
+    rustIdentifier.product = identifier.product;
+    rustIdentifier.version = identifier.version;
+    rustIdentifier.descriptor = rust::String::lossy(identifier.descriptor);
+    android::input::keyboardClassifier::notifyKeyboardChanged(**mRustClassifier, deviceId,
+                                                                rustIdentifier, deviceClasses);
 }
 
 void KeyboardClassifier::processKey(DeviceId deviceId, int32_t evdevCode, uint32_t metaState) {
-    if (mRustClassifier &&
-        !android::input::keyboardClassifier::isFinalized(**mRustClassifier, deviceId)) {
+    if (!android::input::keyboardClassifier::isFinalized(**mRustClassifier, deviceId)) {
         android::input::keyboardClassifier::processKey(**mRustClassifier, deviceId, evdevCode,
                                                        metaState);
     }
diff --git a/libs/input/PropertyMap.cpp b/libs/input/PropertyMap.cpp
index 5f6f9e26b6..6e95cb54f2 100644
--- a/libs/input/PropertyMap.cpp
+++ b/libs/input/PropertyMap.cpp
@@ -118,8 +118,8 @@ std::optional<double> PropertyMap::getDouble(const std::string& key) const {
     return value;
 }
 
-void PropertyMap::addAll(const PropertyMap* map) {
-    for (const auto& [key, value] : map->mProperties) {
+void PropertyMap::addAll(const PropertyMap& map) {
+    for (const auto& [key, value] : map.mProperties) {
         mProperties.emplace(key, value);
     }
 }
diff --git a/libs/input/VelocityTracker.cpp b/libs/input/VelocityTracker.cpp
index 613a0df040..be7f8b4039 100644
--- a/libs/input/VelocityTracker.cpp
+++ b/libs/input/VelocityTracker.cpp
@@ -269,7 +269,7 @@ void VelocityTracker::addMovement(nsecs_t eventTime, int32_t pointerId, int32_t
 
     if (DEBUG_VELOCITY) {
         LOG(INFO) << "VelocityTracker: addMovement axis=" << MotionEvent::getLabel(axis)
-                  << ", eventTime=" << eventTime << ", pointerId=" << pointerId
+                  << ", eventTime=" << eventTime << "ns, pointerId=" << pointerId
                   << ", activePointerId=" << toString(mActivePointerId) << ", position=" << position
                   << ", velocity=" << toString(getVelocity(axis, pointerId));
     }
@@ -300,7 +300,7 @@ void VelocityTracker::addMovement(const MotionEvent& event) {
             axesToProcess.insert(PLANAR_AXES.begin(), PLANAR_AXES.end());
             break;
         case AMOTION_EVENT_ACTION_POINTER_UP:
-            if (event.getFlags() & AMOTION_EVENT_FLAG_CANCELED) {
+            if (event.getFlags().test(MotionFlag::CANCELED)) {
                 clearPointer(event.getPointerId(event.getActionIndex()));
                 return;
             }
diff --git a/libs/input/android/os/InputConfig.aidl b/libs/input/android/os/InputConfig.aidl
index e5f7b56561..727f1d3860 100644
--- a/libs/input/android/os/InputConfig.aidl
+++ b/libs/input/android/os/InputConfig.aidl
@@ -160,4 +160,26 @@ enum InputConfig {
      * determine how these sensitive events are eventually traced.
      */
      SENSITIVE_FOR_PRIVACY       = 1 << 18,
+
+    /**
+     * InputConfig used to indicate that this window is topology aware. Using this flag will allow
+     * windows to receive gestures that can cross display boundaries. This flag is used for cross
+     * display drag and drop of windows and contents.
+     *
+     * Window with this flag can receive an input event stream containing events with varying
+     * displayIds in the corresponding coordinate space when the cursor crosses display boundary.
+     *
+     * When this flag is not set, window will receive a modified event stream where display Id will
+     * remain unchanged and coordinate space will extend beyond the logical display space.
+     */
+     DISPLAY_TOPOLOGY_AWARE       = 1 << 19,
+
+    /**
+     * InputConfig used to indicate that any pointer streams targeting this window should not be
+     * canceled as part of a pilferPointers request.
+     *
+     * This is only meant to be used by system components that need to be perpetually be aware of
+     * all input streams, such as the PointerLocationView used for debugging.
+     */
+     DO_NOT_PILFER                = 1 << 20,
 }
diff --git a/libs/input/input_flags.aconfig b/libs/input/input_flags.aconfig
index a2de0093d1..a9639b29b4 100644
--- a/libs/input/input_flags.aconfig
+++ b/libs/input/input_flags.aconfig
@@ -122,13 +122,6 @@ flag {
   }
 }
 
-flag {
-  name: "enable_keyboard_classifier"
-  namespace: "input"
-  description: "Keyboard classifier that classifies all keyboards into alphabetic or non-alphabetic"
-  bug: "263559234"
-}
-
 flag {
   name: "show_pointers_for_partial_screenshare"
   namespace: "input"
@@ -150,13 +143,6 @@ flag {
   bug: "341717757"
 }
 
-flag {
-  name: "enable_touchpad_no_focus_change"
-  namespace: "input"
-  description: "Prevents touchpad gesture changing window focus."
-  bug: "364460018"
-}
-
 flag {
   name: "enable_input_policy_profile"
   namespace: "input"
@@ -223,6 +209,13 @@ flag {
   }
 }
 
+flag {
+  name: "scale_cursor_speed_with_dpi"
+  namespace: "lse_desktop_experience"
+  description: "Scale the cursor speed based on display density"
+  bug: "367662715"
+}
+
 flag {
   name: "use_cloned_screen_coordinates_as_raw"
   namespace: "input"
@@ -252,3 +245,13 @@ flag {
     purpose: PURPOSE_BUGFIX
   }
 }
+
+flag {
+  name: "use_topology_aware_flag"
+  namespace: "input"
+  description: "Require apps to use topology-aware flag to receive cross-display gestures"
+  bug: "401220484"
+  metadata {
+    purpose: PURPOSE_BUGFIX
+  }
+}
diff --git a/libs/input/rust/input_verifier.rs b/libs/input/rust/input_verifier.rs
index f87dd413c6..4462fe3931 100644
--- a/libs/input/rust/input_verifier.rs
+++ b/libs/input/rust/input_verifier.rs
@@ -393,6 +393,11 @@ impl InputVerifier {
         self.hovering_pointer_ids_by_device.remove(&device_id);
     }
 
+    /// Dump the current state of the verifier
+    pub fn dump(&self) -> String {
+        format!("{:?}", self.touching_pointer_ids_by_device)
+    }
+
     fn ensure_touching_pointers_match(
         &self,
         device_id: DeviceId,
diff --git a/libs/input/rust/lib.rs b/libs/input/rust/lib.rs
index ee999f7666..5b0209004d 100644
--- a/libs/input/rust/lib.rs
+++ b/libs/input/rust/lib.rs
@@ -69,6 +69,7 @@ mod ffi {
             flags: u32,
             button_state: u32,
         ) -> String;
+        fn dump(verifier: &InputVerifier) -> String;
         fn reset_device(verifier: &mut InputVerifier, device_id: i32);
     }
 
@@ -185,6 +186,10 @@ fn process_movement(
     }
 }
 
+fn dump(verifier: &InputVerifier) -> String {
+    verifier.dump()
+}
+
 fn reset_device(verifier: &mut InputVerifier, device_id: i32) {
     verifier.reset_device(DeviceId(device_id));
 }
diff --git a/libs/input/tests/Android.bp b/libs/input/tests/Android.bp
index 968fa5fc1a..93966d8b68 100644
--- a/libs/input/tests/Android.bp
+++ b/libs/input/tests/Android.bp
@@ -10,7 +10,6 @@ package {
 
 cc_test {
     name: "libinput_tests",
-    cpp_std: "c++20",
     host_supported: true,
     srcs: [
         "BlockingQueue_test.cpp",
@@ -80,7 +79,6 @@ cc_test {
         "libbinder",
         "libcutils",
         "liblog",
-        "libstatslog",
         "libtinyxml2",
         "libutils",
         "server_configurable_flags",
@@ -89,6 +87,10 @@ cc_test {
         ":motion_predictor_model",
         "data/*",
     ],
+    device_first_data: [
+        ":keychars_test_data",
+        ":keylayout_test_data",
+    ],
     test_options: {
         unit_test: true,
     },
diff --git a/libs/input/tests/InputConsumerResampling_test.cpp b/libs/input/tests/InputConsumerResampling_test.cpp
index 97688a83ae..748cc69e4b 100644
--- a/libs/input/tests/InputConsumerResampling_test.cpp
+++ b/libs/input/tests/InputConsumerResampling_test.cpp
@@ -56,6 +56,7 @@ struct InputEventEntry {
     std::chrono::nanoseconds eventTime{0};
     std::vector<Pointer> pointers{};
     int32_t action{-1};
+    ui::LogicalDisplayId displayId = ui::LogicalDisplayId::DEFAULT;
 };
 
 } // namespace
@@ -137,7 +138,8 @@ InputMessage InputConsumerResamplingTest::nextPointerMessage(const InputEventEnt
                                                  .eventTime(entry.eventTime.count())
                                                  .deviceId(1)
                                                  .action(entry.action)
-                                                 .downTime(0);
+                                                 .downTime(0)
+                                                 .displayId(entry.displayId);
     for (const Pointer& pointer : entry.pointers) {
         messageBuilder.pointer(pointer.asPointerBuilder());
     }
@@ -741,4 +743,50 @@ TEST_F(InputConsumerResamplingTest, TwoPointersAreResampledIndependently) {
                              AMOTION_EVENT_ACTION_MOVE}});
 }
 
+/**
+ * Events should not be resampled when they are on different displays.
+ */
+TEST_F(InputConsumerResamplingTest, EventsOnDifferentDisplaysAreNotResampled) {
+    // Send the initial ACTION_DOWN separately, so that the first consumed event will only return an
+    // InputEvent with a single action.
+    mClientTestChannel->enqueueMessage(nextPointerMessage(
+            {0ms, {Pointer{.id = 0, .x = 10.0f, .y = 20.0f}}, AMOTION_EVENT_ACTION_DOWN}));
+
+    invokeLooperCallback();
+    assertReceivedMotionEvent({InputEventEntry{0ms,
+                                               {Pointer{.id = 0, .x = 10.0f, .y = 20.0f}},
+                                               AMOTION_EVENT_ACTION_DOWN}});
+
+    // Two ACTION_MOVE events 10 ms apart that move in X direction and stay still in Y, but on
+    // different displays
+    mClientTestChannel->enqueueMessage(
+            nextPointerMessage({10ms,
+                                {Pointer{.id = 0, .x = 20.0f, .y = 30.0f}},
+                                AMOTION_EVENT_ACTION_MOVE,
+                                ui::LogicalDisplayId::DEFAULT}));
+    mClientTestChannel->enqueueMessage(
+            nextPointerMessage({20ms,
+                                {Pointer{.id = 0, .x = 30.0f, .y = 30.0f}},
+                                AMOTION_EVENT_ACTION_MOVE,
+                                ui::LogicalDisplayId{1}}));
+
+    invokeLooperCallback();
+    mConsumer->consumeBatchedInputEvents(nanoseconds{20ms + RESAMPLE_LATENCY * 2}.count());
+
+    // MotionEvent should not be resampled because the resample time falls exactly on the existing
+    // event time.
+    assertReceivedMotionEvent({InputEventEntry{10ms,
+                                               {Pointer{.id = 0, .x = 20.0f, .y = 30.0f}},
+                                               AMOTION_EVENT_ACTION_MOVE,
+                                               ui::LogicalDisplayId::DEFAULT}});
+    assertReceivedMotionEvent({InputEventEntry{20ms,
+                                               {Pointer{.id = 0, .x = 30.0f, .y = 30.0f}},
+                                               AMOTION_EVENT_ACTION_MOVE,
+                                               ui::LogicalDisplayId{1}}});
+
+    mClientTestChannel->assertFinishMessage(/*seq=*/1, /*handled=*/true);
+    mClientTestChannel->assertFinishMessage(/*seq=*/2, /*handled=*/true);
+    mClientTestChannel->assertFinishMessage(/*seq=*/3, /*handled=*/true);
+}
+
 } // namespace android
diff --git a/libs/input/tests/InputDevice_test.cpp b/libs/input/tests/InputDevice_test.cpp
index fe5490caf5..5be32ea63b 100644
--- a/libs/input/tests/InputDevice_test.cpp
+++ b/libs/input/tests/InputDevice_test.cpp
@@ -66,9 +66,6 @@ protected:
     }
 
     void SetUp() override {
-#if !defined(__ANDROID__)
-        GTEST_SKIP() << "b/253299089 Generic files are currently read directly from device.";
-#endif
         loadKeyLayout("Generic");
         loadKeyCharacterMap("Generic");
     }
diff --git a/libs/input/tests/InputEvent_test.cpp b/libs/input/tests/InputEvent_test.cpp
index a67e1ef472..fb94729fac 100644
--- a/libs/input/tests/InputEvent_test.cpp
+++ b/libs/input/tests/InputEvent_test.cpp
@@ -362,9 +362,9 @@ void MotionEventTest::SetUp() {
 }
 
 void MotionEventTest::initializeEventWithHistory(MotionEvent* event) {
-    const int32_t flags = AMOTION_EVENT_FLAG_WINDOW_IS_OBSCURED |
-            AMOTION_EVENT_PRIVATE_FLAG_SUPPORTS_ORIENTATION |
-            AMOTION_EVENT_PRIVATE_FLAG_SUPPORTS_DIRECTIONAL_ORIENTATION;
+    const ftl::Flags<MotionFlag> flags{MotionFlag::WINDOW_IS_OBSCURED,
+                                       MotionFlag::SUPPORTS_ORIENTATION,
+                                       MotionFlag::SUPPORTS_DIRECTIONAL_ORIENTATION};
     event->initialize(mId, 2, AINPUT_SOURCE_TOUCHSCREEN, DISPLAY_ID, HMAC,
                       AMOTION_EVENT_ACTION_MOVE, 0, flags, AMOTION_EVENT_EDGE_FLAG_TOP,
                       AMETA_ALT_ON, AMOTION_EVENT_BUTTON_PRIMARY, MotionClassification::NONE,
@@ -384,9 +384,9 @@ void MotionEventTest::assertEqualsEventWithHistory(const MotionEvent* event) {
     ASSERT_EQ(DISPLAY_ID, event->getDisplayId());
     EXPECT_EQ(HMAC, event->getHmac());
     ASSERT_EQ(AMOTION_EVENT_ACTION_MOVE, event->getAction());
-    ASSERT_EQ(AMOTION_EVENT_FLAG_WINDOW_IS_OBSCURED |
-                      AMOTION_EVENT_PRIVATE_FLAG_SUPPORTS_ORIENTATION |
-                      AMOTION_EVENT_PRIVATE_FLAG_SUPPORTS_DIRECTIONAL_ORIENTATION,
+    ASSERT_EQ(ftl::Flags<MotionFlag>({MotionFlag::WINDOW_IS_OBSCURED,
+                                      MotionFlag::SUPPORTS_ORIENTATION,
+                                      MotionFlag::SUPPORTS_DIRECTIONAL_ORIENTATION}),
               event->getFlags());
     ASSERT_EQ(AMOTION_EVENT_EDGE_FLAG_TOP, event->getEdgeFlags());
     ASSERT_EQ(AMETA_ALT_ON, event->getMetaState());
@@ -595,7 +595,7 @@ TEST_F(MotionEventTest, CheckEventIdWithHistoryIsIncremented) {
     MotionEvent event;
     constexpr int32_t ARBITRARY_ID = 42;
     event.initialize(ARBITRARY_ID, 2, AINPUT_SOURCE_TOUCHSCREEN, DISPLAY_ID, INVALID_HMAC,
-                     AMOTION_EVENT_ACTION_MOVE, 0, 0, AMOTION_EVENT_EDGE_FLAG_NONE, AMETA_NONE,
+                     AMOTION_EVENT_ACTION_MOVE, 0, {}, AMOTION_EVENT_EDGE_FLAG_NONE, AMETA_NONE,
                      AMOTION_EVENT_BUTTON_PRIMARY, MotionClassification::NONE, mTransform, 0, 0,
                      AMOTION_EVENT_INVALID_CURSOR_POSITION, AMOTION_EVENT_INVALID_CURSOR_POSITION,
                      mRawTransform, ARBITRARY_DOWN_TIME, ARBITRARY_EVENT_TIME, 2,
@@ -703,7 +703,7 @@ TEST_F(MotionEventTest, SplitPointerUpCancel) {
                                 .pointer(PointerBuilder(/*id=*/4, ToolType::FINGER).x(4).y(4))
                                 .pointer(PointerBuilder(/*id=*/6, ToolType::FINGER).x(6).y(6))
                                 .pointer(PointerBuilder(/*id=*/8, ToolType::FINGER).x(8).y(8))
-                                .addFlag(AMOTION_EVENT_FLAG_CANCELED)
+                                .addFlag(MotionFlag::CANCELED)
                                 .build();
 
     MotionEvent splitUp;
@@ -838,8 +838,8 @@ TEST_F(MotionEventTest, Transform) {
     }
     MotionEvent event;
     ui::Transform identityTransform;
-    const int32_t flags = AMOTION_EVENT_PRIVATE_FLAG_SUPPORTS_ORIENTATION |
-            AMOTION_EVENT_PRIVATE_FLAG_SUPPORTS_DIRECTIONAL_ORIENTATION;
+    const ftl::Flags<MotionFlag> flags{MotionFlag::SUPPORTS_ORIENTATION,
+                                       MotionFlag::SUPPORTS_DIRECTIONAL_ORIENTATION};
     event.initialize(InputEvent::nextId(), /*deviceId=*/0, AINPUT_SOURCE_TOUCHSCREEN, DISPLAY_ID,
                      INVALID_HMAC, AMOTION_EVENT_ACTION_MOVE, /*actionButton=*/0, flags,
                      AMOTION_EVENT_EDGE_FLAG_NONE, AMETA_NONE, /*buttonState=*/0,
@@ -900,7 +900,7 @@ MotionEvent createMotionEvent(int32_t source, uint32_t action, float x, float y,
     nsecs_t eventTime = systemTime(SYSTEM_TIME_MONOTONIC);
     MotionEvent event;
     event.initialize(InputEvent::nextId(), /*deviceId=*/1, source, ui::LogicalDisplayId::DEFAULT,
-                     INVALID_HMAC, action, /*actionButton=*/0, /*flags=*/0, /*edgeFlags=*/0,
+                     INVALID_HMAC, action, /*actionButton=*/0, /*flags=*/{}, /*edgeFlags=*/0,
                      AMETA_NONE, /*buttonState=*/0, MotionClassification::NONE, transform,
                      /*xPrecision=*/0, /*yPrecision=*/0, AMOTION_EVENT_INVALID_CURSOR_POSITION,
                      AMOTION_EVENT_INVALID_CURSOR_POSITION, rawTransform, eventTime, eventTime,
@@ -1046,7 +1046,7 @@ TEST_F(MotionEventTest, Initialize_SetsClassification) {
     ui::Transform identityTransform;
     for (MotionClassification classification : classifications) {
         event.initialize(InputEvent::nextId(), /*deviceId=*/0, AINPUT_SOURCE_TOUCHSCREEN,
-                         DISPLAY_ID, INVALID_HMAC, AMOTION_EVENT_ACTION_DOWN, 0, 0,
+                         DISPLAY_ID, INVALID_HMAC, AMOTION_EVENT_ACTION_DOWN, 0, {},
                          AMOTION_EVENT_EDGE_FLAG_NONE, AMETA_NONE, 0, classification,
                          identityTransform, 0, 0, AMOTION_EVENT_INVALID_CURSOR_POSITION,
                          AMOTION_EVENT_INVALID_CURSOR_POSITION, identityTransform, /*downTime=*/0,
@@ -1068,7 +1068,7 @@ TEST_F(MotionEventTest, Initialize_SetsCursorPosition) {
 
     ui::Transform identityTransform;
     event.initialize(InputEvent::nextId(), /*deviceId=*/0, AINPUT_SOURCE_MOUSE, DISPLAY_ID,
-                     INVALID_HMAC, AMOTION_EVENT_ACTION_DOWN, 0, 0, AMOTION_EVENT_EDGE_FLAG_NONE,
+                     INVALID_HMAC, AMOTION_EVENT_ACTION_DOWN, 0, {}, AMOTION_EVENT_EDGE_FLAG_NONE,
                      AMETA_NONE, 0, MotionClassification::NONE, identityTransform, 0, 0,
                      /*xCursorPosition=*/280, /*yCursorPosition=*/540, identityTransform,
                      /*downTime=*/0, /*eventTime=*/0, pointerCount, pointerProperties,
@@ -1112,7 +1112,7 @@ TEST_F(MotionEventTest, CoordinatesAreRoundedAppropriately) {
     PointerProperties pp{};
     MotionEvent event;
     event.initialize(InputEvent::nextId(), 2, AINPUT_SOURCE_TOUCHSCREEN, DISPLAY_ID, HMAC,
-                     AMOTION_EVENT_ACTION_MOVE, 0, AMOTION_EVENT_FLAG_WINDOW_IS_OBSCURED,
+                     AMOTION_EVENT_ACTION_MOVE, 0, MotionFlag::WINDOW_IS_OBSCURED,
                      AMOTION_EVENT_EDGE_FLAG_TOP, AMETA_ALT_ON, AMOTION_EVENT_BUTTON_PRIMARY,
                      MotionClassification::NONE, transform, 2.0f, 2.1f, rawCoords.x, rawCoords.y,
                      transform, ARBITRARY_DOWN_TIME, ARBITRARY_EVENT_TIME, 1, &pp, &pc);
@@ -1153,10 +1153,10 @@ TEST_F(MotionEventTest, ValidZeroOrientationRotated) {
                            .pointer(PointerBuilder(/*id=*/4, ToolType::FINGER).x(4).y(4))
                            .transform(ui::Transform(ui::Transform::ROT_90, 100, 100))
                            .rawTransform(ui::Transform(ui::Transform::FLIP_H, 50, 50))
-                           .addFlag(AMOTION_EVENT_PRIVATE_FLAG_SUPPORTS_ORIENTATION);
+                           .addFlag(MotionFlag::SUPPORTS_ORIENTATION);
     MotionEvent nonDirectionalEvent = builder.build();
     MotionEvent directionalEvent =
-            builder.addFlag(AMOTION_EVENT_PRIVATE_FLAG_SUPPORTS_DIRECTIONAL_ORIENTATION).build();
+            builder.addFlag(MotionFlag::SUPPORTS_DIRECTIONAL_ORIENTATION).build();
 
     // The angle is rotated by the initial transform, a 90-degree rotation.
     ASSERT_NEAR(fabs(nonDirectionalEvent.getOrientation(/*pointerIndex=*/0)), M_PI_2, EPSILON);
@@ -1188,11 +1188,11 @@ TEST_F(MotionEventTest, ValidNonZeroOrientationRotated) {
                                             .axis(AMOTION_EVENT_AXIS_ORIENTATION, initial))
                            .transform(ui::Transform(ui::Transform::ROT_90, 100, 100))
                            .rawTransform(ui::Transform(ui::Transform::FLIP_H, 50, 50))
-                           .addFlag(AMOTION_EVENT_PRIVATE_FLAG_SUPPORTS_ORIENTATION);
+                           .addFlag(MotionFlag::SUPPORTS_ORIENTATION);
 
     MotionEvent nonDirectionalEvent = builder.build();
     MotionEvent directionalEvent =
-            builder.addFlag(AMOTION_EVENT_PRIVATE_FLAG_SUPPORTS_DIRECTIONAL_ORIENTATION).build();
+            builder.addFlag(MotionFlag::SUPPORTS_DIRECTIONAL_ORIENTATION).build();
 
     // The angle is rotated by the initial transform, a 90-degree rotation.
     ASSERT_NEAR(nonDirectionalEvent.getOrientation(/*pointerIndex=*/0), initial - M_PI_2, EPSILON);
diff --git a/libs/input/tests/InputPublisherAndConsumerNoResampling_test.cpp b/libs/input/tests/InputPublisherAndConsumerNoResampling_test.cpp
index 1dadae98e4..35cc4a0d3d 100644
--- a/libs/input/tests/InputPublisherAndConsumerNoResampling_test.cpp
+++ b/libs/input/tests/InputPublisherAndConsumerNoResampling_test.cpp
@@ -139,7 +139,7 @@ void verifyArgsEqualToEvent(const PublishMotionArgs& args, const MotionEvent& mo
     EXPECT_EQ(args.hmac, motionEvent.getHmac());
     EXPECT_EQ(args.action, motionEvent.getAction());
     EXPECT_EQ(args.downTime, motionEvent.getDownTime());
-    EXPECT_EQ(args.flags, motionEvent.getFlags());
+    EXPECT_EQ(args.flags, static_cast<int32_t>(motionEvent.getFlags().get()));
     EXPECT_EQ(args.edgeFlags, motionEvent.getEdgeFlags());
     EXPECT_EQ(args.metaState, motionEvent.getMetaState());
     EXPECT_EQ(args.buttonState, motionEvent.getButtonState());
diff --git a/libs/input/tests/InputPublisherAndConsumer_test.cpp b/libs/input/tests/InputPublisherAndConsumer_test.cpp
index e65a919bd6..1fbc1e6116 100644
--- a/libs/input/tests/InputPublisherAndConsumer_test.cpp
+++ b/libs/input/tests/InputPublisherAndConsumer_test.cpp
@@ -129,7 +129,7 @@ void verifyArgsEqualToEvent(const PublishMotionArgs& args, const MotionEvent& mo
     EXPECT_EQ(args.hmac, motionEvent.getHmac());
     EXPECT_EQ(args.action, motionEvent.getAction());
     EXPECT_EQ(args.downTime, motionEvent.getDownTime());
-    EXPECT_EQ(args.flags, motionEvent.getFlags());
+    EXPECT_EQ(args.flags, static_cast<int32_t>(motionEvent.getFlags().get()));
     EXPECT_EQ(args.edgeFlags, motionEvent.getEdgeFlags());
     EXPECT_EQ(args.metaState, motionEvent.getMetaState());
     EXPECT_EQ(args.buttonState, motionEvent.getButtonState());
diff --git a/libs/input/tests/MotionPredictor_test.cpp b/libs/input/tests/MotionPredictor_test.cpp
index 106e686a81..090d128455 100644
--- a/libs/input/tests/MotionPredictor_test.cpp
+++ b/libs/input/tests/MotionPredictor_test.cpp
@@ -59,7 +59,7 @@ static MotionEvent getMotionEvent(int32_t action, float x, float y,
 
     ui::Transform identityTransform;
     event.initialize(InputEvent::nextId(), deviceId, AINPUT_SOURCE_STYLUS,
-                     ui::LogicalDisplayId::DEFAULT, {0}, action, /*actionButton=*/0, /*flags=*/0,
+                     ui::LogicalDisplayId::DEFAULT, {0}, action, /*actionButton=*/0, /*flags=*/{},
                      AMOTION_EVENT_EDGE_FLAG_NONE, AMETA_NONE, /*buttonState=*/0,
                      MotionClassification::NONE, identityTransform,
                      /*xPrecision=*/0.1,
diff --git a/libs/input/tests/TestEventMatchers.h b/libs/input/tests/TestEventMatchers.h
index 8dbdcb310a..2618170d29 100644
--- a/libs/input/tests/TestEventMatchers.h
+++ b/libs/input/tests/TestEventMatchers.h
@@ -79,7 +79,7 @@ public:
             return false;
         }
         if (event.getAction() == AMOTION_EVENT_ACTION_CANCEL &&
-            (event.getFlags() & AMOTION_EVENT_FLAG_CANCELED) == 0) {
+            !event.getFlags().test(MotionFlag::CANCELED)) {
             *listener << "event with CANCEL action is missing FLAG_CANCELED";
             return false;
         }
diff --git a/libs/input/tests/TouchResampling_test.cpp b/libs/input/tests/TouchResampling_test.cpp
index 9841c03826..1bac64441a 100644
--- a/libs/input/tests/TouchResampling_test.cpp
+++ b/libs/input/tests/TouchResampling_test.cpp
@@ -40,6 +40,7 @@ struct InputEventEntry {
     std::chrono::nanoseconds eventTime;
     std::vector<Pointer> pointers;
     int32_t action;
+    ui::LogicalDisplayId displayId = ui::LogicalDisplayId::DEFAULT;
 };
 
 } // namespace
@@ -65,9 +66,10 @@ protected:
 
     status_t publishSimpleMotionEventWithCoords(int32_t action, nsecs_t eventTime,
                                                 const std::vector<PointerProperties>& properties,
-                                                const std::vector<PointerCoords>& coords);
+                                                const std::vector<PointerCoords>& coords,
+                                                ui::LogicalDisplayId displayId);
     void publishSimpleMotionEvent(int32_t action, nsecs_t eventTime,
-                                  const std::vector<Pointer>& pointers);
+                                  const std::vector<Pointer>& pointers, ui::LogicalDisplayId);
     void publishInputEventEntries(const std::vector<InputEventEntry>& entries);
     void consumeInputEventEntries(const std::vector<InputEventEntry>& entries,
                                   std::chrono::nanoseconds frameTime);
@@ -76,7 +78,7 @@ protected:
 
 status_t TouchResamplingTest::publishSimpleMotionEventWithCoords(
         int32_t action, nsecs_t eventTime, const std::vector<PointerProperties>& properties,
-        const std::vector<PointerCoords>& coords) {
+        const std::vector<PointerCoords>& coords, ui::LogicalDisplayId displayId) {
     const ui::Transform identityTransform;
     const nsecs_t downTime = 0;
 
@@ -84,8 +86,8 @@ status_t TouchResamplingTest::publishSimpleMotionEventWithCoords(
         ADD_FAILURE() << "Downtime should be equal to 0 (hardcoded for convenience)";
     }
     return mPublisher->publishMotionEvent(mSeq++, InputEvent::nextId(), /*deviceId=*/1,
-                                          AINPUT_SOURCE_TOUCHSCREEN, ui::LogicalDisplayId::DEFAULT,
-                                          INVALID_HMAC, action, /*actionButton=*/0, /*flags=*/0,
+                                          AINPUT_SOURCE_TOUCHSCREEN, displayId, INVALID_HMAC,
+                                          action, /*actionButton=*/0, /*flags=*/0,
                                           /*edgeFlags=*/0, AMETA_NONE, /*buttonState=*/0,
                                           MotionClassification::NONE, identityTransform,
                                           /*xPrecision=*/0, /*yPrecision=*/0,
@@ -96,7 +98,8 @@ status_t TouchResamplingTest::publishSimpleMotionEventWithCoords(
 }
 
 void TouchResamplingTest::publishSimpleMotionEvent(int32_t action, nsecs_t eventTime,
-                                                   const std::vector<Pointer>& pointers) {
+                                                   const std::vector<Pointer>& pointers,
+                                                   ui::LogicalDisplayId displayId) {
     std::vector<PointerProperties> properties;
     std::vector<PointerCoords> coords;
 
@@ -112,7 +115,8 @@ void TouchResamplingTest::publishSimpleMotionEvent(int32_t action, nsecs_t event
         coords.back().setAxisValue(AMOTION_EVENT_AXIS_Y, pointer.y);
     }
 
-    status_t result = publishSimpleMotionEventWithCoords(action, eventTime, properties, coords);
+    status_t result =
+            publishSimpleMotionEventWithCoords(action, eventTime, properties, coords, displayId);
     ASSERT_EQ(OK, result);
 }
 
@@ -122,7 +126,8 @@ void TouchResamplingTest::publishSimpleMotionEvent(int32_t action, nsecs_t event
  */
 void TouchResamplingTest::publishInputEventEntries(const std::vector<InputEventEntry>& entries) {
     for (const InputEventEntry& entry : entries) {
-        publishSimpleMotionEvent(entry.action, entry.eventTime.count(), entry.pointers);
+        publishSimpleMotionEvent(entry.action, entry.eventTime.count(), entry.pointers,
+                                 entry.displayId);
     }
 }
 
@@ -178,6 +183,7 @@ void TouchResamplingTest::consumeInputEventEntries(const std::vector<InputEventE
         ASSERT_EQ(entry.action, motionEvent->getAction());
         ASSERT_EQ(entry.eventTime.count(), motionEvent->getHistoricalEventTime(i));
         ASSERT_EQ(entry.pointers.size(), motionEvent->getPointerCount());
+        ASSERT_EQ(entry.displayId, motionEvent->getDisplayId());
 
         for (size_t p = 0; p < motionEvent->getPointerCount(); p++) {
             SCOPED_TRACE(p);
@@ -697,4 +703,45 @@ TEST_F(TouchResamplingTest, TwoPointersAreResampledIndependently) {
     consumeInputEventEntries(expectedEntries, frameTime);
 }
 
+TEST_F(TouchResamplingTest, EventsOnDifferentDisplaysAreNotResampled) {
+    std::chrono::nanoseconds frameTime;
+    std::vector<InputEventEntry> entries, expectedEntries;
+
+    // Initial ACTION_DOWN should be separate, because the first consume event will only return
+    // InputEvent with a single action.
+    entries = {
+            //      id  x   y
+            {0ms, {{0, 10, 20}}, AMOTION_EVENT_ACTION_DOWN},
+    };
+    publishInputEventEntries(entries);
+    frameTime = 5ms;
+    expectedEntries = {
+            //      id  x   y
+            {0ms, {{0, 10, 20}}, AMOTION_EVENT_ACTION_DOWN},
+    };
+    consumeInputEventEntries(expectedEntries, frameTime);
+
+    // Two ACTION_MOVE events 10 ms apart that move in X direction and stay still in Y, but on
+    // different displays.
+    entries = {
+            //      id  x   y
+            {10ms, {{0, 20, 30}}, AMOTION_EVENT_ACTION_MOVE, ui::LogicalDisplayId::DEFAULT},
+            {20ms, {{0, 30, 30}}, AMOTION_EVENT_ACTION_MOVE, ui::LogicalDisplayId(1)},
+    };
+    publishInputEventEntries(entries);
+
+    // They are not resampled and sent as two separate events.
+    frameTime = 35ms;
+    expectedEntries = {
+            //      id  x   y
+            {10ms, {{0, 20, 30}}, AMOTION_EVENT_ACTION_MOVE, ui::LogicalDisplayId::DEFAULT},
+    };
+    consumeInputEventEntries(expectedEntries, frameTime);
+    expectedEntries = {
+            //      id  x   y
+            {20ms, {{0, 30, 30}}, AMOTION_EVENT_ACTION_MOVE, ui::LogicalDisplayId(1)},
+    };
+    consumeInputEventEntries(expectedEntries, frameTime);
+}
+
 } // namespace android
diff --git a/libs/input/tests/VelocityTracker_test.cpp b/libs/input/tests/VelocityTracker_test.cpp
index f50a3cdb99..85a5a885ec 100644
--- a/libs/input/tests/VelocityTracker_test.cpp
+++ b/libs/input/tests/VelocityTracker_test.cpp
@@ -156,7 +156,7 @@ static std::vector<MotionEvent> createAxisScrollMotionEventStream(
         ui::Transform identityTransform;
         event.initialize(InputEvent::nextId(), /*deviceId=*/5, AINPUT_SOURCE_ROTARY_ENCODER,
                          ui::LogicalDisplayId::INVALID, INVALID_HMAC, AMOTION_EVENT_ACTION_SCROLL,
-                         /*actionButton=*/0, /*flags=*/0, AMOTION_EVENT_EDGE_FLAG_NONE, AMETA_NONE,
+                         /*actionButton=*/0, /*flags=*/{}, AMOTION_EVENT_EDGE_FLAG_NONE, AMETA_NONE,
                          /*buttonState=*/0, MotionClassification::NONE, identityTransform,
                          /*xPrecision=*/0, /*yPrecision=*/0, AMOTION_EVENT_INVALID_CURSOR_POSITION,
                          AMOTION_EVENT_INVALID_CURSOR_POSITION, identityTransform, /*downTime=*/0,
@@ -215,7 +215,7 @@ static std::vector<MotionEvent> createTouchMotionEventStream(
         MotionEvent event;
         ui::Transform identityTransform;
         event.initialize(InputEvent::nextId(), /*deviceId=*/0, AINPUT_SOURCE_TOUCHSCREEN,
-                         DISPLAY_ID, INVALID_HMAC, action, /*actionButton=*/0, /*flags=*/0,
+                         DISPLAY_ID, INVALID_HMAC, action, /*actionButton=*/0, /*flags=*/{},
                          AMOTION_EVENT_EDGE_FLAG_NONE, AMETA_NONE, /*buttonState=*/0,
                          MotionClassification::NONE, identityTransform, /*xPrecision=*/0,
                          /*yPrecision=*/0, AMOTION_EVENT_INVALID_CURSOR_POSITION,
@@ -507,7 +507,7 @@ TEST_F(VelocityTrackerTest, ActionCancelResultsInZeroVelocity) {
     // ACTION_UP. We need to manually change it to ACTION_CANCEL.
     MotionEvent& lastEvent = events.back();
     lastEvent.setAction(AMOTION_EVENT_ACTION_CANCEL);
-    lastEvent.setFlags(lastEvent.getFlags() | AMOTION_EVENT_FLAG_CANCELED);
+    lastEvent.setFlags(lastEvent.getFlags() | MotionFlag::CANCELED);
     const int32_t pointerId = lastEvent.getPointerId(0);
     checkVelocity(computeVelocity(VelocityTracker::Strategy::IMPULSE, events, AMOTION_EVENT_AXIS_X,
                                   pointerId),
@@ -538,7 +538,7 @@ TEST_F(VelocityTrackerTest, ActionPointerCancelResultsInZeroVelocityForThatPoint
     std::vector<MotionEvent> events = createTouchMotionEventStream(motions);
     // Cancel the lifting pointer of the ACTION_POINTER_UP event
     MotionEvent& pointerUpEvent = events.rbegin()[1];
-    pointerUpEvent.setFlags(pointerUpEvent.getFlags() | AMOTION_EVENT_FLAG_CANCELED);
+    pointerUpEvent.setFlags(pointerUpEvent.getFlags() | MotionFlag::CANCELED);
     const int32_t pointerId = pointerUpEvent.getPointerId(pointerUpEvent.getActionIndex());
     // Double check the stream
     ASSERT_EQ(1, pointerId);
diff --git a/libs/input/tests/VerifiedInputEvent_test.cpp b/libs/input/tests/VerifiedInputEvent_test.cpp
index df5fe9d2d0..65d64b3ec4 100644
--- a/libs/input/tests/VerifiedInputEvent_test.cpp
+++ b/libs/input/tests/VerifiedInputEvent_test.cpp
@@ -29,7 +29,7 @@ static KeyEvent getKeyEventWithFlags(int32_t flags) {
     return event;
 }
 
-static MotionEvent getMotionEventWithFlags(int32_t flags) {
+static MotionEvent getMotionEventWithFlags(ftl::Flags<MotionFlag> flags) {
     MotionEvent event;
     constexpr size_t pointerCount = 1;
     PointerProperties pointerProperties[pointerCount];
@@ -86,7 +86,7 @@ TEST(VerifiedKeyEventTest, VerifiedKeyEventDoesNotContainUnverifiedFlags) {
 }
 
 TEST(VerifiedMotionEventTest, ConvertMotionEventToVerifiedMotionEvent) {
-    MotionEvent event = getMotionEventWithFlags(0);
+    MotionEvent event = getMotionEventWithFlags({});
     VerifiedMotionEvent verified = verifiedMotionEventFromMotionEvent(event);
 
     ASSERT_EQ(VerifiedInputEvent::Type::MOTION, verified.type);
@@ -106,16 +106,16 @@ TEST(VerifiedMotionEventTest, ConvertMotionEventToVerifiedMotionEvent) {
 }
 
 TEST(VerifiedMotionEventTest, VerifiedMotionEventContainsOnlyVerifiedFlags) {
-    MotionEvent event = getMotionEventWithFlags(AMOTION_EVENT_FLAG_WINDOW_IS_OBSCURED |
-                                                AMOTION_EVENT_FLAG_IS_GENERATED_GESTURE);
+    MotionEvent event = getMotionEventWithFlags(
+            {MotionFlag::WINDOW_IS_OBSCURED, MotionFlag::IS_GENERATED_GESTURE});
     VerifiedMotionEvent verified = verifiedMotionEventFromMotionEvent(event);
-    ASSERT_EQ(AMOTION_EVENT_FLAG_WINDOW_IS_OBSCURED, verified.flags);
+    ASSERT_EQ(ftl::Flags<MotionFlag>(MotionFlag::WINDOW_IS_OBSCURED), verified.flags);
 }
 
 TEST(VerifiedMotionEventTest, VerifiedMotionEventDoesNotContainUnverifiedFlags) {
-    MotionEvent event = getMotionEventWithFlags(AMOTION_EVENT_FLAG_TAINTED);
+    MotionEvent event = getMotionEventWithFlags(MotionFlag::TAINTED);
     VerifiedMotionEvent verified = verifiedMotionEventFromMotionEvent(event);
-    ASSERT_EQ(0, verified.flags);
+    ASSERT_EQ(ftl::Flags<MotionFlag>{}, verified.flags);
 }
 
 } // namespace android
diff --git a/libs/math/OWNERS b/libs/math/OWNERS
index 08f0c5f0dc..eea4527f81 100644
--- a/libs/math/OWNERS
+++ b/libs/math/OWNERS
@@ -1,4 +1,3 @@
 mathias@google.com
-romainguy@google.com
 sumir@google.com
 jreck@google.com
diff --git a/libs/math/include/math/half.h b/libs/math/include/math/half.h
index 5ec9bf7b40..87a8a413a0 100644
--- a/libs/math/include/math/half.h
+++ b/libs/math/include/math/half.h
@@ -18,18 +18,17 @@
 
 #include <stdint.h>
 #include <functional>
-#include <iosfwd>
 #include <limits>
 #include <type_traits>
 
 #ifndef LIKELY
 #define LIKELY_DEFINED_LOCAL
 #ifdef __cplusplus
-#   define LIKELY( exp )    (__builtin_expect( !!(exp), true ))
-#   define UNLIKELY( exp )  (__builtin_expect( !!(exp), false ))
+#define LIKELY(exp) (__builtin_expect(!!(exp), true))
+#define UNLIKELY(exp) (__builtin_expect(!!(exp), false))
 #else
-#   define LIKELY( exp )    (__builtin_expect( !!(exp), 1 ))
-#   define UNLIKELY( exp )  (__builtin_expect( !!(exp), 0 ))
+#define LIKELY(exp) (__builtin_expect(!!(exp), 1))
+#define UNLIKELY(exp) (__builtin_expect(!!(exp), 0))
 #endif
 #endif
 
@@ -58,45 +57,45 @@ namespace android {
 class half {
     struct fp16 {
         uint16_t bits;
-        explicit constexpr fp16() noexcept : bits(0) { }
-        explicit constexpr fp16(uint16_t b) noexcept : bits(b) { }
-        void setS(unsigned int s) noexcept { bits = uint16_t((bits & 0x7FFF) | (s<<15)); }
-        void setE(unsigned int s) noexcept { bits = uint16_t((bits & 0xE3FF) | (s<<10)); }
-        void setM(unsigned int s) noexcept { bits = uint16_t((bits & 0xFC00) | (s<< 0)); }
-        constexpr unsigned int getS() const noexcept { return  bits >> 15u; }
-        constexpr unsigned int getE() const noexcept { return (bits >> 10u) & 0x1Fu; }
-        constexpr unsigned int getM() const noexcept { return  bits         & 0x3FFu; }
+        explicit constexpr fp16() noexcept : bits(0) {}
+        explicit constexpr fp16(uint16_t b) noexcept : bits(b) {}
+        void setS(uint32_t s) noexcept { bits = uint16_t((bits & 0x7FFF) | (s << 15)); }
+        void setE(uint32_t s) noexcept { bits = uint16_t((bits & 0x83FF) | (s << 10)); }
+        void setM(uint32_t s) noexcept { bits = uint16_t((bits & 0xFC00) | (s << 0)); }
+        constexpr uint32_t getS() const noexcept { return bits >> 15u; }
+        constexpr uint32_t getE() const noexcept { return (bits >> 10u) & 0x1Fu; }
+        constexpr uint32_t getM() const noexcept { return bits & 0x3FFu; }
     };
     struct fp32 {
         union {
             uint32_t bits;
             float fp;
         };
-        explicit constexpr fp32() noexcept : bits(0) { }
-        explicit constexpr fp32(float f) noexcept : fp(f) { }
-        void setS(unsigned int s) noexcept { bits = uint32_t((bits & 0x7FFFFFFF) | (s<<31)); }
-        void setE(unsigned int s) noexcept { bits = uint32_t((bits & 0x807FFFFF) | (s<<23)); }
-        void setM(unsigned int s) noexcept { bits = uint32_t((bits & 0xFF800000) | (s<< 0)); }
-        constexpr unsigned int getS() const noexcept { return  bits >> 31u; }
-        constexpr unsigned int getE() const noexcept { return (bits >> 23u) & 0xFFu; }
-        constexpr unsigned int getM() const noexcept { return  bits         & 0x7FFFFFu; }
+        explicit constexpr fp32() noexcept : bits(0) {}
+        explicit constexpr fp32(float f) noexcept : fp(f) {}
+        void setS(uint32_t s) noexcept { bits = uint32_t((bits & 0x7FFFFFFF) | (s << 31)); }
+        void setE(uint32_t s) noexcept { bits = uint32_t((bits & 0x807FFFFF) | (s << 23)); }
+        void setM(uint32_t s) noexcept { bits = uint32_t((bits & 0xFF800000) | (s << 0)); }
+        constexpr uint32_t getS() const noexcept { return bits >> 31u; }
+        constexpr uint32_t getE() const noexcept { return (bits >> 23u) & 0xFFu; }
+        constexpr uint32_t getM() const noexcept { return bits & 0x7FFFFFu; }
     };
 
 public:
-    CONSTEXPR half() noexcept { }
-    CONSTEXPR half(float v) noexcept : mBits(ftoh(v)) { }
+    CONSTEXPR half() noexcept {}
+    CONSTEXPR half(float v) noexcept : mBits(ftoh(v)) {}
     CONSTEXPR operator float() const noexcept { return htof(mBits); }
 
     uint16_t getBits() const noexcept { return mBits.bits; }
-    unsigned int getExponent() const noexcept { return mBits.getE(); }
-    unsigned int getMantissa() const noexcept { return mBits.getM(); }
+    uint32_t getExponent() const noexcept { return mBits.getE(); }
+    uint32_t getMantissa() const noexcept { return mBits.getM(); }
 
 private:
     friend class std::numeric_limits<half>;
-    friend CONSTEXPR half operator"" _hf(long double v);
+    friend CONSTEXPR half operator""_hf(long double v);
 
     enum Binary { binary };
-    explicit constexpr half(Binary, uint16_t bits) noexcept : mBits(bits) { }
+    explicit constexpr half(Binary, uint16_t bits) noexcept : mBits(bits) {}
     static CONSTEXPR fp16 ftoh(float v) noexcept;
     static CONSTEXPR float htof(fp16 v) noexcept;
     fp16 mBits;
@@ -109,21 +108,20 @@ inline CONSTEXPR half::fp16 half::ftoh(float v) noexcept {
         out.setE(0x1F);
         out.setM(in.getM() ? 0x200 : 0);
     } else {
-        int e = static_cast<int>(in.getE()) - 127 + 15;
-        if (e >= 0x1F) {
+        uint32_t e = in.getE();
+        uint32_t m = in.getM() + 0x1000; // Rounding to the nearest even.
+        if (e > 143) {
             // overflow
-            out.setE(0x31); // +/- inf
-        } else if (e <= 0) {
-            // underflow
-            // flush to +/- 0
-        } else {
-            unsigned int m = in.getM();
-            out.setE(uint16_t(e));
+            out.setE(0x1F);
+        } else if (e > 112) {
+            // normalized
+            out.setE(e - 112);
             out.setM(m >> 13);
-            if (m & 0x1000) {
-                // rounding
-                out.bits++;
-            }
+        } else if (e > 101) {
+            // denormalized
+            out = fp16(static_cast<uint16_t>((((0x007FF000 + m) >> (125 - e)) + 1) >> 1));
+        } else {
+            // underflow
         }
     }
     out.setS(in.getS());
@@ -138,12 +136,19 @@ inline CONSTEXPR float half::htof(half::fp16 in) noexcept {
     } else {
         if (in.getE() == 0) {
             if (in.getM()) {
-                // TODO: denormal half float, treat as zero for now
-                // (it's stupid because they can be represented as regular float)
+                uint32_t m = in.getM();
+                uint32_t e = 127 - 14;
+                m <<= 13;
+                while (m < 0x800000) {
+                    m <<= 1;
+                    e--;
+                }
+                out.setE(e);
+                out.setM(m & 0x7FFFFF);
             }
         } else {
             int e = static_cast<int>(in.getE()) - 15 + 127;
-            unsigned int m = in.getM();
+            uint32_t m = in.getM();
             out.setE(uint32_t(e));
             out.setM(m << 13);
         }
@@ -152,7 +157,7 @@ inline CONSTEXPR float half::htof(half::fp16 in) noexcept {
     return out.fp;
 }
 
-inline CONSTEXPR android::half operator"" _hf(long double v) {
+inline CONSTEXPR android::half operator""_hf(long double v) {
     return android::half(android::half::binary, android::half::ftoh(static_cast<float>(v)).bits);
 }
 
@@ -160,9 +165,10 @@ inline CONSTEXPR android::half operator"" _hf(long double v) {
 
 namespace std {
 
-template<> struct is_floating_point<android::half> : public std::true_type {};
+template <>
+struct is_floating_point<android::half> : public std::true_type {};
 
-template<>
+template <>
 class numeric_limits<android::half> {
 public:
     typedef android::half type;
@@ -192,21 +198,38 @@ public:
     static constexpr const int max_exponent = 16;
     static constexpr const int max_exponent10 = 4;
 
-    inline static constexpr type round_error() noexcept { return android::half(android::half::binary, 0x3800); }
-    inline static constexpr type min() noexcept { return android::half(android::half::binary, 0x0400); }
-    inline static constexpr type max() noexcept { return android::half(android::half::binary, 0x7bff); }
-    inline static constexpr type lowest() noexcept { return android::half(android::half::binary, 0xfbff); }
-    inline static constexpr type epsilon() noexcept { return android::half(android::half::binary, 0x1400); }
-    inline static constexpr type infinity() noexcept { return android::half(android::half::binary, 0x7c00); }
-    inline static constexpr type quiet_NaN() noexcept { return android::half(android::half::binary, 0x7fff); }
-    inline static constexpr type denorm_min() noexcept { return android::half(android::half::binary, 0x0001); }
-    inline static constexpr type signaling_NaN() noexcept { return android::half(android::half::binary, 0x7dff); }
+    inline static constexpr type round_error() noexcept {
+        return android::half(android::half::binary, 0x3800);
+    }
+    inline static constexpr type min() noexcept {
+        return android::half(android::half::binary, 0x0400);
+    }
+    inline static constexpr type max() noexcept {
+        return android::half(android::half::binary, 0x7bff);
+    }
+    inline static constexpr type lowest() noexcept {
+        return android::half(android::half::binary, 0xfbff);
+    }
+    inline static constexpr type epsilon() noexcept {
+        return android::half(android::half::binary, 0x1400);
+    }
+    inline static constexpr type infinity() noexcept {
+        return android::half(android::half::binary, 0x7c00);
+    }
+    inline static constexpr type quiet_NaN() noexcept {
+        return android::half(android::half::binary, 0x7fff);
+    }
+    inline static constexpr type denorm_min() noexcept {
+        return android::half(android::half::binary, 0x0001);
+    }
+    inline static constexpr type signaling_NaN() noexcept {
+        return android::half(android::half::binary, 0x7dff);
+    }
 };
 
-template<> struct hash<android::half> {
-    size_t operator()(const android::half& half) {
-        return std::hash<float>{}(half);
-    }
+template <>
+struct hash<android::half> {
+    size_t operator()(const android::half& half) { return std::hash<float>{}(half); }
 };
 
 } // namespace std
diff --git a/libs/math/tests/half_test.cpp b/libs/math/tests/half_test.cpp
index a514d986e4..bfff771a34 100644
--- a/libs/math/tests/half_test.cpp
+++ b/libs/math/tests/half_test.cpp
@@ -26,53 +26,63 @@
 
 namespace android {
 
-class HalfTest : public testing::Test {
-protected:
-};
+TEST(HalfTest, TestHalfSize) {
+    EXPECT_EQ(2UL, sizeof(half));
+}
 
-TEST_F(HalfTest, Basics) {
+TEST(HalfTest, TestZero) {
+    EXPECT_EQ(half().getBits(), 0x0000);
+    EXPECT_EQ(half(0.0f).getBits(), 0x0000);
+    EXPECT_EQ(half(-0.0f).getBits(), 0x8000);
+}
 
-    EXPECT_EQ(2UL, sizeof(half));
+TEST(HalfTest, TestNaN) {
+    EXPECT_EQ(half(NAN).getBits(), 0x7e00);
+    EXPECT_EQ(std::numeric_limits<half>::quiet_NaN().getBits(), 0x7FFF);
+    EXPECT_EQ(std::numeric_limits<half>::signaling_NaN().getBits(), 0x7DFF);
+}
+
+TEST(HalfTest, TestInfinity) {
+    EXPECT_EQ(std::numeric_limits<half>::infinity().getBits(), 0x7C00);
+}
 
-    // test +/- zero
-    EXPECT_EQ(0x0000, half().getBits());
-    EXPECT_EQ(0x0000, half( 0.0f).getBits());
-    EXPECT_EQ(0x8000, half(-0.0f).getBits());
+TEST(HalfTest, TestNumericLimits) {
+    EXPECT_EQ(std::numeric_limits<half>::min().getBits(), 0x0400);
+    EXPECT_EQ(std::numeric_limits<half>::max().getBits(), 0x7BFF);
+    EXPECT_EQ(std::numeric_limits<half>::lowest().getBits(), 0xFBFF);
+}
 
-    // test nan
-    EXPECT_EQ(0x7e00, half(NAN).getBits());
+TEST(HalfTest, TestEpsilon) {
+    EXPECT_EQ(std::numeric_limits<half>::epsilon().getBits(), 0x1400);
+}
 
-    // test +/- infinity
-    EXPECT_EQ(0x7C00, half( std::numeric_limits<float>::infinity()).getBits());
-    EXPECT_EQ(0xFC00, half(-std::numeric_limits<float>::infinity()).getBits());
+TEST(HalfTest, TestDenormals) {
+    EXPECT_EQ(half(std::numeric_limits<half>::denorm_min()).getBits(), 0x0001);
+    EXPECT_EQ(half(std::numeric_limits<half>::denorm_min() * 2).getBits(), 0x0002);
+    EXPECT_EQ(half(std::numeric_limits<half>::denorm_min() * 3).getBits(), 0x0003);
+    // test a few known denormals
+    EXPECT_EQ(half(6.09756e-5).getBits(), 0x03FF);
+    EXPECT_EQ(half(5.96046e-8).getBits(), 0x0001);
+    EXPECT_EQ(half(-6.09756e-5).getBits(), 0x83FF);
+    EXPECT_EQ(half(-5.96046e-8).getBits(), 0x8001);
+}
 
+TEST(HalfTest, TestNormal) {
     // test a few known values
-    EXPECT_EQ(0x3C01, half(1.0009765625).getBits());
-    EXPECT_EQ(0xC000, half(-2).getBits());
-    EXPECT_EQ(0x0400, half(6.10352e-5).getBits());
-    EXPECT_EQ(0x7BFF, half(65504).getBits());
-    EXPECT_EQ(0x3555, half(1.0f/3).getBits());
-
-    // numeric limits
-    EXPECT_EQ(0x7C00, std::numeric_limits<half>::infinity().getBits());
-    EXPECT_EQ(0x0400, std::numeric_limits<half>::min().getBits());
-    EXPECT_EQ(0x7BFF, std::numeric_limits<half>::max().getBits());
-    EXPECT_EQ(0xFBFF, std::numeric_limits<half>::lowest().getBits());
-
-    // denormals (flushed to zero)
-    EXPECT_EQ(0x0000, half( 6.09756e-5).getBits());      // if handled, should be: 0x03FF
-    EXPECT_EQ(0x0000, half( 5.96046e-8).getBits());      // if handled, should be: 0x0001
-    EXPECT_EQ(0x8000, half(-6.09756e-5).getBits());      // if handled, should be: 0x83FF
-    EXPECT_EQ(0x8000, half(-5.96046e-8).getBits());      // if handled, should be: 0x8001
+    EXPECT_EQ(half(1.0009765625).getBits(), 0x3C01);
+    EXPECT_EQ(half(-2).getBits(), 0xC000);
+    EXPECT_EQ(half(6.10352e-5).getBits(), 0x0400);
+    EXPECT_EQ(half(65504).getBits(), 0x7BFF);
+    EXPECT_EQ(half(1.0f / 3).getBits(), 0x3555);
 
     // test all exactly representable integers
-    for (int i=-2048 ; i<= 2048 ; ++i) {
+    for (int i = -2048; i <= 2048; ++i) {
         half h = i;
-        EXPECT_EQ(i, float(h));
+        EXPECT_EQ(float(h), i);
     }
 }
 
-TEST_F(HalfTest, Literals) {
+TEST(HalfTest, TestLiterals) {
     half one = 1.0_hf;
     half pi = 3.1415926_hf;
     half minusTwo = -2.0_hf;
@@ -82,9 +92,8 @@ TEST_F(HalfTest, Literals) {
     EXPECT_EQ(half(-2.0f), minusTwo);
 }
 
-
-TEST_F(HalfTest, Vec) {
-    float4 f4(1,2,3,4);
+TEST(HalfTest, TestVec) {
+    float4 f4(1, 2, 3, 4);
     half4 h4(f4);
     half3 h3(f4.xyz);
     half2 h2(f4.xy);
@@ -94,13 +103,17 @@ TEST_F(HalfTest, Vec) {
     EXPECT_EQ(f4.xy, h2);
 }
 
-
-TEST_F(HalfTest, Hash) {
-    float4 f4a(1,2,3,4);
-    float4 f4b(2,2,3,4);
+TEST(HalfTest, TestHash) {
+    float4 f4a(1, 2, 3, 4);
+    float4 f4b(2, 2, 3, 4);
     half4 h4a(f4a), h4b(f4b);
 
     EXPECT_NE(std::hash<half4>{}(h4a), std::hash<half4>{}(h4b));
 }
 
+TEST(HalfTest, TestHalfToFloat) {
+    EXPECT_EQ(4.25f, float(4.25_hf));
+    EXPECT_EQ(3.05175781e-05f, float(3.05175781e-05_hf));
+}
+
 }; // namespace android
diff --git a/libs/nativedisplay/OWNERS b/libs/nativedisplay/OWNERS
new file mode 100644
index 0000000000..0c7b05435d
--- /dev/null
+++ b/libs/nativedisplay/OWNERS
@@ -0,0 +1,3 @@
+# Bug component: 1075130
+
+include /services/surfaceflinger/OWNERS
\ No newline at end of file
diff --git a/libs/nativedisplay/include/surfacetexture/SurfaceTexture.h b/libs/nativedisplay/include/surfacetexture/SurfaceTexture.h
index 253aa18a24..9969d830c1 100644
--- a/libs/nativedisplay/include/surfacetexture/SurfaceTexture.h
+++ b/libs/nativedisplay/include/surfacetexture/SurfaceTexture.h
@@ -98,7 +98,6 @@ public:
      * is created in a detached state, and attachToContext must be called before
      * calls to updateTexImage.
      */
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
     SurfaceTexture(uint32_t tex, uint32_t textureTarget, bool useFenceSync, bool isControlledByApp);
 
     SurfaceTexture(uint32_t textureTarget, bool useFenceSync, bool isControlledByApp);
@@ -110,13 +109,6 @@ public:
     SurfaceTexture(const sp<IGraphicBufferConsumer>& bq, uint32_t textureTarget, bool useFenceSync,
                    bool isControlledByApp)
             __attribute((deprecated("Prefer ctors that create their own surface and consumer.")));
-#else
-    SurfaceTexture(const sp<IGraphicBufferConsumer>& bq, uint32_t tex, uint32_t textureTarget,
-                   bool useFenceSync, bool isControlledByApp);
-
-    SurfaceTexture(const sp<IGraphicBufferConsumer>& bq, uint32_t textureTarget, bool useFenceSync,
-                   bool isControlledByApp);
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
 
     /**
      * updateTexImage acquires the most recently queued buffer, and sets the
@@ -371,10 +363,8 @@ protected:
     /**
      * onSetFrameRate Notifies the consumer of a setFrameRate call from the producer side.
      */
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(BQ_SETFRAMERATE)
     void onSetFrameRate(float frameRate, int8_t compatibility,
                         int8_t changeFrameRateStrategy) override;
-#endif
 
     /**
      * The default consumer usage flags that SurfaceTexture always sets on its
diff --git a/libs/nativedisplay/surfacetexture/SurfaceTexture.cpp b/libs/nativedisplay/surfacetexture/SurfaceTexture.cpp
index c0a1cc5c36..3a374e9990 100644
--- a/libs/nativedisplay/surfacetexture/SurfaceTexture.cpp
+++ b/libs/nativedisplay/surfacetexture/SurfaceTexture.cpp
@@ -35,7 +35,6 @@ namespace android {
 
 static const mat4 mtxIdentity;
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
 SurfaceTexture::SurfaceTexture(uint32_t tex, uint32_t texTarget, bool useFenceSync,
                                bool isControlledByApp)
       : ConsumerBase(isControlledByApp),
@@ -76,7 +75,6 @@ SurfaceTexture::SurfaceTexture(uint32_t texTarget, bool useFenceSync, bool isCon
         mOpMode(OpMode::detached) {
     initialize();
 }
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
 
 SurfaceTexture::SurfaceTexture(const sp<IGraphicBufferConsumer>& bq, uint32_t tex,
                                uint32_t texTarget, bool useFenceSync, bool isControlledByApp)
@@ -558,7 +556,6 @@ void SurfaceTexture::FrameAvailableListenerProxy::onFrameAvailable(const BufferI
     }
 }
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(BQ_SETFRAMERATE)
 void SurfaceTexture::onSetFrameRate(float frameRate, int8_t compatibility,
                                     int8_t changeFrameRateStrategy) {
     SFT_LOGV("onSetFrameRate: %.2f", frameRate);
@@ -572,7 +569,6 @@ void SurfaceTexture::onSetFrameRate(float frameRate, int8_t compatibility,
         listener->onSetFrameRate(frameRate, compatibility, changeFrameRateStrategy);
     }
 }
-#endif
 
 void SurfaceTexture::initialize() {
     SFT_LOGV("SurfaceTexture");
diff --git a/libs/nativewindow/AHardwareBuffer.cpp b/libs/nativewindow/AHardwareBuffer.cpp
index 3205c32f01..eec2d4169b 100644
--- a/libs/nativewindow/AHardwareBuffer.cpp
+++ b/libs/nativewindow/AHardwareBuffer.cpp
@@ -116,6 +116,32 @@ static_assert(
         static_cast<int>(aidl::android::hardware::graphics::common::PixelFormat::YCBCR_P210) ==
                 AHARDWAREBUFFER_FORMAT_YCbCr_P210,
         "HAL and AHardwareBuffer pixel format don't match");
+static_assert(static_cast<int>(aidl::android::hardware::graphics::common::PixelFormat::R_12_UINT) ==
+                      AHARDWAREBUFFER_FORMAT_R12_UINT,
+              "HAL and AHardwareBuffer pixel format don't match");
+static_assert(static_cast<int>(aidl::android::hardware::graphics::common::PixelFormat::R_14_UINT) ==
+                      AHARDWAREBUFFER_FORMAT_R14_UINT,
+              "HAL and AHardwareBuffer pixel format don't match");
+static_assert(
+        static_cast<int>(aidl::android::hardware::graphics::common::PixelFormat::RG_1212_UINT) ==
+                AHARDWAREBUFFER_FORMAT_R12G12_UINT,
+        "HAL and AHardwareBuffer pixel format don't match");
+static_assert(
+        static_cast<int>(aidl::android::hardware::graphics::common::PixelFormat::RG_1414_UINT) ==
+                AHARDWAREBUFFER_FORMAT_R14G14_UINT,
+        "HAL and AHardwareBuffer pixel format don't match");
+static_assert(static_cast<int>(
+                      aidl::android::hardware::graphics::common::PixelFormat::RGBA_12121212_UINT) ==
+                      AHARDWAREBUFFER_FORMAT_R12G12B12A12_UINT,
+              "HAL and AHardwareBuffer pixel format don't match");
+static_assert(static_cast<int>(
+                      aidl::android::hardware::graphics::common::PixelFormat::RGBA_14141414_UINT) ==
+                      AHARDWAREBUFFER_FORMAT_R14G14B14A14_UINT,
+              "HAL and AHardwareBuffer pixel format don't match");
+static_assert(
+        static_cast<int>(aidl::android::hardware::graphics::common::PixelFormat::BGRA_1010102) ==
+                AHARDWAREBUFFER_FORMAT_B10G10R10A2_UNORM,
+        "HAL and AHardwareBuffer pixel format don't match");
 
 static enum AHardwareBufferStatus filterStatus(status_t status) {
     switch (status) {
diff --git a/libs/nativewindow/OWNERS b/libs/nativewindow/OWNERS
new file mode 100644
index 0000000000..0c7b05435d
--- /dev/null
+++ b/libs/nativewindow/OWNERS
@@ -0,0 +1,3 @@
+# Bug component: 1075130
+
+include /services/surfaceflinger/OWNERS
\ No newline at end of file
diff --git a/libs/nativewindow/include/android/hardware_buffer.h b/libs/nativewindow/include/android/hardware_buffer.h
index 5a78a5c82c..f1679ba03f 100644
--- a/libs/nativewindow/include/android/hardware_buffer.h
+++ b/libs/nativewindow/include/android/hardware_buffer.h
@@ -209,6 +209,56 @@ enum AHardwareBuffer_Format {
      *   OpenGL ES: N/A
      */
     AHARDWAREBUFFER_FORMAT_R10G10B10A10_UNORM       = 0x3b,
+
+    /**
+     * Corresponding formats:
+     *   Vulkan: VK_FORMAT_R12X4_UINT
+     *   OpenGL ES: N/A
+     */
+    AHARDWAREBUFFER_FORMAT_R12_UINT       	    = 0x3d,
+
+    /**
+     * Corresponding formats:
+     *   Vulkan: VK_FORMAT_R14X2_UINT
+     *   OpenGL ES: N/A
+     */
+    AHARDWAREBUFFER_FORMAT_R14_UINT               = 0x3e,
+
+    /**
+     * Corresponding formats:
+     *   Vulkan: VK_FORMAT_R12X4G12X4_UINT
+     *   OpenGL ES: N/A
+     */
+    AHARDWAREBUFFER_FORMAT_R12G12_UINT          = 0x3f,
+
+    /**
+     * Corresponding formats:
+     *   Vulkan: VK_FORMAT_R14X2G14X2_UINT
+     *   OpenGL ES: N/A
+     */
+    AHARDWAREBUFFER_FORMAT_R14G14_UINT          = 0x40,
+
+    /**
+     * Corresponding formats:
+     *   Vulkan: VK_FORMAT_R12X4G12X4B12X4A12X4_UINT
+     *   OpenGL ES: N/A
+     */
+    AHARDWAREBUFFER_FORMAT_R12G12B12A12_UINT= 0x41,
+
+    /**
+     * Corresponding formats:
+     *   Vulkan: VK_FORMAT_R14X2G14X2B14X2A14X2_UINT
+     *   OpenGL ES: N/A
+     */
+    AHARDWAREBUFFER_FORMAT_R14G14B14A14_UINT= 0x42,
+
+    /**
+     * Corresponding formats:
+     *   Vulkan: VK_FORMAT_A2A10G10B10_UNORM_PACK32
+     *   OpenGL ES: N/A
+     */
+    AHARDWAREBUFFER_FORMAT_B10G10R10A2_UNORM        = 0x43,
+
 };
 
 /**
diff --git a/libs/nativewindow/tests/ANativeWindowTest.cpp b/libs/nativewindow/tests/ANativeWindowTest.cpp
index 51d0c8195a..ddcab00c57 100644
--- a/libs/nativewindow/tests/ANativeWindowTest.cpp
+++ b/libs/nativewindow/tests/ANativeWindowTest.cpp
@@ -65,10 +65,6 @@ protected:
         EXPECT_EQ(0, success);
     }
 
-#if !COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
-    sp<IGraphicBufferProducer> mProducer;
-    sp<IGraphicBufferConsumer> mConsumer;
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
     sp<BufferItemConsumer> mItemConsumer;
     sp<TestableSurface> mWindow;
 };
diff --git a/cmds/lshal/libprocpartition/Android.bp b/libs/procpartition/Android.bp
similarity index 100%
rename from cmds/lshal/libprocpartition/Android.bp
rename to libs/procpartition/Android.bp
diff --git a/libs/procpartition/OWNERS b/libs/procpartition/OWNERS
new file mode 100644
index 0000000000..ca3f8afc8b
--- /dev/null
+++ b/libs/procpartition/OWNERS
@@ -0,0 +1,3 @@
+elsk@google.com
+smoreland@google.com
+khei@google.com
diff --git a/cmds/lshal/libprocpartition/include/procpartition/procpartition.h b/libs/procpartition/include/procpartition/procpartition.h
similarity index 100%
rename from cmds/lshal/libprocpartition/include/procpartition/procpartition.h
rename to libs/procpartition/include/procpartition/procpartition.h
diff --git a/cmds/lshal/libprocpartition/procpartition.cpp b/libs/procpartition/procpartition.cpp
similarity index 100%
rename from cmds/lshal/libprocpartition/procpartition.cpp
rename to libs/procpartition/procpartition.cpp
diff --git a/libs/renderengine/Android.bp b/libs/renderengine/Android.bp
index 39182aa389..4f96980fa2 100644
--- a/libs/renderengine/Android.bp
+++ b/libs/renderengine/Android.bp
@@ -97,20 +97,21 @@ filegroup {
         "skia/compat/GaneshGpuContext.cpp",
         "skia/compat/GraphiteBackendTexture.cpp",
         "skia/compat/GraphiteGpuContext.cpp",
+        "skia/compat/GraphitePipelineManager.cpp",
         "skia/debug/CaptureTimer.cpp",
         "skia/debug/CommonPool.cpp",
         "skia/debug/SkiaCapture.cpp",
         "skia/debug/SkiaMemoryReporter.cpp",
         "skia/filters/BlurFilter.cpp",
+        "skia/filters/EdgeExtensionShaderFactory.cpp",
         "skia/filters/GainmapFactory.cpp",
         "skia/filters/GaussianBlurFilter.cpp",
         "skia/filters/KawaseBlurDualFilter.cpp",
         "skia/filters/KawaseBlurFilter.cpp",
-        "skia/filters/LinearEffect.cpp",
         "skia/filters/LutShader.cpp",
         "skia/filters/MouriMap.cpp",
+        "skia/filters/RuntimeEffectManager.cpp",
         "skia/filters/StretchShaderFactory.cpp",
-        "skia/filters/EdgeExtensionShaderFactory.cpp",
     ],
 }
 
diff --git a/libs/renderengine/OWNERS b/libs/renderengine/OWNERS
index e296283f26..45a0d59760 100644
--- a/libs/renderengine/OWNERS
+++ b/libs/renderengine/OWNERS
@@ -1,9 +1,7 @@
 # Bug component: 1075131
 
-adyabr@google.com
-alecmouri@google.com
+include /services/surfaceflinger/OWNERS
+
+# Skia
 djsollen@google.com
-jreck@google.com
-lpy@google.com
 nscobie@google.com
-sallyqi@google.com
diff --git a/libs/renderengine/include/renderengine/LayerSettings.h b/libs/renderengine/include/renderengine/LayerSettings.h
index 3523497519..46d73888fd 100644
--- a/libs/renderengine/include/renderengine/LayerSettings.h
+++ b/libs/renderengine/include/renderengine/LayerSettings.h
@@ -17,6 +17,7 @@
 #pragma once
 
 #include <android/gui/BorderSettings.h>
+#include <android/gui/BoxShadowSettings.h>
 #include <gui/DisplayLuts.h>
 #include <math/mat4.h>
 #include <math/vec3.h>
@@ -92,6 +93,10 @@ struct Geometry {
 
     // Rectangle within which corners will be rounded.
     FloatRect roundedCornersCrop = FloatRect();
+
+    // Crop geometry in local space, used for cropping outset rendering, e.g. shadows.
+    vec2 otherRoundedCornersRadius = vec2(0.0f, 0.0f);
+    FloatRect otherCrop = FloatRect();
 };
 
 // Descriptor of the source pixels for this layer.
@@ -134,7 +139,10 @@ struct LayerSettings {
 
     gui::BorderSettings borderSettings;
 
+    gui::BoxShadowSettings boxShadowSettings;
+
     int backgroundBlurRadius = 0;
+    float backgroundBlurScale = 1.0f;
 
     std::vector<BlurRegion> blurRegions;
 
@@ -194,6 +202,7 @@ static inline bool operator==(const LayerSettings& lhs, const LayerSettings& rhs
             lhs.disableBlending == rhs.disableBlending &&
             lhs.skipContentDraw == rhs.skipContentDraw && lhs.shadow == rhs.shadow &&
             lhs.backgroundBlurRadius == rhs.backgroundBlurRadius &&
+            lhs.backgroundBlurScale == rhs.backgroundBlurScale &&
             lhs.blurRegionTransform == rhs.blurRegionTransform &&
             lhs.stretchEffect == rhs.stretchEffect &&
             lhs.edgeExtensionEffect == rhs.edgeExtensionEffect &&
@@ -225,6 +234,12 @@ static inline void PrintTo(const Geometry& settings, ::std::ostream* os) {
     *os << "\n    .roundedCornersRadiusY = " << settings.roundedCornersRadius.y;
     *os << "\n    .roundedCornersCrop = ";
     PrintTo(settings.roundedCornersCrop, os);
+
+    *os << "\n    .otherRoundedCornersRadiusX = " << settings.otherRoundedCornersRadius.x;
+    *os << "\n    .otherRoundedCornersRadiusY = " << settings.otherRoundedCornersRadius.y;
+    *os << "\n    .otherCrop = ";
+    PrintTo(settings.otherCrop, os);
+
     *os << "\n}";
 }
 
@@ -290,6 +305,7 @@ static inline void PrintTo(const LayerSettings& settings, ::std::ostream* os) {
         PrintTo(settings.shadow, os);
     }
     *os << "\n    .backgroundBlurRadius = " << settings.backgroundBlurRadius;
+    *os << "\n    .backgroundBlurScale = " << settings.backgroundBlurScale;
     if (settings.blurRegions.size()) {
         *os << "\n    .blurRegions =";
         for (auto blurRegion : settings.blurRegions) {
diff --git a/libs/renderengine/skia/Cache.cpp b/libs/renderengine/skia/Cache.cpp
index f43694e228..493b7e073e 100644
--- a/libs/renderengine/skia/Cache.cpp
+++ b/libs/renderengine/skia/Cache.cpp
@@ -651,6 +651,102 @@ static void drawEdgeExtensionLayers(SkiaRenderEngine* renderengine, const Displa
     }
 }
 
+static void drawExtendedHDRFilteredImageLayers(SkiaRenderEngine* renderengine, const DisplaySettings& display,
+                                               const std::shared_ptr<ExternalTexture>& dstTexture,
+                                               const std::shared_ptr<ExternalTexture>& srcTexture) {
+    const Rect& displayRect = display.physicalDisplay;
+    FloatRect rect(0, 0, displayRect.width(), displayRect.height());
+    LayerSettings layer{
+            .geometry =
+                    Geometry{
+                            .boundaries = rect,
+                            // The position transform doesn't matter when the reduced shader mode
+                            // in in effect. A matrix transform stage is always included.
+                            .positionTransform = mat4(),
+                            .roundedCornersRadius = {50.f, 50.f},
+                            .roundedCornersCrop = rect,
+                    },
+            .source = PixelSource{.buffer = Buffer{.buffer = srcTexture,
+                                                   .useTextureFiltering = true,
+                                                   .usePremultipliedAlpha = true,
+                                                   .isOpaque = true,
+                                                   .maxLuminanceNits = 0.f}},
+            .sourceDataspace = kExtendedHdrDataSpce,
+    };
+
+    for (auto roundedCornerRadius : {0.f, 50.f}) {
+        layer.geometry.roundedCornersRadius = {roundedCornerRadius, roundedCornerRadius};
+        for (auto alpha : {0.5f, 1.f}) {
+            layer.alpha = alpha;
+            std::vector<LayerSettings> layers;
+
+            for (auto layerWhitePoint : kLayerWhitePoints) {
+                layer.whitePointNits = layerWhitePoint;
+                layers.push_back(layer);
+            }
+            renderengine->drawLayers(display, layers, dstTexture, base::unique_fd());
+        }
+    }
+}
+
+static void drawExtendedHDRFilteredImageShadowLayers(SkiaRenderEngine* renderengine,
+                                                     const DisplaySettings& display,
+                                                     const std::shared_ptr<ExternalTexture>& dstTexture,
+                                                     const std::shared_ptr<ExternalTexture>& srcTexture) {
+    const Rect& displayRect = display.physicalDisplay;
+    FloatRect rect(0, 0, displayRect.width(), displayRect.height());
+    FloatRect smallerRect(20, 20, displayRect.width()-20, displayRect.height()-20);
+
+    LayerSettings layer{
+            .geometry =
+                    Geometry{
+                            .boundaries = rect,
+                            // The position transform doesn't matter when the reduced shader mode
+                            // in in effect. A matrix transform stage is always included.
+                            .positionTransform = mat4(),
+                            .roundedCornersRadius = {50.f, 50.f},
+                            .roundedCornersCrop = rect,
+                    },
+            .source = PixelSource{.buffer = Buffer{.buffer = srcTexture,
+                                                   .useTextureFiltering = true,
+                                                   .usePremultipliedAlpha = true,
+                                                   .isOpaque = true,
+                                                   .maxLuminanceNits = 0.f}},
+            .sourceDataspace = kExtendedHdrDataSpce,
+    };
+
+    LayerSettings caster{
+            .geometry =
+                    Geometry{
+                            .boundaries = smallerRect,
+                            .roundedCornersRadius = {50.f, 50.f},
+                            .roundedCornersCrop = smallerRect,
+                    },
+            .source = PixelSource{.buffer = Buffer{.buffer =srcTexture,
+                                                   .useTextureFiltering = true,
+                                                   .usePremultipliedAlpha = true,
+                                                   .isOpaque = false,
+                                                   .maxLuminanceNits = 0.f}},
+            .alpha = 1,
+        .sourceDataspace = ui::Dataspace::V0_SRGB,
+    };
+
+    for (auto alpha : {0.5f, 1.f}) {
+        layer.alpha = alpha;
+
+        for (auto casterAlpha : {0.5f, 1.f}) {
+            caster.alpha = casterAlpha;
+
+            for (auto layerWhitePoint : kLayerWhitePoints) {
+                layer.whitePointNits = layerWhitePoint;
+
+                auto layers = std::vector<LayerSettings>{layer, caster};
+                renderengine->drawLayers(display, layers, dstTexture, base::unique_fd());
+            }
+        }
+    }
+}
+
 //
 // The collection of shaders cached here were found by using perfetto to record shader compiles
 // during actions that involve RenderEngine, logging the layer settings, and the shader code
@@ -682,6 +778,16 @@ void Cache::primeShaderCache(SkiaRenderEngine* renderengine, PrimeCacheConfig co
                 .maxLuminance = 500,
                 .outputDataspace = kDestDataSpace,
         };
+        DisplaySettings v0srgbDisplay{
+                .physicalDisplay = displayRect,
+                .clip = displayRect,
+                .maxLuminance = 1000,
+                .outputDataspace = ui::Dataspace::V0_SRGB,
+                .deviceHandlesColorTransform = true,
+                .targetLuminanceNits = 128.002f,
+                .dimmingStage = aidl::android::hardware::graphics::composer3::DimmingStage::GAMMA_OETF,
+                .renderIntent = aidl::android::hardware::graphics::composer3::RenderIntent::ENHANCE
+        };
         DisplaySettings p3Display{
                 .physicalDisplay = displayRect,
                 .clip = displayRect,
@@ -841,9 +947,13 @@ void Cache::primeShaderCache(SkiaRenderEngine* renderengine, PrimeCacheConfig co
             drawExtendedHDRImageLayers(renderengine, p3Display, dstTexture, externalTexture);
             drawExtendedHDRImageLayers(renderengine, p3DisplayEnhance, dstTexture, externalTexture);
 
+            drawExtendedHDRFilteredImageLayers(renderengine, v0srgbDisplay, dstTexture, externalTexture);
+            drawExtendedHDRFilteredImageShadowLayers(renderengine, v0srgbDisplay, dstTexture, externalTexture);
+
             drawP3ImageLayers(renderengine, p3DisplayEnhance, dstTexture, externalTexture);
         }
 
+
         // draw one final layer synchronously to force GL submit
         LayerSettings layer{
                 .source = PixelSource{.solidColor = half3(0.f, 0.f, 0.f)},
diff --git a/libs/renderengine/skia/GaneshVkRenderEngine.cpp b/libs/renderengine/skia/GaneshVkRenderEngine.cpp
index cc73f405a6..94c1d0f035 100644
--- a/libs/renderengine/skia/GaneshVkRenderEngine.cpp
+++ b/libs/renderengine/skia/GaneshVkRenderEngine.cpp
@@ -55,7 +55,7 @@ static void unref_semaphore(void* semaphore) {
 
 std::unique_ptr<SkiaGpuContext> GaneshVkRenderEngine::createContext(
         VulkanInterface& vulkanInterface) {
-    return SkiaGpuContext::MakeVulkan_Ganesh(vulkanInterface.getGaneshBackendContext(),
+    return SkiaGpuContext::MakeVulkan_Ganesh(vulkanInterface.createSkiaVulkanBackendContext(),
                                              mSkSLCacheMonitor);
 }
 
diff --git a/libs/renderengine/skia/GraphiteVkRenderEngine.cpp b/libs/renderengine/skia/GraphiteVkRenderEngine.cpp
index a9332fa4e1..85cb68497f 100644
--- a/libs/renderengine/skia/GraphiteVkRenderEngine.cpp
+++ b/libs/renderengine/skia/GraphiteVkRenderEngine.cpp
@@ -22,9 +22,11 @@
 #include <include/gpu/GpuTypes.h>
 #include <include/gpu/graphite/BackendSemaphore.h>
 #include <include/gpu/graphite/Context.h>
+#include <include/gpu/graphite/PrecompileContext.h>
 #include <include/gpu/graphite/Recording.h>
 #include <include/gpu/graphite/vk/VulkanGraphiteTypes.h>
 
+#include <android-base/properties.h>
 #include <android-base/stringprintf.h>
 #include <log/log_main.h>
 #include <sync/sync.h>
@@ -32,6 +34,8 @@
 #include <memory>
 #include <vector>
 
+#include "compat/GraphitePipelineManager.h"
+
 namespace android::renderengine::skia {
 
 using base::StringAppendF;
@@ -53,6 +57,42 @@ std::unique_ptr<GraphiteVkRenderEngine> GraphiteVkRenderEngine::create(
     }
 }
 
+GraphiteVkRenderEngine::~GraphiteVkRenderEngine() {
+    // Ensure precompilation has finished accessing resources (e.g. context, RuntimeEffectManager).
+    // TODO(b/380159947): interrupt precompilation loop on destruction, instead of waiting for it to
+    // finish?
+    if (mPrecompilePipelinesTask.joinable()) {
+        mPrecompilePipelinesTask.join();
+    }
+}
+
+std::future<void> GraphiteVkRenderEngine::primeCache(PrimeCacheConfig config) {
+    std::future<void> ret = {};
+
+    // Note: for local debugging only! Graphite's precompilation should stay ENABLED, and this
+    // switch will be removed in the future without warning.
+    if (base::GetBoolProperty("debug.renderengine.graphite.precompile", true)) {
+        std::unique_ptr<graphite::PrecompileContext> precompileContext =
+                mContext->graphiteContext()->makePrecompileContext();
+        mPrecompilePipelinesTask =
+                std::thread(GraphitePipelineManager::PrecompilePipelines,
+                            std::move(precompileContext), std::ref(mRuntimeEffectManager));
+    } else {
+        ALOGW("Graphite's background shader / pipeline precompilation was disabled!");
+    }
+
+    // Note: for local debugging only! Legacy draw-based prewarming should stay DISABLED, and this
+    // switch will be removed  in the future without warning. Enabling this may regress boot time
+    // unnecessarily.
+    // TODO(b/380159947): remove this option, and force precompilation to always be enabled.
+    if (base::GetBoolProperty("debug.renderengine.graphite.prewarm", false)) {
+        ALOGW("Legacy draw-based shader / pipeline prewarming was enabled, and may delay boot!");
+        ret = SkiaVkRenderEngine::primeCache(config);
+    }
+
+    return ret;
+}
+
 // Graphite-specific function signature for fFinishedProc callback.
 static void unref_semaphore(void* semaphore, skgpu::CallbackResult result) {
     if (result != skgpu::CallbackResult::kSuccess) {
@@ -65,7 +105,7 @@ static void unref_semaphore(void* semaphore, skgpu::CallbackResult result) {
 
 std::unique_ptr<SkiaGpuContext> GraphiteVkRenderEngine::createContext(
         VulkanInterface& vulkanInterface) {
-    return SkiaGpuContext::MakeVulkan_Graphite(vulkanInterface.getGraphiteBackendContext());
+    return SkiaGpuContext::MakeVulkan_Graphite(vulkanInterface.createSkiaVulkanBackendContext());
 }
 
 void GraphiteVkRenderEngine::waitFence(SkiaGpuContext*, base::borrowed_fd fenceFd) {
diff --git a/libs/renderengine/skia/GraphiteVkRenderEngine.h b/libs/renderengine/skia/GraphiteVkRenderEngine.h
index 33a47f1a7f..66d1e88d13 100644
--- a/libs/renderengine/skia/GraphiteVkRenderEngine.h
+++ b/libs/renderengine/skia/GraphiteVkRenderEngine.h
@@ -26,6 +26,9 @@ class GraphiteVkRenderEngine : public SkiaVkRenderEngine {
 public:
     static std::unique_ptr<GraphiteVkRenderEngine> create(const RenderEngineCreationArgs& args);
 
+    ~GraphiteVkRenderEngine() override;
+    std::future<void> primeCache(PrimeCacheConfig config) override;
+
 protected:
     std::unique_ptr<SkiaGpuContext> createContext(VulkanInterface& vulkanInterface) override;
     void waitFence(SkiaGpuContext* context, base::borrowed_fd fenceFd) override;
@@ -35,6 +38,7 @@ protected:
 private:
     GraphiteVkRenderEngine(const RenderEngineCreationArgs& args) : SkiaVkRenderEngine(args) {}
 
+    std::thread mPrecompilePipelinesTask;
     std::vector<graphite::BackendSemaphore> mStagedWaitSemaphores;
 };
 
diff --git a/libs/renderengine/skia/SkiaGLRenderEngine.cpp b/libs/renderengine/skia/SkiaGLRenderEngine.cpp
index ddae9fc78f..acbb07c8ca 100644
--- a/libs/renderengine/skia/SkiaGLRenderEngine.cpp
+++ b/libs/renderengine/skia/SkiaGLRenderEngine.cpp
@@ -314,6 +314,11 @@ SkiaRenderEngine::Contexts SkiaGLRenderEngine::createContexts() {
     return contexts;
 }
 
+bool SkiaGLRenderEngine::supportsForwardPixelKill() const {
+    // ARM gpu support this since 2013
+    constexpr std::string kArm = "ARM";
+    return GLExtensions::getInstance().getVendor() == kArm;
+}
 bool SkiaGLRenderEngine::supportsProtectedContentImpl() const {
     return mProtectedEGLContext != EGL_NO_CONTEXT;
 }
diff --git a/libs/renderengine/skia/SkiaGLRenderEngine.h b/libs/renderengine/skia/SkiaGLRenderEngine.h
index 765103889e..ef322cfc57 100644
--- a/libs/renderengine/skia/SkiaGLRenderEngine.h
+++ b/libs/renderengine/skia/SkiaGLRenderEngine.h
@@ -38,7 +38,6 @@
 #include "android-base/macros.h"
 #include "debug/SkiaCapture.h"
 #include "filters/BlurFilter.h"
-#include "filters/LinearEffect.h"
 #include "filters/StretchShaderFactory.h"
 
 class SkData;
@@ -60,6 +59,7 @@ protected:
     // Implementations of abstract SkiaRenderEngine functions specific to
     // rendering backend
     virtual SkiaRenderEngine::Contexts createContexts();
+    bool supportsForwardPixelKill() const override;
     bool supportsProtectedContentImpl() const override;
     bool useProtectedContextImpl(GrProtected isProtected) override;
     void waitFence(SkiaGpuContext* context, base::borrowed_fd fenceFd) override;
diff --git a/libs/renderengine/skia/SkiaRenderEngine.cpp b/libs/renderengine/skia/SkiaRenderEngine.cpp
index 5b6edb4e30..0938255689 100644
--- a/libs/renderengine/skia/SkiaRenderEngine.cpp
+++ b/libs/renderengine/skia/SkiaRenderEngine.cpp
@@ -21,6 +21,7 @@
 #include "SkiaRenderEngine.h"
 
 #include <SkBlendMode.h>
+#include <SkBlurTypes.h>
 #include <SkCanvas.h>
 #include <SkColor.h>
 #include <SkColorFilter.h>
@@ -32,6 +33,7 @@
 #include <SkImageFilters.h>
 #include <SkImageInfo.h>
 #include <SkM44.h>
+#include <SkMaskFilter.h>
 #include <SkMatrix.h>
 #include <SkPaint.h>
 #include <SkPath.h>
@@ -79,8 +81,9 @@
 #include "filters/GaussianBlurFilter.h"
 #include "filters/KawaseBlurDualFilter.h"
 #include "filters/KawaseBlurFilter.h"
-#include "filters/LinearEffect.h"
+#include "filters/LutShader.h"
 #include "filters/MouriMap.h"
+#include "filters/RuntimeEffectManager.h"
 #include "log/log_main.h"
 #include "skia/compat/SkiaBackendTexture.h"
 #include "skia/debug/SkiaCapture.h"
@@ -236,6 +239,7 @@ static inline SkM44 getSkM44(const android::mat4& matrix) {
                  matrix[0][3], matrix[1][3], matrix[2][3], matrix[3][3]);
 }
 
+[[maybe_unused]]
 static inline SkPoint3 getSkPoint3(const android::vec3& vector) {
     return SkPoint3::Make(vector.x, vector.y, vector.z);
 }
@@ -289,17 +293,17 @@ SkiaRenderEngine::SkiaRenderEngine(Threaded threaded, PixelFormat pixelFormat,
     switch (blurAlgorithm) {
         case BlurAlgorithm::GAUSSIAN: {
             ALOGD("Background Blurs Enabled (Gaussian algorithm)");
-            mBlurFilter = new GaussianBlurFilter();
+            mBlurFilter = new GaussianBlurFilter(mRuntimeEffectManager);
             break;
         }
         case BlurAlgorithm::KAWASE: {
             ALOGD("Background Blurs Enabled (Kawase algorithm)");
-            mBlurFilter = new KawaseBlurFilter();
+            mBlurFilter = new KawaseBlurFilter(mRuntimeEffectManager);
             break;
         }
         case BlurAlgorithm::KAWASE_DUAL_FILTER: {
             ALOGD("Background Blurs Enabled (Kawase dual-filtering algorithm)");
-            mBlurFilter = new KawaseBlurDualFilter();
+            mBlurFilter = new KawaseBlurDualFilter(mRuntimeEffectManager);
             break;
         }
         default: {
@@ -522,6 +526,7 @@ void SkiaRenderEngine::cleanupPostRender() {
 
 sk_sp<SkShader> SkiaRenderEngine::createRuntimeEffectShader(
         const RuntimeEffectShaderParameters& parameters) {
+    SFTRACE_CALL();
     // The given surface will be stretched by HWUI via matrix transformation
     // which gets similar results for most surfaces
     // Determine later on if we need to leverage the stretch shader within
@@ -545,18 +550,9 @@ sk_sp<SkShader> SkiaRenderEngine::createRuntimeEffectShader(
     }
 
     if (graphicBuffer && parameters.layer.luts) {
-        const bool dimInLinearSpace = parameters.display.dimmingStage !=
-                aidl::android::hardware::graphics::composer3::DimmingStage::GAMMA_OETF;
-        const ui::Dataspace runtimeEffectDataspace = !dimInLinearSpace
-                ? static_cast<ui::Dataspace>(
-                          (parameters.outputDataSpace & ui::Dataspace::STANDARD_MASK) |
-                          ui::Dataspace::TRANSFER_GAMMA2_2 |
-                          (parameters.outputDataSpace & ui::Dataspace::RANGE_MASK))
-                : parameters.outputDataSpace;
-
         shader = mLutShader.lutShader(shader, parameters.layer.luts,
                                       parameters.layer.sourceDataspace,
-                                      toSkColorSpace(runtimeEffectDataspace));
+                                      toSkColorSpace(parameters.outputDataSpace));
     }
 
     if (parameters.requiresLinearEffect) {
@@ -591,14 +587,8 @@ sk_sp<SkShader> SkiaRenderEngine::createRuntimeEffectShader(
                                       .undoPremultipliedAlpha = parameters.undoPremultipliedAlpha,
                                       .fakeOutputDataspace = parameters.fakeOutputDataspace};
 
-        auto effectIter = mRuntimeEffects.find(effect);
-        sk_sp<SkRuntimeEffect> runtimeEffect = nullptr;
-        if (effectIter == mRuntimeEffects.end()) {
-            runtimeEffect = buildRuntimeEffect(effect);
-            mRuntimeEffects.insert({effect, runtimeEffect});
-        } else {
-            runtimeEffect = effectIter->second;
-        }
+        sk_sp<SkRuntimeEffect> runtimeEffect =
+                mRuntimeEffectManager.getOrCreateLinearRuntimeEffect(effect);
 
         mat4 colorTransform = parameters.layer.colorTransform;
 
@@ -609,19 +599,23 @@ sk_sp<SkShader> SkiaRenderEngine::createRuntimeEffectShader(
         }
 
         const auto hardwareBuffer = graphicBuffer ? graphicBuffer->toAHardwareBuffer() : nullptr;
-        return createLinearEffectShader(shader, effect, runtimeEffect, std::move(colorTransform),
-                                        parameters.display.maxLuminance,
-                                        parameters.display.currentLuminanceNits,
-                                        parameters.layer.source.buffer.maxLuminanceNits,
-                                        hardwareBuffer, parameters.display.renderIntent);
+        return RuntimeEffectManager::createLinearEffectShader(shader, effect, runtimeEffect,
+                                                              std::move(colorTransform),
+                                                              parameters.display.maxLuminance,
+                                                              parameters.display
+                                                                      .currentLuminanceNits,
+                                                              parameters.layer.source.buffer
+                                                                      .maxLuminanceNits,
+                                                              hardwareBuffer,
+                                                              parameters.display.renderIntent);
     }
     return shader;
 }
 
 sk_sp<SkShader> SkiaRenderEngine::localTonemap(sk_sp<SkShader> shader, float inputMultiplier,
                                                float targetHdrSdrRatio) {
-    static MouriMap kMapper;
-    return kMapper.mouriMap(getActiveContext(), shader, inputMultiplier, targetHdrSdrRatio);
+    return mLocalTonemapper.mouriMap(getActiveContext(), shader, inputMultiplier,
+                                     targetHdrSdrRatio);
 }
 
 void SkiaRenderEngine::initCanvas(SkCanvas* canvas, const DisplaySettings& display) {
@@ -885,6 +879,7 @@ void SkiaRenderEngine::drawLayersInternal(
         const auto [bounds, roundRectClip] =
                 getBoundsAndClip(layer.geometry.boundaries, layer.geometry.roundedCornersCrop,
                                  layer.geometry.roundedCornersRadius);
+
         if (mBlurFilter && layerHasBlur(layer, ctModifiesAlpha)) {
             std::unordered_map<uint32_t, sk_sp<SkImage>> cachedBlurs;
 
@@ -941,7 +936,8 @@ void SkiaRenderEngine::drawLayersInternal(
 
                     cachedBlurs[layer.backgroundBlurRadius] = blurredImage;
 
-                    mBlurFilter->drawBlurRegion(canvas, bounds, layer.backgroundBlurRadius, 1.0f,
+                    mBlurFilter->drawBlurRegion(canvas, bounds, layer.backgroundBlurRadius,
+                                                layer.backgroundBlurScale, 1.0f,
                                                 blurRect, blurredImage, blurInput);
                 }
 
@@ -955,59 +951,118 @@ void SkiaRenderEngine::drawLayersInternal(
                     }
 
                     mBlurFilter->drawBlurRegion(canvas, getBlurRRect(region), region.blurRadius,
-                                                region.alpha, blurRect,
+                                                1.0f, region.alpha, blurRect,
                                                 cachedBlurs[region.blurRadius], blurInput);
                 }
             }
         }
 
-        if (layer.shadow.length > 0) {
-            // This would require a new parameter/flag to SkShadowUtils::DrawShadow
-            LOG_ALWAYS_FATAL_IF(layer.disableBlending, "Cannot disableBlending with a shadow");
-
-            SkRRect shadowBounds, shadowClip;
-            if (layer.geometry.boundaries == layer.shadow.boundaries) {
-                shadowBounds = bounds;
-                shadowClip = roundRectClip;
-            } else {
-                std::tie(shadowBounds, shadowClip) =
-                        getBoundsAndClip(layer.shadow.boundaries, layer.geometry.roundedCornersCrop,
-                                         layer.geometry.roundedCornersRadius);
+        {
+            SFTRACE_NAME("OutsetRendering");
+            SkRRect otherCrop;
+            otherCrop.setRectXY(getSkRect(layer.geometry.otherCrop),
+                                layer.geometry.otherRoundedCornersRadius.x,
+                                layer.geometry.otherRoundedCornersRadius.y);
+            // Outset rendering needs to be clipped by parent.
+            SkAutoCanvasRestore acr(canvas, true);
+            if (!otherCrop.isEmpty()) {
+                canvas->clipRRect(otherCrop, true);
             }
 
-            // Technically, if bounds is a rect and roundRectClip is not empty,
-            // it means that the bounds and roundedCornersCrop were different
-            // enough that we should intersect them to find the proper shadow.
-            // In practice, this often happens when the two rectangles appear to
-            // not match due to rounding errors. Draw the rounded version, which
-            // looks more like the intent.
-            const auto& rrect =
-                    shadowBounds.isRect() && !shadowClip.isEmpty() ? shadowClip : shadowBounds;
-            drawShadow(canvas, rrect, layer.shadow);
-        }
+            if (layer.shadow.length > 0) {
+                // This would require a new parameter/flag to SkShadowUtils::DrawShadow
+                LOG_ALWAYS_FATAL_IF(layer.disableBlending, "Cannot disableBlending with a shadow");
+
+                SkRRect shadowBounds, shadowClip;
+                if (layer.geometry.boundaries == layer.shadow.boundaries) {
+                    shadowBounds = bounds;
+                    shadowClip = roundRectClip;
+                } else {
+                    std::tie(shadowBounds, shadowClip) =
+                            getBoundsAndClip(layer.shadow.boundaries,
+                                             layer.geometry.roundedCornersCrop,
+                                             layer.geometry.roundedCornersRadius);
+                }
 
-        // Similar to shadows, do the rendering before the clip is applied because even when the
-        // layer is occluded it should have an outline.
-        if (layer.borderSettings.strokeWidth > 0) {
-            // TODO(b/367464660): Move this code to the parent scope and
-            // update shadow rendering above to use these bounds since they should be
+                // Technically, if bounds is a rect and roundRectClip is not empty,
+                // it means that the bounds and roundedCornersCrop were different
+                // enough that we should intersect them to find the proper shadow.
+                // In practice, this often happens when the two rectangles appear to
+                // not match due to rounding errors. Draw the rounded version, which
+                // looks more like the intent.
+                const auto& rrect =
+                        shadowBounds.isRect() && !shadowClip.isEmpty() ? shadowClip : shadowBounds;
+                drawShadow(canvas, rrect, layer.shadow);
+            }
+
+            // TODO(b/367464660): Move this code above and
+            // update elevation shadow rendering to use these bounds since they should be
             // identical.
             SkRRect originalBounds, originalClip;
             std::tie(originalBounds, originalClip) =
-                    getBoundsAndClip(layer.geometry.boundaries, layer.geometry.roundedCornersCrop,
+                    getBoundsAndClip(layer.geometry.originalBounds,
+                                     layer.geometry.roundedCornersCrop,
                                      layer.geometry.roundedCornersRadius);
             const SkRRect& preferredOriginalBounds =
                     originalBounds.isRect() && !originalClip.isEmpty() ? originalClip
                                                                        : originalBounds;
 
-            SkRRect outlineRect = preferredOriginalBounds;
-            outlineRect.outset(layer.borderSettings.strokeWidth, layer.borderSettings.strokeWidth);
+            // Similar to shadows, do the rendering before the clip is applied because even when the
+            // layer is occluded it should have an outline.
+            if (layer.borderSettings.strokeWidth > 0) {
+                SFTRACE_NAME("LayerBorder");
+                LOG_ALWAYS_FATAL_IF(layer.disableBlending,
+                                    "Cannot disableBlending with an outline");
+                SkRRect outlineRect = preferredOriginalBounds;
+                outlineRect.outset(layer.borderSettings.strokeWidth,
+                                   layer.borderSettings.strokeWidth);
 
-            SkPaint paint;
-            paint.setAntiAlias(true);
-            paint.setColor(layer.borderSettings.color);
-            paint.setStyle(SkPaint::kFill_Style);
-            canvas->drawDRRect(outlineRect, preferredOriginalBounds, paint);
+                SkPaint paint;
+                paint.setAntiAlias(true);
+                paint.setColor(layer.borderSettings.color);
+                paint.setStyle(SkPaint::kFill_Style);
+                canvas->drawDRRect(outlineRect, preferredOriginalBounds, paint);
+            }
+
+            if (!layer.boxShadowSettings.boxShadows.empty()) {
+                SFTRACE_NAME("BoxShadows");
+                LOG_ALWAYS_FATAL_IF(layer.disableBlending,
+                                    "Cannot disableBlending with a box shadow");
+                for (const gui::BoxShadowSettings::BoxShadowParams& box :
+                     layer.boxShadowSettings.boxShadows) {
+                    SkRRect boxRect = preferredOriginalBounds;
+                    boxRect.outset(box.spreadRadius, box.spreadRadius);
+                    boxRect.offset(box.offsetX, box.offsetY);
+                    float sigma = convertBlurUserRadiusToSigma(box.blurRadius);
+                    SkPaint blur;
+                    blur.setColor(box.color);
+                    blur.setMaskFilter(SkMaskFilter::MakeBlur(kNormal_SkBlurStyle, sigma, false));
+                    canvas->drawRRect(boxRect, blur);
+                }
+
+                const bool opaqueContent =
+                        (!layer.source.buffer.buffer || layer.source.buffer.isOpaque) &&
+                        layer.alpha == 1.0f;
+                if (opaqueContent && supportsForwardPixelKill()) {
+                    SFTRACE_NAME("FPKOptimization");
+                    // This optimization is just for Ganesh and can be removed once graphite is
+                    // enabled.
+                    SkRRect p = preferredOriginalBounds;
+                    // Assume corners are circles.
+                    SkScalar maxRadius = std::max({p.radii(SkRRect::kUpperLeft_Corner).fX,
+                                                   p.radii(SkRRect::kUpperRight_Corner).fX,
+                                                   p.radii(SkRRect::kLowerRight_Corner).fX,
+                                                   p.radii(SkRRect::kLowerLeft_Corner).fX});
+                    SkRect killRect = p.rect();
+                    killRect.inset(maxRadius, maxRadius);
+                    SkPaint paint;
+                    // Draw opaque rect to force FPK on mali results in 2x speedup.
+                    paint.setAntiAlias(false);
+                    paint.setColor(0);
+                    paint.setBlendMode(SkBlendMode::kSrc);
+                    canvas->drawRect(killRect, paint);
+                }
+            }
         }
 
         const float layerDimmingRatio = layer.whitePointNits <= 0.f
@@ -1022,7 +1077,8 @@ void SkiaRenderEngine::drawLayersInternal(
                 (display.outputDataspace & ui::Dataspace::TRANSFER_MASK) ==
                         static_cast<int32_t>(ui::Dataspace::TRANSFER_SRGB);
 
-        const bool useFakeOutputDataspaceForRuntimeEffect = !dimInLinearSpace && isExtendedHdr;
+        const bool useFakeOutputDataspaceForRuntimeEffect =
+                !dimInLinearSpace && (isExtendedHdr || layer.luts);
 
         const ui::Dataspace fakeDataspace = useFakeOutputDataspaceForRuntimeEffect
                 ? static_cast<ui::Dataspace>(
@@ -1042,7 +1098,7 @@ void SkiaRenderEngine::drawLayersInternal(
         const bool requiresLinearEffect = layer.colorTransform != mat4() ||
                 (needsToneMapping(layer.sourceDataspace, display.outputDataspace)) ||
                 (dimInLinearSpace && !equalsWithinMargin(1.f, layerDimmingRatio)) ||
-                (!dimInLinearSpace && isExtendedHdr);
+                useFakeOutputDataspaceForRuntimeEffect;
 
         // quick abort from drawing the remaining portion of the layer
         if (layer.skipContentDraw ||
@@ -1297,9 +1353,8 @@ void SkiaRenderEngine::tonemapAndDrawGainmapInternal(
 
     const auto tonemappedShader = localTonemap(hdrShader, 1.0f, 1.0f);
 
-    static GainmapFactory kGainmapFactory;
     const auto gainmapShader =
-            kGainmapFactory.createSkShader(tonemappedShader, hdrShader, hdrSdrRatio);
+            mGainmapFactory.createSkShader(tonemappedShader, hdrShader, hdrSdrRatio);
 
     sp<Fence> drawFence;
 
@@ -1344,10 +1399,16 @@ void SkiaRenderEngine::drawShadow(SkCanvas* canvas,
     const auto flags =
             settings.casterIsTranslucent ? kTransparentOccluder_ShadowFlag : kNone_ShadowFlag;
 
+    // DrawShadow expects the light pos in device space.
+    // Shadow settings is in layer space (which is our current canvas transform).
+    SkMatrix deviceFromLayer = canvas->getTotalMatrix();
+    SkPoint lightPos = {settings.lightPos.x, settings.lightPos.y}; // lightPos is in layer space
+    deviceFromLayer.mapPoints(&lightPos, 1);                       // lightPos is in device space
+
     SkShadowUtils::DrawShadow(canvas, SkPath::RRect(casterRRect), SkPoint3::Make(0, 0, casterZ),
-                              getSkPoint3(settings.lightPos), settings.lightRadius,
-                              getSkColor(settings.ambientColor), getSkColor(settings.spotColor),
-                              flags);
+                              SkPoint3{lightPos.fX, lightPos.fY, settings.lightPos.z},
+                              settings.lightRadius, getSkColor(settings.ambientColor),
+                              getSkColor(settings.spotColor), flags);
 }
 
 void SkiaRenderEngine::onActiveDisplaySizeChanged(ui::Size size) {
@@ -1439,19 +1500,7 @@ void SkiaRenderEngine::dump(std::string& result) {
         gpuProtectedReporter.logOutput(result, true);
 
         StringAppendF(&result, "\n");
-        StringAppendF(&result, "RenderEngine runtime effects: %zu\n", mRuntimeEffects.size());
-        for (const auto& [linearEffect, unused] : mRuntimeEffects) {
-            StringAppendF(&result, "- inputDataspace: %s\n",
-                          dataspaceDetails(
-                                  static_cast<android_dataspace>(linearEffect.inputDataspace))
-                                  .c_str());
-            StringAppendF(&result, "- outputDataspace: %s\n",
-                          dataspaceDetails(
-                                  static_cast<android_dataspace>(linearEffect.outputDataspace))
-                                  .c_str());
-            StringAppendF(&result, "undoPremultipliedAlpha: %s\n",
-                          linearEffect.undoPremultipliedAlpha ? "true" : "false");
-        }
+        mRuntimeEffectManager.dump(result);
     }
     StringAppendF(&result, "\n");
 }
diff --git a/libs/renderengine/skia/SkiaRenderEngine.h b/libs/renderengine/skia/SkiaRenderEngine.h
index 92b7af985c..787b89a5b2 100644
--- a/libs/renderengine/skia/SkiaRenderEngine.h
+++ b/libs/renderengine/skia/SkiaRenderEngine.h
@@ -38,8 +38,10 @@
 #include "debug/SkiaCapture.h"
 #include "filters/BlurFilter.h"
 #include "filters/EdgeExtensionShaderFactory.h"
-#include "filters/LinearEffect.h"
+#include "filters/GainmapFactory.h"
 #include "filters/LutShader.h"
+#include "filters/MouriMap.h"
+#include "filters/RuntimeEffectManager.h"
 #include "filters/StretchShaderFactory.h"
 
 class SkData;
@@ -63,7 +65,7 @@ public:
     SkiaRenderEngine(Threaded, PixelFormat pixelFormat, BlurAlgorithm);
     ~SkiaRenderEngine() override;
 
-    std::future<void> primeCache(PrimeCacheConfig config) override final;
+    std::future<void> primeCache(PrimeCacheConfig config) override;
     void cleanupPostRender() override final;
     bool supportsBackgroundBlur() override final {
         return mBlurFilter != nullptr;
@@ -88,6 +90,7 @@ protected:
     using Contexts = std::pair<unique_ptr<SkiaGpuContext>, unique_ptr<SkiaGpuContext>>;
     virtual Contexts createContexts() = 0;
     virtual bool supportsProtectedContentImpl() const = 0;
+    virtual bool supportsForwardPixelKill() const { return false; }
     virtual bool useProtectedContextImpl(GrProtected isProtected) = 0;
     virtual void waitFence(SkiaGpuContext* context, base::borrowed_fd fenceFd) = 0;
     virtual base::unique_fd flushAndSubmit(SkiaGpuContext* context,
@@ -126,6 +129,13 @@ protected:
     };
 
     SkSLCacheMonitor mSkSLCacheMonitor;
+    RuntimeEffectManager mRuntimeEffectManager;
+
+    // Graphics context used for creating surfaces and submitting commands.
+    // Unlike mProtectedContext, mContext cannot be marked private because it
+    // occasionally needs to be referenced by subclasses (e.g. for Graphite's
+    // precompilation).
+    unique_ptr<SkiaGpuContext> mContext;
 
 private:
     void mapExternalTextureBuffer(const sp<GraphicBuffer>& buffer,
@@ -179,13 +189,16 @@ private:
             GUARDED_BY(mRenderingMutex);
     std::unordered_map<GraphicBufferId, std::shared_ptr<AutoBackendTexture::LocalRef>> mTextureCache
             GUARDED_BY(mRenderingMutex);
-    std::unordered_map<shaders::LinearEffect, sk_sp<SkRuntimeEffect>, shaders::LinearEffectHasher>
-            mRuntimeEffects;
     AutoBackendTexture::CleanupManager mTextureCleanupMgr GUARDED_BY(mRenderingMutex);
 
-    StretchShaderFactory mStretchShaderFactory;
-    EdgeExtensionShaderFactory mEdgeExtensionShaderFactory;
-    LutShader mLutShader;
+    // Alphabetical by type name
+    // TODO(b/380159947): move these into RuntimeEffectManager
+    EdgeExtensionShaderFactory mEdgeExtensionShaderFactory =
+            EdgeExtensionShaderFactory(mRuntimeEffectManager);
+    GainmapFactory mGainmapFactory = GainmapFactory(mRuntimeEffectManager);
+    LutShader mLutShader = LutShader(mRuntimeEffectManager);
+    MouriMap mLocalTonemapper = MouriMap(mRuntimeEffectManager);
+    StretchShaderFactory mStretchShaderFactory = StretchShaderFactory(mRuntimeEffectManager);
 
     sp<Fence> mLastDrawFence;
     BlurFilter* mBlurFilter = nullptr;
@@ -197,9 +210,7 @@ private:
     // rendering that is potentially modified by multiple threads is guaranteed thread-safe.
     mutable std::mutex mRenderingMutex;
 
-    // Graphics context used for creating surfaces and submitting commands
-    unique_ptr<SkiaGpuContext> mContext;
-    // Same as above, but for protected content (eg. DRM)
+    // Same as mContext, but for protected content (eg. DRM)
     unique_ptr<SkiaGpuContext> mProtectedContext;
     bool mInProtectedContext = false;
 };
diff --git a/libs/renderengine/skia/VulkanInterface.cpp b/libs/renderengine/skia/VulkanInterface.cpp
index 7331bbc418..ddf17351d4 100644
--- a/libs/renderengine/skia/VulkanInterface.cpp
+++ b/libs/renderengine/skia/VulkanInterface.cpp
@@ -32,11 +32,7 @@ namespace android {
 namespace renderengine {
 namespace skia {
 
-VulkanBackendContext VulkanInterface::getGaneshBackendContext() {
-    return this->getGraphiteBackendContext();
-};
-
-VulkanBackendContext VulkanInterface::getGraphiteBackendContext() {
+VulkanBackendContext VulkanInterface::createSkiaVulkanBackendContext() {
     VulkanBackendContext backendContext;
     backendContext.fInstance = mInstance;
     backendContext.fPhysicalDevice = mPhysicalDevice;
@@ -375,6 +371,7 @@ void VulkanInterface::init(bool protectedContent) {
     for (uint32_t i = 0; i < queueCount; ++i) {
         queuePriorityProps[i].sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT;
         queuePriorityProps[i].pNext = nullptr;
+        queueProps[i].sType = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2;
         queueProps[i].pNext = &queuePriorityProps[i];
     }
     vkGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, &queueCount, queueProps.data());
@@ -533,7 +530,7 @@ void VulkanInterface::init(bool protectedContent) {
     mDevice = device;
     mQueue = graphicsQueue;
     mQueueIndex = graphicsQueueIndex;
-    mApiVersion = physicalDeviceApiVersion;
+    mApiVersion = std::min(physicalDeviceApiVersion, appInfo.apiVersion);
     // grExtensions already constructed
     // feature pointers already constructed
     mGrGetProc = sGetProc;
diff --git a/libs/renderengine/skia/VulkanInterface.h b/libs/renderengine/skia/VulkanInterface.h
index d0fe4d1544..1de8b6fd4b 100644
--- a/libs/renderengine/skia/VulkanInterface.h
+++ b/libs/renderengine/skia/VulkanInterface.h
@@ -44,9 +44,7 @@ public:
     bool takeOwnership();
     void teardown();
 
-    // TODO(b/309785258) Combine these into one now that they are the same implementation.
-    VulkanBackendContext getGaneshBackendContext();
-    VulkanBackendContext getGraphiteBackendContext();
+    VulkanBackendContext createSkiaVulkanBackendContext();
     VkSemaphore createExportableSemaphore();
     VkSemaphore importSemaphoreFromSyncFd(int syncFd);
     int exportSemaphoreSyncFd(VkSemaphore semaphore);
diff --git a/libs/renderengine/skia/compat/GraphiteGpuContext.cpp b/libs/renderengine/skia/compat/GraphiteGpuContext.cpp
index 7a72d09804..d983f7e809 100644
--- a/libs/renderengine/skia/compat/GraphiteGpuContext.cpp
+++ b/libs/renderengine/skia/compat/GraphiteGpuContext.cpp
@@ -20,6 +20,7 @@
 #include <include/core/SkSurface.h>
 #include <include/core/SkTraceMemoryDump.h>
 #include <include/gpu/graphite/GraphiteTypes.h>
+#include <include/gpu/graphite/ContextOptions.h>
 #include <include/gpu/graphite/Surface.h>
 #include <include/gpu/graphite/vk/VulkanGraphiteUtils.h>
 
diff --git a/libs/renderengine/skia/compat/GraphiteGpuContext.h b/libs/renderengine/skia/compat/GraphiteGpuContext.h
index 57da796af5..70a43e3187 100644
--- a/libs/renderengine/skia/compat/GraphiteGpuContext.h
+++ b/libs/renderengine/skia/compat/GraphiteGpuContext.h
@@ -18,6 +18,7 @@
 
 #include "SkiaGpuContext.h"
 #include "graphite/Recorder.h"
+#include "graphite/Context.h"
 
 #include <android-base/macros.h>
 
diff --git a/libs/renderengine/skia/compat/GraphitePipelineManager.cpp b/libs/renderengine/skia/compat/GraphitePipelineManager.cpp
new file mode 100644
index 0000000000..4121949326
--- /dev/null
+++ b/libs/renderengine/skia/compat/GraphitePipelineManager.cpp
@@ -0,0 +1,859 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "GraphitePipelineManager.h"
+
+#include <include/core/SkData.h>
+#include <include/core/SkRefCnt.h>
+#include <include/effects/SkRuntimeEffect.h>
+#include <include/gpu/graphite/GraphiteTypes.h>
+#include <include/gpu/graphite/PrecompileContext.h>
+#include <include/gpu/graphite/precompile/PaintOptions.h>
+#include <include/gpu/graphite/precompile/Precompile.h>
+#include <include/gpu/graphite/precompile/PrecompileColorFilter.h>
+#include <include/gpu/graphite/precompile/PrecompileRuntimeEffect.h>
+#include <include/gpu/graphite/precompile/PrecompileShader.h>
+#include <include/gpu/graphite/vk/precompile/VulkanPrecompileShader.h>
+#include <include/gpu/vk/VulkanTypes.h>
+
+#include "skia/filters/RuntimeEffectManager.h"
+
+namespace android::renderengine::skia {
+
+using namespace skgpu::graphite;
+
+using PrecompileShaders::ImageShaderFlags;
+
+using ::skgpu::graphite::DrawTypeFlags;
+using ::skgpu::graphite::PaintOptions;
+using ::skgpu::graphite::RenderPassProperties;
+
+struct PrecompileSettings {
+    PaintOptions fPaintOptions;
+    DrawTypeFlags fDrawTypeFlags = skgpu::graphite::DrawTypeFlags::kNone;
+    RenderPassProperties fRenderPassProps;
+
+    bool isSubsetOf(const PrecompileSettings& superSet) const {
+        return (fDrawTypeFlags & superSet.fDrawTypeFlags) &&
+                fRenderPassProps == superSet.fRenderPassProps;
+    }
+};
+
+sk_sp<PrecompileShader> vulkan_ycbcr_image_shader(uint64_t format,
+                                                  VkSamplerYcbcrModelConversion model,
+                                                  VkSamplerYcbcrRange range,
+                                                  VkChromaLocation location, bool pqCS = false) {
+    SkColorInfo ci{kRGBA_8888_SkColorType, kPremul_SkAlphaType,
+                   pqCS ? SkColorSpace::MakeRGB(SkNamedTransferFn::kPQ, SkNamedGamut::kRec2020)
+                        : nullptr};
+
+    skgpu::VulkanYcbcrConversionInfo info;
+
+    info.fExternalFormat = format;
+    info.fYcbcrModel = model;
+    info.fYcbcrRange = range;
+    info.fXChromaOffset = location;
+    info.fYChromaOffset = location;
+    info.fChromaFilter = VK_FILTER_LINEAR;
+
+    return PrecompileShaders::VulkanYCbCrImage(info,
+                                               PrecompileShaders::ImageShaderFlags::kExcludeCubic,
+                                               {&ci, 1}, {});
+}
+
+// Specifies the child shader to be created for a LinearEffect
+enum class ChildType {
+    kSolidColor,
+    kHWTexture,
+    kHWTextureYCbCr247,
+};
+
+sk_sp<PrecompileShader> create_child_shader(ChildType childType) {
+    switch (childType) {
+        case ChildType::kSolidColor:
+            return PrecompileShaders::Color();
+        case ChildType::kHWTexture: {
+            SkColorInfo ci{kRGBA_8888_SkColorType, kPremul_SkAlphaType,
+                           SkColorSpace::MakeRGB(SkNamedTransferFn::kSRGB,
+                                                 SkNamedGamut::kAdobeRGB)};
+
+            return PrecompileShaders::Image(PrecompileShaders::ImageShaderFlags::kExcludeCubic,
+                                            {&ci, 1}, {});
+        }
+        case ChildType::kHWTextureYCbCr247:
+            // HardwareImage(3: kEwAAPcAAAAAAAAA)
+            return vulkan_ycbcr_image_shader(247, VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020,
+                                             VK_SAMPLER_YCBCR_RANGE_ITU_NARROW,
+                                             VK_CHROMA_LOCATION_COSITED_EVEN,
+                                             /* pqCS= */ true);
+    }
+
+    return nullptr;
+}
+
+skgpu::graphite::PaintOptions LinearEffect(sk_sp<SkRuntimeEffect> linearEffect, ChildType childType,
+                                           SkBlendMode blendMode, bool paintColorIsOpaque = true,
+                                           bool matrixColorFilter = false, bool dither = false) {
+    PaintOptions paintOptions;
+
+    sk_sp<PrecompileShader> child = create_child_shader(childType);
+
+    paintOptions.setShaders({PrecompileRuntimeEffects::MakePrecompileShader(std::move(linearEffect),
+                                                                            {{std::move(child)}})});
+    if (matrixColorFilter) {
+        paintOptions.setColorFilters({PrecompileColorFilters::Matrix()});
+    }
+    paintOptions.setBlendModes({blendMode});
+    paintOptions.setPaintColorIsOpaque(paintColorIsOpaque);
+    paintOptions.setDither(dither);
+
+    return paintOptions;
+}
+
+// =======================================
+//         PaintOptions
+// =======================================
+// NOTE: keep in sync with upstream external/skia/tests/graphite/precompile/PrecompileTestUtils.cpp
+// clang-format off
+
+PaintOptions SolidSrcover() {
+    PaintOptions paintOptions;
+    paintOptions.setBlendModes({ SkBlendMode::kSrcOver });
+    return paintOptions;
+}
+
+PaintOptions SolidMatrixCFSrcover() {
+    PaintOptions paintOptions;
+
+    paintOptions.setColorFilters({ PrecompileColorFilters::Matrix() });
+    paintOptions.setBlendModes({ SkBlendMode::kSrcOver });
+
+    return paintOptions;
+}
+
+PaintOptions TransparentPaintImagePremulHWOnlyMatrixCFSrcover() {
+    PaintOptions paintOptions;
+
+    SkColorInfo ci { kRGBA_8888_SkColorType, kPremul_SkAlphaType, nullptr };
+    paintOptions.setShaders({ PrecompileShaders::Image(ImageShaderFlags::kExcludeCubic,
+                                                       { &ci, 1 },
+                                                       {}) });
+    paintOptions.setColorFilters({ PrecompileColorFilters::Matrix() });
+    paintOptions.setBlendModes({ SkBlendMode::kSrcOver });
+    paintOptions.setPaintColorIsOpaque(false);
+    return paintOptions;
+}
+
+PaintOptions TransparentPaintImagePremulHWOnlyMatrixCFDitherSrcover() {
+    PaintOptions paintOptions;
+
+    SkColorInfo ci { kRGBA_8888_SkColorType, kPremul_SkAlphaType, nullptr };
+    paintOptions.setShaders({ PrecompileShaders::Image(ImageShaderFlags::kExcludeCubic,
+                                                       { &ci, 1 },
+                                                       {}) });
+    paintOptions.setColorFilters({ PrecompileColorFilters::Matrix() });
+    paintOptions.setBlendModes({ SkBlendMode::kSrcOver });
+    paintOptions.setPaintColorIsOpaque(false);
+    paintOptions.setDither(true);
+    return paintOptions;
+}
+
+PaintOptions TransparentPaintImageSRGBHWOnlyMatrixCFDitherSrcover() {
+    SkColorInfo ci { kRGBA_8888_SkColorType,
+                     kPremul_SkAlphaType,
+                     SkColorSpace::MakeRGB(SkNamedTransferFn::kSRGB, SkNamedGamut::kAdobeRGB) };
+
+    PaintOptions paintOptions;
+
+    paintOptions.setShaders({ PrecompileShaders::Image(ImageShaderFlags::kExcludeCubic,
+                                                       { &ci, 1 },
+                                                       {}) });
+    paintOptions.setColorFilters({ PrecompileColorFilters::Matrix() });
+    paintOptions.setBlendModes({ SkBlendMode::kSrcOver });
+    paintOptions.setPaintColorIsOpaque(false);
+    paintOptions.setDither(true);
+    return paintOptions;
+}
+
+PaintOptions TransparentPaintImagePremulHWOnlySrcover() {
+    PaintOptions paintOptions;
+
+    SkColorInfo ci { kRGBA_8888_SkColorType, kPremul_SkAlphaType, nullptr };
+    paintOptions.setShaders({ PrecompileShaders::Image(ImageShaderFlags::kExcludeCubic,
+                                                       { &ci, 1 },
+                                                       {}) });
+    paintOptions.setBlendModes({ SkBlendMode::kSrcOver });
+    paintOptions.setPaintColorIsOpaque(false);
+    return paintOptions;
+}
+
+PaintOptions TransparentPaintImageSRGBHWOnlySrcover() {
+    SkColorInfo ci { kRGBA_8888_SkColorType,
+                     kPremul_SkAlphaType,
+                     SkColorSpace::MakeRGB(SkNamedTransferFn::kSRGB, SkNamedGamut::kAdobeRGB) };
+
+    PaintOptions paintOptions;
+
+    paintOptions.setShaders({ PrecompileShaders::Image(ImageShaderFlags::kExcludeCubic,
+                                                       { &ci, 1 },
+                                                       {}) });
+    paintOptions.setBlendModes({ SkBlendMode::kSrcOver });
+    paintOptions.setPaintColorIsOpaque(false);
+    return paintOptions;
+}
+
+PaintOptions SolidSrcSrcover() {
+    PaintOptions paintOptions;
+    paintOptions.setBlendModes({ SkBlendMode::kSrc, SkBlendMode::kSrcOver });
+    return paintOptions;
+}
+
+PaintOptions ImagePremulHWOnlySrc() {
+    PaintOptions paintOptions;
+
+    SkColorInfo ci { kRGBA_8888_SkColorType, kPremul_SkAlphaType, nullptr };
+    paintOptions.setShaders({ PrecompileShaders::Image(ImageShaderFlags::kExcludeCubic,
+                                                       { &ci, 1 },
+                                                       {}) });
+    paintOptions.setBlendModes({ SkBlendMode::kSrc });
+    return paintOptions;
+}
+
+PaintOptions ImagePremulHWOnlySrcover() {
+    PaintOptions paintOptions;
+
+    SkColorInfo ci { kRGBA_8888_SkColorType, kPremul_SkAlphaType, nullptr };
+    paintOptions.setShaders({ PrecompileShaders::Image(ImageShaderFlags::kExcludeCubic,
+                                                       { &ci, 1 },
+                                                       {}) });
+    paintOptions.setBlendModes({ SkBlendMode::kSrcOver });
+    return paintOptions;
+}
+
+PaintOptions ImageAlphaPremulHWOnlyMatrixCFSrcover() {
+    PaintOptions paintOptions;
+
+    SkColorInfo ci { kAlpha_8_SkColorType, kUnpremul_SkAlphaType, nullptr };
+    paintOptions.setShaders({ PrecompileShaders::Image(ImageShaderFlags::kExcludeCubic,
+                                                       { &ci, 1 },
+                                                       {}) });
+    paintOptions.setColorFilters({ PrecompileColorFilters::Matrix() });
+
+    paintOptions.setBlendModes({ SkBlendMode::kSrcOver });
+    return paintOptions;
+}
+
+PaintOptions ImageAlphaSRGBHWOnlyMatrixCFSrcover() {
+    // Note: this is different from the other SRGB ColorInfos
+    SkColorInfo ci { kAlpha_8_SkColorType,
+                     kUnpremul_SkAlphaType,
+                     SkColorSpace::MakeRGB(SkNamedTransferFn::kSRGB, SkNamedGamut::kAdobeRGB) };
+
+    PaintOptions paintOptions;
+
+    paintOptions.setShaders({ PrecompileShaders::Image(ImageShaderFlags::kExcludeCubic,
+                                                       { &ci, 1 },
+                                                       {}) });
+    paintOptions.setColorFilters({ PrecompileColorFilters::Matrix() });
+
+    paintOptions.setBlendModes({ SkBlendMode::kSrcOver });
+    return paintOptions;
+}
+
+PaintOptions ImagePremulHWOnlyMatrixCFSrcover() {
+    PaintOptions paintOptions;
+
+    SkColorInfo ci { kRGBA_8888_SkColorType, kPremul_SkAlphaType, nullptr };
+    paintOptions.setShaders({ PrecompileShaders::Image(ImageShaderFlags::kExcludeCubic,
+                                                       { &ci, 1 },
+                                                       {}) });
+    paintOptions.setColorFilters({ PrecompileColorFilters::Matrix() });
+
+    paintOptions.setBlendModes({ SkBlendMode::kSrcOver });
+    return paintOptions;
+}
+
+PaintOptions ImagePremulHWOnlyMatrixCFDitherSrcover() {
+    PaintOptions paintOptions;
+
+    SkColorInfo ci { kRGBA_8888_SkColorType, kPremul_SkAlphaType, nullptr };
+    paintOptions.setShaders({ PrecompileShaders::Image(ImageShaderFlags::kExcludeCubic,
+                                                       { &ci, 1 },
+                                                       {}) });
+    paintOptions.setColorFilters({ PrecompileColorFilters::Matrix() });
+
+    paintOptions.setBlendModes({ SkBlendMode::kSrcOver });
+    paintOptions.setDither(true);
+
+    return paintOptions;
+}
+
+PaintOptions ImageSRGBHWOnlyMatrixCFDitherSrcover() {
+    SkColorInfo ci { kRGBA_8888_SkColorType,
+                     kPremul_SkAlphaType,
+                     SkColorSpace::MakeRGB(SkNamedTransferFn::kSRGB, SkNamedGamut::kAdobeRGB) };
+
+    PaintOptions paintOptions;
+
+    paintOptions.setShaders({ PrecompileShaders::Image(ImageShaderFlags::kExcludeCubic,
+                                                       { &ci, 1 },
+                                                       {}) });
+    paintOptions.setColorFilters({ PrecompileColorFilters::Matrix() });
+
+    paintOptions.setBlendModes({ SkBlendMode::kSrcOver });
+    paintOptions.setDither(true);
+
+    return paintOptions;
+}
+
+PaintOptions ImageHWOnlySRGBSrcover() {
+    PaintOptions paintOptions;
+
+    SkColorInfo ci { kRGBA_8888_SkColorType,
+                     kPremul_SkAlphaType,
+                     SkColorSpace::MakeRGB(SkNamedTransferFn::kSRGB,
+                                           SkNamedGamut::kAdobeRGB) };
+    paintOptions.setShaders({ PrecompileShaders::Image(ImageShaderFlags::kExcludeCubic,
+                                                       { &ci, 1 },
+                                                       {}) });
+
+    paintOptions.setBlendModes({ SkBlendMode::kSrcOver });
+    return paintOptions;
+}
+
+skgpu::graphite::PaintOptions MouriMapCrosstalkAndChunk16x16(RuntimeEffectManager& effectManager) {
+    SkColorInfo ci { kRGBA_8888_SkColorType, kPremul_SkAlphaType, nullptr };
+    sk_sp<PrecompileShader> img = PrecompileShaders::Image(ImageShaderFlags::kExcludeCubic,
+                                                           { &ci, 1 },
+                                                           {});
+
+    sk_sp<PrecompileShader> crosstalk = PrecompileRuntimeEffects::
+            MakePrecompileShader(effectManager.getKnownRuntimeEffect(
+                                         RuntimeEffectManager::KnownId::
+                                                 kMouriMap_CrossTalkAndChunk16x16Effect),
+                                 {{std::move(img)}});
+
+    PaintOptions paintOptions;
+    paintOptions.setShaders({ std::move(crosstalk) });
+    paintOptions.setBlendModes({ SkBlendMode::kSrc });
+    return paintOptions;
+}
+
+skgpu::graphite::PaintOptions MouriMapChunk8x8Effect(RuntimeEffectManager& effectManager) {
+    SkColorInfo ci { kRGBA_8888_SkColorType, kPremul_SkAlphaType, nullptr };
+    sk_sp<PrecompileShader> img = PrecompileShaders::Image(ImageShaderFlags::kExcludeCubic,
+                                                           { &ci, 1 },
+                                                           {});
+
+    sk_sp<PrecompileShader> chunk8x8 = PrecompileRuntimeEffects::
+            MakePrecompileShader(effectManager.getKnownRuntimeEffect(
+                                         RuntimeEffectManager::KnownId::kMouriMap_Chunk8x8Effect),
+                                 {{std::move(img)}});
+
+    PaintOptions paintOptions;
+    paintOptions.setShaders({ std::move(chunk8x8) });
+    paintOptions.setBlendModes({ SkBlendMode::kSrc });
+    return paintOptions;
+}
+
+skgpu::graphite::PaintOptions MouriMapBlur(RuntimeEffectManager& effectManager) {
+    SkColorInfo ci { kRGBA_8888_SkColorType, kPremul_SkAlphaType, nullptr };
+    sk_sp<PrecompileShader> img = PrecompileShaders::Image(ImageShaderFlags::kExcludeCubic,
+                                                           { &ci, 1 },
+                                                           {});
+
+    sk_sp<PrecompileShader> blur = PrecompileRuntimeEffects::
+            MakePrecompileShader(effectManager.getKnownRuntimeEffect(
+                                         RuntimeEffectManager::KnownId::kMouriMap_BlurEffect),
+                                 {{std::move(img)}});
+
+    PaintOptions paintOptions;
+    paintOptions.setShaders({ std::move(blur) });
+    paintOptions.setBlendModes({ SkBlendMode::kSrc });
+    return paintOptions;
+}
+
+skgpu::graphite::PaintOptions MouriMapToneMap(RuntimeEffectManager& effectManager) {
+    SkColorInfo ci { kRGBA_8888_SkColorType, kPremul_SkAlphaType, nullptr };
+    sk_sp<PrecompileShader> img1 = PrecompileShaders::Image(ImageShaderFlags::kExcludeCubic,
+                                                            { &ci, 1 },
+                                                            {});
+    sk_sp<PrecompileShader> img2 = PrecompileShaders::Image(ImageShaderFlags::kExcludeCubic,
+                                                            { &ci, 1 },
+                                                            {});
+
+    sk_sp<PrecompileShader> toneMap = PrecompileRuntimeEffects::
+            MakePrecompileShader(effectManager.getKnownRuntimeEffect(
+                                         RuntimeEffectManager::KnownId::kMouriMap_TonemapEffect),
+                                 {{std::move(img1)}, {std::move(img2)}});
+
+    PaintOptions paintOptions;
+    paintOptions.setShaders({ std::move(toneMap) });
+    paintOptions.setBlendModes({ SkBlendMode::kSrc });
+    return paintOptions;
+}
+
+skgpu::graphite::PaintOptions KawaseBlurLowSrcSrcOver(RuntimeEffectManager& effectManager) {
+    sk_sp<SkRuntimeEffect> lowSampleBlurEffect = effectManager.getKnownRuntimeEffect(
+            RuntimeEffectManager::KnownId::kKawaseBlurDualFilter_LowSampleBlurEffect);
+
+    SkColorInfo ci { kRGBA_8888_SkColorType, kPremul_SkAlphaType, nullptr };
+    sk_sp<PrecompileShader> img = PrecompileShaders::Image(ImageShaderFlags::kExcludeCubic,
+                                                           { &ci, 1 },
+                                                           {});
+
+    sk_sp<PrecompileShader> kawase = PrecompileRuntimeEffects::MakePrecompileShader(
+            std::move(lowSampleBlurEffect),
+            { { img } });
+
+    PaintOptions paintOptions;
+    paintOptions.setShaders({ std::move(kawase) });
+    paintOptions.setBlendModes({ SkBlendMode::kSrc, SkBlendMode::kSrcOver });
+    return paintOptions;
+}
+
+skgpu::graphite::PaintOptions KawaseBlurHighSrc(RuntimeEffectManager& effectManager) {
+    sk_sp<SkRuntimeEffect> highSampleBlurEffect = effectManager.getKnownRuntimeEffect(
+            RuntimeEffectManager::KnownId::kKawaseBlurDualFilter_HighSampleBlurEffect);
+
+    SkColorInfo ci { kRGBA_8888_SkColorType, kPremul_SkAlphaType, nullptr };
+    sk_sp<PrecompileShader> img = PrecompileShaders::Image(ImageShaderFlags::kExcludeCubic,
+                                                           { &ci, 1 },
+                                                           {});
+
+    sk_sp<PrecompileShader> kawase = PrecompileRuntimeEffects::MakePrecompileShader(
+            std::move(highSampleBlurEffect),
+            { { img } });
+
+    PaintOptions paintOptions;
+    paintOptions.setShaders({ std::move(kawase) });
+    paintOptions.setBlendModes({ SkBlendMode::kSrc });
+    return paintOptions;
+}
+
+skgpu::graphite::PaintOptions BlurFilterMix(RuntimeEffectManager& effectManager) {
+    sk_sp<SkRuntimeEffect> mixEffect = effectManager.getKnownRuntimeEffect(
+            RuntimeEffectManager::KnownId::kBlurFilter_MixEffect);
+
+    SkColorInfo ci { kRGBA_8888_SkColorType, kPremul_SkAlphaType, nullptr };
+    sk_sp<PrecompileShader> img = PrecompileShaders::Image(ImageShaderFlags::kExcludeCubic,
+                                                           { &ci, 1 },
+                                                           {});
+
+    sk_sp<PrecompileShader> mix = PrecompileRuntimeEffects::MakePrecompileShader(
+            std::move(mixEffect),
+            { { img }, { img } });
+
+    PaintOptions paintOptions;
+    paintOptions.setShaders({ std::move(mix) });
+    paintOptions.setBlendModes({ SkBlendMode::kSrc });
+    return paintOptions;
+}
+
+PaintOptions ImagePremulYCbCr238Srcover() {
+    PaintOptions paintOptions;
+
+    // HardwareImage(3: kHoAAO4AAAAAAAAA)
+    paintOptions.setShaders({ vulkan_ycbcr_image_shader(238,
+                                                        VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709,
+                                                        VK_SAMPLER_YCBCR_RANGE_ITU_NARROW,
+                                                        VK_CHROMA_LOCATION_MIDPOINT) });
+    paintOptions.setBlendModes({ SkBlendMode::kSrcOver });
+    return paintOptions;
+}
+
+PaintOptions ImagePremulYCbCr240Srcover() {
+    PaintOptions paintOptions;
+
+    // HardwareImage(3: kHIAAPAAAAAAAAAA)
+    paintOptions.setShaders({ vulkan_ycbcr_image_shader(240,
+                                                        VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709,
+                                                        VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
+                                                        VK_CHROMA_LOCATION_MIDPOINT) });
+    paintOptions.setBlendModes({ SkBlendMode::kSrcOver });
+    return paintOptions;
+}
+
+PaintOptions TransparentPaintImagePremulYCbCr240Srcover() {
+    PaintOptions paintOptions;
+
+    // HardwareImage(3: kHIAAPAAAAAAAAAA)
+    paintOptions.setShaders({ vulkan_ycbcr_image_shader(240,
+                                                        VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709,
+                                                        VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
+                                                        VK_CHROMA_LOCATION_MIDPOINT) });
+    paintOptions.setBlendModes({ SkBlendMode::kSrcOver });
+    paintOptions.setPaintColorIsOpaque(false);
+    return paintOptions;
+}
+
+skgpu::graphite::PaintOptions MouriMapCrosstalkAndChunk16x16YCbCr247(RuntimeEffectManager& effectManager) {
+    PaintOptions paintOptions;
+
+    // HardwareImage(3: kEwAAPcAAAAAAAAA)
+    sk_sp<PrecompileShader> img = vulkan_ycbcr_image_shader(
+            247,
+            VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020,
+            VK_SAMPLER_YCBCR_RANGE_ITU_NARROW,
+            VK_CHROMA_LOCATION_COSITED_EVEN);
+
+    sk_sp<PrecompileShader> crosstalk = PrecompileRuntimeEffects::MakePrecompileShader(
+            effectManager.getKnownRuntimeEffect(RuntimeEffectManager::KnownId::kMouriMap_CrossTalkAndChunk16x16Effect),
+            { { std::move(img) } });
+
+    paintOptions.setShaders({ std::move(crosstalk) });
+    paintOptions.setBlendModes({ SkBlendMode::kSrc });
+    return paintOptions;
+}
+
+// clang-format on
+
+// =======================================
+//         RenderPassProperties
+// =======================================
+// NOTE: keep in sync with upstream external/skia/tests/graphite/precompile/PrecompileTestUtils.h
+// clang-format off
+
+// RGBA version of the above
+const skgpu::graphite::RenderPassProperties kRGBA_1_D {
+    skgpu::graphite::DepthStencilFlags::kDepth,
+    kRGBA_8888_SkColorType,
+    /* fDstCS= */ nullptr,
+    /* fRequiresMSAA= */ false
+};
+
+// RGBA version of the above
+const skgpu::graphite::RenderPassProperties kRGBA_4_D {
+    skgpu::graphite::DepthStencilFlags::kDepth,
+    kRGBA_8888_SkColorType,
+    /* fDstCS= */ nullptr,
+    /* fRequiresMSAA= */ true
+};
+
+// RGBA version of the above
+const skgpu::graphite::RenderPassProperties kRGBA_4_DS {
+    skgpu::graphite::DepthStencilFlags::kDepthStencil,
+    kRGBA_8888_SkColorType,
+    /* fDstCS= */ nullptr,
+    /* fRequiresMSAA= */ true
+};
+
+// RGBA version of the above
+const skgpu::graphite::RenderPassProperties kRGBA_1_D_SRGB {
+    skgpu::graphite::DepthStencilFlags::kDepth,
+    kRGBA_8888_SkColorType,
+    SkColorSpace::MakeSRGB(),
+    /* fRequiresMSAA= */ false
+};
+
+// RGBA version of the above
+const skgpu::graphite::RenderPassProperties kRGBA_4_DS_SRGB {
+    skgpu::graphite::DepthStencilFlags::kDepthStencil,
+    kRGBA_8888_SkColorType,
+    SkColorSpace::MakeSRGB(),
+    /* fRequiresMSAA= */ true
+};
+
+// Single sampled RGBA16F w/ just depth
+const skgpu::graphite::RenderPassProperties kRGBA16F_1_D {
+    skgpu::graphite::DepthStencilFlags::kDepth,
+    kRGBA_F16_SkColorType,
+    /* fDstCS= */ nullptr,
+    /* fRequiresMSAA= */ false
+};
+
+// The same as kRGBA16F_1_D but w/ an SRGB colorSpace
+const skgpu::graphite::RenderPassProperties kRGBA16F_1_D_SRGB {
+        skgpu::graphite::DepthStencilFlags::kDepth,
+        kRGBA_F16_SkColorType,
+        SkColorSpace::MakeSRGB(),
+        /* fRequiresMSAA= */ false
+};
+
+// clang-format on
+
+// =======================================
+//            DrawTypeFlags
+// =======================================
+// NOTE: keep in sync with upstream external/skia/tests/graphite/precompile/PrecompileTestUtils.h
+// clang-format off
+
+constexpr skgpu::graphite::DrawTypeFlags kRRectAndNonAARect =
+        static_cast<skgpu::graphite::DrawTypeFlags>(skgpu::graphite::DrawTypeFlags::kAnalyticRRect |
+                                                    skgpu::graphite::DrawTypeFlags::kNonAAFillRect);
+constexpr skgpu::graphite::DrawTypeFlags kQuadAndNonAARect =
+        static_cast<skgpu::graphite::DrawTypeFlags>(skgpu::graphite::DrawTypeFlags::kPerEdgeAAQuad |
+                                                    skgpu::graphite::DrawTypeFlags::kNonAAFillRect);
+
+// clang-format on
+
+void GraphitePipelineManager::PrecompilePipelines(
+        std::unique_ptr<graphite::PrecompileContext> precompileContext,
+        RuntimeEffectManager& effectManager) {
+    // Easy references to SkRuntimeEffects for various LinearEffects that may be reused in multiple
+    // precompilation scenarios.
+    // clang-format off
+    const auto kUNKNOWN__SRGB__false__UNKNOWN__Shader =
+            effectManager.getOrCreateLinearRuntimeEffect({
+                    .inputDataspace = ui::Dataspace::UNKNOWN, // Default
+                    .outputDataspace = ui::Dataspace::SRGB,   // (deprecated) sRGB sRGB Full range
+                    .undoPremultipliedAlpha = false,
+                    .fakeOutputDataspace = ui::Dataspace::UNKNOWN, // Default
+                    .type = shaders::LinearEffect::SkSLType::Shader,
+            });
+
+    const auto kBT2020_ITU_PQ__BT2020__false__UNKNOWN__Shader =
+            effectManager.getOrCreateLinearRuntimeEffect({
+                    .inputDataspace = ui::Dataspace::BT2020_ITU_PQ,     // BT2020 SMPTE 2084 Limited range
+                    .outputDataspace = ui::Dataspace::BT2020, // BT2020 SMPTE_170M Full range
+                    .undoPremultipliedAlpha = false,
+                    .fakeOutputDataspace = ui::Dataspace::UNKNOWN, // Default
+                    .type = shaders::LinearEffect::SkSLType::Shader,
+            });
+
+    const auto k0x188a0000__DISPLAY_P3__false__0x90a0000__Shader =
+            effectManager.getOrCreateLinearRuntimeEffect({
+                    .inputDataspace = static_cast<ui::Dataspace>(0x188a0000), // DCI-P3 sRGB Extended range
+                    .outputDataspace = ui::Dataspace::DISPLAY_P3, // DCI-P3 sRGB Full range
+                    .undoPremultipliedAlpha = false,
+                    .fakeOutputDataspace = static_cast<ui::Dataspace>(0x90a0000), // DCI-P3 gamma 2.2 Full range
+                    .type = shaders::LinearEffect::SkSLType::Shader,
+            });
+    // clang-format on
+
+    // =======================================
+    //            Combinations
+    // =======================================
+    // NOTE: keep in sync with upstream
+    // external/skia/tests/graphite/precompile/AndroidPrecompileTest.cpp
+    // clang-format off
+    const PrecompileSettings precompileCases[] = {
+// 100% (1/1) handles: 0
+/*  0 */ { ImagePremulHWOnlySrcover(),         DrawTypeFlags::kNonAAFillRect,   kRGBA16F_1_D },
+// 100% (2/2) handles: 23 45
+/*  1 */ { ImagePremulHWOnlySrcover(),         kRRectAndNonAARect,              kRGBA_1_D },
+// 50% (2/4) handles: 66 75 - due to the w/o msaa load variants not being used
+/*  2 */ { ImagePremulHWOnlySrcover(),         kRRectAndNonAARect,              kRGBA_4_DS },
+
+// 100% (1/1) handles: 1
+/*  3 */ { ImageHWOnlySRGBSrcover(),           DrawTypeFlags::kNonAAFillRect,   kRGBA16F_1_D_SRGB },
+// 100% (2/2) handles: 25 47
+/*  4 */ { ImageHWOnlySRGBSrcover(),           kRRectAndNonAARect,              kRGBA_1_D_SRGB },
+
+// 100% (2/2) handles: 9 29
+/*  5 */ { TransparentPaintImagePremulHWOnlySrcover(), kRRectAndNonAARect,      kRGBA_1_D },
+// 50% (2/4) handles 64 69 - due to the w/o msaa load variants not being used
+/*  6 */ { TransparentPaintImagePremulHWOnlySrcover(), kRRectAndNonAARect,      kRGBA_4_DS },
+
+// 100% (2/2) handles 10 30
+/*  7 */ { TransparentPaintImageSRGBHWOnlySrcover(), kRRectAndNonAARect,        kRGBA_1_D_SRGB },
+
+// 75% (2/2) handles 28 59 60
+/*  8 */ { SolidSrcSrcover(),                  kRRectAndNonAARect,              kRGBA_1_D },
+// 50% (1/2) handles 77 - due to the w/o msaa load variants not being used
+/*  9 */ { SolidSrcover(),                     DrawTypeFlags::kNonAAFillRect,   kRGBA_4_DS },
+
+// 100% (2/2) handles 19 39
+/* 10 */ { ImagePremulHWOnlyMatrixCFSrcover(), kRRectAndNonAARect,              kRGBA_1_D },
+
+// 100% (1/1) handles 12
+/* 11 */ { TransparentPaintImagePremulHWOnlyMatrixCFSrcover(),
+                                            DrawTypeFlags::kAnalyticRRect,   kRGBA_1_D },
+
+// 100% (2/2) handles 14 31
+/* 12 */ { TransparentPaintImagePremulHWOnlyMatrixCFDitherSrcover(),
+                                            kRRectAndNonAARect,              kRGBA_1_D },
+// 50% (1/2) handles 71 - due to the w/o msaa load variants not being used
+/* 13 */ { TransparentPaintImagePremulHWOnlyMatrixCFDitherSrcover(),
+                                            DrawTypeFlags::kNonAAFillRect,   kRGBA_4_DS },
+
+// 100% (2/2) handles 16 33
+/* 14 */ { ImagePremulHWOnlyMatrixCFDitherSrcover(), kRRectAndNonAARect,        kRGBA_1_D },
+// 50% (1/2) handles 72 - due to the w/o msaa load variants not being used
+/* 15 */ { ImagePremulHWOnlyMatrixCFDitherSrcover(), DrawTypeFlags::kNonAAFillRect, kRGBA_4_DS },
+
+// 100% (2/2) handles 15 32
+/* 16 */ { TransparentPaintImageSRGBHWOnlyMatrixCFDitherSrcover(),
+                                            kRRectAndNonAARect,              kRGBA_1_D_SRGB },
+
+// 100% (2/2) handles 17 35
+/* 17 */ { ImageSRGBHWOnlyMatrixCFDitherSrcover(), kRRectAndNonAARect,          kRGBA_1_D_SRGB },
+// 50% (1/2) handles 80 - due to the w/o msaa load variants not being used
+/* 18 */ { ImageSRGBHWOnlyMatrixCFDitherSrcover(), DrawTypeFlags::kAnalyticRRect, kRGBA_4_DS_SRGB },
+
+// 100% (2/2) handles 22 42
+/* 19 */ { SolidMatrixCFSrcover(),             kRRectAndNonAARect,              kRGBA_1_D },
+// 50% (1/2) handles 83
+/* 20 */ { SolidMatrixCFSrcover(),             DrawTypeFlags::kNonAAFillRect,   kRGBA_4_DS },
+
+// 100% (1/1) handles 37
+/* 21 */ { ImageAlphaPremulHWOnlyMatrixCFSrcover(), DrawTypeFlags::kNonAAFillRect, kRGBA_1_D },
+// 50% (1/2) handles 73 - due to the w/o msaa load variants not being used
+/* 22 */ { ImageAlphaPremulHWOnlyMatrixCFSrcover(), DrawTypeFlags::kNonAAFillRect, kRGBA_4_DS },
+
+// 100% (1/1) handles 38
+/* 23 */ { ImageAlphaSRGBHWOnlyMatrixCFSrcover(), DrawTypeFlags::kNonAAFillRect,kRGBA_1_D_SRGB },
+
+// 100% (1/1) handles 44
+/* 24 */ { ImagePremulHWOnlySrc(),             DrawTypeFlags::kNonAAFillRect,   kRGBA_1_D },
+// 100% (1/1) handles 62
+/* 25 */ { ImagePremulHWOnlySrc(),             DrawTypeFlags::kPerEdgeAAQuad,   kRGBA_1_D },
+// 50% (1/2) handles 74 - due to the w/o msaa load variants not being used
+/* 26 */ { ImagePremulHWOnlySrc(),             DrawTypeFlags::kNonAAFillRect,   kRGBA_4_DS },
+
+// 100% (1/1) handles 5
+/* 27 */ { MouriMapBlur(effectManager),                     DrawTypeFlags::kNonAAFillRect,   kRGBA16F_1_D },
+// 100% (1/1) handles 58
+/* 28 */ { MouriMapToneMap(effectManager),                  DrawTypeFlags::kNonAAFillRect,   kRGBA_1_D_SRGB },
+// 100% (1/1) handles 7
+/* 29 */ { MouriMapCrosstalkAndChunk16x16(effectManager),   DrawTypeFlags::kNonAAFillRect,   kRGBA16F_1_D_SRGB },
+// 100% (1/1) handles 6
+/* 30 */ { MouriMapChunk8x8Effect(effectManager),           DrawTypeFlags::kNonAAFillRect,   kRGBA16F_1_D },
+// 100% (2/2) handles 55, 56
+/* 31 */ { KawaseBlurLowSrcSrcOver(effectManager),          DrawTypeFlags::kNonAAFillRect,   kRGBA_1_D },
+// 100% (1/1) handles 54
+/* 32 */ { KawaseBlurHighSrc(effectManager),                DrawTypeFlags::kNonAAFillRect,   kRGBA_1_D },
+// 100% (1/1) handles 52
+/* 33 */ { BlurFilterMix(effectManager),                    DrawTypeFlags::kNonAAFillRect,   kRGBA_1_D },
+
+// These two are solid colors drawn w/ a LinearEffect
+
+// 100% (1/1) handles 4
+/* 34 */ { LinearEffect(kUNKNOWN__SRGB__false__UNKNOWN__Shader,
+                        ChildType::kSolidColor,
+                        SkBlendMode::kSrcOver),
+           DrawTypeFlags::kNonAAFillRect,
+           kRGBA16F_1_D_SRGB },
+// 100% (1/1) handles 57
+/* 35 */ { LinearEffect(kBT2020_ITU_PQ__BT2020__false__UNKNOWN__Shader,
+                        ChildType::kSolidColor,
+                        SkBlendMode::kSrc),
+           DrawTypeFlags::kNonAAFillRect,
+           kRGBA_1_D_SRGB },
+
+// 100% (1/1) handles 2
+/* 36 */ { LinearEffect(kUNKNOWN__SRGB__false__UNKNOWN__Shader,
+                        ChildType::kHWTexture,
+                        SkBlendMode::kSrcOver),
+           DrawTypeFlags::kNonAAFillRect,
+           kRGBA16F_1_D_SRGB },
+
+// These next two only differ by dst surface
+
+// 100% (1/1) handles 27
+/* 37 */ { LinearEffect(k0x188a0000__DISPLAY_P3__false__0x90a0000__Shader,
+                        ChildType::kHWTexture,
+                        SkBlendMode::kSrcOver),
+           DrawTypeFlags::kAnalyticRRect,
+           kRGBA_1_D_SRGB },
+// 50% (1/2) handles 67 - due to the w/o msaa load variants not being used
+/* 38 */ { LinearEffect(k0x188a0000__DISPLAY_P3__false__0x90a0000__Shader,
+                        ChildType::kHWTexture,
+                        SkBlendMode::kSrcOver),
+           DrawTypeFlags::kAnalyticRRect,
+           kRGBA_4_DS_SRGB },
+
+// These next two are the same as the above two but w/ transparent paints
+
+// 100% (1/1) handles 11
+/* 39 */ { LinearEffect(k0x188a0000__DISPLAY_P3__false__0x90a0000__Shader,
+                        ChildType::kHWTexture,
+                        SkBlendMode::kSrcOver,
+                        /* paintColorIsOpaque= */ false),
+           DrawTypeFlags::kAnalyticRRect,
+           kRGBA_1_D_SRGB },
+// 50% (1/2) handlers 65 - due to the w/o msaa load variants not being used
+/* 40 */ { LinearEffect(k0x188a0000__DISPLAY_P3__false__0x90a0000__Shader,
+                        ChildType::kHWTexture,
+                        SkBlendMode::kSrcOver,
+                        /* paintColorIsOpaque= */ false),
+           DrawTypeFlags::kAnalyticRRect,
+           kRGBA_4_DS_SRGB },
+
+// The next 3 have a RE_LinearEffect and a MatrixFilter along w/ different ancillary additions
+// 100% (1/1) handles 20
+/* 41 */ { LinearEffect(k0x188a0000__DISPLAY_P3__false__0x90a0000__Shader,
+                        ChildType::kHWTexture,
+                        SkBlendMode::kSrcOver,
+                        /* paintColorIsOpaque= */ true,
+                        /* matrixColorFilter= */ true),
+           DrawTypeFlags::kAnalyticRRect,
+           kRGBA_1_D_SRGB },
+// 100% (1/1) handles 13
+/* 42 */ { LinearEffect(k0x188a0000__DISPLAY_P3__false__0x90a0000__Shader,
+                        ChildType::kHWTexture,
+                        SkBlendMode::kSrcOver,
+                        /* paintColorIsOpaque= */ false,
+                        /* matrixColorFilter= */ true),
+           DrawTypeFlags::kAnalyticRRect,
+           kRGBA_1_D_SRGB },
+// 100% (1/1) handles 18
+/* 43 */ { LinearEffect(k0x188a0000__DISPLAY_P3__false__0x90a0000__Shader,
+                        ChildType::kHWTexture,
+                        SkBlendMode::kSrcOver,
+                        /* paintColorIsOpaque= */ true,
+                        /* matrixColorFilter= */ true,
+                        /* dither= */ true),
+           DrawTypeFlags::kAnalyticRRect,
+           kRGBA_1_D_SRGB },
+
+// 100% (2/2) handles 26 50
+/* 44 */ { ImagePremulYCbCr238Srcover(),       kRRectAndNonAARect,              kRGBA_1_D },
+// 100% (1/1) handles 49
+/* 45 */ { ImagePremulYCbCr240Srcover(),       DrawTypeFlags::kNonAAFillRect,   kRGBA_1_D },
+// 50% (1/2) handles 76
+/* 46 */ { ImagePremulYCbCr240Srcover(),       DrawTypeFlags::kNonAAFillRect,   kRGBA_4_DS },
+// 50% (1/2) handles 70
+/* 47 */ { TransparentPaintImagePremulYCbCr240Srcover(), DrawTypeFlags::kNonAAFillRect,kRGBA_4_DS },
+// 100% (1/1) handles 8
+/* 48 */ { MouriMapCrosstalkAndChunk16x16YCbCr247(effectManager),DrawTypeFlags::kNonAAFillRect,kRGBA16F_1_D_SRGB },
+
+// The next 2 have the same PaintOptions but different destination surfaces
+
+// 100% (2/2) handles 21 40
+/* 49 */ { LinearEffect(kBT2020_ITU_PQ__BT2020__false__UNKNOWN__Shader,
+                        ChildType::kHWTextureYCbCr247,
+                        SkBlendMode::kSrcOver,
+                        /* paintColorIsOpaque= */ true,
+                        /* matrixColorFilter= */ false,
+                        /* dither= */ true),
+           kRRectAndNonAARect,
+           kRGBA_1_D_SRGB },
+
+// 100% (1/1) handles 82
+/* 50 */ { LinearEffect(kBT2020_ITU_PQ__BT2020__false__UNKNOWN__Shader,
+                        ChildType::kHWTextureYCbCr247,
+                        SkBlendMode::kSrcOver,
+                        /* paintColorIsOpaque= */ true,
+                        /* matrixColorFilter= */ false,
+                        /* dither= */ true),
+           DrawTypeFlags::kNonAAFillRect,
+           kRGBA_4_DS_SRGB },
+    };
+    // clang-format on
+
+    ALOGD("Pipeline precompilation started");
+
+    for (size_t i = 0; i < std::size(precompileCases); i++) {
+        const PrecompileSettings& settings = precompileCases[i];
+        Precompile(precompileContext.get(), settings.fPaintOptions, settings.fDrawTypeFlags,
+                   {&settings.fRenderPassProps, 1});
+    }
+
+    ALOGD("Pipeline precompilation finished");
+}
+
+} // namespace android::renderengine::skia
\ No newline at end of file
diff --git a/libs/renderengine/skia/compat/GraphitePipelineManager.h b/libs/renderengine/skia/compat/GraphitePipelineManager.h
new file mode 100644
index 0000000000..300d5e6f6c
--- /dev/null
+++ b/libs/renderengine/skia/compat/GraphitePipelineManager.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <include/gpu/graphite/PrecompileContext.h>
+
+namespace android::renderengine::skia {
+
+using namespace skgpu;
+
+class RuntimeEffectManager;
+
+/**
+ * Handles precompiling the underlying Skia rendering pipelines needed for RenderEngine's drawing
+ * operations.
+ *
+ * The precompilation settings that RenderEngine gives to Skia that control which pipelines get
+ * precompiled are maintained in upstream Skia, where iteration and testing is easier. They are then
+ * copied here, where slight modifications may be needed (e.g. feeding in the effectManager).
+ *
+ * Note: this class may handle other minor Skia pipeline management tasks in the future, such as
+ * providing a callback for Skia to tell RenderEngine the label of a pipeline that was missed during
+ * precompilation.
+ */
+class GraphitePipelineManager {
+public:
+    // Should be invoked on a thread dedicated to precompilation, as execution may take several
+    // seconds. Drawing work may occur in parallel, as precompilation and drawing operations are
+    // thread-safe in Graphite.
+    static void PrecompilePipelines(std::unique_ptr<graphite::PrecompileContext> precompileContext,
+                                    RuntimeEffectManager& effectManager);
+};
+
+} // namespace android::renderengine::skia
diff --git a/libs/renderengine/skia/compat/SkiaGpuContext.h b/libs/renderengine/skia/compat/SkiaGpuContext.h
index 0bd8283987..09afba799f 100644
--- a/libs/renderengine/skia/compat/SkiaGpuContext.h
+++ b/libs/renderengine/skia/compat/SkiaGpuContext.h
@@ -21,6 +21,7 @@
 
 #include <include/core/SkSurface.h>
 #include <include/gpu/ganesh/GrDirectContext.h>
+#include <include/gpu/ganesh/GrContextOptions.h>
 #include <include/gpu/ganesh/gl/GrGLInterface.h>
 #include <include/gpu/graphite/Context.h>
 #include <include/gpu/vk/VulkanBackendContext.h>
diff --git a/libs/renderengine/skia/filters/BlurFilter.cpp b/libs/renderengine/skia/filters/BlurFilter.cpp
index 8edf98eb89..5b8724b832 100644
--- a/libs/renderengine/skia/filters/BlurFilter.cpp
+++ b/libs/renderengine/skia/filters/BlurFilter.cpp
@@ -28,36 +28,37 @@
 #include <common/trace.h>
 #include <log/log.h>
 
+#include "RuntimeEffectManager.h"
+
 namespace android {
 namespace renderengine {
 namespace skia {
 
-static sk_sp<SkRuntimeEffect> createMixEffect() {
-    SkString mixString(R"(
-        uniform shader blurredInput;
-        uniform shader originalInput;
-        uniform float mixFactor;
-
-        half4 main(float2 xy) {
-            return half4(mix(originalInput.eval(xy), blurredInput.eval(xy), mixFactor)).rgb1;
-        }
-    )");
+static const SkString kMixString(R"(
+    uniform shader blurredInput;
+    uniform shader originalInput;
+    uniform float mixFactor;
 
-    auto [mixEffect, mixError] = SkRuntimeEffect::MakeForShader(mixString);
-    if (!mixEffect) {
-        LOG_ALWAYS_FATAL("RuntimeShader error: %s", mixError.c_str());
+    half4 main(float2 xy) {
+        return half4(mix(originalInput.eval(xy), blurredInput.eval(xy), mixFactor)).rgb1;
     }
-    return mixEffect;
-}
+)");
 
 static SkMatrix getShaderTransform(const SkCanvas* canvas, const SkRect& blurRect,
-                                   const float scale) {
+                                   const float scale, const float zoomScale) {
     // 1. Apply the blur shader matrix, which scales up the blurred surface to its real size
     auto matrix = SkMatrix::Scale(scale, scale);
     // 2. Since the blurred surface has the size of the layer, we align it with the
     // top left corner of the layer position.
     matrix.postConcat(SkMatrix::Translate(blurRect.fLeft, blurRect.fTop));
-    // 3. Finally, apply the inverse canvas matrix. The snapshot made in the BlurFilter is in the
+    // 3. Apply the "zoom" effect as an extra scale + translate around the center of the blur.
+    if (zoomScale != 1.0f) {
+        matrix.postScale(zoomScale, zoomScale);
+        matrix.postTranslate(
+                blurRect.width() * (1 - zoomScale) / 2.0f,
+                blurRect.height() * (1 - zoomScale) / 2.0f);
+    }
+    // 4. Finally, apply the inverse canvas matrix. The snapshot made in the BlurFilter is in the
     // original surface orientation. The inverse matrix has to be applied to align the blur
     // surface with the current orientation/position of the canvas.
     SkMatrix drawInverse;
@@ -67,16 +68,23 @@ static SkMatrix getShaderTransform(const SkCanvas* canvas, const SkRect& blurRec
     return matrix;
 }
 
-BlurFilter::BlurFilter(const float maxCrossFadeRadius)
+BlurFilter::BlurFilter(RuntimeEffectManager& effectManager, const float maxCrossFadeRadius)
       : mMaxCrossFadeRadius(maxCrossFadeRadius),
-        mMixEffect(maxCrossFadeRadius > 0 ? createMixEffect() : nullptr) {}
+        mMixEffect(
+                maxCrossFadeRadius > 0
+                        ? effectManager.createAndStoreRuntimeEffect(RuntimeEffectManager::KnownId::
+                                                                            kBlurFilter_MixEffect,
+                                                                    "BlurFilter_MixEffect",
+                                                                    kMixString)
+                        : nullptr) {}
 
 float BlurFilter::getMaxCrossFadeRadius() const {
     return mMaxCrossFadeRadius;
 }
 
 void BlurFilter::drawBlurRegion(SkCanvas* canvas, const SkRRect& effectRegion,
-                                const uint32_t blurRadius, const float blurAlpha,
+                                const uint32_t blurRadius, const float zoomScale,
+                                const float blurAlpha,
                                 const SkRect& blurRect, sk_sp<SkImage> blurredImage,
                                 sk_sp<SkImage> input) {
     SFTRACE_CALL();
@@ -84,9 +92,10 @@ void BlurFilter::drawBlurRegion(SkCanvas* canvas, const SkRRect& effectRegion,
     SkPaint paint;
     paint.setAlphaf(blurAlpha);
 
-    const auto blurMatrix = getShaderTransform(canvas, blurRect, kInverseInputScale);
+    auto blurMatrix = getShaderTransform(canvas, blurRect, kInverseInputScale, zoomScale);
+
     SkSamplingOptions linearSampling(SkFilterMode::kLinear, SkMipmapMode::kNone);
-    const auto blurShader = blurredImage->makeShader(SkTileMode::kClamp, SkTileMode::kClamp,
+    const auto blurShader = blurredImage->makeShader(SkTileMode::kMirror, SkTileMode::kMirror,
                                                      linearSampling, &blurMatrix);
 
     if (blurRadius < mMaxCrossFadeRadius) {
@@ -98,12 +107,19 @@ void BlurFilter::drawBlurRegion(SkCanvas* canvas, const SkRRect& effectRegion,
         if (!canvas->getTotalMatrix().invert(&inputMatrix)) {
             ALOGE("matrix was unable to be inverted");
         }
+        if (zoomScale != 1.0f) {
+            inputMatrix.preTranslate(
+                    blurRect.width() * (1 - zoomScale) / 2.0f,
+                    blurRect.height() * (1 - zoomScale) / 2.0f);
+            inputMatrix.preScale(zoomScale, zoomScale);
+        }
 
         SkRuntimeShaderBuilder blurBuilder(mMixEffect);
         blurBuilder.child("blurredInput") = blurShader;
         blurBuilder.child("originalInput") =
-                input->makeShader(SkTileMode::kClamp, SkTileMode::kClamp, linearSampling,
+                input->makeShader(SkTileMode::kMirror, SkTileMode::kMirror, linearSampling,
                                   inputMatrix);
+
         blurBuilder.uniform("mixFactor") = blurRadius / mMaxCrossFadeRadius;
 
         paint.setShader(blurBuilder.makeShader());
diff --git a/libs/renderengine/skia/filters/BlurFilter.h b/libs/renderengine/skia/filters/BlurFilter.h
index 180c92262f..68924d979e 100644
--- a/libs/renderengine/skia/filters/BlurFilter.h
+++ b/libs/renderengine/skia/filters/BlurFilter.h
@@ -22,6 +22,7 @@
 #include <SkSurface.h>
 
 #include "../compat/SkiaGpuContext.h"
+#include "RuntimeEffectManager.h"
 
 using namespace std;
 
@@ -36,7 +37,7 @@ public:
     // Downsample scale factor used to improve performance
     static constexpr float kInverseInputScale = 1.0f / kInputScale;
 
-    explicit BlurFilter(float maxCrossFadeRadius = 10.0f);
+    explicit BlurFilter(RuntimeEffectManager& effectManager, float maxCrossFadeRadius = 10.0f);
     virtual ~BlurFilter(){}
 
     // Execute blur, saving it to a texture
@@ -55,9 +56,9 @@ public:
      * @param input original unblurred input that is used to crossfade with the blurredImage
      */
     void drawBlurRegion(SkCanvas* canvas, const SkRRect& effectRegion,
-                                const uint32_t blurRadius, const float blurAlpha,
-                                const SkRect& blurRect, sk_sp<SkImage> blurredImage,
-                                sk_sp<SkImage> input);
+                                const uint32_t blurRadius, const float zoomScale,
+                                const float blurAlpha, const SkRect& blurRect,
+                                sk_sp<SkImage> blurredImage, sk_sp<SkImage> input);
 
     float getMaxCrossFadeRadius() const;
 
diff --git a/libs/renderengine/skia/filters/EdgeExtensionShaderFactory.cpp b/libs/renderengine/skia/filters/EdgeExtensionShaderFactory.cpp
index f007427f1c..11dddae354 100644
--- a/libs/renderengine/skia/filters/EdgeExtensionShaderFactory.cpp
+++ b/libs/renderengine/skia/filters/EdgeExtensionShaderFactory.cpp
@@ -22,9 +22,11 @@
 #include <com_android_graphics_libgui_flags.h>
 #include "log/log_main.h"
 
+#include "RuntimeEffectManager.h"
+
 namespace android::renderengine::skia {
 
-static const SkString edgeShader = SkString(R"(
+static const SkString kEdgeShaderString = SkString(R"(
     uniform shader uContentTexture;
     uniform vec2 uImgSize;
 
@@ -57,22 +59,16 @@ static const SkString edgeShader = SkString(R"(
     }
 )");
 
-EdgeExtensionShaderFactory::EdgeExtensionShaderFactory() {
-    mResult = std::make_unique<SkRuntimeEffect::Result>(SkRuntimeEffect::MakeForShader(edgeShader));
-    LOG_ALWAYS_FATAL_IF(!mResult->errorText.isEmpty(),
-                        "EdgeExtensionShaderFactory compilation "
-                        "failed with an unexpected error: %s",
-                        mResult->errorText.c_str());
+EdgeExtensionShaderFactory::EdgeExtensionShaderFactory(RuntimeEffectManager& effectManager) {
+    mEffect = effectManager.createAndStoreRuntimeEffect(RuntimeEffectManager::KnownId::
+                                                                kEdgeExtensionEffect,
+                                                        "EdgeExtensionEffect", kEdgeShaderString);
 }
 
 sk_sp<SkShader> EdgeExtensionShaderFactory::createSkShader(const sk_sp<SkShader>& inputShader,
                                                            const LayerSettings& layer,
                                                            const SkRect& imageBounds) const {
-    LOG_ALWAYS_FATAL_IF(mResult == nullptr,
-                        "EdgeExtensionShaderFactory did not initialize mResult. "
-                        "This means that we unexpectedly applied the edge extension shader");
-
-    SkRuntimeShaderBuilder builder = SkRuntimeShaderBuilder(mResult->effect);
+    SkRuntimeShaderBuilder builder = SkRuntimeShaderBuilder(mEffect);
 
     builder.child("uContentTexture") = inputShader;
     if (imageBounds.isEmpty()) {
diff --git a/libs/renderengine/skia/filters/EdgeExtensionShaderFactory.h b/libs/renderengine/skia/filters/EdgeExtensionShaderFactory.h
index 17c6b9139f..dbfe0d0932 100644
--- a/libs/renderengine/skia/filters/EdgeExtensionShaderFactory.h
+++ b/libs/renderengine/skia/filters/EdgeExtensionShaderFactory.h
@@ -23,6 +23,8 @@
 #include <renderengine/LayerSettings.h>
 #include <ui/EdgeExtensionEffect.h>
 
+#include "RuntimeEffectManager.h"
+
 namespace android::renderengine::skia {
 
 /**
@@ -33,12 +35,12 @@ namespace android::renderengine::skia {
  */
 class EdgeExtensionShaderFactory {
 public:
-    EdgeExtensionShaderFactory();
+    EdgeExtensionShaderFactory(RuntimeEffectManager& effectManager);
 
     sk_sp<SkShader> createSkShader(const sk_sp<SkShader>& inputShader, const LayerSettings& layer,
                                    const SkRect& imageBounds) const;
 
 private:
-    std::unique_ptr<const SkRuntimeEffect::Result> mResult;
+    sk_sp<SkRuntimeEffect> mEffect;
 };
 } // namespace android::renderengine::skia
diff --git a/libs/renderengine/skia/filters/GainmapFactory.cpp b/libs/renderengine/skia/filters/GainmapFactory.cpp
index e4d4fe96f8..012bce87f0 100644
--- a/libs/renderengine/skia/filters/GainmapFactory.cpp
+++ b/libs/renderengine/skia/filters/GainmapFactory.cpp
@@ -18,19 +18,15 @@
 
 #include <log/log.h>
 
+#include "RuntimeEffectManager.h"
+
 namespace android {
 namespace renderengine {
 namespace skia {
 namespace {
 
-sk_sp<SkRuntimeEffect> makeEffect(const SkString& sksl) {
-    auto [effect, error] = SkRuntimeEffect::MakeForShader(sksl);
-    LOG_ALWAYS_FATAL_IF(!effect, "RuntimeShader error: %s", error.c_str());
-    return effect;
-}
-
 // Please refer to https://developer.android.com/media/platform/hdr-image-format#gain_map-generation
-static const SkString kGainmapShader = SkString(R"(
+static const SkString kGainmapShaderString = SkString(R"(
     uniform shader sdr;
     uniform shader hdr;
     uniform float mapMaxLog2;
@@ -56,7 +52,11 @@ static const SkString kGainmapShader = SkString(R"(
 
 const float INTERPOLATION_STRENGTH_VALUE = 0.7f;
 
-GainmapFactory::GainmapFactory() : mEffect(makeEffect(kGainmapShader)) {}
+GainmapFactory::GainmapFactory(RuntimeEffectManager& effectManager) {
+    mEffect =
+            effectManager.createAndStoreRuntimeEffect(RuntimeEffectManager::KnownId::kGainmapEffect,
+                                                      "GainmapEffect", kGainmapShaderString);
+}
 
 sk_sp<SkShader> GainmapFactory::createSkShader(const sk_sp<SkShader>& sdr,
                                                const sk_sp<SkShader>& hdr, float hdrSdrRatio) {
diff --git a/libs/renderengine/skia/filters/GainmapFactory.h b/libs/renderengine/skia/filters/GainmapFactory.h
index 7aea5e2195..b59f079d84 100644
--- a/libs/renderengine/skia/filters/GainmapFactory.h
+++ b/libs/renderengine/skia/filters/GainmapFactory.h
@@ -18,6 +18,8 @@
 #include <SkRuntimeEffect.h>
 #include <SkShader.h>
 
+#include "RuntimeEffectManager.h"
+
 namespace android {
 namespace renderengine {
 namespace skia {
@@ -30,7 +32,7 @@ namespace skia {
  */
 class GainmapFactory {
 public:
-    GainmapFactory();
+    GainmapFactory(RuntimeEffectManager& effectManager);
     // Generates the gainmap shader. The hdrSdrRatio is the max_content_boost in the UltraHDR
     // specification.
     sk_sp<SkShader> createSkShader(const sk_sp<SkShader>& sdr, const sk_sp<SkShader>& hdr,
diff --git a/libs/renderengine/skia/filters/GaussianBlurFilter.cpp b/libs/renderengine/skia/filters/GaussianBlurFilter.cpp
index b03ebe3353..42fc185533 100644
--- a/libs/renderengine/skia/filters/GaussianBlurFilter.cpp
+++ b/libs/renderengine/skia/filters/GaussianBlurFilter.cpp
@@ -32,6 +32,8 @@
 #include <log/log.h>
 #include "include/gpu/GpuTypes.h" // from Skia
 
+#include "RuntimeEffectManager.h"
+
 namespace android {
 namespace renderengine {
 namespace skia {
@@ -40,7 +42,8 @@ namespace skia {
 // "high quality" mode, in SkBlurMask::Blur() (1 / sqrt(3)).
 static const float BLUR_SIGMA_SCALE = 0.57735f;
 
-GaussianBlurFilter::GaussianBlurFilter(): BlurFilter(/* maxCrossFadeRadius= */ 0.0f) {}
+GaussianBlurFilter::GaussianBlurFilter(RuntimeEffectManager& effectManager)
+      : BlurFilter(effectManager, /* maxCrossFadeRadius= */ 0.0f) {}
 
 sk_sp<SkImage> GaussianBlurFilter::generate(SkiaGpuContext* context, const uint32_t blurRadius,
                                             const sk_sp<SkImage> input,
diff --git a/libs/renderengine/skia/filters/GaussianBlurFilter.h b/libs/renderengine/skia/filters/GaussianBlurFilter.h
index 878ab21b36..4056025cd4 100644
--- a/libs/renderengine/skia/filters/GaussianBlurFilter.h
+++ b/libs/renderengine/skia/filters/GaussianBlurFilter.h
@@ -22,6 +22,8 @@
 #include <SkRuntimeEffect.h>
 #include <SkSurface.h>
 
+#include "RuntimeEffectManager.h"
+
 using namespace std;
 
 namespace android {
@@ -33,7 +35,7 @@ namespace skia {
  */
 class GaussianBlurFilter: public BlurFilter {
 public:
-    explicit GaussianBlurFilter();
+    explicit GaussianBlurFilter(RuntimeEffectManager& effectManager);
     virtual ~GaussianBlurFilter(){}
 
     // Execute blur, saving it to a texture
diff --git a/libs/renderengine/skia/filters/KawaseBlurDualFilter.cpp b/libs/renderengine/skia/filters/KawaseBlurDualFilter.cpp
index ff96b08283..f0efaef6e4 100644
--- a/libs/renderengine/skia/filters/KawaseBlurDualFilter.cpp
+++ b/libs/renderengine/skia/filters/KawaseBlurDualFilter.cpp
@@ -34,14 +34,17 @@
 #include <log/log.h>
 #include <utils/Trace.h>
 
+#include "RuntimeEffectManager.h"
+
 namespace android {
 namespace renderengine {
 namespace skia {
 
-KawaseBlurDualFilter::KawaseBlurDualFilter() : BlurFilter() {
+KawaseBlurDualFilter::KawaseBlurDualFilter(RuntimeEffectManager& effectManager)
+      : BlurFilter(effectManager) {
     // A shader to sample each vertex of a square, plus the original fragment coordinate,
     // using a total of 5 samples.
-    SkString lowSampleBlurString(R"(
+    const SkString kLowSampleBlurString(R"(
         uniform shader child;
         uniform float in_blurOffset;
         uniform float in_crossFade;
@@ -66,7 +69,7 @@ KawaseBlurDualFilter::KawaseBlurDualFilter() : BlurFilter() {
 
     // A shader to sample each vertex of a unit regular heptagon, plus the original fragment
     // coordinate, using a total of 8 samples.
-    SkString highSampleBlurString(R"(
+    const SkString kHighSampleBlurString(R"(
         uniform shader child;
         uniform float in_blurOffset;
 
@@ -93,12 +96,18 @@ KawaseBlurDualFilter::KawaseBlurDualFilter() : BlurFilter() {
         }
     )");
 
-    auto [lowSampleBlurEffect, error] = SkRuntimeEffect::MakeForShader(lowSampleBlurString);
-    auto [highSampleBlurEffect, error2] = SkRuntimeEffect::MakeForShader(highSampleBlurString);
-    LOG_ALWAYS_FATAL_IF(!lowSampleBlurEffect, "RuntimeShader error: %s", error.c_str());
-    LOG_ALWAYS_FATAL_IF(!highSampleBlurEffect, "RuntimeShader error: %s", error2.c_str());
-    mLowSampleBlurEffect = std::move(lowSampleBlurEffect);
-    mHighSampleBlurEffect = std::move(highSampleBlurEffect);
+    mLowSampleBlurEffect =
+            effectManager
+                    .createAndStoreRuntimeEffect(RuntimeEffectManager::KnownId::
+                                                         kKawaseBlurDualFilter_LowSampleBlurEffect,
+                                                 "KawaseBlurDualFilter_LowSampleBlurEffect",
+                                                 kLowSampleBlurString);
+    mHighSampleBlurEffect =
+            effectManager
+                    .createAndStoreRuntimeEffect(RuntimeEffectManager::KnownId::
+                                                         kKawaseBlurDualFilter_HighSampleBlurEffect,
+                                                 "KawaseBlurDualFilter_HighSampleBlurEffect",
+                                                 kHighSampleBlurString);
 }
 
 void KawaseBlurDualFilter::blurInto(const sk_sp<SkSurface>& drawSurface,
diff --git a/libs/renderengine/skia/filters/KawaseBlurDualFilter.h b/libs/renderengine/skia/filters/KawaseBlurDualFilter.h
index 5efda35376..985f5e347f 100644
--- a/libs/renderengine/skia/filters/KawaseBlurDualFilter.h
+++ b/libs/renderengine/skia/filters/KawaseBlurDualFilter.h
@@ -22,6 +22,8 @@
 #include <SkSurface.h>
 #include "BlurFilter.h"
 
+#include "RuntimeEffectManager.h"
+
 namespace android {
 namespace renderengine {
 namespace skia {
@@ -33,7 +35,7 @@ namespace skia {
  */
 class KawaseBlurDualFilter : public BlurFilter {
 public:
-    explicit KawaseBlurDualFilter();
+    explicit KawaseBlurDualFilter(RuntimeEffectManager& effectManager);
     virtual ~KawaseBlurDualFilter() {}
 
     // Execute blur, saving it to a texture
diff --git a/libs/renderengine/skia/filters/KawaseBlurFilter.cpp b/libs/renderengine/skia/filters/KawaseBlurFilter.cpp
index f71a63d591..8e09fad4a4 100644
--- a/libs/renderengine/skia/filters/KawaseBlurFilter.cpp
+++ b/libs/renderengine/skia/filters/KawaseBlurFilter.cpp
@@ -34,11 +34,14 @@
 #include <include/gpu/ganesh/SkSurfaceGanesh.h>
 #include <log/log.h>
 
+#include "RuntimeEffectManager.h"
+
 namespace android {
 namespace renderengine {
 namespace skia {
 
-KawaseBlurFilter::KawaseBlurFilter(): BlurFilter() {
+KawaseBlurFilter::KawaseBlurFilter(RuntimeEffectManager& effectManager)
+      : BlurFilter(effectManager) {
     SkString blurString(
         "uniform shader child;"
         "uniform float in_blurOffset;"
@@ -52,11 +55,10 @@ KawaseBlurFilter::KawaseBlurFilter(): BlurFilter() {
             "return half4(c.rgb * 0.2, 1.0);"
         "}");
 
-    auto [blurEffect, error] = SkRuntimeEffect::MakeForShader(blurString);
-    if (!blurEffect) {
-        LOG_ALWAYS_FATAL("RuntimeShader error: %s", error.c_str());
-    }
-    mBlurEffect = std::move(blurEffect);
+    mBlurEffect =
+            effectManager
+                    .createAndStoreRuntimeEffect(RuntimeEffectManager::KnownId::kKawaseBlurEffect,
+                                                 "KawaseBlurEffect", blurString);
 }
 
 // Draws the given runtime shader on a GPU (Ganesh) surface and returns the result as an
diff --git a/libs/renderengine/skia/filters/KawaseBlurFilter.h b/libs/renderengine/skia/filters/KawaseBlurFilter.h
index 429a5378a3..8d8b9655a2 100644
--- a/libs/renderengine/skia/filters/KawaseBlurFilter.h
+++ b/libs/renderengine/skia/filters/KawaseBlurFilter.h
@@ -22,6 +22,8 @@
 #include <SkRuntimeEffect.h>
 #include <SkSurface.h>
 
+#include "RuntimeEffectManager.h"
+
 using namespace std;
 
 namespace android {
@@ -38,7 +40,7 @@ public:
     // Maximum number of render passes
     static constexpr uint32_t kMaxPasses = 4;
 
-    explicit KawaseBlurFilter();
+    explicit KawaseBlurFilter(RuntimeEffectManager& effectManager);
     virtual ~KawaseBlurFilter(){}
 
     // Execute blur, saving it to a texture
diff --git a/libs/renderengine/skia/filters/LinearEffect.cpp b/libs/renderengine/skia/filters/LinearEffect.cpp
deleted file mode 100644
index 3bc3564f4c..0000000000
--- a/libs/renderengine/skia/filters/LinearEffect.cpp
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright 2020 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "LinearEffect.h"
-
-#define ATRACE_TAG ATRACE_TAG_GRAPHICS
-
-#include <SkString.h>
-#include <common/trace.h>
-#include <log/log.h>
-#include <shaders/shaders.h>
-
-#include <math/mat4.h>
-
-namespace android {
-namespace renderengine {
-namespace skia {
-
-sk_sp<SkRuntimeEffect> buildRuntimeEffect(const shaders::LinearEffect& linearEffect) {
-    SFTRACE_CALL();
-    SkString shaderString = SkString(shaders::buildLinearEffectSkSL(linearEffect));
-
-    auto [shader, error] = SkRuntimeEffect::MakeForShader(shaderString);
-    if (!shader) {
-        LOG_ALWAYS_FATAL("LinearColorFilter construction error: %s", error.c_str());
-    }
-    return shader;
-}
-
-sk_sp<SkShader> createLinearEffectShader(
-        sk_sp<SkShader> shader, const shaders::LinearEffect& linearEffect,
-        sk_sp<SkRuntimeEffect> runtimeEffect, const mat4& colorTransform, float maxDisplayLuminance,
-        float currentDisplayLuminanceNits, float maxLuminance, AHardwareBuffer* buffer,
-        aidl::android::hardware::graphics::composer3::RenderIntent renderIntent) {
-    SFTRACE_CALL();
-    SkRuntimeShaderBuilder effectBuilder(runtimeEffect);
-
-    effectBuilder.child("child") = shader;
-
-    const auto uniforms =
-            shaders::buildLinearEffectUniforms(linearEffect, colorTransform, maxDisplayLuminance,
-                                               currentDisplayLuminanceNits, maxLuminance, buffer,
-                                               renderIntent);
-
-    for (const auto& uniform : uniforms) {
-        effectBuilder.uniform(uniform.name.c_str()).set(uniform.value.data(), uniform.value.size());
-    }
-
-    return effectBuilder.makeShader();
-}
-
-} // namespace skia
-} // namespace renderengine
-} // namespace android
diff --git a/libs/renderengine/skia/filters/LinearEffect.h b/libs/renderengine/skia/filters/LinearEffect.h
deleted file mode 100644
index 3c66c513d9..0000000000
--- a/libs/renderengine/skia/filters/LinearEffect.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright 2020 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-
-#include <math/mat4.h>
-
-#include <optional>
-
-#include <shaders/shaders.h>
-#include "SkRuntimeEffect.h"
-#include "SkShader.h"
-#include "ui/GraphicTypes.h"
-
-namespace android {
-namespace renderengine {
-namespace skia {
-
-sk_sp<SkRuntimeEffect> buildRuntimeEffect(const shaders::LinearEffect& linearEffect);
-
-// Generates a shader resulting from applying the a linear effect created from
-// LinearEffectArgs::buildEffect to an inputShader.
-// Optionally, a color transform may also be provided, which combines with the
-// matrix transforming from linear XYZ to linear RGB immediately before OETF.
-// We also provide additional HDR metadata upon creating the shader:
-// * The max display luminance is the max luminance of the physical display in nits
-// * The current luminance of the physical display in nits
-// * The max luminance is provided as the max luminance for the buffer, either from the SMPTE 2086
-// or as the max light level from the CTA 861.3 standard.
-// * An AHardwareBuffer for implementations that support gralloc4 metadata for
-// communicating any HDR metadata.
-// * A RenderIntent that communicates the downstream renderintent for a physical display, for image
-// quality compensation.
-sk_sp<SkShader> createLinearEffectShader(
-        sk_sp<SkShader> inputShader, const shaders::LinearEffect& linearEffect,
-        sk_sp<SkRuntimeEffect> runtimeEffect, const mat4& colorTransform, float maxDisplayLuminance,
-        float currentDisplayLuminanceNits, float maxLuminance, AHardwareBuffer* buffer,
-        aidl::android::hardware::graphics::composer3::RenderIntent renderIntent);
-} // namespace skia
-} // namespace renderengine
-} // namespace android
diff --git a/libs/renderengine/skia/filters/LutShader.cpp b/libs/renderengine/skia/filters/LutShader.cpp
index 6a577ff41f..80fdc481b1 100644
--- a/libs/renderengine/skia/filters/LutShader.cpp
+++ b/libs/renderengine/skia/filters/LutShader.cpp
@@ -19,11 +19,13 @@
 #include <SkTileMode.h>
 #include <common/trace.h>
 #include <cutils/ashmem.h>
+#include <include/core/SkColorSpace.h>
 #include <math/half.h>
 #include <sys/mman.h>
 #include <ui/ColorSpace.h>
 
-#include "include/core/SkColorSpace.h"
+#include "RuntimeEffectManager.h"
+#include "skia/ColorSpaces.h"
 
 using aidl::android::hardware::graphics::composer3::LutProperties;
 
@@ -44,7 +46,7 @@ static const SkString kShader = SkString(R"(
 
     vec4 main(vec2 xy) {
         float4 rgba = image.eval(xy);
-        float3 linear = toLinearSrgb(rgba.rgb) * normalizeScalar;
+        float3 linear = rgba.rgb * normalizeScalar;
         if (dimension == 1) {
             // RGB
             if (key == 0) {
@@ -70,52 +72,68 @@ static const SkString kShader = SkString(R"(
             }
         } else if (dimension == 3) {
             if (key == 0) {
-                float tx = linear.r * float(size - 1);
-                float ty = linear.g * float(size - 1);
-                float tz = linear.b * float(size - 1);
+                // index
+                float x = linear.r * float(size - 1);
+                float y = linear.g * float(size - 1);
+                float z = linear.b * float(size - 1);
 
-                // calculate lower and upper bounds for each dimension
-                int x = int(tx);
-                int y = int(ty);
-                int z = int(tz);
+                // lower bound
+                float x0 = floor(x);
+                float y0 = floor(y);
+                float z0 = floor(z);
 
-                int i000 = x + y * size + z * size * size;
-                int i100 = i000 + 1;
-                int i010 = i000 + size;
-                int i110 = i000 + size + 1;
-                int i001 = i000 + size * size;
-                int i101 = i000 + size * size + 1;
-                int i011 = i000 + size * size + size;
-                int i111 = i000 + size * size + size + 1;
+                // upper bound
+                float x1 = min(x0 + 1.0, float(size - 1));
+                float y1 = min(y0 + 1.0, float(size - 1));
+                float z1 = min(z0 + 1.0, float(size - 1));
 
-                // get 1d normalized indices
-                float c000 = float(i000) / float(size * size * size);
-                float c100 = float(i100) / float(size * size * size);
-                float c010 = float(i010) / float(size * size * size);
-                float c110 = float(i110) / float(size * size * size);
-                float c001 = float(i001) / float(size * size * size);
-                float c101 = float(i101) / float(size * size * size);
-                float c011 = float(i011) / float(size * size * size);
-                float c111 = float(i111) / float(size * size * size);
+                // weight
+                // if the value reaches to upper bound, x1 == x0, then weight is 0
+                // if no, x1 - x0 should always be 1.0
+                float tx = x1 == x0 ? 0 : x - x0;
+                float ty = y1 == y0 ? 0 : y - y0;
+                float tz = z1 == z0 ? 0 : z - z0;
 
-                //TODO(b/377984618): support Tetrahedral interpolation
+                // get indices
+                // this follows 3d flatten policy described in API/AIDL interface
+                // i.e., `FLAT[z + DEPTH * (y + HEIGHT * x)] = ORIGINAL[x][y][z]`
+                float i000 = z0 + (y0 * float(size)) + (x0 * float(size) * float(size));
+                float i001 = z1 + (y0 * float(size)) + (x0 * float(size) * float(size));
+                float i010 = z0 + (y1 * float(size)) + (x0 * float(size) * float(size));
+                float i011 = z1 + (y1 * float(size)) + (x0 * float(size) * float(size));
+                float i100 = z0 + (y0 * float(size)) + (x1 * float(size) * float(size));
+                float i101 = z1 + (y0 * float(size)) + (x1 * float(size) * float(size));
+                float i110 = z0 + (y1 * float(size)) + (x1 * float(size) * float(size));
+                float i111 = z1 + (y1 * float(size)) + (x1 * float(size) * float(size));
+
+                // TODO(b/377984618): support Tetrahedral interpolation
                 // perform trilinear interpolation
-                float3 c00 = mix(lut.eval(vec2(c000, 0.0) + 0.5).rgb,
-                                 lut.eval(vec2(c100, 0.0) + 0.5).rgb, linear.r);
-                float3 c01 = mix(lut.eval(vec2(c001, 0.0) + 0.5).rgb,
-                                 lut.eval(vec2(c101, 0.0) + 0.5).rgb, linear.r);
-                float3 c10 = mix(lut.eval(vec2(c010, 0.0) + 0.5).rgb,
-                                 lut.eval(vec2(c110, 0.0) + 0.5).rgb, linear.r);
-                float3 c11 = mix(lut.eval(vec2(c011, 0.0) + 0.5).rgb,
-                                 lut.eval(vec2(c111, 0.0) + 0.5).rgb, linear.r);
+                // see https://en.wikipedia.org/wiki/Trilinear_interpolation
+                float3 c000 = lut.eval(vec2(i000, 0.0) + 0.5).rgb;
+                float3 c001 = lut.eval(vec2(i001, 0.0) + 0.5).rgb;
+                float3 c010 = lut.eval(vec2(i010, 0.0) + 0.5).rgb;
+                float3 c011 = lut.eval(vec2(i011, 0.0) + 0.5).rgb;
+                float3 c100 = lut.eval(vec2(i100, 0.0) + 0.5).rgb;
+                float3 c101 = lut.eval(vec2(i101, 0.0) + 0.5).rgb;
+                float3 c110 = lut.eval(vec2(i110, 0.0) + 0.5).rgb;
+                float3 c111 = lut.eval(vec2(i111, 0.0) + 0.5).rgb;
+
+                // mix(x, y, a) = x * (1 - a) + y * a
+                // interpolate along the z-axis
+                float3 c00 = mix(c000, c001, tz);
+                float3 c01 = mix(c010, c011, tz);
+                float3 c10 = mix(c100, c101, tz);
+                float3 c11 = mix(c110, c111, tz);
 
-                float3 c0 = mix(c00, c10, linear.g);
-                float3 c1 = mix(c01, c11, linear.g);
+                // interpolate along the y-axis
+                float3 c0 = mix(c00, c01, ty);
+                float3 c1 = mix(c10, c11, ty);
 
-                linear = mix(c0, c1, linear.b);
+                // interpolate along the x-axis
+                linear = mix(c0, c1, tx);
             }
         }
-        return float4(fromLinearSrgb(linear), rgba.a);
+        return float4(linear, rgba.a);
     })");
 
 // same as shader::toColorSpace function
@@ -143,6 +161,32 @@ static ColorSpace toColorSpace(ui::Dataspace dataspace) {
     }
 }
 
+static float computeHlgScale() {
+    static constexpr auto input = 0.7498773651;
+    static constexpr auto a = 0.17883277;
+    static constexpr auto b = 1 - 4 * a;
+    const static auto c = 0.5 - a * std::log(4 * a);
+    // Returns about 265 nits -- After the typical HLG OOTF this would map to 203 nits under ideal
+    // conditions.
+    return (exp((input - c) / a) + b) / 12;
+}
+
+static float computePqScale() {
+    static constexpr auto input = 0.58068888104;
+    static constexpr auto m1 = 0.1593017578125;
+    static constexpr auto m2 = 78.84375;
+    static constexpr auto c1 = 0.8359375;
+    static constexpr auto c2 = 18.8515625;
+    static constexpr auto c3 = 18.6875;
+    // This should essetially return 203 nits
+    return pow((pow(input, 1 / m2) - c1) / (c2 - c3 * pow(input, 1 / m2)), 1 / m1);
+}
+
+LutShader::LutShader(RuntimeEffectManager& effectManager) {
+    mEffect = effectManager.createAndStoreRuntimeEffect(RuntimeEffectManager::KnownId::kLutEffect,
+                                                        "LutEffect", kShader);
+}
+
 sk_sp<SkShader> LutShader::generateLutShader(sk_sp<SkShader> input,
                                              const std::vector<float>& buffers,
                                              const int32_t offset, const int32_t length,
@@ -170,16 +214,20 @@ sk_sp<SkShader> LutShader::generateLutShader(sk_sp<SkShader> input,
      * 1D Lut RGB/MAX_RGB
      * (R0, 0, 0, 0)
      * (R1, 0, 0, 0)
+     * ...
+     * (R_length-1, 0, 0, 0)
      *
      * 1D Lut CIE_Y
      * (Y0, 0, 0, 0)
      * (Y1, 0, 0, 0)
      * ...
+     * (Y_length-1, 0, 0, 0)
      *
      * 3D Lut MAX_RGB
      * (R0, G0, B0, 0)
      * (R1, G1, B1, 0)
      * ...
+     * (R_length-1, G_length-1, B_length-1, 0)
      */
     SkImageInfo info = SkImageInfo::Make(length /* the number of rgba */, 1, kRGBA_F16_SkColorType,
                                          kPremul_SkAlphaType);
@@ -206,15 +254,15 @@ sk_sp<SkShader> LutShader::generateLutShader(sk_sp<SkShader> input,
     float normalizeScalar = 1.0;
     switch (srcDataspace & HAL_DATASPACE_TRANSFER_MASK) {
         case HAL_DATASPACE_TRANSFER_HLG:
-            normalizeScalar = 0.203;
+            normalizeScalar = computeHlgScale();
             break;
         case HAL_DATASPACE_TRANSFER_ST2084:
-            normalizeScalar = 0.0203;
+            normalizeScalar = computePqScale();
             break;
         default:
             normalizeScalar = 1.0;
     }
-    const int uSize = static_cast<int>(size);
+    const int uSize = static_cast<int>(size); // the size per dimension
     const int uKey = static_cast<int>(samplingKey);
     const int uDimension = static_cast<int>(dimension);
     const float uNormalizeScalar = static_cast<float>(normalizeScalar);
@@ -231,7 +279,10 @@ sk_sp<SkShader> LutShader::generateLutShader(sk_sp<SkShader> input,
     mBuilder->uniform("key") = uKey;
     mBuilder->uniform("dimension") = uDimension;
     mBuilder->uniform("normalizeScalar") = uNormalizeScalar;
-    return mBuilder->makeShader();
+
+    // de-gamma the image without changing the primaries
+    return mBuilder->makeShader()->makeWithWorkingColorSpace(
+            toSkColorSpace(srcDataspace)->makeLinearGamma());
 }
 
 sk_sp<SkShader> LutShader::lutShader(sk_sp<SkShader>& input,
@@ -239,20 +290,11 @@ sk_sp<SkShader> LutShader::lutShader(sk_sp<SkShader>& input,
                                      ui::Dataspace srcDataspace,
                                      sk_sp<SkColorSpace> outColorSpace) {
     if (mBuilder == nullptr) {
-        const static SkRuntimeEffect::Result instance = SkRuntimeEffect::MakeForShader(kShader);
-        mBuilder = std::make_unique<SkRuntimeShaderBuilder>(instance.effect);
+        mBuilder = std::make_unique<SkRuntimeShaderBuilder>(mEffect);
     }
 
     auto& fd = displayLuts->getLutFileDescriptor();
     if (fd.ok()) {
-        // de-gamma the image without changing the primaries
-        SkImage* baseImage = input->isAImage((SkMatrix*)nullptr, (SkTileMode*)nullptr);
-        sk_sp<SkColorSpace> baseColorSpace = baseImage && baseImage->colorSpace()
-                ? baseImage->refColorSpace()
-                : SkColorSpace::MakeSRGB();
-        sk_sp<SkColorSpace> lutMathColorSpace = baseColorSpace->makeLinearGamma();
-        input = input->makeWithWorkingColorSpace(lutMathColorSpace);
-
         auto& offsets = displayLuts->offsets;
         auto& lutProperties = displayLuts->lutProperties;
         std::vector<float> buffers;
@@ -287,8 +329,6 @@ sk_sp<SkShader> LutShader::lutShader(sk_sp<SkShader>& input,
                                       lutProperties[i].dimension, lutProperties[i].size,
                                       lutProperties[i].samplingKey, srcDataspace);
         }
-
-        input = input->makeWithWorkingColorSpace(outColorSpace);
     }
     return input;
 }
diff --git a/libs/renderengine/skia/filters/LutShader.h b/libs/renderengine/skia/filters/LutShader.h
index 7c62fcae08..62f3b7303e 100644
--- a/libs/renderengine/skia/filters/LutShader.h
+++ b/libs/renderengine/skia/filters/LutShader.h
@@ -23,12 +23,15 @@
 #include <gui/DisplayLuts.h>
 #include <ui/GraphicTypes.h>
 
+#include "RuntimeEffectManager.h"
+
 namespace android {
 namespace renderengine {
 namespace skia {
 
 class LutShader {
 public:
+    LutShader(RuntimeEffectManager& effectManager);
     sk_sp<SkShader> lutShader(sk_sp<SkShader>& input, std::shared_ptr<gui::DisplayLuts> displayLuts,
                               ui::Dataspace srcDataspace, sk_sp<SkColorSpace> outColorSpace);
 
@@ -37,6 +40,7 @@ private:
                                       const int32_t offset, const int32_t length,
                                       const int32_t dimension, const int32_t size,
                                       const int32_t samplingKey, ui::Dataspace srcDataspace);
+    sk_sp<SkRuntimeEffect> mEffect;
     std::unique_ptr<SkRuntimeShaderBuilder> mBuilder;
 };
 
diff --git a/libs/renderengine/skia/filters/MouriMap.cpp b/libs/renderengine/skia/filters/MouriMap.cpp
index 5dc36e6358..29d07a8735 100644
--- a/libs/renderengine/skia/filters/MouriMap.cpp
+++ b/libs/renderengine/skia/filters/MouriMap.cpp
@@ -19,16 +19,13 @@
 #include <SkPaint.h>
 #include <SkTileMode.h>
 
+#include "RuntimeEffectManager.h"
+
 namespace android {
 namespace renderengine {
 namespace skia {
 namespace {
-sk_sp<SkRuntimeEffect> makeEffect(const SkString& sksl) {
-    auto [effect, error] = SkRuntimeEffect::MakeForShader(sksl);
-    LOG_ALWAYS_FATAL_IF(!effect, "RuntimeShader error: %s", error.c_str());
-    return effect;
-}
-const SkString kCrosstalkAndChunk16x16(R"(
+const SkString kCrosstalkAndChunk16x16String(R"(
     uniform shader bitmap;
     uniform float inputMultiplier;
     vec4 main(vec2 xy) {
@@ -43,7 +40,7 @@ const SkString kCrosstalkAndChunk16x16(R"(
         return float4(float3(maximum), 1.0);
     }
 )");
-const SkString kChunk8x8(R"(
+const SkString kChunk8x8String(R"(
     uniform shader bitmap;
     vec4 main(vec2 xy) {
         float maximum = 0.0;
@@ -55,7 +52,7 @@ const SkString kChunk8x8(R"(
         return float4(float3(maximum), 1.0);
     }
 )");
-const SkString kBlur(R"(
+const SkString kBlurString(R"(
     uniform shader bitmap;
     vec4 main(vec2 xy) {
         float C[5];
@@ -73,7 +70,7 @@ const SkString kBlur(R"(
         return float4(float3(exp2(result)), 1.0);
     }
 )");
-const SkString kTonemap(R"(
+const SkString kTonemapString(R"(
     uniform shader image;
     uniform shader lux;
     uniform float scaleFactor;
@@ -108,12 +105,22 @@ sk_sp<SkImage> makeImage(SkSurface* surface, const SkRuntimeShaderBuilder& build
 }
 
 } // namespace
-
-MouriMap::MouriMap()
-      : mCrosstalkAndChunk16x16(makeEffect(kCrosstalkAndChunk16x16)),
-        mChunk8x8(makeEffect(kChunk8x8)),
-        mBlur(makeEffect(kBlur)),
-        mTonemap(makeEffect(kTonemap)) {}
+MouriMap::MouriMap(RuntimeEffectManager& effectManager)
+      : mCrosstalkAndChunk16x16(
+                effectManager
+                        .createAndStoreRuntimeEffect(RuntimeEffectManager::KnownId::
+                                                             kMouriMap_CrossTalkAndChunk16x16Effect,
+                                                     "MouriMap_CrossTalkAndChunk16x16",
+                                                     kCrosstalkAndChunk16x16String)),
+        mChunk8x8(effectManager.createAndStoreRuntimeEffect(RuntimeEffectManager::KnownId::
+                                                                    kMouriMap_Chunk8x8Effect,
+                                                            "MouriMap_Chunk8x8", kChunk8x8String)),
+        mBlur(effectManager.createAndStoreRuntimeEffect(RuntimeEffectManager::KnownId::
+                                                                kMouriMap_BlurEffect,
+                                                        "MouriMap_Blur", kBlurString)),
+        mTonemap(effectManager.createAndStoreRuntimeEffect(RuntimeEffectManager::KnownId::
+                                                                   kMouriMap_TonemapEffect,
+                                                           "MouriMap_Tonemap", kTonemapString)) {}
 
 sk_sp<SkShader> MouriMap::mouriMap(SkiaGpuContext* context, sk_sp<SkShader> input,
                                    float inputMultiplier, float targetHdrSdrRatio) {
diff --git a/libs/renderengine/skia/filters/MouriMap.h b/libs/renderengine/skia/filters/MouriMap.h
index f4bfa1549e..fed97f43a5 100644
--- a/libs/renderengine/skia/filters/MouriMap.h
+++ b/libs/renderengine/skia/filters/MouriMap.h
@@ -17,10 +17,14 @@
 #include <SkImage.h>
 #include <SkRuntimeEffect.h>
 #include <SkShader.h>
+
 #include "../compat/SkiaGpuContext.h"
+#include "RuntimeEffectManager.h"
+
 namespace android {
 namespace renderengine {
 namespace skia {
+
 /**
  * MouriMap is a fast, albeit not realtime, tonemapping algorithm optimized for near-exact
  * preservation of SDR (or, equivalently, LDR) regions, while trying to do an acceptable job of
@@ -60,7 +64,7 @@ namespace skia {
  */
 class MouriMap {
 public:
-    MouriMap();
+    MouriMap(RuntimeEffectManager& effectManager);
     // Apply the MouriMap tonemmaping operator to the input.
     // The inputMultiplier informs how to interpret the luminance encoding of the input.
     // For a fixed point input, this is necessary to interpret what "1.0" means for the input
diff --git a/libs/renderengine/skia/filters/RuntimeEffectManager.cpp b/libs/renderengine/skia/filters/RuntimeEffectManager.cpp
new file mode 100644
index 0000000000..161f7b9a89
--- /dev/null
+++ b/libs/renderengine/skia/filters/RuntimeEffectManager.cpp
@@ -0,0 +1,184 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "RuntimeEffectManager.h"
+
+#define ATRACE_TAG ATRACE_TAG_GRAPHICS
+
+#include <SkRuntimeEffect.h>
+#include <SkString.h>
+#include <android-base/stringprintf.h>
+#include <common/trace.h>
+#include <ftl/concat.h>
+#include <log/log.h>
+#include <math/mat4.h>
+#include <shaders/shaders.h>
+#include <ui/DebugUtils.h>
+#include <mutex>
+
+namespace android {
+namespace renderengine {
+namespace skia {
+
+using base::StringAppendF;
+
+sk_sp<SkRuntimeEffect> RuntimeEffectManager::createAndStoreRuntimeEffect(
+        KnownId effectId, const std::string& effectName, const SkString& effectSkSL) {
+    SFTRACE_CALL();
+
+    auto effectIdValue = static_cast<size_t>(effectId);
+    LOG_ALWAYS_FATAL_IF(mKnownRuntimeEffects[effectIdValue],
+                        "RuntimeEffect already created for ID:%zu", effectIdValue);
+
+    std::string name = "RE_" + effectName;
+    SkRuntimeEffect::Options options;
+    options.fName = name;
+    auto [runtimeEffect, error] = SkRuntimeEffect::MakeForShader(effectSkSL, options);
+    LOG_ALWAYS_FATAL_IF(!runtimeEffect, "%s (ID:%zu) construction error: %s", name.c_str(),
+                        effectIdValue, error.c_str());
+
+    mKnownRuntimeEffects[effectIdValue] = runtimeEffect;
+    return runtimeEffect;
+}
+
+sk_sp<SkRuntimeEffect> RuntimeEffectManager::getKnownRuntimeEffect(KnownId effectId) {
+    auto effectIdValue = static_cast<size_t>(effectId);
+    sk_sp<SkRuntimeEffect> runtimeEffect = mKnownRuntimeEffects[effectIdValue];
+    LOG_ALWAYS_FATAL_IF(!runtimeEffect, "RuntimeEffect for ID:%zu has not been created yet",
+                        effectIdValue);
+    return runtimeEffect;
+}
+
+sk_sp<SkRuntimeEffect> RuntimeEffectManager::getOrCreateLinearRuntimeEffect(
+        const shaders::LinearEffect& linearEffect) {
+    SFTRACE_CALL();
+    std::lock_guard lock(mMutex);
+
+    auto effectIter = mLinearEffectMap.find(linearEffect);
+    if (effectIter == mLinearEffectMap.end()) {
+        sk_sp<SkRuntimeEffect> runtimeEffect = buildLinearRuntimeEffect(linearEffect);
+        mLinearEffectMap.insert({linearEffect, runtimeEffect});
+        return runtimeEffect;
+    } else {
+        return effectIter->second;
+    }
+}
+
+std::string variableNameSafeLinearEffectString(const shaders::LinearEffect& effect) {
+    // May only contain alphanumeric characters and underscores. Double underscoress are used to
+    // delineate fields, since dataspace names may contain their own single underscores.
+    return toString(effect.inputDataspace) + "__" + toString(effect.outputDataspace) + "__" +
+            (effect.undoPremultipliedAlpha ? "true" : "false") + "__" +
+            toString(effect.fakeOutputDataspace) + "__" +
+            (effect.type == shaders::LinearEffect::SkSLType::Shader ? "Shader" : "ColorFilter");
+}
+
+// Wrapper around existing toString(ui::Dataspace) that tweaks the result to make it copy/pasteable
+// into struct initialization code.
+std::string dataspaceEnumString(ui::Dataspace dataspace) {
+    const std::string dataspaceStr = toString(dataspace);
+    if (dataspaceStr.starts_with("0x")) {
+        return "static_cast<ui::Dataspace>(" + dataspaceStr + ")";
+    } else {
+        return "ui::Dataspace::" + dataspaceStr;
+    }
+}
+
+void RuntimeEffectManager::dump(std::string& result) {
+    // LinearEffects are ordered (by hash value) when dumped to reduce churn when iterating on the
+    // set of precompiled effects.
+    std::vector<shaders::LinearEffect> orderedLinearEffects;
+    {
+        // Note: rework this locking if other guarded state is dumped in the future!
+        std::lock_guard lock(mMutex);
+        orderedLinearEffects = std::vector<shaders::LinearEffect>(mLinearEffectMap.size());
+        for (const auto& [linearEffect, _] : mLinearEffectMap) {
+            orderedLinearEffects.push_back(linearEffect);
+        }
+    }
+    std::sort(orderedLinearEffects.begin(), orderedLinearEffects.end(), [](auto& lhs, auto& rhs) {
+        auto hasher = shaders::LinearEffectHasher();
+        return hasher(lhs) < hasher(rhs);
+    });
+
+    StringAppendF(&result, "RenderEngine LinearEffects (RuntimeEffects): %zu\n",
+                  orderedLinearEffects.size());
+    for (const auto& linearEffect : orderedLinearEffects) {
+        // Note: the formatting of this output should remain copy/pasteable C++
+        StringAppendF(&result, "// %s\n", variableNameSafeLinearEffectString(linearEffect).c_str());
+        StringAppendF(&result, "{\n");
+        StringAppendF(&result, "    .inputDataspace = %s, // %s\n",
+                      dataspaceEnumString(linearEffect.inputDataspace).c_str(),
+                      dataspaceDetails(static_cast<android_dataspace>(linearEffect.inputDataspace))
+                              .c_str());
+        StringAppendF(&result, "    .outputDataspace = %s, // %s\n",
+                      dataspaceEnumString(linearEffect.outputDataspace).c_str(),
+                      dataspaceDetails(static_cast<android_dataspace>(linearEffect.outputDataspace))
+                              .c_str());
+        StringAppendF(&result, "    .undoPremultipliedAlpha = %s,\n",
+                      linearEffect.undoPremultipliedAlpha ? "true" : "false");
+        StringAppendF(&result, "    .fakeOutputDataspace = %s, // %s\n",
+                      dataspaceEnumString(linearEffect.fakeOutputDataspace).c_str(),
+                      dataspaceDetails(
+                              static_cast<android_dataspace>(linearEffect.fakeOutputDataspace))
+                              .c_str());
+        StringAppendF(&result, "    .type = shaders::LinearEffect::SkSLType::%s,\n",
+                      linearEffect.type == shaders::LinearEffect::SkSLType::Shader ? "Shader"
+                                                                                   : "ColorFilter");
+        StringAppendF(&result, "},\n");
+    }
+}
+
+sk_sp<SkRuntimeEffect> RuntimeEffectManager::buildLinearRuntimeEffect(
+        const shaders::LinearEffect& linearEffect) {
+    SFTRACE_CALL();
+    SkString shaderString = SkString(shaders::buildLinearEffectSkSL(linearEffect));
+
+    std::string name = "RE_LinearEffect_" + variableNameSafeLinearEffectString(linearEffect);
+    SkRuntimeEffect::Options options;
+    options.fName = name;
+    auto [shader, error] = SkRuntimeEffect::MakeForShader(shaderString, options);
+    if (!shader) {
+        LOG_ALWAYS_FATAL("LinearColorFilter construction error: %s", error.c_str());
+    }
+    return shader;
+}
+
+sk_sp<SkShader> RuntimeEffectManager::createLinearEffectShader(
+        sk_sp<SkShader> shader, const shaders::LinearEffect& linearEffect,
+        sk_sp<SkRuntimeEffect> runtimeEffect, const mat4& colorTransform, float maxDisplayLuminance,
+        float currentDisplayLuminanceNits, float maxLuminance, AHardwareBuffer* buffer,
+        aidl::android::hardware::graphics::composer3::RenderIntent renderIntent) {
+    SFTRACE_CALL();
+    SkRuntimeShaderBuilder effectBuilder(runtimeEffect);
+
+    effectBuilder.child("child") = shader;
+
+    const auto uniforms =
+            shaders::buildLinearEffectUniforms(linearEffect, colorTransform, maxDisplayLuminance,
+                                               currentDisplayLuminanceNits, maxLuminance, buffer,
+                                               renderIntent);
+
+    for (const auto& uniform : uniforms) {
+        effectBuilder.uniform(uniform.name.c_str()).set(uniform.value.data(), uniform.value.size());
+    }
+
+    return effectBuilder.makeShader();
+}
+
+} // namespace skia
+} // namespace renderengine
+} // namespace android
diff --git a/libs/renderengine/skia/filters/RuntimeEffectManager.h b/libs/renderengine/skia/filters/RuntimeEffectManager.h
new file mode 100644
index 0000000000..8c61cf62e6
--- /dev/null
+++ b/libs/renderengine/skia/filters/RuntimeEffectManager.h
@@ -0,0 +1,108 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <android-base/thread_annotations.h>
+#include <ftl/enum.h>
+#include <math/mat4.h>
+
+#include <cstddef>
+
+#include <shaders/shaders.h>
+#include "SkRuntimeEffect.h"
+#include "SkShader.h"
+
+namespace android {
+namespace renderengine {
+namespace skia {
+
+/**
+ * Centralized location for sharing access to SkRuntimeEffects between rendering and precompilation.
+ *
+ * Note: data that is lazily-initialized (e.g. SkRuntimeEffects for LinearEffects) must be
+ * thread-safe, otherwise the rendering and precompilation threads may race.
+ */
+class RuntimeEffectManager {
+public:
+    // Ordered alphabetically by overall filter, then by declaration order for filters with multiple
+    // effects.
+    // TODO(b/380159947): use macros to generate enum/name pair
+    enum class KnownId : size_t {
+        kBlurFilter_MixEffect,
+        kEdgeExtensionEffect,
+        kGainmapEffect,
+        kKawaseBlurDualFilter_LowSampleBlurEffect,
+        kKawaseBlurDualFilter_HighSampleBlurEffect,
+        kKawaseBlurEffect,
+        kLutEffect,
+        kMouriMap_CrossTalkAndChunk16x16Effect,
+        kMouriMap_Chunk8x8Effect,
+        kMouriMap_BlurEffect,
+        kMouriMap_TonemapEffect,
+        kStretchEffect,
+
+        kLast,
+    };
+
+    // Fatal error if a RuntimeEffect has already been created/stored for effectId, or if
+    // RuntimeEffect compilation fails.
+    // TODO(b/380159947): use macros to generate enum/name pair
+    sk_sp<SkRuntimeEffect> createAndStoreRuntimeEffect(KnownId effectId,
+                                                       const std::string& effectName,
+                                                       const SkString& effectSkSL);
+    // Fatal error if a RuntimeEffect has not been created/stored yet for effectId.
+    sk_sp<SkRuntimeEffect> getKnownRuntimeEffect(KnownId effectId);
+
+    sk_sp<SkRuntimeEffect> getOrCreateLinearRuntimeEffect(const shaders::LinearEffect& linearEffect)
+            EXCLUDES(mMutex);
+
+    void dump(std::string& result) EXCLUDES(mMutex);
+
+    // Generates a shader resulting from applying a linear effect shader (created according to the
+    // given LinearEffect settings struct) to the given inputShader.
+    //
+    // Optionally, a color transform may also be provided, which combines with the
+    // matrix transforming from linear XYZ to linear RGB immediately before OETF.
+    // We also provide additional HDR metadata upon creating the shader:
+    // * The max display luminance is the max luminance of the physical display in nits
+    // * The current luminance of the physical display in nits
+    // * The max luminance is provided as the max luminance for the buffer, either from the SMPTE
+    // 2086 or as the max light level from the CTA 861.3 standard.
+    // * An AHardwareBuffer for implementations that support gralloc4 metadata for
+    // communicating any HDR metadata.
+    // * A RenderIntent that communicates the downstream renderintent for a physical display, for
+    // image quality compensation.
+    static sk_sp<SkShader> createLinearEffectShader(
+            sk_sp<SkShader> inputShader, const shaders::LinearEffect& linearEffect,
+            sk_sp<SkRuntimeEffect> runtimeEffect, const mat4& colorTransform,
+            float maxDisplayLuminance, float currentDisplayLuminanceNits, float maxLuminance,
+            AHardwareBuffer* buffer,
+            aidl::android::hardware::graphics::composer3::RenderIntent renderIntent);
+
+private:
+    static sk_sp<SkRuntimeEffect> buildLinearRuntimeEffect(
+            const shaders::LinearEffect& linearEffect);
+
+    std::mutex mMutex;
+    std::array<sk_sp<SkRuntimeEffect>, static_cast<size_t>(KnownId::kLast)> mKnownRuntimeEffects{};
+    std::unordered_map<shaders::LinearEffect, sk_sp<SkRuntimeEffect>, shaders::LinearEffectHasher>
+            mLinearEffectMap GUARDED_BY(mMutex);
+};
+
+} // namespace skia
+} // namespace renderengine
+} // namespace android
diff --git a/libs/renderengine/skia/filters/StretchShaderFactory.cpp b/libs/renderengine/skia/filters/StretchShaderFactory.cpp
index beec3eccf5..bab6b1487d 100644
--- a/libs/renderengine/skia/filters/StretchShaderFactory.cpp
+++ b/libs/renderengine/skia/filters/StretchShaderFactory.cpp
@@ -23,11 +23,13 @@
 #include "log/log.h"
 #include <memory>
 
+#include "RuntimeEffectManager.h"
+
 namespace android {
 namespace renderengine {
 namespace skia {
 
-static const SkString stretchShader = SkString(R"(
+static const SkString kStretchShaderString = SkString(R"(
     uniform shader uContentTexture;
 
     // multiplier to apply to scale effect
@@ -189,6 +191,12 @@ static const SkString stretchShader = SkString(R"(
 
 const float INTERPOLATION_STRENGTH_VALUE = 0.7f;
 
+StretchShaderFactory::StretchShaderFactory(RuntimeEffectManager& effectManager) {
+    mEffect =
+            effectManager.createAndStoreRuntimeEffect(RuntimeEffectManager::KnownId::kStretchEffect,
+                                                      "StretchEffect", kStretchShaderString);
+}
+
 sk_sp<SkShader> StretchShaderFactory::createSkShader(const sk_sp<SkShader>& inputShader,
                                                      const StretchEffect& stretchEffect) {
     if (!stretchEffect.hasEffect()) {
@@ -216,9 +224,7 @@ sk_sp<SkShader> StretchShaderFactory::createSkShader(const sk_sp<SkShader>& inpu
     float normalizedScrollY = srcBounds.top / viewportHeight;
 
     if (mBuilder == nullptr) {
-        const static SkRuntimeEffect::Result instance =
-            SkRuntimeEffect::MakeForShader(stretchShader);
-        mBuilder = std::make_unique<SkRuntimeShaderBuilder>(instance.effect);
+        mBuilder = std::make_unique<SkRuntimeShaderBuilder>(mEffect);
     }
 
     mBuilder->child("uContentTexture") = inputShader;
diff --git a/libs/renderengine/skia/filters/StretchShaderFactory.h b/libs/renderengine/skia/filters/StretchShaderFactory.h
index 9c3ab7cb4f..aa8734e716 100644
--- a/libs/renderengine/skia/filters/StretchShaderFactory.h
+++ b/libs/renderengine/skia/filters/StretchShaderFactory.h
@@ -20,15 +20,21 @@
 #include <SkShader.h>
 #include <ui/StretchEffect.h>
 
+#include "RuntimeEffectManager.h"
+
 namespace android {
 namespace renderengine {
 namespace skia {
+
 class StretchShaderFactory {
 public:
+    StretchShaderFactory(RuntimeEffectManager& effectManager);
+
     sk_sp<SkShader> createSkShader(const sk_sp<SkShader>& inputShader,
                                    const StretchEffect& stretchEffect);
 
 private:
+    sk_sp<SkRuntimeEffect> mEffect;
     std::unique_ptr<SkRuntimeShaderBuilder> mBuilder;
 };
 } // namespace skia
diff --git a/libs/renderengine/tests/RenderEngineTest.cpp b/libs/renderengine/tests/RenderEngineTest.cpp
index b5cc65f27d..e7383946e3 100644
--- a/libs/renderengine/tests/RenderEngineTest.cpp
+++ b/libs/renderengine/tests/RenderEngineTest.cpp
@@ -63,46 +63,6 @@ namespace renderengine {
 
 namespace {
 
-double EOTF_PQ(double channel) {
-    float m1 = (2610.0 / 4096.0) / 4.0;
-    float m2 = (2523.0 / 4096.0) * 128.0;
-    float c1 = (3424.0 / 4096.0);
-    float c2 = (2413.0 / 4096.0) * 32.0;
-    float c3 = (2392.0 / 4096.0) * 32.0;
-
-    float tmp = std::pow(std::clamp(channel, 0.0, 1.0), 1.0 / m2);
-    tmp = std::fmax(tmp - c1, 0.0) / (c2 - c3 * tmp);
-    return std::pow(tmp, 1.0 / m1);
-}
-
-vec3 EOTF_PQ(vec3 color) {
-    return vec3(EOTF_PQ(color.r), EOTF_PQ(color.g), EOTF_PQ(color.b));
-}
-
-double EOTF_HLG(double channel) {
-    const float a = 0.17883277;
-    const float b = 0.28466892;
-    const float c = 0.55991073;
-    return channel <= 0.5 ? channel * channel / 3.0 : (exp((channel - c) / a) + b) / 12.0;
-}
-
-vec3 EOTF_HLG(vec3 color) {
-    return vec3(EOTF_HLG(color.r), EOTF_HLG(color.g), EOTF_HLG(color.b));
-}
-
-double OETF_sRGB(double channel) {
-    return channel <= 0.0031308 ? channel * 12.92 : (pow(channel, 1.0 / 2.4) * 1.055) - 0.055;
-}
-
-int sign(float in) {
-    return in >= 0.0 ? 1 : -1;
-}
-
-vec3 OETF_sRGB(vec3 linear) {
-    return vec3(sign(linear.r) * OETF_sRGB(linear.r), sign(linear.g) * OETF_sRGB(linear.g),
-                sign(linear.b) * OETF_sRGB(linear.b));
-}
-
 // clang-format off
 // Converts red channels to green channels, and zeroes out an existing green channel.
 static const auto kRemoveGreenAndMoveRedToGreenMat4 = mat4(0, 1, 0, 0,
@@ -623,12 +583,6 @@ public:
     void drawShadowWithoutCaster(const FloatRect& castingBounds, const ShadowSettings& shadow,
                                  const ubyte4& backgroundColor);
 
-    // Tonemaps grey values from sourceDataspace -> Display P3 and checks that GPU and CPU
-    // implementations are identical Also implicitly checks that the injected tonemap shader
-    // compiles
-    void tonemap(ui::Dataspace sourceDataspace, std::function<vec3(vec3)> eotf,
-                 std::function<vec3(vec3, float)> scaleOotf);
-
     void initializeRenderEngine();
 
     std::unique_ptr<renderengine::RenderEngine> mRE;
@@ -1423,125 +1377,6 @@ void RenderEngineTest::drawShadowWithoutCaster(const FloatRect& castingBounds,
     invokeDraw(settings, layers);
 }
 
-void RenderEngineTest::tonemap(ui::Dataspace sourceDataspace, std::function<vec3(vec3)> eotf,
-                               std::function<vec3(vec3, float)> scaleOotf) {
-    constexpr int32_t kGreyLevels = 256;
-
-    const auto rect = Rect(0, 0, kGreyLevels, 1);
-
-    constexpr float kMaxLuminance = 750.f;
-    constexpr float kCurrentLuminanceNits = 500.f;
-    const renderengine::DisplaySettings display{
-            .physicalDisplay = rect,
-            .clip = rect,
-            .maxLuminance = kMaxLuminance,
-            .currentLuminanceNits = kCurrentLuminanceNits,
-            .outputDataspace = ui::Dataspace::DISPLAY_P3,
-    };
-
-    auto buf = std::make_shared<
-            renderengine::impl::
-                    ExternalTexture>(sp<GraphicBuffer>::make(kGreyLevels, 1,
-                                                             HAL_PIXEL_FORMAT_RGBA_8888, 1,
-                                                             GRALLOC_USAGE_SW_READ_OFTEN |
-                                                                     GRALLOC_USAGE_SW_WRITE_OFTEN |
-                                                                     GRALLOC_USAGE_HW_RENDER |
-                                                                     GRALLOC_USAGE_HW_TEXTURE,
-                                                             "input"),
-                                     *mRE,
-                                     renderengine::impl::ExternalTexture::Usage::READABLE |
-                                             renderengine::impl::ExternalTexture::Usage::WRITEABLE);
-    ASSERT_EQ(0, buf->getBuffer()->initCheck());
-    {
-        uint8_t* pixels;
-        buf->getBuffer()->lock(GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN,
-                               reinterpret_cast<void**>(&pixels));
-
-        uint8_t color = 0;
-        for (int32_t j = 0; j < buf->getBuffer()->getHeight(); j++) {
-            uint8_t* dest = pixels + (buf->getBuffer()->getStride() * j * 4);
-            for (int32_t i = 0; i < buf->getBuffer()->getWidth(); i++) {
-                dest[0] = color;
-                dest[1] = color;
-                dest[2] = color;
-                dest[3] = 255;
-                color++;
-                dest += 4;
-            }
-        }
-        buf->getBuffer()->unlock();
-    }
-
-    mBuffer = std::make_shared<
-            renderengine::impl::
-                    ExternalTexture>(sp<GraphicBuffer>::make(kGreyLevels, 1,
-                                                             HAL_PIXEL_FORMAT_RGBA_8888, 1,
-                                                             GRALLOC_USAGE_SW_READ_OFTEN |
-                                                                     GRALLOC_USAGE_SW_WRITE_OFTEN |
-                                                                     GRALLOC_USAGE_HW_RENDER |
-                                                                     GRALLOC_USAGE_HW_TEXTURE,
-                                                             "output"),
-                                     *mRE,
-                                     renderengine::impl::ExternalTexture::Usage::READABLE |
-                                             renderengine::impl::ExternalTexture::Usage::WRITEABLE);
-    ASSERT_EQ(0, mBuffer->getBuffer()->initCheck());
-
-    const renderengine::LayerSettings layer{.geometry.boundaries = rect.toFloatRect(),
-                                            .source =
-                                                    renderengine::PixelSource{
-                                                            .buffer =
-                                                                    renderengine::Buffer{
-                                                                            .buffer =
-                                                                                    std::move(buf),
-                                                                            .usePremultipliedAlpha =
-                                                                                    true,
-                                                                    },
-                                                    },
-                                            .alpha = 1.0f,
-                                            .sourceDataspace = sourceDataspace};
-
-    std::vector<renderengine::LayerSettings> layers{layer};
-    invokeDraw(display, layers);
-
-    ColorSpace displayP3 = ColorSpace::DisplayP3();
-    ColorSpace bt2020 = ColorSpace::BT2020();
-
-    tonemap::Metadata metadata{.displayMaxLuminance = 750.0f};
-
-    auto generator = [=](Point location) {
-        const double normColor = static_cast<double>(location.x) / (kGreyLevels - 1);
-        const vec3 rgb = vec3(normColor, normColor, normColor);
-
-        const vec3 linearRGB = eotf(rgb);
-
-        const vec3 xyz = bt2020.getRGBtoXYZ() * linearRGB;
-
-        const vec3 scaledXYZ = scaleOotf(xyz, kCurrentLuminanceNits);
-        const auto gains =
-                tonemap::getToneMapper()
-                        ->lookupTonemapGain(static_cast<aidl::android::hardware::graphics::common::
-                                                                Dataspace>(sourceDataspace),
-                                            static_cast<aidl::android::hardware::graphics::common::
-                                                                Dataspace>(
-                                                    ui::Dataspace::DISPLAY_P3),
-                                            {tonemap::
-                                                     Color{.linearRGB =
-                                                                   scaleOotf(linearRGB,
-                                                                             kCurrentLuminanceNits),
-                                                           .xyz = scaledXYZ}},
-                                            metadata);
-        EXPECT_EQ(1, gains.size());
-        const double gain = gains.front();
-        const vec3 normalizedXYZ = scaledXYZ * gain / metadata.displayMaxLuminance;
-
-        const vec3 targetRGB = OETF_sRGB(displayP3.getXYZtoRGB() * normalizedXYZ) * 255;
-        return ubyte4(static_cast<uint8_t>(targetRGB.r), static_cast<uint8_t>(targetRGB.g),
-                      static_cast<uint8_t>(targetRGB.b), 255);
-    };
-
-    expectBufferColor(Rect(kGreyLevels, 1), generator, 2);
-}
-
 // TODO: b/341728634 - Clean up conditional compilation.
 INSTANTIATE_TEST_SUITE_P(PerRenderEngineType, RenderEngineTest,
                          testing::Values(std::make_shared<SkiaGLESRenderEngineFactory>(),
@@ -2953,40 +2788,6 @@ TEST_P(RenderEngineTest, test_isOpaque) {
     expectBufferColor(rect, 117, 251, 76, 255);
 }
 
-TEST_P(RenderEngineTest, test_tonemapPQMatches) {
-    if (!GetParam()->apiSupported()) {
-        GTEST_SKIP();
-    }
-
-    initializeRenderEngine();
-
-    tonemap(
-            static_cast<ui::Dataspace>(HAL_DATASPACE_STANDARD_BT2020 |
-                                       HAL_DATASPACE_TRANSFER_ST2084 | HAL_DATASPACE_RANGE_FULL),
-            [](vec3 color) { return EOTF_PQ(color); },
-            [](vec3 color, float) {
-                static constexpr float kMaxPQLuminance = 10000.f;
-                return color * kMaxPQLuminance;
-            });
-}
-
-TEST_P(RenderEngineTest, test_tonemapHLGMatches) {
-    if (!GetParam()->apiSupported()) {
-        GTEST_SKIP();
-    }
-
-    initializeRenderEngine();
-
-    tonemap(
-            static_cast<ui::Dataspace>(HAL_DATASPACE_STANDARD_BT2020 | HAL_DATASPACE_TRANSFER_HLG |
-                                       HAL_DATASPACE_RANGE_FULL),
-            [](vec3 color) { return EOTF_HLG(color); },
-            [](vec3 color, float currentLuminaceNits) {
-                static constexpr float kMaxHLGLuminance = 1000.f;
-                return color * kMaxHLGLuminance;
-            });
-}
-
 TEST_P(RenderEngineTest, r8_behaves_as_mask) {
     if (!GetParam()->apiSupported()) {
         GTEST_SKIP();
diff --git a/libs/sensor/ISensorServer.cpp b/libs/sensor/ISensorServer.cpp
index 12f600e97e..ae64efb890 100644
--- a/libs/sensor/ISensorServer.cpp
+++ b/libs/sensor/ISensorServer.cpp
@@ -153,7 +153,11 @@ public:
         data.writeInt32(mode);
         data.writeString16(opPackageName);
         data.writeString16(attributionTag);
-        remote()->transact(CREATE_SENSOR_EVENT_CONNECTION, data, &reply);
+
+        status_t status = remote()->transact(CREATE_SENSOR_EVENT_CONNECTION, data, &reply);
+        if (status != OK) {
+            ALOGE("Failed to create sensor event connection: %s", statusToString(status).c_str());
+        }
         return interface_cast<ISensorEventConnection>(reply.readStrongBinder());
     }
 
diff --git a/libs/sensor/Sensor.cpp b/libs/sensor/Sensor.cpp
index 797efbe5df..16a932e7e0 100644
--- a/libs/sensor/Sensor.cpp
+++ b/libs/sensor/Sensor.cpp
@@ -30,6 +30,11 @@
  */
 #define SENSOR_PERMISSION_ACTIVITY_RECOGNITION "android.permission.ACTIVITY_RECOGNITION"
 
+/*
+* The permission to detect moisture intrusion within chassis of a devices
+*/
+#define SENSOR_PERMISSION_MOISTURE_INTRUSION "android.permission.MOISTURE_INTRUSION"
+
 // ----------------------------------------------------------------------------
 namespace android {
 // ----------------------------------------------------------------------------
@@ -299,6 +304,11 @@ Sensor::Sensor(struct sensor_t const& hwSensor, const uuid_t& uuid, int halVersi
         mStringType = SENSOR_STRING_TYPE_HEADING;
         mFlags |= SENSOR_FLAG_CONTINUOUS_MODE;
         break;
+    case SENSOR_TYPE_MOISTURE_INTRUSION:
+        mStringType = SENSOR_STRING_TYPE_MOISTURE_INTRUSION;
+        mRequiredPermission = SENSOR_PERMISSION_MOISTURE_INTRUSION;
+        mFlags |= SENSOR_FLAG_ON_CHANGE_MODE;
+        break;
     default:
         // Only pipe the stringType, requiredPermission and flags for custom sensors.
         if (halVersion > SENSORS_DEVICE_API_VERSION_1_0 && hwSensor.stringType) {
diff --git a/libs/sensor/SensorManager.cpp b/libs/sensor/SensorManager.cpp
index 7b4a86c215..c95bb37f66 100644
--- a/libs/sensor/SensorManager.cpp
+++ b/libs/sensor/SensorManager.cpp
@@ -208,21 +208,7 @@ void SensorManager::sensorManagerDied() {
 }
 
 status_t SensorManager::assertStateLocked() {
-#if COM_ANDROID_HARDWARE_LIBSENSOR_FLAGS(SENSORMANAGER_PING_BINDER)
     if (mSensorServer == nullptr) {
-#else
-    bool initSensorManager = false;
-    if (mSensorServer == nullptr) {
-        initSensorManager = true;
-    } else {
-        // Ping binder to check if sensorservice is alive.
-        status_t err = IInterface::asBinder(mSensorServer)->pingBinder();
-        if (err != NO_ERROR) {
-            initSensorManager = true;
-        }
-    }
-    if (initSensorManager) {
-#endif
         waitForSensorService(&mSensorServer);
         LOG_ALWAYS_FATAL_IF(mSensorServer == nullptr, "getService(SensorService) NULL");
 
diff --git a/libs/sensor/libsensor_flags.aconfig b/libs/sensor/libsensor_flags.aconfig
index cbf3055fd4..0db5bc595e 100644
--- a/libs/sensor/libsensor_flags.aconfig
+++ b/libs/sensor/libsensor_flags.aconfig
@@ -1,14 +1,6 @@
 package: "com.android.hardware.libsensor.flags"
 container: "system"
 
-flag {
-  name: "sensormanager_ping_binder"
-  namespace: "sensors"
-  description: "Whether to pingBinder on SensorManager init"
-  bug: "322228259"
-  is_fixed_read_only: true
-}
-
 flag {
   name: "sensor_event_queue_report_sensor_usage_in_tracing"
   namespace: "sensors"
diff --git a/libs/shaders/OWNERS b/libs/shaders/OWNERS
index 6977a49cc9..0c7b05435d 100644
--- a/libs/shaders/OWNERS
+++ b/libs/shaders/OWNERS
@@ -1,3 +1,3 @@
-alecmouri@google.com
-jreck@google.com
-sallyqi@google.com
+# Bug component: 1075130
+
+include /services/surfaceflinger/OWNERS
\ No newline at end of file
diff --git a/libs/shaders/include/shaders/shaders.h b/libs/shaders/include/shaders/shaders.h
index 5a4aaab851..a7ca27b608 100644
--- a/libs/shaders/include/shaders/shaders.h
+++ b/libs/shaders/include/shaders/shaders.h
@@ -49,14 +49,14 @@ namespace android::shaders {
  */
 struct LinearEffect {
     // Input dataspace of the source colors.
-    const ui::Dataspace inputDataspace = ui::Dataspace::SRGB;
+    ui::Dataspace inputDataspace = ui::Dataspace::SRGB;
 
     // Working dataspace for the output surface.
-    const ui::Dataspace outputDataspace = ui::Dataspace::SRGB;
+    ui::Dataspace outputDataspace = ui::Dataspace::SRGB;
 
     // Sets whether alpha premultiplication must be undone.
     // This is required if the source colors use premultiplied alpha and is not opaque.
-    const bool undoPremultipliedAlpha = false;
+    bool undoPremultipliedAlpha = false;
 
     // "Fake" dataspace of the destination colors. This is used for applying an OETF to compute
     // non-linear RGB. This is used when Skia is expected to color manage the input image based on
diff --git a/libs/tonemap/OWNERS b/libs/tonemap/OWNERS
index 6977a49cc9..0c7b05435d 100644
--- a/libs/tonemap/OWNERS
+++ b/libs/tonemap/OWNERS
@@ -1,3 +1,3 @@
-alecmouri@google.com
-jreck@google.com
-sallyqi@google.com
+# Bug component: 1075130
+
+include /services/surfaceflinger/OWNERS
\ No newline at end of file
diff --git a/libs/tracing_perfetto/include/tracing_perfetto.h b/libs/tracing_perfetto/include/tracing_perfetto.h
index 59c43d6dcc..df97865641 100644
--- a/libs/tracing_perfetto/include/tracing_perfetto.h
+++ b/libs/tracing_perfetto/include/tracing_perfetto.h
@@ -17,6 +17,7 @@
 #pragma once
 
 #include <stdint.h>
+#include "perfetto/public/te_category_macros.h"
 
 namespace tracing_perfetto {
 
@@ -50,4 +51,7 @@ void traceCounter(uint64_t category, const char* name, int64_t value);
 void traceCounter32(uint64_t category, const char* name, int32_t value);
 
 bool isTagEnabled(uint64_t category);
+
+PerfettoTeCategory* getPerfettoCategory(uint64_t category);
+
 }  // namespace tracing_perfetto
diff --git a/libs/tracing_perfetto/tracing_perfetto.cpp b/libs/tracing_perfetto/tracing_perfetto.cpp
index 4b7021393f..31162f34ef 100644
--- a/libs/tracing_perfetto/tracing_perfetto.cpp
+++ b/libs/tracing_perfetto/tracing_perfetto.cpp
@@ -204,4 +204,15 @@ bool isTagEnabled(uint64_t category) {
          atrace_is_tag_enabled(category);
 }
 
+PerfettoTeCategory* getPerfettoCategory(uint64_t category) {
+  struct PerfettoTeCategory* perfettoTeCategory =
+      internal::toPerfettoCategory(category);
+
+  if (internal::isPerfettoCategoryEnabled(perfettoTeCategory)) {
+    return perfettoTeCategory;
+  }
+
+  return nullptr;
+}
+
 }  // namespace tracing_perfetto
diff --git a/libs/ui/Android.bp b/libs/ui/Android.bp
index 10cb992835..cb2e23297d 100644
--- a/libs/ui/Android.bp
+++ b/libs/ui/Android.bp
@@ -124,7 +124,6 @@ cc_library_shared {
         "DebugUtils.cpp",
         "DependencyMonitor.cpp",
         "DeviceProductInfo.cpp",
-        "DisplayIdentification.cpp",
         "DynamicDisplayInfo.cpp",
         "Fence.cpp",
         "FenceTime.cpp",
diff --git a/libs/ui/GraphicBuffer.cpp b/libs/ui/GraphicBuffer.cpp
index f7c94005f1..b5dd98bb59 100644
--- a/libs/ui/GraphicBuffer.cpp
+++ b/libs/ui/GraphicBuffer.cpp
@@ -75,7 +75,7 @@ static void resolveLegacyByteLayoutFromPlaneLayout(const std::vector<ui::PlaneLa
 }
 
 sp<GraphicBuffer> GraphicBuffer::from(ANativeWindowBuffer* anwb) {
-    return static_cast<GraphicBuffer *>(anwb);
+    return sp<GraphicBuffer>::fromExisting(static_cast<GraphicBuffer*>(anwb));
 }
 
 GraphicBuffer* GraphicBuffer::fromAHardwareBuffer(AHardwareBuffer* buffer) {
diff --git a/libs/ui/OWNERS b/libs/ui/OWNERS
index 2a85a4b493..d88c88be45 100644
--- a/libs/ui/OWNERS
+++ b/libs/ui/OWNERS
@@ -1,6 +1,7 @@
-adyabr@google.com
-alecmouri@google.com
+# Bug component: 1075130
+
+include /services/surfaceflinger/OWNERS
+
+# Historical owners
 chrisforbes@google.com
-jreck@google.com
 mathias@google.com
-romainguy@google.com
diff --git a/libs/ui/Transform.cpp b/libs/ui/Transform.cpp
index 23249fa4a9..711481c370 100644
--- a/libs/ui/Transform.cpp
+++ b/libs/ui/Transform.cpp
@@ -96,6 +96,11 @@ Transform Transform::operator * (float value) const {
             R[i][j] = M[i][j] * value;
         }
     }
+    if (value != 1.0) {
+        // If a non-unity scale is applied, the type might change.
+        // Mark it as UNKNOWN to force re-computation.
+        r.mType = UNKNOWN_TYPE;
+    }
     r.type();
     return r;
 }
diff --git a/libs/ui/include/ui/BlurRegion.h b/libs/ui/include/ui/BlurRegion.h
index a9ca369758..1ee53fe792 100644
--- a/libs/ui/include/ui/BlurRegion.h
+++ b/libs/ui/include/ui/BlurRegion.h
@@ -62,6 +62,15 @@ static inline void PrintTo(const BlurRegion& blurRegion, ::std::ostream* os) {
     *os << "\n}";
 }
 
+// copied from skia/src/core/SkBlurMask.cpp
+inline float convertBlurUserRadiusToSigma(float radius) {
+    return radius > 0 ? 0.57735f * radius + 0.5f : 0.0f;
+}
+// copied from skia/src/core/SkBlurEngine.h
+inline float convertBlurSigmaToKernelRadius(float sigma) {
+    return sigma <= 0.03f ? 0 : ceilf(3.f * sigma);
+}
+
 } // namespace android
 
 namespace std {
diff --git a/libs/ui/include/ui/LayerStack.h b/libs/ui/include/ui/LayerStack.h
index f4c8ba250e..fd952d8d1b 100644
--- a/libs/ui/include/ui/LayerStack.h
+++ b/libs/ui/include/ui/LayerStack.h
@@ -25,7 +25,7 @@
 namespace android::ui {
 
 // A LayerStack identifies a Z-ordered group of layers. A layer can only be associated to a single
-// LayerStack, but a LayerStack can be associated to multiple displays, mirroring the same content.
+// LayerStack, and a LayerStack should be unique to each display in the composition target.
 struct LayerStack {
     uint32_t id = UINT32_MAX;
 
@@ -40,7 +40,9 @@ struct LayerStack {
     }
 };
 
-constexpr LayerStack INVALID_LAYER_STACK;
+// An unassigned LayerStack can indicate that a layer is offscreen and will not be
+// rendered onto a display. Multiple displays are allowed to have unassigned LayerStacks.
+constexpr LayerStack UNASSIGNED_LAYER_STACK;
 constexpr LayerStack DEFAULT_LAYER_STACK{0u};
 
 inline bool operator==(LayerStack lhs, LayerStack rhs) {
@@ -70,7 +72,7 @@ struct LayerFilter {
     // Returns true if the input filter can be output to this filter.
     bool includes(LayerFilter other) const {
         // The layer stacks must match.
-        if (other.layerStack == INVALID_LAYER_STACK || other.layerStack != layerStack) {
+        if (other.layerStack == UNASSIGNED_LAYER_STACK || other.layerStack != layerStack) {
             return false;
         }
 
diff --git a/libs/ui/include/ui/ScreenPartStatus.h b/libs/ui/include/ui/ScreenPartStatus.h
new file mode 100644
index 0000000000..37f966a309
--- /dev/null
+++ b/libs/ui/include/ui/ScreenPartStatus.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <cstdint>
+
+namespace android {
+
+// These values must match the ones in ScreenPartStatus.aidl file in the composer HAL
+enum class ScreenPartStatus : uint8_t {
+    // Device cannot differentiate an original screen from a replaced screen.
+    UNSUPPORTED = 0,
+    // Device has the original screen it was manufactured with.
+    ORIGINAL = 1,
+    // Device has a replaced screen.
+    REPLACED = 2,
+
+    ftl_last = REPLACED
+};
+
+} // namespace android
diff --git a/libs/ui/include/ui/StaticDisplayInfo.h b/libs/ui/include/ui/StaticDisplayInfo.h
index 53164487f3..0d37abfd4c 100644
--- a/libs/ui/include/ui/StaticDisplayInfo.h
+++ b/libs/ui/include/ui/StaticDisplayInfo.h
@@ -20,6 +20,7 @@
 
 #include <ui/DeviceProductInfo.h>
 #include <ui/Rotation.h>
+#include <ui/ScreenPartStatus.h>
 
 namespace android::ui {
 
@@ -32,6 +33,7 @@ struct StaticDisplayInfo {
     float density = 0.f;
     bool secure = false;
     std::optional<DeviceProductInfo> deviceProductInfo;
+    android::ScreenPartStatus screenPartStatus;
     Rotation installOrientation = ROTATION_0;
 };
 
diff --git a/libs/ui/tests/Android.bp b/libs/ui/tests/Android.bp
index d950f2a23f..ae2366a995 100644
--- a/libs/ui/tests/Android.bp
+++ b/libs/ui/tests/Android.bp
@@ -44,17 +44,6 @@ cc_test {
     ],
 }
 
-cc_test {
-    name: "DisplayIdentification_test",
-    shared_libs: ["libui"],
-    static_libs: ["libgmock"],
-    srcs: ["DisplayIdentification_test.cpp"],
-    cflags: [
-        "-Wall",
-        "-Werror",
-    ],
-}
-
 cc_test {
     name: "FlattenableHelpers_test",
     shared_libs: ["libui"],
diff --git a/libs/ui/tests/Transform_test.cpp b/libs/ui/tests/Transform_test.cpp
index 6964284eaa..fa584e40bf 100644
--- a/libs/ui/tests/Transform_test.cpp
+++ b/libs/ui/tests/Transform_test.cpp
@@ -46,4 +46,15 @@ TEST(TransformTest, inverseRotation_hasCorrectType) {
     testRotationFlagsForInverse(Transform::FLIP_V, Transform::FLIP_V, false);
 }
 
+TEST(TransformTest, scaling_hasCorrectType) {
+    const Transform identityTransform = Transform();
+    EXPECT_TRUE(identityTransform.getType() == Transform::IDENTITY);
+
+    // An unity scale should keep transform unchanged.
+    EXPECT_TRUE(identityTransform == (identityTransform * 1.0));
+
+    // A non-unity scale should result in SCALE transform.
+    EXPECT_TRUE((identityTransform * 2.0).getType() == Transform::SCALE);
+}
+
 } // namespace android::ui
diff --git a/libs/vibrator/ExternalVibrationUtils.cpp b/libs/vibrator/ExternalVibrationUtils.cpp
index ca13afcbaf..f443f0afed 100644
--- a/libs/vibrator/ExternalVibrationUtils.cpp
+++ b/libs/vibrator/ExternalVibrationUtils.cpp
@@ -28,42 +28,9 @@
 namespace android::os {
 
 namespace {
-static constexpr float HAPTIC_SCALE_VERY_LOW_RATIO = 2.0f / 3.0f;
-static constexpr float HAPTIC_SCALE_LOW_RATIO = 3.0f / 4.0f;
-static constexpr float HAPTIC_MAX_AMPLITUDE_FLOAT = 1.0f;
 static constexpr float SCALE_GAMMA = 0.65f; // Same as VibrationEffect.SCALE_GAMMA
 static constexpr float SCALE_LEVEL_GAIN = 1.4f; // Same as VibrationConfig.DEFAULT_SCALE_LEVEL_GAIN
 
-float getOldHapticScaleGamma(HapticLevel level) {
-    switch (level) {
-    case HapticLevel::VERY_LOW:
-        return 2.0f;
-    case HapticLevel::LOW:
-        return 1.5f;
-    case HapticLevel::HIGH:
-        return 0.5f;
-    case HapticLevel::VERY_HIGH:
-        return 0.25f;
-    default:
-        return 1.0f;
-    }
-}
-
-float getOldHapticMaxAmplitudeRatio(HapticLevel level) {
-    switch (level) {
-    case HapticLevel::VERY_LOW:
-        return HAPTIC_SCALE_VERY_LOW_RATIO;
-    case HapticLevel::LOW:
-        return HAPTIC_SCALE_LOW_RATIO;
-    case HapticLevel::NONE:
-    case HapticLevel::HIGH:
-    case HapticLevel::VERY_HIGH:
-        return 1.0f;
-    default:
-        return 0.0f;
-    }
-}
-
 /* Same as VibrationScaler.getScaleFactor */
 float getHapticScaleFactor(HapticScale scale) {
     if (android_os_vibrator_haptics_scale_v2_enabled()) {
@@ -105,13 +72,7 @@ float getHapticScaleFactor(HapticScale scale) {
     }
 }
 
-float applyOldHapticScale(float value, float gamma, float maxAmplitudeRatio) {
-    float sign = value >= 0 ? 1.0 : -1.0;
-    return powf(fabsf(value / HAPTIC_MAX_AMPLITUDE_FLOAT), gamma)
-                * maxAmplitudeRatio * HAPTIC_MAX_AMPLITUDE_FLOAT * sign;
-}
-
-float applyNewHapticScale(float value, float scaleFactor) {
+float applyHapticScale(float value, float scaleFactor) {
     if (android_os_vibrator_haptics_scale_v2_enabled()) {
         if (scaleFactor <= 1 || value == 0) {
             return value * scaleFactor;
@@ -154,17 +115,10 @@ void applyHapticScale(float* buffer, size_t length, HapticScale scale) {
     HapticLevel hapticLevel = scale.getLevel();
     float scaleFactor = getHapticScaleFactor(scale);
     float adaptiveScaleFactor = scale.getAdaptiveScaleFactor();
-    float oldGamma = getOldHapticScaleGamma(hapticLevel);
-    float oldMaxAmplitudeRatio = getOldHapticMaxAmplitudeRatio(hapticLevel);
 
     for (size_t i = 0; i < length; i++) {
         if (hapticLevel != HapticLevel::NONE) {
-            if (android_os_vibrator_fix_audio_coupled_haptics_scaling() ||
-                android_os_vibrator_haptics_scale_v2_enabled()) {
-                buffer[i] = applyNewHapticScale(buffer[i], scaleFactor);
-            } else {
-                buffer[i] = applyOldHapticScale(buffer[i], oldGamma, oldMaxAmplitudeRatio);
-            }
+            buffer[i] = applyHapticScale(buffer[i], scaleFactor);
         }
 
         if (adaptiveScaleFactor >= 0 && adaptiveScaleFactor != 1.0f) {
diff --git a/libs/vibrator/tests/ExternalVibrationUtilsTest.cpp b/libs/vibrator/tests/ExternalVibrationUtilsTest.cpp
index 9369f80da3..fb464b88c2 100644
--- a/libs/vibrator/tests/ExternalVibrationUtilsTest.cpp
+++ b/libs/vibrator/tests/ExternalVibrationUtilsTest.cpp
@@ -64,18 +64,7 @@ protected:
     float mBuffer[TEST_BUFFER_LENGTH];
 };
 
-TEST_F_WITH_FLAGS(ExternalVibrationUtilsTest, TestLegacyScaleMute,
-                  REQUIRES_FLAGS_DISABLED(ACONFIG_FLAG(FLAG_NS, fix_audio_coupled_haptics_scaling),
-                                          ACONFIG_FLAG(FLAG_NS, haptics_scale_v2_enabled))) {
-    float expected[TEST_BUFFER_LENGTH];
-    std::fill(std::begin(expected), std::end(expected), 0);
-
-    scaleBuffer(HapticLevel::MUTE);
-    EXPECT_FLOATS_NEARLY_EQ(expected, mBuffer, TEST_BUFFER_LENGTH, TEST_TOLERANCE);
-}
-
-TEST_F_WITH_FLAGS(ExternalVibrationUtilsTest, TestFixedScaleMute,
-                  REQUIRES_FLAGS_ENABLED(ACONFIG_FLAG(FLAG_NS, fix_audio_coupled_haptics_scaling)),
+TEST_F_WITH_FLAGS(ExternalVibrationUtilsTest, TestScaleMute,
                   REQUIRES_FLAGS_DISABLED(ACONFIG_FLAG(FLAG_NS, haptics_scale_v2_enabled))) {
     float expected[TEST_BUFFER_LENGTH];
     std::fill(std::begin(expected), std::end(expected), 0);
@@ -84,10 +73,8 @@ TEST_F_WITH_FLAGS(ExternalVibrationUtilsTest, TestFixedScaleMute,
     EXPECT_FLOATS_NEARLY_EQ(expected, mBuffer, TEST_BUFFER_LENGTH, TEST_TOLERANCE);
 }
 
-TEST_F_WITH_FLAGS(
-        ExternalVibrationUtilsTest, TestScaleV2Mute,
-        // Value of fix_audio_coupled_haptics_scaling is not important, should work with either
-        REQUIRES_FLAGS_ENABLED(ACONFIG_FLAG(FLAG_NS, haptics_scale_v2_enabled))) {
+TEST_F_WITH_FLAGS(ExternalVibrationUtilsTest, TestScaleV2Mute,
+                  REQUIRES_FLAGS_ENABLED(ACONFIG_FLAG(FLAG_NS, haptics_scale_v2_enabled))) {
     float expected[TEST_BUFFER_LENGTH];
     std::fill(std::begin(expected), std::end(expected), 0);
 
@@ -95,18 +82,7 @@ TEST_F_WITH_FLAGS(
     EXPECT_FLOATS_NEARLY_EQ(expected, mBuffer, TEST_BUFFER_LENGTH, TEST_TOLERANCE);
 }
 
-TEST_F_WITH_FLAGS(ExternalVibrationUtilsTest, TestLegacyScaleNone,
-                  REQUIRES_FLAGS_DISABLED(ACONFIG_FLAG(FLAG_NS, fix_audio_coupled_haptics_scaling),
-                                          ACONFIG_FLAG(FLAG_NS, haptics_scale_v2_enabled))) {
-    float expected[TEST_BUFFER_LENGTH];
-    std::copy(std::begin(TEST_BUFFER), std::end(TEST_BUFFER), std::begin(expected));
-
-    scaleBuffer(HapticLevel::NONE);
-    EXPECT_FLOATS_NEARLY_EQ(expected, mBuffer, TEST_BUFFER_LENGTH, TEST_TOLERANCE);
-}
-
-TEST_F_WITH_FLAGS(ExternalVibrationUtilsTest, TestFixedScaleNone,
-                  REQUIRES_FLAGS_ENABLED(ACONFIG_FLAG(FLAG_NS, fix_audio_coupled_haptics_scaling)),
+TEST_F_WITH_FLAGS(ExternalVibrationUtilsTest, TestScaleNone,
                   REQUIRES_FLAGS_DISABLED(ACONFIG_FLAG(FLAG_NS, haptics_scale_v2_enabled))) {
     float expected[TEST_BUFFER_LENGTH];
     std::copy(std::begin(TEST_BUFFER), std::end(TEST_BUFFER), std::begin(expected));
@@ -115,10 +91,8 @@ TEST_F_WITH_FLAGS(ExternalVibrationUtilsTest, TestFixedScaleNone,
     EXPECT_FLOATS_NEARLY_EQ(expected, mBuffer, TEST_BUFFER_LENGTH, TEST_TOLERANCE);
 }
 
-TEST_F_WITH_FLAGS(
-        ExternalVibrationUtilsTest, TestScaleV2None,
-        // Value of fix_audio_coupled_haptics_scaling is not important, should work with either
-        REQUIRES_FLAGS_ENABLED(ACONFIG_FLAG(FLAG_NS, haptics_scale_v2_enabled))) {
+TEST_F_WITH_FLAGS(ExternalVibrationUtilsTest, TestScaleV2None,
+                  REQUIRES_FLAGS_ENABLED(ACONFIG_FLAG(FLAG_NS, haptics_scale_v2_enabled))) {
     float expected[TEST_BUFFER_LENGTH];
     std::copy(std::begin(TEST_BUFFER), std::end(TEST_BUFFER), std::begin(expected));
 
@@ -126,28 +100,7 @@ TEST_F_WITH_FLAGS(
     EXPECT_FLOATS_NEARLY_EQ(expected, mBuffer, TEST_BUFFER_LENGTH, TEST_TOLERANCE);
 }
 
-TEST_F_WITH_FLAGS(ExternalVibrationUtilsTest, TestLegacyScaleToHapticLevel,
-                  REQUIRES_FLAGS_DISABLED(ACONFIG_FLAG(FLAG_NS, fix_audio_coupled_haptics_scaling),
-                                          ACONFIG_FLAG(FLAG_NS, haptics_scale_v2_enabled))) {
-    float expectedVeryHigh[TEST_BUFFER_LENGTH] = { 1, -1, 0.84f, -0.66f };
-    scaleBuffer(HapticLevel::VERY_HIGH);
-    EXPECT_FLOATS_NEARLY_EQ(expectedVeryHigh, mBuffer, TEST_BUFFER_LENGTH, TEST_TOLERANCE);
-
-    float expectedHigh[TEST_BUFFER_LENGTH] = { 1, -1, 0.7f, -0.44f };
-    scaleBuffer(HapticLevel::HIGH);
-    EXPECT_FLOATS_NEARLY_EQ(expectedHigh, mBuffer, TEST_BUFFER_LENGTH, TEST_TOLERANCE);
-
-    float expectedLow[TEST_BUFFER_LENGTH] = { 0.75f, -0.75f, 0.26f, -0.06f };
-    scaleBuffer(HapticLevel::LOW);
-    EXPECT_FLOATS_NEARLY_EQ(expectedLow, mBuffer, TEST_BUFFER_LENGTH, TEST_TOLERANCE);
-
-    float expectedVeryLow[TEST_BUFFER_LENGTH] = { 0.66f, -0.66f, 0.16f, -0.02f };
-    scaleBuffer(HapticLevel::VERY_LOW);
-    EXPECT_FLOATS_NEARLY_EQ(expectedVeryLow, mBuffer, TEST_BUFFER_LENGTH, TEST_TOLERANCE);
-}
-
-TEST_F_WITH_FLAGS(ExternalVibrationUtilsTest, TestFixedScaleToHapticLevel,
-                  REQUIRES_FLAGS_ENABLED(ACONFIG_FLAG(FLAG_NS, fix_audio_coupled_haptics_scaling)),
+TEST_F_WITH_FLAGS(ExternalVibrationUtilsTest, TestScaleToHapticLevel,
                   REQUIRES_FLAGS_DISABLED(ACONFIG_FLAG(FLAG_NS, haptics_scale_v2_enabled))) {
     float expectedVeryHigh[TEST_BUFFER_LENGTH] = { 1, -1, 0.79f, -0.39f };
     scaleBuffer(HapticLevel::VERY_HIGH);
@@ -166,10 +119,8 @@ TEST_F_WITH_FLAGS(ExternalVibrationUtilsTest, TestFixedScaleToHapticLevel,
     EXPECT_FLOATS_NEARLY_EQ(expectedVeryLow, mBuffer, TEST_BUFFER_LENGTH, TEST_TOLERANCE);
 }
 
-TEST_F_WITH_FLAGS(
-        ExternalVibrationUtilsTest, TestScaleV2ToHapticLevel,
-        // Value of fix_audio_coupled_haptics_scaling is not important, should work with either
-        REQUIRES_FLAGS_ENABLED(ACONFIG_FLAG(FLAG_NS, haptics_scale_v2_enabled))) {
+TEST_F_WITH_FLAGS(ExternalVibrationUtilsTest, TestScaleV2ToHapticLevel,
+                  REQUIRES_FLAGS_ENABLED(ACONFIG_FLAG(FLAG_NS, haptics_scale_v2_enabled))) {
     float expectedVeryHigh[TEST_BUFFER_LENGTH] = { 1, -1, 0.8f, -0.38f };
     scaleBuffer(HapticLevel::VERY_HIGH);
     EXPECT_FLOATS_NEARLY_EQ(expectedVeryHigh, mBuffer, TEST_BUFFER_LENGTH, TEST_TOLERANCE);
@@ -187,20 +138,16 @@ TEST_F_WITH_FLAGS(
     EXPECT_FLOATS_NEARLY_EQ(expectedVeryLow, mBuffer, TEST_BUFFER_LENGTH, TEST_TOLERANCE);
 }
 
-TEST_F_WITH_FLAGS(
-        ExternalVibrationUtilsTest, TestScaleV2ToScaleFactorUndefinedUsesHapticLevel,
-        // Value of fix_audio_coupled_haptics_scaling is not important, should work with either
-        REQUIRES_FLAGS_ENABLED(ACONFIG_FLAG(FLAG_NS, haptics_scale_v2_enabled))) {
+TEST_F_WITH_FLAGS(ExternalVibrationUtilsTest, TestScaleV2ToScaleFactorUndefinedUsesHapticLevel,
+                  REQUIRES_FLAGS_ENABLED(ACONFIG_FLAG(FLAG_NS, haptics_scale_v2_enabled))) {
     constexpr float adaptiveScaleNone = 1.0f;
     float expectedVeryHigh[TEST_BUFFER_LENGTH] = {1, -1, 0.8f, -0.38f};
     scaleBuffer(HapticScale(HapticLevel::VERY_HIGH, -1.0f /* scaleFactor */, adaptiveScaleNone));
     EXPECT_FLOATS_NEARLY_EQ(expectedVeryHigh, mBuffer, TEST_BUFFER_LENGTH, TEST_TOLERANCE);
 }
 
-TEST_F_WITH_FLAGS(
-        ExternalVibrationUtilsTest, TestScaleV2ToScaleFactorIgnoresLevel,
-        // Value of fix_audio_coupled_haptics_scaling is not important, should work with either
-        REQUIRES_FLAGS_ENABLED(ACONFIG_FLAG(FLAG_NS, haptics_scale_v2_enabled))) {
+TEST_F_WITH_FLAGS(ExternalVibrationUtilsTest, TestScaleV2ToScaleFactorIgnoresLevel,
+                  REQUIRES_FLAGS_ENABLED(ACONFIG_FLAG(FLAG_NS, haptics_scale_v2_enabled))) {
     constexpr float adaptiveScaleNone = 1.0f;
 
     float expectedVeryHigh[TEST_BUFFER_LENGTH] = { 1, -1, 1, -0.55f };
@@ -220,54 +167,14 @@ TEST_F_WITH_FLAGS(
     EXPECT_FLOATS_NEARLY_EQ(expectedVeryLow, mBuffer, TEST_BUFFER_LENGTH, TEST_TOLERANCE);
 }
 
-TEST_F_WITH_FLAGS(ExternalVibrationUtilsTest, TestAdaptiveScaleFactorUndefinedIsIgnoredLegacyScale,
-                  REQUIRES_FLAGS_DISABLED(ACONFIG_FLAG(FLAG_NS, fix_audio_coupled_haptics_scaling),
-                                          ACONFIG_FLAG(FLAG_NS, haptics_scale_v2_enabled))) {
-    float expectedVeryHigh[TEST_BUFFER_LENGTH] = {1, -1, 0.79f, -0.39f};
-    scaleBuffer(HapticLevel::VERY_HIGH, -1.0f /* adaptiveScaleFactor */);
-    EXPECT_FLOATS_NEARLY_EQ(expectedVeryHigh, mBuffer, TEST_BUFFER_LENGTH, TEST_TOLERANCE);
-}
-
-TEST_F_WITH_FLAGS(ExternalVibrationUtilsTest, TestAdaptiveScaleFactorAppliedAfterLegacyScale,
-                  REQUIRES_FLAGS_DISABLED(ACONFIG_FLAG(FLAG_NS, fix_audio_coupled_haptics_scaling),
-                                          ACONFIG_FLAG(FLAG_NS, haptics_scale_v2_enabled))) {
-    // Adaptive scale mutes vibration
-    float expectedMuted[TEST_BUFFER_LENGTH];
-    std::fill(std::begin(expectedMuted), std::end(expectedMuted), 0);
-    scaleBuffer(HapticLevel::VERY_HIGH, 0.0f /* adaptiveScaleFactor */);
-    EXPECT_FLOATS_NEARLY_EQ(expectedMuted, mBuffer, TEST_BUFFER_LENGTH, TEST_TOLERANCE);
-
-    // Haptic level scale up then adaptive scale down
-    float expectedVeryHigh[TEST_BUFFER_LENGTH] = { 0.2, -0.2, 0.16f, -0.13f };
-    scaleBuffer(HapticLevel::VERY_HIGH, 0.2f /* adaptiveScaleFactor */);
-    EXPECT_FLOATS_NEARLY_EQ(expectedVeryHigh, mBuffer, TEST_BUFFER_LENGTH, TEST_TOLERANCE);
-
-    // Haptic level scale up then adaptive scale up
-    float expectedHigh[TEST_BUFFER_LENGTH] = { 1.5f, -1.5f, 1.06f, -0.67f };
-    scaleBuffer(HapticLevel::HIGH, 1.5f /* adaptiveScaleFactor */);
-    EXPECT_FLOATS_NEARLY_EQ(expectedHigh, mBuffer, TEST_BUFFER_LENGTH, TEST_TOLERANCE);
-
-    // Haptic level scale down then adaptive scale down
-    float expectedLow[TEST_BUFFER_LENGTH] = { 0.45f, -0.45f, 0.15f, -0.04f };
-    scaleBuffer(HapticLevel::LOW, 0.6f /* adaptiveScaleFactor */);
-    EXPECT_FLOATS_NEARLY_EQ(expectedLow, mBuffer, TEST_BUFFER_LENGTH, TEST_TOLERANCE);
-
-    // Haptic level scale down then adaptive scale up
-    float expectedVeryLow[TEST_BUFFER_LENGTH] = { 1.33f, -1.33f, 0.33f, -0.05f };
-    scaleBuffer(HapticLevel::VERY_LOW, 2 /* adaptiveScaleFactor */);
-    EXPECT_FLOATS_NEARLY_EQ(expectedVeryLow, mBuffer, TEST_BUFFER_LENGTH, TEST_TOLERANCE);
-}
-
-TEST_F_WITH_FLAGS(ExternalVibrationUtilsTest, TestAdaptiveScaleFactorUndefinedIgnoredFixedScale,
-                  REQUIRES_FLAGS_ENABLED(ACONFIG_FLAG(FLAG_NS, fix_audio_coupled_haptics_scaling)),
+TEST_F_WITH_FLAGS(ExternalVibrationUtilsTest, TestAdaptiveScaleFactorUndefinedIgnoredScale,
                   REQUIRES_FLAGS_DISABLED(ACONFIG_FLAG(FLAG_NS, haptics_scale_v2_enabled))) {
     float expectedVeryHigh[TEST_BUFFER_LENGTH] = {1, -1, 0.79f, -0.39f};
     scaleBuffer(HapticLevel::VERY_HIGH, -1.0f /* adaptiveScaleFactor */);
     EXPECT_FLOATS_NEARLY_EQ(expectedVeryHigh, mBuffer, TEST_BUFFER_LENGTH, TEST_TOLERANCE);
 }
 
-TEST_F_WITH_FLAGS(ExternalVibrationUtilsTest, TestAdaptiveScaleFactorAppliedAfterFixedScale,
-                  REQUIRES_FLAGS_ENABLED(ACONFIG_FLAG(FLAG_NS, fix_audio_coupled_haptics_scaling)),
+TEST_F_WITH_FLAGS(ExternalVibrationUtilsTest, TestAdaptiveScaleFactorAppliedAfterScale,
                   REQUIRES_FLAGS_DISABLED(ACONFIG_FLAG(FLAG_NS, haptics_scale_v2_enabled))) {
     // Adaptive scale mutes vibration
     float expectedMuted[TEST_BUFFER_LENGTH];
@@ -296,19 +203,15 @@ TEST_F_WITH_FLAGS(ExternalVibrationUtilsTest, TestAdaptiveScaleFactorAppliedAfte
     EXPECT_FLOATS_NEARLY_EQ(expectedVeryLow, mBuffer, TEST_BUFFER_LENGTH, TEST_TOLERANCE);
 }
 
-TEST_F_WITH_FLAGS(
-        ExternalVibrationUtilsTest, TestAdaptiveScaleFactorUndefinedIgnoredScaleV2,
-        // Value of fix_audio_coupled_haptics_scaling is not important, should work with either
-        REQUIRES_FLAGS_ENABLED(ACONFIG_FLAG(FLAG_NS, haptics_scale_v2_enabled))) {
+TEST_F_WITH_FLAGS(ExternalVibrationUtilsTest, TestAdaptiveScaleFactorUndefinedIgnoredScaleV2,
+                  REQUIRES_FLAGS_ENABLED(ACONFIG_FLAG(FLAG_NS, haptics_scale_v2_enabled))) {
     float expectedVeryHigh[TEST_BUFFER_LENGTH] = {1, -1, 0.8f, -0.38f};
     scaleBuffer(HapticLevel::VERY_HIGH, -1.0f /* adaptiveScaleFactor */);
     EXPECT_FLOATS_NEARLY_EQ(expectedVeryHigh, mBuffer, TEST_BUFFER_LENGTH, TEST_TOLERANCE);
 }
 
-TEST_F_WITH_FLAGS(
-        ExternalVibrationUtilsTest, TestAdaptiveScaleFactorAppliedAfterScaleV2,
-        // Value of fix_audio_coupled_haptics_scaling is not important, should work with either
-        REQUIRES_FLAGS_ENABLED(ACONFIG_FLAG(FLAG_NS, haptics_scale_v2_enabled))) {
+TEST_F_WITH_FLAGS(ExternalVibrationUtilsTest, TestAdaptiveScaleFactorAppliedAfterScaleV2,
+                  REQUIRES_FLAGS_ENABLED(ACONFIG_FLAG(FLAG_NS, haptics_scale_v2_enabled))) {
     // Adaptive scale mutes vibration
     float expectedMuted[TEST_BUFFER_LENGTH];
     std::fill(std::begin(expectedMuted), std::end(expectedMuted), 0);
@@ -336,22 +239,7 @@ TEST_F_WITH_FLAGS(
     EXPECT_FLOATS_NEARLY_EQ(expectedVeryLow, mBuffer, TEST_BUFFER_LENGTH, TEST_TOLERANCE);
 }
 
-TEST_F_WITH_FLAGS(ExternalVibrationUtilsTest, TestLimitAppliedAfterLegacyScale,
-                  REQUIRES_FLAGS_DISABLED(ACONFIG_FLAG(FLAG_NS, fix_audio_coupled_haptics_scaling),
-                                          ACONFIG_FLAG(FLAG_NS, haptics_scale_v2_enabled))) {
-    // Scaled = { 0.2, -0.2, 0.16f, -0.13f };
-    float expectedClippedVeryHigh[TEST_BUFFER_LENGTH] = { 0.15f, -0.15f, 0.15f, -0.13f };
-    scaleBuffer(HapticLevel::VERY_HIGH, 0.2f /* adaptiveScaleFactor */, 0.15f /* limit */);
-    EXPECT_FLOATS_NEARLY_EQ(expectedClippedVeryHigh, mBuffer, TEST_BUFFER_LENGTH, TEST_TOLERANCE);
-
-    // Scaled = { 1, -1, 0.5f, -0.2f };
-    float expectedClippedVeryLow[TEST_BUFFER_LENGTH] = { 0.7f, -0.7f, 0.33f, -0.05f };
-    scaleBuffer(HapticLevel::VERY_LOW, 2 /* adaptiveScaleFactor */, 0.7f /* limit */);
-    EXPECT_FLOATS_NEARLY_EQ(expectedClippedVeryLow, mBuffer, TEST_BUFFER_LENGTH, TEST_TOLERANCE);
-}
-
-TEST_F_WITH_FLAGS(ExternalVibrationUtilsTest, TestLimitAppliedAfterFixedScale,
-                  REQUIRES_FLAGS_ENABLED(ACONFIG_FLAG(FLAG_NS, fix_audio_coupled_haptics_scaling)),
+TEST_F_WITH_FLAGS(ExternalVibrationUtilsTest, TestLimitAppliedAfterScale,
                   REQUIRES_FLAGS_DISABLED(ACONFIG_FLAG(FLAG_NS, haptics_scale_v2_enabled))) {
     // Scaled = { 0.2, -0.2, 0.16f, -0.13f };
     float expectedClippedVeryHigh[TEST_BUFFER_LENGTH] = { 0.15f, -0.15f, 0.15f, -0.07f };
@@ -364,10 +252,8 @@ TEST_F_WITH_FLAGS(ExternalVibrationUtilsTest, TestLimitAppliedAfterFixedScale,
     EXPECT_FLOATS_NEARLY_EQ(expectedClippedVeryLow, mBuffer, TEST_BUFFER_LENGTH, TEST_TOLERANCE);
 }
 
-TEST_F_WITH_FLAGS(
-        ExternalVibrationUtilsTest, TestLimitAppliedAfterScaleV2,
-        // Value of fix_audio_coupled_haptics_scaling is not important, should work with either
-        REQUIRES_FLAGS_ENABLED(ACONFIG_FLAG(FLAG_NS, haptics_scale_v2_enabled))) {
+TEST_F_WITH_FLAGS(ExternalVibrationUtilsTest, TestLimitAppliedAfterScaleV2,
+                  REQUIRES_FLAGS_ENABLED(ACONFIG_FLAG(FLAG_NS, haptics_scale_v2_enabled))) {
     // Scaled = { 0.2, -0.2, 0.15f, -0.07f };
     float expectedClippedVeryHigh[TEST_BUFFER_LENGTH] = { 0.15f, -0.15f, 0.15f, -0.07f };
     scaleBuffer(HapticLevel::VERY_HIGH, 0.2f /* adaptiveScaleFactor */, 0.15f /* limit */);
diff --git a/opengl/OWNERS b/opengl/OWNERS
index 645a578c76..6f00e26dfa 100644
--- a/opengl/OWNERS
+++ b/opengl/OWNERS
@@ -3,3 +3,4 @@ cnorthrop@google.com
 ianelliott@google.com
 jessehall@google.com
 tomnom@google.com
+nikigupta@google.com
\ No newline at end of file
diff --git a/opengl/libs/EGL/egl_platform_entries.cpp b/opengl/libs/EGL/egl_platform_entries.cpp
index 6713a5c69d..65a28f9a72 100644
--- a/opengl/libs/EGL/egl_platform_entries.cpp
+++ b/opengl/libs/EGL/egl_platform_entries.cpp
@@ -617,11 +617,19 @@ void getNativePixelFormat(EGLDisplay dpy, egl_connection_t* cnx, EGLConfig confi
     if (a == 0) {
         if (8 == r && 0 == g && 0 == b) {
             *format = PixelFormat::R_8;
+        } else if (12 == r && 0 == g && 0 == b) {
+            *format = PixelFormat::R_12_UINT;
+        } else if (14 == r && 0 == g && 0 == b) {
+            *format = PixelFormat::R_14_UINT;
         } else if (colorDepth <= 16) {
             *format = PixelFormat::RGB_565;
         } else {
             if (componentType == EGL_COLOR_COMPONENT_TYPE_FIXED_EXT) {
-                if (colorDepth > 24) {
+                if (12 == r && 12 == g && 0 == b) {
+                    *format = PixelFormat::RG_1212_UINT;
+                } else if (14 == r && 14 == g && 0 == b) {
+                    *format = PixelFormat::RG_1414_UINT;
+                } else if (colorDepth > 24) {
                     *format = PixelFormat::RGBA_1010102;
                 } else {
                     *format = PixelFormat::RGBX_8888;
@@ -632,7 +640,11 @@ void getNativePixelFormat(EGLDisplay dpy, egl_connection_t* cnx, EGLConfig confi
         }
     } else {
         if (componentType == EGL_COLOR_COMPONENT_TYPE_FIXED_EXT) {
-            if (colorDepth > 24) {
+            if (12 == r && 12 == g && 12 == b) {
+                *format = PixelFormat::RGBA_12121212_UINT;
+            } else if (14 == r && 14 == g && 14 == b) {
+                *format = PixelFormat::RGBA_14141414_UINT;
+            } else if (colorDepth > 24) {
                 *format = PixelFormat::RGBA_1010102;
             } else {
                 *format = PixelFormat::RGBA_8888;
@@ -1184,6 +1196,12 @@ static __eglMustCastToProperFunctionPointerType findBuiltinWrapper(const char* p
 }
 
 __eglMustCastToProperFunctionPointerType eglGetProcAddressImpl(const char* procname) {
+    // This is not required by the EGL spec, but we're choosing to fail gracefully (return nullptr)
+    // rather than performing undefined behavior (crashing).
+    if (procname == nullptr) {
+        return nullptr;
+    }
+
     if (FILTER_EXTENSIONS(procname)) {
         return nullptr;
     }
diff --git a/opengl/libs/libEGL.map.txt b/opengl/libs/libEGL.map.txt
index 0c14e01c7b..995d36cca6 100644
--- a/opengl/libs/libEGL.map.txt
+++ b/opengl/libs/libEGL.map.txt
@@ -4,7 +4,7 @@ LIBEGL {
     eglBindTexImage;
     eglChooseConfig;
     eglClientWaitSync; # introduced=29
-    eglClientWaitSyncKHR; # introduced-arm=18 introduced-arm64=21 introduced-mips=18 introduced-mips64=21 introduced-x86=18 introduced-x86_64=21
+    eglClientWaitSyncKHR;
     eglCopyBuffers;
     eglCreateContext;
     eglCreateImage; # introduced=29
@@ -19,7 +19,7 @@ LIBEGL {
     eglCreateStreamKHR; # introduced=23
     eglCreateStreamProducerSurfaceKHR; # introduced=23
     eglCreateSync; # introduced=29
-    eglCreateSyncKHR; # introduced-arm=18 introduced-arm64=21 introduced-mips=18 introduced-mips64=21 introduced-x86=18 introduced-x86_64=21
+    eglCreateSyncKHR;
     eglCreateWindowSurface;
     eglDestroyContext;
     eglDestroyImage; # introduced=29
@@ -27,7 +27,7 @@ LIBEGL {
     eglDestroyStreamKHR; # introduced=23
     eglDestroySurface;
     eglDestroySync; # introduced=29
-    eglDestroySyncKHR; # introduced-arm=18 introduced-arm64=21 introduced-mips=18 introduced-mips64=21 introduced-x86=18 introduced-x86_64=21
+    eglDestroySyncKHR;
     eglDupNativeFenceFDANDROID; # llndk
     eglGetConfigAttrib;
     eglGetConfigs;
@@ -41,13 +41,13 @@ LIBEGL {
     eglGetProcAddress;
     eglGetStreamFileDescriptorKHR; # introduced=23
     eglGetSyncAttrib; # introduced=29
-    eglGetSyncAttribKHR; # introduced-arm=18 introduced-arm64=21 introduced-mips=18 introduced-mips64=21 introduced-x86=18 introduced-x86_64=21
-    eglGetSystemTimeFrequencyNV; # introduced-arm=14 introduced-arm64=21 introduced-mips=14 introduced-mips64=21 introduced-x86=14 introduced-x86_64=21
-    eglGetSystemTimeNV; # introduced-arm=14 introduced-arm64=21 introduced-mips=14 introduced-mips64=21 introduced-x86=14 introduced-x86_64=21
+    eglGetSyncAttribKHR;
+    eglGetSystemTimeFrequencyNV;
+    eglGetSystemTimeNV;
     eglInitialize;
     eglLockSurfaceKHR;
     eglMakeCurrent;
-    eglPresentationTimeANDROID; # introduced-arm=18 introduced-arm64=21 introduced-mips=18 introduced-mips64=21 introduced-x86=18 introduced-x86_64=21
+    eglPresentationTimeANDROID;
     eglQueryAPI;
     eglQueryContext;
     eglQueryStreamKHR; # introduced=23
@@ -59,7 +59,7 @@ LIBEGL {
     eglReleaseTexImage;
     eglReleaseThread;
     eglSetDamageRegionKHR; # introduced=23
-    eglSignalSyncKHR; # introduced-arm=18 introduced-arm64=21 introduced-mips=18 introduced-mips64=21 introduced-x86=18 introduced-x86_64=21
+    eglSignalSyncKHR;
     eglStreamAttribKHR; # introduced=23
     eglStreamConsumerAcquireKHR; # introduced=23
     eglStreamConsumerGLTextureExternalKHR; # introduced=23
@@ -74,7 +74,7 @@ LIBEGL {
     eglWaitGL;
     eglWaitNative;
     eglWaitSync; # introduced=29
-    eglWaitSyncKHR; # introduced-arm=18 introduced-arm64=21 introduced-mips=18 introduced-mips64=21 introduced-x86=18 introduced-x86_64=21
+    eglWaitSyncKHR;
   local:
     *;
 };
diff --git a/services/gpuservice/Android.bp b/services/gpuservice/Android.bp
index 74e354f09c..0a9204a6da 100644
--- a/services/gpuservice/Android.bp
+++ b/services/gpuservice/Android.bp
@@ -7,13 +7,6 @@ package {
     default_applicable_licenses: ["frameworks_native_license"],
 }
 
-aconfig_declarations {
-    name: "gpuservice_flags",
-    package: "com.android.frameworks.gpuservice.flags",
-    container: "system",
-    srcs: ["gpuservice_flags.aconfig"],
-}
-
 cc_defaults {
     name: "gpuservice_defaults",
     cflags: [
@@ -26,11 +19,6 @@ cc_defaults {
     ],
 }
 
-cc_aconfig_library {
-    name: "gpuservice_multiuser_flags_c_lib",
-    aconfig_declarations: "gpuservice_flags",
-}
-
 cc_aconfig_library {
     name: "gpuservice_flags_c_lib",
     aconfig_declarations: "graphicsenv_flags",
@@ -105,9 +93,6 @@ cc_library_static {
     srcs: [
         ":libgpuservice_sources",
     ],
-    shared_libs: [
-        "gpuservice_multiuser_flags_c_lib",
-    ],
 }
 
 cc_defaults {
@@ -142,7 +127,4 @@ cc_binary {
     static_libs: [
         "libgpuservice",
     ],
-    shared_libs: [
-        "gpuservice_multiuser_flags_c_lib",
-    ],
 }
diff --git a/services/gpuservice/GpuService.cpp b/services/gpuservice/GpuService.cpp
index 46327dfbe7..d7d1f85d05 100644
--- a/services/gpuservice/GpuService.cpp
+++ b/services/gpuservice/GpuService.cpp
@@ -24,7 +24,6 @@
 #include <binder/IResultReceiver.h>
 #include <binder/Parcel.h>
 #include <binder/PermissionCache.h>
-#include <com_android_frameworks_gpuservice_flags.h>
 #include <com_android_graphics_graphicsenv_flags.h>
 #include <cutils/properties.h>
 #include <cutils/multiuser.h>
@@ -42,7 +41,6 @@
 #include <thread>
 #include <memory>
 
-namespace gpuservice_flags = com::android::frameworks::gpuservice::flags;
 namespace graphicsenv_flags = com::android::graphics::graphicsenv::flags;
 
 namespace android {
@@ -120,22 +118,13 @@ void GpuService::toggleAngleAsSystemDriver(bool enabled) {
 
     // only system_server with the ACCESS_GPU_SERVICE permission is allowed to set
     // persist.graphics.egl
-    if (gpuservice_flags::multiuser_permission_check()) {
-        // retrieve the appid of Settings app on multiuser builds
-        const int multiuserappid = multiuser_get_app_id(uid);
-        if (multiuserappid != AID_SYSTEM ||
-            !PermissionCache::checkPermission(sAccessGpuServicePermission, pid, uid)) {
-            ALOGE("Permission Denial: can't set persist.graphics.egl from setAngleAsSystemDriver() "
+    // retrieve the appid of Settings app on multiuser builds
+    const int multiuserappid = multiuser_get_app_id(uid);
+    if (multiuserappid != AID_SYSTEM ||
+        !PermissionCache::checkPermission(sAccessGpuServicePermission, pid, uid)) {
+        ALOGE("Permission Denial: can't set persist.graphics.egl from setAngleAsSystemDriver() "
                 "pid=%d, uid=%d\n, multiuserappid=%d", pid, uid, multiuserappid);
-            return;
-        }
-    } else {
-        if (uid != AID_SYSTEM ||
-            !PermissionCache::checkPermission(sAccessGpuServicePermission, pid, uid)) {
-            ALOGE("Permission Denial: can't set persist.graphics.egl from setAngleAsSystemDriver() "
-                "pid=%d, uid=%d\n", pid, uid);
-            return;
-        }
+        return;
     }
 
     std::lock_guard<std::mutex> lock(mLock);
@@ -146,6 +135,11 @@ void GpuService::toggleAngleAsSystemDriver(bool enabled) {
     }
 }
 
+std::string GpuService::getPersistGraphicsEgl() {
+    std::lock_guard<std::mutex> lock(mLock);
+    return android::base::GetProperty("persist.graphics.egl", "");
+}
+
 FeatureOverrides GpuService::getFeatureOverrides() {
     if (!graphicsenv_flags::angle_feature_overrides()) {
         FeatureOverrides featureOverrides;
diff --git a/services/gpuservice/bpfprogs/Android.bp b/services/gpuservice/bpfprogs/Android.bp
index a391c811a0..7906ce3374 100644
--- a/services/gpuservice/bpfprogs/Android.bp
+++ b/services/gpuservice/bpfprogs/Android.bp
@@ -24,4 +24,15 @@ package {
 bpf {
     name: "gpuMem.o",
     srcs: ["gpuMem.c"],
+    include_dirs: [
+        "system/bpf/include/defs",
+    ],
+}
+
+libbpf_prog {
+    name: "gpuMem.bpf",
+    srcs: ["gpuMem.c"],
+    header_libs: [
+        "android_bpf_defs",
+    ],
 }
diff --git a/services/gpuservice/bpfprogs/gpuMem.c b/services/gpuservice/bpfprogs/gpuMem.c
index 16e1e8a1ef..4a8b100dee 100644
--- a/services/gpuservice/bpfprogs/gpuMem.c
+++ b/services/gpuservice/bpfprogs/gpuMem.c
@@ -14,7 +14,11 @@
  * limitations under the License.
  */
 
-#include <bpf_helpers.h>
+#include <android_bpf_defs.h>
+
+#ifdef ENABLE_LIBBPF
+#include <stdint.h>
+#endif  // ENABLE_LIBBPF
 
 /*
  * On Android the number of active processes using gpu is limited.
@@ -48,7 +52,8 @@ struct gpu_mem_total_args {
  * Pass AID_GRAPHICS as gid since gpuservice is in the graphics group.
  * Upon seeing size 0, the corresponding KEY needs to be cleaned up.
  */
-DEFINE_BPF_PROG("tracepoint/gpu_mem/gpu_mem_total", AID_ROOT, AID_GRAPHICS, tp_gpu_mem_total)
+DEFINE_BPF_PROG("tracepoint/gpu_mem/gpu_mem_total", AID_ROOT, AID_GRAPHICS,
+                tracepoint_gpu_mem_gpu_mem_total)
 (struct gpu_mem_total_args* args) {
     uint64_t key = 0;
     uint64_t cur_val = 0;
diff --git a/services/gpuservice/gpuservice_flags.aconfig b/services/gpuservice/gpuservice_flags.aconfig
deleted file mode 100644
index be6a7bb231..0000000000
--- a/services/gpuservice/gpuservice_flags.aconfig
+++ /dev/null
@@ -1,12 +0,0 @@
-package: "com.android.frameworks.gpuservice.flags"
-container: "system"
-
-flag {
-    name: "multiuser_permission_check"
-    namespace: "gpu"
-    description: "Whether to consider headless system user mode/multiuser when checking toggleAngleAsSystemDriver permission."
-    bug: "389867658"
-    metadata {
-        purpose: PURPOSE_BUGFIX
-    }
-}
diff --git a/services/gpuservice/gpustats/Android.bp b/services/gpuservice/gpustats/Android.bp
index 0e64716e6d..384b74856d 100644
--- a/services/gpuservice/gpustats/Android.bp
+++ b/services/gpuservice/gpustats/Android.bp
@@ -14,7 +14,7 @@ cc_defaults {
         "libgraphicsenv",
         "liblog",
         "libprotoutil",
-        "libstatslog",
+        "libstatslog_gpustats",
         "libstatspull",
         "libstatssocket",
         "libutils",
@@ -39,7 +39,7 @@ cc_library_static {
         "-Werror",
         "-Wformat",
         "-Wthread-safety",
-        "-Wunused",
         "-Wunreachable-code",
+        "-Wunused",
     ],
 }
diff --git a/services/gpuservice/gpustats/GpuStats.cpp b/services/gpuservice/gpustats/GpuStats.cpp
index 6d758bc8a8..705cf971c7 100644
--- a/services/gpuservice/gpustats/GpuStats.cpp
+++ b/services/gpuservice/gpustats/GpuStats.cpp
@@ -23,17 +23,18 @@
 #include <cutils/properties.h>
 #include <log/log.h>
 #include <stats_event.h>
-#include <statslog.h>
+#include <statslog_gpustats.h>
 #include <utils/Trace.h>
 
+#include <algorithm>
 #include <unordered_set>
 
 namespace android {
 
 GpuStats::~GpuStats() {
     if (mStatsdRegistered) {
-        AStatsManager_clearPullAtomCallback(android::util::GPU_STATS_GLOBAL_INFO);
-        AStatsManager_clearPullAtomCallback(android::util::GPU_STATS_APP_INFO);
+        AStatsManager_clearPullAtomCallback(android::gpustats::GPU_STATS_GLOBAL_INFO);
+        AStatsManager_clearPullAtomCallback(android::gpustats::GPU_STATS_APP_INFO);
     }
 }
 
@@ -296,9 +297,9 @@ void GpuStats::interceptSystemDriverStatsLocked() {
 
 void GpuStats::registerStatsdCallbacksIfNeeded() {
     if (!mStatsdRegistered) {
-        AStatsManager_setPullAtomCallback(android::util::GPU_STATS_GLOBAL_INFO, nullptr,
+        AStatsManager_setPullAtomCallback(android::gpustats::GPU_STATS_GLOBAL_INFO, nullptr,
                                          GpuStats::pullAtomCallback, this);
-        AStatsManager_setPullAtomCallback(android::util::GPU_STATS_APP_INFO, nullptr,
+        AStatsManager_setPullAtomCallback(android::gpustats::GPU_STATS_APP_INFO, nullptr,
                                          GpuStats::pullAtomCallback, this);
         mStatsdRegistered = true;
     }
@@ -421,16 +422,16 @@ AStatsManager_PullAtomCallbackReturn GpuStats::pullAppInfoAtom(AStatsEventList*
                 engineNames.push_back(engineName.c_str());
             }
 
-            android::util::addAStatsEvent(
+            android::gpustats::addAStatsEvent(
                     data,
-                    android::util::GPU_STATS_APP_INFO,
+                    android::gpustats::GPU_STATS_APP_INFO,
                     ele.second.appPackageName.c_str(),
                     ele.second.driverVersionCode,
-                    android::util::BytesField(glDriverBytes.c_str(),
+                    android::gpustats::BytesField(glDriverBytes.c_str(),
                                               glDriverBytes.length()),
-                    android::util::BytesField(vkDriverBytes.c_str(),
+                    android::gpustats::BytesField(vkDriverBytes.c_str(),
                                               vkDriverBytes.length()),
-                    android::util::BytesField(angleDriverBytes.c_str(),
+                    android::gpustats::BytesField(angleDriverBytes.c_str(),
                                               angleDriverBytes.length()),
                     ele.second.cpuVulkanInUse,
                     ele.second.falsePrerotation,
@@ -461,9 +462,9 @@ AStatsManager_PullAtomCallbackReturn GpuStats::pullGlobalInfoAtom(AStatsEventLis
 
     if (data) {
         for (const auto& ele : mGlobalStats) {
-          android::util::addAStatsEvent(
+          android::gpustats::addAStatsEvent(
                   data,
-                  android::util::GPU_STATS_GLOBAL_INFO,
+                  android::gpustats::GPU_STATS_GLOBAL_INFO,
                   ele.second.driverPackageName.c_str(),
                   ele.second.driverVersionName.c_str(),
                   ele.second.driverVersionCode,
@@ -491,9 +492,9 @@ AStatsManager_PullAtomCallbackReturn GpuStats::pullAtomCallback(int32_t atomTag,
     ATRACE_CALL();
 
     GpuStats* pGpuStats = reinterpret_cast<GpuStats*>(cookie);
-    if (atomTag == android::util::GPU_STATS_GLOBAL_INFO) {
+    if (atomTag == android::gpustats::GPU_STATS_GLOBAL_INFO) {
         return pGpuStats->pullGlobalInfoAtom(data);
-    } else if (atomTag == android::util::GPU_STATS_APP_INFO) {
+    } else if (atomTag == android::gpustats::GPU_STATS_APP_INFO) {
         return pGpuStats->pullAppInfoAtom(data);
     }
 
diff --git a/services/gpuservice/gpuwork/Android.bp b/services/gpuservice/gpuwork/Android.bp
index e20404044a..691071bd4b 100644
--- a/services/gpuservice/gpuwork/Android.bp
+++ b/services/gpuservice/gpuwork/Android.bp
@@ -31,8 +31,9 @@ cc_library_shared {
         "libbpf_bcc",
         "libcutils",
         "liblog",
-        "libstatslog",
+        "libstatslog_gpustats",
         "libstatspull",
+        "libstatssocket",
         "libutils",
     ],
     export_include_dirs: [
@@ -50,11 +51,48 @@ cc_library_shared {
         "-Werror",
         "-Wformat",
         "-Wthread-safety",
-        "-Wunused",
         "-Wunreachable-code",
+        "-Wunused",
     ],
     required: [
         "bpfloader",
         "gpuWork.o",
     ],
 }
+
+cc_library_shared {
+    name: "libstatslog_gpustats",
+    host_supported: true,
+    generated_sources: ["statslog_gpustats.cpp"],
+    generated_headers: ["statslog_gpustats.h"],
+    export_generated_headers: ["statslog_gpustats.h"],
+    shared_libs: [
+        "libstatspull",
+        "libstatssocket",
+    ],
+    export_shared_lib_headers: [
+        "libstatspull",
+        "libstatssocket",
+    ],
+}
+
+genrule {
+    name: "statslog_gpustats.h",
+    tools: ["stats-log-api-gen"],
+    cmd: "$(location stats-log-api-gen) --header $(genDir)/statslog_gpustats.h" +
+        " --module gpustats --namespace android,gpustats",
+    out: [
+        "statslog_gpustats.h",
+    ],
+}
+
+genrule {
+    name: "statslog_gpustats.cpp",
+    tools: ["stats-log-api-gen"],
+    cmd: "$(location stats-log-api-gen) --cpp $(genDir)/statslog_gpustats.cpp" +
+        " --module gpustats --namespace android,gpustats" +
+        " --importHeader statslog_gpustats.h",
+    out: [
+        "statslog_gpustats.cpp",
+    ],
+}
diff --git a/services/gpuservice/gpuwork/GpuWork.cpp b/services/gpuservice/gpuwork/GpuWork.cpp
index 7628745537..e89e4c18e7 100644
--- a/services/gpuservice/gpuwork/GpuWork.cpp
+++ b/services/gpuservice/gpuwork/GpuWork.cpp
@@ -27,7 +27,7 @@
 #include <log/log.h>
 #include <random>
 #include <stats_event.h>
-#include <statslog.h>
+#include <statslog_gpustats.h>
 #include <unistd.h>
 #include <utils/Timers.h>
 #include <utils/Trace.h>
@@ -110,7 +110,7 @@ GpuWork::~GpuWork() {
     {
         std::scoped_lock<std::mutex> lock(mMutex);
         if (mStatsdRegistered) {
-            AStatsManager_clearPullAtomCallback(android::util::GPU_WORK_PER_UID);
+            AStatsManager_clearPullAtomCallback(android::gpustats::GPU_WORK_PER_UID);
         }
     }
 
@@ -155,7 +155,7 @@ void GpuWork::initialize() {
 
     {
         std::lock_guard<std::mutex> lock(mMutex);
-        AStatsManager_setPullAtomCallback(int32_t{android::util::GPU_WORK_PER_UID}, nullptr,
+        AStatsManager_setPullAtomCallback(int32_t{android::gpustats::GPU_WORK_PER_UID}, nullptr,
                                           GpuWork::pullAtomCallback, this);
         mStatsdRegistered = true;
     }
@@ -260,7 +260,7 @@ AStatsManager_PullAtomCallbackReturn GpuWork::pullAtomCallback(int32_t atomTag,
     ATRACE_CALL();
 
     GpuWork* gpuWork = reinterpret_cast<GpuWork*>(cookie);
-    if (atomTag == android::util::GPU_WORK_PER_UID) {
+    if (atomTag == android::gpustats::GPU_WORK_PER_UID) {
         return gpuWork->pullWorkAtoms(data);
     }
 
@@ -417,7 +417,7 @@ AStatsManager_PullAtomCallbackReturn GpuWork::pullWorkAtoms(AStatsEventList* dat
             }
 
             ALOGI("pullWorkAtoms: adding stats for GPU ID %" PRIu32 "; UID %" PRIu32, gpuId, uid);
-            android::util::addAStatsEvent(data, int32_t{android::util::GPU_WORK_PER_UID},
+            android::gpustats::addAStatsEvent(data, int32_t{android::gpustats::GPU_WORK_PER_UID},
                                           // uid
                                           bitcast_int32(uid),
                                           // gpu_id
@@ -479,7 +479,7 @@ void GpuWork::clearMapIfNeeded() {
     uint64_t numEntries = globalData.value().num_map_entries;
 
     // If the map is <=75% full, we do nothing.
-    if (numEntries <= (kMaxTrackedGpuIdUids / 4) * 3) {
+    if (numEntries <= (MAX_TRACKED_GPU_ID_UIDS / 4) * 3) {
         return;
     }
 
@@ -511,7 +511,7 @@ void GpuWork::clearMap() {
 
     base::Result<GpuIdUid> key = mGpuWorkMap.getFirstKey();
 
-    for (size_t i = 0; i < kMaxTrackedGpuIdUids; ++i) {
+    for (size_t i = 0; i < MAX_TRACKED_GPU_ID_UIDS; ++i) {
         if (!key.ok()) {
             break;
         }
diff --git a/services/gpuservice/gpuwork/bpfprogs/Android.bp b/services/gpuservice/gpuwork/bpfprogs/Android.bp
index 2e444fefa9..ea85ea149a 100644
--- a/services/gpuservice/gpuwork/bpfprogs/Android.bp
+++ b/services/gpuservice/gpuwork/bpfprogs/Android.bp
@@ -23,6 +23,17 @@ bpf {
         "-Wthread-safety",
         "-Wunreachable-code",
     ],
+    include_dirs: [
+        "system/bpf/include/defs",
+    ],
+}
+
+libbpf_prog {
+    name: "gpuWork.bpf",
+    srcs: ["gpuWork.c"],
+    header_libs: [
+        "android_bpf_defs",
+    ],
 }
 
 cc_library_headers {
diff --git a/services/gpuservice/gpuwork/bpfprogs/gpuWork.c b/services/gpuservice/gpuwork/bpfprogs/gpuWork.c
index 94abc69426..862944c8ce 100644
--- a/services/gpuservice/gpuwork/bpfprogs/gpuWork.c
+++ b/services/gpuservice/gpuwork/bpfprogs/gpuWork.c
@@ -20,13 +20,13 @@
 #include <stddef.h>
 #include <stdint.h>
 
-#include <bpf_helpers.h>
+#include <android_bpf_defs.h>
 
 #define S_IN_NS (1000000000)
 #define SMALL_TIME_GAP_LIMIT_NS (S_IN_NS)
 
 // A map from GpuIdUid (GPU ID and application UID) to |UidTrackingInfo|.
-DEFINE_BPF_MAP_GRW(gpu_work_map, HASH, GpuIdUid, UidTrackingInfo, kMaxTrackedGpuIdUids,
+DEFINE_BPF_MAP_GRW(gpu_work_map, HASH, GpuIdUid, UidTrackingInfo, MAX_TRACKED_GPU_ID_UIDS,
                    AID_GRAPHICS);
 
 // A map containing a single entry of |GlobalData|.
@@ -174,7 +174,8 @@ _Static_assert(offsetof(GpuWorkPeriodEvent, gpu_id) == 8 &&
                "must match the tracepoint field offsets found via adb shell cat "
                "/sys/kernel/tracing/events/power/gpu_work_period/format");
 
-DEFINE_BPF_PROG("tracepoint/power/gpu_work_period", AID_ROOT, AID_GRAPHICS, tp_gpu_work_period)
+DEFINE_BPF_PROG("tracepoint/power/gpu_work_period", AID_ROOT, AID_GRAPHICS,
+                tracepoint_power_gpu_work_period)
 (GpuWorkPeriodEvent* const period) {
     // Note: In eBPF programs, |__sync_fetch_and_add| is translated to an atomic
     // add.
diff --git a/services/gpuservice/gpuwork/bpfprogs/include/gpuwork/gpuWork.h b/services/gpuservice/gpuwork/bpfprogs/include/gpuwork/gpuWork.h
index 2affb60a0c..eee1beb6e0 100644
--- a/services/gpuservice/gpuwork/bpfprogs/include/gpuwork/gpuWork.h
+++ b/services/gpuservice/gpuwork/bpfprogs/include/gpuwork/gpuWork.h
@@ -18,6 +18,9 @@
 
 #include <stdint.h>
 
+// The maximum number of tracked GPU ID and UID pairs (|GpuIdUid|).
+#define MAX_TRACKED_GPU_ID_UIDS 512
+
 #ifdef __cplusplus
 #include <type_traits>
 
@@ -60,9 +63,6 @@ typedef struct {
     uint64_t num_map_entries;
 } GlobalData;
 
-// The maximum number of tracked GPU ID and UID pairs (|GpuIdUid|).
-static const uint32_t kMaxTrackedGpuIdUids = 512;
-
 #ifdef __cplusplus
 } // namespace gpuwork
 } // namespace android
diff --git a/services/gpuservice/include/gpuservice/GpuService.h b/services/gpuservice/include/gpuservice/GpuService.h
index 22be9a72b9..e8ac5335f5 100644
--- a/services/gpuservice/include/gpuservice/GpuService.h
+++ b/services/gpuservice/include/gpuservice/GpuService.h
@@ -67,6 +67,7 @@ private:
     std::string getUpdatableDriverPath() override;
     FeatureOverrides getFeatureOverrides() override;
     void toggleAngleAsSystemDriver(bool enabled) override;
+    std::string getPersistGraphicsEgl() override;
     void addVulkanEngineName(const std::string& appPackageName, const uint64_t driverVersionCode,
                              const char *engineName) override;
 
diff --git a/services/gpuservice/tests/fuzzers/Android.bp b/services/gpuservice/tests/fuzzers/Android.bp
index 7be3253565..d4d48c48ea 100644
--- a/services/gpuservice/tests/fuzzers/Android.bp
+++ b/services/gpuservice/tests/fuzzers/Android.bp
@@ -13,9 +13,6 @@ cc_fuzz {
         "libgpuservice",
         "liblog",
     ],
-    shared_libs: [
-        "gpuservice_multiuser_flags_c_lib",
-    ],
     fuzz_config: {
         cc: [
             "paulthomson@google.com",
diff --git a/services/gpuservice/tests/unittests/Android.bp b/services/gpuservice/tests/unittests/Android.bp
index 0dac24d560..e611d8f232 100644
--- a/services/gpuservice/tests/unittests/Android.bp
+++ b/services/gpuservice/tests/unittests/Android.bp
@@ -89,7 +89,6 @@ cc_test {
     ],
     header_libs: ["bpf_headers"],
     shared_libs: [
-        "gpuservice_multiuser_flags_c_lib",
         "libbase",
         "libbinder",
         "libbpf_bcc",
@@ -98,7 +97,7 @@ cc_test {
         "liblog",
         "libprotobuf-cpp-lite",
         "libprotoutil",
-        "libstatslog",
+        "libstatslog_gpustats",
         "libstatspull",
         "libutils",
     ],
diff --git a/services/gpuservice/tests/unittests/GpuStatsTest.cpp b/services/gpuservice/tests/unittests/GpuStatsTest.cpp
index b367457579..54ad929654 100644
--- a/services/gpuservice/tests/unittests/GpuStatsTest.cpp
+++ b/services/gpuservice/tests/unittests/GpuStatsTest.cpp
@@ -24,7 +24,7 @@
 #include <gpustats/GpuStats.h>
 #include <gtest/gtest.h>
 #include <stats_pull_atom_callback.h>
-#include <statslog.h>
+#include <statslog_gpustats.h>
 #include <utils/Looper.h>
 #include <utils/String16.h>
 #include <utils/Vector.h>
@@ -520,7 +520,7 @@ TEST_F(GpuStatsTest, canPullGlobalAtom) {
     EXPECT_FALSE(inputCommand(InputCommand::DUMP_GLOBAL).empty());
     EXPECT_FALSE(inputCommand(InputCommand::DUMP_APP).empty());
 
-    EXPECT_TRUE(testableGpuStats.makePullAtomCallback(android::util::GPU_STATS_GLOBAL_INFO) ==
+    EXPECT_TRUE(testableGpuStats.makePullAtomCallback(android::gpustats::GPU_STATS_GLOBAL_INFO) ==
                 AStatsManager_PULL_SUCCESS);
 
     EXPECT_TRUE(inputCommand(InputCommand::DUMP_GLOBAL).empty());
@@ -537,7 +537,7 @@ TEST_F(GpuStatsTest, canPullAppAtom) {
     EXPECT_FALSE(inputCommand(InputCommand::DUMP_GLOBAL).empty());
     EXPECT_FALSE(inputCommand(InputCommand::DUMP_APP).empty());
 
-    EXPECT_TRUE(testableGpuStats.makePullAtomCallback(android::util::GPU_STATS_APP_INFO) ==
+    EXPECT_TRUE(testableGpuStats.makePullAtomCallback(android::gpustats::GPU_STATS_APP_INFO) ==
                 AStatsManager_PULL_SUCCESS);
 
     EXPECT_FALSE(inputCommand(InputCommand::DUMP_GLOBAL).empty());
diff --git a/services/inputflinger/Android.bp b/services/inputflinger/Android.bp
index 107fd207be..2206264c80 100644
--- a/services/inputflinger/Android.bp
+++ b/services/inputflinger/Android.bp
@@ -30,7 +30,6 @@ inputflinger_tidy_checks = [
 cc_defaults {
     name: "inputflinger_defaults",
     host_supported: true,
-    cpp_std: "c++20",
     cflags: [
         "-DANDROID_UTILS_REF_BASE_DISABLE_IMPLICIT_CONSTRUCTION",
         "-Wall",
@@ -47,6 +46,7 @@ cc_defaults {
             "bounds",
         ],
     },
+    afdo: true,
     tidy: true,
     tidy_checks: [
         "-*", // Disable all checks not explicitly enabled for now
@@ -113,7 +113,7 @@ cc_defaults {
         "libkll",
         "liblog",
         "libprotobuf-cpp-lite",
-        "libstatslog",
+        "libstatslog_inputflinger",
         "libstatspull",
         "libstatssocket",
         "libutils",
@@ -218,7 +218,9 @@ cc_defaults {
         "libinput",
         "liblog",
         "libprocessgroup",
-        "libstatslog",
+        "libstatslog_inputflinger",
+        "libstatspull",
+        "libstatssocket",
         "libutils",
     ],
     header_libs: [
@@ -284,3 +286,36 @@ phony {
         "monkey_test",
     ],
 }
+
+cc_library_shared {
+    name: "libstatslog_inputflinger",
+    host_supported: true,
+    generated_sources: ["statslog_inputflinger.cpp"],
+    generated_headers: ["statslog_inputflinger.h"],
+    export_generated_headers: ["statslog_inputflinger.h"],
+    shared_libs: [
+        "libstatspull",
+        "libstatssocket",
+    ],
+}
+
+genrule {
+    name: "statslog_inputflinger.h",
+    tools: ["stats-log-api-gen"],
+    cmd: "$(location stats-log-api-gen) --header $(genDir)/statslog_inputflinger.h" +
+        " --module input --namespace android,inputflinger,stats",
+    out: [
+        "statslog_inputflinger.h",
+    ],
+}
+
+genrule {
+    name: "statslog_inputflinger.cpp",
+    tools: ["stats-log-api-gen"],
+    cmd: "$(location stats-log-api-gen) --cpp $(genDir)/statslog_inputflinger.cpp" +
+        " --module input --namespace android,inputflinger,stats" +
+        " --importHeader statslog_inputflinger.h",
+    out: [
+        "statslog_inputflinger.cpp",
+    ],
+}
diff --git a/services/inputflinger/InputCommonConverter.cpp b/services/inputflinger/InputCommonConverter.cpp
index e376734b86..1c5ba127bc 100644
--- a/services/inputflinger/InputCommonConverter.cpp
+++ b/services/inputflinger/InputCommonConverter.cpp
@@ -348,10 +348,10 @@ MotionEvent toMotionEvent(const NotifyMotionArgs& args, const ui::Transform* tra
 
     MotionEvent event;
     event.initialize(args.id, args.deviceId, args.source, args.displayId, *hmac, args.action,
-                     args.actionButton, args.flags, args.edgeFlags, args.metaState,
-                     args.buttonState, args.classification, *transform, args.xPrecision,
-                     args.yPrecision, args.xCursorPosition, args.yCursorPosition, *rawTransform,
-                     args.downTime, args.eventTime, args.getPointerCount(),
+                     args.actionButton, ftl::Flags<MotionFlag>(args.flags), args.edgeFlags,
+                     args.metaState, args.buttonState, args.classification, *transform,
+                     args.xPrecision, args.yPrecision, args.xCursorPosition, args.yCursorPosition,
+                     *rawTransform, args.downTime, args.eventTime, args.getPointerCount(),
                      args.pointerProperties.data(), args.pointerCoords.data());
     return event;
 }
diff --git a/services/inputflinger/InputDeviceMetricsCollector.cpp b/services/inputflinger/InputDeviceMetricsCollector.cpp
index 46211441a9..a8f4fc900b 100644
--- a/services/inputflinger/InputDeviceMetricsCollector.cpp
+++ b/services/inputflinger/InputDeviceMetricsCollector.cpp
@@ -44,7 +44,7 @@ int32_t linuxBusToInputDeviceBusEnum(int32_t linuxBus, bool isUsiStylus) {
     if (isUsiStylus) {
         // This is a stylus connected over the Universal Stylus Initiative (USI) protocol.
         // For metrics purposes, we treat this protocol as a separate bus.
-        return util::INPUT_DEVICE_USAGE_REPORTED__DEVICE_BUS__USI;
+        return inputflinger::stats::INPUT_DEVICE_USAGE_REPORTED__DEVICE_BUS__USI;
     }
 
     // When adding cases to this switch, also add them to the copy of this method in
@@ -52,11 +52,11 @@ int32_t linuxBusToInputDeviceBusEnum(int32_t linuxBus, bool isUsiStylus) {
     // TODO(b/286394420): deduplicate this method with the one in TouchpadInputMapper.cpp.
     switch (linuxBus) {
         case BUS_USB:
-            return util::INPUT_DEVICE_USAGE_REPORTED__DEVICE_BUS__USB;
+            return inputflinger::stats::INPUT_DEVICE_USAGE_REPORTED__DEVICE_BUS__USB;
         case BUS_BLUETOOTH:
-            return util::INPUT_DEVICE_USAGE_REPORTED__DEVICE_BUS__BLUETOOTH;
+            return inputflinger::stats::INPUT_DEVICE_USAGE_REPORTED__DEVICE_BUS__BLUETOOTH;
         default:
-            return util::INPUT_DEVICE_USAGE_REPORTED__DEVICE_BUS__OTHER;
+            return inputflinger::stats::INPUT_DEVICE_USAGE_REPORTED__DEVICE_BUS__OTHER;
     }
 }
 
@@ -94,9 +94,11 @@ class : public InputDeviceMetricsLogger {
             ALOGD_IF(DEBUG, "        - uid: %s\t duration: %dms", uid.toString().c_str(),
                      durMillis);
         }
-        util::stats_write(util::INPUTDEVICE_USAGE_REPORTED, info.vendor, info.product, info.version,
-                          linuxBusToInputDeviceBusEnum(info.bus, info.isUsiStylus), durationMillis,
-                          sources, durationsPerSource, uids, durationsPerUid);
+        inputflinger::stats::stats_write(inputflinger::stats::INPUTDEVICE_USAGE_REPORTED,
+                                         info.vendor, info.product, info.version,
+                                         linuxBusToInputDeviceBusEnum(info.bus, info.isUsiStylus),
+                                         durationMillis, sources, durationsPerSource, uids,
+                                         durationsPerUid);
     }
 } sStatsdLogger;
 
diff --git a/services/inputflinger/InputDeviceMetricsSource.h b/services/inputflinger/InputDeviceMetricsSource.h
index 702baddc37..0277ac2ae9 100644
--- a/services/inputflinger/InputDeviceMetricsSource.h
+++ b/services/inputflinger/InputDeviceMetricsSource.h
@@ -19,7 +19,7 @@
 #include "NotifyArgs.h"
 
 #include <linux/input.h>
-#include <statslog.h>
+#include <statslog_inputflinger.h>
 
 namespace android {
 
@@ -27,23 +27,28 @@ namespace android {
  * Enum representation of the InputDeviceUsageSource.
  */
 enum class InputDeviceUsageSource : int32_t {
-    UNKNOWN = util::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__UNKNOWN,
-    BUTTONS = util::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__BUTTONS,
-    KEYBOARD = util::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__KEYBOARD,
-    DPAD = util::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__DPAD,
-    GAMEPAD = util::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__GAMEPAD,
-    JOYSTICK = util::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__JOYSTICK,
-    MOUSE = util::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__MOUSE,
-    MOUSE_CAPTURED = util::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__MOUSE_CAPTURED,
-    TOUCHPAD = util::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__TOUCHPAD,
-    TOUCHPAD_CAPTURED = util::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__TOUCHPAD_CAPTURED,
-    ROTARY_ENCODER = util::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__ROTARY_ENCODER,
-    STYLUS_DIRECT = util::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__STYLUS_DIRECT,
-    STYLUS_INDIRECT = util::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__STYLUS_INDIRECT,
-    STYLUS_FUSED = util::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__STYLUS_FUSED,
-    TOUCH_NAVIGATION = util::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__TOUCH_NAVIGATION,
-    TOUCHSCREEN = util::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__TOUCHSCREEN,
-    TRACKBALL = util::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__TRACKBALL,
+    UNKNOWN = inputflinger::stats::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__UNKNOWN,
+    BUTTONS = inputflinger::stats::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__BUTTONS,
+    KEYBOARD = inputflinger::stats::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__KEYBOARD,
+    DPAD = inputflinger::stats::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__DPAD,
+    GAMEPAD = inputflinger::stats::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__GAMEPAD,
+    JOYSTICK = inputflinger::stats::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__JOYSTICK,
+    MOUSE = inputflinger::stats::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__MOUSE,
+    MOUSE_CAPTURED =
+            inputflinger::stats::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__MOUSE_CAPTURED,
+    TOUCHPAD = inputflinger::stats::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__TOUCHPAD,
+    TOUCHPAD_CAPTURED =
+            inputflinger::stats::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__TOUCHPAD_CAPTURED,
+    ROTARY_ENCODER =
+            inputflinger::stats::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__ROTARY_ENCODER,
+    STYLUS_DIRECT = inputflinger::stats::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__STYLUS_DIRECT,
+    STYLUS_INDIRECT =
+            inputflinger::stats::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__STYLUS_INDIRECT,
+    STYLUS_FUSED = inputflinger::stats::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__STYLUS_FUSED,
+    TOUCH_NAVIGATION =
+            inputflinger::stats::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__TOUCH_NAVIGATION,
+    TOUCHSCREEN = inputflinger::stats::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__TOUCHSCREEN,
+    TRACKBALL = inputflinger::stats::INPUT_DEVICE_USAGE_REPORTED__USAGE_SOURCES__TRACKBALL,
 
     ftl_first = UNKNOWN,
     ftl_last = TRACKBALL,
diff --git a/services/inputflinger/InputFilter.cpp b/services/inputflinger/InputFilter.cpp
index bb4e617bde..0cc02ecca5 100644
--- a/services/inputflinger/InputFilter.cpp
+++ b/services/inputflinger/InputFilter.cpp
@@ -45,9 +45,9 @@ AidlKeyEvent notifyKeyArgsToKeyEvent(const NotifyKeyArgs& args) {
 }
 
 InputFilter::InputFilter(InputListenerInterface& listener, IInputFlingerRust& rust,
-                         InputFilterPolicyInterface& policy)
+                         InputFilterPolicyInterface& policy, JNIEnv* env)
       : mNextListener(listener),
-        mCallbacks(ndk::SharedRefBase::make<InputFilterCallbacks>(listener, policy)),
+        mCallbacks(ndk::SharedRefBase::make<InputFilterCallbacks>(listener, policy, env)),
         mPolicy(policy) {
     LOG_ALWAYS_FATAL_IF(!rust.createInputFilter(mCallbacks, &mInputFilterRust).isOk());
     LOG_ALWAYS_FATAL_IF(!mInputFilterRust);
diff --git a/services/inputflinger/InputFilter.h b/services/inputflinger/InputFilter.h
index f626703524..bf976271eb 100644
--- a/services/inputflinger/InputFilter.h
+++ b/services/inputflinger/InputFilter.h
@@ -50,7 +50,7 @@ public:
     using AidlDeviceInfo = aidl::com::android::server::inputflinger::DeviceInfo;
 
     explicit InputFilter(InputListenerInterface& listener, IInputFlingerRust& rust,
-                         InputFilterPolicyInterface& policy);
+                         InputFilterPolicyInterface& policy, JNIEnv* env);
     ~InputFilter() override = default;
     void notifyInputDevicesChanged(const NotifyInputDevicesChangedArgs& args) override;
     void notifyKey(const NotifyKeyArgs& args) override;
diff --git a/services/inputflinger/InputFilterCallbacks.cpp b/services/inputflinger/InputFilterCallbacks.cpp
index 493459acfb..ed6d779165 100644
--- a/services/inputflinger/InputFilterCallbacks.cpp
+++ b/services/inputflinger/InputFilterCallbacks.cpp
@@ -23,6 +23,7 @@
 #include <utils/StrongPointer.h>
 #include <functional>
 #include "InputThread.h"
+#include "jni.h"
 
 namespace android {
 
@@ -41,11 +42,12 @@ using namespace aidl::com::android::server::inputflinger;
 
 class InputFilterThread : public BnInputThread {
 public:
-    InputFilterThread(std::shared_ptr<IInputThreadCallback> callback) : mCallback(callback) {
+    InputFilterThread(std::shared_ptr<IInputThreadCallback> callback, JNIEnv* env)
+          : mCallback(callback) {
         mLooper = sp<Looper>::make(/*allowNonCallbacks=*/false);
         mThread = std::make_unique<InputThread>(
                 "InputFilter", [this]() { loopOnce(); }, [this]() { mLooper->wake(); },
-                /*isInCriticalPath=*/false);
+                /*isInCriticalPath=*/false, env);
     }
 
     ndk::ScopedAStatus finish() override {
@@ -79,8 +81,8 @@ private:
 } // namespace
 
 InputFilterCallbacks::InputFilterCallbacks(InputListenerInterface& listener,
-                                           InputFilterPolicyInterface& policy)
-      : mNextListener(listener), mPolicy(policy) {}
+                                           InputFilterPolicyInterface& policy, JNIEnv* env)
+      : mNextListener(listener), mPolicy(policy), mJniEnv(env) {}
 
 ndk::ScopedAStatus InputFilterCallbacks::sendKeyEvent(const AidlKeyEvent& event) {
     mNextListener.notifyKey(keyEventToNotifyKeyArgs(event));
@@ -101,7 +103,7 @@ ndk::ScopedAStatus InputFilterCallbacks::onModifierStateChanged(int32_t modifier
 ndk::ScopedAStatus InputFilterCallbacks::createInputFilterThread(
         const std::shared_ptr<IInputThreadCallback>& callback,
         std::shared_ptr<IInputThread>* aidl_return) {
-    *aidl_return = ndk::SharedRefBase::make<InputFilterThread>(callback);
+    *aidl_return = ndk::SharedRefBase::make<InputFilterThread>(callback, mJniEnv);
     return ndk::ScopedAStatus::ok();
 }
 
diff --git a/services/inputflinger/InputFilterCallbacks.h b/services/inputflinger/InputFilterCallbacks.h
index a74955b5c6..4d350063f7 100644
--- a/services/inputflinger/InputFilterCallbacks.h
+++ b/services/inputflinger/InputFilterCallbacks.h
@@ -39,7 +39,7 @@ using IInputThreadCallback =
 class InputFilterCallbacks : public IInputFilter::BnInputFilterCallbacks {
 public:
     explicit InputFilterCallbacks(InputListenerInterface& listener,
-                                  InputFilterPolicyInterface& policy);
+                                  InputFilterPolicyInterface& policy, JNIEnv* env);
     ~InputFilterCallbacks() override = default;
 
     uint32_t getModifierState();
@@ -48,6 +48,7 @@ public:
 private:
     InputListenerInterface& mNextListener;
     InputFilterPolicyInterface& mPolicy;
+    JNIEnv* mJniEnv;
     mutable std::mutex mLock;
     struct StickyModifierState {
         uint32_t modifierState;
diff --git a/services/inputflinger/InputManager.cpp b/services/inputflinger/InputManager.cpp
index 7d62ed9461..1ac1f92611 100644
--- a/services/inputflinger/InputManager.cpp
+++ b/services/inputflinger/InputManager.cpp
@@ -125,15 +125,15 @@ std::shared_ptr<IInputFlingerRust> createInputFlingerRust() {
 InputManager::InputManager(const sp<InputReaderPolicyInterface>& readerPolicy,
                            InputDispatcherPolicyInterface& dispatcherPolicy,
                            PointerChoreographerPolicyInterface& choreographerPolicy,
-                           InputFilterPolicyInterface& inputFilterPolicy) {
+                           InputFilterPolicyInterface& inputFilterPolicy, JNIEnv* env) {
     mInputFlingerRust = createInputFlingerRust();
 
-    mDispatcher = createInputDispatcher(dispatcherPolicy);
+    mDispatcher = createInputDispatcher(dispatcherPolicy, env);
     mTracingStages.emplace_back(
             std::make_unique<TracedInputListener>("InputDispatcher", *mDispatcher));
 
     mInputFilter = std::make_unique<InputFilter>(*mTracingStages.back(), *mInputFlingerRust,
-                                                 inputFilterPolicy);
+                                                 inputFilterPolicy, env);
     mTracingStages.emplace_back(
             std::make_unique<TracedInputListener>("InputFilter", *mInputFilter));
 
@@ -156,7 +156,7 @@ InputManager::InputManager(const sp<InputReaderPolicyInterface>& readerPolicy,
     mTracingStages.emplace_back(
             std::make_unique<TracedInputListener>("UnwantedInteractionBlocker", *mBlocker));
 
-    mReader = createInputReader(readerPolicy, *mTracingStages.back());
+    mReader = createInputReader(readerPolicy, *mTracingStages.back(), env);
 }
 
 InputManager::~InputManager() {
diff --git a/services/inputflinger/InputManager.h b/services/inputflinger/InputManager.h
index c479aaf9b6..44cf8c42f4 100644
--- a/services/inputflinger/InputManager.h
+++ b/services/inputflinger/InputManager.h
@@ -121,7 +121,7 @@ public:
     InputManager(const sp<InputReaderPolicyInterface>& readerPolicy,
                  InputDispatcherPolicyInterface& dispatcherPolicy,
                  PointerChoreographerPolicyInterface& choreographerPolicy,
-                 InputFilterPolicyInterface& inputFilterPolicy);
+                 InputFilterPolicyInterface& inputFilterPolicy, JNIEnv* env);
 
     status_t start() override;
     status_t stop() override;
diff --git a/services/inputflinger/InputThread.cpp b/services/inputflinger/InputThread.cpp
index 7cf4e397f9..8950d2c787 100644
--- a/services/inputflinger/InputThread.cpp
+++ b/services/inputflinger/InputThread.cpp
@@ -16,9 +16,12 @@
 
 #include "InputThread.h"
 
+#include <functional>
+
 #include <android-base/logging.h>
 #include <com_android_input_flags.h>
 #include <processgroup/processgroup.h>
+#include "jni.h"
 
 namespace android {
 
@@ -26,63 +29,72 @@ namespace input_flags = com::android::input::flags;
 
 namespace {
 
-bool applyInputEventProfile(const Thread& thread) {
-#if defined(__ANDROID__)
-    return SetTaskProfiles(thread.getTid(), {"InputPolicy"});
-#else
-    // Since thread information is not available and there's no benefit of
-    // applying the task profile on host, return directly.
-    return true;
-#endif
+bool applyInputEventProfile() {
+    static constexpr pid_t CURRENT_THREAD = 0;
+    return SetTaskProfiles(CURRENT_THREAD, {"InputPolicy"});
 }
 
-// Implementation of Thread from libutils.
-class InputThreadImpl : public Thread {
+class JvmAttacher {
 public:
-    explicit InputThreadImpl(std::function<void()> loop)
-          : Thread(/* canCallJava */ true), mThreadLoop(loop) {}
-
-    ~InputThreadImpl() {}
+    JvmAttacher(JNIEnv* env, const std::string& name) {
+        if (env == nullptr) {
+            LOG(INFO) << "env is nullptr for thread " << name;
+            return;
+        }
+        env->GetJavaVM(&mVm);
+        LOG_IF(FATAL, mVm == nullptr) << "Could not get JavaVM from provided JNIEnv";
 
-private:
-    std::function<void()> mThreadLoop;
+        JavaVMAttachArgs args{
+                .version = JNI_VERSION_1_6,
+                .name = name.c_str(),
+                .group = nullptr,
+        };
+        if (mVm->AttachCurrentThread(&env, &args) != JNI_OK) {
+            LOG(FATAL) << "Cannot attach thread " << name << " to Java VM.";
+        }
+    }
 
-    bool threadLoop() override {
-        mThreadLoop();
-        return true;
+    ~JvmAttacher() {
+        if (mVm != nullptr && mVm->DetachCurrentThread() != JNI_OK) {
+            LOG(FATAL) << "Cannot detach thread from Java VM.";
+        }
     }
+
+private:
+    JavaVM* mVm = nullptr;
 };
 
 } // namespace
 
 InputThread::InputThread(std::string name, std::function<void()> loop, std::function<void()> wake,
-                         bool isInCriticalPath)
+                         bool isInCriticalPath, JNIEnv* env)
       : mThreadWake(wake) {
-    mThread = sp<InputThreadImpl>::make(loop);
-    mThread->run(name.c_str(), ANDROID_PRIORITY_URGENT_DISPLAY);
-    if (input_flags::enable_input_policy_profile() && isInCriticalPath) {
-        if (!applyInputEventProfile(*mThread)) {
-            LOG(ERROR) << "Couldn't apply input policy profile for " << name;
+    std::thread loopThread{[this, name, isInCriticalPath, loop, env] {
+        if (input_flags::enable_input_policy_profile() && isInCriticalPath) {
+            if (!applyInputEventProfile()) {
+                LOG(ERROR) << "Couldn't apply input policy profile for " << name;
+            }
         }
-    }
+
+        JvmAttacher jvmAttacher(env, name);
+
+        while (!mStopThread) {
+            loop();
+        }
+    }};
+    mThread = std::move(loopThread);
 }
 
 InputThread::~InputThread() {
-    mThread->requestExit();
+    mStopThread = true;
     if (mThreadWake) {
         mThreadWake();
     }
-    mThread->requestExitAndWait();
+    mThread.join();
 }
 
 bool InputThread::isCallingThread() {
-#if defined(__ANDROID__)
-    return gettid() == mThread->getTid();
-#else
-    // Assume that the caller is doing everything correctly,
-    // since thread information is not available on host
-    return false;
-#endif
+    return std::this_thread::get_id() == mThread.get_id();
 }
 
 } // namespace android
diff --git a/services/inputflinger/NotifyArgs.cpp b/services/inputflinger/NotifyArgs.cpp
index 3de639f36c..574a12142f 100644
--- a/services/inputflinger/NotifyArgs.cpp
+++ b/services/inputflinger/NotifyArgs.cpp
@@ -61,7 +61,7 @@ NotifyMotionArgs::NotifyMotionArgs(
         int32_t id, nsecs_t eventTime, nsecs_t readTime, int32_t deviceId, uint32_t source,
         ui::LogicalDisplayId displayId, uint32_t policyFlags, int32_t action, int32_t actionButton,
         int32_t flags, int32_t metaState, int32_t buttonState, MotionClassification classification,
-        int32_t edgeFlags, uint32_t pointerCount, const PointerProperties* pointerProperties,
+        uint32_t pointerCount, const PointerProperties* pointerProperties,
         const PointerCoords* pointerCoords, float xPrecision, float yPrecision,
         float xCursorPosition, float yCursorPosition, nsecs_t downTime,
         const std::vector<TouchVideoFrame>& videoFrames)
@@ -77,7 +77,7 @@ NotifyMotionArgs::NotifyMotionArgs(
         metaState(metaState),
         buttonState(buttonState),
         classification(classification),
-        edgeFlags(edgeFlags),
+        edgeFlags(AMOTION_EVENT_EDGE_FLAG_NONE),
         xPrecision(xPrecision),
         yPrecision(yPrecision),
         xCursorPosition(xCursorPosition),
@@ -133,8 +133,9 @@ std::string NotifyMotionArgs::dump() const {
         }
         coords += "}";
     }
-    return StringPrintf("NotifyMotionArgs(id=%" PRId32 ", eventTime=%" PRId64 ", deviceId=%" PRId32
-                        ", source=%s, action=%s, pointerCount=%zu pointers=%s, flags=0x%08x)",
+    return StringPrintf("NotifyMotionArgs(id=%" PRId32 ", eventTime=%" PRId64 "ns, "
+                        "deviceId=%" PRId32 ", source=%s, action=%s, pointerCount=%zu, "
+                        "pointers=%s, flags=0x%08x)",
                         id, eventTime, deviceId, inputEventSourceToString(source).c_str(),
                         MotionEvent::actionToString(action).c_str(), getPointerCount(),
                         coords.c_str(), flags);
diff --git a/services/inputflinger/PointerChoreographer.cpp b/services/inputflinger/PointerChoreographer.cpp
index 98f0f346df..daeef49fe6 100644
--- a/services/inputflinger/PointerChoreographer.cpp
+++ b/services/inputflinger/PointerChoreographer.cpp
@@ -107,13 +107,15 @@ PointerChoreographer::PointerChoreographer(InputListenerInterface& inputListener
       : PointerChoreographer(
                 inputListener, policy,
                 [](const sp<android::gui::WindowInfosListener>& listener) {
-                    auto initialInfo = std::make_pair(std::vector<android::gui::WindowInfo>{},
-                                                      std::vector<android::gui::DisplayInfo>{});
 #if defined(__ANDROID__)
-                    SurfaceComposerClient::getDefault()->addWindowInfosListener(listener,
-                                                                                &initialInfo);
+                    android::base::Result<android::gui::WindowInfosUpdate> result =
+                            SurfaceComposerClient::getDefault()->addWindowInfosListener(listener);
+                    LOG_IF(FATAL, !result.ok()) << "Can't add window listener, pointers won't work";
+                    return result->windowInfos;
+#else
+                    gui::WindowInfosUpdate emptyUpdate;
+                    return emptyUpdate.windowInfos;
 #endif
-                    return initialInfo.first;
                 },
                 [](const sp<android::gui::WindowInfosListener>& listener) {
 #if defined(__ANDROID__)
@@ -867,14 +869,12 @@ std::optional<DisplayViewport> PointerChoreographer::getViewportForPointerDevice
     return std::nullopt;
 }
 
-vec2 PointerChoreographer::getMouseCursorPosition(ui::LogicalDisplayId displayId) {
+std::optional<vec2> PointerChoreographer::getMouseCursorPosition(ui::LogicalDisplayId displayId) {
     std::scoped_lock _l(getLock());
-    const ui::LogicalDisplayId resolvedDisplayId = getTargetMouseDisplayLocked(displayId);
-    if (auto it = mMousePointersByDisplay.find(resolvedDisplayId);
-        it != mMousePointersByDisplay.end()) {
+    if (auto it = mMousePointersByDisplay.find(displayId); it != mMousePointersByDisplay.end()) {
         return it->second->getPosition();
     }
-    return {AMOTION_EVENT_INVALID_CURSOR_POSITION, AMOTION_EVENT_INVALID_CURSOR_POSITION};
+    return std::nullopt;
 }
 
 void PointerChoreographer::setShowTouchesEnabled(bool enabled) {
@@ -1030,7 +1030,8 @@ PointerChoreographer::findDestinationDisplayLocked(const ui::LogicalDisplayId so
         LOG(WARNING) << "Source display missing from topology " << sourceDisplayId;
         return std::nullopt;
     }
-    for (const DisplayTopologyAdjacentDisplay& adjacentDisplay : sourceNode->second) {
+    for (const DisplayTopologyAdjacentDisplay& adjacentDisplay :
+         sourceNode->second.adjacentDisplays) {
         if (adjacentDisplay.position != sourceBoundary) {
             continue;
         }
@@ -1043,8 +1044,8 @@ PointerChoreographer::findDestinationDisplayLocked(const ui::LogicalDisplayId so
         }
         // As displays can have different densities we need to do all calculations in
         // density-independent-pixels a.k.a. dp values.
-        const int sourceDensity = mTopology.displaysDensity.at(sourceDisplayId);
-        const int adjacentDisplayDensity = mTopology.displaysDensity.at(adjacentDisplay.displayId);
+        const int sourceDensity = mTopology.graph.at(sourceDisplayId).density;
+        const int adjacentDisplayDensity = mTopology.graph.at(adjacentDisplay.displayId).density;
         const float sourceCursorOffsetDp = pxToDp(sourceCursorOffsetPx, sourceDensity);
         const int32_t edgeSizePx = sourceBoundary == DisplayTopologyPosition::TOP ||
                         sourceBoundary == DisplayTopologyPosition::BOTTOM
diff --git a/services/inputflinger/PointerChoreographer.h b/services/inputflinger/PointerChoreographer.h
index 67bdca1bab..56de9dc555 100644
--- a/services/inputflinger/PointerChoreographer.h
+++ b/services/inputflinger/PointerChoreographer.h
@@ -60,7 +60,15 @@ public:
     virtual void setDisplayViewports(const std::vector<DisplayViewport>& viewports) = 0;
     virtual std::optional<DisplayViewport> getViewportForPointerDevice(
             ui::LogicalDisplayId associatedDisplayId = ui::LogicalDisplayId::INVALID) = 0;
-    virtual vec2 getMouseCursorPosition(ui::LogicalDisplayId displayId) = 0;
+    /**
+     * Gets the current position of the mouse cursor on the specified display.
+     *
+     * Returns optional.empty if no cursor is available, or if existing cursor is not on
+     * supplied `displayId`.
+     *
+     * This method is inherently racy, and should only be used for test purposes.
+     */
+    virtual std::optional<vec2> getMouseCursorPosition(ui::LogicalDisplayId displayId) = 0;
     virtual void setShowTouchesEnabled(bool enabled) = 0;
     virtual void setStylusPointerIconEnabled(bool enabled) = 0;
     /**
@@ -107,7 +115,7 @@ public:
     void setDisplayViewports(const std::vector<DisplayViewport>& viewports) override;
     std::optional<DisplayViewport> getViewportForPointerDevice(
             ui::LogicalDisplayId associatedDisplayId) override;
-    vec2 getMouseCursorPosition(ui::LogicalDisplayId displayId) override;
+    std::optional<vec2> getMouseCursorPosition(ui::LogicalDisplayId displayId) override;
     void setShowTouchesEnabled(bool enabled) override;
     void setStylusPointerIconEnabled(bool enabled) override;
     bool setPointerIcon(std::variant<std::unique_ptr<SpriteIcon>, PointerIconStyle> icon,
diff --git a/services/inputflinger/benchmarks/Android.bp b/services/inputflinger/benchmarks/Android.bp
index 438507229b..b850761b19 100644
--- a/services/inputflinger/benchmarks/Android.bp
+++ b/services/inputflinger/benchmarks/Android.bp
@@ -27,7 +27,7 @@ cc_benchmark {
         "libinputflinger_base",
         "libinputreporter",
         "liblog",
-        "libstatslog",
+        "libstatslog_inputflinger",
         "libutils",
     ],
     static_libs: [
diff --git a/services/inputflinger/benchmarks/InputDispatcher_benchmarks.cpp b/services/inputflinger/benchmarks/InputDispatcher_benchmarks.cpp
index 96c8640e2f..7ac223015d 100644
--- a/services/inputflinger/benchmarks/InputDispatcher_benchmarks.cpp
+++ b/services/inputflinger/benchmarks/InputDispatcher_benchmarks.cpp
@@ -63,7 +63,7 @@ static MotionEvent generateMotionEvent() {
     MotionEvent event;
     event.initialize(IInputConstants::INVALID_INPUT_EVENT_ID, DEVICE_ID, AINPUT_SOURCE_TOUCHSCREEN,
                      ui::LogicalDisplayId::DEFAULT, INVALID_HMAC, AMOTION_EVENT_ACTION_DOWN,
-                     /* actionButton */ 0, /* flags */ 0,
+                     /* actionButton */ 0, /* flags */ {},
                      /* edgeFlags */ 0, AMETA_NONE, /* buttonState */ 0, MotionClassification::NONE,
                      identityTransform, /* xPrecision */ 0,
                      /* yPrecision */ 0, AMOTION_EVENT_INVALID_CURSOR_POSITION,
@@ -91,8 +91,7 @@ static NotifyMotionArgs generateMotionArgs() {
                           DEVICE_ID, AINPUT_SOURCE_TOUCHSCREEN, ui::LogicalDisplayId::DEFAULT,
                           POLICY_FLAG_PASS_TO_USER, AMOTION_EVENT_ACTION_DOWN,
                           /* actionButton */ 0, /* flags */ 0, AMETA_NONE, /* buttonState */ 0,
-                          MotionClassification::NONE, AMOTION_EVENT_EDGE_FLAG_NONE, 1,
-                          pointerProperties, pointerCoords,
+                          MotionClassification::NONE, 1, pointerProperties, pointerCoords,
                           /* xPrecision */ 0, /* yPrecision */ 0,
                           AMOTION_EVENT_INVALID_CURSOR_POSITION,
                           AMOTION_EVENT_INVALID_CURSOR_POSITION, currentTime, /* videoFrames */ {});
@@ -103,7 +102,7 @@ static NotifyMotionArgs generateMotionArgs() {
 static void benchmarkNotifyMotion(benchmark::State& state) {
     // Create dispatcher
     FakeInputDispatcherPolicy fakePolicy;
-    auto dispatcher = std::make_unique<InputDispatcher>(fakePolicy);
+    auto dispatcher = std::make_unique<InputDispatcher>(fakePolicy, /*env=*/nullptr);
     dispatcher->setInputDispatchMode(/*enabled*/ true, /*frozen*/ false);
     dispatcher->start();
 
@@ -138,7 +137,7 @@ static void benchmarkNotifyMotion(benchmark::State& state) {
 static void benchmarkInjectMotion(benchmark::State& state) {
     // Create dispatcher
     FakeInputDispatcherPolicy fakePolicy;
-    auto dispatcher = std::make_unique<InputDispatcher>(fakePolicy);
+    auto dispatcher = std::make_unique<InputDispatcher>(fakePolicy, /*env=*/nullptr);
     dispatcher->setInputDispatchMode(/*enabled*/ true, /*frozen*/ false);
     dispatcher->start();
 
@@ -172,7 +171,7 @@ static void benchmarkInjectMotion(benchmark::State& state) {
 static void benchmarkOnWindowInfosChanged(benchmark::State& state) {
     // Create dispatcher
     FakeInputDispatcherPolicy fakePolicy;
-    auto dispatcher = std::make_unique<InputDispatcher>(fakePolicy);
+    auto dispatcher = std::make_unique<InputDispatcher>(fakePolicy, /*env=*/nullptr);
     dispatcher->setInputDispatchMode(/*enabled*/ true, /*frozen*/ false);
     dispatcher->start();
 
diff --git a/services/inputflinger/dispatcher/Android.bp b/services/inputflinger/dispatcher/Android.bp
index 1aa8b2b69b..54cbaa6ed1 100644
--- a/services/inputflinger/dispatcher/Android.bp
+++ b/services/inputflinger/dispatcher/Android.bp
@@ -70,7 +70,7 @@ cc_defaults {
         "libkll",
         "liblog",
         "libprotobuf-cpp-lite",
-        "libstatslog",
+        "libstatslog_inputflinger",
         "libstatspull",
         "libstatssocket",
         "libutils",
diff --git a/services/inputflinger/dispatcher/Entry.cpp b/services/inputflinger/dispatcher/Entry.cpp
index ff407af8e1..e2cd5d123d 100644
--- a/services/inputflinger/dispatcher/Entry.cpp
+++ b/services/inputflinger/dispatcher/Entry.cpp
@@ -147,7 +147,7 @@ std::string KeyEntry::getDescription() const {
     if (!IS_DEBUGGABLE_BUILD) {
         return "KeyEvent";
     }
-    return StringPrintf("KeyEvent(deviceId=%d, eventTime=%" PRIu64 ", source=%s, displayId=%s, "
+    return StringPrintf("KeyEvent(deviceId=%d, eventTime=%" PRIu64 "ns, source=%s, displayId=%s, "
                         "action=%s, "
                         "flags=0x%08x, keyCode=%s(%d), scanCode=%d, metaState=0x%08x, "
                         "repeatCount=%d), policyFlags=0x%08x",
@@ -179,7 +179,7 @@ std::string TouchModeEntry::getDescription() const {
 MotionEntry::MotionEntry(int32_t id, std::shared_ptr<InjectionState> injectionState,
                          nsecs_t eventTime, int32_t deviceId, uint32_t source,
                          ui::LogicalDisplayId displayId, uint32_t policyFlags, int32_t action,
-                         int32_t actionButton, int32_t flags, int32_t metaState,
+                         int32_t actionButton, ftl::Flags<MotionFlag> flags, int32_t metaState,
                          int32_t buttonState, MotionClassification classification,
                          int32_t edgeFlags, float xPrecision, float yPrecision,
                          float xCursorPosition, float yCursorPosition, nsecs_t downTime,
@@ -211,15 +211,14 @@ std::string MotionEntry::getDescription() const {
         return "MotionEvent";
     }
     std::string msg;
-    msg += StringPrintf("MotionEvent(deviceId=%d, eventTime=%" PRIu64
-                        ", source=%s, displayId=%s, action=%s, actionButton=0x%08x, flags=0x%08x,"
-                        " metaState=0x%08x, "
+    msg += StringPrintf("MotionEvent(deviceId=%d, eventTime=%" PRIu64 "ns, source=%s, displayId=%s,"
+                        "action=%s, actionButton=0x%08x, flags=%s, metaState=0x%08x, "
                         "buttonState=0x%08x, "
                         "classification=%s, edgeFlags=0x%08x, xPrecision=%.1f, yPrecision=%.1f, "
                         "xCursorPosition=%0.1f, yCursorPosition=%0.1f, pointers=[",
                         deviceId, eventTime, inputEventSourceToString(source).c_str(),
                         displayId.toString().c_str(), MotionEvent::actionToString(action).c_str(),
-                        actionButton, flags, metaState, buttonState,
+                        actionButton, flags.string().c_str(), metaState, buttonState,
                         motionClassificationToString(classification), edgeFlags, xPrecision,
                         yPrecision, xCursorPosition, yCursorPosition);
 
@@ -290,19 +289,14 @@ DispatchEntry::DispatchEntry(std::shared_ptr<const EventEntry> eventEntry,
         rawTransform(rawTransform),
         globalScaleFactor(globalScaleFactor),
         deliveryTime(0),
-        resolvedFlags(0),
+        resolvedMotionFlags{},
         targetUid(targetUid),
         vsyncId(vsyncId),
         windowId(windowId) {
     switch (this->eventEntry->type) {
-        case EventEntry::Type::KEY: {
-            const KeyEntry& keyEntry = static_cast<const KeyEntry&>(*this->eventEntry);
-            resolvedFlags = keyEntry.flags;
-            break;
-        }
         case EventEntry::Type::MOTION: {
             const MotionEntry& motionEntry = static_cast<const MotionEntry&>(*this->eventEntry);
-            resolvedFlags = motionEntry.flags;
+            resolvedMotionFlags = motionEntry.flags;
             break;
         }
         default: {
@@ -321,10 +315,13 @@ uint32_t DispatchEntry::nextSeq() {
 }
 
 std::ostream& operator<<(std::ostream& out, const DispatchEntry& entry) {
+    out << "DispatchEntry{";
+    if (entry.eventEntry->type == EventEntry::Type::MOTION) {
+        out << "resolvedMotionFlags=" << entry.resolvedMotionFlags.string() << ", ";
+    }
     std::string transform;
     entry.transform.dump(transform, "transform");
-    out << "DispatchEntry{resolvedFlags=" << entry.resolvedFlags
-        << ", targetFlags=" << entry.targetFlags.string() << ", transform=" << transform
+    out << "targetFlags=" << entry.targetFlags.string() << ", transform=" << transform
         << "} original: " << entry.eventEntry->getDescription();
     return out;
 }
diff --git a/services/inputflinger/dispatcher/Entry.h b/services/inputflinger/dispatcher/Entry.h
index 9cd76c7d11..b252c990cf 100644
--- a/services/inputflinger/dispatcher/Entry.h
+++ b/services/inputflinger/dispatcher/Entry.h
@@ -20,6 +20,7 @@
 #include "InputTargetFlags.h"
 #include "trace/EventTrackerInterface.h"
 
+#include <ftl/flags.h>
 #include <gui/InputApplication.h>
 #include <input/Input.h>
 #include <stdint.h>
@@ -159,7 +160,7 @@ struct MotionEntry : EventEntry {
     ui::LogicalDisplayId displayId;
     int32_t action;
     int32_t actionButton;
-    int32_t flags;
+    ftl::Flags<MotionFlag> flags;
     int32_t metaState;
     int32_t buttonState;
     MotionClassification classification;
@@ -177,10 +178,10 @@ struct MotionEntry : EventEntry {
 
     MotionEntry(int32_t id, std::shared_ptr<InjectionState> injectionState, nsecs_t eventTime,
                 int32_t deviceId, uint32_t source, ui::LogicalDisplayId displayId,
-                uint32_t policyFlags, int32_t action, int32_t actionButton, int32_t flags,
-                int32_t metaState, int32_t buttonState, MotionClassification classification,
-                int32_t edgeFlags, float xPrecision, float yPrecision, float xCursorPosition,
-                float yCursorPosition, nsecs_t downTime,
+                uint32_t policyFlags, int32_t action, int32_t actionButton,
+                ftl::Flags<MotionFlag> flags, int32_t metaState, int32_t buttonState,
+                MotionClassification classification, int32_t edgeFlags, float xPrecision,
+                float yPrecision, float xCursorPosition, float yCursorPosition, nsecs_t downTime,
                 const std::vector<PointerProperties>& pointerProperties,
                 const std::vector<PointerCoords>& pointerCoords);
     std::string getDescription() const override;
@@ -228,7 +229,8 @@ struct DispatchEntry {
     // An ANR will be triggered if a response for this entry is not received by timeoutTime
     nsecs_t timeoutTime;
 
-    int32_t resolvedFlags;
+    // These are only valid for EventEntry::Type::MOTION
+    ftl::Flags<MotionFlag> resolvedMotionFlags;
 
     // Information about the dispatch window used for tracing. We avoid holding a window handle
     // here because information in a window handle may be dynamically updated within the lifespan
diff --git a/services/inputflinger/dispatcher/FocusResolver.h b/services/inputflinger/dispatcher/FocusResolver.h
index 2910ba44c8..644c2a7b5d 100644
--- a/services/inputflinger/dispatcher/FocusResolver.h
+++ b/services/inputflinger/dispatcher/FocusResolver.h
@@ -68,8 +68,6 @@ public:
     void displayRemoved(ui::LogicalDisplayId displayId);
 
     // exposed for debugging
-    bool hasFocusedWindowTokens() const { return !mFocusedWindowTokenByDisplay.empty(); }
-    std::string dumpFocusedWindows() const;
     std::string dump() const;
 
 private:
@@ -123,6 +121,8 @@ private:
             ui::LogicalDisplayId displayId, const std::string& reason, const sp<IBinder>& token,
             const std::string& tokenName = "");
     std::optional<android::gui::FocusRequest> getFocusRequest(ui::LogicalDisplayId displayId);
+
+    std::string dumpFocusedWindows() const;
 };
 
 } // namespace android::inputdispatcher
diff --git a/services/inputflinger/dispatcher/InputDispatcher.cpp b/services/inputflinger/dispatcher/InputDispatcher.cpp
index 2908c61182..a6a1ef2570 100644
--- a/services/inputflinger/dispatcher/InputDispatcher.cpp
+++ b/services/inputflinger/dispatcher/InputDispatcher.cpp
@@ -82,21 +82,21 @@ namespace android::inputdispatcher {
 
 namespace {
 
-// Input tracing is only available on debuggable builds (userdebug and eng) when the feature
-// flag is enabled. When the flag is changed, tracing will only be available after reboot.
+// Input tracing is only available on debuggable builds when the feature flag is enabled. When the
+// flag is changed, tracing will only be available after reboot.
 bool isInputTracingEnabled() {
-    static const std::string buildType = base::GetProperty("ro.build.type", "user");
-    static const bool isUserdebugOrEng = buildType == "userdebug" || buildType == "eng";
-    return input_flags::enable_input_event_tracing() && isUserdebugOrEng;
+    static const bool isDebuggable = base::GetBoolProperty("ro.debuggable", false);
+    return input_flags::enable_input_event_tracing() && isDebuggable;
 }
 
 // Create the input tracing backend that writes to perfetto from a single thread.
-std::unique_ptr<trace::InputTracingBackendInterface> createInputTracingBackendIfEnabled() {
+std::unique_ptr<trace::InputTracingBackendInterface> createInputTracingBackendIfEnabled(
+        JNIEnv* env) {
     if (!isInputTracingEnabled()) {
         return nullptr;
     }
-    return std::make_unique<trace::impl::ThreadedBackend<trace::impl::PerfettoBackend>>(
-            trace::impl::PerfettoBackend());
+    return std::make_unique<trace::impl::ThreadedBackend<
+            trace::impl::PerfettoBackend>>(trace::impl::PerfettoBackend(), env);
 }
 
 template <class Entry>
@@ -412,8 +412,8 @@ std::unique_ptr<DispatchEntry> createDispatchEntry(const IdGenerator& idGenerato
     const sp<WindowInfoHandle> win = inputTarget.windowHandle;
     const std::optional<int32_t> windowId =
             win ? std::make_optional(win->getInfo()->id) : std::nullopt;
-    // Assume the only targets that are not associated with a window are global monitors, and use
-    // the system UID for global monitors for tracing purposes.
+    // Assume the only targets that are not associated with a window are focus input monitors, and
+    // use the system UID for monitors for tracing purposes.
     const gui::Uid uid = win ? win->getInfo()->ownerUid : gui::Uid(AID_SYSTEM);
 
     if (inputTarget.useDefaultPointerTransform() && !zeroCoords) {
@@ -578,34 +578,6 @@ bool isUserActivityEvent(const EventEntry& eventEntry) {
     }
 }
 
-// Returns true if the given window can accept pointer events at the given display location.
-bool windowAcceptsTouchAt(const WindowInfo& windowInfo, ui::LogicalDisplayId displayId, float x,
-                          float y, bool isStylus, const ui::Transform& displayTransform) {
-    const auto inputConfig = windowInfo.inputConfig;
-    if (windowInfo.displayId != displayId ||
-        inputConfig.test(WindowInfo::InputConfig::NOT_VISIBLE)) {
-        return false;
-    }
-    const bool windowCanInterceptTouch = isStylus && windowInfo.interceptsStylus();
-    if (inputConfig.test(WindowInfo::InputConfig::NOT_TOUCHABLE) && !windowCanInterceptTouch) {
-        return false;
-    }
-
-    // Window Manager works in the logical display coordinate space. When it specifies bounds for a
-    // window as (l, t, r, b), the range of x in [l, r) and y in [t, b) are considered to be inside
-    // the window. Points on the right and bottom edges should not be inside the window, so we need
-    // to be careful about performing a hit test when the display is rotated, since the "right" and
-    // "bottom" of the window will be different in the display (un-rotated) space compared to in the
-    // logical display in which WM determined the bounds. Perform the hit test in the logical
-    // display space to ensure these edges are considered correctly in all orientations.
-    const auto touchableRegion = displayTransform.transform(windowInfo.touchableRegion);
-    const auto p = displayTransform.transform(x, y);
-    if (!touchableRegion.contains(std::floor(p.x), std::floor(p.y))) {
-        return false;
-    }
-    return true;
-}
-
 // Returns true if the given window's frame can occlude pointer events at the given display
 // location.
 bool windowOccludesTouchAt(const WindowInfo& windowInfo, ui::LogicalDisplayId displayId, float x,
@@ -743,7 +715,7 @@ std::vector<TouchedWindow> getHoveringWindowsLocked(const TouchState* oldState,
             if (CC_UNLIKELY(maskedAction != AMOTION_EVENT_ACTION_HOVER_MOVE)) {
                 android::base::LogSeverity severity = android::base::LogSeverity::FATAL;
                 if (!input_flags::a11y_crash_on_inconsistent_event_stream() &&
-                    entry.flags & AMOTION_EVENT_FLAG_IS_ACCESSIBILITY_EVENT) {
+                    entry.flags.test(MotionFlag::IS_ACCESSIBILITY_EVENT)) {
                     // The Accessibility injected touch exploration event stream
                     // has known inconsistencies, so log ERROR instead of
                     // crashing the device with FATAL.
@@ -924,12 +896,15 @@ std::string dumpWindowForTouchOcclusion(const WindowInfo& info, bool isTouchedWi
 
 // --- InputDispatcher ---
 
-InputDispatcher::InputDispatcher(InputDispatcherPolicyInterface& policy)
-      : InputDispatcher(policy, createInputTracingBackendIfEnabled()) {}
+InputDispatcher::InputDispatcher(InputDispatcherPolicyInterface& policy, JNIEnv* env)
+      : InputDispatcher(policy, createInputTracingBackendIfEnabled(env), env) {}
 
 InputDispatcher::InputDispatcher(InputDispatcherPolicyInterface& policy,
-                                 std::unique_ptr<trace::InputTracingBackendInterface> traceBackend)
-      : mPolicy(policy),
+                                 std::unique_ptr<trace::InputTracingBackendInterface> traceBackend,
+                                 JNIEnv* env)
+      : mJniEnv(env),
+        mPolicy(policy),
+
         mLooper(sp<Looper>::make(false)),
         mPendingEvent(nullptr),
         mLastDropReason(DropReason::NOT_DROPPED),
@@ -957,7 +932,10 @@ InputDispatcher::InputDispatcher(InputDispatcherPolicyInterface& policy,
 
     mWindowInfoListener = sp<DispatcherWindowListener>::make(*this);
 #if defined(__ANDROID__)
-    SurfaceComposerClient::getDefault()->addWindowInfosListener(mWindowInfoListener);
+    android::base::Result<gui::WindowInfosUpdate> result =
+            SurfaceComposerClient::getDefault()->addWindowInfosListener(mWindowInfoListener);
+    LOG_IF(FATAL, !result.ok()) << "Can't listen for window info. Input will not work";
+    onWindowInfosChanged(*result);
 #endif
     mKeyRepeatState.lastKeyEntry = nullptr;
 
@@ -986,7 +964,7 @@ status_t InputDispatcher::start() {
     }
     mThread = std::make_unique<InputThread>(
             "InputDispatcher", [this]() { dispatchOnce(); }, [this]() { mLooper->wake(); },
-            /*isInCriticalPath=*/true);
+            /*isInCriticalPath=*/true, mJniEnv);
     return OK;
 }
 
@@ -1458,8 +1436,7 @@ sp<WindowInfoHandle> InputDispatcher::DispatcherWindowInfo::findTouchedWindowAt(
         }
 
         const WindowInfo& info = *windowHandle->getInfo();
-        if (!info.isSpy() &&
-            windowAcceptsTouchAt(info, displayId, x, y, isStylus, getDisplayTransform(displayId))) {
+        if (!info.isSpy() && windowAcceptsTouchAt(info, displayId, x, y, isStylus)) {
             return windowHandle;
         }
     }
@@ -1500,11 +1477,10 @@ std::vector<sp<WindowInfoHandle>> InputDispatcher::findTouchedSpyWindowsAt(
         const DispatcherWindowInfo& windowInfos) {
     // Traverse windows from front to back and gather the touched spy windows.
     std::vector<sp<WindowInfoHandle>> spyWindows;
-    const ui::Transform displayTransform = windowInfos.getDisplayTransform(displayId);
     const auto& windowHandles = windowInfos.getWindowHandlesForDisplay(displayId);
     for (const sp<WindowInfoHandle>& windowHandle : windowHandles) {
         const WindowInfo& info = *windowHandle->getInfo();
-        if (!windowAcceptsTouchAt(info, displayId, x, y, isStylus, displayTransform)) {
+        if (!windowInfos.windowAcceptsTouchAt(info, displayId, x, y, isStylus)) {
             // Skip if the pointer is outside of the window.
             continue;
         }
@@ -1656,12 +1632,19 @@ std::shared_ptr<KeyEntry> InputDispatcher::synthesizeKeyRepeatLocked(nsecs_t cur
     uint32_t policyFlags = entry->policyFlags &
             (POLICY_FLAG_RAW_MASK | POLICY_FLAG_PASS_TO_USER | POLICY_FLAG_TRUSTED);
 
+    int32_t resolvedFlags = entry->flags & ~AKEY_EVENT_FLAG_LONG_PRESS;
+    const int32_t newRepeatCount = entry->repeatCount + 1;
+    if (newRepeatCount == 1) {
+        // This flag is only set for the first key repeat
+        resolvedFlags |= AKEY_EVENT_FLAG_LONG_PRESS;
+    }
+
     std::shared_ptr<KeyEntry> newEntry =
             std::make_unique<KeyEntry>(mIdGenerator.nextId(), /*injectionState=*/nullptr,
                                        currentTime, entry->deviceId, entry->source,
-                                       entry->displayId, policyFlags, entry->action, entry->flags,
+                                       entry->displayId, policyFlags, entry->action, resolvedFlags,
                                        entry->keyCode, entry->scanCode, entry->metaState,
-                                       entry->repeatCount + 1, entry->downTime);
+                                       newRepeatCount, entry->downTime);
 
     newEntry->syntheticRepeat = true;
     if (mTracer) {
@@ -1677,7 +1660,7 @@ bool InputDispatcher::dispatchDeviceResetLocked(nsecs_t currentTime,
                                                 const DeviceResetEntry& entry) {
     LOG_IF(INFO, DEBUG_OUTBOUND_EVENT_DETAILS)
             << "dispatchDeviceReset - eventTime=" << entry.eventTime
-            << ", deviceId=" << entry.deviceId;
+            << "ns, deviceId=" << entry.deviceId;
 
     // Reset key repeating in case a keyboard device was disabled or enabled.
     if (mKeyRepeatState.lastKeyEntry && mKeyRepeatState.lastKeyEntry->deviceId == entry.deviceId) {
@@ -1896,14 +1879,14 @@ bool InputDispatcher::dispatchKeyLocked(nsecs_t currentTime, std::shared_ptr<con
         entry->interceptKeyWakeupTime = 0;
     }
 
+    const ui::LogicalDisplayId displayId = getTargetDisplayId(*entry);
     // Give the policy a chance to intercept the key.
     if (entry->interceptKeyResult == KeyEntry::InterceptKeyResult::UNKNOWN) {
         if (entry->policyFlags & POLICY_FLAG_PASS_TO_USER) {
-            sp<IBinder> focusedWindowToken =
-                    mFocusResolver.getFocusedWindowToken(getTargetDisplayId(*entry));
+            sp<IBinder> focusedWindowToken = mFocusResolver.getFocusedWindowToken(displayId);
 
-            auto command = [this, focusedWindowToken, entry]() REQUIRES(mLock) {
-                doInterceptKeyBeforeDispatchingCommand(focusedWindowToken, *entry);
+            auto command = [this, focusedWindowToken, displayId, entry]() REQUIRES(mLock) {
+                doInterceptKeyBeforeDispatchingCommand(focusedWindowToken, displayId, *entry);
             };
             postCommandLocked(std::move(command));
             return false; // wait for the command to run
@@ -1952,7 +1935,7 @@ bool InputDispatcher::dispatchKeyLocked(nsecs_t currentTime, std::shared_ptr<con
                           InputTarget::Flags::FOREGROUND, getDownTime(*entry), inputTargets);
 
     // Add monitor channels from event's or focused display.
-    addGlobalMonitoringTargetsLocked(inputTargets, getTargetDisplayId(*entry));
+    addFocusInputMonitoringTargetsLocked(inputTargets, displayId);
 
     if (mTracer) {
         ensureEventTraced(*entry);
@@ -2031,13 +2014,13 @@ void InputDispatcher::findAndDispatchFallbackEvent(nsecs_t currentTime,
 
 void InputDispatcher::logOutboundKeyDetails(const char* prefix, const KeyEntry& entry) {
     LOG_IF(INFO, DEBUG_OUTBOUND_EVENT_DETAILS)
-            << prefix << "eventTime=" << entry.eventTime << ", deviceId=" << entry.deviceId
+            << prefix << "eventTime=" << entry.eventTime << "ns, deviceId=" << entry.deviceId
             << ", source=0x" << std::hex << entry.source
             << ", displayId=" << entry.displayId.toString() << ", policyFlags=0x"
             << entry.policyFlags << ", action=0x" << entry.action << ", flags=0x" << entry.flags
             << ", keyCode=0x" << entry.keyCode << ", scanCode=0x" << entry.scanCode
             << ", metaState=0x" << entry.metaState << ", repeatCount=" << std::dec
-            << entry.repeatCount << ", downTime=" << entry.downTime;
+            << entry.repeatCount << ", downTime=" << entry.downTime << "ns";
 }
 
 void InputDispatcher::dispatchSensorLocked(nsecs_t currentTime,
@@ -2045,7 +2028,7 @@ void InputDispatcher::dispatchSensorLocked(nsecs_t currentTime,
                                            DropReason* dropReason, nsecs_t& nextWakeupTime) {
     LOG_IF(INFO, DEBUG_OUTBOUND_EVENT_DETAILS)
             << "notifySensorEvent eventTime=" << entry->eventTime
-            << ", hwTimestamp=" << entry->hwTimestamp << ", deviceId=" << entry->deviceId
+            << "ns, hwTimestamp=" << entry->hwTimestamp << ", deviceId=" << entry->deviceId
             << ", source=0x" << std::hex << entry->source << std::dec
             << ", sensorType=" << ftl::enum_string(entry->sensorType);
     auto command = [this, entry]() REQUIRES(mLock) {
@@ -2162,8 +2145,10 @@ bool InputDispatcher::dispatchMotionLocked(nsecs_t currentTime,
         return true;
     }
 
-    // Add monitor channels from event's or focused display.
-    addGlobalMonitoringTargetsLocked(inputTargets, getTargetDisplayId(*entry));
+    if (!isPointerEvent) {
+        // Add monitor channels from event's or focused display.
+        addFocusInputMonitoringTargetsLocked(inputTargets, getTargetDisplayId(*entry));
+    }
 
     if (mTracer) {
         ensureEventTraced(*entry);
@@ -2201,13 +2186,14 @@ void InputDispatcher::dispatchDragLocked(nsecs_t currentTime,
 
 void InputDispatcher::logOutboundMotionDetails(const char* prefix, const MotionEntry& entry) {
     if (DEBUG_OUTBOUND_EVENT_DETAILS) {
-        ALOGD("%seventTime=%" PRId64 ", deviceId=%d, source=%s, displayId=%s, policyFlags=0x%x, "
-              "action=%s, actionButton=0x%x, flags=0x%x, "
-              "metaState=0x%x, buttonState=0x%x, downTime=%" PRId64,
+        ALOGD("%seventTime=%" PRId64 "ns, deviceId=%d, source=%s, displayId=%s, policyFlags=0x%x, "
+              "action=%s, actionButton=0x%x, flags=%s, "
+              "metaState=0x%x, buttonState=0x%x, downTime=%" PRId64 "ns",
               prefix, entry.eventTime, entry.deviceId,
               inputEventSourceToString(entry.source).c_str(), entry.displayId.toString().c_str(),
               entry.policyFlags, MotionEvent::actionToString(entry.action).c_str(),
-              entry.actionButton, entry.flags, entry.metaState, entry.buttonState, entry.downTime);
+              entry.actionButton, entry.flags.string().c_str(), entry.metaState, entry.buttonState,
+              entry.downTime);
 
         for (uint32_t i = 0; i < entry.getPointerCount(); i++) {
             ALOGD("  Pointer %d: id=%d, toolType=%s, "
@@ -3058,32 +3044,30 @@ void InputDispatcher::DispatcherTouchState::addPointerWindowTarget(
     }
 }
 
-void InputDispatcher::addGlobalMonitoringTargetsLocked(std::vector<InputTarget>& inputTargets,
-                                                       ui::LogicalDisplayId displayId) {
+void InputDispatcher::addFocusInputMonitoringTargetsLocked(std::vector<InputTarget>& inputTargets,
+                                                           ui::LogicalDisplayId displayId) {
     mConnectionManager
-            .forEachGlobalMonitorConnection(displayId,
-                                            [&](const std::shared_ptr<Connection>& connection) {
-                                                if (!connection->responsive) {
-                                                    ALOGW("Ignoring unrsponsive monitor: %s",
-                                                          connection->getInputChannelName()
-                                                                  .c_str());
-                                                    return;
-                                                }
-
-                                                InputTarget target{connection};
-                                                // target.firstDownTimeInTarget is not set for
-                                                // global monitors. It is only required in split
-                                                // touch and global monitoring works as intended
-                                                // even without setting firstDownTimeInTarget. Since
-                                                // global monitors don't have windows, use the
-                                                // display transform as the raw transform.
-                                                base::ScopedLockAssertion assumeLocked(mLock);
-                                                target.rawTransform =
-                                                        mWindowInfos.getDisplayTransform(displayId);
-                                                target.setDefaultPointerTransform(
-                                                        target.rawTransform);
-                                                inputTargets.push_back(target);
-                                            });
+            .forEachMonitorConnection(displayId,
+                                      [&](const std::shared_ptr<Connection>& connection) {
+                                          if (!connection->responsive) {
+                                              ALOGW("Ignoring unresponsive monitor: %s",
+                                                    connection->getInputChannelName().c_str());
+                                              return;
+                                          }
+
+                                          InputTarget target{connection};
+                                          // target.firstDownTimeInTarget is not set for
+                                          // monitors. It is only required in split
+                                          // touch. Focus event monitoring works as intended
+                                          // even without setting firstDownTimeInTarget. Since
+                                          // monitors don't have windows, use the
+                                          // display transform as the raw transform.
+                                          base::ScopedLockAssertion assumeLocked(mLock);
+                                          target.rawTransform =
+                                                  mWindowInfos.getDisplayTransform(displayId);
+                                          target.setDefaultPointerTransform(target.rawTransform);
+                                          inputTargets.push_back(target);
+                                      });
 }
 
 /**
@@ -3458,7 +3442,7 @@ void InputDispatcher::enqueueDispatchEntryLocked(const std::shared_ptr<Connectio
                 // Determine the resolved motion entry.
                 const MotionEntry& motionEntry = static_cast<const MotionEntry&>(*eventEntry);
                 int32_t resolvedAction = motionEntry.action;
-                int32_t resolvedFlags = motionEntry.flags;
+                ftl::Flags<MotionFlag> resolvedFlags = motionEntry.flags;
 
                 if (inputTarget.dispatchMode == InputTarget::DispatchMode::OUTSIDE) {
                     resolvedAction = AMOTION_EVENT_ACTION_OUTSIDE;
@@ -3482,20 +3466,20 @@ void InputDispatcher::enqueueDispatchEntryLocked(const std::shared_ptr<Connectio
                 }
 
                 if (resolvedAction == AMOTION_EVENT_ACTION_CANCEL) {
-                    resolvedFlags |= AMOTION_EVENT_FLAG_CANCELED;
+                    resolvedFlags |= MotionFlag::CANCELED;
                 }
                 if (dispatchEntry->targetFlags.test(InputTarget::Flags::WINDOW_IS_OBSCURED)) {
-                    resolvedFlags |= AMOTION_EVENT_FLAG_WINDOW_IS_OBSCURED;
+                    resolvedFlags |= MotionFlag::WINDOW_IS_OBSCURED;
                 }
                 if (dispatchEntry->targetFlags.test(
                             InputTarget::Flags::WINDOW_IS_PARTIALLY_OBSCURED)) {
-                    resolvedFlags |= AMOTION_EVENT_FLAG_WINDOW_IS_PARTIALLY_OBSCURED;
+                    resolvedFlags |= MotionFlag::WINDOW_IS_PARTIALLY_OBSCURED;
                 }
                 if (dispatchEntry->targetFlags.test(InputTarget::Flags::NO_FOCUS_CHANGE)) {
-                    resolvedFlags |= AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE;
+                    resolvedFlags |= MotionFlag::NO_FOCUS_CHANGE;
                 }
 
-                dispatchEntry->resolvedFlags = resolvedFlags;
+                dispatchEntry->resolvedMotionFlags = resolvedFlags;
                 if (resolvedAction != motionEntry.action) {
                     std::optional<std::vector<PointerProperties>> usingProperties;
                     std::optional<std::vector<PointerCoords>> usingCoords;
@@ -3578,12 +3562,12 @@ void InputDispatcher::enqueueDispatchEntryLocked(const std::shared_ptr<Connectio
             }
 
             if (!connection->inputState.trackMotion(*resolvedMotion,
-                                                    dispatchEntry->resolvedFlags)) {
+                                                    dispatchEntry->resolvedMotionFlags)) {
                 LOG(WARNING) << "channel " << connection->getInputChannelName()
                              << "~ dropping inconsistent event: " << *dispatchEntry;
                 return; // skip the inconsistent event
             }
-            if ((dispatchEntry->resolvedFlags & AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE) &&
+            if (dispatchEntry->resolvedMotionFlags.test(MotionFlag::NO_FOCUS_CHANGE) &&
                 (resolvedMotion->policyFlags & POLICY_FLAG_TRUSTED)) {
                 // Skip reporting pointer down outside focus to the policy.
                 break;
@@ -3687,19 +3671,23 @@ void InputDispatcher::processInteractionsLocked(const EventEntry& entry,
                            };
     postCommandLocked(std::move(command));
 
-    if (newConnectionTokens == mInteractionConnectionTokens) {
+    const ui::LogicalDisplayId displayId = getTargetDisplayId(entry);
+    if (const auto& it = mInteractionConnectionTokensByDisplay.find(displayId);
+        it != mInteractionConnectionTokensByDisplay.end() && newConnectionTokens == it->second) {
         return; // no change
     }
-    mInteractionConnectionTokens = newConnectionTokens;
+    mInteractionConnectionTokensByDisplay[displayId] = newConnectionTokens;
 
-    std::string targetList;
+    std::string targetList = "[";
     for (const std::shared_ptr<Connection>& connection : newConnections) {
-        targetList += connection->getInputChannelName() + ", ";
+        targetList += connection->getInputChannelName() + ",";
     }
-    std::string message = "Interaction with: " + targetList;
-    if (targetList.empty()) {
-        message += "<none>";
+    if (!newConnections.empty()) {
+        targetList.pop_back();
     }
+    targetList += "]";
+    const std::string message =
+            "Interaction with: " + targetList + ", on displayId " + displayId.toString();
     android_log_event_list(LOGTAG_INPUT_INTERACTION) << message << LOG_ID_EVENTS;
 }
 
@@ -3756,7 +3744,7 @@ status_t InputDispatcher::publishMotionEvent(Connection& connection,
             .publishMotionEvent(dispatchEntry.seq, motionEntry.id, motionEntry.deviceId,
                                 motionEntry.source, motionEntry.displayId, std::move(hmac),
                                 motionEntry.action, motionEntry.actionButton,
-                                dispatchEntry.resolvedFlags, motionEntry.edgeFlags,
+                                dispatchEntry.resolvedMotionFlags.get(), motionEntry.edgeFlags,
                                 motionEntry.metaState, motionEntry.buttonState,
                                 motionEntry.classification, dispatchEntry.transform,
                                 motionEntry.xPrecision, motionEntry.yPrecision,
@@ -3792,14 +3780,14 @@ void InputDispatcher::startDispatchCycleLocked(nsecs_t currentTime,
                         << connection->getInputChannelName();
 
                 // Publish the key event.
-                status = connection->inputPublisher
-                                 .publishKeyEvent(dispatchEntry->seq, keyEntry.id,
-                                                  keyEntry.deviceId, keyEntry.source,
-                                                  keyEntry.displayId, std::move(hmac),
-                                                  keyEntry.action, dispatchEntry->resolvedFlags,
-                                                  keyEntry.keyCode, keyEntry.scanCode,
-                                                  keyEntry.metaState, keyEntry.repeatCount,
-                                                  keyEntry.downTime, keyEntry.eventTime);
+                status =
+                        connection->inputPublisher
+                                .publishKeyEvent(dispatchEntry->seq, keyEntry.id, keyEntry.deviceId,
+                                                 keyEntry.source, keyEntry.displayId,
+                                                 std::move(hmac), keyEntry.action, keyEntry.flags,
+                                                 keyEntry.keyCode, keyEntry.scanCode,
+                                                 keyEntry.metaState, keyEntry.repeatCount,
+                                                 keyEntry.downTime, keyEntry.eventTime);
                 if (mTracer) {
                     ensureEventTraced(keyEntry);
                     mTracer->traceEventDispatch(*dispatchEntry, *keyEntry.traceTracker);
@@ -3938,14 +3926,14 @@ const std::array<uint8_t, 32> InputDispatcher::getSignature(
     VerifiedMotionEvent verifiedEvent =
             verifiedMotionEventFromMotionEntry(motionEntry, dispatchEntry.rawTransform);
     verifiedEvent.actionMasked = actionMasked;
-    verifiedEvent.flags = dispatchEntry.resolvedFlags & VERIFIED_MOTION_EVENT_FLAGS;
+    verifiedEvent.flags = dispatchEntry.resolvedMotionFlags & VERIFIED_MOTION_EVENT_FLAGS;
     return sign(verifiedEvent);
 }
 
 const std::array<uint8_t, 32> InputDispatcher::getSignature(
         const KeyEntry& keyEntry, const DispatchEntry& dispatchEntry) const {
     VerifiedKeyEvent verifiedEvent = verifiedKeyEventFromKeyEntry(keyEntry);
-    verifiedEvent.flags = dispatchEntry.resolvedFlags & VERIFIED_KEY_EVENT_FLAGS;
+    verifiedEvent.flags = keyEntry.flags & VERIFIED_KEY_EVENT_FLAGS;
     return sign(verifiedEvent);
 }
 
@@ -4124,12 +4112,10 @@ void InputDispatcher::synthesizeCancelationEventsForAllConnectionsLocked(
 
 void InputDispatcher::synthesizeCancelationEventsForMonitorsLocked(
         const CancelationOptions& options) {
-    mConnectionManager.forEachGlobalMonitorConnection(
-            [&](const std::shared_ptr<Connection>& connection) {
-                base::ScopedLockAssertion assumeLocked(mLock);
-                synthesizeCancelationEventsForConnectionLocked(connection, options,
-                                                               /*window=*/nullptr);
-            });
+    mConnectionManager.forEachMonitorConnection([&](const std::shared_ptr<Connection>& connection) {
+        base::ScopedLockAssertion assumeLocked(mLock);
+        synthesizeCancelationEventsForConnectionLocked(connection, options, /*window=*/nullptr);
+    });
 }
 
 void InputDispatcher::synthesizeCancelationEventsForWindowLocked(
@@ -4393,7 +4379,7 @@ std::unique_ptr<MotionEntry> InputDispatcher::splitMotionEvent(
     if (action == AMOTION_EVENT_ACTION_DOWN && splitDownTime != originalMotionEntry.eventTime) {
         logDispatchStateLocked();
         LOG_ALWAYS_FATAL("Split motion event has mismatching downTime and eventTime for "
-                         "ACTION_DOWN, motionEntry=%s, splitDownTime=%" PRId64,
+                         "ACTION_DOWN, motionEntry=%s, splitDownTime=%" PRId64 "ns",
                          originalMotionEntry.getDescription().c_str(), splitDownTime);
     }
 
@@ -4436,13 +4422,13 @@ void InputDispatcher::notifyInputDevicesChanged(const NotifyInputDevicesChangedA
 void InputDispatcher::notifyKey(const NotifyKeyArgs& args) {
     LOG_IF(INFO, debugInboundEventDetails())
             << "notifyKey - id=" << args.id << ", eventTime=" << args.eventTime
-            << ", deviceId=" << args.deviceId
+            << "ns, deviceId=" << args.deviceId
             << ", source=" << inputEventSourceToString(args.source)
             << ", displayId=" << args.displayId.toString() << ", policyFlags=0x" << std::hex
             << args.policyFlags << ", action=" << KeyEvent::actionToString(args.action)
             << ", flags=0x" << args.flags << ", keyCode=" << KeyEvent::getLabel(args.keyCode)
             << ", scanCode=0x" << args.scanCode << ", metaState=0x" << args.metaState
-            << ", downTime=" << std::dec << args.downTime;
+            << ", downTime=" << std::dec << args.downTime << "ns";
     Result<void> keyCheck = validateKeyEvent(args.action);
     if (!keyCheck.ok()) {
         LOG(ERROR) << "invalid key event: " << keyCheck.error();
@@ -4529,10 +4515,10 @@ bool InputDispatcher::shouldSendKeyToInputFilterLocked(const NotifyKeyArgs& args
 
 void InputDispatcher::notifyMotion(const NotifyMotionArgs& args) {
     if (debugInboundEventDetails()) {
-        ALOGD("notifyMotion - id=%" PRIx32 " eventTime=%" PRId64 ", deviceId=%d, source=%s, "
+        ALOGD("notifyMotion - id=%" PRIx32 " eventTime=%" PRId64 "ns, deviceId=%d, source=%s, "
               "displayId=%s, policyFlags=0x%x, "
               "action=%s, actionButton=0x%x, flags=0x%x, metaState=0x%x, buttonState=0x%x, "
-              "xCursorPosition=%f, yCursorPosition=%f, downTime=%" PRId64,
+              "xCursorPosition=%f, yCursorPosition=%f, downTime=%" PRId64 "ns",
               args.id, args.eventTime, args.deviceId, inputEventSourceToString(args.source).c_str(),
               args.displayId.toString().c_str(), args.policyFlags,
               MotionEvent::actionToString(args.action).c_str(), args.actionButton, args.flags,
@@ -4607,8 +4593,8 @@ void InputDispatcher::notifyMotion(const NotifyMotionArgs& args) {
 
             MotionEvent event;
             event.initialize(args.id, args.deviceId, args.source, args.displayId, INVALID_HMAC,
-                             args.action, args.actionButton, args.flags, args.edgeFlags,
-                             args.metaState, args.buttonState, args.classification,
+                             args.action, args.actionButton, ftl::Flags<MotionFlag>(args.flags),
+                             args.edgeFlags, args.metaState, args.buttonState, args.classification,
                              displayTransform, args.xPrecision, args.yPrecision,
                              args.xCursorPosition, args.yCursorPosition, displayTransform,
                              args.downTime, args.eventTime, args.getPointerCount(),
@@ -4627,11 +4613,12 @@ void InputDispatcher::notifyMotion(const NotifyMotionArgs& args) {
                 std::make_unique<MotionEntry>(args.id, /*injectionState=*/nullptr, args.eventTime,
                                               args.deviceId, args.source, args.displayId,
                                               policyFlags, args.action, args.actionButton,
-                                              args.flags, args.metaState, args.buttonState,
-                                              args.classification, args.edgeFlags, args.xPrecision,
-                                              args.yPrecision, args.xCursorPosition,
-                                              args.yCursorPosition, args.downTime,
-                                              args.pointerProperties, args.pointerCoords);
+                                              ftl::Flags<MotionFlag>(args.flags), args.metaState,
+                                              args.buttonState, args.classification, args.edgeFlags,
+                                              args.xPrecision, args.yPrecision,
+                                              args.xCursorPosition, args.yCursorPosition,
+                                              args.downTime, args.pointerProperties,
+                                              args.pointerCoords);
         if (mTracer) {
             newEntry->traceTracker = mTracer->traceInboundEvent(*newEntry);
         }
@@ -4654,7 +4641,7 @@ void InputDispatcher::notifyMotion(const NotifyMotionArgs& args) {
 void InputDispatcher::notifySensor(const NotifySensorArgs& args) {
     LOG_IF(INFO, debugInboundEventDetails())
             << "notifySensor - id=" << args.id << " eventTime=" << args.eventTime
-            << ", deviceId=" << args.deviceId << ", source=0x" << std::hex << args.source
+            << "ns, deviceId=" << args.deviceId << ", source=0x" << std::hex << args.source
             << std::dec << ", sensorType=" << ftl::enum_string(args.sensorType);
 
     bool needWake = false;
@@ -4678,8 +4665,8 @@ void InputDispatcher::notifySensor(const NotifySensorArgs& args) {
 
 void InputDispatcher::notifyVibratorState(const NotifyVibratorStateArgs& args) {
     LOG_IF(INFO, debugInboundEventDetails())
-            << "notifyVibratorState - eventTime=" << args.eventTime << ", device=" << args.deviceId
-            << ", isOn=" << args.isOn;
+            << "notifyVibratorState - eventTime=" << args.eventTime
+            << "ns, deviceId=" << args.deviceId << ", isOn=" << args.isOn;
     mPolicy.notifyVibratorState(args.deviceId, args.isOn);
 }
 
@@ -4689,7 +4676,7 @@ bool InputDispatcher::shouldSendMotionToInputFilterLocked(const NotifyMotionArgs
 
 void InputDispatcher::notifySwitch(const NotifySwitchArgs& args) {
     LOG_IF(INFO, debugInboundEventDetails())
-            << "notifySwitch - eventTime=" << args.eventTime << ", policyFlags=0x" << std::hex
+            << "notifySwitch - eventTime=" << args.eventTime << "ns, policyFlags=0x" << std::hex
             << args.policyFlags << ", switchValues=0x" << std::setfill('0') << std::setw(8)
             << args.switchValues << ", switchMask=0x" << std::setw(8) << args.switchMask;
 
@@ -4701,7 +4688,8 @@ void InputDispatcher::notifySwitch(const NotifySwitchArgs& args) {
 void InputDispatcher::notifyDeviceReset(const NotifyDeviceResetArgs& args) {
     // TODO(b/308677868) Remove device reset from the InputListener interface
     LOG_IF(INFO, debugInboundEventDetails())
-            << "notifyDeviceReset - eventTime=" << args.eventTime << ", deviceId=" << args.deviceId;
+            << "notifyDeviceReset - eventTime=" << args.eventTime
+            << "ns, deviceId=" << args.deviceId;
 
     bool needWake = false;
     { // acquire lock
@@ -4724,7 +4712,7 @@ void InputDispatcher::notifyDeviceReset(const NotifyDeviceResetArgs& args) {
 void InputDispatcher::notifyPointerCaptureChanged(const NotifyPointerCaptureChangedArgs& args) {
     LOG_IF(INFO, debugInboundEventDetails())
             << "notifyPointerCaptureChanged - eventTime=%" << args.eventTime
-            << ", enabled=" << toString(args.request.isEnable());
+            << "ns, enabled=" << toString(args.request.isEnable());
 
     bool needWake = false;
     { // acquire lock
@@ -4743,7 +4731,7 @@ bool InputDispatcher::shouldRejectInjectedMotionLocked(const MotionEvent& motion
                                                        DeviceId deviceId,
                                                        ui::LogicalDisplayId displayId,
                                                        std::optional<gui::Uid> targetUid,
-                                                       int32_t flags) {
+                                                       ftl::Flags<MotionFlag> flags) {
     // Don't verify targeted injection, since it will only affect the caller's
     // window, and the windows are typically destroyed at the end of the test.
     if (targetUid.has_value()) {
@@ -4763,7 +4751,7 @@ bool InputDispatcher::shouldRejectInjectedMotionLocked(const MotionEvent& motion
             verifier.processMovement(deviceId, motionEvent.getSource(), motionEvent.getAction(),
                                      motionEvent.getActionButton(), motionEvent.getPointerCount(),
                                      motionEvent.getPointerProperties(),
-                                     motionEvent.getSamplePointerCoords(), flags,
+                                     motionEvent.getSamplePointerCoords(), flags.get(),
                                      motionEvent.getButtonState());
     if (!result.ok()) {
         logDispatchStateLocked();
@@ -4861,7 +4849,7 @@ InputEventInjectionResult InputDispatcher::injectInputEvent(const InputEvent* ev
                     isPointerEvent && (event->getDisplayId() == ui::LogicalDisplayId::INVALID)
                     ? ui::LogicalDisplayId::DEFAULT
                     : event->getDisplayId();
-            int32_t flags = motionEvent.getFlags();
+            ftl::Flags<MotionFlag> flags = motionEvent.getFlags();
 
             if (!(policyFlags & POLICY_FLAG_FILTERED)) {
                 nsecs_t eventTime = motionEvent.getEventTime();
@@ -4876,11 +4864,11 @@ InputEventInjectionResult InputDispatcher::injectInputEvent(const InputEvent* ev
             }
 
             if (policyFlags & POLICY_FLAG_INJECTED_FROM_ACCESSIBILITY) {
-                flags |= AMOTION_EVENT_FLAG_IS_ACCESSIBILITY_EVENT;
+                flags |= MotionFlag::IS_ACCESSIBILITY_EVENT;
             }
 
             if (policyFlags & POLICY_FLAG_INJECTED_FROM_ACCESSIBILITY_TOOL) {
-                flags |= AMOTION_EVENT_FLAG_INJECTED_FROM_ACCESSIBILITY_TOOL;
+                flags |= MotionFlag::INJECTED_FROM_ACCESSIBILITY_TOOL;
             }
 
             mLock.lock();
@@ -5250,7 +5238,7 @@ ui::Transform InputDispatcher::DispatcherWindowInfo::getRawTransform(
         std::optional<ui::LogicalDisplayId> pointerDisplayId) const {
     // TODO(b/383092013): Handle TOPOLOGY_AWARE window flag.
     // For now, we assume all windows are topology-aware and can handle cross-display streams.
-    if (com::android::input::flags::connected_displays_cursor() && pointerDisplayId.has_value() &&
+    if (InputFlags::connectedDisplaysCursorEnabled() && pointerDisplayId.has_value() &&
         *pointerDisplayId != windowInfo.displayId) {
         // Sending pointer to a different display than the window. This is a
         // cross-display drag gesture, so always use the new display's transform.
@@ -5266,6 +5254,36 @@ ui::Transform InputDispatcher::DispatcherWindowInfo::getRawTransform(
     return getDisplayTransform(windowInfo.displayId);
 }
 
+bool InputDispatcher::DispatcherWindowInfo::windowAcceptsTouchAt(const gui::WindowInfo& windowInfo,
+                                                                 ui::LogicalDisplayId displayId,
+                                                                 float x, float y,
+                                                                 bool isStylus) const {
+    const auto inputConfig = windowInfo.inputConfig;
+    if (windowInfo.displayId != displayId ||
+        inputConfig.test(WindowInfo::InputConfig::NOT_VISIBLE)) {
+        return false;
+    }
+    const bool windowCanInterceptTouch = isStylus && windowInfo.interceptsStylus();
+    if (inputConfig.test(WindowInfo::InputConfig::NOT_TOUCHABLE) && !windowCanInterceptTouch) {
+        return false;
+    }
+
+    // Window Manager works in the logical display coordinate space. When it specifies bounds for a
+    // window as (l, t, r, b), the range of x in [l, r) and y in [t, b) are considered to be inside
+    // the window. Points on the right and bottom edges should not be inside the window, so we need
+    // to be careful about performing a hit test when the display is rotated, since the "right" and
+    // "bottom" of the window will be different in the display (un-rotated) space compared to in the
+    // logical display in which WM determined the bounds. Perform the hit test in the logical
+    // display space to ensure these edges are considered correctly in all orientations.
+    const ui::Transform& displayTransform = getDisplayTransform(windowInfo.displayId);
+    const auto touchableRegion = displayTransform.transform(windowInfo.touchableRegion);
+    const auto p = displayTransform.transform(x, y);
+    if (!touchableRegion.contains(std::floor(p.x), std::floor(p.y))) {
+        return false;
+    }
+    return true;
+}
+
 ui::LogicalDisplayId InputDispatcher::DispatcherWindowInfo::getPrimaryDisplayId(
         ui::LogicalDisplayId displayId) const {
     if (mTopology.graph.contains(displayId)) {
@@ -5500,6 +5518,13 @@ void InputDispatcher::setInputWindowsLocked(
                                             WindowInfo::InputConfig::TRUSTED_OVERLAY),
                             "%s has feature INTERCEPTS_STYLUS, but is not a trusted overlay.",
                             window->getName().c_str());
+
+        // Ensure all do-not-pilfer requests come from trusted overlays
+        LOG_ALWAYS_FATAL_IF(info.inputConfig.test(WindowInfo::InputConfig::DO_NOT_PILFER) &&
+                                    !info.inputConfig.test(
+                                            WindowInfo::InputConfig::TRUSTED_OVERLAY),
+                            "%s has feature DO_NOT_PILFER, but is not a trusted overlay.",
+                            window->getName().c_str());
     }
 
     // Copy old handles for release if they are no longer present.
@@ -5613,14 +5638,16 @@ InputDispatcher::DispatcherTouchState::updateHoveringStateFromWindowInfo(
     std::list<CancellationArgs> cancellations;
     // Check if the hovering should stop because the window is no longer eligible to receive it
     // (for example, if the touchable region changed)
-    ui::Transform displayTransform = mWindowInfos.getDisplayTransform(displayId);
     for (TouchedWindow& touchedWindow : state.windows) {
+        const gui::WindowInfo& windowInfo = *touchedWindow.windowHandle->getInfo();
         std::vector<DeviceId> erasedDevices = touchedWindow.eraseHoveringPointersIf(
                 [&](const PointerProperties& properties, float x, float y) {
                     const bool isStylus = properties.toolType == ToolType::STYLUS;
+                    // The touchstate's displayId may be different from window's display on the
+                    // connected-displays, for this reason we use use window's displayId here.
                     const bool stillAcceptsTouch =
-                            windowAcceptsTouchAt(*touchedWindow.windowHandle->getInfo(), displayId,
-                                                 x, y, isStylus, displayTransform);
+                            mWindowInfos.windowAcceptsTouchAt(windowInfo, windowInfo.displayId, x,
+                                                              y, isStylus);
                     return !stillAcceptsTouch;
                 });
 
@@ -5724,15 +5751,6 @@ void InputDispatcher::setFocusedDisplay(ui::LogicalDisplayId displayId) {
             // Find new focused window and validate
             sp<IBinder> newFocusedWindowToken = mFocusResolver.getFocusedWindowToken(displayId);
             sendFocusChangedCommandLocked(oldFocusedWindowToken, newFocusedWindowToken);
-
-            if (newFocusedWindowToken == nullptr) {
-                ALOGW("Focused display #%s does not have a focused window.",
-                      displayId.toString().c_str());
-                if (mFocusResolver.hasFocusedWindowTokens()) {
-                    ALOGE("But another display has a focused window\n%s",
-                          mFocusResolver.dumpFocusedWindows().c_str());
-                }
-            }
         }
     } // release lock
 
@@ -5811,7 +5829,7 @@ bool InputDispatcher::setInTouchMode(bool inTouchMode, gui::Pid pid, gui::Uid ui
         }
         if (!hasPermission) {
             if (!focusedWindowIsOwnedByLocked(pid, uid) &&
-                !recentWindowsAreOwnedByLocked(pid, uid)) {
+                !recentWindowsAreOwnedByLocked(displayId, pid, uid)) {
                 ALOGD("Touch mode switch rejected, caller (pid=%s, uid=%s) doesn't own the focused "
                       "window nor none of the previously interacted window",
                       pid.toString().c_str(), uid.toString().c_str());
@@ -5839,13 +5857,19 @@ bool InputDispatcher::focusedWindowIsOwnedByLocked(gui::Pid pid, gui::Uid uid) {
     return isWindowOwnedBy(windowHandle, pid, uid);
 }
 
-bool InputDispatcher::recentWindowsAreOwnedByLocked(gui::Pid pid, gui::Uid uid) {
-    return std::find_if(mInteractionConnectionTokens.begin(), mInteractionConnectionTokens.end(),
+bool InputDispatcher::recentWindowsAreOwnedByLocked(ui::LogicalDisplayId displayId, gui::Pid pid,
+                                                    gui::Uid uid) {
+    const auto& it = mInteractionConnectionTokensByDisplay.find(displayId);
+    if (it == mInteractionConnectionTokensByDisplay.end()) {
+        return false;
+    }
+    const auto& interactionConnectionTokens = it->second;
+    return std::find_if(interactionConnectionTokens.begin(), interactionConnectionTokens.end(),
                         [&](const sp<IBinder>& connectionToken) REQUIRES(mLock) {
                             const sp<WindowInfoHandle> windowHandle =
                                     mWindowInfos.findWindowHandle(connectionToken);
                             return isWindowOwnedBy(windowHandle, pid, uid);
-                        }) != mInteractionConnectionTokens.end();
+                        }) != interactionConnectionTokens.end();
 }
 
 void InputDispatcher::setMaximumObscuringOpacityForTouch(float opacity) {
@@ -6131,6 +6155,13 @@ void InputDispatcher::dumpDispatchStateLocked(std::string& dump) const {
     const nsecs_t currentTime = now();
 
     dump += addLinePrefix(mConnectionManager.dump(currentTime), INDENT);
+    if (!mInputFilterVerifiersByDisplay.empty()) {
+        for (const auto& [displayId, verifier] : mInputFilterVerifiersByDisplay) {
+            dump += addLinePrefix(std::string("Verifier on ") + displayId.toString() + " : " +
+                                          verifier.dump(),
+                                  INDENT);
+        }
+    }
 
     // Dump recently dispatched or dropped events from oldest to newest.
     if (!mRecentQueue.empty()) {
@@ -6227,7 +6258,7 @@ Result<std::unique_ptr<InputChannel>> InputDispatcher::createInputChannel(const
     return clientChannel;
 }
 
-Result<std::unique_ptr<InputChannel>> InputDispatcher::createInputMonitor(
+Result<std::unique_ptr<InputChannel>> InputDispatcher::createFocusInputMonitor(
         ui::LogicalDisplayId displayId, const std::string& name, gui::Pid pid) {
     std::unique_ptr<InputChannel> serverChannel;
     std::unique_ptr<InputChannel> clientChannel;
@@ -6240,16 +6271,16 @@ Result<std::unique_ptr<InputChannel>> InputDispatcher::createInputMonitor(
         std::scoped_lock _l(mLock);
 
         if (displayId < ui::LogicalDisplayId::DEFAULT) {
-            return base::Error(BAD_VALUE) << "Attempted to create input monitor with name " << name
-                                          << " without a specified display.";
+            return base::Error(BAD_VALUE) << "Attempted to create focus input monitor with name "
+                                          << name << " without a specified display.";
         }
 
         const sp<IBinder>& token = serverChannel->getConnectionToken();
         std::function<int(int events)> callback = std::bind(&InputDispatcher::handleReceiveCallback,
                                                             this, std::placeholders::_1, token);
 
-        mConnectionManager.createGlobalInputMonitor(displayId, std::move(serverChannel),
-                                                    mIdGenerator, pid, callback);
+        mConnectionManager.createFocusInputMonitor(displayId, std::move(serverChannel),
+                                                   mIdGenerator, pid, callback);
     }
 
     // Wake the looper because some connections have changed.
@@ -6291,14 +6322,15 @@ status_t InputDispatcher::removeInputChannelLocked(const std::shared_ptr<Connect
 }
 
 void InputDispatcher::ConnectionManager::removeMonitorChannel(const sp<IBinder>& connectionToken) {
-    for (auto it = mGlobalMonitorsByDisplay.begin(); it != mGlobalMonitorsByDisplay.end();) {
+    for (auto it = mFocusInputMonitorsByDisplay.begin();
+         it != mFocusInputMonitorsByDisplay.end();) {
         auto& [displayId, monitors] = *it;
         std::erase_if(monitors, [connectionToken](const Monitor& monitor) {
             return monitor.connection->getToken() == connectionToken;
         });
 
         if (monitors.empty()) {
-            it = mGlobalMonitorsByDisplay.erase(it);
+            it = mFocusInputMonitorsByDisplay.erase(it);
         } else {
             ++it;
         }
@@ -6365,13 +6397,20 @@ InputDispatcher::DispatcherTouchState::pilferPointers(const sp<IBinder>& token,
         std::bitset<MAX_POINTER_ID + 1> pointerIds = getPointerIds(pointers);
         std::string canceledWindows;
         for (const TouchedWindow& w : state.windows) {
-            if (w.windowHandle->getToken() != token) {
-                cancellations.emplace_back(w.windowHandle,
-                                           CancelationOptions::Mode::CANCEL_POINTER_EVENTS,
-                                           deviceId, displayId, pointerIds);
-                canceledWindows += canceledWindows.empty() ? "[" : ", ";
-                canceledWindows += w.windowHandle->getName();
+            if (w.windowHandle->getToken() == token) {
+                // Skip cancelling from pilfering window.
+                continue;
+            }
+            if (w.windowHandle->getInfo()->inputConfig.test(
+                        WindowInfo::InputConfig::DO_NOT_PILFER)) {
+                // Skip cancelling from window with DO_NOT_PILFER flag.
+                continue;
             }
+            cancellations.emplace_back(w.windowHandle,
+                                       CancelationOptions::Mode::CANCEL_POINTER_EVENTS, deviceId,
+                                       displayId, pointerIds);
+            canceledWindows += canceledWindows.empty() ? "[" : ", ";
+            canceledWindows += w.windowHandle->getName();
         }
         canceledWindows += canceledWindows.empty() ? "[]" : "]";
         LOG(INFO) << "Channel " << requestingConnection.getInputChannelName()
@@ -6382,7 +6421,7 @@ InputDispatcher::DispatcherTouchState::pilferPointers(const sp<IBinder>& token,
         // This only blocks relevant pointers to be sent to other windows
         window.addPilferingPointers(deviceId, pointerIds);
 
-        state.cancelPointersForWindowsExcept(deviceId, pointerIds, token);
+        state.cancelPointersForPilferingRequest(deviceId, pointerIds, token);
     }
     return cancellations;
 }
@@ -6440,7 +6479,7 @@ void InputDispatcher::setDisplayEligibilityForPointerCapture(ui::LogicalDisplayI
 
 std::optional<gui::Pid> InputDispatcher::ConnectionManager::findMonitorPidByToken(
         const sp<IBinder>& token) const {
-    for (const auto& [_, monitors] : mGlobalMonitorsByDisplay) {
+    for (const auto& [_, monitors] : mFocusInputMonitorsByDisplay) {
         for (const Monitor& monitor : monitors) {
             if (monitor.connection->getToken() == token) {
                 return monitor.pid;
@@ -6632,8 +6671,10 @@ void InputDispatcher::updateLastAnrStateLocked(const std::string& windowLabel,
 }
 
 void InputDispatcher::doInterceptKeyBeforeDispatchingCommand(const sp<IBinder>& focusedWindowToken,
+                                                             const ui::LogicalDisplayId displayId,
                                                              const KeyEntry& entry) {
-    const KeyEvent event = createKeyEvent(entry);
+    KeyEvent event = createKeyEvent(entry);
+    event.setDisplayId(displayId);
     std::variant<nsecs_t, KeyEntry::InterceptKeyResult> interceptResult;
     nsecs_t delay = 0;
     { // release lock
@@ -7102,6 +7143,7 @@ void InputDispatcher::displayRemoved(ui::LogicalDisplayId displayId) {
         mTouchModePerDisplay.erase(displayId);
         mVerifiersByDisplay.erase(displayId);
         mInputFilterVerifiersByDisplay.erase(displayId);
+        mInteractionConnectionTokensByDisplay.erase(displayId);
     } // release lock
 
     // Wake up poll loop since it may need to make new input dispatching choices.
@@ -7342,27 +7384,27 @@ InputDispatcher::ConnectionManager::~ConnectionManager() {
     }
 }
 
-void InputDispatcher::ConnectionManager::forEachGlobalMonitorConnection(
+void InputDispatcher::ConnectionManager::forEachMonitorConnection(
         std::function<void(const std::shared_ptr<Connection>&)> f) const {
-    for (const auto& [_, monitors] : mGlobalMonitorsByDisplay) {
+    for (const auto& [_, monitors] : mFocusInputMonitorsByDisplay) {
         for (const Monitor& monitor : monitors) {
             f(monitor.connection);
         }
     }
 }
 
-void InputDispatcher::ConnectionManager::forEachGlobalMonitorConnection(
+void InputDispatcher::ConnectionManager::forEachMonitorConnection(
         ui::LogicalDisplayId displayId,
         std::function<void(const std::shared_ptr<Connection>&)> f) const {
-    auto monitorsIt = mGlobalMonitorsByDisplay.find(displayId);
-    if (monitorsIt == mGlobalMonitorsByDisplay.end()) return;
+    auto monitorsIt = mFocusInputMonitorsByDisplay.find(displayId);
+    if (monitorsIt == mFocusInputMonitorsByDisplay.end()) return;
 
     for (const Monitor& monitor : monitorsIt->second) {
         f(monitor.connection);
     }
 }
 
-void InputDispatcher::ConnectionManager::createGlobalInputMonitor(
+void InputDispatcher::ConnectionManager::createFocusInputMonitor(
         ui::LogicalDisplayId displayId, std::unique_ptr<InputChannel>&& inputChannel,
         const android::IdGenerator& idGenerator, gui::Pid pid, std::function<int(int)> callback) {
     const int fd = inputChannel->getFd();
@@ -7373,7 +7415,7 @@ void InputDispatcher::ConnectionManager::createGlobalInputMonitor(
     if (!inserted) {
         ALOGE("Created a new connection, but the token %p is already known", token.get());
     }
-    mGlobalMonitorsByDisplay[displayId].emplace_back(connection, pid);
+    mFocusInputMonitorsByDisplay[displayId].emplace_back(connection, pid);
 
     mLooper->addFd(fd, 0, ALOOPER_EVENT_INPUT, sp<LooperEventCallback>::make(callback), nullptr);
 }
@@ -7409,9 +7451,9 @@ status_t InputDispatcher::ConnectionManager::removeConnection(
 
 std::string InputDispatcher::ConnectionManager::dump(nsecs_t currentTime) const {
     std::string dump;
-    if (!mGlobalMonitorsByDisplay.empty()) {
-        for (const auto& [displayId, monitors] : mGlobalMonitorsByDisplay) {
-            dump += StringPrintf("Global monitors on display %s:\n", displayId.toString().c_str());
+    if (!mFocusInputMonitorsByDisplay.empty()) {
+        for (const auto& [displayId, monitors] : mFocusInputMonitorsByDisplay) {
+            dump += StringPrintf("Focus monitors on display %s:\n", displayId.toString().c_str());
             const size_t numMonitors = monitors.size();
             for (size_t i = 0; i < numMonitors; i++) {
                 const Monitor& monitor = monitors[i];
@@ -7422,7 +7464,7 @@ std::string InputDispatcher::ConnectionManager::dump(nsecs_t currentTime) const
             }
         }
     } else {
-        dump += "Global Monitors: <none>\n";
+        dump += "Focus Monitors: <none>\n";
     }
 
     if (!mConnectionsByToken.empty()) {
diff --git a/services/inputflinger/dispatcher/InputDispatcher.h b/services/inputflinger/dispatcher/InputDispatcher.h
index 2e8f2ce04e..9f00cb26fe 100644
--- a/services/inputflinger/dispatcher/InputDispatcher.h
+++ b/services/inputflinger/dispatcher/InputDispatcher.h
@@ -39,6 +39,7 @@
 #include "trace/InputTracingBackendInterface.h"
 
 #include <attestation/HmacKeyManager.h>
+#include <ftl/flags.h>
 #include <gui/InputApplication.h>
 #include <gui/WindowInfosUpdate.h>
 #include <input/Input.h>
@@ -87,10 +88,10 @@ class InputDispatcher : public android::InputDispatcherInterface {
 public:
     static constexpr bool kDefaultInTouchMode = true;
 
-    explicit InputDispatcher(InputDispatcherPolicyInterface& policy);
+    explicit InputDispatcher(InputDispatcherPolicyInterface& policy, JNIEnv* env);
     // Constructor used for testing.
     explicit InputDispatcher(InputDispatcherPolicyInterface&,
-                             std::unique_ptr<trace::InputTracingBackendInterface>);
+                             std::unique_ptr<trace::InputTracingBackendInterface>, JNIEnv* env);
     ~InputDispatcher() override;
 
     void dump(std::string& dump) const override;
@@ -134,9 +135,8 @@ public:
     base::Result<std::unique_ptr<InputChannel>> createInputChannel(
             const std::string& name) override;
     void setFocusedWindow(const android::gui::FocusRequest&) override;
-    base::Result<std::unique_ptr<InputChannel>> createInputMonitor(ui::LogicalDisplayId displayId,
-                                                                   const std::string& name,
-                                                                   gui::Pid pid) override;
+    base::Result<std::unique_ptr<InputChannel>> createFocusInputMonitor(
+            ui::LogicalDisplayId displayId, const std::string& name, gui::Pid pid) override;
     status_t removeInputChannel(const sp<IBinder>& connectionToken) override;
     status_t pilferPointers(const sp<IBinder>& token) override;
     void requestPointerCapture(const sp<IBinder>& windowToken, bool enabled) override;
@@ -176,6 +176,7 @@ private:
         NO_POINTER_CAPTURE,
     };
 
+    JNIEnv* mJniEnv;
     std::unique_ptr<InputThread> mThread;
 
     InputDispatcherPolicyInterface& mPolicy;
@@ -240,16 +241,16 @@ private:
 
         // Find a monitor pid by the provided token.
         std::optional<gui::Pid> findMonitorPidByToken(const sp<IBinder>& token) const;
-        void forEachGlobalMonitorConnection(
+        void forEachMonitorConnection(
                 std::function<void(const std::shared_ptr<Connection>&)> f) const;
-        void forEachGlobalMonitorConnection(
+        void forEachMonitorConnection(
                 ui::LogicalDisplayId displayId,
                 std::function<void(const std::shared_ptr<Connection>&)> f) const;
 
-        void createGlobalInputMonitor(ui::LogicalDisplayId displayId,
-                                      std::unique_ptr<InputChannel>&& inputChannel,
-                                      const IdGenerator& idGenerator, gui::Pid pid,
-                                      std::function<int(int)> callback);
+        void createFocusInputMonitor(ui::LogicalDisplayId displayId,
+                                     std::unique_ptr<InputChannel>&& inputChannel,
+                                     const IdGenerator& idGenerator, gui::Pid pid,
+                                     std::function<int(int)> callback);
 
         status_t removeConnection(const std::shared_ptr<Connection>& connection);
 
@@ -265,8 +266,9 @@ private:
         std::unordered_map<sp<IBinder>, std::shared_ptr<Connection>, StrongPointerHash<IBinder>>
                 mConnectionsByToken;
 
-        // Input channels that will receive a copy of all input events sent to the provided display.
-        std::unordered_map<ui::LogicalDisplayId, std::vector<Monitor>> mGlobalMonitorsByDisplay;
+        // Input channels that will receive a copy of all non-pointer input events sent to the
+        // focused window on the provided display.
+        std::unordered_map<ui::LogicalDisplayId, std::vector<Monitor>> mFocusInputMonitorsByDisplay;
 
         void removeMonitorChannel(const sp<IBinder>& connectionToken);
     };
@@ -342,6 +344,10 @@ private:
         sp<android::gui::WindowInfoHandle> findWallpaperWindowBelow(
                 const sp<android::gui::WindowInfoHandle>& windowHandle) const;
 
+        // Returns true if the given window can accept pointer events at the given display location.
+        bool windowAcceptsTouchAt(const gui::WindowInfo& windowInfo, ui::LogicalDisplayId displayId,
+                                  float x, float y, bool isStylus) const;
+
         bool isTouchTrusted(const TouchOcclusionInfo& occlusionInfo) const;
 
         // Returns topology's primary display if the display belongs to it, otherwise the
@@ -577,8 +583,8 @@ private:
     std::condition_variable mInjectionResultAvailable;
     bool shouldRejectInjectedMotionLocked(const MotionEvent& motion, DeviceId deviceId,
                                           ui::LogicalDisplayId displayId,
-                                          std::optional<gui::Uid> targetUid, int32_t flags)
-            REQUIRES(mLock);
+                                          std::optional<gui::Uid> targetUid,
+                                          ftl::Flags<MotionFlag> flags) REQUIRES(mLock);
     void setInjectionResult(const EventEntry& entry,
                             android::os::InputEventInjectionResult injectionResult);
     void transformMotionEntryForInjectionLocked(MotionEntry&,
@@ -705,8 +711,10 @@ private:
 
     // The connection tokens of the channels that the user last interacted (used for debugging and
     // when switching touch mode state).
-    std::unordered_set<sp<IBinder>, StrongPointerHash<IBinder>> mInteractionConnectionTokens
-            GUARDED_BY(mLock);
+    std::unordered_map<ui::LogicalDisplayId,
+                       std::unordered_set<sp<IBinder>, StrongPointerHash<IBinder>>>
+            mInteractionConnectionTokensByDisplay GUARDED_BY(mLock);
+
     void processInteractionsLocked(const EventEntry& entry, const std::vector<InputTarget>& targets)
             REQUIRES(mLock);
 
@@ -808,8 +816,8 @@ private:
                                ftl::Flags<InputTarget::Flags> targetFlags,
                                std::optional<nsecs_t> firstDownTimeInTarget,
                                std::vector<InputTarget>& inputTargets) const REQUIRES(mLock);
-    void addGlobalMonitoringTargetsLocked(std::vector<InputTarget>& inputTargets,
-                                          ui::LogicalDisplayId displayId) REQUIRES(mLock);
+    void addFocusInputMonitoringTargetsLocked(std::vector<InputTarget>& inputTargets,
+                                              ui::LogicalDisplayId displayId) REQUIRES(mLock);
     void pokeUserActivityLocked(const EventEntry& eventEntry) REQUIRES(mLock);
     // Enqueue a drag event if needed, and update the touch state.
     // Uses findTouchedWindowTargetsLocked to make the decision
@@ -898,6 +906,7 @@ private:
                                         const std::shared_ptr<Connection>& connection, uint32_t seq,
                                         bool handled, nsecs_t consumeTime) REQUIRES(mLock);
     void doInterceptKeyBeforeDispatchingCommand(const sp<IBinder>& focusedWindowToken,
+                                                const ui::LogicalDisplayId displayId,
                                                 const KeyEntry& entry) REQUIRES(mLock);
     void onFocusChangedLocked(const FocusResolver::FocusChanges& changes,
                               const std::unique_ptr<trace::EventTrackerInterface>& traceTracker,
@@ -934,7 +943,8 @@ private:
 
     // Check window ownership
     bool focusedWindowIsOwnedByLocked(gui::Pid pid, gui::Uid uid) REQUIRES(mLock);
-    bool recentWindowsAreOwnedByLocked(gui::Pid pid, gui::Uid uid) REQUIRES(mLock);
+    bool recentWindowsAreOwnedByLocked(ui::LogicalDisplayId displayId, gui::Pid pid, gui::Uid uid)
+            REQUIRES(mLock);
 
     sp<InputReporterInterface> mReporter;
 
diff --git a/services/inputflinger/dispatcher/InputDispatcherFactory.cpp b/services/inputflinger/dispatcher/InputDispatcherFactory.cpp
index 3ef8419221..06b6689fa2 100644
--- a/services/inputflinger/dispatcher/InputDispatcherFactory.cpp
+++ b/services/inputflinger/dispatcher/InputDispatcherFactory.cpp
@@ -20,8 +20,8 @@
 namespace android {
 
 std::unique_ptr<InputDispatcherInterface> createInputDispatcher(
-        InputDispatcherPolicyInterface& policy) {
-    return std::make_unique<android::inputdispatcher::InputDispatcher>(policy);
+        InputDispatcherPolicyInterface& policy, JNIEnv* env) {
+    return std::make_unique<android::inputdispatcher::InputDispatcher>(policy, env);
 }
 
 } // namespace android
diff --git a/services/inputflinger/dispatcher/InputState.cpp b/services/inputflinger/dispatcher/InputState.cpp
index 782a54f09e..363cffe9c6 100644
--- a/services/inputflinger/dispatcher/InputState.cpp
+++ b/services/inputflinger/dispatcher/InputState.cpp
@@ -91,7 +91,7 @@ bool InputState::trackKey(const KeyEntry& entry, int32_t flags) {
  *  true if the incoming event was correctly tracked,
  *  false if the incoming event should be dropped.
  */
-bool InputState::trackMotion(const MotionEntry& entry, int32_t flags) {
+bool InputState::trackMotion(const MotionEntry& entry, ftl::Flags<MotionFlag> flags) {
     // Don't track non-pointer events
     if (!isFromSource(entry.source, AINPUT_SOURCE_CLASS_POINTER)) {
         // This is a focus-dispatched event; we don't track its state.
@@ -252,7 +252,8 @@ void InputState::addKeyMemento(const KeyEntry& entry, int32_t flags) {
     mKeyMementos.push_back(memento);
 }
 
-void InputState::addMotionMemento(const MotionEntry& entry, int32_t flags, bool hovering) {
+void InputState::addMotionMemento(const MotionEntry& entry, ftl::Flags<MotionFlag> flags,
+                                  bool hovering) {
     MotionMemento memento;
     memento.deviceId = entry.deviceId;
     memento.source = entry.source;
@@ -404,9 +405,9 @@ std::unique_ptr<MotionEntry> InputState::createCancelEntryForMemento(const Motio
                                                                      nsecs_t eventTime) const {
     const int32_t action =
             memento.hovering ? AMOTION_EVENT_ACTION_HOVER_EXIT : AMOTION_EVENT_ACTION_CANCEL;
-    int32_t flags = memento.flags;
+    ftl::Flags<MotionFlag> flags = memento.flags;
     if (action == AMOTION_EVENT_ACTION_CANCEL) {
-        flags |= AMOTION_EVENT_FLAG_CANCELED;
+        flags |= MotionFlag::CANCELED;
     }
     return std::make_unique<MotionEntry>(mIdGenerator.nextId(), /*injectionState=*/nullptr,
                                          eventTime, memento.deviceId, memento.source,
@@ -545,9 +546,8 @@ std::vector<std::unique_ptr<MotionEntry>> InputState::synthesizeCancelationEvent
                                               currentTime, memento.deviceId, memento.source,
                                               memento.displayId, memento.policyFlags, action,
                                               /*actionButton=*/0,
-                                              memento.flags | AMOTION_EVENT_FLAG_CANCELED,
-                                              AMETA_NONE, /*buttonState=*/0,
-                                              MotionClassification::NONE,
+                                              memento.flags | MotionFlag::CANCELED, AMETA_NONE,
+                                              /*buttonState=*/0, MotionClassification::NONE,
                                               AMOTION_EVENT_EDGE_FLAG_NONE, memento.xPrecision,
                                               memento.yPrecision, memento.xCursorPosition,
                                               memento.yCursorPosition, memento.downTime,
@@ -661,7 +661,7 @@ std::ostream& operator<<(std::ostream& out, const InputState& state) {
         for (const InputState::MotionMemento& memento : state.mMotionMementos) {
             out << "{deviceId=" << memento.deviceId
                 << ", hovering=" << std::to_string(memento.hovering)
-                << ", downTime=" << memento.downTime << "}, ";
+                << ", downTime=" << memento.downTime << "ns}, ";
         }
     }
     return out;
diff --git a/services/inputflinger/dispatcher/InputState.h b/services/inputflinger/dispatcher/InputState.h
index 2808ba71bd..6215c5ae90 100644
--- a/services/inputflinger/dispatcher/InputState.h
+++ b/services/inputflinger/dispatcher/InputState.h
@@ -19,6 +19,7 @@
 #include "CancelationOptions.h"
 #include "Entry.h"
 
+#include <ftl/flags.h>
 #include <utils/Timers.h>
 #include <bitset>
 
@@ -46,7 +47,7 @@ public:
     // Records tracking information for a motion event that has just been published.
     // Returns true if the event should be delivered, false if it is inconsistent
     // and should be skipped.
-    bool trackMotion(const MotionEntry& entry, int32_t flags);
+    bool trackMotion(const MotionEntry& entry, ftl::Flags<MotionFlag> flags);
 
     /**
      * Return the PointerProperties and the PointerCoords for the last event, if found. Return
@@ -103,7 +104,7 @@ private:
         DeviceId deviceId;
         uint32_t source;
         ui::LogicalDisplayId displayId{ui::LogicalDisplayId::INVALID};
-        int32_t flags;
+        ftl::Flags<MotionFlag> flags;
         float xPrecision;
         float yPrecision;
         float xCursorPosition;
@@ -131,7 +132,7 @@ private:
     ssize_t findMotionMemento(const MotionEntry& entry, bool hovering) const;
 
     void addKeyMemento(const KeyEntry& entry, int32_t flags);
-    void addMotionMemento(const MotionEntry& entry, int32_t flags, bool hovering);
+    void addMotionMemento(const MotionEntry& entry, ftl::Flags<MotionFlag> flags, bool hovering);
 
     static bool shouldCancelKey(const KeyMemento& memento, const CancelationOptions& options);
     static bool shouldCancelMotion(const MotionMemento& memento, const CancelationOptions& options);
diff --git a/services/inputflinger/dispatcher/LatencyAggregator.cpp b/services/inputflinger/dispatcher/LatencyAggregator.cpp
index d0e9d7c983..b7b00d1fd1 100644
--- a/services/inputflinger/dispatcher/LatencyAggregator.cpp
+++ b/services/inputflinger/dispatcher/LatencyAggregator.cpp
@@ -81,8 +81,8 @@ static std::chrono::milliseconds getSlowEventMinReportingInterval() {
 namespace android::inputdispatcher {
 
 /**
- * Same as android::util::BytesField, but doesn't store raw pointers, and therefore deletes its
- * resources automatically.
+ * Same as android::inputflinger::stats::BytesField, but doesn't store raw pointers, and therefore
+ * deletes its resources automatically.
  */
 class SafeBytesField {
 public:
@@ -91,8 +91,8 @@ public:
         mBuffer.resize(aggProto.ByteSizeLong());
         aggProto.SerializeToArray(mBuffer.data(), mBuffer.size());
     }
-    android::util::BytesField getBytesField() {
-        return android::util::BytesField(mBuffer.data(), mBuffer.size());
+    android::inputflinger::stats::BytesField getBytesField() {
+        return android::inputflinger::stats::BytesField(mBuffer.data(), mBuffer.size());
     }
 
 private:
@@ -100,8 +100,8 @@ private:
 };
 
 LatencyAggregator::LatencyAggregator() {
-    AStatsManager_setPullAtomCallback(android::util::INPUT_EVENT_LATENCY_SKETCH, nullptr,
-                                      LatencyAggregator::pullAtomCallback, this);
+    AStatsManager_setPullAtomCallback(android::inputflinger::stats::INPUT_EVENT_LATENCY_SKETCH,
+                                      nullptr, LatencyAggregator::pullAtomCallback, this);
     dist_proc::aggregation::KllQuantileOptions options;
     options.set_inv_eps(100); // Request precision of 1.0%, instead of default 0.1%
     for (size_t i = 0; i < SketchIndex::SIZE; i++) {
@@ -111,7 +111,7 @@ LatencyAggregator::LatencyAggregator() {
 }
 
 LatencyAggregator::~LatencyAggregator() {
-    AStatsManager_clearPullAtomCallback(android::util::INPUT_EVENT_LATENCY_SKETCH);
+    AStatsManager_clearPullAtomCallback(android::inputflinger::stats::INPUT_EVENT_LATENCY_SKETCH);
 }
 
 AStatsManager_PullAtomCallbackReturn LatencyAggregator::pullAtomCallback(int32_t atomTag,
@@ -184,8 +184,8 @@ AStatsManager_PullAtomCallbackReturn LatencyAggregator::pullData(AStatsEventList
         serializedDownData[i] = std::make_unique<SafeBytesField>(*mDownSketches[i]);
         serializedMoveData[i] = std::make_unique<SafeBytesField>(*mMoveSketches[i]);
     }
-    android::util::
-            addAStatsEvent(data, android::util::INPUT_EVENT_LATENCY_SKETCH,
+    android::inputflinger::stats::
+            addAStatsEvent(data, android::inputflinger::stats::INPUT_EVENT_LATENCY_SKETCH,
                            // DOWN sketches
                            serializedDownData[SketchIndex::EVENT_TO_READ]->getBytesField(),
                            serializedDownData[SketchIndex::READ_TO_DELIVER]->getBytesField(),
@@ -251,18 +251,19 @@ void LatencyAggregator::processSlowEvent(const InputEventTimeline& timeline) {
         const nsecs_t consumeToGpuComplete = gpuCompletedTime - connectionTimeline.consumeTime;
         const nsecs_t gpuCompleteToPresent = presentTime - gpuCompletedTime;
 
-        android::util::stats_write(android::util::SLOW_INPUT_EVENT_REPORTED,
-                                   timeline.inputEventActionType ==
-                                           InputEventActionType::MOTION_ACTION_DOWN,
-                                   static_cast<int32_t>(ns2us(eventToRead)),
-                                   static_cast<int32_t>(ns2us(readToDeliver)),
-                                   static_cast<int32_t>(ns2us(deliverToConsume)),
-                                   static_cast<int32_t>(ns2us(consumeToFinish)),
-                                   static_cast<int32_t>(ns2us(consumeToGpuComplete)),
-                                   static_cast<int32_t>(ns2us(gpuCompleteToPresent)),
-                                   static_cast<int32_t>(ns2us(endToEndLatency.count())),
-                                   static_cast<int32_t>(mNumEventsSinceLastSlowEventReport),
-                                   static_cast<int32_t>(mNumSkippedSlowEvents));
+        android::inputflinger::stats::
+                stats_write(android::inputflinger::stats::SLOW_INPUT_EVENT_REPORTED,
+                            timeline.inputEventActionType ==
+                                    InputEventActionType::MOTION_ACTION_DOWN,
+                            static_cast<int32_t>(ns2us(eventToRead)),
+                            static_cast<int32_t>(ns2us(readToDeliver)),
+                            static_cast<int32_t>(ns2us(deliverToConsume)),
+                            static_cast<int32_t>(ns2us(consumeToFinish)),
+                            static_cast<int32_t>(ns2us(consumeToGpuComplete)),
+                            static_cast<int32_t>(ns2us(gpuCompleteToPresent)),
+                            static_cast<int32_t>(ns2us(endToEndLatency.count())),
+                            static_cast<int32_t>(mNumEventsSinceLastSlowEventReport),
+                            static_cast<int32_t>(mNumSkippedSlowEvents));
         mNumEventsSinceLastSlowEventReport = 0;
         mNumSkippedSlowEvents = 0;
         mLastSlowEventTime = timeline.readTime;
@@ -287,7 +288,7 @@ std::string LatencyAggregator::dump(const char* prefix) const {
 
     return StringPrintf("%sLatencyAggregator:\n", prefix) + sketchDump +
             StringPrintf("%s  mNumSketchEventsProcessed=%zu\n", prefix, mNumSketchEventsProcessed) +
-            StringPrintf("%s  mLastSlowEventTime=%" PRId64 "\n", prefix, mLastSlowEventTime) +
+            StringPrintf("%s  mLastSlowEventTime=%" PRId64 "ns\n", prefix, mLastSlowEventTime) +
             StringPrintf("%s  mNumEventsSinceLastSlowEventReport = %zu\n", prefix,
                          mNumEventsSinceLastSlowEventReport) +
             StringPrintf("%s  mNumSkippedSlowEvents = %zu\n", prefix, mNumSkippedSlowEvents);
diff --git a/services/inputflinger/dispatcher/LatencyAggregator.h b/services/inputflinger/dispatcher/LatencyAggregator.h
index 468add1435..12ead4f110 100644
--- a/services/inputflinger/dispatcher/LatencyAggregator.h
+++ b/services/inputflinger/dispatcher/LatencyAggregator.h
@@ -18,7 +18,7 @@
 
 #include <android-base/thread_annotations.h>
 #include <kll.h>
-#include <statslog.h>
+#include <statslog_inputflinger.h>
 #include <utils/Timers.h>
 
 #include "InputEventTimeline.h"
diff --git a/services/inputflinger/dispatcher/LatencyAggregatorWithHistograms.cpp b/services/inputflinger/dispatcher/LatencyAggregatorWithHistograms.cpp
index 4da05c19cf..558c89e789 100644
--- a/services/inputflinger/dispatcher/LatencyAggregatorWithHistograms.cpp
+++ b/services/inputflinger/dispatcher/LatencyAggregatorWithHistograms.cpp
@@ -20,7 +20,7 @@
 
 #include <inttypes.h>
 #include <log/log_event_list.h>
-#include <statslog.h>
+#include <statslog_inputflinger.h>
 
 #include <android-base/logging.h>
 #include <android-base/stringprintf.h>
@@ -78,40 +78,52 @@ namespace android::inputdispatcher {
 int32_t LatencyStageIndexToAtomEnum(LatencyStageIndex latencyStageIndex) {
     switch (latencyStageIndex) {
         case LatencyStageIndex::EVENT_TO_READ:
-            return util::INPUT_EVENT_LATENCY_REPORTED__LATENCY_STAGE__EVENT_TO_READ;
+            return inputflinger::stats::INPUT_EVENT_LATENCY_REPORTED__LATENCY_STAGE__EVENT_TO_READ;
         case LatencyStageIndex::READ_TO_DELIVER:
-            return util::INPUT_EVENT_LATENCY_REPORTED__LATENCY_STAGE__READ_TO_DELIVER;
+            return inputflinger::stats::
+                    INPUT_EVENT_LATENCY_REPORTED__LATENCY_STAGE__READ_TO_DELIVER;
         case LatencyStageIndex::DELIVER_TO_CONSUME:
-            return util::INPUT_EVENT_LATENCY_REPORTED__LATENCY_STAGE__DELIVER_TO_CONSUME;
+            return inputflinger::stats::
+                    INPUT_EVENT_LATENCY_REPORTED__LATENCY_STAGE__DELIVER_TO_CONSUME;
         case LatencyStageIndex::CONSUME_TO_FINISH:
-            return util::INPUT_EVENT_LATENCY_REPORTED__LATENCY_STAGE__CONSUME_TO_FINISH;
+            return inputflinger::stats::
+                    INPUT_EVENT_LATENCY_REPORTED__LATENCY_STAGE__CONSUME_TO_FINISH;
         case LatencyStageIndex::CONSUME_TO_GPU_COMPLETE:
-            return util::INPUT_EVENT_LATENCY_REPORTED__LATENCY_STAGE__CONSUME_TO_GPU_COMPLETE;
+            return inputflinger::stats::
+                    INPUT_EVENT_LATENCY_REPORTED__LATENCY_STAGE__CONSUME_TO_GPU_COMPLETE;
         case LatencyStageIndex::GPU_COMPLETE_TO_PRESENT:
-            return util::INPUT_EVENT_LATENCY_REPORTED__LATENCY_STAGE__GPU_COMPLETE_TO_PRESENT;
+            return inputflinger::stats::
+                    INPUT_EVENT_LATENCY_REPORTED__LATENCY_STAGE__GPU_COMPLETE_TO_PRESENT;
         case LatencyStageIndex::END_TO_END:
-            return util::INPUT_EVENT_LATENCY_REPORTED__LATENCY_STAGE__END_TO_END;
+            return inputflinger::stats::INPUT_EVENT_LATENCY_REPORTED__LATENCY_STAGE__END_TO_END;
         default:
-            return util::INPUT_EVENT_LATENCY_REPORTED__LATENCY_STAGE__UNKNOWN_LATENCY_STAGE;
+            return inputflinger::stats::
+                    INPUT_EVENT_LATENCY_REPORTED__LATENCY_STAGE__UNKNOWN_LATENCY_STAGE;
     }
 }
 
 int32_t InputEventTypeEnumToAtomEnum(InputEventActionType inputEventActionType) {
     switch (inputEventActionType) {
         case InputEventActionType::UNKNOWN_INPUT_EVENT:
-            return util::INPUT_EVENT_LATENCY_REPORTED__INPUT_EVENT_TYPE__UNKNOWN_INPUT_EVENT;
+            return inputflinger::stats::
+                    INPUT_EVENT_LATENCY_REPORTED__INPUT_EVENT_TYPE__UNKNOWN_INPUT_EVENT;
         case InputEventActionType::MOTION_ACTION_DOWN:
-            return util::INPUT_EVENT_LATENCY_REPORTED__INPUT_EVENT_TYPE__MOTION_ACTION_DOWN;
+            return inputflinger::stats::
+                    INPUT_EVENT_LATENCY_REPORTED__INPUT_EVENT_TYPE__MOTION_ACTION_DOWN;
         case InputEventActionType::MOTION_ACTION_MOVE:
-            return util::INPUT_EVENT_LATENCY_REPORTED__INPUT_EVENT_TYPE__MOTION_ACTION_MOVE;
+            return inputflinger::stats::
+                    INPUT_EVENT_LATENCY_REPORTED__INPUT_EVENT_TYPE__MOTION_ACTION_MOVE;
         case InputEventActionType::MOTION_ACTION_UP:
-            return util::INPUT_EVENT_LATENCY_REPORTED__INPUT_EVENT_TYPE__MOTION_ACTION_UP;
+            return inputflinger::stats::
+                    INPUT_EVENT_LATENCY_REPORTED__INPUT_EVENT_TYPE__MOTION_ACTION_UP;
         case InputEventActionType::MOTION_ACTION_HOVER_MOVE:
-            return util::INPUT_EVENT_LATENCY_REPORTED__INPUT_EVENT_TYPE__MOTION_ACTION_HOVER_MOVE;
+            return inputflinger::stats::
+                    INPUT_EVENT_LATENCY_REPORTED__INPUT_EVENT_TYPE__MOTION_ACTION_HOVER_MOVE;
         case InputEventActionType::MOTION_ACTION_SCROLL:
-            return util::INPUT_EVENT_LATENCY_REPORTED__INPUT_EVENT_TYPE__MOTION_ACTION_SCROLL;
+            return inputflinger::stats::
+                    INPUT_EVENT_LATENCY_REPORTED__INPUT_EVENT_TYPE__MOTION_ACTION_SCROLL;
         case InputEventActionType::KEY:
-            return util::INPUT_EVENT_LATENCY_REPORTED__INPUT_EVENT_TYPE__KEY;
+            return inputflinger::stats::INPUT_EVENT_LATENCY_REPORTED__INPUT_EVENT_TYPE__KEY;
     }
 }
 
@@ -237,8 +249,8 @@ void LatencyAggregatorWithHistograms::pushLatencyStatistics() {
                 continue;
             }
 
-            stats_write(android::util::INPUT_EVENT_LATENCY_REPORTED, vendorId, productId,
-                        sourcesVector, InputEventTypeEnumToAtomEnum(action),
+            stats_write(android::inputflinger::stats::INPUT_EVENT_LATENCY_REPORTED, vendorId,
+                        productId, sourcesVector, InputEventTypeEnumToAtomEnum(action),
                         LatencyStageIndexToAtomEnum(
                                 static_cast<LatencyStageIndex>(latencyStageIndex)),
                         histogramVersions[latencyStageIndex][actionIndex], binCountsVector);
@@ -284,18 +296,19 @@ void LatencyAggregatorWithHistograms::processSlowEvent(const InputEventTimeline&
         const nsecs_t consumeToGpuComplete = gpuCompletedTime - connectionTimeline.consumeTime;
         const nsecs_t gpuCompleteToPresent = presentTime - gpuCompletedTime;
 
-        android::util::stats_write(android::util::SLOW_INPUT_EVENT_REPORTED,
-                                   timeline.inputEventActionType ==
-                                           InputEventActionType::MOTION_ACTION_DOWN,
-                                   static_cast<int32_t>(ns2us(eventToRead)),
-                                   static_cast<int32_t>(ns2us(readToDeliver)),
-                                   static_cast<int32_t>(ns2us(deliverToConsume)),
-                                   static_cast<int32_t>(ns2us(consumeToFinish)),
-                                   static_cast<int32_t>(ns2us(consumeToGpuComplete)),
-                                   static_cast<int32_t>(ns2us(gpuCompleteToPresent)),
-                                   static_cast<int32_t>(ns2us(endToEndLatency.count())),
-                                   static_cast<int32_t>(mNumEventsSinceLastSlowEventReport),
-                                   static_cast<int32_t>(mNumSkippedSlowEvents));
+        android::inputflinger::stats::
+                stats_write(android::inputflinger::stats::SLOW_INPUT_EVENT_REPORTED,
+                            timeline.inputEventActionType ==
+                                    InputEventActionType::MOTION_ACTION_DOWN,
+                            static_cast<int32_t>(ns2us(eventToRead)),
+                            static_cast<int32_t>(ns2us(readToDeliver)),
+                            static_cast<int32_t>(ns2us(deliverToConsume)),
+                            static_cast<int32_t>(ns2us(consumeToFinish)),
+                            static_cast<int32_t>(ns2us(consumeToGpuComplete)),
+                            static_cast<int32_t>(ns2us(gpuCompleteToPresent)),
+                            static_cast<int32_t>(ns2us(endToEndLatency.count())),
+                            static_cast<int32_t>(mNumEventsSinceLastSlowEventReport),
+                            static_cast<int32_t>(mNumSkippedSlowEvents));
         mNumEventsSinceLastSlowEventReport = 0;
         mNumSkippedSlowEvents = 0;
         mLastSlowEventTime = timeline.readTime;
@@ -337,7 +350,7 @@ std::string LatencyAggregatorWithHistograms::dump(const char* prefix) const {
     }
 
     return StringPrintf("%sLatencyAggregatorWithHistograms:\n", prefix) + statisticsStr +
-            StringPrintf("%s  mLastSlowEventTime=%" PRId64 "\n", prefix, mLastSlowEventTime) +
+            StringPrintf("%s  mLastSlowEventTime=%" PRId64 "ns\n", prefix, mLastSlowEventTime) +
             StringPrintf("%s  mNumEventsSinceLastSlowEventReport = %zu\n", prefix,
                          mNumEventsSinceLastSlowEventReport) +
             StringPrintf("%s  mNumSkippedSlowEvents = %zu\n", prefix, mNumSkippedSlowEvents);
diff --git a/services/inputflinger/dispatcher/TouchState.cpp b/services/inputflinger/dispatcher/TouchState.cpp
index f1fca0c317..af720cc4c8 100644
--- a/services/inputflinger/dispatcher/TouchState.cpp
+++ b/services/inputflinger/dispatcher/TouchState.cpp
@@ -138,11 +138,13 @@ void TouchState::removeWindowByToken(const sp<IBinder>& token) {
     }
 }
 
-void TouchState::cancelPointersForWindowsExcept(DeviceId deviceId,
-                                                std::bitset<MAX_POINTER_ID + 1> pointerIds,
-                                                const sp<IBinder>& token) {
+void TouchState::cancelPointersForPilferingRequest(DeviceId deviceId,
+                                                   std::bitset<MAX_POINTER_ID + 1> pointerIds,
+                                                   const sp<IBinder>& token) {
     std::for_each(windows.begin(), windows.end(), [&](TouchedWindow& w) {
-        if (w.windowHandle->getToken() != token) {
+        if (w.windowHandle->getToken() != token &&
+            !w.windowHandle->getInfo()->inputConfig.test(
+                    gui::WindowInfo::InputConfig::DO_NOT_PILFER)) {
             w.removeTouchingPointers(deviceId, pointerIds);
         }
     });
@@ -174,6 +176,10 @@ void TouchState::cancelPointersForNonPilferingWindows() {
     // limitation here.
     for (const auto& [deviceId, allPilferedPointerIds] : allPilferedPointerIdsByDevice) {
         std::for_each(windows.begin(), windows.end(), [&](TouchedWindow& w) {
+            if (w.windowHandle->getInfo()->inputConfig.test(
+                        gui::WindowInfo::InputConfig::DO_NOT_PILFER)) {
+                return;
+            }
             std::bitset<MAX_POINTER_ID + 1> pilferedByOtherWindows =
                     w.getPilferingPointers(deviceId) ^ allPilferedPointerIds;
             // Remove all pointers pilfered by other windows
diff --git a/services/inputflinger/dispatcher/TouchState.h b/services/inputflinger/dispatcher/TouchState.h
index 20155f4396..80a54f0d61 100644
--- a/services/inputflinger/dispatcher/TouchState.h
+++ b/services/inputflinger/dispatcher/TouchState.h
@@ -57,10 +57,10 @@ struct TouchState {
     void removeAllPointersForDevice(DeviceId deviceId);
     void removeWindowByToken(const sp<IBinder>& token);
 
-    // Cancel pointers for current set of windows except the window with particular binder token.
-    void cancelPointersForWindowsExcept(DeviceId deviceId,
-                                        std::bitset<MAX_POINTER_ID + 1> pointerIds,
-                                        const sp<IBinder>& token);
+    // Cancel pointers for current set of windows for a pilfering request.
+    void cancelPointersForPilferingRequest(DeviceId deviceId,
+                                           std::bitset<MAX_POINTER_ID + 1> pointerIds,
+                                           const sp<IBinder>& token);
     // Cancel pointers for current set of non-pilfering windows i.e. windows with isPilferingWindow
     // set to false.
     void cancelPointersForNonPilferingWindows();
diff --git a/services/inputflinger/dispatcher/include/InputDispatcherFactory.h b/services/inputflinger/dispatcher/include/InputDispatcherFactory.h
index 6b298c2dac..1761ae8d74 100644
--- a/services/inputflinger/dispatcher/include/InputDispatcherFactory.h
+++ b/services/inputflinger/dispatcher/include/InputDispatcherFactory.h
@@ -25,6 +25,6 @@ namespace android {
 
 // This factory method is used to encapsulate implementation details in internal header files.
 std::unique_ptr<InputDispatcherInterface> createInputDispatcher(
-        InputDispatcherPolicyInterface& policy);
+        InputDispatcherPolicyInterface& policy, JNIEnv* env);
 
 } // namespace android
diff --git a/services/inputflinger/dispatcher/include/InputDispatcherInterface.h b/services/inputflinger/dispatcher/include/InputDispatcherInterface.h
index b22ddca4e6..e139457971 100644
--- a/services/inputflinger/dispatcher/include/InputDispatcherInterface.h
+++ b/services/inputflinger/dispatcher/include/InputDispatcherInterface.h
@@ -174,14 +174,15 @@ public:
             const std::string& name) = 0;
 
     /**
-     * Creates an input channel to be used to monitor all input events on a display.
+     * Creates an input channel to be used to monitor all non-pointer input events going to focused
+     * windows on a display.
      *
      * Each monitor must target a specific display and will only receive input events sent to that
      * display.
      *
      * This method may be called on any thread (usually by the input manager).
      */
-    virtual base::Result<std::unique_ptr<InputChannel>> createInputMonitor(
+    virtual base::Result<std::unique_ptr<InputChannel>> createFocusInputMonitor(
             ui::LogicalDisplayId displayId, const std::string& name, gui::Pid pid) = 0;
 
     /* Removes input channels that will no longer receive input events.
diff --git a/services/inputflinger/dispatcher/trace/AndroidInputEventProtoConverter.h b/services/inputflinger/dispatcher/trace/AndroidInputEventProtoConverter.h
index c19d278370..4fae5fce17 100644
--- a/services/inputflinger/dispatcher/trace/AndroidInputEventProtoConverter.h
+++ b/services/inputflinger/dispatcher/trace/AndroidInputEventProtoConverter.h
@@ -73,7 +73,7 @@ public:
         outProto.set_device_id(event.deviceId);
         outProto.set_display_id(event.displayId.val());
         outProto.set_classification(static_cast<int32_t>(event.classification));
-        outProto.set_flags(event.flags);
+        outProto.set_flags(event.flags.get());
         outProto.set_policy_flags(event.policyFlags);
         outProto.set_button_state(event.buttonState);
         outProto.set_action_button(event.actionButton);
@@ -137,7 +137,7 @@ public:
         std::visit([&](auto entry) { outProto.set_event_id(entry.id); }, args.eventEntry);
         outProto.set_vsync_id(args.vsyncId);
         outProto.set_window_id(args.windowId);
-        outProto.set_resolved_flags(args.resolvedFlags);
+        outProto.set_resolved_flags(args.resolvedMotionFlags.get());
 
         if (isRedacted) {
             return;
diff --git a/services/inputflinger/dispatcher/trace/InputTracer.cpp b/services/inputflinger/dispatcher/trace/InputTracer.cpp
index 5d2b8541d1..0693f620a5 100644
--- a/services/inputflinger/dispatcher/trace/InputTracer.cpp
+++ b/services/inputflinger/dispatcher/trace/InputTracer.cpp
@@ -217,7 +217,7 @@ void InputTracer::traceEventDispatch(const DispatchEntry& dispatchEntry,
     // TODO(b/210460522): Pass HMAC into traceEventDispatch.
     const WindowDispatchArgs windowDispatchArgs{*tracedEventIt,
                                                 dispatchEntry.deliveryTime,
-                                                dispatchEntry.resolvedFlags,
+                                                dispatchEntry.resolvedMotionFlags,
                                                 dispatchEntry.targetUid,
                                                 vsyncId,
                                                 windowId,
diff --git a/services/inputflinger/dispatcher/trace/InputTracingBackendInterface.h b/services/inputflinger/dispatcher/trace/InputTracingBackendInterface.h
index 2ff6e1c84d..d025d0b725 100644
--- a/services/inputflinger/dispatcher/trace/InputTracingBackendInterface.h
+++ b/services/inputflinger/dispatcher/trace/InputTracingBackendInterface.h
@@ -16,6 +16,7 @@
 
 #pragma once
 
+#include <ftl/flags.h>
 #include <gui/PidUid.h>
 #include <input/Input.h>
 #include <ui/Transform.h>
@@ -73,7 +74,7 @@ struct TracedMotionEvent {
     ui::LogicalDisplayId displayId = ui::LogicalDisplayId::INVALID;
     int32_t action;
     int32_t actionButton;
-    int32_t flags;
+    ftl::Flags<MotionFlag> flags;
     int32_t metaState;
     int32_t buttonState;
     MotionClassification classification;
@@ -107,7 +108,7 @@ struct TracedEventMetadata {
 struct WindowDispatchArgs {
     TracedEvent eventEntry;
     nsecs_t deliveryTime;
-    int32_t resolvedFlags;
+    ftl::Flags<MotionFlag> resolvedMotionFlags;
     gui::Uid targetUid = gui::Uid::INVALID;
     int64_t vsyncId;
     int32_t windowId;
diff --git a/services/inputflinger/dispatcher/trace/ThreadedBackend.cpp b/services/inputflinger/dispatcher/trace/ThreadedBackend.cpp
index 4f61885162..88101aa808 100644
--- a/services/inputflinger/dispatcher/trace/ThreadedBackend.cpp
+++ b/services/inputflinger/dispatcher/trace/ThreadedBackend.cpp
@@ -37,11 +37,11 @@ struct Visitor : V... {
 // --- ThreadedBackend ---
 
 template <typename Backend>
-ThreadedBackend<Backend>::ThreadedBackend(Backend&& innerBackend)
+ThreadedBackend<Backend>::ThreadedBackend(Backend&& innerBackend, JNIEnv* env)
       : mBackend(std::move(innerBackend)),
         mTracerThread(
                 "InputTracer", [this]() { threadLoop(); },
-                [this]() { mThreadWakeCondition.notify_all(); }, /*isInCriticalPath=*/false) {}
+                [this]() { mThreadWakeCondition.notify_all(); }, /*isInCriticalPath=*/false, env) {}
 
 template <typename Backend>
 ThreadedBackend<Backend>::~ThreadedBackend() {
diff --git a/services/inputflinger/dispatcher/trace/ThreadedBackend.h b/services/inputflinger/dispatcher/trace/ThreadedBackend.h
index 52a84c470c..9b74a91ed3 100644
--- a/services/inputflinger/dispatcher/trace/ThreadedBackend.h
+++ b/services/inputflinger/dispatcher/trace/ThreadedBackend.h
@@ -35,7 +35,7 @@ namespace android::inputdispatcher::trace::impl {
 template <typename Backend>
 class ThreadedBackend : public InputTracingBackendInterface {
 public:
-    ThreadedBackend(Backend&& innerBackend);
+    ThreadedBackend(Backend&& innerBackend, JNIEnv* env);
     ~ThreadedBackend() override;
 
     void traceKeyEvent(const TracedKeyEvent&, const TracedEventMetadata&) override;
diff --git a/services/inputflinger/include/InputReaderFactory.h b/services/inputflinger/include/InputReaderFactory.h
index dad14d6c92..b94c247d34 100644
--- a/services/inputflinger/include/InputReaderFactory.h
+++ b/services/inputflinger/include/InputReaderFactory.h
@@ -15,6 +15,7 @@
  */
 
 #include <utils/StrongPointer.h>
+#include "jni.h"
 
 namespace android {
 
@@ -23,6 +24,7 @@ class InputReaderPolicyInterface;
 class InputListenerInterface;
 
 std::unique_ptr<InputReaderInterface> createInputReader(
-        const sp<InputReaderPolicyInterface>& policy, InputListenerInterface& listener);
+        const sp<InputReaderPolicyInterface>& policy, InputListenerInterface& listener,
+        JNIEnv* env);
 
 } // namespace android
diff --git a/services/inputflinger/include/InputThread.h b/services/inputflinger/include/InputThread.h
index ed92b8f949..0d1554ff42 100644
--- a/services/inputflinger/include/InputThread.h
+++ b/services/inputflinger/include/InputThread.h
@@ -16,7 +16,9 @@
 
 #pragma once
 
-#include <utils/Thread.h>
+#include <functional>
+#include <thread>
+#include "jni.h"
 
 namespace android {
 
@@ -29,14 +31,15 @@ namespace android {
 class InputThread {
 public:
     explicit InputThread(std::string name, std::function<void()> loop, std::function<void()> wake,
-                         bool isInCriticalPath);
+                         bool isInCriticalPath, JNIEnv* env);
     virtual ~InputThread();
 
     bool isCallingThread();
 
 private:
     std::function<void()> mThreadWake;
-    sp<Thread> mThread;
+    std::thread mThread;
+    std::atomic_bool mStopThread = false;
 };
 
 } // namespace android
diff --git a/services/inputflinger/include/NotifyArgs.h b/services/inputflinger/include/NotifyArgs.h
index c513bfcf50..0eecb6dd53 100644
--- a/services/inputflinger/include/NotifyArgs.h
+++ b/services/inputflinger/include/NotifyArgs.h
@@ -110,7 +110,7 @@ struct NotifyMotionArgs {
     NotifyMotionArgs(int32_t id, nsecs_t eventTime, nsecs_t readTime, int32_t deviceId,
                      uint32_t source, ui::LogicalDisplayId displayId, uint32_t policyFlags,
                      int32_t action, int32_t actionButton, int32_t flags, int32_t metaState,
-                     int32_t buttonState, MotionClassification classification, int32_t edgeFlags,
+                     int32_t buttonState, MotionClassification classification,
                      uint32_t pointerCount, const PointerProperties* pointerProperties,
                      const PointerCoords* pointerCoords, float xPrecision, float yPrecision,
                      float xCursorPosition, float yCursorPosition, nsecs_t downTime,
diff --git a/services/inputflinger/include/NotifyArgsBuilders.h b/services/inputflinger/include/NotifyArgsBuilders.h
index 13eaaf3be9..1b3e4bf7b1 100644
--- a/services/inputflinger/include/NotifyArgsBuilders.h
+++ b/services/inputflinger/include/NotifyArgsBuilders.h
@@ -139,7 +139,6 @@ public:
                 AMETA_NONE,
                 mButtonState,
                 mClassification,
-                /*edgeFlags=*/0,
                 static_cast<uint32_t>(mPointers.size()),
                 pointerProperties.data(),
                 pointerCoords.data(),
diff --git a/services/inputflinger/reader/Android.bp b/services/inputflinger/reader/Android.bp
index dc7f7c1d26..3c99a69396 100644
--- a/services/inputflinger/reader/Android.bp
+++ b/services/inputflinger/reader/Android.bp
@@ -88,7 +88,7 @@ cc_defaults {
         "libinput",
         "libjsoncpp",
         "liblog",
-        "libstatslog",
+        "libstatslog_inputflinger",
         "libstatspull",
         "libstatssocket",
         "libutils",
diff --git a/services/inputflinger/reader/EventHub.cpp b/services/inputflinger/reader/EventHub.cpp
index 559bc0aa7a..6326d489d9 100644
--- a/services/inputflinger/reader/EventHub.cpp
+++ b/services/inputflinger/reader/EventHub.cpp
@@ -49,7 +49,7 @@
 #include <input/PrintTools.h>
 #include <input/VirtualKeyMap.h>
 #include <openssl/sha.h>
-#include <statslog.h>
+#include <statslog_inputflinger.h>
 #include <utils/Errors.h>
 #include <utils/Log.h>
 #include <utils/Timers.h>
@@ -86,6 +86,10 @@ static constexpr int32_t FF_WEAK_MAGNITUDE_CHANNEL_IDX = 1;
 
 static constexpr size_t EVENT_BUFFER_SIZE = 256;
 
+// Logs if the difference between the event timestamp and the read time is
+// greater than this threshold.
+static constexpr nsecs_t SLOW_READ_LOG_THRESHOLD_NS = ms2ns(100);
+
 // Mapping for input battery class node IDs lookup.
 // https://www.kernel.org/doc/Documentation/power/power_supply_class.txt
 static const std::unordered_map<std::string, InputBatteryClass> BATTERY_CLASSES =
@@ -359,10 +363,13 @@ static base::Result<std::shared_ptr<PropertyMap>> loadConfiguration(
                                                                           CONFIGURATION);
     if (configurationFile.empty()) {
         ALOGD("No input device configuration file found for device '%s'.", ident.name.c_str());
-        return base::Result<std::shared_ptr<PropertyMap>>(nullptr);
+        return base::Error(ENOENT);
     }
     base::Result<std::shared_ptr<PropertyMap>> propertyMap =
             PropertyMap::load(configurationFile.c_str());
+    if (propertyMap.ok()) {
+        propertyMap.value()->addProperty("configurationFile", configurationFile);
+    }
 
     return propertyMap;
 }
@@ -1899,84 +1906,7 @@ std::vector<RawEvent> EventHub::getEvents(int timeoutMillis) {
 
         handleSysfsNodeChangeNotificationsLocked();
 
-        // Use a do-while loop to ensure that we drain the closing and opening devices loop
-        // at least once, even if there are no devices to re-open.
-        do {
-            if (!mDeviceIdsToReopen.empty()) {
-                // If there are devices that need to be re-opened, ensure that we re-open them
-                // one at a time to send the DEVICE_REMOVED and DEVICE_ADDED notifications for
-                // each before moving on to the next. This is to avoid notifying all device
-                // removals and additions in one batch, which could cause additional unnecessary
-                // device added/removed notifications for merged InputDevices from InputReader.
-                const int32_t deviceId = mDeviceIdsToReopen.back();
-                mDeviceIdsToReopen.erase(mDeviceIdsToReopen.end() - 1);
-                if (auto it = mDevices.find(deviceId); it != mDevices.end()) {
-                    ALOGI("Reopening input device: id=%d, name=%s", it->second->id,
-                          it->second->identifier.name.c_str());
-                    const auto path = it->second->path;
-                    closeDeviceLocked(*it->second);
-                    openDeviceLocked(path);
-                }
-            }
-
-            // Report any devices that had last been added/removed.
-            for (auto it = mClosingDevices.begin(); it != mClosingDevices.end();) {
-                std::unique_ptr<Device> device = std::move(*it);
-                ALOGV("Reporting device closed: id=%d, name=%s\n", device->id,
-                      device->path.c_str());
-                const int32_t deviceId = (device->id == mBuiltInKeyboardId)
-                        ? ReservedInputDeviceId::BUILT_IN_KEYBOARD_ID
-                        : device->id;
-                events.push_back({
-                        .when = now,
-                        .deviceId = deviceId,
-                        .type = DEVICE_REMOVED,
-                });
-                it = mClosingDevices.erase(it);
-                if (events.size() == EVENT_BUFFER_SIZE) {
-                    break;
-                }
-            }
-
-            if (mNeedToScanDevices) {
-                mNeedToScanDevices = false;
-                scanDevicesLocked();
-            }
-
-            while (!mOpeningDevices.empty()) {
-                std::unique_ptr<Device> device = std::move(*mOpeningDevices.rbegin());
-                mOpeningDevices.pop_back();
-                ALOGV("Reporting device opened: id=%d, name=%s\n", device->id,
-                      device->path.c_str());
-                const int32_t deviceId = device->id == mBuiltInKeyboardId ? 0 : device->id;
-                events.push_back({
-                        .when = now,
-                        .deviceId = deviceId,
-                        .type = DEVICE_ADDED,
-                });
-
-                // Try to find a matching video device by comparing device names
-                for (auto it = mUnattachedVideoDevices.begin(); it != mUnattachedVideoDevices.end();
-                     it++) {
-                    std::unique_ptr<TouchVideoDevice>& videoDevice = *it;
-                    if (tryAddVideoDeviceLocked(*device, videoDevice)) {
-                        // videoDevice was transferred to 'device'
-                        it = mUnattachedVideoDevices.erase(it);
-                        break;
-                    }
-                }
-
-                auto [dev_it, inserted] = mDevices.insert_or_assign(device->id, std::move(device));
-                if (!inserted) {
-                    ALOGW("Device id %d exists, replaced.", device->id);
-                }
-                if (events.size() == EVENT_BUFFER_SIZE) {
-                    break;
-                }
-            }
-
-            // Perform this loop of re-opening devices so that we re-open one device at a time.
-        } while (!mDeviceIdsToReopen.empty());
+        handleDeviceChangesLocked(events, now);
 
         if (events.size() == EVENT_BUFFER_SIZE) {
             break;
@@ -2071,6 +2001,15 @@ std::vector<RawEvent> EventHub::getEvents(int timeoutMillis) {
                                 .code = iev.code,
                                 .value = iev.value,
                         });
+                        const nsecs_t readDeltaNs = events.back().readTime - events.back().when;
+                        if (readDeltaNs >= SLOW_READ_LOG_THRESHOLD_NS) {
+                            ALOGW(
+                                    "Slow read detected for device '%s', eventTime: %" PRId64 "ns, "
+                                    "readDelta: %" PRId64 " ns (over the threshold of %" PRId64
+                                    " ms)",
+                                    device->identifier.name.c_str(), events.back().when,
+                                    readDeltaNs, ns2ms(SLOW_READ_LOG_THRESHOLD_NS));
+                        }
                     }
                     if (events.size() >= EVENT_BUFFER_SIZE) {
                         // The result buffer is full.  Reset the pending event index
@@ -2157,6 +2096,85 @@ std::vector<RawEvent> EventHub::getEvents(int timeoutMillis) {
     return events;
 }
 
+void EventHub::handleDeviceChangesLocked(std::vector<RawEvent>& events, nsecs_t now) {
+    // Use a do-while loop to ensure that we drain the closing and opening devices
+    // at least once, even if there are no devices to re-open.
+    do {
+        if (!mDeviceIdsToReopen.empty()) {
+            // If there are devices that need to be re-opened, ensure that we re-open them
+            // one at a time to send the DEVICE_REMOVED and DEVICE_ADDED notifications for
+            // each before moving on to the next. This is to avoid notifying all device
+            // removals and additions in one batch, which could cause additional unnecessary
+            // device added/removed notifications for merged InputDevices from InputReader.
+            const int32_t deviceId = mDeviceIdsToReopen.back();
+            mDeviceIdsToReopen.erase(mDeviceIdsToReopen.end() - 1);
+            if (auto it = mDevices.find(deviceId); it != mDevices.end()) {
+                ALOGI("Reopening input device: id=%d, name=%s", it->second->id,
+                      it->second->identifier.name.c_str());
+                const auto path = it->second->path;
+                closeDeviceLocked(*it->second);
+                openDeviceLocked(path);
+            }
+        }
+
+        // Report any devices that had last been added/removed.
+        for (auto it = mClosingDevices.begin(); it != mClosingDevices.end();) {
+            std::unique_ptr<Device> device = std::move(*it);
+            ALOGV("Reporting device closed: id=%d, name=%s\n", device->id, device->path.c_str());
+            const int32_t deviceId = (device->id == mBuiltInKeyboardId)
+                    ? ReservedInputDeviceId::BUILT_IN_KEYBOARD_ID
+                    : device->id;
+            events.push_back({
+                    .when = now,
+                    .deviceId = deviceId,
+                    .type = DEVICE_REMOVED,
+            });
+            it = mClosingDevices.erase(it);
+            if (events.size() == EVENT_BUFFER_SIZE) {
+                break;
+            }
+        }
+
+        if (mNeedToScanDevices) {
+            mNeedToScanDevices = false;
+            scanDevicesLocked();
+        }
+
+        while (!mOpeningDevices.empty()) {
+            std::unique_ptr<Device> device = std::move(*mOpeningDevices.rbegin());
+            mOpeningDevices.pop_back();
+            ALOGV("Reporting device opened: id=%d, name=%s\n", device->id, device->path.c_str());
+            const int32_t deviceId = device->id == mBuiltInKeyboardId ? 0 : device->id;
+            events.push_back({
+                    .when = now,
+                    .deviceId = deviceId,
+                    .type = DEVICE_ADDED,
+            });
+
+            // Try to find a matching video device by comparing device names
+            for (auto it = mUnattachedVideoDevices.begin(); it != mUnattachedVideoDevices.end();
+                 it++) {
+                std::unique_ptr<TouchVideoDevice>& videoDevice = *it;
+                if (tryAddVideoDeviceLocked(*device, videoDevice)) {
+                    // videoDevice was transferred to 'device'
+                    it = mUnattachedVideoDevices.erase(it);
+                    break;
+                }
+            }
+
+            auto [dev_it, inserted] = mDevices.insert_or_assign(device->id, std::move(device));
+            if (!inserted) {
+                ALOGW("Device id %d exists, replaced.", device->id);
+            }
+            if (events.size() == EVENT_BUFFER_SIZE) {
+                break;
+            }
+        }
+
+        // Perform this loop of re-opening devices so that we re-open one device at a time.
+    } while (!mDeviceIdsToReopen.empty());
+}
+
 std::vector<TouchVideoFrame> EventHub::getVideoFrames(int32_t deviceId) {
     std::scoped_lock _l(mLock);
 
@@ -2285,9 +2303,10 @@ void EventHub::reportDeviceAddedForStatisticsLocked(const InputDeviceIdentifier&
         obfuscatedId += StringPrintf("%02x", digest[i]);
     }
 
-    android::util::stats_write(android::util::INPUTDEVICE_REGISTERED, identifier.name.c_str(),
-                               identifier.vendor, identifier.product, identifier.version,
-                               identifier.bus, obfuscatedId.c_str(), classes.get());
+    android::inputflinger::stats::stats_write(android::inputflinger::stats::INPUTDEVICE_REGISTERED,
+                                              identifier.name.c_str(), identifier.vendor,
+                                              identifier.product, identifier.version,
+                                              identifier.bus, obfuscatedId.c_str(), classes.get());
 }
 
 void EventHub::openDeviceLocked(const std::string& devicePath) {
@@ -2383,13 +2402,18 @@ void EventHub::openDeviceLocked(const std::string& devicePath) {
 
     // Load the configuration file for the device.
     std::shared_ptr<PropertyMap> configuration = nullptr;
-    base::Result<std::shared_ptr<PropertyMap>> propertyMapResult = loadConfiguration(identifier);
+    std::string configFile;
+    auto propertyMapResult = loadConfiguration(identifier);
     if (!propertyMapResult.ok()) {
-        ALOGE("Error loading input device configuration file for device '%s'. "
-              "Using default configuration. Error: %s",
-              identifier.name.c_str(), propertyMapResult.error().message().c_str());
+        // Most devices don't specify an input device configuration file, therefore suppress those
+        // prints.
+        ALOGE_IF(propertyMapResult.error().code() != ENOENT,
+                 "Error loading input device configuration file for device '%s'. "
+                 "Using default configuration. Error: %s",
+                 identifier.name.c_str(), propertyMapResult.error().message().c_str());
     } else {
         configuration = propertyMapResult.value();
+        configFile = propertyMapResult.value()->getString("configurationFile").value_or("<none>");
     }
 
     // Allocate device.  (The device object takes ownership of the fd at this point.)
@@ -2609,7 +2633,7 @@ void EventHub::openDeviceLocked(const std::string& devicePath) {
     ALOGI("New device: id=%d, fd=%d, path='%s', name='%s', classes=%s, "
           "configuration='%s', keyLayout='%s', keyCharacterMap='%s', builtinKeyboard=%s, ",
           deviceId, fd, devicePath.c_str(), device->identifier.name.c_str(),
-          device->classes.string().c_str(), device->configurationFile.c_str(),
+          device->classes.string().c_str(), configFile.c_str(),
           device->keyMap.keyLayoutFile.c_str(), device->keyMap.keyCharacterMapFile.c_str(),
           toString(mBuiltInKeyboardId == deviceId));
 
@@ -3043,7 +3067,11 @@ void EventHub::dump(std::string& dump) const {
                                      device->associatedDevice->layoutInfo->layoutType.c_str());
             }
             dump += StringPrintf(INDENT3 "ConfigurationFile: %s\n",
-                                 device->configurationFile.c_str());
+                                 device->configuration
+                                         ? device->configuration->getString("configurationFile")
+                                                   .value_or("<none>")
+                                                   .c_str()
+                                         : "<none>");
             dump += StringPrintf(INDENT3 "VideoDevice: %s\n",
                                  device->videoDevice ? device->videoDevice->dump().c_str()
                                                      : "<none>");
diff --git a/services/inputflinger/reader/InputDevice.cpp b/services/inputflinger/reader/InputDevice.cpp
index 594dcba144..c8badff5a4 100644
--- a/services/inputflinger/reader/InputDevice.cpp
+++ b/services/inputflinger/reader/InputDevice.cpp
@@ -262,7 +262,7 @@ std::list<NotifyArgs> InputDevice::configureInternal(nsecs_t when,
                 std::optional<PropertyMap> configuration =
                         getEventHub()->getConfiguration(context.getEventHubId());
                 if (configuration) {
-                    mConfiguration.addAll(&(*configuration));
+                    mConfiguration.addAll(*configuration);
                 }
             });
 
diff --git a/services/inputflinger/reader/InputReader.cpp b/services/inputflinger/reader/InputReader.cpp
index 74ef972848..316ac9301e 100644
--- a/services/inputflinger/reader/InputReader.cpp
+++ b/services/inputflinger/reader/InputReader.cpp
@@ -122,8 +122,9 @@ std::optional<DeviceId> getDeviceIdOfNewGesture(const NotifyArgs& args) {
 
 InputReader::InputReader(std::shared_ptr<EventHubInterface> eventHub,
                          const sp<InputReaderPolicyInterface>& policy,
-                         InputListenerInterface& listener)
+                         InputListenerInterface& listener, JNIEnv* env)
       : mContext(this),
+        mJniEnv(env),
         mEventHub(eventHub),
         mPolicy(policy),
         mNextListener(listener),
@@ -147,7 +148,7 @@ status_t InputReader::start() {
     }
     mThread = std::make_unique<InputThread>(
             "InputReader", [this]() { loopOnce(); }, [this]() { mEventHub->wake(); },
-            /*isInCriticalPath=*/true);
+            /*isInCriticalPath=*/true, mJniEnv);
     return OK;
 }
 
diff --git a/services/inputflinger/reader/InputReaderFactory.cpp b/services/inputflinger/reader/InputReaderFactory.cpp
index 2d9ffc3ec8..487960e67d 100644
--- a/services/inputflinger/reader/InputReaderFactory.cpp
+++ b/services/inputflinger/reader/InputReaderFactory.cpp
@@ -21,8 +21,9 @@
 namespace android {
 
 std::unique_ptr<InputReaderInterface> createInputReader(
-        const sp<InputReaderPolicyInterface>& policy, InputListenerInterface& listener) {
-    return std::make_unique<InputReader>(std::make_unique<EventHub>(), policy, listener);
+        const sp<InputReaderPolicyInterface>& policy, InputListenerInterface& listener,
+        JNIEnv* env) {
+    return std::make_unique<InputReader>(std::make_unique<EventHub>(), policy, listener, env);
 }
 
 } // namespace android
\ No newline at end of file
diff --git a/services/inputflinger/reader/include/EventHub.h b/services/inputflinger/reader/include/EventHub.h
index 9f3a57c265..f3a147362e 100644
--- a/services/inputflinger/reader/include/EventHub.h
+++ b/services/inputflinger/reader/include/EventHub.h
@@ -669,7 +669,6 @@ private:
         };
         std::map<int /*axis*/, AxisState> absState;
 
-        std::string configurationFile;
         std::shared_ptr<PropertyMap> configuration;
         std::unique_ptr<VirtualKeyMap> virtualKeyMap;
         KeyMap keyMap;
@@ -783,6 +782,8 @@ private:
 
     void handleSysfsNodeChangeNotificationsLocked() REQUIRES(mLock);
 
+    void handleDeviceChangesLocked(std::vector<RawEvent>& events, nsecs_t now) REQUIRES(mLock);
+
     // Protect all internal state.
     mutable std::mutex mLock;
 
diff --git a/services/inputflinger/reader/include/InputReader.h b/services/inputflinger/reader/include/InputReader.h
index 9212d37966..012728515b 100644
--- a/services/inputflinger/reader/include/InputReader.h
+++ b/services/inputflinger/reader/include/InputReader.h
@@ -52,7 +52,8 @@ struct StylusState;
 class InputReader : public InputReaderInterface {
 public:
     InputReader(std::shared_ptr<EventHubInterface> eventHub,
-                const sp<InputReaderPolicyInterface>& policy, InputListenerInterface& listener);
+                const sp<InputReaderPolicyInterface>& policy, InputListenerInterface& listener,
+                JNIEnv* env);
     virtual ~InputReader();
 
     void dump(std::string& dump) override;
@@ -177,6 +178,7 @@ protected:
     mutable std::mutex mLock;
 
 private:
+    JNIEnv* mJniEnv;
     std::unique_ptr<InputThread> mThread;
 
     std::condition_variable mReaderIsAliveCondition;
diff --git a/services/inputflinger/reader/mapper/CapturedTouchpadEventConverter.cpp b/services/inputflinger/reader/mapper/CapturedTouchpadEventConverter.cpp
index d796af158b..5814288ba7 100644
--- a/services/inputflinger/reader/mapper/CapturedTouchpadEventConverter.cpp
+++ b/services/inputflinger/reader/mapper/CapturedTouchpadEventConverter.cpp
@@ -313,8 +313,8 @@ NotifyMotionArgs CapturedTouchpadEventConverter::makeMotionArgs(
                             ui::LogicalDisplayId::INVALID, /*policyFlags=*/POLICY_FLAG_WAKE, action,
                             /*actionButton=*/actionButton, flags,
                             mReaderContext.getGlobalMetaState(), mButtonState,
-                            MotionClassification::NONE, AMOTION_EVENT_EDGE_FLAG_NONE, coords.size(),
-                            properties.data(), coords.data(), /*xPrecision=*/1.0f,
+                            MotionClassification::NONE, coords.size(), properties.data(),
+                            coords.data(), /*xPrecision=*/1.0f,
                             /*yPrecision=*/1.0f, AMOTION_EVENT_INVALID_CURSOR_POSITION,
                             AMOTION_EVENT_INVALID_CURSOR_POSITION, mDownTime, /*videoFrames=*/{});
 }
diff --git a/services/inputflinger/reader/mapper/CursorInputMapper.cpp b/services/inputflinger/reader/mapper/CursorInputMapper.cpp
index e21c2f9120..df225a17a4 100644
--- a/services/inputflinger/reader/mapper/CursorInputMapper.cpp
+++ b/services/inputflinger/reader/mapper/CursorInputMapper.cpp
@@ -25,6 +25,7 @@
 #include <com_android_input_flags.h>
 #include <ftl/enum.h>
 #include <input/AccelerationCurve.h>
+#include <input/InputFlags.h>
 
 #include "CursorButtonAccumulator.h"
 #include "CursorScrollAccumulator.h"
@@ -35,6 +36,24 @@
 
 namespace android {
 
+namespace {
+
+/** Max density value supported by input. */
+const int32_t ACONFIGURATION_MAX_SUPPORTED_DENSITY = ACONFIGURATION_DENSITY_ANY;
+
+// Density values in range (0, ACONFIGURATION_MAX_SUPPORTED_DENSITY] are supported for cursor
+// moves scaling. Other density values e.g. ACONFIGURATION_DENSITY_DEFAULT,
+// ACONFIGURATION_DENSITY_NONE etc. are ignored.
+inline bool isDensityValueSupportedForScaling(int32_t density) {
+    if (density > 0 && density <= ACONFIGURATION_MAX_SUPPORTED_DENSITY) {
+        return true;
+    }
+    ALOGE("Unexpected display density value %d, cursor move scaling will be disabled.", density);
+    return false;
+}
+
+} // namespace
+
 // The default velocity control parameters that has no effect.
 static const VelocityControlParameters FLAT_VELOCITY_CONTROL_PARAMS{};
 
@@ -129,6 +148,7 @@ void CursorInputMapper::dump(std::string& dump) {
     dump += StringPrintf(INDENT3 "DisplayId: %s\n",
                          toString(mDisplayId, streamableToString).c_str());
     dump += StringPrintf(INDENT3 "Orientation: %s\n", ftl::enum_string(mOrientation).c_str());
+    dump += StringPrintf(INDENT3 "ViewportDensityDpi: %d\n", mViewportDensityDpi);
     dump += StringPrintf(INDENT3 "ButtonState: 0x%08x\n", mButtonState);
     dump += StringPrintf(INDENT3 "Down: %s\n", toString(isPointerDown(mButtonState)));
     dump += StringPrintf(INDENT3 "DownTime: %" PRId64 "\n", mDownTime);
@@ -272,9 +292,6 @@ std::list<NotifyArgs> CursorInputMapper::sync(nsecs_t when, nsecs_t readTime) {
     pointerProperties.id = 0;
     pointerProperties.toolType = ToolType::MOUSE;
 
-    PointerCoords pointerCoords;
-    pointerCoords.clear();
-
     // A negative value represents inverted scrolling direction.
     // Applies only if the source is a mouse.
     const bool isMouse =
@@ -291,18 +308,6 @@ std::list<NotifyArgs> CursorInputMapper::sync(nsecs_t when, nsecs_t readTime) {
 
     float xCursorPosition = AMOTION_EVENT_INVALID_CURSOR_POSITION;
     float yCursorPosition = AMOTION_EVENT_INVALID_CURSOR_POSITION;
-    if (mSource == AINPUT_SOURCE_MOUSE) {
-        pointerCoords.setAxisValue(AMOTION_EVENT_AXIS_RELATIVE_X, deltaX);
-        pointerCoords.setAxisValue(AMOTION_EVENT_AXIS_RELATIVE_Y, deltaY);
-    } else {
-        // Pointer capture and navigation modes
-        pointerCoords.setAxisValue(AMOTION_EVENT_AXIS_X, deltaX);
-        pointerCoords.setAxisValue(AMOTION_EVENT_AXIS_Y, deltaY);
-        pointerCoords.setAxisValue(AMOTION_EVENT_AXIS_RELATIVE_X, deltaX);
-        pointerCoords.setAxisValue(AMOTION_EVENT_AXIS_RELATIVE_Y, deltaY);
-    }
-
-    pointerCoords.setAxisValue(AMOTION_EVENT_AXIS_PRESSURE, down ? 1.0f : 0.0f);
 
     // Moving an external trackball or mouse should wake the device.
     // We don't do this for internal cursor devices to prevent them from waking up
@@ -313,23 +318,48 @@ std::list<NotifyArgs> CursorInputMapper::sync(nsecs_t when, nsecs_t readTime) {
         policyFlags |= POLICY_FLAG_WAKE;
     }
 
+    const int32_t metaState = getContext()->getGlobalMetaState();
+    // Send an event for the cursor motion.
+    // TODO(b/407018146): we currently need to send a zero-delta HOVER_MOVE before scrolls so that
+    //  InputDispatcher generates a HOVER_ENTER event if necessary. (The VirtualMouseTest in CTS
+    //  depends on this.) Fix this issue then remove `|| scrolled` here.
+    if (moved || scrolled) {
+        int32_t action = wasDown || mSource != AINPUT_SOURCE_MOUSE
+                ? AMOTION_EVENT_ACTION_MOVE
+                : AMOTION_EVENT_ACTION_HOVER_MOVE;
+
+        PointerCoords moveCoords;
+        moveCoords.clear();
+        moveCoords.setAxisValue(AMOTION_EVENT_AXIS_RELATIVE_X, deltaX);
+        moveCoords.setAxisValue(AMOTION_EVENT_AXIS_RELATIVE_Y, deltaY);
+        if (mSource != AINPUT_SOURCE_MOUSE) {
+            // Pointer capture and navigation modes
+            moveCoords.setAxisValue(AMOTION_EVENT_AXIS_X, deltaX);
+            moveCoords.setAxisValue(AMOTION_EVENT_AXIS_Y, deltaY);
+        }
+
+        moveCoords.setAxisValue(AMOTION_EVENT_AXIS_PRESSURE, wasDown ? 1.0f : 0.0f);
+
+        out.push_back(NotifyMotionArgs(getContext()->getNextId(), when, readTime, getDeviceId(),
+                                       mSource, *mDisplayId, policyFlags, action, 0, 0, metaState,
+                                       lastButtonState, MotionClassification::NONE, 1,
+                                       &pointerProperties, &moveCoords, mXPrecision, mYPrecision,
+                                       xCursorPosition, yCursorPosition, downTime,
+                                       /*videoFrames=*/{}));
+    }
+
     // Synthesize key down from buttons if needed.
     out += synthesizeButtonKeys(getContext(), AKEY_EVENT_ACTION_DOWN, when, readTime, getDeviceId(),
                                 mSource, *mDisplayId, policyFlags, lastButtonState,
                                 currentButtonState);
 
-    // Send motion event.
-    if (downChanged || moved || scrolled || buttonsChanged) {
-        int32_t metaState = getContext()->getGlobalMetaState();
+    // Send motion events for buttons and scrolling.
+    if (downChanged || scrolled || buttonsChanged) {
         int32_t buttonState = lastButtonState;
-        int32_t motionEventAction;
-        if (downChanged) {
-            motionEventAction = down ? AMOTION_EVENT_ACTION_DOWN : AMOTION_EVENT_ACTION_UP;
-        } else if (down || (mSource != AINPUT_SOURCE_MOUSE)) {
-            motionEventAction = AMOTION_EVENT_ACTION_MOVE;
-        } else {
-            motionEventAction = AMOTION_EVENT_ACTION_HOVER_MOVE;
-        }
+
+        PointerCoords pointerCoords;
+        pointerCoords.clear();
+        pointerCoords.setAxisValue(AMOTION_EVENT_AXIS_PRESSURE, down ? 1.0f : 0.0f);
 
         if (buttonsReleased) {
             BitSet32 released(buttonsReleased);
@@ -340,20 +370,22 @@ std::list<NotifyArgs> CursorInputMapper::sync(nsecs_t when, nsecs_t readTime) {
                                                getDeviceId(), mSource, *mDisplayId, policyFlags,
                                                AMOTION_EVENT_ACTION_BUTTON_RELEASE, actionButton, 0,
                                                metaState, buttonState, MotionClassification::NONE,
-                                               AMOTION_EVENT_EDGE_FLAG_NONE, 1, &pointerProperties,
-                                               &pointerCoords, mXPrecision, mYPrecision,
-                                               xCursorPosition, yCursorPosition, downTime,
-                                               /*videoFrames=*/{}));
+                                               1, &pointerProperties, &pointerCoords, mXPrecision,
+                                               mYPrecision, xCursorPosition, yCursorPosition,
+                                               downTime, /*videoFrames=*/{}));
             }
         }
 
-        out.push_back(NotifyMotionArgs(getContext()->getNextId(), when, readTime, getDeviceId(),
-                                       mSource, *mDisplayId, policyFlags, motionEventAction, 0, 0,
-                                       metaState, currentButtonState, MotionClassification::NONE,
-                                       AMOTION_EVENT_EDGE_FLAG_NONE, 1, &pointerProperties,
-                                       &pointerCoords, mXPrecision, mYPrecision, xCursorPosition,
-                                       yCursorPosition, downTime,
-                                       /*videoFrames=*/{}));
+        if (downChanged) {
+            int32_t action = down ? AMOTION_EVENT_ACTION_DOWN : AMOTION_EVENT_ACTION_UP;
+            out.push_back(NotifyMotionArgs(getContext()->getNextId(), when, readTime, getDeviceId(),
+                                           mSource, *mDisplayId, policyFlags, action, 0, 0,
+                                           metaState, currentButtonState,
+                                           MotionClassification::NONE, 1, &pointerProperties,
+                                           &pointerCoords, mXPrecision, mYPrecision,
+                                           xCursorPosition, yCursorPosition, downTime,
+                                           /*videoFrames=*/{}));
+        }
 
         if (buttonsPressed) {
             BitSet32 pressed(buttonsPressed);
@@ -364,24 +396,22 @@ std::list<NotifyArgs> CursorInputMapper::sync(nsecs_t when, nsecs_t readTime) {
                                                getDeviceId(), mSource, *mDisplayId, policyFlags,
                                                AMOTION_EVENT_ACTION_BUTTON_PRESS, actionButton, 0,
                                                metaState, buttonState, MotionClassification::NONE,
-                                               AMOTION_EVENT_EDGE_FLAG_NONE, 1, &pointerProperties,
-                                               &pointerCoords, mXPrecision, mYPrecision,
-                                               xCursorPosition, yCursorPosition, downTime,
-                                               /*videoFrames=*/{}));
+                                               1, &pointerProperties, &pointerCoords, mXPrecision,
+                                               mYPrecision, xCursorPosition, yCursorPosition,
+                                               downTime, /*videoFrames=*/{}));
             }
         }
 
         ALOG_ASSERT(buttonState == currentButtonState);
 
         // Send hover move after UP to tell the application that the mouse is hovering now.
-        if (motionEventAction == AMOTION_EVENT_ACTION_UP && (mSource == AINPUT_SOURCE_MOUSE)) {
+        if (downChanged && !down && (mSource == AINPUT_SOURCE_MOUSE)) {
             out.push_back(NotifyMotionArgs(getContext()->getNextId(), when, readTime, getDeviceId(),
                                            mSource, *mDisplayId, policyFlags,
                                            AMOTION_EVENT_ACTION_HOVER_MOVE, 0, 0, metaState,
-                                           currentButtonState, MotionClassification::NONE,
-                                           AMOTION_EVENT_EDGE_FLAG_NONE, 1, &pointerProperties,
-                                           &pointerCoords, mXPrecision, mYPrecision,
-                                           xCursorPosition, yCursorPosition, downTime,
+                                           currentButtonState, MotionClassification::NONE, 1,
+                                           &pointerProperties, &pointerCoords, mXPrecision,
+                                           mYPrecision, xCursorPosition, yCursorPosition, downTime,
                                            /*videoFrames=*/{}));
         }
 
@@ -393,10 +423,9 @@ std::list<NotifyArgs> CursorInputMapper::sync(nsecs_t when, nsecs_t readTime) {
             out.push_back(NotifyMotionArgs(getContext()->getNextId(), when, readTime, getDeviceId(),
                                            mSource, *mDisplayId, policyFlags,
                                            AMOTION_EVENT_ACTION_SCROLL, 0, 0, metaState,
-                                           currentButtonState, MotionClassification::NONE,
-                                           AMOTION_EVENT_EDGE_FLAG_NONE, 1, &pointerProperties,
-                                           &pointerCoords, mXPrecision, mYPrecision,
-                                           xCursorPosition, yCursorPosition, downTime,
+                                           currentButtonState, MotionClassification::NONE, 1,
+                                           &pointerProperties, &pointerCoords, mXPrecision,
+                                           mYPrecision, xCursorPosition, yCursorPosition, downTime,
                                            /*videoFrames=*/{}));
         }
     }
@@ -481,12 +510,22 @@ void CursorInputMapper::configureOnChangePointerSpeed(const InputReaderConfigura
         mPointerVelocityControl.setAccelerationEnabled(false);
         mWheelXVelocityControl.setParameters(FLAT_VELOCITY_CONTROL_PARAMS);
         mWheelYVelocityControl.setParameters(FLAT_VELOCITY_CONTROL_PARAMS);
+        mXScale = mYScale = 1.0;
         return;
     }
 
     bool disableAllScaling = config.displaysWithMouseScalingDisabled.count(
                                      mDisplayId.value_or(ui::LogicalDisplayId::INVALID)) != 0;
 
+    if (mParameters.mode == Parameters::Mode::POINTER) {
+        // TODO(b/408170793): We use ACONFIGURATION_DENSITY_XHIGH as baseline for scale due to
+        // legacy reasons, this need to be tuned with further UX testing.
+        mXScale = mYScale = InputFlags::scaleCursorSpeedWithDisplayDensity() &&
+                        !disableAllScaling && isDensityValueSupportedForScaling(mViewportDensityDpi)
+                ? static_cast<float>(mViewportDensityDpi) /
+                        static_cast<float>(ACONFIGURATION_DENSITY_XHIGH)
+                : 1.0;
+    }
     mPointerVelocityControl.setAccelerationEnabled(!disableAllScaling);
 
     mPointerVelocityControl.setCurve(
@@ -529,6 +568,9 @@ void CursorInputMapper::configureOnChangeDisplayInfo(const InputReaderConfigurat
                         static_cast<float>(resolvedViewport->logicalBottom - 1)}
             : FloatRect{0, 0, 0, 0};
 
+    mViewportDensityDpi =
+            resolvedViewport ? resolvedViewport->densityDpi : ACONFIGURATION_DENSITY_MEDIUM;
+
     bumpGeneration();
 }
 
diff --git a/services/inputflinger/reader/mapper/CursorInputMapper.h b/services/inputflinger/reader/mapper/CursorInputMapper.h
index f2b2b6f2a8..3872cdc7b5 100644
--- a/services/inputflinger/reader/mapper/CursorInputMapper.h
+++ b/services/inputflinger/reader/mapper/CursorInputMapper.h
@@ -20,6 +20,7 @@
 #include "CursorScrollAccumulator.h"
 #include "InputMapper.h"
 
+#include <android/configuration.h>
 #include <input/VelocityControl.h>
 #include <ui/Rotation.h>
 
@@ -114,6 +115,7 @@ private:
     std::optional<ui::LogicalDisplayId> mDisplayId;
     ui::Rotation mOrientation{ui::ROTATION_0};
     FloatRect mBoundsInLogicalDisplay{};
+    int32_t mViewportDensityDpi{ACONFIGURATION_DENSITY_NONE};
 
     // The button state as of the last sync.
     int32_t mButtonState;
diff --git a/services/inputflinger/reader/mapper/JoystickInputMapper.cpp b/services/inputflinger/reader/mapper/JoystickInputMapper.cpp
index 3091714e00..e72e83b474 100644
--- a/services/inputflinger/reader/mapper/JoystickInputMapper.cpp
+++ b/services/inputflinger/reader/mapper/JoystickInputMapper.cpp
@@ -348,9 +348,8 @@ std::list<NotifyArgs> JoystickInputMapper::sync(nsecs_t when, nsecs_t readTime,
     out.push_back(NotifyMotionArgs(getContext()->getNextId(), when, readTime, getDeviceId(),
                                    AINPUT_SOURCE_JOYSTICK, displayId, policyFlags,
                                    AMOTION_EVENT_ACTION_MOVE, 0, 0, metaState, buttonState,
-                                   MotionClassification::NONE, AMOTION_EVENT_EDGE_FLAG_NONE, 1,
-                                   &pointerProperties, &pointerCoords, 0, 0,
-                                   AMOTION_EVENT_INVALID_CURSOR_POSITION,
+                                   MotionClassification::NONE, 1, &pointerProperties,
+                                   &pointerCoords, 0, 0, AMOTION_EVENT_INVALID_CURSOR_POSITION,
                                    AMOTION_EVENT_INVALID_CURSOR_POSITION, 0, /*videoFrames=*/{}));
     return out;
 }
diff --git a/services/inputflinger/reader/mapper/RotaryEncoderInputMapper.cpp b/services/inputflinger/reader/mapper/RotaryEncoderInputMapper.cpp
index c633b495e4..a3d92553e7 100644
--- a/services/inputflinger/reader/mapper/RotaryEncoderInputMapper.cpp
+++ b/services/inputflinger/reader/mapper/RotaryEncoderInputMapper.cpp
@@ -205,9 +205,9 @@ std::list<NotifyArgs> RotaryEncoderInputMapper::sync(nsecs_t when, nsecs_t readT
         out.push_back(
                 NotifyMotionArgs(getContext()->getNextId(), when, readTime, getDeviceId(), mSource,
                                  mDisplayId, policyFlags, AMOTION_EVENT_ACTION_SCROLL, 0, 0,
-                                 metaState, /*buttonState=*/0, MotionClassification::NONE,
-                                 AMOTION_EVENT_EDGE_FLAG_NONE, 1, &pointerProperties,
-                                 &pointerCoords, 0, 0, AMOTION_EVENT_INVALID_CURSOR_POSITION,
+                                 metaState, /*buttonState=*/0, MotionClassification::NONE, 1,
+                                 &pointerProperties, &pointerCoords, 0, 0,
+                                 AMOTION_EVENT_INVALID_CURSOR_POSITION,
                                  AMOTION_EVENT_INVALID_CURSOR_POSITION, 0, /*videoFrames=*/{}));
     }
 
diff --git a/services/inputflinger/reader/mapper/TouchInputMapper.cpp b/services/inputflinger/reader/mapper/TouchInputMapper.cpp
index 4d36db8ff7..5ec6705e55 100644
--- a/services/inputflinger/reader/mapper/TouchInputMapper.cpp
+++ b/services/inputflinger/reader/mapper/TouchInputMapper.cpp
@@ -237,7 +237,6 @@ void TouchInputMapper::populateDeviceInfo(InputDeviceInfo& info) {
     if (mCursorScrollAccumulator.haveRelativeHWheel()) {
         info.addMotionRange(AMOTION_EVENT_AXIS_HSCROLL, mSource, -1.0f, 1.0f, 0.0f, 0.0f, 0.0f);
     }
-    info.setButtonUnderPad(mParameters.hasButtonUnderPad);
     info.setUsiVersion(mParameters.usiVersion);
 }
 
@@ -408,25 +407,7 @@ void TouchInputMapper::resolveExternalStylusPresence() {
 TouchInputMapper::Parameters TouchInputMapper::computeParameters(
         const InputDeviceContext& deviceContext) {
     Parameters parameters;
-    // Use the pointer presentation mode for devices that do not support distinct
-    // multitouch.  The spot-based presentation relies on being able to accurately
-    // locate two or more fingers on the touch pad.
-    parameters.gestureMode = deviceContext.hasInputProperty(INPUT_PROP_SEMI_MT)
-            ? Parameters::GestureMode::SINGLE_TOUCH
-            : Parameters::GestureMode::MULTI_TOUCH;
-
     const PropertyMap& config = deviceContext.getConfiguration();
-    std::optional<std::string> gestureModeString = config.getString("touch.gestureMode");
-    if (gestureModeString.has_value()) {
-        if (*gestureModeString == "single-touch") {
-            parameters.gestureMode = Parameters::GestureMode::SINGLE_TOUCH;
-        } else if (*gestureModeString == "multi-touch") {
-            parameters.gestureMode = Parameters::GestureMode::MULTI_TOUCH;
-        } else if (*gestureModeString != "default") {
-            ALOGW("Invalid value for touch.gestureMode: '%s'", gestureModeString->c_str());
-        }
-    }
-
     parameters.deviceType = computeDeviceType(deviceContext);
 
     parameters.hasButtonUnderPad = deviceContext.hasInputProperty(INPUT_PROP_BUTTONPAD);
@@ -523,8 +504,6 @@ TouchInputMapper::Parameters::DeviceType TouchInputMapper::computeDeviceType(
 void TouchInputMapper::dumpParameters(std::string& dump) {
     dump += INDENT3 "Parameters:\n";
 
-    dump += INDENT4 "GestureMode: " + ftl::enum_string(mParameters.gestureMode) + "\n";
-
     dump += INDENT4 "DeviceType: " + ftl::enum_string(mParameters.deviceType) + "\n";
 
     dump += StringPrintf(INDENT4 "AssociatedDisplay: hasAssociatedDisplay=%s, isExternal=%s, "
@@ -1991,7 +1970,7 @@ std::list<NotifyArgs> TouchInputMapper::abortTouches(
         out.push_back(dispatchMotion(when, readTime, policyFlags, mSource,
                                      currentGestureDisplayId.value_or(resolveDisplayId()),
                                      AMOTION_EVENT_ACTION_CANCEL, 0, AMOTION_EVENT_FLAG_CANCELED,
-                                     metaState, buttonState, AMOTION_EVENT_EDGE_FLAG_NONE,
+                                     metaState, buttonState,
                                      mCurrentCookedState.cookedPointerData.pointerProperties,
                                      mCurrentCookedState.cookedPointerData.pointerCoords,
                                      mCurrentCookedState.cookedPointerData.idToIndex, currentIdBits,
@@ -2046,7 +2025,6 @@ std::list<NotifyArgs> TouchInputMapper::dispatchTouches(nsecs_t when, nsecs_t re
             // The listener takes care of batching moves so we don't have to deal with that here.
             out.push_back(dispatchMotion(when, readTime, policyFlags, mSource, resolveDisplayId(),
                                          AMOTION_EVENT_ACTION_MOVE, 0, 0, metaState, buttonState,
-                                         AMOTION_EVENT_EDGE_FLAG_NONE,
                                          mCurrentCookedState.cookedPointerData.pointerProperties,
                                          mCurrentCookedState.cookedPointerData.pointerCoords,
                                          mCurrentCookedState.cookedPointerData.idToIndex,
@@ -2085,7 +2063,7 @@ std::list<NotifyArgs> TouchInputMapper::dispatchTouches(nsecs_t when, nsecs_t re
             out.push_back(dispatchMotion(when, readTime, policyFlags, mSource, resolveDisplayId(),
                                          AMOTION_EVENT_ACTION_POINTER_UP, 0,
                                          isCanceled ? AMOTION_EVENT_FLAG_CANCELED : 0, metaState,
-                                         buttonState, 0,
+                                         buttonState,
                                          mLastCookedState.cookedPointerData.pointerProperties,
                                          mLastCookedState.cookedPointerData.pointerCoords,
                                          mLastCookedState.cookedPointerData.idToIndex,
@@ -2102,7 +2080,7 @@ std::list<NotifyArgs> TouchInputMapper::dispatchTouches(nsecs_t when, nsecs_t re
         if (moveNeeded && !moveIdBits.isEmpty()) {
             ALOG_ASSERT(moveIdBits.value == dispatchedIdBits.value);
             out.push_back(dispatchMotion(when, readTime, policyFlags, mSource, resolveDisplayId(),
-                                         AMOTION_EVENT_ACTION_MOVE, 0, 0, metaState, buttonState, 0,
+                                         AMOTION_EVENT_ACTION_MOVE, 0, 0, metaState, buttonState,
                                          mCurrentCookedState.cookedPointerData.pointerProperties,
                                          mCurrentCookedState.cookedPointerData.pointerCoords,
                                          mCurrentCookedState.cookedPointerData.idToIndex,
@@ -2124,7 +2102,7 @@ std::list<NotifyArgs> TouchInputMapper::dispatchTouches(nsecs_t when, nsecs_t re
             out.push_back(
                     dispatchMotion(when, readTime, policyFlags, mSource, resolveDisplayId(),
                                    AMOTION_EVENT_ACTION_POINTER_DOWN, 0, 0, metaState, buttonState,
-                                   0, mCurrentCookedState.cookedPointerData.pointerProperties,
+                                   mCurrentCookedState.cookedPointerData.pointerProperties,
                                    mCurrentCookedState.cookedPointerData.pointerCoords,
                                    mCurrentCookedState.cookedPointerData.idToIndex,
                                    dispatchedIdBits, downId, mOrientedXPrecision,
@@ -2143,7 +2121,7 @@ std::list<NotifyArgs> TouchInputMapper::dispatchHoverExit(nsecs_t when, nsecs_t
         int32_t metaState = getContext()->getGlobalMetaState();
         out.push_back(dispatchMotion(when, readTime, policyFlags, mSource, resolveDisplayId(),
                                      AMOTION_EVENT_ACTION_HOVER_EXIT, 0, 0, metaState,
-                                     mLastCookedState.buttonState, 0,
+                                     mLastCookedState.buttonState,
                                      mLastCookedState.cookedPointerData.pointerProperties,
                                      mLastCookedState.cookedPointerData.pointerCoords,
                                      mLastCookedState.cookedPointerData.idToIndex,
@@ -2164,7 +2142,7 @@ std::list<NotifyArgs> TouchInputMapper::dispatchHoverEnterAndMove(nsecs_t when,
         if (!mSentHoverEnter) {
             out.push_back(dispatchMotion(when, readTime, policyFlags, mSource, resolveDisplayId(),
                                          AMOTION_EVENT_ACTION_HOVER_ENTER, 0, 0, metaState,
-                                         mCurrentRawState.buttonState, 0,
+                                         mCurrentRawState.buttonState,
                                          mCurrentCookedState.cookedPointerData.pointerProperties,
                                          mCurrentCookedState.cookedPointerData.pointerCoords,
                                          mCurrentCookedState.cookedPointerData.idToIndex,
@@ -2176,7 +2154,7 @@ std::list<NotifyArgs> TouchInputMapper::dispatchHoverEnterAndMove(nsecs_t when,
 
         out.push_back(dispatchMotion(when, readTime, policyFlags, mSource, resolveDisplayId(),
                                      AMOTION_EVENT_ACTION_HOVER_MOVE, 0, 0, metaState,
-                                     mCurrentRawState.buttonState, 0,
+                                     mCurrentRawState.buttonState,
                                      mCurrentCookedState.cookedPointerData.pointerProperties,
                                      mCurrentCookedState.cookedPointerData.pointerCoords,
                                      mCurrentCookedState.cookedPointerData.idToIndex,
@@ -2199,7 +2177,7 @@ std::list<NotifyArgs> TouchInputMapper::dispatchButtonRelease(nsecs_t when, nsec
         buttonState &= ~actionButton;
         out.push_back(dispatchMotion(when, readTime, policyFlags, mSource, resolveDisplayId(),
                                      AMOTION_EVENT_ACTION_BUTTON_RELEASE, actionButton, 0,
-                                     metaState, buttonState, 0,
+                                     metaState, buttonState,
                                      mLastCookedState.cookedPointerData.pointerProperties,
                                      mLastCookedState.cookedPointerData.pointerCoords,
                                      mLastCookedState.cookedPointerData.idToIndex, idBits, -1,
@@ -2221,7 +2199,7 @@ std::list<NotifyArgs> TouchInputMapper::dispatchButtonPress(nsecs_t when, nsecs_
         buttonState |= actionButton;
         out.push_back(dispatchMotion(when, readTime, policyFlags, mSource, resolveDisplayId(),
                                      AMOTION_EVENT_ACTION_BUTTON_PRESS, actionButton, 0, metaState,
-                                     buttonState, 0,
+                                     buttonState,
                                      mCurrentCookedState.cookedPointerData.pointerProperties,
                                      mCurrentCookedState.cookedPointerData.pointerCoords,
                                      mCurrentCookedState.cookedPointerData.idToIndex, idBits, -1,
@@ -2245,8 +2223,7 @@ std::list<NotifyArgs> TouchInputMapper::dispatchGestureButtonRelease(nsecs_t whe
         buttonState &= ~actionButton;
         out.push_back(dispatchMotion(when, readTime, policyFlags, mSource, resolveDisplayId(),
                                      AMOTION_EVENT_ACTION_BUTTON_RELEASE, actionButton, 0,
-                                     metaState, buttonState, 0,
-                                     mPointerGesture.lastGestureProperties,
+                                     metaState, buttonState, mPointerGesture.lastGestureProperties,
                                      mPointerGesture.lastGestureCoords,
                                      mPointerGesture.lastGestureIdToIndex, idBits, -1,
                                      mOrientedXPrecision, mOrientedYPrecision,
@@ -2269,7 +2246,7 @@ std::list<NotifyArgs> TouchInputMapper::dispatchGestureButtonPress(nsecs_t when,
         buttonState |= actionButton;
         out.push_back(dispatchMotion(when, readTime, policyFlags, mSource, resolveDisplayId(),
                                      AMOTION_EVENT_ACTION_BUTTON_PRESS, actionButton, 0, metaState,
-                                     buttonState, 0, mPointerGesture.currentGestureProperties,
+                                     buttonState, mPointerGesture.currentGestureProperties,
                                      mPointerGesture.currentGestureCoords,
                                      mPointerGesture.currentGestureIdToIndex, idBits, -1,
                                      mOrientedXPrecision, mOrientedYPrecision,
@@ -2617,8 +2594,7 @@ std::list<NotifyArgs> TouchInputMapper::dispatchPointerGestures(nsecs_t when, ns
             const uint32_t cancelFlags = flags | AMOTION_EVENT_FLAG_CANCELED;
             out.push_back(dispatchMotion(when, readTime, policyFlags, mSource, resolveDisplayId(),
                                          AMOTION_EVENT_ACTION_CANCEL, 0, cancelFlags, metaState,
-                                         buttonState, AMOTION_EVENT_EDGE_FLAG_NONE,
-                                         mPointerGesture.lastGestureProperties,
+                                         buttonState, mPointerGesture.lastGestureProperties,
                                          mPointerGesture.lastGestureCoords,
                                          mPointerGesture.lastGestureIdToIndex,
                                          dispatchedGestureIdBits, -1, 0, 0,
@@ -2644,7 +2620,6 @@ std::list<NotifyArgs> TouchInputMapper::dispatchPointerGestures(nsecs_t when, ns
                 out.push_back(dispatchMotion(when, readTime, policyFlags, mSource,
                                              resolveDisplayId(), AMOTION_EVENT_ACTION_POINTER_UP, 0,
                                              flags, metaState, buttonState,
-                                             AMOTION_EVENT_EDGE_FLAG_NONE,
                                              mPointerGesture.lastGestureProperties,
                                              mPointerGesture.lastGestureCoords,
                                              mPointerGesture.lastGestureIdToIndex,
@@ -2660,7 +2635,6 @@ std::list<NotifyArgs> TouchInputMapper::dispatchPointerGestures(nsecs_t when, ns
     if (moveNeeded) {
         out.push_back(dispatchMotion(when, readTime, policyFlags, mSource, resolveDisplayId(),
                                      AMOTION_EVENT_ACTION_MOVE, 0, flags, metaState, buttonState,
-                                     AMOTION_EVENT_EDGE_FLAG_NONE,
                                      mPointerGesture.currentGestureProperties,
                                      mPointerGesture.currentGestureCoords,
                                      mPointerGesture.currentGestureIdToIndex,
@@ -2682,7 +2656,7 @@ std::list<NotifyArgs> TouchInputMapper::dispatchPointerGestures(nsecs_t when, ns
 
             out.push_back(dispatchMotion(when, readTime, policyFlags, mSource, resolveDisplayId(),
                                          AMOTION_EVENT_ACTION_POINTER_DOWN, 0, flags, metaState,
-                                         buttonState, 0, mPointerGesture.currentGestureProperties,
+                                         buttonState, mPointerGesture.currentGestureProperties,
                                          mPointerGesture.currentGestureCoords,
                                          mPointerGesture.currentGestureIdToIndex,
                                          dispatchedGestureIdBits, id, 0, 0,
@@ -2700,8 +2674,7 @@ std::list<NotifyArgs> TouchInputMapper::dispatchPointerGestures(nsecs_t when, ns
     if (mPointerGesture.currentGestureMode == PointerGesture::Mode::HOVER) {
         out.push_back(dispatchMotion(when, readTime, policyFlags, mSource, resolveDisplayId(),
                                      AMOTION_EVENT_ACTION_HOVER_MOVE, 0, flags, metaState,
-                                     buttonState, AMOTION_EVENT_EDGE_FLAG_NONE,
-                                     mPointerGesture.currentGestureProperties,
+                                     buttonState, mPointerGesture.currentGestureProperties,
                                      mPointerGesture.currentGestureCoords,
                                      mPointerGesture.currentGestureIdToIndex,
                                      mPointerGesture.currentGestureIdBits, -1, 0, 0,
@@ -2722,10 +2695,9 @@ std::list<NotifyArgs> TouchInputMapper::dispatchPointerGestures(nsecs_t when, ns
         out.push_back(NotifyMotionArgs(getContext()->getNextId(), when, readTime, getDeviceId(),
                                        mSource, ui::LogicalDisplayId::INVALID, policyFlags,
                                        AMOTION_EVENT_ACTION_HOVER_MOVE, 0, flags, metaState,
-                                       buttonState, MotionClassification::NONE,
-                                       AMOTION_EVENT_EDGE_FLAG_NONE, 1, &pointerProperties,
-                                       &pointerCoords, 0, 0, 0.f, 0.f, mPointerGesture.downTime,
-                                       /*videoFrames=*/{}));
+                                       buttonState, MotionClassification::NONE, 1,
+                                       &pointerProperties, &pointerCoords, 0, 0, 0.f, 0.f,
+                                       mPointerGesture.downTime, /*videoFrames=*/{}));
     }
 
     // Update state.
@@ -2759,8 +2731,7 @@ std::list<NotifyArgs> TouchInputMapper::abortPointerGestures(nsecs_t when, nsecs
         int32_t buttonState = mCurrentRawState.buttonState;
         out.push_back(dispatchMotion(when, readTime, policyFlags, mSource, resolveDisplayId(),
                                      AMOTION_EVENT_ACTION_CANCEL, 0, AMOTION_EVENT_FLAG_CANCELED,
-                                     metaState, buttonState, AMOTION_EVENT_EDGE_FLAG_NONE,
-                                     mPointerGesture.lastGestureProperties,
+                                     metaState, buttonState, mPointerGesture.lastGestureProperties,
                                      mPointerGesture.lastGestureCoords,
                                      mPointerGesture.lastGestureIdToIndex,
                                      mPointerGesture.lastGestureIdBits, -1, 0, 0,
@@ -3580,7 +3551,7 @@ std::list<NotifyArgs> TouchInputMapper::dispatchPointerSimple(nsecs_t when, nsec
         out.push_back(NotifyMotionArgs(getContext()->getNextId(), when, readTime, getDeviceId(),
                                        mSource, displayId, policyFlags, AMOTION_EVENT_ACTION_UP, 0,
                                        0, metaState, mLastRawState.buttonState,
-                                       MotionClassification::NONE, AMOTION_EVENT_EDGE_FLAG_NONE, 1,
+                                       MotionClassification::NONE, 1,
                                        &mPointerSimple.lastProperties, &mPointerSimple.lastCoords,
                                        mOrientedXPrecision, mOrientedYPrecision,
                                        mPointerSimple.lastCursorX, mPointerSimple.lastCursorY,
@@ -3596,11 +3567,10 @@ std::list<NotifyArgs> TouchInputMapper::dispatchPointerSimple(nsecs_t when, nsec
                 NotifyMotionArgs(getContext()->getNextId(), when, readTime, getDeviceId(), mSource,
                                  displayId, policyFlags, AMOTION_EVENT_ACTION_HOVER_EXIT, 0, 0,
                                  metaState, mLastRawState.buttonState, MotionClassification::NONE,
-                                 AMOTION_EVENT_EDGE_FLAG_NONE, 1, &mPointerSimple.lastProperties,
-                                 &mPointerSimple.lastCoords, mOrientedXPrecision,
-                                 mOrientedYPrecision, mPointerSimple.lastCursorX,
-                                 mPointerSimple.lastCursorY, mPointerSimple.downTime,
-                                 /*videoFrames=*/{}));
+                                 1, &mPointerSimple.lastProperties, &mPointerSimple.lastCoords,
+                                 mOrientedXPrecision, mOrientedYPrecision,
+                                 mPointerSimple.lastCursorX, mPointerSimple.lastCursorY,
+                                 mPointerSimple.downTime, /*videoFrames=*/{}));
     }
 
     if (down) {
@@ -3613,8 +3583,7 @@ std::list<NotifyArgs> TouchInputMapper::dispatchPointerSimple(nsecs_t when, nsec
                                            mSource, displayId, policyFlags,
                                            AMOTION_EVENT_ACTION_DOWN, 0, 0, metaState,
                                            mCurrentRawState.buttonState, MotionClassification::NONE,
-                                           AMOTION_EVENT_EDGE_FLAG_NONE, 1,
-                                           &mPointerSimple.currentProperties,
+                                           1, &mPointerSimple.currentProperties,
                                            &mPointerSimple.currentCoords, mOrientedXPrecision,
                                            mOrientedYPrecision, cursorPosition.x, cursorPosition.y,
                                            mPointerSimple.downTime, /*videoFrames=*/{}));
@@ -3624,7 +3593,7 @@ std::list<NotifyArgs> TouchInputMapper::dispatchPointerSimple(nsecs_t when, nsec
         out.push_back(NotifyMotionArgs(getContext()->getNextId(), when, readTime, getDeviceId(),
                                        mSource, displayId, policyFlags, AMOTION_EVENT_ACTION_MOVE,
                                        0, 0, metaState, mCurrentRawState.buttonState,
-                                       MotionClassification::NONE, AMOTION_EVENT_EDGE_FLAG_NONE, 1,
+                                       MotionClassification::NONE, 1,
                                        &mPointerSimple.currentProperties,
                                        &mPointerSimple.currentCoords, mOrientedXPrecision,
                                        mOrientedYPrecision, cursorPosition.x, cursorPosition.y,
@@ -3640,8 +3609,7 @@ std::list<NotifyArgs> TouchInputMapper::dispatchPointerSimple(nsecs_t when, nsec
                                            mSource, displayId, policyFlags,
                                            AMOTION_EVENT_ACTION_HOVER_ENTER, 0, 0, metaState,
                                            mCurrentRawState.buttonState, MotionClassification::NONE,
-                                           AMOTION_EVENT_EDGE_FLAG_NONE, 1,
-                                           &mPointerSimple.currentProperties,
+                                           1, &mPointerSimple.currentProperties,
                                            &mPointerSimple.currentCoords, mOrientedXPrecision,
                                            mOrientedYPrecision, cursorPosition.x, cursorPosition.y,
                                            mPointerSimple.downTime, /*videoFrames=*/{}));
@@ -3652,10 +3620,10 @@ std::list<NotifyArgs> TouchInputMapper::dispatchPointerSimple(nsecs_t when, nsec
                 NotifyMotionArgs(getContext()->getNextId(), when, readTime, getDeviceId(), mSource,
                                  displayId, policyFlags, AMOTION_EVENT_ACTION_HOVER_MOVE, 0, 0,
                                  metaState, mCurrentRawState.buttonState,
-                                 MotionClassification::NONE, AMOTION_EVENT_EDGE_FLAG_NONE, 1,
-                                 &mPointerSimple.currentProperties, &mPointerSimple.currentCoords,
-                                 mOrientedXPrecision, mOrientedYPrecision, cursorPosition.x,
-                                 cursorPosition.y, mPointerSimple.downTime, /*videoFrames=*/{}));
+                                 MotionClassification::NONE, 1, &mPointerSimple.currentProperties,
+                                 &mPointerSimple.currentCoords, mOrientedXPrecision,
+                                 mOrientedYPrecision, cursorPosition.x, cursorPosition.y,
+                                 mPointerSimple.downTime, /*videoFrames=*/{}));
     }
 
     if (mCurrentRawState.rawVScroll || mCurrentRawState.rawHScroll) {
@@ -3672,7 +3640,7 @@ std::list<NotifyArgs> TouchInputMapper::dispatchPointerSimple(nsecs_t when, nsec
         out.push_back(NotifyMotionArgs(getContext()->getNextId(), when, readTime, getDeviceId(),
                                        mSource, displayId, policyFlags, AMOTION_EVENT_ACTION_SCROLL,
                                        0, 0, metaState, mCurrentRawState.buttonState,
-                                       MotionClassification::NONE, AMOTION_EVENT_EDGE_FLAG_NONE, 1,
+                                       MotionClassification::NONE, 1,
                                        &mPointerSimple.currentProperties, &pointerCoords,
                                        mOrientedXPrecision, mOrientedYPrecision, cursorPosition.x,
                                        cursorPosition.y, mPointerSimple.downTime,
@@ -3702,7 +3670,7 @@ std::list<NotifyArgs> TouchInputMapper::abortPointerSimple(nsecs_t when, nsecs_t
                                        mPointerSimple.source, mPointerSimple.displayId, policyFlags,
                                        AMOTION_EVENT_ACTION_CANCEL, 0, AMOTION_EVENT_FLAG_CANCELED,
                                        metaState, mLastRawState.buttonState,
-                                       MotionClassification::NONE, AMOTION_EVENT_EDGE_FLAG_NONE, 1,
+                                       MotionClassification::NONE, 1,
                                        &mPointerSimple.lastProperties, &mPointerSimple.lastCoords,
                                        mOrientedXPrecision, mOrientedYPrecision,
                                        mPointerSimple.lastCursorX, mPointerSimple.lastCursorY,
@@ -3716,10 +3684,10 @@ std::list<NotifyArgs> TouchInputMapper::abortPointerSimple(nsecs_t when, nsecs_t
 NotifyMotionArgs TouchInputMapper::dispatchMotion(
         nsecs_t when, nsecs_t readTime, uint32_t policyFlags, uint32_t source,
         ui::LogicalDisplayId displayId, int32_t action, int32_t actionButton, int32_t flags,
-        int32_t metaState, int32_t buttonState, int32_t edgeFlags,
-        const PropertiesArray& properties, const CoordsArray& coords,
-        const IdToIndexArray& idToIndex, BitSet32 idBits, int32_t changedId, float xPrecision,
-        float yPrecision, nsecs_t downTime, MotionClassification classification) const {
+        int32_t metaState, int32_t buttonState, const PropertiesArray& properties,
+        const CoordsArray& coords, const IdToIndexArray& idToIndex, BitSet32 idBits,
+        int32_t changedId, float xPrecision, float yPrecision, nsecs_t downTime,
+        MotionClassification classification) const {
     std::vector<PointerCoords> pointerCoords;
     std::vector<PointerProperties> pointerProperties;
     uint32_t pointerCount = 0;
@@ -3781,7 +3749,7 @@ NotifyMotionArgs TouchInputMapper::dispatchMotion(
                   [this](TouchVideoFrame& frame) { frame.rotate(this->mInputDeviceOrientation); });
     return NotifyMotionArgs(getContext()->getNextId(), when, readTime, deviceId, source, displayId,
                             policyFlags, action, actionButton, flags, metaState, buttonState,
-                            classification, edgeFlags, pointerCount, pointerProperties.data(),
+                            classification, pointerCount, pointerProperties.data(),
                             pointerCoords.data(), xPrecision, yPrecision, xCursorPosition,
                             yCursorPosition, downTime, std::move(frames));
 }
@@ -3853,6 +3821,11 @@ void TouchInputMapper::assignPointerIds(const RawState& last, RawState& current)
     // match (by distance) for each current pointer.
     // The pointers must have the same tool type but it is possible for them to
     // transition from hovering to touching or vice-versa while retaining the same id.
+    struct PointerDistanceHeapElement {
+        uint32_t currentPointerIndex : 8 {};
+        uint32_t lastPointerIndex : 8 {};
+        uint64_t distanceSq : 48 {};
+    };
     PointerDistanceHeapElement heap[MAX_POINTERS * MAX_POINTERS];
 
     uint32_t heapSize = 0;
@@ -3868,12 +3841,12 @@ void TouchInputMapper::assignPointerIds(const RawState& last, RawState& current)
                 int64_t deltaX = currentPointer.x - lastPointer.x;
                 int64_t deltaY = currentPointer.y - lastPointer.y;
 
-                uint64_t distance = uint64_t(deltaX * deltaX + deltaY * deltaY);
+                uint64_t distanceSq = uint64_t(deltaX * deltaX + deltaY * deltaY);
 
                 // Insert new element into the heap (sift up).
                 heap[heapSize].currentPointerIndex = currentPointerIndex;
                 heap[heapSize].lastPointerIndex = lastPointerIndex;
-                heap[heapSize].distance = distance;
+                heap[heapSize].distanceSq = distanceSq;
                 heapSize += 1;
             }
         }
@@ -3889,11 +3862,11 @@ void TouchInputMapper::assignPointerIds(const RawState& last, RawState& current)
             }
 
             if (childIndex + 1 < heapSize &&
-                heap[childIndex + 1].distance < heap[childIndex].distance) {
+                heap[childIndex + 1].distanceSq < heap[childIndex].distanceSq) {
                 childIndex += 1;
             }
 
-            if (heap[parentIndex].distance <= heap[childIndex].distance) {
+            if (heap[parentIndex].distanceSq <= heap[childIndex].distanceSq) {
                 break;
             }
 
@@ -3906,7 +3879,7 @@ void TouchInputMapper::assignPointerIds(const RawState& last, RawState& current)
         ALOGD("assignPointerIds - initial distance min-heap: size=%d", heapSize);
         for (size_t i = 0; i < heapSize; i++) {
             ALOGD("  heap[%zu]: cur=%" PRIu32 ", last=%" PRIu32 ", distance=%" PRIu64, i,
-                  heap[i].currentPointerIndex, heap[i].lastPointerIndex, heap[i].distance);
+                  heap[i].currentPointerIndex, heap[i].lastPointerIndex, heap[i].distanceSq);
         }
     }
 
@@ -3935,11 +3908,11 @@ void TouchInputMapper::assignPointerIds(const RawState& last, RawState& current)
                     }
 
                     if (childIndex + 1 < heapSize &&
-                        heap[childIndex + 1].distance < heap[childIndex].distance) {
+                        heap[childIndex + 1].distanceSq < heap[childIndex].distanceSq) {
                         childIndex += 1;
                     }
 
-                    if (heap[parentIndex].distance <= heap[childIndex].distance) {
+                    if (heap[parentIndex].distanceSq <= heap[childIndex].distanceSq) {
                         break;
                     }
 
@@ -3952,7 +3925,7 @@ void TouchInputMapper::assignPointerIds(const RawState& last, RawState& current)
                     for (size_t j = 0; j < heapSize; j++) {
                         ALOGD("  heap[%zu]: cur=%" PRIu32 ", last=%" PRIu32 ", distance=%" PRIu64,
                               j, heap[j].currentPointerIndex, heap[j].lastPointerIndex,
-                              heap[j].distance);
+                              heap[j].distanceSq);
                     }
                 }
             }
@@ -3978,8 +3951,8 @@ void TouchInputMapper::assignPointerIds(const RawState& last, RawState& current)
 
             ALOGD_IF(DEBUG_POINTER_ASSIGNMENT,
                      "assignPointerIds - matched: cur=%" PRIu32 ", last=%" PRIu32 ", id=%" PRIu32
-                     ", distance=%" PRIu64,
-                     lastPointerIndex, currentPointerIndex, id, heap[0].distance);
+                     ", distanceSq=%" PRIu64,
+                     lastPointerIndex, currentPointerIndex, id, heap[0].distanceSq);
             break;
         }
     }
diff --git a/services/inputflinger/reader/mapper/TouchInputMapper.h b/services/inputflinger/reader/mapper/TouchInputMapper.h
index 45fc6bfa36..5612479d71 100644
--- a/services/inputflinger/reader/mapper/TouchInputMapper.h
+++ b/services/inputflinger/reader/mapper/TouchInputMapper.h
@@ -247,14 +247,6 @@ protected:
         bool hasButtonUnderPad;
         std::string uniqueDisplayId;
 
-        enum class GestureMode {
-            SINGLE_TOUCH,
-            MULTI_TOUCH,
-
-            ftl_last = MULTI_TOUCH
-        };
-        GestureMode gestureMode;
-
         bool wake;
 
         // The Universal Stylus Initiative (USI) protocol version supported by this device.
@@ -532,12 +524,6 @@ private:
     // into freeform gestures.
     float mPointerGestureMaxSwipeWidth;
 
-    struct PointerDistanceHeapElement {
-        uint32_t currentPointerIndex : 8 {};
-        uint32_t lastPointerIndex : 8 {};
-        uint64_t distance : 48 {}; // squared distance
-    };
-
     enum class PointerUsage {
         NONE,
         GESTURES,
@@ -841,10 +827,10 @@ private:
     [[nodiscard]] NotifyMotionArgs dispatchMotion(
             nsecs_t when, nsecs_t readTime, uint32_t policyFlags, uint32_t source,
             ui::LogicalDisplayId displayId, int32_t action, int32_t actionButton, int32_t flags,
-            int32_t metaState, int32_t buttonState, int32_t edgeFlags,
-            const PropertiesArray& properties, const CoordsArray& coords,
-            const IdToIndexArray& idToIndex, BitSet32 idBits, int32_t changedId, float xPrecision,
-            float yPrecision, nsecs_t downTime, MotionClassification classification) const;
+            int32_t metaState, int32_t buttonState, const PropertiesArray& properties,
+            const CoordsArray& coords, const IdToIndexArray& idToIndex, BitSet32 idBits,
+            int32_t changedId, float xPrecision, float yPrecision, nsecs_t downTime,
+            MotionClassification classification) const;
 
     // Returns if this touch device is a touch screen with an associated display.
     bool isTouchScreen();
diff --git a/services/inputflinger/reader/mapper/TouchpadInputMapper.cpp b/services/inputflinger/reader/mapper/TouchpadInputMapper.cpp
index 63eb357bdb..1c9993b2f8 100644
--- a/services/inputflinger/reader/mapper/TouchpadInputMapper.cpp
+++ b/services/inputflinger/reader/mapper/TouchpadInputMapper.cpp
@@ -34,8 +34,7 @@
 #include <input/PrintTools.h>
 #include <linux/input-event-codes.h>
 #include <log/log_main.h>
-#include <stats_pull_atom_callback.h>
-#include <statslog.h>
+#include <statslog_inputflinger.h>
 #include "InputReaderBase.h"
 #include "TouchCursorInputMapperCommon.h"
 #include "TouchpadInputMapper.h"
@@ -107,7 +106,7 @@ int32_t linuxBusToInputDeviceBusEnum(int32_t linuxBus, bool isUsiStylus) {
     if (isUsiStylus) {
         // This is a stylus connected over the Universal Stylus Initiative (USI) protocol.
         // For metrics purposes, we treat this protocol as a separate bus.
-        return util::INPUT_DEVICE_USAGE_REPORTED__DEVICE_BUS__USI;
+        return inputflinger::stats::INPUT_DEVICE_USAGE_REPORTED__DEVICE_BUS__USI;
     }
 
     // When adding cases to this switch, also add them to the copy of this method in
@@ -115,11 +114,11 @@ int32_t linuxBusToInputDeviceBusEnum(int32_t linuxBus, bool isUsiStylus) {
     // TODO(b/286394420): deduplicate this method with the one in InputDeviceMetricsCollector.cpp.
     switch (linuxBus) {
         case BUS_USB:
-            return util::INPUT_DEVICE_USAGE_REPORTED__DEVICE_BUS__USB;
+            return inputflinger::stats::INPUT_DEVICE_USAGE_REPORTED__DEVICE_BUS__USB;
         case BUS_BLUETOOTH:
-            return util::INPUT_DEVICE_USAGE_REPORTED__DEVICE_BUS__BLUETOOTH;
+            return inputflinger::stats::INPUT_DEVICE_USAGE_REPORTED__DEVICE_BUS__BLUETOOTH;
         default:
-            return util::INPUT_DEVICE_USAGE_REPORTED__DEVICE_BUS__OTHER;
+            return inputflinger::stats::INPUT_DEVICE_USAGE_REPORTED__DEVICE_BUS__OTHER;
     }
 }
 
@@ -181,16 +180,19 @@ public:
 
 private:
     MetricsAccumulator() {
-        AStatsManager_setPullAtomCallback(android::util::TOUCHPAD_USAGE, /*metadata=*/nullptr,
+        AStatsManager_setPullAtomCallback(android::inputflinger::stats::TOUCHPAD_USAGE,
+                                          /*metadata=*/nullptr,
                                           MetricsAccumulator::pullAtomCallback, /*cookie=*/nullptr);
     }
 
-    ~MetricsAccumulator() { AStatsManager_clearPullAtomCallback(android::util::TOUCHPAD_USAGE); }
+    ~MetricsAccumulator() {
+        AStatsManager_clearPullAtomCallback(android::inputflinger::stats::TOUCHPAD_USAGE);
+    }
 
     static AStatsManager_PullAtomCallbackReturn pullAtomCallback(int32_t atomTag,
                                                                  AStatsEventList* outEventList,
                                                                  void* cookie) {
-        LOG_ALWAYS_FATAL_IF(atomTag != android::util::TOUCHPAD_USAGE);
+        LOG_ALWAYS_FATAL_IF(atomTag != android::inputflinger::stats::TOUCHPAD_USAGE);
         MetricsAccumulator& accumulator = MetricsAccumulator::getInstance();
         accumulator.produceAtomsAndReset(*outEventList);
         return AStatsManager_PULL_SUCCESS;
@@ -205,9 +207,10 @@ private:
     void produceAtomsLocked(AStatsEventList& outEventList) const REQUIRES(mLock) {
         for (auto& [id, counters] : mCounters) {
             auto [busId, vendorId, productId, versionId] = id;
-            addAStatsEvent(&outEventList, android::util::TOUCHPAD_USAGE, vendorId, productId,
-                           versionId, linuxBusToInputDeviceBusEnum(busId, /*isUsi=*/false),
-                           counters.fingers, counters.palms, counters.twoFingerSwipeGestures,
+            addAStatsEvent(&outEventList, android::inputflinger::stats::TOUCHPAD_USAGE, vendorId,
+                           productId, versionId,
+                           linuxBusToInputDeviceBusEnum(busId, /*isUsi=*/false), counters.fingers,
+                           counters.palms, counters.twoFingerSwipeGestures,
                            counters.threeFingerSwipeGestures, counters.fourFingerSwipeGestures,
                            counters.pinchGestures);
         }
diff --git a/services/inputflinger/reader/mapper/gestures/GestureConverter.cpp b/services/inputflinger/reader/mapper/gestures/GestureConverter.cpp
index 3255877cf1..95caafb107 100644
--- a/services/inputflinger/reader/mapper/gestures/GestureConverter.cpp
+++ b/services/inputflinger/reader/mapper/gestures/GestureConverter.cpp
@@ -82,7 +82,6 @@ GestureConverter::GestureConverter(InputReaderContext& readerContext,
                                    const InputDeviceContext& deviceContext, int32_t deviceId)
       : mDeviceId(deviceId),
         mReaderContext(readerContext),
-        mEnableNoFocusChange(input_flags::enable_touchpad_no_focus_change()),
         // We can safely assume that ABS_MT_POSITION_X and _Y axes will be available, as EventHub
         // won't classify a device as a touchpad if they're not present.
         mXAxisInfo(deviceContext.getAbsoluteAxisInfo(ABS_MT_POSITION_X).value()),
@@ -690,7 +689,7 @@ NotifyMotionArgs GestureConverter::makeMotionArgs(nsecs_t when, nsecs_t readTime
     if (action == AMOTION_EVENT_ACTION_CANCEL) {
         flags |= AMOTION_EVENT_FLAG_CANCELED;
     }
-    if (mEnableNoFocusChange && isGestureNoFocusChange(mCurrentClassification)) {
+    if (isGestureNoFocusChange(mCurrentClassification)) {
         flags |= AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE;
     }
     if (mCurrentClassification == MotionClassification::TWO_FINGER_SWIPE) {
@@ -711,7 +710,6 @@ NotifyMotionArgs GestureConverter::makeMotionArgs(nsecs_t when, nsecs_t readTime
             mReaderContext.getGlobalMetaState(),
             buttonState,
             mCurrentClassification,
-            AMOTION_EVENT_EDGE_FLAG_NONE,
             pointerCount,
             mFingerProps.data(),
             pointerCoords,
diff --git a/services/inputflinger/reader/mapper/gestures/GestureConverter.h b/services/inputflinger/reader/mapper/gestures/GestureConverter.h
index ae85e3a4ff..0dd3b82831 100644
--- a/services/inputflinger/reader/mapper/gestures/GestureConverter.h
+++ b/services/inputflinger/reader/mapper/gestures/GestureConverter.h
@@ -106,7 +106,6 @@ private:
 
     const int32_t mDeviceId;
     InputReaderContext& mReaderContext;
-    const bool mEnableNoFocusChange;
     bool mEnableSystemGestures{true};
 
     bool mThreeFingerTapShortcutEnabled{false};
diff --git a/services/inputflinger/tests/Android.bp b/services/inputflinger/tests/Android.bp
index 677cf1e6c4..f350408686 100644
--- a/services/inputflinger/tests/Android.bp
+++ b/services/inputflinger/tests/Android.bp
@@ -134,4 +134,8 @@ cc_test {
         "device-tests",
     ],
     native_coverage: false,
+    device_first_data: [
+        ":keychars_test_data",
+        ":keylayout_test_data",
+    ],
 }
diff --git a/services/inputflinger/tests/AndroidInputEventProtoConverter_test.cpp b/services/inputflinger/tests/AndroidInputEventProtoConverter_test.cpp
index 1fd6cee1eb..1f3f8b80d2 100644
--- a/services/inputflinger/tests/AndroidInputEventProtoConverter_test.cpp
+++ b/services/inputflinger/tests/AndroidInputEventProtoConverter_test.cpp
@@ -108,7 +108,7 @@ TEST(AndroidInputEventProtoConverterTest, ToProtoMotionEvent) {
     event.deviceId = 4;
     event.displayId = ui::LogicalDisplayId(5);
     event.classification = MotionClassification::PINCH;
-    event.flags = 6;
+    event.flags = MotionFlag::CANCELED;
     event.policyFlags = 7;
     event.buttonState = 8;
     event.actionButton = 9;
@@ -152,7 +152,7 @@ TEST(AndroidInputEventProtoConverterTest, ToProtoMotionEvent) {
     EXPECT_CALL(proto, set_device_id(4));
     EXPECT_CALL(proto, set_display_id(5));
     EXPECT_CALL(proto, set_classification(AMOTION_EVENT_CLASSIFICATION_PINCH));
-    EXPECT_CALL(proto, set_flags(6));
+    EXPECT_CALL(proto, set_flags(ftl::Flags<MotionFlag>(MotionFlag::CANCELED).get()));
     EXPECT_CALL(proto, set_policy_flags(7));
     EXPECT_CALL(proto, set_button_state(8));
     EXPECT_CALL(proto, set_action_button(9));
@@ -203,7 +203,7 @@ TEST(AndroidInputEventProtoConverterTest, ToProtoMotionEvent_Redacted) {
     event.deviceId = 4;
     event.displayId = ui::LogicalDisplayId(5);
     event.classification = MotionClassification::PINCH;
-    event.flags = 6;
+    event.flags = MotionFlag::CANCELED;
     event.policyFlags = 7;
     event.buttonState = 8;
     event.actionButton = 9;
@@ -247,7 +247,7 @@ TEST(AndroidInputEventProtoConverterTest, ToProtoMotionEvent_Redacted) {
     EXPECT_CALL(proto, set_device_id(4));
     EXPECT_CALL(proto, set_display_id(5));
     EXPECT_CALL(proto, set_classification(AMOTION_EVENT_CLASSIFICATION_PINCH));
-    EXPECT_CALL(proto, set_flags(6));
+    EXPECT_CALL(proto, set_flags(ftl::Flags<MotionFlag>(MotionFlag::CANCELED).get()));
     EXPECT_CALL(proto, set_policy_flags(7));
     EXPECT_CALL(proto, set_button_state(8));
     EXPECT_CALL(proto, set_action_button(9));
@@ -301,7 +301,7 @@ TEST(AndroidInputEventProtoConverterTest, ToProtoMotionEvent_ZeroValues) {
     event.deviceId = 0;
     event.displayId = ui::LogicalDisplayId(0);
     event.classification = {};
-    event.flags = 0;
+    event.flags = {};
     event.policyFlags = 0;
     event.buttonState = 0;
     event.actionButton = 0;
@@ -466,7 +466,8 @@ TEST(AndroidInputEventProtoConverterTest, ToProtoWindowDispatchEvent_Motion_Iden
     args.eventEntry = motion;
     args.vsyncId = 1;
     args.windowId = 2;
-    args.resolvedFlags = 3;
+    ftl::Flags<MotionFlag> resolvedFlags = MotionFlag::WINDOW_IS_OBSCURED;
+    args.resolvedMotionFlags = resolvedFlags;
     args.rawTransform = ui::Transform{};
     args.transform = ui::Transform{};
 
@@ -476,7 +477,7 @@ TEST(AndroidInputEventProtoConverterTest, ToProtoWindowDispatchEvent_Motion_Iden
     EXPECT_CALL(proto, set_event_id(0));
     EXPECT_CALL(proto, set_vsync_id(1));
     EXPECT_CALL(proto, set_window_id(2));
-    EXPECT_CALL(proto, set_resolved_flags(3));
+    EXPECT_CALL(proto, set_resolved_flags(resolvedFlags.get()));
     EXPECT_CALL(proto, add_dispatched_pointer()).WillOnce(Return(&pointer));
     EXPECT_CALL(pointer, set_pointer_id(4));
 
@@ -503,7 +504,8 @@ TEST(AndroidInputEventProtoConverterTest, ToProtoWindowDispatchEvent_Motion_Cust
     args.eventEntry = motion;
     args.vsyncId = 1;
     args.windowId = 2;
-    args.resolvedFlags = 3;
+    ftl::Flags<MotionFlag> resolvedFlags = MotionFlag::WINDOW_IS_OBSCURED;
+    args.resolvedMotionFlags = resolvedFlags;
     args.rawTransform.set(2, 0, 0, 0.5);
     args.transform.set(1.0, 0, 0, 0.5);
 
@@ -514,7 +516,7 @@ TEST(AndroidInputEventProtoConverterTest, ToProtoWindowDispatchEvent_Motion_Cust
     EXPECT_CALL(proto, set_event_id(0));
     EXPECT_CALL(proto, set_vsync_id(1));
     EXPECT_CALL(proto, set_window_id(2));
-    EXPECT_CALL(proto, set_resolved_flags(3));
+    EXPECT_CALL(proto, set_resolved_flags(resolvedFlags.get()));
     EXPECT_CALL(proto, add_dispatched_pointer()).WillOnce(Return(&pointer));
     EXPECT_CALL(pointer, set_pointer_id(4));
 
@@ -543,7 +545,8 @@ TEST(AndroidInputEventProtoConverterTest, ToProtoWindowDispatchEvent_Motion_Reda
     args.eventEntry = motion;
     args.vsyncId = 1;
     args.windowId = 2;
-    args.resolvedFlags = 3;
+    ftl::Flags<MotionFlag> resolvedFlags = MotionFlag::WINDOW_IS_OBSCURED;
+    args.resolvedMotionFlags = resolvedFlags;
     args.rawTransform = ui::Transform{};
     args.transform = ui::Transform{};
 
@@ -552,7 +555,7 @@ TEST(AndroidInputEventProtoConverterTest, ToProtoWindowDispatchEvent_Motion_Reda
     EXPECT_CALL(proto, set_event_id(0));
     EXPECT_CALL(proto, set_vsync_id(1));
     EXPECT_CALL(proto, set_window_id(2));
-    EXPECT_CALL(proto, set_resolved_flags(3));
+    EXPECT_CALL(proto, set_resolved_flags(resolvedFlags.get()));
 
     // Redacted fields
     EXPECT_CALL(proto, add_dispatched_pointer()).Times(0);
@@ -567,7 +570,7 @@ TEST(AndroidInputEventProtoConverterTest, ToProtoWindowDispatchEvent_Key) {
     args.eventEntry = key;
     args.vsyncId = 1;
     args.windowId = 2;
-    args.resolvedFlags = 3;
+    args.resolvedMotionFlags = MotionFlag::WINDOW_IS_OBSCURED;
     args.rawTransform = ui::Transform{};
     args.transform = ui::Transform{};
 
@@ -576,7 +579,8 @@ TEST(AndroidInputEventProtoConverterTest, ToProtoWindowDispatchEvent_Key) {
     EXPECT_CALL(proto, set_event_id(0));
     EXPECT_CALL(proto, set_vsync_id(1));
     EXPECT_CALL(proto, set_window_id(2));
-    EXPECT_CALL(proto, set_resolved_flags(3));
+    EXPECT_CALL(proto,
+                set_resolved_flags(ftl::Flags<MotionFlag>(MotionFlag::WINDOW_IS_OBSCURED).get()));
 
     TestProtoConverter::toProtoWindowDispatchEvent(args, proto, /*isRedacted=*/true);
 }
diff --git a/services/inputflinger/tests/CapturedTouchpadEventConverter_test.cpp b/services/inputflinger/tests/CapturedTouchpadEventConverter_test.cpp
index c6246d9eec..ceaf438374 100644
--- a/services/inputflinger/tests/CapturedTouchpadEventConverter_test.cpp
+++ b/services/inputflinger/tests/CapturedTouchpadEventConverter_test.cpp
@@ -623,7 +623,7 @@ TEST_F(CapturedTouchpadEventConverterTest, FingerAndFingerTurningIntoPalm_partia
                                     AllOf(WithMotionAction(
                                                   AMOTION_EVENT_ACTION_POINTER_UP |
                                                   1 << AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT),
-                                          WithFlags(AMOTION_EVENT_FLAG_CANCELED)))));
+                                          WithFlags(MotionFlag::CANCELED)))));
     EXPECT_THAT(args, Each(VariantWith<NotifyMotionArgs>(WithPointerCount(2u))));
 }
 
diff --git a/services/inputflinger/tests/CursorInputMapper_test.cpp b/services/inputflinger/tests/CursorInputMapper_test.cpp
index 594ee3b579..55ce2df1b7 100644
--- a/services/inputflinger/tests/CursorInputMapper_test.cpp
+++ b/services/inputflinger/tests/CursorInputMapper_test.cpp
@@ -23,6 +23,7 @@
 #include <variant>
 
 #include <android-base/logging.h>
+#include <android/configuration.h>
 #include <android_companion_virtualdevice_flags.h>
 #include <com_android_input_flags.h>
 #include <gmock/gmock.h>
@@ -38,6 +39,7 @@
 #include "InputReaderBase.h"
 #include "InterfaceMocks.h"
 #include "NotifyArgs.h"
+#include "ScopedFlagOverride.h"
 #include "TestEventMatchers.h"
 #include "ui/Rotation.h"
 
@@ -57,6 +59,8 @@ constexpr auto HOVER_MOVE = AMOTION_EVENT_ACTION_HOVER_MOVE;
 constexpr auto INVALID_CURSOR_POSITION = AMOTION_EVENT_INVALID_CURSOR_POSITION;
 constexpr auto AXIS_X = AMOTION_EVENT_AXIS_X;
 constexpr auto AXIS_Y = AMOTION_EVENT_AXIS_Y;
+constexpr auto AXIS_RELATIVE_X = AMOTION_EVENT_AXIS_RELATIVE_X;
+constexpr auto AXIS_RELATIVE_Y = AMOTION_EVENT_AXIS_RELATIVE_Y;
 constexpr ui::LogicalDisplayId DISPLAY_ID = ui::LogicalDisplayId::DEFAULT;
 constexpr ui::LogicalDisplayId SECONDARY_DISPLAY_ID = ui::LogicalDisplayId{DISPLAY_ID.val() + 1};
 constexpr int32_t DISPLAY_WIDTH = 480;
@@ -66,7 +70,8 @@ constexpr int32_t TRACKBALL_MOVEMENT_THRESHOLD = 6;
 
 namespace {
 
-DisplayViewport createPrimaryViewport(ui::Rotation orientation) {
+DisplayViewport createPrimaryViewport(ui::Rotation orientation,
+                                      int32_t densityDpi = ACONFIGURATION_DENSITY_XHIGH) {
     const bool isRotated =
             orientation == ui::Rotation::Rotation90 || orientation == ui::Rotation::Rotation270;
     DisplayViewport v;
@@ -80,6 +85,7 @@ DisplayViewport createPrimaryViewport(ui::Rotation orientation) {
     v.deviceHeight = isRotated ? DISPLAY_WIDTH : DISPLAY_HEIGHT;
     v.isActive = true;
     v.uniqueId = "local:1";
+    v.densityDpi = densityDpi;
     return v;
 }
 
@@ -261,6 +267,59 @@ TEST_F(CursorInputMapperUnitTest, HoverAndLeftButtonPress) {
                             VariantWith<NotifyMotionArgs>(WithMotionAction(HOVER_MOVE))));
 }
 
+TEST_F(CursorInputMapperUnitTest, MoveAndButtonChangeInSameFrame) {
+    createMapper();
+    std::list<NotifyArgs> args;
+
+    // Move the cursor and press the button
+    args += process(EV_REL, REL_X, -10);
+    args += process(EV_REL, REL_Y, 20);
+    args += process(EV_KEY, BTN_LEFT, 1);
+    args += process(EV_SYN, SYN_REPORT, 0);
+    ASSERT_THAT(args,
+                ElementsAre(VariantWith<NotifyMotionArgs>(
+                                    AllOf(WithMotionAction(HOVER_MOVE), WithButtonState(0),
+                                          WithNegativeAxis(AXIS_RELATIVE_X),
+                                          WithPositiveAxis(AXIS_RELATIVE_Y), WithPressure(0.0f))),
+                            VariantWith<NotifyMotionArgs>(
+                                    AllOf(WithMotionAction(ACTION_DOWN),
+                                          WithButtonState(AMOTION_EVENT_BUTTON_PRIMARY),
+                                          WithZeroAxis(AXIS_RELATIVE_X),
+                                          WithZeroAxis(AXIS_RELATIVE_Y), WithPressure(1.0f))),
+                            VariantWith<NotifyMotionArgs>(
+                                    AllOf(WithMotionAction(BUTTON_PRESS),
+                                          WithActionButton(AMOTION_EVENT_BUTTON_PRIMARY),
+                                          WithButtonState(AMOTION_EVENT_BUTTON_PRIMARY),
+                                          WithZeroAxis(AXIS_RELATIVE_X),
+                                          WithZeroAxis(AXIS_RELATIVE_Y), WithPressure(1.0f)))));
+
+    // Move some more and release the button
+    args.clear();
+    args += process(EV_REL, REL_X, 10);
+    args += process(EV_REL, REL_Y, -5);
+    args += process(EV_KEY, BTN_LEFT, 0);
+    args += process(EV_SYN, SYN_REPORT, 0);
+    ASSERT_THAT(args,
+                ElementsAre(VariantWith<NotifyMotionArgs>(
+                                    AllOf(WithMotionAction(ACTION_MOVE),
+                                          WithButtonState(AMOTION_EVENT_BUTTON_PRIMARY),
+                                          WithPositiveAxis(AXIS_RELATIVE_X),
+                                          WithNegativeAxis(AXIS_RELATIVE_Y), WithPressure(1.0f))),
+                            VariantWith<NotifyMotionArgs>(
+                                    AllOf(WithMotionAction(BUTTON_RELEASE),
+                                          WithActionButton(AMOTION_EVENT_BUTTON_PRIMARY),
+                                          WithButtonState(0), WithZeroAxis(AXIS_RELATIVE_X),
+                                          WithZeroAxis(AXIS_RELATIVE_Y), WithPressure(0.0f))),
+                            VariantWith<NotifyMotionArgs>(
+                                    AllOf(WithMotionAction(ACTION_UP), WithButtonState(0),
+                                          WithZeroAxis(AXIS_RELATIVE_X),
+                                          WithZeroAxis(AXIS_RELATIVE_Y), WithPressure(0.0f))),
+                            VariantWith<NotifyMotionArgs>(
+                                    AllOf(WithMotionAction(HOVER_MOVE), WithButtonState(0),
+                                          WithZeroAxis(AXIS_RELATIVE_X),
+                                          WithZeroAxis(AXIS_RELATIVE_Y), WithPressure(0.0f)))));
+}
+
 /**
  * Test that enabling mouse swap primary button will have the left click result in a
  * `SECONDARY_BUTTON` event and a right click will result in a `PRIMARY_BUTTON` event.
@@ -443,7 +502,8 @@ TEST_F(CursorInputMapperUnitTest, ProcessShouldSetAllFieldsAndIncludeGlobalMetaS
     EXPECT_THAT(args,
                 Each(VariantWith<NotifyMotionArgs>(
                         AllOf(WithEventTime(ARBITRARY_TIME), WithDeviceId(DEVICE_ID),
-                              WithSource(AINPUT_SOURCE_TRACKBALL), WithFlags(0), WithEdgeFlags(0),
+                              WithSource(AINPUT_SOURCE_TRACKBALL),
+                              WithFlags(ftl::Flags<MotionFlag>()), WithEdgeFlags(0),
                               WithPolicyFlags(0),
                               WithMetaState(AMETA_SHIFT_LEFT_ON | AMETA_SHIFT_ON),
                               WithButtonState(AMOTION_EVENT_BUTTON_PRIMARY), WithPointerCount(1),
@@ -463,7 +523,8 @@ TEST_F(CursorInputMapperUnitTest, ProcessShouldSetAllFieldsAndIncludeGlobalMetaS
     EXPECT_THAT(args,
                 Each(VariantWith<NotifyMotionArgs>(
                         AllOf(WithEventTime(ARBITRARY_TIME + 1), WithDeviceId(DEVICE_ID),
-                              WithSource(AINPUT_SOURCE_TRACKBALL), WithFlags(0), WithEdgeFlags(0),
+                              WithSource(AINPUT_SOURCE_TRACKBALL),
+                              WithFlags(ftl::Flags<MotionFlag>()), WithEdgeFlags(0),
                               WithPolicyFlags(0),
                               WithMetaState(AMETA_SHIFT_LEFT_ON | AMETA_SHIFT_ON),
                               WithButtonState(0), WithPointerCount(1), WithPointerId(0, 0),
@@ -539,12 +600,15 @@ TEST_F(CursorInputMapperUnitTest, ProcessShouldHandleCombinedXYAndButtonUpdates)
     args += process(ARBITRARY_TIME, EV_KEY, BTN_MOUSE, 1);
     args += process(ARBITRARY_TIME, EV_SYN, SYN_REPORT, 0);
     EXPECT_THAT(args,
-                ElementsAre(VariantWith<NotifyMotionArgs>(WithMotionAction(ACTION_DOWN)),
-                            VariantWith<NotifyMotionArgs>(WithMotionAction(BUTTON_PRESS))));
-    EXPECT_THAT(args,
-                Each(VariantWith<NotifyMotionArgs>(AllOf(WithPositiveAxis(AXIS_X),
-                                                         WithNegativeAxis(AXIS_Y),
-                                                         WithPressure(1.0f)))));
+                ElementsAre(VariantWith<NotifyMotionArgs>(
+                                    AllOf(WithMotionAction(ACTION_MOVE), WithPressure(0.0f),
+                                          WithPositiveAxis(AXIS_X), WithNegativeAxis(AXIS_Y))),
+                            VariantWith<NotifyMotionArgs>(
+                                    AllOf(WithMotionAction(ACTION_DOWN), WithPressure(1.0f),
+                                          WithZeroAxis(AXIS_X), WithZeroAxis(AXIS_Y))),
+                            VariantWith<NotifyMotionArgs>(
+                                    AllOf(WithMotionAction(BUTTON_PRESS), WithPressure(1.0f),
+                                          WithZeroAxis(AXIS_X), WithZeroAxis(AXIS_Y)))));
     args.clear();
 
     // Move X, Y a bit while pressed.
@@ -780,11 +844,9 @@ TEST_F(CursorInputMapperUnitTest, ProcessShouldHandleAllButtonsWithZeroCoords) {
     args += process(ARBITRARY_TIME, EV_KEY, BTN_RIGHT, 0);
     args += process(ARBITRARY_TIME, EV_SYN, SYN_REPORT, 0);
     EXPECT_THAT(args,
-                ElementsAre(VariantWith<NotifyMotionArgs>(WithMotionAction(BUTTON_RELEASE)),
-                            VariantWith<NotifyMotionArgs>(WithMotionAction(ACTION_MOVE))));
-    EXPECT_THAT(args,
-                Each(VariantWith<NotifyMotionArgs>(
-                        AllOf(WithButtonState(AMOTION_EVENT_BUTTON_TERTIARY),
+                ElementsAre(VariantWith<NotifyMotionArgs>(
+                        AllOf(WithMotionAction(BUTTON_RELEASE),
+                              WithButtonState(AMOTION_EVENT_BUTTON_TERTIARY),
                               WithCoords(0.0f, 0.0f), WithPressure(1.0f)))));
     args.clear();
 
@@ -817,10 +879,6 @@ TEST_P(CursorInputMapperButtonKeyTest, ProcessShouldHandleButtonKeyWithZeroCoord
     EXPECT_THAT(args,
                 ElementsAre(VariantWith<NotifyKeyArgs>(AllOf(WithKeyAction(AKEY_EVENT_ACTION_DOWN),
                                                              WithKeyCode(expectedKeyCode))),
-                            VariantWith<NotifyMotionArgs>(
-                                    AllOf(WithMotionAction(HOVER_MOVE),
-                                          WithButtonState(expectedButtonState),
-                                          WithCoords(0.0f, 0.0f), WithPressure(0.0f))),
                             VariantWith<NotifyMotionArgs>(
                                     AllOf(WithMotionAction(BUTTON_PRESS),
                                           WithButtonState(expectedButtonState),
@@ -833,9 +891,6 @@ TEST_P(CursorInputMapperButtonKeyTest, ProcessShouldHandleButtonKeyWithZeroCoord
                 ElementsAre(VariantWith<NotifyMotionArgs>(
                                     AllOf(WithMotionAction(BUTTON_RELEASE), WithButtonState(0),
                                           WithCoords(0.0f, 0.0f), WithPressure(0.0f))),
-                            VariantWith<NotifyMotionArgs>(
-                                    AllOf(WithMotionAction(HOVER_MOVE), WithButtonState(0),
-                                          WithCoords(0.0f, 0.0f), WithPressure(0.0f))),
                             VariantWith<NotifyKeyArgs>(AllOf(WithKeyAction(AKEY_EVENT_ACTION_UP),
                                                              WithKeyCode(expectedKeyCode)))));
 }
@@ -1129,6 +1184,168 @@ TEST_F(CursorInputMapperUnitTest, ConfigureAccelerationOnDisplayChange) {
                               WithRelativeMotion(10, 20)))));
 }
 
+class DensityDependentCursorUnitTest : public CursorInputMapperUnitTest {
+private:
+    bool mFlagValueBeforeTest;
+
+protected:
+    void SetUp() override {
+        mFlagValueBeforeTest = com::android::input::flags::scale_cursor_speed_with_dpi();
+        com::android::input::flags::scale_cursor_speed_with_dpi(true);
+        CursorInputMapperUnitTest::SetUp();
+    }
+
+    void TearDown() override {
+        com::android::input::flags::scale_cursor_speed_with_dpi(mFlagValueBeforeTest);
+    }
+
+    std::list<NotifyArgs> processRelativeMove(int32_t rawRelativeX, int32_t rawRelativeY) {
+        std::list<NotifyArgs> args;
+        args += process(ARBITRARY_TIME, EV_REL, REL_X, rawRelativeX);
+        args += process(ARBITRARY_TIME, EV_REL, REL_Y, rawRelativeY);
+        args += process(ARBITRARY_TIME, EV_SYN, SYN_REPORT, 0);
+        return args;
+    }
+
+    std::tuple<float, float> getBaselineCursorMoves(int32_t rawRelativeX, int32_t rawRelativeY) {
+        // Cursor moves are not scaled for display density ACONFIGURATION_DENSITY_XHIGH, which is
+        // considered baseline. Acceleration will still apply.
+        DisplayViewport mediumDensityViewport =
+                createPrimaryViewport(ui::Rotation::Rotation0, ACONFIGURATION_DENSITY_XHIGH);
+        mReaderConfiguration.setDisplayViewports({mediumDensityViewport});
+        EXPECT_CALL((*mDevice), getAssociatedViewport)
+                .WillRepeatedly(Return(mediumDensityViewport));
+        mMapper = createInputMapper<CursorInputMapper>(*mDeviceContext, mReaderConfiguration);
+
+        std::list<NotifyArgs> args = processRelativeMove(rawRelativeX, rawRelativeY);
+        auto coords = get<NotifyMotionArgs>(args.back()).pointerCoords[0];
+        return {coords.getAxisValue(AMOTION_EVENT_AXIS_RELATIVE_X),
+                coords.getAxisValue(AMOTION_EVENT_AXIS_RELATIVE_Y)};
+    }
+};
+
+TEST_F(DensityDependentCursorUnitTest, ScalesCursorMoveWithDisplayDensity) {
+    // Use same move values on different density displays, generated events should be scaled
+    // according to the display density.
+    const int32_t rawRelativeX = 10;
+    const int32_t rawRelativeY = 20;
+    const auto [baselineRelativeX, baselineRelativeY] =
+            getBaselineCursorMoves(rawRelativeX, rawRelativeY);
+
+    DisplayViewport highDensityViewport =
+            createPrimaryViewport(ui::Rotation::Rotation0, ACONFIGURATION_DENSITY_XXHIGH);
+    mReaderConfiguration.setDisplayViewports({highDensityViewport});
+    EXPECT_CALL((*mDevice), getAssociatedViewport).WillRepeatedly(Return(highDensityViewport));
+
+    std::list<NotifyArgs> args =
+            mMapper->reconfigure(ARBITRARY_TIME, mReaderConfiguration,
+                                 InputReaderConfiguration::Change::DISPLAY_INFO);
+    args.clear();
+
+    args += processRelativeMove(rawRelativeX, rawRelativeY);
+    float scalingFactor = static_cast<float>(ACONFIGURATION_DENSITY_XXHIGH) /
+            static_cast<float>(ACONFIGURATION_DENSITY_XHIGH);
+    ASSERT_THAT(args,
+                ElementsAre(VariantWith<NotifyMotionArgs>(
+                        AllOf(WithMotionAction(HOVER_MOVE),
+                              WithRelativeMotion(baselineRelativeX * scalingFactor,
+                                                 baselineRelativeY * scalingFactor)))));
+}
+
+TEST_F(DensityDependentCursorUnitTest, FallbackToNoScalingWhenDensityUnavailable) {
+    const int32_t rawRelativeX = 10;
+    const int32_t rawRelativeY = 20;
+    const auto [baselineRelativeX, baselineRelativeY] =
+            getBaselineCursorMoves(rawRelativeX, rawRelativeY);
+
+    // Viewport without density information should be equivalent to viewport with baseline density.
+    DisplayViewport noneDensityViewport =
+            createPrimaryViewport(ui::Rotation::Rotation0, ACONFIGURATION_DENSITY_NONE);
+    mReaderConfiguration.setDisplayViewports({noneDensityViewport});
+    EXPECT_CALL((*mDevice), getAssociatedViewport).WillRepeatedly(Return(noneDensityViewport));
+    std::list<NotifyArgs> args =
+            mMapper->reconfigure(ARBITRARY_TIME, mReaderConfiguration,
+                                 InputReaderConfiguration::Change::DISPLAY_INFO);
+    args.clear();
+
+    args += processRelativeMove(rawRelativeX, rawRelativeY);
+    ASSERT_THAT(args,
+                ElementsAre(VariantWith<NotifyMotionArgs>(
+                        AllOf(WithMotionAction(HOVER_MOVE),
+                              WithRelativeMotion(baselineRelativeX, baselineRelativeY)))));
+}
+
+TEST_F(DensityDependentCursorUnitTest,
+       DoesNotScaleCursorMoveWithDisplayDensityWhenMouseScalingDisabled) {
+    // Create a medium density viewport and disable all scaling.
+    mReaderConfiguration.displaysWithMouseScalingDisabled.emplace(DISPLAY_ID);
+    DisplayViewport mediumDensityViewport =
+            createPrimaryViewport(ui::Rotation::Rotation0, ACONFIGURATION_DENSITY_MEDIUM);
+    mReaderConfiguration.setDisplayViewports({mediumDensityViewport});
+    EXPECT_CALL((*mDevice), getAssociatedViewport).WillRepeatedly(Return(mediumDensityViewport));
+    mMapper = createInputMapper<CursorInputMapper>(*mDeviceContext, mReaderConfiguration);
+
+    const int32_t rawRelativeX = 10;
+    const int32_t rawRelativeY = 20;
+    std::list<NotifyArgs> args;
+    args += processRelativeMove(rawRelativeX, rawRelativeY);
+    ASSERT_THAT(args,
+                ElementsAre(VariantWith<NotifyMotionArgs>(
+                        AllOf(WithMotionAction(HOVER_MOVE),
+                              WithRelativeMotion(rawRelativeX, rawRelativeY)))));
+}
+
+TEST_F(DensityDependentCursorUnitTest,
+       ResetScaleCursorMoveWithDisplayDensityWhenMouseScalingDisabled) {
+    // Create a medium density viewport.
+    DisplayViewport mediumDensityViewport =
+            createPrimaryViewport(ui::Rotation::Rotation0, ACONFIGURATION_DENSITY_MEDIUM);
+    mReaderConfiguration.setDisplayViewports({mediumDensityViewport});
+    EXPECT_CALL((*mDevice), getAssociatedViewport).WillRepeatedly(Return(mediumDensityViewport));
+    mMapper = createInputMapper<CursorInputMapper>(*mDeviceContext, mReaderConfiguration);
+
+    std::list<NotifyArgs> args;
+    // Disables scaling
+    mReaderConfiguration.displaysWithMouseScalingDisabled.emplace(DISPLAY_ID);
+    args += mMapper->reconfigure(ARBITRARY_TIME, mReaderConfiguration,
+                                 InputReaderConfiguration::Change::POINTER_SPEED);
+    args.clear();
+
+    const int32_t rawRelativeX = 10;
+    const int32_t rawRelativeY = 20;
+    args += processRelativeMove(rawRelativeX, rawRelativeY);
+    ASSERT_THAT(args,
+                ElementsAre(VariantWith<NotifyMotionArgs>(
+                        AllOf(WithMotionAction(HOVER_MOVE),
+                              WithRelativeMotion(rawRelativeX, rawRelativeY)))));
+}
+
+TEST_F(DensityDependentCursorUnitTest, DoesNotScaleCursorMoveWithPointerCaptureEnabled) {
+    // Create a medium density viewport, that should have scaling enabled by default.
+    DisplayViewport mediumDensityViewport =
+            createPrimaryViewport(ui::Rotation::Rotation0, ACONFIGURATION_DENSITY_MEDIUM);
+    mReaderConfiguration.setDisplayViewports({mediumDensityViewport});
+    EXPECT_CALL((*mDevice), getAssociatedViewport).WillRepeatedly(Return(mediumDensityViewport));
+    mMapper = createInputMapper<CursorInputMapper>(*mDeviceContext, mReaderConfiguration);
+
+    // Request pointer capture after the mapper has been configured.
+    setPointerCapture(true);
+
+    // Verify pointer capture has been enabled.
+    const int32_t rawRelativeX = 10;
+    const int32_t rawRelativeY = 20;
+    std::list<NotifyArgs> args;
+    args += processRelativeMove(rawRelativeX, rawRelativeY);
+    ASSERT_THAT(args,
+                ElementsAre(VariantWith<NotifyMotionArgs>(
+                        AllOf(WithMotionAction(ACTION_MOVE),
+                              WithSource(AINPUT_SOURCE_MOUSE_RELATIVE),
+                              WithCoords(rawRelativeX, rawRelativeY),
+                              WithRelativeMotion(rawRelativeX, rawRelativeY),
+                              WithCursorPosition(INVALID_CURSOR_POSITION,
+                                                 INVALID_CURSOR_POSITION)))));
+}
+
 namespace {
 
 // Minimum timestamp separation between subsequent input events from a Bluetooth device.
diff --git a/services/inputflinger/tests/DisplayTopologyGraph_test.cpp b/services/inputflinger/tests/DisplayTopologyGraph_test.cpp
index fd2f21c4cb..bbd5654c53 100644
--- a/services/inputflinger/tests/DisplayTopologyGraph_test.cpp
+++ b/services/inputflinger/tests/DisplayTopologyGraph_test.cpp
@@ -14,6 +14,7 @@
  * limitations under the License.
  */
 
+#include <com_android_input_flags.h>
 #include <gtest/gtest.h>
 #include <input/DisplayTopologyGraph.h>
 
@@ -21,6 +22,8 @@
 #include <string_view>
 #include <tuple>
 
+#include "ScopedFlagOverride.h"
+
 namespace android {
 
 namespace {
@@ -31,87 +34,151 @@ constexpr int DENSITY_MEDIUM = 160;
 
 } // namespace
 
+using DisplayProperties = DisplayTopologyGraph::Properties;
+using AdjacentDisplaysVector = std::vector<DisplayTopologyAdjacentDisplay>;
+using DisplayPropertiesMap = std::unordered_map<ui::LogicalDisplayId, DisplayProperties>;
+
 using DisplayTopologyGraphTestFixtureParam =
-        std::tuple<std::string_view /*name*/, DisplayTopologyGraph, bool /*isValid*/>;
+        std::tuple<std::string_view /*name*/, ui::LogicalDisplayId /*primaryDisplayId*/,
+                   DisplayPropertiesMap, bool /*isValid*/>;
 
 class DisplayTopologyGraphTestFixture
       : public testing::Test,
         public testing::WithParamInterface<DisplayTopologyGraphTestFixtureParam> {};
 
 TEST_P(DisplayTopologyGraphTestFixture, DisplayTopologyGraphTest) {
-    const auto& [_, displayTopology, isValid] = GetParam();
-    EXPECT_EQ(isValid, displayTopology.isValid());
+    SCOPED_FLAG_OVERRIDE(enable_display_topology_validation, true);
+    auto [_, primaryDisplayId, graph, isValid] = GetParam();
+    auto result = DisplayTopologyGraph::create(primaryDisplayId, std::move(graph));
+    EXPECT_EQ(isValid, result.ok());
 }
 
 INSTANTIATE_TEST_SUITE_P(
         DisplayTopologyGraphTest, DisplayTopologyGraphTestFixture,
         testing::Values(
+                std::make_tuple("InvalidPrimaryDisplay",
+                                /*primaryDisplayId=*/ui::LogicalDisplayId::INVALID,
+                                /*graph=*/DisplayPropertiesMap{}, false),
+                std::make_tuple("PrimaryDisplayNotInGraph",
+                                /*primaryDisplayId=*/DISPLAY_ID_1,
+                                /*graph=*/DisplayPropertiesMap{}, false),
                 std::make_tuple(
-                        "InvalidPrimaryDisplay",
-                        DisplayTopologyGraph{.primaryDisplayId = ui::LogicalDisplayId::INVALID,
-                                             .graph = {},
-                                             .displaysDensity = {}},
+                        "DisplayDensityInvalid",
+                        /*primaryDisplayId=*/DISPLAY_ID_1,
+                        /*graph=*/
+                        DisplayPropertiesMap{
+                                {DISPLAY_ID_1,
+                                 DisplayProperties{.adjacentDisplays = AdjacentDisplaysVector{},
+                                                   .density = -1,
+                                                   .boundsInGlobalDp = FloatRect(0, 0, 100, 100)}}},
                         false),
-                std::make_tuple("PrimaryDisplayNotInGraph",
-                                DisplayTopologyGraph{.primaryDisplayId = DISPLAY_ID_1,
-                                                     .graph = {},
-                                                     .displaysDensity = {}},
-                                false),
-                std::make_tuple("DisplayDensityMissing",
-                                DisplayTopologyGraph{.primaryDisplayId = DISPLAY_ID_1,
-                                                     .graph = {{DISPLAY_ID_1, {}}},
-                                                     .displaysDensity = {}},
-                                false),
-                std::make_tuple("ValidSingleDisplayTopology",
-                                DisplayTopologyGraph{.primaryDisplayId = DISPLAY_ID_1,
-                                                     .graph = {{DISPLAY_ID_1, {}}},
-                                                     .displaysDensity = {{DISPLAY_ID_1,
-                                                                          DENSITY_MEDIUM}}},
-                                true),
+                std::make_tuple(
+                        "DisplayBoundsInvalid",
+                        /*primaryDisplayId=*/DISPLAY_ID_1,
+                        /*graph=*/
+                        DisplayPropertiesMap{
+                                {DISPLAY_ID_1,
+                                 DisplayProperties{.adjacentDisplays = AdjacentDisplaysVector{},
+                                                   .density = DENSITY_MEDIUM,
+                                                   .boundsInGlobalDp = FloatRect(0, 0, 0, 0)}}},
+                        false),
+                std::make_tuple(
+                        "ValidSingleDisplayTopology",
+                        /*primaryDisplayId=*/DISPLAY_ID_1,
+                        /*graph=*/
+                        DisplayPropertiesMap{
+                                {DISPLAY_ID_1,
+                                 DisplayProperties{.adjacentDisplays = AdjacentDisplaysVector{},
+                                                   .density = DENSITY_MEDIUM,
+                                                   .boundsInGlobalDp = FloatRect(0, 0, 100, 100)}}},
+                        true),
                 std::make_tuple(
                         "MissingReverseEdge",
-                        DisplayTopologyGraph{.primaryDisplayId = DISPLAY_ID_1,
-                                             .graph = {{DISPLAY_ID_1,
-                                                        {{DISPLAY_ID_2,
-                                                          DisplayTopologyPosition::TOP, 0}}}},
-                                             .displaysDensity = {{DISPLAY_ID_1, DENSITY_MEDIUM},
-                                                                 {DISPLAY_ID_2, DENSITY_MEDIUM}}},
+                        /*primaryDisplayId=*/DISPLAY_ID_1,
+                        /*graph=*/
+                        DisplayPropertiesMap{
+                                {DISPLAY_ID_1,
+                                 DisplayProperties{.adjacentDisplays =
+                                                           AdjacentDisplaysVector{
+                                                                   {DISPLAY_ID_2,
+                                                                    DisplayTopologyPosition::TOP,
+                                                                    0}},
+                                                   .density = DENSITY_MEDIUM,
+                                                   .boundsInGlobalDp = FloatRect(0, 0, 100, 100)}},
+                                {DISPLAY_ID_2,
+                                 DisplayProperties{.adjacentDisplays = AdjacentDisplaysVector{},
+                                                   .density = DENSITY_MEDIUM,
+                                                   .boundsInGlobalDp = FloatRect(0, 100, 100,
+                                                                                 200)}}},
                         false),
                 std::make_tuple(
                         "IncorrectReverseEdgeDirection",
-                        DisplayTopologyGraph{.primaryDisplayId = DISPLAY_ID_1,
-                                             .graph = {{DISPLAY_ID_1,
-                                                        {{DISPLAY_ID_2,
-                                                          DisplayTopologyPosition::TOP, 0}}},
-                                                       {DISPLAY_ID_2,
-                                                        {{DISPLAY_ID_1,
-                                                          DisplayTopologyPosition::TOP, 0}}}},
-                                             .displaysDensity = {{DISPLAY_ID_1, DENSITY_MEDIUM},
-                                                                 {DISPLAY_ID_2, DENSITY_MEDIUM}}},
+                        /*primaryDisplayId=*/DISPLAY_ID_1,
+                        /*graph=*/
+                        DisplayPropertiesMap{
+                                {DISPLAY_ID_1,
+                                 DisplayProperties{.adjacentDisplays =
+                                                           AdjacentDisplaysVector{
+                                                                   {DISPLAY_ID_2,
+                                                                    DisplayTopologyPosition::TOP,
+                                                                    0}},
+                                                   .density = DENSITY_MEDIUM,
+                                                   .boundsInGlobalDp = FloatRect(0, 0, 100, 100)}},
+                                {DISPLAY_ID_2,
+                                 DisplayProperties{.adjacentDisplays =
+                                                           AdjacentDisplaysVector{
+                                                                   {DISPLAY_ID_1,
+                                                                    DisplayTopologyPosition::TOP,
+                                                                    0}},
+                                                   .density = DENSITY_MEDIUM,
+                                                   .boundsInGlobalDp = FloatRect(0, 100, 100,
+                                                                                 200)}}},
                         false),
                 std::make_tuple(
                         "IncorrectReverseEdgeOffset",
-                        DisplayTopologyGraph{.primaryDisplayId = DISPLAY_ID_1,
-                                             .graph = {{DISPLAY_ID_1,
-                                                        {{DISPLAY_ID_2,
-                                                          DisplayTopologyPosition::TOP, 10}}},
-                                                       {DISPLAY_ID_2,
-                                                        {{DISPLAY_ID_1,
-                                                          DisplayTopologyPosition::BOTTOM, 20}}}},
-                                             .displaysDensity = {{DISPLAY_ID_1, DENSITY_MEDIUM},
-                                                                 {DISPLAY_ID_2, DENSITY_MEDIUM}}},
+                        /*primaryDisplayId=*/DISPLAY_ID_1,
+                        /*graph=*/
+                        DisplayPropertiesMap{
+                                {DISPLAY_ID_1,
+                                 DisplayProperties{.adjacentDisplays =
+                                                           AdjacentDisplaysVector{
+                                                                   {DISPLAY_ID_2,
+                                                                    DisplayTopologyPosition::TOP,
+                                                                    10}},
+                                                   .density = DENSITY_MEDIUM,
+                                                   .boundsInGlobalDp = FloatRect(0, 0, 100, 100)}},
+                                {DISPLAY_ID_2,
+                                 DisplayProperties{.adjacentDisplays =
+                                                           AdjacentDisplaysVector{
+                                                                   {DISPLAY_ID_1,
+                                                                    DisplayTopologyPosition::TOP,
+                                                                    20}},
+                                                   .density = DENSITY_MEDIUM,
+                                                   .boundsInGlobalDp = FloatRect(0, 100, 100,
+                                                                                 200)}}},
                         false),
                 std::make_tuple(
                         "ValidMultiDisplayTopology",
-                        DisplayTopologyGraph{.primaryDisplayId = DISPLAY_ID_1,
-                                             .graph = {{DISPLAY_ID_1,
-                                                        {{DISPLAY_ID_2,
-                                                          DisplayTopologyPosition::TOP, 10}}},
-                                                       {DISPLAY_ID_2,
-                                                        {{DISPLAY_ID_1,
-                                                          DisplayTopologyPosition::BOTTOM, -10}}}},
-                                             .displaysDensity = {{DISPLAY_ID_1, DENSITY_MEDIUM},
-                                                                 {DISPLAY_ID_2, DENSITY_MEDIUM}}},
+                        /*primaryDisplayId=*/DISPLAY_ID_1,
+                        /*graph=*/
+                        DisplayPropertiesMap{
+                                {DISPLAY_ID_1,
+                                 DisplayProperties{.adjacentDisplays =
+                                                           AdjacentDisplaysVector{
+                                                                   {DISPLAY_ID_2,
+                                                                    DisplayTopologyPosition::TOP,
+                                                                    10}},
+                                                   .density = DENSITY_MEDIUM,
+                                                   .boundsInGlobalDp = FloatRect(0, 0, 100, 100)}},
+                                {DISPLAY_ID_2,
+                                 DisplayProperties{.adjacentDisplays =
+                                                           AdjacentDisplaysVector{
+                                                                   {DISPLAY_ID_1,
+                                                                    DisplayTopologyPosition::BOTTOM,
+                                                                    -10}},
+                                                   .density = DENSITY_MEDIUM,
+                                                   .boundsInGlobalDp = FloatRect(0, 100, 100,
+                                                                                 200)}}},
                         true)),
         [](const testing::TestParamInfo<DisplayTopologyGraphTestFixtureParam>& p) {
             return std::string{std::get<0>(p.param)};
diff --git a/services/inputflinger/tests/FakeEventHub.cpp b/services/inputflinger/tests/FakeEventHub.cpp
index 8987b99525..522f69ad36 100644
--- a/services/inputflinger/tests/FakeEventHub.cpp
+++ b/services/inputflinger/tests/FakeEventHub.cpp
@@ -92,10 +92,6 @@ void FakeEventHub::addConfigurationProperty(int32_t deviceId, const char* key, c
     getDevice(deviceId)->configuration.addProperty(key, value);
 }
 
-void FakeEventHub::addConfigurationMap(int32_t deviceId, const PropertyMap* configuration) {
-    getDevice(deviceId)->configuration.addAll(configuration);
-}
-
 void FakeEventHub::addAbsoluteAxis(int32_t deviceId, int axis, int32_t minValue, int32_t maxValue,
                                    int flat, int fuzz, int resolution) {
     Device* device = getDevice(deviceId);
diff --git a/services/inputflinger/tests/FakeEventHub.h b/services/inputflinger/tests/FakeEventHub.h
index 1cd33c1c98..688acc0be6 100644
--- a/services/inputflinger/tests/FakeEventHub.h
+++ b/services/inputflinger/tests/FakeEventHub.h
@@ -115,7 +115,6 @@ public:
     status_t disableDevice(int32_t deviceId) override;
 
     void addConfigurationProperty(int32_t deviceId, const char* key, const char* value);
-    void addConfigurationMap(int32_t deviceId, const PropertyMap* configuration);
 
     void addAbsoluteAxis(int32_t deviceId, int axis, int32_t minValue, int32_t maxValue, int flat,
                          int fuzz, int resolution = 0);
diff --git a/services/inputflinger/tests/FakeInputDispatcherPolicy.cpp b/services/inputflinger/tests/FakeInputDispatcherPolicy.cpp
index dcb148fe41..323cb09dc7 100644
--- a/services/inputflinger/tests/FakeInputDispatcherPolicy.cpp
+++ b/services/inputflinger/tests/FakeInputDispatcherPolicy.cpp
@@ -411,10 +411,14 @@ void FakeInputDispatcherPolicy::interceptMotionBeforeQueueing(ui::LogicalDisplay
                                                               int32_t, nsecs_t, uint32_t&) {}
 
 std::variant<nsecs_t, inputdispatcher::KeyEntry::InterceptKeyResult>
-FakeInputDispatcherPolicy::interceptKeyBeforeDispatching(const sp<IBinder>&, const KeyEvent&,
+FakeInputDispatcherPolicy::interceptKeyBeforeDispatching(const sp<IBinder>&, const KeyEvent& event,
                                                          uint32_t) {
-    if (std::holds_alternative<inputdispatcher::KeyEntry::InterceptKeyResult>(
-                mInterceptKeyBeforeDispatchingResult)) {
+    if (inputdispatcher::KeyEntry::InterceptKeyResult* result =
+                std::get_if<inputdispatcher::KeyEntry::InterceptKeyResult>(
+                        &mInterceptKeyBeforeDispatchingResult)) {
+        if (*result == inputdispatcher::KeyEntry::InterceptKeyResult::SKIP) {
+            mKeysConsumedByPolicy.emplace(event);
+        }
         return mInterceptKeyBeforeDispatchingResult;
     }
 
@@ -430,6 +434,15 @@ FakeInputDispatcherPolicy::interceptKeyBeforeDispatching(const sp<IBinder>&, con
     return delay;
 }
 
+void FakeInputDispatcherPolicy::assertKeyConsumedByPolicy(
+        const ::testing::Matcher<KeyEvent>& matcher) {
+    ASSERT_THAT(*mKeysConsumedByPolicy.popWithTimeout(100ms), matcher);
+}
+
+void FakeInputDispatcherPolicy::assertNoKeysConsumedByPolicy() {
+    ASSERT_TRUE(mKeysConsumedByPolicy.empty());
+}
+
 std::optional<KeyEvent> FakeInputDispatcherPolicy::dispatchUnhandledKey(const sp<IBinder>&,
                                                                         const KeyEvent& event,
                                                                         uint32_t) {
diff --git a/services/inputflinger/tests/FakeInputDispatcherPolicy.h b/services/inputflinger/tests/FakeInputDispatcherPolicy.h
index b151686e9b..ada0bf130c 100644
--- a/services/inputflinger/tests/FakeInputDispatcherPolicy.h
+++ b/services/inputflinger/tests/FakeInputDispatcherPolicy.h
@@ -20,6 +20,7 @@
 
 #include "InputDispatcherInterface.h"
 #include "NotifyArgs.h"
+#include "TestEventMatchers.h"
 
 #include <condition_variable>
 #include <functional>
@@ -119,6 +120,8 @@ public:
     void setInterceptKeyBeforeDispatchingResult(
             std::variant<nsecs_t, inputdispatcher::KeyEntry::InterceptKeyResult> result);
     void assertFocusedDisplayNotified(ui::LogicalDisplayId expectedDisplay);
+    void assertKeyConsumedByPolicy(const ::testing::Matcher<KeyEvent>& matcher);
+    void assertNoKeysConsumedByPolicy();
 
 private:
     std::mutex mLock;
@@ -150,6 +153,7 @@ private:
 
     std::variant<nsecs_t, inputdispatcher::KeyEntry::InterceptKeyResult>
             mInterceptKeyBeforeDispatchingResult;
+    BlockingQueue<KeyEvent> mKeysConsumedByPolicy;
 
     BlockingQueue<std::pair<int32_t /*deviceId*/, std::set<gui::Uid>>> mNotifiedInteractions;
 
diff --git a/services/inputflinger/tests/FakeInputTracingBackend.cpp b/services/inputflinger/tests/FakeInputTracingBackend.cpp
index b46055ed1c..9f69643ec4 100644
--- a/services/inputflinger/tests/FakeInputTracingBackend.cpp
+++ b/services/inputflinger/tests/FakeInputTracingBackend.cpp
@@ -42,7 +42,7 @@ MotionEvent toInputEvent(const trace::TracedMotionEvent& e,
                          const std::array<uint8_t, 32>& hmac) {
     MotionEvent traced;
     traced.initialize(e.id, e.deviceId, e.source, e.displayId, hmac, e.action, e.actionButton,
-                      dispatchArgs.resolvedFlags, e.edgeFlags, e.metaState, e.buttonState,
+                      dispatchArgs.resolvedMotionFlags, e.edgeFlags, e.metaState, e.buttonState,
                       e.classification, dispatchArgs.transform, e.xPrecision, e.yPrecision,
                       e.xCursorPosition, e.yCursorPosition, dispatchArgs.rawTransform, e.downTime,
                       e.eventTime, e.pointerProperties.size(), e.pointerProperties.data(),
@@ -53,9 +53,9 @@ MotionEvent toInputEvent(const trace::TracedMotionEvent& e,
 KeyEvent toInputEvent(const trace::TracedKeyEvent& e, const trace::WindowDispatchArgs& dispatchArgs,
                       const std::array<uint8_t, 32>& hmac) {
     KeyEvent traced;
-    traced.initialize(e.id, e.deviceId, e.source, e.displayId, hmac, e.action,
-                      dispatchArgs.resolvedFlags, e.keyCode, e.scanCode, e.metaState,
-                      dispatchArgs.resolvedKeyRepeatCount, e.downTime, e.eventTime);
+    traced.initialize(e.id, e.deviceId, e.source, e.displayId, hmac, e.action, e.flags, e.keyCode,
+                      e.scanCode, e.metaState, dispatchArgs.resolvedKeyRepeatCount, e.downTime,
+                      e.eventTime);
     return traced;
 }
 
diff --git a/services/inputflinger/tests/FakeWindows.cpp b/services/inputflinger/tests/FakeWindows.cpp
index b116521155..e24cd95a24 100644
--- a/services/inputflinger/tests/FakeWindows.cpp
+++ b/services/inputflinger/tests/FakeWindows.cpp
@@ -80,6 +80,13 @@ void FakeInputReceiver::sendTimeline(int32_t inputEventId,
     ASSERT_EQ(OK, status);
 }
 
+void FakeInputReceiver::consumeEvent(InputEventType expectedEventType, int32_t expectedAction,
+                                     std::optional<ui::LogicalDisplayId> expectedDisplayId,
+                                     std::optional<ftl::Flags<MotionFlag>> expectedFlags) {
+    consumeEvent(expectedEventType, expectedAction, expectedDisplayId,
+                 expectedFlags ? std::make_optional(expectedFlags->get()) : std::nullopt);
+}
+
 void FakeInputReceiver::consumeEvent(InputEventType expectedEventType, int32_t expectedAction,
                                      std::optional<ui::LogicalDisplayId> expectedDisplayId,
                                      std::optional<int32_t> expectedFlags) {
@@ -107,7 +114,8 @@ void FakeInputReceiver::consumeEvent(InputEventType expectedEventType, int32_t e
             const MotionEvent& motionEvent = static_cast<const MotionEvent&>(*event);
             ASSERT_THAT(motionEvent, WithMotionAction(expectedAction));
             if (expectedFlags.has_value()) {
-                EXPECT_EQ(expectedFlags.value(), motionEvent.getFlags());
+                EXPECT_EQ(expectedFlags.value(),
+                          static_cast<int32_t>(motionEvent.getFlags().get()));
             }
             break;
         }
@@ -147,6 +155,23 @@ void FakeInputReceiver::consumeMotionEvent(const ::testing::Matcher<MotionEvent>
     ASSERT_THAT(*motionEvent, matcher);
 }
 
+void FakeInputReceiver::consumeKeyEvent(const ::testing::Matcher<KeyEvent>& matcher) {
+    std::unique_ptr<InputEvent> event = consume(CONSUME_TIMEOUT_EVENT_EXPECTED);
+
+    if (event == nullptr) {
+        FAIL() << mName << ": expected a KeyEvent, but didn't get one.";
+        return;
+    }
+
+    if (event->getType() != InputEventType::KEY) {
+        FAIL() << mName << " expected a KeyEvent, got " << *event;
+        return;
+    }
+    const auto keyEvent = std::unique_ptr<KeyEvent>(static_cast<KeyEvent*>(event.release()));
+
+    ASSERT_THAT(*keyEvent, matcher);
+}
+
 void FakeInputReceiver::consumeFocusEvent(bool hasFocus, bool inTouchMode) {
     std::unique_ptr<InputEvent> event = consume(CONSUME_TIMEOUT_EVENT_EXPECTED);
     ASSERT_NE(nullptr, event) << mName.c_str() << ": consumer should have returned non-NULL event.";
diff --git a/services/inputflinger/tests/FakeWindows.h b/services/inputflinger/tests/FakeWindows.h
index 54dc25aaa0..3467d63817 100644
--- a/services/inputflinger/tests/FakeWindows.h
+++ b/services/inputflinger/tests/FakeWindows.h
@@ -20,6 +20,7 @@
 #include "TestEventMatchers.h"
 
 #include <android-base/logging.h>
+#include <ftl/flags.h>
 #include <gtest/gtest.h>
 #include <input/Input.h>
 #include <input/InputConsumer.h>
@@ -78,6 +79,10 @@ public:
 
     void sendTimeline(int32_t inputEventId, std::array<nsecs_t, GraphicsTimeline::SIZE> timeline);
 
+    void consumeEvent(android::InputEventType expectedEventType, int32_t expectedAction,
+                      std::optional<ui::LogicalDisplayId> expectedDisplayId,
+                      std::optional<ftl::Flags<MotionFlag>> expectedFlags);
+
     void consumeEvent(android::InputEventType expectedEventType, int32_t expectedAction,
                       std::optional<ui::LogicalDisplayId> expectedDisplayId,
                       std::optional<int32_t> expectedFlags);
@@ -85,6 +90,8 @@ public:
     std::unique_ptr<MotionEvent> consumeMotion();
     void consumeMotionEvent(const ::testing::Matcher<MotionEvent>& matcher);
 
+    void consumeKeyEvent(const ::testing::Matcher<KeyEvent>& matcher);
+
     void consumeFocusEvent(bool hasFocus, bool inTouchMode);
     void consumeCaptureEvent(bool hasCapture);
     void consumeDragEvent(bool isExiting, float x, float y);
@@ -188,6 +195,10 @@ public:
         mInfo.setInputConfig(InputConfig::GLOBAL_STYLUS_BLOCKS_TOUCH, shouldGlobalStylusBlockTouch);
     }
 
+    inline void setDoNotPilfer(bool doNotPilfer) {
+        mInfo.setInputConfig(InputConfig::DO_NOT_PILFER, doNotPilfer);
+    }
+
     inline void setAlpha(float alpha) { mInfo.alpha = alpha; }
 
     inline void setTouchOcclusionMode(gui::TouchOcclusionMode mode) {
@@ -258,15 +269,15 @@ public:
 
     inline void consumeMotionCancel(
             ui::LogicalDisplayId expectedDisplayId = ui::LogicalDisplayId::DEFAULT,
-            int32_t expectedFlags = 0) {
+            ftl::Flags<MotionFlag> expectedFlags = {}) {
         consumeMotionEvent(testing::AllOf(WithMotionAction(AMOTION_EVENT_ACTION_CANCEL),
                                           WithDisplayId(expectedDisplayId),
-                                          WithFlags(expectedFlags | AMOTION_EVENT_FLAG_CANCELED)));
+                                          WithFlags(expectedFlags | MotionFlag::CANCELED)));
     }
 
     inline void consumeMotionMove(
             ui::LogicalDisplayId expectedDisplayId = ui::LogicalDisplayId::DEFAULT,
-            int32_t expectedFlags = 0) {
+            ftl::Flags<MotionFlag> expectedFlags = {}) {
         consumeMotionEvent(testing::AllOf(WithMotionAction(AMOTION_EVENT_ACTION_MOVE),
                                           WithDisplayId(expectedDisplayId),
                                           WithFlags(expectedFlags)));
@@ -274,13 +285,13 @@ public:
 
     inline void consumeMotionDown(
             ui::LogicalDisplayId expectedDisplayId = ui::LogicalDisplayId::DEFAULT,
-            int32_t expectedFlags = 0) {
+            ftl::Flags<MotionFlag> expectedFlags = {}) {
         consumeAnyMotionDown(expectedDisplayId, expectedFlags);
     }
 
     inline void consumeAnyMotionDown(
             std::optional<ui::LogicalDisplayId> expectedDisplayId = std::nullopt,
-            std::optional<int32_t> expectedFlags = std::nullopt) {
+            std::optional<ftl::Flags<MotionFlag>> expectedFlags = std::nullopt) {
         consumeMotionEvent(
                 testing::AllOf(WithMotionAction(AMOTION_EVENT_ACTION_DOWN),
                                testing::Conditional(expectedDisplayId.has_value(),
@@ -292,7 +303,7 @@ public:
     inline void consumeMotionPointerDown(
             int32_t pointerIdx,
             ui::LogicalDisplayId expectedDisplayId = ui::LogicalDisplayId::DEFAULT,
-            int32_t expectedFlags = 0) {
+            ftl::Flags<MotionFlag> expectedFlags = {}) {
         const int32_t action = AMOTION_EVENT_ACTION_POINTER_DOWN |
                 (pointerIdx << AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT);
         consumeMotionEvent(testing::AllOf(WithMotionAction(action),
@@ -316,7 +327,7 @@ public:
 
     inline void consumeMotionUp(
             ui::LogicalDisplayId expectedDisplayId = ui::LogicalDisplayId::DEFAULT,
-            int32_t expectedFlags = 0) {
+            ftl::Flags<MotionFlag> expectedFlags = {}) {
         consumeMotionEvent(testing::AllOf(WithMotionAction(AMOTION_EVENT_ACTION_UP),
                                           WithDisplayId(expectedDisplayId),
                                           WithFlags(expectedFlags)));
@@ -324,7 +335,7 @@ public:
 
     inline void consumeMotionOutside(
             ui::LogicalDisplayId expectedDisplayId = ui::LogicalDisplayId::DEFAULT,
-            int32_t expectedFlags = 0) {
+            ftl::Flags<MotionFlag> expectedFlags = {}) {
         consumeMotionEvent(testing::AllOf(WithMotionAction(AMOTION_EVENT_ACTION_OUTSIDE),
                                           WithDisplayId(expectedDisplayId),
                                           WithFlags(expectedFlags)));
diff --git a/services/inputflinger/tests/GestureConverter_test.cpp b/services/inputflinger/tests/GestureConverter_test.cpp
index 35310a529b..ca97908041 100644
--- a/services/inputflinger/tests/GestureConverter_test.cpp
+++ b/services/inputflinger/tests/GestureConverter_test.cpp
@@ -285,8 +285,6 @@ TEST_F(GestureConverterTest, DragWithButton) {
 }
 
 TEST_F(GestureConverterTest, Scroll) {
-    input_flags::enable_touchpad_no_focus_change(true);
-
     const nsecs_t downTime = 12345;
     InputDeviceContext deviceContext(*mDevice, EVENTHUB_ID);
     GestureConverter converter(*mReader->getContext(), deviceContext, DEVICE_ID);
@@ -308,8 +306,8 @@ TEST_F(GestureConverterTest, Scroll) {
     ASSERT_THAT(args,
                 Each(VariantWith<NotifyMotionArgs>(
                         AllOf(WithMotionClassification(MotionClassification::TWO_FINGER_SWIPE),
-                              WithFlags(AMOTION_EVENT_FLAG_IS_GENERATED_GESTURE |
-                                        AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE),
+                              WithFlags({MotionFlag::IS_GENERATED_GESTURE,
+                                         MotionFlag::NO_FOCUS_CHANGE}),
                               WithToolType(ToolType::FINGER),
                               WithDisplayId(ui::LogicalDisplayId::DEFAULT)))));
 
@@ -321,8 +319,8 @@ TEST_F(GestureConverterTest, Scroll) {
                               WithGestureScrollDistance(0, 5, EPSILON),
                               WithMotionClassification(MotionClassification::TWO_FINGER_SWIPE),
                               WithToolType(ToolType::FINGER),
-                              WithFlags(AMOTION_EVENT_FLAG_IS_GENERATED_GESTURE |
-                                        AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE),
+                              WithFlags({MotionFlag::IS_GENERATED_GESTURE,
+                                         MotionFlag::NO_FOCUS_CHANGE}),
                               WithDisplayId(ui::LogicalDisplayId::DEFAULT)))));
 
     Gesture flingGesture(kGestureFling, ARBITRARY_GESTURE_TIME, ARBITRARY_GESTURE_TIME, 1, 1,
@@ -335,8 +333,8 @@ TEST_F(GestureConverterTest, Scroll) {
                                           WithGestureScrollDistance(0, 0, EPSILON),
                                           WithMotionClassification(
                                                   MotionClassification::TWO_FINGER_SWIPE),
-                                          WithFlags(AMOTION_EVENT_FLAG_IS_GENERATED_GESTURE |
-                                                    AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE))),
+                                          WithFlags({MotionFlag::IS_GENERATED_GESTURE,
+                                                     MotionFlag::NO_FOCUS_CHANGE}))),
                             VariantWith<NotifyMotionArgs>(
                                     AllOf(WithMotionAction(AMOTION_EVENT_ACTION_HOVER_ENTER),
                                           WithCoords(0, 0),
@@ -957,8 +955,6 @@ TEST_F(GestureConverterTest, DisablingSystemGestures_EndsOngoingMultiFingerSwipe
 }
 
 TEST_F(GestureConverterTest, Pinch_Inwards) {
-    input_flags::enable_touchpad_no_focus_change(true);
-
     InputDeviceContext deviceContext(*mDevice, EVENTHUB_ID);
     GestureConverter converter(*mReader->getContext(), deviceContext, DEVICE_ID);
     converter.setDisplayId(ui::LogicalDisplayId::DEFAULT);
@@ -982,7 +978,7 @@ TEST_F(GestureConverterTest, Pinch_Inwards) {
                               WithGesturePinchScaleFactor(1.0f, EPSILON),
                               WithToolType(ToolType::FINGER),
                               WithDisplayId(ui::LogicalDisplayId::DEFAULT),
-                              WithFlags(AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE)))));
+                              WithFlags(MotionFlag::NO_FOCUS_CHANGE)))));
 
     Gesture updateGesture(kGesturePinch, ARBITRARY_GESTURE_TIME, ARBITRARY_GESTURE_TIME,
                           /* dz= */ 0.8, GESTURES_ZOOM_UPDATE);
@@ -995,7 +991,7 @@ TEST_F(GestureConverterTest, Pinch_Inwards) {
                               WithPointerCoords(0, -80, 0), WithPointerCoords(1, 80, 0),
                               WithPointerCount(2u), WithToolType(ToolType::FINGER),
                               WithDisplayId(ui::LogicalDisplayId::DEFAULT),
-                              WithFlags(AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE)))));
+                              WithFlags(MotionFlag::NO_FOCUS_CHANGE)))));
 
     Gesture endGesture(kGesturePinch, ARBITRARY_GESTURE_TIME, ARBITRARY_GESTURE_TIME, /* dz= */ 1,
                        GESTURES_ZOOM_END);
@@ -1008,13 +1004,13 @@ TEST_F(GestureConverterTest, Pinch_Inwards) {
                                           WithMotionClassification(MotionClassification::PINCH),
                                           WithGesturePinchScaleFactor(1.0f, EPSILON),
                                           WithPointerCount(2u),
-                                          WithFlags(AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE))),
+                                          WithFlags(MotionFlag::NO_FOCUS_CHANGE))),
                             VariantWith<NotifyMotionArgs>(
                                     AllOf(WithMotionAction(AMOTION_EVENT_ACTION_UP),
                                           WithMotionClassification(MotionClassification::PINCH),
                                           WithGesturePinchScaleFactor(1.0f, EPSILON),
                                           WithPointerCount(1u),
-                                          WithFlags(AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE))),
+                                          WithFlags(MotionFlag::NO_FOCUS_CHANGE))),
                             VariantWith<NotifyMotionArgs>(
                                     AllOf(WithMotionAction(AMOTION_EVENT_ACTION_HOVER_ENTER),
                                           WithCoords(0, 0),
@@ -1026,8 +1022,6 @@ TEST_F(GestureConverterTest, Pinch_Inwards) {
 }
 
 TEST_F(GestureConverterTest, Pinch_Outwards) {
-    input_flags::enable_touchpad_no_focus_change(true);
-
     InputDeviceContext deviceContext(*mDevice, EVENTHUB_ID);
     GestureConverter converter(*mReader->getContext(), deviceContext, DEVICE_ID);
     converter.setDisplayId(ui::LogicalDisplayId::DEFAULT);
@@ -1051,7 +1045,7 @@ TEST_F(GestureConverterTest, Pinch_Outwards) {
                               WithGesturePinchScaleFactor(1.0f, EPSILON),
                               WithToolType(ToolType::FINGER),
                               WithDisplayId(ui::LogicalDisplayId::DEFAULT),
-                              WithFlags(AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE)))));
+                              WithFlags(MotionFlag::NO_FOCUS_CHANGE)))));
 
     Gesture updateGesture(kGesturePinch, ARBITRARY_GESTURE_TIME, ARBITRARY_GESTURE_TIME,
                           /* dz= */ 1.1, GESTURES_ZOOM_UPDATE);
@@ -1064,7 +1058,7 @@ TEST_F(GestureConverterTest, Pinch_Outwards) {
                               WithPointerCoords(0, -110, 0), WithPointerCoords(1, 110, 0),
                               WithPointerCount(2u), WithToolType(ToolType::FINGER),
                               WithDisplayId(ui::LogicalDisplayId::DEFAULT),
-                              WithFlags(AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE)))));
+                              WithFlags(MotionFlag::NO_FOCUS_CHANGE)))));
 
     Gesture endGesture(kGesturePinch, ARBITRARY_GESTURE_TIME, ARBITRARY_GESTURE_TIME, /* dz= */ 1,
                        GESTURES_ZOOM_END);
@@ -1077,13 +1071,13 @@ TEST_F(GestureConverterTest, Pinch_Outwards) {
                                           WithMotionClassification(MotionClassification::PINCH),
                                           WithGesturePinchScaleFactor(1.0f, EPSILON),
                                           WithPointerCount(2u),
-                                          WithFlags(AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE))),
+                                          WithFlags(MotionFlag::NO_FOCUS_CHANGE))),
                             VariantWith<NotifyMotionArgs>(
                                     AllOf(WithMotionAction(AMOTION_EVENT_ACTION_UP),
                                           WithMotionClassification(MotionClassification::PINCH),
                                           WithGesturePinchScaleFactor(1.0f, EPSILON),
                                           WithPointerCount(1u),
-                                          WithFlags(AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE))),
+                                          WithFlags(MotionFlag::NO_FOCUS_CHANGE))),
                             VariantWith<NotifyMotionArgs>(
                                     AllOf(WithMotionAction(AMOTION_EVENT_ACTION_HOVER_ENTER),
                                           WithCoords(0, 0),
@@ -1179,8 +1173,6 @@ TEST_F(GestureConverterTest, ResetWithButtonPressed) {
 }
 
 TEST_F(GestureConverterTest, ResetDuringScroll) {
-    input_flags::enable_touchpad_no_focus_change(true);
-
     InputDeviceContext deviceContext(*mDevice, EVENTHUB_ID);
     GestureConverter converter(*mReader->getContext(), deviceContext, DEVICE_ID);
     converter.setDisplayId(ui::LogicalDisplayId::DEFAULT);
@@ -1196,8 +1188,8 @@ TEST_F(GestureConverterTest, ResetDuringScroll) {
                                           WithGestureScrollDistance(0, 0, EPSILON),
                                           WithMotionClassification(
                                                   MotionClassification::TWO_FINGER_SWIPE),
-                                          WithFlags(AMOTION_EVENT_FLAG_IS_GENERATED_GESTURE |
-                                                    AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE))),
+                                          WithFlags({MotionFlag::IS_GENERATED_GESTURE,
+                                                     MotionFlag::NO_FOCUS_CHANGE}))),
                             VariantWith<NotifyMotionArgs>(
                                     AllOf(WithMotionAction(AMOTION_EVENT_ACTION_HOVER_ENTER),
                                           WithCoords(0, 0),
diff --git a/services/inputflinger/tests/InputDispatcher_test.cpp b/services/inputflinger/tests/InputDispatcher_test.cpp
index 298ba4209a..43c56ac197 100644
--- a/services/inputflinger/tests/InputDispatcher_test.cpp
+++ b/services/inputflinger/tests/InputDispatcher_test.cpp
@@ -119,12 +119,9 @@ static constexpr gui::Uid SECONDARY_WINDOW_UID{1012};
 // An arbitrary pid of the gesture monitor window
 static constexpr gui::Pid MONITOR_PID{2001};
 
-static constexpr int32_t FLAG_WINDOW_IS_OBSCURED = AMOTION_EVENT_FLAG_WINDOW_IS_OBSCURED;
-static constexpr int32_t FLAG_WINDOW_IS_PARTIALLY_OBSCURED =
-        AMOTION_EVENT_FLAG_WINDOW_IS_PARTIALLY_OBSCURED;
-
-static constexpr int EXPECTED_WALLPAPER_FLAGS =
-        FLAG_WINDOW_IS_OBSCURED | FLAG_WINDOW_IS_PARTIALLY_OBSCURED;
+static constexpr ftl::Flags<MotionFlag>
+        EXPECTED_WALLPAPER_FLAGS{MotionFlag::WINDOW_IS_OBSCURED,
+                                 MotionFlag::WINDOW_IS_PARTIALLY_OBSCURED};
 
 using ReservedInputDeviceId::VIRTUAL_KEYBOARD_ID;
 
@@ -183,7 +180,8 @@ protected:
         mFakePolicy = std::make_unique<FakeInputDispatcherPolicy>();
         mDispatcher = std::make_unique<InputDispatcher>(*mFakePolicy,
                                                         std::make_unique<FakeInputTracingBackend>(
-                                                                mVerifyingTrace));
+                                                                mVerifyingTrace),
+                                                        /*env=*/nullptr);
 
         mDispatcher->setInputDispatchMode(/*enabled=*/true, /*frozen=*/false);
         // Start InputDispatcher thread
@@ -286,7 +284,7 @@ TEST_F(InputDispatcherTest, InjectInputEvent_ValidatesMotionEvents) {
     ui::Transform identityTransform;
     // Rejects undefined motion actions.
     event.initialize(InputEvent::nextId(), DEVICE_ID, source, DISPLAY_ID, INVALID_HMAC,
-                     /*action=*/-1, 0, 0, edgeFlags, metaState, 0, classification,
+                     /*action=*/-1, 0, /*flags=*/{}, edgeFlags, metaState, 0, classification,
                      identityTransform, 0, 0, AMOTION_EVENT_INVALID_CURSOR_POSITION,
                      AMOTION_EVENT_INVALID_CURSOR_POSITION, identityTransform, ARBITRARY_TIME,
                      ARBITRARY_TIME,
@@ -298,7 +296,7 @@ TEST_F(InputDispatcherTest, InjectInputEvent_ValidatesMotionEvents) {
 
     // Rejects pointer down with invalid index.
     event.initialize(InputEvent::nextId(), DEVICE_ID, source, DISPLAY_ID, INVALID_HMAC,
-                     POINTER_1_DOWN, 0, 0, edgeFlags, metaState, 0, classification,
+                     POINTER_1_DOWN, 0, /*flags=*/{}, edgeFlags, metaState, 0, classification,
                      identityTransform, 0, 0, AMOTION_EVENT_INVALID_CURSOR_POSITION,
                      AMOTION_EVENT_INVALID_CURSOR_POSITION, identityTransform, ARBITRARY_TIME,
                      ARBITRARY_TIME,
@@ -311,9 +309,10 @@ TEST_F(InputDispatcherTest, InjectInputEvent_ValidatesMotionEvents) {
     event.initialize(InputEvent::nextId(), DEVICE_ID, source, DISPLAY_ID, INVALID_HMAC,
                      AMOTION_EVENT_ACTION_POINTER_DOWN |
                              (~0U << AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT),
-                     0, 0, edgeFlags, metaState, 0, classification, identityTransform, 0, 0,
-                     AMOTION_EVENT_INVALID_CURSOR_POSITION, AMOTION_EVENT_INVALID_CURSOR_POSITION,
-                     identityTransform, ARBITRARY_TIME, ARBITRARY_TIME,
+                     0, /*flags=*/{}, edgeFlags, metaState, 0, classification, identityTransform, 0,
+                     0, AMOTION_EVENT_INVALID_CURSOR_POSITION,
+                     AMOTION_EVENT_INVALID_CURSOR_POSITION, identityTransform, ARBITRARY_TIME,
+                     ARBITRARY_TIME,
                      /*pointerCount=*/1, pointerProperties, pointerCoords);
     ASSERT_EQ(InputEventInjectionResult::FAILED,
               mDispatcher->injectInputEvent(&event, /*targetUid=*/{}, InputEventInjectionSync::NONE,
@@ -322,8 +321,8 @@ TEST_F(InputDispatcherTest, InjectInputEvent_ValidatesMotionEvents) {
 
     // Rejects pointer up with invalid index.
     event.initialize(InputEvent::nextId(), DEVICE_ID, source, DISPLAY_ID, INVALID_HMAC,
-                     POINTER_1_UP, 0, 0, edgeFlags, metaState, 0, classification, identityTransform,
-                     0, 0, AMOTION_EVENT_INVALID_CURSOR_POSITION,
+                     POINTER_1_UP, 0, /*flags=*/{}, edgeFlags, metaState, 0, classification,
+                     identityTransform, 0, 0, AMOTION_EVENT_INVALID_CURSOR_POSITION,
                      AMOTION_EVENT_INVALID_CURSOR_POSITION, identityTransform, ARBITRARY_TIME,
                      ARBITRARY_TIME,
                      /*pointerCount=*/1, pointerProperties, pointerCoords);
@@ -335,9 +334,10 @@ TEST_F(InputDispatcherTest, InjectInputEvent_ValidatesMotionEvents) {
     event.initialize(InputEvent::nextId(), DEVICE_ID, source, DISPLAY_ID, INVALID_HMAC,
                      AMOTION_EVENT_ACTION_POINTER_UP |
                              (~0U << AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT),
-                     0, 0, edgeFlags, metaState, 0, classification, identityTransform, 0, 0,
-                     AMOTION_EVENT_INVALID_CURSOR_POSITION, AMOTION_EVENT_INVALID_CURSOR_POSITION,
-                     identityTransform, ARBITRARY_TIME, ARBITRARY_TIME,
+                     0, /*flags=*/{}, edgeFlags, metaState, 0, classification, identityTransform, 0,
+                     0, AMOTION_EVENT_INVALID_CURSOR_POSITION,
+                     AMOTION_EVENT_INVALID_CURSOR_POSITION, identityTransform, ARBITRARY_TIME,
+                     ARBITRARY_TIME,
                      /*pointerCount=*/1, pointerProperties, pointerCoords);
     ASSERT_EQ(InputEventInjectionResult::FAILED,
               mDispatcher->injectInputEvent(&event, /*targetUid=*/{}, InputEventInjectionSync::NONE,
@@ -346,8 +346,8 @@ TEST_F(InputDispatcherTest, InjectInputEvent_ValidatesMotionEvents) {
 
     // Rejects motion events with invalid number of pointers.
     event.initialize(InputEvent::nextId(), DEVICE_ID, source, DISPLAY_ID, INVALID_HMAC,
-                     AMOTION_EVENT_ACTION_DOWN, 0, 0, edgeFlags, metaState, 0, classification,
-                     identityTransform, 0, 0, AMOTION_EVENT_INVALID_CURSOR_POSITION,
+                     AMOTION_EVENT_ACTION_DOWN, 0, /*flags=*/{}, edgeFlags, metaState, 0,
+                     classification, identityTransform, 0, 0, AMOTION_EVENT_INVALID_CURSOR_POSITION,
                      AMOTION_EVENT_INVALID_CURSOR_POSITION, identityTransform, ARBITRARY_TIME,
                      ARBITRARY_TIME,
                      /*pointerCount=*/0, pointerProperties, pointerCoords);
@@ -357,8 +357,8 @@ TEST_F(InputDispatcherTest, InjectInputEvent_ValidatesMotionEvents) {
             << "Should reject motion events with 0 pointers.";
 
     event.initialize(InputEvent::nextId(), DEVICE_ID, source, DISPLAY_ID, INVALID_HMAC,
-                     AMOTION_EVENT_ACTION_DOWN, 0, 0, edgeFlags, metaState, 0, classification,
-                     identityTransform, 0, 0, AMOTION_EVENT_INVALID_CURSOR_POSITION,
+                     AMOTION_EVENT_ACTION_DOWN, 0, /*flags=*/{}, edgeFlags, metaState, 0,
+                     classification, identityTransform, 0, 0, AMOTION_EVENT_INVALID_CURSOR_POSITION,
                      AMOTION_EVENT_INVALID_CURSOR_POSITION, identityTransform, ARBITRARY_TIME,
                      ARBITRARY_TIME,
                      /*pointerCount=*/MAX_POINTERS + 1, pointerProperties, pointerCoords);
@@ -370,8 +370,8 @@ TEST_F(InputDispatcherTest, InjectInputEvent_ValidatesMotionEvents) {
     // Rejects motion events with invalid pointer ids.
     pointerProperties[0].id = -1;
     event.initialize(InputEvent::nextId(), DEVICE_ID, source, DISPLAY_ID, INVALID_HMAC,
-                     AMOTION_EVENT_ACTION_DOWN, 0, 0, edgeFlags, metaState, 0, classification,
-                     identityTransform, 0, 0, AMOTION_EVENT_INVALID_CURSOR_POSITION,
+                     AMOTION_EVENT_ACTION_DOWN, 0, /*flags=*/{}, edgeFlags, metaState, 0,
+                     classification, identityTransform, 0, 0, AMOTION_EVENT_INVALID_CURSOR_POSITION,
                      AMOTION_EVENT_INVALID_CURSOR_POSITION, identityTransform, ARBITRARY_TIME,
                      ARBITRARY_TIME,
                      /*pointerCount=*/1, pointerProperties, pointerCoords);
@@ -382,8 +382,8 @@ TEST_F(InputDispatcherTest, InjectInputEvent_ValidatesMotionEvents) {
 
     pointerProperties[0].id = MAX_POINTER_ID + 1;
     event.initialize(InputEvent::nextId(), DEVICE_ID, source, DISPLAY_ID, INVALID_HMAC,
-                     AMOTION_EVENT_ACTION_DOWN, 0, 0, edgeFlags, metaState, 0, classification,
-                     identityTransform, 0, 0, AMOTION_EVENT_INVALID_CURSOR_POSITION,
+                     AMOTION_EVENT_ACTION_DOWN, 0, /*flags=*/{}, edgeFlags, metaState, 0,
+                     classification, identityTransform, 0, 0, AMOTION_EVENT_INVALID_CURSOR_POSITION,
                      AMOTION_EVENT_INVALID_CURSOR_POSITION, identityTransform, ARBITRARY_TIME,
                      ARBITRARY_TIME,
                      /*pointerCount=*/1, pointerProperties, pointerCoords);
@@ -396,8 +396,8 @@ TEST_F(InputDispatcherTest, InjectInputEvent_ValidatesMotionEvents) {
     pointerProperties[0].id = 1;
     pointerProperties[1].id = 1;
     event.initialize(InputEvent::nextId(), DEVICE_ID, source, DISPLAY_ID, INVALID_HMAC,
-                     AMOTION_EVENT_ACTION_DOWN, 0, 0, edgeFlags, metaState, 0, classification,
-                     identityTransform, 0, 0, AMOTION_EVENT_INVALID_CURSOR_POSITION,
+                     AMOTION_EVENT_ACTION_DOWN, 0, /*flags=*/{}, edgeFlags, metaState, 0,
+                     classification, identityTransform, 0, 0, AMOTION_EVENT_INVALID_CURSOR_POSITION,
                      AMOTION_EVENT_INVALID_CURSOR_POSITION, identityTransform, ARBITRARY_TIME,
                      ARBITRARY_TIME,
                      /*pointerCount=*/2, pointerProperties, pointerCoords);
@@ -426,7 +426,8 @@ class FakeMonitorReceiver {
 public:
     FakeMonitorReceiver(InputDispatcher& dispatcher, const std::string name,
                         ui::LogicalDisplayId displayId)
-          : mInputReceiver(*dispatcher.createInputMonitor(displayId, name, MONITOR_PID), name) {}
+          : mInputReceiver(*dispatcher.createFocusInputMonitor(displayId, name, MONITOR_PID),
+                           name) {}
 
     sp<IBinder> getToken() { return mInputReceiver.getToken(); }
 
@@ -435,6 +436,10 @@ public:
                                     expectedFlags);
     }
 
+    void consumeKeyEvent(::testing::Matcher<KeyEvent> matcher) {
+        mInputReceiver.consumeKeyEvent(matcher);
+    }
+
     std::optional<int32_t> receiveEvent() {
         const auto [sequenceNum, _] = mInputReceiver.receiveEvent(CONSUME_TIMEOUT_EVENT_EXPECTED);
         return sequenceNum;
@@ -442,26 +447,29 @@ public:
 
     void finishEvent(uint32_t consumeSeq) { return mInputReceiver.finishEvent(consumeSeq); }
 
-    void consumeMotionDown(ui::LogicalDisplayId expectedDisplayId, int32_t expectedFlags = 0) {
+    void consumeMotionDown(ui::LogicalDisplayId expectedDisplayId,
+                           ftl::Flags<MotionFlag> expectedFlags = {}) {
         mInputReceiver.consumeEvent(InputEventType::MOTION, AMOTION_EVENT_ACTION_DOWN,
                                     expectedDisplayId, expectedFlags);
     }
 
-    void consumeMotionMove(ui::LogicalDisplayId expectedDisplayId, int32_t expectedFlags = 0) {
+    void consumeMotionMove(ui::LogicalDisplayId expectedDisplayId,
+                           ftl::Flags<MotionFlag> expectedFlags = {}) {
         mInputReceiver.consumeEvent(InputEventType::MOTION, AMOTION_EVENT_ACTION_MOVE,
                                     expectedDisplayId, expectedFlags);
     }
 
-    void consumeMotionUp(ui::LogicalDisplayId expectedDisplayId, int32_t expectedFlags = 0) {
+    void consumeMotionUp(ui::LogicalDisplayId expectedDisplayId,
+                         ftl::Flags<MotionFlag> expectedFlags = {}) {
         mInputReceiver.consumeEvent(InputEventType::MOTION, AMOTION_EVENT_ACTION_UP,
                                     expectedDisplayId, expectedFlags);
     }
 
-    void consumeMotionCancel(ui::LogicalDisplayId expectedDisplayId, int32_t expectedFlags = 0) {
-        mInputReceiver.consumeMotionEvent(
-                AllOf(WithMotionAction(AMOTION_EVENT_ACTION_CANCEL),
-                      WithDisplayId(expectedDisplayId),
-                      WithFlags(expectedFlags | AMOTION_EVENT_FLAG_CANCELED)));
+    void consumeMotionCancel(ui::LogicalDisplayId expectedDisplayId,
+                             ftl::Flags<MotionFlag> expectedFlags = {}) {
+        mInputReceiver.consumeMotionEvent(AllOf(WithMotionAction(AMOTION_EVENT_ACTION_CANCEL),
+                                                WithDisplayId(expectedDisplayId),
+                                                WithFlags(expectedFlags | MotionFlag::CANCELED)));
     }
 
     void consumeMotionPointerDown(int32_t pointerIdx) {
@@ -622,9 +630,8 @@ static NotifyKeyArgs generateKeyArgs(
     NotifyMotionArgs args(InputEvent::nextId(), currentTime, /*readTime=*/0, DEVICE_ID, source,
                           displayId, POLICY_FLAG_PASS_TO_USER, action, /*actionButton=*/0,
                           /*flags=*/0, AMETA_NONE, /*buttonState=*/0, MotionClassification::NONE,
-                          AMOTION_EVENT_EDGE_FLAG_NONE, pointerCount, pointerProperties,
-                          pointerCoords, /*xPrecision=*/0, /*yPrecision=*/0,
-                          AMOTION_EVENT_INVALID_CURSOR_POSITION,
+                          pointerCount, pointerProperties, pointerCoords, /*xPrecision=*/0,
+                          /*yPrecision=*/0, AMOTION_EVENT_INVALID_CURSOR_POSITION,
                           AMOTION_EVENT_INVALID_CURSOR_POSITION, currentTime, /*videoFrames=*/{});
 
     return args;
@@ -699,6 +706,24 @@ TEST_F(InputDispatcherDeathTest, DuplicateWindowInfosAbortDispatcher) {
                  "Incorrect WindowInfosUpdate provided");
 }
 
+/**
+ * InputDispatcher aborts when a window with DO_NOT_PILFER is not a trusted overlay.
+ */
+TEST_F(InputDispatcherDeathTest, DoNotPilferFlagRequiresTrustedOverlay) {
+    testing::GTEST_FLAG(death_test_style) = "threadsafe";
+    ScopedSilentDeath _silentDeath;
+
+    std::shared_ptr<FakeApplicationHandle> application = std::make_shared<FakeApplicationHandle>();
+    sp<FakeWindowHandle> window =
+            sp<FakeWindowHandle>::make(application, mDispatcher, "Fake Window",
+                                       ui::LogicalDisplayId::DEFAULT);
+    window->setDoNotPilfer(true);
+    window->setTrustedOverlay(true);
+    ASSERT_DEATH(mDispatcher->onWindowInfosChanged(
+                         {{*window->getInfo(), *window->getInfo()}, {}, 0, 0}),
+                 "Incorrect WindowInfosUpdate provided");
+}
+
 TEST_F(InputDispatcherTest, WhenDisplayNotSpecified_InjectMotionToDefaultDisplay) {
     std::shared_ptr<FakeApplicationHandle> application = std::make_shared<FakeApplicationHandle>();
     sp<FakeWindowHandle> window =
@@ -989,7 +1014,7 @@ TEST_F(InputDispatcherTest, MultiDeviceDisappearingWindowWithWallpaperWindows) {
             AllOf(WithMotionAction(ACTION_CANCEL), WithDeviceId(deviceB)));
     rightWallpaperWindow->consumeMotionEvent(
             AllOf(WithMotionAction(ACTION_CANCEL), WithDeviceId(deviceB),
-                  WithFlags(EXPECTED_WALLPAPER_FLAGS | AMOTION_EVENT_FLAG_CANCELED)));
+                  WithFlags(EXPECTED_WALLPAPER_FLAGS | MotionFlag::CANCELED)));
 }
 
 /**
@@ -1077,7 +1102,7 @@ TEST_F(InputDispatcherTest, MultiDeviceSlipperyTouchWithWallpaperWindow) {
             AllOf(WithMotionAction(ACTION_CANCEL), WithDeviceId(deviceB)));
     middleWallpaperWindow->consumeMotionEvent(
             AllOf(WithMotionAction(ACTION_CANCEL), WithDeviceId(deviceB),
-                  WithFlags(EXPECTED_WALLPAPER_FLAGS | AMOTION_EVENT_FLAG_CANCELED)));
+                  WithFlags(EXPECTED_WALLPAPER_FLAGS | MotionFlag::CANCELED)));
     rightForegroundWindow->consumeMotionEvent(
             AllOf(WithMotionAction(ACTION_DOWN), WithDeviceId(deviceB)));
     rightWallpaperWindow->consumeMotionEvent(AllOf(WithMotionAction(ACTION_DOWN),
@@ -1184,13 +1209,13 @@ TEST_F(InputDispatcherTest, MultiDeviceTouchTransferWithWallpaperWindows) {
             AllOf(WithMotionAction(ACTION_CANCEL), WithDeviceId(deviceB)));
     middleWallpaperWindow->consumeMotionEvent(
             AllOf(WithMotionAction(ACTION_CANCEL), WithDeviceId(deviceB),
-                  WithFlags(EXPECTED_WALLPAPER_FLAGS | AMOTION_EVENT_FLAG_CANCELED)));
+                  WithFlags(EXPECTED_WALLPAPER_FLAGS | MotionFlag::CANCELED)));
     rightForegroundWindow->consumeMotionEvent(AllOf(WithMotionAction(ACTION_DOWN),
                                                     WithDeviceId(deviceB),
-                                                    WithFlags(AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE)));
+                                                    WithFlags(MotionFlag::NO_FOCUS_CHANGE)));
     rightWallpaperWindow->consumeMotionEvent(
             AllOf(WithMotionAction(ACTION_DOWN), WithDeviceId(deviceB),
-                  WithFlags(EXPECTED_WALLPAPER_FLAGS | AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE)));
+                  WithFlags(EXPECTED_WALLPAPER_FLAGS | MotionFlag::NO_FOCUS_CHANGE)));
 
     // Make sure the right window can receive the remaining events.
     mDispatcher->notifyMotion(MotionArgsBuilder(ACTION_MOVE, AINPUT_SOURCE_TOUCHSCREEN)
@@ -1203,10 +1228,10 @@ TEST_F(InputDispatcherTest, MultiDeviceTouchTransferWithWallpaperWindows) {
     middleWallpaperWindow->assertNoEvents();
     rightForegroundWindow->consumeMotionEvent(AllOf(WithMotionAction(ACTION_MOVE),
                                                     WithDeviceId(deviceB),
-                                                    WithFlags(AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE)));
+                                                    WithFlags(MotionFlag::NO_FOCUS_CHANGE)));
     rightWallpaperWindow->consumeMotionEvent(
             AllOf(WithMotionAction(ACTION_MOVE), WithDeviceId(deviceB),
-                  WithFlags(EXPECTED_WALLPAPER_FLAGS | AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE)));
+                  WithFlags(EXPECTED_WALLPAPER_FLAGS | MotionFlag::NO_FOCUS_CHANGE)));
 }
 
 /**
@@ -5300,7 +5325,7 @@ TEST_F(InputDispatcherTest, InvalidA11yHoverStreamDoesNotCrash) {
     MotionEventBuilder hoverEnterBuilder =
             MotionEventBuilder(AMOTION_EVENT_ACTION_HOVER_ENTER, AINPUT_SOURCE_MOUSE)
                     .pointer(PointerBuilder(0, ToolType::MOUSE).x(300).y(400))
-                    .addFlag(AMOTION_EVENT_FLAG_IS_ACCESSIBILITY_EVENT);
+                    .addFlag(MotionFlag::IS_ACCESSIBILITY_EVENT);
     ASSERT_EQ(InputEventInjectionResult::SUCCEEDED,
               injectMotionEvent(*mDispatcher, hoverEnterBuilder.build()));
     window->consumeMotionEvent(WithMotionAction(AMOTION_EVENT_ACTION_HOVER_ENTER));
@@ -5327,7 +5352,7 @@ TEST_F(InputDispatcherTest, InvalidA11yEventsGetRejected) {
     auto injectFromAccessibility = [&](int32_t action, float x, float y) {
         MotionEvent event = MotionEventBuilder(action, AINPUT_SOURCE_TOUCHSCREEN)
                                     .pointer(PointerBuilder(0, ToolType::FINGER).x(x).y(y))
-                                    .addFlag(AMOTION_EVENT_FLAG_IS_ACCESSIBILITY_EVENT)
+                                    .addFlag(MotionFlag::IS_ACCESSIBILITY_EVENT)
                                     .build();
         return injectMotionEvent(*mDispatcher, event, 100ms,
                                  InputEventInjectionSync::WAIT_FOR_RESULT, /*targetUid=*/{},
@@ -5695,6 +5720,33 @@ TEST_F(InputDispatcherTest, InterceptKeyIfKeyUp) {
     window->consumeKeyUp(ui::LogicalDisplayId::DEFAULT);
 }
 
+/**
+ * Keys are sent to policy with correct displayId
+ */
+TEST_F(InputDispatcherTest, InterceptKeyBeforeDispatchingPolicy_getsCorrectDisplayId) {
+    std::shared_ptr<FakeApplicationHandle> application = std::make_shared<FakeApplicationHandle>();
+    sp<FakeWindowHandle> window =
+            sp<FakeWindowHandle>::make(application, mDispatcher, "Fake Window",
+                                       ui::LogicalDisplayId(2));
+    window->setFocusable(true);
+
+    mDispatcher->onWindowInfosChanged({{*window->getInfo()}, {}, 0, 0});
+    mDispatcher->setFocusedDisplay(ui::LogicalDisplayId(2));
+    setFocusedWindow(window);
+
+    window->consumeFocusEvent(true);
+
+    mFakePolicy->setInterceptKeyBeforeDispatchingResult(
+            inputdispatcher::KeyEntry::InterceptKeyResult::SKIP);
+
+    mDispatcher->notifyKey(KeyArgsBuilder(ACTION_DOWN, AINPUT_SOURCE_KEYBOARD)
+                                   .keyCode(AKEYCODE_A)
+                                   .displayId(ui::LogicalDisplayId::INVALID)
+                                   .build());
+    mFakePolicy->assertKeyConsumedByPolicy(
+            AllOf(WithKeyCode(AKEYCODE_A), WithDisplayId(ui::LogicalDisplayId(2))));
+}
+
 /**
  * Two windows. First is a regular window. Second does not overlap with the first, and has
  * WATCH_OUTSIDE_TOUCH.
@@ -6714,15 +6766,11 @@ TEST_F(InputDispatcherDisplayProjectionTest, UseCloneLayerStackTransformForRawCo
 
 TEST_F(InputDispatcherDisplayProjectionTest, CancelMotionWithCorrectCoordinates) {
     auto [firstWindow, secondWindow] = setupScaledDisplayScenario();
-    // The monitor will always receive events in the logical display's coordinate space, because
-    // it does not have a window.
-    FakeMonitorReceiver monitor{*mDispatcher, "Monitor", ui::LogicalDisplayId::DEFAULT};
 
     // Send down to the first window.
     mDispatcher->notifyMotion(generateMotionArgs(ACTION_DOWN, AINPUT_SOURCE_TOUCHSCREEN,
                                                  ui::LogicalDisplayId::DEFAULT, {PointF{50, 100}}));
     firstWindow->consumeMotionEvent(AllOf(WithMotionAction(ACTION_DOWN), WithCoords(100, 400)));
-    monitor.consumeMotionEvent(AllOf(WithMotionAction(ACTION_DOWN), WithCoords(100, 400)));
 
     // Second pointer goes down on second window.
     mDispatcher->notifyMotion(generateMotionArgs(POINTER_1_DOWN, AINPUT_SOURCE_TOUCHSCREEN,
@@ -6731,15 +6779,11 @@ TEST_F(InputDispatcherDisplayProjectionTest, CancelMotionWithCorrectCoordinates)
     secondWindow->consumeMotionEvent(AllOf(WithMotionAction(ACTION_DOWN), WithCoords(100, 80)));
     const std::map<int32_t, PointF> expectedMonitorPointers{{0, PointF{100, 400}},
                                                             {1, PointF{300, 880}}};
-    monitor.consumeMotionEvent(
-            AllOf(WithMotionAction(POINTER_1_DOWN), WithPointers(expectedMonitorPointers)));
 
     mDispatcher->cancelCurrentTouch();
 
     firstWindow->consumeMotionEvent(AllOf(WithMotionAction(ACTION_CANCEL), WithCoords(100, 400)));
     secondWindow->consumeMotionEvent(AllOf(WithMotionAction(ACTION_CANCEL), WithCoords(100, 80)));
-    monitor.consumeMotionEvent(
-            AllOf(WithMotionAction(ACTION_CANCEL), WithPointers(expectedMonitorPointers)));
 }
 
 TEST_F(InputDispatcherDisplayProjectionTest, SynthesizeDownWithCorrectCoordinates) {
@@ -7008,12 +7052,12 @@ TEST_P(InputDispatcherDisplayOrientationFixture, BlockUntrustClickInDifferentOri
                 generateMotionArgs(AMOTION_EVENT_ACTION_DOWN, AINPUT_SOURCE_TOUCHSCREEN,
                                    ui::LogicalDisplayId::DEFAULT, {pointInDisplaySpace}));
         simpleAppWindow->consumeMotionDown(ui::LogicalDisplayId::DEFAULT,
-                                           AMOTION_EVENT_FLAG_WINDOW_IS_PARTIALLY_OBSCURED);
+                                           MotionFlag::WINDOW_IS_PARTIALLY_OBSCURED);
         mDispatcher->notifyMotion(
                 generateMotionArgs(AMOTION_EVENT_ACTION_UP, AINPUT_SOURCE_TOUCHSCREEN,
                                    ui::LogicalDisplayId::DEFAULT, {pointInDisplaySpace}));
         simpleAppWindow->consumeMotionUp(ui::LogicalDisplayId::DEFAULT,
-                                         AMOTION_EVENT_FLAG_WINDOW_IS_PARTIALLY_OBSCURED);
+                                         MotionFlag::WINDOW_IS_PARTIALLY_OBSCURED);
     }
     untrustedWindow->assertNoEvents();
 }
@@ -7072,8 +7116,7 @@ TEST_P(TransferTouchFixture, TransferTouch_OnePointer) {
     ASSERT_TRUE(success);
     // The first window gets cancel and the second gets down
     firstWindow->consumeMotionCancel();
-    secondWindow->consumeMotionDown(ui::LogicalDisplayId::DEFAULT,
-                                    AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    secondWindow->consumeMotionDown(ui::LogicalDisplayId::DEFAULT, MotionFlag::NO_FOCUS_CHANGE);
     wallpaper->consumeMotionCancel(ui::LogicalDisplayId::DEFAULT, EXPECTED_WALLPAPER_FLAGS);
     // There should not be any changes to the focused window when transferring touch
     ASSERT_NO_FATAL_FAILURE(mFakePolicy->assertOnPointerDownWasNotCalled());
@@ -7083,8 +7126,7 @@ TEST_P(TransferTouchFixture, TransferTouch_OnePointer) {
                                                  ui::LogicalDisplayId::DEFAULT));
     // The first window gets no events and the second gets up
     firstWindow->assertNoEvents();
-    secondWindow->consumeMotionUp(ui::LogicalDisplayId::DEFAULT,
-                                  AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    secondWindow->consumeMotionUp(ui::LogicalDisplayId::DEFAULT, MotionFlag::NO_FOCUS_CHANGE);
     wallpaper->assertNoEvents();
 }
 
@@ -7133,8 +7175,7 @@ TEST_P(TransferTouchFixture, TransferTouch_MultipleWindowsWithSpy) {
     ASSERT_TRUE(success);
     // The first window gets cancel and the second gets down
     firstWindow->consumeMotionCancel();
-    secondWindow->consumeMotionDown(ui::LogicalDisplayId::DEFAULT,
-                                    AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    secondWindow->consumeMotionDown(ui::LogicalDisplayId::DEFAULT, MotionFlag::NO_FOCUS_CHANGE);
 
     // Send up event to the second window
     mDispatcher->notifyMotion(generateMotionArgs(AMOTION_EVENT_ACTION_UP, AINPUT_SOURCE_TOUCHSCREEN,
@@ -7142,8 +7183,7 @@ TEST_P(TransferTouchFixture, TransferTouch_MultipleWindowsWithSpy) {
     // The first  window gets no events and the second+spy get up
     firstWindow->assertNoEvents();
     spyWindow->consumeMotionUp();
-    secondWindow->consumeMotionUp(ui::LogicalDisplayId::DEFAULT,
-                                  AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    secondWindow->consumeMotionUp(ui::LogicalDisplayId::DEFAULT, MotionFlag::NO_FOCUS_CHANGE);
 }
 
 TEST_P(TransferTouchFixture, TransferTouch_TwoPointers) {
@@ -7185,10 +7225,9 @@ TEST_P(TransferTouchFixture, TransferTouch_TwoPointers) {
     ASSERT_TRUE(success);
     // The first window gets cancel and the second gets down and pointer down
     firstWindow->consumeMotionCancel();
-    secondWindow->consumeMotionDown(ui::LogicalDisplayId::DEFAULT,
-                                    AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    secondWindow->consumeMotionDown(ui::LogicalDisplayId::DEFAULT, MotionFlag::NO_FOCUS_CHANGE);
     secondWindow->consumeMotionPointerDown(1, ui::LogicalDisplayId::DEFAULT,
-                                           AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+                                           MotionFlag::NO_FOCUS_CHANGE);
 
     // Send pointer up to the second window
     mDispatcher->notifyMotion(generateMotionArgs(POINTER_1_UP, AINPUT_SOURCE_TOUCHSCREEN,
@@ -7198,7 +7237,7 @@ TEST_P(TransferTouchFixture, TransferTouch_TwoPointers) {
     firstWindow->assertNoEvents();
     secondWindow->consumeMotionPointerUp(/*pointerIdx=*/1,
                                          AllOf(WithDisplayId(ui::LogicalDisplayId::DEFAULT),
-                                               WithFlags(AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE),
+                                               WithFlags(MotionFlag::NO_FOCUS_CHANGE),
                                                WithPointerCount(2)));
 
     // Send up event to the second window
@@ -7206,8 +7245,7 @@ TEST_P(TransferTouchFixture, TransferTouch_TwoPointers) {
                                                  ui::LogicalDisplayId::DEFAULT));
     // The first window gets nothing and the second gets up
     firstWindow->assertNoEvents();
-    secondWindow->consumeMotionUp(ui::LogicalDisplayId::DEFAULT,
-                                  AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    secondWindow->consumeMotionUp(ui::LogicalDisplayId::DEFAULT, MotionFlag::NO_FOCUS_CHANGE);
 }
 
 TEST_P(TransferTouchFixture, TransferTouch_MultipleWallpapers) {
@@ -7257,22 +7295,20 @@ TEST_P(TransferTouchFixture, TransferTouch_MultipleWallpapers) {
 
     // The first window gets cancel and the second gets down
     firstWindow->consumeMotionCancel();
-    secondWindow->consumeMotionDown(ui::LogicalDisplayId::DEFAULT,
-                                    AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    secondWindow->consumeMotionDown(ui::LogicalDisplayId::DEFAULT, MotionFlag::NO_FOCUS_CHANGE);
     wallpaper1->consumeMotionCancel(ui::LogicalDisplayId::DEFAULT, EXPECTED_WALLPAPER_FLAGS);
     wallpaper2->consumeMotionDown(ui::LogicalDisplayId::DEFAULT,
-                                  EXPECTED_WALLPAPER_FLAGS | AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+                                  EXPECTED_WALLPAPER_FLAGS | MotionFlag::NO_FOCUS_CHANGE);
 
     // Send up event to the second window
     mDispatcher->notifyMotion(generateMotionArgs(AMOTION_EVENT_ACTION_UP, AINPUT_SOURCE_TOUCHSCREEN,
                                                  ui::LogicalDisplayId::DEFAULT));
     // The first  window gets no events and the second gets up
     firstWindow->assertNoEvents();
-    secondWindow->consumeMotionUp(ui::LogicalDisplayId::DEFAULT,
-                                  AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    secondWindow->consumeMotionUp(ui::LogicalDisplayId::DEFAULT, MotionFlag::NO_FOCUS_CHANGE);
     wallpaper1->assertNoEvents();
     wallpaper2->consumeMotionUp(ui::LogicalDisplayId::DEFAULT,
-                                EXPECTED_WALLPAPER_FLAGS | AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+                                EXPECTED_WALLPAPER_FLAGS | MotionFlag::NO_FOCUS_CHANGE);
 }
 
 // For the cases of single pointer touch and two pointers non-split touch, the api's
@@ -7335,7 +7371,7 @@ TEST_F(InputDispatcherTest, TransferTouch_TwoPointersSplitTouch) {
     // The first window gets cancel and the new gets pointer down (it already saw down)
     firstWindow->consumeMotionCancel();
     secondWindow->consumeMotionPointerDown(1, ui::LogicalDisplayId::DEFAULT,
-                                           AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+                                           MotionFlag::NO_FOCUS_CHANGE);
 
     // Send pointer up to the second window
     mDispatcher->notifyMotion(generateMotionArgs(POINTER_1_UP, AINPUT_SOURCE_TOUCHSCREEN,
@@ -7345,7 +7381,7 @@ TEST_F(InputDispatcherTest, TransferTouch_TwoPointersSplitTouch) {
     firstWindow->assertNoEvents();
     secondWindow->consumeMotionPointerUp(/*pointerIdx=*/1,
                                          AllOf(WithDisplayId(ui::LogicalDisplayId::DEFAULT),
-                                               WithFlags(AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE),
+                                               WithFlags(MotionFlag::NO_FOCUS_CHANGE),
                                                WithPointerCount(2)));
 
     // Send up event to the second window
@@ -7353,8 +7389,7 @@ TEST_F(InputDispatcherTest, TransferTouch_TwoPointersSplitTouch) {
                                                  ui::LogicalDisplayId::DEFAULT));
     // The first window gets nothing and the second gets up
     firstWindow->assertNoEvents();
-    secondWindow->consumeMotionUp(ui::LogicalDisplayId::DEFAULT,
-                                  AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    secondWindow->consumeMotionUp(ui::LogicalDisplayId::DEFAULT, MotionFlag::NO_FOCUS_CHANGE);
 }
 
 // Same as TransferTouch_TwoPointersSplitTouch, but using 'transferTouchOnDisplay' api.
@@ -7471,7 +7506,7 @@ TEST_F(InputDispatcherTest, TransferTouch_CloneSurface) {
     // The first window gets cancel.
     firstWindowInPrimary->consumeMotionCancel();
     secondWindowInPrimary->consumeMotionDown(ui::LogicalDisplayId::DEFAULT,
-                                             AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+                                             MotionFlag::NO_FOCUS_CHANGE);
 
     ASSERT_EQ(InputEventInjectionResult::SUCCEEDED,
               injectMotionEvent(*mDispatcher, AMOTION_EVENT_ACTION_MOVE, AINPUT_SOURCE_TOUCHSCREEN,
@@ -7479,7 +7514,7 @@ TEST_F(InputDispatcherTest, TransferTouch_CloneSurface) {
             << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
     firstWindowInPrimary->assertNoEvents();
     secondWindowInPrimary->consumeMotionMove(ui::LogicalDisplayId::DEFAULT,
-                                             AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+                                             MotionFlag::NO_FOCUS_CHANGE);
 
     ASSERT_EQ(InputEventInjectionResult::SUCCEEDED,
               injectMotionUp(*mDispatcher, AINPUT_SOURCE_TOUCHSCREEN, ui::LogicalDisplayId::DEFAULT,
@@ -7487,7 +7522,7 @@ TEST_F(InputDispatcherTest, TransferTouch_CloneSurface) {
             << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
     firstWindowInPrimary->assertNoEvents();
     secondWindowInPrimary->consumeMotionUp(ui::LogicalDisplayId::DEFAULT,
-                                           AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+                                           MotionFlag::NO_FOCUS_CHANGE);
 }
 
 // Same as TransferTouch_CloneSurface, but this touch on the secondary display and use
@@ -7537,22 +7572,20 @@ TEST_F(InputDispatcherTest, TransferTouchOnDisplay_CloneSurface) {
 
     // The first window gets cancel.
     firstWindowInSecondary->consumeMotionCancel(SECOND_DISPLAY_ID);
-    secondWindowInSecondary->consumeMotionDown(SECOND_DISPLAY_ID,
-                                               AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    secondWindowInSecondary->consumeMotionDown(SECOND_DISPLAY_ID, MotionFlag::NO_FOCUS_CHANGE);
 
     ASSERT_EQ(InputEventInjectionResult::SUCCEEDED,
               injectMotionEvent(*mDispatcher, AMOTION_EVENT_ACTION_MOVE, AINPUT_SOURCE_TOUCHSCREEN,
                                 SECOND_DISPLAY_ID, {150, 50}))
             << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
     firstWindowInSecondary->assertNoEvents();
-    secondWindowInSecondary->consumeMotionMove(SECOND_DISPLAY_ID,
-                                               AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    secondWindowInSecondary->consumeMotionMove(SECOND_DISPLAY_ID, MotionFlag::NO_FOCUS_CHANGE);
 
     ASSERT_EQ(InputEventInjectionResult::SUCCEEDED,
               injectMotionUp(*mDispatcher, AINPUT_SOURCE_TOUCHSCREEN, SECOND_DISPLAY_ID, {150, 50}))
             << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
     firstWindowInSecondary->assertNoEvents();
-    secondWindowInSecondary->consumeMotionUp(SECOND_DISPLAY_ID, AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    secondWindowInSecondary->consumeMotionUp(SECOND_DISPLAY_ID, MotionFlag::NO_FOCUS_CHANGE);
 }
 
 TEST_F(InputDispatcherTest, FocusedWindow_ReceivesFocusEventAndKeyEvent) {
@@ -7655,9 +7688,6 @@ TEST_F(InputDispatcherTest, FocusedWindow_PolicyConsumedKeyIgnoresDisableUserAct
 }
 
 TEST_F(InputDispatcherTest, FocusedWindow_DoesNotReceivePolicyFallbackKey) {
-#if !defined(__ANDROID__)
-    GTEST_SKIP() << "b/253299089 Generic files are currently read directly from device.";
-#endif
     InputDeviceInfo testDevice = generateTestDeviceInfo(/*vendorId=*/0,
                                                         /*productId=*/0, /*deviceId=*/1);
     std::unique_ptr<KeyCharacterMap> kcm = loadKeyCharacterMap("Generic");
@@ -7827,11 +7857,11 @@ TEST_F(InputDispatcherTest, PointerCancel_SendCancelWhenSplitTouch) {
     NotifyMotionArgs pointerUpMotionArgs =
             generateMotionArgs(POINTER_1_UP, AINPUT_SOURCE_TOUCHSCREEN,
                                ui::LogicalDisplayId::DEFAULT, {pointInFirst, pointInSecond});
-    pointerUpMotionArgs.flags |= AMOTION_EVENT_FLAG_CANCELED;
+    pointerUpMotionArgs.flags |= ftl::Flags<MotionFlag>(MotionFlag::CANCELED).get();
     mDispatcher->notifyMotion(pointerUpMotionArgs);
     // The first window gets move and the second gets cancel.
-    firstWindow->consumeMotionMove(ui::LogicalDisplayId::DEFAULT, AMOTION_EVENT_FLAG_CANCELED);
-    secondWindow->consumeMotionCancel(ui::LogicalDisplayId::DEFAULT, AMOTION_EVENT_FLAG_CANCELED);
+    firstWindow->consumeMotionMove(ui::LogicalDisplayId::DEFAULT, MotionFlag::CANCELED);
+    secondWindow->consumeMotionCancel(ui::LogicalDisplayId::DEFAULT, MotionFlag::CANCELED);
 
     // Send up event.
     mDispatcher->notifyMotion(generateMotionArgs(AMOTION_EVENT_ACTION_UP, AINPUT_SOURCE_TOUCHSCREEN,
@@ -7858,74 +7888,6 @@ TEST_F(InputDispatcherTest, SendTimeline_DoesNotCrashDispatcher) {
 
 using InputDispatcherMonitorTest = InputDispatcherTest;
 
-/**
- * Two entities that receive touch: A window, and a global monitor.
- * The touch goes to the window, and then the window disappears.
- * The monitor does not get cancel right away. But if more events come in, the touch gets canceled
- * for the monitor, as well.
- * 1. foregroundWindow
- * 2. monitor <-- global monitor (doesn't observe z order, receives all events)
- */
-TEST_F(InputDispatcherMonitorTest, MonitorTouchIsCanceledWhenForegroundWindowDisappears) {
-    std::shared_ptr<FakeApplicationHandle> application = std::make_shared<FakeApplicationHandle>();
-    sp<FakeWindowHandle> window = sp<FakeWindowHandle>::make(application, mDispatcher, "Foreground",
-                                                             ui::LogicalDisplayId::DEFAULT);
-
-    FakeMonitorReceiver monitor =
-            FakeMonitorReceiver(*mDispatcher, "M_1", ui::LogicalDisplayId::DEFAULT);
-
-    mDispatcher->onWindowInfosChanged({{*window->getInfo()}, {}, 0, 0});
-    ASSERT_EQ(InputEventInjectionResult::SUCCEEDED,
-              injectMotionDown(*mDispatcher, AINPUT_SOURCE_TOUCHSCREEN,
-                               ui::LogicalDisplayId::DEFAULT, {100, 200}))
-            << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
-
-    // Both the foreground window and the global monitor should receive the touch down
-    window->consumeMotionDown();
-    monitor.consumeMotionDown(ui::LogicalDisplayId::DEFAULT);
-
-    ASSERT_EQ(InputEventInjectionResult::SUCCEEDED,
-              injectMotionEvent(*mDispatcher, AMOTION_EVENT_ACTION_MOVE, AINPUT_SOURCE_TOUCHSCREEN,
-                                ui::LogicalDisplayId::DEFAULT, {110, 200}))
-            << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
-
-    window->consumeMotionMove();
-    monitor.consumeMotionMove(ui::LogicalDisplayId::DEFAULT);
-
-    // Now the foreground window goes away
-    mDispatcher->onWindowInfosChanged({{}, {}, 0, 0});
-    window->consumeMotionCancel();
-    monitor.assertNoEvents(); // Global monitor does not get a cancel yet
-
-    // If more events come in, there will be no more foreground window to send them to. This will
-    // cause a cancel for the monitor, as well.
-    ASSERT_EQ(InputEventInjectionResult::FAILED,
-              injectMotionEvent(*mDispatcher, AMOTION_EVENT_ACTION_MOVE, AINPUT_SOURCE_TOUCHSCREEN,
-                                ui::LogicalDisplayId::DEFAULT, {120, 200}))
-            << "Injection should fail because the window was removed";
-    window->assertNoEvents();
-    // Global monitor now gets the cancel
-    monitor.consumeMotionCancel(ui::LogicalDisplayId::DEFAULT);
-}
-
-TEST_F(InputDispatcherMonitorTest, ReceivesMotionEvents) {
-    std::shared_ptr<FakeApplicationHandle> application = std::make_shared<FakeApplicationHandle>();
-    sp<FakeWindowHandle> window =
-            sp<FakeWindowHandle>::make(application, mDispatcher, "Fake Window",
-                                       ui::LogicalDisplayId::DEFAULT);
-    mDispatcher->onWindowInfosChanged({{*window->getInfo()}, {}, 0, 0});
-
-    FakeMonitorReceiver monitor =
-            FakeMonitorReceiver(*mDispatcher, "M_1", ui::LogicalDisplayId::DEFAULT);
-
-    ASSERT_EQ(InputEventInjectionResult::SUCCEEDED,
-              injectMotionDown(*mDispatcher, AINPUT_SOURCE_TOUCHSCREEN,
-                               ui::LogicalDisplayId::DEFAULT))
-            << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
-    window->consumeMotionDown(ui::LogicalDisplayId::DEFAULT);
-    monitor.consumeMotionDown(ui::LogicalDisplayId::DEFAULT);
-}
-
 TEST_F(InputDispatcherMonitorTest, MonitorCannotPilferPointers) {
     FakeMonitorReceiver monitor =
             FakeMonitorReceiver(*mDispatcher, "M_1", ui::LogicalDisplayId::DEFAULT);
@@ -7940,7 +7902,6 @@ TEST_F(InputDispatcherMonitorTest, MonitorCannotPilferPointers) {
               injectMotionDown(*mDispatcher, AINPUT_SOURCE_TOUCHSCREEN,
                                ui::LogicalDisplayId::DEFAULT))
             << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
-    monitor.consumeMotionDown(ui::LogicalDisplayId::DEFAULT);
     window->consumeMotionDown(ui::LogicalDisplayId::DEFAULT);
 
     // Pilfer pointers from the monitor.
@@ -7952,33 +7913,9 @@ TEST_F(InputDispatcherMonitorTest, MonitorCannotPilferPointers) {
                                 ui::LogicalDisplayId::DEFAULT))
             << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
 
-    monitor.consumeMotionMove(ui::LogicalDisplayId::DEFAULT);
     window->consumeMotionMove(ui::LogicalDisplayId::DEFAULT);
 }
 
-TEST_F(InputDispatcherMonitorTest, NoWindowTransform) {
-    std::shared_ptr<FakeApplicationHandle> application = std::make_shared<FakeApplicationHandle>();
-    sp<FakeWindowHandle> window =
-            sp<FakeWindowHandle>::make(application, mDispatcher, "Fake Window",
-                                       ui::LogicalDisplayId::DEFAULT);
-    mDispatcher->onWindowInfosChanged({{*window->getInfo()}, {}, 0, 0});
-    window->setWindowOffset(20, 40);
-    window->setWindowTransform(0, 1, -1, 0);
-
-    FakeMonitorReceiver monitor =
-            FakeMonitorReceiver(*mDispatcher, "M_1", ui::LogicalDisplayId::DEFAULT);
-
-    ASSERT_EQ(InputEventInjectionResult::SUCCEEDED,
-              injectMotionDown(*mDispatcher, AINPUT_SOURCE_TOUCHSCREEN,
-                               ui::LogicalDisplayId::DEFAULT))
-            << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
-    window->consumeMotionDown(ui::LogicalDisplayId::DEFAULT);
-    std::unique_ptr<MotionEvent> event = monitor.consumeMotion();
-    ASSERT_NE(nullptr, event);
-    // Even though window has transform, gesture monitor must not.
-    ASSERT_EQ(ui::Transform(), event->getTransform());
-}
-
 TEST_F(InputDispatcherMonitorTest, InjectionFailsWithNoWindow) {
     std::shared_ptr<FakeApplicationHandle> application = std::make_shared<FakeApplicationHandle>();
     FakeMonitorReceiver monitor =
@@ -7991,222 +7928,6 @@ TEST_F(InputDispatcherMonitorTest, InjectionFailsWithNoWindow) {
     monitor.assertNoEvents();
 }
 
-/**
- * Two displays
- * The first monitor has a foreground window, a monitor
- * The second window has only one monitor.
- * We first inject a Down event into the first display, this injection should succeed and both
- * the foreground window and monitor should receive a down event, then inject a Down event into
- * the second display as well, this injection should fail, at this point, the first display
- * window and monitor should not receive a cancel or any other event.
- * Continue to inject Move and UP events to the first display, the events should be received
- * normally by the foreground window and monitor.
- */
-TEST_F(InputDispatcherMonitorTest, MonitorTouchIsNotCanceledWhenAnotherEmptyDisplayReceiveEvents) {
-    std::shared_ptr<FakeApplicationHandle> application = std::make_shared<FakeApplicationHandle>();
-    sp<FakeWindowHandle> window = sp<FakeWindowHandle>::make(application, mDispatcher, "Foreground",
-                                                             ui::LogicalDisplayId::DEFAULT);
-
-    FakeMonitorReceiver monitor =
-            FakeMonitorReceiver(*mDispatcher, "M_1", ui::LogicalDisplayId::DEFAULT);
-    FakeMonitorReceiver secondMonitor = FakeMonitorReceiver(*mDispatcher, "M_2", SECOND_DISPLAY_ID);
-
-    mDispatcher->onWindowInfosChanged({{*window->getInfo()}, {}, 0, 0});
-    ASSERT_EQ(InputEventInjectionResult::SUCCEEDED,
-              injectMotionDown(*mDispatcher, AINPUT_SOURCE_TOUCHSCREEN,
-                               ui::LogicalDisplayId::DEFAULT, {100, 200}))
-            << "The down event injected into the first display should succeed";
-
-    window->consumeMotionDown();
-    monitor.consumeMotionDown(ui::LogicalDisplayId::DEFAULT);
-
-    ASSERT_EQ(InputEventInjectionResult::FAILED,
-              injectMotionDown(*mDispatcher, AINPUT_SOURCE_TOUCHSCREEN, SECOND_DISPLAY_ID,
-                               {100, 200}))
-            << "The down event injected into the second display should fail since there's no "
-               "touchable window";
-
-    // Continue to inject event to first display.
-    ASSERT_EQ(InputEventInjectionResult::SUCCEEDED,
-              injectMotionEvent(*mDispatcher, AMOTION_EVENT_ACTION_MOVE, AINPUT_SOURCE_TOUCHSCREEN,
-                                ui::LogicalDisplayId::DEFAULT, {110, 220}))
-            << "The move event injected into the first display should succeed";
-
-    window->consumeMotionMove();
-    monitor.consumeMotionMove(ui::LogicalDisplayId::DEFAULT);
-
-    ASSERT_EQ(InputEventInjectionResult::SUCCEEDED,
-              injectMotionUp(*mDispatcher, AINPUT_SOURCE_TOUCHSCREEN, ui::LogicalDisplayId::DEFAULT,
-                             {110, 220}))
-            << "The up event injected into the first display should succeed";
-
-    window->consumeMotionUp();
-    monitor.consumeMotionUp(ui::LogicalDisplayId::DEFAULT);
-
-    window->assertNoEvents();
-    monitor.assertNoEvents();
-    secondMonitor.assertNoEvents();
-}
-
-/**
- * Two displays
- * There is a monitor and foreground window on each display.
- * First, we inject down events into each of the two displays, at this point, the foreground windows
- * and monitors on both displays should receive down events.
- * At this point, the foreground window of the second display goes away, the gone window should
- * receive the cancel event, and the other windows and monitors should not receive any events.
- * Inject a move event into the second display. At this point, the injection should fail because
- * the second display no longer has a foreground window. At this point, the monitor on the second
- * display should receive a cancel event, and any windows or monitors on the first display should
- * not receive any events, and any subsequent injection of events into the second display should
- * also fail.
- * Continue to inject events into the first display, and the events should all be injected
- * successfully and received normally.
- */
-TEST_F(InputDispatcherMonitorTest, MonitorTouchIsNotCancelWhenAnotherDisplayMonitorTouchCanceled) {
-    std::shared_ptr<FakeApplicationHandle> application = std::make_shared<FakeApplicationHandle>();
-    sp<FakeWindowHandle> window = sp<FakeWindowHandle>::make(application, mDispatcher, "Foreground",
-                                                             ui::LogicalDisplayId::DEFAULT);
-    sp<FakeWindowHandle> secondWindow =
-            sp<FakeWindowHandle>::make(application, mDispatcher, "SecondForeground",
-                                       SECOND_DISPLAY_ID);
-
-    FakeMonitorReceiver monitor =
-            FakeMonitorReceiver(*mDispatcher, "M_1", ui::LogicalDisplayId::DEFAULT);
-    FakeMonitorReceiver secondMonitor = FakeMonitorReceiver(*mDispatcher, "M_2", SECOND_DISPLAY_ID);
-
-    // There is a foreground window on both displays.
-    mDispatcher->onWindowInfosChanged({{*window->getInfo(), *secondWindow->getInfo()}, {}, 0, 0});
-    ASSERT_EQ(InputEventInjectionResult::SUCCEEDED,
-              injectMotionDown(*mDispatcher, AINPUT_SOURCE_TOUCHSCREEN,
-                               ui::LogicalDisplayId::DEFAULT, {100, 200}))
-            << "The down event injected into the first display should succeed";
-
-    window->consumeMotionDown(ui::LogicalDisplayId::DEFAULT);
-    monitor.consumeMotionDown(ui::LogicalDisplayId::DEFAULT);
-
-    ASSERT_EQ(InputEventInjectionResult::SUCCEEDED,
-              injectMotionDown(*mDispatcher, AINPUT_SOURCE_TOUCHSCREEN, SECOND_DISPLAY_ID,
-                               {100, 200}))
-            << "The down event injected into the second display should succeed";
-
-    secondWindow->consumeMotionDown(SECOND_DISPLAY_ID);
-    secondMonitor.consumeMotionDown(SECOND_DISPLAY_ID);
-
-    // Now second window is gone away.
-    mDispatcher->onWindowInfosChanged({{*window->getInfo()}, {}, 0, 0});
-
-    // The gone window should receive a cancel, and the monitor on the second display should not
-    // receive any events.
-    secondWindow->consumeMotionCancel(SECOND_DISPLAY_ID);
-    secondMonitor.assertNoEvents();
-
-    ASSERT_EQ(InputEventInjectionResult::FAILED,
-              injectMotionEvent(*mDispatcher, AMOTION_EVENT_ACTION_MOVE, AINPUT_SOURCE_TOUCHSCREEN,
-                                SECOND_DISPLAY_ID, {110, 220}))
-            << "The move event injected into the second display should fail because there's no "
-               "touchable window";
-    // Now the monitor on the second display should receive a cancel event.
-    secondMonitor.consumeMotionCancel(SECOND_DISPLAY_ID);
-
-    ASSERT_EQ(InputEventInjectionResult::SUCCEEDED,
-              injectMotionEvent(*mDispatcher, AMOTION_EVENT_ACTION_MOVE, AINPUT_SOURCE_TOUCHSCREEN,
-                                ui::LogicalDisplayId::DEFAULT, {110, 200}))
-            << "The move event injected into the first display should succeed";
-
-    window->consumeMotionMove();
-    monitor.consumeMotionMove(ui::LogicalDisplayId::DEFAULT);
-
-    ASSERT_EQ(InputEventInjectionResult::FAILED,
-              injectMotionUp(*mDispatcher, AINPUT_SOURCE_TOUCHSCREEN, SECOND_DISPLAY_ID,
-                             {110, 220}))
-            << "The up event injected into the second display should fail because there's no "
-               "touchable window";
-
-    ASSERT_EQ(InputEventInjectionResult::SUCCEEDED,
-              injectMotionUp(*mDispatcher, AINPUT_SOURCE_TOUCHSCREEN, ui::LogicalDisplayId::DEFAULT,
-                             {110, 220}))
-            << "The up event injected into the first display should succeed";
-
-    window->consumeMotionUp(ui::LogicalDisplayId::DEFAULT);
-    monitor.consumeMotionUp(ui::LogicalDisplayId::DEFAULT);
-
-    window->assertNoEvents();
-    monitor.assertNoEvents();
-    secondWindow->assertNoEvents();
-    secondMonitor.assertNoEvents();
-}
-
-/**
- * One display with transform
- * There is a foreground window and a monitor on the display
- * Inject down event and move event sequentially, the foreground window and monitor can receive down
- * event and move event, then let the foreground window go away, the foreground window receives
- * cancel event, inject move event again, the monitor receives cancel event, all the events received
- * by the monitor should be with the same transform as the display
- */
-TEST_F(InputDispatcherMonitorTest, MonitorTouchCancelEventWithDisplayTransform) {
-    std::shared_ptr<FakeApplicationHandle> application = std::make_shared<FakeApplicationHandle>();
-    sp<FakeWindowHandle> window = sp<FakeWindowHandle>::make(application, mDispatcher, "Foreground",
-                                                             ui::LogicalDisplayId::DEFAULT);
-    FakeMonitorReceiver monitor =
-            FakeMonitorReceiver(*mDispatcher, "M_1", ui::LogicalDisplayId::DEFAULT);
-
-    ui::Transform transform;
-    transform.set({1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 0, 0, 1});
-
-    gui::DisplayInfo displayInfo;
-    displayInfo.displayId = ui::LogicalDisplayId::DEFAULT;
-    displayInfo.transform = transform;
-
-    mDispatcher->onWindowInfosChanged({{*window->getInfo()}, {displayInfo}, 0, 0});
-
-    ASSERT_EQ(InputEventInjectionResult::SUCCEEDED,
-              injectMotionDown(*mDispatcher, AINPUT_SOURCE_TOUCHSCREEN,
-                               ui::LogicalDisplayId::DEFAULT, {100, 200}))
-            << "The down event injected should succeed";
-
-    window->consumeMotionDown();
-    std::unique_ptr<MotionEvent> downMotionEvent = monitor.consumeMotion();
-    EXPECT_EQ(transform, downMotionEvent->getTransform());
-    EXPECT_EQ(AMOTION_EVENT_ACTION_DOWN, downMotionEvent->getAction());
-
-    ASSERT_EQ(InputEventInjectionResult::SUCCEEDED,
-              injectMotionEvent(*mDispatcher, AMOTION_EVENT_ACTION_MOVE, AINPUT_SOURCE_TOUCHSCREEN,
-                                ui::LogicalDisplayId::DEFAULT, {110, 220}))
-            << "The move event injected should succeed";
-
-    window->consumeMotionMove();
-    std::unique_ptr<MotionEvent> moveMotionEvent = monitor.consumeMotion();
-    EXPECT_EQ(transform, moveMotionEvent->getTransform());
-    EXPECT_EQ(AMOTION_EVENT_ACTION_MOVE, moveMotionEvent->getAction());
-
-    // Let foreground window gone
-    mDispatcher->onWindowInfosChanged({{}, {displayInfo}, 0, 0});
-
-    // Foreground window should receive a cancel event, but not the monitor.
-    window->consumeMotionCancel();
-
-    ASSERT_EQ(InputEventInjectionResult::FAILED,
-              injectMotionEvent(*mDispatcher, AMOTION_EVENT_ACTION_MOVE, AINPUT_SOURCE_TOUCHSCREEN,
-                                ui::LogicalDisplayId::DEFAULT, {110, 220}))
-            << "The move event injected should failed";
-    // Now foreground should not receive any events, but monitor should receive a cancel event
-    // with transform that same as display's display.
-    std::unique_ptr<MotionEvent> cancelMotionEvent = monitor.consumeMotion();
-    EXPECT_EQ(transform, cancelMotionEvent->getTransform());
-    EXPECT_EQ(ui::LogicalDisplayId::DEFAULT, cancelMotionEvent->getDisplayId());
-    EXPECT_EQ(AMOTION_EVENT_ACTION_CANCEL, cancelMotionEvent->getAction());
-
-    // Other event inject to this display should fail.
-    ASSERT_EQ(InputEventInjectionResult::FAILED,
-              injectMotionEvent(*mDispatcher, AMOTION_EVENT_ACTION_UP, AINPUT_SOURCE_TOUCHSCREEN,
-                                ui::LogicalDisplayId::DEFAULT, {110, 220}))
-            << "The up event injected should fail because the touched window was removed";
-    window->assertNoEvents();
-    monitor.assertNoEvents();
-}
-
 TEST_F(InputDispatcherTest, TestMoveEvent) {
     std::shared_ptr<FakeApplicationHandle> application = std::make_shared<FakeApplicationHandle>();
     sp<FakeWindowHandle> window =
@@ -8230,7 +7951,7 @@ TEST_F(InputDispatcherTest, TestMoveEvent) {
                                              motionArgs.pointerCoords[0].getX() - 10);
 
     mDispatcher->notifyMotion(motionArgs);
-    window->consumeMotionMove(ui::LogicalDisplayId::DEFAULT, /*expectedFlags=*/0);
+    window->consumeMotionMove(ui::LogicalDisplayId::DEFAULT, /*expectedFlags=*/{});
 }
 
 /**
@@ -8376,7 +8097,7 @@ TEST_F(InputDispatcherTest, VerifyInputEvent_MotionEvent) {
     EXPECT_EQ(rawXY.x, verifiedMotion.rawX);
     EXPECT_EQ(rawXY.y, verifiedMotion.rawY);
     EXPECT_EQ(motionArgs.action & AMOTION_EVENT_ACTION_MASK, verifiedMotion.actionMasked);
-    EXPECT_EQ(motionArgs.flags & VERIFIED_MOTION_EVENT_FLAGS, verifiedMotion.flags);
+    EXPECT_EQ(motionArgs.flags & VERIFIED_MOTION_EVENT_FLAGS.get(), verifiedMotion.flags.get());
     EXPECT_EQ(motionArgs.downTime, verifiedMotion.downTimeNanos);
     EXPECT_EQ(motionArgs.metaState, verifiedMotion.metaState);
     EXPECT_EQ(motionArgs.buttonState, verifiedMotion.buttonState);
@@ -8635,7 +8356,7 @@ TEST_F(InputDispatcherTest, DisplayRemoved) {
  * OBSCURED should be set for the MotionEvent that reaches the bottom window.
  *
  * In this test, we ensure that the event received by the bottom window has
- * FLAG_WINDOW_IS_PARTIALLY_OBSCURED.
+ * MotionFlag::WINDOW_IS_PARTIALLY_OBSCURED.
  */
 TEST_F(InputDispatcherTest, SlipperyWindow_SetsFlagPartiallyObscured) {
     constexpr gui::Pid SLIPPERY_PID{WINDOW_PID.val() + 1};
@@ -8678,7 +8399,7 @@ TEST_F(InputDispatcherTest, SlipperyWindow_SetsFlagPartiallyObscured) {
     slipperyExitWindow->consumeMotionCancel();
 
     slipperyEnterWindow->consumeMotionDown(ui::LogicalDisplayId::DEFAULT,
-                                           AMOTION_EVENT_FLAG_WINDOW_IS_PARTIALLY_OBSCURED);
+                                           MotionFlag::WINDOW_IS_PARTIALLY_OBSCURED);
 }
 
 /**
@@ -9730,52 +9451,6 @@ TEST_F(InputDispatcherFocusOnTwoDisplaysTest, SetInputWindow_MultiDisplayFocus)
     windowInSecondary->assertNoEvents();
 }
 
-// Test per-display input monitors for motion event.
-TEST_F(InputDispatcherFocusOnTwoDisplaysTest, MonitorMotionEvent_MultiDisplay) {
-    FakeMonitorReceiver monitorInPrimary =
-            FakeMonitorReceiver(*mDispatcher, "M_1", ui::LogicalDisplayId::DEFAULT);
-    FakeMonitorReceiver monitorInSecondary =
-            FakeMonitorReceiver(*mDispatcher, "M_2", SECOND_DISPLAY_ID);
-
-    // Test touch down on primary display.
-    ASSERT_EQ(InputEventInjectionResult::SUCCEEDED,
-              injectMotionDown(*mDispatcher, AINPUT_SOURCE_TOUCHSCREEN,
-                               ui::LogicalDisplayId::DEFAULT))
-            << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
-    windowInPrimary->consumeMotionDown(ui::LogicalDisplayId::DEFAULT);
-    monitorInPrimary.consumeMotionDown(ui::LogicalDisplayId::DEFAULT);
-    windowInSecondary->assertNoEvents();
-    monitorInSecondary.assertNoEvents();
-
-    // Test touch down on second display.
-    ASSERT_EQ(InputEventInjectionResult::SUCCEEDED,
-              injectMotionDown(*mDispatcher, AINPUT_SOURCE_TOUCHSCREEN, SECOND_DISPLAY_ID))
-            << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
-    windowInPrimary->assertNoEvents();
-    monitorInPrimary.assertNoEvents();
-    windowInSecondary->consumeMotionDown(SECOND_DISPLAY_ID);
-    monitorInSecondary.consumeMotionDown(SECOND_DISPLAY_ID);
-
-    // Lift up the touch from the second display
-    ASSERT_EQ(InputEventInjectionResult::SUCCEEDED,
-              injectMotionUp(*mDispatcher, AINPUT_SOURCE_TOUCHSCREEN, SECOND_DISPLAY_ID))
-            << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
-    windowInSecondary->consumeMotionUp(SECOND_DISPLAY_ID);
-    monitorInSecondary.consumeMotionUp(SECOND_DISPLAY_ID);
-
-    // Test inject a non-pointer motion event.
-    // If specific a display, it will dispatch to the focused window of particular display,
-    // or it will dispatch to the focused window of focused display.
-    ASSERT_EQ(InputEventInjectionResult::SUCCEEDED,
-              injectMotionDown(*mDispatcher, AINPUT_SOURCE_TRACKBALL,
-                               ui::LogicalDisplayId::INVALID))
-            << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
-    windowInPrimary->assertNoEvents();
-    monitorInPrimary.assertNoEvents();
-    windowInSecondary->consumeMotionDown(ui::LogicalDisplayId::INVALID);
-    monitorInSecondary.consumeMotionDown(ui::LogicalDisplayId::INVALID);
-}
-
 // Test per-display input monitors for key event.
 TEST_F(InputDispatcherFocusOnTwoDisplaysTest, MonitorKeyEvent_MultiDisplay) {
     // Input monitor per display.
@@ -9817,50 +9492,6 @@ TEST_F(InputDispatcherFocusOnTwoDisplaysTest, CanFocusWindowOnUnfocusedDisplay)
     secondWindowInPrimary->consumeKeyDown(ui::LogicalDisplayId::DEFAULT);
 }
 
-TEST_F(InputDispatcherFocusOnTwoDisplaysTest, CancelTouch_MultiDisplay) {
-    FakeMonitorReceiver monitorInPrimary =
-            FakeMonitorReceiver(*mDispatcher, "M_1", ui::LogicalDisplayId::DEFAULT);
-    FakeMonitorReceiver monitorInSecondary =
-            FakeMonitorReceiver(*mDispatcher, "M_2", SECOND_DISPLAY_ID);
-
-    // Test touch down on primary display.
-    ASSERT_EQ(InputEventInjectionResult::SUCCEEDED,
-              injectMotionDown(*mDispatcher, AINPUT_SOURCE_TOUCHSCREEN,
-                               ui::LogicalDisplayId::DEFAULT))
-            << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
-    windowInPrimary->consumeMotionDown(ui::LogicalDisplayId::DEFAULT);
-    monitorInPrimary.consumeMotionDown(ui::LogicalDisplayId::DEFAULT);
-
-    // Test touch down on second display.
-    ASSERT_EQ(InputEventInjectionResult::SUCCEEDED,
-              injectMotionDown(*mDispatcher, AINPUT_SOURCE_TOUCHSCREEN, SECOND_DISPLAY_ID))
-            << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
-    windowInSecondary->consumeMotionDown(SECOND_DISPLAY_ID);
-    monitorInSecondary.consumeMotionDown(SECOND_DISPLAY_ID);
-
-    // Trigger cancel touch.
-    mDispatcher->cancelCurrentTouch();
-    windowInPrimary->consumeMotionCancel(ui::LogicalDisplayId::DEFAULT);
-    monitorInPrimary.consumeMotionCancel(ui::LogicalDisplayId::DEFAULT);
-    windowInSecondary->consumeMotionCancel(SECOND_DISPLAY_ID);
-    monitorInSecondary.consumeMotionCancel(SECOND_DISPLAY_ID);
-
-    // Test inject a move motion event, no window/monitor should receive the event.
-    ASSERT_EQ(InputEventInjectionResult::FAILED,
-              injectMotionEvent(*mDispatcher, AMOTION_EVENT_ACTION_MOVE, AINPUT_SOURCE_TOUCHSCREEN,
-                                ui::LogicalDisplayId::DEFAULT, {110, 200}))
-            << "Inject motion event should return InputEventInjectionResult::FAILED";
-    windowInPrimary->assertNoEvents();
-    monitorInPrimary.assertNoEvents();
-
-    ASSERT_EQ(InputEventInjectionResult::FAILED,
-              injectMotionEvent(*mDispatcher, AMOTION_EVENT_ACTION_MOVE, AINPUT_SOURCE_TOUCHSCREEN,
-                                SECOND_DISPLAY_ID, {110, 200}))
-            << "Inject motion event should return InputEventInjectionResult::FAILED";
-    windowInSecondary->assertNoEvents();
-    monitorInSecondary.assertNoEvents();
-}
-
 /**
  * Send a key to the primary display and to the secondary display.
  * Then cause the key on the primary display to be canceled by sending in a stale key.
@@ -10090,7 +9721,7 @@ protected:
     }
 
     void testInjectedMotion(int32_t policyFlags, int32_t injectedDeviceId, int32_t resolvedDeviceId,
-                            int32_t flags) {
+                            ftl::Flags<MotionFlag> flags) {
         MotionEvent event;
         PointerProperties pointerProperties[1];
         PointerCoords pointerCoords[1];
@@ -10103,7 +9734,7 @@ protected:
         ui::Transform identityTransform;
         const nsecs_t eventTime = systemTime(SYSTEM_TIME_MONOTONIC);
         event.initialize(InputEvent::nextId(), injectedDeviceId, AINPUT_SOURCE_TOUCHSCREEN,
-                         DISPLAY_ID, INVALID_HMAC, AMOTION_EVENT_ACTION_DOWN, 0, 0,
+                         DISPLAY_ID, INVALID_HMAC, AMOTION_EVENT_ACTION_DOWN, 0, /*flags=*/{},
                          AMOTION_EVENT_EDGE_FLAG_NONE, AMETA_NONE, 0, MotionClassification::NONE,
                          identityTransform, 0, 0, AMOTION_EVENT_INVALID_CURSOR_POSITION,
                          AMOTION_EVENT_INVALID_CURSOR_POSITION, identityTransform, eventTime,
@@ -10141,7 +9772,7 @@ TEST_F(InputFilterInjectionPolicyTest,
        MotionEventsInjectedFromAccessibility_HaveAccessibilityFlag) {
     testInjectedMotion(POLICY_FLAG_FILTERED | POLICY_FLAG_INJECTED_FROM_ACCESSIBILITY,
                        /*injectedDeviceId=*/3, /*resolvedDeviceId=*/3,
-                       AMOTION_EVENT_FLAG_IS_ACCESSIBILITY_EVENT);
+                       MotionFlag::IS_ACCESSIBILITY_EVENT);
 }
 
 TEST_F(InputFilterInjectionPolicyTest,
@@ -10149,8 +9780,8 @@ TEST_F(InputFilterInjectionPolicyTest,
     testInjectedMotion(POLICY_FLAG_FILTERED | POLICY_FLAG_INJECTED_FROM_ACCESSIBILITY |
                                POLICY_FLAG_INJECTED_FROM_ACCESSIBILITY_TOOL,
                        /*injectedDeviceId=*/3, /*resolvedDeviceId=*/3,
-                       AMOTION_EVENT_FLAG_IS_ACCESSIBILITY_EVENT |
-                               AMOTION_EVENT_FLAG_INJECTED_FROM_ACCESSIBILITY_TOOL);
+                       {MotionFlag::IS_ACCESSIBILITY_EVENT,
+                        MotionFlag::INJECTED_FROM_ACCESSIBILITY_TOOL});
 }
 
 TEST_F(InputFilterInjectionPolicyTest, RegularInjectedEvents_ReceiveVirtualDeviceId) {
@@ -10398,12 +10029,12 @@ TEST_F(InputDispatcherOnPointerDownOutsideFocus, NoFocusChangeFlag) {
             MotionEventBuilder(AMOTION_EVENT_ACTION_DOWN, AINPUT_SOURCE_MOUSE)
                     .eventTime(systemTime(SYSTEM_TIME_MONOTONIC))
                     .pointer(PointerBuilder(/*id=*/0, ToolType::FINGER).x(20).y(20))
-                    .addFlag(AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE)
+                    .addFlag(MotionFlag::NO_FOCUS_CHANGE)
                     .build();
     ASSERT_EQ(InputEventInjectionResult::SUCCEEDED, injectMotionEvent(*mDispatcher, event))
             << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
     mUnfocusedWindow->consumeAnyMotionDown(ui::LogicalDisplayId::DEFAULT,
-                                           AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+                                           MotionFlag::NO_FOCUS_CHANGE);
 
     ASSERT_TRUE(mDispatcher->waitForIdle());
     mFakePolicy->assertOnPointerDownWasNotCalled();
@@ -10999,11 +10630,9 @@ TEST_F(InputDispatcherSingleWindowAnr, UnresponsiveMonitorAnr) {
     FakeMonitorReceiver monitor =
             FakeMonitorReceiver(*mDispatcher, "M_1", ui::LogicalDisplayId::DEFAULT);
 
-    ASSERT_EQ(InputEventInjectionResult::SUCCEEDED,
-              injectMotionDown(*mDispatcher, AINPUT_SOURCE_TOUCHSCREEN,
-                               ui::LogicalDisplayId::DEFAULT, WINDOW_LOCATION));
+    ASSERT_EQ(InputEventInjectionResult::SUCCEEDED, injectKeyDownNoRepeat(*mDispatcher));
 
-    mWindow->consumeMotionDown(ui::LogicalDisplayId::DEFAULT);
+    mWindow->consumeKeyEvent(WithKeyAction(ACTION_DOWN));
     const std::optional<uint32_t> consumeSeq = monitor.receiveEvent();
     ASSERT_TRUE(consumeSeq);
 
@@ -11011,7 +10640,7 @@ TEST_F(InputDispatcherSingleWindowAnr, UnresponsiveMonitorAnr) {
                                                          MONITOR_PID);
 
     monitor.finishEvent(*consumeSeq);
-    monitor.consumeMotionCancel(ui::LogicalDisplayId::DEFAULT);
+    monitor.consumeKeyEvent(AllOf(WithKeyAction(ACTION_UP), WithFlags(AKEY_EVENT_FLAG_CANCELED)));
 
     ASSERT_TRUE(mDispatcher->waitForIdle());
     mFakePolicy->assertNotifyWindowResponsiveWasCalled(monitor.getToken(), MONITOR_PID);
@@ -11331,7 +10960,7 @@ TEST_F(InputDispatcherMultiWindowAnr, TwoWindows_BothUnresponsive) {
                                         .build()));
     mFocusedWindow->consumeMotionDown();
     mFocusedWindow->consumeMotionUp();
-    mUnfocusedWindow->consumeMotionOutside(ui::LogicalDisplayId::DEFAULT, /*flags=*/0);
+    mUnfocusedWindow->consumeMotionOutside(ui::LogicalDisplayId::DEFAULT, /*flags=*/{});
     // We consumed all events, so no ANR
     ASSERT_TRUE(mDispatcher->waitForIdle());
     mFakePolicy->assertNotifyAnrWasNotCalled();
@@ -11407,7 +11036,7 @@ TEST_F(InputDispatcherMultiWindowAnr, TwoWindows_BothUnresponsiveWithSameTimeout
 // At the same time, FLAG_WATCH_OUTSIDE_TOUCH targets should not receive any events.
 TEST_F(InputDispatcherMultiWindowAnr, DuringAnr_SecondTapIsIgnored) {
     tapOnFocusedWindow();
-    mUnfocusedWindow->consumeMotionOutside(ui::LogicalDisplayId::DEFAULT, /*flags=*/0);
+    mUnfocusedWindow->consumeMotionOutside(ui::LogicalDisplayId::DEFAULT, /*flags=*/{});
     // Receive the events, but don't respond
     const auto [downEventSequenceNum, downEvent] = mFocusedWindow->receiveEvent(); // ACTION_DOWN
     ASSERT_TRUE(downEventSequenceNum);
@@ -11540,7 +11169,7 @@ TEST_F(InputDispatcherMultiWindowAnr, SplitTouch_SingleWindowAnr) {
     mDispatcher->notifyMotion(
             generateMotionArgs(AMOTION_EVENT_ACTION_DOWN, AINPUT_SOURCE_TOUCHSCREEN,
                                ui::LogicalDisplayId::DEFAULT, {FOCUSED_WINDOW_LOCATION}));
-    mUnfocusedWindow->consumeMotionOutside(ui::LogicalDisplayId::DEFAULT, /*flags=*/0);
+    mUnfocusedWindow->consumeMotionOutside(ui::LogicalDisplayId::DEFAULT, /*flags=*/{});
 
     // Touch Window 2
     mDispatcher->notifyMotion(
@@ -12645,6 +12274,10 @@ protected:
         mWindowOnSecondDisplay->setFrame({0, 0, 100, 100});
 
         mDispatcher->setFocusedApplication(ui::LogicalDisplayId::DEFAULT, mApp);
+        updateWindowInfos();
+    }
+
+    void updateWindowInfos() {
         mDispatcher->onWindowInfosChanged(
                 {{*mSpyWindow->getInfo(), *mWindow->getInfo(), *mSecondWindow->getInfo(),
                   *mWindowOnSecondDisplay->getInfo()},
@@ -12763,7 +12396,7 @@ protected:
                                                   /*transferEntireGesture=*/false);
         if (transferred) {
             targetWindow->consumeMotionCancel(dragStartDisplay);
-            mDragWindow->consumeMotionDown(dragStartDisplay, AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+            mDragWindow->consumeMotionDown(dragStartDisplay, MotionFlag::NO_FOCUS_CHANGE);
         }
         return transferred;
     }
@@ -12784,8 +12417,7 @@ TEST_F(InputDispatcherDragTests, DragEnterAndDragExit) {
               injectMotionEvent(*mDispatcher, AMOTION_EVENT_ACTION_MOVE, AINPUT_SOURCE_TOUCHSCREEN,
                                 ui::LogicalDisplayId::DEFAULT, {50, 50}))
             << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
-    mDragWindow->consumeMotionMove(ui::LogicalDisplayId::DEFAULT,
-                                   AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    mDragWindow->consumeMotionMove(ui::LogicalDisplayId::DEFAULT, MotionFlag::NO_FOCUS_CHANGE);
     mWindow->consumeDragEvent(false, 50, 50);
     mSecondWindow->assertNoEvents();
 
@@ -12794,8 +12426,7 @@ TEST_F(InputDispatcherDragTests, DragEnterAndDragExit) {
               injectMotionEvent(*mDispatcher, AMOTION_EVENT_ACTION_MOVE, AINPUT_SOURCE_TOUCHSCREEN,
                                 ui::LogicalDisplayId::DEFAULT, {150, 50}))
             << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
-    mDragWindow->consumeMotionMove(ui::LogicalDisplayId::DEFAULT,
-                                   AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    mDragWindow->consumeMotionMove(ui::LogicalDisplayId::DEFAULT, MotionFlag::NO_FOCUS_CHANGE);
     mWindow->consumeDragEvent(true, 150, 50);
     mSecondWindow->consumeDragEvent(false, 50, 50);
 
@@ -12804,8 +12435,7 @@ TEST_F(InputDispatcherDragTests, DragEnterAndDragExit) {
               injectMotionEvent(*mDispatcher, AMOTION_EVENT_ACTION_MOVE, AINPUT_SOURCE_TOUCHSCREEN,
                                 ui::LogicalDisplayId::DEFAULT, {50, 50}))
             << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
-    mDragWindow->consumeMotionMove(ui::LogicalDisplayId::DEFAULT,
-                                   AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    mDragWindow->consumeMotionMove(ui::LogicalDisplayId::DEFAULT, MotionFlag::NO_FOCUS_CHANGE);
     mWindow->consumeDragEvent(false, 50, 50);
     mSecondWindow->consumeDragEvent(true, -50, 50);
 
@@ -12813,7 +12443,7 @@ TEST_F(InputDispatcherDragTests, DragEnterAndDragExit) {
               injectMotionUp(*mDispatcher, AINPUT_SOURCE_TOUCHSCREEN, ui::LogicalDisplayId::DEFAULT,
                              {50, 50}))
             << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
-    mDragWindow->consumeMotionUp(ui::LogicalDisplayId::DEFAULT, AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    mDragWindow->consumeMotionUp(ui::LogicalDisplayId::DEFAULT, MotionFlag::NO_FOCUS_CHANGE);
     mWindow->assertNoEvents();
     mSecondWindow->assertNoEvents();
 }
@@ -12850,8 +12480,7 @@ TEST_F(InputDispatcherDragTests, DragAndDrop) {
               injectMotionEvent(*mDispatcher, AMOTION_EVENT_ACTION_MOVE, AINPUT_SOURCE_TOUCHSCREEN,
                                 ui::LogicalDisplayId::DEFAULT, {50, 50}))
             << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
-    mDragWindow->consumeMotionMove(ui::LogicalDisplayId::DEFAULT,
-                                   AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    mDragWindow->consumeMotionMove(ui::LogicalDisplayId::DEFAULT, MotionFlag::NO_FOCUS_CHANGE);
     mWindow->consumeDragEvent(false, 50, 50);
     mSecondWindow->assertNoEvents();
 
@@ -12860,8 +12489,7 @@ TEST_F(InputDispatcherDragTests, DragAndDrop) {
               injectMotionEvent(*mDispatcher, AMOTION_EVENT_ACTION_MOVE, AINPUT_SOURCE_TOUCHSCREEN,
                                 ui::LogicalDisplayId::DEFAULT, {150, 50}))
             << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
-    mDragWindow->consumeMotionMove(ui::LogicalDisplayId::DEFAULT,
-                                   AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    mDragWindow->consumeMotionMove(ui::LogicalDisplayId::DEFAULT, MotionFlag::NO_FOCUS_CHANGE);
     mWindow->consumeDragEvent(true, 150, 50);
     mSecondWindow->consumeDragEvent(false, 50, 50);
 
@@ -12870,7 +12498,7 @@ TEST_F(InputDispatcherDragTests, DragAndDrop) {
               injectMotionUp(*mDispatcher, AINPUT_SOURCE_TOUCHSCREEN, ui::LogicalDisplayId::DEFAULT,
                              {150, 50}))
             << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
-    mDragWindow->consumeMotionUp(ui::LogicalDisplayId::DEFAULT, AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    mDragWindow->consumeMotionUp(ui::LogicalDisplayId::DEFAULT, MotionFlag::NO_FOCUS_CHANGE);
     mFakePolicy->assertDropTargetEquals(*mDispatcher, mSecondWindow->getToken());
     mWindow->assertNoEvents();
     mSecondWindow->assertNoEvents();
@@ -12917,8 +12545,56 @@ TEST_F(InputDispatcherDragTests, DragAndDropNotCancelledIfSomeOtherPointerIsPilf
 
     // Drag window should still receive the new event
     mDragWindow->consumeMotionEvent(
-            AllOf(WithMotionAction(ACTION_MOVE), WithFlags(AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE)));
+            AllOf(WithMotionAction(ACTION_MOVE), WithFlags(MotionFlag::NO_FOCUS_CHANGE)));
+    mDragWindow->assertNoEvents();
+}
+
+TEST_F(InputDispatcherDragTests, DragAndDropWithDoNotPilferSpy) {
+    // Configure the spy to have the DO_NOT_PILFER flag.
+    mSpyWindow->setDoNotPilfer(true);
+    updateWindowInfos();
+
+    startDrag();
+
+    // No cancel event after drag start
+    mSpyWindow->assertNoEvents();
+
+    const MotionEvent secondFingerDownEvent =
+            MotionEventBuilder(POINTER_1_DOWN, AINPUT_SOURCE_TOUCHSCREEN)
+                    .eventTime(systemTime(SYSTEM_TIME_MONOTONIC))
+                    .pointer(PointerBuilder(/*id=*/0, ToolType::FINGER).x(50).y(50))
+                    .pointer(PointerBuilder(/*id=*/1, ToolType::FINGER).x(60).y(60))
+                    .build();
+    ASSERT_EQ(InputEventInjectionResult::SUCCEEDED,
+              injectMotionEvent(*mDispatcher, secondFingerDownEvent, INJECT_EVENT_TIMEOUT,
+                                InputEventInjectionSync::WAIT_FOR_RESULT))
+            << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
+
+    // Since the spy window sets the DO_NOT_PILFER flag, the drag pointer does
+    // not get canceled for the spy window.
+    mSpyWindow->consumeMotionEvent(AllOf(WithMotionAction(POINTER_1_DOWN), WithPointerIds({0, 1})));
+    mDragWindow->consumeMotionEvent(WithMotionAction(ACTION_MOVE));
+
+    mSpyWindow->assertNoEvents();
+
+    const MotionEvent firstFingerMoveEvent =
+            MotionEventBuilder(ACTION_MOVE, AINPUT_SOURCE_TOUCHSCREEN)
+                    .eventTime(systemTime(SYSTEM_TIME_MONOTONIC))
+                    .pointer(PointerBuilder(/*id=*/0, ToolType::FINGER).x(60).y(60))
+                    .pointer(PointerBuilder(/*id=*/1, ToolType::FINGER).x(60).y(60))
+                    .build();
+    ASSERT_EQ(InputEventInjectionResult::SUCCEEDED,
+              injectMotionEvent(*mDispatcher, firstFingerMoveEvent, INJECT_EVENT_TIMEOUT,
+                                InputEventInjectionSync::WAIT_FOR_RESULT))
+            << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
+
+    // Drag window should not receive the new event
+    mDragWindow->consumeMotionEvent(
+            AllOf(WithMotionAction(ACTION_MOVE), WithFlags(MotionFlag::NO_FOCUS_CHANGE)));
     mDragWindow->assertNoEvents();
+    // And the spy window should still receive both pointers
+    mSpyWindow->consumeMotionEvent(AllOf(WithMotionAction(ACTION_MOVE), WithPointerIds({0, 1})));
+    mSpyWindow->assertNoEvents();
 }
 
 TEST_F(InputDispatcherDragTests, StylusDragAndDrop) {
@@ -12932,8 +12608,7 @@ TEST_F(InputDispatcherDragTests, StylusDragAndDrop) {
                                         .pointer(PointerBuilder(0, ToolType::STYLUS).x(50).y(50))
                                         .build()))
             << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
-    mDragWindow->consumeMotionMove(ui::LogicalDisplayId::DEFAULT,
-                                   AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    mDragWindow->consumeMotionMove(ui::LogicalDisplayId::DEFAULT, MotionFlag::NO_FOCUS_CHANGE);
     mWindow->consumeDragEvent(false, 50, 50);
     mSecondWindow->assertNoEvents();
 
@@ -12955,8 +12630,7 @@ TEST_F(InputDispatcherDragTests, StylusDragAndDrop) {
                                         .pointer(PointerBuilder(0, ToolType::STYLUS).x(150).y(50))
                                         .build()))
             << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
-    mDragWindow->consumeMotionMove(ui::LogicalDisplayId::DEFAULT,
-                                   AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    mDragWindow->consumeMotionMove(ui::LogicalDisplayId::DEFAULT, MotionFlag::NO_FOCUS_CHANGE);
     mWindow->assertNoEvents();
     mSecondWindow->assertNoEvents();
     mFakePolicy->assertDropTargetEquals(*mDispatcher, mSecondWindow->getToken());
@@ -12969,7 +12643,7 @@ TEST_F(InputDispatcherDragTests, StylusDragAndDrop) {
                                         .pointer(PointerBuilder(0, ToolType::STYLUS).x(150).y(50))
                                         .build()))
             << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
-    mDragWindow->consumeMotionUp(ui::LogicalDisplayId::DEFAULT, AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    mDragWindow->consumeMotionUp(ui::LogicalDisplayId::DEFAULT, MotionFlag::NO_FOCUS_CHANGE);
     mWindow->assertNoEvents();
     mSecondWindow->assertNoEvents();
 }
@@ -12987,8 +12661,7 @@ TEST_F(InputDispatcherDragTests, DragAndDropOnInvalidWindow) {
               injectMotionEvent(*mDispatcher, AMOTION_EVENT_ACTION_MOVE, AINPUT_SOURCE_TOUCHSCREEN,
                                 ui::LogicalDisplayId::DEFAULT, {50, 50}))
             << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
-    mDragWindow->consumeMotionMove(ui::LogicalDisplayId::DEFAULT,
-                                   AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    mDragWindow->consumeMotionMove(ui::LogicalDisplayId::DEFAULT, MotionFlag::NO_FOCUS_CHANGE);
     mWindow->consumeDragEvent(false, 50, 50);
     mSecondWindow->assertNoEvents();
 
@@ -12997,8 +12670,7 @@ TEST_F(InputDispatcherDragTests, DragAndDropOnInvalidWindow) {
               injectMotionEvent(*mDispatcher, AMOTION_EVENT_ACTION_MOVE, AINPUT_SOURCE_TOUCHSCREEN,
                                 ui::LogicalDisplayId::DEFAULT, {150, 50}))
             << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
-    mDragWindow->consumeMotionMove(ui::LogicalDisplayId::DEFAULT,
-                                   AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    mDragWindow->consumeMotionMove(ui::LogicalDisplayId::DEFAULT, MotionFlag::NO_FOCUS_CHANGE);
     mWindow->consumeDragEvent(true, 150, 50);
     mSecondWindow->assertNoEvents();
 
@@ -13007,7 +12679,7 @@ TEST_F(InputDispatcherDragTests, DragAndDropOnInvalidWindow) {
               injectMotionUp(*mDispatcher, AINPUT_SOURCE_TOUCHSCREEN, ui::LogicalDisplayId::DEFAULT,
                              {150, 50}))
             << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
-    mDragWindow->consumeMotionUp(ui::LogicalDisplayId::DEFAULT, AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    mDragWindow->consumeMotionUp(ui::LogicalDisplayId::DEFAULT, MotionFlag::NO_FOCUS_CHANGE);
     mFakePolicy->assertDropTargetEquals(*mDispatcher, nullptr);
     mWindow->assertNoEvents();
     mSecondWindow->assertNoEvents();
@@ -13074,8 +12746,7 @@ TEST_F(InputDispatcherDragTests, DragAndDropWhenSplitTouch) {
     ASSERT_EQ(InputEventInjectionResult::SUCCEEDED,
               injectMotionEvent(*mDispatcher, secondFingerMoveEvent, INJECT_EVENT_TIMEOUT,
                                 InputEventInjectionSync::WAIT_FOR_RESULT));
-    mDragWindow->consumeMotionMove(ui::LogicalDisplayId::DEFAULT,
-                                   AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    mDragWindow->consumeMotionMove(ui::LogicalDisplayId::DEFAULT, MotionFlag::NO_FOCUS_CHANGE);
     mWindow->consumeDragEvent(false, 50, 50);
     mSecondWindow->consumeMotionMove();
 
@@ -13089,7 +12760,7 @@ TEST_F(InputDispatcherDragTests, DragAndDropWhenSplitTouch) {
     ASSERT_EQ(InputEventInjectionResult::SUCCEEDED,
               injectMotionEvent(*mDispatcher, secondFingerUpEvent, INJECT_EVENT_TIMEOUT,
                                 InputEventInjectionSync::WAIT_FOR_RESULT));
-    mDragWindow->consumeMotionUp(ui::LogicalDisplayId::DEFAULT, AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    mDragWindow->consumeMotionUp(ui::LogicalDisplayId::DEFAULT, MotionFlag::NO_FOCUS_CHANGE);
     mFakePolicy->assertDropTargetEquals(*mDispatcher, mWindow->getToken());
     mWindow->assertNoEvents();
     mSecondWindow->consumeMotionMove();
@@ -13116,7 +12787,7 @@ TEST_F(InputDispatcherDragTests, DragAndDropWhenMultiDisplays) {
                                         .displayId(SECOND_DISPLAY_ID)
                                         .pointer(PointerBuilder(0, ToolType::FINGER).x(100).y(100))
                                         .build()));
-    windowInSecondary->consumeMotionDown(SECOND_DISPLAY_ID, /*expectedFlag=*/0);
+    windowInSecondary->consumeMotionDown(SECOND_DISPLAY_ID, /*expectedFlag=*/{});
     // Update window again.
     mDispatcher->onWindowInfosChanged(
             {{*mDragWindow->getInfo(), *mSpyWindow->getInfo(), *mWindow->getInfo(),
@@ -13130,8 +12801,7 @@ TEST_F(InputDispatcherDragTests, DragAndDropWhenMultiDisplays) {
               injectMotionEvent(*mDispatcher, AMOTION_EVENT_ACTION_MOVE, AINPUT_SOURCE_TOUCHSCREEN,
                                 ui::LogicalDisplayId::DEFAULT, {50, 50}))
             << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
-    mDragWindow->consumeMotionMove(ui::LogicalDisplayId::DEFAULT,
-                                   AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    mDragWindow->consumeMotionMove(ui::LogicalDisplayId::DEFAULT, MotionFlag::NO_FOCUS_CHANGE);
     mWindow->consumeDragEvent(false, 50, 50);
     mSecondWindow->assertNoEvents();
 
@@ -13140,8 +12810,7 @@ TEST_F(InputDispatcherDragTests, DragAndDropWhenMultiDisplays) {
               injectMotionEvent(*mDispatcher, AMOTION_EVENT_ACTION_MOVE, AINPUT_SOURCE_TOUCHSCREEN,
                                 ui::LogicalDisplayId::DEFAULT, {150, 50}))
             << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
-    mDragWindow->consumeMotionMove(ui::LogicalDisplayId::DEFAULT,
-                                   AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    mDragWindow->consumeMotionMove(ui::LogicalDisplayId::DEFAULT, MotionFlag::NO_FOCUS_CHANGE);
     mWindow->consumeDragEvent(true, 150, 50);
     mSecondWindow->consumeDragEvent(false, 50, 50);
 
@@ -13150,7 +12819,7 @@ TEST_F(InputDispatcherDragTests, DragAndDropWhenMultiDisplays) {
               injectMotionUp(*mDispatcher, AINPUT_SOURCE_TOUCHSCREEN, ui::LogicalDisplayId::DEFAULT,
                              {150, 50}))
             << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
-    mDragWindow->consumeMotionUp(ui::LogicalDisplayId::DEFAULT, AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    mDragWindow->consumeMotionUp(ui::LogicalDisplayId::DEFAULT, MotionFlag::NO_FOCUS_CHANGE);
     mFakePolicy->assertDropTargetEquals(*mDispatcher, mSecondWindow->getToken());
     mWindow->assertNoEvents();
     mSecondWindow->assertNoEvents();
@@ -13168,8 +12837,7 @@ TEST_F(InputDispatcherDragTests, MouseDragAndDrop) {
                                                          .y(50))
                                         .build()))
             << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
-    mDragWindow->consumeMotionMove(ui::LogicalDisplayId::DEFAULT,
-                                   AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    mDragWindow->consumeMotionMove(ui::LogicalDisplayId::DEFAULT, MotionFlag::NO_FOCUS_CHANGE);
     mWindow->consumeDragEvent(false, 50, 50);
     mSecondWindow->assertNoEvents();
 
@@ -13183,8 +12851,7 @@ TEST_F(InputDispatcherDragTests, MouseDragAndDrop) {
                                                          .y(50))
                                         .build()))
             << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
-    mDragWindow->consumeMotionMove(ui::LogicalDisplayId::DEFAULT,
-                                   AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    mDragWindow->consumeMotionMove(ui::LogicalDisplayId::DEFAULT, MotionFlag::NO_FOCUS_CHANGE);
     mWindow->consumeDragEvent(true, 150, 50);
     mSecondWindow->consumeDragEvent(false, 50, 50);
 
@@ -13210,7 +12877,7 @@ TEST_F(InputDispatcherDragTests, MouseDragAndDrop) {
                                                          .y(50))
                                         .build()))
             << "Inject motion event should return InputEventInjectionResult::SUCCEEDED";
-    mDragWindow->consumeMotionUp(ui::LogicalDisplayId::DEFAULT, AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    mDragWindow->consumeMotionUp(ui::LogicalDisplayId::DEFAULT, MotionFlag::NO_FOCUS_CHANGE);
     mFakePolicy->assertDropTargetEquals(*mDispatcher, mSecondWindow->getToken());
     mWindow->assertNoEvents();
     mSecondWindow->assertNoEvents();
@@ -13252,7 +12919,7 @@ TEST_F(InputDispatcherDragTests, DragAndDropFinishedWhenCancelCurrentTouch) {
     mDispatcher->cancelCurrentTouch();
     ASSERT_NO_FATAL_FAILURE(mSecondWindow->consumeMotionCancel());
     ASSERT_NO_FATAL_FAILURE(mDragWindow->consumeMotionCancel(ui::LogicalDisplayId::DEFAULT,
-                                                             AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE));
+                                                             MotionFlag::NO_FOCUS_CHANGE));
     ASSERT_NO_FATAL_FAILURE(mSpyWindow->consumeMotionCancel());
 
     ASSERT_TRUE(mDispatcher->waitForIdle());
@@ -13369,7 +13036,7 @@ TEST_F(InputDispatcherDragTests, DragAndDropWhenSplitTouchAndMultiDevice) {
 
     mDragWindow->consumeMotionEvent(AllOf(WithMotionAction(ACTION_MOVE), WithDeviceId(deviceA),
                                           WithDisplayId(ui::LogicalDisplayId::DEFAULT),
-                                          WithFlags(AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE)));
+                                          WithFlags(MotionFlag::NO_FOCUS_CHANGE)));
     mWindow->consumeDragEvent(false, 51, 51);
     mSecondWindow->consumeMotionEvent(AllOf(WithMotionAction(ACTION_MOVE), WithDeviceId(deviceA),
                                             WithDisplayId(ui::LogicalDisplayId::DEFAULT)));
@@ -13382,7 +13049,7 @@ TEST_F(InputDispatcherDragTests, DragAndDropWhenSplitTouchAndMultiDevice) {
                                       .build());
     mDragWindow->consumeMotionEvent(AllOf(WithMotionAction(ACTION_UP), WithDeviceId(deviceA),
                                           WithDisplayId(ui::LogicalDisplayId::DEFAULT),
-                                          WithFlags(AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE)));
+                                          WithFlags(MotionFlag::NO_FOCUS_CHANGE)));
     mFakePolicy->assertDropTargetEquals(*mDispatcher, mWindow->getToken());
     mSecondWindow->consumeMotionEvent(AllOf(WithMotionAction(ACTION_MOVE), WithDeviceId(deviceA),
                                             WithDisplayId(ui::LogicalDisplayId::DEFAULT)));
@@ -13482,7 +13149,7 @@ TEST_F(InputDispatcherDropInputFeatureTest, ObscuredWindowDropsInput) {
                                                  AINPUT_SOURCE_TOUCHSCREEN,
                                                  ui::LogicalDisplayId::DEFAULT));
     window->consumeMotionDown(ui::LogicalDisplayId::DEFAULT,
-                              AMOTION_EVENT_FLAG_WINDOW_IS_PARTIALLY_OBSCURED);
+                              MotionFlag::WINDOW_IS_PARTIALLY_OBSCURED);
     window->assertNoEvents();
 }
 
@@ -14156,12 +13823,10 @@ TEST_F(InputDispatcherPilferPointersTest, PartiallyPilferRequiredPointers) {
     EXPECT_EQ(OK, mDispatcher->pilferPointers(spy->getToken()));
     window->consumeMotionPointerUp(/*pointerIdx=*/2,
                                    AllOf(WithDisplayId(ui::LogicalDisplayId::DEFAULT),
-                                         WithFlags(AMOTION_EVENT_FLAG_CANCELED),
-                                         WithPointerCount(3)));
+                                         WithFlags(MotionFlag::CANCELED), WithPointerCount(3)));
     window->consumeMotionPointerUp(/*pointerIdx=*/1,
                                    AllOf(WithDisplayId(ui::LogicalDisplayId::DEFAULT),
-                                         WithFlags(AMOTION_EVENT_FLAG_CANCELED),
-                                         WithPointerCount(2)));
+                                         WithFlags(MotionFlag::CANCELED), WithPointerCount(2)));
 
     spy->assertNoEvents();
     window->assertNoEvents();
@@ -14418,6 +14083,46 @@ TEST_F(InputDispatcherPilferPointersTest, NoPilferingWithHoveringPointers) {
     window->assertNoEvents();
 }
 
+TEST_F(InputDispatcherPilferPointersTest, DoNotPilfer) {
+    // The foreground window and spy3 have DO_NOT_PILFER set.
+    auto window = createForeground();
+    window->setDoNotPilfer(true);
+    window->setTrustedOverlay(true);
+    auto spy1 = createSpy();
+    auto spy2 = createSpy();
+    auto spy3 = createSpy();
+    spy3->setDoNotPilfer(true);
+    mDispatcher->onWindowInfosChanged(
+            {{*spy1->getInfo(), *spy2->getInfo(), *spy3->getInfo(), *window->getInfo()}, {}, 0, 0});
+
+    // All windows receive the first pointer.
+    mDispatcher->notifyMotion(
+            MotionArgsBuilder(ACTION_DOWN, AINPUT_SOURCE_TOUCHSCREEN)
+                    .pointer(PointerBuilder(/*id=*/0, ToolType::FINGER).x(100).y(200))
+                    .build());
+    window->consumeMotionDown();
+    spy1->consumeMotionDown();
+    spy2->consumeMotionDown();
+    spy3->consumeMotionDown();
+
+    // Pilfer pointers from the second spy window.
+    EXPECT_EQ(OK, mDispatcher->pilferPointers(spy2->getToken()));
+    window->assertNoEvents();
+    spy1->consumeMotionCancel();
+    spy2->assertNoEvents();
+    spy3->assertNoEvents();
+
+    // The rest of the gesture should only be sent to the pilfering and do-not-pilfer windows.
+    mDispatcher->notifyMotion(
+            MotionArgsBuilder(ACTION_MOVE, AINPUT_SOURCE_TOUCHSCREEN)
+                    .pointer(PointerBuilder(/*id=*/0, ToolType::FINGER).x(100).y(200))
+                    .build());
+    window->consumeMotionMove();
+    spy1->assertNoEvents();
+    spy2->consumeMotionMove();
+    spy3->consumeMotionMove();
+}
+
 class InputDispatcherStylusInterceptorTest : public InputDispatcherTest {
 public:
     std::pair<sp<FakeWindowHandle>, sp<FakeWindowHandle>> setupStylusOverlayScenario() {
@@ -15083,9 +14788,9 @@ protected:
  * Two windows. An untouchable window partially occludes a touchable region below it.
  * Use a finger to touch the bottom window.
  * When the finger touches down in the obscured area, the motion event should always have the
- * FLAG_WINDOW_IS_OBSCURED flag, regardless of where it is moved to. If it starts from a
- * non-obscured area, the motion event should always with a FLAG_WINDOW_IS_PARTIALLY_OBSCURED flag,
- * regardless of where it is moved to.
+ * MotionFlag::WINDOW_IS_OBSCURED, regardless of where it is moved to. If it starts from a
+ * non-obscured area, the motion event should always with a MotionFlag::WINDOW_IS_PARTIALLY_OBSCURED
+ * flag, regardless of where it is moved to.
  */
 TEST_F(InputDispatcherObscuredFlagTest, TouchObscuredTest) {
     mWindow->setFrame({0, 0, 100, 100});
@@ -15102,7 +14807,7 @@ TEST_F(InputDispatcherObscuredFlagTest, TouchObscuredTest) {
                     .build());
 
     mWindow->consumeMotionEvent(AllOf(WithMotionAction(ACTION_DOWN),
-                                      WithFlags(FLAG_WINDOW_IS_OBSCURED),
+                                      WithFlags(MotionFlag::WINDOW_IS_OBSCURED),
                                       WithDisplayId(DISPLAY_ID)));
 
     mDispatcher->notifyMotion(
@@ -15111,7 +14816,7 @@ TEST_F(InputDispatcherObscuredFlagTest, TouchObscuredTest) {
                     .build());
 
     mWindow->consumeMotionEvent(AllOf(WithMotionAction(ACTION_MOVE),
-                                      WithFlags(FLAG_WINDOW_IS_OBSCURED),
+                                      WithFlags(MotionFlag::WINDOW_IS_OBSCURED),
                                       WithDisplayId(DISPLAY_ID)));
 
     mDispatcher->notifyMotion(
@@ -15120,7 +14825,7 @@ TEST_F(InputDispatcherObscuredFlagTest, TouchObscuredTest) {
                     .build());
 
     mWindow->consumeMotionEvent(AllOf(WithMotionAction(ACTION_UP),
-                                      WithFlags(FLAG_WINDOW_IS_OBSCURED),
+                                      WithFlags(MotionFlag::WINDOW_IS_OBSCURED),
                                       WithDisplayId(DISPLAY_ID)));
 }
 
@@ -15128,7 +14833,7 @@ TEST_F(InputDispatcherObscuredFlagTest, TouchObscuredTest) {
  * Two windows. An untouchable window partially occludes a touchable region below it.
  * Use a finger to touch the bottom window.
  * When the finger starts from a non-obscured area, the motion event should always have the
- * FLAG_WINDOW_IS_PARTIALLY_OBSCURED flag, regardless of where it is moved to.
+ * MotionFlag::WINDOW_IS_PARTIALLY_OBSCURED flag, regardless of where it is moved to.
  */
 TEST_F(InputDispatcherObscuredFlagTest, TouchPartiallyObscuredTest) {
     mWindow->setFrame({0, 0, 100, 100});
@@ -15138,14 +14843,14 @@ TEST_F(InputDispatcherObscuredFlagTest, TouchPartiallyObscuredTest) {
             {{*mOcclusionWindow->getInfo(), *mWindow->getInfo()}, {}, 0, 0});
 
     // If the finger touch goes down in the region that is not directly obscured by the overlay.
-    // Expect the entire stream to use FLAG_WINDOW_IS_PARTIALLY_OBSCURED.
+    // Expect the entire stream to use MotionFlag::WINDOW_IS_PARTIALLY_OBSCURED.
     mDispatcher->notifyMotion(
             MotionArgsBuilder(ACTION_DOWN, AINPUT_SOURCE_TOUCHSCREEN)
                     .pointer(PointerBuilder(/*id=*/0, ToolType::FINGER).x(50).y(60))
                     .build());
 
     mWindow->consumeMotionEvent(AllOf(WithMotionAction(ACTION_DOWN),
-                                      WithFlags(FLAG_WINDOW_IS_PARTIALLY_OBSCURED),
+                                      WithFlags(MotionFlag::WINDOW_IS_PARTIALLY_OBSCURED),
                                       WithDisplayId(DISPLAY_ID)));
 
     mDispatcher->notifyMotion(
@@ -15154,7 +14859,7 @@ TEST_F(InputDispatcherObscuredFlagTest, TouchPartiallyObscuredTest) {
                     .build());
 
     mWindow->consumeMotionEvent(AllOf(WithMotionAction(ACTION_MOVE),
-                                      WithFlags(FLAG_WINDOW_IS_PARTIALLY_OBSCURED),
+                                      WithFlags(MotionFlag::WINDOW_IS_PARTIALLY_OBSCURED),
                                       WithDisplayId(DISPLAY_ID)));
 
     mDispatcher->notifyMotion(
@@ -15163,7 +14868,7 @@ TEST_F(InputDispatcherObscuredFlagTest, TouchPartiallyObscuredTest) {
                     .build());
 
     mWindow->consumeMotionEvent(AllOf(WithMotionAction(ACTION_UP),
-                                      WithFlags(FLAG_WINDOW_IS_PARTIALLY_OBSCURED),
+                                      WithFlags(MotionFlag::WINDOW_IS_PARTIALLY_OBSCURED),
                                       WithDisplayId(DISPLAY_ID)));
 }
 
@@ -15171,8 +14876,9 @@ TEST_F(InputDispatcherObscuredFlagTest, TouchPartiallyObscuredTest) {
  * Two windows. An untouchable window partially occludes a touchable region below it.
  * Use the mouse to hover over the bottom window.
  * When the hover happens over the occluded area, the window below should receive a motion
- * event with the FLAG_WINDOW_IS_OBSCURED flag. When the hover event moves to the non-occluded area,
- * the window below should receive a motion event with the FLAG_WINDOW_IS_PARTIALLY_OBSCURED flag.
+ * event with the MotionFlag::WINDOW_IS_OBSCURED flag. When the hover event moves to the
+ * non-occluded area, the window below should receive a motion event with the
+ * MotionFlag::WINDOW_IS_PARTIALLY_OBSCURED flag.
  */
 TEST_F(InputDispatcherObscuredFlagTest, MouseHoverObscuredTest) {
     mWindow->setFrame({0, 0, 100, 100});
@@ -15181,33 +14887,37 @@ TEST_F(InputDispatcherObscuredFlagTest, MouseHoverObscuredTest) {
     mDispatcher->onWindowInfosChanged(
             {{*mOcclusionWindow->getInfo(), *mWindow->getInfo()}, {}, 0, 0});
 
-    // TODO(b/328160937): The window should receive a motion event with the FLAG_WINDOW_IS_OBSCURED
-    // flag.
+    // TODO(b/328160937): The window should receive a motion event with the
+    // MotionFlag::WINDOW_IS_OBSCURED flag.
     mDispatcher->notifyMotion(
             MotionArgsBuilder(ACTION_HOVER_MOVE, AINPUT_SOURCE_MOUSE)
                     .pointer(PointerBuilder(/*id=*/0, ToolType::MOUSE).x(50).y(20))
                     .build());
-    mWindow->consumeMotionEvent(AllOf(WithMotionAction(ACTION_HOVER_ENTER), WithFlags(0)));
+    mWindow->consumeMotionEvent(
+            AllOf(WithMotionAction(ACTION_HOVER_ENTER), WithFlags(ftl::Flags<MotionFlag>{})));
 
     mDispatcher->notifyMotion(
             MotionArgsBuilder(ACTION_HOVER_MOVE, AINPUT_SOURCE_MOUSE)
                     .pointer(PointerBuilder(/*id=*/0, ToolType::MOUSE).x(50).y(30))
                     .build());
-    mWindow->consumeMotionEvent(AllOf(WithMotionAction(ACTION_HOVER_MOVE), WithFlags(0)));
+    mWindow->consumeMotionEvent(
+            AllOf(WithMotionAction(ACTION_HOVER_MOVE), WithFlags(ftl::Flags<MotionFlag>{})));
 
     // TODO(b/328160937): The window should receive a motion event with the
-    // FLAG_WINDOW_IS_PARTIALLY_OBSCURED flag.
+    // MotionFlag::WINDOW_IS_PARTIALLY_OBSCURED flag.
     mDispatcher->notifyMotion(
             MotionArgsBuilder(ACTION_HOVER_MOVE, AINPUT_SOURCE_MOUSE)
                     .pointer(PointerBuilder(/*id=*/0, ToolType::MOUSE).x(50).y(50))
                     .build());
-    mWindow->consumeMotionEvent(AllOf(WithMotionAction(ACTION_HOVER_MOVE), WithFlags(0)));
+    mWindow->consumeMotionEvent(
+            AllOf(WithMotionAction(ACTION_HOVER_MOVE), WithFlags(ftl::Flags<MotionFlag>{})));
 
     mDispatcher->notifyMotion(
             MotionArgsBuilder(ACTION_HOVER_MOVE, AINPUT_SOURCE_MOUSE)
                     .pointer(PointerBuilder(/*id=*/0, ToolType::MOUSE).x(50).y(60))
                     .build());
-    mWindow->consumeMotionEvent(AllOf(WithMotionAction(ACTION_HOVER_MOVE), WithFlags(0)));
+    mWindow->consumeMotionEvent(
+            AllOf(WithMotionAction(ACTION_HOVER_MOVE), WithFlags(ftl::Flags<MotionFlag>{})));
 
     mDispatcher->notifyMotion(
             MotionArgsBuilder(ACTION_HOVER_MOVE, AINPUT_SOURCE_MOUSE)
@@ -15215,8 +14925,9 @@ TEST_F(InputDispatcherObscuredFlagTest, MouseHoverObscuredTest) {
                     .build());
 
     // TODO(b/328160937): The window should receive a HOVER_EXIT with the
-    //  FLAG_WINDOW_IS_PARTIALLY_OBSCURED flag. The cause of the current issue is that we moved the
-    //  mouse to a location where there are no windows, so the HOVER_EXIT event cannot be generated.
+    //  MotionFlag::WINDOW_IS_PARTIALLY_OBSCURED flag. The cause of the current issue is that we
+    //  moved the mouse to a location where there are no windows, so the HOVER_EXIT event cannot be
+    //  generated.
     mWindow->assertNoEvents();
 }
 
@@ -15225,7 +14936,8 @@ TEST_F(InputDispatcherObscuredFlagTest, MouseHoverObscuredTest) {
  * Use the stylus to hover over the bottom window.
  * When the hover happens over the occluded area, the window below should receive a motion
  * event with the FLAG_WINDOW_IS_OBSCURED flag. When the hover event moves to the non-occluded area,
- * the window below should receive a motion event with the FLAG_WINDOW_IS_PARTIALLY_OBSCURED flag.
+ * the window below should receive a motion event with the MotionFlag::WINDOW_IS_PARTIALLY_OBSCURED
+ * flag.
  */
 TEST_F(InputDispatcherObscuredFlagTest, StylusHoverObscuredTest) {
     mWindow->setFrame({0, 0, 100, 100});
@@ -15240,33 +14952,38 @@ TEST_F(InputDispatcherObscuredFlagTest, StylusHoverObscuredTest) {
             MotionArgsBuilder(ACTION_HOVER_ENTER, AINPUT_SOURCE_STYLUS)
                     .pointer(PointerBuilder(/*id=*/0, ToolType::STYLUS).x(50).y(20))
                     .build());
-    mWindow->consumeMotionEvent(AllOf(WithMotionAction(ACTION_HOVER_ENTER), WithFlags(0)));
+    mWindow->consumeMotionEvent(
+            AllOf(WithMotionAction(ACTION_HOVER_ENTER), WithFlags(ftl::Flags<MotionFlag>{})));
 
     mDispatcher->notifyMotion(
             MotionArgsBuilder(ACTION_HOVER_MOVE, AINPUT_SOURCE_STYLUS)
                     .pointer(PointerBuilder(/*id=*/0, ToolType::STYLUS).x(50).y(30))
                     .build());
-    mWindow->consumeMotionEvent(AllOf(WithMotionAction(ACTION_HOVER_MOVE), WithFlags(0)));
+    mWindow->consumeMotionEvent(
+            AllOf(WithMotionAction(ACTION_HOVER_MOVE), WithFlags(ftl::Flags<MotionFlag>{})));
 
     // TODO(b/328160937): The window should receive a motion event with the
-    // FLAG_WINDOW_IS_PARTIALLY_OBSCURED flag.
+    // MotionFlag::WINDOW_IS_PARTIALLY_OBSCURED flag.
     mDispatcher->notifyMotion(
             MotionArgsBuilder(ACTION_HOVER_MOVE, AINPUT_SOURCE_STYLUS)
                     .pointer(PointerBuilder(/*id=*/0, ToolType::STYLUS).x(50).y(50))
                     .build());
-    mWindow->consumeMotionEvent(AllOf(WithMotionAction(ACTION_HOVER_MOVE), WithFlags(0)));
+    mWindow->consumeMotionEvent(
+            AllOf(WithMotionAction(ACTION_HOVER_MOVE), WithFlags(ftl::Flags<MotionFlag>{})));
 
     mDispatcher->notifyMotion(
             MotionArgsBuilder(ACTION_HOVER_MOVE, AINPUT_SOURCE_STYLUS)
                     .pointer(PointerBuilder(/*id=*/0, ToolType::STYLUS).x(50).y(60))
                     .build());
-    mWindow->consumeMotionEvent(AllOf(WithMotionAction(ACTION_HOVER_MOVE), WithFlags(0)));
+    mWindow->consumeMotionEvent(
+            AllOf(WithMotionAction(ACTION_HOVER_MOVE), WithFlags(ftl::Flags<MotionFlag>{})));
 
     mDispatcher->notifyMotion(
             MotionArgsBuilder(ACTION_HOVER_EXIT, AINPUT_SOURCE_STYLUS)
                     .pointer(PointerBuilder(/*id=*/0, ToolType::STYLUS).x(50).y(70))
                     .build());
-    mWindow->consumeMotionEvent(AllOf(WithMotionAction(ACTION_HOVER_EXIT), WithFlags(0)));
+    mWindow->consumeMotionEvent(
+            AllOf(WithMotionAction(ACTION_HOVER_EXIT), WithFlags(ftl::Flags<MotionFlag>{})));
 }
 
 class TransferOrDontTransferFixture : public InputDispatcherTest,
@@ -15465,18 +15182,23 @@ TEST_P(TransferOrDontTransferFixture, MouseAndTouchTransferSimultaneousMultiDevi
 INSTANTIATE_TEST_SUITE_P(WithAndWithoutTransfer, TransferOrDontTransferFixture, testing::Bool());
 
 class InputDispatcherConnectedDisplayTest : public InputDispatcherDragTests {
+protected:
     constexpr static int DENSITY_MEDIUM = 160;
 
-    const DisplayTopologyGraph
-            mTopology{.primaryDisplayId = DISPLAY_ID,
-                      .graph = {{DISPLAY_ID,
-                                 {{SECOND_DISPLAY_ID, DisplayTopologyPosition::TOP, 0.0f}}},
-                                {SECOND_DISPLAY_ID,
-                                 {{DISPLAY_ID, DisplayTopologyPosition::BOTTOM, 0.0f}}}},
-                      .displaysDensity = {{DISPLAY_ID, DENSITY_MEDIUM},
-                                          {SECOND_DISPLAY_ID, DENSITY_MEDIUM}}};
+    const DisplayTopologyGraph mTopology =
+            DisplayTopologyGraph::create(/*primaryDisplayId=*/DISPLAY_ID,
+                                         /*topologyGraph=*/
+                                         {{DISPLAY_ID,
+                                           {{{SECOND_DISPLAY_ID, DisplayTopologyPosition::TOP,
+                                              0.0f}},
+                                            DENSITY_MEDIUM,
+                                            FloatRect(0, -500, 500, 0)}},
+                                          {SECOND_DISPLAY_ID,
+                                           {{{DISPLAY_ID, DisplayTopologyPosition::BOTTOM, 0.0f}},
+                                            DENSITY_MEDIUM,
+                                            FloatRect(0, 0, 500, 5000)}}})
+                    .value();
 
-protected:
     void SetUp() override {
         addDisplay(DISPLAY_ID, ui::Transform());
         addDisplay(SECOND_DISPLAY_ID,
@@ -15562,7 +15284,7 @@ TEST_F(InputDispatcherConnectedDisplayTest, MultiDisplayMouseDragAndDropFromPrim
                     .buttonState(AMOTION_EVENT_BUTTON_PRIMARY)
                     .pointer(PointerBuilder(MOUSE_POINTER_ID, ToolType::MOUSE).x(50).y(50))
                     .build());
-    mDragWindow->consumeMotionMove(DISPLAY_ID, AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    mDragWindow->consumeMotionMove(DISPLAY_ID, MotionFlag::NO_FOCUS_CHANGE);
     mWindow->consumeDragEvent(false, 50, 50);
     mSecondWindow->assertNoEvents();
     mWindowOnSecondDisplay->assertNoEvents();
@@ -15574,7 +15296,7 @@ TEST_F(InputDispatcherConnectedDisplayTest, MultiDisplayMouseDragAndDropFromPrim
                     .buttonState(AMOTION_EVENT_BUTTON_PRIMARY)
                     .pointer(PointerBuilder(MOUSE_POINTER_ID, ToolType::MOUSE).x(150).y(50))
                     .build());
-    mDragWindow->consumeMotionMove(DISPLAY_ID, AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    mDragWindow->consumeMotionMove(DISPLAY_ID, MotionFlag::NO_FOCUS_CHANGE);
     mWindow->consumeDragEvent(true, 150, 50);
     mSecondWindow->consumeDragEvent(false, 50, 50);
     mWindowOnSecondDisplay->assertNoEvents();
@@ -15586,7 +15308,7 @@ TEST_F(InputDispatcherConnectedDisplayTest, MultiDisplayMouseDragAndDropFromPrim
                     .buttonState(AMOTION_EVENT_BUTTON_PRIMARY)
                     .pointer(PointerBuilder(MOUSE_POINTER_ID, ToolType::MOUSE).x(50).y(50))
                     .build());
-    mDragWindow->consumeMotionMove(SECOND_DISPLAY_ID, AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    mDragWindow->consumeMotionMove(SECOND_DISPLAY_ID, MotionFlag::NO_FOCUS_CHANGE);
     mWindow->assertNoEvents();
     mSecondWindow->consumeDragEvent(true, -50, 50);
     mWindowOnSecondDisplay->consumeDragEvent(false, 50, 50);
@@ -15598,7 +15320,7 @@ TEST_F(InputDispatcherConnectedDisplayTest, MultiDisplayMouseDragAndDropFromPrim
                     .buttonState(0)
                     .pointer(PointerBuilder(MOUSE_POINTER_ID, ToolType::MOUSE).x(50).y(50))
                     .build());
-    mDragWindow->consumeMotionUp(SECOND_DISPLAY_ID, AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    mDragWindow->consumeMotionUp(SECOND_DISPLAY_ID, MotionFlag::NO_FOCUS_CHANGE);
     mFakePolicy->assertDropTargetEquals(*mDispatcher, mWindowOnSecondDisplay->getToken());
     mWindow->assertNoEvents();
     mSecondWindow->assertNoEvents();
@@ -15616,7 +15338,7 @@ TEST_F(InputDispatcherConnectedDisplayTest, MultiDisplayMouseDragAndDropFromNonP
                     .buttonState(AMOTION_EVENT_BUTTON_PRIMARY)
                     .pointer(PointerBuilder(MOUSE_POINTER_ID, ToolType::MOUSE).x(50).y(50))
                     .build());
-    mDragWindow->consumeMotionMove(SECOND_DISPLAY_ID, AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    mDragWindow->consumeMotionMove(SECOND_DISPLAY_ID, MotionFlag::NO_FOCUS_CHANGE);
     mWindow->assertNoEvents();
     mSecondWindow->assertNoEvents();
     mWindowOnSecondDisplay->consumeDragEvent(false, 50, 50);
@@ -15628,7 +15350,7 @@ TEST_F(InputDispatcherConnectedDisplayTest, MultiDisplayMouseDragAndDropFromNonP
                     .buttonState(AMOTION_EVENT_BUTTON_PRIMARY)
                     .pointer(PointerBuilder(MOUSE_POINTER_ID, ToolType::MOUSE).x(50).y(50))
                     .build());
-    mDragWindow->consumeMotionMove(DISPLAY_ID, AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    mDragWindow->consumeMotionMove(DISPLAY_ID, MotionFlag::NO_FOCUS_CHANGE);
     mWindow->consumeDragEvent(false, 50, 50);
     mSecondWindow->assertNoEvents();
     mWindowOnSecondDisplay->consumeDragEvent(true, 50, 50);
@@ -15640,13 +15362,57 @@ TEST_F(InputDispatcherConnectedDisplayTest, MultiDisplayMouseDragAndDropFromNonP
                     .buttonState(0)
                     .pointer(PointerBuilder(MOUSE_POINTER_ID, ToolType::MOUSE).x(50).y(50))
                     .build());
-    mDragWindow->consumeMotionUp(DISPLAY_ID, AMOTION_EVENT_FLAG_NO_FOCUS_CHANGE);
+    mDragWindow->consumeMotionUp(DISPLAY_ID, MotionFlag::NO_FOCUS_CHANGE);
     mFakePolicy->assertDropTargetEquals(*mDispatcher, mWindow->getToken());
     mWindow->assertNoEvents();
     mSecondWindow->assertNoEvents();
     mWindowOnSecondDisplay->assertNoEvents();
 }
 
+/**
+ * Test that touch state is maintained across windowInfo updates on the non-primary display.
+ *
+ * Create two windows, one on the primary display and another on the secondary display.
+ * Start hovering on the window on the secondary display.
+ *
+ * Update the window info, and verify that the hover state is maintained, and no events are
+ * generated.
+ *
+ * Remove the window on the secondary display, and verify that the window receives a HOVER_EXIT
+ * event.
+ */
+TEST_F(InputDispatcherConnectedDisplayTest,
+       NonPrimaryDisplayTouchStateIsMaintainedOnWindowInfoUpdate) {
+    SCOPED_FLAG_OVERRIDE(connected_displays_cursor, true);
+    sp<FakeWindowHandle> window0 =
+            sp<FakeWindowHandle>::make(std::make_shared<FakeApplicationHandle>(), mDispatcher,
+                                       "TestWindowOnPrimaryDisplay", mTopology.primaryDisplayId);
+    window0->setFrame(Rect(0, 0, 500, 500));
+    sp<FakeWindowHandle> window1 =
+            sp<FakeWindowHandle>::make(std::make_shared<FakeApplicationHandle>(), mDispatcher,
+                                       "TestWindowOnNonPrimaryDisplay", SECOND_DISPLAY_ID);
+    window1->setFrame(Rect(0, 0, 500, 500));
+    mDispatcher->onWindowInfosChanged({{*window0->getInfo(), *window1->getInfo()}, {}, 0, 0});
+
+    // Add hover state to window on display 1.
+    mDispatcher->notifyMotion(
+            MotionArgsBuilder(AMOTION_EVENT_ACTION_HOVER_ENTER, AINPUT_SOURCE_MOUSE)
+                    .displayId(SECOND_DISPLAY_ID)
+                    .pointer(PointerBuilder(MOUSE_POINTER_ID, ToolType::MOUSE).x(100).y(100))
+                    .build());
+    window1->consumeMotionEvent(WithMotionAction(AMOTION_EVENT_ACTION_HOVER_ENTER));
+
+    // Sending same window info should not generate any events.
+    mDispatcher->onWindowInfosChanged({{*window0->getInfo(), *window1->getInfo()}, {}, 0, 0});
+    window1->assertNoEvents();
+
+    // Remove the window now, it should receive hover_exit as usual.
+    mDispatcher->onWindowInfosChanged({{}, {}, 0, 0});
+    window1->consumeMotionEvent(WithMotionAction(AMOTION_EVENT_ACTION_HOVER_EXIT));
+
+    window0->assertNoEvents();
+}
+
 using InputDispatcherConnectedDisplayPointerInWindowTest = InputDispatcherConnectedDisplayTest;
 
 TEST_F(InputDispatcherConnectedDisplayPointerInWindowTest, MouseOnWindowOnPrimaryDisplay) {
diff --git a/services/inputflinger/tests/InputProcessorConverter_test.cpp b/services/inputflinger/tests/InputProcessorConverter_test.cpp
index bdf156c49a..f5cd6b8743 100644
--- a/services/inputflinger/tests/InputProcessorConverter_test.cpp
+++ b/services/inputflinger/tests/InputProcessorConverter_test.cpp
@@ -41,9 +41,9 @@ static NotifyMotionArgs generateBasicMotionArgs() {
                                 /*deviceId=*/3, AINPUT_SOURCE_ANY, ui::LogicalDisplayId::DEFAULT,
                                 /*policyFlags=*/4, AMOTION_EVENT_ACTION_DOWN, /*actionButton=*/0,
                                 /*flags=*/0, AMETA_NONE, /*buttonState=*/0,
-                                MotionClassification::NONE, AMOTION_EVENT_EDGE_FLAG_NONE,
-                                /*pointerCount=*/1, &properties, &coords, /*xPrecision=*/0,
-                                /*yPrecision=*/0, AMOTION_EVENT_INVALID_CURSOR_POSITION,
+                                MotionClassification::NONE, /*pointerCount=*/1, &properties,
+                                &coords, /*xPrecision=*/0, /*yPrecision=*/0,
+                                AMOTION_EVENT_INVALID_CURSOR_POSITION,
                                 AMOTION_EVENT_INVALID_CURSOR_POSITION, downTime,
                                 /*videoFrames=*/{});
     return motionArgs;
diff --git a/services/inputflinger/tests/InputProcessor_test.cpp b/services/inputflinger/tests/InputProcessor_test.cpp
index d4c5a009a6..4755470c53 100644
--- a/services/inputflinger/tests/InputProcessor_test.cpp
+++ b/services/inputflinger/tests/InputProcessor_test.cpp
@@ -47,9 +47,9 @@ static NotifyMotionArgs generateBasicMotionArgs() {
                                 /*deviceId=*/3, AINPUT_SOURCE_ANY, ui::LogicalDisplayId::DEFAULT,
                                 /*policyFlags=*/4, AMOTION_EVENT_ACTION_DOWN, /*actionButton=*/0,
                                 /*flags=*/0, AMETA_NONE, /*buttonState=*/0,
-                                MotionClassification::NONE, AMOTION_EVENT_EDGE_FLAG_NONE,
-                                /*pointerCount=*/1, &properties, &coords, /*xPrecision=*/0,
-                                /*yPrecision=*/0, AMOTION_EVENT_INVALID_CURSOR_POSITION,
+                                MotionClassification::NONE, /*pointerCount=*/1, &properties,
+                                &coords, /*xPrecision=*/0, /*yPrecision=*/0,
+                                AMOTION_EVENT_INVALID_CURSOR_POSITION,
                                 AMOTION_EVENT_INVALID_CURSOR_POSITION, downTime,
                                 /*videoFrames=*/{});
     return motionArgs;
diff --git a/services/inputflinger/tests/InputReader_test.cpp b/services/inputflinger/tests/InputReader_test.cpp
index d1d8192395..357b0c17f4 100644
--- a/services/inputflinger/tests/InputReader_test.cpp
+++ b/services/inputflinger/tests/InputReader_test.cpp
@@ -611,14 +611,10 @@ protected:
     }
 
     void addDevice(int32_t eventHubId, const std::string& name,
-                   ftl::Flags<InputDeviceClass> classes, const PropertyMap* configuration,
-                   std::string sysfsRootPath = "") {
+                   ftl::Flags<InputDeviceClass> classes, std::string sysfsRootPath = "") {
         mFakeEventHub->addDevice(eventHubId, name, classes);
         mFakeEventHub->setSysfsRootPath(eventHubId, sysfsRootPath);
 
-        if (configuration) {
-            mFakeEventHub->addConfigurationMap(eventHubId, configuration);
-        }
         mReader->loopOnce();
         mReader->loopOnce();
         ASSERT_NO_FATAL_FAILURE(mFakePolicy->assertInputDevicesChanged());
@@ -639,22 +635,21 @@ protected:
     FakeInputMapper& addDeviceWithFakeInputMapper(int32_t deviceId, int32_t eventHubId,
                                                   const std::string& name,
                                                   ftl::Flags<InputDeviceClass> classes,
-                                                  uint32_t sources,
-                                                  const PropertyMap* configuration) {
+                                                  uint32_t sources) {
         std::shared_ptr<InputDevice> device = mReader->newDevice(deviceId, name);
         FakeInputMapper& mapper =
                 device->addMapper<FakeInputMapper>(eventHubId,
                                                    mFakePolicy->getReaderConfiguration(), sources);
         mReader->pushNextDevice(device);
-        addDevice(eventHubId, name, classes, configuration);
+        addDevice(eventHubId, name, classes);
         return mapper;
     }
 };
 
 TEST_F(InputReaderTest, PolicyGetInputDevices) {
-    ASSERT_NO_FATAL_FAILURE(addDevice(1, "keyboard", InputDeviceClass::KEYBOARD, nullptr));
-    ASSERT_NO_FATAL_FAILURE(addDevice(2, "ignored", ftl::Flags<InputDeviceClass>(0),
-                                      nullptr)); // no classes so device will be ignored
+    ASSERT_NO_FATAL_FAILURE(addDevice(1, "keyboard", InputDeviceClass::KEYBOARD));
+    // no classes so device will be ignored
+    ASSERT_NO_FATAL_FAILURE(addDevice(2, "ignored", ftl::Flags<InputDeviceClass>(0)));
 
     // Should also have received a notification describing the new input devices.
     const std::vector<InputDeviceInfo>& inputDevices = mFakePolicy->getInputDevices();
@@ -668,8 +663,7 @@ TEST_F(InputReaderTest, PolicyGetInputDevices) {
 
 TEST_F(InputReaderTest, GetSysfsRootPath) {
     constexpr std::string SYSFS_ROOT = "xyz";
-    ASSERT_NO_FATAL_FAILURE(
-            addDevice(1, "keyboard", InputDeviceClass::KEYBOARD, nullptr, SYSFS_ROOT));
+    ASSERT_NO_FATAL_FAILURE(addDevice(1, "keyboard", InputDeviceClass::KEYBOARD, SYSFS_ROOT));
 
     // Should also have received a notification describing the new input device.
     ASSERT_EQ(1U, mFakePolicy->getInputDevices().size());
@@ -679,7 +673,7 @@ TEST_F(InputReaderTest, GetSysfsRootPath) {
 }
 
 TEST_F(InputReaderTest, InputDeviceRecreatedOnSysfsNodeChanged) {
-    ASSERT_NO_FATAL_FAILURE(addDevice(1, "keyboard", InputDeviceClass::KEYBOARD, nullptr));
+    ASSERT_NO_FATAL_FAILURE(addDevice(1, "keyboard", InputDeviceClass::KEYBOARD));
     mFakeEventHub->setSysfsRootPath(1, "xyz");
 
     // Should also have received a notification describing the new input device.
@@ -716,10 +710,8 @@ TEST_F(InputReaderTest, GetMergedInputDevices) {
     // Push same device instance for next device to be added, so they'll have same identifier.
     mReader->pushNextDevice(device);
     mReader->pushNextDevice(device);
-    ASSERT_NO_FATAL_FAILURE(
-            addDevice(eventHubIds[0], "fake1", InputDeviceClass::KEYBOARD, nullptr));
-    ASSERT_NO_FATAL_FAILURE(
-            addDevice(eventHubIds[1], "fake2", InputDeviceClass::KEYBOARD, nullptr));
+    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[0], "fake1", InputDeviceClass::KEYBOARD));
+    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[1], "fake2", InputDeviceClass::KEYBOARD));
 
     // Two devices will be merged to one input device as they have same identifier
     ASSERT_EQ(1U, mFakePolicy->getInputDevices().size());
@@ -741,13 +733,11 @@ TEST_F(InputReaderTest, GetMergedInputDevicesEnabled) {
     mReader->pushNextDevice(device);
     // Sensor device is initially disabled
     ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[0], "fake1",
-                                      InputDeviceClass::KEYBOARD | InputDeviceClass::SENSOR,
-                                      nullptr));
+                                      InputDeviceClass::KEYBOARD | InputDeviceClass::SENSOR));
     // Device is disabled because the only sub device is a sensor device and disabled initially.
     ASSERT_FALSE(mFakeEventHub->isDeviceEnabled(eventHubIds[0]));
     ASSERT_FALSE(device->isEnabled());
-    ASSERT_NO_FATAL_FAILURE(
-            addDevice(eventHubIds[1], "fake2", InputDeviceClass::KEYBOARD, nullptr));
+    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[1], "fake2", InputDeviceClass::KEYBOARD));
     // The merged device is enabled if any sub device is enabled
     ASSERT_TRUE(mFakeEventHub->isDeviceEnabled(eventHubIds[1]));
     ASSERT_TRUE(device->isEnabled());
@@ -762,7 +752,7 @@ TEST_F(InputReaderTest, WhenEnabledChanges_SendsDeviceResetNotification) {
     device->addMapper<FakeInputMapper>(eventHubId, mFakePolicy->getReaderConfiguration(),
                                        AINPUT_SOURCE_KEYBOARD);
     mReader->pushNextDevice(device);
-    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubId, "fake", deviceClass, nullptr));
+    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubId, "fake", deviceClass));
 
     NotifyDeviceResetArgs resetArgs;
     ASSERT_NO_FATAL_FAILURE(mFakeListener->assertNotifyDeviceResetWasCalled(&resetArgs));
@@ -792,9 +782,8 @@ TEST_F(InputReaderTest, GetKeyCodeState_ForwardsRequestsToMappers) {
     constexpr int32_t deviceId = END_RESERVED_ID + 1000;
     constexpr ftl::Flags<InputDeviceClass> deviceClass = InputDeviceClass::KEYBOARD;
     constexpr int32_t eventHubId = 1;
-    FakeInputMapper& mapper =
-            addDeviceWithFakeInputMapper(deviceId, eventHubId, "fake", deviceClass,
-                                         AINPUT_SOURCE_KEYBOARD, nullptr);
+    FakeInputMapper& mapper = addDeviceWithFakeInputMapper(deviceId, eventHubId, "fake",
+                                                           deviceClass, AINPUT_SOURCE_KEYBOARD);
     mapper.setKeyCodeState(AKEYCODE_A, AKEY_STATE_DOWN);
 
     ASSERT_EQ(AKEY_STATE_UNKNOWN, mReader->getKeyCodeState(0,
@@ -824,9 +813,9 @@ TEST_F(InputReaderTest, GetKeyCodeState_ForwardsRequestsToMappers) {
 TEST_F(InputReaderTest, GetKeyCodeForKeyLocation_ForwardsRequestsToMappers) {
     constexpr int32_t deviceId = END_RESERVED_ID + 1000;
     constexpr int32_t eventHubId = 1;
-    FakeInputMapper& mapper = addDeviceWithFakeInputMapper(deviceId, eventHubId, "keyboard",
-                                                           InputDeviceClass::KEYBOARD,
-                                                           AINPUT_SOURCE_KEYBOARD, nullptr);
+    FakeInputMapper& mapper =
+            addDeviceWithFakeInputMapper(deviceId, eventHubId, "keyboard",
+                                         InputDeviceClass::KEYBOARD, AINPUT_SOURCE_KEYBOARD);
     mapper.addKeyCodeMapping(AKEYCODE_Y, AKEYCODE_Z);
 
     ASSERT_EQ(AKEYCODE_UNKNOWN, mReader->getKeyCodeForKeyLocation(0, AKEYCODE_Y))
@@ -843,9 +832,9 @@ TEST_F(InputReaderTest, GetKeyCodeForKeyLocation_ForwardsRequestsToMappers) {
 TEST_F(InputReaderTest, GetKeyCodeForKeyLocation_NoKeyboardMapper) {
     constexpr int32_t deviceId = END_RESERVED_ID + 1000;
     constexpr int32_t eventHubId = 1;
-    FakeInputMapper& mapper = addDeviceWithFakeInputMapper(deviceId, eventHubId, "joystick",
-                                                           InputDeviceClass::JOYSTICK,
-                                                           AINPUT_SOURCE_GAMEPAD, nullptr);
+    FakeInputMapper& mapper =
+            addDeviceWithFakeInputMapper(deviceId, eventHubId, "joystick",
+                                         InputDeviceClass::JOYSTICK, AINPUT_SOURCE_GAMEPAD);
     mapper.addKeyCodeMapping(AKEYCODE_Y, AKEYCODE_Z);
 
     ASSERT_EQ(AKEYCODE_UNKNOWN, mReader->getKeyCodeForKeyLocation(deviceId, AKEYCODE_Y))
@@ -856,9 +845,8 @@ TEST_F(InputReaderTest, GetScanCodeState_ForwardsRequestsToMappers) {
     constexpr int32_t deviceId = END_RESERVED_ID + 1000;
     constexpr ftl::Flags<InputDeviceClass> deviceClass = InputDeviceClass::KEYBOARD;
     constexpr int32_t eventHubId = 1;
-    FakeInputMapper& mapper =
-            addDeviceWithFakeInputMapper(deviceId, eventHubId, "fake", deviceClass,
-                                         AINPUT_SOURCE_KEYBOARD, nullptr);
+    FakeInputMapper& mapper = addDeviceWithFakeInputMapper(deviceId, eventHubId, "fake",
+                                                           deviceClass, AINPUT_SOURCE_KEYBOARD);
     mapper.setScanCodeState(KEY_A, AKEY_STATE_DOWN);
 
     ASSERT_EQ(AKEY_STATE_UNKNOWN, mReader->getScanCodeState(0,
@@ -889,9 +877,8 @@ TEST_F(InputReaderTest, GetSwitchState_ForwardsRequestsToMappers) {
     constexpr int32_t deviceId = END_RESERVED_ID + 1000;
     constexpr ftl::Flags<InputDeviceClass> deviceClass = InputDeviceClass::KEYBOARD;
     constexpr int32_t eventHubId = 1;
-    FakeInputMapper& mapper =
-            addDeviceWithFakeInputMapper(deviceId, eventHubId, "fake", deviceClass,
-                                         AINPUT_SOURCE_KEYBOARD, nullptr);
+    FakeInputMapper& mapper = addDeviceWithFakeInputMapper(deviceId, eventHubId, "fake",
+                                                           deviceClass, AINPUT_SOURCE_KEYBOARD);
     mapper.setSwitchState(SW_LID, AKEY_STATE_DOWN);
 
     ASSERT_EQ(AKEY_STATE_UNKNOWN, mReader->getSwitchState(0,
@@ -922,9 +909,8 @@ TEST_F(InputReaderTest, MarkSupportedKeyCodes_ForwardsRequestsToMappers) {
     constexpr int32_t deviceId = END_RESERVED_ID + 1000;
     constexpr ftl::Flags<InputDeviceClass> deviceClass = InputDeviceClass::KEYBOARD;
     constexpr int32_t eventHubId = 1;
-    FakeInputMapper& mapper =
-            addDeviceWithFakeInputMapper(deviceId, eventHubId, "fake", deviceClass,
-                                         AINPUT_SOURCE_KEYBOARD, nullptr);
+    FakeInputMapper& mapper = addDeviceWithFakeInputMapper(deviceId, eventHubId, "fake",
+                                                           deviceClass, AINPUT_SOURCE_KEYBOARD);
 
     mapper.addSupportedKeyCode(AKEYCODE_A);
     mapper.addSupportedKeyCode(AKEYCODE_B);
@@ -969,9 +955,8 @@ TEST_F(InputReaderTest, LoopOnce_ForwardsRawEventsToMappers) {
     constexpr nsecs_t when = 0;
     constexpr int32_t eventHubId = 1;
     constexpr nsecs_t readTime = 2;
-    FakeInputMapper& mapper =
-            addDeviceWithFakeInputMapper(deviceId, eventHubId, "fake", deviceClass,
-                                         AINPUT_SOURCE_KEYBOARD, nullptr);
+    FakeInputMapper& mapper = addDeviceWithFakeInputMapper(deviceId, eventHubId, "fake",
+                                                           deviceClass, AINPUT_SOURCE_KEYBOARD);
 
     mFakeEventHub->enqueueEvent(when, readTime, eventHubId, EV_KEY, KEY_A, 1);
     mReader->loopOnce();
@@ -996,7 +981,7 @@ TEST_F(InputReaderTest, DeviceReset_RandomId) {
     device->addMapper<FakeInputMapper>(eventHubId, mFakePolicy->getReaderConfiguration(),
                                        AINPUT_SOURCE_KEYBOARD);
     mReader->pushNextDevice(device);
-    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubId, "fake", deviceClass, nullptr));
+    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubId, "fake", deviceClass));
 
     NotifyDeviceResetArgs resetArgs;
     ASSERT_NO_FATAL_FAILURE(mFakeListener->assertNotifyDeviceResetWasCalled(&resetArgs));
@@ -1030,7 +1015,7 @@ TEST_F(InputReaderTest, DeviceReset_GenerateIdWithInputReaderSource) {
     device->addMapper<FakeInputMapper>(eventHubId, mFakePolicy->getReaderConfiguration(),
                                        AINPUT_SOURCE_KEYBOARD);
     mReader->pushNextDevice(device);
-    ASSERT_NO_FATAL_FAILURE(addDevice(deviceId, "fake", deviceClass, nullptr));
+    ASSERT_NO_FATAL_FAILURE(addDevice(deviceId, "fake", deviceClass));
 
     NotifyDeviceResetArgs resetArgs;
     ASSERT_NO_FATAL_FAILURE(mFakeListener->assertNotifyDeviceResetWasCalled(&resetArgs));
@@ -1069,7 +1054,7 @@ TEST_F(InputReaderTest, Device_CanDispatchToDisplay) {
     // Add the device, and make sure all of the callbacks are triggered.
     // The device is added after the input port associations are processed since
     // we do not yet support dynamic device-to-display associations.
-    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubId, "fake", deviceClass, nullptr));
+    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubId, "fake", deviceClass));
     ASSERT_NO_FATAL_FAILURE(mFakeListener->assertNotifyDeviceResetWasCalled());
     ASSERT_NO_FATAL_FAILURE(mapper.assertConfigureWasCalled());
 
@@ -1096,8 +1081,8 @@ TEST_F(InputReaderTest, WhenEnabledChanges_AllSubdevicesAreUpdated) {
                                        AINPUT_SOURCE_KEYBOARD);
     mReader->pushNextDevice(device);
     mReader->pushNextDevice(device);
-    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[0], "fake1", deviceClass, nullptr));
-    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[1], "fake2", deviceClass, nullptr));
+    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[0], "fake1", deviceClass));
+    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[1], "fake2", deviceClass));
 
     NotifyDeviceResetArgs resetArgs;
     ASSERT_NO_FATAL_FAILURE(mFakeListener->assertNotifyDeviceResetWasCalled(&resetArgs));
@@ -1141,8 +1126,8 @@ TEST_F(InputReaderTest, GetKeyCodeState_ForwardsRequestsToSubdeviceMappers) {
                                                AINPUT_SOURCE_KEYBOARD);
     mReader->pushNextDevice(device);
     mReader->pushNextDevice(device);
-    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[0], "fake1", deviceClass, nullptr));
-    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[1], "fake2", deviceClass, nullptr));
+    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[0], "fake1", deviceClass));
+    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[1], "fake2", deviceClass));
 
     mapperDevice1.setKeyCodeState(AKEYCODE_A, AKEY_STATE_DOWN);
     mapperDevice2.setKeyCodeState(AKEYCODE_B, AKEY_STATE_DOWN);
@@ -1183,12 +1168,10 @@ TEST_F(InputReaderTest, GetLastUsedInputDeviceId) {
     constexpr int32_t SECOND_DEVICE_ID = FIRST_DEVICE_ID + 1;
     FakeInputMapper& firstMapper =
             addDeviceWithFakeInputMapper(FIRST_DEVICE_ID, FIRST_DEVICE_ID, "first",
-                                         InputDeviceClass::KEYBOARD, AINPUT_SOURCE_KEYBOARD,
-                                         /*configuration=*/nullptr);
+                                         InputDeviceClass::KEYBOARD, AINPUT_SOURCE_KEYBOARD);
     FakeInputMapper& secondMapper =
             addDeviceWithFakeInputMapper(SECOND_DEVICE_ID, SECOND_DEVICE_ID, "second",
-                                         InputDeviceClass::TOUCH_MT, AINPUT_SOURCE_STYLUS,
-                                         /*configuration=*/nullptr);
+                                         InputDeviceClass::TOUCH_MT, AINPUT_SOURCE_STYLUS);
 
     ASSERT_EQ(ReservedInputDeviceId::INVALID_INPUT_DEVICE_ID, mReader->getLastUsedInputDeviceId());
 
@@ -1276,7 +1259,7 @@ TEST_F(InputReaderTest, VibratorGetVibratorIds) {
                                                        AINPUT_SOURCE_KEYBOARD);
     mReader->pushNextDevice(device);
 
-    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubId, "fake", deviceClass, nullptr));
+    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubId, "fake", deviceClass));
     ASSERT_NO_FATAL_FAILURE(mapper.assertConfigureWasCalled());
 
     ASSERT_EQ(mapper.getVibratorIds().size(), 2U);
@@ -1340,7 +1323,7 @@ TEST_F(InputReaderTest, BatteryGetCapacity) {
             device->addController<FakePeripheralController>(eventHubId);
     mReader->pushNextDevice(device);
 
-    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubId, "fake", deviceClass, nullptr));
+    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubId, "fake", deviceClass));
 
     ASSERT_EQ(controller.getBatteryCapacity(FakeEventHub::DEFAULT_BATTERY),
               FakeEventHub::BATTERY_CAPACITY);
@@ -1358,7 +1341,7 @@ TEST_F(InputReaderTest, BatteryGetStatus) {
             device->addController<FakePeripheralController>(eventHubId);
     mReader->pushNextDevice(device);
 
-    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubId, "fake", deviceClass, nullptr));
+    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubId, "fake", deviceClass));
 
     ASSERT_EQ(controller.getBatteryStatus(FakeEventHub::DEFAULT_BATTERY),
               FakeEventHub::BATTERY_STATUS);
@@ -1375,7 +1358,7 @@ TEST_F(InputReaderTest, BatteryGetDevicePath) {
     device->addController<FakePeripheralController>(eventHubId);
     mReader->pushNextDevice(device);
 
-    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubId, "fake", deviceClass, nullptr));
+    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubId, "fake", deviceClass));
 
     ASSERT_EQ(mReader->getBatteryDevicePath(deviceId), FakeEventHub::BATTERY_DEVPATH);
 }
@@ -1397,7 +1380,7 @@ TEST_F(InputReaderTest, LightGetColor) {
     mFakeEventHub->addRawLightInfo(/*rawId=*/1, std::move(info));
     mFakeEventHub->fakeLightBrightness(/*rawId=*/1, 0x55);
 
-    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubId, "fake", deviceClass, nullptr));
+    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubId, "fake", deviceClass));
 
     ASSERT_TRUE(controller.setLightColor(/*lightId=*/1, LIGHT_BRIGHTNESS));
     ASSERT_EQ(controller.getLightColor(/*lightId=*/1), LIGHT_BRIGHTNESS);
@@ -1406,9 +1389,9 @@ TEST_F(InputReaderTest, LightGetColor) {
 }
 
 TEST_F(InputReaderTest, SetPowerWakeUp) {
-    ASSERT_NO_FATAL_FAILURE(addDevice(1, "1st", InputDeviceClass::KEYBOARD, nullptr));
-    ASSERT_NO_FATAL_FAILURE(addDevice(2, "2nd", InputDeviceClass::KEYBOARD, nullptr));
-    ASSERT_NO_FATAL_FAILURE(addDevice(3, "3rd", InputDeviceClass::KEYBOARD, nullptr));
+    ASSERT_NO_FATAL_FAILURE(addDevice(1, "1st", InputDeviceClass::KEYBOARD));
+    ASSERT_NO_FATAL_FAILURE(addDevice(2, "2nd", InputDeviceClass::KEYBOARD));
+    ASSERT_NO_FATAL_FAILURE(addDevice(3, "3rd", InputDeviceClass::KEYBOARD));
 
     ASSERT_EQ(mFakeEventHub->fakeReadKernelWakeup(1), false);
 
@@ -1424,8 +1407,8 @@ TEST_F(InputReaderTest, MergeableInputDevices) {
 
     // By default, all of the default-created eventhub devices will have the same identifier
     // (implicitly vid 0, pid 0, etc.), which is why we expect them to be merged.
-    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[0], "1st", InputDeviceClass::KEYBOARD, nullptr));
-    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[1], "2nd", InputDeviceClass::JOYSTICK, nullptr));
+    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[0], "1st", InputDeviceClass::KEYBOARD));
+    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[1], "2nd", InputDeviceClass::JOYSTICK));
 
     // The two devices will be merged to one input device as they have same identifier, and none are
     // pointer devices.
@@ -1437,9 +1420,9 @@ TEST_F(InputReaderTest, MergeableDevicesWithTouch) {
 
     // By default, all of the default-created eventhub devices will have the same identifier
     // (implicitly vid 0, pid 0, etc.), which is why we expect them to be merged.
-    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[0], "1st", InputDeviceClass::TOUCH_MT, nullptr));
-    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[1], "2nd", InputDeviceClass::KEYBOARD, nullptr));
-    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[2], "3rd", InputDeviceClass::GAMEPAD, nullptr));
+    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[0], "1st", InputDeviceClass::TOUCH_MT));
+    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[1], "2nd", InputDeviceClass::KEYBOARD));
+    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[2], "3rd", InputDeviceClass::GAMEPAD));
 
     // The three devices will be merged to one input device as they have same identifier, and only
     // one is a pointer device.
@@ -1453,9 +1436,9 @@ TEST_F(InputReaderTest, UnmergeableTouchDevices) {
 
     // By default, all of the default-created eventhub devices will have the same identifier
     // (implicitly vid 0, pid 0, etc.), which is why they can potentially be merged.
-    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[0], "1st", InputDeviceClass::TOUCH, nullptr));
-    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[1], "2nd", InputDeviceClass::TOUCH_MT, nullptr));
-    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[2], "2nd", InputDeviceClass::CURSOR, nullptr));
+    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[0], "1st", InputDeviceClass::TOUCH));
+    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[1], "2nd", InputDeviceClass::TOUCH_MT));
+    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[2], "2nd", InputDeviceClass::CURSOR));
 
     // The three devices will not be merged, as they have same identifier, but are all pointer
     // devices.
@@ -1470,10 +1453,10 @@ TEST_F(InputReaderTest, MergeableMixedDevices) {
 
     // By default, all of the default-created eventhub devices will have the same identifier
     // (implicitly vid 0, pid 0, etc.), which is why they can potentially be merged.
-    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[0], "1st", InputDeviceClass::TOUCH, nullptr));
-    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[1], "2nd", InputDeviceClass::TOUCH_MT, nullptr));
-    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[2], "3rd", InputDeviceClass::DPAD, nullptr));
-    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[3], "4th", InputDeviceClass::JOYSTICK, nullptr));
+    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[0], "1st", InputDeviceClass::TOUCH));
+    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[1], "2nd", InputDeviceClass::TOUCH_MT));
+    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[2], "3rd", InputDeviceClass::DPAD));
+    ASSERT_NO_FATAL_FAILURE(addDevice(eventHubIds[3], "4th", InputDeviceClass::JOYSTICK));
 
     // Non-touch devices can be merged with one of the touch devices, as they have same identifier,
     // but the two touch devices will not combine with each other. It is not specified which touch
@@ -1540,7 +1523,7 @@ protected:
                                                             EVENT_DID_NOT_HAPPEN_TIMEOUT);
 
         mReader = std::make_unique<InputReader>(std::make_shared<EventHub>(), mFakePolicy,
-                                                *mTestListener);
+                                                *mTestListener, /*env=*/nullptr);
         ASSERT_EQ(mReader->start(), OK);
 
         // Since this test is run on a real device, all the input devices connected
diff --git a/services/inputflinger/tests/InputTracingTest.cpp b/services/inputflinger/tests/InputTracingTest.cpp
index 3cc4bdd79e..a6933a2997 100644
--- a/services/inputflinger/tests/InputTracingTest.cpp
+++ b/services/inputflinger/tests/InputTracingTest.cpp
@@ -104,10 +104,12 @@ protected:
         impl::PerfettoBackend::sPackageManagerProvider = []() { return kPackageManager; };
         mFakePolicy = std::make_unique<FakeInputDispatcherPolicy>();
 
-        auto tracingBackend = std::make_unique<impl::ThreadedBackend<impl::PerfettoBackend>>(
-                impl::PerfettoBackend());
+        auto tracingBackend = std::make_unique<
+                impl::ThreadedBackend<impl::PerfettoBackend>>(impl::PerfettoBackend(),
+                                                              /*env=*/nullptr);
         mRequestTracerIdle = tracingBackend->getIdleWaiterForTesting();
-        mDispatcher = std::make_unique<InputDispatcher>(*mFakePolicy, std::move(tracingBackend));
+        mDispatcher = std::make_unique<InputDispatcher>(*mFakePolicy, std::move(tracingBackend),
+                                                        /*env=*/nullptr);
 
         mDispatcher->setInputDispatchMode(/*enabled=*/true, /*frozen=*/false);
         ASSERT_EQ(OK, mDispatcher->start());
diff --git a/services/inputflinger/tests/InstrumentedInputReader.cpp b/services/inputflinger/tests/InstrumentedInputReader.cpp
index 53fc8a1f58..cbf4e4df4a 100644
--- a/services/inputflinger/tests/InstrumentedInputReader.cpp
+++ b/services/inputflinger/tests/InstrumentedInputReader.cpp
@@ -21,7 +21,7 @@ namespace android {
 InstrumentedInputReader::InstrumentedInputReader(std::shared_ptr<EventHubInterface> eventHub,
                                                  const sp<InputReaderPolicyInterface>& policy,
                                                  InputListenerInterface& listener)
-      : InputReader(eventHub, policy, listener), mFakeContext(this) {}
+      : InputReader(eventHub, policy, listener, /*env=*/nullptr), mFakeContext(this) {}
 
 void InstrumentedInputReader::pushNextDevice(std::shared_ptr<InputDevice> device) {
     mNextDevices.push(device);
diff --git a/services/inputflinger/tests/NotifyArgs_test.cpp b/services/inputflinger/tests/NotifyArgs_test.cpp
index 2e5ecc3350..4e932f0275 100644
--- a/services/inputflinger/tests/NotifyArgs_test.cpp
+++ b/services/inputflinger/tests/NotifyArgs_test.cpp
@@ -72,8 +72,8 @@ TEST(NotifyMotionArgsTest, TestCopyAssignmentOperator) {
     std::vector<TouchVideoFrame> videoFrames = {frame};
     const NotifyMotionArgs args(id, eventTime, readTime, deviceId, source, displayId, policyFlags,
                                 action, actionButton, flags, metaState, buttonState, classification,
-                                edgeFlags, pointerCount, pointerProperties, pointerCoords,
-                                xPrecision, yPrecision, xCursorPosition, yCursorPosition, downTime,
+                                pointerCount, pointerProperties, pointerCoords, xPrecision,
+                                yPrecision, xCursorPosition, yCursorPosition, downTime,
                                 videoFrames);
 
     NotifyMotionArgs otherArgs{};
diff --git a/services/inputflinger/tests/PointerChoreographer_test.cpp b/services/inputflinger/tests/PointerChoreographer_test.cpp
index 2b469c5645..a16793351c 100644
--- a/services/inputflinger/tests/PointerChoreographer_test.cpp
+++ b/services/inputflinger/tests/PointerChoreographer_test.cpp
@@ -150,9 +150,14 @@ protected:
             // setDefaultMouseDisplayId without topology.
             // For this reason in tests we mock this behavior by creating topology with a single
             // display.
-            mChoreographer.setDisplayTopology({.primaryDisplayId = displayId,
-                                               .graph{{displayId, {}}},
-                                               .displaysDensity = {{displayId, DENSITY_MEDIUM}}});
+            mChoreographer.setDisplayTopology(
+                    DisplayTopologyGraph::create(/*primaryDisplayId=*/displayId,
+                                                 /*topologyGraph=*/
+                                                 {{displayId,
+                                                   {{},
+                                                    DENSITY_MEDIUM,
+                                                    FloatRect(0, 0, 500, 500)}}})
+                            .value());
         } else {
             mChoreographer.setDefaultMouseDisplayId(displayId);
         }
@@ -2769,6 +2774,8 @@ public:
     static constexpr ui::LogicalDisplayId DISPLAY_LEFT_ID = ui::LogicalDisplayId{50};
     static constexpr ui::LogicalDisplayId DISPLAY_TOP_RIGHT_CORNER_ID = ui::LogicalDisplayId{60};
     static constexpr ui::LogicalDisplayId DISPLAY_HIGH_DENSITY_ID = ui::LogicalDisplayId{70};
+    // We can use same fake display-bounds for all displays as bounds positions are not checked.
+    static constexpr FloatRect FAKE_BOUNDS = FloatRect(0, 0, 100, 100);
 
 protected:
     // Note: viewport size is in pixels and offsets in topology are in dp
@@ -2784,24 +2791,48 @@ protected:
             createViewport(DISPLAY_HIGH_DENSITY_ID, /*width*/ 200, /*height*/ 200, ui::ROTATION_0),
     };
 
-    DisplayTopologyGraph
-            mTopology{DISPLAY_CENTER_ID,
-                      {{DISPLAY_CENTER_ID,
-                        {{DISPLAY_TOP_ID, DisplayTopologyPosition::TOP, 50.0f},
-                         // Place a high density display on the left of DISPLAY_TOP_ID with 25 dp
-                         // gap
-                         {DISPLAY_HIGH_DENSITY_ID, DisplayTopologyPosition::TOP, -75.0f},
-                         {DISPLAY_RIGHT_ID, DisplayTopologyPosition::RIGHT, 10.0f},
-                         {DISPLAY_BOTTOM_ID, DisplayTopologyPosition::BOTTOM, 10.0f},
-                         {DISPLAY_LEFT_ID, DisplayTopologyPosition::LEFT, 10.0f},
-                         {DISPLAY_TOP_RIGHT_CORNER_ID, DisplayTopologyPosition::RIGHT, -90.0f}}}},
-                      {{DISPLAY_CENTER_ID, DENSITY_MEDIUM},
-                       {DISPLAY_TOP_ID, DENSITY_MEDIUM},
-                       {DISPLAY_RIGHT_ID, DENSITY_MEDIUM},
-                       {DISPLAY_BOTTOM_ID, DENSITY_MEDIUM},
-                       {DISPLAY_LEFT_ID, DENSITY_MEDIUM},
-                       {DISPLAY_TOP_RIGHT_CORNER_ID, DENSITY_MEDIUM},
-                       {DISPLAY_HIGH_DENSITY_ID, DENSITY_HIGH}}};
+    DisplayTopologyGraph mTopology =
+            DisplayTopologyGraph::
+                    create(/*primaryDisplay=*/DISPLAY_CENTER_ID,
+                           /*adjacencyGraph=*/
+                           {{DISPLAY_CENTER_ID,
+                             {{{DISPLAY_TOP_ID, DisplayTopologyPosition::TOP, 50.0f},
+                               // Place a high density display on the left of DISPLAY_TOP_ID with
+                               // 25 dp gap
+                               {DISPLAY_HIGH_DENSITY_ID, DisplayTopologyPosition::TOP, -75.0f},
+                               {DISPLAY_RIGHT_ID, DisplayTopologyPosition::RIGHT, 10.0f},
+                               {DISPLAY_BOTTOM_ID, DisplayTopologyPosition::BOTTOM, 10.0f},
+                               {DISPLAY_LEFT_ID, DisplayTopologyPosition::LEFT, 10.0f},
+                               {DISPLAY_TOP_RIGHT_CORNER_ID, DisplayTopologyPosition::RIGHT,
+                                -90.0f}},
+                              DENSITY_MEDIUM,
+                              FAKE_BOUNDS}},
+                            // Reverse edges
+                            {DISPLAY_TOP_ID,
+                             {{{DISPLAY_CENTER_ID, DisplayTopologyPosition::BOTTOM, -50.0f}},
+                              DENSITY_MEDIUM,
+                              FAKE_BOUNDS}},
+                            {DISPLAY_HIGH_DENSITY_ID,
+                             {{{DISPLAY_CENTER_ID, DisplayTopologyPosition::BOTTOM, 75.0f}},
+                              DENSITY_HIGH,
+                              FAKE_BOUNDS}},
+                            {DISPLAY_RIGHT_ID,
+                             {{{DISPLAY_CENTER_ID, DisplayTopologyPosition::LEFT, -10.0f}},
+                              DENSITY_MEDIUM,
+                              FAKE_BOUNDS}},
+                            {DISPLAY_BOTTOM_ID,
+                             {{{DISPLAY_CENTER_ID, DisplayTopologyPosition::TOP, -10.0f}},
+                              DENSITY_MEDIUM,
+                              FAKE_BOUNDS}},
+                            {DISPLAY_LEFT_ID,
+                             {{{DISPLAY_CENTER_ID, DisplayTopologyPosition::RIGHT, -10.0f}},
+                              DENSITY_MEDIUM,
+                              FAKE_BOUNDS}},
+                            {DISPLAY_TOP_RIGHT_CORNER_ID,
+                             {{{DISPLAY_CENTER_ID, DisplayTopologyPosition::LEFT, 90.0f}},
+                              DENSITY_MEDIUM,
+                              FAKE_BOUNDS}}})
+                            .value();
 };
 
 TEST_P(PointerChoreographerDisplayTopologyCursorTestFixture,
@@ -2940,10 +2971,12 @@ protected:
     static constexpr ui::LogicalDisplayId FIRST_DISPLAY_ID = ui::LogicalDisplayId{10};
     static constexpr ui::LogicalDisplayId SECOND_DISPLAY_ID = ui::LogicalDisplayId{20};
     static constexpr ui::LogicalDisplayId THIRD_DISPLAY_ID = ui::LogicalDisplayId{30};
+    static constexpr int32_t DISPLAY_WIDTH = 100;
+    static constexpr int32_t DISPLAY_HEIGHT = 100;
 
     DisplayViewport createViewport(ui::LogicalDisplayId displayId) {
-        return PointerChoreographerDisplayTopologyTests::createViewport(displayId, /*width=*/100,
-                                                                        /*height=*/100,
+        return PointerChoreographerDisplayTopologyTests::createViewport(displayId, DISPLAY_WIDTH,
+                                                                        DISPLAY_HEIGHT,
                                                                         ui::ROTATION_0);
     }
 
@@ -2953,25 +2986,42 @@ protected:
         // Prepare a topology with all display connected from left to right.
         ui::LogicalDisplayId previousDisplay = primaryDisplayId;
 
-        std::unordered_map<ui::LogicalDisplayId, std::vector<DisplayTopologyAdjacentDisplay>>
-                topologyGraph;
-        topologyGraph[primaryDisplayId] = {};
-
-        std::unordered_map<ui::LogicalDisplayId, int> displaysDensity;
-        displaysDensity[primaryDisplayId] = DENSITY_MEDIUM;
+        std::unordered_map<ui::LogicalDisplayId, DisplayTopologyGraph::Properties> topologyGraph;
+        topologyGraph.emplace(primaryDisplayId,
+                              DisplayTopologyGraph::Properties{{},
+                                                               DENSITY_MEDIUM,
+                                                               FloatRect(0, 0, DISPLAY_WIDTH,
+                                                                         DISPLAY_HEIGHT)});
 
         for (ui::LogicalDisplayId adjacentDisplayId : adjacentDisplays) {
-            topologyGraph[previousDisplay].push_back({.displayId = adjacentDisplayId,
-                                                      .position = DisplayTopologyPosition::RIGHT,
-                                                      .offsetDp = 0.0f});
-            topologyGraph[adjacentDisplayId].push_back({.displayId = previousDisplay,
-                                                        .position = DisplayTopologyPosition::LEFT,
-                                                        .offsetDp = 0.0f});
-
-            displaysDensity[adjacentDisplayId] = DENSITY_MEDIUM;
+            auto& previousDisplayIt = topologyGraph.at(previousDisplay);
+            previousDisplayIt.adjacentDisplays.push_back(
+                    {.displayId = adjacentDisplayId,
+                     .position = DisplayTopologyPosition::RIGHT,
+                     .offsetDp = 0.0f});
+
+            const auto& previousDisplayBounds = previousDisplayIt.boundsInGlobalDp;
+            topologyGraph
+                    .emplace(adjacentDisplayId,
+                             DisplayTopologyGraph::Properties{{},
+                                                              DENSITY_MEDIUM,
+                                                              FloatRect(previousDisplayBounds.right,
+                                                                        0,
+                                                                        previousDisplayBounds
+                                                                                        .right +
+                                                                                DISPLAY_WIDTH,
+                                                                        DISPLAY_HEIGHT)});
+
+            topologyGraph[adjacentDisplayId].adjacentDisplays.push_back(
+                    {.displayId = previousDisplay,
+                     .position = DisplayTopologyPosition::LEFT,
+                     .offsetDp = 0.0f});
+
+            previousDisplay = adjacentDisplayId;
         }
 
-        mChoreographer.setDisplayTopology({primaryDisplayId, topologyGraph, displaysDensity});
+        mChoreographer.setDisplayTopology(
+                DisplayTopologyGraph::create(primaryDisplayId, std::move(topologyGraph)).value());
     }
 };
 
@@ -3028,7 +3078,7 @@ TEST_F(PointerChoreographerDisplayTopologyDefaultMouseDisplayTests,
 
     // Change the primary display to the third display
     setDisplayTopologyWithDisplays(/*primaryDisplayId=*/THIRD_DISPLAY_ID, /*adjacentDisplays=*/
-                                   {SECOND_DISPLAY_ID, THIRD_DISPLAY_ID});
+                                   {SECOND_DISPLAY_ID, FIRST_DISPLAY_ID});
 
     assertPointerControllerNotCreated();
     pc->assertViewportSet(SECOND_DISPLAY_ID);
@@ -3161,6 +3211,51 @@ TEST_F(PointerChoreographerDisplayTopologyDefaultMouseDisplayTests,
     ASSERT_TRUE(pc->isPointerShown());
 }
 
+TEST_F(PointerChoreographerDisplayTopologyDefaultMouseDisplayTests,
+       GetCursorPositionReturnValidPositionForDisplayWithCursor) {
+    SCOPED_FLAG_OVERRIDE(connected_displays_cursor, true);
+    SCOPED_FLAG_OVERRIDE(connected_displays_associated_display_cursor_bugfix, true);
+
+    // Add two displays
+    mChoreographer.setDisplayViewports(
+            {createViewport(FIRST_DISPLAY_ID), createViewport(SECOND_DISPLAY_ID)});
+    setDisplayTopologyWithDisplays(/*primaryDisplayId=*/FIRST_DISPLAY_ID,
+                                   /*adjacentDisplays=*/{SECOND_DISPLAY_ID});
+
+    mChoreographer.notifyInputDevicesChanged(
+            {/*id=*/0, {generateTestDeviceInfo(DEVICE_ID, AINPUT_SOURCE_MOUSE, FIRST_DISPLAY_ID)}});
+
+    auto pc = assertPointerControllerCreated(ControllerType::MOUSE);
+    pc->assertViewportSet(FIRST_DISPLAY_ID);
+
+    auto firstDisplayCursor = mChoreographer.getMouseCursorPosition(FIRST_DISPLAY_ID);
+    // Valid
+    ASSERT_TRUE(firstDisplayCursor.has_value());
+
+    // Invalid, cursor is currently on first display
+    auto secondDisplayCursor = mChoreographer.getMouseCursorPosition(SECOND_DISPLAY_ID);
+    ASSERT_FALSE(secondDisplayCursor.has_value());
+
+    // Move cursor to the secondary display
+    auto pointerBuilder = PointerBuilder(/*id=*/0, ToolType::MOUSE)
+                                  .axis(AMOTION_EVENT_AXIS_RELATIVE_X, /*x=*/100)
+                                  .axis(AMOTION_EVENT_AXIS_RELATIVE_Y, /*y=*/0);
+    mChoreographer.notifyMotion(
+            MotionArgsBuilder(AMOTION_EVENT_ACTION_HOVER_MOVE, AINPUT_SOURCE_MOUSE)
+                    .pointer(pointerBuilder)
+                    .deviceId(DEVICE_ID)
+                    .displayId(ui::LogicalDisplayId::INVALID)
+                    .build());
+    pc->assertViewportSet(SECOND_DISPLAY_ID);
+    firstDisplayCursor = mChoreographer.getMouseCursorPosition(FIRST_DISPLAY_ID);
+    // Invalid, cursor is currently on second display
+    ASSERT_FALSE(firstDisplayCursor.has_value());
+
+    // Valid
+    secondDisplayCursor = mChoreographer.getMouseCursorPosition(SECOND_DISPLAY_ID);
+    ASSERT_TRUE(secondDisplayCursor.has_value());
+}
+
 class PointerChoreographerWindowInfoListenerTest : public testing::Test {};
 
 TEST_F(PointerChoreographerWindowInfoListenerTest,
diff --git a/services/inputflinger/tests/PreferStylusOverTouch_test.cpp b/services/inputflinger/tests/PreferStylusOverTouch_test.cpp
index a36d526913..80fe922560 100644
--- a/services/inputflinger/tests/PreferStylusOverTouch_test.cpp
+++ b/services/inputflinger/tests/PreferStylusOverTouch_test.cpp
@@ -67,9 +67,8 @@ static NotifyMotionArgs generateMotionArgs(nsecs_t downTime, nsecs_t eventTime,
                           ui::LogicalDisplayId::DEFAULT, POLICY_FLAG_PASS_TO_USER, action,
                           /* actionButton */ 0,
                           /*flags=*/0, AMETA_NONE, /*buttonState=*/0, MotionClassification::NONE,
-                          AMOTION_EVENT_EDGE_FLAG_NONE, pointerCount, pointerProperties,
-                          pointerCoords, /*xPrecision=*/0, /*yPrecision=*/0,
-                          AMOTION_EVENT_INVALID_CURSOR_POSITION,
+                          pointerCount, pointerProperties, pointerCoords, /*xPrecision=*/0,
+                          /*yPrecision=*/0, AMOTION_EVENT_INVALID_CURSOR_POSITION,
                           AMOTION_EVENT_INVALID_CURSOR_POSITION, downTime, /*videoFrames=*/{});
 
     return args;
diff --git a/services/inputflinger/tests/TestEventMatchers.h b/services/inputflinger/tests/TestEventMatchers.h
index 1262af7bf9..2236379c7a 100644
--- a/services/inputflinger/tests/TestEventMatchers.h
+++ b/services/inputflinger/tests/TestEventMatchers.h
@@ -22,6 +22,7 @@
 
 #include <android-base/stringprintf.h>
 #include <android/input.h>
+#include <ftl/flags.h>
 #include <gmock/gmock.h>
 #include <gtest/gtest.h>
 #include <input/Input.h>
@@ -143,7 +144,7 @@ public:
             return false;
         }
         if (event.getAction() == AMOTION_EVENT_ACTION_CANCEL &&
-            (event.getFlags() & AMOTION_EVENT_FLAG_CANCELED) == 0) {
+            !event.getFlags().test(MotionFlag::CANCELED)) {
             *listener << "event with CANCEL action is missing FLAG_CANCELED";
             return false;
         }
@@ -232,23 +233,15 @@ inline WithDeviceIdMatcher WithDeviceId(int32_t deviceId) {
 }
 
 /// Flags
-class WithFlagsMatcher {
+class WithKeyFlagsMatcher {
 public:
     using is_gtest_matcher = void;
-    explicit WithFlagsMatcher(int32_t flags) : mFlags(flags) {}
-
-    bool MatchAndExplain(const NotifyMotionArgs& args, std::ostream*) const {
-        return mFlags == args.flags;
-    }
+    explicit WithKeyFlagsMatcher(int32_t flags) : mFlags(flags) {}
 
     bool MatchAndExplain(const NotifyKeyArgs& args, std::ostream*) const {
         return mFlags == args.flags;
     }
 
-    bool MatchAndExplain(const MotionEvent& event, std::ostream*) const {
-        return mFlags == event.getFlags();
-    }
-
     bool MatchAndExplain(const KeyEvent& event, std::ostream*) const {
         return mFlags == event.getFlags();
     }
@@ -263,8 +256,33 @@ private:
     const int32_t mFlags;
 };
 
-inline WithFlagsMatcher WithFlags(int32_t flags) {
-    return WithFlagsMatcher(flags);
+class WithMotionFlagsMatcher {
+public:
+    using is_gtest_matcher = void;
+    explicit WithMotionFlagsMatcher(ftl::Flags<MotionFlag> flags) : mFlags(flags) {}
+
+    bool MatchAndExplain(const NotifyMotionArgs& args, std::ostream*) const {
+        return mFlags == ftl::Flags<MotionFlag>(args.flags);
+    }
+
+    bool MatchAndExplain(const MotionEvent& event, std::ostream*) const {
+        return mFlags == event.getFlags();
+    }
+
+    void DescribeTo(std::ostream* os) const { *os << "with flags " << mFlags.string(); }
+
+    void DescribeNegationTo(std::ostream* os) const { *os << "wrong flags"; }
+
+private:
+    const ftl::Flags<MotionFlag> mFlags;
+};
+
+inline WithKeyFlagsMatcher WithFlags(int32_t flags) {
+    return WithKeyFlagsMatcher(flags);
+}
+
+inline WithMotionFlagsMatcher WithFlags(ftl::Flags<MotionFlag> flags) {
+    return WithMotionFlagsMatcher(flags);
 }
 
 /// DownTime
diff --git a/services/inputflinger/tests/UnwantedInteractionBlocker_test.cpp b/services/inputflinger/tests/UnwantedInteractionBlocker_test.cpp
index bbb2fc8d38..f18351921e 100644
--- a/services/inputflinger/tests/UnwantedInteractionBlocker_test.cpp
+++ b/services/inputflinger/tests/UnwantedInteractionBlocker_test.cpp
@@ -91,9 +91,8 @@ static NotifyMotionArgs generateMotionArgs(nsecs_t downTime, nsecs_t eventTime,
                           ui::LogicalDisplayId::DEFAULT, POLICY_FLAG_PASS_TO_USER, action,
                           /*actionButton=*/0,
                           /*flags=*/0, AMETA_NONE, /*buttonState=*/0, MotionClassification::NONE,
-                          AMOTION_EVENT_EDGE_FLAG_NONE, pointerCount, pointerProperties,
-                          pointerCoords, /*xPrecision=*/0, /*yPrecision=*/0,
-                          AMOTION_EVENT_INVALID_CURSOR_POSITION,
+                          pointerCount, pointerProperties, pointerCoords, /*xPrecision=*/0,
+                          /*yPrecision=*/0, AMOTION_EVENT_INVALID_CURSOR_POSITION,
                           AMOTION_EVENT_INVALID_CURSOR_POSITION, downTime, /*videoFrames=*/{});
 
     return args;
@@ -636,7 +635,7 @@ TEST_F(UnwantedInteractionBlockerTest, TouchIsBlockedWhenMixedWithStylus) {
     args4.pointerProperties[1].toolType = ToolType::STYLUS;
     mBlocker->notifyMotion(args4);
     mTestListener.assertNotifyMotionWasCalled(
-            AllOf(WithMotionAction(POINTER_0_UP), WithFlags(FLAG_CANCELED)));
+            AllOf(WithMotionAction(POINTER_0_UP), WithFlags(MotionFlag::CANCELED)));
 
     NotifyMotionArgs args5 =
             generateMotionArgs(/*downTime=*/0, 4 * RESAMPLE_PERIOD, MOVE, {{12, 22, 30}});
diff --git a/services/inputflinger/tests/fuzzers/FuzzedInputStream.h b/services/inputflinger/tests/fuzzers/FuzzedInputStream.h
index 43975f0836..672eaa8df2 100644
--- a/services/inputflinger/tests/fuzzers/FuzzedInputStream.h
+++ b/services/inputflinger/tests/fuzzers/FuzzedInputStream.h
@@ -200,9 +200,9 @@ NotifyMotionArgs generateFuzzedMotionArgs(IdGenerator& idGenerator, FuzzedDataPr
     return NotifyMotionArgs(idGenerator.nextId(), eventTime, readTime, deviceId, source, displayId,
                             POLICY_FLAG_PASS_TO_USER, action, actionButton,
                             getFuzzedFlags(fdp, action), AMETA_NONE, getFuzzedButtonState(fdp),
-                            MotionClassification::NONE, AMOTION_EVENT_EDGE_FLAG_NONE, pointerCount,
-                            pointerProperties.data(), pointerCoords.data(), /*xPrecision=*/0,
-                            /*yPrecision=*/0, cursorX, cursorY, downTime, /*videoFrames=*/{});
+                            MotionClassification::NONE, pointerCount, pointerProperties.data(),
+                            pointerCoords.data(), /*xPrecision=*/0, /*yPrecision=*/0, cursorX,
+                            cursorY, downTime, /*videoFrames=*/{});
 }
 
 } // namespace android
diff --git a/services/inputflinger/tests/fuzzers/InputDispatcherFuzzer.cpp b/services/inputflinger/tests/fuzzers/InputDispatcherFuzzer.cpp
index abce931eff..5c1a781939 100644
--- a/services/inputflinger/tests/fuzzers/InputDispatcherFuzzer.cpp
+++ b/services/inputflinger/tests/fuzzers/InputDispatcherFuzzer.cpp
@@ -143,7 +143,7 @@ extern "C" int LLVMFuzzerTestOneInput(uint8_t* data, size_t size) {
     NotifyStreamProvider streamProvider(fdp);
 
     FakeInputDispatcherPolicy fakePolicy;
-    auto dispatcher = std::make_unique<InputDispatcher>(fakePolicy);
+    auto dispatcher = std::make_unique<InputDispatcher>(fakePolicy, /*env=*/nullptr);
     dispatcher->setInputDispatchMode(/*enabled=*/true, /*frozen=*/false);
     // Start InputDispatcher thread
     dispatcher->start();
diff --git a/services/inputflinger/tests/fuzzers/InputReaderFuzzer.cpp b/services/inputflinger/tests/fuzzers/InputReaderFuzzer.cpp
index 0c8ba50776..c99b3ef1ed 100644
--- a/services/inputflinger/tests/fuzzers/InputReaderFuzzer.cpp
+++ b/services/inputflinger/tests/fuzzers/InputReaderFuzzer.cpp
@@ -48,7 +48,8 @@ public:
     FuzzInputReader(std::shared_ptr<EventHubInterface> fuzzEventHub,
                     const sp<InputReaderPolicyInterface>& fuzzPolicy,
                     InputListenerInterface& fuzzListener) {
-        reader = std::make_unique<InputReader>(fuzzEventHub, fuzzPolicy, fuzzListener);
+        reader = std::make_unique<InputReader>(fuzzEventHub, fuzzPolicy, fuzzListener,
+                                               /*env=*/nullptr);
     }
 
     void dump(std::string& dump) { reader->dump(dump); }
diff --git a/services/memtrackproxy/MemtrackProxy.cpp b/services/memtrackproxy/MemtrackProxy.cpp
index 9e41a9333e..c14b39fba2 100644
--- a/services/memtrackproxy/MemtrackProxy.cpp
+++ b/services/memtrackproxy/MemtrackProxy.cpp
@@ -16,6 +16,8 @@
 
 #include "MemtrackProxy.h"
 
+#include <string.h>
+
 #include <android-base/logging.h>
 #include <android/binder_manager.h>
 #include <private/android_filesystem_config.h>
@@ -28,6 +30,8 @@ namespace android {
 namespace hardware {
 namespace memtrack {
 
+namespace {
+
 // Check Memtrack Flags
 static_assert(static_cast<uint32_t>(V1_0_hidl::MemtrackFlag::SMAPS_ACCOUNTED) ==
               static_cast<uint32_t>(V1_aidl::MemtrackRecord::FLAG_SMAPS_ACCOUNTED));
@@ -60,6 +64,18 @@ static_assert(static_cast<uint32_t>(V1_0_hidl::MemtrackType::MULTIMEDIA) ==
 static_assert(static_cast<uint32_t>(V1_0_hidl::MemtrackType::CAMERA) ==
               static_cast<uint32_t>(V1_aidl::MemtrackType::CAMERA));
 
+// LINT.IfChange
+constexpr char kMemtrackDefaultMsg[] = "memtrack default implementation";
+// LINT.ThenChange(/hardware/interfaces/memtrack/aidl/default/Memtrack.cpp)
+
+static inline bool isMemtrackDefaultImpl(const ndk::ScopedAStatus& status) {
+    return !status.isOk()
+            && status.getExceptionCode() == EX_UNSUPPORTED_OPERATION
+            && strcmp(status.getMessage(), kMemtrackDefaultMsg) == 0;
+}
+
+}  // namespace
+
 __attribute__((warn_unused_result)) bool translate(const V1_0_hidl::MemtrackRecord& in,
                                                    V1_aidl::MemtrackRecord* out) {
     // Convert uint64_t to int64_t (long in AIDL). AIDL doesn't support unsigned types.
@@ -104,6 +120,7 @@ MemtrackProxy::MemtrackProxy() {
     if (!memtrack_aidl_instance_) {
         memtrack_hidl_instance_ = MemtrackProxy::MemtrackHidlInstance();
     }
+    is_get_memory_supported_ = true;
 }
 
 ndk::ScopedAStatus MemtrackProxy::getMemory(int pid, MemtrackType type,
@@ -122,13 +139,28 @@ ndk::ScopedAStatus MemtrackProxy::getMemory(int pid, MemtrackType type,
 
     if (type != MemtrackType::OTHER && type != MemtrackType::GL && type != MemtrackType::GRAPHICS &&
         type != MemtrackType::MULTIMEDIA && type != MemtrackType::CAMERA) {
-        return ndk::ScopedAStatus::fromExceptionCode(EX_UNSUPPORTED_OPERATION);
+        return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);
     }
 
     _aidl_return->clear();
 
     if (memtrack_aidl_instance_) {
-        return memtrack_aidl_instance_->getMemory(pid, type, _aidl_return);
+        if (!is_get_memory_supported_) {
+            return ndk::ScopedAStatus::ok();
+        }
+
+        ndk::ScopedAStatus aidl_status =
+            memtrack_aidl_instance_->getMemory(pid, type, _aidl_return);
+
+        if (isMemtrackDefaultImpl(aidl_status)) {
+            // The default memory track HAL doesn't support the |getMemory| method.
+            // Therefore we prevent making additional binder calls to the HAL once
+            // we know the operation isn't supported.
+            is_get_memory_supported_ = false;
+            return ndk::ScopedAStatus::ok();
+        }
+
+        return aidl_status;
     } else if (memtrack_hidl_instance_) {
         ndk::ScopedAStatus aidl_status;
 
diff --git a/services/memtrackproxy/include/memtrackproxy/MemtrackProxy.h b/services/memtrackproxy/include/memtrackproxy/MemtrackProxy.h
index 5ac1fbf417..2cce8f0439 100644
--- a/services/memtrackproxy/include/memtrackproxy/MemtrackProxy.h
+++ b/services/memtrackproxy/include/memtrackproxy/MemtrackProxy.h
@@ -51,6 +51,7 @@ private:
 
     sp<V1_0_hidl::IMemtrack> memtrack_hidl_instance_;
     std::shared_ptr<V1_aidl::IMemtrack> memtrack_aidl_instance_;
+    bool is_get_memory_supported_;
 };
 
 } // namespace memtrack
diff --git a/services/powermanager/benchmarks/Android.bp b/services/powermanager/benchmarks/Android.bp
index 2b5ddb1460..cc54cc549a 100644
--- a/services/powermanager/benchmarks/Android.bp
+++ b/services/powermanager/benchmarks/Android.bp
@@ -26,9 +26,7 @@ cc_benchmark {
     defaults: ["android.hardware.power-ndk_shared"],
     srcs: [
         "main.cpp",
-        "PowerHalAidlBenchmarks.cpp",
         "PowerHalControllerBenchmarks.cpp",
-        "PowerHalHidlBenchmarks.cpp",
     ],
     shared_libs: [
         "libbase",
diff --git a/services/powermanager/benchmarks/PowerHalAidlBenchmarks.cpp b/services/powermanager/benchmarks/PowerHalAidlBenchmarks.cpp
deleted file mode 100644
index 3a1b426520..0000000000
--- a/services/powermanager/benchmarks/PowerHalAidlBenchmarks.cpp
+++ /dev/null
@@ -1,255 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *            http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "PowerHalAidlBenchmarks"
-
-#include <aidl/android/hardware/power/Boost.h>
-#include <aidl/android/hardware/power/IPower.h>
-#include <aidl/android/hardware/power/IPowerHintSession.h>
-#include <aidl/android/hardware/power/Mode.h>
-#include <aidl/android/hardware/power/WorkDuration.h>
-#include <benchmark/benchmark.h>
-#include <binder/IServiceManager.h>
-#include <binder/Status.h>
-#include <powermanager/PowerHalLoader.h>
-#include <testUtil.h>
-#include <chrono>
-
-using aidl::android::hardware::power::Boost;
-using aidl::android::hardware::power::IPower;
-using aidl::android::hardware::power::IPowerHintSession;
-using aidl::android::hardware::power::Mode;
-using aidl::android::hardware::power::WorkDuration;
-using android::power::PowerHalLoader;
-using std::chrono::microseconds;
-
-using namespace android;
-using namespace std::chrono_literals;
-
-// Values from Boost.aidl and Mode.aidl.
-static constexpr int64_t FIRST_BOOST = static_cast<int64_t>(*ndk::enum_range<Boost>().begin());
-static constexpr int64_t LAST_BOOST = static_cast<int64_t>(*(ndk::enum_range<Boost>().end()-1));
-static constexpr int64_t FIRST_MODE = static_cast<int64_t>(*ndk::enum_range<Mode>().begin());
-static constexpr int64_t LAST_MODE = static_cast<int64_t>(*(ndk::enum_range<Mode>().end()-1));
-
-class DurationWrapper : public WorkDuration {
-public:
-    DurationWrapper(int64_t dur, int64_t time) {
-        durationNanos = dur;
-        timeStampNanos = time;
-    }
-};
-
-static const std::vector<WorkDuration> DURATIONS = {
-        DurationWrapper(1L, 1L),
-        DurationWrapper(1000L, 2L),
-        DurationWrapper(1000000L, 3L),
-        DurationWrapper(1000000000L, 4L),
-};
-
-// Delay between oneway method calls to avoid overflowing the binder buffers.
-static constexpr microseconds ONEWAY_API_DELAY = 100us;
-
-template <class R, class... Args0, class... Args1>
-static void runBenchmark(benchmark::State& state, microseconds delay, R (IPower::*fn)(Args0...),
-                         Args1&&... args1) {
-    std::shared_ptr<IPower> hal = PowerHalLoader::loadAidl();
-
-    if (hal == nullptr) {
-        ALOGV("Power HAL not available, skipping test...");
-        state.SkipWithMessage("Power HAL unavailable");
-        return;
-    }
-
-    ndk::ScopedAStatus ret = (*hal.*fn)(std::forward<Args1>(args1)...);
-    if (ret.getExceptionCode() == binder::Status::EX_UNSUPPORTED_OPERATION) {
-        ALOGV("Power HAL does not support this operation, skipping test...");
-        state.SkipWithMessage("operation unsupported");
-        return;
-    }
-
-    for (auto _ : state) {
-        ret = (*hal.*fn)(std::forward<Args1>(args1)...);
-        if (!ret.isOk()) {
-            state.SkipWithError(ret.getDescription().c_str());
-            break;
-        }
-        if (delay > 0us) {
-            state.PauseTiming();
-            testDelaySpin(std::chrono::duration_cast<std::chrono::duration<float>>(delay).count());
-            state.ResumeTiming();
-        }
-    }
-}
-
-template <class R, class... Args0, class... Args1>
-static void runSessionBenchmark(benchmark::State& state, R (IPowerHintSession::*fn)(Args0...),
-                                Args1&&... args1) {
-    std::shared_ptr<IPower> hal = PowerHalLoader::loadAidl();
-
-    if (hal == nullptr) {
-        ALOGV("Power HAL not available, skipping test...");
-        state.SkipWithMessage("Power HAL unavailable");
-        return;
-    }
-
-    // do not use tid from the benchmark process, use 1 for init
-    std::vector<int32_t> threadIds{1};
-    int64_t durationNanos = 16666666L;
-    std::shared_ptr<IPowerHintSession> session;
-
-    auto status = hal->createHintSession(1, 0, threadIds, durationNanos, &session);
-
-    if (session == nullptr) {
-        ALOGV("Power HAL doesn't support session, skipping test...");
-        state.SkipWithMessage("operation unsupported");
-        return;
-    }
-
-    ndk::ScopedAStatus ret = (*session.*fn)(std::forward<Args1>(args1)...);
-    if (ret.getExceptionCode() == binder::Status::EX_UNSUPPORTED_OPERATION) {
-        ALOGV("Power HAL does not support this operation, skipping test...");
-        state.SkipWithMessage("operation unsupported");
-        return;
-    }
-
-    for (auto _ : state) {
-        ret = (*session.*fn)(std::forward<Args1>(args1)...);
-        if (!ret.isOk()) {
-            state.SkipWithError(ret.getDescription().c_str());
-            break;
-        }
-        state.PauseTiming();
-        testDelaySpin(std::chrono::duration_cast<std::chrono::duration<float>>(ONEWAY_API_DELAY)
-                                .count());
-        state.ResumeTiming();
-    }
-    session->close();
-}
-
-static void BM_PowerHalAidlBenchmarks_isBoostSupported(benchmark::State& state) {
-    bool isSupported;
-    Boost boost = static_cast<Boost>(state.range(0));
-    runBenchmark(state, 0us, &IPower::isBoostSupported, boost, &isSupported);
-}
-
-static void BM_PowerHalAidlBenchmarks_isModeSupported(benchmark::State& state) {
-    bool isSupported;
-    Mode mode = static_cast<Mode>(state.range(0));
-    runBenchmark(state, 0us, &IPower::isModeSupported, mode, &isSupported);
-}
-
-static void BM_PowerHalAidlBenchmarks_setBoost(benchmark::State& state) {
-    Boost boost = static_cast<Boost>(state.range(0));
-    bool isSupported;
-    std::shared_ptr<IPower> hal = PowerHalLoader::loadAidl();
-
-    if (hal == nullptr) {
-        ALOGV("Power HAL not available, skipping test...");
-        state.SkipWithMessage("Power HAL unavailable");
-        return;
-    }
-
-    ndk::ScopedAStatus ret = hal->isBoostSupported(boost, &isSupported);
-    if (!ret.isOk() || !isSupported) {
-        state.SkipWithMessage("operation unsupported");
-        return;
-    }
-
-    runBenchmark(state, ONEWAY_API_DELAY, &IPower::setBoost, boost, 1);
-}
-
-static void BM_PowerHalAidlBenchmarks_setMode(benchmark::State& state) {
-    Mode mode = static_cast<Mode>(state.range(0));
-    bool isSupported;
-    std::shared_ptr<IPower> hal = PowerHalLoader::loadAidl();
-
-    if (hal == nullptr) {
-        ALOGV("Power HAL not available, skipping test...");
-        state.SkipWithMessage("Power HAL unavailable");
-        return;
-    }
-
-    ndk::ScopedAStatus ret = hal->isModeSupported(mode, &isSupported);
-    if (!ret.isOk() || !isSupported) {
-        state.SkipWithMessage("operation unsupported");
-        return;
-    }
-
-    runBenchmark(state, ONEWAY_API_DELAY, &IPower::setMode, mode, false);
-}
-
-static void BM_PowerHalAidlBenchmarks_createHintSession(benchmark::State& state) {
-    std::vector<int32_t> threadIds{static_cast<int32_t>(state.range(0))};
-    int64_t durationNanos = 16666666L;
-    int32_t tgid = 999;
-    int32_t uid = 1001;
-    std::shared_ptr<IPowerHintSession> appSession;
-    std::shared_ptr<IPower> hal = PowerHalLoader::loadAidl();
-
-    if (hal == nullptr) {
-        ALOGV("Power HAL not available, skipping test...");
-        state.SkipWithMessage("Power HAL unavailable");
-        return;
-    }
-
-    ndk::ScopedAStatus ret =
-            hal->createHintSession(tgid, uid, threadIds, durationNanos, &appSession);
-    if (ret.getExceptionCode() == binder::Status::EX_UNSUPPORTED_OPERATION) {
-        ALOGV("Power HAL does not support this operation, skipping test...");
-        state.SkipWithMessage("operation unsupported");
-        return;
-    } else if (!ret.isOk()) {
-        state.SkipWithError(ret.getDescription().c_str());
-        return;
-    } else {
-        appSession->close();
-    }
-
-    for (auto _ : state) {
-        ret = hal->createHintSession(tgid, uid, threadIds, durationNanos, &appSession);
-        if (!ret.isOk()) {
-            state.SkipWithError(ret.getDescription().c_str());
-            break;
-        }
-        state.PauseTiming();
-        appSession->close();
-        state.ResumeTiming();
-    }
-}
-
-static void BM_PowerHalAidlBenchmarks_getHintSessionPreferredRate(benchmark::State& state) {
-    int64_t rate;
-    runBenchmark(state, 0us, &IPower::getHintSessionPreferredRate, &rate);
-}
-
-static void BM_PowerHalAidlBenchmarks_updateTargetWorkDuration(benchmark::State& state) {
-    int64_t duration = 1000;
-    runSessionBenchmark(state, &IPowerHintSession::updateTargetWorkDuration, duration);
-}
-
-static void BM_PowerHalAidlBenchmarks_reportActualWorkDuration(benchmark::State& state) {
-    runSessionBenchmark(state, &IPowerHintSession::reportActualWorkDuration, DURATIONS);
-}
-
-BENCHMARK(BM_PowerHalAidlBenchmarks_isBoostSupported)->DenseRange(FIRST_BOOST, LAST_BOOST, 1);
-BENCHMARK(BM_PowerHalAidlBenchmarks_isModeSupported)->DenseRange(FIRST_MODE, LAST_MODE, 1);
-BENCHMARK(BM_PowerHalAidlBenchmarks_setBoost)->DenseRange(FIRST_BOOST, LAST_BOOST, 1);
-BENCHMARK(BM_PowerHalAidlBenchmarks_setMode)->DenseRange(FIRST_MODE, LAST_MODE, 1);
-BENCHMARK(BM_PowerHalAidlBenchmarks_createHintSession)->Arg(1);
-BENCHMARK(BM_PowerHalAidlBenchmarks_getHintSessionPreferredRate);
-BENCHMARK(BM_PowerHalAidlBenchmarks_updateTargetWorkDuration);
-BENCHMARK(BM_PowerHalAidlBenchmarks_reportActualWorkDuration);
diff --git a/services/powermanager/benchmarks/PowerHalControllerBenchmarks.cpp b/services/powermanager/benchmarks/PowerHalControllerBenchmarks.cpp
index 0fda686231..d2e12aebbe 100644
--- a/services/powermanager/benchmarks/PowerHalControllerBenchmarks.cpp
+++ b/services/powermanager/benchmarks/PowerHalControllerBenchmarks.cpp
@@ -21,12 +21,15 @@
 #include <benchmark/benchmark.h>
 #include <chrono>
 #include <powermanager/PowerHalController.h>
+#include <powermanager/PowerHintSessionWrapper.h>
 #include <testUtil.h>
 
 using aidl::android::hardware::power::Boost;
 using aidl::android::hardware::power::Mode;
+using aidl::android::hardware::power::WorkDuration;
 using android::power::HalResult;
 using android::power::PowerHalController;
+using android::power::PowerHintSessionWrapper;
 
 using namespace android;
 using namespace std::chrono_literals;
@@ -37,6 +40,21 @@ static constexpr int64_t LAST_BOOST = static_cast<int64_t>(*(ndk::enum_range<Boo
 static constexpr int64_t FIRST_MODE = static_cast<int64_t>(*ndk::enum_range<Mode>().begin());
 static constexpr int64_t LAST_MODE = static_cast<int64_t>(*(ndk::enum_range<Mode>().end()-1));
 
+class DurationWrapper : public WorkDuration {
+public:
+    DurationWrapper(int64_t dur, int64_t time) {
+        durationNanos = dur;
+        timeStampNanos = time;
+    }
+};
+
+static const std::vector<WorkDuration> DURATIONS = {
+        DurationWrapper(1L, 1L),
+        DurationWrapper(1000L, 2L),
+        DurationWrapper(1000000L, 3L),
+        DurationWrapper(1000000000L, 4L),
+};
+
 // Delay between oneway method calls to avoid overflowing the binder buffers.
 static constexpr std::chrono::microseconds ONEWAY_API_DELAY = 100us;
 
@@ -92,6 +110,50 @@ static void runCachedBenchmark(benchmark::State& state,
     }
 }
 
+template <class T, class... Args0, class... Args1>
+static void runSessionBenchmark(benchmark::State& state,
+                                HalResult<T> (PowerHintSessionWrapper::*fn)(Args0...),
+                                Args1&&... args1) {
+    PowerHalController controller;
+
+    // do not use tid from the benchmark process, use 1 for init
+    std::vector<int32_t> threadIds{1};
+    int64_t durationNanos = 16666666L;
+
+    HalResult<std::shared_ptr<PowerHintSessionWrapper>> result =
+        controller.createHintSession(1, 0, threadIds, durationNanos);
+
+    if (result.isFailed()) {
+        state.SkipWithError(result.errorMessage());
+        return;
+    } else if (result.isUnsupported()) {
+        ALOGV("Power HAL doesn't support session, skipping test...");
+        state.SkipWithMessage("operation unsupported");
+        return;
+    }
+
+    std::shared_ptr<PowerHintSessionWrapper> session = result.value();
+    HalResult<T> ret = (*session.*fn)(std::forward<Args1>(args1)...);
+    if (ret.isUnsupported()) {
+        ALOGV("Power HAL session does not support this operation, skipping test...");
+        state.SkipWithMessage("operation unsupported");
+        return;
+    }
+
+    for (auto _ : state) {
+        ret = (*session.*fn)(std::forward<Args1>(args1)...);
+        if (!ret.isOk()) {
+            state.SkipWithError(ret.errorMessage());
+            break;
+        }
+        state.PauseTiming();
+        testDelaySpin(
+                std::chrono::duration_cast<std::chrono::duration<float>>(ONEWAY_API_DELAY).count());
+        state.ResumeTiming();
+    }
+    session->close();
+}
+
 static void BM_PowerHalControllerBenchmarks_init(benchmark::State& state) {
     for (auto _ : state) {
         PowerHalController controller;
@@ -129,9 +191,53 @@ static void BM_PowerHalControllerBenchmarks_setModeCached(benchmark::State& stat
     runCachedBenchmark(state, &PowerHalController::setMode, mode, false);
 }
 
+static void BM_PowerHalControllerBenchmarks_createHintSession(benchmark::State& state) {
+    std::vector<int32_t> threadIds{static_cast<int32_t>(state.range(0))};
+    int64_t durationNanos = 16666666L;
+    int32_t tgid = 999;
+    int32_t uid = 1001;
+    PowerHalController controller;
+
+    HalResult<std::shared_ptr<PowerHintSessionWrapper>> result =
+        controller.createHintSession(tgid, uid, threadIds, durationNanos);
+    if (result.isFailed()) {
+        state.SkipWithError(result.errorMessage());
+        return;
+    } else if (result.isUnsupported()) {
+        ALOGV("Power HAL doesn't support session, skipping test...");
+        state.SkipWithMessage("operation unsupported");
+        return;
+    } else {
+        result.value()->close();
+    }
+
+    for (auto _ : state) {
+        result = controller.createHintSession(tgid, uid, threadIds, durationNanos);
+        if (!result.isOk()) {
+            state.SkipWithError(result.errorMessage());
+            break;
+        }
+        state.PauseTiming();
+        result.value()->close();
+        state.ResumeTiming();
+    }
+}
+
+static void BM_PowerHalControllerBenchmarks_updateTargetWorkDuration(benchmark::State& state) {
+    int64_t duration = 1000;
+    runSessionBenchmark(state, &PowerHintSessionWrapper::updateTargetWorkDuration, duration);
+}
+
+static void BM_PowerHalControllerBenchmarks_reportActualWorkDuration(benchmark::State& state) {
+    runSessionBenchmark(state, &PowerHintSessionWrapper::reportActualWorkDuration, DURATIONS);
+}
+
 BENCHMARK(BM_PowerHalControllerBenchmarks_init);
 BENCHMARK(BM_PowerHalControllerBenchmarks_initCached);
 BENCHMARK(BM_PowerHalControllerBenchmarks_setBoost)->DenseRange(FIRST_BOOST, LAST_BOOST, 1);
 BENCHMARK(BM_PowerHalControllerBenchmarks_setBoostCached)->DenseRange(FIRST_BOOST, LAST_BOOST, 1);
 BENCHMARK(BM_PowerHalControllerBenchmarks_setMode)->DenseRange(FIRST_MODE, LAST_MODE, 1);
 BENCHMARK(BM_PowerHalControllerBenchmarks_setModeCached)->DenseRange(FIRST_MODE, LAST_MODE, 1);
+BENCHMARK(BM_PowerHalControllerBenchmarks_createHintSession)->Arg(1);
+BENCHMARK(BM_PowerHalControllerBenchmarks_updateTargetWorkDuration);
+BENCHMARK(BM_PowerHalControllerBenchmarks_reportActualWorkDuration);
diff --git a/services/powermanager/benchmarks/PowerHalHidlBenchmarks.cpp b/services/powermanager/benchmarks/PowerHalHidlBenchmarks.cpp
deleted file mode 100644
index 95fd0c2a4d..0000000000
--- a/services/powermanager/benchmarks/PowerHalHidlBenchmarks.cpp
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *            http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "PowerHalHidlBenchmarks"
-
-#include <aidl/android/hardware/power/Boost.h>
-#include <aidl/android/hardware/power/IPower.h>
-#include <aidl/android/hardware/power/Mode.h>
-#include <android/hardware/power/1.1/IPower.h>
-#include <benchmark/benchmark.h>
-#include <hardware/power.h>
-#include <hardware_legacy/power.h>
-#include <testUtil.h>
-#include <chrono>
-
-using android::hardware::Return;
-using android::hardware::power::V1_0::Feature;
-using android::hardware::power::V1_0::PowerHint;
-using std::chrono::microseconds;
-using IPower1_0 = android::hardware::power::V1_0::IPower;
-using IPower1_1 = android::hardware::power::V1_1::IPower;
-
-using namespace android;
-using namespace std::chrono_literals;
-
-// Values from types.hal from versions 1.0 to 1.3.
-static constexpr int64_t FIRST_POWER_HINT = static_cast<int64_t>(PowerHint::VSYNC);
-static constexpr int64_t LAST_POWER_HINT = static_cast<int64_t>(PowerHint::LAUNCH);
-
-// Delay between oneway method calls to avoid overflowing the binder buffers.
-static constexpr microseconds ONEWAY_API_DELAY = 100us;
-
-template <class R, class I, class... Args0, class... Args1>
-static void runBenchmark(benchmark::State& state, microseconds delay, Return<R> (I::*fn)(Args0...),
-                         Args1&&... args1) {
-    sp<I> hal = I::getService();
-
-    if (hal == nullptr) {
-        ALOGV("Power HAL HIDL not available, skipping test...");
-        state.SkipWithMessage("Power HAL unavailable");
-        return;
-    }
-
-    for (auto _ : state) {
-        Return<R> ret = (*hal.*fn)(std::forward<Args1>(args1)...);
-        if (!ret.isOk()) {
-            state.SkipWithError(ret.description().c_str());
-            break;
-        }
-        if (delay > 0us) {
-            state.PauseTiming();
-            testDelaySpin(std::chrono::duration_cast<std::chrono::duration<float>>(delay).count());
-            state.ResumeTiming();
-        }
-    }
-}
-
-static void BM_PowerHalHidlBenchmarks_setFeature(benchmark::State& state) {
-    runBenchmark(state, 0us, &IPower1_0::setFeature, Feature::POWER_FEATURE_DOUBLE_TAP_TO_WAKE,
-                 false);
-}
-
-static void BM_PowerHalHidlBenchmarks_setInteractive(benchmark::State& state) {
-    runBenchmark(state, 0us, &IPower1_0::setInteractive, false);
-}
-
-static void BM_PowerHalHidlBenchmarks_powerHint(benchmark::State& state) {
-    PowerHint powerHint = static_cast<PowerHint>(state.range(0));
-    runBenchmark(state, 0us, &IPower1_0::powerHint, powerHint, 0);
-}
-
-static void BM_PowerHalHidlBenchmarks_powerHintAsync(benchmark::State& state) {
-    PowerHint powerHint = static_cast<PowerHint>(state.range(0));
-    runBenchmark(state, ONEWAY_API_DELAY, &IPower1_1::powerHintAsync, powerHint, 0);
-}
-
-BENCHMARK(BM_PowerHalHidlBenchmarks_setFeature);
-BENCHMARK(BM_PowerHalHidlBenchmarks_setInteractive);
-BENCHMARK(BM_PowerHalHidlBenchmarks_powerHint)->DenseRange(FIRST_POWER_HINT, LAST_POWER_HINT, 1);
-BENCHMARK(BM_PowerHalHidlBenchmarks_powerHintAsync)
-        ->DenseRange(FIRST_POWER_HINT, LAST_POWER_HINT, 1);
diff --git a/services/schedulerservice/Android.bp b/services/schedulerservice/Android.bp
deleted file mode 100644
index 4ef72d0c83..0000000000
--- a/services/schedulerservice/Android.bp
+++ /dev/null
@@ -1,32 +0,0 @@
-package {
-    // See: http://go/android-license-faq
-    // A large-scale-change added 'default_applicable_licenses' to import
-    // all of the 'license_kinds' from "frameworks_native_license"
-    // to get the below license kinds:
-    //   SPDX-license-identifier-Apache-2.0
-    default_applicable_licenses: ["frameworks_native_license"],
-}
-
-cc_library_shared {
-    name: "libschedulerservicehidl",
-    srcs: [
-        "SchedulingPolicyService.cpp",
-    ],
-    cflags: ["-Wall", "-Werror"],
-    shared_libs: [
-        "libhidlbase",
-        "libmediautils",
-        "liblog",
-        "libutils",
-        "android.frameworks.schedulerservice@1.0",
-    ],
-    header_libs: [
-        "libcutils_headers",
-    ],
-    export_include_dirs: [
-        "include/"
-    ],
-    local_include_dirs: [
-        "include/schedulerservice/",
-    ],
-}
diff --git a/services/schedulerservice/SchedulingPolicyService.cpp b/services/schedulerservice/SchedulingPolicyService.cpp
deleted file mode 100644
index a1106cf49b..0000000000
--- a/services/schedulerservice/SchedulingPolicyService.cpp
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#define LOG_TAG "schedulerservicehidl"
-
-#include "SchedulingPolicyService.h"
-
-#include <private/android_filesystem_config.h> // for AID_CAMERASERVER
-
-#include <log/log.h>
-#include <hwbinder/IPCThreadState.h>
-#include <mediautils/SchedulingPolicyService.h>
-
-namespace android {
-namespace frameworks {
-namespace schedulerservice {
-namespace V1_0 {
-namespace implementation {
-
-bool SchedulingPolicyService::isAllowed() {
-    using ::android::hardware::IPCThreadState;
-
-    return IPCThreadState::self()->getCallingUid() == AID_CAMERASERVER;
-}
-
-Return<bool> SchedulingPolicyService::requestPriority(int32_t pid, int32_t tid, int32_t priority) {
-    if (priority < static_cast<int32_t>(Priority::MIN) ||
-            priority > static_cast<int32_t>(Priority::MAX)) {
-        return false;
-    }
-
-    if (!isAllowed()) {
-        return false;
-    }
-
-    // TODO(b/37226359): decouple from and remove AIDL service
-    // this should always be allowed since we are in system_server.
-    int value = ::android::requestPriority(pid, tid, priority, false /* isForApp */);
-    return value == 0 /* success */;
-}
-
-Return<int32_t> SchedulingPolicyService::getMaxAllowedPriority() {
-    if (!isAllowed()) {
-        return 0;
-    }
-
-    // TODO(b/37226359): decouple from and remove AIDL service
-    return 3;
-}
-
-}  // namespace implementation
-}  // namespace V1_0
-}  // namespace schedulerservice
-}  // namespace frameworks
-}  // namespace android
diff --git a/services/schedulerservice/include/schedulerservice/SchedulingPolicyService.h b/services/schedulerservice/include/schedulerservice/SchedulingPolicyService.h
deleted file mode 100644
index 7d1c478ba7..0000000000
--- a/services/schedulerservice/include/schedulerservice/SchedulingPolicyService.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#pragma once
-
-#include <android/frameworks/schedulerservice/1.0/ISchedulingPolicyService.h>
-#include <hidl/MQDescriptor.h>
-#include <hidl/Status.h>
-
-namespace android {
-namespace frameworks {
-namespace schedulerservice {
-namespace V1_0 {
-namespace implementation {
-
-using ::android::frameworks::schedulerservice::V1_0::ISchedulingPolicyService;
-using ::android::hidl::base::V1_0::DebugInfo;
-using ::android::hidl::base::V1_0::IBase;
-using ::android::hardware::hidl_array;
-using ::android::hardware::hidl_memory;
-using ::android::hardware::hidl_string;
-using ::android::hardware::hidl_vec;
-using ::android::hardware::Return;
-using ::android::hardware::Void;
-using ::android::sp;
-
-struct SchedulingPolicyService : public ISchedulingPolicyService {
-    Return<bool> requestPriority(int32_t pid, int32_t tid, int32_t priority) override;
-    Return<int32_t> getMaxAllowedPriority() override;
-private:
-    bool isAllowed();
-};
-
-}  // namespace implementation
-}  // namespace V1_0
-}  // namespace schedulerservice
-}  // namespace frameworks
-}  // namespace android
diff --git a/services/sensorservice/CorrectedGyroSensor.cpp b/services/sensorservice/CorrectedGyroSensor.cpp
index 005af18b2c..903a836d9b 100644
--- a/services/sensorservice/CorrectedGyroSensor.cpp
+++ b/services/sensorservice/CorrectedGyroSensor.cpp
@@ -55,7 +55,7 @@ CorrectedGyroSensor::CorrectedGyroSensor(sensor_t const* list, size_t count)
 bool CorrectedGyroSensor::process(sensors_event_t* outEvent,
         const sensors_event_t& event)
 {
-    if (event.type == SENSOR_TYPE_GYROSCOPE) {
+    if (event.sensor == mGyro.getHandle()) {
         const vec3_t bias(mSensorFusion.getGyroBias());
         *outEvent = event;
         outEvent->data[0] -= bias.x;
diff --git a/services/sensorservice/GravitySensor.cpp b/services/sensorservice/GravitySensor.cpp
index 9d8add169f..4f79e0433e 100644
--- a/services/sensorservice/GravitySensor.cpp
+++ b/services/sensorservice/GravitySensor.cpp
@@ -54,7 +54,7 @@ GravitySensor::GravitySensor(sensor_t const* list, size_t count) {
 bool GravitySensor::process(sensors_event_t* outEvent,
         const sensors_event_t& event)
 {
-    if (event.type == SENSOR_TYPE_ACCELEROMETER) {
+    if (event.sensor == mAccelerometer.getHandle()) {
         vec3_t g;
         if (!mSensorFusion.hasEstimate(FUSION_NOMAG))
             return false;
diff --git a/services/sensorservice/GravitySensor.h b/services/sensorservice/GravitySensor.h
index 483f468f9a..e0b33f756a 100644
--- a/services/sensorservice/GravitySensor.h
+++ b/services/sensorservice/GravitySensor.h
@@ -39,6 +39,7 @@ public:
     virtual bool process(sensors_event_t* outEvent, const sensors_event_t& event) override;
     virtual status_t activate(void* ident, bool enabled) override;
     virtual status_t setDelay(void* ident, int handle, int64_t ns) override;
+    int32_t getAccelHandle() const { return mAccelerometer.getHandle(); }
 };
 
 // ---------------------------------------------------------------------------
diff --git a/services/sensorservice/LimitedAxesImuSensor.cpp b/services/sensorservice/LimitedAxesImuSensor.cpp
index 2f91479b38..9e01f2ef7d 100644
--- a/services/sensorservice/LimitedAxesImuSensor.cpp
+++ b/services/sensorservice/LimitedAxesImuSensor.cpp
@@ -63,7 +63,7 @@ LimitedAxesImuSensor::LimitedAxesImuSensor(sensor_t const* list, size_t count,
 }
 
 bool LimitedAxesImuSensor::process(sensors_event_t* outEvent, const sensors_event_t& event) {
-    if (event.type == mImu3dSensor.getType()) {
+    if (event.sensor == mImu3dSensor.getHandle()) {
         *outEvent = event;
         size_t imu3dDataSize = SensorServiceUtil::eventSizeBySensorType(mImu3dSensor.getType());
         outEvent->data[0 + imu3dDataSize] = 1;
diff --git a/services/sensorservice/LinearAccelerationSensor.cpp b/services/sensorservice/LinearAccelerationSensor.cpp
index d1cd732499..494c82b8f5 100644
--- a/services/sensorservice/LinearAccelerationSensor.cpp
+++ b/services/sensorservice/LinearAccelerationSensor.cpp
@@ -50,7 +50,7 @@ bool LinearAccelerationSensor::process(sensors_event_t* outEvent,
         const sensors_event_t& event)
 {
     bool result = mGravitySensor.process(outEvent, event);
-    if (result && event.type == SENSOR_TYPE_ACCELEROMETER) {
+    if (result && event.sensor == mGravitySensor.getAccelHandle()) {
         outEvent->data[0] = event.acceleration.x - outEvent->data[0];
         outEvent->data[1] = event.acceleration.y - outEvent->data[1];
         outEvent->data[2] = event.acceleration.z - outEvent->data[2];
diff --git a/services/sensorservice/OrientationSensor.cpp b/services/sensorservice/OrientationSensor.cpp
index ea5dbc9044..13230323ce 100644
--- a/services/sensorservice/OrientationSensor.cpp
+++ b/services/sensorservice/OrientationSensor.cpp
@@ -47,7 +47,7 @@ OrientationSensor::OrientationSensor() {
 bool OrientationSensor::process(sensors_event_t* outEvent,
         const sensors_event_t& event)
 {
-    if (event.type == SENSOR_TYPE_ACCELEROMETER) {
+    if (event.sensor == mSensorFusion.getAccelHandle()) {
         if (mSensorFusion.hasEstimate()) {
             vec3_t g;
             const float rad2deg = 180 / M_PI;
diff --git a/services/sensorservice/SensorDirectConnection.cpp b/services/sensorservice/SensorDirectConnection.cpp
index 33724a93b5..00daa9b156 100644
--- a/services/sensorservice/SensorDirectConnection.cpp
+++ b/services/sensorservice/SensorDirectConnection.cpp
@@ -119,6 +119,11 @@ void SensorService::SensorDirectConnection::onSensorAccessChanged(bool hasAccess
 }
 
 void SensorService::SensorDirectConnection::onMicSensorAccessChanged(bool isMicToggleOn) {
+    // TODO(b/398253250): Create a more robust way to allow VNDK and system clients to be exempted
+    if (mUid == AID_SYSTEM) {
+        return;
+    }
+
     if (isMicToggleOn) {
         capRates();
     } else {
@@ -184,7 +189,9 @@ int32_t SensorService::SensorDirectConnection::configureChannel(int handle, int
     }
 
     int requestedRateLevel = rateLevel;
-    if (mService->isSensorInCappedSet(s.getType()) && rateLevel != SENSOR_DIRECT_RATE_STOP) {
+    // TODO(b/398253250): Create a more robust way to allow VNDK and system clients to be exempted
+    if (mService->isSensorInCappedSet(s.getType()) && rateLevel != SENSOR_DIRECT_RATE_STOP &&
+        mUid != AID_SYSTEM) {
         status_t err = mService->adjustRateLevelBasedOnMicAndPermission(&rateLevel, mOpPackageName);
         if (err != OK) {
             return err;
diff --git a/services/sensorservice/SensorFusion.cpp b/services/sensorservice/SensorFusion.cpp
index 16088ca7ea..a5b75853b0 100644
--- a/services/sensorservice/SensorFusion.cpp
+++ b/services/sensorservice/SensorFusion.cpp
@@ -41,9 +41,12 @@ SensorFusion::SensorFusion()
     mEnabled[FUSION_NOGYRO] = false;
 
     if (count > 0) {
-        for (size_t i=0 ; i<size_t(count) ; i++) {
-            // Only use non-wakeup sensors
-            if ((list[i].flags & SENSOR_FLAG_WAKE_UP) == 0) {
+        std::unordered_set<int> foundNonWakeSensorTypes;
+        for (size_t i = 0; i < size_t(count); i++) {
+            // Only use non-wakeup sensors, and always pick the first one
+            if ((list[i].flags & SENSOR_FLAG_WAKE_UP) == 0 &&
+                !foundNonWakeSensorTypes.contains(list[i].type)) {
+                foundNonWakeSensorTypes.insert(list[i].type);
                 if (list[i].type == SENSOR_TYPE_ACCELEROMETER) {
                     mAcc = Sensor(list + i);
                 }
@@ -78,8 +81,11 @@ SensorFusion::SensorFusion()
 }
 
 void SensorFusion::process(const sensors_event_t& event) {
+    // sensor additional info is not currently used in fusion algorithm
+    if (event.type == SENSOR_TYPE_ADDITIONAL_INFO)
+        return;
 
-    if (event.type == mGyro.getType()) {
+    if (event.sensor == mGyro.getHandle()) {
         float dT;
         if ( event.timestamp - mGyroTime> 0 &&
              event.timestamp - mGyroTime< (int64_t)(5e7) ) { //0.05sec
@@ -101,14 +107,14 @@ void SensorFusion::process(const sensors_event_t& event) {
             }
         }
         mGyroTime = event.timestamp;
-    } else if (event.type == SENSOR_TYPE_MAGNETIC_FIELD) {
+    } else if (event.sensor == mMag.getHandle()) {
         const vec3_t mag(event.data);
         for (int i = 0; i<NUM_FUSION_MODE; ++i) {
             if (mEnabled[i]) {
                 mFusions[i].handleMag(mag);// fusion in no mag mode will ignore
             }
         }
-    } else if (event.type == SENSOR_TYPE_ACCELEROMETER) {
+    } else if (event.sensor == mAcc.getHandle()) {
         float dT;
         if ( event.timestamp - mAccTime> 0 &&
              event.timestamp - mAccTime< (int64_t)(1e8) ) { //0.1sec
diff --git a/services/sensorservice/SensorFusion.h b/services/sensorservice/SensorFusion.h
index 66a72902cc..0ccbce2b45 100644
--- a/services/sensorservice/SensorFusion.h
+++ b/services/sensorservice/SensorFusion.h
@@ -20,6 +20,8 @@
 #include <stdint.h>
 #include <sys/types.h>
 
+#include <android/util/ProtoOutputStream.h>
+
 #include <utils/SortedVector.h>
 #include <utils/Singleton.h>
 #include <utils/String8.h>
@@ -87,6 +89,7 @@ public:
     status_t activate(int mode, void* ident, bool enabled);
     status_t setDelay(int mode, void* ident, int64_t ns);
 
+    int32_t getAccelHandle() const { return mAcc.getHandle(); }
     float getPowerUsage(int mode=FUSION_9AXIS) const;
     int32_t getMinDelay() const;
 
diff --git a/services/sensorservice/SensorService.cpp b/services/sensorservice/SensorService.cpp
index eabbb3977c..c28ef15479 100644
--- a/services/sensorservice/SensorService.cpp
+++ b/services/sensorservice/SensorService.cpp
@@ -2570,10 +2570,7 @@ void SensorService::UidPolicy::onUidActive(uid_t uid) {
         Mutex::Autolock _l(mUidLock);
         mActiveUids.insert(uid);
     }
-    sp<SensorService> service = mService.promote();
-    if (service != nullptr) {
-        service->onUidStateChanged(uid, UID_STATE_ACTIVE);
-    }
+    postUidStateChanged(uid, UID_STATE_ACTIVE);
 }
 
 void SensorService::UidPolicy::onUidIdle(uid_t uid, __unused bool disabled) {
@@ -2585,10 +2582,7 @@ void SensorService::UidPolicy::onUidIdle(uid_t uid, __unused bool disabled) {
         }
     }
     if (deleted) {
-        sp<SensorService> service = mService.promote();
-        if (service != nullptr) {
-            service->onUidStateChanged(uid, UID_STATE_IDLE);
-        }
+        postUidStateChanged(uid, UID_STATE_IDLE);
     }
 }
 
@@ -2613,9 +2607,18 @@ void SensorService::UidPolicy::updateOverrideUid(uid_t uid, bool active, bool in
         isActive = isUidActiveLocked(uid);
     }
     if (wasActive != isActive) {
-        sp<SensorService> service = mService.promote();
-        if (service != nullptr) {
-            service->onUidStateChanged(uid, isActive ? UID_STATE_ACTIVE : UID_STATE_IDLE);
+        postUidStateChanged(uid, isActive ? UID_STATE_ACTIVE : UID_STATE_IDLE);
+    }
+}
+
+void SensorService::UidPolicy::postUidStateChanged(uid_t uid, UidState state) {
+    sp<MessageHandler> handler = new UidStateChangeHandler(mService, uid, state);
+    sp<SensorService> service = mService.promote();
+    if (service != nullptr) {
+        if (sensorservice_flags::use_looper_for_uid_state_change()) {
+            service->mLooper->sendMessage(handler, Message(0));
+        } else {
+            service->onUidStateChanged(uid, state);
         }
     }
 }
diff --git a/services/sensorservice/SensorService.h b/services/sensorservice/SensorService.h
index bd54d24a9f..de6034a4fe 100644
--- a/services/sensorservice/SensorService.h
+++ b/services/sensorservice/SensorService.h
@@ -308,8 +308,24 @@ private:
             void addOverrideUid(uid_t uid, bool active);
             void removeOverrideUid(uid_t uid);
         private:
+            class UidStateChangeHandler : public MessageHandler {
+            public:
+                UidStateChangeHandler(wp<SensorService> service, uid_t uid, UidState uidState)
+                      : mService(service), mUid(uid), mUidState(uidState) {}
+                void handleMessage(const Message& /*message*/) override {
+                    sp<SensorService> service = mService.promote();
+                    if (service != nullptr) {
+                        service->onUidStateChanged(mUid, mUidState);
+                    }
+                }
+            private:
+                wp<SensorService> mService;
+                uid_t mUid;
+                UidState mUidState;
+            };
             bool isUidActiveLocked(uid_t uid);
             void updateOverrideUid(uid_t uid, bool active, bool insert);
+            void postUidStateChanged(uid_t uid, UidState state);
 
             Mutex mUidLock;
             wp<SensorService> mService;
diff --git a/services/sensorservice/SensorServiceUtils.cpp b/services/sensorservice/SensorServiceUtils.cpp
index 46b4b5bff6..80eeaee9cf 100644
--- a/services/sensorservice/SensorServiceUtils.cpp
+++ b/services/sensorservice/SensorServiceUtils.cpp
@@ -64,6 +64,7 @@ size_t eventSizeBySensorType(int type) {
         case SENSOR_TYPE_HEART_BEAT:
         case SENSOR_TYPE_LOW_LATENCY_OFFBODY_DETECT:
         case SENSOR_TYPE_HINGE_ANGLE:
+        case SENSOR_TYPE_MOISTURE_INTRUSION:
             return 1;
 
         case SENSOR_TYPE_HEAD_TRACKER:
diff --git a/services/sensorservice/sensorservice_flags.aconfig b/services/sensorservice/sensorservice_flags.aconfig
index 63089737e3..5d6446d794 100644
--- a/services/sensorservice/sensorservice_flags.aconfig
+++ b/services/sensorservice/sensorservice_flags.aconfig
@@ -47,4 +47,14 @@ flag {
   metadata {
     purpose: PURPOSE_BUGFIX
   }
+}
+
+flag {
+  name: "use_looper_for_uid_state_change"
+  namespace: "sensors"
+  description: "Processes UID state changes on the SensorEventAckReceiver thread instead of calling (UI) thread"
+  bug: "399607981"
+  metadata {
+    purpose: PURPOSE_BUGFIX
+  }
 }
\ No newline at end of file
diff --git a/services/stats/OWNERS b/services/stats/OWNERS
index 791b711de8..774170c273 100644
--- a/services/stats/OWNERS
+++ b/services/stats/OWNERS
@@ -1,7 +1,5 @@
 jeffreyhuang@google.com
-joeo@google.com
 muhammadq@google.com
 ruchirr@google.com
 singhtejinder@google.com
-tsaichristine@google.com
 yaochen@google.com
diff --git a/services/surfaceflinger/Android.bp b/services/surfaceflinger/Android.bp
index 9aa1ffa96f..3aedd82ad6 100644
--- a/services/surfaceflinger/Android.bp
+++ b/services/surfaceflinger/Android.bp
@@ -84,7 +84,7 @@ cc_defaults {
         "libnativewindow",
         "libprocessgroup",
         "libprotobuf-cpp-lite",
-        "libstatslog_surfaceflinger",
+        "libstatslog_surfaceflinger_bootstrap",
         "libsync",
         "libui",
         "libutils",
@@ -202,12 +202,12 @@ filegroup {
         "BackgroundExecutor.cpp",
         "Client.cpp",
         "ClientCache.cpp",
+        "Display/DisplayIdentification.cpp",
         "Display/DisplayModeController.cpp",
         "Display/DisplaySnapshot.cpp",
         "DisplayDevice.cpp",
         "Effects/Daltonizer.cpp",
         "FpsReporter.cpp",
-        "FrameTimeline/FrameTimeline.cpp",
         "FrameTracer/FrameTracer.cpp",
         "FrameTracker.cpp",
         "FrontEnd/LayerCreationArgs.cpp",
@@ -230,6 +230,7 @@ filegroup {
         "RegionSamplingThread.cpp",
         "Scheduler/EventThread.cpp",
         "Scheduler/FrameRateOverrideMappings.cpp",
+        "Scheduler/FrameTimeline.cpp",
         "Scheduler/LayerHistory.cpp",
         "Scheduler/LayerInfo.cpp",
         "Scheduler/MessageQueue.cpp",
@@ -345,16 +346,47 @@ cc_library_shared {
     ],
 }
 
+cc_library {
+    name: "libstatslog_surfaceflinger_bootstrap",
+    generated_sources: ["statslog_surfaceflinger_bootstrap.cpp"],
+    generated_headers: ["statslog_surfaceflinger_bootstrap.h"],
+    export_generated_headers: ["statslog_surfaceflinger_bootstrap.h"],
+    shared_libs: [
+        "libbinder",
+        "libstatsbootstrap",
+        "libutils",
+    ],
+}
+
+genrule {
+    name: "statslog_surfaceflinger_bootstrap.h",
+    tools: ["stats-log-api-gen"],
+    cmd: "$(location stats-log-api-gen) --header $(genDir)/statslog_surfaceflinger_bootstrap.h" +
+        " --module surfaceflinger --namespace android,surfaceflinger,stats --bootstrap",
+    out: [
+        "statslog_surfaceflinger_bootstrap.h",
+    ],
+}
+
+genrule {
+    name: "statslog_surfaceflinger_bootstrap.cpp",
+    tools: ["stats-log-api-gen"],
+    cmd: "$(location stats-log-api-gen) --cpp $(genDir)/statslog_surfaceflinger_bootstrap.cpp" +
+        " --module surfaceflinger --namespace android,surfaceflinger,stats" +
+        " --importHeader statslog_surfaceflinger_bootstrap.h --bootstrap",
+    out: [
+        "statslog_surfaceflinger_bootstrap.cpp",
+    ],
+}
+
 cc_library {
     name: "libstatslog_surfaceflinger",
     generated_sources: ["statslog_surfaceflinger.cpp"],
     generated_headers: ["statslog_surfaceflinger.h"],
     export_generated_headers: ["statslog_surfaceflinger.h"],
     shared_libs: [
-        "android.os.statsbootstrap_aidl-cpp",
-        "libbinder",
-        "libstatsbootstrap",
-        "libutils",
+        "libstatspull",
+        "libstatssocket",
     ],
 }
 
@@ -362,7 +394,7 @@ genrule {
     name: "statslog_surfaceflinger.h",
     tools: ["stats-log-api-gen"],
     cmd: "$(location stats-log-api-gen) --header $(genDir)/statslog_surfaceflinger.h" +
-        " --module surfaceflinger --namespace android,surfaceflinger,stats --bootstrap",
+        " --module surfaceflinger --namespace android,surfaceflinger,stats",
     out: [
         "statslog_surfaceflinger.h",
     ],
@@ -373,7 +405,7 @@ genrule {
     tools: ["stats-log-api-gen"],
     cmd: "$(location stats-log-api-gen) --cpp $(genDir)/statslog_surfaceflinger.cpp" +
         " --module surfaceflinger --namespace android,surfaceflinger,stats" +
-        " --importHeader statslog_surfaceflinger.h --bootstrap",
+        " --importHeader statslog_surfaceflinger.h",
     out: [
         "statslog_surfaceflinger.cpp",
     ],
diff --git a/services/surfaceflinger/Client.cpp b/services/surfaceflinger/Client.cpp
index 6088e255df..77170977f8 100644
--- a/services/surfaceflinger/Client.cpp
+++ b/services/surfaceflinger/Client.cpp
@@ -99,10 +99,11 @@ binder::Status Client::getLayerFrameStats(const sp<IBinder>& handle, gui::FrameS
 }
 
 binder::Status Client::mirrorSurface(const sp<IBinder>& mirrorFromHandle,
+                                     const sp<IBinder>& stopAtHandle,
                                      gui::CreateSurfaceResult* outResult) {
     LayerCreationArgs args(mFlinger.get(), sp<Client>::fromExisting(this), "MirrorRoot",
                            0 /* flags */, gui::LayerMetadata());
-    status_t status = mFlinger->mirrorLayer(args, mirrorFromHandle, *outResult);
+    status_t status = mFlinger->mirrorLayer(args, mirrorFromHandle, stopAtHandle, *outResult);
     return binderStatusFromStatusT(status);
 }
 
diff --git a/services/surfaceflinger/Client.h b/services/surfaceflinger/Client.h
index 77916e0a78..485d0d9c54 100644
--- a/services/surfaceflinger/Client.h
+++ b/services/surfaceflinger/Client.h
@@ -51,6 +51,7 @@ private:
                                       gui::FrameStats* outStats) override;
 
     binder::Status mirrorSurface(const sp<IBinder>& mirrorFromHandle,
+                                 const sp<IBinder>& stopAtHandle,
                                  gui::CreateSurfaceResult* outResult) override;
 
     binder::Status mirrorDisplay(int64_t displayId, gui::CreateSurfaceResult* outResult) override;
diff --git a/services/surfaceflinger/CompositionEngine/include/compositionengine/Display.h b/services/surfaceflinger/CompositionEngine/include/compositionengine/Display.h
index acd915464e..6163a2611d 100644
--- a/services/surfaceflinger/CompositionEngine/include/compositionengine/Display.h
+++ b/services/surfaceflinger/CompositionEngine/include/compositionengine/Display.h
@@ -17,9 +17,6 @@
 #pragma once
 
 #include <cstdint>
-#include <optional>
-
-#include <ui/DisplayIdentification.h>
 
 #include <compositionengine/Output.h>
 
diff --git a/services/surfaceflinger/CompositionEngine/include/compositionengine/LayerFECompositionState.h b/services/surfaceflinger/CompositionEngine/include/compositionengine/LayerFECompositionState.h
index 34b0bb5653..a241538eba 100644
--- a/services/surfaceflinger/CompositionEngine/include/compositionengine/LayerFECompositionState.h
+++ b/services/surfaceflinger/CompositionEngine/include/compositionengine/LayerFECompositionState.h
@@ -19,6 +19,7 @@
 #include <cstdint>
 
 #include <android/gui/BorderSettings.h>
+#include <android/gui/BoxShadowSettings.h>
 #include <android/gui/CachingHint.h>
 #include <gui/DisplayLuts.h>
 #include <gui/HdrMetadata.h>
@@ -121,6 +122,9 @@ struct LayerFECompositionState {
     // Background blur in pixels
     int backgroundBlurRadius{0};
 
+    // Background blur content scale factor, between 0.0 and 1.0
+    float backgroundBlurScale{1.0f};
+
     // The transform from layer local coordinates to composition coordinates
     ui::Transform geomLayerTransform;
 
@@ -145,6 +149,9 @@ struct LayerFECompositionState {
     // The settings to configure the outline of a layer.
     gui::BorderSettings borderSettings;
 
+    // The settings to configure box shadows of a layer.
+    gui::BoxShadowSettings boxShadowSettings;
+
     // List of regions that require blur
     std::vector<BlurRegion> blurRegions;
 
@@ -240,6 +247,43 @@ struct LayerFECompositionState {
 
     // Debugging
     virtual void dump(std::string& out) const;
+
+    FloatRect outsetRectForShadow(const FloatRect& input) const {
+        FloatRect output = input;
+
+        // RenderEngine currently blurs shadows to smooth out edges, so outset by
+        // 2x the length instead of 1x to compensate
+        float outset = shadowSettings.length * 2;
+
+        // Stroke antialiasing should never add more than 2 pixels.
+        if (borderSettings.strokeWidth > 0) {
+            outset = std::max(outset, borderSettings.strokeWidth + 2);
+        }
+
+        output.left -= outset;
+        output.top -= outset;
+        output.right += outset;
+        output.bottom += outset;
+
+        for (const gui::BoxShadowSettings::BoxShadowParams& boxShadow :
+             boxShadowSettings.boxShadows) {
+            float radius = convertBlurSigmaToKernelRadius(
+                                   convertBlurUserRadiusToSigma(boxShadow.blurRadius)) +
+                    boxShadow.spreadRadius;
+
+            float shadowLeft = input.left + boxShadow.offsetX - radius;
+            float shadowTop = input.top + boxShadow.offsetY - radius;
+            float shadowRight = input.right + boxShadow.offsetX + radius;
+            float shadowBottom = input.bottom + boxShadow.offsetY + radius;
+
+            output.left = std::min(shadowLeft, output.left);
+            output.top = std::min(shadowTop, output.top);
+            output.right = std::max(shadowRight, output.right);
+            output.bottom = std::max(shadowBottom, output.bottom);
+        }
+
+        return output;
+    }
 };
 
 } // namespace android::compositionengine
diff --git a/services/surfaceflinger/CompositionEngine/include/compositionengine/Output.h b/services/surfaceflinger/CompositionEngine/include/compositionengine/Output.h
index 4266da4b07..398224339a 100644
--- a/services/surfaceflinger/CompositionEngine/include/compositionengine/Output.h
+++ b/services/surfaceflinger/CompositionEngine/include/compositionengine/Output.h
@@ -29,7 +29,6 @@
 
 #include <compositionengine/LayerFE.h>
 #include <renderengine/LayerSettings.h>
-#include <ui/DisplayIdentification.h>
 #include <ui/Fence.h>
 #include <ui/FenceTime.h>
 #include <ui/GraphicTypes.h>
@@ -133,6 +132,7 @@ public:
         sp<Fence> presentFence{Fence::NO_FENCE};
         sp<Fence> clientTargetAcquireFence{Fence::NO_FENCE};
         std::unordered_map<HWC2::Layer*, sp<Fence>> layerFences;
+        sp<Fence> readbackFence{Fence::NO_FENCE};
     };
 
     struct ColorProfile {
@@ -159,6 +159,7 @@ public:
         // only has a value if there's something needing it, like when a TrustedPresentationListener
         // is set
         std::optional<Region> aboveCoveredLayersExcludingOverlays;
+        int32_t aboveBlurRequests = 0;
     };
 
     virtual ~Output();
@@ -240,6 +241,7 @@ public:
     // See Output::setLayerFilter.
     virtual bool includesLayer(ui::LayerFilter) const = 0;
     virtual bool includesLayer(const sp<LayerFE>&) const = 0;
+    virtual bool includesLayer(LayerFE*) const = 0;
 
     // Returns a pointer to the output layer corresponding to the given layer on
     // this output, or nullptr if the layer does not have one
@@ -283,6 +285,9 @@ public:
     // Enables overriding the 170M trasnfer function as sRGB
     virtual void setTreat170mAsSrgb(bool) = 0;
 
+    // For test use only. Returns whether the planner has the layer caching texture pool enabled.
+    virtual bool plannerTexturePoolEnabled() const = 0;
+
 protected:
     virtual void setDisplayColorProfile(std::unique_ptr<DisplayColorProfile>) = 0;
     virtual void setRenderSurface(std::unique_ptr<RenderSurface>) = 0;
diff --git a/services/surfaceflinger/CompositionEngine/include/compositionengine/OutputLayer.h b/services/surfaceflinger/CompositionEngine/include/compositionengine/OutputLayer.h
index c0243b81db..72b6079664 100644
--- a/services/surfaceflinger/CompositionEngine/include/compositionengine/OutputLayer.h
+++ b/services/surfaceflinger/CompositionEngine/include/compositionengine/OutputLayer.h
@@ -30,7 +30,6 @@
 #pragma clang diagnostic ignored "-Wconversion"
 #pragma clang diagnostic ignored "-Wextra"
 
-#include <ui/DisplayIdentification.h>
 #include "DisplayHardware/ComposerHal.h"
 
 #include "LayerFE.h"
diff --git a/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/Display.h b/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/Display.h
index 6ec7be885a..f368ad1756 100644
--- a/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/Display.h
+++ b/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/Display.h
@@ -27,8 +27,6 @@
 #include <ui/PixelFormat.h>
 #include <ui/Size.h>
 
-#include <ui/DisplayIdentification.h>
-
 #include "DisplayHardware/HWComposer.h"
 #include "PowerAdvisor/PowerAdvisor.h"
 
diff --git a/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/Output.h b/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/Output.h
index 873764b065..42d137d09e 100644
--- a/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/Output.h
+++ b/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/Output.h
@@ -76,6 +76,7 @@ public:
 
     bool includesLayer(ui::LayerFilter) const override;
     bool includesLayer(const sp<LayerFE>&) const override;
+    bool includesLayer(LayerFE*) const override;
 
     compositionengine::OutputLayer* getOutputLayerForLayer(const sp<LayerFE>&) const override;
 
@@ -118,7 +119,9 @@ public:
     const ReleasedLayers& getReleasedLayersForTest() const;
     void setDisplayColorProfileForTest(std::unique_ptr<compositionengine::DisplayColorProfile>);
     void setRenderSurfaceForTest(std::unique_ptr<compositionengine::RenderSurface>);
+
     bool plannerEnabled() const { return mPlanner != nullptr; }
+    bool plannerTexturePoolEnabled() const override;
     virtual bool anyLayersRequireClientComposition() const;
     virtual void updateProtectedContentState();
     virtual bool dequeueRenderBuffer(base::unique_fd*,
@@ -176,6 +179,7 @@ protected:
 private:
     void dirtyEntireOutput();
     compositionengine::OutputLayer* findLayerRequestingBackgroundComposition() const;
+    void sanitizeOutputLayers() const;
     void finishPrepareFrame();
     ui::Dataspace getBestDataspace(ui::Dataspace*, bool*) const;
     compositionengine::Output::ColorProfile pickColorProfile(
diff --git a/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/OutputCompositionState.h b/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/OutputCompositionState.h
index c76b34481b..7d78b8fe91 100644
--- a/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/OutputCompositionState.h
+++ b/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/OutputCompositionState.h
@@ -173,6 +173,8 @@ struct OutputCompositionState {
 
     PictureProfileHandle pictureProfileHandle;
 
+    sp<GraphicBuffer> readbackBuffer = nullptr;
+
     // Debugging
     void dump(std::string& result) const;
 };
diff --git a/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/OutputLayer.h b/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/OutputLayer.h
index efddc857cd..25020315d5 100644
--- a/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/OutputLayer.h
+++ b/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/OutputLayer.h
@@ -28,8 +28,6 @@
 #include <ui/PictureProfileHandle.h>
 #include <ui/Rect.h>
 
-#include <ui/DisplayIdentification.h>
-
 #include <aidl/android/hardware/graphics/composer3/Composition.h>
 
 using aidl::android::hardware::graphics::composer3::LutProperties;
diff --git a/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/OutputLayerCompositionState.h b/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/OutputLayerCompositionState.h
index c558739464..3dc115e199 100644
--- a/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/OutputLayerCompositionState.h
+++ b/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/OutputLayerCompositionState.h
@@ -105,6 +105,9 @@ struct OutputLayerCompositionState {
     // The picture profile for this layer.
     PictureProfileHandle pictureProfileHandle;
 
+    // ignore blur requests if there's just too many on top of this layer
+    bool ignoreBlur{false};
+
     // Overrides the buffer, acquire fence, and display frame stored in LayerFECompositionState
     struct {
         std::shared_ptr<renderengine::ExternalTexture> buffer = nullptr;
diff --git a/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/planner/CachedSet.h b/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/planner/CachedSet.h
index 86bcf20677..e09e308a01 100644
--- a/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/planner/CachedSet.h
+++ b/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/planner/CachedSet.h
@@ -42,6 +42,7 @@ public:
         const std::string& getName() const { return mState->getName(); }
         int32_t getBackgroundBlurRadius() const { return mState->getBackgroundBlurRadius(); }
         Rect getDisplayFrame() const { return mState->getDisplayFrame(); }
+        bool hasBlurBehind() const { return mState->hasBlurBehind(); }
         const Region& getVisibleRegion() const { return mState->getVisibleRegion(); }
         const sp<GraphicBuffer>& getBuffer() const {
             return mState->getOutputLayer()->getLayerFE().getCompositionState()->buffer;
diff --git a/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/planner/Flattener.h b/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/planner/Flattener.h
index e42b9b12f4..98ff745cd0 100644
--- a/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/planner/Flattener.h
+++ b/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/planner/Flattener.h
@@ -110,6 +110,7 @@ public:
                           bool deviceHandlesColorTransform);
 
     void setTexturePoolEnabled(bool enabled) { mTexturePool.setEnabled(enabled); }
+    bool isTexturePoolEnabled() const { return mTexturePool.isEnabled(); }
 
     void dump(std::string& result) const;
     void dumpLayers(std::string& result) const;
@@ -172,17 +173,18 @@ private:
                 const bool requiresHolePunch =
                         mHolePunchCandidate && mHolePunchCandidate->requiresHolePunch();
 
-                if (!requiresHolePunch) {
-                    // If we don't require a hole punch, then treat solid color layers at the front
-                    // to be "cheap", so remove them from the candidate cached set.
+                if (!requiresHolePunch && mBlurringLayer == nullptr) {
+                    // If we don't require a hole punch and we're not being blurred, then treat
+                    // solid color layers at the front to be "cheap", so remove them from the
+                    // candidate cached set.
                     while (mNumSets > 1 && mStart->getLayerCount() == 1 &&
                            mStart->getFirstLayer().getBuffer() == nullptr) {
                         mStart++;
                         mNumSets--;
                     }
 
-                    // Only allow for single cached sets if a hole punch is required. If we're here,
-                    // then we don't require a hole punch, so don't build a run.
+                    // Only allow for single cached sets if a hole punch or blur is required.
+                    // Neither is true if we're here.
                     if (mNumSets <= 1) {
                         return std::nullopt;
                     }
diff --git a/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/planner/LayerState.h b/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/planner/LayerState.h
index 5e3e3d8a31..eb942421d8 100644
--- a/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/planner/LayerState.h
+++ b/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/planner/LayerState.h
@@ -75,6 +75,7 @@ enum class LayerStateField : uint32_t {
     HasProtectedContent   = 1u << 19,
     CachingHint           = 1u << 20,
     DimmingEnabled        = 1u << 21,
+    BlursDisabled         = 1u << 22,
 };
 // clang-format on
 
@@ -236,7 +237,8 @@ public:
     Rect getDisplayFrame() const { return mDisplayFrame.get(); }
     const Region& getVisibleRegion() const { return mVisibleRegion.get(); }
     bool hasBlurBehind() const {
-        return mBackgroundBlurRadius.get() > 0 || !mBlurRegions.get().empty();
+        return (mBackgroundBlurRadius.get() > 0 || !mBlurRegions.get().empty()) &&
+                !mIsBlursDisabled.get();
     }
     int32_t getBackgroundBlurRadius() const { return mBackgroundBlurRadius.get(); }
     aidl::android::hardware::graphics::composer3::Composition getCompositionType() const {
@@ -508,7 +510,10 @@ private:
     OutputLayerState<bool, LayerStateField::DimmingEnabled> mIsDimmingEnabled{
             [](auto layer) { return layer->getLayerFE().getCompositionState()->dimmingEnabled; }};
 
-    static const constexpr size_t kNumNonUniqueFields = 20;
+    OutputLayerState<bool, LayerStateField::BlursDisabled> mIsBlursDisabled{
+            [](auto layer) { return layer->getState().ignoreBlur; }};
+
+    static const constexpr size_t kNumNonUniqueFields = 21;
 
     std::array<StateInterface*, kNumNonUniqueFields> getNonUniqueFields() {
         std::array<const StateInterface*, kNumNonUniqueFields> constFields =
@@ -522,11 +527,12 @@ private:
     }
 
     std::array<const StateInterface*, kNumNonUniqueFields> getNonUniqueFields() const {
-        return {&mDisplayFrame, &mSourceCrop,     &mBufferTransform,      &mBlendMode,
-                &mAlpha,        &mLayerMetadata,  &mVisibleRegion,        &mOutputDataspace,
-                &mPixelFormat,  &mColorTransform, &mCompositionType,      &mSidebandStream,
-                &mBuffer,       &mSolidColor,     &mBackgroundBlurRadius, &mBlurRegions,
-                &mFrameNumber,  &mIsProtected,    &mCachingHint,          &mIsDimmingEnabled};
+        return {&mDisplayFrame,   &mSourceCrop,     &mBufferTransform,      &mBlendMode,
+                &mAlpha,          &mLayerMetadata,  &mVisibleRegion,        &mOutputDataspace,
+                &mPixelFormat,    &mColorTransform, &mCompositionType,      &mSidebandStream,
+                &mBuffer,         &mSolidColor,     &mBackgroundBlurRadius, &mBlurRegions,
+                &mFrameNumber,    &mIsProtected,    &mCachingHint,          &mIsDimmingEnabled,
+                &mIsBlursDisabled};
     }
 };
 
diff --git a/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/planner/Planner.h b/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/planner/Planner.h
index c968df708f..187fc4c5c1 100644
--- a/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/planner/Planner.h
+++ b/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/planner/Planner.h
@@ -41,7 +41,7 @@ namespace compositionengine::impl::planner {
 // as a more efficient representation of parts of the layer stack.
 // Implicitly, layer caching must also be enabled for the Planner to have any effect
 // E.g., setprop debug.sf.enable_layer_caching 1, or
-// adb shell service call SurfaceFlinger 1040 i32 1 [i64 <display ID>]
+// adb shell service call SurfaceFlinger 1040 i32 1
 class Planner {
 public:
     Planner(renderengine::RenderEngine& renderengine);
@@ -70,6 +70,8 @@ public:
 
     void setTexturePoolEnabled(bool enabled) { mFlattener.setTexturePoolEnabled(enabled); }
 
+    bool isTexturePoolEnabled() const { return mFlattener.isTexturePoolEnabled(); }
+
     void dump(const Vector<String16>& args, std::string&);
 
 private:
diff --git a/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/planner/TexturePool.h b/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/planner/TexturePool.h
index d607c75325..b2aafa8676 100644
--- a/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/planner/TexturePool.h
+++ b/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/planner/TexturePool.h
@@ -85,6 +85,8 @@ public:
 
     void dump(std::string& out) const;
 
+    bool isEnabled() const { return mEnabled; }
+
 protected:
     // Proteted visibility so that they can be used for testing
     const static constexpr size_t kMinPoolSize = 3;
diff --git a/services/surfaceflinger/CompositionEngine/include/compositionengine/mock/Display.h b/services/surfaceflinger/CompositionEngine/include/compositionengine/mock/Display.h
index 2d51b71b09..5322eea194 100644
--- a/services/surfaceflinger/CompositionEngine/include/compositionengine/mock/Display.h
+++ b/services/surfaceflinger/CompositionEngine/include/compositionengine/mock/Display.h
@@ -22,7 +22,6 @@
 #include <compositionengine/mock/Output.h>
 #include <gmock/gmock.h>
 #include <system/window.h>
-#include <ui/DisplayIdentification.h>
 
 namespace android::compositionengine::mock {
 
diff --git a/services/surfaceflinger/CompositionEngine/include/compositionengine/mock/Output.h b/services/surfaceflinger/CompositionEngine/include/compositionengine/mock/Output.h
index eaa3dd37ec..eb216b7cf6 100644
--- a/services/surfaceflinger/CompositionEngine/include/compositionengine/mock/Output.h
+++ b/services/surfaceflinger/CompositionEngine/include/compositionengine/mock/Output.h
@@ -48,6 +48,7 @@ public:
     MOCK_METHOD(void, setLayerFilter, (ui::LayerFilter));
     MOCK_METHOD(bool, includesLayer, (ui::LayerFilter), (const));
     MOCK_METHOD(bool, includesLayer, (const sp<compositionengine::LayerFE>&), (const));
+    MOCK_METHOD(bool, includesLayer, (compositionengine::LayerFE*), (const));
 
     MOCK_METHOD1(setColorTransform, void(const compositionengine::CompositionRefreshArgs&));
     MOCK_METHOD1(setColorProfile, void(const ColorProfile&));
@@ -136,6 +137,7 @@ public:
     MOCK_METHOD1(canPredictCompositionStrategy, bool(const CompositionRefreshArgs&));
     MOCK_METHOD1(setPredictCompositionStrategy, void(bool));
     MOCK_METHOD1(setTreat170mAsSrgb, void(bool));
+    MOCK_METHOD(bool, plannerTexturePoolEnabled, (), (const));
     MOCK_METHOD(void, setHintSessionGpuStart, (TimePoint startTime));
     MOCK_METHOD(void, setHintSessionGpuFence, (std::unique_ptr<FenceTime> && gpuFence));
     MOCK_METHOD(void, setHintSessionRequiresRenderEngine, (bool requiresRenderEngine));
diff --git a/services/surfaceflinger/CompositionEngine/src/ClientCompositionRequestCache.cpp b/services/surfaceflinger/CompositionEngine/src/ClientCompositionRequestCache.cpp
index dc841952c9..35eeb9b5a1 100644
--- a/services/surfaceflinger/CompositionEngine/src/ClientCompositionRequestCache.cpp
+++ b/services/surfaceflinger/CompositionEngine/src/ClientCompositionRequestCache.cpp
@@ -37,6 +37,7 @@ inline bool equalIgnoringSource(const renderengine::LayerSettings& lhs,
             lhs.colorTransform == rhs.colorTransform &&
             lhs.disableBlending == rhs.disableBlending && lhs.shadow == rhs.shadow &&
             lhs.backgroundBlurRadius == rhs.backgroundBlurRadius &&
+            lhs.backgroundBlurScale == rhs.backgroundBlurScale &&
             lhs.stretchEffect == rhs.stretchEffect &&
             lhs.edgeExtensionEffect == rhs.edgeExtensionEffect &&
             lhs.whitePointNits == rhs.whitePointNits;
diff --git a/services/surfaceflinger/CompositionEngine/src/Display.cpp b/services/surfaceflinger/CompositionEngine/src/Display.cpp
index 531cab6938..6dc8324952 100644
--- a/services/surfaceflinger/CompositionEngine/src/Display.cpp
+++ b/services/surfaceflinger/CompositionEngine/src/Display.cpp
@@ -26,6 +26,7 @@
 #include <compositionengine/impl/DumpHelpers.h>
 #include <compositionengine/impl/OutputLayer.h>
 #include <compositionengine/impl/RenderSurface.h>
+#include <ui/DisplayId.h>
 
 // TODO(b/129481165): remove the #pragma below and fix conversion issues
 #pragma clang diagnostic push
@@ -266,6 +267,12 @@ bool Display::chooseCompositionStrategy(
 
     const TimePoint hwcValidateStartTime = TimePoint::now();
 
+    const auto physicalDisplayId = getDisplayIdVariant().and_then(asPhysicalDisplayId);
+
+    if (physicalDisplayId && getState().readbackBuffer) {
+        hwc.setReadbackBuffer(*physicalDisplayId, getState().readbackBuffer, Fence::NO_FENCE);
+    }
+
     if (status_t result = hwc.getDeviceCompositionChanges(*halDisplayId, requiresClientComposition,
                                                           getState().earliestPresentTime,
                                                           getState().expectedPresentTime,
@@ -308,7 +315,7 @@ bool Display::getSkipColorTransform() const {
                                         DisplayCapability::SKIP_CLIENT_COLOR_TRANSFORM);
     }
 
-    return hwc.hasCapability(Capability::SKIP_CLIENT_COLOR_TRANSFORM);
+    return Output::getSkipColorTransform();
 }
 
 bool Display::allLayersRequireClientComposition() const {
@@ -384,8 +391,13 @@ void Display::applyLayerLutsToLayers(const LayerLuts& layerLuts) {
 
         if (auto lutsIt = layerLuts.find(hwcLayer); lutsIt != layerLuts.end()) {
             if (auto mapperIt = mapper.find(hwcLayer); mapperIt != mapper.end()) {
-                layer->applyDeviceLayerLut(::android::base::unique_fd(mapperIt->second.release()),
-                                           lutsIt->second);
+                if (mapperIt->second.ok()) {
+                    layer->applyDeviceLayerLut(::android::base::unique_fd(
+                                                       mapperIt->second.release()),
+                                               lutsIt->second);
+                } else {
+                    layer->applyDeviceLayerLut(::android::base::unique_fd(), lutsIt->second);
+                }
             }
         }
     }
diff --git a/services/surfaceflinger/CompositionEngine/src/LayerFECompositionState.cpp b/services/surfaceflinger/CompositionEngine/src/LayerFECompositionState.cpp
index 294b167d4a..e7f02c3f46 100644
--- a/services/surfaceflinger/CompositionEngine/src/LayerFECompositionState.cpp
+++ b/services/surfaceflinger/CompositionEngine/src/LayerFECompositionState.cpp
@@ -73,6 +73,9 @@ void LayerFECompositionState::dump(std::string& out) const {
     out.append("      ");
     dumpVal(out, "borderSettings", borderSettings.toString());
 
+    out.append("      ");
+    dumpVal(out, "boxShadowSettings", boxShadowSettings.toString());
+
     out.append("\n      ");
     dumpVal(out, "blend", toString(blendMode), blendMode);
     dumpVal(out, "alpha", alpha);
diff --git a/services/surfaceflinger/CompositionEngine/src/Output.cpp b/services/surfaceflinger/CompositionEngine/src/Output.cpp
index 00a61a5ab6..b450e36132 100644
--- a/services/surfaceflinger/CompositionEngine/src/Output.cpp
+++ b/services/surfaceflinger/CompositionEngine/src/Output.cpp
@@ -389,6 +389,10 @@ void Output::setRenderSurfaceForTest(std::unique_ptr<compositionengine::RenderSu
     mRenderSurface = std::move(surface);
 }
 
+bool Output::plannerTexturePoolEnabled() const {
+    return mPlanner && mPlanner->isTexturePoolEnabled();
+}
+
 Region Output::getDirtyRegion() const {
     const auto& outputState = getState();
     return outputState.dirtyRegion.intersect(outputState.layerStackSpace.getContent());
@@ -399,6 +403,10 @@ bool Output::includesLayer(ui::LayerFilter filter) const {
 }
 
 bool Output::includesLayer(const sp<LayerFE>& layerFE) const {
+    return includesLayer(layerFE.get());
+}
+
+bool Output::includesLayer(LayerFE* layerFE) const {
     const auto* layerFEState = layerFE->getCompositionState();
     return layerFEState && includesLayer(layerFEState->outputFilter);
 }
@@ -617,7 +625,7 @@ void Output::ensureOutputLayerIfVisible(sp<compositionengine::LayerFE>& layerFE,
     Region transparentRegion;
 
     /*
-     * shadowRegion: Region cast by the layer's shadow.
+     * shadowRegion: Region cast by the layer's shadow or border.
      */
     Region shadowRegion;
 
@@ -631,18 +639,9 @@ void Output::ensureOutputLayerIfVisible(sp<compositionengine::LayerFE>& layerFE,
     // Get the visible region
     // TODO(b/121291683): Is it worth creating helper methods on LayerFEState
     // for computations like this?
-    const Rect visibleRect(tr.transform(layerFEState->geomLayerBounds));
-    visibleRegion.set(visibleRect);
-
-    if (layerFEState->shadowSettings.length > 0.0f) {
-        // if the layer casts a shadow, offset the layers visible region and
-        // calculate the shadow region.
-        const auto inset = static_cast<int32_t>(ceilf(layerFEState->shadowSettings.length) * -1.0f);
-        Rect visibleRectWithShadows(visibleRect);
-        visibleRectWithShadows.inset(inset, inset, inset, inset);
-        visibleRegion.set(visibleRectWithShadows);
-        shadowRegion = visibleRegion.subtract(visibleRect);
-    }
+    const Rect geomRect(tr.transform(layerFEState->geomLayerBounds));
+    visibleRegion.set(Rect(layerFEState->outsetRectForShadow(geomRect.toFloatRect())));
+    shadowRegion = visibleRegion.subtract(geomRect);
 
     if (visibleRegion.isEmpty()) {
         return;
@@ -689,7 +688,7 @@ void Output::ensureOutputLayerIfVisible(sp<compositionengine::LayerFE>& layerFE,
         // Otherwise we don't try and compute the opaque region since there may
         // be errors at the edges, and we treat the entire layer as
         // translucent.
-        opaqueRegion.set(visibleRect);
+        opaqueRegion.set(geomRect);
     }
 
     // Clip the covered region to the visible region
@@ -776,6 +775,9 @@ void Output::ensureOutputLayerIfVisible(sp<compositionengine::LayerFE>& layerFE,
     // one, or create a new one if we do not.
     auto outputLayer = ensureOutputLayer(prevOutputLayerIndex, layerFE);
 
+    coverage.aboveBlurRequests += static_cast<int32_t>(layerFEState->backgroundBlurRadius > 0 ||
+                                                       !layerFEState->blurRegions.empty());
+
     // Store the layer coverage information into the layer state as some of it
     // is useful later.
     auto& outputLayerState = outputLayer->editState();
@@ -790,6 +792,11 @@ void Output::ensureOutputLayerIfVisible(sp<compositionengine::LayerFE>& layerFE,
             ? outputState.transform.transform(
                       transparentRegion.intersect(outputState.layerStackSpace.getContent()))
             : Region();
+
+    // See b/399120953: blurs are so expensive that they may be susceptible to compression side
+    // channel attacks
+    static constexpr auto kMaxBlurRequests = 10;
+    outputLayerState.ignoreBlur = coverage.aboveBlurRequests > kMaxBlurRequests;
     if (CC_UNLIKELY(computeAboveCoveredExcludingOverlays)) {
         outputLayerState.coveredRegionExcludingDisplayOverlays =
                 std::move(coveredRegionExcludingDisplayOverlays);
@@ -1152,6 +1159,15 @@ void Output::prepareFrame() {
 
     std::optional<android::HWComposer::DeviceRequestedChanges> changes;
     bool success = chooseCompositionStrategy(&changes);
+
+    if (success && changes.has_value()) {
+        for (const compositionengine::OutputLayer* layer : getOutputLayersOrderedByZ()) {
+            HWC2::Layer* hwcLayer = layer->getHwcLayer();
+            if (!hwcLayer || changes->changedTypes.contains(hwcLayer)) continue;
+            changes->changedTypes[hwcLayer] = layer->getState().hwc->hwcCompositionType;
+        }
+    }
+
     resetCompositionStrategy();
     outputState.strategyPrediction = CompositionStrategyPredictionState::DISABLED;
     outputState.previousDeviceRequestedChanges = changes;
@@ -1183,6 +1199,14 @@ GpuCompositionResult Output::prepareFrameAsync() {
     const auto& previousChanges = state.previousDeviceRequestedChanges;
     std::optional<android::HWComposer::DeviceRequestedChanges> changes;
     resetCompositionStrategy();
+    // Store all layer composition types before appplying composition strategy
+    android::HWComposer::DeviceRequestedChanges::ChangedTypes backups;
+    for (const compositionengine::OutputLayer* layer : getOutputLayersOrderedByZ()) {
+        HWC2::Layer* hwcLayer = layer->getHwcLayer();
+        if (!hwcLayer) continue;
+        backups[hwcLayer] = layer->getState().hwc->hwcCompositionType;
+    }
+
     auto hwcResult = chooseCompositionStrategyAsync(&changes);
     if (state.previousDeviceRequestedSuccess) {
         applyCompositionStrategy(previousChanges);
@@ -1203,6 +1227,14 @@ GpuCompositionResult Output::prepareFrameAsync() {
     }
 
     auto chooseCompositionSuccess = hwcResult.get();
+    if (chooseCompositionSuccess && changes.has_value()) {
+        // Keep track of all layer composition types, not just changes
+        for (const compositionengine::OutputLayer* layer : getOutputLayersOrderedByZ()) {
+            HWC2::Layer* hwcLayer = layer->getHwcLayer();
+            if (!hwcLayer || changes->changedTypes.contains(hwcLayer)) continue;
+            changes->changedTypes[hwcLayer] = backups[hwcLayer];
+        }
+    }
     const bool predictionSucceeded = dequeueSucceeded && changes == previousChanges;
     state.strategyPrediction = predictionSucceeded ? CompositionStrategyPredictionState::SUCCESS
                                                    : CompositionStrategyPredictionState::FAIL;
@@ -1291,18 +1323,11 @@ void Output::updateProtectedContentState() {
     auto& renderEngine = getCompositionEngine().getRenderEngine();
     const bool supportsProtectedContent = renderEngine.supportsProtectedContent();
 
-    bool isProtected;
-    if (FlagManager::getInstance().display_protected()) {
-        isProtected = outputState.isProtected;
-    } else {
-        isProtected = outputState.isSecure;
-    }
-
     // We need to set the render surface as protected (DRM) if all the following conditions are met:
     // 1. The display is protected (in legacy, check if the display is secure)
     // 2. Protected content is supported
     // 3. At least one layer has protected content.
-    if (isProtected && supportsProtectedContent) {
+    if (outputState.isProtected && supportsProtectedContent) {
         auto layers = getOutputLayersOrderedByZ();
         bool needsProtected = std::any_of(layers.begin(), layers.end(), [](auto* layer) {
             return layer->getLayerFE().getCompositionState()->hasProtectedContent &&
@@ -1499,7 +1524,7 @@ std::vector<LayerFE::LayerSettings> Output::generateClientCompositionRequests(
     const Region viewportRegion(outputState.layerStackSpace.getContent());
     bool firstLayer = true;
 
-    bool disableBlurs = false;
+    bool disableBlursWholesale = false;
     uint64_t previousOverrideBufferId = 0;
 
     for (auto* layer : getOutputLayersOrderedByZ()) {
@@ -1516,7 +1541,8 @@ std::vector<LayerFE::LayerSettings> Output::generateClientCompositionRequests(
             continue;
         }
 
-        disableBlurs |= layerFEState->sidebandStream != nullptr;
+        disableBlursWholesale |= layerFEState->sidebandStream != nullptr;
+        bool disableBlurForLayer = layer->getState().ignoreBlur || disableBlursWholesale;
 
         const bool clientComposition = layer->requiresClientComposition();
 
@@ -1546,23 +1572,21 @@ std::vector<LayerFE::LayerSettings> Output::generateClientCompositionRequests(
                           layer->getLayerFE().getDebugName());
                 }
             } else {
-                LayerFE::ClientCompositionTargetSettings::BlurSetting blurSetting = disableBlurs
+                LayerFE::ClientCompositionTargetSettings::BlurSetting blurSetting =
+                        disableBlurForLayer
                         ? LayerFE::ClientCompositionTargetSettings::BlurSetting::Disabled
                         : (layer->getState().overrideInfo.disableBackgroundBlur
                                    ? LayerFE::ClientCompositionTargetSettings::BlurSetting::
                                              BlurRegionsOnly
                                    : LayerFE::ClientCompositionTargetSettings::BlurSetting::
                                              Enabled);
-                bool isProtected = supportsProtectedContent;
-                if (FlagManager::getInstance().display_protected()) {
-                    isProtected = outputState.isProtected && supportsProtectedContent;
-                }
                 compositionengine::LayerFE::ClientCompositionTargetSettings
                         targetSettings{.clip = clip,
                                        .needsFiltering = layer->needsFiltering() ||
                                                outputState.needsFiltering,
                                        .isSecure = outputState.isSecure,
-                                       .isProtected = isProtected,
+                                       .isProtected = outputState.isProtected &&
+                                               supportsProtectedContent,
                                        .viewport = outputState.layerStackSpace.getContent(),
                                        .dataspace = outputDataspace,
                                        .realContentIsVisible = realContentIsVisible,
@@ -1714,6 +1738,9 @@ void Output::resetCompositionStrategy() {
 }
 
 bool Output::getSkipColorTransform() const {
+    // TODO: This needs to be true because the color transform is a global across all displays, but
+    // use-cases like screen recording don't want the color transform. Please make color transforms
+    // actually a per-display concept :(
     return true;
 }
 
diff --git a/services/surfaceflinger/CompositionEngine/src/OutputLayer.cpp b/services/surfaceflinger/CompositionEngine/src/OutputLayer.cpp
index e4793a4cf2..a6117d1de7 100644
--- a/services/surfaceflinger/CompositionEngine/src/OutputLayer.cpp
+++ b/services/surfaceflinger/CompositionEngine/src/OutputLayer.cpp
@@ -227,24 +227,8 @@ Rect OutputLayer::calculateOutputDisplayFrame() const {
 
     // Some HWCs may clip client composited input to its displayFrame. Make sure
     // that this does not cut off the shadow.
-    if (layerState.forceClientComposition && layerState.shadowSettings.length > 0.0f) {
-        // RenderEngine currently blurs shadows to smooth out edges, so outset by
-        // 2x the length instead of 1x to compensate
-        const auto outset = layerState.shadowSettings.length * 2;
-        geomLayerBounds.left -= outset;
-        geomLayerBounds.top -= outset;
-        geomLayerBounds.right += outset;
-        geomLayerBounds.bottom += outset;
-    }
-
-    // Similar to above
-    if (layerState.forceClientComposition && layerState.borderSettings.strokeWidth > 0.0f) {
-        // Antialiasing should never add more than 2 pixels.
-        const auto outset = layerState.borderSettings.strokeWidth + 2;
-        geomLayerBounds.left -= outset;
-        geomLayerBounds.top -= outset;
-        geomLayerBounds.right += outset;
-        geomLayerBounds.bottom += outset;
+    if (layerState.forceClientComposition) {
+        geomLayerBounds = layerState.outsetRectForShadow(geomLayerBounds);
     }
 
     geomLayerBounds = layerTransform.transform(geomLayerBounds);
@@ -986,6 +970,11 @@ void OutputLayer::applyDeviceCompositionTypeChange(Composition compositionType)
     LOG_FATAL_IF(!state.hwc);
     auto& hwcState = *state.hwc;
 
+    if (hwcState.hwcCompositionType == compositionType) {
+        // no changes
+        return;
+    }
+
     // Only detected disallowed changes if this was not a skip layer, because the
     // validated composition type may be arbitrary (usually DEVICE, to reflect that there were
     // fewer GPU layers)
@@ -1028,23 +1017,27 @@ void OutputLayer::applyDeviceLayerLut(
     auto& state = editState();
     LOG_FATAL_IF(!state.hwc);
     auto& hwcState = *state.hwc;
-    std::vector<int32_t> offsets;
-    std::vector<int32_t> dimensions;
-    std::vector<int32_t> sizes;
-    std::vector<int32_t> samplingKeys;
-    for (const auto& [offset, properties] : lutOffsetsAndProperties) {
-        // The Lut(s) that comes back through CommandResultPayload should be
-        // only one sampling key.
-        if (properties.samplingKeys.size() == 1) {
-            offsets.emplace_back(offset);
-            dimensions.emplace_back(static_cast<int32_t>(properties.dimension));
-            sizes.emplace_back(static_cast<int32_t>(properties.size));
-            samplingKeys.emplace_back(static_cast<int32_t>(properties.samplingKeys[0]));
+    if (lutFd.ok()) {
+        std::vector<int32_t> offsets;
+        std::vector<int32_t> dimensions;
+        std::vector<int32_t> sizes;
+        std::vector<int32_t> samplingKeys;
+        for (const auto& [offset, properties] : lutOffsetsAndProperties) {
+            // The Lut(s) that comes back through CommandResultPayload should be
+            // only one sampling key.
+            if (properties.samplingKeys.size() == 1) {
+                offsets.emplace_back(offset);
+                dimensions.emplace_back(static_cast<int32_t>(properties.dimension));
+                sizes.emplace_back(static_cast<int32_t>(properties.size));
+                samplingKeys.emplace_back(static_cast<int32_t>(properties.samplingKeys[0]));
+            }
         }
+        hwcState.luts = std::make_shared<gui::DisplayLuts>(std::move(lutFd), std::move(offsets),
+                                                           std::move(dimensions), std::move(sizes),
+                                                           std::move(samplingKeys));
+    } else {
+        hwcState.luts = nullptr;
     }
-    hwcState.luts = std::make_shared<gui::DisplayLuts>(std::move(lutFd), std::move(offsets),
-                                                       std::move(dimensions), std::move(sizes),
-                                                       std::move(samplingKeys));
 }
 
 bool OutputLayer::needsFiltering() const {
diff --git a/services/surfaceflinger/CompositionEngine/src/planner/CachedSet.cpp b/services/surfaceflinger/CompositionEngine/src/planner/CachedSet.cpp
index 409a206ace..a458b5ebd0 100644
--- a/services/surfaceflinger/CompositionEngine/src/planner/CachedSet.cpp
+++ b/services/surfaceflinger/CompositionEngine/src/planner/CachedSet.cpp
@@ -196,9 +196,14 @@ void CachedSet::render(renderengine::RenderEngine& renderEngine, TexturePool& te
     std::vector<renderengine::LayerSettings> layerSettings;
     renderengine::LayerSettings highlight;
     for (const auto& layer : mLayers) {
+        auto blurSettings = targetSettings;
+        if (!layer.hasBlurBehind()) {
+            blurSettings.blurSetting =
+                    LayerFE::ClientCompositionTargetSettings::BlurSetting::Disabled;
+        }
         if (auto clientCompositionSettings =
                     layer.getState()->getOutputLayer()->getLayerFE().prepareClientComposition(
-                            targetSettings)) {
+                            blurSettings)) {
             layerSettings.push_back(std::move(*clientCompositionSettings));
         }
     }
diff --git a/services/surfaceflinger/CompositionEngine/tests/DisplayTest.cpp b/services/surfaceflinger/CompositionEngine/tests/DisplayTest.cpp
index 77fd4466ef..4b127fe676 100644
--- a/services/surfaceflinger/CompositionEngine/tests/DisplayTest.cpp
+++ b/services/surfaceflinger/CompositionEngine/tests/DisplayTest.cpp
@@ -302,7 +302,7 @@ TEST_F(DisplaySetConfigurationTest, configuresPhysicalDisplay) {
     EXPECT_FALSE(mDisplay->isValid());
 
     const auto& filter = mDisplay->getState().layerFilter;
-    EXPECT_EQ(ui::INVALID_LAYER_STACK, filter.layerStack);
+    EXPECT_EQ(ui::UNASSIGNED_LAYER_STACK, filter.layerStack);
     EXPECT_FALSE(filter.toInternalDisplay);
 }
 
@@ -322,7 +322,7 @@ TEST_F(DisplaySetConfigurationTest, configuresHalVirtualDisplay) {
     EXPECT_FALSE(mDisplay->isValid());
 
     const auto& filter = mDisplay->getState().layerFilter;
-    EXPECT_EQ(ui::INVALID_LAYER_STACK, filter.layerStack);
+    EXPECT_EQ(ui::UNASSIGNED_LAYER_STACK, filter.layerStack);
     EXPECT_FALSE(filter.toInternalDisplay);
 }
 
@@ -342,7 +342,7 @@ TEST_F(DisplaySetConfigurationTest, configuresGpuVirtualDisplay) {
     EXPECT_FALSE(mDisplay->isValid());
 
     const auto& filter = mDisplay->getState().layerFilter;
-    EXPECT_EQ(ui::INVALID_LAYER_STACK, filter.layerStack);
+    EXPECT_EQ(ui::UNASSIGNED_LAYER_STACK, filter.layerStack);
     EXPECT_FALSE(filter.toInternalDisplay);
 }
 
@@ -689,8 +689,6 @@ using DisplayGetSkipColorTransformTest = DisplayWithLayersTestCommon;
 using aidl::android::hardware::graphics::composer3::DisplayCapability;
 
 TEST_F(DisplayGetSkipColorTransformTest, checksCapabilityIfGpuDisplay) {
-    EXPECT_CALL(mHwComposer, hasCapability(Capability::SKIP_CLIENT_COLOR_TRANSFORM))
-            .WillOnce(Return(true));
     auto args = getDisplayCreationArgsForGpuVirtualDisplay();
     auto gpuDisplay{impl::createDisplay(mCompositionEngine, args)};
     EXPECT_TRUE(gpuDisplay->getSkipColorTransform());
diff --git a/services/surfaceflinger/CompositionEngine/tests/OutputLayerTest.cpp b/services/surfaceflinger/CompositionEngine/tests/OutputLayerTest.cpp
index 2f531f11fe..a0bc5fdc38 100644
--- a/services/surfaceflinger/CompositionEngine/tests/OutputLayerTest.cpp
+++ b/services/surfaceflinger/CompositionEngine/tests/OutputLayerTest.cpp
@@ -375,6 +375,33 @@ TEST_F(OutputLayerDisplayFrameTest, outlineExpandsDisplayFrame_onlyIfForcingClie
     EXPECT_THAT(calculateOutputDisplayFrame(), expected);
 }
 
+TEST_F(OutputLayerDisplayFrameTest, boxShadowExpandsDisplayFrame) {
+    gui::BoxShadowSettings::BoxShadowParams boxShadow;
+    boxShadow.blurRadius = 4;
+    boxShadow.spreadRadius = 1;
+    boxShadow.offsetX = 3;
+    boxShadow.offsetY = 2;
+    mLayerFEState.boxShadowSettings.boxShadows.push_back(boxShadow);
+    mLayerFEState.forceClientComposition = true;
+
+    mLayerFEState.geomLayerBounds = FloatRect{100.f, 100.f, 200.f, 200.f};
+    // See LayerFECompositionState::outsetRectForShadow for how to calculate expected value.
+    EXPECT_THAT(calculateOutputDisplayFrame(), Rect(93, 92, 213, 212));
+}
+
+TEST_F(OutputLayerDisplayFrameTest, boxShadowExpandsDisplayFrame_onlyIfForcingClientComposition) {
+    gui::BoxShadowSettings::BoxShadowParams boxShadow;
+    boxShadow.blurRadius = 5;
+    boxShadow.offsetX = 3;
+    boxShadow.offsetY = 2;
+    mLayerFEState.boxShadowSettings.boxShadows.push_back(boxShadow);
+    mLayerFEState.forceClientComposition = false;
+
+    mLayerFEState.geomLayerBounds = FloatRect{100.f, 100.f, 200.f, 200.f};
+    Rect expected{mLayerFEState.geomLayerBounds};
+    EXPECT_THAT(calculateOutputDisplayFrame(), expected);
+}
+
 /*
  * OutputLayer::calculateOutputRelativeBufferTransform()
  */
diff --git a/services/surfaceflinger/CompositionEngine/tests/OutputTest.cpp b/services/surfaceflinger/CompositionEngine/tests/OutputTest.cpp
index 590626ace5..a763a9e02b 100644
--- a/services/surfaceflinger/CompositionEngine/tests/OutputTest.cpp
+++ b/services/surfaceflinger/CompositionEngine/tests/OutputTest.cpp
@@ -646,8 +646,8 @@ TEST_F(OutputTest, layerFiltering) {
     mOutput->setLayerFilter({layerStack1, true});
 
     // It excludes layers with no layer stack, internal-only or not.
-    EXPECT_FALSE(mOutput->includesLayer({ui::INVALID_LAYER_STACK, false}));
-    EXPECT_FALSE(mOutput->includesLayer({ui::INVALID_LAYER_STACK, true}));
+    EXPECT_FALSE(mOutput->includesLayer({ui::UNASSIGNED_LAYER_STACK, false}));
+    EXPECT_FALSE(mOutput->includesLayer({ui::UNASSIGNED_LAYER_STACK, true}));
 
     // It includes layers on layerStack1, internal-only or not.
     EXPECT_TRUE(mOutput->includesLayer({layerStack1, false}));
@@ -685,10 +685,10 @@ TEST_F(OutputTest, layerFilteringWithCompositionState) {
     mOutput->setLayerFilter({layerStack1, true});
 
     // It excludes layers with no layer stack, internal-only or not.
-    layer.layerFEState.outputFilter = {ui::INVALID_LAYER_STACK, false};
+    layer.layerFEState.outputFilter = {ui::UNASSIGNED_LAYER_STACK, false};
     EXPECT_FALSE(mOutput->includesLayer(layerFE));
 
-    layer.layerFEState.outputFilter = {ui::INVALID_LAYER_STACK, true};
+    layer.layerFEState.outputFilter = {ui::UNASSIGNED_LAYER_STACK, true};
     EXPECT_FALSE(mOutput->includesLayer(layerFE));
 
     // It includes layers on layerStack1, internal-only or not.
@@ -1882,8 +1882,8 @@ TEST_F(OutputEnsureOutputLayerIfVisibleTest, coverageAccumulatesWithShadowsTest)
 
     mCoverageState.dirtyRegion = Region(Rect(0, 0, 500, 500));
     // half of the layer including the casting shadow is covered and opaque
-    mCoverageState.aboveCoveredLayers = Region(Rect(40, 40, 100, 260));
-    mCoverageState.aboveOpaqueLayers = Region(Rect(40, 40, 100, 260));
+    mCoverageState.aboveCoveredLayers = Region(Rect(30, 30, 100, 270));
+    mCoverageState.aboveOpaqueLayers = Region(Rect(30, 30, 100, 270));
 
     EXPECT_CALL(mOutput, ensureOutputLayer(Eq(0u), Eq(mLayer.layerFE)))
             .WillOnce(Return(&mLayer.outputLayer));
@@ -1891,16 +1891,16 @@ TEST_F(OutputEnsureOutputLayerIfVisibleTest, coverageAccumulatesWithShadowsTest)
     ensureOutputLayerIfVisible();
 
     const Region kExpectedDirtyRegion = Region(Rect(0, 0, 500, 500));
-    const Region kExpectedAboveCoveredRegion = Region(Rect(40, 40, 160, 260));
+    const Region kExpectedAboveCoveredRegion = Region(Rect(30, 30, 170, 270));
     // add starting opaque region to the opaque half of the casting layer bounds
     const Region kExpectedAboveOpaqueRegion =
-            Region(Rect(40, 40, 100, 260)).orSelf(Rect(100, 50, 150, 250));
-    const Region kExpectedLayerVisibleRegion = Region(Rect(100, 40, 160, 260));
+            Region(Rect(30, 30, 100, 270)).orSelf(Rect(100, 50, 150, 250));
+    const Region kExpectedLayerVisibleRegion = Region(Rect(100, 30, 170, 270));
     const Region kExpectedoutputSpaceLayerVisibleRegion = Region(Rect(100, 50, 150, 250));
-    const Region kExpectedLayerCoveredRegion = Region(Rect(40, 40, 100, 260));
-    const Region kExpectedLayerVisibleNonTransparentRegion = Region(Rect(100, 40, 160, 260));
+    const Region kExpectedLayerCoveredRegion = Region(Rect(30, 30, 100, 270));
+    const Region kExpectedLayerVisibleNonTransparentRegion = Region(Rect(100, 30, 170, 270));
     const Region kExpectedLayerShadowRegion =
-            Region(Rect(40, 40, 160, 260)).subtractSelf(Rect(50, 50, 150, 250));
+            Region(Rect(30, 30, 170, 270)).subtractSelf(Rect(50, 50, 150, 250));
 
     EXPECT_THAT(mCoverageState.dirtyRegion, RegionEq(kExpectedDirtyRegion));
     EXPECT_THAT(mCoverageState.aboveCoveredLayers, RegionEq(kExpectedAboveCoveredRegion));
@@ -1923,18 +1923,24 @@ TEST_F(OutputEnsureOutputLayerIfVisibleTest, shadowRegionOnlyTest) {
     mLayer.layerFEState.shadowSettings.length = 10.0f;
 
     mCoverageState.dirtyRegion = Region(Rect(0, 0, 500, 500));
-    // Casting layer is covered by an opaque region leaving only part of its shadow to be drawn
-    mCoverageState.aboveCoveredLayers = Region(Rect(40, 40, 150, 260));
-    mCoverageState.aboveOpaqueLayers = Region(Rect(40, 40, 150, 260));
+
+    // Casting layer is covered by an opaque region leaving only
+    // right part (x > 150) of its shadow to be drawn.
+    mCoverageState.aboveCoveredLayers = Region(Rect(30, 30, 150, 270));
+    mCoverageState.aboveOpaqueLayers = Region(Rect(30, 30, 150, 270));
 
     EXPECT_CALL(mOutput, ensureOutputLayer(Eq(0u), Eq(mLayer.layerFE)))
             .WillOnce(Return(&mLayer.outputLayer));
 
     ensureOutputLayerIfVisible();
 
-    const Region kExpectedLayerVisibleRegion = Region(Rect(150, 40, 160, 260));
+    // Bottom part of the layer + shadow.
+    // original layer : 50,  50, 150, 250
+    // layer + shadow : 30,  30, 170, 270
+    // visible portion: 150, 30, 170, 270
+    const Region kExpectedLayerVisibleRegion = Region(Rect(150, 30, 170, 270));
     const Region kExpectedLayerShadowRegion =
-            Region(Rect(40, 40, 160, 260)).subtractSelf(Rect(50, 50, 150, 250));
+            Region(Rect(30, 30, 170, 270)).subtractSelf(Rect(50, 50, 150, 250));
 
     EXPECT_THAT(mLayer.outputLayerState.visibleRegion, RegionEq(kExpectedLayerVisibleRegion));
     EXPECT_THAT(mLayer.outputLayerState.shadowRegion, RegionEq(kExpectedLayerShadowRegion));
@@ -1949,8 +1955,8 @@ TEST_F(OutputEnsureOutputLayerIfVisibleTest, takesNotSoEarlyOutifLayerWithShadow
 
     mCoverageState.dirtyRegion = Region(Rect(0, 0, 500, 500));
     // Casting layer and its shadows are covered by an opaque region
-    mCoverageState.aboveCoveredLayers = Region(Rect(40, 40, 160, 260));
-    mCoverageState.aboveOpaqueLayers = Region(Rect(40, 40, 160, 260));
+    mCoverageState.aboveCoveredLayers = Region(Rect(30, 30, 170, 270));
+    mCoverageState.aboveOpaqueLayers = Region(Rect(30, 30, 170, 270));
 
     ensureOutputLayerIfVisible();
 }
@@ -4324,11 +4330,7 @@ struct OutputComposeSurfacesTest_HandlesProtectedContent : public OutputComposeS
 
 TEST_F(OutputComposeSurfacesTest_HandlesProtectedContent, ifNoProtectedContentLayers) {
     SET_FLAG_FOR_TEST(flags::protected_if_client, true);
-    if (FlagManager::getInstance().display_protected()) {
-        mOutput.mState.isProtected = true;
-    } else {
-        mOutput.mState.isSecure = true;
-    }
+    mOutput.mState.isProtected = true;
     mLayer2.mLayerFEState.hasProtectedContent = false;
     EXPECT_CALL(mRenderEngine, supportsProtectedContent()).WillRepeatedly(Return(true));
     EXPECT_CALL(*mRenderSurface, isProtected).WillOnce(Return(true));
@@ -4343,11 +4345,7 @@ TEST_F(OutputComposeSurfacesTest_HandlesProtectedContent, ifNoProtectedContentLa
 
 TEST_F(OutputComposeSurfacesTest_HandlesProtectedContent, ifNotEnabled) {
     SET_FLAG_FOR_TEST(flags::protected_if_client, true);
-    if (FlagManager::getInstance().display_protected()) {
-        mOutput.mState.isProtected = true;
-    } else {
-        mOutput.mState.isSecure = true;
-    }
+    mOutput.mState.isProtected = true;
     mLayer2.mLayerFEState.hasProtectedContent = true;
     EXPECT_CALL(mRenderEngine, supportsProtectedContent()).WillRepeatedly(Return(true));
 
@@ -4370,11 +4368,7 @@ TEST_F(OutputComposeSurfacesTest_HandlesProtectedContent, ifNotEnabled) {
 
 TEST_F(OutputComposeSurfacesTest_HandlesProtectedContent, ifAlreadyEnabledEverywhere) {
     SET_FLAG_FOR_TEST(flags::protected_if_client, true);
-    if (FlagManager::getInstance().display_protected()) {
-        mOutput.mState.isProtected = true;
-    } else {
-        mOutput.mState.isSecure = true;
-    }
+    mOutput.mState.isProtected = true;
     mLayer2.mLayerFEState.hasProtectedContent = true;
     EXPECT_CALL(mRenderEngine, supportsProtectedContent()).WillRepeatedly(Return(true));
     EXPECT_CALL(*mRenderSurface, isProtected).WillOnce(Return(true));
@@ -4388,11 +4382,7 @@ TEST_F(OutputComposeSurfacesTest_HandlesProtectedContent, ifAlreadyEnabledEveryw
 
 TEST_F(OutputComposeSurfacesTest_HandlesProtectedContent, ifAlreadyEnabledInRenderSurface) {
     SET_FLAG_FOR_TEST(flags::protected_if_client, true);
-    if (FlagManager::getInstance().display_protected()) {
-        mOutput.mState.isProtected = true;
-    } else {
-        mOutput.mState.isSecure = true;
-    }
+    mOutput.mState.isProtected = true;
     mLayer2.mLayerFEState.hasProtectedContent = true;
     EXPECT_CALL(mRenderEngine, supportsProtectedContent()).WillRepeatedly(Return(true));
     EXPECT_CALL(*mRenderSurface, isProtected).WillOnce(Return(true));
@@ -5512,11 +5502,7 @@ struct OutputUpdateProtectedContentStateTest : public testing::Test {
 
 TEST_F(OutputUpdateProtectedContentStateTest, ifProtectedContentLayerComposeByHWC) {
     SET_FLAG_FOR_TEST(flags::protected_if_client, true);
-    if (FlagManager::getInstance().display_protected()) {
-        mOutput.mState.isProtected = true;
-    } else {
-        mOutput.mState.isSecure = true;
-    }
+    mOutput.mState.isProtected = true;
     mLayer1.mLayerFEState.hasProtectedContent = false;
     mLayer2.mLayerFEState.hasProtectedContent = true;
     EXPECT_CALL(mRenderEngine, supportsProtectedContent()).WillRepeatedly(Return(true));
@@ -5528,11 +5514,7 @@ TEST_F(OutputUpdateProtectedContentStateTest, ifProtectedContentLayerComposeByHW
 
 TEST_F(OutputUpdateProtectedContentStateTest, ifProtectedContentLayerComposeByClient) {
     SET_FLAG_FOR_TEST(flags::protected_if_client, true);
-    if (FlagManager::getInstance().display_protected()) {
-        mOutput.mState.isProtected = true;
-    } else {
-        mOutput.mState.isSecure = true;
-    }
+    mOutput.mState.isProtected = true;
     mLayer1.mLayerFEState.hasProtectedContent = false;
     mLayer2.mLayerFEState.hasProtectedContent = true;
     EXPECT_CALL(mRenderEngine, supportsProtectedContent()).WillRepeatedly(Return(true));
diff --git a/services/surfaceflinger/CompositionEngine/tests/planner/CachedSetTest.cpp b/services/surfaceflinger/CompositionEngine/tests/planner/CachedSetTest.cpp
index d61d7ba574..5b33407146 100644
--- a/services/surfaceflinger/CompositionEngine/tests/planner/CachedSetTest.cpp
+++ b/services/surfaceflinger/CompositionEngine/tests/planner/CachedSetTest.cpp
@@ -1011,12 +1011,12 @@ TEST_F(CachedSetTest, addBlur) {
     EXPECT_CALL(*layerFE1,
                 prepareClientComposition(ClientCompositionTargetSettingsBlurSettingsEq(
                         compositionengine::LayerFE::ClientCompositionTargetSettings::BlurSetting::
-                                Enabled)))
+                                Disabled)))
             .WillOnce(Return(clientComp1));
     EXPECT_CALL(*layerFE2,
                 prepareClientComposition(ClientCompositionTargetSettingsBlurSettingsEq(
                         compositionengine::LayerFE::ClientCompositionTargetSettings::BlurSetting::
-                                Enabled)))
+                                Disabled)))
             .WillOnce(Return(clientComp2));
     EXPECT_CALL(*layerFE3,
                 prepareClientComposition(ClientCompositionTargetSettingsBlurSettingsEq(
diff --git a/libs/ui/DisplayIdentification.cpp b/services/surfaceflinger/Display/DisplayIdentification.cpp
similarity index 89%
rename from libs/ui/DisplayIdentification.cpp
rename to services/surfaceflinger/Display/DisplayIdentification.cpp
index 78e84fc4dc..18b54eb548 100644
--- a/libs/ui/DisplayIdentification.cpp
+++ b/services/surfaceflinger/Display/DisplayIdentification.cpp
@@ -17,6 +17,8 @@
 #undef LOG_TAG
 #define LOG_TAG "DisplayIdentification"
 
+#include "DisplayIdentification.h"
+
 #include <algorithm>
 #include <cctype>
 #include <cstdint>
@@ -26,13 +28,13 @@
 #include <string>
 #include <string_view>
 
+#include <common/FlagManager.h>
 #include <ftl/concat.h>
 #include <ftl/hash.h>
 #include <log/log.h>
-#include <ui/DisplayIdentification.h>
 #include <ui/Size.h>
 
-namespace android {
+namespace android::display {
 namespace {
 
 using byte_view = std::span<const uint8_t>;
@@ -206,9 +208,10 @@ std::optional<Edid> parseEdid(const DisplayIdentificationData& edid) {
         ALOGE("Invalid EDID: block zero S/N is truncated.");
         return {};
     }
-    const uint32_t blockZeroSerialNumber = edid[kSerialNumberOffset] +
-            (edid[kSerialNumberOffset + 1] << 8) + (edid[kSerialNumberOffset + 2] << 16) +
-            (edid[kSerialNumberOffset + 3] << 24);
+    const uint32_t blockZeroSerialNumber = static_cast<uint32_t>(edid[kSerialNumberOffset]) |
+            (static_cast<uint32_t>(edid[kSerialNumberOffset + 1]) << 8) |
+            (static_cast<uint32_t>(edid[kSerialNumberOffset + 2]) << 16) |
+            (static_cast<uint32_t>(edid[kSerialNumberOffset + 3]) << 24);
     const auto hashedBlockZeroSNOpt = blockZeroSerialNumber == 0
             ? std::nullopt
             : ftl::stable_hash(std::string_view(std::to_string(blockZeroSerialNumber)));
@@ -316,24 +319,29 @@ std::optional<Edid> parseEdid(const DisplayIdentificationData& edid) {
         view = view.subspan(kDescriptorLength);
     }
 
+    // Prefer display name instead of using product code or (integer) serial number, since the
+    // latter have been observed to change on some displays with multiple inputs. As fields are
+    // discovered to be empty, fall back to less reliable fields.
     std::string_view modelString = displayName;
 
     if (modelString.empty()) {
-        ALOGW("Invalid EDID: falling back to serial number due to missing display name.");
+        ALOGW("EDID: falling back to serial number due to missing display name.");
         modelString = descriptorBlockSerialNumber;
     }
     if (modelString.empty()) {
-        ALOGW("Invalid EDID: falling back to ASCII text due to missing serial number.");
+        ALOGW("EDID: falling back to ASCII text due to missing serial number.");
         modelString = asciiText;
     }
+
+    std::string productString;
     if (modelString.empty()) {
-        ALOGE("Invalid EDID: display name and fallback descriptors are missing.");
-        return {};
+        ALOGW("EDID: falling back to PNP + ProductID due to missing unspecified text.");
+        productString = std::string(pnpId->data()) + std::to_string(productId);
+        modelString = productString;
     }
 
-    // Hash model string instead of using product code or (integer) serial number, since the latter
-    // have been observed to change on some displays with multiple inputs. Use a stable hash instead
-    // of std::hash which is only required to be same within a single execution of a program.
+    // Use a stable hash instead of std::hash which is only required to be same within a single
+    // execution of a program.
     const uint32_t modelHash = static_cast<uint32_t>(*ftl::stable_hash(modelString));
 
     // Parse extension blocks.
@@ -394,7 +402,8 @@ std::optional<PnpId> getPnpId(uint16_t manufacturerId) {
 }
 
 std::optional<DisplayIdentificationInfo> parseDisplayIdentificationData(
-        uint8_t port, const DisplayIdentificationData& data) {
+        uint8_t port, const DisplayIdentificationData& data,
+        android::ScreenPartStatus screenPartStatus) {
     if (data.empty()) {
         ALOGI("Display identification data is empty.");
         return {};
@@ -410,16 +419,29 @@ std::optional<DisplayIdentificationInfo> parseDisplayIdentificationData(
         return {};
     }
 
-    const auto displayId = PhysicalDisplayId::fromEdid(port, edid->manufacturerId, edid->modelHash);
+    const auto displayId = FlagManager::getInstance().stable_edid_ids()
+            ? generateEdidDisplayId(*edid)
+            : PhysicalDisplayId::fromEdid(port, edid->manufacturerId, edid->modelHash);
     return DisplayIdentificationInfo{
             .id = displayId,
             .name = std::string(edid->displayName),
             .port = port,
             .deviceProductInfo = buildDeviceProductInfo(*edid),
             .preferredDetailedTimingDescriptor = edid->preferredDetailedTimingDescriptor,
+            .screenPartStatus = screenPartStatus,
     };
 }
 
+PhysicalDisplayId resolveDisplayIdCollision(PhysicalDisplayId id, uint8_t port) {
+    const uint8_t lowByte = static_cast<uint8_t>(id.value) == port ? ~port : port;
+    const uint64_t newIdValue = (id.value & ~0xFFULL) | lowByte;
+
+    ALOGI("Display ID %" PRIu64 " --> resolved to %" PRIu64 " using %" PRIu8 " as suffix.",
+          id.value, newIdValue, lowByte);
+
+    return PhysicalDisplayId::fromValue(newIdValue);
+}
+
 PhysicalDisplayId getVirtualDisplayId(uint32_t id) {
     return PhysicalDisplayId::fromEdid(0, kVirtualEdidManufacturerId, id);
 }
@@ -447,4 +469,4 @@ PhysicalDisplayId generateEdidDisplayId(const Edid& edid) {
     return PhysicalDisplayId::fromValue(id);
 }
 
-} // namespace android
+} // namespace android::display
diff --git a/libs/ui/include/ui/DisplayIdentification.h b/services/surfaceflinger/Display/DisplayIdentification.h
similarity index 84%
rename from libs/ui/include/ui/DisplayIdentification.h
rename to services/surfaceflinger/Display/DisplayIdentification.h
index 201d5e9ff5..3464ae19b7 100644
--- a/libs/ui/include/ui/DisplayIdentification.h
+++ b/services/surfaceflinger/Display/DisplayIdentification.h
@@ -16,7 +16,6 @@
 
 #pragma once
 
-#include <array>
 #include <cstdint>
 #include <optional>
 #include <string>
@@ -25,40 +24,33 @@
 
 #include <ui/DeviceProductInfo.h>
 #include <ui/DisplayId.h>
+#include <ui/ScreenPartStatus.h>
 #include <ui/Size.h>
 
 #define LEGACY_DISPLAY_TYPE_PRIMARY 0
 #define LEGACY_DISPLAY_TYPE_EXTERNAL 1
 
-namespace android {
+namespace android::display {
 
 using DisplayIdentificationData = std::vector<uint8_t>;
 
+enum class HotplugStatus {
+    Connected,
+    // This is a special workaround for the lack of headless mode. If a display is in this status,
+    // the display modes are reloaded.
+    Reconnected
+};
+
 struct DetailedTimingDescriptor {
     ui::Size pixelSizeCount;
     ui::Size physicalSizeInMm;
 };
 
-// These values must match the ones in ScreenPartStatus.aidl file in the composer HAL
-enum class ScreenPartStatus : uint8_t {
-    /**
-     * Device cannot differentiate an original screen from a replaced screen.
-     */
-    UNSUPPORTED = 0,
-    /**
-     * Device has the original screen it was manufactured with.
-     */
-    ORIGINAL = 1,
-    /**
-     * Device has a replaced screen.
-     */
-    REPLACED = 2,
-};
-
 struct DisplayIdentificationInfo {
     PhysicalDisplayId id;
     std::string name;
     uint8_t port;
+    HotplugStatus hotplugStatus = HotplugStatus::Connected;
     std::optional<DeviceProductInfo> deviceProductInfo;
     std::optional<DetailedTimingDescriptor> preferredDetailedTimingDescriptor;
     ScreenPartStatus screenPartStatus;
@@ -105,7 +97,9 @@ std::optional<Edid> parseEdid(const DisplayIdentificationData&);
 std::optional<PnpId> getPnpId(uint16_t manufacturerId);
 
 std::optional<DisplayIdentificationInfo> parseDisplayIdentificationData(
-        uint8_t port, const DisplayIdentificationData&);
+        uint8_t port, const DisplayIdentificationData&, android::ScreenPartStatus screenPartStatus);
+
+PhysicalDisplayId resolveDisplayIdCollision(PhysicalDisplayId id, uint8_t port);
 
 PhysicalDisplayId getVirtualDisplayId(uint32_t id);
 
@@ -113,4 +107,4 @@ PhysicalDisplayId getVirtualDisplayId(uint32_t id);
 // display's parsed EDID fields.
 PhysicalDisplayId generateEdidDisplayId(const Edid& edid);
 
-} // namespace android
+} // namespace android::display
diff --git a/services/surfaceflinger/Display/DisplaySnapshot.cpp b/services/surfaceflinger/Display/DisplaySnapshot.cpp
index 39607400d6..e7ef37ad87 100644
--- a/services/surfaceflinger/Display/DisplaySnapshot.cpp
+++ b/services/surfaceflinger/Display/DisplaySnapshot.cpp
@@ -27,11 +27,13 @@
 namespace android::display {
 
 DisplaySnapshot::DisplaySnapshot(PhysicalDisplayId displayId, uint8_t port,
+                                 android::ScreenPartStatus screenPartStatus,
                                  ui::DisplayConnectionType connectionType,
                                  DisplayModes&& displayModes, ui::ColorModes&& colorModes,
                                  std::optional<DeviceProductInfo>&& deviceProductInfo)
       : mDisplayId(displayId),
         mPort(port),
+        mScreenPartStatus(screenPartStatus),
         mConnectionType(connectionType),
         mDisplayModes(std::move(displayModes)),
         mColorModes(std::move(colorModes)),
diff --git a/services/surfaceflinger/Display/DisplaySnapshot.h b/services/surfaceflinger/Display/DisplaySnapshot.h
index 0030aad91e..9b58b3a625 100644
--- a/services/surfaceflinger/Display/DisplaySnapshot.h
+++ b/services/surfaceflinger/Display/DisplaySnapshot.h
@@ -21,6 +21,7 @@
 
 #include <ui/ColorMode.h>
 #include <ui/DisplayId.h>
+#include <ui/ScreenPartStatus.h>
 #include <ui/StaticDisplayInfo.h>
 
 #include "DisplayHardware/DisplayMode.h"
@@ -31,14 +32,16 @@ namespace android::display {
 // Immutable state of a physical display, captured on hotplug.
 class DisplaySnapshot {
 public:
-    DisplaySnapshot(PhysicalDisplayId, uint8_t, ui::DisplayConnectionType, DisplayModes&&,
-                    ui::ColorModes&&, std::optional<DeviceProductInfo>&&);
+    DisplaySnapshot(PhysicalDisplayId, uint8_t, android::ScreenPartStatus,
+                    ui::DisplayConnectionType, DisplayModes&&, ui::ColorModes&&,
+                    std::optional<DeviceProductInfo>&&);
 
     DisplaySnapshot(const DisplaySnapshot&) = delete;
     DisplaySnapshot(DisplaySnapshot&&) = default;
 
     PhysicalDisplayId displayId() const { return mDisplayId; }
     uint8_t port() const { return mPort; }
+    android::ScreenPartStatus screenPartStatus() const { return mScreenPartStatus; }
     ui::DisplayConnectionType connectionType() const { return mConnectionType; }
 
     std::optional<DisplayModeId> translateModeId(hal::HWConfigId) const;
@@ -54,6 +57,7 @@ public:
 private:
     const PhysicalDisplayId mDisplayId;
     const uint8_t mPort;
+    const android::ScreenPartStatus mScreenPartStatus;
     const ui::DisplayConnectionType mConnectionType;
 
     // Effectively const except in move constructor.
diff --git a/services/surfaceflinger/DisplayDevice.cpp b/services/surfaceflinger/DisplayDevice.cpp
index bad5e2e3b5..2968b37568 100644
--- a/services/surfaceflinger/DisplayDevice.cpp
+++ b/services/surfaceflinger/DisplayDevice.cpp
@@ -50,17 +50,6 @@ namespace android {
 
 namespace hal = hardware::graphics::composer::hal;
 
-namespace gui {
-inline std::string_view to_string(ISurfaceComposer::OptimizationPolicy optimizationPolicy) {
-    switch (optimizationPolicy) {
-        case ISurfaceComposer::OptimizationPolicy::optimizeForPower:
-            return "optimizeForPower";
-        case ISurfaceComposer::OptimizationPolicy::optimizeForPerformance:
-            return "optimizeForPerformance";
-    }
-}
-} // namespace gui
-
 DisplayDeviceCreationArgs::DisplayDeviceCreationArgs(
         const sp<SurfaceFlinger>& flinger, HWComposer& hwComposer, const wp<IBinder>& displayToken,
         std::shared_ptr<compositionengine::Display> compositionDisplay)
@@ -486,23 +475,28 @@ void DisplayDevice::onVrrIdle(bool idle) {
     }
 }
 
-void DisplayDevice::animateOverlay() {
+void DisplayDevice::animateRefreshRateOverlay() {
     if (mRefreshRateOverlay) {
         mRefreshRateOverlay->animate();
     }
-    if (mHdrSdrRatioOverlay) {
-        // hdr sdr ratio is designed to be on the top right of the screen,
-        // therefore, we need to re-calculate the display's width and height
-        if (mIsOrientationChanged) {
-            auto width = getWidth();
-            auto height = getHeight();
-            if (mOrientation == ui::ROTATION_90 || mOrientation == ui::ROTATION_270) {
-                std::swap(width, height);
-            }
-            mHdrSdrRatioOverlay->setViewport({width, height});
+}
+
+void DisplayDevice::animateHdrSdrRatioOverlay() {
+    if (!mHdrSdrRatioOverlay) {
+        return;
+    }
+
+    // hdr sdr ratio is designed to be on the top right of the screen,
+    // therefore, we need to re-calculate the display's width and height
+    if (mIsOrientationChanged) {
+        auto width = getWidth();
+        auto height = getHeight();
+        if (mOrientation == ui::ROTATION_90 || mOrientation == ui::ROTATION_270) {
+            std::swap(width, height);
         }
-        mHdrSdrRatioOverlay->animate();
+        mHdrSdrRatioOverlay->setViewport({width, height});
     }
+    mHdrSdrRatioOverlay->animate();
 }
 
 void DisplayDevice::adjustRefreshRate(Fps pacesetterDisplayRefreshRate) {
diff --git a/services/surfaceflinger/DisplayDevice.h b/services/surfaceflinger/DisplayDevice.h
index 7d7c8adb7b..0022e311fc 100644
--- a/services/surfaceflinger/DisplayDevice.h
+++ b/services/surfaceflinger/DisplayDevice.h
@@ -30,7 +30,6 @@
 #include <renderengine/RenderEngine.h>
 #include <system/window.h>
 #include <ui/DisplayId.h>
-#include <ui/DisplayIdentification.h>
 #include <ui/DisplayState.h>
 #include <ui/GraphicTypes.h>
 #include <ui/HdrCapabilities.h>
@@ -67,6 +66,17 @@ namespace display {
 class DisplaySnapshot;
 } // namespace display
 
+namespace gui {
+inline const char* to_string(ISurfaceComposer::OptimizationPolicy optimizationPolicy) {
+    switch (optimizationPolicy) {
+        case ISurfaceComposer::OptimizationPolicy::optimizeForPower:
+            return "optimizeForPower";
+        case ISurfaceComposer::OptimizationPolicy::optimizeForPerformance:
+            return "optimizeForPerformance";
+    }
+}
+} // namespace gui
+
 class DisplayDevice : public RefBase {
 public:
     constexpr static float sDefaultMinLumiance = 0.0;
@@ -209,7 +219,8 @@ public:
             REQUIRES(kMainThreadContext);
     void updateRefreshRateOverlayRate(Fps refreshRate, Fps renderFps, bool setByHwc = false);
     bool isRefreshRateOverlayEnabled() const { return mRefreshRateOverlay != nullptr; }
-    void animateOverlay();
+    void animateRefreshRateOverlay();
+    void animateHdrSdrRatioOverlay();
     bool onKernelTimerChanged(std::optional<DisplayModeId>, bool timerExpired);
     void onVrrIdle(bool idle);
 
diff --git a/services/surfaceflinger/DisplayHardware/AidlComposerHal.cpp b/services/surfaceflinger/DisplayHardware/AidlComposerHal.cpp
index 8ead09ca19..51388e9dde 100644
--- a/services/surfaceflinger/DisplayHardware/AidlComposerHal.cpp
+++ b/services/surfaceflinger/DisplayHardware/AidlComposerHal.cpp
@@ -28,6 +28,7 @@
 #include <common/trace.h>
 #include <fmt/core.h>
 #include <log/log.h>
+#include <ui/ScreenPartStatus.h>
 
 #include <aidl/android/hardware/graphics/composer3/BnComposerCallback.h>
 
@@ -1271,7 +1272,8 @@ Error AidlComposer::getDataspaceSaturationMatrix(Dataspace dataspace, mat4* outM
 }
 
 Error AidlComposer::getDisplayIdentificationData(Display display, uint8_t* outPort,
-                                                 std::vector<uint8_t>* outData) {
+                                                 std::vector<uint8_t>* outData,
+                                                 android::ScreenPartStatus* outScreenPartStatus) {
     AidlDisplayIdentification displayIdentification;
     const auto status =
             mAidlComposerClient->getDisplayIdentificationData(translate<int64_t>(display),
@@ -1283,6 +1285,8 @@ Error AidlComposer::getDisplayIdentificationData(Display display, uint8_t* outPo
 
     *outPort = static_cast<uint8_t>(displayIdentification.port);
     *outData = displayIdentification.data;
+    *outScreenPartStatus =
+            static_cast<android::ScreenPartStatus>(displayIdentification.screenPartStatus);
 
     return Error::NONE;
 }
@@ -1753,6 +1757,51 @@ Error AidlComposer::getLuts(Display display, const std::vector<sp<GraphicBuffer>
     return Error::NONE;
 }
 
+Error AidlComposer::getReadbackBufferAttributes(Display display,
+                                                V3_0::ReadbackBufferAttributes* outAttributes) {
+    const auto status =
+            mAidlComposerClient->getReadbackBufferAttributes(translate<int64_t>(display),
+                                                             outAttributes);
+    if (!status.isOk()) {
+        ALOGE("%s failed %s", __func__, status.getDescription().c_str());
+        return static_cast<Error>(status.getServiceSpecificError());
+    }
+    return Error::NONE;
+}
+
+Error AidlComposer::setReadbackBuffer(Display display, const sp<GraphicBuffer>& buffer,
+                                      int acquireFence) {
+    ::aidl::android::hardware::common::NativeHandle handle;
+    if (buffer.get()) {
+        handle = ::android::dupToAidl(buffer->getNativeBuffer()->handle);
+    }
+
+    ::ndk::ScopedFileDescriptor fence;
+    fence.set(acquireFence);
+    const auto status =
+            mAidlComposerClient->setReadbackBuffer(translate<int64_t>(display), handle, fence);
+
+    if (!status.isOk()) {
+        ALOGE("%s failed %s", __func__, status.getDescription().c_str());
+        return static_cast<Error>(status.getServiceSpecificError());
+    }
+
+    return Error::NONE;
+}
+
+Error AidlComposer::getReadbackBufferFence(Display display, int* outReleaseFence) {
+    ndk::ScopedFileDescriptor fence;
+    const auto status =
+            mAidlComposerClient->getReadbackBufferFence(translate<int64_t>(display), &fence);
+    if (!status.isOk()) {
+        ALOGE("%s failed %s", __func__, status.getDescription().c_str());
+        return static_cast<Error>(status.getServiceSpecificError());
+    }
+
+    *outReleaseFence = fence.release();
+    return Error::NONE;
+}
+
 ftl::Optional<std::reference_wrapper<ComposerClientWriter>> AidlComposer::getWriter(Display display)
         REQUIRES_SHARED(mMutex) {
     return mWriters.get(display);
diff --git a/services/surfaceflinger/DisplayHardware/AidlComposerHal.h b/services/surfaceflinger/DisplayHardware/AidlComposerHal.h
index b84d39a2c3..818ca0c5e2 100644
--- a/services/surfaceflinger/DisplayHardware/AidlComposerHal.h
+++ b/services/surfaceflinger/DisplayHardware/AidlComposerHal.h
@@ -20,6 +20,7 @@
 
 #include <ftl/shared_mutex.h>
 #include <ui/DisplayMap.h>
+#include <ui/ScreenPartStatus.h>
 
 #include <functional>
 #include <optional>
@@ -180,7 +181,8 @@ public:
 
     // Composer HAL 2.3
     Error getDisplayIdentificationData(Display display, uint8_t* outPort,
-                                       std::vector<uint8_t>* outData) override;
+                                       std::vector<uint8_t>* outData,
+                                       android::ScreenPartStatus* outScreenPartStatus) override;
     Error setLayerColorTransform(Display display, Layer layer, const float* matrix) override;
     Error getDisplayedContentSamplingAttributes(Display display, PixelFormat* outFormat,
                                                 Dataspace* outDataspace,
@@ -253,6 +255,11 @@ public:
     Error startHdcpNegotiation(Display, const aidl::android::hardware::drm::HdcpLevels&) override;
     Error getLuts(Display, const std::vector<sp<GraphicBuffer>>&,
                   std::vector<aidl::android::hardware::graphics::composer3::Luts>*) override;
+    Error getReadbackBufferAttributes(Display display,
+                                      V3_0::ReadbackBufferAttributes* outAttributes) override;
+    Error setReadbackBuffer(Display display, const sp<GraphicBuffer>& buffer,
+                            int acquireFence) override;
+    Error getReadbackBufferFence(Display display, int* outReleaseFence) override;
 
 private:
     // Many public functions above simply write a command into the command
diff --git a/services/surfaceflinger/DisplayHardware/ComposerHal.h b/services/surfaceflinger/DisplayHardware/ComposerHal.h
index c55893106f..76cbcb6049 100644
--- a/services/surfaceflinger/DisplayHardware/ComposerHal.h
+++ b/services/surfaceflinger/DisplayHardware/ComposerHal.h
@@ -30,6 +30,7 @@
 #include <ui/DisplayedFrameStats.h>
 #include <ui/GraphicBuffer.h>
 #include <ui/PictureProfileHandle.h>
+#include <ui/ScreenPartStatus.h>
 #include <utils/StrongPointer.h>
 
 #include "DisplayHardware/Hal.h"
@@ -48,6 +49,7 @@
 #include <aidl/android/hardware/graphics/composer3/IComposerCallback.h>
 #include <aidl/android/hardware/graphics/composer3/Luts.h>
 #include <aidl/android/hardware/graphics/composer3/OverlayProperties.h>
+#include <aidl/android/hardware/graphics/composer3/ReadbackBufferAttributes.h>
 
 #include <optional>
 
@@ -93,6 +95,7 @@ using PerFrameMetadataBlob = IComposerClient::PerFrameMetadataBlob;
 using AidlTransform = ::aidl::android::hardware::graphics::common::Transform;
 using DisplayConfiguration = V3_0::DisplayConfiguration;
 using aidl::android::hardware::graphics::common::Hdr;
+using android::ScreenPartStatus;
 
 class Composer {
 public:
@@ -234,7 +237,8 @@ public:
 
     // Composer HAL 2.3
     virtual Error getDisplayIdentificationData(Display display, uint8_t* outPort,
-                                               std::vector<uint8_t>* outData) = 0;
+                                               std::vector<uint8_t>* outData,
+                                               android::ScreenPartStatus* outScreenPartStatus) = 0;
     virtual Error setLayerColorTransform(Display display, Layer layer, const float* matrix) = 0;
     virtual Error getDisplayedContentSamplingAttributes(Display display, PixelFormat* outFormat,
                                                         Dataspace* outDataspace,
@@ -321,6 +325,11 @@ public:
                                        const aidl::android::hardware::drm::HdcpLevels& levels) = 0;
     virtual Error getLuts(Display display, const std::vector<sp<GraphicBuffer>>&,
                           std::vector<V3_0::Luts>*) = 0;
+    virtual Error getReadbackBufferAttributes(Display display,
+                                              V3_0::ReadbackBufferAttributes* outAttributes) = 0;
+    virtual Error setReadbackBuffer(Display display, const sp<GraphicBuffer>& buffer,
+                                    int acquireFence) = 0;
+    virtual Error getReadbackBufferFence(Display display, int* outReleaseFence) = 0;
 };
 
 } // namespace Hwc2
diff --git a/services/surfaceflinger/DisplayHardware/FramebufferSurface.cpp b/services/surfaceflinger/DisplayHardware/FramebufferSurface.cpp
index 748765a4e4..b40555c363 100644
--- a/services/surfaceflinger/DisplayHardware/FramebufferSurface.cpp
+++ b/services/surfaceflinger/DisplayHardware/FramebufferSurface.cpp
@@ -49,18 +49,11 @@ namespace android {
 
 using ui::Dataspace;
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
 FramebufferSurface::FramebufferSurface(HWComposer& hwc, PhysicalDisplayId displayId,
                                        const sp<IGraphicBufferProducer>& producer,
                                        const sp<IGraphicBufferConsumer>& consumer,
                                        const ui::Size& size, const ui::Size& maxSize)
       : ConsumerBase(producer, consumer),
-#else
-FramebufferSurface::FramebufferSurface(HWComposer& hwc, PhysicalDisplayId displayId,
-                                       const sp<IGraphicBufferConsumer>& consumer,
-                                       const ui::Size& size, const ui::Size& maxSize)
-      : ConsumerBase(consumer),
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
         mDisplayId(displayId),
         mMaxSize(maxSize),
         mCurrentBufferSlot(-1),
diff --git a/services/surfaceflinger/DisplayHardware/FramebufferSurface.h b/services/surfaceflinger/DisplayHardware/FramebufferSurface.h
index 6ca64a2437..bb2cec216c 100644
--- a/services/surfaceflinger/DisplayHardware/FramebufferSurface.h
+++ b/services/surfaceflinger/DisplayHardware/FramebufferSurface.h
@@ -27,8 +27,6 @@
 #include <ui/DisplayId.h>
 #include <ui/Size.h>
 
-#include <ui/DisplayIdentification.h>
-
 // ---------------------------------------------------------------------------
 namespace android {
 // ---------------------------------------------------------------------------
@@ -41,16 +39,10 @@ class HWComposer;
 
 class FramebufferSurface : public ConsumerBase, public compositionengine::DisplaySurface {
 public:
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
     FramebufferSurface(HWComposer& hwc, PhysicalDisplayId displayId,
                        const sp<IGraphicBufferProducer>& producer,
                        const sp<IGraphicBufferConsumer>& consumer, const ui::Size& size,
                        const ui::Size& maxSize);
-#else
-    FramebufferSurface(HWComposer& hwc, PhysicalDisplayId displayId,
-                       const sp<IGraphicBufferConsumer>& consumer, const ui::Size& size,
-                       const ui::Size& maxSize);
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
 
     virtual status_t beginFrame(bool mustRecompose);
     virtual status_t prepareFrame(CompositionType compositionType);
@@ -120,4 +112,3 @@ private:
 // ---------------------------------------------------------------------------
 
 #endif // ANDROID_SF_FRAMEBUFFER_SURFACE_H
-
diff --git a/services/surfaceflinger/DisplayHardware/HWC2.cpp b/services/surfaceflinger/DisplayHardware/HWC2.cpp
index fd0bf7386b..0f01ca6924 100644
--- a/services/surfaceflinger/DisplayHardware/HWC2.cpp
+++ b/services/surfaceflinger/DisplayHardware/HWC2.cpp
@@ -626,9 +626,9 @@ Error Display::getRequestedLuts(LayerLuts* outLuts,
         auto layer = getLayerById(layerIds[i]);
         if (layer) {
             auto& layerLut = tmpLuts[i];
+            std::vector<std::pair<int32_t, LutProperties>> lutOffsetsAndProperties;
             if (layerLut.luts.pfd.get() >= 0 && layerLut.luts.offsets.has_value()) {
                 const auto& offsets = layerLut.luts.offsets.value();
-                std::vector<std::pair<int32_t, LutProperties>> lutOffsetsAndProperties;
                 lutOffsetsAndProperties.reserve(offsets.size());
                 std::transform(offsets.begin(), offsets.end(), layerLut.luts.lutProperties.begin(),
                                std::back_inserter(lutOffsetsAndProperties),
@@ -637,8 +637,12 @@ Error Display::getRequestedLuts(LayerLuts* outLuts,
                 lutFileDescriptorMapper.emplace_or_replace(layer.get(),
                                                            ::android::base::unique_fd(
                                                                    layerLut.luts.pfd.release()));
+            } else if (layerLut.luts.pfd.get() < 0) {
+                outLuts->emplace_or_replace(layer.get(), lutOffsetsAndProperties);
+                lutFileDescriptorMapper.emplace_or_replace(layer.get(),
+                                                           ::android::base::unique_fd());
             } else {
-                ALOGE("getRequestedLuts: invalid luts on layer %" PRIu64 " found"
+                ALOGE("getRequestedLuts: invalid luts offsets on layer %" PRIu64 " found"
                       " on display %" PRIu64 ". pfd.get()=%d, offsets.has_value()=%d",
                       layerIds[i], mId, layerLut.luts.pfd.get(), layerLut.luts.offsets.has_value());
             }
@@ -685,6 +689,28 @@ Error Display::getLuts(const std::vector<sp<GraphicBuffer>>& buffers,
     return static_cast<Error>(error);
 }
 
+Error Display::getReadbackBufferAttributes(
+        aidl::android::hardware::graphics::composer3::ReadbackBufferAttributes* outAttributes) {
+    const auto error = mComposer.getReadbackBufferAttributes(mId, outAttributes);
+    return static_cast<Error>(error);
+}
+
+Error Display::setReadbackBuffer(const sp<GraphicBuffer>& buffer,
+                                 const android::sp<android::Fence>& acquireFence) {
+    const auto error = mComposer.setReadbackBuffer(mId, buffer, acquireFence->dup());
+    return static_cast<Error>(error);
+}
+
+Error Display::getReadbackBufferFence(android::sp<android::Fence>* outReleaseFence) {
+    int fence;
+    const auto error = mComposer.getReadbackBufferFence(mId, &fence);
+    if (error != Error::NONE) {
+        return error;
+    }
+    *outReleaseFence = sp<Fence>::make(fence);
+    return static_cast<Error>(error);
+}
+
 // For use by Device
 
 void Display::setConnected(bool connected) {
diff --git a/services/surfaceflinger/DisplayHardware/HWC2.h b/services/surfaceflinger/DisplayHardware/HWC2.h
index 3f518211c4..5b2c6446c9 100644
--- a/services/surfaceflinger/DisplayHardware/HWC2.h
+++ b/services/surfaceflinger/DisplayHardware/HWC2.h
@@ -208,6 +208,12 @@ public:
     [[nodiscard]] virtual hal::Error getLuts(
             const std::vector<android::sp<android::GraphicBuffer>>&,
             std::vector<aidl::android::hardware::graphics::composer3::Luts>*) = 0;
+
+    [[nodiscard]] virtual hal::Error getReadbackBufferAttributes(
+            aidl::android::hardware::graphics::composer3::ReadbackBufferAttributes*) = 0;
+    [[nodiscard]] virtual hal::Error setReadbackBuffer(const sp<GraphicBuffer>&,
+                                                       const android::sp<android::Fence>&) = 0;
+    [[nodiscard]] virtual hal::Error getReadbackBufferFence(android::sp<android::Fence>*) = 0;
 };
 
 namespace impl {
@@ -298,6 +304,14 @@ public:
     hal::Error getLuts(const std::vector<android::sp<android::GraphicBuffer>>&,
                        std::vector<aidl::android::hardware::graphics::composer3::Luts>*) override;
 
+    hal::Error getReadbackBufferAttributes(
+            aidl::android::hardware::graphics::composer3::ReadbackBufferAttributes* outAttributes)
+            override;
+    virtual hal::Error setReadbackBuffer(const sp<GraphicBuffer>& buffer,
+                                         const android::sp<android::Fence>& acquireFence) override;
+    virtual hal::Error getReadbackBufferFence(
+            android::sp<android::Fence>* outReleaseFence) override;
+
     // Other Display methods
     hal::HWDisplayId getId() const override { return mId; }
     bool isConnected() const override { return mIsConnected; }
diff --git a/services/surfaceflinger/DisplayHardware/HWComposer.cpp b/services/surfaceflinger/DisplayHardware/HWComposer.cpp
index 758d924a53..ae6d6f0490 100644
--- a/services/surfaceflinger/DisplayHardware/HWComposer.cpp
+++ b/services/surfaceflinger/DisplayHardware/HWComposer.cpp
@@ -115,10 +115,13 @@ void HWComposer::setCallback(HWC2::ComposerCallback& callback) {
     mComposer->registerCallback(callback);
 }
 
-bool HWComposer::getDisplayIdentificationData(hal::HWDisplayId hwcDisplayId, uint8_t* outPort,
-                                              DisplayIdentificationData* outData) const {
+bool HWComposer::getDisplayIdentificationData(
+        hal::HWDisplayId hwcDisplayId, uint8_t* outPort,
+        display::DisplayIdentificationData* outData,
+        android::ScreenPartStatus* outScreenPartStatus) const {
     const auto error = static_cast<hal::Error>(
-            mComposer->getDisplayIdentificationData(hwcDisplayId, outPort, outData));
+            mComposer->getDisplayIdentificationData(hwcDisplayId, outPort, outData,
+                                                    outScreenPartStatus));
     if (error != hal::Error::NONE) {
         if (error != hal::Error::UNSUPPORTED) {
             LOG_HWC_DISPLAY_ERROR(hwcDisplayId, to_string(error).c_str());
@@ -137,8 +140,8 @@ bool HWComposer::hasDisplayCapability(HalDisplayId displayId, DisplayCapability
     return mDisplayData.at(displayId).hwcDisplay->hasCapability(capability);
 }
 
-std::optional<DisplayIdentificationInfo> HWComposer::onHotplug(hal::HWDisplayId hwcDisplayId,
-                                                               HotplugEvent event) {
+std::optional<display::DisplayIdentificationInfo> HWComposer::onHotplug(
+        hal::HWDisplayId hwcDisplayId, HotplugEvent event) {
     switch (event) {
         case HotplugEvent::Connected:
             return onHotplugConnect(hwcDisplayId);
@@ -226,9 +229,17 @@ bool HWComposer::allocateVirtualDisplay(HalVirtualDisplayId displayId, ui::Size
 
 void HWComposer::allocatePhysicalDisplay(hal::HWDisplayId hwcDisplayId, PhysicalDisplayId displayId,
                                          uint8_t port, std::optional<ui::Size> physicalSize) {
-    LOG_ALWAYS_FATAL_IF(!mActivePorts.try_emplace(port).second,
-                        "Cannot attach display %" PRIu64 " to an already active port %" PRIu8 ".",
-                        hwcDisplayId, port);
+    // TODO: b/413414541 - turn this back to LOG_ALWAYS_FATAL_IF once the issue is resolved.
+    ALOGE_IF(!mActivePorts.try_emplace(port).second,
+             "Attaching display %" PRIu64 " to an already active port %" PRIu8 ".", hwcDisplayId,
+             port);
+
+    if (FlagManager::getInstance().stable_edid_ids()) {
+        LOG_ALWAYS_FATAL_IF(hasDisplayWithId(displayId),
+                            "Cannot attach display to HAL display %" PRIu64
+                            " with a duplicate display ID %" PRIu64 ".",
+                            hwcDisplayId, displayId.value);
+    }
 
     mPhysicalDisplayIdMap[hwcDisplayId] = displayId;
 
@@ -1073,6 +1084,33 @@ status_t HWComposer::getLuts(
     return NO_ERROR;
 }
 
+status_t HWComposer::getReadbackBufferAttributes(
+        PhysicalDisplayId displayId,
+        aidl::android::hardware::graphics::composer3::ReadbackBufferAttributes* outAttributes) {
+    RETURN_IF_INVALID_DISPLAY(displayId, BAD_INDEX);
+    auto& hwcDisplay = mDisplayData[displayId].hwcDisplay;
+    auto error = hwcDisplay->getReadbackBufferAttributes(outAttributes);
+    RETURN_IF_HWC_ERROR(error, displayId, UNKNOWN_ERROR);
+    return NO_ERROR;
+}
+
+status_t HWComposer::setReadbackBuffer(PhysicalDisplayId displayId, const sp<GraphicBuffer>& buffer,
+                                       const android::sp<android::Fence>& acquireFence) {
+    RETURN_IF_INVALID_DISPLAY(displayId, BAD_INDEX);
+    auto& hwcDisplay = mDisplayData[displayId].hwcDisplay;
+    auto error = hwcDisplay->setReadbackBuffer(buffer, acquireFence);
+    RETURN_IF_HWC_ERROR(error, displayId, UNKNOWN_ERROR);
+    return NO_ERROR;
+}
+sp<Fence> HWComposer::getReadbackBufferFence(PhysicalDisplayId displayId) {
+    RETURN_IF_INVALID_DISPLAY(displayId, Fence::NO_FENCE);
+    auto& hwcDisplay = mDisplayData[displayId].hwcDisplay;
+    sp<Fence> fence = Fence::NO_FENCE;
+    auto error = hwcDisplay->getReadbackBufferFence(&fence);
+    RETURN_IF_HWC_ERROR(error, displayId, Fence::NO_FENCE);
+    return fence;
+}
+
 const std::unordered_map<std::string, bool>& HWComposer::getSupportedLayerGenericMetadata() const {
     return mSupportedLayerGenericMetadata;
 }
@@ -1164,18 +1202,22 @@ bool HWComposer::shouldIgnoreHotplugConnect(hal::HWDisplayId hwcDisplayId, uint8
     return false;
 }
 
-std::optional<DisplayIdentificationInfo> HWComposer::onHotplugConnect(
+std::optional<display::DisplayIdentificationInfo> HWComposer::onHotplugConnect(
         hal::HWDisplayId hwcDisplayId) {
-    std::optional<DisplayIdentificationInfo> info;
+    std::optional<display::DisplayIdentificationInfo> info;
     if (const auto displayId = toPhysicalDisplayId(hwcDisplayId)) {
-        info = DisplayIdentificationInfo{.id = *displayId,
-                                         .name = std::string(),
-                                         .deviceProductInfo = std::nullopt};
+        info = display::DisplayIdentificationInfo{.id = *displayId,
+                                                  .name = std::string(),
+                                                  .hotplugStatus =
+                                                          display::HotplugStatus::Reconnected,
+                                                  .deviceProductInfo = std::nullopt};
         if (mUpdateDeviceProductInfoOnHotplugReconnect) {
             uint8_t port;
-            DisplayIdentificationData data;
-            getDisplayIdentificationData(hwcDisplayId, &port, &data);
-            if (auto newInfo = parseDisplayIdentificationData(port, data)) {
+            display::DisplayIdentificationData data;
+            android::ScreenPartStatus screenPartStatus;
+            getDisplayIdentificationData(hwcDisplayId, &port, &data, &screenPartStatus);
+            if (auto newInfo =
+                        display::parseDisplayIdentificationData(port, data, screenPartStatus)) {
                 info->deviceProductInfo = std::move(newInfo->deviceProductInfo);
                 info->preferredDetailedTimingDescriptor =
                         std::move(newInfo->preferredDetailedTimingDescriptor);
@@ -1185,9 +1227,10 @@ std::optional<DisplayIdentificationInfo> HWComposer::onHotplugConnect(
         }
     } else {
         uint8_t port;
-        DisplayIdentificationData data;
+        display::DisplayIdentificationData data;
+        android::ScreenPartStatus screenPartStatus;
         const bool hasDisplayIdentificationData =
-                getDisplayIdentificationData(hwcDisplayId, &port, &data);
+                getDisplayIdentificationData(hwcDisplayId, &port, &data, &screenPartStatus);
         if (mPhysicalDisplayIdMap.empty()) {
             mHasMultiDisplaySupport = hasDisplayIdentificationData;
             ALOGI("Switching to %s multi-display mode",
@@ -1198,10 +1241,15 @@ std::optional<DisplayIdentificationInfo> HWComposer::onHotplugConnect(
             return {};
         }
 
-        info = [this, hwcDisplayId, &port, &data, hasDisplayIdentificationData] {
+        info = [this, hwcDisplayId, &port, &data, &screenPartStatus, hasDisplayIdentificationData] {
             const bool isPrimary = !mPrimaryHwcDisplayId;
             if (mHasMultiDisplaySupport) {
-                if (const auto info = parseDisplayIdentificationData(port, data)) {
+                if (auto info =
+                            display::parseDisplayIdentificationData(port, data, screenPartStatus)) {
+                    if (FlagManager::getInstance().stable_edid_ids() &&
+                        hasDisplayWithId(info->id)) {
+                        info->id = display::resolveDisplayIdCollision(info->id, info->port);
+                    }
                     return *info;
                 }
                 ALOGE("Failed to parse identification data for display %" PRIu64, hwcDisplayId);
@@ -1211,13 +1259,24 @@ std::optional<DisplayIdentificationInfo> HWComposer::onHotplugConnect(
                 port = isPrimary ? LEGACY_DISPLAY_TYPE_PRIMARY : LEGACY_DISPLAY_TYPE_EXTERNAL;
             }
 
-            return DisplayIdentificationInfo{.id = PhysicalDisplayId::fromPort(port),
-                                             .name = isPrimary ? "Primary display"
-                                                               : "Secondary display",
-                                             .port = port,
-                                             .deviceProductInfo = std::nullopt};
+            return display::DisplayIdentificationInfo{
+                    .id = PhysicalDisplayId::fromPort(port),
+                    .name = isPrimary ? "Primary display" : "Secondary display",
+                    .port = port,
+                    .deviceProductInfo = std::nullopt,
+                    .screenPartStatus = screenPartStatus,
+            };
         }();
 
+        // Fail the hotplug if the display ID conflict could not be resolved to avoid display
+        // mixups.
+        if (FlagManager::getInstance().stable_edid_ids() && hasDisplayWithId(info->id)) {
+            ALOGE("Ignoring connection of display %" PRIu64
+                  ". Failed to resolve Display ID collision for duplicate display ID %" PRIu64 ".",
+                  hwcDisplayId, info->id.value);
+            return {};
+        }
+
         mComposer->onHotplugConnect(hwcDisplayId);
     }
 
@@ -1231,7 +1290,7 @@ std::optional<DisplayIdentificationInfo> HWComposer::onHotplugConnect(
     return info;
 }
 
-std::optional<DisplayIdentificationInfo> HWComposer::onHotplugDisconnect(
+std::optional<display::DisplayIdentificationInfo> HWComposer::onHotplugDisconnect(
         hal::HWDisplayId hwcDisplayId) {
     LOG_ALWAYS_FATAL_IF(hwcDisplayId == mPrimaryHwcDisplayId,
                         "Primary display cannot be disconnected.");
@@ -1251,17 +1310,17 @@ std::optional<DisplayIdentificationInfo> HWComposer::onHotplugDisconnect(
     // it as disconnected.
     mDisplayData.at(*displayId).hwcDisplay->setConnected(false);
     mComposer->onHotplugDisconnect(hwcDisplayId);
-    return DisplayIdentificationInfo{.id = *displayId};
+    return display::DisplayIdentificationInfo{.id = *displayId};
 }
 
-std::optional<DisplayIdentificationInfo> HWComposer::onHotplugLinkTrainingFailure(
+std::optional<display::DisplayIdentificationInfo> HWComposer::onHotplugLinkTrainingFailure(
         hal::HWDisplayId hwcDisplayId) {
     const auto displayId = toPhysicalDisplayId(hwcDisplayId);
     if (!displayId) {
         LOG_HWC_DISPLAY_ERROR(hwcDisplayId, "Invalid HWC display");
         return {};
     }
-    return DisplayIdentificationInfo{.id = *displayId};
+    return display::DisplayIdentificationInfo{.id = *displayId};
 }
 
 void HWComposer::loadCapabilities() {
@@ -1332,6 +1391,12 @@ void HWComposer::loadLayerMetadataSupport() {
     }
 }
 
+bool HWComposer::hasDisplayWithId(PhysicalDisplayId displayId) const {
+    return ftl::find_if(mPhysicalDisplayIdMap,
+                        [displayId](const auto& pair) { return pair.second == displayId; })
+            .has_value();
+}
+
 } // namespace impl
 } // namespace android
 
diff --git a/services/surfaceflinger/DisplayHardware/HWComposer.h b/services/surfaceflinger/DisplayHardware/HWComposer.h
index fcecd23bca..58ef9098e6 100644
--- a/services/surfaceflinger/DisplayHardware/HWComposer.h
+++ b/services/surfaceflinger/DisplayHardware/HWComposer.h
@@ -27,11 +27,12 @@
 #include <android-base/thread_annotations.h>
 #include <ftl/expected.h>
 #include <ftl/future.h>
-#include <ui/DisplayIdentification.h>
 #include <ui/DisplayMap.h>
 #include <ui/FenceTime.h>
 #include <ui/PictureProfileHandle.h>
 
+#include "Display/DisplayIdentification.h"
+
 // TODO(b/129481165): remove the #pragma below and fix conversion issues
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Wconversion"
@@ -130,8 +131,9 @@ public:
 
     virtual void setCallback(HWC2::ComposerCallback&) = 0;
 
-    virtual bool getDisplayIdentificationData(hal::HWDisplayId, uint8_t* outPort,
-                                              DisplayIdentificationData* outData) const = 0;
+    virtual bool getDisplayIdentificationData(
+            hal::HWDisplayId, uint8_t* outPort, display::DisplayIdentificationData* outData,
+            android::ScreenPartStatus* outScreenPartStatus) const = 0;
 
     virtual bool hasCapability(aidl::android::hardware::graphics::composer3::Capability) const = 0;
     virtual bool hasDisplayCapability(
@@ -237,7 +239,8 @@ public:
     // Returns the stable display ID of the display for which the hotplug event was received, or
     // std::nullopt if hotplug event was ignored.
     // This function is called from SurfaceFlinger.
-    virtual std::optional<DisplayIdentificationInfo> onHotplug(hal::HWDisplayId, HotplugEvent) = 0;
+    virtual std::optional<display::DisplayIdentificationInfo> onHotplug(hal::HWDisplayId,
+                                                                        HotplugEvent) = 0;
 
     // If true we'll update the DeviceProductInfo on subsequent hotplug connected events.
     // TODO(b/157555476): Remove when the framework has proper support for headless mode
@@ -331,6 +334,14 @@ public:
                                           const aidl::android::hardware::drm::HdcpLevels&) = 0;
     virtual status_t getLuts(PhysicalDisplayId, const std::vector<sp<GraphicBuffer>>&,
                              std::vector<aidl::android::hardware::graphics::composer3::Luts>*) = 0;
+
+    virtual status_t getReadbackBufferAttributes(
+            PhysicalDisplayId,
+            aidl::android::hardware::graphics::composer3::ReadbackBufferAttributes*
+                    outAttributes) = 0;
+    virtual status_t setReadbackBuffer(PhysicalDisplayId, const sp<GraphicBuffer>& buffer,
+                                       const android::sp<android::Fence>& acquireFence) = 0;
+    virtual sp<Fence> getReadbackBufferFence(PhysicalDisplayId) = 0;
 };
 
 static inline bool operator==(const android::HWComposer::DeviceRequestedChanges& lhs,
@@ -351,8 +362,9 @@ public:
 
     void setCallback(HWC2::ComposerCallback&) override;
 
-    bool getDisplayIdentificationData(hal::HWDisplayId, uint8_t* outPort,
-                                      DisplayIdentificationData* outData) const override;
+    bool getDisplayIdentificationData(
+            hal::HWDisplayId, uint8_t* outPort, display::DisplayIdentificationData* outData,
+            android::ScreenPartStatus* outScreenPartStatus) const override;
 
     bool hasCapability(aidl::android::hardware::graphics::composer3::Capability) const override;
     bool hasDisplayCapability(
@@ -439,7 +451,8 @@ public:
 
     // Events handling ---------------------------------------------------------
 
-    std::optional<DisplayIdentificationInfo> onHotplug(hal::HWDisplayId, HotplugEvent) override;
+    std::optional<display::DisplayIdentificationInfo> onHotplug(hal::HWDisplayId,
+                                                                HotplugEvent) override;
 
     bool updatesDeviceProductInfoOnHotplugReconnect() const override;
 
@@ -501,6 +514,14 @@ public:
     status_t getLuts(PhysicalDisplayId, const std::vector<sp<GraphicBuffer>>&,
                      std::vector<aidl::android::hardware::graphics::composer3::Luts>*) override;
 
+    status_t getReadbackBufferAttributes(
+            PhysicalDisplayId,
+            aidl::android::hardware::graphics::composer3::ReadbackBufferAttributes* outAttributes)
+            override;
+    status_t setReadbackBuffer(PhysicalDisplayId, const sp<GraphicBuffer>& buffer,
+                               const android::sp<android::Fence>& acquireFence) override;
+    sp<Fence> getReadbackBufferFence(PhysicalDisplayId) override;
+
     // for debugging ----------------------------------------------------------
     void dump(std::string& out) const override;
     void dumpOverlayProperties(std::string& out) const override;
@@ -546,9 +567,10 @@ private:
         hal::Vsync vsyncEnabled GUARDED_BY(vsyncEnabledLock) = hal::Vsync::DISABLE;
     };
 
-    std::optional<DisplayIdentificationInfo> onHotplugConnect(hal::HWDisplayId);
-    std::optional<DisplayIdentificationInfo> onHotplugDisconnect(hal::HWDisplayId);
-    std::optional<DisplayIdentificationInfo> onHotplugLinkTrainingFailure(hal::HWDisplayId);
+    std::optional<display::DisplayIdentificationInfo> onHotplugConnect(hal::HWDisplayId);
+    std::optional<display::DisplayIdentificationInfo> onHotplugDisconnect(hal::HWDisplayId);
+    std::optional<display::DisplayIdentificationInfo> onHotplugLinkTrainingFailure(
+            hal::HWDisplayId);
     bool shouldIgnoreHotplugConnect(hal::HWDisplayId, uint8_t port,
                                     bool hasDisplayIdentificationData) const;
 
@@ -570,6 +592,7 @@ private:
     void loadLayerMetadataSupport();
     void loadOverlayProperties();
     void loadHdrConversionCapabilities();
+    bool hasDisplayWithId(PhysicalDisplayId displayId) const;
 
     std::unordered_map<HalDisplayId, DisplayData> mDisplayData;
     ui::PhysicalDisplaySet<uint8_t> mActivePorts;
diff --git a/services/surfaceflinger/DisplayHardware/HidlComposerHal.cpp b/services/surfaceflinger/DisplayHardware/HidlComposerHal.cpp
index 5e03f30304..150e404f9b 100644
--- a/services/surfaceflinger/DisplayHardware/HidlComposerHal.cpp
+++ b/services/surfaceflinger/DisplayHardware/HidlComposerHal.cpp
@@ -34,6 +34,7 @@
 #include <hidl/HidlTransportSupport.h>
 #include <hidl/HidlTransportUtils.h>
 #include <log/log.h>
+#include <ui/ScreenPartStatus.h>
 
 #include "HWC2.h"
 #include "Hal.h"
@@ -1091,7 +1092,8 @@ Error HidlComposer::getDataspaceSaturationMatrix(Dataspace dataspace, mat4* outM
 // Composer HAL 2.3
 
 Error HidlComposer::getDisplayIdentificationData(Display display, uint8_t* outPort,
-                                                 std::vector<uint8_t>* outData) {
+                                                 std::vector<uint8_t>* outData,
+                                                 android::ScreenPartStatus*) {
     if (!mClient_2_3) {
         return Error::UNSUPPORTED;
     }
@@ -1470,6 +1472,18 @@ Error HidlComposer::getLuts(Display, const std::vector<sp<GraphicBuffer>>&,
     return Error::UNSUPPORTED;
 }
 
+Error HidlComposer::getReadbackBufferAttributes(Display, V3_0::ReadbackBufferAttributes*) {
+    return Error::UNSUPPORTED;
+}
+
+Error HidlComposer::setReadbackBuffer(Display, const sp<GraphicBuffer>&, int) {
+    return Error::UNSUPPORTED;
+}
+
+Error HidlComposer::getReadbackBufferFence(Display, int*) {
+    return Error::UNSUPPORTED;
+}
+
 Error HidlComposer::setDisplayPictureProfileId(Display, PictureProfileId) {
     return Error::UNSUPPORTED;
 }
diff --git a/services/surfaceflinger/DisplayHardware/HidlComposerHal.h b/services/surfaceflinger/DisplayHardware/HidlComposerHal.h
index d3874e4889..2c885dc22e 100644
--- a/services/surfaceflinger/DisplayHardware/HidlComposerHal.h
+++ b/services/surfaceflinger/DisplayHardware/HidlComposerHal.h
@@ -21,7 +21,6 @@
 #include <optional>
 #include <string>
 #include <unordered_map>
-#include <utility>
 #include <vector>
 
 // TODO(b/129481165): remove the #pragma below and fix conversion issues
@@ -35,6 +34,7 @@
 #include <math/mat4.h>
 #include <ui/DisplayedFrameStats.h>
 #include <ui/GraphicBuffer.h>
+#include <ui/ScreenPartStatus.h>
 #include <utils/StrongPointer.h>
 
 #include <aidl/android/hardware/graphics/composer3/Composition.h>
@@ -288,7 +288,8 @@ public:
 
     // Composer HAL 2.3
     Error getDisplayIdentificationData(Display display, uint8_t* outPort,
-                                       std::vector<uint8_t>* outData) override;
+                                       std::vector<uint8_t>* outData,
+                                       android::ScreenPartStatus* outScreenPartStatus) override;
     Error setLayerColorTransform(Display display, Layer layer, const float* matrix) override;
     Error getDisplayedContentSamplingAttributes(Display display, PixelFormat* outFormat,
                                                 Dataspace* outDataspace,
@@ -366,6 +367,11 @@ public:
     Error startHdcpNegotiation(Display, const aidl::android::hardware::drm::HdcpLevels&) override;
     Error getLuts(Display, const std::vector<sp<GraphicBuffer>>&,
                   std::vector<aidl::android::hardware::graphics::composer3::Luts>*) override;
+    Error getReadbackBufferAttributes(Display display,
+                                      V3_0::ReadbackBufferAttributes* outAttributes) override;
+    Error setReadbackBuffer(Display display, const sp<GraphicBuffer>& buffer,
+                            int acquireFence) override;
+    Error getReadbackBufferFence(Display display, int* outReleaseFence) override;
 
 private:
     class CommandWriter : public CommandWriterBase {
diff --git a/services/surfaceflinger/DisplayHardware/VirtualDisplaySurface.cpp b/services/surfaceflinger/DisplayHardware/VirtualDisplaySurface.cpp
index 56ed11f07a..b8be2b8dbb 100644
--- a/services/surfaceflinger/DisplayHardware/VirtualDisplaySurface.cpp
+++ b/services/surfaceflinger/DisplayHardware/VirtualDisplaySurface.cpp
@@ -53,11 +53,7 @@ VirtualDisplaySurface::VirtualDisplaySurface(HWComposer& hwc,
                                              const sp<IGraphicBufferProducer>& bqProducer,
                                              const sp<IGraphicBufferConsumer>& bqConsumer,
                                              const std::string& name)
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
       : ConsumerBase(bqProducer, bqConsumer),
-#else
-      : ConsumerBase(bqConsumer),
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
         mHwc(hwc),
         mVirtualIdVariant(virtualIdVariant),
         mDisplayName(name),
@@ -102,10 +98,6 @@ VirtualDisplaySurface::VirtualDisplaySurface(HWComposer& hwc,
     }
     mOutputFormat = mDefaultOutputFormat;
 
-    ConsumerBase::mName = String8::format("VDS: %s", mDisplayName.c_str());
-    mConsumer->setConsumerName(ConsumerBase::mName);
-    mConsumer->setConsumerUsageBits(GRALLOC_USAGE_HW_COMPOSER);
-    mConsumer->setDefaultBufferSize(sinkWidth, sinkHeight);
     sink->setAsyncMode(true);
     IGraphicBufferProducer::QueueBufferOutput output;
     mSource[SOURCE_SCRATCH]->connect(nullptr, NATIVE_WINDOW_API_EGL, false, &output);
@@ -115,6 +107,18 @@ VirtualDisplaySurface::VirtualDisplaySurface(HWComposer& hwc,
     }
 }
 
+void VirtualDisplaySurface::initializeConsumer() {
+    ConsumerBase::mName = String8::format("VDS: %s", mDisplayName.c_str());
+    mConsumer->setConsumerName(ConsumerBase::mName);
+    mConsumer->setConsumerUsageBits(GRALLOC_USAGE_HW_COMPOSER);
+    mConsumer->setDefaultBufferSize(mSinkBufferWidth, mSinkBufferHeight);
+}
+
+void VirtualDisplaySurface::onFirstRef() {
+    ConsumerBase::onFirstRef();
+    initializeConsumer();
+}
+
 VirtualDisplaySurface::~VirtualDisplaySurface() {
     mSource[SOURCE_SCRATCH]->disconnect(NATIVE_WINDOW_API_EGL);
 }
diff --git a/services/surfaceflinger/DisplayHardware/VirtualDisplaySurface.h b/services/surfaceflinger/DisplayHardware/VirtualDisplaySurface.h
index cb65c79152..d80b9ccf1d 100644
--- a/services/surfaceflinger/DisplayHardware/VirtualDisplaySurface.h
+++ b/services/surfaceflinger/DisplayHardware/VirtualDisplaySurface.h
@@ -16,7 +16,6 @@
 
 #pragma once
 
-#include <optional>
 #include <string>
 
 #include <compositionengine/DisplaySurface.h>
@@ -25,8 +24,6 @@
 #include <gui/IGraphicBufferProducer.h>
 #include <ui/DisplayId.h>
 
-#include <ui/DisplayIdentification.h>
-
 namespace android {
 
 class HWComposer;
@@ -94,6 +91,8 @@ public:
     // any client composition prediction.
     virtual bool supportsCompositionStrategyPrediction() const override { return false; };
 
+    void onFirstRef() override;
+
 private:
     enum Source : size_t {
         SOURCE_SINK = 0,
@@ -103,6 +102,8 @@ private:
         ftl_last = SOURCE_SCRATCH,
     };
 
+    void initializeConsumer();
+
     virtual ~VirtualDisplaySurface();
 
     //
diff --git a/services/surfaceflinger/FpsReporter.cpp b/services/surfaceflinger/FpsReporter.cpp
index a47348fbc4..3ae21c9878 100644
--- a/services/surfaceflinger/FpsReporter.cpp
+++ b/services/surfaceflinger/FpsReporter.cpp
@@ -26,7 +26,7 @@
 
 namespace android {
 
-FpsReporter::FpsReporter(frametimeline::FrameTimeline& frameTimeline, std::unique_ptr<Clock> clock)
+FpsReporter::FpsReporter(scheduler::FrameTimeline& frameTimeline, std::unique_ptr<Clock> clock)
       : mFrameTimeline(frameTimeline), mClock(std::move(clock)) {
     LOG_ALWAYS_FATAL_IF(mClock == nullptr, "Passed in null clock when constructing FpsReporter!");
 }
diff --git a/services/surfaceflinger/FpsReporter.h b/services/surfaceflinger/FpsReporter.h
index 01f1e07b26..48b3b97d73 100644
--- a/services/surfaceflinger/FpsReporter.h
+++ b/services/surfaceflinger/FpsReporter.h
@@ -23,8 +23,8 @@
 #include <unordered_map>
 
 #include "Clock.h"
-#include "FrameTimeline/FrameTimeline.h"
 #include "FrontEnd/LayerHierarchy.h"
+#include "Scheduler/FrameTimeline.h"
 #include "WpHash.h"
 
 namespace android {
@@ -34,7 +34,7 @@ class SurfaceFlinger;
 
 class FpsReporter : public IBinder::DeathRecipient {
 public:
-    FpsReporter(frametimeline::FrameTimeline& frameTimeline,
+    FpsReporter(scheduler::FrameTimeline& frameTimeline,
                 std::unique_ptr<Clock> clock = std::make_unique<SteadyClock>());
 
     // Dispatches updated layer fps values for the registered listeners
@@ -58,7 +58,7 @@ private:
         int32_t taskId;
     };
 
-    frametimeline::FrameTimeline& mFrameTimeline;
+    scheduler::FrameTimeline& mFrameTimeline;
     static const constexpr std::chrono::steady_clock::duration kMinDispatchDuration =
             std::chrono::milliseconds(500);
     std::unique_ptr<Clock> mClock;
@@ -66,4 +66,4 @@ private:
     std::unordered_map<wp<IBinder>, TrackedListener, WpHash> mListeners GUARDED_BY(mMutex);
 };
 
-} // namespace android
\ No newline at end of file
+} // namespace android
diff --git a/services/surfaceflinger/FrontEnd/LayerCreationArgs.cpp b/services/surfaceflinger/FrontEnd/LayerCreationArgs.cpp
index 97af445513..243c00cb92 100644
--- a/services/surfaceflinger/FrontEnd/LayerCreationArgs.cpp
+++ b/services/surfaceflinger/FrontEnd/LayerCreationArgs.cpp
@@ -86,7 +86,7 @@ std::string LayerCreationArgs::getDebugString() const {
     if (layerIdToMirror != UNASSIGNED_LAYER_ID) {
         stream << " layerIdToMirror=" << layerIdToMirror;
     }
-    if (layerStackToMirror != ui::INVALID_LAYER_STACK) {
+    if (layerStackToMirror != ui::UNASSIGNED_LAYER_STACK) {
         stream << " layerStackToMirror=" << layerStackToMirror.id;
     }
     return stream.str();
diff --git a/services/surfaceflinger/FrontEnd/LayerCreationArgs.h b/services/surfaceflinger/FrontEnd/LayerCreationArgs.h
index 07a5724852..73baeb0fcc 100644
--- a/services/surfaceflinger/FrontEnd/LayerCreationArgs.h
+++ b/services/surfaceflinger/FrontEnd/LayerCreationArgs.h
@@ -58,9 +58,10 @@ struct LayerCreationArgs {
     bool addToRoot = true;
     wp<IBinder> parentHandle = nullptr;
     wp<IBinder> mirrorLayerHandle = nullptr;
-    ui::LayerStack layerStackToMirror = ui::INVALID_LAYER_STACK;
+    ui::LayerStack layerStackToMirror = ui::UNASSIGNED_LAYER_STACK;
     uint32_t parentId = UNASSIGNED_LAYER_ID;
     uint32_t layerIdToMirror = UNASSIGNED_LAYER_ID;
+    uint32_t stopLayerId = UNASSIGNED_LAYER_ID;
     std::atomic<int32_t>* pendingBuffers = 0;
 };
 
diff --git a/services/surfaceflinger/FrontEnd/LayerLifecycleManager.cpp b/services/surfaceflinger/FrontEnd/LayerLifecycleManager.cpp
index d369403737..9cdc8ee6d8 100644
--- a/services/surfaceflinger/FrontEnd/LayerLifecycleManager.cpp
+++ b/services/surfaceflinger/FrontEnd/LayerLifecycleManager.cpp
@@ -55,10 +55,10 @@ void LayerLifecycleManager::addLayers(std::vector<std::unique_ptr<RequestedLayer
         mChangedLayers.push_back(newLayer.get());
         layer.parentId = linkLayer(layer.parentId, layer.id);
         layer.relativeParentId = linkLayer(layer.relativeParentId, layer.id);
-        if (layer.layerStackToMirror != ui::INVALID_LAYER_STACK) {
+        if (layer.layerStackToMirror != ui::UNASSIGNED_LAYER_STACK) {
             // Set mirror layer's default layer stack to -1 so it doesn't end up rendered on a
             // display accidentally.
-            layer.layerStack = ui::INVALID_LAYER_STACK;
+            layer.layerStack = ui::UNASSIGNED_LAYER_STACK;
 
             // if this layer is mirroring a display, then walk though all the existing root layers
             // for the layer stack and add them as children to be mirrored.
@@ -124,7 +124,7 @@ void LayerLifecycleManager::onHandlesDestroyed(
 
         layer.parentId = unlinkLayer(layer.parentId, layer.id);
         layer.relativeParentId = unlinkLayer(layer.relativeParentId, layer.id);
-        if (layer.layerStackToMirror != ui::INVALID_LAYER_STACK) {
+        if (layer.layerStackToMirror != ui::UNASSIGNED_LAYER_STACK) {
             layer.mirrorIds = unlinkLayers(layer.mirrorIds, layer.id);
             swapErase(mDisplayMirroringLayers, layer.id);
         } else {
@@ -221,7 +221,20 @@ void LayerLifecycleManager::applyTransactions(
             layer->merge(resolvedComposerState);
 
             if (layer->what & layer_state_t::eBackgroundColorChanged) {
-                if (layer->bgColorLayerId == UNASSIGNED_LAYER_ID && layer->bgColor.a != 0) {
+                RequestedLayerState* bgColorLayer = nullptr;
+                if (layer->bgColorLayerId != UNASSIGNED_LAYER_ID) {
+                    bgColorLayer = getLayerFromId(layer->bgColorLayerId);
+                    if (bgColorLayer == nullptr) {
+                        LLOG_ALWAYS_FATAL_WITH_TRACE_IF(!ignoreUnknownLayers,
+                                                        "%s Background color layer with layerid=%d "
+                                                        "not found",
+                                                        __func__, layer->bgColorLayerId);
+                        layer->bgColorLayerId = UNASSIGNED_LAYER_ID;
+                    }
+                }
+                if (bgColorLayer == nullptr && layer->bgColor.a != 0) {
+                    // Case 1: The background layer doesn't exist and the background color has a
+                    // non-zero alpha. Create a background layer.
                     LayerCreationArgs
                             backgroundLayerArgs(LayerCreationArgs::getInternalLayerId(
                                                         LayerCreationArgs::sInternalSequence++),
@@ -241,13 +254,15 @@ void LayerLifecycleManager::applyTransactions(
                     backgroundLayer->dataspace = layer->bgColorDataspace;
                     layer->bgColorLayerId = backgroundLayer->id;
                     addLayers({std::move(newLayers)});
-                } else if (layer->bgColorLayerId != UNASSIGNED_LAYER_ID && layer->bgColor.a == 0) {
-                    RequestedLayerState* bgColorLayer = getLayerFromId(layer->bgColorLayerId);
+                } else if (bgColorLayer != nullptr && layer->bgColor.a == 0) {
+                    // Case 2: The background layer exists and the background color has a zero
+                    // alpha (invisible). Destroy the background layer.
                     layer->bgColorLayerId = UNASSIGNED_LAYER_ID;
                     bgColorLayer->parentId = unlinkLayer(bgColorLayer->parentId, bgColorLayer->id);
                     onHandlesDestroyed({{bgColorLayer->id, bgColorLayer->debugName}});
-                } else if (layer->bgColorLayerId != UNASSIGNED_LAYER_ID) {
-                    RequestedLayerState* bgColorLayer = getLayerFromId(layer->bgColorLayerId);
+                } else if (bgColorLayer != nullptr && layer->bgColor.a != 0) {
+                    // Case 3: The background layer exists and the background color alpha might
+                    // have changed. Update the background layer.
                     bgColorLayer->color = layer->bgColor;
                     bgColorLayer->dataspace = layer->bgColorDataspace;
                     bgColorLayer->what |= layer_state_t::eColorChanged |
diff --git a/services/surfaceflinger/FrontEnd/LayerSnapshot.cpp b/services/surfaceflinger/FrontEnd/LayerSnapshot.cpp
index 3aa2e98e8f..53148bbab8 100644
--- a/services/surfaceflinger/FrontEnd/LayerSnapshot.cpp
+++ b/services/surfaceflinger/FrontEnd/LayerSnapshot.cpp
@@ -134,7 +134,7 @@ LayerSnapshot::LayerSnapshot(const RequestedLayerState& state,
     clientChanges = 0;
     mirrorRootPath =
             LayerHierarchy::isMirror(path.variant) ? path : LayerHierarchy::TraversalPath::ROOT;
-    reachablilty = LayerSnapshot::Reachablilty::Unreachable;
+    reachability = LayerSnapshot::Reachability::Unreachable;
     frameRateSelectionPriority = state.frameRateSelectionPriority;
     layerMetadata = state.metadata;
 }
@@ -155,6 +155,7 @@ bool LayerSnapshot::isOpaqueFormat(PixelFormat format) {
         case PIXEL_FORMAT_BGRA_8888:
         case PIXEL_FORMAT_RGBA_FP16:
         case PIXEL_FORMAT_RGBA_1010102:
+        case PIXEL_FORMAT_RGBA_10101010:
         case PIXEL_FORMAT_R_8:
             return false;
     }
@@ -179,12 +180,17 @@ bool LayerSnapshot::hasBlur() const {
     return backgroundBlurRadius > 0 || blurRegions.size() > 0;
 }
 
-bool LayerSnapshot::hasOutline() const {
+bool LayerSnapshot::hasBorderSettings() const {
     return borderSettings.strokeWidth > 0;
 }
 
+bool LayerSnapshot::hasBoxShadowSettings() const {
+    return !boxShadowSettings.boxShadows.empty();
+}
+
 bool LayerSnapshot::hasEffect() const {
-    return fillsColor() || drawShadows() || hasBlur() || hasOutline();
+    return fillsColor() || drawShadows() || hasBlur() || hasBorderSettings() ||
+            hasBoxShadowSettings();
 }
 
 bool LayerSnapshot::hasSomethingToDraw() const {
@@ -218,7 +224,7 @@ bool LayerSnapshot::isHiddenByPolicy() const {
 }
 
 bool LayerSnapshot::getIsVisible() const {
-    if (reachablilty != LayerSnapshot::Reachablilty::Reachable) {
+    if (reachability != LayerSnapshot::Reachability::Reachable) {
         return false;
     }
 
@@ -239,9 +245,9 @@ bool LayerSnapshot::getIsVisible() const {
 
 std::string LayerSnapshot::getIsVisibleReason() const {
     // not visible
-    if (reachablilty == LayerSnapshot::Reachablilty::Unreachable)
+    if (reachability == LayerSnapshot::Reachability::Unreachable)
         return "layer not reachable from root";
-    if (reachablilty == LayerSnapshot::Reachablilty::ReachableByRelativeParent)
+    if (reachability == LayerSnapshot::Reachability::ReachableByRelativeParent)
         return "layer only reachable via relative parent";
     if (isHiddenByPolicyFromParent) return "hidden by parent or layer flag";
     if (isHiddenByPolicyFromRelativeParent) return "hidden by relative parent";
@@ -257,8 +263,11 @@ std::string LayerSnapshot::getIsVisibleReason() const {
         reason << " buffer=" << externalTexture->getId() << " frame=" << frameNumber;
     if (fillsColor() || color.a > 0.0f) reason << " color{" << color << "}";
     if (drawShadows()) reason << " shadowSettings.length=" << shadowSettings.length;
-    if (hasOutline()) reason << "borderSettings=" << borderSettings.toString();
+    if (hasBoxShadowSettings())
+        reason << " boxShadowSettings.length=" << boxShadowSettings.toString();
+    if (hasBorderSettings()) reason << "borderSettings=" << borderSettings.toString();
     if (backgroundBlurRadius > 0) reason << " backgroundBlurRadius=" << backgroundBlurRadius;
+    if (backgroundBlurScale != 1.0f) reason << " backgroundBlurScale=" << backgroundBlurScale;
     if (blurRegions.size() > 0) reason << " blurRegions.size()=" << blurRegions.size();
     if (contentDirty) reason << " contentDirty";
     return reason.str();
@@ -276,7 +285,7 @@ bool LayerSnapshot::isTransformValid(const ui::Transform& t) {
 bool LayerSnapshot::hasInputInfo() const {
     return (inputInfo.token != nullptr ||
             inputInfo.inputConfig.test(gui::WindowInfo::InputConfig::NO_INPUT_CHANNEL)) &&
-            reachablilty == Reachablilty::Reachable;
+            reachability == Reachability::Reachable;
 }
 
 std::string LayerSnapshot::getDebugString() const {
@@ -341,6 +350,14 @@ std::ostream& operator<<(std::ostream& out, const LayerSnapshot& obj) {
     if (obj.edgeExtensionEffect.hasEffect()) {
         out << obj.edgeExtensionEffect;
     }
+
+    if (obj.currentHdrSdrRatio > 1.f) {
+        out << " currentHdrSdrRatio=" << obj.currentHdrSdrRatio;
+    }
+
+    if (obj.desiredHdrSdrRatio > 1.f) {
+        out << " desiredHdrSdrRatio=" << obj.desiredHdrSdrRatio;
+    }
     return out;
 }
 
@@ -418,6 +435,9 @@ void LayerSnapshot::merge(const RequestedLayerState& requested, bool forceUpdate
     if (forceUpdate || requested.what & layer_state_t::eBorderSettingsChanged) {
         borderSettings = requested.borderSettings;
     }
+    if (forceUpdate || requested.what & layer_state_t::eBoxShadowSettingsChanged) {
+        boxShadowSettings = requested.boxShadowSettings;
+    }
     if (forceUpdate || requested.what & layer_state_t::eFrameRateSelectionPriority) {
         frameRateSelectionPriority = requested.frameRateSelectionPriority;
     }
@@ -517,7 +537,8 @@ void LayerSnapshot::merge(const RequestedLayerState& requested, bool forceUpdate
                  layer_state_t::eBlurRegionsChanged | layer_state_t::eStretchChanged |
                  layer_state_t::eEdgeExtensionChanged | layer_state_t::eBorderSettingsChanged)) {
         forceClientComposition = shadowSettings.length > 0 || stretchEffect.hasEffect() ||
-                edgeExtensionEffect.hasEffect() || borderSettings.strokeWidth > 0;
+                edgeExtensionEffect.hasEffect() || borderSettings.strokeWidth > 0 ||
+                !boxShadowSettings.boxShadows.empty();
     }
 
     if (forceUpdate ||
diff --git a/services/surfaceflinger/FrontEnd/LayerSnapshot.h b/services/surfaceflinger/FrontEnd/LayerSnapshot.h
index eca9718c0c..847b06c264 100644
--- a/services/surfaceflinger/FrontEnd/LayerSnapshot.h
+++ b/services/surfaceflinger/FrontEnd/LayerSnapshot.h
@@ -76,6 +76,11 @@ struct LayerSnapshot : public compositionengine::LayerFECompositionState {
     bool contentOpaque;
     bool layerOpaqueFlagSet;
     RoundedCornerState roundedCorner;
+    // roundedCorner of the parent but in local space.
+    RoundedCornerState parentRoundedCorner;
+    // geomLayerCrop of the parent but in local space.
+    FloatRect parentGeomLayerCrop;
+
     FloatRect transformedBounds;
     Rect transformedBoundsWithoutTransparentRegion;
     bool premultipliedAlpha;
@@ -109,7 +114,7 @@ struct LayerSnapshot : public compositionengine::LayerFECompositionState {
     uint32_t touchCropId;
     gui::Uid uid = gui::Uid::INVALID;
     gui::Pid pid = gui::Pid::INVALID;
-    enum class Reachablilty : uint32_t {
+    enum class Reachability : uint32_t {
         // Can traverse the hierarchy from a root node and reach this snapshot
         Reachable,
         // Cannot traverse the hierarchy from a root node and reach this snapshot
@@ -135,7 +140,7 @@ struct LayerSnapshot : public compositionengine::LayerFECompositionState {
         // and input.
         ReachableByRelativeParent
     };
-    Reachablilty reachablilty;
+    Reachability reachability;
     // True when the surfaceDamage is recognized as a small area update.
     bool isSmallDirty = false;
 
@@ -149,7 +154,8 @@ struct LayerSnapshot : public compositionengine::LayerFECompositionState {
     bool hasBlur() const;
     bool hasBufferOrSidebandStream() const;
     bool hasEffect() const;
-    bool hasOutline() const;
+    bool hasBoxShadowSettings() const;
+    bool hasBorderSettings() const;
     bool hasSomethingToDraw() const;
     bool isContentOpaque() const;
     bool isHiddenByPolicy() const;
diff --git a/services/surfaceflinger/FrontEnd/LayerSnapshotBuilder.cpp b/services/surfaceflinger/FrontEnd/LayerSnapshotBuilder.cpp
index e3526d9de0..c96dcd5d32 100644
--- a/services/surfaceflinger/FrontEnd/LayerSnapshotBuilder.cpp
+++ b/services/surfaceflinger/FrontEnd/LayerSnapshotBuilder.cpp
@@ -438,8 +438,8 @@ void LayerSnapshotBuilder::updateSnapshots(const Args& args) {
     }
 
     for (auto& snapshot : mSnapshots) {
-        if (snapshot->reachablilty == LayerSnapshot::Reachablilty::Reachable) {
-            snapshot->reachablilty = LayerSnapshot::Reachablilty::Unreachable;
+        if (snapshot->reachability == LayerSnapshot::Reachability::Reachable) {
+            snapshot->reachability = LayerSnapshot::Reachability::Unreachable;
         }
     }
 
@@ -450,11 +450,17 @@ void LayerSnapshotBuilder::updateSnapshots(const Args& args) {
         LayerHierarchy::TraversalPath childPath =
                 root.makeChild(args.root.getLayer()->id, LayerHierarchy::Variant::Attached);
         updateSnapshotsInHierarchy(args, args.root, childPath, rootSnapshot, /*depth=*/0);
+        if (FlagManager::getInstance().stop_layer()) {
+            applyStopLayers(args.root, childPath);
+        }
     } else {
         for (auto& [childHierarchy, variant] : args.root.mChildren) {
             LayerHierarchy::TraversalPath childPath =
                     root.makeChild(childHierarchy->getLayer()->id, variant);
             updateSnapshotsInHierarchy(args, *childHierarchy, childPath, rootSnapshot, /*depth=*/0);
+            if (FlagManager::getInstance().stop_layer()) {
+                applyStopLayers(*childHierarchy, childPath);
+            }
         }
     }
 
@@ -480,7 +486,7 @@ void LayerSnapshotBuilder::updateSnapshots(const Args& args) {
     while (it < mSnapshots.end()) {
         auto& traversalPath = it->get()->path;
         const bool unreachable =
-                it->get()->reachablilty == LayerSnapshot::Reachablilty::Unreachable;
+                it->get()->reachability == LayerSnapshot::Reachability::Unreachable;
         const bool isClone = traversalPath.isClone();
         const bool layerIsDestroyed =
                 destroyedLayerIds.find(traversalPath.id) != destroyedLayerIds.end();
@@ -631,7 +637,7 @@ bool LayerSnapshotBuilder::sortSnapshotsByZ(const Args& args) {
         mSnapshots[globalZ]->globalZ = globalZ;
         /* mark unreachable snapshots as explicitly invisible */
         updateVisibility(*mSnapshots[globalZ], false);
-        if (mSnapshots[globalZ]->reachablilty == LayerSnapshot::Reachablilty::Unreachable) {
+        if (mSnapshots[globalZ]->reachability == LayerSnapshot::Reachability::Unreachable) {
             hasUnreachableSnapshots = true;
         }
         globalZ++;
@@ -655,8 +661,8 @@ void LayerSnapshotBuilder::updateRelativeState(LayerSnapshot& snapshot,
             snapshot.relativeLayerMetadata = parentSnapshot.relativeLayerMetadata;
         }
     }
-    if (snapshot.reachablilty == LayerSnapshot::Reachablilty::Unreachable) {
-        snapshot.reachablilty = LayerSnapshot::Reachablilty::ReachableByRelativeParent;
+    if (snapshot.reachability == LayerSnapshot::Reachability::Unreachable) {
+        snapshot.reachability = LayerSnapshot::Reachability::ReachableByRelativeParent;
     }
 }
 
@@ -711,6 +717,13 @@ void LayerSnapshotBuilder::resetRelativeState(LayerSnapshot& snapshot) {
     snapshot.relativeLayerMetadata.mMap.clear();
 }
 
+int multiplyAlpha(int color, float alpha) {
+    uint32_t c = static_cast<uint32_t>(color);
+    float scaledAlpha = alpha * (c >> 24) / 255.0f;
+    uint32_t a = static_cast<uint32_t>(scaledAlpha * 255 + 0.5f);
+    return static_cast<int32_t>((c & ~0xff000000) | (a << 24));
+}
+
 void LayerSnapshotBuilder::updateSnapshot(LayerSnapshot& snapshot, const Args& args,
                                           const RequestedLayerState& requested,
                                           const LayerSnapshot& parentSnapshot,
@@ -723,7 +736,7 @@ void LayerSnapshotBuilder::updateSnapshot(LayerSnapshot& snapshot, const Args& a
              RequestedLayerState::Changes::FrameRate | RequestedLayerState::Changes::GameMode);
     snapshot.changes |= parentChanges;
     if (args.displayChanges) snapshot.changes |= RequestedLayerState::Changes::Geometry;
-    snapshot.reachablilty = LayerSnapshot::Reachablilty::Reachable;
+    snapshot.reachability = LayerSnapshot::Reachability::Reachable;
     snapshot.clientChanges |= (parentSnapshot.clientChanges & layer_state_t::AFFECTS_CHILDREN);
     // mark the content as dirty if the parent state changes can dirty the child's content (for
     // example alpha)
@@ -781,7 +794,7 @@ void LayerSnapshotBuilder::updateSnapshot(LayerSnapshot& snapshot, const Args& a
         // Display mirrors are always placed in a VirtualDisplay so we never want to capture layers
         // marked as skip capture
         snapshot.handleSkipScreenshotFlag = parentSnapshot.handleSkipScreenshotFlag ||
-                (requested.layerStackToMirror != ui::INVALID_LAYER_STACK);
+                (requested.layerStackToMirror != ui::UNASSIGNED_LAYER_STACK);
     }
 
     if (forceUpdate || snapshot.clientChanges & layer_state_t::eAlphaChanged) {
@@ -903,11 +916,16 @@ void LayerSnapshotBuilder::updateSnapshot(LayerSnapshot& snapshot, const Args& a
 
     if (forceUpdate ||
         snapshot.clientChanges &
-                (layer_state_t::eBackgroundBlurRadiusChanged | layer_state_t::eBlurRegionsChanged |
+                (layer_state_t::eBackgroundBlurRadiusChanged |
+                 layer_state_t::eBackgroundBlurScaleChanged |
+                 layer_state_t::eBlurRegionsChanged |
                  layer_state_t::eAlphaChanged)) {
         snapshot.backgroundBlurRadius = args.supportsBlur
                 ? static_cast<int>(parentSnapshot.color.a * (float)requested.backgroundBlurRadius)
                 : 0;
+        snapshot.backgroundBlurScale = args.supportsBlur
+                ? requested.backgroundBlurScale
+                : 1.0f;
         snapshot.blurRegions = requested.blurRegions;
         for (auto& region : snapshot.blurRegions) {
             region.alpha = region.alpha * snapshot.color.a;
@@ -935,16 +953,24 @@ void LayerSnapshotBuilder::updateSnapshot(LayerSnapshot& snapshot, const Args& a
         updateShadows(snapshot, requested, args.globalShadowSettings);
     }
 
+    if (forceUpdate ||
+        snapshot.clientChanges &
+                (layer_state_t::eBoxShadowSettingsChanged | layer_state_t::eAlphaChanged)) {
+        snapshot.boxShadowSettings = requested.boxShadowSettings;
+        for (gui::BoxShadowSettings::BoxShadowParams& params :
+             snapshot.boxShadowSettings.boxShadows) {
+            params.color = multiplyAlpha(params.color, snapshot.alpha);
+        }
+    }
+
     if (forceUpdate ||
         snapshot.clientChanges &
                 (layer_state_t::eBorderSettingsChanged | layer_state_t::eAlphaChanged)) {
         snapshot.borderSettings = requested.borderSettings;
 
         // Multiply outline alpha by snapshot alpha.
-        uint32_t c = static_cast<uint32_t>(snapshot.borderSettings.color);
-        float alpha = snapshot.alpha * (c >> 24) / 255.0f;
-        uint32_t a = static_cast<uint32_t>(alpha * 255 + 0.5f);
-        snapshot.borderSettings.color = static_cast<int32_t>((c & ~0xff000000) | (a << 24));
+        snapshot.borderSettings.color =
+                multiplyAlpha(snapshot.borderSettings.color, snapshot.alpha);
     }
 
     if (forceUpdate ||
@@ -956,7 +982,8 @@ void LayerSnapshotBuilder::updateSnapshot(LayerSnapshot& snapshot, const Args& a
     // computed snapshot properties
     snapshot.forceClientComposition = snapshot.shadowSettings.length > 0 ||
             snapshot.stretchEffect.hasEffect() || snapshot.edgeExtensionEffect.hasEffect() ||
-            snapshot.borderSettings.strokeWidth > 0;
+            snapshot.borderSettings.strokeWidth > 0 ||
+            !snapshot.boxShadowSettings.boxShadows.empty();
 
     snapshot.contentOpaque = snapshot.isContentOpaque();
     snapshot.isOpaque = snapshot.contentOpaque && !snapshot.roundedCorner.hasRoundedCorners() &&
@@ -1026,6 +1053,8 @@ void LayerSnapshotBuilder::updateRoundedCorner(LayerSnapshot& snapshot,
     } else {
         snapshot.roundedCorner.radius = snapshot.roundedCorner.requestedRadius;
     }
+
+    snapshot.parentRoundedCorner = parentRoundedCorner;
 }
 
 /**
@@ -1112,6 +1141,9 @@ void LayerSnapshotBuilder::updateLayerBounds(LayerSnapshot& snapshot,
                                                         requested.getTransparentRegion());
         snapshot.cursorFrame = snapshot.geomLayerTransform.transform(bounds);
     }
+
+    snapshot.parentGeomLayerCrop =
+            snapshot.localTransform.inverse().transform(parentSnapshot.geomLayerCrop);
 }
 
 void LayerSnapshotBuilder::updateShadows(LayerSnapshot& snapshot, const RequestedLayerState&,
@@ -1381,4 +1413,98 @@ void LayerSnapshotBuilder::updateTouchableRegionCrop(const Args& args) {
     }
 }
 
+// Apply stop layers to the hierarchy.
+//
+// If layer X specifies stop layer Y, then any layer within X's subhierarchy that is z-ordered
+// above Y is hidden. The stop layer itself, layer Y, is also hidden.
+//
+// This works by traversing the hierarchy in z-order. When a layer that specifies a stop layer is
+// encountered, the specified stop layer is pushed to the stopLayer stack, the subhierarchy is
+// traversed, then the stop layer is popped from the stack. If a layer whose id is stored in the
+// stop layer stack is encountered during traversal, it is added to the activeStopLayers set. Any
+// layer visited while the activeStopLayer set is non-empty is hidden. When an element is popped
+// from the stopLayer stack, any active stop layers that are no longer in the stopLayer stack are
+// removed from the activeStopLayers set.
+void LayerSnapshotBuilder::applyStopLayers(const LayerHierarchy& hierarchy,
+                                           const LayerHierarchy::TraversalPath& traversalPath) {
+    ftl::SmallVector<uint32_t, 5> stopLayers;
+    ftl::SmallVector<uint32_t, 5> activeStopLayers;
+    applyStopLayersInternal(hierarchy, traversalPath, stopLayers, activeStopLayers);
+}
+
+void LayerSnapshotBuilder::applyStopLayersInternal(
+        const LayerHierarchy& hierarchy, const LayerHierarchy::TraversalPath& traversalPath,
+        ftl::SmallVector<uint32_t, 5>& stopLayers,
+        ftl::SmallVector<uint32_t, 5>& activeStopLayers) {
+    const RequestedLayerState* layer = hierarchy.getLayer();
+
+    // Push to the stopLayer stack.
+    if (layer->stopLayerId != UNASSIGNED_LAYER_ID) {
+        stopLayers.push_back(layer->stopLayerId);
+    }
+
+    // Hide this layer if the activeStopLayers set is non-empty.
+    if (!activeStopLayers.empty()) {
+        LayerSnapshot* snapshot = getSnapshot(traversalPath);
+        snapshot->isHiddenByPolicyFromParent = true;
+    }
+
+    // Traverse z-ordered below children before potentially activating this layer as a stop layer.
+    auto childIt = hierarchy.mChildren.begin();
+    while (childIt != hierarchy.mChildren.end()) {
+        auto& [childHierarchy, childVariant] = *childIt;
+        if (childHierarchy->getLayer()->z >= 0) {
+            break;
+        }
+        childIt++;
+
+        LayerHierarchy::TraversalPath childTraversalPath =
+                traversalPath.makeChild(childHierarchy->getLayer()->id, childVariant);
+        if (childTraversalPath.detached) {
+            continue;
+        }
+
+        applyStopLayersInternal(*childHierarchy, childTraversalPath, stopLayers, activeStopLayers);
+    }
+
+    // Activate this layer as a stop layer if it's in the stopLayers stack.
+    bool isStopLayer =
+            std::find(stopLayers.begin(), stopLayers.end(), layer->id) != stopLayers.end();
+    if (isStopLayer) {
+        activeStopLayers.push_back(layer->id);
+        LayerSnapshot* snapshot = getSnapshot(traversalPath);
+        snapshot->isHiddenByPolicyFromParent = true;
+    }
+
+    // Traverse z-ordered above children.
+    while (childIt != hierarchy.mChildren.end()) {
+        auto& [childHierarchy, childVariant] = *childIt++;
+
+        LayerHierarchy::TraversalPath childTraversalPath =
+                traversalPath.makeChild(childHierarchy->getLayer()->id, childVariant);
+        if (childTraversalPath.detached) {
+            continue;
+        }
+
+        applyStopLayersInternal(*childHierarchy, childTraversalPath, stopLayers, activeStopLayers);
+    }
+
+    // Pop from the stopLayer stack and remove active stop layers from the activeStopLayers set
+    // if necessary.
+    if (layer->stopLayerId != UNASSIGNED_LAYER_ID) {
+        stopLayers.pop_back();
+
+        auto it = activeStopLayers.begin();
+        while (it != activeStopLayers.end()) {
+            bool stopLayerNoLongerActive =
+                    std::find(stopLayers.begin(), stopLayers.end(), *it) == stopLayers.end();
+            if (stopLayerNoLongerActive) {
+                activeStopLayers.unstable_erase(it);
+            } else {
+                it++;
+            }
+        }
+    }
+}
+
 } // namespace android::surfaceflinger::frontend
diff --git a/services/surfaceflinger/FrontEnd/LayerSnapshotBuilder.h b/services/surfaceflinger/FrontEnd/LayerSnapshotBuilder.h
index 94b7e5fa5a..385fdc796d 100644
--- a/services/surfaceflinger/FrontEnd/LayerSnapshotBuilder.h
+++ b/services/surfaceflinger/FrontEnd/LayerSnapshotBuilder.h
@@ -117,9 +117,6 @@ private:
     static void resetRelativeState(LayerSnapshot& snapshot);
     static void updateRoundedCorner(LayerSnapshot& snapshot, const RequestedLayerState& layerState,
                                     const LayerSnapshot& parentSnapshot, const Args& args);
-    static bool extensionEdgeSharedWithParent(LayerSnapshot& snapshot,
-                                              const RequestedLayerState& requested,
-                                              const LayerSnapshot& parentSnapshot);
     static void updateBoundsForEdgeExtension(LayerSnapshot& snapshot);
     void updateLayerBounds(LayerSnapshot& snapshot, const RequestedLayerState& layerState,
                            const LayerSnapshot& parentSnapshot, uint32_t displayRotationFlags);
@@ -139,6 +136,11 @@ private:
                                           const Args& args, bool* outChildHasValidFrameRate);
     void updateTouchableRegionCrop(const Args& args);
 
+    void applyStopLayers(const LayerHierarchy&, const LayerHierarchy::TraversalPath&);
+    void applyStopLayersInternal(const LayerHierarchy&, const LayerHierarchy::TraversalPath&,
+                                 ftl::SmallVector<uint32_t, 5>& stopLayers,
+                                 ftl::SmallVector<uint32_t, 5>& activeStopLayers);
+
     std::unordered_map<LayerHierarchy::TraversalPath, LayerSnapshot*,
                        LayerHierarchy::TraversalPathHash>
             mPathToSnapshot;
diff --git a/services/surfaceflinger/FrontEnd/RequestedLayerState.cpp b/services/surfaceflinger/FrontEnd/RequestedLayerState.cpp
index 621fd6c00e..d32a53ed77 100644
--- a/services/surfaceflinger/FrontEnd/RequestedLayerState.cpp
+++ b/services/surfaceflinger/FrontEnd/RequestedLayerState.cpp
@@ -57,6 +57,7 @@ RequestedLayerState::RequestedLayerState(const LayerCreationArgs& args)
         ownerPid(args.ownerPid),
         parentId(args.parentId),
         layerIdToMirror(args.layerIdToMirror),
+        stopLayerId(args.stopLayerId),
         pendingBuffers(args.pendingBuffers) {
     layerId = static_cast<int32_t>(args.sequence);
     changes |= RequestedLayerState::Changes::Created;
@@ -73,7 +74,7 @@ RequestedLayerState::RequestedLayerState(const LayerCreationArgs& args)
     }
     if (layerIdToMirror != UNASSIGNED_LAYER_ID) {
         changes |= RequestedLayerState::Changes::Mirror;
-    } else if (args.layerStackToMirror != ui::INVALID_LAYER_STACK) {
+    } else if (args.layerStackToMirror != ui::UNASSIGNED_LAYER_STACK) {
         layerStackToMirror = args.layerStackToMirror;
         changes |= RequestedLayerState::Changes::Mirror;
     }
@@ -119,7 +120,6 @@ RequestedLayerState::RequestedLayerState(const LayerCreationArgs& args)
     bufferData = std::make_shared<BufferData>();
     bufferData->frameNumber = 0;
     bufferData->acquireFence = sp<Fence>::make(-1);
-    acquireFenceTime = std::make_shared<FenceTime>(bufferData->acquireFence);
     colorSpaceAgnostic = false;
     frameRateSelectionPriority = Layer::PRIORITY_UNSET;
     shadowRadius = 0.f;
@@ -216,19 +216,18 @@ void RequestedLayerState::merge(const ResolvedComposerState& resolvedComposerSta
                     frameNumberChanged ? bufferData->frameNumber : oldFramenumber + 1;
             bufferData->frameNumber = frameNumber;
 
-            if ((barrierProducerId > bufferData->producerId) ||
-                ((barrierProducerId == bufferData->producerId) &&
-                 (barrierFrameNumber > bufferData->frameNumber))) {
-                ALOGE("Out of order buffers detected for %s producedId=%d frameNumber=%" PRIu64
+            if (isFrameBarrierNewer(barrierProducerId, barrierFrameNumber, bufferData->producerId,
+                                    bufferData->frameNumber)) {
+                ALOGE("Out-of-order buffers detected for %s producedId=%d frameNumber=%" PRIu64
                       " -> producedId=%d frameNumber=%" PRIu64,
                       getDebugString().c_str(), barrierProducerId, barrierFrameNumber,
                       bufferData->producerId, frameNumber);
                 TransactionTraceWriter::getInstance().invoke("out_of_order_buffers_",
                                                              /*overwrite=*/false);
+            } else {
+                barrierProducerId = bufferData->producerId;
+                barrierFrameNumber = bufferData->frameNumber;
             }
-
-            barrierProducerId = std::max(bufferData->producerId, barrierProducerId);
-            barrierFrameNumber = std::max(bufferData->frameNumber, barrierFrameNumber);
         }
 
         const bool newBufferFormatOpaque = LayerSnapshot::isOpaqueFormat(
@@ -359,6 +358,11 @@ void RequestedLayerState::merge(const ResolvedComposerState& resolvedComposerSta
         changes |= RequestedLayerState::Changes::Geometry;
     }
 
+    if (clientState.what & layer_state_t::eStopLayerChanged) {
+        stopLayerId = resolvedComposerState.stopLayerId;
+        changes |= RequestedLayerState::Changes::Visibility;
+    }
+
     // We can't just check requestedTransform here because LayerSnapshotBuilder uses
     // getTransform which reads destinationFrame or buffer dimensions.
     // Display rotation does not affect validity so just use ROT_0.
@@ -630,10 +634,7 @@ bool RequestedLayerState::isSimpleBufferUpdate(const layer_state_t& s) const {
     const uint64_t deniedFlags = layer_state_t::eProducerDisconnect | layer_state_t::eLayerChanged |
             layer_state_t::eRelativeLayerChanged | layer_state_t::eTransparentRegionChanged |
             layer_state_t::eBlurRegionsChanged | layer_state_t::eLayerStackChanged |
-            layer_state_t::eReparent |
-            (FlagManager::getInstance().latch_unsignaled_with_auto_refresh_changed()
-                     ? 0
-                     : (layer_state_t::eAutoRefreshChanged | layer_state_t::eFlagsChanged));
+            layer_state_t::eReparent;
     if (s.what & deniedFlags) {
         SFTRACE_FORMAT_INSTANT("%s: false [has denied flags 0x%" PRIx64 "]", __func__,
                                s.what & deniedFlags);
@@ -645,7 +646,8 @@ bool RequestedLayerState::isSimpleBufferUpdate(const layer_state_t& s) const {
             layer_state_t::eColorTransformChanged | layer_state_t::eBackgroundColorChanged |
             layer_state_t::eMatrixChanged | layer_state_t::eCornerRadiusChanged |
             layer_state_t::eClientDrawnCornerRadiusChanged |
-            layer_state_t::eBackgroundBlurRadiusChanged | layer_state_t::eBufferTransformChanged |
+            layer_state_t::eBackgroundBlurRadiusChanged |
+            layer_state_t::eBackgroundBlurScaleChanged | layer_state_t::eBufferTransformChanged |
             layer_state_t::eTransformToDisplayInverseChanged | layer_state_t::eCropChanged |
             layer_state_t::eDataspaceChanged | layer_state_t::eHdrMetadataChanged |
             layer_state_t::eSidebandStreamChanged | layer_state_t::eColorSpaceAgnosticChanged |
@@ -655,9 +657,7 @@ bool RequestedLayerState::isSimpleBufferUpdate(const layer_state_t& s) const {
             layer_state_t::eDestinationFrameChanged | layer_state_t::eDimmingEnabledChanged |
             layer_state_t::eExtendedRangeBrightnessChanged |
             layer_state_t::eDesiredHdrHeadroomChanged | layer_state_t::eLutsChanged |
-            (FlagManager::getInstance().latch_unsignaled_with_auto_refresh_changed()
-                     ? layer_state_t::eFlagsChanged
-                     : 0);
+            layer_state_t::eFlagsChanged;
     if (changedFlags & deniedChanges) {
         SFTRACE_FORMAT_INSTANT("%s: false [has denied changes flags 0x%" PRIx64 "]", __func__,
                                changedFlags & deniedChanges);
diff --git a/services/surfaceflinger/FrontEnd/RequestedLayerState.h b/services/surfaceflinger/FrontEnd/RequestedLayerState.h
index b8310beab5..065f569754 100644
--- a/services/surfaceflinger/FrontEnd/RequestedLayerState.h
+++ b/services/surfaceflinger/FrontEnd/RequestedLayerState.h
@@ -121,14 +121,14 @@ struct RequestedLayerState : layer_state_t {
     bool potentialCursor{false};
     bool protectedByApp{false}; // application requires protected path to external sink
     ui::Transform requestedTransform;
-    std::shared_ptr<FenceTime> acquireFenceTime;
     std::shared_ptr<renderengine::ExternalTexture> externalTexture;
     gui::GameMode gameMode;
     scheduler::LayerInfo::FrameRate requestedFrameRate;
     uint32_t parentId = UNASSIGNED_LAYER_ID;
     uint32_t relativeParentId = UNASSIGNED_LAYER_ID;
     uint32_t layerIdToMirror = UNASSIGNED_LAYER_ID;
-    ui::LayerStack layerStackToMirror = ui::INVALID_LAYER_STACK;
+    uint32_t stopLayerId = UNASSIGNED_LAYER_ID;
+    ui::LayerStack layerStackToMirror = ui::UNASSIGNED_LAYER_STACK;
     uint32_t touchCropId = UNASSIGNED_LAYER_ID;
     uint32_t bgColorLayerId = UNASSIGNED_LAYER_ID;
     uint64_t barrierFrameNumber = 0;
diff --git a/services/surfaceflinger/Jank/JankTracker.h b/services/surfaceflinger/Jank/JankTracker.h
index 5917358797..2c58eebca2 100644
--- a/services/surfaceflinger/Jank/JankTracker.h
+++ b/services/surfaceflinger/Jank/JankTracker.h
@@ -25,9 +25,9 @@
 #include <utils/Mutex.h>
 
 namespace android {
-namespace frametimeline {
+namespace scheduler {
 class FrameTimelineTest;
-}
+} // namespace scheduler
 
 /**
  * JankTracker maintains a backlog of frame jank classification and manages and notififies any
@@ -52,7 +52,7 @@ protected:
     static std::vector<gui::JankData> getCollectedJankDataForTesting(int32_t layerId);
     static void clearAndStopCollectingAllJankDataForTesting();
 
-    friend class frametimeline::FrameTimelineTest;
+    friend class scheduler::FrameTimelineTest;
 
 private:
     JankTracker() {}
diff --git a/services/surfaceflinger/Layer.cpp b/services/surfaceflinger/Layer.cpp
index 2e312827f2..479f74a630 100644
--- a/services/surfaceflinger/Layer.cpp
+++ b/services/surfaceflinger/Layer.cpp
@@ -64,12 +64,12 @@
 
 #include "DisplayDevice.h"
 #include "DisplayHardware/HWComposer.h"
-#include "FrameTimeline/FrameTimeline.h"
 #include "FrameTracer/FrameTracer.h"
 #include "FrontEnd/LayerCreationArgs.h"
 #include "FrontEnd/LayerHandle.h"
 #include "Layer.h"
 #include "LayerProtoHelper.h"
+#include "Scheduler/FrameTimeline.h"
 #include "SurfaceFlinger.h"
 #include "TimeStats/TimeStats.h"
 #include "TransactionCallbackInvoker.h"
@@ -128,7 +128,7 @@ using gui::LayerMetadata;
 using gui::WindowInfo;
 using ui::Size;
 
-using PresentState = frametimeline::SurfaceFrame::PresentState;
+using PresentState = scheduler::SurfaceFrame::PresentState;
 
 Layer::Layer(const surfaceflinger::LayerCreationArgs& args)
       : sequence(args.sequence),
@@ -143,9 +143,7 @@ Layer::Layer(const surfaceflinger::LayerCreationArgs& args)
     mDrawingState.transform.set(0, 0);
     mDrawingState.frameNumber = 0;
     mDrawingState.previousFrameNumber = 0;
-    mDrawingState.barrierFrameNumber = 0;
     mDrawingState.producerId = 0;
-    mDrawingState.barrierProducerId = 0;
     mDrawingState.bufferTransform = 0;
     mDrawingState.transformToDisplayInverse = false;
     mDrawingState.acquireFence = sp<Fence>::make(-1);
@@ -186,11 +184,11 @@ Layer::~Layer() {
     mFlinger->onLayerDestroyed(this);
 
     const auto currentTime = std::chrono::steady_clock::now();
-    if (mBufferInfo.mTimeSinceDataspaceUpdate > std::chrono::steady_clock::time_point::min()) {
-        mFlinger->mLayerEvents.emplace_back(mOwnerUid, getSequence(), mBufferInfo.mDataspace,
-                                            std::chrono::duration_cast<std::chrono::milliseconds>(
-                                                    currentTime -
-                                                    mBufferInfo.mTimeSinceDataspaceUpdate));
+    if (mLastLayerEvent.has_value() &&
+        mTimeSinceLayerEventsUpdate > std::chrono::steady_clock::time_point::min()) {
+        mLastLayerEvent->timeSinceLastEvent = std::chrono::duration_cast<std::chrono::milliseconds>(
+                currentTime - mTimeSinceLayerEventsUpdate);
+        mFlinger->mLayerEvents.emplace_back(mLastLayerEvent.value());
     }
 
     if (mDrawingState.sidebandStream != nullptr) {
@@ -450,15 +448,15 @@ void Layer::setFrameTimelineVsyncForBufferlessTransaction(const FrameTimelineInf
     setFrameTimelineVsyncForSkippedFrames(info, postTime, mTransactionName, gameMode);
 }
 
-void Layer::addSurfaceFrameDroppedForBuffer(
-        std::shared_ptr<frametimeline::SurfaceFrame>& surfaceFrame, nsecs_t dropTime) {
+void Layer::addSurfaceFrameDroppedForBuffer(std::shared_ptr<scheduler::SurfaceFrame>& surfaceFrame,
+                                            nsecs_t dropTime) {
     surfaceFrame->setDropTime(dropTime);
     surfaceFrame->setPresentState(PresentState::Dropped);
     mFlinger->mFrameTimeline->addSurfaceFrame(surfaceFrame);
 }
 
 void Layer::addSurfaceFramePresentedForBuffer(
-        std::shared_ptr<frametimeline::SurfaceFrame>& surfaceFrame, nsecs_t acquireFenceTime,
+        std::shared_ptr<scheduler::SurfaceFrame>& surfaceFrame, nsecs_t acquireFenceTime,
         nsecs_t currentLatchTime) REQUIRES(mFlinger->mStateLock) {
     surfaceFrame->setAcquireFenceTime(acquireFenceTime);
     surfaceFrame->setPresentState(PresentState::Presented, mLastLatchTime);
@@ -466,7 +464,7 @@ void Layer::addSurfaceFramePresentedForBuffer(
     updateLastLatchTime(currentLatchTime);
 }
 
-std::shared_ptr<frametimeline::SurfaceFrame> Layer::createSurfaceFrameForTransaction(
+std::shared_ptr<scheduler::SurfaceFrame> Layer::createSurfaceFrameForTransaction(
         const FrameTimelineInfo& info, nsecs_t postTime, gui::GameMode gameMode)
         REQUIRES(mFlinger->mStateLock) {
     auto surfaceFrame =
@@ -488,7 +486,7 @@ std::shared_ptr<frametimeline::SurfaceFrame> Layer::createSurfaceFrameForTransac
     return surfaceFrame;
 }
 
-std::shared_ptr<frametimeline::SurfaceFrame> Layer::createSurfaceFrameForBuffer(
+std::shared_ptr<scheduler::SurfaceFrame> Layer::createSurfaceFrameForBuffer(
         const FrameTimelineInfo& info, nsecs_t queueTime, std::string debugName,
         gui::GameMode gameMode) REQUIRES(mFlinger->mStateLock) {
     auto surfaceFrame =
@@ -644,9 +642,16 @@ void Layer::clearFrameStats() {
 void Layer::getFrameStats(FrameStats* outStats) const {
     if (FlagManager::getInstance().deprecate_frame_tracker()) {
         if (auto ftl = getTimeline()) {
-            float fps = ftl->get().computeFps({getSequence()});
+            nsecs_t refreshPeriod =
+                    Fps::fromValue(ftl->get().computeFps({getSequence()})).getPeriodNsecs();
+            // FPS computation requires some number of layer updates before the calculation can be
+            // made. If not enough frames are available return the projected FPS based on the
+            // pacesetter display's native refresh rate.
+            if (!refreshPeriod) {
+                refreshPeriod = mFlinger->mScheduler->getPacesetterVsyncPeriod().ns();
+            }
             ftl->get().generateFrameStats(getSequence(), mFrameStatsHistorySize, outStats);
-            outStats->refreshPeriodNano = Fps::fromValue(fps).getPeriodNsecs();
+            outStats->refreshPeriodNano = refreshPeriod;
         }
     } else {
         mDeprecatedFrameTracker.getStats(outStats);
@@ -895,12 +900,6 @@ bool Layer::setBuffer(std::shared_ptr<renderengine::ExternalTexture>& buffer,
         REQUIRES(mFlinger->mStateLock) {
     SFTRACE_FORMAT("setBuffer %s - hasBuffer=%s", getDebugName(), (buffer ? "true" : "false"));
 
-    const bool frameNumberChanged =
-            bufferData.flags.test(BufferData::BufferDataChange::frameNumberChanged);
-    const uint64_t frameNumber =
-            frameNumberChanged ? bufferData.frameNumber : mDrawingState.frameNumber + 1;
-    SFTRACE_FORMAT_INSTANT("setBuffer %s - %" PRIu64, getDebugName(), frameNumber);
-
     if (mDrawingState.buffer) {
         releasePreviousBuffer();
     } else if (buffer) {
@@ -926,22 +925,9 @@ bool Layer::setBuffer(std::shared_ptr<renderengine::ExternalTexture>& buffer,
         }
     }
 
-    if ((mDrawingState.producerId > bufferData.producerId) ||
-        ((mDrawingState.producerId == bufferData.producerId) &&
-         (mDrawingState.frameNumber > frameNumber))) {
-        ALOGE("Out of order buffers detected for %s producedId=%d frameNumber=%" PRIu64
-              " -> producedId=%d frameNumber=%" PRIu64,
-              getDebugName(), mDrawingState.producerId, mDrawingState.frameNumber,
-              bufferData.producerId, frameNumber);
-        TransactionTraceWriter::getInstance().invoke("out_of_order_buffers_", /*overwrite=*/false);
-    }
-
     mDrawingState.producerId = bufferData.producerId;
-    mDrawingState.barrierProducerId =
-            std::max(mDrawingState.producerId, mDrawingState.barrierProducerId);
-    mDrawingState.frameNumber = frameNumber;
-    mDrawingState.barrierFrameNumber =
-            std::max(mDrawingState.frameNumber, mDrawingState.barrierFrameNumber);
+    mDrawingState.frameNumber = bufferData.frameNumber;
+    SFTRACE_FORMAT_INSTANT("setBuffer %s - %" PRIu64, getDebugName(), bufferData.frameNumber);
 
     mDrawingState.releaseBufferListener = bufferData.releaseBufferListener;
     mDrawingState.previousBuffer = std::move(mDrawingState.buffer);
@@ -969,10 +955,10 @@ bool Layer::setBuffer(std::shared_ptr<renderengine::ExternalTexture>& buffer,
     if (bufferData.dequeueTime > 0) {
         const uint64_t bufferId = mDrawingState.buffer->getId();
         mFlinger->mFrameTracer->traceNewLayer(layerId, getName().c_str());
-        mFlinger->mFrameTracer->traceTimestamp(layerId, bufferId, frameNumber,
+        mFlinger->mFrameTracer->traceTimestamp(layerId, bufferId, bufferData.frameNumber,
                                                bufferData.dequeueTime,
                                                FrameTracer::FrameEvent::DEQUEUE);
-        mFlinger->mFrameTracer->traceTimestamp(layerId, bufferId, frameNumber, postTime,
+        mFlinger->mFrameTracer->traceTimestamp(layerId, bufferId, bufferData.frameNumber, postTime,
                                                FrameTracer::FrameEvent::QUEUE);
     }
 
@@ -1173,7 +1159,7 @@ Rect Layer::getBufferSize(const State& /*s*/) const {
     }
 
     if (getTransformToDisplayInverse()) {
-        uint32_t invTransform = SurfaceFlinger::getActiveDisplayRotationFlags();
+        uint32_t invTransform = SurfaceFlinger::getFrontInternalDisplayRotationFlags();
         if (invTransform & ui::Transform::ROT_90) {
             std::swap(bufWidth, bufHeight);
         }
@@ -1326,17 +1312,8 @@ void Layer::gatherBufferInfo() {
             }
         }
     }
-    if (lastDataspace != mBufferInfo.mDataspace ||
-        mBufferInfo.mTimeSinceDataspaceUpdate == std::chrono::steady_clock::time_point::min()) {
+    if (lastDataspace != mBufferInfo.mDataspace) {
         mFlinger->mHdrLayerInfoChanged = true;
-        const auto currentTime = std::chrono::steady_clock::now();
-        if (mBufferInfo.mTimeSinceDataspaceUpdate > std::chrono::steady_clock::time_point::min()) {
-            mFlinger->mLayerEvents
-                    .emplace_back(mOwnerUid, getSequence(), lastDataspace,
-                                  std::chrono::duration_cast<std::chrono::milliseconds>(
-                                          currentTime - mBufferInfo.mTimeSinceDataspaceUpdate));
-        }
-        mBufferInfo.mTimeSinceDataspaceUpdate = currentTime;
     }
     if (mBufferInfo.mDesiredHdrSdrRatio != mDrawingState.desiredHdrSdrRatio) {
         mBufferInfo.mDesiredHdrSdrRatio = mDrawingState.desiredHdrSdrRatio;
@@ -1344,6 +1321,30 @@ void Layer::gatherBufferInfo() {
     }
     mBufferInfo.mCrop = computeBufferCrop(mDrawingState);
     mBufferInfo.mTransformToDisplayInverse = mDrawingState.transformToDisplayInverse;
+
+    // update layer event
+    // a new layer event instance is added if any defined parameter changes.
+    if (!mLastLayerEvent.has_value()) {
+        mLastLayerEvent =
+                std::make_optional<SurfaceFlinger::LayerEvent>({mOwnerUid, getSequence()});
+    }
+
+    if (mLastLayerEvent->dataspace != mBufferInfo.mDataspace ||
+        mLastLayerEvent->desiredHdrHeadroom != mBufferInfo.mDesiredHdrSdrRatio ||
+        mLastLayerEvent->useLuts != mDrawingState.useLuts ||
+        mTimeSinceLayerEventsUpdate == std::chrono::steady_clock::time_point::min()) {
+        const auto currentTime = std::chrono::steady_clock::now();
+        if (mTimeSinceLayerEventsUpdate > std::chrono::steady_clock::time_point::min()) {
+            mLastLayerEvent->timeSinceLastEvent =
+                    std::chrono::duration_cast<std::chrono::milliseconds>(
+                            currentTime - mTimeSinceLayerEventsUpdate);
+            mFlinger->mLayerEvents.emplace_back(mLastLayerEvent.value());
+        }
+        mTimeSinceLayerEventsUpdate = currentTime;
+        mLastLayerEvent->dataspace = mBufferInfo.mDataspace;
+        mLastLayerEvent->useLuts = mDrawingState.useLuts;
+        mLastLayerEvent->desiredHdrHeadroom = mBufferInfo.mDesiredHdrSdrRatio;
+    }
 }
 
 Rect Layer::computeBufferCrop(const State& s) {
diff --git a/services/surfaceflinger/Layer.h b/services/surfaceflinger/Layer.h
index 88754f9fa3..a65fad4242 100644
--- a/services/surfaceflinger/Layer.h
+++ b/services/surfaceflinger/Layer.h
@@ -73,9 +73,9 @@ class OutputLayer;
 struct LayerFECompositionState;
 }
 
-namespace frametimeline {
+namespace scheduler {
 class SurfaceFrame;
-} // namespace frametimeline
+} // namespace scheduler
 
 class Layer : public virtual RefBase {
 public:
@@ -104,20 +104,14 @@ public:
 
         uint64_t frameNumber;
         uint64_t previousFrameNumber;
-        // high watermark framenumber to use to check for barriers to protect ourselves
-        // from out of order transactions
-        uint64_t barrierFrameNumber;
         ui::Transform transform;
 
         uint32_t producerId = 0;
-        // high watermark producerId to use to check for barriers to protect ourselves
-        // from out of order transactions
-        uint32_t barrierProducerId = 0;
 
         uint32_t bufferTransform;
         bool transformToDisplayInverse;
         Region transparentRegionHint;
-        std::shared_ptr<renderengine::ExternalTexture> previousBuffer;
+        std::weak_ptr<renderengine::ExternalTexture> previousBuffer;
         std::shared_ptr<renderengine::ExternalTexture> buffer;
         sp<Fence> acquireFence;
         std::shared_ptr<FenceTime> acquireFenceTime;
@@ -143,11 +137,11 @@ public:
         // such SurfaceFrame exists because only one buffer can be presented on the layer per vsync.
         // If multiple buffers are queued, the prior ones will be dropped, along with the
         // SurfaceFrame that's tracking them.
-        std::shared_ptr<frametimeline::SurfaceFrame> bufferSurfaceFrameTX;
+        std::shared_ptr<scheduler::SurfaceFrame> bufferSurfaceFrameTX;
         // A map of token(frametimelineVsyncId) to the SurfaceFrame that's tracking a transaction
         // that contains the token. Only one SurfaceFrame exisits for transactions that share the
         // same token, unless they are presented in different vsyncs.
-        std::unordered_map<int64_t, std::shared_ptr<frametimeline::SurfaceFrame>>
+        std::unordered_map<int64_t, std::shared_ptr<scheduler::SurfaceFrame>>
                 bufferlessSurfaceFramesTX;
         // An arbitrary threshold for the number of BufferlessSurfaceFrames in the state. Used to
         // trigger a warning if the number of SurfaceFrames crosses the threshold.
@@ -160,6 +154,7 @@ public:
         float desiredHdrSdrRatio = -1.f;
         int64_t latchedVsyncId = 0;
         bool useVsyncIdForRefreshRateSelection = false;
+        bool useLuts = false;
     };
 
     explicit Layer(const surfaceflinger::LayerCreationArgs& args);
@@ -187,6 +182,7 @@ public:
     bool setDataspace(ui::Dataspace /*dataspace*/);
     bool setExtendedRangeBrightness(float currentBufferRatio, float desiredRatio);
     bool setDesiredHdrHeadroom(float desiredRatio);
+    void setUseLuts(bool useLuts) { mDrawingState.useLuts = useLuts; }
     bool setSidebandStream(const sp<NativeHandle>& /*sidebandStream*/,
                            const FrameTimelineInfo& /* info*/, nsecs_t /* postTime */,
                            gui::GameMode gameMode);
@@ -245,8 +241,6 @@ public:
         sp<Fence> mFence;
         uint32_t mTransform{0};
         ui::Dataspace mDataspace{ui::Dataspace::UNKNOWN};
-        std::chrono::steady_clock::time_point mTimeSinceDataspaceUpdate =
-                std::chrono::steady_clock::time_point::min();
         Rect mCrop;
         PixelFormat mPixelFormat{PIXEL_FORMAT_NONE};
         bool mTransformToDisplayInverse{false};
@@ -258,6 +252,9 @@ public:
     };
 
     BufferInfo mBufferInfo;
+    std::optional<SurfaceFlinger::LayerEvent> mLastLayerEvent;
+    std::chrono::steady_clock::time_point mTimeSinceLayerEventsUpdate =
+            std::chrono::steady_clock::time_point::min();
     std::shared_ptr<gui::BufferReleaseChannel::ProducerEndpoint> mBufferReleaseChannel;
 
     bool fenceHasSignaled() const;
@@ -333,15 +330,14 @@ public:
     void setFrameTimelineVsyncForBufferlessTransaction(const FrameTimelineInfo& info,
                                                        nsecs_t postTime, gui::GameMode gameMode);
 
-    void addSurfaceFrameDroppedForBuffer(std::shared_ptr<frametimeline::SurfaceFrame>& surfaceFrame,
+    void addSurfaceFrameDroppedForBuffer(std::shared_ptr<scheduler::SurfaceFrame>& surfaceFrame,
                                          nsecs_t dropTime);
-    void addSurfaceFramePresentedForBuffer(
-            std::shared_ptr<frametimeline::SurfaceFrame>& surfaceFrame, nsecs_t acquireFenceTime,
-            nsecs_t currentLatchTime);
+    void addSurfaceFramePresentedForBuffer(std::shared_ptr<scheduler::SurfaceFrame>& surfaceFrame,
+                                           nsecs_t acquireFenceTime, nsecs_t currentLatchTime);
 
-    std::shared_ptr<frametimeline::SurfaceFrame> createSurfaceFrameForTransaction(
+    std::shared_ptr<scheduler::SurfaceFrame> createSurfaceFrameForTransaction(
             const FrameTimelineInfo& info, nsecs_t postTime, gui::GameMode gameMode);
-    std::shared_ptr<frametimeline::SurfaceFrame> createSurfaceFrameForBuffer(
+    std::shared_ptr<scheduler::SurfaceFrame> createSurfaceFrameForBuffer(
             const FrameTimelineInfo& info, nsecs_t queueTime, std::string debugName,
             gui::GameMode gameMode);
     void setFrameTimelineVsyncForSkippedFrames(const FrameTimelineInfo& info, nsecs_t postTime,
@@ -558,7 +554,7 @@ private:
 
     std::vector<std::pair<frontend::LayerHierarchy::TraversalPath, sp<LayerFE>>> mLayerFEs;
     bool mHandleAlive = false;
-    std::optional<std::reference_wrapper<frametimeline::FrameTimeline>> getTimeline() const {
+    std::optional<std::reference_wrapper<scheduler::FrameTimeline>> getTimeline() const {
         return *mFlinger->mFrameTimeline;
     }
 };
diff --git a/services/surfaceflinger/LayerFE.cpp b/services/surfaceflinger/LayerFE.cpp
index 3cd432cd2b..73a7494d92 100644
--- a/services/surfaceflinger/LayerFE.cpp
+++ b/services/surfaceflinger/LayerFE.cpp
@@ -114,6 +114,7 @@ std::optional<compositionengine::LayerFE::LayerSettings> LayerFE::prepareClientC
     prepareShadowClientComposition(*layerSettings, targetSettings.viewport);
 
     layerSettings->borderSettings = mSnapshot->borderSettings;
+    layerSettings->boxShadowSettings = mSnapshot->boxShadowSettings;
 
     return layerSettings;
 }
@@ -123,6 +124,14 @@ std::optional<compositionengine::LayerFE::LayerSettings> LayerFE::prepareClientC
     SFTRACE_CALL();
     compositionengine::LayerFE::LayerSettings layerSettings;
     layerSettings.geometry.originalBounds = mSnapshot->geomLayerBounds;
+
+    if (mSnapshot->parentRoundedCorner.hasRequestedRadius()) {
+        layerSettings.geometry.otherRoundedCornersRadius = mSnapshot->parentRoundedCorner.radius;
+        layerSettings.geometry.otherCrop = mSnapshot->parentRoundedCorner.cropRect;
+    } else {
+        layerSettings.geometry.otherCrop = mSnapshot->parentGeomLayerCrop;
+    }
+
     layerSettings.geometry.boundaries =
             reduce(mSnapshot->geomLayerBounds, mSnapshot->transparentRegionHint);
     layerSettings.geometry.positionTransform = mSnapshot->geomLayerTransform.asMatrix4();
@@ -158,11 +167,13 @@ std::optional<compositionengine::LayerFE::LayerSettings> LayerFE::prepareClientC
     switch (targetSettings.blurSetting) {
         case LayerFE::ClientCompositionTargetSettings::BlurSetting::Enabled:
             layerSettings.backgroundBlurRadius = mSnapshot->backgroundBlurRadius;
+            layerSettings.backgroundBlurScale = mSnapshot->backgroundBlurScale;
             layerSettings.blurRegions = mSnapshot->blurRegions;
             layerSettings.blurRegionTransform = mSnapshot->localTransformInverse.asMatrix4();
             break;
         case LayerFE::ClientCompositionTargetSettings::BlurSetting::BackgroundBlurOnly:
             layerSettings.backgroundBlurRadius = mSnapshot->backgroundBlurRadius;
+            layerSettings.backgroundBlurScale = mSnapshot->backgroundBlurScale;
             break;
         case LayerFE::ClientCompositionTargetSettings::BlurSetting::BlurRegionsOnly:
             layerSettings.blurRegions = mSnapshot->blurRegions;
@@ -208,7 +219,7 @@ void LayerFE::prepareEffectsClientComposition(
     if (targetSettings.realContentIsVisible && fillsColor()) {
         // Set color for color fill settings.
         layerSettings.source.solidColor = mSnapshot->color.rgb;
-    } else if (hasBlur() || drawShadows() || hasOutline()) {
+    } else if (hasBlur() || drawShadows() || hasBorderSettings() || hasBoxShadowSettings()) {
         layerSettings.skipContentDraw = true;
     }
 }
@@ -222,15 +233,8 @@ void LayerFE::prepareBufferStateClientComposition(
         // activeBuffer, then we need to return LayerSettings.
         return;
     }
-    bool blackOutLayer;
-    if (FlagManager::getInstance().display_protected()) {
-        blackOutLayer = (mSnapshot->hasProtectedContent && !targetSettings.isProtected) ||
+    bool blackOutLayer = (mSnapshot->hasProtectedContent && !targetSettings.isProtected) ||
                 (mSnapshot->isSecure && !targetSettings.isSecure);
-    } else {
-        blackOutLayer = (mSnapshot->hasProtectedContent && !targetSettings.isProtected) ||
-                ((mSnapshot->isSecure || mSnapshot->hasProtectedContent) &&
-                 !targetSettings.isSecure);
-    }
     const bool bufferCanBeUsedAsHwTexture =
             mSnapshot->externalTexture->getUsage() & GraphicBuffer::USAGE_HW_TEXTURE;
     if (blackOutLayer || !bufferCanBeUsedAsHwTexture) {
@@ -282,7 +286,7 @@ void LayerFE::prepareBufferStateClientComposition(
          * the code below applies the primary display's inverse transform to
          * the texture transform
          */
-        uint32_t transform = SurfaceFlinger::getActiveDisplayRotationFlags();
+        uint32_t transform = SurfaceFlinger::getFrontInternalDisplayRotationFlags();
         mat4 tr = inverseOrientation(transform);
 
         /**
@@ -339,11 +343,19 @@ void LayerFE::prepareShadowClientComposition(LayerFE::LayerSettings& caster,
         return;
     }
 
-    // Shift the spot light x-position to the middle of the display and then
-    // offset it by casting layer's screen pos.
-    state.lightPos.x =
-            (static_cast<float>(layerStackRect.width()) / 2.f) - mSnapshot->transformedBounds.left;
-    state.lightPos.y -= mSnapshot->transformedBounds.top;
+    // The light source should be at (screenWidth/2, globalShadowSettings.lightPos.y) in
+    // screenspace.
+    vec2 lightPosScreenSpace = {
+            (static_cast<float>(layerStackRect.width()) / 2.f),
+            state.lightPos.y,
+    };
+
+    // Skia expects light pos in layer space.
+    vec2 lightPosLayerSpace = mSnapshot->geomInverseLayerTransform.transform(lightPosScreenSpace);
+
+    state.lightPos.x = lightPosLayerSpace.x;
+    state.lightPos.y = lightPosLayerSpace.y;
+
     caster.shadow = state;
 }
 
@@ -395,8 +407,12 @@ bool LayerFE::hasBlur() const {
     return mSnapshot->backgroundBlurRadius > 0 || mSnapshot->blurRegions.size() > 0;
 }
 
-bool LayerFE::hasOutline() const {
-    return mSnapshot->borderSettings.strokeWidth > 0;
+bool LayerFE::hasBorderSettings() const {
+    return mSnapshot->hasBorderSettings();
+}
+
+bool LayerFE::hasBoxShadowSettings() const {
+    return mSnapshot->hasBoxShadowSettings();
 }
 
 bool LayerFE::drawShadows() const {
diff --git a/services/surfaceflinger/LayerFE.h b/services/surfaceflinger/LayerFE.h
index b897a90687..69072ccf4a 100644
--- a/services/surfaceflinger/LayerFE.h
+++ b/services/surfaceflinger/LayerFE.h
@@ -83,13 +83,17 @@ private:
             compositionengine::LayerFE::LayerSettings&,
             compositionengine::LayerFE::ClientCompositionTargetSettings&) const;
 
-    bool hasEffect() const { return fillsColor() || drawShadows() || hasBlur() || hasOutline(); }
+    bool hasEffect() const {
+        return fillsColor() || drawShadows() || hasBlur() || hasBorderSettings() ||
+                hasBoxShadowSettings();
+    }
     bool hasBufferOrSidebandStream() const;
 
     bool fillsColor() const;
     bool hasBlur() const;
     bool drawShadows() const;
-    bool hasOutline() const;
+    bool hasBoxShadowSettings() const;
+    bool hasBorderSettings() const;
 
     const sp<GraphicBuffer> getBuffer() const;
 
diff --git a/services/surfaceflinger/LayerProtoHelper.cpp b/services/surfaceflinger/LayerProtoHelper.cpp
index 280d66e12a..5bb22d9286 100644
--- a/services/surfaceflinger/LayerProtoHelper.cpp
+++ b/services/surfaceflinger/LayerProtoHelper.cpp
@@ -351,13 +351,13 @@ frontend::LayerSnapshot* LayerProtoFromSnapshotGenerator::getSnapshot(
 void LayerProtoFromSnapshotGenerator::writeHierarchyToProto(
         const frontend::LayerHierarchy& root, const frontend::LayerHierarchy::TraversalPath& path) {
     using Variant = frontend::LayerHierarchy::Variant;
-    perfetto::protos::LayerProto* layerProto = mLayersProto.add_layers();
     const frontend::RequestedLayerState& layer = *root.getLayer();
     frontend::LayerSnapshot* snapshot = getSnapshot(path, layer);
     if (mVisitedLayers.find(snapshot->uniqueSequence) != mVisitedLayers.end()) {
         TransactionTraceWriter::getInstance().invoke("DuplicateLayer", /* overwrite= */ false);
         return;
     }
+    perfetto::protos::LayerProto* layerProto = mLayersProto.add_layers();
     mVisitedLayers.insert(snapshot->uniqueSequence);
     LayerProtoHelper::writeSnapshotToProto(layerProto, layer, *snapshot, mTraceFlags);
 
diff --git a/services/surfaceflinger/LocklessQueue.h b/services/surfaceflinger/LocklessQueue.h
index 4d0b26147c..17c25d8bcf 100644
--- a/services/surfaceflinger/LocklessQueue.h
+++ b/services/surfaceflinger/LocklessQueue.h
@@ -41,7 +41,7 @@ class LocklessQueue {
 public:
     bool isEmpty() { return (mPush.load() == nullptr) && (mPop.load() == nullptr); }
 
-    void push(T value) {
+    void push(T&& value) {
         Entry* entry = new Entry(std::move(value));
         Entry* previousHead = mPush.load(/*std::memory_order_relaxed*/);
         do {
@@ -79,7 +79,7 @@ private:
     public:
         T mValue;
         std::atomic<Entry*> mNext;
-        Entry(T value) : mValue(value) {}
+        Entry(T&& value) : mValue(std::move(value)) {}
     };
     std::atomic<Entry*> mPush = nullptr;
     std::atomic<Entry*> mPop = nullptr;
diff --git a/services/surfaceflinger/OWNERS b/services/surfaceflinger/OWNERS
index 13edd1668e..5728d760e4 100644
--- a/services/surfaceflinger/OWNERS
+++ b/services/surfaceflinger/OWNERS
@@ -2,9 +2,12 @@
 
 adyabr@google.com
 alecmouri@google.com
+carlosmr@google.com
 domlaskowski@google.com
+huisinro@google.com
 jreck@google.com
-lpy@google.com
+jshargo@google.com
+lpique@google.com
 mattbuckley@google.com
 melodymhsu@google.com
 pdwilliams@google.com
diff --git a/services/surfaceflinger/PowerAdvisor/PowerAdvisor.cpp b/services/surfaceflinger/PowerAdvisor/PowerAdvisor.cpp
index 788448d079..31c1b593d1 100644
--- a/services/surfaceflinger/PowerAdvisor/PowerAdvisor.cpp
+++ b/services/surfaceflinger/PowerAdvisor/PowerAdvisor.cpp
@@ -200,7 +200,7 @@ void PowerAdvisor::sendHintSessionHint(hal::SessionHint hint) {
         return;
     }
     SFTRACE_CALL();
-    if (sTraceHintSessionData) SFTRACE_INT("Session hint", static_cast<int>(hint));
+    SFTRACE_INT("Session hint", static_cast<int>(hint));
     {
         std::scoped_lock lock(mHintSessionMutex);
         if (!ensurePowerHintSessionRunning()) {
@@ -288,7 +288,7 @@ void PowerAdvisor::updateTargetWorkDuration(Duration targetDuration) {
     SFTRACE_CALL();
     {
         mTargetDuration = targetDuration;
-        if (sTraceHintSessionData) SFTRACE_INT64("Time target", targetDuration.ns());
+        SFTRACE_INT64("Target Work Duration", targetDuration.ns());
         if (targetDuration == mLastTargetDurationSent) return;
         std::scoped_lock lock(mHintSessionMutex);
         if (!ensurePowerHintSessionRunning()) {
@@ -321,14 +321,15 @@ void PowerAdvisor::reportActualWorkDuration() {
         return;
     }
     actualDuration->durationNanos += sTargetSafetyMargin.ns();
+    SFTRACE_INT64("Reported Work Duration", actualDuration->durationNanos);
+    if (supportsGpuReporting()) {
+        SFTRACE_INT64("Reported cpu duration", actualDuration->cpuDurationNanos);
+        SFTRACE_INT64("Reported gpu duration", actualDuration->gpuDurationNanos);
+    }
+
     if (sTraceHintSessionData) {
         SFTRACE_INT64("Measured duration", actualDuration->durationNanos);
         SFTRACE_INT64("Target error term", actualDuration->durationNanos - mTargetDuration.ns());
-        SFTRACE_INT64("Reported duration", actualDuration->durationNanos);
-        if (supportsGpuReporting()) {
-            SFTRACE_INT64("Reported cpu duration", actualDuration->cpuDurationNanos);
-            SFTRACE_INT64("Reported gpu duration", actualDuration->gpuDurationNanos);
-        }
         SFTRACE_INT64("Reported target", mLastTargetDurationSent.ns());
         SFTRACE_INT64("Reported target error term",
                       actualDuration->durationNanos - mLastTargetDurationSent.ns());
@@ -807,7 +808,14 @@ void PowerAdvisor::setCommittedWorkload(ftl::Flags<Workload> workload) {
                                               ftl::truncated<20>(mCommittedWorkload.string()))
                                           .c_str());
 
-        // TODO(b/385028458) load up hint
+        // TODO(b/385028458) load up hint for other increased workloads.
+
+        // Provides a load up hint only for effects that require client
+        // composition, such as blur or shadows.
+        if (FlagManager::getInstance().adpf_cpu_effects_loadup() &&
+            mCommittedWorkload.any(adpf::Workload::EFFECTS)) {
+            notifyCpuLoadUp();
+        }
     }
 }
 
diff --git a/services/surfaceflinger/PowerAdvisor/PowerAdvisor.h b/services/surfaceflinger/PowerAdvisor/PowerAdvisor.h
index b97160a3e5..1e48958ddc 100644
--- a/services/surfaceflinger/PowerAdvisor/PowerAdvisor.h
+++ b/services/surfaceflinger/PowerAdvisor/PowerAdvisor.h
@@ -36,7 +36,6 @@
 #include <common/trace.h>
 #include <ftl/flags.h>
 #include <scheduler/Time.h>
-#include <ui/DisplayIdentification.h>
 #include "../Scheduler/OneShotTimer.h"
 #include "Workload.h"
 
diff --git a/services/surfaceflinger/PowerAdvisor/SessionLayerMap.h b/services/surfaceflinger/PowerAdvisor/SessionLayerMap.h
index 51808a65fc..766a0b4f73 100644
--- a/services/surfaceflinger/PowerAdvisor/SessionLayerMap.h
+++ b/services/surfaceflinger/PowerAdvisor/SessionLayerMap.h
@@ -20,6 +20,7 @@
 #include <set>
 #include <unordered_map>
 #include <unordered_set>
+#include <vector>
 
 namespace android::adpf {
 
diff --git a/services/surfaceflinger/QueuedTransactionState.h b/services/surfaceflinger/QueuedTransactionState.h
index 6a17a0d0cb..f605cf7d9d 100644
--- a/services/surfaceflinger/QueuedTransactionState.h
+++ b/services/surfaceflinger/QueuedTransactionState.h
@@ -25,7 +25,6 @@
 #include <common/FlagManager.h>
 #include <ftl/flags.h>
 #include <gui/LayerState.h>
-#include <gui/TransactionState.h>
 #include <system/window.h>
 
 namespace android {
@@ -46,31 +45,41 @@ public:
     uint32_t parentId = UNASSIGNED_LAYER_ID;
     uint32_t relativeParentId = UNASSIGNED_LAYER_ID;
     uint32_t touchCropId = UNASSIGNED_LAYER_ID;
+    uint32_t stopLayerId = UNASSIGNED_LAYER_ID;
 };
 
 struct QueuedTransactionState {
     QueuedTransactionState() = default;
 
-    QueuedTransactionState(TransactionState&& transactionState,
-                           std::vector<ResolvedComposerState>&& composerStates,
-                           std::vector<uint64_t>&& uncacheBufferIds, int64_t postTime,
-                           int originPid, int originUid)
-          : frameTimelineInfo(std::move(transactionState.mFrameTimelineInfo)),
-            states(composerStates),
-            displays(std::move(transactionState.mDisplayStates)),
-            flags(transactionState.mFlags),
-            applyToken(transactionState.mApplyToken),
-            inputWindowCommands(std::move(transactionState.mInputWindowCommands)),
-            desiredPresentTime(transactionState.mDesiredPresentTime),
-            isAutoTimestamp(transactionState.mIsAutoTimestamp),
+    QueuedTransactionState(const FrameTimelineInfo& frameTimelineInfo,
+                           std::vector<ResolvedComposerState>& composerStates,
+                           const Vector<DisplayState>& displayStates, uint32_t transactionFlags,
+                           const sp<IBinder>& applyToken,
+                           const InputWindowCommands& inputWindowCommands,
+                           int64_t desiredPresentTime, bool isAutoTimestamp,
+                           std::vector<uint64_t> uncacheBufferIds, int64_t postTime,
+                           bool hasListenerCallbacks,
+                           std::vector<ListenerCallbacks> listenerCallbacks, int originPid,
+                           int originUid, uint64_t transactionId,
+                           std::vector<uint64_t> mergedTransactionIds,
+                           std::vector<gui::EarlyWakeupInfo> earlyWakeupInfos)
+          : frameTimelineInfo(frameTimelineInfo),
+            states(std::move(composerStates)),
+            displays(displayStates),
+            flags(transactionFlags),
+            applyToken(applyToken),
+            inputWindowCommands(inputWindowCommands),
+            desiredPresentTime(desiredPresentTime),
+            isAutoTimestamp(isAutoTimestamp),
             uncacheBufferIds(std::move(uncacheBufferIds)),
             postTime(postTime),
-            hasListenerCallbacks(transactionState.mHasListenerCallbacks),
-            listenerCallbacks(std::move(transactionState.mListenerCallbacks)),
+            hasListenerCallbacks(hasListenerCallbacks),
+            listenerCallbacks(std::move(listenerCallbacks)),
             originPid(originPid),
             originUid(originUid),
-            id(transactionState.getId()),
-            mergedTransactionIds(std::move(transactionState.mMergedTransactionIds)) {}
+            id(transactionId),
+            mergedTransactionIds(std::move(mergedTransactionIds)),
+            earlyWakeupInfos(std::move(earlyWakeupInfos)) {}
 
     // Invokes `void(const layer_state_t&)` visitor for matching layers.
     template <typename Visitor>
@@ -105,22 +114,15 @@ struct QueuedTransactionState {
 
         for (const auto& state : states) {
             const bool frameRateChanged = state.state.what & layer_state_t::eFrameRateChanged;
-            if (FlagManager::getInstance().vrr_bugfix_24q4()) {
-                const bool frameRateIsNoVote = frameRateChanged &&
-                        state.state.frameRateCompatibility == ANATIVEWINDOW_FRAME_RATE_NO_VOTE;
-                const bool frameRateCategoryChanged =
-                        state.state.what & layer_state_t::eFrameRateCategoryChanged;
-                const bool frameRateCategoryIsNoPreference = frameRateCategoryChanged &&
-                        state.state.frameRateCategory ==
-                                ANATIVEWINDOW_FRAME_RATE_CATEGORY_NO_PREFERENCE;
-                if (!frameRateIsNoVote && !frameRateCategoryIsNoPreference) {
-                    return true;
-                }
-            } else {
-                if (!frameRateChanged ||
-                    state.state.frameRateCompatibility != ANATIVEWINDOW_FRAME_RATE_NO_VOTE) {
-                    return true;
-                }
+            const bool frameRateIsNoVote = frameRateChanged &&
+                    state.state.frameRateCompatibility == ANATIVEWINDOW_FRAME_RATE_NO_VOTE;
+            const bool frameRateCategoryChanged =
+                    state.state.what & layer_state_t::eFrameRateCategoryChanged;
+            const bool frameRateCategoryIsNoPreference = frameRateCategoryChanged &&
+                    state.state.frameRateCategory ==
+                            ANATIVEWINDOW_FRAME_RATE_CATEGORY_NO_PREFERENCE;
+            if (!frameRateIsNoVote && !frameRateCategoryIsNoPreference) {
+                return true;
             }
         }
 
@@ -129,7 +131,7 @@ struct QueuedTransactionState {
 
     FrameTimelineInfo frameTimelineInfo;
     std::vector<ResolvedComposerState> states;
-    std::vector<DisplayState> displays;
+    Vector<DisplayState> displays;
     uint32_t flags;
     sp<IBinder> applyToken;
     InputWindowCommands inputWindowCommands;
@@ -144,6 +146,7 @@ struct QueuedTransactionState {
     uint64_t id;
     bool sentFenceTimeoutWarning = false;
     std::vector<uint64_t> mergedTransactionIds;
+    std::vector<gui::EarlyWakeupInfo> earlyWakeupInfos;
     ftl::Flags<adpf::Workload> workloadHint;
 };
 
diff --git a/services/surfaceflinger/RefreshRateOverlay.cpp b/services/surfaceflinger/RefreshRateOverlay.cpp
index 35f12a0484..a3d1b39a19 100644
--- a/services/surfaceflinger/RefreshRateOverlay.cpp
+++ b/services/surfaceflinger/RefreshRateOverlay.cpp
@@ -288,8 +288,7 @@ void RefreshRateOverlay::onVrrIdle(bool idle) {
 }
 
 void RefreshRateOverlay::changeRenderRate(Fps renderFps) {
-    if (mFeatures.test(Features::RenderRate) && mRefreshRate &&
-        FlagManager::getInstance().misc1()) {
+    if (mFeatures.test(Features::RenderRate) && mRefreshRate) {
         mRenderFps = renderFps;
         const auto buffer = getOrCreateBuffers(*mRefreshRate, renderFps, mIsVrrIdle)[mFrame];
         createTransaction().setBuffer(mSurfaceControl->get(), buffer).apply();
diff --git a/services/surfaceflinger/RegionSamplingThread.cpp b/services/surfaceflinger/RegionSamplingThread.cpp
index 615492a872..837d37d894 100644
--- a/services/surfaceflinger/RegionSamplingThread.cpp
+++ b/services/surfaceflinger/RegionSamplingThread.cpp
@@ -141,6 +141,25 @@ void RegionSamplingThread::removeListener(const sp<IRegionSamplingListener>& lis
     mDescriptors.erase(wp<IBinder>(IInterface::asBinder(listener)));
 }
 
+const std::vector<gui::RegionSamplingDescriptor> RegionSamplingThread::getListeners() {
+    std::lock_guard lock(mSamplingMutex);
+    std::vector<gui::RegionSamplingDescriptor> listeners;
+    for (const auto& [listener, descriptor] : mDescriptors) {
+        gui::ARect guiRect;
+        guiRect.left = descriptor.area.left;
+        guiRect.top = descriptor.area.top;
+        guiRect.right = descriptor.area.right;
+        guiRect.bottom = descriptor.area.bottom;
+
+        gui::RegionSamplingDescriptor guiDescriptor;
+        guiDescriptor.area = guiRect;
+        guiDescriptor.stopLayerId = descriptor.stopLayerId;
+        guiDescriptor.listener = descriptor.listener;
+        listeners.emplace_back(guiDescriptor);
+    }
+    return listeners;
+}
+
 void RegionSamplingThread::checkForStaleLuma() {
     std::lock_guard lock(mThreadControlMutex);
 
@@ -195,7 +214,7 @@ void RegionSamplingThread::binderDied(const wp<IBinder>& who) {
 }
 
 float sampleArea(const uint32_t* data, int32_t width, int32_t height, int32_t stride,
-                 uint32_t orientation, const Rect& sample_area) {
+                 const Rect& sample_area) {
     if (!sample_area.isValid() || (sample_area.getWidth() > width) ||
         (sample_area.getHeight() > height)) {
         ALOGE("invalid sampling region requested");
@@ -224,7 +243,7 @@ float sampleArea(const uint32_t* data, int32_t width, int32_t height, int32_t st
 
 std::vector<float> RegionSamplingThread::sampleBuffer(
         const sp<GraphicBuffer>& buffer, const Point& leftTop,
-        const std::vector<RegionSamplingThread::Descriptor>& descriptors, uint32_t orientation) {
+        const std::vector<RegionSamplingThread::Descriptor>& descriptors) {
     void* data_raw = nullptr;
     buffer->lock(GRALLOC_USAGE_SW_READ_OFTEN, &data_raw);
     std::shared_ptr<uint32_t> data(reinterpret_cast<uint32_t*>(data_raw),
@@ -237,7 +256,7 @@ std::vector<float> RegionSamplingThread::sampleBuffer(
     std::vector<float> lumas(descriptors.size());
     std::transform(descriptors.begin(), descriptors.end(), lumas.begin(),
                    [&](auto const& descriptor) {
-                       return sampleArea(data.get(), width, height, stride, orientation,
+                       return sampleArea(data.get(), width, height, stride,
                                          descriptor.area - leftTop);
                    });
     return lumas;
@@ -251,23 +270,6 @@ void RegionSamplingThread::captureSample() {
         return;
     }
 
-    wp<const DisplayDevice> displayWeak;
-
-    ui::LayerStack layerStack;
-    ui::Transform::RotationFlags orientation;
-    ui::Size displaySize;
-    Rect layerStackSpaceRect;
-
-    {
-        // TODO(b/159112860): Don't keep sp<DisplayDevice> outside of SF main thread
-        const sp<const DisplayDevice> display = mFlinger.getDefaultDisplayDevice();
-        displayWeak = display;
-        layerStack = display->getLayerStack();
-        orientation = ui::Transform::toRotationFlags(display->getOrientation());
-        displaySize = display->getSize();
-        layerStackSpaceRect = display->getLayerStackSpaceRect();
-    }
-
     std::vector<RegionSamplingThread::Descriptor> descriptors;
     Region sampleRegion;
     for (const auto& [listener, descriptor] : mDescriptors) {
@@ -320,8 +322,6 @@ void RegionSamplingThread::captureSample() {
         return layerFilterFn(snapshot.name.c_str(), snapshot.path.id, bounds, transform,
                              outStopTraversal);
     };
-    auto getLayerSnapshotsFn =
-            mFlinger.getLayerSnapshotsForScreenshots(layerStack, CaptureArgs::UNSET_UID, filterFn);
 
     std::shared_ptr<renderengine::ExternalTexture> buffer = nullptr;
     if (mCachedBuffer && mCachedBuffer->getBuffer()->getWidth() == sampledBounds.getWidth() &&
@@ -342,24 +342,25 @@ void RegionSamplingThread::captureSample() {
                                                              WRITEABLE);
     }
 
-    constexpr bool kRegionSampling = true;
-    constexpr bool kGrayscale = false;
-    constexpr bool kIsProtected = false;
-
-    SurfaceFlinger::ScreenshotArgs screenshotArgs;
-    screenshotArgs.captureTypeVariant = displayWeak;
-    screenshotArgs.displayIdVariant = std::nullopt;
-    screenshotArgs.sourceCrop = sampledBounds.isEmpty() ? layerStackSpaceRect : sampledBounds;
-    screenshotArgs.reqSize = sampledBounds.getSize();
-    screenshotArgs.dataspace = ui::Dataspace::V0_SRGB;
-    screenshotArgs.isSecure = true;
-    screenshotArgs.seamlessTransition = false;
+    SurfaceFlinger::ScreenshotArgs
+            screenshotArgs{.captureTypeVariant = std::monostate{},
+                           .displayIdVariant = std::nullopt,
+                           .snapshotRequest =
+                                   SurfaceFlinger::SnapshotRequestArgs{.uid = gui::Uid::INVALID,
+                                                                       .snapshotFilterFn =
+                                                                               filterFn},
+                           .sourceCrop = sampledBounds,
+                           .size = sampledBounds.getSize(),
+                           .dataspace = ui::Dataspace::V0_SRGB,
+                           .disableBlur = true,
+                           .isGrayscale = false,
+                           .isSecure = true,
+                           .seamlessTransition = false,
+                           .debugName = "RegionSampling"};
 
     std::vector<std::pair<Layer*, sp<LayerFE>>> layers;
-    mFlinger.getSnapshotsFromMainThread(screenshotArgs, getLayerSnapshotsFn, layers);
-    FenceResult fenceResult = mFlinger.captureScreenshot(screenshotArgs, buffer, kRegionSampling,
-                                                         kGrayscale, kIsProtected, nullptr, layers)
-                                      .get();
+    mFlinger.setScreenshotSnapshotsAndDisplayState(screenshotArgs);
+    FenceResult fenceResult = mFlinger.captureScreenshot(screenshotArgs, buffer, nullptr).get();
     if (fenceResult.ok()) {
         fenceResult.value()->waitForever(LOG_TAG);
     }
@@ -372,8 +373,8 @@ void RegionSamplingThread::captureSample() {
     }
 
     ALOGV("Sampling %zu descriptors", activeDescriptors.size());
-    std::vector<float> lumas = sampleBuffer(buffer->getBuffer(), sampledBounds.leftTop(),
-                                            activeDescriptors, orientation);
+    std::vector<float> lumas =
+            sampleBuffer(buffer->getBuffer(), sampledBounds.leftTop(), activeDescriptors);
     if (lumas.size() != activeDescriptors.size()) {
         ALOGW("collected %zu median luma values for %zu descriptors", lumas.size(),
               activeDescriptors.size());
diff --git a/services/surfaceflinger/RegionSamplingThread.h b/services/surfaceflinger/RegionSamplingThread.h
index e8c891e4bf..1d9e7ab498 100644
--- a/services/surfaceflinger/RegionSamplingThread.h
+++ b/services/surfaceflinger/RegionSamplingThread.h
@@ -18,6 +18,7 @@
 
 #include <android-base/thread_annotations.h>
 #include <android/gui/IRegionSamplingListener.h>
+#include <android/gui/RegionSamplingDescriptor.h>
 #include <binder/IBinder.h>
 #include <renderengine/ExternalTexture.h>
 #include <ui/GraphicBuffer.h>
@@ -43,7 +44,7 @@ struct SamplingOffsetCallback;
 using gui::IRegionSamplingListener;
 
 float sampleArea(const uint32_t* data, int32_t width, int32_t height, int32_t stride,
-                 uint32_t orientation, const Rect& area);
+                 const Rect& area);
 
 class RegionSamplingThread : public IBinder::DeathRecipient {
 public:
@@ -77,6 +78,8 @@ public:
                      const sp<IRegionSamplingListener>& listener);
     // Remove the listener to stop receiving median luma notifications.
     void removeListener(const sp<IRegionSamplingListener>& listener);
+    // Gets all listeners that are receiving median luma notifications.
+    const std::vector<gui::RegionSamplingDescriptor> getListeners();
 
     // Notifies sampling engine that composition is done and new content is
     // available, and the deadline for the sampling work on the main thread to
@@ -93,7 +96,7 @@ private:
 
     std::vector<float> sampleBuffer(
             const sp<GraphicBuffer>& buffer, const Point& leftTop,
-            const std::vector<RegionSamplingThread::Descriptor>& descriptors, uint32_t orientation);
+            const std::vector<RegionSamplingThread::Descriptor>& descriptors);
 
     void doSample(std::optional<std::chrono::steady_clock::time_point> samplingDeadline);
     void binderDied(const wp<IBinder>& who) override;
diff --git a/services/surfaceflinger/Scheduler/EventThread.cpp b/services/surfaceflinger/Scheduler/EventThread.cpp
index 5390295e9a..ba6ddd731e 100644
--- a/services/surfaceflinger/Scheduler/EventThread.cpp
+++ b/services/surfaceflinger/Scheduler/EventThread.cpp
@@ -45,7 +45,8 @@
 #include <common/FlagManager.h>
 #include <scheduler/FrameRateMode.h>
 #include <scheduler/VsyncConfig.h>
-#include "FrameTimeline/FrameTimeline.h"
+#include "FrameTimeline.h"
+#include "Scheduler.h"
 #include "VSyncDispatch.h"
 
 #include "EventThread.h"
@@ -95,9 +96,18 @@ std::string toString(const DisplayEventReceiver::Event& event) {
                                 "}",
                                 to_string(event.header.displayId).c_str(), event.vsync.count,
                                 event.vsync.vsyncData.preferredExpectedPresentationTime());
+        case DisplayEventType::DISPLAY_EVENT_MODE_AND_FRAME_RATE_CHANGE:
+            return StringPrintf("ModeAndFrameRateOverridesChanged{displayId=%s, modeId=%u, "
+                                "appVsyncOffset=%" PRId64 ", presentationDeadline=%" PRId64 "}",
+                                to_string(event.header.displayId).c_str(), event.modeChange.modeId,
+                                event.modeChange.appVsyncOffset,
+                                event.modeChange.presentationDeadline);
         case DisplayEventType::DISPLAY_EVENT_MODE_CHANGE:
-            return StringPrintf("ModeChanged{displayId=%s, modeId=%u}",
-                                to_string(event.header.displayId).c_str(), event.modeChange.modeId);
+            return StringPrintf("ModeChanged{displayId=%s, modeId=%u, appVsyncOffset=%" PRId64
+                                ", presentationDeadline=%" PRId64 "}",
+                                to_string(event.header.displayId).c_str(), event.modeChange.modeId,
+                                event.modeChange.appVsyncOffset,
+                                event.modeChange.presentationDeadline);
         case DisplayEventType::DISPLAY_EVENT_HDCP_LEVELS_CHANGE:
             return StringPrintf("HdcpLevelsChange{displayId=%s, connectedLevel=%d, maxLevel=%d}",
                                 to_string(event.header.displayId).c_str(),
@@ -153,12 +163,17 @@ DisplayEventReceiver::Event makeVSync(PhysicalDisplayId displayId, nsecs_t times
     return event;
 }
 
-DisplayEventReceiver::Event makeModeChanged(const scheduler::FrameRateMode& mode) {
+DisplayEventReceiver::Event makeModeChanged(
+        const scheduler::FrameRateMode& mode, scheduler::VsyncConfigSet config,
+        DisplayEventType eventType = DisplayEventType::DISPLAY_EVENT_MODE_CHANGE) {
     DisplayEventReceiver::Event event;
-    event.header = {DisplayEventType::DISPLAY_EVENT_MODE_CHANGE,
-                    mode.modePtr->getPhysicalDisplayId(), systemTime()};
+    event.header = {eventType, mode.modePtr->getPhysicalDisplayId(), systemTime()};
     event.modeChange.modeId = ftl::to_underlying(mode.modePtr->getId());
     event.modeChange.vsyncPeriod = mode.fps.getPeriodNsecs();
+    event.modeChange.appVsyncOffset = config.late.appOffset;
+    event.modeChange.presentationDeadline =
+            scheduler::Scheduler::getPresentationDeadline(mode.fps,
+                                                          Duration::fromNs(config.late.sfOffset));
     return event;
 }
 
@@ -283,6 +298,13 @@ status_t EventThreadConnection::postEvent(const DisplayEventReceiver::Event& eve
         return toStatus(size);
     }
 
+    if (FlagManager::getInstance().unify_refresh_rate_callbacks()) {
+        mPendingEvents.emplace_back(event);
+        const auto size = DisplayEventReceiver::sendEvents(&mChannel, mPendingEvents.data(),
+                                                           mPendingEvents.size());
+        mPendingEvents.clear();
+        return toStatus(size);
+    }
     auto size = DisplayEventReceiver::sendEvents(&mChannel, &event, 1);
     return toStatus(size);
 }
@@ -294,10 +316,11 @@ EventThread::~EventThread() = default;
 namespace impl {
 
 EventThread::EventThread(const char* name, std::shared_ptr<scheduler::VsyncSchedule> vsyncSchedule,
-                         android::frametimeline::TokenManager* tokenManager,
+                         android::scheduler::TokenManager* tokenManager,
                          IEventThreadCallback& callback, std::chrono::nanoseconds workDuration,
                          std::chrono::nanoseconds readyDuration)
       : mThreadName(name),
+        mEventThreadStateName(base::StringPrintf("EventThreadState-%s", name)),
         mVsyncTracer(base::StringPrintf("VSYNC-%s", name), 0),
         mWorkDuration(base::StringPrintf("VsyncWorkDuration-%s", name), workDuration),
         mReadyDuration(readyDuration),
@@ -328,7 +351,7 @@ EventThread::EventThread(const char* name, std::shared_ptr<scheduler::VsyncSched
 EventThread::~EventThread() {
     {
         std::lock_guard<std::mutex> lock(mMutex);
-        mState = State::Quit;
+        updateState(State::Quit);
         mCondition.notify_all();
     }
     mThread.join();
@@ -351,8 +374,7 @@ sp<EventThreadConnection> EventThread::createEventConnection(
     auto connection = sp<EventThreadConnection>::make(const_cast<EventThread*>(this),
                                                       IPCThreadState::self()->getCallingUid(),
                                                       eventRegistration);
-    if (FlagManager::getInstance().misc1() &&
-        !FlagManager::getInstance().disable_sched_fifo_sf_sched()) {
+    if (!FlagManager::getInstance().disable_sched_fifo_sf_sched()) {
         const int policy = SCHED_FIFO;
         connection->setMinSchedulerPolicy(policy, sched_get_priority_min(policy));
     }
@@ -439,6 +461,8 @@ void EventThread::enableSyntheticVsync(bool enable) {
         return;
     }
 
+    ALOGD("%s synthetic vsync", enable ? "Enabling" : "Disabling");
+
     mVSyncState->synthetic = enable;
     mCondition.notify_all();
 }
@@ -478,10 +502,27 @@ void EventThread::onHotplugConnectionError(int32_t errorCode) {
     mCondition.notify_all();
 }
 
-void EventThread::onModeChanged(const scheduler::FrameRateMode& mode) {
+void EventThread::onModeAndFrameRateOverridesChanged(PhysicalDisplayId displayId,
+                                                     const scheduler::FrameRateMode& mode,
+                                                     std::vector<FrameRateOverride> overrides,
+                                                     scheduler::VsyncConfigSet config) {
+    std::lock_guard<std::mutex> lock(mMutex);
+
+    for (auto frameRateOverride : overrides) {
+        mPendingEvents.push_back(makeFrameRateOverrideEvent(displayId, frameRateOverride));
+    }
+    mPendingEvents.push_back(
+            makeModeChanged(mode, config,
+                            DisplayEventType::DISPLAY_EVENT_MODE_AND_FRAME_RATE_CHANGE));
+
+    mCondition.notify_all();
+}
+
+void EventThread::onModeChanged(const scheduler::FrameRateMode& mode,
+                                scheduler::VsyncConfigSet config) {
     std::lock_guard<std::mutex> lock(mMutex);
 
-    mPendingEvents.push_back(makeModeChanged(mode));
+    mPendingEvents.push_back(makeModeChanged(mode, config));
     mCondition.notify_all();
 }
 
@@ -564,17 +605,17 @@ void EventThread::threadMain(std::unique_lock<std::mutex>& lock) {
             const bool vsyncOmitted =
                     FlagManager::getInstance().no_vsyncs_on_screen_off() && mVSyncState->omitted;
             if (vsyncOmitted) {
-                mState = State::Idle;
+                updateState(State::Idle);
                 SFTRACE_INT("VsyncPendingScreenOn", 1);
             } else {
-                mState = mVSyncState->synthetic ? State::SyntheticVSync : State::VSync;
+                updateState(mVSyncState->synthetic ? State::SyntheticVSync : State::VSync);
                 if (FlagManager::getInstance().no_vsyncs_on_screen_off()) {
                     SFTRACE_INT("VsyncPendingScreenOn", 0);
                 }
             }
         } else {
             ALOGW_IF(!mVSyncState, "Ignoring VSYNC request while display is disconnected");
-            mState = State::Idle;
+            updateState(State::Idle);
         }
 
         if (mState == State::VSync) {
@@ -641,10 +682,11 @@ bool EventThread::shouldConsumeEvent(const DisplayEventReceiver::Event& event,
         case DisplayEventType::DISPLAY_EVENT_HDCP_LEVELS_CHANGE:
             return true;
 
-        case DisplayEventType::DISPLAY_EVENT_MODE_CHANGE: {
+        case DisplayEventType::DISPLAY_EVENT_MODE_AND_FRAME_RATE_CHANGE:
+            [[fallthrough]];
+        case DisplayEventType::DISPLAY_EVENT_MODE_CHANGE:
             return connection->mEventRegistration.test(
                     gui::ISurfaceComposer::EventRegistration::modeChanged);
-        }
 
         case DisplayEventType::DISPLAY_EVENT_MODE_REJECTION:
             return true;
@@ -820,6 +862,16 @@ void EventThread::dump(std::string& result) const {
     result += '\n';
 }
 
+void EventThread::updateState(State state) {
+    if (state == mState) {
+        return;
+    }
+    mState = state;
+
+    SFTRACE_ASYNC_FOR_TRACK_END(mEventThreadStateName.c_str(), 0);
+    SFTRACE_ASYNC_FOR_TRACK_BEGIN(mEventThreadStateName.c_str(), toCString(mState), 0);
+}
+
 const char* EventThread::toCString(State state) {
     switch (state) {
         case State::Idle:
@@ -855,6 +907,16 @@ scheduler::VSyncCallbackRegistration EventThread::onNewVsyncScheduleInternal(
                                      .lastVsync = mLastVsyncCallbackTime.ns(),
                                      .committedVsyncOpt = mLastCommittedVsyncTime.ns()});
     }
+
+    // Hotplug disconnect causes mVSyncState to get nuked when the pacesetter display is
+    // disconnected. Without mVSyncState, all vsync events are ignored, and thus the apps freeze
+    // their transactions. The only way to revive the 'mVSyncState' right now is a new Hotplug
+    // connect event. We should also revive 'mVSyncState' here so that when a new pacesetter is
+    // selected, it can have a new vsync state.
+    if (FlagManager::getInstance().pacesetter_selection() && !mVSyncState) {
+        SFTRACE_FORMAT_INSTANT("OnNewVsyncScheduleInternalNewState");
+        mVSyncState.emplace();
+    }
     return oldRegistration;
 }
 
diff --git a/services/surfaceflinger/Scheduler/EventThread.h b/services/surfaceflinger/Scheduler/EventThread.h
index 612883a88b..643ad62c8f 100644
--- a/services/surfaceflinger/Scheduler/EventThread.h
+++ b/services/surfaceflinger/Scheduler/EventThread.h
@@ -25,6 +25,7 @@
 #include <utils/Errors.h>
 
 #include <scheduler/FrameRateMode.h>
+#include <scheduler/VsyncConfig.h>
 #include <condition_variable>
 #include <cstdint>
 #include <deque>
@@ -46,9 +47,9 @@ class EventThread;
 class EventThreadTest;
 class SurfaceFlinger;
 
-namespace frametimeline {
+namespace scheduler {
 class TokenManager;
-} // namespace frametimeline
+} // namespace scheduler
 
 using gui::ParcelableVsyncEventData;
 using gui::VsyncEventData;
@@ -113,8 +114,16 @@ public:
 
     virtual void onHotplugConnectionError(int32_t connectionError) = 0;
 
-    // called when SF changes the active mode and apps needs to be notified about the change
-    virtual void onModeChanged(const scheduler::FrameRateMode&) = 0;
+    // Called when apps need to be notified about the change in the active mode and
+    // frame rate overrides.
+    virtual void onModeAndFrameRateOverridesChanged(PhysicalDisplayId,
+                                                    const scheduler::FrameRateMode&,
+                                                    std::vector<FrameRateOverride>,
+                                                    scheduler::VsyncConfigSet) = 0;
+
+    // called when SF changes the active mode or updates the WorkDuration
+    // and apps needs to be notified about the change
+    virtual void onModeChanged(const scheduler::FrameRateMode&, scheduler::VsyncConfigSet) = 0;
 
     // called when SF rejects the mode change request
     virtual void onModeRejected(PhysicalDisplayId displayId, DisplayModeId modeId) = 0;
@@ -156,7 +165,7 @@ namespace impl {
 class EventThread : public android::EventThread {
 public:
     EventThread(const char* name, std::shared_ptr<scheduler::VsyncSchedule>,
-                frametimeline::TokenManager*, IEventThreadCallback& callback,
+                scheduler::TokenManager*, IEventThreadCallback& callback,
                 std::chrono::nanoseconds workDuration, std::chrono::nanoseconds readyDuration);
     ~EventThread();
 
@@ -177,7 +186,11 @@ public:
 
     void onHotplugConnectionError(int32_t connectionError) override;
 
-    void onModeChanged(const scheduler::FrameRateMode&) override;
+    void onModeAndFrameRateOverridesChanged(PhysicalDisplayId, const scheduler::FrameRateMode&,
+                                            std::vector<FrameRateOverride>,
+                                            scheduler::VsyncConfigSet) override;
+
+    void onModeChanged(const scheduler::FrameRateMode&, scheduler::VsyncConfigSet) override;
 
     void onModeRejected(PhysicalDisplayId displayId, DisplayModeId modeId) override;
 
@@ -225,6 +238,7 @@ private:
             std::shared_ptr<scheduler::VsyncSchedule>) EXCLUDES(mMutex);
 
     const char* const mThreadName;
+    std::string mEventThreadStateName;
     TracedOrdinal<int> mVsyncTracer;
     TracedOrdinal<std::chrono::nanoseconds> mWorkDuration GUARDED_BY(mMutex);
     std::chrono::nanoseconds mReadyDuration GUARDED_BY(mMutex);
@@ -232,7 +246,7 @@ private:
     TimePoint mLastVsyncCallbackTime GUARDED_BY(mMutex) = TimePoint::now();
     TimePoint mLastCommittedVsyncTime GUARDED_BY(mMutex) = TimePoint::now();
     scheduler::VSyncCallbackRegistration mVsyncRegistration GUARDED_BY(mMutex);
-    frametimeline::TokenManager* const mTokenManager;
+    scheduler::TokenManager* const mTokenManager;
 
     IEventThreadCallback& mCallback;
 
@@ -269,6 +283,8 @@ private:
 
     State mState GUARDED_BY(mMutex) = State::Idle;
 
+    void updateState(State state) REQUIRES(mMutex);
+
     static const char* toCString(State);
 };
 
diff --git a/services/surfaceflinger/FrameTimeline/FrameTimeline.cpp b/services/surfaceflinger/Scheduler/FrameTimeline.cpp
similarity index 99%
rename from services/surfaceflinger/FrameTimeline/FrameTimeline.cpp
rename to services/surfaceflinger/Scheduler/FrameTimeline.cpp
index 51d4078987..da8d3d033d 100644
--- a/services/surfaceflinger/FrameTimeline/FrameTimeline.cpp
+++ b/services/surfaceflinger/Scheduler/FrameTimeline.cpp
@@ -30,9 +30,9 @@
 #include <numeric>
 #include <unordered_set>
 
-#include "../Jank/JankTracker.h"
+#include "Jank/JankTracker.h"
 
-namespace android::frametimeline {
+namespace android::scheduler {
 
 using base::StringAppendF;
 using FrameTimelineEvent = perfetto::protos::pbzero::FrameTimelineEvent;
@@ -338,7 +338,7 @@ int64_t TraceCookieCounter::getCookieForTracing() {
 SurfaceFrame::SurfaceFrame(const FrameTimelineInfo& frameTimelineInfo, pid_t ownerPid,
                            uid_t ownerUid, int32_t layerId, std::string layerName,
                            std::string debugName, PredictionState predictionState,
-                           frametimeline::TimelineItem&& predictions,
+                           scheduler::TimelineItem&& predictions,
                            std::shared_ptr<TimeStats> timeStats,
                            JankClassificationThresholds thresholds,
                            TraceCookieCounter* traceCookieCounter, bool isBuffer, GameMode gameMode)
@@ -916,9 +916,7 @@ FrameTimeline::FrameTimeline(std::shared_ptr<TimeStats> timeStats, pid_t surface
                              JankClassificationThresholds thresholds, bool useBootTimeClock,
                              bool filterFramesBeforeTraceStarts)
       : mUseBootTimeClock(useBootTimeClock),
-        mFilterFramesBeforeTraceStarts(
-                FlagManager::getInstance().filter_frames_before_trace_starts() &&
-                filterFramesBeforeTraceStarts),
+        mFilterFramesBeforeTraceStarts(filterFramesBeforeTraceStarts),
         mMaxDisplayFrames(kDefaultMaxDisplayFrames),
         mTimeStats(std::move(timeStats)),
         mSurfaceFlingerPid(surfaceFlingerPid),
@@ -1398,10 +1396,8 @@ nsecs_t FrameTimeline::DisplayFrame::trace(pid_t surfaceFlingerPid, nsecs_t mono
         surfaceFrame->trace(mToken, monoBootOffset, filterFramesBeforeTraceStarts);
     }
 
-    if (FlagManager::getInstance().add_sf_skipped_frames_to_trace()) {
-        addSkippedFrame(surfaceFlingerPid, monoBootOffset, previousPredictionPresentTime,
-                        filterFramesBeforeTraceStarts);
-    }
+    addSkippedFrame(surfaceFlingerPid, monoBootOffset, previousPredictionPresentTime,
+                    filterFramesBeforeTraceStarts);
     return mSurfaceFlingerPredictions.presentTime;
 }
 
@@ -1671,4 +1667,4 @@ void FrameTimeline::reset() {
 }
 
 } // namespace impl
-} // namespace android::frametimeline
+} // namespace android::scheduler
diff --git a/services/surfaceflinger/FrameTimeline/FrameTimeline.h b/services/surfaceflinger/Scheduler/FrameTimeline.h
similarity index 97%
rename from services/surfaceflinger/FrameTimeline/FrameTimeline.h
rename to services/surfaceflinger/Scheduler/FrameTimeline.h
index fa83cd8523..9018b0dbb6 100644
--- a/services/surfaceflinger/FrameTimeline/FrameTimeline.h
+++ b/services/surfaceflinger/Scheduler/FrameTimeline.h
@@ -39,7 +39,7 @@
 
 #include "../TimeStats/TimeStats.h"
 
-namespace android::frametimeline {
+namespace android::scheduler {
 
 class FrameTimelineTest;
 
@@ -150,7 +150,7 @@ public:
 
 private:
     // Friend class for testing
-    friend class android::frametimeline::FrameTimelineTest;
+    friend class android::scheduler::FrameTimelineTest;
 
     std::atomic<int64_t> mTraceCookie = 0;
 };
@@ -358,7 +358,7 @@ public:
 
 namespace impl {
 
-class TokenManager : public android::frametimeline::TokenManager {
+class TokenManager : public android::scheduler::TokenManager {
 public:
     TokenManager() : mCurrentToken(FrameTimelineInfo::INVALID_VSYNC_ID + 1) {}
     ~TokenManager() = default;
@@ -368,7 +368,7 @@ public:
 
 private:
     // Friend class for testing
-    friend class android::frametimeline::FrameTimelineTest;
+    friend class android::scheduler::FrameTimelineTest;
 
     void flushTokens(nsecs_t flushTime) REQUIRES(mMutex);
 
@@ -378,7 +378,7 @@ private:
     static constexpr size_t kMaxTokens = 500;
 };
 
-class FrameTimeline : public android::frametimeline::FrameTimeline {
+class FrameTimeline : public android::scheduler::FrameTimeline {
 public:
     class FrameTimelineDataSource : public perfetto::DataSource<FrameTimelineDataSource> {
     public:
@@ -499,12 +499,12 @@ public:
                   bool filterFramesBeforeTraceStarts = true);
     ~FrameTimeline() = default;
 
-    frametimeline::TokenManager* getTokenManager() override { return &mTokenManager; }
+    scheduler::TokenManager* getTokenManager() override { return &mTokenManager; }
     std::shared_ptr<SurfaceFrame> createSurfaceFrameForToken(
             const FrameTimelineInfo& frameTimelineInfo, pid_t ownerPid, uid_t ownerUid,
             int32_t layerId, std::string layerName, std::string debugName, bool isBuffer,
             GameMode) override;
-    void addSurfaceFrame(std::shared_ptr<frametimeline::SurfaceFrame> surfaceFrame) override;
+    void addSurfaceFrame(std::shared_ptr<scheduler::SurfaceFrame> surfaceFrame) override;
     void setSfWakeUp(int64_t token, nsecs_t wakeupTime, Fps refreshRate, Fps renderRate) override;
     void setSfPresent(nsecs_t sfPresentTime, const std::shared_ptr<FenceTime>& presentFence,
                       const std::shared_ptr<FenceTime>& gpuFence = FenceTime::NO_FENCE) override;
@@ -525,7 +525,7 @@ public:
 
 private:
     // Friend class for testing
-    friend class android::frametimeline::FrameTimelineTest;
+    friend class android::scheduler::FrameTimelineTest;
 
     void flushPendingPresentFences() REQUIRES(mMutex);
     std::optional<size_t> getFirstSignalFenceIndex() const REQUIRES(mMutex);
@@ -558,4 +558,4 @@ private:
 };
 
 } // namespace impl
-} // namespace android::frametimeline
+} // namespace android::scheduler
diff --git a/services/surfaceflinger/Scheduler/ISchedulerCallback.h b/services/surfaceflinger/Scheduler/ISchedulerCallback.h
index d02d14912f..5cae398b0e 100644
--- a/services/surfaceflinger/Scheduler/ISchedulerCallback.h
+++ b/services/surfaceflinger/Scheduler/ISchedulerCallback.h
@@ -32,7 +32,8 @@ struct ISchedulerCallback {
     virtual void onExpectedPresentTimePosted(TimePoint, ftl::NonNull<DisplayModePtr>,
                                              Fps renderRate) = 0;
     virtual void onCommitNotComposited() = 0;
-    virtual void vrrDisplayIdle(bool idle) = 0;
+    virtual void vrrDisplayIdle(PhysicalDisplayId, bool idle) = 0;
+    virtual void enableLayerCachingTexturePool(PhysicalDisplayId, bool enable) = 0;
 
 protected:
     ~ISchedulerCallback() = default;
diff --git a/services/surfaceflinger/Scheduler/LayerHistory.cpp b/services/surfaceflinger/Scheduler/LayerHistory.cpp
index 630beb03a3..5931339700 100644
--- a/services/surfaceflinger/Scheduler/LayerHistory.cpp
+++ b/services/surfaceflinger/Scheduler/LayerHistory.cpp
@@ -41,7 +41,7 @@ namespace android::scheduler {
 namespace {
 
 bool isLayerActive(const LayerInfo& info, nsecs_t threshold, bool isVrrDevice) {
-    if (FlagManager::getInstance().misc1() && !info.isVisible()) {
+    if (!info.isVisible()) {
         return false;
     }
 
@@ -122,6 +122,10 @@ void LayerHistory::registerLayer(Layer* layer, bool contentDetectionEnabled,
     mInactiveLayerInfos.insert({layer->getSequence(), std::make_pair(layer, std::move(info))});
 }
 
+void LayerHistory::setDisplaySize(ui::Size displaySize) {
+    mDisplayArea = static_cast<uint32_t>(displaySize.width * displaySize.height);
+}
+
 void LayerHistory::deregisterLayer(Layer* layer) {
     std::lock_guard lock(mLock);
     if (!mActiveLayerInfos.erase(layer->getSequence())) {
@@ -405,9 +409,11 @@ void LayerHistory::clear() {
 
 std::string LayerHistory::dump() const {
     std::lock_guard lock(mLock);
-    return base::StringPrintf("{size=%zu, active=%zu}\n\tGameFrameRateOverrides=\n\t\t%s",
+    return base::StringPrintf("{size=%zu, active=%zu}\n\tdisplayArea=%" PRIu32
+                              "\n\tGameFrameRateOverrides=\n\t\t%s",
                               mActiveLayerInfos.size() + mInactiveLayerInfos.size(),
-                              mActiveLayerInfos.size(), dumpGameFrameRateOverridesLocked().c_str());
+                              mActiveLayerInfos.size(), mDisplayArea,
+                              dumpGameFrameRateOverridesLocked().c_str());
 }
 
 std::string LayerHistory::dumpGameFrameRateOverridesLocked() const {
@@ -442,7 +448,7 @@ auto LayerHistory::findLayer(int32_t id) -> std::pair<LayerStatus, LayerPair*> {
 }
 
 bool LayerHistory::isSmallDirtyArea(uint32_t dirtyArea, float threshold) const {
-    const float ratio = (float)dirtyArea / mDisplayArea;
+    const float ratio = static_cast<float>(dirtyArea) / mDisplayArea;
     const bool isSmallDirty = ratio <= threshold;
     SFTRACE_FORMAT_INSTANT("small dirty=%s, ratio=%.3f", isSmallDirty ? "true" : "false", ratio);
     return isSmallDirty;
diff --git a/services/surfaceflinger/Scheduler/LayerHistory.h b/services/surfaceflinger/Scheduler/LayerHistory.h
index e3babbabef..77b7981c19 100644
--- a/services/surfaceflinger/Scheduler/LayerHistory.h
+++ b/services/surfaceflinger/Scheduler/LayerHistory.h
@@ -54,8 +54,8 @@ public:
     void registerLayer(Layer*, bool contentDetectionEnabled,
                        FrameRateCompatibility frameRateCompatibility);
 
-    // Sets the display size. Client is responsible for synchronization.
-    void setDisplayArea(uint32_t displayArea) { mDisplayArea = displayArea; }
+    // Client is responsible for synchronization.
+    void setDisplaySize(ui::Size displaySize);
 
     // Sets whether a mode change is pending to be applied
     void setModeChangePending(bool pending) { mModeChangePending = pending; }
@@ -143,6 +143,7 @@ private:
     LayerInfos mActiveLayerInfos GUARDED_BY(mLock);
     LayerInfos mInactiveLayerInfos GUARDED_BY(mLock);
 
+    // TODO: Track display areas on a per-display basis rather than as a single global state.
     uint32_t mDisplayArea = 0;
 
     // Whether to emit systrace output and debug logs.
@@ -151,7 +152,8 @@ private:
     // Whether to use priority sent from WindowManager to determine the relevancy of the layer.
     const bool mUseFrameRatePriority;
 
-    // Whether a mode change is in progress or not
+    // Whether a mode change is in progress or not.
+    /// TODO: Track mode change pending on a per-display basis rather than as a single global state.
     std::atomic<bool> mModeChangePending = false;
 
     // A list to look up the game frame rate overrides
diff --git a/services/surfaceflinger/Scheduler/MessageQueue.cpp b/services/surfaceflinger/Scheduler/MessageQueue.cpp
index 91a798ed3e..d51492f42e 100644
--- a/services/surfaceflinger/Scheduler/MessageQueue.cpp
+++ b/services/surfaceflinger/Scheduler/MessageQueue.cpp
@@ -24,7 +24,7 @@
 #include <scheduler/interface/ICompositor.h>
 
 #include "EventThread.h"
-#include "FrameTimeline/FrameTimeline.h"
+#include "FrameTimeline.h"
 #include "MessageQueue.h"
 
 namespace android::impl {
@@ -75,7 +75,7 @@ void MessageQueue::vsyncCallback(nsecs_t vsyncTime, nsecs_t targetWakeupTime, ns
 }
 
 void MessageQueue::initVsyncInternal(std::shared_ptr<scheduler::VSyncDispatch> dispatch,
-                                     frametimeline::TokenManager& tokenManager,
+                                     scheduler::TokenManager& tokenManager,
                                      std::chrono::nanoseconds workDuration) {
     std::unique_ptr<scheduler::VSyncCallbackRegistration> oldRegistration;
     {
diff --git a/services/surfaceflinger/Scheduler/MessageQueue.h b/services/surfaceflinger/Scheduler/MessageQueue.h
index ba1efbe58f..d7cd87491d 100644
--- a/services/surfaceflinger/Scheduler/MessageQueue.h
+++ b/services/surfaceflinger/Scheduler/MessageQueue.h
@@ -66,7 +66,7 @@ public:
     virtual ~MessageQueue() = default;
 
     virtual void initVsyncInternal(std::shared_ptr<scheduler::VSyncDispatch>,
-                                   frametimeline::TokenManager&,
+                                   scheduler::TokenManager&,
                                    std::chrono::nanoseconds workDuration) = 0;
     virtual void destroyVsync() = 0;
     virtual void setDuration(std::chrono::nanoseconds workDuration) = 0;
@@ -118,7 +118,7 @@ private:
     const sp<Handler> mHandler;
 
     struct Vsync {
-        frametimeline::TokenManager* tokenManager = nullptr;
+        scheduler::TokenManager* tokenManager = nullptr;
 
         mutable std::mutex mutex;
         std::unique_ptr<scheduler::VSyncCallbackRegistration> registration GUARDED_BY(mutex);
@@ -139,7 +139,7 @@ private:
 public:
     explicit MessageQueue(ICompositor&);
 
-    void initVsyncInternal(std::shared_ptr<scheduler::VSyncDispatch>, frametimeline::TokenManager&,
+    void initVsyncInternal(std::shared_ptr<scheduler::VSyncDispatch>, scheduler::TokenManager&,
                            std::chrono::nanoseconds workDuration) override;
     void destroyVsync() override;
     void setDuration(std::chrono::nanoseconds workDuration) override;
diff --git a/services/surfaceflinger/Scheduler/OneShotTimer.h b/services/surfaceflinger/Scheduler/OneShotTimer.h
index 4e1e2eef00..c851faa4f1 100644
--- a/services/surfaceflinger/Scheduler/OneShotTimer.h
+++ b/services/surfaceflinger/Scheduler/OneShotTimer.h
@@ -19,6 +19,7 @@
 #include <semaphore.h>
 #include <chrono>
 #include <condition_variable>
+#include <functional>
 #include <thread>
 #include "../Clock.h"
 
diff --git a/services/surfaceflinger/Scheduler/RefreshRateSelector.cpp b/services/surfaceflinger/Scheduler/RefreshRateSelector.cpp
index 97f1f8ff31..7efb687135 100644
--- a/services/surfaceflinger/Scheduler/RefreshRateSelector.cpp
+++ b/services/surfaceflinger/Scheduler/RefreshRateSelector.cpp
@@ -1089,7 +1089,7 @@ auto RefreshRateSelector::getFrameRateOverrides(const std::vector<LayerRequireme
         ALOGV("%s: overriding to %s for uid=%d", __func__, to_string(overrideFps).c_str(), uid);
         SFTRACE_FORMAT_INSTANT("%s: overriding to %s for uid=%d", __func__,
                                to_string(overrideFps).c_str(), uid);
-        if (SFTRACE_ENABLED() && FlagManager::getInstance().trace_frame_rate_override()) {
+        if (SFTRACE_ENABLED()) {
             std::stringstream ss;
             ss << "FrameRateOverride " << uid;
             SFTRACE_INT(ss.str().c_str(), overrideFps.getIntValue());
@@ -1674,7 +1674,7 @@ void RefreshRateSelector::dump(utils::Dumper& dumper) const {
 }
 
 std::chrono::milliseconds RefreshRateSelector::getIdleTimerTimeout() {
-    if (FlagManager::getInstance().idle_screen_refresh_rate_timeout() && mIdleTimer) {
+    if (mIdleTimer) {
         return std::chrono::duration_cast<std::chrono::milliseconds>(mIdleTimer->interval());
     }
     return mConfig.legacyIdleTimerTimeout;
diff --git a/services/surfaceflinger/Scheduler/Scheduler.cpp b/services/surfaceflinger/Scheduler/Scheduler.cpp
index 16266c6b00..6a8155ba38 100644
--- a/services/surfaceflinger/Scheduler/Scheduler.cpp
+++ b/services/surfaceflinger/Scheduler/Scheduler.cpp
@@ -35,7 +35,6 @@
 #include <ui/DisplayMap.h>
 #include <utils/Timers.h>
 
-#include <FrameTimeline/FrameTimeline.h>
 #include <scheduler/interface/ICompositor.h>
 
 #include <cinttypes>
@@ -47,6 +46,7 @@
 #include <common/FlagManager.h>
 #include "EventThread.h"
 #include "FrameRateOverrideMappings.h"
+#include "FrameTimeline.h"
 #include "FrontEnd/LayerHandle.h"
 #include "Layer.h"
 #include "OneShotTimer.h"
@@ -83,8 +83,7 @@ Scheduler::~Scheduler() {
     demotePacesetterDisplay({.toggleIdleTimer = true});
 }
 
-void Scheduler::initVsync(frametimeline::TokenManager& tokenManager,
-                          std::chrono::nanoseconds workDuration) {
+void Scheduler::initVsync(TokenManager& tokenManager, std::chrono::nanoseconds workDuration) {
     Impl::initVsyncInternal(getVsyncSchedule()->getDispatch(), tokenManager, workDuration);
 }
 
@@ -92,11 +91,7 @@ void Scheduler::startTimers() {
     using namespace sysprop;
     using namespace std::string_literals;
 
-    const int32_t defaultTouchTimerValue =
-            FlagManager::getInstance().enable_fro_dependent_features() &&
-                    sysprop::enable_frame_rate_override(true)
-            ? 200
-            : 0;
+    const int32_t defaultTouchTimerValue = sysprop::enable_frame_rate_override(true) ? 200 : 0;
     if (const int32_t millis = set_touch_timer_ms(defaultTouchTimerValue); millis > 0) {
         // Touch events are coming to SF every 100ms, so the timer needs to be higher than that
         mTouchTimer.emplace(
@@ -128,9 +123,16 @@ void Scheduler::setPacesetterDisplay(PhysicalDisplayId pacesetterId) {
         std::scoped_lock lock{mVsyncConfigLock};
         mVsyncConfiguration->reset();
     }
+
     updatePhaseConfiguration(pacesetterId, pacesetterSelectorPtr()->getActiveMode().fps);
 }
 
+PhysicalDisplayId Scheduler::getPacesetterDisplayId() const {
+    std::scoped_lock lock(mDisplayLock);
+    LOG_ALWAYS_FATAL_IF(!mPacesetterDisplayId, "Missing a pacesetter!");
+    return *mPacesetterDisplayId;
+}
+
 void Scheduler::registerDisplay(PhysicalDisplayId displayId, RefreshRateSelectorPtr selectorPtr,
                                 PhysicalDisplayId activeDisplayId) {
     auto schedulePtr =
@@ -356,7 +358,7 @@ void Scheduler::onExpectedPresentTimePosted(TimePoint expectedPresentTime) {
     }
 }
 
-void Scheduler::createEventThread(Cycle cycle, frametimeline::TokenManager* tokenManager,
+void Scheduler::createEventThread(Cycle cycle, TokenManager* tokenManager,
                                   std::chrono::nanoseconds workDuration,
                                   std::chrono::nanoseconds readyDuration) {
     auto eventThread =
@@ -420,19 +422,35 @@ void Scheduler::omitVsyncDispatching(bool omitted) {
     eventThreadFor(Cycle::LastComposite).omitVsyncDispatching(omitted);
 }
 
-void Scheduler::onFrameRateOverridesChanged() {
-    const auto [pacesetterId, supportsFrameRateOverrideByContent] = [this] {
+std::pair<FrameRateMode, std::vector<FrameRateOverride>> Scheduler::getFrameRateOverrides() {
+    const auto [activeMode, supportsFrameRateOverrideByContent] = [this] {
         std::scoped_lock lock(mDisplayLock);
         const auto pacesetterOpt = pacesetterDisplayLocked();
         LOG_ALWAYS_FATAL_IF(!pacesetterOpt);
         const Display& pacesetter = *pacesetterOpt;
-        return std::make_pair(FTL_FAKE_GUARD(kMainThreadContext, *mPacesetterDisplayId),
+        return std::make_pair(pacesetter.selectorPtr->getActiveMode(),
                               pacesetter.selectorPtr->supportsAppFrameRateOverrideByContent());
     }();
 
-    std::vector<FrameRateOverride> overrides =
-            mFrameRateOverrideMappings.getAllFrameRateOverrides(supportsFrameRateOverrideByContent);
+    return {activeMode,
+            mFrameRateOverrideMappings.getAllFrameRateOverrides(
+                    supportsFrameRateOverrideByContent)};
+}
 
+void Scheduler::onFrameRateOverridesChanged() {
+    const PhysicalDisplayId pacesetterId = [this] {
+        std::scoped_lock lock(mDisplayLock);
+        return FTL_FAKE_GUARD(kMainThreadContext, *mPacesetterDisplayId);
+    }();
+    auto [pacesetterMode, overrides] = getFrameRateOverrides();
+
+    if (FlagManager::getInstance().unify_refresh_rate_callbacks()) {
+        const auto vsyncConfigSet = getVsyncConfigsForRefreshRate(pacesetterMode.fps);
+        eventThreadFor(Cycle::Render)
+                .onModeAndFrameRateOverridesChanged(pacesetterId, pacesetterMode,
+                                                    std::move(overrides), vsyncConfigSet);
+        return;
+    }
     eventThreadFor(Cycle::Render).onFrameRateOverridesChanged(pacesetterId, std::move(overrides));
 }
 
@@ -443,8 +461,9 @@ void Scheduler::onHdcpLevelsChanged(Cycle cycle, PhysicalDisplayId displayId,
 
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Wunused-value" // b/369277774
-bool Scheduler::onDisplayModeChanged(PhysicalDisplayId displayId, const FrameRateMode& mode,
-                                     bool clearContentRequirements) {
+bool Scheduler::updatePolicyContentRequirements(PhysicalDisplayId displayId,
+                                                const FrameRateMode& mode,
+                                                bool clearContentRequirements) {
     const bool isPacesetter =
             FTL_FAKE_GUARD(kMainThreadContext,
                            (std::scoped_lock(mDisplayLock), displayId == mPacesetterDisplayId));
@@ -459,14 +478,42 @@ bool Scheduler::onDisplayModeChanged(PhysicalDisplayId displayId, const FrameRat
             mPolicy.contentRequirements.clear();
         }
     }
+    return isPacesetter;
+}
+#pragma clang diagnostic pop
+
+bool Scheduler::onDisplayModeChanged(PhysicalDisplayId displayId, const FrameRateMode& mode,
+                                     bool clearContentRequirements) {
+    const bool isPacesetter =
+            updatePolicyContentRequirements(displayId, mode, clearContentRequirements);
+    if (FlagManager::getInstance().unify_refresh_rate_callbacks()) {
+        return onDisplayModeAndFrameRateOverridesChanged(displayId, mode, clearContentRequirements);
+    }
+    if (hasEventThreads()) {
+        const auto vsyncConfigSet = getVsyncConfigsForRefreshRate(mode.fps);
+        eventThreadFor(Cycle::Render).onModeChanged(mode, vsyncConfigSet);
+    }
+    return isPacesetter;
+}
 
+bool Scheduler::onDisplayModeAndFrameRateOverridesChanged(PhysicalDisplayId displayId,
+                                                          const FrameRateMode& mode,
+                                                          bool clearContentRequirements) {
+    const bool isPacesetter =
+            updatePolicyContentRequirements(displayId, mode, clearContentRequirements);
     if (hasEventThreads()) {
-        eventThreadFor(Cycle::Render).onModeChanged(mode);
+        const PhysicalDisplayId pacesetterId = [this] {
+            std::scoped_lock lock(mDisplayLock);
+            return FTL_FAKE_GUARD(kMainThreadContext, *mPacesetterDisplayId);
+        }();
+        const auto vsyncConfigSet = getVsyncConfigsForRefreshRate(mode.fps);
+        const auto [pacesetterMode, overrides] = getFrameRateOverrides();
+        eventThreadFor(Cycle::Render)
+                .onModeAndFrameRateOverridesChanged(pacesetterId, mode, overrides, vsyncConfigSet);
     }
 
     return isPacesetter;
 }
-#pragma clang diagnostic pop
 
 void Scheduler::onDisplayModeRejected(PhysicalDisplayId displayId, DisplayModeId modeId) {
     if (hasEventThreads()) {
@@ -495,7 +542,15 @@ void Scheduler::emitModeChangeIfNeeded() {
     mPolicy.emittedModeOpt = mode;
 
     if (hasEventThreads()) {
-        eventThreadFor(Cycle::Render).onModeChanged(mode);
+        const auto vsyncConfigSet = getVsyncConfigsForRefreshRate(mode.fps);
+        if (FlagManager::getInstance().unify_refresh_rate_callbacks()) {
+            const auto [pacesetterMode, overrides] = getFrameRateOverrides();
+            eventThreadFor(Cycle::Render)
+                    .onModeAndFrameRateOverridesChanged(mode.modePtr->getPhysicalDisplayId(), mode,
+                                                        overrides, vsyncConfigSet);
+        } else {
+            eventThreadFor(Cycle::Render).onModeChanged(mode, vsyncConfigSet);
+        }
     }
 }
 
@@ -528,15 +583,25 @@ void Scheduler::updatePhaseConfiguration(PhysicalDisplayId displayId, Fps refres
 }
 #pragma clang diagnostic pop
 
-void Scheduler::reloadPhaseConfiguration(Fps refreshRate, Duration minSfDuration,
+void Scheduler::reloadPhaseConfiguration(const FrameRateMode& mode, Duration minSfDuration,
                                          Duration maxSfDuration, Duration appDuration) {
     const auto currentConfigs = [=, this] {
         std::scoped_lock lock{mVsyncConfigLock};
-        mVsyncConfiguration = std::make_unique<impl::WorkDuration>(refreshRate, minSfDuration,
+        mVsyncConfiguration = std::make_unique<impl::WorkDuration>(mode.fps, minSfDuration,
                                                                    maxSfDuration, appDuration);
         return mVsyncConfiguration->getCurrentConfigs();
     }();
-    setVsyncConfig(mVsyncModulator->setVsyncConfigSet(currentConfigs), refreshRate.getPeriod());
+    setVsyncConfig(mVsyncModulator->setVsyncConfigSet(currentConfigs), mode.fps.getPeriod());
+
+    if (FlagManager::getInstance().unify_refresh_rate_callbacks()) {
+        onDisplayModeAndFrameRateOverridesChanged(mode.modePtr->getPhysicalDisplayId(), mode,
+                                                  /*clearContentRequirements*/ false);
+        return;
+    }
+    if (hasEventThreads()) {
+        const auto vsyncConfigSet = getVsyncConfigsForRefreshRate(mode.fps);
+        eventThreadFor(Cycle::Render).onModeChanged(mode, vsyncConfigSet);
+    }
 }
 
 void Scheduler::setActiveDisplayPowerModeForRefreshRateStats(hal::PowerMode powerMode) {
@@ -637,8 +702,9 @@ void Scheduler::setRenderRate(PhysicalDisplayId id, Fps renderFrameRate, bool ap
 
     ALOGV("%s %s (%s)", __func__, to_string(mode.fps).c_str(),
           to_string(mode.modePtr->getVsyncRate()).c_str());
-
-    display.schedulePtr->getTracker().setRenderRate(renderFrameRate, applyImmediately);
+    std::vector<FrameRateOverride> overrides = mFrameRateOverrideMappings.getAllFrameRateOverrides(
+            display.selectorPtr->supportsAppFrameRateOverrideByContent());
+    display.schedulePtr->getTracker().setRenderRate(renderFrameRate, applyImmediately, overrides);
 }
 
 Fps Scheduler::getNextFrameInterval(PhysicalDisplayId id,
@@ -730,8 +796,24 @@ void Scheduler::recordLayerHistory(int32_t id, const LayerProps& layerProps, nse
     }
 }
 
-void Scheduler::setModeChangePending(bool pending) {
-    mLayerHistory.setModeChangePending(pending);
+void Scheduler::setModeChangePending(PhysicalDisplayId displayId, bool pending) {
+    if (!FlagManager::getInstance().pacesetter_selection()) {
+        mLayerHistory.setModeChangePending(pending);
+        return;
+    }
+
+    std::scoped_lock lock(mDisplayLock);
+    ftl::FakeGuard guard(kMainThreadContext);
+    const auto displayOpt = mDisplays.get(displayId);
+    if (!displayOpt) {
+        ALOGW("%s: Invalid display %s!", __func__, to_string(displayId).c_str());
+        return;
+    }
+    displayOpt->get().isModeChangePending = pending;
+
+    mLayerHistory.setModeChangePending(
+            std::any_of(mDisplays.cbegin(), mDisplays.cend(),
+                        [](const auto& display) { return display.second.isModeChangePending; }));
 }
 
 void Scheduler::setDefaultFrameRateCompatibility(
@@ -834,12 +916,23 @@ auto Scheduler::getVsyncScheduleLocked(std::optional<PhysicalDisplayId> idOpt) c
     return displayOpt->get().schedulePtr;
 }
 
-void Scheduler::kernelIdleTimerCallback(TimerState state) {
+void Scheduler::kernelIdleTimerCallback(PhysicalDisplayId displayId, TimerState state) {
     SFTRACE_INT("ExpiredKernelIdleTimer", static_cast<int>(state));
 
-    // TODO(145561154): cleanup the kernel idle timer implementation and the refresh rate
-    // magic number
-    const Fps refreshRate = pacesetterSelectorPtr()->getActiveMode().modePtr->getPeakFps();
+    Fps refreshRate;
+    {
+        std::scoped_lock lock(mDisplayLock);
+        ftl::FakeGuard guard(kMainThreadContext);
+        const auto displayOpt = mDisplays.get(displayId);
+        if (!displayOpt) {
+            ALOGW("%s: Invalid display %s!", __func__, to_string(displayId).c_str());
+            return;
+        }
+
+        // TODO: b/145561154 - Clean up the kernel idle timer implementation and the refresh rate
+        // magic number
+        refreshRate = displayOpt->get().selectorPtr->getActiveMode().modePtr->getPeakFps();
+    }
 
     constexpr Fps FPS_THRESHOLD_FOR_KERNEL_TIMER = 65_Hz;
     using namespace fps_approx_ops;
@@ -934,6 +1027,7 @@ void Scheduler::dump(utils::Dumper& dumper) const {
 
         display.selectorPtr->dump(dumper);
         display.targeterPtr->dump(dumper);
+        dumper.dump("isModeChangePending"sv, display.isModeChangePending);
         dumper.eol();
     }
 }
@@ -953,17 +1047,21 @@ void Scheduler::dumpVsync(std::string& out) const {
         base::StringAppendF(&out, "VsyncSchedule for follower %s:\n", to_string(id).c_str());
         display.schedulePtr->dump(out);
     }
+
+    mVsyncModulator->dump(out);
 }
 
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Wunused-value" // b/369277774
-void Scheduler::updateFrameRateOverrides(GlobalSignals consideredSignals, Fps displayRefreshRate) {
+bool Scheduler::updateFrameRateOverrides(GlobalSignals consideredSignals, Fps displayRefreshRate) {
     const bool changed = (std::scoped_lock(mPolicyLock),
                           updateFrameRateOverridesLocked(consideredSignals, displayRefreshRate));
 
-    if (changed) {
+    if (!FlagManager::getInstance().unify_refresh_rate_callbacks()) {
         onFrameRateOverridesChanged();
     }
+
+    return changed;
 }
 #pragma clang diagnostic pop
 
@@ -1004,11 +1102,24 @@ std::shared_ptr<VsyncSchedule> Scheduler::promotePacesetterDisplayLocked(
             pacesetter.selectorPtr->setIdleTimerCallbacks(
                     {.platform = {.onReset = [this] { idleTimerCallback(TimerState::Reset); },
                                   .onExpired = [this] { idleTimerCallback(TimerState::Expired); }},
-                     .kernel = {.onReset = [this] { kernelIdleTimerCallback(TimerState::Reset); },
+                     .kernel = {.onReset =
+                                        [this, pacesetterId] {
+                                            kernelIdleTimerCallback(pacesetterId,
+                                                                    TimerState::Reset);
+                                        },
                                 .onExpired =
-                                        [this] { kernelIdleTimerCallback(TimerState::Expired); }},
-                     .vrr = {.onReset = [this] { mSchedulerCallback.vrrDisplayIdle(false); },
-                             .onExpired = [this] { mSchedulerCallback.vrrDisplayIdle(true); }}});
+                                        [this, pacesetterId] {
+                                            kernelIdleTimerCallback(pacesetterId,
+                                                                    TimerState::Expired);
+                                        }},
+                     .vrr = {.onReset =
+                                     [this, pacesetterId] {
+                                         mSchedulerCallback.vrrDisplayIdle(pacesetterId, false);
+                                     },
+                             .onExpired =
+                                     [this, pacesetterId] {
+                                         mSchedulerCallback.vrrDisplayIdle(pacesetterId, true);
+                                     }}});
 
             pacesetter.selectorPtr->startIdleTimer();
         }
@@ -1016,8 +1127,13 @@ std::shared_ptr<VsyncSchedule> Scheduler::promotePacesetterDisplayLocked(
         newVsyncSchedulePtr = pacesetter.schedulePtr;
 
         constexpr bool kForce = true;
-        newVsyncSchedulePtr->onDisplayModeChanged(pacesetter.selectorPtr->getActiveMode().modePtr,
-                                                  kForce);
+        const auto pacesetterActiveModePtr = pacesetter.selectorPtr->getActiveMode().modePtr;
+        newVsyncSchedulePtr->onDisplayModeChanged(pacesetterActiveModePtr, kForce);
+
+        if (FlagManager::getInstance().pacesetter_selection()) {
+            mSchedulerCallback.enableLayerCachingTexturePool(pacesetterId, true);
+            onPacesetterDisplaySizeChanged(pacesetterActiveModePtr->getResolution());
+        }
     }
     return newVsyncSchedulePtr;
 }
@@ -1041,6 +1157,11 @@ void Scheduler::demotePacesetterDisplay(PromotionParams params) {
         }
     }
 
+    if (FlagManager::getInstance().pacesetter_selection()) {
+        const PhysicalDisplayId pacesetterId = FTL_FAKE_GUARD(mDisplayLock, *mPacesetterDisplayId);
+        mSchedulerCallback.enableLayerCachingTexturePool(pacesetterId, false);
+    }
+
     // Clear state that depends on the pacesetter's RefreshRateSelector.
     std::scoped_lock lock(mPolicyLock);
     mPolicy = {};
@@ -1149,10 +1270,11 @@ template <typename S, typename T>
 auto Scheduler::applyPolicy(S Policy::*statePtr, T&& newState) -> GlobalSignals {
     SFTRACE_CALL();
     std::vector<display::DisplayModeRequest> modeRequests;
+    std::vector<display::DisplayModeRequest> emitModeChangedEvents;
     GlobalSignals consideredSignals;
 
     bool refreshRateChanged = false;
-    bool frameRateOverridesChanged;
+    ftl::Optional<FrameRateMode> modeOpt;
 
     {
         std::scoped_lock lock(mPolicyLock);
@@ -1162,7 +1284,6 @@ auto Scheduler::applyPolicy(S Policy::*statePtr, T&& newState) -> GlobalSignals
         currentState = std::forward<T>(newState);
 
         DisplayModeChoiceMap modeChoices;
-        ftl::Optional<FrameRateMode> modeOpt;
         {
             std::scoped_lock lock(mDisplayLock);
             ftl::FakeGuard guard(kMainThreadContext);
@@ -1181,17 +1302,22 @@ auto Scheduler::applyPolicy(S Policy::*statePtr, T&& newState) -> GlobalSignals
         }
 
         modeRequests.reserve(modeChoices.size());
+        emitModeChangedEvents.reserve(modeChoices.size());
         for (auto& [id, choice] : modeChoices) {
-            modeRequests.emplace_back(
-                    display::DisplayModeRequest{.mode = std::move(choice.mode),
-                                                .emitEvent = choice.consideredSignals
-                                                                     .shouldEmitEvent()});
+            if (FlagManager::getInstance().unify_refresh_rate_callbacks()) {
+                modeRequests.emplace_back(display::DisplayModeRequest{.mode = choice.mode});
+                emitModeChangedEvents.emplace_back(
+                        display::DisplayModeRequest{.mode = std::move(choice.mode),
+                                                    .emitEvent = choice.consideredSignals
+                                                                         .shouldEmitEvent()});
+            } else {
+                modeRequests.emplace_back(
+                        display::DisplayModeRequest{.mode = std::move(choice.mode),
+                                                    .emitEvent = choice.consideredSignals
+                                                                         .shouldEmitEvent()});
+            }
         }
 
-        if (!FlagManager::getInstance().vrr_bugfix_dropped_frame()) {
-            frameRateOverridesChanged =
-                    updateFrameRateOverridesLocked(consideredSignals, modeOpt->fps);
-        }
         if (mPolicy.modeOpt != modeOpt) {
             mPolicy.modeOpt = modeOpt;
             refreshRateChanged = true;
@@ -1205,13 +1331,25 @@ auto Scheduler::applyPolicy(S Policy::*statePtr, T&& newState) -> GlobalSignals
         mSchedulerCallback.requestDisplayModes(std::move(modeRequests));
     }
 
-    if (FlagManager::getInstance().vrr_bugfix_dropped_frame()) {
+    bool frameRateOverridesChanged = false;
+    {
         std::scoped_lock lock(mPolicyLock);
         frameRateOverridesChanged =
                 updateFrameRateOverridesLocked(consideredSignals, mPolicy.modeOpt->fps);
     }
-    if (frameRateOverridesChanged) {
+    if (frameRateOverridesChanged && !FlagManager::getInstance().unify_refresh_rate_callbacks()) {
         onFrameRateOverridesChanged();
+        return consideredSignals;
+    }
+
+    for (auto displayModeRequest : emitModeChangedEvents) {
+        const auto mode = displayModeRequest.mode;
+        const auto modePtr = mode.modePtr;
+        bool const emitModeChangedEvent = refreshRateChanged && displayModeRequest.emitEvent;
+        if (emitModeChangedEvent || frameRateOverridesChanged) {
+            onDisplayModeAndFrameRateOverridesChanged(modePtr->getPhysicalDisplayId(), mode,
+                                                      /*clearContentRequirements*/ true);
+        }
     }
     return consideredSignals;
 }
@@ -1296,8 +1434,8 @@ bool Scheduler::onCompositionPresented(nsecs_t presentTime) {
     return false;
 }
 
-void Scheduler::onActiveDisplayAreaChanged(uint32_t displayArea) {
-    mLayerHistory.setDisplayArea(displayArea);
+void Scheduler::onPacesetterDisplaySizeChanged(ui::Size displaySize) {
+    mLayerHistory.setDisplaySize(displaySize);
 }
 
 void Scheduler::setGameModeFrameRateForUid(FrameRateOverride frameRateOverride) {
diff --git a/services/surfaceflinger/Scheduler/Scheduler.h b/services/surfaceflinger/Scheduler/Scheduler.h
index 694856e9ce..dc33c29030 100644
--- a/services/surfaceflinger/Scheduler/Scheduler.h
+++ b/services/surfaceflinger/Scheduler/Scheduler.h
@@ -63,10 +63,6 @@ namespace android {
 class FenceTime;
 class TimeStats;
 
-namespace frametimeline {
-class TokenManager;
-} // namespace frametimeline
-
 namespace surfaceflinger {
 class Factory;
 } // namespace surfaceflinger
@@ -76,6 +72,7 @@ namespace scheduler {
 using GlobalSignals = RefreshRateSelector::GlobalSignals;
 
 class RefreshRateStats;
+class TokenManager;
 class VsyncConfiguration;
 class VsyncSchedule;
 
@@ -98,6 +95,8 @@ public:
     void setPacesetterDisplay(PhysicalDisplayId) REQUIRES(kMainThreadContext)
             EXCLUDES(mDisplayLock, mVsyncConfigLock);
 
+    PhysicalDisplayId getPacesetterDisplayId() const EXCLUDES(mDisplayLock);
+
     using RefreshRateSelectorPtr = std::shared_ptr<RefreshRateSelector>;
 
     using ConstVsyncSchedulePtr = std::shared_ptr<const VsyncSchedule>;
@@ -116,7 +115,7 @@ public:
 
     void run();
 
-    void initVsync(frametimeline::TokenManager&, std::chrono::nanoseconds workDuration);
+    void initVsync(TokenManager&, std::chrono::nanoseconds workDuration);
 
     using Impl::setDuration;
 
@@ -139,8 +138,7 @@ public:
         return std::move(future);
     }
 
-    void createEventThread(Cycle, frametimeline::TokenManager*,
-                           std::chrono::nanoseconds workDuration,
+    void createEventThread(Cycle, TokenManager*, std::chrono::nanoseconds workDuration,
                            std::chrono::nanoseconds readyDuration);
 
     sp<IDisplayEventConnection> createDisplayEventConnection(
@@ -152,6 +150,16 @@ public:
 
     void dispatchHotplugError(int32_t errorCode);
 
+    // Returns true if the PhysicalDisplayId is the pacesetter.
+    bool updatePolicyContentRequirements(PhysicalDisplayId, const FrameRateMode&,
+                                         bool clearContentRequirements)
+            EXCLUDES(mPolicyLock, mDisplayLock);
+
+    // Returns true if the PhysicalDisplayId is the pacesetter.
+    bool onDisplayModeAndFrameRateOverridesChanged(PhysicalDisplayId, const FrameRateMode&,
+                                                   bool clearContentRequirements)
+            EXCLUDES(mPolicyLock, mDisplayLock);
+
     // Returns true if the PhysicalDisplayId is the pacesetter.
     bool onDisplayModeChanged(PhysicalDisplayId, const FrameRateMode&,
                               bool clearContentRequirements) EXCLUDES(mPolicyLock);
@@ -190,8 +198,9 @@ public:
     }
 
     void updatePhaseConfiguration(PhysicalDisplayId, Fps) EXCLUDES(mVsyncConfigLock);
-    void reloadPhaseConfiguration(Fps, Duration minSfDuration, Duration maxSfDuration,
-                                  Duration appDuration) EXCLUDES(mVsyncConfigLock);
+    void reloadPhaseConfiguration(const FrameRateMode&, Duration minSfDuration,
+                                  Duration maxSfDuration, Duration appDuration)
+            EXCLUDES(mVsyncConfigLock);
 
     VsyncConfigSet getCurrentVsyncConfigs() const EXCLUDES(mVsyncConfigLock) {
         std::scoped_lock lock{mVsyncConfigLock};
@@ -203,6 +212,12 @@ public:
         return mVsyncConfiguration->getConfigsForRefreshRate(refreshRate);
     }
 
+    static nsecs_t getPresentationDeadline(Fps refreshRate, Duration sfVsyncOffset) {
+        // We add an additional 1ms to allow for processing time and
+        // differences between the ideal and actual refresh rate.
+        return refreshRate.getPeriodNsecs() - sfVsyncOffset.ns() + 1000000;
+    }
+
     // Sets the render rate for the scheduler to run at.
     void setRenderRate(PhysicalDisplayId, Fps, bool applyImmediately);
 
@@ -234,7 +249,7 @@ public:
     void registerLayer(Layer*, FrameRateCompatibility);
     void recordLayerHistory(int32_t id, const LayerProps& layerProps, nsecs_t presentTime,
                             nsecs_t now, LayerHistory::LayerUpdateType) EXCLUDES(mDisplayLock);
-    void setModeChangePending(bool pending);
+    void setModeChangePending(PhysicalDisplayId, bool pending) EXCLUDES(mDisplayLock);
     void setDefaultFrameRateCompatibility(int32_t id, scheduler::FrameRateCompatibility);
     void setLayerProperties(int32_t id, const LayerProps&);
     void deregisterLayer(Layer*);
@@ -291,7 +306,7 @@ public:
     bool onCompositionPresented(nsecs_t presentTime);
 
     // Notifies the scheduler when the display size has changed. Called from SF's main thread
-    void onActiveDisplayAreaChanged(uint32_t displayArea);
+    void onPacesetterDisplaySizeChanged(ui::Size displaySize);
 
     // Stores the preferred refresh rate that an app should run at.
     // FrameRateOverride.refreshRateHz == 0 means no preference.
@@ -319,6 +334,9 @@ public:
     // Retrieves the overridden refresh rate for a given uid.
     std::optional<Fps> getFrameRateOverride(uid_t) const EXCLUDES(mDisplayLock);
 
+    std::pair<FrameRateMode, std::vector<FrameRateOverride>> getFrameRateOverrides()
+            EXCLUDES(mDisplayLock);
+
     Period getPacesetterVsyncPeriod() const EXCLUDES(mDisplayLock) {
         return pacesetterSelectorPtr()->getActiveMode().fps.getPeriod();
     }
@@ -335,7 +353,8 @@ public:
         return mLayerHistory.getLayerFramerate(now, id);
     }
 
-    void updateFrameRateOverrides(GlobalSignals, Fps displayRefreshRate) EXCLUDES(mPolicyLock);
+    // Returns true if frame rate overrides has changed.
+    bool updateFrameRateOverrides(GlobalSignals, Fps displayRefreshRate) EXCLUDES(mPolicyLock);
 
     // Returns true if the small dirty detection is enabled for the appId.
     bool supportSmallDirtyDetection(int32_t appId) {
@@ -374,7 +393,7 @@ private:
     }
 
     // Update feature state machine to given state when corresponding timer resets or expires.
-    void kernelIdleTimerCallback(TimerState) EXCLUDES(mDisplayLock);
+    void kernelIdleTimerCallback(PhysicalDisplayId, TimerState) EXCLUDES(mDisplayLock);
     void idleTimerCallback(TimerState);
     void touchTimerCallback(TimerState);
     void displayPowerTimerCallback(TimerState);
@@ -534,6 +553,7 @@ private:
         FrameTargeterPtr targeterPtr;
 
         hal::PowerMode powerMode = hal::PowerMode::OFF;
+        bool isModeChangePending = false;
     };
 
     using DisplayRef = std::reference_wrapper<Display>;
@@ -542,8 +562,8 @@ private:
     ui::PhysicalDisplayMap<PhysicalDisplayId, Display> mDisplays GUARDED_BY(mDisplayLock)
             GUARDED_BY(kMainThreadContext);
 
-    ftl::Optional<PhysicalDisplayId> mPacesetterDisplayId GUARDED_BY(mDisplayLock)
-            GUARDED_BY(kMainThreadContext);
+    // May be read from any thread, but must only be written from the main thread.
+    ftl::Optional<PhysicalDisplayId> mPacesetterDisplayId GUARDED_BY(mDisplayLock);
 
     ftl::Optional<DisplayRef> pacesetterDisplayLocked() REQUIRES(mDisplayLock) {
         return static_cast<const Scheduler*>(this)->pacesetterDisplayLocked().transform(
diff --git a/services/surfaceflinger/Scheduler/VSyncDispatchTimerQueue.cpp b/services/surfaceflinger/Scheduler/VSyncDispatchTimerQueue.cpp
index 1925f1165c..17f6d3e815 100644
--- a/services/surfaceflinger/Scheduler/VSyncDispatchTimerQueue.cpp
+++ b/services/surfaceflinger/Scheduler/VSyncDispatchTimerQueue.cpp
@@ -38,12 +38,6 @@ using base::StringAppendF;
 
 namespace {
 
-ScheduleResult getExpectedCallbackTime(nsecs_t nextVsyncTime,
-                                       const VSyncDispatch::ScheduleTiming& timing) {
-    return {TimePoint::fromNs(nextVsyncTime - timing.readyDuration - timing.workDuration),
-            TimePoint::fromNs(nextVsyncTime)};
-}
-
 void traceEntry(const VSyncDispatchTimerQueueEntry& entry, nsecs_t now) {
     if (!SFTRACE_ENABLED() || !entry.wakeupTime().has_value() || !entry.targetVsync().has_value()) {
         return;
@@ -113,20 +107,12 @@ ScheduleResult VSyncDispatchTimerQueueEntry::schedule(VSyncDispatch::ScheduleTim
             mArmedInfo && ((nextWakeupTime > (mArmedInfo->mActualWakeupTime + mMinVsyncDistance)));
     SFTRACE_FORMAT_INSTANT("%s: wouldSkipAVsyncTarget=%d wouldSkipAWakeup=%d", mName.c_str(),
                            wouldSkipAVsyncTarget, wouldSkipAWakeup);
-    if (FlagManager::getInstance().dont_skip_on_early_ro()) {
-        if (wouldSkipAVsyncTarget || wouldSkipAWakeup) {
-            nextVsyncTime = mArmedInfo->mActualVsyncTime;
-        } else {
-            nextVsyncTime = adjustVsyncIfNeeded(tracker, nextVsyncTime);
-        }
-        nextWakeupTime = std::max(now, nextVsyncTime - timing.workDuration - timing.readyDuration);
+    if (wouldSkipAVsyncTarget || wouldSkipAWakeup) {
+        nextVsyncTime = mArmedInfo->mActualVsyncTime;
     } else {
-        if (wouldSkipAVsyncTarget && wouldSkipAWakeup) {
-            return getExpectedCallbackTime(nextVsyncTime, timing);
-        }
         nextVsyncTime = adjustVsyncIfNeeded(tracker, nextVsyncTime);
-        nextWakeupTime = nextVsyncTime - timing.workDuration - timing.readyDuration;
     }
+    nextWakeupTime = std::max(now, nextVsyncTime - timing.workDuration - timing.readyDuration);
 
     auto const nextReadyTime = nextVsyncTime - timing.readyDuration;
     mScheduleTiming = timing;
@@ -184,16 +170,14 @@ auto VSyncDispatchTimerQueueEntry::getArmedInfo(VSyncTracker& tracker, nsecs_t n
     const auto nextReadyTime = nextVsyncTime - timing.readyDuration;
     const auto nextWakeupTime = nextReadyTime - timing.workDuration;
 
-    if (FlagManager::getInstance().dont_skip_on_early_ro()) {
-        bool const wouldSkipAVsyncTarget =
-                armedInfo && (nextVsyncTime > (armedInfo->mActualVsyncTime + mMinVsyncDistance));
-        bool const wouldSkipAWakeup =
-                armedInfo && (nextWakeupTime > (armedInfo->mActualWakeupTime + mMinVsyncDistance));
-        SFTRACE_FORMAT_INSTANT("%s: wouldSkipAVsyncTarget=%d wouldSkipAWakeup=%d", mName.c_str(),
-                               wouldSkipAVsyncTarget, wouldSkipAWakeup);
-        if (wouldSkipAVsyncTarget || wouldSkipAWakeup) {
-            return *armedInfo;
-        }
+    bool const wouldSkipAVsyncTarget =
+            armedInfo && (nextVsyncTime > (armedInfo->mActualVsyncTime + mMinVsyncDistance));
+    bool const wouldSkipAWakeup =
+            armedInfo && (nextWakeupTime > (armedInfo->mActualWakeupTime + mMinVsyncDistance));
+    SFTRACE_FORMAT_INSTANT("%s: wouldSkipAVsyncTarget=%d wouldSkipAWakeup=%d", mName.c_str(),
+                            wouldSkipAVsyncTarget, wouldSkipAWakeup);
+    if (wouldSkipAVsyncTarget || wouldSkipAWakeup) {
+        return *armedInfo;
     }
 
     return ArmingInfo{nextWakeupTime, nextVsyncTime, nextReadyTime};
diff --git a/services/surfaceflinger/Scheduler/VSyncPredictor.cpp b/services/surfaceflinger/Scheduler/VSyncPredictor.cpp
index bb04d12d7c..6f64ba7c9d 100644
--- a/services/surfaceflinger/Scheduler/VSyncPredictor.cpp
+++ b/services/surfaceflinger/Scheduler/VSyncPredictor.cpp
@@ -25,6 +25,7 @@
 
 #include <algorithm>
 #include <chrono>
+#include <numeric>
 #include <sstream>
 
 #include <android-base/logging.h>
@@ -374,11 +375,7 @@ bool VSyncPredictor::isVSyncInPhase(nsecs_t timePoint, Fps frameRate) {
     purgeTimelines(now);
 
     for (auto& timeline : mTimelines) {
-        const bool isVsyncValid = FlagManager::getInstance().vrr_bugfix_24q4()
-                ? timeline.isWithin(TimePoint::fromNs(vsync)) ==
-                        VsyncTimeline::VsyncOnTimeline::Unique
-                : timeline.validUntil() && timeline.validUntil()->ns() > vsync;
-        if (isVsyncValid) {
+        if (timeline.isWithin(TimePoint::fromNs(vsync)) == VsyncTimeline::VsyncOnTimeline::Unique) {
             return timeline.isVSyncInPhase(model, vsync, frameRate);
         }
     }
@@ -387,7 +384,8 @@ bool VSyncPredictor::isVSyncInPhase(nsecs_t timePoint, Fps frameRate) {
     return mTimelines.back().isVSyncInPhase(model, vsync, frameRate);
 }
 
-void VSyncPredictor::setRenderRate(Fps renderRate, bool applyImmediately) {
+void VSyncPredictor::setRenderRate(Fps renderRate, bool applyImmediately,
+                                   std::vector<FrameRateOverride> frameRateOverrides) {
     SFTRACE_FORMAT("%s %s", __func__, to_string(renderRate).c_str());
     ALOGV("%s %s: RenderRate %s ", __func__, to_string(mId).c_str(), to_string(renderRate).c_str());
     std::lock_guard lock(mMutex);
@@ -411,19 +409,12 @@ void VSyncPredictor::setRenderRate(Fps renderRate, bool applyImmediately) {
         SFTRACE_FORMAT_INSTANT("newRenderRateIsHigher");
         mTimelines.clear();
         mLastCommittedVsync = TimePoint::fromNs(0);
-
+        mTimelines.emplace_back(mLastCommittedVsync, mIdealPeriod, renderRate);
     } else {
-        if (FlagManager::getInstance().vrr_bugfix_24q4()) {
-            // We need to freeze the timeline at the committed vsync, and
-            // then use with threshold adjustments when required to avoid
-            // marginal errors when checking the vsync on the timeline.
-            mTimelines.back().freeze(mLastCommittedVsync);
-        } else {
-            mTimelines.back().freeze(
-                    TimePoint::fromNs(mLastCommittedVsync.ns() + mIdealPeriod.ns() / 2));
-        }
+        mTimelines.back().freeze(getVSyncPredictionModelLocked(), mLastCommittedVsync,
+                                 frameRateOverrides);
+        mTimelines.emplace_back(*(mTimelines.back().validUntil()), mIdealPeriod, renderRate);
     }
-    mTimelines.emplace_back(mLastCommittedVsync, mIdealPeriod, renderRate);
     purgeTimelines(TimePoint::fromNs(mClock->now()));
 }
 
@@ -646,11 +637,7 @@ void VSyncPredictor::purgeTimelines(android::TimePoint now) {
     }
 
     while (mTimelines.size() > 1) {
-        const auto validUntilOpt = mTimelines.front().validUntil();
-        const bool isTimelineOutDated = FlagManager::getInstance().vrr_bugfix_24q4()
-                ? mTimelines.front().isWithin(now) == VsyncTimeline::VsyncOnTimeline::Outside
-                : validUntilOpt && *validUntilOpt < now;
-        if (isTimelineOutDated) {
+        if (mTimelines.front().isWithin(now) == VsyncTimeline::VsyncOnTimeline::Outside) {
             mTimelines.pop_front();
         } else {
             break;
@@ -672,14 +659,46 @@ VSyncPredictor::VsyncTimeline::VsyncTimeline(TimePoint knownVsync, Period idealP
         mRenderRateOpt(renderRateOpt),
         mLastVsyncSequence(makeVsyncSequence(knownVsync)) {}
 
-void VSyncPredictor::VsyncTimeline::freeze(TimePoint lastVsync) {
+void VSyncPredictor::VsyncTimeline::freeze(Model model, TimePoint lastVsync,
+                                           std::vector<FrameRateOverride> frameRateOverrides) {
     LOG_ALWAYS_FATAL_IF(mValidUntil.has_value());
+    if (FlagManager::getInstance().vsync_predictor_rate_change_with_aligned_sequence() &&
+        !frameRateOverrides.empty() && mLastVsyncSequence) {
+        const int64_t renderRatePhase =
+                getFreezeSequencePhase(model, lastVsync, std::move(frameRateOverrides));
+        lastVsync = TimePoint::fromNs(lastVsync.ns() + model.slope * renderRatePhase);
+    }
+
     SFTRACE_FORMAT_INSTANT("renderRate %s valid for %.2f",
                            mRenderRateOpt ? to_string(*mRenderRateOpt).c_str() : "NA",
                            float(lastVsync.ns() - TimePoint::now().ns()) / 1e6f);
     mValidUntil = lastVsync;
 }
 
+int64_t VSyncPredictor::VsyncTimeline::getFreezeSequencePhase(
+        Model model, TimePoint lastVsync, std::vector<FrameRateOverride> frameRateOverrides) {
+    static constexpr uint32_t kCapacity = 10;
+    ftl::SmallMap<Fps, ftl::Unit, kCapacity, FpsApproxEqual> overridesSet;
+    for (auto [_, frameRateHz] : frameRateOverrides) {
+        overridesSet.emplace_or_replace(Fps::fromValue(frameRateHz));
+    }
+
+    const auto idealPeriodFps = Fps::fromPeriodNsecs(mIdealPeriod.ns());
+
+    int64_t divisor = 1;
+    for (auto [fps, _] : overridesSet) {
+        auto frameRateDivisor = RefreshRateSelector::getFrameRateDivisor(idealPeriodFps, fps);
+        if (frameRateDivisor <= 0) continue;
+        divisor = std::lcm(divisor, frameRateDivisor);
+    }
+
+    const auto lastVsyncSequence = getVsyncSequenceLocked(model, lastVsync.ns());
+    auto seq = static_cast<int64_t>(std::ceil(static_cast<double>(lastVsyncSequence.seq) /
+                                              static_cast<double>(divisor))) *
+            divisor;
+    return seq - lastVsyncSequence.seq;
+}
+
 std::optional<TimePoint> VSyncPredictor::VsyncTimeline::nextAnticipatedVSyncTimeFrom(
         Model model, std::optional<Period> minFramePeriodOpt, nsecs_t vsync,
         MissedVsync missedVsync, std::optional<nsecs_t> lastVsyncOpt) {
@@ -702,12 +721,6 @@ std::optional<TimePoint> VSyncPredictor::VsyncTimeline::nextAnticipatedVSyncTime
                 SFTRACE_FORMAT_INSTANT("lastFrameMissed");
             }
         } else if (mightBackpressure && lastVsyncOpt) {
-            if (!FlagManager::getInstance().vrr_bugfix_24q4()) {
-                // lastVsyncOpt does not need to be corrected with the new rate, and
-                // it should be used as is to avoid skipping a frame when changing rates are
-                // aligned at vsync time.
-                lastVsyncOpt = snapToVsyncAlignedWithRenderRate(model, *lastVsyncOpt);
-            }
             const auto vsyncDiff = vsyncTime - *lastVsyncOpt;
             if (vsyncDiff <= minFramePeriodOpt->ns() - threshold) {
                 // avoid a duplicate vsync
@@ -726,10 +739,7 @@ std::optional<TimePoint> VSyncPredictor::VsyncTimeline::nextAnticipatedVSyncTime
     }
 
     SFTRACE_FORMAT_INSTANT("vsync in %.2fms", float(vsyncTime - TimePoint::now().ns()) / 1e6f);
-    const bool isVsyncInvalid = FlagManager::getInstance().vrr_bugfix_24q4()
-            ? isWithin(TimePoint::fromNs(vsyncTime)) == VsyncOnTimeline::Outside
-            : mValidUntil && vsyncTime > mValidUntil->ns();
-    if (isVsyncInvalid) {
+    if (isWithin(TimePoint::fromNs(vsyncTime)) == VsyncOnTimeline::Outside) {
         SFTRACE_FORMAT_INSTANT("no longer valid for vsync in %.2f",
                                static_cast<float>(vsyncTime - TimePoint::now().ns()) / 1e6f);
         return std::nullopt;
@@ -785,9 +795,7 @@ bool VSyncPredictor::VsyncTimeline::isVSyncInPhase(Model model, nsecs_t vsync, F
         return ticks<std::milli, float>(TimePoint::fromNs(timePoint) - now);
     };
 
-    Fps displayFps = !FlagManager::getInstance().vrr_bugfix_24q4() && mRenderRateOpt
-            ? *mRenderRateOpt
-            : Fps::fromPeriodNsecs(mIdealPeriod.ns());
+    Fps displayFps = Fps::fromPeriodNsecs(mIdealPeriod.ns());
     const auto divisor = RefreshRateSelector::getFrameRateDivisor(displayFps, frameRate);
     const auto now = TimePoint::now();
 
diff --git a/services/surfaceflinger/Scheduler/VSyncPredictor.h b/services/surfaceflinger/Scheduler/VSyncPredictor.h
index 2df3d0465f..6d8f86739e 100644
--- a/services/surfaceflinger/Scheduler/VSyncPredictor.h
+++ b/services/surfaceflinger/Scheduler/VSyncPredictor.h
@@ -76,7 +76,8 @@ public:
                 mRateMap.find(idealPeriod())->second.slope;
     }
 
-    void setRenderRate(Fps, bool applyImmediately) final EXCLUDES(mMutex);
+    void setRenderRate(Fps, bool applyImmediately, std::vector<FrameRateOverride>) final
+            EXCLUDES(mMutex);
 
     void onFrameBegin(TimePoint expectedPresentTime, FrameTime lastSignaledFrameTime) final
             EXCLUDES(mMutex);
@@ -101,7 +102,7 @@ private:
         std::optional<TimePoint> nextAnticipatedVSyncTimeFrom(
                 Model model, std::optional<Period> minFramePeriodOpt, nsecs_t vsyncTime,
                 MissedVsync lastMissedVsync, std::optional<nsecs_t> lastVsyncOpt = {});
-        void freeze(TimePoint lastVsync);
+        void freeze(Model, TimePoint lastVsync, std::vector<FrameRateOverride>);
         std::optional<TimePoint> validUntil() const { return mValidUntil; }
         bool isVSyncInPhase(Model, nsecs_t vsync, Fps frameRate);
         void shiftVsyncSequence(Duration phase, Period minFramePeriod);
@@ -118,6 +119,10 @@ private:
         nsecs_t snapToVsyncAlignedWithRenderRate(Model model, nsecs_t vsync);
         VsyncSequence getVsyncSequenceLocked(Model, nsecs_t vsync);
         std::optional<VsyncSequence> makeVsyncSequence(TimePoint knownVsync);
+        // Get the phase for vsync sequence where all the provided frameRateOverrides align
+        // from the vsync provided.
+        int64_t getFreezeSequencePhase(Model, TimePoint vsync,
+                                       std::vector<FrameRateOverride> frameRateOverrides);
 
         const Period mIdealPeriod = Duration::fromNs(0);
         std::optional<Fps> mRenderRateOpt;
diff --git a/services/surfaceflinger/Scheduler/VSyncTracker.h b/services/surfaceflinger/Scheduler/VSyncTracker.h
index 3376fadad0..df528891f6 100644
--- a/services/surfaceflinger/Scheduler/VSyncTracker.h
+++ b/services/surfaceflinger/Scheduler/VSyncTracker.h
@@ -23,9 +23,12 @@
 #include <scheduler/FrameRateMode.h>
 #include <scheduler/FrameTime.h>
 
+#include <gui/DisplayEventReceiver.h>
+
 #include "VSyncDispatch.h"
 
 namespace android::scheduler {
+using FrameRateOverride = DisplayEventReceiver::Event::FrameRateOverride;
 
 /*
  * VSyncTracker is an interface for providing estimates on future Vsync signal times based on
@@ -103,15 +106,19 @@ public:
      * Sets a render rate on the tracker. If the render rate is not a divisor
      * of the period, the render rate is ignored until the period changes.
      * The tracker will continue to track the vsync timeline and expect it
-     * to match the current period, however, nextAnticipatedVSyncTimeFrom will
-     * return vsyncs according to the render rate set. Setting a render rate is useful
-     * when a display is running at 120Hz but the render frame rate is 60Hz.
+     * to match the current period.
+     * nextAnticipatedVSyncTimeFrom will return vsyncs according to the new render rate
+     * set only after the point where all the frame rate overrides align.
+     * Setting a render rate is useful when a display is running at 120Hz but
+     * the render frame rate is 60Hz.
      *
      * \param [in] Fps   The render rate the tracker should operate at.
      * \param [in] applyImmediately Whether to apply the new render rate immediately regardless of
      *                              already committed vsyncs.
+     * \param [in] std::vector<FrameRateOverride> list of all the frame rate overrides currently
+     *                                            active with the old render rate.
      */
-    virtual void setRenderRate(Fps, bool applyImmediately) = 0;
+    virtual void setRenderRate(Fps, bool applyImmediately, std::vector<FrameRateOverride>) = 0;
 
     virtual void onFrameBegin(TimePoint expectedPresentTime, FrameTime lastSignaledFrameTime) = 0;
 
diff --git a/services/surfaceflinger/Scheduler/VsyncModulator.cpp b/services/surfaceflinger/Scheduler/VsyncModulator.cpp
index 3c5f68c4c2..5892f165db 100644
--- a/services/surfaceflinger/Scheduler/VsyncModulator.cpp
+++ b/services/surfaceflinger/Scheduler/VsyncModulator.cpp
@@ -21,6 +21,8 @@
 
 #include "VsyncModulator.h"
 
+#include <android/gui/EarlyWakeupInfo.h>
+#include <common/FlagManager.h>
 #include <common/trace.h>
 #include <log/log.h>
 
@@ -32,6 +34,8 @@ using namespace std::chrono_literals;
 
 namespace android::scheduler {
 
+using base::StringAppendF;
+
 const std::chrono::nanoseconds VsyncModulator::MIN_EARLY_TRANSACTION_TIME = 1ms;
 
 VsyncModulator::VsyncModulator(const VsyncConfigSet& config, Now now)
@@ -44,31 +48,52 @@ VsyncConfig VsyncModulator::setVsyncConfigSet(const VsyncConfigSet& config) {
     return updateVsyncConfigLocked();
 }
 
-VsyncModulator::VsyncConfigOpt VsyncModulator::setTransactionSchedule(TransactionSchedule schedule,
-                                                                      const sp<IBinder>& token) {
+VsyncModulator::VsyncConfigOpt VsyncModulator::setTransactionSchedule(
+        TransactionSchedule schedule, std::vector<gui::EarlyWakeupInfo> earlyWakeupInfos) {
     std::lock_guard<std::mutex> lock(mMutex);
-    switch (schedule) {
-        case Schedule::EarlyStart:
-            if (token) {
-                mEarlyWakeupRequests.emplace(token);
-                token->linkToDeath(sp<DeathRecipient>::fromExisting(this));
-            } else {
-                ALOGW("%s: EarlyStart requested without a valid token", __func__);
-            }
-            break;
-        case Schedule::EarlyEnd: {
-            if (token && mEarlyWakeupRequests.erase(token) > 0) {
-                token->unlinkToDeath(sp<DeathRecipient>::fromExisting(this));
-            } else {
-                ALOGW("%s: Unexpected EarlyEnd", __func__);
+
+    for (auto& info : earlyWakeupInfos) {
+        sp<IBinder> token = info.token;
+        std::string trace = info.trace;
+
+        switch (schedule) {
+            case Schedule::EarlyStart:
+                if (token) {
+                    SFTRACE_FORMAT_INSTANT("%s: EarlyStart requested by %s with token %p", __func__,
+                                           trace.c_str(), token.get());
+                    mEarlyWakeupRequests[token] =
+                            std::make_unique<gui::EarlyWakeupInfo>(std::move(info));
+                    token->linkToDeath(sp<DeathRecipient>::fromExisting(this));
+                } else {
+                    ALOGW("%s: EarlyStart requested without a valid token", __func__);
+                }
+                break;
+            case Schedule::EarlyEnd: {
+                if (token && mEarlyWakeupRequests.erase(token)) {
+                    SFTRACE_FORMAT_INSTANT("%s: EarlyEnd requested by %s with token %p", __func__,
+                                           trace.c_str(), token.get());
+                    token->unlinkToDeath(sp<DeathRecipient>::fromExisting(this));
+                } else {
+                    ALOGW("%s: Unexpected EarlyEnd %s", __func__, info.toString().c_str());
+                }
+                break;
             }
-            break;
+            case Schedule::Late:
+                // This is a speculative fix because we think we are leaking tokens.
+                // If earlyWakeupInfos is not empty, we were not in Schedule late
+                // because we got both eEarlyWakeupStart and eEarlyWakeupEnd in the
+                // same transaction. Clean up state for any earlyWakeupEnd operations.
+                if (!info.isStartRequest) {
+                    ALOGW("%s: Clearing request by %s with token %p", __func__, trace.c_str(),
+                          token.get());
+                    mEarlyWakeupRequests.erase(token);
+                }
+                break;
         }
-        case Schedule::Late:
-            // No change to mEarlyWakeup for non-explicit states.
-            break;
     }
 
+    SFTRACE_INT("EarlyWakeupRequests", static_cast<int>(mEarlyWakeupRequests.size()));
+
     if (mEarlyWakeupRequests.empty() && schedule == Schedule::EarlyEnd) {
         mEarlyTransactionFrames = MIN_EARLY_TRANSACTION_FRAMES;
         mEarlyTransactionStartTime = mNow();
@@ -167,8 +192,6 @@ VsyncConfig VsyncModulator::updateVsyncConfigLocked() {
     SFTRACE_INT("Vsync-Late", &mVsyncConfig == &mVsyncConfigSet.late);
 
     // Trace early vsync conditions
-    SFTRACE_INT("EarlyWakeupRequests",
-                                 static_cast<int>(mEarlyWakeupRequests.size()));
     SFTRACE_INT("EarlyTransactionFrames", mEarlyTransactionFrames);
     SFTRACE_INT("RefreshRateChangePending", mRefreshRateChangePending);
 
@@ -180,6 +203,7 @@ VsyncConfig VsyncModulator::updateVsyncConfigLocked() {
 
 void VsyncModulator::binderDied(const wp<IBinder>& who) {
     std::lock_guard<std::mutex> lock(mMutex);
+    ALOGW("binder died");
     mEarlyWakeupRequests.erase(who);
     static_cast<void>(updateVsyncConfigLocked());
 }
@@ -189,4 +213,12 @@ bool VsyncModulator::isVsyncConfigEarly() const {
     return getNextVsyncConfigType() != VsyncConfigType::Late;
 }
 
+void VsyncModulator::dump(std::string& result) const {
+    std::lock_guard<std::mutex> lock(mMutex);
+    StringAppendF(&result, " Early Wakeup Requests (count=%zu):\n", mEarlyWakeupRequests.size());
+    for (const auto& pair : mEarlyWakeupRequests) {
+        StringAppendF(&result, "   %s\n", pair.second->toString().c_str());
+    }
+}
+
 } // namespace android::scheduler
diff --git a/services/surfaceflinger/Scheduler/VsyncModulator.h b/services/surfaceflinger/Scheduler/VsyncModulator.h
index d0a793535c..dd74cf52cf 100644
--- a/services/surfaceflinger/Scheduler/VsyncModulator.h
+++ b/services/surfaceflinger/Scheduler/VsyncModulator.h
@@ -21,7 +21,10 @@
 #include <optional>
 #include <unordered_set>
 
+#include <android-base/properties.h>
+#include <android-base/stringprintf.h>
 #include <android-base/thread_annotations.h>
+#include <android/gui/EarlyWakeupInfo.h>
 #include <binder/IBinder.h>
 #include <utils/Timers.h>
 
@@ -62,8 +65,8 @@ public:
     [[nodiscard]] VsyncConfig setVsyncConfigSet(const VsyncConfigSet&) EXCLUDES(mMutex);
 
     // Changes offsets in response to transaction flags or commit.
-    [[nodiscard]] VsyncConfigOpt setTransactionSchedule(TransactionSchedule,
-                                                        const sp<IBinder>& = {}) EXCLUDES(mMutex);
+    [[nodiscard]] VsyncConfigOpt setTransactionSchedule(
+            TransactionSchedule, std::vector<android::gui::EarlyWakeupInfo> = {}) EXCLUDES(mMutex);
     [[nodiscard]] VsyncConfigOpt onTransactionCommit();
 
     // Called when we send a refresh rate change to hardware composer, so that
@@ -76,6 +79,8 @@ public:
 
     [[nodiscard]] VsyncConfigOpt onDisplayRefresh(bool usedGpuComposition);
 
+    void dump(std::string& result) const EXCLUDES(mMutex);
+
 protected:
     // Called from unit tests as well
     void binderDied(const wp<IBinder>&) override EXCLUDES(mMutex);
@@ -96,7 +101,8 @@ private:
     using Schedule = TransactionSchedule;
     std::atomic<Schedule> mTransactionSchedule = Schedule::Late;
 
-    std::unordered_set<wp<IBinder>, WpHash> mEarlyWakeupRequests GUARDED_BY(mMutex);
+    std::unordered_map<wp<IBinder>, std::unique_ptr<gui::EarlyWakeupInfo>, WpHash>
+            mEarlyWakeupRequests GUARDED_BY(mMutex);
     std::atomic<bool> mRefreshRateChangePending = false;
 
     std::atomic<int> mEarlyTransactionFrames = 0;
diff --git a/services/surfaceflinger/Scheduler/include/scheduler/FrameTargeter.h b/services/surfaceflinger/Scheduler/include/scheduler/FrameTargeter.h
index ff461d2d85..f0a5be9f26 100644
--- a/services/surfaceflinger/Scheduler/include/scheduler/FrameTargeter.h
+++ b/services/surfaceflinger/Scheduler/include/scheduler/FrameTargeter.h
@@ -107,7 +107,6 @@ protected:
     // signaled by now (unless that frame missed).
     std::pair<bool /* wouldBackpressure */, PresentFence> expectedSignaledPresentFence(
             Period vsyncPeriod, Period minFramePeriod) const;
-    std::array<PresentFence, 2> mPresentFencesLegacy;
     ui::RingBuffer<PresentFence, 5> mPresentFences;
 
     FrameTime mLastSignaledFrameTime;
diff --git a/services/surfaceflinger/Scheduler/src/FrameTargeter.cpp b/services/surfaceflinger/Scheduler/src/FrameTargeter.cpp
index 50199492cb..59d032c6af 100644
--- a/services/surfaceflinger/Scheduler/src/FrameTargeter.cpp
+++ b/services/surfaceflinger/Scheduler/src/FrameTargeter.cpp
@@ -32,10 +32,6 @@ FrameTarget::FrameTarget(const std::string& displayLabel)
 std::pair<bool /* wouldBackpressure */, FrameTarget::PresentFence>
 FrameTarget::expectedSignaledPresentFence(Period vsyncPeriod, Period minFramePeriod) const {
     SFTRACE_CALL();
-    if (!FlagManager::getInstance().allow_n_vsyncs_in_targeter()) {
-        const size_t i = static_cast<size_t>(targetsVsyncsAhead<2>(minFramePeriod));
-        return {true, mPresentFencesLegacy[i]};
-    }
 
     bool wouldBackpressure = true;
     auto expectedPresentTime = mExpectedPresentTime;
@@ -80,14 +76,10 @@ bool FrameTarget::wouldPresentEarly(Period vsyncPeriod, Period minFramePeriod) c
 }
 
 const FenceTimePtr& FrameTarget::presentFenceForPreviousFrame() const {
-    if (FlagManager::getInstance().allow_n_vsyncs_in_targeter()) {
-        if (mPresentFences.size() > 0) {
-            return mPresentFences.back().fenceTime;
-        }
-        return FenceTime::NO_FENCE;
+    if (mPresentFences.size() > 0) {
+        return mPresentFences.back().fenceTime;
     }
-
-    return mPresentFencesLegacy.front().fenceTime;
+    return FenceTime::NO_FENCE;
 }
 
 void FrameTargeter::beginFrame(const BeginFrameArgs& args, const IVsyncSource& vsyncSource) {
@@ -139,10 +131,6 @@ void FrameTargeter::beginFrame(const BeginFrameArgs& args, const IVsyncSource& v
         const bool considerBackpressure =
                 mBackpressureGpuComposition || !mCompositionCoverage.test(CompositionCoverage::Gpu);
 
-        if (!FlagManager::getInstance().allow_n_vsyncs_in_targeter()) {
-            return static_cast<int>(considerBackpressure);
-        }
-
         if (!wouldBackpressure || !considerBackpressure) {
             return 0;
         }
@@ -205,12 +193,7 @@ FenceTimePtr FrameTargeter::setPresentFence(sp<Fence> presentFence) {
 }
 
 FenceTimePtr FrameTargeter::setPresentFence(sp<Fence> presentFence, FenceTimePtr presentFenceTime) {
-    if (FlagManager::getInstance().allow_n_vsyncs_in_targeter()) {
-        addFence(std::move(presentFence), presentFenceTime, mExpectedPresentTime);
-    } else {
-        mPresentFencesLegacy[1] = mPresentFencesLegacy[0];
-        mPresentFencesLegacy[0] = {std::move(presentFence), presentFenceTime, mExpectedPresentTime};
-    }
+    addFence(std::move(presentFence), presentFenceTime, mExpectedPresentTime);
     return presentFenceTime;
 }
 
diff --git a/services/surfaceflinger/Scheduler/tests/FrameTargeterTest.cpp b/services/surfaceflinger/Scheduler/tests/FrameTargeterTest.cpp
index 6f4e1f1dfe..5c346b25e6 100644
--- a/services/surfaceflinger/Scheduler/tests/FrameTargeterTest.cpp
+++ b/services/surfaceflinger/Scheduler/tests/FrameTargeterTest.cpp
@@ -197,7 +197,6 @@ TEST_F(FrameTargeterTest, recallsPastVsync) {
 }
 
 TEST_F(FrameTargeterTest, wouldBackpressureAfterTime) {
-    SET_FLAG_FOR_TEST(flags::allow_n_vsyncs_in_targeter, true);
     VsyncId vsyncId{111};
     TimePoint frameBeginTime(1000ms);
     constexpr Fps kRefreshRate = 60_Hz;
@@ -221,31 +220,6 @@ TEST_F(FrameTargeterTest, wouldBackpressureAfterTime) {
     }
 }
 
-TEST_F(FrameTargeterTest, wouldBackpressureAfterTimeLegacy) {
-    SET_FLAG_FOR_TEST(flags::allow_n_vsyncs_in_targeter, false);
-    VsyncId vsyncId{111};
-    TimePoint frameBeginTime(1000ms);
-    constexpr Fps kRefreshRate = 60_Hz;
-    constexpr Period kPeriod = kRefreshRate.getPeriod();
-    constexpr Duration kFrameDuration = 13ms;
-
-    { Frame frame(this, vsyncId++, frameBeginTime, kFrameDuration, kRefreshRate, kRefreshRate); }
-    {
-        Frame frame(this, vsyncId++, frameBeginTime, kFrameDuration, kRefreshRate, kRefreshRate);
-
-        const auto [wouldBackpressure, presentFence] =
-                expectedSignaledPresentFence(kPeriod, kPeriod);
-        EXPECT_TRUE(wouldBackpressure);
-    }
-    {
-        frameBeginTime += kPeriod;
-        Frame frame(this, vsyncId++, frameBeginTime, kFrameDuration, kRefreshRate, kRefreshRate);
-        const auto [wouldBackpressure, presentFence] =
-                expectedSignaledPresentFence(kPeriod, kPeriod);
-        EXPECT_TRUE(wouldBackpressure);
-    }
-}
-
 TEST_F(FrameTargeterTest, recallsPastVsyncTwoVsyncsAhead) {
     VsyncId vsyncId{222};
     TimePoint frameBeginTime(2000ms);
@@ -264,8 +238,6 @@ TEST_F(FrameTargeterTest, recallsPastVsyncTwoVsyncsAhead) {
 }
 
 TEST_F(FrameTargeterTest, recallsPastVsyncFiveVsyncsAhead) {
-    SET_FLAG_FOR_TEST(flags::allow_n_vsyncs_in_targeter, true);
-
     VsyncId vsyncId{222};
     TimePoint frameBeginTime(2000ms);
     constexpr Fps kRefreshRate = 120_Hz;
diff --git a/services/surfaceflinger/ScreenCaptureOutput.cpp b/services/surfaceflinger/ScreenCaptureOutput.cpp
index 2906bbd5b8..ccd999a50c 100644
--- a/services/surfaceflinger/ScreenCaptureOutput.cpp
+++ b/services/surfaceflinger/ScreenCaptureOutput.cpp
@@ -33,13 +33,12 @@ std::shared_ptr<ScreenCaptureOutput> createScreenCaptureOutput(ScreenCaptureOutp
             /* sourceCrop */ const Rect, ftl::Optional<DisplayIdVariant>,
             const compositionengine::Output::ColorProfile&,
             /* layerAlpha */ float,
-            /* regionSampling */ bool>(args.compositionEngine, args.sourceCrop,
-                                       args.displayIdVariant, args.colorProfile, args.layerAlpha,
-                                       args.regionSampling,
-                                       args.dimInGammaSpaceForEnhancedScreenshots,
-                                       args.enableLocalTonemapping);
+            /* disableBlur */ bool>(args.compositionEngine, args.sourceCrop, args.displayIdVariant,
+                                    args.colorProfile, args.layerAlpha, args.disableBlur,
+                                    args.dimInGammaSpaceForEnhancedScreenshots,
+                                    args.enableLocalTonemapping);
     output->editState().isSecure = args.isSecure;
-    output->editState().isProtected = args.isProtected;
+    output->editState().isProtected = args.buffer->getUsage() & GRALLOC_USAGE_PROTECTED;
     output->setCompositionEnabled(true);
     output->setLayerFilter({args.layerStack});
     output->setRenderSurface(std::make_unique<ScreenCaptureRenderSurface>(std::move(args.buffer)));
@@ -57,27 +56,19 @@ std::shared_ptr<ScreenCaptureOutput> createScreenCaptureOutput(ScreenCaptureOutp
     output->setDisplaySize({sourceCrop.getWidth(), sourceCrop.getHeight()});
     output->setProjection(orientation, sourceCrop,
                           {args.reqBufferSize.width, args.reqBufferSize.height});
-
-    {
-        std::string name = args.regionSampling ? "RegionSampling" : "ScreenCaptureOutput";
-        if (const auto id = args.displayIdVariant.and_then(asDisplayIdOfType<DisplayId>)) {
-            base::StringAppendF(&name, " for %" PRIu64, id->value);
-        }
-        output->setName(name);
-    }
+    output->setName(args.debugName);
     return output;
 }
 
 ScreenCaptureOutput::ScreenCaptureOutput(
         const Rect sourceCrop, ftl::Optional<DisplayIdVariant> displayIdVariant,
         const compositionengine::Output::ColorProfile& colorProfile, float layerAlpha,
-        bool regionSampling, bool dimInGammaSpaceForEnhancedScreenshots,
-        bool enableLocalTonemapping)
+        bool disableBlur, bool dimInGammaSpaceForEnhancedScreenshots, bool enableLocalTonemapping)
       : mSourceCrop(sourceCrop),
         mDisplayIdVariant(displayIdVariant),
         mColorProfile(colorProfile),
         mLayerAlpha(layerAlpha),
-        mRegionSampling(regionSampling),
+        mDisableBlur(disableBlur),
         mDimInGammaSpaceForEnhancedScreenshots(dimInGammaSpaceForEnhancedScreenshots),
         mEnableLocalTonemapping(enableLocalTonemapping) {}
 
@@ -137,15 +128,18 @@ ScreenCaptureOutput::generateLuts() {
             }
         }
 
-        std::vector<aidl::android::hardware::graphics::composer3::Luts> luts;
-        if (const auto physicalDisplayId = mDisplayIdVariant.and_then(asPhysicalDisplayId)) {
-            auto& hwc = getCompositionEngine().getHwComposer();
-            hwc.getLuts(*physicalDisplayId, buffers, &luts);
-        }
+        // only call getLuts if buffers are not empty
+        if (!buffers.empty()) {
+            std::vector<aidl::android::hardware::graphics::composer3::Luts> luts;
+            if (const auto physicalDisplayId = mDisplayIdVariant.and_then(asPhysicalDisplayId)) {
+                auto& hwc = getCompositionEngine().getHwComposer();
+                hwc.getLuts(*physicalDisplayId, buffers, &luts);
+            }
 
-        if (buffers.size() == luts.size()) {
-            for (size_t i = 0; i < luts.size(); i++) {
-                lutsMapper[layerIds[i]] = std::move(luts[i]);
+            if (buffers.size() == luts.size()) {
+                for (size_t i = 0; i < luts.size(); i++) {
+                    lutsMapper[layerIds[i]] = std::move(luts[i]);
+                }
             }
         }
     }
@@ -183,13 +177,13 @@ ScreenCaptureOutput::generateClientCompositionRequests(
                             static_cast<int32_t>(aidlLuts.lutProperties[j].samplingKeys[0]));
                 }
                 layer.luts = std::make_shared<gui::DisplayLuts>(base::unique_fd(
-                                                                        aidlLuts.pfd.dup().get()),
+                                                                        aidlLuts.pfd.release()),
                                                                 offsets, dimensions, sizes, keys);
             }
         }
     }
 
-    if (mRegionSampling) {
+    if (mDisableBlur) {
         for (auto& layer : clientCompositionLayers) {
             layer.backgroundBlurRadius = 0;
             layer.blurRegions.clear();
diff --git a/services/surfaceflinger/ScreenCaptureOutput.h b/services/surfaceflinger/ScreenCaptureOutput.h
index d4e20fc2f3..774f0b00a5 100644
--- a/services/surfaceflinger/ScreenCaptureOutput.h
+++ b/services/surfaceflinger/ScreenCaptureOutput.h
@@ -37,12 +37,12 @@ struct ScreenCaptureOutputArgs {
     // Counterintuitively, when targetBrightness > 1.0 then dim the scene.
     float targetBrightness;
     float layerAlpha;
-    bool regionSampling;
+    bool disableBlur;
     bool treat170mAsSrgb;
     bool dimInGammaSpaceForEnhancedScreenshots;
     bool isSecure = false;
-    bool isProtected = false;
     bool enableLocalTonemapping = false;
+    std::string debugName;
 };
 
 // ScreenCaptureOutput is used to compose a set of layers into a preallocated buffer.
@@ -53,7 +53,7 @@ class ScreenCaptureOutput : public compositionengine::impl::Output {
 public:
     ScreenCaptureOutput(const Rect sourceCrop, ftl::Optional<DisplayIdVariant> displayIdVariant,
                         const compositionengine::Output::ColorProfile& colorProfile,
-                        float layerAlpha, bool regionSampling,
+                        float layerAlpha, bool disableBlur,
                         bool dimInGammaSpaceForEnhancedScreenshots, bool enableLocalTonemapping);
 
     void updateColorProfile(const compositionengine::CompositionRefreshArgs&) override;
@@ -73,7 +73,7 @@ private:
     const ftl::Optional<DisplayIdVariant> mDisplayIdVariant;
     const compositionengine::Output::ColorProfile& mColorProfile;
     const float mLayerAlpha;
-    const bool mRegionSampling;
+    const bool mDisableBlur;
     const bool mDimInGammaSpaceForEnhancedScreenshots;
     const bool mEnableLocalTonemapping;
 };
diff --git a/services/surfaceflinger/SurfaceFlinger.cpp b/services/surfaceflinger/SurfaceFlinger.cpp
index 42a77fd844..af2c1f0288 100644
--- a/services/surfaceflinger/SurfaceFlinger.cpp
+++ b/services/surfaceflinger/SurfaceFlinger.cpp
@@ -75,6 +75,7 @@
 #include <gui/LayerState.h>
 #include <gui/Surface.h>
 #include <gui/SurfaceComposerClient.h>
+#include <gui/TransactionState.h>
 #include <hidl/ServiceManagement.h>
 #include <layerproto/LayerProtoHeader.h>
 #include <linux/sched/types.h>
@@ -85,7 +86,7 @@
 #include <renderengine/RenderEngine.h>
 #include <renderengine/impl/ExternalTexture.h>
 #include <scheduler/FrameTargeter.h>
-#include <statslog_surfaceflinger.h>
+#include <statslog_surfaceflinger_bootstrap.h>
 #include <sys/types.h>
 #include <ui/ColorSpace.h>
 #include <ui/DebugUtils.h>
@@ -125,11 +126,11 @@
 #include <gui/LayerStatePermissions.h>
 #include <gui/SchedulingPolicy.h>
 #include <gui/SyncScreenCaptureListener.h>
-#include <ui/DisplayIdentification.h>
 #include "BackgroundExecutor.h"
 #include "Client.h"
 #include "ClientCache.h"
 #include "Colorizer.h"
+#include "Display/DisplayIdentification.h"
 #include "DisplayDevice.h"
 #include "DisplayHardware/ComposerHal.h"
 #include "DisplayHardware/FramebufferSurface.h"
@@ -137,7 +138,6 @@
 #include "DisplayHardware/VirtualDisplaySurface.h"
 #include "Effects/Daltonizer.h"
 #include "FpsReporter.h"
-#include "FrameTimeline/FrameTimeline.h"
 #include "FrameTracer/FrameTracer.h"
 #include "FrontEnd/LayerCreationArgs.h"
 #include "FrontEnd/LayerHandle.h"
@@ -155,6 +155,7 @@
 #include "PowerAdvisor/Workload.h"
 #include "RegionSamplingThread.h"
 #include "Scheduler/EventThread.h"
+#include "Scheduler/FrameTimeline.h"
 #include "Scheduler/LayerHistory.h"
 #include "Scheduler/Scheduler.h"
 #include "Scheduler/VsyncConfiguration.h"
@@ -361,6 +362,14 @@ bool isExpectedPresentWithinTimeout(TimePoint expectedPresentTime,
     return std::abs(expectedPresentTime.ns() -
                     (lastExpectedPresentTimestamp.ns() + timeoutOpt->ns())) < threshold.ns();
 }
+
+void invokeScreenCaptureError(const status_t status,
+                              const sp<IScreenCaptureListener>& captureListener) {
+    ScreenCaptureResults captureResults;
+    captureResults.fenceResult = base::unexpected(status);
+    captureListener->onScreenCaptureCompleted(captureResults);
+}
+
 } // namespace
 
 // ---------------------------------------------------------------------------
@@ -413,7 +422,8 @@ bool callingThreadHasPermission(const String16& permission) {
             PermissionCache::checkPermission(permission, pid, uid);
 }
 
-ui::Transform::RotationFlags SurfaceFlinger::sActiveDisplayRotationFlags = ui::Transform::ROT_0;
+ui::Transform::RotationFlags SurfaceFlinger::sFrontInternalDisplayRotationFlags =
+        ui::Transform::ROT_0;
 
 SurfaceFlinger::SurfaceFlinger(Factory& factory, SkipInitializationTag)
       : mFactory(factory),
@@ -532,7 +542,8 @@ SurfaceFlinger::SurfaceFlinger(Factory& factory) : SurfaceFlinger(factory, SkipI
     mRefreshRateOverlayShowInMiddle =
             property_get_bool("debug.sf.show_refresh_rate_overlay_in_middle", 0);
 
-    if (!mIsUserBuild && base::GetBoolProperty("debug.sf.enable_transaction_tracing"s, true)) {
+    if (base::GetBoolProperty("ro.debuggable", false) &&
+        base::GetBoolProperty("debug.sf.enable_transaction_tracing"s, true)) {
         mTransactionTracing.emplace();
         mLayerTracing.setTransactionTracing(*mTransactionTracing);
     }
@@ -704,11 +715,11 @@ std::vector<PhysicalDisplayId> SurfaceFlinger::getPhysicalDisplayIdsLocked() con
     std::vector<PhysicalDisplayId> displayIds;
     displayIds.reserve(mPhysicalDisplays.size());
 
-    const auto defaultDisplayId = getDefaultDisplayDeviceLocked()->getPhysicalId();
-    displayIds.push_back(defaultDisplayId);
+    const auto frontInternalDisplayId = getFrontInternalDisplayLocked()->getPhysicalId();
+    displayIds.push_back(frontInternalDisplayId);
 
     for (const auto& [id, display] : mPhysicalDisplays) {
-        if (id != defaultDisplayId) {
+        if (id != frontInternalDisplayId) {
             displayIds.push_back(id);
         }
     }
@@ -947,11 +958,11 @@ void SurfaceFlinger::init() FTL_FAKE_GUARD(kMainThreadContext) {
     LOG_ALWAYS_FATAL_IF(!configureLocked(),
                         "Initial display configuration failed: HWC did not hotplug");
 
-    mActiveDisplayId = getPrimaryDisplayIdLocked();
+    mFrontInternalDisplayId = getPrimaryDisplayIdLocked();
 
     // Commit primary display.
     sp<const DisplayDevice> display;
-    if (const auto indexOpt = mCurrentState.getDisplayIndex(mActiveDisplayId)) {
+    if (const auto indexOpt = mCurrentState.getDisplayIndex(mFrontInternalDisplayId)) {
         const auto& displays = mCurrentState.displays;
 
         const auto& token = displays.keyAt(*indexOpt);
@@ -960,7 +971,7 @@ void SurfaceFlinger::init() FTL_FAKE_GUARD(kMainThreadContext) {
         processDisplayAdded(token, state);
         mDrawingState.displays.add(token, state);
 
-        display = getDefaultDisplayDeviceLocked();
+        display = getFrontInternalDisplayLocked();
     }
 
     LOG_ALWAYS_FATAL_IF(!display, "Failed to configure the primary display");
@@ -1007,7 +1018,16 @@ void SurfaceFlinger::init() FTL_FAKE_GUARD(kMainThreadContext) {
     // initialize our drawing state
     mDrawingState = mCurrentState;
 
-    onActiveDisplayChangedLocked(nullptr, *display);
+    if (FlagManager::getInstance().pacesetter_selection()) {
+        // No need to trigger update for pacesetter via Scheduler::setPacesetterDisplay() as it is
+        // done as part of adding the `display` in initScheduler().
+
+        getRenderEngine().onActiveDisplaySizeChanged(findLargestFramebufferSizeLocked());
+        const auto pacesetter = getPacesetterDisplayLocked();
+        applyRefreshRateSelectorPolicy(pacesetter->getPhysicalId(),
+                                       pacesetter->refreshRateSelector());
+    }
+    onNewFrontInternalDisplay(nullptr, *display);
 
     static_cast<void>(mScheduler->schedule(
             [this]() FTL_FAKE_GUARD(kMainThreadContext) { initializeDisplays(); }));
@@ -1178,6 +1198,7 @@ status_t SurfaceFlinger::getStaticDisplayInfo(int64_t displayId, ui::StaticDispl
     info->connectionType = snapshot.connectionType();
     info->port = snapshot.port();
     info->deviceProductInfo = snapshot.deviceProductInfo();
+    info->screenPartStatus = snapshot.screenPartStatus();
 
     if (mEmulatedDisplayDensity) {
         info->density = mEmulatedDisplayDensity;
@@ -1239,9 +1260,10 @@ void SurfaceFlinger::getDynamicDisplayInfoInternal(ui::DynamicDisplayInfo*& info
         // VsyncController offset.  Any additional delays introduced by the hardware
         // composer or panel must be accounted for here.
         //
-        // We add an additional 1ms to allow for processing time and
-        // differences between the ideal and actual refresh rate.
-        outMode.presentationDeadline = peakFps.getPeriodNsecs() - outMode.sfVsyncOffset + 1000000;
+        outMode.presentationDeadline =
+                scheduler::Scheduler::getPresentationDeadline(peakFps,
+                                                              Duration::fromNs(
+                                                                      outMode.sfVsyncOffset));
         excludeDolbyVisionIf4k30Present(display->getHdrCapabilities().getSupportedHdrTypes(),
                                         outMode);
         info->supportedDisplayModes.push_back(outMode);
@@ -1361,7 +1383,7 @@ status_t SurfaceFlinger::getDisplayStats(const sp<IBinder>& displayToken,
     return NO_ERROR;
 }
 
-void SurfaceFlinger::setDesiredMode(display::DisplayModeRequest&& desiredMode) {
+void SurfaceFlinger::setDesiredMode(display::DisplayModeRequest desiredMode) {
     const auto mode = desiredMode.mode;
     const auto displayId = mode.modePtr->getPhysicalDisplayId();
 
@@ -1395,7 +1417,7 @@ void SurfaceFlinger::setDesiredMode(display::DisplayModeRequest&& desiredMode) {
             mScheduler->modulateVsync(displayId, &VsyncModulator::onRefreshRateChangeInitiated);
 
             mScheduler->updatePhaseConfiguration(displayId, mode.fps);
-            mScheduler->setModeChangePending(true);
+            mScheduler->setModeChangePending(displayId, true);
 
             // The mode set to switch resolution is not initiated until the display transaction that
             // resizes the display. DM sends this transaction in response to a mode change event, so
@@ -1519,9 +1541,8 @@ bool SurfaceFlinger::finalizeDisplayModeChange(PhysicalDisplayId displayId) {
 
 void SurfaceFlinger::dropModeRequest(PhysicalDisplayId displayId) {
     mDisplayModeController.clearDesiredMode(displayId);
-    if (displayId == mActiveDisplayId) {
-        // TODO(b/255635711): Check for pending mode changes on other displays.
-        mScheduler->setModeChangePending(false);
+    if (displayId == mFrontInternalDisplayId || FlagManager::getInstance().pacesetter_selection()) {
+        mScheduler->setModeChangePending(displayId, false);
     }
 }
 
@@ -2056,6 +2077,18 @@ status_t SurfaceFlinger::addRegionSamplingListener(const Rect& samplingArea,
     return NO_ERROR;
 }
 
+status_t SurfaceFlinger::addRegionSamplingListenerWithStopLayerId(
+        const Rect& samplingArea, const int32_t stopLayerId,
+        const sp<IRegionSamplingListener>& listener) {
+    if (!listener || samplingArea == Rect::INVALID_RECT || samplingArea.isEmpty()) {
+        return BAD_VALUE;
+    }
+
+    mRegionSamplingThread->addListener(samplingArea,
+                                       stopLayerId ? stopLayerId : UNASSIGNED_LAYER_ID, listener);
+    return NO_ERROR;
+}
+
 status_t SurfaceFlinger::removeRegionSamplingListener(const sp<IRegionSamplingListener>& listener) {
     if (!listener) {
         return BAD_VALUE;
@@ -2064,6 +2097,12 @@ status_t SurfaceFlinger::removeRegionSamplingListener(const sp<IRegionSamplingLi
     return NO_ERROR;
 }
 
+status_t SurfaceFlinger::getRegionSamplingListeners(
+        std::vector<gui::RegionSamplingDescriptor>* listeners) const {
+    *listeners = mRegionSamplingThread->getListeners();
+    return NO_ERROR;
+}
+
 status_t SurfaceFlinger::addFpsListener(int32_t taskId, const sp<gui::IFpsListener>& listener) {
     if (!listener) {
         return BAD_VALUE;
@@ -2592,12 +2631,8 @@ bool SurfaceFlinger::updateLayerSnapshots(VsyncId vsyncId, nsecs_t frameTimeNs,
         mUpdateAttachedChoreographer = true;
     }
     outTransactionsAreEmpty = mLayerLifecycleManager.getGlobalChanges().get() == 0;
-    if (FlagManager::getInstance().vrr_bugfix_24q4()) {
-        mustComposite |= mLayerLifecycleManager.getGlobalChanges().any(
-                frontend::RequestedLayerState::kMustComposite);
-    } else {
-        mustComposite |= mLayerLifecycleManager.getGlobalChanges().get() != 0;
-    }
+    mustComposite |= mLayerLifecycleManager.getGlobalChanges().any(
+            frontend::RequestedLayerState::kMustComposite);
 
     bool newDataLatched = false;
     SFTRACE_NAME("DisplayCallbackAndStatsUpdates");
@@ -2609,7 +2644,7 @@ bool SurfaceFlinger::updateLayerSnapshots(VsyncId vsyncId, nsecs_t frameTimeNs,
     for (auto& layer : mLayerLifecycleManager.getLayers()) {
         if (layer->changes.test(frontend::RequestedLayerState::Changes::Created) &&
             layer->bgColorLayer) {
-            sp<Layer> bgColorLayer = getFactory().createEffectLayer(
+            sp<Layer> bgColorLayer = getFactory().createLayer(
                     LayerCreationArgs(this, nullptr, layer->name,
                                       ISurfaceComposerClient::eFXSurfaceEffect, LayerMetadata(),
                                       std::make_optional(layer->id), true));
@@ -2699,6 +2734,20 @@ bool SurfaceFlinger::commit(PhysicalDisplayId pacesetterId,
         mTimeStats->incrementMissedFrames();
     }
 
+    // SF::processHotplugDisconnect() does not immediately propagate the display removal to the
+    // Scheduler and CompositionEngine, but instead requires a call to processDisplayChangesLocked()
+    // to process the rest in the next commit. We should retry the commit with the new pacesetter
+    // after display transactions have been propagated.
+    {
+        const bool hasPacesetterDisplay =
+                FTL_FAKE_GUARD(mStateLock, mPhysicalDisplays.contains(pacesetterId));
+        if (FlagManager::getInstance().pacesetter_selection() && !hasPacesetterDisplay) {
+            FTL_FAKE_GUARD(mStateLock, processDisplayChangesLocked());
+            mScheduler->scheduleFrame();
+            return false;
+        }
+    }
+
     // If a mode set is pending and the fence hasn't fired yet, wait for the next commit.
     if (std::any_of(frameTargets.begin(), frameTargets.end(),
                     [this](const auto& pair) FTL_FAKE_GUARD(kMainThreadContext) {
@@ -2729,9 +2778,7 @@ bool SurfaceFlinger::commit(PhysicalDisplayId pacesetterId,
                 mScheduler->getVsyncSchedule()->getTracker().onFrameMissed(
                         pacesetterFrameTarget.expectedPresentTime());
             }
-            const Duration slack = FlagManager::getInstance().allow_n_vsyncs_in_targeter()
-                    ? TimePoint::now() - pacesetterFrameTarget.frameBeginTime()
-                    : Duration::fromNs(0);
+            const Duration slack = TimePoint::now() - pacesetterFrameTarget.frameBeginTime();
             scheduleCommit(FrameHint::kNone, slack);
             return false;
         }
@@ -2740,10 +2787,10 @@ bool SurfaceFlinger::commit(PhysicalDisplayId pacesetterId,
     const Period vsyncPeriod = mScheduler->getVsyncSchedule()->period();
 
     // Save this once per commit + composite to ensure consistency
-    // TODO (b/240619471): consider removing active display check once AOD is fixed
-    const auto activeDisplay = FTL_FAKE_GUARD(mStateLock, getDisplayDeviceLocked(mActiveDisplayId));
-    mPowerHintSessionEnabled = mPowerAdvisor->usePowerHintSession() && activeDisplay &&
-            activeDisplay->getPowerMode() == hal::PowerMode::ON;
+    // TODO: b/240619471 - Consider removing front internal display check once AOD is fixed
+    const auto frontInternalDisplay = FTL_FAKE_GUARD(mStateLock, getFrontInternalDisplayLocked());
+    mPowerHintSessionEnabled = mPowerAdvisor->usePowerHintSession() && frontInternalDisplay &&
+            frontInternalDisplay->getPowerMode() == hal::PowerMode::ON;
     if (mPowerHintSessionEnabled) {
         mPowerAdvisor->setCommitStart(pacesetterFrameTarget.frameBeginTime());
         mPowerAdvisor->setExpectedPresentTime(pacesetterFrameTarget.expectedPresentTime());
@@ -2762,10 +2809,16 @@ bool SurfaceFlinger::commit(PhysicalDisplayId pacesetterId,
         mPowerAdvisor->updateTargetWorkDuration(idealVsyncPeriod);
     }
 
-    if (mRefreshRateOverlaySpinner || mHdrSdrRatioOverlay) {
+    if (mRefreshRateOverlaySpinner) {
         Mutex::Autolock lock(mStateLock);
-        if (const auto display = getDefaultDisplayDeviceLocked()) {
-            display->animateOverlay();
+        for (const auto& [_, display] : mDisplays) {
+            display->animateRefreshRateOverlay();
+        }
+    }
+    if (mHdrSdrRatioOverlay) {
+        Mutex::Autolock lock(mStateLock);
+        for (const auto& [_, display] : mDisplays) {
+            display->animateHdrSdrRatioOverlay();
         }
     }
 
@@ -2866,15 +2919,11 @@ CompositeResultsPerDisplay SurfaceFlinger::composite(
     // Tracks layer stacks of displays that are added to CompositionEngine output.
     ui::DisplayMap<ui::LayerStack, ftl::Unit> outputLayerStacks;
     auto isUniqueOutputLayerStack = [&outputLayerStacks](DisplayId id, ui::LayerStack layerStack) {
-        if (FlagManager::getInstance().reject_dupe_layerstacks()) {
-            if (layerStack != ui::INVALID_LAYER_STACK && outputLayerStacks.contains(layerStack)) {
-                // TODO: remove log and DisplayId from params once reject_dupe_layerstacks flag is
-                // removed
-                ALOGD("Existing layer stack ID %d output to another display %" PRIu64
-                      ", dropping display from outputs",
-                      layerStack.id, id.value);
-                return false;
-            }
+        if (layerStack != ui::UNASSIGNED_LAYER_STACK && outputLayerStacks.contains(layerStack)) {
+            ALOGD("Existing layer stack ID %d output to another display %" PRIu64
+                  ", dropping display from outputs",
+                  layerStack.id, id.value);
+            return false;
         }
 
         outputLayerStacks.try_emplace(layerStack);
@@ -2924,7 +2973,7 @@ CompositeResultsPerDisplay SurfaceFlinger::composite(
     refreshArgs.updatingOutputGeometryThisFrame = mVisibleRegionsDirty;
     refreshArgs.updatingGeometryThisFrame = mGeometryDirty.exchange(false) ||
             mVisibleRegionsDirty || mDrawingState.colorMatrixChanged;
-    refreshArgs.internalDisplayRotationFlags = getActiveDisplayRotationFlags();
+    refreshArgs.internalDisplayRotationFlags = getFrontInternalDisplayRotationFlags();
 
     if (CC_UNLIKELY(mDrawingState.colorMatrixChanged)) {
         refreshArgs.colorTransformMatrix = mDrawingState.colorMatrix;
@@ -2975,12 +3024,16 @@ CompositeResultsPerDisplay SurfaceFlinger::composite(
             }
         }
     }
-
     refreshArgs.refreshStartTime = systemTime(SYSTEM_TIME_MONOTONIC);
+
     for (auto& [layer, layerFE] : layers) {
         layer->onPreComposition(refreshArgs.refreshStartTime);
+
+        validateForReadback(layerFE);
     }
 
+    setupOutputsForReadback(refreshArgs.outputs);
+
     for (auto& [layer, layerFE] : layers) {
         attachReleaseFenceFutureToLayer(layer, layerFE,
                                         layerFE->mSnapshot->outputFilter.layerStack);
@@ -2996,14 +3049,17 @@ CompositeResultsPerDisplay SurfaceFlinger::composite(
                         LayerFE::ReleaseFencePromiseStatus::UNINITIALIZED ||
                 layerFE->getReleaseFencePromiseStatus() ==
                         LayerFE::ReleaseFencePromiseStatus::FULFILLED) {
-                // layerStack is invalid because layer is not on a display
+                // layerStack is unassigned because layer is not on a display
                 attachReleaseFenceFutureToLayer(layer.get(), layerFE.get(),
-                                                ui::INVALID_LAYER_STACK);
+                                                ui::UNASSIGNED_LAYER_STACK);
             }
         }
     }
 
     mCompositionEngine->present(refreshArgs);
+
+    finalizeReadback(refreshArgs.outputs);
+
     ftl::Flags<adpf::Workload> compositedWorkload;
     if (refreshArgs.updatingGeometryThisFrame || refreshArgs.updatingOutputGeometryThisFrame) {
         compositedWorkload |= adpf::Workload::VISIBLE_REGION;
@@ -3015,13 +3071,13 @@ CompositeResultsPerDisplay SurfaceFlinger::composite(
 
     int index = 0;
     ftl::StaticVector<char, WorkloadTracer::COMPOSITION_SUMMARY_SIZE> compositionSummary;
-    auto lastLayerStack = ui::INVALID_LAYER_STACK;
+    auto lastLayerStack = ui::UNASSIGNED_LAYER_STACK;
 
     uint64_t prevOverrideBufferId = 0;
     for (auto& [layer, layerFE] : layers) {
         CompositionResult compositionResult{layerFE->stealCompositionResult()};
         if (lastLayerStack != layerFE->mSnapshot->outputFilter.layerStack) {
-            if (lastLayerStack != ui::INVALID_LAYER_STACK) {
+            if (lastLayerStack != ui::UNASSIGNED_LAYER_STACK) {
                 // add a space to separate displays
                 compositionSummary.push_back(' ');
             }
@@ -3346,7 +3402,7 @@ void SurfaceFlinger::onCompositionPresented(PhysicalDisplayId pacesetterId,
             if (optDisplay && !optDisplay->get()->isVirtual()) {
                 auto fence = getHwComposer().getPresentFence(optDisplay->get()->getPhysicalId());
                 layer->prepareReleaseCallbacks(ftl::yield<FenceResult>(fence),
-                                               ui::INVALID_LAYER_STACK);
+                                               ui::UNASSIGNED_LAYER_STACK);
             }
         }
         layer->releasePendingBuffer(presentTime.ns());
@@ -3365,7 +3421,9 @@ void SurfaceFlinger::onCompositionPresented(PhysicalDisplayId pacesetterId,
                 stats::stats_write(stats::SURFACE_CONTROL_EVENT,
                                    static_cast<int32_t>(layerEvent.uid),
                                    static_cast<int64_t>(layerEvent.timeSinceLastEvent.count()),
-                                   static_cast<int32_t>(layerEvent.dataspace));
+                                   static_cast<int32_t>(layerEvent.dataspace),
+                                   static_cast<bool>(layerEvent.useLuts),
+                                   static_cast<float>(layerEvent.desiredHdrHeadroom));
         if (result < 0) {
             ALOGW("Failed to report layer event with error: %d", result);
         }
@@ -3701,13 +3759,16 @@ bool SurfaceFlinger::configureLocked() {
     }
 
     for (const auto [hwcDisplayId, event] : events) {
-        if (auto info = getHwComposer().onHotplug(hwcDisplayId, event)) {
-            const auto displayId = info->id;
-            const ftl::Concat displayString("display ", displayId.value, "(HAL ID ", hwcDisplayId,
-                                            ')');
-            // TODO: b/393126541 - replace if with switch as all cases are handled.
-            if (event == HWComposer::HotplugEvent::Connected ||
-                event == HWComposer::HotplugEvent::LinkUnstable) {
+        auto info = getHwComposer().onHotplug(hwcDisplayId, event);
+        if (!info) {
+            continue;
+        }
+
+        const auto displayId = info->id;
+        const ftl::Concat displayString("display ", displayId.value, "(HAL ID ", hwcDisplayId, ')');
+        switch (event) {
+            case HWComposer::HotplugEvent::Connected:
+            case HWComposer::HotplugEvent::LinkUnstable: {
                 const auto activeModeIdOpt =
                         processHotplugConnect(displayId, hwcDisplayId, std::move(*info),
                                               displayString.c_str(), event);
@@ -3736,23 +3797,23 @@ bool SurfaceFlinger::configureLocked() {
                 LOG_ALWAYS_FATAL_IF(!snapshotOpt);
 
                 mDisplayModeController.registerDisplay(*snapshotOpt, *activeModeIdOpt, config);
-            } else { // event == HWComposer::HotplugEvent::Disconnected
+                break;
+            }
+            case HWComposer::HotplugEvent::Disconnected:
                 // Unregister before destroying the DisplaySnapshot below.
                 mDisplayModeController.unregisterDisplay(displayId);
-
                 processHotplugDisconnect(displayId, displayString.c_str());
-            }
+                break;
         }
     }
 
     return !events.empty();
 }
 
-std::optional<DisplayModeId> SurfaceFlinger::processHotplugConnect(PhysicalDisplayId displayId,
-                                                                   hal::HWDisplayId hwcDisplayId,
-                                                                   DisplayIdentificationInfo&& info,
-                                                                   const char* displayString,
-                                                                   HWComposer::HotplugEvent event) {
+std::optional<DisplayModeId> SurfaceFlinger::processHotplugConnect(
+        PhysicalDisplayId displayId, hal::HWDisplayId hwcDisplayId,
+        display::DisplayIdentificationInfo&& info, const char* displayString,
+        HWComposer::HotplugEvent event) {
     auto [displayModes, activeMode] = loadDisplayModes(displayId);
     if (!activeMode) {
         ALOGE("Failed to hotplug %s", displayString);
@@ -3766,6 +3827,7 @@ std::optional<DisplayModeId> SurfaceFlinger::processHotplugConnect(PhysicalDispl
         const auto& display = displayOpt->get();
         const auto& snapshot = display.snapshot();
         const uint8_t port = snapshot.port();
+        const android::ScreenPartStatus screenPartStatus = snapshot.screenPartStatus();
 
         std::optional<DeviceProductInfo> deviceProductInfo;
         if (getHwComposer().updatesDeviceProductInfoOnHotplugReconnect()) {
@@ -3778,8 +3840,9 @@ std::optional<DisplayModeId> SurfaceFlinger::processHotplugConnect(PhysicalDispl
         // display on reconnect.
         const auto it =
                 mPhysicalDisplays.try_replace(displayId, display.token(), displayId, port,
-                                              snapshot.connectionType(), std::move(displayModes),
-                                              std::move(colorModes), std::move(deviceProductInfo));
+                                              screenPartStatus, snapshot.connectionType(),
+                                              std::move(displayModes), std::move(colorModes),
+                                              std::move(deviceProductInfo));
 
         auto& state = mCurrentState.displays.editValueFor(it->second.token());
         state.sequenceId = DisplayDeviceState{}.sequenceId; // Generate new sequenceId.
@@ -3796,8 +3859,8 @@ std::optional<DisplayModeId> SurfaceFlinger::processHotplugConnect(PhysicalDispl
     const ui::DisplayConnectionType connectionType =
             getHwComposer().getDisplayConnectionType(displayId);
 
-    mPhysicalDisplays.try_emplace(displayId, token, displayId, info.port, connectionType,
-                                  std::move(displayModes), std::move(colorModes),
+    mPhysicalDisplays.try_emplace(displayId, token, displayId, info.port, info.screenPartStatus,
+                                  connectionType, std::move(displayModes), std::move(colorModes),
                                   std::move(info.deviceProductInfo));
 
     DisplayDeviceState state;
@@ -4010,7 +4073,6 @@ void SurfaceFlinger::processDisplayAdded(const wp<IBinder>& displayToken,
                  "adding a supported display, but rendering "
                  "surface is provided (%p), ignoring it",
                  state.surface.get());
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
         const auto frameBufferSurface =
                 sp<FramebufferSurface>::make(getHwComposer(), state.physical->id, bqProducer,
                                              bqConsumer,
@@ -4018,13 +4080,6 @@ void SurfaceFlinger::processDisplayAdded(const wp<IBinder>& displayToken,
                                              ui::Size(maxGraphicsWidth, maxGraphicsHeight));
         displaySurface = frameBufferSurface;
         producer = frameBufferSurface->getSurface()->getIGraphicBufferProducer();
-#else
-        displaySurface =
-                sp<FramebufferSurface>::make(getHwComposer(), state.physical->id, bqConsumer,
-                                             state.physical->activeMode->getResolution(),
-                                             ui::Size(maxGraphicsWidth, maxGraphicsHeight));
-        producer = bqProducer;
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
     }
 
     LOG_FATAL_IF(!displaySurface);
@@ -4034,7 +4089,7 @@ void SurfaceFlinger::processDisplayAdded(const wp<IBinder>& displayToken,
     if (mScheduler && !display->isVirtual()) {
         // For hotplug reconnect, renew the registration since display modes have been reloaded.
         mScheduler->registerDisplay(display->getPhysicalId(), display->holdRefreshRateSelector(),
-                                    mActiveDisplayId);
+                                    mFrontInternalDisplayId);
     }
 
     if (display->isVirtual()) {
@@ -4080,7 +4135,7 @@ void SurfaceFlinger::processDisplayRemoved(const wp<IBinder>& displayToken) {
         if (const auto virtualDisplayIdVariant = display->getVirtualDisplayIdVariant()) {
             releaseVirtualDisplay(*virtualDisplayIdVariant);
         } else {
-            mScheduler->unregisterDisplay(display->getPhysicalId(), mActiveDisplayId);
+            mScheduler->unregisterDisplay(display->getPhysicalId(), mFrontInternalDisplayId);
         }
 
         if (display->isRefreshable()) {
@@ -4145,8 +4200,17 @@ void SurfaceFlinger::processDisplayChanged(const wp<IBinder>& displayToken,
                 setPhysicalDisplayPowerMode(display, hal::PowerMode::ON);
             }
 
-            if (display->getPhysicalId() == mActiveDisplayId) {
-                onActiveDisplayChangedLocked(nullptr, *display);
+            if (display->getPhysicalId() == mFrontInternalDisplayId) {
+                if (FlagManager::getInstance().pacesetter_selection()) {
+                    mScheduler->setPacesetterDisplay(mFrontInternalDisplayId);
+
+                    getRenderEngine().onActiveDisplaySizeChanged(
+                            findLargestFramebufferSizeLocked());
+                    const auto pacesetter = getPacesetterDisplayLocked();
+                    applyRefreshRateSelectorPolicy(pacesetter->getPhysicalId(),
+                                                   pacesetter->refreshRateSelector());
+                }
+                onNewFrontInternalDisplay(nullptr, *display);
             }
         }
         return;
@@ -4161,7 +4225,7 @@ void SurfaceFlinger::processDisplayChanged(const wp<IBinder>& displayToken,
             display->setFlags(currentState.flags);
         }
 
-        const auto updateDisplaySize = [&]() {
+        const auto updateDisplaySize = [&]() REQUIRES(mStateLock) {
             if (currentState.width != drawingState.width ||
                 currentState.height != drawingState.height) {
                 const ui::Size resolution = ui::Size(currentState.width, currentState.height);
@@ -4178,8 +4242,17 @@ void SurfaceFlinger::processDisplayChanged(const wp<IBinder>& displayToken,
                     display->setDisplaySize(resolution);
                 }
 
-                if (display->getId() == mActiveDisplayId) {
-                    onActiveDisplaySizeChanged(*display);
+                if (FlagManager::getInstance().pacesetter_selection()) {
+                    if (display->getId() == mScheduler->getPacesetterDisplayId()) {
+                        mScheduler->onPacesetterDisplaySizeChanged(display->getSize());
+                        getRenderEngine().onActiveDisplaySizeChanged(
+                                findLargestFramebufferSizeLocked());
+                    }
+                } else {
+                    if (display->getId() == mFrontInternalDisplayId) {
+                        mScheduler->onPacesetterDisplaySizeChanged(display->getSize());
+                        getRenderEngine().onActiveDisplaySizeChanged(display->getSize());
+                    }
                 }
             }
         };
@@ -4194,9 +4267,9 @@ void SurfaceFlinger::processDisplayChanged(const wp<IBinder>& displayToken,
             (currentState.orientedDisplaySpaceRect != drawingState.orientedDisplaySpaceRect)) {
             display->setProjection(currentState.orientation, currentState.layerStackSpaceRect,
                                    currentState.orientedDisplaySpaceRect);
-            if (display->getId() == mActiveDisplayId) {
-                mActiveDisplayTransformHint = display->getTransformHint();
-                sActiveDisplayRotationFlags =
+            if (display->getId() == mFrontInternalDisplayId) {
+                mFrontInternalDisplayTransformHint = display->getTransformHint();
+                sFrontInternalDisplayRotationFlags =
                         ui::Transform::toRotationFlags(display->getOrientation());
             }
         }
@@ -4433,7 +4506,7 @@ void SurfaceFlinger::requestDisplayModes(std::vector<display::DisplayModeRequest
         if (!display) continue;
 
         if (display->refreshRateSelector().isModeAllowed(request.mode)) {
-            setDesiredMode(std::move(request));
+            setDesiredMode(request);
         } else {
             ALOGV("%s: Mode %d is disallowed for display %s", __func__,
                   ftl::to_underlying(modePtr->getId()), to_string(displayId).c_str());
@@ -4595,9 +4668,7 @@ void SurfaceFlinger::sendNotifyExpectedPresentHint(PhysicalDisplayId displayId)
 }
 
 void SurfaceFlinger::onCommitNotComposited() {
-    if (FlagManager::getInstance().commit_not_composited()) {
-        mFrameTimeline->onCommitNotComposited();
-    }
+    mFrameTimeline->onCommitNotComposited();
 }
 
 void SurfaceFlinger::initScheduler(const sp<const DisplayDevice>& display) {
@@ -4610,9 +4681,7 @@ void SurfaceFlinger::initScheduler(const sp<const DisplayDevice>& display) {
 
     FeatureFlags features;
 
-    const auto defaultContentDetectionValue =
-            FlagManager::getInstance().enable_fro_dependent_features() &&
-            sysprop::enable_frame_rate_override(true);
+    const auto defaultContentDetectionValue = sysprop::enable_frame_rate_override(true);
     if (sysprop::use_content_detection_for_refresh_rate(defaultContentDetectionValue)) {
         features |= Feature::kContentDetection;
         if (FlagManager::getInstance().enable_small_area_detection()) {
@@ -4643,7 +4712,7 @@ void SurfaceFlinger::initScheduler(const sp<const DisplayDevice>& display) {
 
     // The pacesetter must be registered before EventThread creation below.
     mScheduler->registerDisplay(display->getPhysicalId(), display->holdRefreshRateSelector(),
-                                mActiveDisplayId);
+                                mFrontInternalDisplayId);
     if (FlagManager::getInstance().vrr_config()) {
         mScheduler->setRenderRate(display->getPhysicalId(), activeMode.fps,
                                   /*applyImmediately*/ true);
@@ -4688,11 +4757,30 @@ void SurfaceFlinger::invalidateLayerStack(const ui::LayerFilter& layerFilter, co
     }
 }
 
+ui::Size SurfaceFlinger::findLargestFramebufferSizeLocked() const {
+    ui::Size maxSize(0, 0);
+    int64_t maxArea = 0;
+    for (const auto& [_, display] : mDisplays) {
+        if (!display->isPoweredOn()) {
+            continue;
+        }
+
+        const ui::Size size = display->getSize();
+        const int64_t area = size.getWidth() * size.getHeight();
+        if (area > maxArea) {
+            maxSize = size;
+            maxArea = area;
+        }
+    }
+
+    return maxSize;
+}
+
 status_t SurfaceFlinger::addClientLayer(LayerCreationArgs& args, const sp<IBinder>& handle,
                                         const sp<Layer>& layer, const wp<Layer>& parent,
                                         uint32_t* outTransformHint) {
     if (outTransformHint) {
-        *outTransformHint = mActiveDisplayTransformHint;
+        *outTransformHint = mFrontInternalDisplayTransformHint;
     }
     args.parentId = LayerHandle::getLayerId(args.parentHandle.promote());
     args.layerIdToMirror = LayerHandle::getLayerId(args.mirrorLayerHandle.promote());
@@ -4720,8 +4808,10 @@ uint32_t SurfaceFlinger::clearTransactionFlags(uint32_t mask) {
 }
 
 void SurfaceFlinger::setTransactionFlags(uint32_t mask, TransactionSchedule schedule,
-                                         const sp<IBinder>& applyToken, FrameHint frameHint) {
-    mScheduler->modulateVsync({}, &VsyncModulator::setTransactionSchedule, schedule, applyToken);
+                                         FrameHint frameHint,
+                                         std::vector<gui::EarlyWakeupInfo> earlyWakeupInfos) {
+    mScheduler->modulateVsync({}, &VsyncModulator::setTransactionSchedule, schedule,
+                              std::move(earlyWakeupInfos));
     uint32_t transactionFlags = mTransactionFlags.fetch_or(mask);
     SFTRACE_INT("mTransactionFlags", transactionFlags);
 
@@ -4983,7 +5073,10 @@ bool SurfaceFlinger::shouldLatchUnsignaled(const layer_state_t& state, size_t nu
     return true;
 }
 
-status_t SurfaceFlinger::setTransactionState(TransactionState&& transactionState) {
+status_t SurfaceFlinger::setTransactionState(SimpleTransactionState podState,
+                                             const ComplexTransactionState& complexState,
+                                             MutableTransactionState& mutableState,
+                                             const sp<IBinder>& applyToken) {
     SFTRACE_CALL();
 
     IPCThreadState* ipc = IPCThreadState::self();
@@ -4991,7 +5084,8 @@ status_t SurfaceFlinger::setTransactionState(TransactionState&& transactionState
     const int originUid = ipc->getCallingUid();
     uint32_t permissions = LayerStatePermissions::getTransactionPermissions(originPid, originUid);
     ftl::Flags<adpf::Workload> queuedWorkload;
-    for (auto& composerState : transactionState.mComposerStates) {
+    auto& states = mutableState.mComposerStates;
+    for (auto& composerState : states) {
         composerState.state.sanitize(permissions);
         if (composerState.state.what & layer_state_t::COMPOSITION_EFFECTS) {
             queuedWorkload |= adpf::Workload::EFFECTS;
@@ -5001,27 +5095,30 @@ status_t SurfaceFlinger::setTransactionState(TransactionState&& transactionState
         }
     }
 
-    for (DisplayState& display : transactionState.mDisplayStates) {
+    for (DisplayState& display : mutableState.mDisplayStates) {
         display.sanitize(permissions);
     }
 
-    if (!transactionState.mInputWindowCommands.empty() &&
+    auto inputWindowCommands = complexState.mInputWindowCommands;
+    if (!inputWindowCommands.empty() &&
         (permissions & layer_state_t::Permission::ACCESS_SURFACE_FLINGER) == 0) {
         ALOGE("Only privileged callers are allowed to send input commands.");
-        transactionState.mInputWindowCommands.clear();
+        inputWindowCommands.clear();
     }
 
-    if (transactionState.mFlags & (eEarlyWakeupStart | eEarlyWakeupEnd)) {
+    uint32_t flags = podState.mFlags;
+
+    if (flags & (eEarlyWakeupStart | eEarlyWakeupEnd)) {
         const bool hasPermission =
                 (permissions & layer_state_t::Permission::ACCESS_SURFACE_FLINGER) ||
                 callingThreadHasPermission(sWakeupSurfaceFlinger);
         if (!hasPermission) {
             ALOGE("Caller needs permission android.permission.WAKEUP_SURFACE_FLINGER to use "
                   "eEarlyWakeup[Start|End] flags");
-            transactionState.mFlags &= ~(eEarlyWakeupStart | eEarlyWakeupEnd);
+            flags &= ~(eEarlyWakeupStart | eEarlyWakeupEnd);
         }
     }
-    if (transactionState.mFlags & eEarlyWakeupStart) {
+    if (flags & eEarlyWakeupStart) {
         queuedWorkload |= adpf::Workload::WAKEUP;
     }
     mPowerAdvisor->setQueuedWorkload(queuedWorkload);
@@ -5029,8 +5126,9 @@ status_t SurfaceFlinger::setTransactionState(TransactionState&& transactionState
     const int64_t postTime = systemTime();
 
     std::vector<uint64_t> uncacheBufferIds;
-    uncacheBufferIds.reserve(transactionState.mUncacheBuffers.size());
-    for (const auto& uncacheBuffer : transactionState.mUncacheBuffers) {
+    const auto& uncacheBuffers = complexState.mUncacheBuffers;
+    uncacheBufferIds.reserve(uncacheBuffers.size());
+    for (const auto& uncacheBuffer : uncacheBuffers) {
         sp<GraphicBuffer> buffer = ClientCache::getInstance().erase(uncacheBuffer);
         if (buffer != nullptr) {
             uncacheBufferIds.push_back(buffer->getId());
@@ -5038,8 +5136,8 @@ status_t SurfaceFlinger::setTransactionState(TransactionState&& transactionState
     }
 
     std::vector<ResolvedComposerState> resolvedStates;
-    resolvedStates.reserve(transactionState.mComposerStates.size());
-    for (auto& state : transactionState.mComposerStates) {
+    resolvedStates.reserve(states.size());
+    for (auto& state : states) {
         resolvedStates.emplace_back(std::move(state));
         auto& resolvedState = resolvedStates.back();
         resolvedState.layerId = LayerHandle::getLayerId(resolvedState.state.surface);
@@ -5050,7 +5148,7 @@ status_t SurfaceFlinger::setTransactionState(TransactionState&& transactionState
                     (layer) ? layer->getDebugName() : std::to_string(resolvedState.state.layerId);
             resolvedState.externalTexture =
                     getExternalTextureFromBufferData(*resolvedState.state.bufferData,
-                                                     layerName.c_str(), transactionState.getId());
+                                                     layerName.c_str(), podState.mId);
             if (resolvedState.externalTexture) {
                 resolvedState.state.bufferData->buffer = resolvedState.externalTexture->getBuffer();
                 if (FlagManager::getInstance().monitor_buffer_fences()) {
@@ -5078,12 +5176,23 @@ status_t SurfaceFlinger::setTransactionState(TransactionState&& transactionState
         }
     }
 
-    QueuedTransactionState state{std::move(transactionState),
-                                 std::move(resolvedStates),
+    QueuedTransactionState state{complexState.mFrameTimelineInfo,
+                                 resolvedStates,
+                                 mutableState.mDisplayStates,
+                                 flags,
+                                 applyToken,
+                                 std::move(inputWindowCommands),
+                                 podState.mDesiredPresentTime,
+                                 podState.mIsAutoTimestamp,
                                  std::move(uncacheBufferIds),
                                  postTime,
+                                 complexState.mCallbacks.mHasListenerCallbacks,
+                                 complexState.mCallbacks.mFlattenedListenerCallbacks,
                                  originPid,
-                                 originUid};
+                                 originUid,
+                                 podState.mId,
+                                 complexState.mMergedTransactionIds,
+                                 complexState.mEarlyWakeupInfos};
     state.workloadHint = queuedWorkload;
 
     if (mTransactionTracing) {
@@ -5098,8 +5207,6 @@ status_t SurfaceFlinger::setTransactionState(TransactionState&& transactionState
 
     const auto frameHint = state.isFrameActive() ? FrameHint::kActive : FrameHint::kNone;
     // Copy fields of |state| needed after it is moved into queueTransaction
-    VsyncId vsyncId{state.frameTimelineInfo.vsyncId};
-    auto applyToken = state.applyToken;
     {
         // Transactions are added via a lockless queue and does not need to be added from the main
         // thread.
@@ -5109,16 +5216,18 @@ status_t SurfaceFlinger::setTransactionState(TransactionState&& transactionState
 
     for (const auto& [displayId, data] : mNotifyExpectedPresentMap) {
         if (data.hintStatus.load() == NotifyExpectedPresentHintStatus::ScheduleOnTx) {
-            scheduleNotifyExpectedPresentHint(displayId, vsyncId);
+            scheduleNotifyExpectedPresentHint(displayId,
+                                              VsyncId{complexState.mFrameTimelineInfo.vsyncId});
         }
     }
-    setTransactionFlags(eTransactionFlushNeeded, schedule, applyToken, frameHint);
+    setTransactionFlags(eTransactionFlushNeeded, schedule, frameHint,
+                        std::move(complexState.mEarlyWakeupInfos));
     return NO_ERROR;
 }
 
 bool SurfaceFlinger::applyTransactionState(
         const FrameTimelineInfo& frameTimelineInfo, std::vector<ResolvedComposerState>& states,
-        std::span<DisplayState> displays, uint32_t flags,
+        Vector<DisplayState>& displays, uint32_t flags,
         const InputWindowCommands& inputWindowCommands, const int64_t desiredPresentTime,
         bool isAutoTimestamp, const std::vector<uint64_t>& uncacheBufferIds, const int64_t postTime,
         bool hasListenerCallbacks, const std::vector<ListenerCallbacks>& listenerCallbacks,
@@ -5393,6 +5502,10 @@ uint32_t SurfaceFlinger::updateLayerCallbacksAndStats(const FrameTimelineInfo& f
         layer->setBufferReleaseChannel(s.bufferReleaseChannel);
     }
 
+    if (what & layer_state_t::eLutsChanged) {
+        layer->setUseLuts(s.luts ? true : false);
+    }
+
     const auto& requestedLayerState = mLayerLifecycleManager.getLayerFromId(layer->getSequence());
     bool willPresentCurrentTransaction = requestedLayerState &&
             (requestedLayerState->hasReadyFrame() ||
@@ -5410,6 +5523,7 @@ uint32_t SurfaceFlinger::addInputWindowCommands(const InputWindowCommands& input
 
 status_t SurfaceFlinger::mirrorLayer(const LayerCreationArgs& args,
                                      const sp<IBinder>& mirrorFromHandle,
+                                     const sp<IBinder>& stopAtHandle,
                                      gui::CreateSurfaceResult& outResult) {
     if (!mirrorFromHandle) {
         return NAME_NOT_FOUND;
@@ -5427,7 +5541,14 @@ status_t SurfaceFlinger::mirrorLayer(const LayerCreationArgs& args,
         mirrorArgs.flags |= ISurfaceComposerClient::eNoColorFill;
         mirrorArgs.mirrorLayerHandle = mirrorFromHandle;
         mirrorArgs.addToRoot = false;
-        status_t result = createEffectLayer(mirrorArgs, &outResult.handle, &mirrorLayer);
+        if (stopAtHandle) {
+            uint32_t stopLayerId = LayerHandle::getLayerId(stopAtHandle);
+            if (stopLayerId == UNASSIGNED_LAYER_ID) {
+                return NAME_NOT_FOUND;
+            }
+            mirrorArgs.stopLayerId = stopLayerId;
+        }
+        status_t result = createLayer(mirrorArgs, &outResult.handle, &mirrorLayer);
         if (result != NO_ERROR) {
             return result;
         }
@@ -5451,6 +5572,7 @@ status_t SurfaceFlinger::mirrorDisplay(DisplayId displayId, const LayerCreationA
     ui::LayerStack layerStack;
     sp<Layer> rootMirrorLayer;
     status_t result = 0;
+    LayerCreationArgs mirrorArgs = LayerCreationArgs::fromOtherArgs(args);
 
     {
         Mutex::Autolock lock(mStateLock);
@@ -5461,19 +5583,18 @@ status_t SurfaceFlinger::mirrorDisplay(DisplayId displayId, const LayerCreationA
         }
 
         layerStack = display->getLayerStack();
-        LayerCreationArgs mirrorArgs = LayerCreationArgs::fromOtherArgs(args);
         mirrorArgs.flags |= ISurfaceComposerClient::eNoColorFill;
         mirrorArgs.addToRoot = true;
         mirrorArgs.layerStackToMirror = layerStack;
-        result = createEffectLayer(mirrorArgs, &outResult.handle, &rootMirrorLayer);
+        result = createLayer(mirrorArgs, &outResult.handle, &rootMirrorLayer);
         if (result != NO_ERROR) {
             return result;
         }
-        outResult.layerId = rootMirrorLayer->sequence;
-        outResult.layerName = String16(rootMirrorLayer->getDebugName());
-        addClientLayer(mirrorArgs, outResult.handle, rootMirrorLayer /* layer */,
-                       nullptr /* parent */, nullptr /* outTransformHint */);
     }
+    outResult.layerId = rootMirrorLayer->sequence;
+    outResult.layerName = String16(rootMirrorLayer->getDebugName());
+    addClientLayer(mirrorArgs, outResult.handle, rootMirrorLayer /* layer */, nullptr /* parent */,
+                   nullptr /* outTransformHint */);
 
     setTransactionFlags(eTransactionFlushNeeded);
     return NO_ERROR;
@@ -5491,7 +5612,7 @@ status_t SurfaceFlinger::createLayer(LayerCreationArgs& args, gui::CreateSurface
             args.flags |= ISurfaceComposerClient::eNoColorFill;
             [[fallthrough]];
         case ISurfaceComposerClient::eFXSurfaceEffect: {
-            result = createBufferStateLayer(args, &outResult.handle, &layer);
+            result = createLayer(args, &outResult.handle, &layer);
             if (result != NO_ERROR) {
                 return result;
             }
@@ -5533,22 +5654,12 @@ status_t SurfaceFlinger::createLayer(LayerCreationArgs& args, gui::CreateSurface
     return result;
 }
 
-status_t SurfaceFlinger::createBufferStateLayer(LayerCreationArgs& args, sp<IBinder>* handle,
-                                                sp<Layer>* outLayer) {
-    if (checkLayerLeaks() != NO_ERROR) {
-        return NO_MEMORY;
-    }
-    *outLayer = getFactory().createBufferStateLayer(args);
-    *handle = (*outLayer)->getHandle();
-    return NO_ERROR;
-}
-
-status_t SurfaceFlinger::createEffectLayer(const LayerCreationArgs& args, sp<IBinder>* handle,
-                                           sp<Layer>* outLayer) {
+status_t SurfaceFlinger::createLayer(const LayerCreationArgs& args, sp<IBinder>* handle,
+                                     sp<Layer>* outLayer) {
     if (checkLayerLeaks() != NO_ERROR) {
         return NO_MEMORY;
     }
-    *outLayer = getFactory().createEffectLayer(args);
+    *outLayer = getFactory().createLayer(args);
     *handle = (*outLayer)->getHandle();
     return NO_ERROR;
 }
@@ -5608,8 +5719,7 @@ void SurfaceFlinger::initializeDisplays() {
 
     auto layerStack = ui::DEFAULT_LAYER_STACK.id;
     for (const auto& [id, display] : FTL_FAKE_GUARD(mStateLock, mPhysicalDisplays)) {
-        state.displays.emplace_back(
-                DisplayState(display.token(), ui::LayerStack::fromValue(layerStack++)));
+        state.displays.push(DisplayState(display.token(), ui::LayerStack::fromValue(layerStack++)));
     }
 
     std::vector<QueuedTransactionState> transactions;
@@ -5661,12 +5771,6 @@ void SurfaceFlinger::setPhysicalDisplayPowerMode(const sp<DisplayDevice>& displa
                                            .transform(&PhysicalDisplay::isInternal)
                                            .value_or(false);
 
-    const auto activeDisplay = getDisplayDeviceLocked(mActiveDisplayId);
-
-    ALOGW_IF(display != activeDisplay && isInternalDisplay && activeDisplay &&
-                     activeDisplay->isPoweredOn(),
-             "Trying to change power mode on inactive display without powering off active display");
-
     const bool couldRefresh = display->isRefreshable();
     display->setPowerMode(mode);
     const bool canRefresh = display->isRefreshable();
@@ -5677,27 +5781,32 @@ void SurfaceFlinger::setPhysicalDisplayPowerMode(const sp<DisplayDevice>& displa
         incRefreshableDisplays();
     }
 
+    const bool shouldApplyOptimizationPolicy =
+            FlagManager::getInstance().disable_synthetic_vsync_for_performance() &&
+            FlagManager::getInstance().correct_virtual_display_power_state();
+    if ((isInternalDisplay || FlagManager::getInstance().pacesetter_selection()) &&
+        shouldApplyOptimizationPolicy) {
+        applyOptimizationPolicy(__func__);
+    }
+
     const auto activeMode = display->refreshRateSelector().getActiveMode().modePtr;
+    using OptimizationPolicy = gui::ISurfaceComposer::OptimizationPolicy;
     if (currentMode == hal::PowerMode::OFF) {
         // Turn on the display
+        const auto frontInternalDisplay = getFrontInternalDisplayLocked();
 
-        // Activate the display (which involves a modeset to the active mode) when the inner or
-        // outer display of a foldable is powered on. This condition relies on the above
-        // DisplayDevice::setPowerMode. If `display` and `activeDisplay` are the same display,
-        // then the `activeDisplay->isPoweredOn()` below is true, such that the display is not
-        // activated every time it is powered on.
-        //
-        // TODO(b/255635821): Remove the concept of active display.
-        if (isInternalDisplay && (!activeDisplay || !activeDisplay->isPoweredOn())) {
-            onActiveDisplayChangedLocked(activeDisplay.get(), *display);
+        // Detects the new front internal display when the inner or outer display of a foldable is
+        // powered on. This condition relies on the above DisplayDevice::setPowerMode. If `display`
+        // and `frontInternalDisplay` are the same display, then the
+        // `frontInternalDisplay->isPoweredOn()` below is true, such that the front internal display
+        // is not detected every time it is powered on.
+        if (isInternalDisplay && (!frontInternalDisplay || !frontInternalDisplay->isPoweredOn())) {
+            onNewFrontInternalDisplay(frontInternalDisplay.get(), *display);
         }
 
-        if (displayId == mActiveDisplayId) {
-            if (FlagManager::getInstance().correct_virtual_display_power_state()) {
-                applyOptimizationPolicy("setPhysicalDisplayPowerMode(ON)");
-            } else {
-                disablePowerOptimizations("setPhysicalDisplayPowerMode(ON)");
-            }
+        if (displayId == mFrontInternalDisplayId && !shouldApplyOptimizationPolicy) {
+            optimizeThreadScheduling("setPhysicalDisplayPowerMode(ON/DOZE)",
+                                     OptimizationPolicy::optimizeForPerformance);
         }
 
         getHwComposer().setPowerMode(displayId, mode);
@@ -5706,7 +5815,7 @@ void SurfaceFlinger::setPhysicalDisplayPowerMode(const sp<DisplayDevice>& displa
                     mScheduler->getVsyncSchedule(displayId)->getPendingHardwareVsyncState();
             requestHardwareVsync(displayId, enable);
 
-            if (displayId == mActiveDisplayId) {
+            if (displayId == mFrontInternalDisplayId && !shouldApplyOptimizationPolicy) {
                 mScheduler->enableSyntheticVsync(false);
             }
 
@@ -5719,17 +5828,21 @@ void SurfaceFlinger::setPhysicalDisplayPowerMode(const sp<DisplayDevice>& displa
     } else if (mode == hal::PowerMode::OFF) {
         const bool currentModeNotDozeSuspend = (currentMode != hal::PowerMode::DOZE_SUSPEND);
         // Turn off the display
-        if (displayId == mActiveDisplayId) {
-            if (const auto display = getActivatableDisplay()) {
-                onActiveDisplayChangedLocked(activeDisplay.get(), *display);
+        if (FlagManager::getInstance().pacesetter_selection()) {
+            mScheduler->setModeChangePending(displayId, false);
+        }
+
+        if (displayId == mFrontInternalDisplayId) {
+            if (const auto display = findFrontInternalDisplay()) {
+                const auto frontInternalDisplay = getFrontInternalDisplayLocked();
+                onNewFrontInternalDisplay(frontInternalDisplay.get(), *display);
             } else {
-                if (FlagManager::getInstance().correct_virtual_display_power_state()) {
-                    applyOptimizationPolicy("setPhysicalDisplayPowerMode(OFF)");
-                } else {
-                    enablePowerOptimizations("setPhysicalDisplayPowerMode(OFF)");
+                if (!shouldApplyOptimizationPolicy) {
+                    optimizeThreadScheduling("setPhysicalDisplayPowerMode(OFF)",
+                                             OptimizationPolicy::optimizeForPower);
                 }
 
-                if (currentModeNotDozeSuspend) {
+                if (currentModeNotDozeSuspend && !shouldApplyOptimizationPolicy) {
                     mScheduler->enableSyntheticVsync();
                 }
             }
@@ -5753,11 +5866,13 @@ void SurfaceFlinger::setPhysicalDisplayPowerMode(const sp<DisplayDevice>& displa
         // Update display while dozing
         getHwComposer().setPowerMode(displayId, mode);
         if (currentMode == hal::PowerMode::DOZE_SUSPEND) {
-            if (displayId == mActiveDisplayId) {
+            if (displayId == mFrontInternalDisplayId) {
                 ALOGI("Force repainting for DOZE_SUSPEND -> DOZE or ON.");
                 mVisibleRegionsDirty = true;
                 scheduleRepaint();
-                mScheduler->enableSyntheticVsync(false);
+                if (!shouldApplyOptimizationPolicy) {
+                    mScheduler->enableSyntheticVsync(false);
+                }
             }
             constexpr bool kAllowToEnable = true;
             mScheduler->resyncToHardwareVsync(displayId, kAllowToEnable, activeMode.get());
@@ -5767,7 +5882,7 @@ void SurfaceFlinger::setPhysicalDisplayPowerMode(const sp<DisplayDevice>& displa
         constexpr bool kDisallow = true;
         mScheduler->disableHardwareVsync(displayId, kDisallow);
 
-        if (displayId == mActiveDisplayId) {
+        if (displayId == mFrontInternalDisplayId && !shouldApplyOptimizationPolicy) {
             mScheduler->enableSyntheticVsync();
         }
         getHwComposer().setPowerMode(displayId, mode);
@@ -5776,12 +5891,26 @@ void SurfaceFlinger::setPhysicalDisplayPowerMode(const sp<DisplayDevice>& displa
         getHwComposer().setPowerMode(displayId, mode);
     }
 
-    if (displayId == mActiveDisplayId) {
+    if (displayId == mFrontInternalDisplayId) {
         mTimeStats->setPowerMode(mode);
         mScheduler->setActiveDisplayPowerModeForRefreshRateStats(mode);
     }
 
     mScheduler->setDisplayPowerMode(displayId, mode);
+    if (FlagManager::getInstance().pacesetter_selection() &&
+        mScheduler->getPacesetterDisplayId() != mFrontInternalDisplayId) {
+        // TODO: b/389983418 - Update pacesetter designation inside
+        // Scheduler::setDisplayPowerMode().
+        mScheduler->setPacesetterDisplay(mFrontInternalDisplayId);
+
+        // Whether or not the policy of the new pacesetter display changed while it was powered off
+        // (in which case its preferred mode has already been propagated to HWC via setDesiredMode),
+        // the Scheduler's emittedModeOpt must be initialized to the newly active mode, and the
+        // kernel idle timer of the pacesetter display must be toggled.
+        const auto pacesetter = getPacesetterDisplayLocked();
+        applyRefreshRateSelectorPolicy(pacesetter->getPhysicalId(),
+                                       pacesetter->refreshRateSelector());
+    }
 
     ALOGD("Finished setting power mode %d on physical display %s", mode,
           to_string(displayId).c_str());
@@ -5806,43 +5935,44 @@ void SurfaceFlinger::setVirtualDisplayPowerMode(const sp<DisplayDevice>& display
           to_string(displayId).c_str());
 }
 
-bool SurfaceFlinger::shouldOptimizeForPerformance() {
-    for (const auto& [_, display] : mDisplays) {
-        // Displays that are optimized for power are always powered on and should not influence
-        // whether there is an active display for the purpose of power optimization, etc. If these
-        // displays are being shown somewhere, a different (physical or virtual) display that is
-        // optimized for performance will be powered on in addition. Displays optimized for
-        // performance will change power mode, so if they are off then they are not active.
-        if (display->isPoweredOn() &&
-            display->getOptimizationPolicy() ==
-                    gui::ISurfaceComposer::OptimizationPolicy::optimizeForPerformance) {
-            return true;
-        }
-    }
-    return false;
-}
-
-void SurfaceFlinger::enablePowerOptimizations(const char* whence) {
-    ALOGD("%s: Enabling power optimizations", whence);
-
-    setSchedAttr(false, whence);
-    setSchedFifo(false, whence);
-}
-
-void SurfaceFlinger::disablePowerOptimizations(const char* whence) {
-    ALOGD("%s: Disabling power optimizations", whence);
+void SurfaceFlinger::optimizeThreadScheduling(
+        const char* whence, gui::ISurfaceComposer::OptimizationPolicy optimizationPolicy) {
+    ALOGD("%s: Optimizing thread scheduling: %s", whence, to_string(optimizationPolicy));
 
+    const bool optimizeForPerformance =
+            optimizationPolicy == gui::ISurfaceComposer::OptimizationPolicy::optimizeForPerformance;
     // TODO: b/281692563 - Merge the syscalls. For now, keep uclamp in a separate syscall
     // and set it before SCHED_FIFO due to b/190237315.
-    setSchedAttr(true, whence);
-    setSchedFifo(true, whence);
+    setSchedAttr(optimizeForPerformance, whence);
+    setSchedFifo(optimizeForPerformance, whence);
 }
 
 void SurfaceFlinger::applyOptimizationPolicy(const char* whence) {
-    if (shouldOptimizeForPerformance()) {
-        disablePowerOptimizations(whence);
-    } else {
-        enablePowerOptimizations(whence);
+    using OptimizationPolicy = gui::ISurfaceComposer::OptimizationPolicy;
+
+    const bool optimizeForPerformance =
+            std::any_of(mDisplays.begin(), mDisplays.end(), [](const auto& pair) {
+                const auto& display = pair.second;
+                return display->isPoweredOn() &&
+                        display->getOptimizationPolicy() ==
+                        OptimizationPolicy::optimizeForPerformance;
+            });
+
+    optimizeThreadScheduling(whence,
+                             optimizeForPerformance ? OptimizationPolicy::optimizeForPerformance
+                                                    : OptimizationPolicy::optimizeForPower);
+
+    if (mScheduler) {
+        const bool disableSyntheticVsync =
+                std::any_of(mDisplays.begin(), mDisplays.end(), [](const auto& pair) {
+                    const auto& display = pair.second;
+                    const hal::PowerMode powerMode = display->getPowerMode();
+                    return powerMode != hal::PowerMode::OFF &&
+                            powerMode != hal::PowerMode::DOZE_SUSPEND &&
+                            display->getOptimizationPolicy() ==
+                            OptimizationPolicy::optimizeForPerformance;
+                });
+        mScheduler->enableSyntheticVsync(!disableSyntheticVsync);
     }
 }
 
@@ -6095,8 +6225,10 @@ void SurfaceFlinger::dumpDisplayIdentificationData(std::string& result) const {
                       *hwcDisplayId);
 
         uint8_t port;
-        DisplayIdentificationData data;
-        if (!getHwComposer().getDisplayIdentificationData(*hwcDisplayId, &port, &data)) {
+        display::DisplayIdentificationData data;
+        android::ScreenPartStatus screenPartStatus;
+        if (!getHwComposer().getDisplayIdentificationData(*hwcDisplayId, &port, &data,
+                                                          &screenPartStatus)) {
             result.append("no display identification data\n");
             continue;
         }
@@ -6106,18 +6238,19 @@ void SurfaceFlinger::dumpDisplayIdentificationData(std::string& result) const {
             continue;
         }
 
-        if (!isEdid(data)) {
+        if (!display::isEdid(data)) {
             result.append("unknown format for display identification data\n");
             continue;
         }
 
-        const auto edid = parseEdid(data);
+        const auto edid = display::parseEdid(data);
         if (!edid) {
             result.append("invalid EDID\n");
             continue;
         }
 
-        StringAppendF(&result, "port=%u pnpId=%s displayName=\"", port, edid->pnpId.data());
+        StringAppendF(&result, "port=%u pnpId=%s screenPartStatus=%s displayName=\"", port,
+                      edid->pnpId.data(), ftl::enum_string(screenPartStatus).c_str());
         result.append(edid->displayName.data(), edid->displayName.length());
         result.append("\"\n");
     }
@@ -6140,10 +6273,12 @@ void SurfaceFlinger::dumpRawDisplayIdentificationData(const DumpArgs& args,
                                                       std::string& result) const {
     hal::HWDisplayId hwcDisplayId;
     uint8_t port;
-    DisplayIdentificationData data;
+    display::DisplayIdentificationData data;
+    android::ScreenPartStatus screenPartStatus;
 
     if (args.size() > 1 && base::ParseUint(String8(args[1]), &hwcDisplayId) &&
-        getHwComposer().getDisplayIdentificationData(hwcDisplayId, &port, &data)) {
+        getHwComposer().getDisplayIdentificationData(hwcDisplayId, &port, &data,
+                                                     &screenPartStatus)) {
         result.append(reinterpret_cast<const char*>(data.data()), data.size());
     }
 }
@@ -6182,7 +6317,7 @@ void SurfaceFlinger::dumpHdrInfo(std::string& result) const {
 void SurfaceFlinger::dumpFrontEnd(std::string& result) {
     std::ostringstream out;
     out << "\nComposition list (bottom to top)\n";
-    ui::LayerStack lastPrintedLayerStackHeader = ui::INVALID_LAYER_STACK;
+    ui::LayerStack lastPrintedLayerStackHeader = ui::UNASSIGNED_LAYER_STACK;
     for (const auto& snapshot : mLayerSnapshotBuilder.getSnapshots()) {
         if (lastPrintedLayerStackHeader != snapshot->outputFilter.layerStack) {
             lastPrintedLayerStackHeader = snapshot->outputFilter.layerStack;
@@ -6192,7 +6327,7 @@ void SurfaceFlinger::dumpFrontEnd(std::string& result) {
     }
 
     out << "\nInput list\n";
-    lastPrintedLayerStackHeader = ui::INVALID_LAYER_STACK;
+    lastPrintedLayerStackHeader = ui::UNASSIGNED_LAYER_STACK;
     mLayerSnapshotBuilder.forEachInputSnapshot([&](const frontend::LayerSnapshot& snapshot) {
         if (lastPrintedLayerStackHeader != snapshot.outputFilter.layerStack) {
             lastPrintedLayerStackHeader = snapshot.outputFilter.layerStack;
@@ -6210,7 +6345,7 @@ void SurfaceFlinger::dumpFrontEnd(std::string& result) {
 void SurfaceFlinger::dumpVisibleFrontEnd(std::string& result) {
     std::ostringstream out;
     out << "\nComposition list (bottom to top)\n";
-    ui::LayerStack lastPrintedLayerStackHeader = ui::INVALID_LAYER_STACK;
+    ui::LayerStack lastPrintedLayerStackHeader = ui::UNASSIGNED_LAYER_STACK;
     mLayerSnapshotBuilder.forEachVisibleSnapshot(
             [&](std::unique_ptr<frontend::LayerSnapshot>& snapshot) {
                 if (snapshot->hasSomethingToDraw()) {
@@ -6223,7 +6358,7 @@ void SurfaceFlinger::dumpVisibleFrontEnd(std::string& result) {
             });
 
     out << "\nInput list\n";
-    lastPrintedLayerStackHeader = ui::INVALID_LAYER_STACK;
+    lastPrintedLayerStackHeader = ui::UNASSIGNED_LAYER_STACK;
     mLayerSnapshotBuilder.forEachInputSnapshot([&](const frontend::LayerSnapshot& snapshot) {
         if (lastPrintedLayerStackHeader != snapshot.outputFilter.layerStack) {
             lastPrintedLayerStackHeader = snapshot.outputFilter.layerStack;
@@ -6309,8 +6444,7 @@ void SurfaceFlinger::dumpHwcLayersMinidump(std::string& result) const {
             continue;
         }
 
-        StringAppendF(&result, "Display %s (%s) HWC layers:\n", to_string(*displayId).c_str(),
-                      displayId == mActiveDisplayId ? "active" : "inactive");
+        StringAppendF(&result, "Display %s HWC layers:\n", to_string(*displayId).c_str());
         Layer::miniDumpHeader(result);
 
         const DisplayDevice& ref = *display;
@@ -6382,7 +6516,6 @@ void SurfaceFlinger::dumpAll(const DumpArgs& args, const std::string& compositio
      * Dump the visible layer list
      */
     colorizer.bold(result);
-    StringAppendF(&result, "SurfaceFlinger New Frontend Enabled:%s\n", "true");
     StringAppendF(&result, "Active Layers - layers with client handles (count = %zu)\n",
                   mNumLayers.load());
     colorizer.reset(result);
@@ -6412,7 +6545,7 @@ void SurfaceFlinger::dumpAll(const DumpArgs& args, const std::string& compositio
     ClientCache::getInstance().dump(result);
     DebugEGLImageTracker::getInstance()->dump(result);
 
-    if (const auto display = getDefaultDisplayDeviceLocked()) {
+    if (const auto display = getFrontInternalDisplayLocked()) {
         display->getCompositionDisplay()->getState().undefinedRegion.dump(result,
                                                                           "undefinedRegion");
         StringAppendF(&result, "  orientation=%s, isPoweredOn=%d\n",
@@ -6420,7 +6553,7 @@ void SurfaceFlinger::dumpAll(const DumpArgs& args, const std::string& compositio
     }
     StringAppendF(&result, "  transaction-flags         : %08x\n", mTransactionFlags.load());
 
-    if (const auto display = getDefaultDisplayDeviceLocked()) {
+    if (const auto display = getFrontInternalDisplayLocked()) {
         std::string peakFps, xDpi, yDpi;
         const auto activeMode = display->refreshRateSelector().getActiveMode();
         if (const auto activeModePtr = activeMode.modePtr.get()) {
@@ -6793,7 +6926,7 @@ status_t SurfaceFlinger::onTransact(uint32_t code, const Parcel& data, Parcel* r
             }
             // Is a DisplayColorSetting supported?
             case 1027: {
-                const auto display = getDefaultDisplayDevice();
+                const auto display = getFrontInternalDisplay();
                 if (!display) {
                     return NAME_NOT_FOUND;
                 }
@@ -6876,7 +7009,7 @@ status_t SurfaceFlinger::onTransact(uint32_t code, const Parcel& data, Parcel* r
             case 1035: {
                 // Parameters:
                 // - (required) i32 mode id.
-                // - (optional) i64 display id. Using default display if not provided.
+                // - (optional) i64 display id. Using pacesetter display if not provided.
                 // - (optional) f min render rate. Using mode's fps is not provided.
                 // - (optional) f max render rate. Using mode's fps is not provided.
 
@@ -6885,7 +7018,7 @@ status_t SurfaceFlinger::onTransact(uint32_t code, const Parcel& data, Parcel* r
                 const auto display = [&]() -> sp<IBinder> {
                     uint64_t value;
                     if (data.readUint64(&value) != NO_ERROR) {
-                        return getDefaultDisplayDevice()->getDisplayToken().promote();
+                        return getPacesetterDisplay()->getDisplayToken().promote();
                     }
 
                     if (const auto token =
@@ -6923,7 +7056,7 @@ status_t SurfaceFlinger::onTransact(uint32_t code, const Parcel& data, Parcel* r
                     return mScheduler
                             ->schedule([this]() FTL_FAKE_GUARD(kMainThreadContext) {
                                 const auto display =
-                                        FTL_FAKE_GUARD(mStateLock, getDefaultDisplayDeviceLocked());
+                                        FTL_FAKE_GUARD(mStateLock, getPacesetterDisplayLocked());
 
                                 // This is a little racy, but not in a way that hurts anything. As
                                 // we grab the defaultMode from the display manager policy, we could
@@ -6943,7 +7076,7 @@ status_t SurfaceFlinger::onTransact(uint32_t code, const Parcel& data, Parcel* r
                     return mScheduler
                             ->schedule([this]() FTL_FAKE_GUARD(kMainThreadContext) {
                                 const auto display =
-                                        FTL_FAKE_GUARD(mStateLock, getDefaultDisplayDeviceLocked());
+                                        FTL_FAKE_GUARD(mStateLock, getPacesetterDisplayLocked());
                                 return setDesiredDisplayModeSpecsInternal(
                                         display,
                                         scheduler::RefreshRateSelector::NoOverridePolicy{});
@@ -6982,28 +7115,15 @@ status_t SurfaceFlinger::onTransact(uint32_t code, const Parcel& data, Parcel* r
                 return NO_ERROR;
             }
             // Toggle caching feature
-            // First argument is an int32 - nonzero enables caching and zero disables caching
-            // Second argument is an optional uint64 - if present, then limits enabling/disabling
-            // caching to a particular physical display
+            // First argument is an int32 - nonzero enables caching and zero disables caching for
+            // all displays
             case 1040: {
                 auto future = mScheduler->schedule([&] {
                     n = data.readInt32();
-                    PhysicalDisplayId inputId;
-                    if (uint64_t inputDisplayId; data.readUint64(&inputDisplayId) == NO_ERROR) {
-                        inputId = PhysicalDisplayId::fromValue(inputDisplayId);
-                        if (!getPhysicalDisplayToken(inputId)) {
-                            ALOGE("No display with id: %" PRIu64, inputDisplayId);
-                            return NAME_NOT_FOUND;
-                        }
-                    }
-                    {
-                        Mutex::Autolock lock(mStateLock);
-                        mLayerCachingEnabled = n != 0;
-                        for (const auto& [_, display] : mDisplays) {
-                            if (inputId == display->getPhysicalId()) {
-                                display->enableLayerCaching(mLayerCachingEnabled);
-                            }
-                        }
+                    Mutex::Autolock lock(mStateLock);
+                    mLayerCachingEnabled = n != 0;
+                    for (const auto& [_, display] : mDisplays) {
+                        display->enableLayerCaching(mLayerCachingEnabled);
                     }
                     return OK;
                 });
@@ -7183,9 +7303,8 @@ status_t SurfaceFlinger::onTransact(uint32_t code, const Parcel& data, Parcel* r
                     data.readInt64(&appDurationNs) != NO_ERROR) {
                     return BAD_VALUE;
                 }
-                mScheduler->reloadPhaseConfiguration(mDisplayModeController
-                                                             .getActiveMode(mActiveDisplayId)
-                                                             .fps,
+                mScheduler->reloadPhaseConfiguration(mDisplayModeController.getActiveMode(
+                                                             mFrontInternalDisplayId),
                                                      Duration::fromNs(minSfNs),
                                                      Duration::fromNs(maxSfNs),
                                                      Duration::fromNs(appDurationNs));
@@ -7204,7 +7323,7 @@ void SurfaceFlinger::kernelTimerChanged(bool expired) {
     // Update the overlay on the main thread to avoid race conditions with
     // RefreshRateSelector::getActiveMode
     static_cast<void>(mScheduler->schedule([=, this]() FTL_FAKE_GUARD(kMainThreadContext) {
-        const auto display = FTL_FAKE_GUARD(mStateLock, getDefaultDisplayDeviceLocked());
+        const auto display = FTL_FAKE_GUARD(mStateLock, getPacesetterDisplayLocked());
         if (!display) {
             ALOGW("%s: default display is null", __func__);
             return;
@@ -7219,22 +7338,25 @@ void SurfaceFlinger::kernelTimerChanged(bool expired) {
     }));
 }
 
-void SurfaceFlinger::vrrDisplayIdle(bool idle) {
+void SurfaceFlinger::vrrDisplayIdle(PhysicalDisplayId displayId, bool idle) {
     // Update the overlay on the main thread to avoid race conditions with
     // RefreshRateSelector::getActiveMode
     static_cast<void>(mScheduler->schedule([=, this] {
-        const auto display = FTL_FAKE_GUARD(mStateLock, getDefaultDisplayDeviceLocked());
-        if (!display) {
-            ALOGW("%s: default display is null", __func__);
-            return;
+        if (const auto display = FTL_FAKE_GUARD(mStateLock, getDisplayDeviceLocked(displayId))) {
+            if (display->isRefreshRateOverlayEnabled()) {
+                display->onVrrIdle(idle);
+                mScheduler->scheduleFrame();
+            }
         }
-        if (!display->isRefreshRateOverlayEnabled()) return;
-
-        display->onVrrIdle(idle);
-        mScheduler->scheduleFrame();
     }));
 }
 
+void SurfaceFlinger::enableLayerCachingTexturePool(PhysicalDisplayId displayId, bool enable) {
+    if (const auto display = FTL_FAKE_GUARD(mStateLock, getDisplayDeviceLocked(displayId))) {
+        display->getCompositionDisplay()->setLayerCachingTexturePoolEnabled(enable);
+    }
+}
+
 auto SurfaceFlinger::getKernelIdleTimerProperties(PhysicalDisplayId displayId)
         -> std::pair<std::optional<KernelIdleTimerController>, std::chrono::milliseconds> {
     const bool isKernelIdleTimerHwcSupported = getHwComposer().getComposer()->isSupported(
@@ -7364,15 +7486,25 @@ ui::Dataspace pickBestDataspace(ui::Dataspace requestedDataspace, ui::ColorMode
     return dataspaceForColorMode;
 }
 
-} // namespace
-
-static void invokeScreenCaptureError(const status_t status,
-                                     const sp<IScreenCaptureListener>& captureListener) {
-    ScreenCaptureResults captureResults;
-    captureResults.fenceResult = base::unexpected(status);
-    captureListener->onScreenCaptureCompleted(captureResults);
+// Scans through layer handles to provide a list of layer IDs that should be
+// excluded from a screenshot, or std::nullopt if any layer handle does not
+// correspond to a valid layer ID.
+static base::expected<std::unordered_set<uint32_t>, status_t> getExcludeLayerIds(
+        const std::vector<::android::sp<::android::IBinder>>& excludeHandles) {
+    std::unordered_set<uint32_t> excludeLayerIds;
+    for (const auto& handle : excludeHandles) {
+        uint32_t excludeLayer = LayerHandle::getLayerId(handle);
+        if (excludeLayer != UNASSIGNED_LAYER_ID) {
+            excludeLayerIds.emplace(excludeLayer);
+        } else {
+            return base::unexpected(NAME_NOT_FOUND);
+        }
+    }
+    return excludeLayerIds;
 }
 
+} // namespace
+
 void SurfaceFlinger::captureDisplay(const DisplayCaptureArgs& args,
                                     const sp<IScreenCaptureListener>& captureListener) {
     SFTRACE_CALL();
@@ -7397,130 +7529,53 @@ void SurfaceFlinger::captureDisplay(const DisplayCaptureArgs& args,
         return;
     }
 
-    wp<const DisplayDevice> displayWeak;
-    ftl::Optional<DisplayIdVariant> displayIdVariantOpt;
-    ui::LayerStack layerStack;
-    ui::Size reqSize(args.width, args.height);
-    std::unordered_set<uint32_t> excludeLayerIds;
-    Rect layerStackSpaceRect;
-    bool displayIsSecure;
-
-    {
-        Mutex::Autolock lock(mStateLock);
-        sp<DisplayDevice> display = getDisplayDeviceLocked(args.displayToken);
-        if (!display) {
-            ALOGD("Unable to find display device for captureDisplay");
-            invokeScreenCaptureError(NAME_NOT_FOUND, captureListener);
-            return;
-        }
-        displayWeak = display;
-        displayIdVariantOpt = display->getDisplayIdVariant();
-        layerStack = display->getLayerStack();
-        displayIsSecure = display->isSecure();
-
-        layerStackSpaceRect = display->getLayerStackSpaceRect();
-        // set the requested width/height to the logical display layer stack rect size by default
-        if (args.width == 0 || args.height == 0) {
-            reqSize = layerStackSpaceRect.getSize();
-        }
-
-        for (const auto& handle : captureArgs.excludeHandles) {
-            uint32_t excludeLayer = LayerHandle::getLayerId(handle);
-            if (excludeLayer != UNASSIGNED_LAYER_ID) {
-                excludeLayerIds.emplace(excludeLayer);
-            } else {
-                ALOGD("Invalid layer handle passed as excludeLayer to captureDisplay");
-                invokeScreenCaptureError(NAME_NOT_FOUND, captureListener);
-                return;
-            }
-        }
-    }
-
-    GetLayerSnapshotsFunction getLayerSnapshotsFn =
-            getLayerSnapshotsForScreenshots(layerStack, captureArgs.uid,
-                                            std::move(excludeLayerIds));
-
-    ScreenshotArgs screenshotArgs;
-    screenshotArgs.captureTypeVariant = displayWeak;
-    screenshotArgs.displayIdVariant = displayIdVariantOpt;
-    screenshotArgs.sourceCrop = gui::aidl_utils::fromARect(captureArgs.sourceCrop);
-    if (screenshotArgs.sourceCrop.isEmpty()) {
-        screenshotArgs.sourceCrop = layerStackSpaceRect;
+    auto excludeLayerIds = getExcludeLayerIds(captureArgs.excludeHandles);
+    if (!excludeLayerIds) {
+        ALOGD("Invalid layer handle passed as excludeLayer to captureDisplay");
+        invokeScreenCaptureError(excludeLayerIds.error(), captureListener);
+        return;
     }
-    screenshotArgs.reqSize = reqSize;
-    screenshotArgs.dataspace = static_cast<ui::Dataspace>(captureArgs.dataspace);
-    screenshotArgs.isSecure = captureArgs.captureSecureLayers && displayIsSecure;
-    screenshotArgs.seamlessTransition = captureArgs.hintForSeamlessTransition;
 
-    captureScreenCommon(screenshotArgs, getLayerSnapshotsFn, reqSize,
-                        static_cast<ui::PixelFormat>(captureArgs.pixelFormat),
-                        captureArgs.allowProtected, captureArgs.grayscale, captureListener);
+    ScreenshotArgs screenshotArgs{.captureTypeVariant = args.displayToken,
+                                  .snapshotRequest =
+                                          SnapshotRequestArgs{.uid = gui::Uid{static_cast<uid_t>(
+                                                                      captureArgs.uid)},
+                                                              .excludeLayerIds =
+                                                                      excludeLayerIds.value()},
+                                  .sourceCrop = gui::aidl_utils::fromARect(captureArgs.sourceCrop),
+                                  .size = ui::Size(args.width, args.height),
+                                  .dataspace = static_cast<ui::Dataspace>(captureArgs.dataspace),
+                                  .disableBlur = false,
+                                  .isGrayscale = captureArgs.grayscale,
+                                  .isSecure = captureArgs.captureSecureLayers,
+                                  .includeProtected = captureArgs.allowProtected,
+                                  .seamlessTransition = captureArgs.hintForSeamlessTransition,
+                                  .debugName = "ScreenCapture"};
+
+    captureScreenCommon(screenshotArgs, static_cast<ui::PixelFormat>(captureArgs.pixelFormat),
+                        captureListener);
 }
 
 void SurfaceFlinger::captureDisplay(DisplayId displayId, const CaptureArgs& args,
                                     const sp<IScreenCaptureListener>& captureListener) {
-    ui::LayerStack layerStack;
-    wp<const DisplayDevice> displayWeak;
-    ftl::Optional<DisplayIdVariant> displayIdVariantOpt;
-    ui::Size size;
-    Rect layerStackSpaceRect;
-    bool displayIsSecure;
-
-    {
-        Mutex::Autolock lock(mStateLock);
-
-        const auto display = getDisplayDeviceLocked(displayId);
-        if (!display) {
-            ALOGD("Unable to find display device for captureDisplay");
-            invokeScreenCaptureError(NAME_NOT_FOUND, captureListener);
-            return;
-        }
-
-        displayWeak = display;
-        displayIdVariantOpt = display->getDisplayIdVariant();
-        layerStack = display->getLayerStack();
-        layerStackSpaceRect = display->getLayerStackSpaceRect();
-        size = display->getLayerStackSpaceRect().getSize();
-        displayIsSecure = display->isSecure();
-    }
-
-    size.width *= args.frameScaleX;
-    size.height *= args.frameScaleY;
-
-    // We could query a real value for this but it'll be a long, long time until we support
-    // displays that need upwards of 1GB per buffer so...
-    constexpr auto kMaxTextureSize = 16384;
-    if (size.width <= 0 || size.height <= 0 || size.width >= kMaxTextureSize ||
-        size.height >= kMaxTextureSize) {
-        ALOGD("captureDisplay resolved to invalid size %d x %d", size.width, size.height);
-        invokeScreenCaptureError(BAD_VALUE, captureListener);
-        return;
-    }
-
-    GetLayerSnapshotsFunction getLayerSnapshotsFn =
-            getLayerSnapshotsForScreenshots(layerStack, CaptureArgs::UNSET_UID,
-                                            /*snapshotFilterFn=*/nullptr);
-
     if (captureListener == nullptr) {
         ALOGE("capture screen must provide a capture listener callback");
         invokeScreenCaptureError(BAD_VALUE, captureListener);
         return;
     }
 
-    constexpr bool kAllowProtected = false;
-    constexpr bool kGrayscale = false;
-
-    ScreenshotArgs screenshotArgs;
-    screenshotArgs.captureTypeVariant = displayWeak;
-    screenshotArgs.displayIdVariant = displayIdVariantOpt;
-    screenshotArgs.sourceCrop = layerStackSpaceRect;
-    screenshotArgs.reqSize = size;
-    screenshotArgs.dataspace = static_cast<ui::Dataspace>(args.dataspace);
-    screenshotArgs.isSecure = args.captureSecureLayers && displayIsSecure;
-    screenshotArgs.seamlessTransition = args.hintForSeamlessTransition;
+    ScreenshotArgs screenshotArgs{.captureTypeVariant = displayId,
+                                  .snapshotRequest = SnapshotRequestArgs{.uid = gui::Uid::INVALID},
+                                  .size = ui::Size(args.frameScaleX, args.frameScaleY),
+                                  .dataspace = static_cast<ui::Dataspace>(args.dataspace),
+                                  .disableBlur = false,
+                                  .isGrayscale = false,
+                                  .isSecure = args.captureSecureLayers,
+                                  .includeProtected = false,
+                                  .seamlessTransition = args.hintForSeamlessTransition,
+                                  .debugName = "ScreenCapture"};
 
-    captureScreenCommon(screenshotArgs, getLayerSnapshotsFn, size,
-                        static_cast<ui::PixelFormat>(args.pixelFormat), kAllowProtected, kGrayscale,
+    captureScreenCommon(screenshotArgs, static_cast<ui::PixelFormat>(args.pixelFormat),
                         captureListener);
 }
 
@@ -7547,7 +7602,6 @@ void SurfaceFlinger::captureLayers(const LayerCaptureArgs& args,
 
     ui::Size reqSize;
     sp<Layer> parent;
-    std::unordered_set<uint32_t> excludeLayerIds;
     ui::Dataspace dataspace = static_cast<ui::Dataspace>(captureArgs.dataspace);
 
     if (captureArgs.captureSecureLayers && !hasCaptureBlackoutContentPermission()) {
@@ -7586,18 +7640,13 @@ void SurfaceFlinger::captureLayers(const LayerCaptureArgs& args,
         }
         reqSize = ui::Size(crop.width() * captureArgs.frameScaleX,
                            crop.height() * captureArgs.frameScaleY);
-
-        for (const auto& handle : captureArgs.excludeHandles) {
-            uint32_t excludeLayer = LayerHandle::getLayerId(handle);
-            if (excludeLayer != UNASSIGNED_LAYER_ID) {
-                excludeLayerIds.emplace(excludeLayer);
-            } else {
-                ALOGD("Invalid layer handle passed as excludeLayer to captureLayers");
-                invokeScreenCaptureError(NAME_NOT_FOUND, captureListener);
-                return;
-            }
-        }
     } // mStateLock
+    auto excludeLayerIds = getExcludeLayerIds(captureArgs.excludeHandles);
+    if (!excludeLayerIds) {
+        ALOGD("Invalid layer handle passed as excludeLayer to captureLayers");
+        invokeScreenCaptureError(excludeLayerIds.error(), captureListener);
+        return;
+    }
 
     // really small crop or frameScale
     if (reqSize.width <= 0 || reqSize.height <= 0) {
@@ -7612,29 +7661,33 @@ void SurfaceFlinger::captureLayers(const LayerCaptureArgs& args,
                                     : crop.toFloatRect();
     }
 
-    GetLayerSnapshotsFunction getLayerSnapshotsFn =
-            getLayerSnapshotsForScreenshots(parent->sequence, captureArgs.uid,
-                                            std::move(excludeLayerIds), args.childrenOnly,
-                                            parentCrop);
-
     if (captureListener == nullptr) {
         ALOGD("capture screen must provide a capture listener callback");
         invokeScreenCaptureError(BAD_VALUE, captureListener);
         return;
     }
 
-    ScreenshotArgs screenshotArgs;
-    screenshotArgs.captureTypeVariant = parent->getSequence();
-    screenshotArgs.childrenOnly = args.childrenOnly;
-    screenshotArgs.sourceCrop = crop;
-    screenshotArgs.reqSize = reqSize;
-    screenshotArgs.dataspace = static_cast<ui::Dataspace>(captureArgs.dataspace);
-    screenshotArgs.isSecure = captureArgs.captureSecureLayers;
-    screenshotArgs.seamlessTransition = captureArgs.hintForSeamlessTransition;
-
-    captureScreenCommon(screenshotArgs, getLayerSnapshotsFn, reqSize,
-                        static_cast<ui::PixelFormat>(captureArgs.pixelFormat),
-                        captureArgs.allowProtected, captureArgs.grayscale, captureListener);
+    ScreenshotArgs screenshotArgs{.captureTypeVariant = parent->getSequence(),
+                                  .snapshotRequest =
+                                          SnapshotRequestArgs{.uid = gui::Uid{static_cast<uid_t>(
+                                                                      captureArgs.uid)},
+                                                              .rootLayerId = parent->getSequence(),
+                                                              .excludeLayerIds =
+                                                                      excludeLayerIds.value(),
+                                                              .childrenOnly = args.childrenOnly,
+                                                              .parentCrop = parentCrop},
+                                  .sourceCrop = crop,
+                                  .size = reqSize,
+                                  .dataspace = static_cast<ui::Dataspace>(captureArgs.dataspace),
+                                  .disableBlur = false,
+                                  .isGrayscale = captureArgs.grayscale,
+                                  .isSecure = captureArgs.captureSecureLayers,
+                                  .includeProtected = captureArgs.allowProtected,
+                                  .seamlessTransition = captureArgs.hintForSeamlessTransition,
+                                  .debugName = "ScreenCapture"};
+
+    captureScreenCommon(screenshotArgs, static_cast<ui::PixelFormat>(captureArgs.pixelFormat),
+                        captureListener);
 }
 
 // Creates a Future release fence for a layer and keeps track of it in a list to
@@ -7666,69 +7719,123 @@ bool SurfaceFlinger::layersHasProtectedLayer(
 // Getting layer snapshots and accessing display state should take place on
 // main thread. Accessing display requires mStateLock, and contention for
 // this lock is reduced when grabbed from the main thread, thus also reducing
-// risk of deadlocks. Returns false if no display is found.
-bool SurfaceFlinger::getSnapshotsFromMainThread(
-        ScreenshotArgs& args, GetLayerSnapshotsFunction getLayerSnapshotsFn,
-        std::vector<std::pair<Layer*, sp<LayerFE>>>& layers) {
+// risk of deadlocks. Returns an error status if no display is found.
+base::expected<SurfaceFlinger::ScreenshotStrategy, status_t>
+SurfaceFlinger::setScreenshotSnapshotsAndDisplayState(ScreenshotArgs& args) {
     return mScheduler
-            ->schedule([=, this, &args, &layers]() REQUIRES(kMainThreadContext) {
+            ->schedule([=, this, &args]() REQUIRES(kMainThreadContext)
+                               -> base::expected<SurfaceFlinger::ScreenshotStrategy, status_t> {
                 SFTRACE_NAME_FOR_TRACK(WorkloadTracer::TRACK_NAME, "Screenshot");
                 mPowerAdvisor->setScreenshotWorkload();
-                SFTRACE_NAME("getSnapshotsFromMainThread");
-                layers = getLayerSnapshotsFn();
+                SFTRACE_NAME("setScreenshotSnapshotsAndDisplayState");
+                status_t status = setScreenshotDisplayState(args);
+                if (status != OK) {
+                    return base::unexpected<status_t>(status);
+                }
+
+                bool capturingDisplay =
+                        std::holds_alternative<DisplayId>(args.captureTypeVariant) ||
+                        std::holds_alternative<sp<IBinder>>(args.captureTypeVariant);
+
+                bool canDpuReadback = FlagManager::getInstance().readback_screenshot() &&
+                        // The device needs to explicitly opt-in, in addition to the trunk stable
+                        // flag being flipped.
+                        FlagManager::getInstance().productionize_readback_screenshot() &&
+                        capturingDisplay && args.snapshotRequest.excludeLayerIds.empty() &&
+                        !args.disableBlur && !args.isGrayscale &&
+                        args.dataspace == ui::Dataspace::UNKNOWN;
+
+                // TODO: we need to check for a uniform transform too. I.e., no screen rotation, no
+                // scaling, etc.
+                if (canDpuReadback) {
+                    auto displayId = *args.displayIdVariant;
+                    if (std::holds_alternative<PhysicalDisplayId>(displayId)) {
+                        aidl::android::hardware::graphics::composer3::ReadbackBufferAttributes
+                                attributes;
+                        auto status =
+                                getHwComposer().getReadbackBufferAttributes(*asPhysicalDisplayId(
+                                                                                    displayId),
+                                                                            &attributes);
+                        if (status == OK) {
+                            const uint32_t usage = GRALLOC_USAGE_HW_COMPOSER |
+                                    GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_SW_READ_OFTEN |
+                                    GRALLOC_USAGE_SW_WRITE_OFTEN;
+                            const auto readbackBuffer =
+                                    getFactory()
+                                            .createGraphicBuffer(args.size.getWidth(),
+                                                                 args.size.getHeight(),
+                                                                 static_cast<android_pixel_format>(
+                                                                         attributes.format),
+                                                                 1 /* layerCount */, usage,
+                                                                 "screenshot");
+                            mReadbackRequests.emplace_back(*asPhysicalDisplayId(displayId),
+                                                           readbackBuffer, args.captureListener,
+                                                           args.seamlessTransition, args.isSecure);
+                            scheduleComposite(FrameHint::kNone);
+                            return ScreenshotStrategy::Readback;
+                        }
+                    }
+                }
+
+                args.layers = getLayerSnapshotsForScreenshots(args.snapshotRequest);
+
                 // Non-threaded RenderEngine eventually returns to the main thread a 2nd time
                 // to complete the screenshot. Release fences should only be added during the 2nd
                 // hop to main thread in order to avoid potential deadlocks from waiting for the
                 // the future fence to fire.
                 if (mRenderEngine->isThreaded()) {
-                    for (auto& [layer, layerFE] : layers) {
+                    for (auto& [layer, layerFE] : args.layers) {
                         attachReleaseFenceFutureToLayer(layer, layerFE.get(),
-                                                        ui::INVALID_LAYER_STACK);
+                                                        ui::UNASSIGNED_LAYER_STACK);
                     }
                 }
-                return getDisplayStateOnMainThread(args);
+
+                return ScreenshotStrategy::Gpu;
             })
             .get();
 }
 
-void SurfaceFlinger::captureScreenCommon(ScreenshotArgs& args,
-                                         GetLayerSnapshotsFunction getLayerSnapshotsFn,
-                                         ui::Size bufferSize, ui::PixelFormat reqPixelFormat,
-                                         bool allowProtected, bool grayscale,
+void SurfaceFlinger::captureScreenCommon(ScreenshotArgs& args, ui::PixelFormat reqPixelFormat,
                                          const sp<IScreenCaptureListener>& captureListener) {
     SFTRACE_CALL();
 
-    if (exceedsMaxRenderTargetSize(bufferSize.getWidth(), bufferSize.getHeight())) {
+    args.captureListener = captureListener;
+
+    auto result = setScreenshotSnapshotsAndDisplayState(args);
+    if (!result.ok()) {
+        invokeScreenCaptureError(result.error(), captureListener);
+        return;
+    }
+
+    if (exceedsMaxRenderTargetSize(args.size.getWidth(), args.size.getHeight())) {
         ALOGE("Attempted to capture screen with size (%" PRId32 ", %" PRId32
               ") that exceeds render target size limit.",
-              bufferSize.getWidth(), bufferSize.getHeight());
+              args.size.getWidth(), args.size.getHeight());
         invokeScreenCaptureError(BAD_VALUE, captureListener);
         return;
     }
 
-    std::vector<std::pair<Layer*, sp<LayerFE>>> layers;
-    bool hasDisplayState = getSnapshotsFromMainThread(args, getLayerSnapshotsFn, layers);
-    if (!hasDisplayState) {
-        ALOGD("Display state not found");
-        invokeScreenCaptureError(NO_MEMORY, captureListener);
+    if (result.value() == ScreenshotStrategy::Readback) {
+        return;
     }
 
-    const bool hasHdrLayer = std::any_of(layers.cbegin(), layers.cend(), [this](const auto& layer) {
-        return isHdrLayer(*(layer.second->mSnapshot.get()));
-    });
+    const bool hasHdrLayer =
+            std::any_of(args.layers.cbegin(), args.layers.cend(), [this](const auto& layer) {
+                return isHdrLayer(*(layer.second->mSnapshot.get()));
+            });
 
     const bool supportsProtected = getRenderEngine().supportsProtectedContent();
     bool hasProtectedLayer = false;
-    if (allowProtected && supportsProtected) {
-        hasProtectedLayer = layersHasProtectedLayer(layers);
+    if (args.includeProtected && supportsProtected) {
+        hasProtectedLayer = layersHasProtectedLayer(args.layers);
     }
-    const bool isProtected = hasProtectedLayer && allowProtected && supportsProtected;
+    const bool isProtected = hasProtectedLayer && args.includeProtected && supportsProtected;
     const uint32_t usage = GRALLOC_USAGE_HW_COMPOSER | GRALLOC_USAGE_HW_RENDER |
             GRALLOC_USAGE_HW_TEXTURE |
             (isProtected ? GRALLOC_USAGE_PROTECTED
                          : GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN);
     sp<GraphicBuffer> buffer =
-            getFactory().createGraphicBuffer(bufferSize.getWidth(), bufferSize.getHeight(),
+            getFactory().createGraphicBuffer(args.size.getWidth(), args.size.getHeight(),
                                              static_cast<android_pixel_format>(reqPixelFormat),
                                              1 /* layerCount */, usage, "screenshot");
 
@@ -7784,64 +7891,121 @@ void SurfaceFlinger::captureScreenCommon(ScreenshotArgs& args,
     }
 
     auto futureFence =
-            captureScreenshot(args, texture, false /* regionSampling */, grayscale, isProtected,
-                              captureListener, layers, hdrTexture, gainmapTexture);
+            captureScreenshot(args, texture, captureListener, hdrTexture, gainmapTexture);
     futureFence.get();
 }
 
-// Returns true if display is found and args was populated with display state
-// data. Otherwise, returns false.
-bool SurfaceFlinger::getDisplayStateOnMainThread(ScreenshotArgs& args) {
+// Returns OK if display is found and args was populated with display state
+// data. Otherwise, returns an error status.
+status_t SurfaceFlinger::setScreenshotDisplayState(ScreenshotArgs& args) {
+    Mutex::Autolock lock(mStateLock);
     sp<const DisplayDevice> display = nullptr;
-    {
-        Mutex::Autolock lock(mStateLock);
-        // Screenshot initiated through captureLayers
-        if (auto* layerSequence = std::get_if<int32_t>(&args.captureTypeVariant)) {
-            // LayerSnapshotBuilder should only be accessed from the main thread.
-            const frontend::LayerSnapshot* snapshot =
-                    mLayerSnapshotBuilder.getSnapshot(*layerSequence);
-            if (!snapshot) {
-                ALOGW("Couldn't find layer snapshot for %d", *layerSequence);
-            } else {
-                if (!args.childrenOnly) {
-                    args.transform = snapshot->localTransform.inverse();
-                }
-                if (args.sourceCrop.isEmpty()) {
-                    args.sourceCrop = snapshot->bufferSize;
-                }
-                display = findDisplay(
-                        [layerStack = snapshot->outputFilter.layerStack](const auto& display) {
-                            return display.getLayerStack() == layerStack;
-                        });
+
+    // Screenshot initiated through captureLayers
+    if (auto* layerSequence = std::get_if<int32_t>(&args.captureTypeVariant)) {
+        // LayerSnapshotBuilder should only be accessed from the main thread.
+        const frontend::LayerSnapshot* snapshot = mLayerSnapshotBuilder.getSnapshot(*layerSequence);
+        if (!snapshot) {
+            ALOGW("Couldn't find layer snapshot for %d", *layerSequence);
+        } else {
+            if (!args.snapshotRequest.childrenOnly) {
+                args.transform = snapshot->localTransform.inverse();
+            }
+            if (args.sourceCrop.isEmpty()) {
+                args.sourceCrop = snapshot->bufferSize;
             }
+            display = findDisplay(
+                    [layerStack = snapshot->outputFilter.layerStack](const auto& display) {
+                        return display.getLayerStack() == layerStack;
+                    });
+            args.debugName.append(", ").append(snapshot->debugName);
+        }
+
+        // Screenshot initiated through captureDisplay by ID
+    } else if (auto* displayId = std::get_if<DisplayId>(&args.captureTypeVariant)) {
+        display = getDisplayDeviceLocked(*displayId);
+        if (!display) {
+            ALOGD("Unable to find display device for captureDisplay by ID");
+            return NAME_NOT_FOUND;
+        }
+
+        Rect layerStackSpaceRect = display->getLayerStackSpaceRect();
+        args.isSecure &= display->isSecure();
+        args.snapshotRequest.layerStack = display->getLayerStack();
+        args.sourceCrop = layerStackSpaceRect;
+        args.size.width *= layerStackSpaceRect.getWidth();
+        args.size.height *= layerStackSpaceRect.getHeight();
+
+        // We could query a real value for this but it'll be a long, long time until we support
+        // displays that need upwards of 1GB per buffer so...
+        constexpr auto kMaxTextureSize = 16384;
+        if (args.size.width <= 0 || args.size.height <= 0 || args.size.width >= kMaxTextureSize ||
+            args.size.height >= kMaxTextureSize) {
+            ALOGD("captureDisplay resolved to invalid size %d x %d", args.size.width,
+                  args.size.height);
+            return BAD_VALUE;
+        }
 
-            // Screenshot initiated through captureDisplay
-        } else if (auto* displayWeak =
-                           std::get_if<wp<const DisplayDevice>>(&args.captureTypeVariant)) {
-            display = displayWeak->promote();
+        // Screenshot initiated through captureDisplay by displayToken
+    } else if (auto* displayToken = std::get_if<sp<IBinder>>(&args.captureTypeVariant)) {
+        display = getDisplayDeviceLocked(*displayToken);
+        if (!display) {
+            ALOGD("Unable to find display device for captureDisplay by displayToken");
+            return NAME_NOT_FOUND;
+        }
+
+        Rect layerStackSpaceRect = display->getLayerStackSpaceRect();
+        args.isSecure &= display->isSecure();
+        args.snapshotRequest.layerStack = display->getLayerStack();
+
+        if (args.sourceCrop.isEmpty()) {
+            args.sourceCrop = layerStackSpaceRect;
+        }
+        // Set the requested width/height to the logical display layer stack rect size by
+        // default
+        if (args.size.width == 0 || args.size.height == 0) {
+            args.size = layerStackSpaceRect.getSize();
         }
 
-        if (display == nullptr) {
-            display = getDefaultDisplayDeviceLocked();
+        // Screenshot initiated for region sampling
+    } else if (std::holds_alternative<std::monostate>(args.captureTypeVariant)) {
+        display = getFrontInternalDisplayLocked();
+        if (!display) {
+            ALOGD("Unable to find display device for region sampling");
+            return NAME_NOT_FOUND;
         }
 
-        if (display != nullptr) {
-            const auto& state = display->getCompositionDisplay()->getState();
-            args.displayBrightnessNits = state.displayBrightnessNits;
-            args.sdrWhitePointNits = state.sdrWhitePointNits;
-            args.renderIntent = state.renderIntent;
-            args.colorMode = state.colorMode;
-            return true;
+        args.snapshotRequest.layerStack = display->getLayerStack();
+
+        if (args.sourceCrop.isEmpty()) {
+            Rect layerStackSpaceRect = display->getLayerStackSpaceRect();
+            args.sourceCrop = layerStackSpaceRect;
+            args.size = layerStackSpaceRect.getSize();
         }
     }
-    return false;
+
+    if (display == nullptr) {
+        display = getPacesetterDisplayLocked();
+    }
+
+    if (display != nullptr) {
+        const auto& state = display->getCompositionDisplay()->getState();
+        args.displayBrightnessNits = state.displayBrightnessNits;
+        args.sdrWhitePointNits = state.sdrWhitePointNits;
+        args.renderIntent = state.renderIntent;
+        args.colorMode = state.colorMode;
+        args.debugName.append(", ").append(display->getDisplayName());
+        args.debugName.append(" (").append(to_string(display->getId())).append(")");
+        args.displayIdVariant = display->getDisplayIdVariant();
+        return OK;
+    }
+    ALOGD("Display state not found");
+    return NO_MEMORY;
 }
 
 ftl::SharedFuture<FenceResult> SurfaceFlinger::captureScreenshot(
         ScreenshotArgs& args, const std::shared_ptr<renderengine::ExternalTexture>& buffer,
-        bool regionSampling, bool grayscale, bool isProtected,
         const sp<IScreenCaptureListener>& captureListener,
-        const std::vector<std::pair<Layer*, sp<LayerFE>>>& layers,
         const std::shared_ptr<renderengine::ExternalTexture>& hdrBuffer,
         const std::shared_ptr<renderengine::ExternalTexture>& gainmapBuffer) {
     SFTRACE_CALL();
@@ -7853,8 +8017,7 @@ ftl::SharedFuture<FenceResult> SurfaceFlinger::captureScreenshot(
 
     if (hdrBuffer && gainmapBuffer) {
         ftl::SharedFuture<FenceResult> hdrRenderFuture =
-                renderScreenImpl(args, hdrBuffer, regionSampling, grayscale, isProtected,
-                                 captureResults, layers);
+                renderScreenImpl(args, hdrBuffer, captureResults);
         captureResults.buffer = buffer->getBuffer();
         captureResults.optionalGainMap = gainmapBuffer->getBuffer();
 
@@ -7866,17 +8029,26 @@ ftl::SharedFuture<FenceResult> SurfaceFlinger::captureScreenshot(
                                 return fenceResult;
                             }
 
-                            return getRenderEngine()
-                                    .tonemapAndDrawGainmap(hdrBuffer, fenceResult.value()->get(),
-                                                           hdrSdrRatio,
-                                                           static_cast<ui::Dataspace>(dataspace),
-                                                           buffer, gainmapBuffer)
-                                    .get();
+                            auto tonemapAndDrawGainmap = [&]() -> FenceResult {
+                                return getRenderEngine()
+                                        .tonemapAndDrawGainmap(hdrBuffer,
+                                                               fenceResult.value()->get(),
+                                                               hdrSdrRatio,
+                                                               static_cast<ui::Dataspace>(
+                                                                       dataspace),
+                                                               buffer, gainmapBuffer)
+                                        .get();
+                            };
+
+                            if (mRenderEngine->isThreaded()) {
+                                return tonemapAndDrawGainmap();
+                            } else {
+                                return mScheduler->schedule(std::move(tonemapAndDrawGainmap)).get();
+                            }
                         })
                         .share();
     } else {
-        renderFuture = renderScreenImpl(args, buffer, regionSampling, grayscale, isProtected,
-                                        captureResults, layers);
+        renderFuture = renderScreenImpl(args, buffer, captureResults);
     }
 
     if (captureListener) {
@@ -7896,11 +8068,10 @@ ftl::SharedFuture<FenceResult> SurfaceFlinger::captureScreenshot(
 
 ftl::SharedFuture<FenceResult> SurfaceFlinger::renderScreenImpl(
         ScreenshotArgs& args, const std::shared_ptr<renderengine::ExternalTexture>& buffer,
-        bool regionSampling, bool grayscale, bool isProtected, ScreenCaptureResults& captureResults,
-        const std::vector<std::pair<Layer*, sp<LayerFE>>>& layers) {
+        ScreenCaptureResults& captureResults) {
     SFTRACE_CALL();
 
-    for (auto& [_, layerFE] : layers) {
+    for (auto& [_, layerFE] : args.layers) {
         frontend::LayerSnapshot* snapshot = layerFE->mSnapshot.get();
         captureResults.capturedSecureLayers |= (snapshot->isVisible && snapshot->isSecure);
         captureResults.capturedHdrLayers |= isHdrLayer(*snapshot);
@@ -7945,27 +8116,26 @@ ftl::SharedFuture<FenceResult> SurfaceFlinger::renderScreenImpl(
     captureResults.buffer = capturedBuffer->getBuffer();
 
     ui::LayerStack layerStack{ui::DEFAULT_LAYER_STACK};
-    if (!layers.empty()) {
-        const sp<LayerFE>& layerFE = layers.back().second;
+    if (!args.layers.empty()) {
+        const sp<LayerFE>& layerFE = args.layers.back().second;
         layerStack = layerFE->getCompositionState()->outputFilter.layerStack;
     }
 
     auto present = [this, buffer = capturedBuffer, dataspace = captureResults.capturedDataspace,
-                    grayscale, isProtected, layers, layerStack, regionSampling, args, renderIntent,
-                    enableLocalTonemapping]() -> FenceResult {
+                    layerStack, args, renderIntent, enableLocalTonemapping]() -> FenceResult {
         std::unique_ptr<compositionengine::CompositionEngine> compositionEngine =
                 mFactory.createCompositionEngine();
         compositionEngine->setRenderEngine(mRenderEngine.get());
         compositionEngine->setHwComposer(mHWComposer.get());
 
         std::vector<sp<compositionengine::LayerFE>> layerFEs;
-        layerFEs.reserve(layers.size());
-        for (auto& [layer, layerFE] : layers) {
+        layerFEs.reserve(args.layers.size());
+        for (auto& [layer, layerFE] : args.layers) {
             // Release fences were not yet added for non-threaded render engine. To avoid
             // deadlocks between main thread and binder threads waiting for the future fence
             // result, fences should be added to layers in the same hop onto the main thread.
             if (!mRenderEngine->isThreaded()) {
-                attachReleaseFenceFutureToLayer(layer, layerFE.get(), ui::INVALID_LAYER_STACK);
+                attachReleaseFenceFutureToLayer(layer, layerFE.get(), ui::UNASSIGNED_LAYER_STACK);
             }
             layerFEs.push_back(layerFE);
         }
@@ -8005,20 +8175,20 @@ ftl::SharedFuture<FenceResult> SurfaceFlinger::renderScreenImpl(
                                         .sourceCrop = args.sourceCrop,
                                         .buffer = std::move(buffer),
                                         .displayIdVariant = args.displayIdVariant,
-                                        .reqBufferSize = args.reqSize,
+                                        .reqBufferSize = args.size,
                                         .sdrWhitePointNits = args.sdrWhitePointNits,
                                         .displayBrightnessNits = args.displayBrightnessNits,
                                         .targetBrightness = targetBrightness,
                                         .layerAlpha = layerAlpha,
-                                        .regionSampling = regionSampling,
+                                        .disableBlur = args.disableBlur,
                                         .treat170mAsSrgb = mTreat170mAsSrgb,
                                         .dimInGammaSpaceForEnhancedScreenshots =
                                                 dimInGammaSpaceForEnhancedScreenshots,
                                         .isSecure = args.isSecure,
-                                        .isProtected = isProtected,
-                                        .enableLocalTonemapping = enableLocalTonemapping});
+                                        .enableLocalTonemapping = enableLocalTonemapping,
+                                        .debugName = args.debugName});
 
-        const float colorSaturation = grayscale ? 0 : 1;
+        const float colorSaturation = args.isGrayscale ? 0 : 1;
         compositionengine::CompositionRefreshArgs refreshArgs{
                 .outputs = {output},
                 .layers = std::move(layerFEs),
@@ -8103,8 +8273,12 @@ status_t SurfaceFlinger::applyRefreshRateSelectorPolicy(
     const scheduler::RefreshRateSelector::Policy currentPolicy = selector.getCurrentPolicy();
     ALOGV("Setting desired display mode specs: %s", currentPolicy.toString().c_str());
 
-    if (mScheduler->onDisplayModeChanged(displayId, selector.getActiveMode(),
-                                         /*clearContentRequirements*/ true)) {
+    const auto isPacesetter = FlagManager::getInstance().unify_refresh_rate_callbacks()
+            ? mScheduler->updatePolicyContentRequirements(displayId, selector.getActiveMode(),
+                                                          /*clearContentRequirements*/ true)
+            : mScheduler->onDisplayModeChanged(displayId, selector.getActiveMode(),
+                                               /*clearContentRequirements*/ true);
+    if (isPacesetter) {
         mDisplayModeController.updateKernelIdleTimer(displayId);
     }
 
@@ -8126,7 +8300,16 @@ status_t SurfaceFlinger::applyRefreshRateSelectorPolicy(
         return INVALID_OPERATION;
     }
 
-    setDesiredMode({std::move(preferredMode), .emitEvent = true});
+    if (FlagManager::getInstance().unify_refresh_rate_callbacks() &&
+        mScheduler->updateFrameRateOverrides(scheduler::GlobalSignals{}, preferredFps)) {
+        setDesiredMode({preferredMode, .emitEvent = false});
+        // Update the frameRateOverride and display mode change.
+        mScheduler->onDisplayModeAndFrameRateOverridesChanged(displayId, preferredMode,
+                                                              /*clearContentRequirements*/ false);
+        return NO_ERROR;
+    }
+
+    setDesiredMode({preferredMode, .emitEvent = true});
 
     // Update the frameRateOverride list as the display render rate might have changed
     mScheduler->updateFrameRateOverrides(scheduler::GlobalSignals{}, preferredFps);
@@ -8177,13 +8360,9 @@ status_t SurfaceFlinger::setDesiredDisplayModeSpecs(const sp<IBinder>& displayTo
             return INVALID_OPERATION;
         } else {
             using Policy = scheduler::RefreshRateSelector::DisplayManagerPolicy;
-            const auto idleScreenConfigOpt =
-                    FlagManager::getInstance().idle_screen_refresh_rate_timeout()
-                    ? specs.idleScreenRefreshRateConfig
-                    : std::nullopt;
             const Policy policy{DisplayModeId(specs.defaultMode), translate(specs.primaryRanges),
                                 translate(specs.appRequestRanges), specs.allowGroupSwitching,
-                                idleScreenConfigOpt};
+                                specs.idleScreenRefreshRateConfig};
 
             return setDesiredDisplayModeSpecsInternal(display, policy);
         }
@@ -8250,6 +8429,9 @@ status_t SurfaceFlinger::setGlobalShadowSettings(const half4& ambientColor, cons
     // these values are overridden when calculating the shadow settings for a layer.
     mCurrentState.globalShadowSettings.lightPos.x = 0.f;
     mCurrentState.globalShadowSettings.length = 0.f;
+
+    setTransactionFlags(eTransactionNeeded);
+
     return NO_ERROR;
 }
 
@@ -8351,7 +8533,8 @@ status_t SurfaceFlinger::getMaxAcquiredBufferCount(int* buffers) const {
     Fps maxRefreshRate = 60_Hz;
 
     if (!getHwComposer().isHeadless()) {
-        if (const auto display = getDefaultDisplayDevice()) {
+        const sp<const DisplayDevice> display = getPacesetterDisplay();
+        if (display) {
             maxRefreshRate = display->refreshRateSelector().getSupportedRefreshRateRange().max;
         }
     }
@@ -8366,7 +8549,9 @@ uint32_t SurfaceFlinger::getMaxAcquiredBufferCountForCurrentRefreshRate(uid_t ui
     if (const auto frameRateOverride = mScheduler->getFrameRateOverride(uid)) {
         refreshRate = *frameRateOverride;
     } else if (!getHwComposer().isHeadless()) {
-        if (const auto display = FTL_FAKE_GUARD(mStateLock, getDefaultDisplayDeviceLocked())) {
+        const sp<const DisplayDevice> display =
+                FTL_FAKE_GUARD(mStateLock, getPacesetterDisplayLocked());
+        if (display) {
             refreshRate = display->refreshRateSelector().getActiveMode().fps;
         }
     }
@@ -8392,50 +8577,49 @@ void SurfaceFlinger::sample() {
     mRegionSamplingThread->onCompositionComplete(scheduleFrameTimeOpt);
 }
 
-void SurfaceFlinger::onActiveDisplaySizeChanged(const DisplayDevice& activeDisplay) {
-    mScheduler->onActiveDisplayAreaChanged(activeDisplay.getWidth() * activeDisplay.getHeight());
-    getRenderEngine().onActiveDisplaySizeChanged(activeDisplay.getSize());
-}
-
-sp<DisplayDevice> SurfaceFlinger::getActivatableDisplay() const {
+sp<DisplayDevice> SurfaceFlinger::findFrontInternalDisplay() const {
     if (mPhysicalDisplays.size() == 1) return nullptr;
 
-    // TODO(b/255635821): Choose the pacesetter display, considering both internal and external
-    // displays. For now, pick the other internal display, assuming a dual-display foldable.
     return findDisplay([this](const DisplayDevice& display) REQUIRES(mStateLock) {
         const auto idOpt = asPhysicalDisplayId(display.getDisplayIdVariant());
-        return idOpt.has_value() && *idOpt != mActiveDisplayId && display.isPoweredOn() &&
+        return idOpt.has_value() && *idOpt != mFrontInternalDisplayId && display.isPoweredOn() &&
                 mPhysicalDisplays.get(*idOpt)
                         .transform(&PhysicalDisplay::isInternal)
                         .value_or(false);
     });
 }
 
-void SurfaceFlinger::onActiveDisplayChangedLocked(const DisplayDevice* inactiveDisplayPtr,
-                                                  const DisplayDevice& activeDisplay) {
+void SurfaceFlinger::onNewFrontInternalDisplay(const DisplayDevice* oldFrontInternalDisplayPtr,
+                                               const DisplayDevice& newFrontInternalDisplay) {
     SFTRACE_CALL();
 
-    if (inactiveDisplayPtr) {
-        inactiveDisplayPtr->getCompositionDisplay()->setLayerCachingTexturePoolEnabled(false);
-    }
+    mFrontInternalDisplayId = newFrontInternalDisplay.getPhysicalId();
 
-    mActiveDisplayId = activeDisplay.getPhysicalId();
-    activeDisplay.getCompositionDisplay()->setLayerCachingTexturePoolEnabled(true);
+    mFrontInternalDisplayTransformHint = newFrontInternalDisplay.getTransformHint();
+    sFrontInternalDisplayRotationFlags =
+            ui::Transform::toRotationFlags(newFrontInternalDisplay.getOrientation());
 
-    // TODO(b/255635711): Check for pending mode changes on other displays.
-    mScheduler->setModeChangePending(false);
+    if (!FlagManager::getInstance().pacesetter_selection()) {
+        if (oldFrontInternalDisplayPtr) {
+            oldFrontInternalDisplayPtr->getCompositionDisplay()->setLayerCachingTexturePoolEnabled(
+                    false);
+            mScheduler->setModeChangePending(oldFrontInternalDisplayPtr->getPhysicalId(), false);
+        }
+
+        mScheduler->onPacesetterDisplaySizeChanged(newFrontInternalDisplay.getSize());
+        getRenderEngine().onActiveDisplaySizeChanged(newFrontInternalDisplay.getSize());
 
-    mScheduler->setPacesetterDisplay(mActiveDisplayId);
+        newFrontInternalDisplay.getCompositionDisplay()->setLayerCachingTexturePoolEnabled(true);
 
-    onActiveDisplaySizeChanged(activeDisplay);
-    mActiveDisplayTransformHint = activeDisplay.getTransformHint();
-    sActiveDisplayRotationFlags = ui::Transform::toRotationFlags(activeDisplay.getOrientation());
+        mScheduler->setPacesetterDisplay(mFrontInternalDisplayId);
 
-    // Whether or not the policy of the new active/pacesetter display changed while it was inactive
-    // (in which case its preferred mode has already been propagated to HWC via setDesiredMode), the
-    // Scheduler's cachedModeChangedParams must be initialized to the newly active mode, and the
-    // kernel idle timer of the newly active display must be toggled.
-    applyRefreshRateSelectorPolicy(mActiveDisplayId, activeDisplay.refreshRateSelector());
+        // Whether or not the policy of the new front internal display changed while it was powered
+        // off (in which case its preferred mode has already been propagated to HWC via
+        // setDesiredMode), the Scheduler's emittedModeOpt must be initialized to the newly
+        // active mode, and the kernel idle timer of the front internal display must be toggled.
+        applyRefreshRateSelectorPolicy(mFrontInternalDisplayId,
+                                       newFrontInternalDisplay.refreshRateSelector());
+    }
 }
 
 status_t SurfaceFlinger::addWindowInfosListener(const sp<IWindowInfosListener>& windowInfosListener,
@@ -8485,6 +8669,7 @@ void SurfaceFlinger::updateHdcpLevels(hal::HWDisplayId hwcDisplayId, int32_t con
         if (const auto display = FTL_FAKE_GUARD(mStateLock, getDisplayDeviceLocked(displayId))) {
             Mutex::Autolock lock(mStateLock);
             display->setSecure(secure);
+            setTransactionFlags(eDisplayTransactionNeeded);
         }
         FTL_FAKE_GUARD(kMainThreadContext, mDisplayModeController.setSecure(displayId, secure));
         mScheduler->onHdcpLevelsChanged(scheduler::Cycle::Render, displayId, connectedLevel,
@@ -8525,6 +8710,19 @@ std::shared_ptr<renderengine::ExternalTexture> SurfaceFlinger::getExternalTextur
         return nullptr;
     }
 
+    if (bufferData.buffer && bufferData.buffer->getLayerCount() != 1) {
+        std::string errorMessage =
+                base::StringPrintf("Attempted to create an ExternalTexture with layer count (%u)"
+                                   " != 1 for layer %s",
+                                   bufferData.buffer->getLayerCount(), layerName);
+        ALOGD("%s", errorMessage.c_str());
+        if (bufferData.releaseBufferListener) {
+            bufferData.releaseBufferListener->onTransactionQueueStalled(
+                    String8(errorMessage.c_str()));
+        }
+        return nullptr;
+    }
+
     bool cachedBufferChanged =
             bufferData.flags.test(BufferData::BufferDataChange::cachedBufferChanged);
     if (cachedBufferChanged && bufferData.buffer) {
@@ -8608,12 +8806,9 @@ std::vector<std::pair<Layer*, LayerFE*>> SurfaceFlinger::moveSnapshotsToComposit
     return layers;
 }
 
-std::function<std::vector<std::pair<Layer*, sp<LayerFE>>>()>
-SurfaceFlinger::getLayerSnapshotsForScreenshots(
-        std::optional<ui::LayerStack> layerStack, uint32_t uid,
-        std::function<bool(const frontend::LayerSnapshot&, bool& outStopTraversal)>
-                snapshotFilterFn) {
-    return [&, layerStack, uid]() FTL_FAKE_GUARD(kMainThreadContext) {
+std::vector<std::pair<Layer*, sp<LayerFE>>> SurfaceFlinger::getLayerSnapshotsForScreenshots(
+        const SnapshotRequestArgs& args) {
+    auto snapshotLambda = [&](const SnapshotRequestArgs& args) FTL_FAKE_GUARD(kMainThreadContext) {
         std::vector<std::pair<Layer*, sp<LayerFE>>> layers;
         bool stopTraversal = false;
         mLayerSnapshotBuilder.forEachVisibleSnapshot(
@@ -8622,16 +8817,16 @@ SurfaceFlinger::getLayerSnapshotsForScreenshots(
                     if (stopTraversal) {
                         return;
                     }
-                    if (layerStack && snapshot->outputFilter.layerStack != *layerStack) {
+                    if (args.layerStack && snapshot->outputFilter.layerStack != *args.layerStack) {
                         return;
                     }
-                    if (uid != CaptureArgs::UNSET_UID && snapshot->uid != gui::Uid(uid)) {
+                    if (args.uid != gui::Uid::INVALID && snapshot->uid != gui::Uid(args.uid)) {
                         return;
                     }
                     if (!snapshot->hasSomethingToDraw()) {
                         return;
                     }
-                    if (snapshotFilterFn && !snapshotFilterFn(*snapshot, stopTraversal)) {
+                    if (args.snapshotFilterFn && !args.snapshotFilterFn(*snapshot, stopTraversal)) {
                         return;
                     }
 
@@ -8647,88 +8842,54 @@ SurfaceFlinger::getLayerSnapshotsForScreenshots(
 
         return layers;
     };
-}
-
-std::function<std::vector<std::pair<Layer*, sp<LayerFE>>>()>
-SurfaceFlinger::getLayerSnapshotsForScreenshots(std::optional<ui::LayerStack> layerStack,
-                                                uint32_t uid,
-                                                std::unordered_set<uint32_t> excludeLayerIds) {
-    return [&, layerStack, uid,
-            excludeLayerIds = std::move(excludeLayerIds)]() FTL_FAKE_GUARD(kMainThreadContext) {
-        if (excludeLayerIds.empty()) {
-            auto getLayerSnapshotsFn =
-                    getLayerSnapshotsForScreenshots(layerStack, uid, /*snapshotFilterFn=*/nullptr);
-            std::vector<std::pair<Layer*, sp<LayerFE>>> layers = getLayerSnapshotsFn();
-            return layers;
-        }
-
-        frontend::LayerSnapshotBuilder::Args
-                args{.root = mLayerHierarchyBuilder.getHierarchy(),
-                     .layerLifecycleManager = mLayerLifecycleManager,
-                     .forceUpdate = frontend::LayerSnapshotBuilder::ForceUpdateFlags::HIERARCHY,
-                     .displays = mFrontEndDisplayInfos,
-                     .displayChanges = true,
-                     .globalShadowSettings = mDrawingState.globalShadowSettings,
-                     .supportsBlur = mSupportsBlur,
-                     .forceFullDamage = mForceFullDamage,
-                     .excludeLayerIds = std::move(excludeLayerIds),
-                     .supportedLayerGenericMetadata =
-                             getHwComposer().getSupportedLayerGenericMetadata(),
-                     .genericLayerMetadataKeyMap = getGenericLayerMetadataKeyMap(),
-                     .skipRoundCornersWhenProtected =
-                             !getRenderEngine().supportsProtectedContent()};
-        mLayerSnapshotBuilder.update(args);
-
-        auto getLayerSnapshotsFn =
-                getLayerSnapshotsForScreenshots(layerStack, uid, /*snapshotFilterFn=*/nullptr);
-        std::vector<std::pair<Layer*, sp<LayerFE>>> layers = getLayerSnapshotsFn();
-
-        args.excludeLayerIds.clear();
-        mLayerSnapshotBuilder.update(args);
-
-        return layers;
-    };
-}
 
-std::function<std::vector<std::pair<Layer*, sp<LayerFE>>>()>
-SurfaceFlinger::getLayerSnapshotsForScreenshots(uint32_t rootLayerId, uint32_t uid,
-                                                std::unordered_set<uint32_t> excludeLayerIds,
-                                                bool childrenOnly,
-                                                const std::optional<FloatRect>& parentCrop) {
-    return [&, rootLayerId, uid, excludeLayerIds = std::move(excludeLayerIds), childrenOnly,
-            parentCrop]() FTL_FAKE_GUARD(kMainThreadContext) {
-        auto root = mLayerHierarchyBuilder.getPartialHierarchy(rootLayerId, childrenOnly);
+    std::vector<std::pair<Layer*, sp<LayerFE>>> layers;
+    if (args.rootLayerId || !args.excludeLayerIds.empty()) {
+        // Create and update LayerSnapshotBuilder args before iterating through snapshots
         frontend::LayerSnapshotBuilder::Args
-                args{.root = root,
-                     .layerLifecycleManager = mLayerLifecycleManager,
-                     .forceUpdate = frontend::LayerSnapshotBuilder::ForceUpdateFlags::HIERARCHY,
-                     .displays = mFrontEndDisplayInfos,
-                     .displayChanges = true,
-                     .globalShadowSettings = mDrawingState.globalShadowSettings,
-                     .supportsBlur = mSupportsBlur,
-                     .forceFullDamage = mForceFullDamage,
-                     .parentCrop = parentCrop,
-                     .excludeLayerIds = std::move(excludeLayerIds),
-                     .supportedLayerGenericMetadata =
-                             getHwComposer().getSupportedLayerGenericMetadata(),
-                     .genericLayerMetadataKeyMap = getGenericLayerMetadataKeyMap(),
-                     .skipRoundCornersWhenProtected =
-                             !getRenderEngine().supportsProtectedContent()};
-        // The layer may not exist if it was just created and a screenshot was requested immediately
-        // after. In this case, the hierarchy will be empty so we will not render any layers.
-        args.rootSnapshot.isSecure = mLayerLifecycleManager.getLayerFromId(rootLayerId) &&
-                mLayerLifecycleManager.isLayerSecure(rootLayerId);
-        mLayerSnapshotBuilder.update(args);
+                builderArgs{.root = args.rootLayerId
+                                    ? mLayerHierarchyBuilder
+                                              .getPartialHierarchy(args.rootLayerId.value(),
+                                                                   args.childrenOnly)
+                                    : mLayerHierarchyBuilder.getHierarchy(),
+                            .layerLifecycleManager = mLayerLifecycleManager,
+                            .forceUpdate =
+                                    frontend::LayerSnapshotBuilder::ForceUpdateFlags::HIERARCHY,
+                            .displays = mFrontEndDisplayInfos,
+                            .displayChanges = true,
+                            .globalShadowSettings = mDrawingState.globalShadowSettings,
+                            .supportsBlur = mSupportsBlur,
+                            .forceFullDamage = mForceFullDamage,
+                            .excludeLayerIds = std::move(args.excludeLayerIds),
+                            .supportedLayerGenericMetadata =
+                                    getHwComposer().getSupportedLayerGenericMetadata(),
+                            .genericLayerMetadataKeyMap = getGenericLayerMetadataKeyMap(),
+                            .skipRoundCornersWhenProtected =
+                                    !getRenderEngine().supportsProtectedContent()};
+        if (args.rootLayerId) {
+            builderArgs.parentCrop = args.parentCrop;
+            // The layer may not exist if it was just created and a screenshot was requested
+            // immediately after. In this case, the hierarchy will be empty so we will not render
+            // any layers.
+            builderArgs.rootSnapshot.isSecure =
+                    mLayerLifecycleManager.getLayerFromId(args.rootLayerId.value()) &&
+                    mLayerLifecycleManager.isLayerSecure(args.rootLayerId.value());
+        }
+        mLayerSnapshotBuilder.update(builderArgs);
+        layers = snapshotLambda(args);
+
+        // Reset LayerSnapshotBuilder args after snapshots are obtained
+        if (args.rootLayerId) {
+            builderArgs.root = mLayerHierarchyBuilder.getHierarchy();
+            builderArgs.parentCrop.reset();
+        }
+        builderArgs.excludeLayerIds.clear();
+        mLayerSnapshotBuilder.update(builderArgs);
 
-        auto getLayerSnapshotsFn =
-                getLayerSnapshotsForScreenshots({}, uid, /*snapshotFilterFn=*/nullptr);
-        std::vector<std::pair<Layer*, sp<LayerFE>>> layers = getLayerSnapshotsFn();
-        args.root = mLayerHierarchyBuilder.getHierarchy();
-        args.parentCrop.reset();
-        args.excludeLayerIds.clear();
-        mLayerSnapshotBuilder.update(args);
-        return layers;
-    };
+    } else {
+        layers = snapshotLambda(args);
+    }
+    return layers;
 }
 
 void SurfaceFlinger::doActiveLayersTracingIfNeeded(bool isCompositionComputed,
@@ -8833,17 +8994,15 @@ binder::Status SurfaceComposerAIDL::createDisplayEventConnection(
 
 binder::Status SurfaceComposerAIDL::createConnection(sp<gui::ISurfaceComposerClient>* outClient) {
     const sp<Client> client = sp<Client>::make(mFlinger);
-    if (client->initCheck() == NO_ERROR) {
-        *outClient = client;
-        if (FlagManager::getInstance().misc1()) {
-            const int policy = SCHED_FIFO;
-            client->setMinSchedulerPolicy(policy, sched_get_priority_min(policy));
-        }
-        return binder::Status::ok();
-    } else {
+    if (client->initCheck() != NO_ERROR) {
         *outClient = nullptr;
         return binderStatusFromStatusT(BAD_VALUE);
     }
+
+    *outClient = client;
+    const int policy = SCHED_FIFO;
+    client->setMinSchedulerPolicy(policy, sched_get_priority_min(policy));
+    return binder::Status::ok();
 }
 
 binder::Status SurfaceComposerAIDL::createVirtualDisplay(
@@ -8947,6 +9106,7 @@ binder::Status SurfaceComposerAIDL::getStaticDisplayInfo(int64_t displayId,
         outInfo->density = info.density;
         outInfo->secure = info.secure;
         outInfo->installOrientation = static_cast<gui::Rotation>(info.installOrientation);
+        outInfo->screenPartStatus = static_cast<uint8_t>(info.screenPartStatus);
 
         if (const std::optional<DeviceProductInfo> dpi = info.deviceProductInfo) {
             gui::DeviceProductInfo dinfo;
@@ -9358,6 +9518,22 @@ binder::Status SurfaceComposerAIDL::addRegionSamplingListener(
     return binderStatusFromStatusT(status);
 }
 
+binder::Status SurfaceComposerAIDL::addRegionSamplingListenerWithStopLayerId(
+        const gui::ARect& samplingArea, const int32_t stopLayerId,
+        const sp<gui::IRegionSamplingListener>& listener) {
+    status_t status = checkAccessPermission();
+    if (status != OK) {
+        return binderStatusFromStatusT(status);
+    }
+    android::Rect rect;
+    rect.left = samplingArea.left;
+    rect.top = samplingArea.top;
+    rect.right = samplingArea.right;
+    rect.bottom = samplingArea.bottom;
+    status = mFlinger->addRegionSamplingListenerWithStopLayerId(rect, stopLayerId, listener);
+    return binderStatusFromStatusT(status);
+}
+
 binder::Status SurfaceComposerAIDL::removeRegionSamplingListener(
         const sp<gui::IRegionSamplingListener>& listener) {
     status_t status = checkReadFrameBufferPermission();
@@ -9367,6 +9543,15 @@ binder::Status SurfaceComposerAIDL::removeRegionSamplingListener(
     return binderStatusFromStatusT(status);
 }
 
+binder::Status SurfaceComposerAIDL::getRegionSamplingListeners(
+        std::vector<gui::RegionSamplingDescriptor>* listeners) {
+    status_t status = checkAccessPermission();
+    if (status == OK) {
+        status = mFlinger->getRegionSamplingListeners(listeners);
+    }
+    return binderStatusFromStatusT(status);
+}
+
 binder::Status SurfaceComposerAIDL::addFpsListener(int32_t taskId,
                                                    const sp<gui::IFpsListener>& listener) {
     status_t status = checkReadFrameBufferPermission();
@@ -9776,6 +9961,63 @@ const DisplayDevice* SurfaceFlinger::getDisplayFromLayerStack(ui::LayerStack lay
     return nullptr;
 }
 
+void SurfaceFlinger::validateForReadback(LayerFE* layer) {
+    for (auto it = mReadbackRequests.begin(); it != mReadbackRequests.end(); it++) {
+        auto& request = *it;
+        ftl::FakeGuard guard(mStateLock);
+        if (const auto display = getCompositionDisplayLocked(request.id)) {
+            if (display->includesLayer(layer)) {
+                auto snapshot = layer->mSnapshot.get();
+                if (snapshot->isVisible &&
+                    ((!request.isSecure && snapshot->isSecure) ||
+                     (!request.seamlessTransition && isHdrLayer(*(layer->mSnapshot.get()))) ||
+                     snapshot->hasProtectedContent)) {
+                    // TODO: The clients that want this path are okay with dropping the
+                    // screenshot request on the floor and erroring out. BUT: for clients that
+                    // don't explicitly want DPU readback we can be nicer and bounce over to
+                    // renderScreenImpl() to hit the GPU path.
+                    invokeScreenCaptureError(NAME_NOT_FOUND, request.captureListener);
+                    mReadbackRequests.erase(it);
+                    break;
+                }
+            }
+        }
+    }
+}
+void SurfaceFlinger::setupOutputsForReadback(
+        std::vector<std::shared_ptr<compositionengine::Output>>& outputs) {
+    for (auto& request : mReadbackRequests) {
+        for (auto& output : outputs) {
+            if (request.id.value == output->getDisplayId()->value) {
+                output->editState().readbackBuffer = std::move(request.buffer);
+            }
+        }
+    }
+}
+void SurfaceFlinger::finalizeReadback(
+        std::vector<std::shared_ptr<compositionengine::Output>>& outputs) {
+    for (auto& output : outputs) {
+        if (output->getState().readbackBuffer) {
+            for (const auto& request : mReadbackRequests) {
+                if (request.id.value == output->getDisplayId()->value) {
+                    ScreenCaptureResults captureResults;
+                    captureResults.buffer = std::move(output->editState().readbackBuffer);
+                    captureResults.fenceResult = getHwComposer().getReadbackBufferFence(request.id);
+                    request.captureListener->onScreenCaptureCompleted(captureResults);
+                }
+            }
+        }
+    }
+
+    for (auto& request : mReadbackRequests) {
+        if (request.buffer) {
+            invokeScreenCaptureError(NAME_NOT_FOUND, request.captureListener);
+        }
+    }
+
+    mReadbackRequests.clear();
+}
+
 } // namespace android
 
 #if defined(__gl_h_)
diff --git a/services/surfaceflinger/SurfaceFlinger.h b/services/surfaceflinger/SurfaceFlinger.h
index f0298079a0..ec50bff43d 100644
--- a/services/surfaceflinger/SurfaceFlinger.h
+++ b/services/surfaceflinger/SurfaceFlinger.h
@@ -43,6 +43,8 @@
 #include <gui/ISurfaceComposer.h>
 #include <gui/ITransactionCompletedListener.h>
 #include <gui/LayerState.h>
+#include <gui/SimpleTransactionState.h>
+#include <gui/TransactionState.h>
 #include <layerproto/LayerProtoHeader.h>
 #include <math/mat4.h>
 #include <renderengine/LayerSettings.h>
@@ -117,6 +119,7 @@
 #include <aidl/android/hardware/graphics/common/DisplayHotplugEvent.h>
 #include <aidl/android/hardware/graphics/composer3/RefreshRateChangedDebugData.h>
 #include "Client.h"
+#include "gui/SimpleTransactionState.h"
 
 using namespace android::surfaceflinger;
 
@@ -147,7 +150,7 @@ using gui::IRegionSamplingListener;
 using gui::LayerCaptureArgs;
 using gui::ScreenCaptureResults;
 
-namespace frametimeline {
+namespace scheduler {
 class FrameTimeline;
 }
 
@@ -342,8 +345,8 @@ public:
     // TODO (b/281857977): This should be annotated with REQUIRES(kMainThreadContext), but this
     // would require thread safety annotations throughout the frontend (in particular Layer and
     // LayerFE).
-    static ui::Transform::RotationFlags getActiveDisplayRotationFlags() {
-        return sActiveDisplayRotationFlags;
+    static ui::Transform::RotationFlags getFrontInternalDisplayRotationFlags() {
+        return sFrontInternalDisplayRotationFlags;
     }
 
 protected:
@@ -379,7 +382,6 @@ private:
     friend class TunnelModeEnabledReporterTest;
 
     using TransactionSchedule = scheduler::TransactionSchedule;
-    using GetLayerSnapshotsFunction = std::function<std::vector<std::pair<Layer*, sp<LayerFE>>>()>;
     using DumpArgs = Vector<String16>;
     using Dumper = std::function<void(const DumpArgs&, bool asProto, std::string&)>;
 
@@ -545,7 +547,10 @@ private:
     }
 
     sp<IBinder> getPhysicalDisplayToken(PhysicalDisplayId displayId) const;
-    status_t setTransactionState(TransactionState&&) override;
+    status_t setTransactionState(SimpleTransactionState podState,
+                                 const ComplexTransactionState& complexState,
+                                 MutableTransactionState& mutableState,
+                                 const sp<IBinder>& applyToken) override;
     void bootFinished();
     status_t getSupportedFrameTimestamps(std::vector<FrameEvent>* outSupported) const;
     sp<IDisplayEventConnection> createDisplayEventConnection(
@@ -602,7 +607,12 @@ private:
     status_t isWideColorDisplay(const sp<IBinder>& displayToken, bool* outIsWideColorDisplay) const;
     status_t addRegionSamplingListener(const Rect& samplingArea, const sp<IBinder>& stopLayerHandle,
                                        const sp<IRegionSamplingListener>& listener);
+    status_t addRegionSamplingListenerWithStopLayerId(const Rect& samplingArea,
+                                                      const int32_t stopLayerId,
+                                                      const sp<IRegionSamplingListener>& listener);
     status_t removeRegionSamplingListener(const sp<IRegionSamplingListener>& listener);
+    status_t getRegionSamplingListeners(
+            std::vector<gui::RegionSamplingDescriptor>* listeners) const;
     status_t addFpsListener(int32_t taskId, const sp<gui::IFpsListener>& listener);
     status_t removeFpsListener(const sp<gui::IFpsListener>& listener);
     status_t addTunnelModeEnabledListener(const sp<gui::ITunnelModeEnabledListener>& listener);
@@ -690,7 +700,9 @@ private:
                                      Fps renderRate) override;
     void onCommitNotComposited() override
             REQUIRES(kMainThreadContext);
-    void vrrDisplayIdle(bool idle) override;
+    void vrrDisplayIdle(PhysicalDisplayId displayId, bool idle) override;
+    void enableLayerCachingTexturePool(PhysicalDisplayId, bool enable) override
+            REQUIRES(kMainThreadContext);
 
     // ICEPowerCallback overrides:
     void notifyCpuLoadUp() override;
@@ -711,7 +723,7 @@ private:
     // Show hdr sdr ratio overlay
     bool mHdrSdrRatioOverlay = false;
 
-    void setDesiredMode(display::DisplayModeRequest&&) REQUIRES(mStateLock);
+    void setDesiredMode(display::DisplayModeRequest) REQUIRES(mStateLock);
 
     status_t setActiveModeFromBackdoor(const sp<display::DisplayToken>&, DisplayModeId, Fps minFps,
                                        Fps maxFps);
@@ -733,19 +745,14 @@ private:
     void setVirtualDisplayPowerMode(const sp<DisplayDevice>& display, hal::PowerMode mode)
             REQUIRES(mStateLock, kMainThreadContext);
 
-    // Returns whether to optimize globally for performance instead of power.
-    bool shouldOptimizeForPerformance() REQUIRES(mStateLock);
-
-    // Turns on power optimizations, for example when there are no displays to be optimized for
-    // performance.
-    static void enablePowerOptimizations(const char* whence);
-
-    // Turns off power optimizations.
-    static void disablePowerOptimizations(const char* whence);
+    // Adjusts thread scheduling according to the optimization policy
+    static void optimizeThreadScheduling(
+            const char* whence, gui::ISurfaceComposer::OptimizationPolicy optimizationPolicy);
 
     // Enables or disables power optimizations depending on whether there are displays that should
     // be optimized for performance.
-    void applyOptimizationPolicy(const char* whence) REQUIRES(mStateLock);
+    void applyOptimizationPolicy(const char* whence) REQUIRES(kMainThreadContext)
+            REQUIRES(mStateLock);
 
     // Returns the preferred mode for PhysicalDisplayId if the Scheduler has selected one for that
     // display. Falls back to the display's defaultModeId otherwise.
@@ -792,7 +799,7 @@ private:
      */
     bool applyTransactionState(const FrameTimelineInfo& info,
                                std::vector<ResolvedComposerState>& state,
-                               std::span<DisplayState> displays, uint32_t flags,
+                               Vector<DisplayState>& displays, uint32_t flags,
                                const InputWindowCommands& inputWindowCommands,
                                const int64_t desiredPresentTime, bool isAutoTimestamp,
                                const std::vector<uint64_t>& uncacheBufferIds,
@@ -827,8 +834,8 @@ private:
 
     // Sets the masked bits, and schedules a commit if needed.
     void setTransactionFlags(uint32_t mask, TransactionSchedule = TransactionSchedule::Late,
-                             const sp<IBinder>& applyToken = nullptr,
-                             FrameHint = FrameHint::kActive);
+                             FrameHint = FrameHint::kActive,
+                             std::vector<gui::EarlyWakeupInfo> earlyWakeupInfo = {});
 
     // Clears and returns the masked bits.
     uint32_t clearTransactionFlags(uint32_t mask);
@@ -847,17 +854,14 @@ private:
      */
     status_t createLayer(LayerCreationArgs& args, gui::CreateSurfaceResult& outResult);
 
-    status_t createBufferStateLayer(LayerCreationArgs& args, sp<IBinder>* outHandle,
-                                    sp<Layer>* outLayer);
-
-    status_t createEffectLayer(const LayerCreationArgs& args, sp<IBinder>* outHandle,
-                               sp<Layer>* outLayer);
+    status_t createLayer(const LayerCreationArgs& args, sp<IBinder>* outHandle,
+                         sp<Layer>* outLayer);
 
     // Checks if there are layer leaks before creating layer
     status_t checkLayerLeaks();
 
     status_t mirrorLayer(const LayerCreationArgs& args, const sp<IBinder>& mirrorFromHandle,
-                         gui::CreateSurfaceResult& outResult);
+                         const sp<IBinder>& stopAtHandle, gui::CreateSurfaceResult& outResult);
 
     status_t mirrorDisplay(DisplayId displayId, const LayerCreationArgs& args,
                            gui::CreateSurfaceResult& outResult);
@@ -876,20 +880,45 @@ private:
 
     using OutputCompositionState = compositionengine::impl::OutputCompositionState;
 
+    struct SnapshotRequestArgs {
+        // Uid initiating the screenshot request
+        gui::Uid uid{gui::Uid::INVALID};
+
+        std::optional<ui::LayerStack> layerStack{std::nullopt};
+
+        std::optional<uint32_t> rootLayerId{std::nullopt};
+
+        // IDs of layers that will be excluded from the screenshot
+        std::unordered_set<uint32_t> excludeLayerIds{};
+
+        // If true, transform is inverted from the parent layer snapshot
+        bool childrenOnly{false};
+
+        std::optional<FloatRect> parentCrop{std::nullopt};
+
+        std::function<bool(const frontend::LayerSnapshot&, bool& outStopTraversal)>
+                snapshotFilterFn{nullptr};
+    };
+
     /*
      * Parameters used across screenshot methods.
      */
     struct ScreenshotArgs {
         // Contains the sequence ID of the parent layer if the screenshot is
-        // initiated though captureLayers(), or the display that the render
-        // result will be on if initiated through captureDisplay()
-        std::variant<int32_t, wp<const DisplayDevice>> captureTypeVariant;
+        // initiated though captureLayers(), or the displayToken or displayID
+        // that the render result will be on if initiated through captureDisplay().
+        // The monostate type is used to denote that the screenshot is initiated
+        // for region sampling.
+        std::variant<std::monostate, int32_t, sp<IBinder>, DisplayId> captureTypeVariant;
 
         // Display ID of the display the result will be on
         ftl::Optional<DisplayIdVariant> displayIdVariant{std::nullopt};
 
-        // If true, transform is inverted from the parent layer snapshot
-        bool childrenOnly{false};
+        // Arguments provided to screenshot function for getting layer snapshots
+        SnapshotRequestArgs snapshotRequest;
+
+        // List of all layer snapshots that are included in the screenshot
+        std::vector<std::pair<Layer*, sp<LayerFE>>> layers;
 
         // Source crop of the render area
         Rect sourceCrop;
@@ -899,15 +928,25 @@ private:
         ui::Transform transform;
 
         // Size of the physical render area
-        ui::Size reqSize;
+        ui::Size size;
 
         // Composition dataspace of the render area
         ui::Dataspace dataspace;
 
+        // Whether blur should be disabled, such as for region sampling
+        bool disableBlur{false};
+
+        // If true, screenshot is captured in grayscale
+        bool isGrayscale{false};
+
         // If false, the secure layer is blacked out or skipped
         // when rendered to an insecure render area
         bool isSecure{false};
 
+        // If true, includes protected layers which, if screenshotted, results
+        // in a protected output buffer
+        bool includeProtected{false};
+
         // If true, the render result may be used for system animations
         // that must preserve the exact colors of the display
         bool seamlessTransition{false};
@@ -923,30 +962,34 @@ private:
 
         // Current active render intent of the output composition state
         ui::RenderIntent renderIntent{ui::RenderIntent::COLORIMETRIC};
+
+        // Current listener for the screenshot result
+        sp<IScreenCaptureListener> captureListener{nullptr};
+
+        std::string debugName;
     };
 
-    bool getSnapshotsFromMainThread(ScreenshotArgs& args,
-                                    GetLayerSnapshotsFunction getLayerSnapshotsFn,
-                                    std::vector<std::pair<Layer*, sp<LayerFE>>>& layers);
+    enum class ScreenshotStrategy {
+        Readback,
+        Gpu,
+    };
+    base::expected<ScreenshotStrategy, status_t> setScreenshotSnapshotsAndDisplayState(
+            ScreenshotArgs& args);
 
-    void captureScreenCommon(ScreenshotArgs& args, GetLayerSnapshotsFunction, ui::Size bufferSize,
-                             ui::PixelFormat, bool allowProtected, bool grayscale,
+    void captureScreenCommon(ScreenshotArgs& args, ui::PixelFormat,
                              const sp<IScreenCaptureListener>&);
 
-    bool getDisplayStateOnMainThread(ScreenshotArgs& args) REQUIRES(kMainThreadContext);
+    status_t setScreenshotDisplayState(ScreenshotArgs& args) REQUIRES(kMainThreadContext);
 
     ftl::SharedFuture<FenceResult> captureScreenshot(
             ScreenshotArgs& args, const std::shared_ptr<renderengine::ExternalTexture>& buffer,
-            bool regionSampling, bool grayscale, bool isProtected,
             const sp<IScreenCaptureListener>& captureListener,
-            const std::vector<std::pair<Layer*, sp<LayerFE>>>& layers,
             const std::shared_ptr<renderengine::ExternalTexture>& hdrBuffer = nullptr,
             const std::shared_ptr<renderengine::ExternalTexture>& gainmapBuffer = nullptr);
 
     ftl::SharedFuture<FenceResult> renderScreenImpl(
             ScreenshotArgs& args, const std::shared_ptr<renderengine::ExternalTexture>&,
-            bool regionSampling, bool grayscale, bool isProtected, ScreenCaptureResults&,
-            const std::vector<std::pair<Layer*, sp<LayerFE>>>& layers);
+            ScreenCaptureResults&);
 
     void readPersistentProperties();
 
@@ -996,18 +1039,33 @@ private:
         return nullptr;
     }
 
-    // Returns the primary display or (for foldables) the active display.
-    sp<const DisplayDevice> getDefaultDisplayDeviceLocked() const REQUIRES(mStateLock) {
-        return const_cast<SurfaceFlinger*>(this)->getDefaultDisplayDeviceLocked();
+    sp<const DisplayDevice> getPacesetterDisplayLocked() const REQUIRES(mStateLock) {
+        return const_cast<SurfaceFlinger*>(this)->getPacesetterDisplayLocked();
     }
 
-    sp<DisplayDevice> getDefaultDisplayDeviceLocked() REQUIRES(mStateLock) {
-        return getDisplayDeviceLocked(mActiveDisplayId);
+    sp<DisplayDevice> getPacesetterDisplayLocked() REQUIRES(mStateLock) {
+        if (!FlagManager::getInstance().pacesetter_selection()) {
+            return getFrontInternalDisplayLocked();
+        }
+        return getDisplayDeviceLocked(mScheduler->getPacesetterDisplayId());
     }
 
-    sp<const DisplayDevice> getDefaultDisplayDevice() const EXCLUDES(mStateLock) {
+    sp<const DisplayDevice> getPacesetterDisplay() const EXCLUDES(mStateLock) {
         Mutex::Autolock lock(mStateLock);
-        return getDefaultDisplayDeviceLocked();
+        return getPacesetterDisplayLocked();
+    }
+
+    sp<const DisplayDevice> getFrontInternalDisplayLocked() const REQUIRES(mStateLock) {
+        return const_cast<SurfaceFlinger*>(this)->getFrontInternalDisplayLocked();
+    }
+
+    sp<DisplayDevice> getFrontInternalDisplayLocked() REQUIRES(mStateLock) {
+        return getDisplayDeviceLocked(mFrontInternalDisplayId);
+    }
+
+    sp<const DisplayDevice> getFrontInternalDisplay() const EXCLUDES(mStateLock) {
+        Mutex::Autolock lock(mStateLock);
+        return getFrontInternalDisplayLocked();
     }
 
     using DisplayDeviceAndSnapshot = std::pair<sp<DisplayDevice>, display::DisplaySnapshotRef>;
@@ -1049,6 +1107,8 @@ private:
                         .value_or(false)};
     }
 
+    ui::Size findLargestFramebufferSizeLocked() const REQUIRES(mStateLock);
+
     /*
      * H/W composer
      */
@@ -1081,7 +1141,7 @@ private:
 
     // Returns the active mode ID, or nullopt on hotplug failure.
     std::optional<DisplayModeId> processHotplugConnect(PhysicalDisplayId, hal::HWDisplayId,
-                                                       DisplayIdentificationInfo&&,
+                                                       display::DisplayIdentificationInfo&&,
                                                        const char* displayString,
                                                        HWComposer::HotplugEvent event)
             REQUIRES(mStateLock, kMainThreadContext);
@@ -1153,15 +1213,12 @@ private:
     void releaseVirtualDisplay(VirtualDisplayIdVariant displayId);
     void releaseVirtualDisplaySnapshot(VirtualDisplayId displayId);
 
-    // Returns a display other than `mActiveDisplayId` that can be activated, if any.
-    sp<DisplayDevice> getActivatableDisplay() const REQUIRES(mStateLock, kMainThreadContext);
+    sp<DisplayDevice> findFrontInternalDisplay() const REQUIRES(mStateLock, kMainThreadContext);
 
-    void onActiveDisplayChangedLocked(const DisplayDevice* inactiveDisplayPtr,
-                                      const DisplayDevice& activeDisplay)
+    void onNewFrontInternalDisplay(const DisplayDevice* oldFrontInternalDisplayPtr,
+                                   const DisplayDevice& newFrontInternalDisplay)
             REQUIRES(mStateLock, kMainThreadContext);
 
-    void onActiveDisplaySizeChanged(const DisplayDevice&);
-
     /*
      * Debugging & dumpsys
      */
@@ -1298,9 +1355,24 @@ private:
         int32_t layerId;
         ui::Dataspace dataspace;
         std::chrono::milliseconds timeSinceLastEvent;
+        bool useLuts;
+        float desiredHdrHeadroom;
     };
     std::vector<LayerEvent> mLayerEvents;
 
+    struct ReadbackRequest {
+        PhysicalDisplayId id;
+        sp<GraphicBuffer> buffer;
+        sp<IScreenCaptureListener> captureListener;
+        bool seamlessTransition;
+        bool isSecure;
+    };
+    std::vector<ReadbackRequest> mReadbackRequests;
+
+    void validateForReadback(LayerFE* layer);
+    void setupOutputsForReadback(std::vector<std::shared_ptr<compositionengine::Output>>& outputs);
+    void finalizeReadback(std::vector<std::shared_ptr<compositionengine::Output>>& outputs);
+
     // Used to ensure we omit a callback when HDR layer info listener is newly added but the
     // scene hasn't changed
     bool mAddingHDRLayerInfoListener = false;
@@ -1355,7 +1427,7 @@ private:
             GUARDED_BY(mVirtualDisplaysMutex);
 
     // The inner or outer display for foldables, while unfolded or folded, respectively.
-    std::atomic<PhysicalDisplayId> mActiveDisplayId;
+    std::atomic<PhysicalDisplayId> mFrontInternalDisplayId;
 
     display::DisplayModeController mDisplayModeController;
 
@@ -1378,7 +1450,7 @@ private:
 
     const std::shared_ptr<TimeStats> mTimeStats;
     const std::unique_ptr<FrameTracer> mFrameTracer;
-    const std::unique_ptr<frametimeline::FrameTimeline> mFrameTimeline;
+    const std::unique_ptr<scheduler::FrameTimeline> mFrameTimeline;
 
     VsyncId mLastCommittedVsyncId;
 
@@ -1465,11 +1537,11 @@ private:
     ActivePictureTracker::Listeners mActivePictureListenersToAdd GUARDED_BY(mStateLock);
     ActivePictureTracker::Listeners mActivePictureListenersToRemove GUARDED_BY(mStateLock);
 
-    std::atomic<ui::Transform::RotationFlags> mActiveDisplayTransformHint;
+    std::atomic<ui::Transform::RotationFlags> mFrontInternalDisplayTransformHint;
 
     // Must only be accessed on the main thread.
     // TODO (b/259407931): Remove.
-    static ui::Transform::RotationFlags sActiveDisplayRotationFlags;
+    static ui::Transform::RotationFlags sFrontInternalDisplayRotationFlags;
 
     bool isRefreshRateOverlayEnabled() const REQUIRES(mStateLock) {
         return hasDisplay(
@@ -1479,16 +1551,9 @@ private:
         return hasDisplay(
                 [](const auto& display) { return display.isHdrSdrRatioOverlayEnabled(); });
     }
-    std::function<std::vector<std::pair<Layer*, sp<LayerFE>>>()> getLayerSnapshotsForScreenshots(
-            std::optional<ui::LayerStack> layerStack, uint32_t uid,
-            std::function<bool(const frontend::LayerSnapshot&, bool& outStopTraversal)>
-                    snapshotFilterFn);
-    std::function<std::vector<std::pair<Layer*, sp<LayerFE>>>()> getLayerSnapshotsForScreenshots(
-            std::optional<ui::LayerStack> layerStack, uint32_t uid,
-            std::unordered_set<uint32_t> excludeLayerIds);
-    std::function<std::vector<std::pair<Layer*, sp<LayerFE>>>()> getLayerSnapshotsForScreenshots(
-            uint32_t rootLayerId, uint32_t uid, std::unordered_set<uint32_t> excludeLayerIds,
-            bool childrenOnly, const std::optional<FloatRect>& optionalParentCrop);
+
+    std::vector<std::pair<Layer*, sp<LayerFE>>> getLayerSnapshotsForScreenshots(
+            const SnapshotRequestArgs& args) REQUIRES(kMainThreadContext);
 
     const sp<WindowInfosListenerInvoker> mWindowInfosListenerInvoker;
 
@@ -1648,8 +1713,12 @@ public:
     binder::Status addRegionSamplingListener(
             const gui::ARect& samplingArea, const sp<IBinder>& stopLayerHandle,
             const sp<gui::IRegionSamplingListener>& listener) override;
+    binder::Status addRegionSamplingListenerWithStopLayerId(
+            const gui::ARect& samplingArea, const int32_t stopLayerId,
+            const sp<gui::IRegionSamplingListener>& listener) override;
     binder::Status removeRegionSamplingListener(
             const sp<gui::IRegionSamplingListener>& listener) override;
+    binder::Status getRegionSamplingListeners(std::vector<gui::RegionSamplingDescriptor>*) override;
     binder::Status addFpsListener(int32_t taskId, const sp<gui::IFpsListener>& listener) override;
     binder::Status removeFpsListener(const sp<gui::IFpsListener>& listener) override;
     binder::Status addTunnelModeEnabledListener(
diff --git a/services/surfaceflinger/SurfaceFlingerDefaultFactory.cpp b/services/surfaceflinger/SurfaceFlingerDefaultFactory.cpp
index b1d8ba9a2f..9e36516f63 100644
--- a/services/surfaceflinger/SurfaceFlingerDefaultFactory.cpp
+++ b/services/surfaceflinger/SurfaceFlingerDefaultFactory.cpp
@@ -30,7 +30,7 @@
 #include "SurfaceFlingerProperties.h"
 
 #include "DisplayHardware/ComposerHal.h"
-#include "FrameTimeline/FrameTimeline.h"
+#include "Scheduler/FrameTimeline.h"
 #include "Scheduler/Scheduler.h"
 #include "Scheduler/VsyncConfiguration.h"
 #include "Scheduler/VsyncController.h"
@@ -77,11 +77,7 @@ std::unique_ptr<compositionengine::CompositionEngine> DefaultFactory::createComp
     return compositionengine::impl::createCompositionEngine();
 }
 
-sp<Layer> DefaultFactory::createBufferStateLayer(const LayerCreationArgs& args) {
-    return sp<Layer>::make(args);
-}
-
-sp<Layer> DefaultFactory::createEffectLayer(const LayerCreationArgs& args) {
+sp<Layer> DefaultFactory::createLayer(const LayerCreationArgs& args) {
     return sp<Layer>::make(args);
 }
 
@@ -93,9 +89,9 @@ std::unique_ptr<FrameTracer> DefaultFactory::createFrameTracer() {
     return std::make_unique<FrameTracer>();
 }
 
-std::unique_ptr<frametimeline::FrameTimeline> DefaultFactory::createFrameTimeline(
+std::unique_ptr<scheduler::FrameTimeline> DefaultFactory::createFrameTimeline(
         std::shared_ptr<TimeStats> timeStats, pid_t surfaceFlingerPid) {
-    return std::make_unique<frametimeline::impl::FrameTimeline>(timeStats, surfaceFlingerPid);
+    return std::make_unique<scheduler::impl::FrameTimeline>(timeStats, surfaceFlingerPid);
 }
 
 } // namespace android::surfaceflinger
diff --git a/services/surfaceflinger/SurfaceFlingerDefaultFactory.h b/services/surfaceflinger/SurfaceFlingerDefaultFactory.h
index 7ebf10fff0..d6223068bc 100644
--- a/services/surfaceflinger/SurfaceFlingerDefaultFactory.h
+++ b/services/surfaceflinger/SurfaceFlingerDefaultFactory.h
@@ -39,11 +39,10 @@ public:
     std::unique_ptr<surfaceflinger::NativeWindowSurface> createNativeWindowSurface(
             const sp<IGraphicBufferProducer>&) override;
     std::unique_ptr<compositionengine::CompositionEngine> createCompositionEngine() override;
-    sp<Layer> createBufferStateLayer(const LayerCreationArgs& args) override;
-    sp<Layer> createEffectLayer(const LayerCreationArgs& args) override;
+    sp<Layer> createLayer(const LayerCreationArgs& args) override;
     sp<LayerFE> createLayerFE(const std::string& layerName, const Layer* owner) override;
     std::unique_ptr<FrameTracer> createFrameTracer() override;
-    std::unique_ptr<frametimeline::FrameTimeline> createFrameTimeline(
+    std::unique_ptr<scheduler::FrameTimeline> createFrameTimeline(
             std::shared_ptr<TimeStats> timeStats, pid_t surfaceFlingerPid) override;
 };
 
diff --git a/services/surfaceflinger/SurfaceFlingerFactory.h b/services/surfaceflinger/SurfaceFlingerFactory.h
index c7d1fa0594..287178d44e 100644
--- a/services/surfaceflinger/SurfaceFlingerFactory.h
+++ b/services/surfaceflinger/SurfaceFlingerFactory.h
@@ -49,14 +49,11 @@ class CompositionEngine;
 } // namespace compositionengine
 
 namespace scheduler {
+class FrameTimeline;
 class VsyncConfiguration;
 class VsyncController;
 } // namespace scheduler
 
-namespace frametimeline {
-class FrameTimeline;
-} // namespace frametimeline
-
 namespace surfaceflinger {
 
 struct LayerCreationArgs;
@@ -83,11 +80,10 @@ public:
 
     virtual std::unique_ptr<compositionengine::CompositionEngine> createCompositionEngine() = 0;
 
-    virtual sp<Layer> createBufferStateLayer(const LayerCreationArgs& args) = 0;
-    virtual sp<Layer> createEffectLayer(const LayerCreationArgs& args) = 0;
+    virtual sp<Layer> createLayer(const LayerCreationArgs& args) = 0;
     virtual sp<LayerFE> createLayerFE(const std::string& layerName, const Layer* owner) = 0;
     virtual std::unique_ptr<FrameTracer> createFrameTracer() = 0;
-    virtual std::unique_ptr<frametimeline::FrameTimeline> createFrameTimeline(
+    virtual std::unique_ptr<scheduler::FrameTimeline> createFrameTimeline(
             std::shared_ptr<TimeStats> timeStats, pid_t surfaceFlingerPid) = 0;
 
 protected:
diff --git a/services/surfaceflinger/Tracing/LayerTracing.cpp b/services/surfaceflinger/Tracing/LayerTracing.cpp
index d78f9bbbae..de4bcb8d7f 100644
--- a/services/surfaceflinger/Tracing/LayerTracing.cpp
+++ b/services/surfaceflinger/Tracing/LayerTracing.cpp
@@ -192,9 +192,11 @@ void LayerTracing::writeSnapshotToStream(perfetto::protos::LayersSnapshotProto&&
 
 void LayerTracing::writeSnapshotToPerfetto(const perfetto::protos::LayersSnapshotProto& snapshot,
                                            Mode srcMode) {
+    SFTRACE_CALL();
     const auto snapshotBytes = snapshot.SerializeAsString();
 
     LayerDataSource::Trace([&](LayerDataSource::TraceContext context) {
+        SFTRACE_NAME("writeSnapshotToPerfetto_traceFunction");
         auto dstMode = context.GetCustomTlsState()->mMode;
         if (srcMode == Mode::MODE_GENERATED) {
             // Layers snapshots produced by LayerTraceGenerator have srcMode == MODE_GENERATED
diff --git a/services/surfaceflinger/Tracing/TransactionProtoParser.cpp b/services/surfaceflinger/Tracing/TransactionProtoParser.cpp
index 6bbc04cf6f..9fafa49967 100644
--- a/services/surfaceflinger/Tracing/TransactionProtoParser.cpp
+++ b/services/surfaceflinger/Tracing/TransactionProtoParser.cpp
@@ -127,6 +127,9 @@ perfetto::protos::LayerState TransactionProtoParser::toProto(
     if (layer.what & layer_state_t::eBackgroundBlurRadiusChanged) {
         proto.set_background_blur_radius(layer.backgroundBlurRadius);
     }
+    if (layer.what & layer_state_t::eBackgroundBlurScaleChanged) {
+        proto.set_background_blur_scale(layer.backgroundBlurScale);
+    }
 
     if (layer.what & layer_state_t::eAlphaChanged) {
         proto.set_alpha(layer.color.a);
@@ -321,7 +324,7 @@ QueuedTransactionState TransactionProtoParser::fromProto(
     int32_t displayCount = proto.display_changes_size();
     t.displays.reserve(static_cast<size_t>(displayCount));
     for (int i = 0; i < displayCount; i++) {
-        t.displays.emplace_back(fromProto(proto.display_changes(i)));
+        t.displays.add(fromProto(proto.display_changes(i)));
     }
     return t;
 }
@@ -396,6 +399,9 @@ void TransactionProtoParser::fromProto(const perfetto::protos::LayerState& proto
     if (proto.what() & layer_state_t::eBackgroundBlurRadiusChanged) {
         layer.backgroundBlurRadius = proto.background_blur_radius();
     }
+    if (proto.what() & layer_state_t::eBackgroundBlurScaleChanged) {
+        layer.backgroundBlurScale = proto.background_blur_radius();
+    }
 
     if (proto.what() & layer_state_t::eAlphaChanged) {
         layer.color.a = proto.alpha();
diff --git a/services/surfaceflinger/Tracing/TransactionTracing.cpp b/services/surfaceflinger/Tracing/TransactionTracing.cpp
index 1cd75170bf..dfe2be9043 100644
--- a/services/surfaceflinger/Tracing/TransactionTracing.cpp
+++ b/services/surfaceflinger/Tracing/TransactionTracing.cpp
@@ -18,6 +18,7 @@
 #define LOG_TAG "TransactionTracing"
 
 #include <android-base/stringprintf.h>
+#include <common/trace.h>
 #include <log/log.h>
 #include <utils/SystemClock.h>
 
@@ -87,6 +88,7 @@ void TransactionTracing::onFlush(TransactionTracing::Mode mode) {
 void TransactionTracing::writeRingBufferToPerfetto(TransactionTracing::Mode mode) {
     // Write the ring buffer (starting state + following sequence of transactions) to perfetto
     // tracing sessions with the specified mode.
+    SFTRACE_CALL();
     const auto fileProto = writeToProto();
 
     TransactionDataSource::Trace([&](TransactionDataSource::TraceContext context) {
@@ -132,6 +134,7 @@ status_t TransactionTracing::writeToFile(const std::string& filename) {
 }
 
 perfetto::protos::TransactionTraceFile TransactionTracing::writeToProto() {
+    SFTRACE_CALL();
     std::scoped_lock<std::mutex> lock(mTraceLock);
     perfetto::protos::TransactionTraceFile fileProto = createTraceFileProto();
     const auto startingStateProto = createStartingStateProtoLocked();
@@ -160,6 +163,7 @@ perfetto::protos::TransactionTraceFile TransactionTracing::createTraceFileProto(
 }
 
 void TransactionTracing::dump(std::string& result) const {
+    SFTRACE_CALL();
     std::scoped_lock lock(mTraceLock);
     base::StringAppendF(&result, "  queued transactions=%zu created layers=%zu states=%zu\n",
                         mQueuedTransactions.size(), mCreatedLayers.size(), mStartingStates.size());
@@ -167,6 +171,7 @@ void TransactionTracing::dump(std::string& result) const {
 }
 
 void TransactionTracing::addQueuedTransaction(const QueuedTransactionState& transaction) {
+    SFTRACE_CALL();
     perfetto::protos::TransactionState* state =
             new perfetto::protos::TransactionState(mProtoParser.toProto(transaction));
     mTransactionQueue.push(state);
@@ -176,6 +181,7 @@ void TransactionTracing::addCommittedTransactions(int64_t vsyncId, nsecs_t commi
                                                   frontend::Update& newUpdate,
                                                   const frontend::DisplayInfos& displayInfos,
                                                   bool displayInfoChanged) {
+    SFTRACE_CALL();
     CommittedUpdates update;
     update.vsyncId = vsyncId;
     update.timestamp = commitTime;
@@ -228,6 +234,7 @@ void TransactionTracing::loop() {
 
 void TransactionTracing::addEntry(const std::vector<CommittedUpdates>& committedUpdates,
                                   const std::vector<uint32_t>& destroyedLayers) {
+    SFTRACE_CALL();
     std::scoped_lock lock(mTraceLock);
     std::vector<std::string> removedEntries;
     perfetto::protos::TransactionTraceEntry entryProto;
@@ -354,6 +361,7 @@ void TransactionTracing::onLayerRemoved(int32_t layerId) {
 void TransactionTracing::tryPushToTracingThread() {
     // Try to acquire the lock from main thread.
     if (mMainThreadLock.try_lock()) {
+        SFTRACE_NAME("pushTransactionsToTracingThread");
         // We got the lock! Collect any pending transactions and continue.
         mUpdates.insert(mUpdates.end(), std::make_move_iterator(mPendingUpdates.begin()),
                         std::make_move_iterator(mPendingUpdates.end()));
@@ -370,6 +378,7 @@ void TransactionTracing::tryPushToTracingThread() {
 
 void TransactionTracing::updateStartingStateLocked(
         const perfetto::protos::TransactionTraceEntry& removedEntry) {
+    SFTRACE_CALL();
     mStartingTimestamp = removedEntry.elapsed_realtime_nanos();
     // Keep track of layer starting state so we can reconstruct the layer state as we purge
     // transactions from the buffer.
@@ -410,6 +419,7 @@ void TransactionTracing::updateStartingStateLocked(
 
 std::optional<perfetto::protos::TransactionTraceEntry>
 TransactionTracing::createStartingStateProtoLocked() {
+    SFTRACE_CALL();
     if (mStartingStates.empty()) {
         return std::nullopt;
     }
diff --git a/services/surfaceflinger/common/FlagManager.cpp b/services/surfaceflinger/common/FlagManager.cpp
index ebf451501d..f41bcf3a79 100644
--- a/services/surfaceflinger/common/FlagManager.cpp
+++ b/services/surfaceflinger/common/FlagManager.cpp
@@ -24,7 +24,6 @@
 #include <log/log.h>
 #include <renderengine/RenderEngine.h>
 #include <server_configurable_flags/get_flags.h>
-#include <cinttypes>
 
 #include <android_companion_virtualdevice_flags.h>
 #include <android_hardware_flags.h>
@@ -38,10 +37,6 @@ using namespace com::android::graphics::surfaceflinger;
 
 static constexpr const char* kExperimentNamespace = "surface_flinger_native_boot";
 
-std::unique_ptr<FlagManager> FlagManager::mInstance;
-std::once_flag FlagManager::mOnce;
-
-FlagManager::FlagManager(ConstructorTag) {}
 FlagManager::~FlagManager() = default;
 
 namespace {
@@ -72,12 +67,8 @@ const FlagManager& FlagManager::getInstance() {
 }
 
 FlagManager& FlagManager::getMutableInstance() {
-    std::call_once(mOnce, [&] {
-        LOG_ALWAYS_FATAL_IF(mInstance, "Instance already created");
-        mInstance = std::make_unique<FlagManager>(ConstructorTag{});
-    });
-
-    return *mInstance;
+    static FlagManager sInstance;
+    return sInstance;
 }
 
 void FlagManager::markBootCompleted() {
@@ -117,12 +108,14 @@ void FlagManager::dump(std::string& result) const {
     DUMP_SYSPROP_FLAG(disable_sched_fifo_re);
     DUMP_SYSPROP_FLAG(disable_sched_fifo_composer);
     DUMP_SYSPROP_FLAG(disable_sched_fifo_composer_callback);
+    DUMP_SYSPROP_FLAG(productionize_readback_screenshot);
 
     /// Legacy server flags ///
     DUMP_LEGACY_SERVER_FLAG(use_adpf_cpu_hint);
     DUMP_LEGACY_SERVER_FLAG(use_skia_tracing);
 
     /// Trunk stable server (R/W) flags ///
+    DUMP_ACONFIG_FLAG(adpf_cpu_effects_loadup);
     DUMP_ACONFIG_FLAG(adpf_gpu_sf);
     DUMP_ACONFIG_FLAG(adpf_native_session_manager);
     DUMP_ACONFIG_FLAG(adpf_use_fmq_channel);
@@ -130,30 +123,27 @@ void FlagManager::dump(std::string& result) const {
     DUMP_ACONFIG_FLAG(graphite_renderengine_preview_rollout);
     DUMP_ACONFIG_FLAG(increase_missed_frame_jank_threshold);
     DUMP_ACONFIG_FLAG(monitor_buffer_fences);
+    DUMP_ACONFIG_FLAG(readback_screenshot);
     DUMP_ACONFIG_FLAG(refresh_rate_overlay_on_external_display);
+    DUMP_ACONFIG_FLAG(vsync_predictor_rate_change_with_aligned_sequence);
+    DUMP_ACONFIG_FLAG(unify_refresh_rate_callbacks);
     DUMP_ACONFIG_FLAG(vsync_predictor_recovery);
 
     /// Trunk stable readonly flags ///
     /// IMPORTANT - please keep alphabetize to reduce merge conflicts
-    DUMP_ACONFIG_FLAG(add_sf_skipped_frames_to_trace);
     DUMP_ACONFIG_FLAG(adpf_fmq_sf);
-    DUMP_ACONFIG_FLAG(allow_n_vsyncs_in_targeter);
     DUMP_ACONFIG_FLAG(arr_setframerate_gte_enum);
     DUMP_ACONFIG_FLAG(begone_bright_hlg);
     DUMP_ACONFIG_FLAG(cache_when_source_crop_layer_only_moved);
-    DUMP_ACONFIG_FLAG(commit_not_composited);
     DUMP_ACONFIG_FLAG(connected_display_hdr);
     DUMP_ACONFIG_FLAG(correct_dpi_with_display_size);
     DUMP_ACONFIG_FLAG(deprecate_frame_tracker);
     DUMP_ACONFIG_FLAG(deprecate_vsync_sf);
     DUMP_ACONFIG_FLAG(detached_mirror);
+    DUMP_ACONFIG_FLAG(disable_synthetic_vsync_for_performance);
     DUMP_ACONFIG_FLAG(display_config_error_hal);
-    DUMP_ACONFIG_FLAG(display_protected);
-    DUMP_ACONFIG_FLAG(dont_skip_on_early_ro);
-    DUMP_ACONFIG_FLAG(enable_fro_dependent_features);
     DUMP_ACONFIG_FLAG(enable_layer_command_batching);
     DUMP_ACONFIG_FLAG(enable_small_area_detection);
-    DUMP_ACONFIG_FLAG(filter_frames_before_trace_starts);
     DUMP_ACONFIG_FLAG(flush_buffer_slots_to_uncache);
     DUMP_ACONFIG_FLAG(force_compile_graphite_renderengine);
     DUMP_ACONFIG_FLAG(fp16_client_target);
@@ -162,26 +152,22 @@ void FlagManager::dump(std::string& result) const {
     DUMP_ACONFIG_FLAG(graphite_renderengine);
     DUMP_ACONFIG_FLAG(hdcp_level_hal);
     DUMP_ACONFIG_FLAG(hdcp_negotiation);
-    DUMP_ACONFIG_FLAG(idle_screen_refresh_rate_timeout);
-    DUMP_ACONFIG_FLAG(latch_unsignaled_with_auto_refresh_changed);
     DUMP_ACONFIG_FLAG(local_tonemap_screenshots);
-    DUMP_ACONFIG_FLAG(misc1);
     DUMP_ACONFIG_FLAG(no_vsyncs_on_screen_off);
     DUMP_ACONFIG_FLAG(override_trusted_overlay);
+    DUMP_ACONFIG_FLAG(pacesetter_selection);
     DUMP_ACONFIG_FLAG(protected_if_client);
-    DUMP_ACONFIG_FLAG(reject_dupe_layerstacks);
     DUMP_ACONFIG_FLAG(renderable_buffer_usage);
     DUMP_ACONFIG_FLAG(restore_blur_step);
     DUMP_ACONFIG_FLAG(skip_invisible_windows_in_input);
     DUMP_ACONFIG_FLAG(stable_edid_ids);
+    DUMP_ACONFIG_FLAG(stop_layer);
     DUMP_ACONFIG_FLAG(synced_resolution_switch);
-    DUMP_ACONFIG_FLAG(trace_frame_rate_override);
     DUMP_ACONFIG_FLAG(true_hdr_screenshots);
     DUMP_ACONFIG_FLAG(use_known_refresh_rate_for_fps_consistency);
-    DUMP_ACONFIG_FLAG(vrr_bugfix_24q4);
-    DUMP_ACONFIG_FLAG(vrr_bugfix_dropped_frame);
     DUMP_ACONFIG_FLAG(vrr_config);
     DUMP_ACONFIG_FLAG(vulkan_renderengine);
+    DUMP_ACONFIG_FLAG(wb_virtualdisplay2);
     DUMP_ACONFIG_FLAG(window_blur_kawase2);
     /// IMPORTANT - please keep alphabetize to reduce merge conflicts
 
@@ -243,6 +229,7 @@ FLAG_MANAGER_SYSPROP_FLAG(disable_sched_fifo_sf_sched, /* default */ false)
 FLAG_MANAGER_SYSPROP_FLAG(disable_sched_fifo_re, /* default */ false)
 FLAG_MANAGER_SYSPROP_FLAG(disable_sched_fifo_composer, /* default */ false)
 FLAG_MANAGER_SYSPROP_FLAG(disable_sched_fifo_composer_callback, /* default */ false)
+FLAG_MANAGER_SYSPROP_FLAG(productionize_readback_screenshot, /* default */ false)
 
 /// Legacy server flags ///
 FLAG_MANAGER_LEGACY_SERVER_FLAG(test_flag, "", "")
@@ -257,34 +244,25 @@ FLAG_MANAGER_ACONFIG_FLAG(arr_setframerate_gte_enum, "debug.sf.arr_setframerate_
 FLAG_MANAGER_ACONFIG_FLAG(enable_small_area_detection, "")
 FLAG_MANAGER_ACONFIG_FLAG(stable_edid_ids, "debug.sf.stable_edid_ids")
 FLAG_MANAGER_ACONFIG_FLAG(frame_rate_category_mrr, "debug.sf.frame_rate_category_mrr")
-FLAG_MANAGER_ACONFIG_FLAG(misc1, "")
 FLAG_MANAGER_ACONFIG_FLAG(vrr_config, "debug.sf.enable_vrr_config")
 FLAG_MANAGER_ACONFIG_FLAG(hdcp_level_hal, "")
 FLAG_MANAGER_ACONFIG_FLAG(hdcp_negotiation, "debug.sf.hdcp_negotiation");
-FLAG_MANAGER_ACONFIG_FLAG(add_sf_skipped_frames_to_trace, "")
 FLAG_MANAGER_ACONFIG_FLAG(use_known_refresh_rate_for_fps_consistency, "")
 FLAG_MANAGER_ACONFIG_FLAG(cache_when_source_crop_layer_only_moved,
                           "debug.sf.cache_source_crop_only_moved")
-FLAG_MANAGER_ACONFIG_FLAG(enable_fro_dependent_features, "")
-FLAG_MANAGER_ACONFIG_FLAG(display_protected, "")
 FLAG_MANAGER_ACONFIG_FLAG(fp16_client_target, "debug.sf.fp16_client_target")
 FLAG_MANAGER_ACONFIG_FLAG(game_default_frame_rate, "")
 FLAG_MANAGER_ACONFIG_FLAG(enable_layer_command_batching, "debug.sf.enable_layer_command_batching")
 FLAG_MANAGER_ACONFIG_FLAG(vulkan_renderengine, "debug.renderengine.vulkan")
 FLAG_MANAGER_ACONFIG_FLAG(renderable_buffer_usage, "")
 FLAG_MANAGER_ACONFIG_FLAG(restore_blur_step, "debug.renderengine.restore_blur_step")
-FLAG_MANAGER_ACONFIG_FLAG(dont_skip_on_early_ro, "")
 FLAG_MANAGER_ACONFIG_FLAG(no_vsyncs_on_screen_off, "debug.sf.no_vsyncs_on_screen_off")
+FLAG_MANAGER_ACONFIG_FLAG(pacesetter_selection, "debug.sf.pacesetter_selection")
 FLAG_MANAGER_ACONFIG_FLAG(protected_if_client, "")
-FLAG_MANAGER_ACONFIG_FLAG(vrr_bugfix_24q4, "");
-FLAG_MANAGER_ACONFIG_FLAG(vrr_bugfix_dropped_frame, "")
 FLAG_MANAGER_ACONFIG_FLAG(graphite_renderengine, "debug.renderengine.graphite")
-FLAG_MANAGER_ACONFIG_FLAG(filter_frames_before_trace_starts, "")
-FLAG_MANAGER_ACONFIG_FLAG(latch_unsignaled_with_auto_refresh_changed, "");
 FLAG_MANAGER_ACONFIG_FLAG(deprecate_vsync_sf, "");
-FLAG_MANAGER_ACONFIG_FLAG(allow_n_vsyncs_in_targeter, "");
 FLAG_MANAGER_ACONFIG_FLAG(detached_mirror, "");
-FLAG_MANAGER_ACONFIG_FLAG(commit_not_composited, "");
+FLAG_MANAGER_ACONFIG_FLAG(disable_synthetic_vsync_for_performance, "");
 FLAG_MANAGER_ACONFIG_FLAG(correct_dpi_with_display_size, "");
 FLAG_MANAGER_ACONFIG_FLAG(local_tonemap_screenshots, "debug.sf.local_tonemap_screenshots");
 FLAG_MANAGER_ACONFIG_FLAG(override_trusted_overlay, "");
@@ -295,18 +273,23 @@ FLAG_MANAGER_ACONFIG_FLAG(display_config_error_hal, "");
 FLAG_MANAGER_ACONFIG_FLAG(connected_display_hdr, "debug.sf.connected_display_hdr");
 FLAG_MANAGER_ACONFIG_FLAG(deprecate_frame_tracker, "");
 FLAG_MANAGER_ACONFIG_FLAG(skip_invisible_windows_in_input, "");
+FLAG_MANAGER_ACONFIG_FLAG(stop_layer, "");
 FLAG_MANAGER_ACONFIG_FLAG(begone_bright_hlg, "debug.sf.begone_bright_hlg");
+FLAG_MANAGER_ACONFIG_FLAG(wb_virtualdisplay2, "");
 FLAG_MANAGER_ACONFIG_FLAG(window_blur_kawase2, "");
-FLAG_MANAGER_ACONFIG_FLAG(reject_dupe_layerstacks, "");
 FLAG_MANAGER_ACONFIG_FLAG(synced_resolution_switch, "");
 
 /// Trunk stable server (R/W) flags ///
 FLAG_MANAGER_ACONFIG_FLAG(refresh_rate_overlay_on_external_display, "")
+FLAG_MANAGER_ACONFIG_FLAG(adpf_cpu_effects_loadup, "");
 FLAG_MANAGER_ACONFIG_FLAG(adpf_gpu_sf, "")
 FLAG_MANAGER_ACONFIG_FLAG(adpf_native_session_manager, "");
 FLAG_MANAGER_ACONFIG_FLAG(graphite_renderengine_preview_rollout, "");
 FLAG_MANAGER_ACONFIG_FLAG(increase_missed_frame_jank_threshold, "");
 FLAG_MANAGER_ACONFIG_FLAG(monitor_buffer_fences, "");
+FLAG_MANAGER_ACONFIG_FLAG(readback_screenshot, "")
+FLAG_MANAGER_ACONFIG_FLAG(vsync_predictor_rate_change_with_aligned_sequence, "")
+FLAG_MANAGER_ACONFIG_FLAG(unify_refresh_rate_callbacks, "");
 FLAG_MANAGER_ACONFIG_FLAG(vsync_predictor_recovery, "");
 
 /// Trunk stable server (R/W) flags from outside SurfaceFlinger ///
@@ -314,12 +297,7 @@ FLAG_MANAGER_ACONFIG_FLAG_IMPORTED(adpf_use_fmq_channel, "", android::os)
 FLAG_MANAGER_ACONFIG_FLAG_IMPORTED(correct_virtual_display_power_state, "",
                                    android::companion::virtualdevice::flags)
 
-/// Trunk stable readonly flags from outside SurfaceFlinger ///
-FLAG_MANAGER_ACONFIG_FLAG_IMPORTED(idle_screen_refresh_rate_timeout, "",
-                                   com::android::server::display::feature::flags)
 FLAG_MANAGER_ACONFIG_FLAG_IMPORTED(adpf_use_fmq_channel_fixed, "", android::os)
-FLAG_MANAGER_ACONFIG_FLAG_IMPORTED(trace_frame_rate_override, "",
-                                   com::android::graphics::libgui::flags);
 FLAG_MANAGER_ACONFIG_FLAG_IMPORTED(luts_api, "",
                                    android::hardware::flags);
 } // namespace android
diff --git a/services/surfaceflinger/common/include/common/FlagManager.h b/services/surfaceflinger/common/include/common/FlagManager.h
index 72b3bc302a..867bca3265 100644
--- a/services/surfaceflinger/common/include/common/FlagManager.h
+++ b/services/surfaceflinger/common/include/common/FlagManager.h
@@ -16,9 +16,8 @@
 
 #pragma once
 
-#include <cstdint>
+#include <atomic>
 #include <functional>
-#include <mutex>
 #include <optional>
 #include <string>
 
@@ -26,15 +25,10 @@ namespace android {
 // Manages flags for SurfaceFlinger, including default values, system properties, and Mendel
 // experiment configuration values. Can be called from any thread.
 class FlagManager {
-private:
-    // Effectively making the constructor private, while allowing std::make_unique to work
-    struct ConstructorTag {};
-
 public:
     static const FlagManager& getInstance();
     static FlagManager& getMutableInstance();
 
-    FlagManager(ConstructorTag);
     virtual ~FlagManager();
 
     void markBootCompleted();
@@ -49,6 +43,7 @@ public:
     bool disable_sched_fifo_re() const;
     bool disable_sched_fifo_composer() const;
     bool disable_sched_fifo_composer_callback() const;
+    bool productionize_readback_screenshot() const;
 
     /// Legacy server flags ///
     bool test_flag() const;
@@ -56,6 +51,7 @@ public:
     bool use_skia_tracing() const;
 
     /// Trunk stable server (R/W) flags ///
+    bool adpf_cpu_effects_loadup() const;
     bool adpf_gpu_sf() const;
     bool adpf_native_session_manager() const;
     bool adpf_use_fmq_channel() const;
@@ -64,30 +60,27 @@ public:
     bool graphite_renderengine_preview_rollout() const;
     bool increase_missed_frame_jank_threshold() const;
     bool monitor_buffer_fences() const;
+    bool readback_screenshot() const;
     bool refresh_rate_overlay_on_external_display() const;
+    bool vsync_predictor_rate_change_with_aligned_sequence() const;
+    bool unify_refresh_rate_callbacks() const;
     bool vsync_predictor_recovery() const;
 
     /// Trunk stable readonly flags ///
     /// IMPORTANT - please keep alphabetize to reduce merge conflicts
-    bool add_sf_skipped_frames_to_trace() const;
     bool adpf_fmq_sf() const;
-    bool allow_n_vsyncs_in_targeter() const;
     bool arr_setframerate_gte_enum() const;
     bool begone_bright_hlg() const;
     bool cache_when_source_crop_layer_only_moved() const;
-    bool commit_not_composited() const;
     bool connected_display_hdr() const;
     bool correct_dpi_with_display_size() const;
     bool deprecate_frame_tracker() const;
     bool deprecate_vsync_sf() const;
     bool detached_mirror() const;
+    bool disable_synthetic_vsync_for_performance() const;
     bool display_config_error_hal() const;
-    bool display_protected() const;
-    bool dont_skip_on_early_ro() const;
-    bool enable_fro_dependent_features() const;
     bool enable_layer_command_batching() const;
     bool enable_small_area_detection() const;
-    bool filter_frames_before_trace_starts() const;
     bool flush_buffer_slots_to_uncache() const;
     bool force_compile_graphite_renderengine() const;
     bool fp16_client_target() const;
@@ -97,26 +90,23 @@ public:
     bool hdcp_level_hal() const;
     bool hdcp_negotiation() const;
     bool idle_screen_refresh_rate_timeout() const;
-    bool latch_unsignaled_with_auto_refresh_changed() const;
     bool local_tonemap_screenshots() const;
     bool luts_api() const;
-    bool misc1() const;
     bool no_vsyncs_on_screen_off() const;
     bool override_trusted_overlay() const;
+    bool pacesetter_selection() const;
     bool protected_if_client() const;
-    bool reject_dupe_layerstacks() const;
     bool renderable_buffer_usage() const;
     bool restore_blur_step() const;
     bool skip_invisible_windows_in_input() const;
     bool stable_edid_ids() const;
+    bool stop_layer() const;
     bool synced_resolution_switch() const;
-    bool trace_frame_rate_override() const;
     bool true_hdr_screenshots() const;
     bool use_known_refresh_rate_for_fps_consistency() const;
-    bool vrr_bugfix_24q4() const;
-    bool vrr_bugfix_dropped_frame() const;
     bool vrr_config() const;
     bool vulkan_renderengine() const;
+    bool wb_virtualdisplay2() const;
     bool window_blur_kawase2() const;
     /// IMPORTANT - please keep alphabetize to reduce merge conflicts
 
@@ -128,6 +118,7 @@ protected:
 private:
     friend class TestableFlagManager;
 
+    FlagManager() = default;
     FlagManager(const FlagManager&) = delete;
 
     void dumpFlag(std::string& result, bool readonly, const char* name,
@@ -135,8 +126,5 @@ private:
 
     std::atomic_bool mBootCompleted = false;
     std::atomic_bool mUnitTestMode = false;
-
-    static std::unique_ptr<FlagManager> mInstance;
-    static std::once_flag mOnce;
 };
 } // namespace android
diff --git a/services/surfaceflinger/main_surfaceflinger.cpp b/services/surfaceflinger/main_surfaceflinger.cpp
index 4afcd00ecb..863af176c8 100644
--- a/services/surfaceflinger/main_surfaceflinger.cpp
+++ b/services/surfaceflinger/main_surfaceflinger.cpp
@@ -149,8 +149,7 @@ int main() {
 
     // publish gui::ISurfaceComposer, the new AIDL interface
     sp<SurfaceComposerAIDL> composerAIDL = sp<SurfaceComposerAIDL>::make(flinger);
-    if (FlagManager::getInstance().misc1() &&
-        !FlagManager::getInstance().disable_sched_fifo_composer()) {
+    if (!FlagManager::getInstance().disable_sched_fifo_composer()) {
         composerAIDL->setMinSchedulerPolicy(SCHED_FIFO, newPriority);
     }
     sm->addService(String16("SurfaceFlingerAIDL"), composerAIDL, false,
diff --git a/services/surfaceflinger/surfaceflinger_flags.aconfig b/services/surfaceflinger/surfaceflinger_flags.aconfig
index 56bca7fb18..6020da9afe 100644
--- a/services/surfaceflinger/surfaceflinger_flags.aconfig
+++ b/services/surfaceflinger/surfaceflinger_flags.aconfig
@@ -3,14 +3,6 @@
 package: "com.android.graphics.surfaceflinger.flags"
 container: "system"
 
-flag {
-  name: "misc1"
-  namespace: "core_graphics"
-  description: "This flag controls minor miscellaneous SurfaceFlinger changes"
-  bug: "297389311"
-  is_fixed_read_only: true
-}
-
 flag {
   name: "connected_display"
   namespace: "core_graphics"
@@ -71,14 +63,6 @@ flag {
   is_fixed_read_only: true
 }
 
-flag {
-  name: "add_sf_skipped_frames_to_trace"
-  namespace: "core_graphics"
-  description: "Add SurfaceFlinger dropped Frames to frame timeline"
-  bug: "273701290"
-  is_fixed_read_only: true
-}
-
 # This file is locked and should not be changed. Use surfaceflinger_flags_new.aconfig
 
 flag {
@@ -116,22 +100,6 @@ flag {
   is_fixed_read_only: true
 }
 
-flag {
-  name: "enable_fro_dependent_features"
-  namespace: "core_graphics"
-  description: "enable frame rate override dependent features by default"
-  bug: "314217419"
-  is_fixed_read_only: true
-}
-
-flag {
-  name: "display_protected"
-  namespace: "core_graphics"
-  description: "Introduce protected displays to specify whether they should render protected content"
-  bug: "301647974"
-  is_fixed_read_only: true
-}
-
 flag {
   name: "fp16_client_target"
   namespace: "core_graphics"
@@ -200,17 +168,6 @@ flag {
 
 # This file is locked and should not be changed. Use surfaceflinger_flags_new.aconfig
 
-flag {
-  name: "dont_skip_on_early_ro"
-  namespace: "core_graphics"
-  description: "This flag is guarding the behaviour where SurfaceFlinger is trying to opportunistically present a frame when the configuration change from late to early"
-  bug: "273702768"
-  is_fixed_read_only: true
-  metadata {
-    purpose: PURPOSE_BUGFIX
-  }
-}
-
 flag {
   name: "protected_if_client"
   namespace: "core_graphics"
@@ -222,15 +179,4 @@ flag {
   }
 }
 
-flag {
-  name: "allow_n_vsyncs_in_targeter"
-  namespace: "core_graphics"
-  description: "This flag will enable utilizing N vsyncs in the FrameTargeter for past vsyncs"
-  bug: "308858993"
-  is_fixed_read_only: true
-  metadata {
-    purpose: PURPOSE_BUGFIX
-  }
-}
-
 # This file is locked and should not be changed. Use surfaceflinger_flags_new.aconfig
diff --git a/services/surfaceflinger/surfaceflinger_flags_new.aconfig b/services/surfaceflinger/surfaceflinger_flags_new.aconfig
index e8b75cfa6d..013a96fb96 100644
--- a/services/surfaceflinger/surfaceflinger_flags_new.aconfig
+++ b/services/surfaceflinger/surfaceflinger_flags_new.aconfig
@@ -3,6 +3,16 @@
 package: "com.android.graphics.surfaceflinger.flags"
 container: "system"
 
+flag {
+  name: "adpf_cpu_effects_loadup"
+  namespace: "window_surfaces"
+  description: "Enables CPU loadup hints for effects using client composition"
+  bug: "409887260"
+  metadata {
+    purpose: PURPOSE_BUGFIX
+  }
+} # adpf_cpu_effects_loadup
+
 flag {
   name: "adpf_fmq_sf"
   namespace: "game"
@@ -59,28 +69,6 @@ flag {
   is_fixed_read_only: true
 } # begone_bright_hlg
 
-flag {
-  name: "ce_fence_promise"
-  namespace: "window_surfaces"
-  description: "Moves logic for buffer release fences into LayerFE"
-  bug: "294936197"
-  is_fixed_read_only: true
-  metadata {
-    purpose: PURPOSE_BUGFIX
-  }
- } # ce_fence_promise
-
-flag {
-  name: "commit_not_composited"
-  namespace: "core_graphics"
-  description: "mark frames as non janky if the transaction resulted in no composition"
-  bug: "340633280"
-  is_fixed_read_only: true
-  metadata {
-    purpose: PURPOSE_BUGFIX
-  }
-} # commit_not_composited
-
 flag {
   name: "connected_display_hdr"
   namespace: "core_graphics"
@@ -133,6 +121,17 @@ flag {
   }
 } # detached_mirror
 
+flag {
+  name: "disable_synthetic_vsync_for_performance"
+  namespace: "core_graphics"
+  description: "Turn off synthetic VSYNC when adjusting thread scheduling for performance"
+  bug: "406147398"
+  metadata {
+    purpose: PURPOSE_BUGFIX
+  }
+  is_exported: true
+} # disable_synthetic_vsync_for_performance
+
 flag {
   name: "display_config_error_hal"
   namespace: "core_graphics"
@@ -141,17 +140,6 @@ flag {
   is_fixed_read_only: true
 } # display_config_error_hal
 
-flag {
-  name: "filter_frames_before_trace_starts"
-  namespace: "core_graphics"
-  description: "Do not trace FrameTimeline events for frames started before the trace started"
-  bug: "364194637"
-  is_fixed_read_only: true
-  metadata {
-    purpose: PURPOSE_BUGFIX
-  }
-} # filter_frames_before_trace_starts
-
 flag {
   name: "flush_buffer_slots_to_uncache"
   namespace: "core_graphics"
@@ -206,17 +194,6 @@ flag {
   bug: "342265411"
 } # increase_missed_frame_jank_threshold
 
-flag {
-  name: "latch_unsignaled_with_auto_refresh_changed"
-  namespace: "core_graphics"
-  description: "Ignore eAutoRefreshChanged with latch unsignaled"
-  bug: "331513837"
-  is_fixed_read_only: true
-  metadata {
-    purpose: PURPOSE_BUGFIX
-  }
-} # latch_unsignaled_with_auto_refresh_changed
-
 flag {
   name: "local_tonemap_screenshots"
   namespace: "core_graphics"
@@ -241,26 +218,18 @@ flag {
 } # no_vsyncs_on_screen_off
 
 flag {
-  name: "reject_dupe_layerstacks"
-  namespace: "window_surfaces"
-  description: "Reject duplicate layerstacks for displays"
-  bug: "370358572"
-  is_fixed_read_only: true
-  metadata {
-    purpose: PURPOSE_BUGFIX
-  }
- } # reject_dupe_layerstacks
+  name: "pacesetter_selection"
+  namespace: "desktop_display"
+  description: "Moves pacesetter designation to the display with highest refresh rate. Prefers to keep the same display as pacesetter if there are multiple displays of the same highest refresh rate."
+  bug: "374072507"
+} # pacesetter_selection
 
 flag {
-  name: "single_hop_screenshot"
-  namespace: "window_surfaces"
-  description: "Only access SF main thread once during a screenshot"
-  bug: "285553970"
-  is_fixed_read_only: true
-  metadata {
-    purpose: PURPOSE_BUGFIX
-  }
- } # single_hop_screenshot
+  name: "readback_screenshot"
+  namespace: "core_graphics"
+  description: "Allows devices to use DPU readback for fullscreen screenshots"
+  bug: "384816457"
+} # readback_screenshot
 
 flag {
   name: "skip_invisible_windows_in_input"
@@ -281,6 +250,14 @@ flag {
   is_fixed_read_only: true
 } # stable_edid_ids
 
+flag {
+    name: "stop_layer"
+    namespace: "window_surfaces"
+    description: "Enables stop layers when building layer snapshots"
+    bug: "403312802"
+    is_fixed_read_only: true
+} # stop_layer
+
 flag {
   name: "synced_resolution_switch"
   namespace: "core_graphics"
@@ -308,34 +285,24 @@ flag {
 } # override_trusted_overlay
 
 flag {
-  name: "view_set_requested_frame_rate_mrr"
-  namespace: "core_graphics"
-  description: "Enable to use frame rate category NoPreference with fixed frame rate vote on MRR devices"
-  bug: "352206100"
-  is_fixed_read_only: true
-} # view_set_requested_frame_rate_mrr
-
-flag {
-  name: "vrr_bugfix_24q4"
-  namespace: "core_graphics"
-  description: "bug fixes for VRR"
-  bug: "331513837"
-  is_fixed_read_only: true
-  metadata {
-    purpose: PURPOSE_BUGFIX
-  }
-} # vrr_bugfix_24q4
+    name: "unify_refresh_rate_callbacks"
+    namespace: "core_graphics"
+    description: "Unifies mode changed and FrameRateOverride callbacks"
+    bug: "399482301"
+    metadata {
+        purpose: PURPOSE_BUGFIX
+    }
+} # unify_refresh_rate_callbacks
 
 flag {
-  name: "vrr_bugfix_dropped_frame"
+  name: "vsync_predictor_rate_change_with_aligned_sequence"
   namespace: "core_graphics"
-  description: "bug fix for VRR dropped frame"
-  bug: "343603085"
-  is_fixed_read_only: true
+  description: "Render rate changes where all the frame rate overrides align"
+  bug: "377240935"
   metadata {
     purpose: PURPOSE_BUGFIX
   }
-} # vrr_bugfix_dropped_frame
+} # vsync_predictor_rate_change_with_aligned_sequence
 
 flag {
   name: "vsync_predictor_recovery"
@@ -347,6 +314,13 @@ flag {
   }
  } # vsync_predictor_recovery
 
+flag {
+  name: "wb_virtualdisplay2"
+  namespace: "core_graphics"
+  description: "When enabled, use VirtualDisplaySurface2 instead of the legacy one"
+  bug: "340933138"
+} # wb_virtualdisplay2
+
 flag {
   name: "window_blur_kawase2"
   namespace: "core_graphics"
diff --git a/services/surfaceflinger/tests/Binder_test.cpp b/services/surfaceflinger/tests/Binder_test.cpp
index 3152973da6..67bfcb6b84 100644
--- a/services/surfaceflinger/tests/Binder_test.cpp
+++ b/services/surfaceflinger/tests/Binder_test.cpp
@@ -92,8 +92,6 @@ void BinderTest::getDisplayEventConnectionSchedulingPolicy(gui::SchedulingPolicy
 }
 
 TEST_F(BinderTest, SchedulingPolicy) {
-    if (!flags::misc1()) GTEST_SKIP();
-
     const int policy = SCHED_FIFO;
     const int priority = sched_get_priority_min(policy);
 
@@ -116,8 +114,6 @@ TEST_F(BinderTest, NonAidlSchedulingPolicy) {
 }
 
 TEST_F(BinderTest, ClientSchedulingPolicy) {
-    if (!flags::misc1()) GTEST_SKIP();
-
     const int policy = SCHED_FIFO;
     const int priority = sched_get_priority_min(policy);
 
@@ -129,8 +125,6 @@ TEST_F(BinderTest, ClientSchedulingPolicy) {
 }
 
 TEST_F(BinderTest, DisplayEventConnectionSchedulingPolicy) {
-    if (!flags::misc1()) GTEST_SKIP();
-
     const int policy = SCHED_FIFO;
     const int priority = sched_get_priority_min(policy);
 
@@ -173,8 +167,6 @@ void BinderTestRtCaller::TearDown() {
 }
 
 TEST_F(BinderTestRtCaller, SchedulingPolicy) {
-    if (!flags::misc1()) GTEST_SKIP();
-
     const int policy = SCHED_FIFO;
     const int priority = sched_get_priority_min(policy);
 
@@ -197,8 +189,6 @@ TEST_F(BinderTestRtCaller, NonAidlSchedulingPolicy) {
 }
 
 TEST_F(BinderTestRtCaller, ClientSchedulingPolicy) {
-    if (!flags::misc1()) GTEST_SKIP();
-
     const int policy = SCHED_FIFO;
     const int priority = sched_get_priority_min(policy);
 
@@ -210,8 +200,6 @@ TEST_F(BinderTestRtCaller, ClientSchedulingPolicy) {
 }
 
 TEST_F(BinderTestRtCaller, DisplayEventConnectionSchedulingPolicy) {
-    if (!flags::misc1()) GTEST_SKIP();
-
     const int policy = SCHED_FIFO;
     const int priority = sched_get_priority_min(policy);
 
diff --git a/services/surfaceflinger/tests/BootDisplayMode_test.cpp b/services/surfaceflinger/tests/BootDisplayMode_test.cpp
index 222642f50c..84dec13ac6 100644
--- a/services/surfaceflinger/tests/BootDisplayMode_test.cpp
+++ b/services/surfaceflinger/tests/BootDisplayMode_test.cpp
@@ -65,13 +65,15 @@ protected:
     }
 
     void TearDown() override {
-        binder::Status status = mSf->setBootDisplayMode(mDisplayToken, mOldMode);
-        EXPECT_EQ(NO_ERROR, statusTFromBinderStatus(status));
-
-        gui::DynamicDisplayInfo info;
-        status = mSf->getDynamicDisplayInfoFromToken(mDisplayToken, &info);
-        EXPECT_EQ(NO_ERROR, statusTFromBinderStatus(status));
-        EXPECT_EQ(mOldMode, info.preferredBootDisplayMode);
+        if (!IsSkipped()) {
+            binder::Status status = mSf->setBootDisplayMode(mDisplayToken, mOldMode);
+            EXPECT_EQ(NO_ERROR, statusTFromBinderStatus(status));
+
+            gui::DynamicDisplayInfo info;
+            status = mSf->getDynamicDisplayInfoFromToken(mDisplayToken, &info);
+            EXPECT_EQ(NO_ERROR, statusTFromBinderStatus(status));
+            EXPECT_EQ(mOldMode, info.preferredBootDisplayMode);
+        }
     }
 
     ui::DisplayModeId mOldMode;
diff --git a/services/surfaceflinger/tests/BufferGenerator.cpp b/services/surfaceflinger/tests/BufferGenerator.cpp
index efab7b856a..beb5a1e19d 100644
--- a/services/surfaceflinger/tests/BufferGenerator.cpp
+++ b/services/surfaceflinger/tests/BufferGenerator.cpp
@@ -42,13 +42,8 @@ public:
      * through saved callback. */
     class BufferListener : public ConsumerBase::FrameAvailableListener {
     public:
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
         BufferListener(sp<BufferItemConsumer> consumer, BufferCallback callback)
-#else
-        BufferListener(sp<IGraphicBufferConsumer> consumer, BufferCallback callback)
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
-              : mConsumer(consumer), mCallback(callback) {
-        }
+              : mConsumer(consumer), mCallback(callback) {}
 
         void onFrameAvailable(const BufferItem& /*item*/) {
             BufferItem item;
@@ -60,11 +55,7 @@ public:
         }
 
     private:
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
         sp<BufferItemConsumer> mConsumer;
-#else
-        sp<IGraphicBufferConsumer> mConsumer;
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
         BufferCallback mCallback;
     };
 
@@ -72,7 +63,6 @@ public:
      * queue. */
     void initialize(uint32_t width, uint32_t height, android_pixel_format_t format,
                     BufferCallback callback) {
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
         mBufferItemConsumer = sp<BufferItemConsumer>::make(GraphicBuffer::USAGE_HW_TEXTURE);
         mBufferItemConsumer->setDefaultBufferSize(width, height);
         mBufferItemConsumer->setDefaultBufferFormat(format);
@@ -81,22 +71,6 @@ public:
         mBufferItemConsumer->setFrameAvailableListener(mListener);
 
         mSurface = mBufferItemConsumer->getSurface();
-#else
-        sp<IGraphicBufferProducer> producer;
-        sp<IGraphicBufferConsumer> consumer;
-        BufferQueue::createBufferQueue(&producer, &consumer);
-
-        consumer->setDefaultBufferSize(width, height);
-        consumer->setDefaultBufferFormat(format);
-
-        mBufferItemConsumer =
-                sp<BufferItemConsumer>::make(consumer, GraphicBuffer::USAGE_HW_TEXTURE);
-
-        mListener = sp<BufferListener>::make(consumer, callback);
-        mBufferItemConsumer->setFrameAvailableListener(mListener);
-
-        mSurface = sp<Surface>::make(producer, true);
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
     }
 
     /* Used by Egl manager. The surface is never displayed. */
diff --git a/services/surfaceflinger/tests/BufferGeneratorShader.h b/services/surfaceflinger/tests/BufferGeneratorShader.h
index 564cda3ccc..1914f9a8db 100644
--- a/services/surfaceflinger/tests/BufferGeneratorShader.h
+++ b/services/surfaceflinger/tests/BufferGeneratorShader.h
@@ -34,9 +34,9 @@ void main() {
 static const char* FRAGMENT_SHADER = R"SHADER__(#version 300 es
 precision highp float;
 
-layout(location = 0) uniform vec4 resolution;
-layout(location = 1) uniform float time;
-layout(location = 2) uniform vec3[4] SPHERICAL_HARMONICS;
+uniform vec4 resolution;
+uniform float time;
+uniform vec3[4] SPHERICAL_HARMONICS;
 
 layout(location = 0) out vec4 fragColor;
 
diff --git a/services/surfaceflinger/tests/DereferenceSurfaceControl_test.cpp b/services/surfaceflinger/tests/DereferenceSurfaceControl_test.cpp
index 192602d7d2..46b98f9193 100644
--- a/services/surfaceflinger/tests/DereferenceSurfaceControl_test.cpp
+++ b/services/surfaceflinger/tests/DereferenceSurfaceControl_test.cpp
@@ -52,8 +52,6 @@ protected:
 };
 
 TEST_F(DereferenceSurfaceControlTest, LayerNotInTransaction) {
-    // Last strong pointer is removed, the layer is destroyed and is removed
-    // from compostion.
     fgLayer = nullptr;
     {
         SCOPED_TRACE("after setting null");
@@ -63,9 +61,7 @@ TEST_F(DereferenceSurfaceControlTest, LayerNotInTransaction) {
 }
 
 TEST_F(DereferenceSurfaceControlTest, LayerInTransaction) {
-    Transaction transaction;
-    transaction.show(fgLayer);
-    // |transaction| retains a strong pointer, so layer is retained.
+    auto transaction = Transaction().show(fgLayer);
     fgLayer = nullptr;
     {
         SCOPED_TRACE("after setting null");
diff --git a/services/surfaceflinger/tests/IPC_test.cpp b/services/surfaceflinger/tests/IPC_test.cpp
index 94cb878311..18bd3b92d2 100644
--- a/services/surfaceflinger/tests/IPC_test.cpp
+++ b/services/surfaceflinger/tests/IPC_test.cpp
@@ -42,22 +42,14 @@ using CallbackInfo = SurfaceComposerClient::CallbackInfo;
 using TCLHash = SurfaceComposerClient::TCLHash;
 using android::hardware::graphics::common::V1_1::BufferUsage;
 
-class TransactionHelper : public Transaction, public Parcelable {
+class TransactionHelper : public Transaction {
 public:
-    TransactionHelper() : Transaction() {}
     size_t getNumListeners() { return mListenerCallbacks.size(); }
 
     std::unordered_map<sp<ITransactionCompletedListener>, CallbackInfo, TCLHash>
     getListenerCallbacks() {
         return mListenerCallbacks;
     }
-    status_t writeToParcel(Parcel* parcel) const override {
-        return Transaction::writeToParcel(parcel);
-    }
-
-    status_t readFromParcel(const Parcel* parcel) override {
-        return Transaction::readFromParcel(parcel);
-    }
 };
 
 class IPCTestUtils {
diff --git a/services/surfaceflinger/tests/LayerCallback_test.cpp b/services/surfaceflinger/tests/LayerCallback_test.cpp
index 5a8291413c..0bf2087308 100644
--- a/services/surfaceflinger/tests/LayerCallback_test.cpp
+++ b/services/surfaceflinger/tests/LayerCallback_test.cpp
@@ -52,7 +52,10 @@ public:
     }
 
     virtual sp<SurfaceControl> createLayerWithBuffer() {
-        return createLayer(mClient, "test", 0, 0, ISurfaceComposerClient::eFXSurfaceBufferState);
+        const std::string test_name = std::string("Test layer for ") +
+                ::testing::UnitTest::GetInstance()->current_test_info()->name();
+        return createLayer(mClient, test_name.c_str(), 0, 0,
+                           ISurfaceComposerClient::eFXSurfaceBufferState);
     }
 
     static int fillBuffer(Transaction& transaction, const sp<SurfaceControl>& layer,
@@ -85,7 +88,6 @@ public:
                 return err;
             }
         }
-
         transaction.addTransactionCompletedCallback(callbackHelper->function,
                                                     callbackHelper->getContext());
         return NO_ERROR;
@@ -170,7 +172,7 @@ TEST_F(LayerCallbackTest, BufferColor) {
     CallbackHelper callback;
     int err = fillTransaction(transaction, &callback, layer, true, true);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
 
@@ -189,7 +191,7 @@ TEST_F(LayerCallbackTest, NoBufferNoColor) {
     CallbackHelper callback;
     int err = fillTransaction(transaction, &callback, layer, false, false);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
 
@@ -212,7 +214,7 @@ TEST_F(LayerCallbackTest, BufferNoColor) {
     CallbackHelper callback;
     int err = fillTransaction(transaction, &callback, layer, true, false);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
 
@@ -234,7 +236,7 @@ TEST_F(LayerCallbackTest, NoBufferColor) {
     CallbackHelper callback;
     int err = fillTransaction(transaction, &callback, layer, false, true);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
 
@@ -254,7 +256,7 @@ TEST_F(LayerCallbackTest, NoStateChange) {
     CallbackHelper callback;
     int err = fillTransaction(transaction, &callback);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
 
@@ -272,7 +274,7 @@ TEST_F(LayerCallbackTest, OffScreen) {
     CallbackHelper callback;
     int err = fillTransaction(transaction, &callback, layer);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
 
@@ -295,12 +297,12 @@ TEST_F(LayerCallbackTest, MergeBufferNoColor) {
     CallbackHelper callback1, callback2;
     int err = fillTransaction(transaction1, &callback1, layer1);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
     err = fillTransaction(transaction2, &callback2, layer2);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
 
@@ -329,12 +331,12 @@ TEST_F(LayerCallbackTest, MergeNoBufferColor) {
     CallbackHelper callback1, callback2;
     int err = fillTransaction(transaction1, &callback1, layer1, false, true);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
     err = fillTransaction(transaction2, &callback2, layer2, false, true);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
 
@@ -364,12 +366,12 @@ TEST_F(LayerCallbackTest, MergeOneBufferOneColor) {
     CallbackHelper callback1, callback2;
     int err = fillTransaction(transaction1, &callback1, layer1);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
     err = fillTransaction(transaction2, &callback2, layer2, false, true);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
 
@@ -399,12 +401,12 @@ TEST_F(LayerCallbackTest, Merge_SameCallback) {
     CallbackHelper callback;
     int err = fillTransaction(transaction1, &callback, layer1);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
     err = fillTransaction(transaction2, &callback, layer2);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
 
@@ -424,12 +426,12 @@ TEST_F(LayerCallbackTest, Merge_SameLayer) {
     CallbackHelper callback1, callback2;
     int err = fillTransaction(transaction1, &callback1, layer);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
     err = fillTransaction(transaction2, &callback2, layer);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
 
@@ -458,12 +460,12 @@ TEST_F(LayerCallbackTest, Merge_DifferentClients) {
     CallbackHelper callback1, callback2;
     int err = fillTransaction(transaction1, &callback1, layer1);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
     err = fillTransaction(transaction2, &callback2, layer2);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
 
@@ -492,7 +494,7 @@ TEST_F(LayerCallbackTest, MultipleTransactions) {
     for (size_t i = 0; i < 10; i++) {
         int err = fillTransaction(transaction, &callback, layer);
         if (err) {
-            GTEST_SUCCEED() << "test not supported";
+            GTEST_FAIL() << "Error:" << err;
             return;
         }
 
@@ -520,14 +522,14 @@ TEST_F(LayerCallbackTest, MultipleTransactions_NoStateChange) {
         if (i == 0) {
             int err = fillTransaction(transaction, &callback, layer);
             if (err) {
-                GTEST_SUCCEED() << "test not supported";
+                GTEST_FAIL() << "Error:" << err;
                 return;
             }
             expected.addSurface(ExpectedResult::Transaction::PRESENTED, layer);
         } else {
             int err = fillTransaction(transaction, &callback);
             if (err) {
-                GTEST_SUCCEED() << "test not supported";
+                GTEST_FAIL() << "Error:" << err;
                 return;
             }
         }
@@ -549,13 +551,13 @@ TEST_F(LayerCallbackTest, MultipleTransactions_SameStateChange) {
         if (i == 0) {
             int err = fillTransaction(transaction, &callback, layer);
             if (err) {
-                GTEST_SUCCEED() << "test not supported";
+                GTEST_FAIL() << "Error:" << err;
                 return;
             }
         } else {
             int err = fillTransaction(transaction, &callback);
             if (err) {
-                GTEST_SUCCEED() << "test not supported";
+                GTEST_FAIL() << "Error:" << err;
                 return;
             }
         }
@@ -587,12 +589,12 @@ TEST_F(LayerCallbackTest, MultipleTransactions_Merge) {
     for (size_t i = 0; i < 10; i++) {
         int err = fillTransaction(transaction1, &callback1, layer1);
         if (err) {
-            GTEST_SUCCEED() << "test not supported";
+            GTEST_FAIL() << "Error:" << err;
             return;
         }
         err = fillTransaction(transaction2, &callback2, layer2);
         if (err) {
-            GTEST_SUCCEED() << "test not supported";
+            GTEST_FAIL() << "Error:" << err;
             return;
         }
 
@@ -636,12 +638,12 @@ TEST_F(LayerCallbackTest, MultipleTransactions_Merge_DifferentClients) {
     for (size_t i = 0; i < 10; i++) {
         int err = fillTransaction(transaction1, &callback1, layer1);
         if (err) {
-            GTEST_SUCCEED() << "test not supported";
+            GTEST_FAIL() << "Error:" << err;
             return;
         }
         err = fillTransaction(transaction2, &callback2, layer2);
         if (err) {
-            GTEST_SUCCEED() << "test not supported";
+            GTEST_FAIL() << "Error:" << err;
             return;
         }
 
@@ -686,12 +688,12 @@ TEST_F(LayerCallbackTest, MultipleTransactions_Merge_DifferentClients_NoStateCha
     // Normal call to set up test
     int err = fillTransaction(transaction1, &callback1, layer1);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
     err = fillTransaction(transaction2, &callback2, layer2);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
 
@@ -714,12 +716,12 @@ TEST_F(LayerCallbackTest, MultipleTransactions_Merge_DifferentClients_NoStateCha
     // Test
     err = fillTransaction(transaction1, &callback1);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
     err = fillTransaction(transaction2, &callback2);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
 
@@ -748,12 +750,12 @@ TEST_F(LayerCallbackTest, MultipleTransactions_Merge_DifferentClients_SameStateC
     // Normal call to set up test
     int err = fillTransaction(transaction1, &callback1, layer1);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
     err = fillTransaction(transaction2, &callback2, layer2);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
 
@@ -776,12 +778,12 @@ TEST_F(LayerCallbackTest, MultipleTransactions_Merge_DifferentClients_SameStateC
     // Test
     err = fillTransaction(transaction1, &callback1);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
     err = fillTransaction(transaction2, &callback2);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
 
@@ -812,7 +814,7 @@ TEST_F(LayerCallbackTest, DISABLED_MultipleTransactions_SingleFrame) {
 
         int err = fillTransaction(transaction, &callback, layer);
         if (err) {
-            GTEST_SUCCEED() << "test not supported";
+            GTEST_FAIL() << "Error:" << err;
             return;
         }
 
@@ -830,7 +832,7 @@ TEST_F(LayerCallbackTest, MultipleTransactions_SingleFrame_NoStateChange) {
     CallbackHelper callback;
     int err = fillTransaction(transaction, &callback, layer);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
 
@@ -847,7 +849,7 @@ TEST_F(LayerCallbackTest, MultipleTransactions_SingleFrame_NoStateChange) {
 
         err = fillTransaction(transaction, &callback);
         if (err) {
-            GTEST_SUCCEED() << "test not supported";
+            GTEST_FAIL() << "Error:" << err;
             return;
         }
 
@@ -865,7 +867,7 @@ TEST_F(LayerCallbackTest, MultipleTransactions_SingleFrame_SameStateChange) {
     CallbackHelper callback;
     int err = fillTransaction(transaction, &callback, layer);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
 
@@ -887,7 +889,7 @@ TEST_F(LayerCallbackTest, MultipleTransactions_SingleFrame_SameStateChange) {
 
         err = fillTransaction(transaction, &callback);
         if (err) {
-            GTEST_SUCCEED() << "test not supported";
+            GTEST_FAIL() << "Error:" << err;
             return;
         }
 
@@ -907,7 +909,7 @@ TEST_F(LayerCallbackTest, DesiredPresentTime) {
     CallbackHelper callback;
     int err = fillTransaction(transaction, &callback, layer);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
 
@@ -931,7 +933,7 @@ TEST_F(LayerCallbackTest, DesiredPresentTime_Multiple) {
     CallbackHelper callback1;
     int err = fillTransaction(transaction, &callback1, layer);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
 
@@ -948,7 +950,7 @@ TEST_F(LayerCallbackTest, DesiredPresentTime_Multiple) {
     CallbackHelper callback2;
     err = fillTransaction(transaction, &callback2, layer);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
 
@@ -977,7 +979,7 @@ TEST_F(LayerCallbackTest, DISABLED_DesiredPresentTime_OutOfOrder) {
     CallbackHelper callback1;
     int err = fillTransaction(transaction, &callback1, layer);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
 
@@ -994,7 +996,7 @@ TEST_F(LayerCallbackTest, DISABLED_DesiredPresentTime_OutOfOrder) {
     CallbackHelper callback2;
     err = fillTransaction(transaction, &callback2, layer);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
 
@@ -1021,7 +1023,7 @@ TEST_F(LayerCallbackTest, DesiredPresentTime_Past) {
     CallbackHelper callback;
     int err = fillTransaction(transaction, &callback, layer);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
 
@@ -1045,7 +1047,7 @@ TEST_F(LayerCallbackTest, ExpectedPresentTime) {
     CallbackHelper callback;
     int err = fillTransaction(transaction, &callback, layer);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
 
@@ -1073,7 +1075,7 @@ TEST_F(LayerCallbackTest, EmptyBufferStateChanges) {
     for (size_t i = 0; i < 10; i++) {
         int err = fillTransaction(transaction, &callback, bufferLayer);
         if (err) {
-            GTEST_SUCCEED() << "test not supported";
+            GTEST_FAIL() << "Error:" << err;
             return;
         }
 
@@ -1108,7 +1110,7 @@ TEST_F(LayerCallbackTest, DISABLED_NonBufferLayerStateChanges) {
     CallbackHelper callback;
     int err = fillTransaction(transaction, &callback);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
     transaction.setPosition(layer, 1, 2);
@@ -1130,7 +1132,7 @@ TEST_F(LayerCallbackTest, CommitCallbackOffscreenLayer) {
     int err = fillTransaction(transaction, &callback, layer, true);
     err |= fillBuffer(transaction, offscreenLayer);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
 
@@ -1157,7 +1159,7 @@ TEST_F(LayerCallbackTest, TransactionCommittedCallback_BSL) {
     CallbackHelper callback;
     int err = fillTransaction(transaction, &callback, layer, true);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
     transaction.addTransactionCommittedCallback(callback.function, callback.getContext()).apply();
@@ -1177,7 +1179,7 @@ TEST_F(LayerCallbackTest, TransactionCommittedCallback_EffectLayer) {
     CallbackHelper callback;
     int err = fillTransaction(transaction, &callback);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
     transaction.addTransactionCommittedCallback(callback.function, callback.getContext()).apply();
@@ -1197,7 +1199,7 @@ TEST_F(LayerCallbackTest, TransactionCommittedCallback_ContainerLayer) {
     CallbackHelper callback;
     int err = fillTransaction(transaction, &callback);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
     transaction.addTransactionCommittedCallback(callback.function, callback.getContext()).apply();
@@ -1213,7 +1215,7 @@ TEST_F(LayerCallbackTest, TransactionCommittedCallback_NoLayer) {
     CallbackHelper callback;
     int err = fillTransaction(transaction, &callback);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
     transaction.addTransactionCommittedCallback(callback.function, callback.getContext()).apply();
@@ -1233,7 +1235,7 @@ TEST_F(LayerCallbackTest, SetNullBuffer) {
     int err = fillTransaction(transaction, &callback, layer, /*setBuffer=*/true,
                               /*setBackgroundColor=*/false);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
     transaction.apply();
@@ -1261,17 +1263,21 @@ TEST_F(LayerCallbackTest, SetNullBuffer) {
     err = fillTransaction(transaction, &callback, layer, /*setBuffer=*/true,
                           /*setBackgroundColor=*/false);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
 
     transaction.apply();
 
     {
+        // TODO(b/294915480) Fix this as part of release buffer cleanup. We should not be passing a
+        // release fence in this case, because there is no buffer to release. We currently pass a
+        // release fence because of defensive code used to track screenshot work. Passing a fence
+        // here is odd but harmless.
         ExpectedResult expected;
         expected.addSurface(ExpectedResult::Transaction::PRESENTED, layer,
                             ExpectedResult::Buffer::ACQUIRED,
-                            ExpectedResult::PreviousBuffer::NOT_RELEASED);
+                            ExpectedResult::PreviousBuffer::RELEASED);
         EXPECT_NO_FATAL_FAILURE(waitForCallback(callback, expected, true));
     }
 }
@@ -1304,12 +1310,12 @@ TEST_F(LayerCallbackTest, OccludedLayerHasReleaseCallback) {
     CallbackHelper callback1a, callback1b, callback2a, callback2b;
     int err = fillTransaction(transaction1, &callback1a, layer1);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
     err = fillTransaction(transaction2, &callback2a, layer2);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
 
@@ -1338,12 +1344,12 @@ TEST_F(LayerCallbackTest, OccludedLayerHasReleaseCallback) {
     // Submit new buffers so previous buffers can be released
     err = fillTransaction(transaction1, &callback1b, layer1);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
     err = fillTransaction(transaction2, &callback2b, layer2);
     if (err) {
-        GTEST_SUCCEED() << "test not supported";
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
 
diff --git a/services/surfaceflinger/tests/LayerRenderTypeTransaction_test.cpp b/services/surfaceflinger/tests/LayerRenderTypeTransaction_test.cpp
index 4b3ad8ad5a..0e0063b163 100644
--- a/services/surfaceflinger/tests/LayerRenderTypeTransaction_test.cpp
+++ b/services/surfaceflinger/tests/LayerRenderTypeTransaction_test.cpp
@@ -1333,8 +1333,8 @@ TEST_P(LayerRenderTypeTransactionTest, DISABLED_SetFenceBasic_BufferState) {
     TransactionUtils::fillGraphicBufferColor(buffer, Rect(0, 0, 32, 32), Color::RED);
 
     sp<Fence> fence;
-    if (getBuffer(nullptr, &fence) != NO_ERROR) {
-        GTEST_SUCCEED() << "test not supported";
+    if (status_t err = getBuffer(nullptr, &fence) != NO_ERROR) {
+        GTEST_FAIL() << "Error:" << err;
         return;
     }
 
diff --git a/services/surfaceflinger/tests/LayerTypeAndRenderTypeTransaction_test.cpp b/services/surfaceflinger/tests/LayerTypeAndRenderTypeTransaction_test.cpp
index ada9862f23..e581440b41 100644
--- a/services/surfaceflinger/tests/LayerTypeAndRenderTypeTransaction_test.cpp
+++ b/services/surfaceflinger/tests/LayerTypeAndRenderTypeTransaction_test.cpp
@@ -749,6 +749,163 @@ TEST_P(LayerTypeAndRenderTypeTransactionTest, SetBorderSettings) {
     }
 }
 
+TEST_P(LayerTypeAndRenderTypeTransactionTest, SetBoxShadowSettings) {
+    sp<SurfaceControl> parent;
+    sp<SurfaceControl> child;
+    const uint32_t size = 64;
+    const uint32_t parentSize = size * 3;
+    ASSERT_NO_FATAL_FAILURE(parent = createLayer("parent", parentSize, parentSize));
+    ASSERT_NO_FATAL_FAILURE(fillLayerColor(parent, Color::WHITE, parentSize, parentSize));
+    ASSERT_NO_FATAL_FAILURE(child = createLayer("child", size, size));
+    ASSERT_NO_FATAL_FAILURE(fillLayerColor(child, Color::GREEN, size, size));
+
+    Transaction()
+            .setCrop(parent, Rect(0, 0, parentSize, parentSize))
+            .reparent(child, parent)
+            .setPosition(child, size, size)
+            .setCornerRadius(child, 20.0f)
+            .apply(true);
+
+    {
+        gui::BoxShadowSettings settings;
+        gui::BoxShadowSettings::BoxShadowParams boxShadow;
+        boxShadow.blurRadius = 20.0f;
+        boxShadow.spreadRadius = 20.0f;
+        boxShadow.color = 0xff000000;
+        boxShadow.offsetX = 0;
+        boxShadow.offsetY = 0;
+        settings.boxShadows.push_back(boxShadow);
+
+        Transaction().setBoxShadowSettings(child, settings).apply(true);
+
+        auto shot = getScreenCapture();
+
+        shot->expectBufferMatchesImageFromFile(Rect(0, 0, parentSize, parentSize),
+                                               "testdata/SetBoxShadowSettings_LargeBlur.png");
+    }
+
+    {
+        gui::BoxShadowSettings settings;
+        gui::BoxShadowSettings::BoxShadowParams boxShadow;
+        boxShadow.blurRadius = 5.0f;
+        boxShadow.spreadRadius = 20.0f;
+        boxShadow.color = 0xff0088ff;
+        boxShadow.offsetX = 20;
+        boxShadow.offsetY = -20;
+        settings.boxShadows.push_back(boxShadow);
+
+        Transaction().setBoxShadowSettings(child, settings).apply(true);
+
+        auto shot = getScreenCapture();
+
+        shot->expectBufferMatchesImageFromFile(Rect(0, 0, parentSize, parentSize),
+                                               "testdata/SetBoxShadowSettings_SmallBlur.png");
+    }
+
+    {
+        gui::BoxShadowSettings settings;
+        gui::BoxShadowSettings::BoxShadowParams boxShadow;
+        boxShadow.blurRadius = 5.0f;
+        boxShadow.spreadRadius = 10.0f;
+        boxShadow.color = 0xffff8888;
+        boxShadow.offsetX = 20;
+        boxShadow.offsetY = -20;
+        settings.boxShadows.push_back(boxShadow);
+
+        boxShadow.blurRadius = 5.0f;
+        boxShadow.spreadRadius = 10.0f;
+        boxShadow.color = 0xff8888ff;
+        boxShadow.offsetX = -20;
+        boxShadow.offsetY = 20;
+        settings.boxShadows.push_back(boxShadow);
+
+        Transaction().setBoxShadowSettings(child, settings).apply(true);
+
+        auto shot = getScreenCapture();
+
+        shot->expectBufferMatchesImageFromFile(Rect(0, 0, parentSize, parentSize),
+                                               "testdata/SetBoxShadowSettings_Multiple.png");
+    }
+
+    {
+        gui::BoxShadowSettings settings;
+        gui::BoxShadowSettings::BoxShadowParams boxShadow;
+        boxShadow.blurRadius = 5.0f;
+        boxShadow.spreadRadius = 20.0f;
+        boxShadow.color = 0xff8888ff;
+        boxShadow.offsetX = 20;
+        boxShadow.offsetY = -20;
+        settings.boxShadows.push_back(boxShadow);
+
+        Transaction().setBoxShadowSettings(child, settings).setAlpha(child, 0.2f).apply(true);
+
+        auto shot = getScreenCapture();
+
+        shot->expectBufferMatchesImageFromFile(Rect(0, 0, parentSize, parentSize),
+                                               "testdata/SetBoxShadowSettings_LayerAlpha.png");
+    }
+
+    {
+        gui::BoxShadowSettings settings;
+        gui::BoxShadowSettings::BoxShadowParams boxShadow;
+        boxShadow.blurRadius = 5.0f;
+        boxShadow.spreadRadius = 5.0f;
+        boxShadow.color = 0xff8888ff;
+        boxShadow.offsetX = 10;
+        boxShadow.offsetY = 10;
+        settings.boxShadows.push_back(boxShadow);
+
+        Transaction()
+                .setBoxShadowSettings(child, settings)
+                .setCornerRadius(child, 0)
+                .setAlpha(child, 1.0)
+                .apply(true);
+
+        auto shot = getScreenCapture();
+
+        shot->expectBufferMatchesImageFromFile(Rect(0, 0, parentSize, parentSize),
+                                               "testdata/SetBoxShadowSettings_Square.png");
+    }
+}
+
+TEST_P(LayerTypeAndRenderTypeTransactionTest, CropElevationShadowByParent) {
+    sp<SurfaceControl> parent;
+    sp<SurfaceControl> child;
+    const uint32_t size = 64;
+    const uint32_t parentSize = size * 3;
+    ASSERT_NO_FATAL_FAILURE(parent = createLayer("parent", parentSize, parentSize));
+    ASSERT_NO_FATAL_FAILURE(fillLayerColor(parent, Color::WHITE, parentSize, parentSize));
+    ASSERT_NO_FATAL_FAILURE(child = createLayer("child", size, size));
+    ASSERT_NO_FATAL_FAILURE(fillLayerColor(child, Color::BLUE, size, size));
+
+    SurfaceComposerClient::getDefault()->setGlobalShadowSettings({1, 0, 0, 0.5f}, {0, 1, 0, 0.5f},
+                                                                 0, 250.0f, 800.0f);
+
+    // Global shadow settings are committed after snapshot updates so we have to perform a commit
+    // before enabling layer shadows.
+    Transaction().apply(true);
+
+    ui::Size resolution = mRenderPathHarness.getRotatedResolution();
+    int x = resolution.width / 2;
+    int y = 500;
+
+    Transaction()
+            .setPosition(parent, x, y)
+            .setCrop(parent, Rect(0, 0, parentSize / 2, parentSize))
+            .reparent(child, parent)
+            .setPosition(child, size, size)
+            .setCrop(child, Rect(0, 0, size, size))
+            .setPosition(child, size, size)
+            .setCornerRadius(child, 20.0f)
+            .setShadowRadius(child, 20.0f)
+            .apply(true);
+
+    auto shot = getScreenCapture();
+
+    shot->expectBufferMatchesImageFromFile(Rect(x, y, x + parentSize, y + parentSize),
+                                           "testdata/CropElevationShadowByParent.png");
+}
+
 TEST_P(LayerTypeAndRenderTypeTransactionTest, SetBackgroundBlurRadiusSimple) {
     if (!deviceSupportsBlurs()) GTEST_SKIP();
     if (!deviceUsesSkiaRenderEngine()) GTEST_SKIP();
@@ -995,6 +1152,70 @@ TEST_P(LayerTypeAndRenderTypeTransactionTest, SetBufferFormat) {
         shot->expectColor(crop, Color::RED);
     }
 }
+
+class RotatedVirtualDisplayTest
+      : public LayerTypeTransactionHarness,
+        public ::testing::WithParamInterface<std::tuple<uint32_t, RenderPath, ui::Rotation>> {
+public:
+    RotatedVirtualDisplayTest()
+          : LayerTypeTransactionHarness(std::get<0>(GetParam())),
+            mRenderPathHarness(this, std::get<1>(GetParam()), std::get<2>(GetParam())) {}
+
+    std::unique_ptr<ScreenCapture> getScreenCapture() {
+        return mRenderPathHarness.getScreenCapture();
+    }
+
+protected:
+    LayerRenderPathTestHarness mRenderPathHarness;
+};
+
+INSTANTIATE_TEST_CASE_P(RotatedVirtualDisplayTests, RotatedVirtualDisplayTest,
+                        ::testing::Combine(::testing::Values(static_cast<uint32_t>(
+                                                   ISurfaceComposerClient::eFXSurfaceBufferState)),
+                                           ::testing::Values(RenderPath::VIRTUAL_DISPLAY),
+                                           ::testing::Values(ui::Rotation::Rotation0,
+                                                             ui::Rotation::Rotation90,
+                                                             ui::Rotation::Rotation180,
+                                                             ui::Rotation::Rotation270)));
+
+TEST_P(RotatedVirtualDisplayTest, ElevationShadowHasCorrectOrientation) {
+    sp<SurfaceControl> parent;
+    sp<SurfaceControl> child;
+    const uint32_t size = 64;
+    const uint32_t parentSize = size * 3;
+    ASSERT_NO_FATAL_FAILURE(parent = createLayer("parent", parentSize, parentSize));
+    ASSERT_NO_FATAL_FAILURE(fillLayerColor(parent, Color::WHITE, parentSize, parentSize));
+    ASSERT_NO_FATAL_FAILURE(child = createLayer("child", size, size));
+    ASSERT_NO_FATAL_FAILURE(fillLayerColor(child, Color::GREEN, size, size));
+
+    SurfaceComposerClient::getDefault()->setGlobalShadowSettings({1, 0, 0, 1.0f}, {0, 1, 0, 1.0f},
+                                                                 0, 500.0f, 800.0f);
+
+    // Global shadow settings are committed after snapshot updates so we have to perform a commit
+    // before enabling layer shadows.
+    Transaction().apply(true);
+
+    ui::Size resolution = mRenderPathHarness.getRotatedResolution();
+    int x = resolution.width / 2;
+    int y = 500;
+    Transaction()
+            .setPosition(parent, x, y)
+            .setCrop(parent, Rect(0, 0, parentSize, parentSize))
+            .reparent(child, parent)
+            .setCrop(child, Rect(0, 0, size, size))
+            .setPosition(child, size, size)
+            .setCornerRadius(child, 20.0f)
+            .setShadowRadius(child, 20.0f)
+            .apply(true);
+
+    auto shot = getScreenCapture();
+
+    shot->expectBufferMatchesImageFromFile(mRenderPathHarness.rotateRect(
+                                                   Rect(x, y, x + parentSize, y + parentSize)),
+                                           "testdata/Shadow_" +
+                                                   mRenderPathHarness.getRotationName() + ".png");
+}
+
 } // namespace android
 
 // TODO(b/129481165): remove the #pragma below and fix conversion issues
diff --git a/services/surfaceflinger/tests/LayerTypeTransaction_test.cpp b/services/surfaceflinger/tests/LayerTypeTransaction_test.cpp
index 76bae4116c..a0d0a24717 100644
--- a/services/surfaceflinger/tests/LayerTypeTransaction_test.cpp
+++ b/services/surfaceflinger/tests/LayerTypeTransaction_test.cpp
@@ -192,7 +192,10 @@ TEST_P(LayerTypeTransactionTest, RefreshRateIsInitialized) {
     FrameStats frameStats;
     mClient->getLayerFrameStats(handle, &frameStats);
 
-    ASSERT_GT(frameStats.refreshPeriodNano, static_cast<nsecs_t>(0));
+    // 10000 FPS is a decent upper limit.
+    ASSERT_GT(frameStats.refreshPeriodNano, static_cast<nsecs_t>(100000));
+    // 1 FPS is an unlikely lower limit
+    ASSERT_LT(frameStats.refreshPeriodNano, static_cast<nsecs_t>(1000000000));
 }
 
 } // namespace android
diff --git a/services/surfaceflinger/tests/MirrorLayer_test.cpp b/services/surfaceflinger/tests/MirrorLayer_test.cpp
index 6cc1c51cde..6c4aef0c3e 100644
--- a/services/surfaceflinger/tests/MirrorLayer_test.cpp
+++ b/services/surfaceflinger/tests/MirrorLayer_test.cpp
@@ -360,6 +360,35 @@ TEST_F(MirrorLayerTest, OffscreenMirrorScreenshot) {
     }
 }
 
+TEST_F(MirrorLayerTest, MirrorLayerWithStopLayer) {
+    if (!FlagManager::getInstance().stop_layer()) {
+        GTEST_SKIP() << "skipping test - stop_layer feature flag disabled";
+    }
+
+    sp<SurfaceControl> grandchild =
+            createColorLayer("Grandchild layer", Color::BLUE, mChildLayer.get());
+    Transaction()
+            .setFlags(grandchild, layer_state_t::eLayerOpaque, layer_state_t::eLayerOpaque)
+            .setCrop(grandchild, Rect(0, 0, 200, 200))
+            .show(grandchild)
+            .apply();
+
+    // Mirror child with stop layer set to grandchild.
+    sp<SurfaceControl> mirrorLayer = mClient->mirrorSurface(mChildLayer.get(), grandchild.get());
+    ASSERT_NE(mirrorLayer, nullptr);
+
+    // Add mirrorLayer as child of mParentLayer so it's shown on the display
+    Transaction()
+            .reparent(mirrorLayer, mParentLayer)
+            .setPosition(mirrorLayer, 500, 500)
+            .show(mirrorLayer)
+            .apply();
+
+    auto shot = screenshot();
+    // Assert that we see the child's color and not the grandchild's color
+    shot->expectColor(Rect(550, 550, 600, 600), Color::GREEN);
+}
+
 } // namespace android
 
 // TODO(b/129481165): remove the #pragma below and fix conversion issues
diff --git a/services/surfaceflinger/tests/MultiDisplay_test.cpp b/services/surfaceflinger/tests/MultiDisplay_test.cpp
index cf6d3282a1..9d30465cb1 100644
--- a/services/surfaceflinger/tests/MultiDisplay_test.cpp
+++ b/services/surfaceflinger/tests/MultiDisplay_test.cpp
@@ -18,7 +18,6 @@
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Wconversion"
 
-#include <common/FlagManager.h>
 #include <gui/IConsumerListener.h>
 #include <ui/DisplayState.h>
 
@@ -125,39 +124,14 @@ TEST_F(MultiDisplayTest, RenderLayerInVirtualDisplay) {
 }
 
 TEST_F(MultiDisplayTest, RenderLayerInMirroredVirtualDisplay) {
-    // Create a display and set its layer stack to the main display's layer stack so
-    // the contents of the main display are mirrored on to the virtual display.
-
-    // Assumption here is that the new mirrored display has the same layer stack rect as the
-    // primary display that it is mirroring.
-    createDisplay(mMainDisplayState.layerStackSpaceRect, ui::DEFAULT_LAYER_STACK);
-    createColorLayer(ui::DEFAULT_LAYER_STACK);
-
-    sp<SurfaceControl> mirrorSc =
-            SurfaceComposerClient::getDefault()->mirrorDisplay(mMainDisplayId);
-
-    asTransaction([&](Transaction& t) { t.setPosition(mColorLayer, 10, 10); });
-
-    // Verify color layer renders correctly on main display and it is mirrored on the
-    // virtual display.
-    std::unique_ptr<ScreenCapture> sc;
-    ScreenCapture::captureScreen(&sc, mMainDisplay);
-    sc->expectColor(Rect(10, 10, 40, 50), mExpectedColor);
-    sc->expectColor(Rect(0, 0, 9, 9), {0, 0, 0, 255});
-
-    ScreenCapture::captureScreen(&sc, mVirtualDisplay);
-    sc->expectColor(Rect(10, 10, 40, 50), mExpectedColor);
-    sc->expectColor(Rect(0, 0, 9, 9), {0, 0, 0, 255});
-}
-
-TEST_F(MultiDisplayTest, RenderLayerWithPromisedFenceInMirroredVirtualDisplay) {
     // Create a display and use a unique layerstack ID for mirrorDisplay() so
     // the contents of the main display are mirrored on to the virtual display.
 
     // A unique layerstack ID must be used because sharing the same layerFE
     // with more than one display is unsupported. A unique layerstack ensures
-    // that a different layerFE is used between displays.
-    constexpr ui::LayerStack layerStack{77687666}; // ASCII for MDLB (MultiDisplayLayerBounds)
+    // that a different layerFE is used between displays. Each layerFE has a
+    // promised fence that is each fulfilled.
+    constexpr ui::LayerStack layerStack{776884}; // ASCII for MDT (MultiDisplayTest)
     createDisplay(mMainDisplayState.layerStackSpaceRect, layerStack);
     createColorLayer(ui::DEFAULT_LAYER_STACK);
 
@@ -181,10 +155,7 @@ TEST_F(MultiDisplayTest, RenderLayerWithPromisedFenceInMirroredVirtualDisplay) {
     sc->expectColor(Rect(0, 0, 9, 9), {0, 0, 0, 255});
 }
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
 TEST_F(MultiDisplayTest, rejectDuplicateLayerStacks) {
-    if (!FlagManager::getInstance().reject_dupe_layerstacks()) return;
-
     // Setup
     sp<CpuConsumer> cpuConsumer1 = sp<CpuConsumer>::make(static_cast<size_t>(1));
     cpuConsumer1->setName(String8("consumer 1"));
@@ -225,7 +196,6 @@ TEST_F(MultiDisplayTest, rejectDuplicateLayerStacks) {
     ASSERT_EQ(NO_ERROR, cpuConsumer1->lockNextBuffer(&buffer1));
     ASSERT_NE(NO_ERROR, cpuConsumer2->lockNextBuffer(&buffer2));
 }
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
 } // namespace android
 
 // TODO(b/129481165): remove the #pragma below and fix conversion issues
diff --git a/services/surfaceflinger/tests/TransactionTestHarnesses.h b/services/surfaceflinger/tests/TransactionTestHarnesses.h
index c91f1ea760..906c7d1441 100644
--- a/services/surfaceflinger/tests/TransactionTestHarnesses.h
+++ b/services/surfaceflinger/tests/TransactionTestHarnesses.h
@@ -28,58 +28,42 @@ using android::hardware::graphics::common::V1_1::BufferUsage;
 
 class LayerRenderPathTestHarness {
 public:
-    LayerRenderPathTestHarness(LayerTransactionTest* delegate, RenderPath renderPath)
-          : mDelegate(delegate), mRenderPath(renderPath) {}
+    LayerRenderPathTestHarness(LayerTransactionTest* delegate, RenderPath renderPath,
+                               ui::Rotation virtualDisplayRotation = ui::Rotation::Rotation0)
+          : mDelegate(delegate), mRenderPath(renderPath) {
+        const auto ids = SurfaceComposerClient::getPhysicalDisplayIds();
+        mDisplayId = ids.front();
+        const auto displayToken =
+                ids.empty() ? nullptr : SurfaceComposerClient::getPhysicalDisplayToken(mDisplayId);
+
+        ui::DisplayState displayState;
+        SurfaceComposerClient::getDisplayState(displayToken, &displayState);
+
+        ui::DisplayMode displayMode;
+        SurfaceComposerClient::getActiveDisplayMode(displayToken, &displayMode);
+        mBufferSize = displayMode.resolution;
+
+        if (mRenderPath == RenderPath::VIRTUAL_DISPLAY) {
+            mRotation = virtualDisplayRotation;
+        } else {
+            mRotation = displayState.orientation;
+        }
+    }
 
     std::unique_ptr<ScreenCapture> getScreenCapture() {
         switch (mRenderPath) {
             case RenderPath::SCREENSHOT:
                 return mDelegate->screenshot();
             case RenderPath::VIRTUAL_DISPLAY:
-
-                const auto ids = SurfaceComposerClient::getPhysicalDisplayIds();
-                const PhysicalDisplayId displayId = ids.front();
-                const auto displayToken = ids.empty()
-                        ? nullptr
-                        : SurfaceComposerClient::getPhysicalDisplayToken(displayId);
-
-                ui::DisplayState displayState;
-                SurfaceComposerClient::getDisplayState(displayToken, &displayState);
-
-                ui::DisplayMode displayMode;
-                SurfaceComposerClient::getActiveDisplayMode(displayToken, &displayMode);
-                ui::Size resolution = displayMode.resolution;
-                if (displayState.orientation == ui::Rotation::Rotation90 ||
-                    displayState.orientation == ui::Rotation::Rotation270) {
-                    std::swap(resolution.width, resolution.height);
-                }
-
                 sp<IBinder> vDisplay;
 
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
                 sp<BufferItemConsumer> itemConsumer = sp<BufferItemConsumer>::make(
                         // Sample usage bits from screenrecord
                         GRALLOC_USAGE_HW_VIDEO_ENCODER | GRALLOC_USAGE_SW_READ_OFTEN);
                 sp<BufferListener> listener = sp<BufferListener>::make(this);
                 itemConsumer->setFrameAvailableListener(listener);
                 itemConsumer->setName(String8("Virtual disp consumer (TransactionTest)"));
-                itemConsumer->setDefaultBufferSize(resolution.getWidth(), resolution.getHeight());
-#else
-                sp<IGraphicBufferProducer> producer;
-                sp<IGraphicBufferConsumer> consumer;
-                sp<BufferItemConsumer> itemConsumer;
-                BufferQueue::createBufferQueue(&producer, &consumer);
-
-                consumer->setConsumerName(String8("Virtual disp consumer (TransactionTest)"));
-                consumer->setDefaultBufferSize(resolution.getWidth(), resolution.getHeight());
-
-                itemConsumer = sp<BufferItemConsumer>::make(consumer,
-                                                            // Sample usage bits from screenrecord
-                                                            GRALLOC_USAGE_HW_VIDEO_ENCODER |
-                                                                    GRALLOC_USAGE_SW_READ_OFTEN);
-                sp<BufferListener> listener = sp<BufferListener>::make(this);
-                itemConsumer->setFrameAvailableListener(listener);
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
+                itemConsumer->setDefaultBufferSize(mBufferSize.width, mBufferSize.height);
 
                 static const std::string kDisplayName("VirtualDisplay");
                 vDisplay = SurfaceComposerClient::createVirtualDisplay(kDisplayName,
@@ -88,17 +72,13 @@ public:
                 constexpr ui::LayerStack layerStack{
                         848472}; // ASCII for TTH (TransactionTestHarnesses)
                 sp<SurfaceControl> mirrorSc =
-                        SurfaceComposerClient::getDefault()->mirrorDisplay(displayId);
+                        SurfaceComposerClient::getDefault()->mirrorDisplay(mDisplayId);
 
                 SurfaceComposerClient::Transaction t;
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
                 t.setDisplaySurface(vDisplay,
                                     itemConsumer->getSurface()->getIGraphicBufferProducer());
-#else
-                t.setDisplaySurface(vDisplay, producer);
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
-                t.setDisplayProjection(vDisplay, ui::Rotation::Rotation0, Rect(resolution),
-                                       Rect(resolution));
+                t.setDisplayProjection(vDisplay, mRotation, Rect(getRotatedResolution()),
+                                       Rect(getRotatedResolution()));
                 t.setDisplayLayerStack(vDisplay, layerStack);
                 t.setLayerStack(mirrorSc, layerStack);
                 t.apply();
@@ -118,18 +98,36 @@ public:
 
                 // Possible race condition with destroying virtual displays, in which
                 // CompositionEngine::present may attempt to be called on the same
-                // display multiple times. The layerStack is set to invalid here so
+                // display multiple times. The layerStack is set as unassigned here so
                 // that the display is ignored if that scenario occurs.
-                t.setLayerStack(mirrorSc, ui::INVALID_LAYER_STACK);
+                t.setLayerStack(mirrorSc, ui::UNASSIGNED_LAYER_STACK);
                 t.apply(true);
                 SurfaceComposerClient::destroyVirtualDisplay(vDisplay);
                 return sc;
         }
     }
 
+    std::string getRotationName() const { return ui::toCString(mRotation); }
+
+    ui::Size getRotatedResolution() const {
+        ui::Size size = mBufferSize;
+        size.rotate(mRotation);
+        return size;
+    }
+
+    android::Rect rotateRect(const android::Rect& r) const {
+        ui::Transform transform;
+        transform.set(ui::Transform::toRotationFlags(mRotation), mBufferSize.width,
+                      mBufferSize.height);
+        return transform.transform(r);
+    }
+
 protected:
     LayerTransactionTest* mDelegate;
     RenderPath mRenderPath;
+    ui::Size mBufferSize;
+    PhysicalDisplayId mDisplayId;
+    ui::Rotation mRotation = ui::Rotation::Rotation0;
     std::mutex mMutex;
     std::condition_variable mCondition;
     bool mAvailable = false;
diff --git a/services/surfaceflinger/tests/VirtualDisplay_test.cpp b/services/surfaceflinger/tests/VirtualDisplay_test.cpp
index 1108c7fe56..467b54211c 100644
--- a/services/surfaceflinger/tests/VirtualDisplay_test.cpp
+++ b/services/surfaceflinger/tests/VirtualDisplay_test.cpp
@@ -27,20 +27,10 @@ namespace {
 class VirtualDisplayTest : public ::testing::Test {
 protected:
     void SetUp() override {
-#if COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
         mGLConsumer = sp<GLConsumer>::make(GLConsumer::TEXTURE_EXTERNAL, true, false, false);
         mGLConsumer->setName(String8("Virtual disp consumer (VirtualDisplayTest)"));
         mGLConsumer->setDefaultBufferSize(100, 100);
         mProducer = mGLConsumer->getSurface()->getIGraphicBufferProducer();
-#else
-        sp<IGraphicBufferConsumer> consumer;
-
-        BufferQueue::createBufferQueue(&mProducer, &consumer);
-        consumer->setConsumerName(String8("Virtual disp consumer (VirtualDisplayTest)"));
-        consumer->setDefaultBufferSize(100, 100);
-
-        mGLConsumer = sp<GLConsumer>::make(consumer, GLConsumer::TEXTURE_EXTERNAL, true, false);
-#endif // COM_ANDROID_GRAPHICS_LIBGUI_FLAGS(WB_CONSUMER_BASE_OWNS_BQ)
     }
 
     sp<IGraphicBufferProducer> mProducer;
diff --git a/services/surfaceflinger/tests/benchmarks/Android.bp b/services/surfaceflinger/tests/benchmarks/Android.bp
index 22fca08ccf..43e07e747b 100644
--- a/services/surfaceflinger/tests/benchmarks/Android.bp
+++ b/services/surfaceflinger/tests/benchmarks/Android.bp
@@ -10,9 +10,9 @@ package {
 cc_benchmark {
     name: "surfaceflinger_microbenchmarks",
     srcs: [
+        "*.cpp",
         ":libsurfaceflinger_mock_sources",
         ":libsurfaceflinger_sources",
-        "*.cpp",
     ],
     defaults: [
         "libsurfaceflinger_mocks_defaults",
@@ -28,3 +28,15 @@ cc_benchmark {
         "surfaceflinger_tests_common_headers",
     ],
 }
+
+cc_benchmark {
+    name: "surfaceflinger_microbenchmarks_host_supported",
+    srcs: [
+        "LocklessQueue_benchmarks.cpp",
+        "main.cpp",
+    ],
+    static_libs: [
+        "libgtest",
+    ],
+    host_supported: true,
+}
diff --git a/services/surfaceflinger/tests/benchmarks/LocklessQueue.h b/services/surfaceflinger/tests/benchmarks/LocklessQueue.h
new file mode 120000
index 0000000000..296b31fac7
--- /dev/null
+++ b/services/surfaceflinger/tests/benchmarks/LocklessQueue.h
@@ -0,0 +1 @@
+../../LocklessQueue.h
\ No newline at end of file
diff --git a/services/surfaceflinger/tests/benchmarks/LocklessQueue_benchmarks.cpp b/services/surfaceflinger/tests/benchmarks/LocklessQueue_benchmarks.cpp
index 60bd58acd5..75508af364 100644
--- a/services/surfaceflinger/tests/benchmarks/LocklessQueue_benchmarks.cpp
+++ b/services/surfaceflinger/tests/benchmarks/LocklessQueue_benchmarks.cpp
@@ -14,8 +14,9 @@
  * limitations under the License.
  */
 
-#include <memory>
 #include <optional>
+#include <utility>
+#include <vector>
 
 #include <benchmark/benchmark.h>
 
@@ -24,15 +25,18 @@
 namespace android::surfaceflinger {
 
 namespace {
+
 static void pushPop(benchmark::State& state) {
-    LocklessQueue<std::vector<uint32_t>> queue;
+    using ItemT = std::vector<int64_t>;
+    LocklessQueue<ItemT> queue;
+    ItemT item(size_t(state.range(0)), 42);
     for (auto _ : state) {
-        queue.push({10, 5});
-        std::vector<uint32_t> poppedValue = *queue.pop();
-        benchmark::DoNotOptimize(poppedValue);
+        queue.push(std::move(item));
+        item = std::move(*queue.pop());
+        benchmark::DoNotOptimize(item);
     }
 }
-BENCHMARK(pushPop);
+BENCHMARK(pushPop)->Range(1, 1048576);
 
 } // namespace
 } // namespace android::surfaceflinger
diff --git a/services/surfaceflinger/tests/common/LayerLifecycleManagerHelper.h b/services/surfaceflinger/tests/common/LayerLifecycleManagerHelper.h
index 1bee27be3f..6f7af9f46d 100644
--- a/services/surfaceflinger/tests/common/LayerLifecycleManagerHelper.h
+++ b/services/surfaceflinger/tests/common/LayerLifecycleManagerHelper.h
@@ -45,12 +45,13 @@ public:
         return args;
     }
 
-    static LayerCreationArgs createDisplayMirrorArgs(uint32_t id,
-                                                     ui::LayerStack layerStackToMirror) {
+    static LayerCreationArgs createDisplayMirrorArgs(uint32_t id, ui::LayerStack layerStackToMirror,
+                                                     uint32_t stopLayerId = UNASSIGNED_LAYER_ID) {
         LayerCreationArgs args(std::make_optional(id));
         args.name = "testlayer";
         args.addToRoot = true;
         args.layerStackToMirror = layerStackToMirror;
+        args.stopLayerId = stopLayerId;
         return args;
     }
 
@@ -94,10 +95,11 @@ public:
         mLifecycleManager.addLayers(std::move(layers));
     }
 
-    void createDisplayMirrorLayer(uint32_t id, ui::LayerStack layerStack) {
+    void createDisplayMirrorLayer(uint32_t id, ui::LayerStack layerStack,
+                                  uint32_t stopLayerId = UNASSIGNED_LAYER_ID) {
         std::vector<std::unique_ptr<RequestedLayerState>> layers;
         layers.emplace_back(std::make_unique<RequestedLayerState>(
-                createDisplayMirrorArgs(/*id=*/id, layerStack)));
+                createDisplayMirrorArgs(/*id=*/id, layerStack, stopLayerId)));
         mLifecycleManager.addLayers(std::move(layers));
     }
 
@@ -318,6 +320,17 @@ public:
         mLifecycleManager.applyTransactions(transactions);
     }
 
+    void setBackgroundBlurScale(uint32_t id, float backgroundBlurScale) {
+        std::vector<QueuedTransactionState> transactions;
+        transactions.emplace_back();
+        transactions.back().states.push_back({});
+
+        transactions.back().states.front().state.what = layer_state_t::eBackgroundBlurScaleChanged;
+        transactions.back().states.front().layerId = id;
+        transactions.back().states.front().state.backgroundBlurScale = backgroundBlurScale;
+        mLifecycleManager.applyTransactions(transactions);
+    }
+
     void setFrameRateSelectionPriority(uint32_t id, int32_t priority) {
         std::vector<QueuedTransactionState> transactions;
         transactions.emplace_back();
@@ -515,6 +528,17 @@ public:
         mLifecycleManager.applyTransactions(transactions);
     }
 
+    void setBoxShadowSettings(uint32_t id, gui::BoxShadowSettings settings) {
+        std::vector<QueuedTransactionState> transactions;
+        transactions.emplace_back();
+        transactions.back().states.push_back({});
+
+        transactions.back().states.front().state.what = layer_state_t::eBoxShadowSettingsChanged;
+        transactions.back().states.front().layerId = id;
+        transactions.back().states.front().state.boxShadowSettings = settings;
+        mLifecycleManager.applyTransactions(transactions);
+    }
+
     void setTrustedOverlay(uint32_t id, gui::TrustedOverlay trustedOverlay) {
         std::vector<QueuedTransactionState> transactions;
         transactions.emplace_back();
@@ -566,6 +590,16 @@ public:
         mLifecycleManager.applyTransactions(transactions);
     }
 
+    void setStopLayer(uint32_t id, uint32_t stopLayerId) {
+        std::vector<QueuedTransactionState> transactions;
+        transactions.emplace_back();
+        transactions.back().states.emplace_back();
+        transactions.back().states.back().layerId = id;
+        transactions.back().states.back().state.what = layer_state_t::eStopLayerChanged;
+        transactions.back().states.back().stopLayerId = stopLayerId;
+        mLifecycleManager.applyTransactions(transactions);
+    }
+
 private:
     LayerLifecycleManager& mLifecycleManager;
 };
diff --git a/services/surfaceflinger/tests/end2end/Android.bp b/services/surfaceflinger/tests/end2end/Android.bp
index 8810330179..1e59cc4850 100644
--- a/services/surfaceflinger/tests/end2end/Android.bp
+++ b/services/surfaceflinger/tests/end2end/Android.bp
@@ -12,6 +12,10 @@ cc_test {
     test_suites: ["device-tests"],
     require_root: true,
 
+    defaults: [
+        "android.hardware.graphics.common-ndk_static",
+    ],
+
     cpp_std: "experimental",
     cflags: [
         "-DANDROID_UTILS_REF_BASE_DISABLE_IMPLICIT_CONSTRUCTION",
@@ -32,10 +36,29 @@ cc_test {
     ],
     srcs: [
         "main.cpp",
+        "test_framework/core/BufferId.cpp",
+        "test_framework/core/EdidBuilder.cpp",
         "test_framework/core/TestService.cpp",
-        "test_framework/fake_hwc3/Hwc3Composer.cpp",
-        "test_framework/fake_hwc3/Hwc3Controller.cpp",
+        "test_framework/hwc3/DisplayVSyncEventService.cpp",
+        "test_framework/hwc3/FakeComposer.cpp",
+        "test_framework/hwc3/Hwc3Controller.cpp",
+        "test_framework/hwc3/MultiDisplayRefreshEventGenerator.cpp",
+        "test_framework/hwc3/ObservingComposer.cpp",
+        "test_framework/hwc3/SingleDisplayRefreshEventGenerator.cpp",
+        "test_framework/hwc3/SingleDisplayRefreshSchedule.cpp",
+        "test_framework/hwc3/TimeKeeperThread.cpp",
+        "test_framework/surfaceflinger/DisplayEventReceiver.cpp",
+        "test_framework/surfaceflinger/PollFdThread.cpp",
         "test_framework/surfaceflinger/SFController.cpp",
+        "test_framework/surfaceflinger/SimpleBufferPool.cpp",
+        "test_framework/surfaceflinger/Surface.cpp",
+
+        // Internal tests
+        "tests/internal/AsyncFunction_test.cpp",
+        "tests/internal/DisplayRefresh_test.cpp",
+        "tests/internal/EdidBuilder_test.cpp",
+
+        // SurfaceFlinger tests
         "tests/Placeholder_test.cpp",
     ],
     tidy: true,
@@ -61,7 +84,6 @@ cc_test {
     ],
     static_libs: [
         "android.hardware.common-V2-ndk",
-        "android.hardware.graphics.common-V6-ndk",
         "android.hardware.graphics.composer3-V3-ndk",
         "libgtest",
     ],
diff --git a/services/surfaceflinger/tests/end2end/test_framework/core/AsyncFunction.h b/services/surfaceflinger/tests/end2end/test_framework/core/AsyncFunction.h
new file mode 100644
index 0000000000..443a3ec487
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/core/AsyncFunction.h
@@ -0,0 +1,280 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <cstddef>
+#include <functional>
+#include <memory>
+#include <mutex>
+#include <optional>
+#include <type_traits>
+#include <utility>
+
+#include <android-base/thread_annotations.h>
+#include <ftl/finalizer.h>
+#include <ftl/function.h>
+
+namespace android::surfaceflinger::tests::end2end::test_framework::core {
+
+// Define a function wrapper class that has some special features to make it async safe.
+//
+// 1) The contained function is only called on one thread at a time.
+// 2) The contained function can be safely replaced at any time.
+// 3) This wrapper helps ensure that after replacement, all calls to the replaced function are
+//    complete by a well-defined synchronization point, which can be deferred to happen outside of
+//    mutex locks that might otherwise cause a deadlock.
+//
+// To achieve the last feature, the `set` function to perform replacement returns a special
+// `Finalizer` instance which is either automatically invoked on destruction, or on demand via
+// `operator()` with no arguments (and returning no value). When invoked, the finalizer waits for
+// any calls to the replaced function to complete, and as the finalizer can be moved if needed, this
+// wait can be done without other mutexes being held that might cause a deadlock in the replaced
+// function.
+//
+// Once the finalizer completes, any resources needed only by the previous function can be
+// safely destroyed. The finalizer also destroys any captured state that was part of the
+// previous function.
+//
+// Note that the target function that is called by this wrapper is allowed to replace the function
+// this wrapper contains. When this happens there is no synchronization point, as waiting for the
+// replaced function to complete as part of what is executed while it is invoked would be a
+// deadlock. For this case, the returned finalizer instance is a no-op if invoked. Instead the
+// capture for the prior function will be destroyed when the control returns back to the wrapper,
+// before control returns to the code that invoked the wrapper.
+//
+// Instances of this class can be default constructed, and invoking the contained function in this
+// state does nothing, and also requires no synchronization point when replaced by an actual target.
+// After being set, this state can be entered again by using the `clear()` member function.
+//
+// If the contained function has a return type T other than void, the return type of the wrapper
+// will be std::optional<T>. If there is no target set, invoking the wrapper will return a
+// std::nullopt value, otherwise it will return an optional with the value set to the value returned
+// by the contained function.
+//
+// Usage:
+//
+//    AsyncFunctionStd<void()> function = [this](){
+//        std_lock_guard lock(mutex);
+//        someMemberFunction();
+//    };
+//
+//    function(); // Invokes someMemberFunction();
+//
+//    // May invoke someMemberFunction or otherMemberFunction (set below).
+//    std::async(std::launch::async, function);
+//
+//    ftl::AsyncFunctionStd<void()>::Finalizer finalizer;
+//    {
+//        std_lock_guard lock(mutex);
+//        finalizer = function.set([this](){
+//            std_lock_guard lock(mutex);
+//            otherMemberFunction();
+//        });
+//        // do not invoke the finalizer with locks held, unless there is no chance of a deadlock.
+//    }
+//    function()    // Invokes instance2->otherMemberFunction();
+//    finalizer();  // Waits for calls to someMemberFunction to complete
+//    // It is now safe to destroy resources that are used by someMemberFunction.
+//
+//    std::ignore = function.clear();  // Clear the function and implicitly invoke the returned
+//    finalizer.
+//    // It is now safe to destroy resource that used used by otherMemberFunction, including
+//    // 'this' if desired.
+//
+template <typename Function>
+class AsyncFunction final {
+    struct SharedFunction;
+
+    // Turns some return type `T` into `std::optional<T>`, unless `T` is `void`.
+    template <typename T>
+    using AddOptionalUnlessVoid = std::conditional_t<std::is_void_v<T>, T, std::optional<T>>;
+
+  public:
+    using Finalizer = ftl::FinalizerStd;
+
+    // The return type from `operator()`.
+    using result_type = AddOptionalUnlessVoid<typename Function::result_type>;
+
+    // Default construct an empty state.
+    AsyncFunction() = default;
+
+    ~AsyncFunction() {
+        // Ensure any outstanding calls complete before teardown by clearing the shared_ptr. Note
+        // however if there are any, there would likely be other problems since the owning class is
+        // in the process of being destroyed.
+        setInternal(nullptr)();
+    }
+
+    // For simplicity, copying and moving are not possible.
+    AsyncFunction(const AsyncFunction&) = delete;
+    auto operator=(const AsyncFunction&) = delete;
+    AsyncFunction(AsyncFunction&&) = delete;
+    auto operator=(AsyncFunction&&) = delete;
+
+    // Constructs an AsyncFunction from the function type.
+    template <typename NewFunction>
+        requires(!std::is_same_v<std::remove_cvref_t<NewFunction>, AsyncFunction> &&
+                 std::is_constructible_v<Function, NewFunction>)
+    // NOLINTNEXTLINE(google-explicit-constructor)
+    explicit(false) AsyncFunction(NewFunction&& function)
+        : mShared(std::make_shared<SharedFunction>(std::forward<NewFunction>(function))) {}
+
+    // Replaces the contained function value with a new one.
+    //
+    // Returns a finalizer which when invoked waits for calls to the old function value
+    // complete. This is done so that the caller can invoke the caller without locks held
+    // that might block the call from completing,
+    template <typename NewFunction>
+        requires(std::is_constructible_v<Function, NewFunction>)
+    [[nodiscard]] auto set(NewFunction&& function) -> Finalizer {
+        return setInternal(std::make_shared<SharedFunction>(std::forward<NewFunction>(function)));
+    }
+
+    // Clears the contained function value.
+    //
+    // Returns a finalizer which when invoked waits for calls to the old function value
+    // complete. This is done so that the caller can invoke the caller without locks held
+    // that might block the call from completing,
+    [[nodiscard]] auto clear() -> Finalizer { return setInternal(nullptr); }
+
+    // Invoke the contained function, if set.
+    template <typename... Args>
+        requires(std::is_invocable_v<Function, Args...>)
+    auto operator()(Args&&... args) const -> result_type {
+        // We might need to retry the process to forward the call if we happen to obtain a zombie
+        // shared_ptr. We try at least once.
+        bool retry = true;
+        while (std::exchange(retry, false)) {
+            // To avoid deadlocks, the call to the contained function must be made on a copy of the
+            // shared_ptr without the internal locks on the source shared_ptr member data.
+            const auto shared = copy();
+
+            // Confirm we got a non-null pointer before continuing. The pointer can be null if no
+            // target is set.
+            if (shared == nullptr) {
+                break;
+            }
+
+            // We must hold shared->callingMutex before accessing the other fields it contains.
+            std::lock_guard lock(shared->callingMutex);
+
+            // Now that the calling mutex is held, confirm it is valid to use.
+            if (!shared->valid) [[unlikely]] {
+                // If the pointer isn't valid, we must retry to get a new copy.
+                // It indicates another thread set a new target by setting a new pointer after we
+                // made our copy, but before we acquired `callingMutex`. Our pointer is effectively
+                // a zombie, and must not be used.
+                retry = true;
+                continue;
+            }
+
+            // If `Function` can be (possibly explicitly) converted to bool, it is used as a check
+            // at runtime that the function is safe to invoke.
+            if constexpr (std::is_constructible_v<bool, Function>) {
+                if (!shared->function) {
+                    break;
+                }
+            }
+
+            // Forward the call. Note that callingMutex must be held for the duration of the call.
+            return std::invoke(shared->function, std::forward<Args>(args)...);
+        }
+
+        // If we reached this point, we had no target to invoke.
+        if constexpr (!std::is_void_v<std::invoke_result_t<Function, Args...>>) {
+            // If the function was supposed to return a value, we explicitly return `std::nullopt`
+            // rather than manufacturing a value of some arbitrary type (perhaps by default
+            // construction).
+            return std::nullopt;
+        }
+    }
+
+  private:
+    struct SharedFunction final {
+        SharedFunction() = default;
+
+        template <typename NewFunction>
+            requires(!std::is_same_v<NewFunction, SharedFunction>)
+        explicit SharedFunction(NewFunction&& newFunction)
+            : function(std::forward<NewFunction>(newFunction)) {}
+
+        // NOLINTBEGIN(misc-non-private-member-variables-in-classes)
+
+        // `callingMutex` must be held for the duration that `function` is invoked.
+        mutable std::recursive_mutex callingMutex;
+        const Function function;  // NOLINT(cppcoreguidelines-avoid-const-or-ref-data-members)
+        // If valid is false, it means the shared pointer was exchanged to point at a new value, and
+        // the function here is no longer safe to invoke.
+        bool valid = true;  // GUARDED_BY(callingMutex)
+
+        // NOLINTEND(misc-non-private-member-variables-in-classes)
+    };
+
+    [[nodiscard]] auto setInternal(std::shared_ptr<SharedFunction> newShared) -> Finalizer {
+        // To avoid deadlocks, the old instance MUST be destroyed outside of all locks, including
+        // locks held by the caller. It is the caller's responsibility to invoke the returned
+        // finalizer outside of any locks being holds.
+        std::shared_ptr<SharedFunction> prior = exchange(std::move(newShared));
+
+        return Finalizer([prior = std::move(prior)]() {
+            if (prior) {
+                // Wait for any call to complete.
+                // Note that callingMutex is a recursive_mutex so that we won't deadlock if the
+                // current thread is already holding the same lock.
+                std::lock_guard lock(prior->callingMutex);
+                // Mark the function as no longer valid to call, on the off chance another thread
+                // obtained a copy just before this thread did the exchange.
+                prior->valid = false;
+            }
+        });
+    }
+
+    [[nodiscard]] auto exchange(std::shared_ptr<SharedFunction>&& newShared)
+            -> std::shared_ptr<SharedFunction> {
+        std::lock_guard lock(mMutex);
+        return std::exchange(mShared, std::move(newShared));
+    }
+
+    [[nodiscard]] auto copy() const -> std::shared_ptr<SharedFunction> {
+        std::lock_guard lock(mMutex);
+        return mShared;
+    }
+
+    // In the future, maybe this can become `std::atomic<std::shared_ptr<Function>>`.
+    mutable std::mutex mMutex;
+    std::shared_ptr<SharedFunction> mShared GUARDED_BY(mMutex);
+};
+
+template <typename Function>
+AsyncFunction(Function&&) -> AsyncFunction<std::decay_t<Function>>;
+
+template <typename Signature>
+using AsyncFunctionStd = AsyncFunction<std::function<Signature>>;
+
+template <typename Signature>
+using AsyncFunctionFtl = AsyncFunction<ftl::Function<Signature>>;
+
+template <typename Signature>
+using AsyncFunctionFtl1 = AsyncFunction<ftl::Function<Signature, 1>>;
+
+template <typename Signature>
+using AsyncFunctionFtl2 = AsyncFunction<ftl::Function<Signature, 2>>;
+
+template <typename Signature>
+using AsyncFunctionFtl3 = AsyncFunction<ftl::Function<Signature, 3>>;
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::core
diff --git a/services/surfaceflinger/tests/end2end/test_framework/core/BufferId.cpp b/services/surfaceflinger/tests/end2end/test_framework/core/BufferId.cpp
new file mode 100644
index 0000000000..570679271c
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/core/BufferId.cpp
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <cstdint>
+#include <string>
+
+#include <sys/stat.h>
+
+#include <aidl/android/hardware/common/NativeHandle.h>
+#include <android-base/logging.h>
+#include <cutils/native_handle.h>
+#include <fmt/format.h>
+#include <ftl/cast.h>
+#include <ui/GraphicBuffer.h>
+#include <utils/StrongPointer.h>
+
+#include "test_framework/core/BufferId.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::core {
+namespace {
+
+auto bufferFdToBufferId(int rawFd) -> BufferId {
+    struct stat stat{};
+    const int result = fstat(rawFd, &stat);
+    CHECK(result == 0);
+    CHECK(ftl::cast_safety<uint64_t>(stat.st_ino) == ftl::CastSafety::kSafe);
+    CHECK(ftl::cast_safety<uint64_t>(stat.st_dev) == ftl::CastSafety::kSafe);
+    return {.inode = static_cast<uint64_t>(stat.st_ino),
+            .device = static_cast<uint64_t>(stat.st_dev)};
+}
+
+}  // namespace
+
+auto toBufferId(const aidl::android::hardware::common::NativeHandle& handle) -> BufferId {
+    CHECK(!handle.fds.empty());
+    return bufferFdToBufferId(handle.fds[0].get());
+}
+
+auto toBufferId(const native_handle_t* handle) -> BufferId {
+    CHECK(handle != nullptr);
+    CHECK(handle->numFds > 0);
+    return bufferFdToBufferId(handle->data[0]);
+}
+
+auto toBufferId(const sp<GraphicBuffer>& buffer) -> BufferId {
+    CHECK(buffer != nullptr);
+    return toBufferId(buffer->getNativeBuffer()->handle);
+}
+
+auto toString(const BufferId& value) -> std::string {
+    return fmt::format("BufferId{{inode: {}, device: {}}}", value.inode, value.device);
+}
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::core
\ No newline at end of file
diff --git a/services/surfaceflinger/tests/end2end/test_framework/core/BufferId.h b/services/surfaceflinger/tests/end2end/test_framework/core/BufferId.h
new file mode 100644
index 0000000000..2fa0a98c88
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/core/BufferId.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <cstdint>
+#include <string>
+
+#include <aidl/android/hardware/common/NativeHandle.h>
+#include <cutils/native_handle.h>
+#include <ui/GraphicBuffer.h>
+#include <utils/StrongPointer.h>
+
+namespace android::surfaceflinger::tests::end2end::test_framework::core {
+
+struct BufferId final {
+    uint64_t inode;
+    uint64_t device;
+
+    friend auto operator==(const BufferId&, const BufferId&) -> bool = default;
+};
+
+auto toBufferId(const native_handle_t* handle) -> BufferId;
+auto toBufferId(const sp<GraphicBuffer>& buffer) -> BufferId;
+auto toBufferId(const aidl::android::hardware::common::NativeHandle& handle) -> BufferId;
+
+auto toString(const BufferId& value) -> std::string;
+
+inline auto format_as(const BufferId& event) -> std::string {
+    return toString(event);
+}
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::core
diff --git a/services/surfaceflinger/tests/end2end/test_framework/core/EdidBuilder.cpp b/services/surfaceflinger/tests/end2end/test_framework/core/EdidBuilder.cpp
new file mode 100644
index 0000000000..454530c372
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/core/EdidBuilder.cpp
@@ -0,0 +1,736 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <algorithm>
+#include <array>
+#include <bit>
+#include <cassert>
+#include <cstddef>
+#include <cstdint>
+#include <cstdlib>
+#include <limits>
+#include <numeric>
+#include <span>
+#include <string_view>
+#include <tuple>
+#include <utility>
+
+#include <android-base/logging.h>
+#include <ftl/enum.h>
+#include <ui/Size.h>
+
+#include "test_framework/core/EdidBuilder.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::core {
+
+namespace {
+
+constexpr unsigned kDescriptor1Offset = 54;
+constexpr unsigned kDescriptorSize = 18;
+constexpr unsigned kDescriptorEndOffset = 126;
+
+// The base EDID binary format is full of values where the bits are packed non-contiguously.
+//
+// This function helps select specific contiguous bits from an input integer value, and optionally
+// shifts them so they can be combined with other bits.
+//
+// `kInMask` specifies the bits of interest from the integer value.
+// `kOutMask` specifies the output mask, helping document where in the output byte those bits go.
+//
+template <uint32_t kInMask, uint32_t kOutMask = std::numeric_limits<uint8_t>::max()>
+constexpr auto select(uint32_t value) -> uint32_t {
+    static_assert(kInMask > 0);   // Must not be zero bits
+    static_assert(kOutMask > 0);  // Must not be zero bits
+    // The number of bits in each mask must be the same
+    static_assert(std::popcount(kInMask) == std::popcount(kOutMask));
+    // The bits in each mask must be contiguous
+    static_assert(std::popcount(kInMask) == std::countr_one(kInMask >> std::countr_zero(kInMask)));
+    static_assert(std::popcount(kOutMask) ==
+                  std::countr_one(kOutMask >> std::countr_zero(kOutMask)));
+
+    // Determine how much to shift kInMask to have it match kOutMask. May be negative.
+    static constexpr int kShift = std::countr_zero(kInMask) - std::countr_zero(kOutMask);
+
+    // Mask and shift.
+    if constexpr (kShift < 0) {
+        return (value & kInMask) << (-kShift);
+    } else {
+        return (value & kInMask) >> kShift;
+    }
+}
+
+class Writer final {
+  public:
+    explicit Writer(EdidBuilder::EdidBytes& buffer, size_t begin,
+                    size_t end = EdidBuilder::kEdidByteCount)
+        : destination(&buffer), offset(begin), end(end) {
+        CHECK(begin < EdidBuilder::kEdidByteCount);
+        CHECK(end <= EdidBuilder::kEdidByteCount);
+    }
+
+    void operator()(uint32_t value) {
+        CHECK(offset < EdidBuilder::kEdidByteCount);
+        CHECK(value >= 0 && value <= std::numeric_limits<uint8_t>::max());
+
+        // NOLINTBEGIN(cppcoreguidelines-pro-bounds-constant-array-index)
+        (*destination)[offset] = static_cast<uint8_t>(value);
+        // NOLINTEND(cppcoreguidelines-pro-bounds-constant-array-index)
+        offset += 1;
+    }
+
+    void strncpy(std::string_view::const_iterator source, size_t size) {
+        CHECK(offset < end);
+        CHECK(offset + size <= end);
+        std::copy_n(source, size, destination->begin() + offset);
+        offset += size;
+    }
+
+    void copy(std::span<const uint8_t> source) {
+        CHECK(offset < end);
+        CHECK(offset + source.size() <= end);
+        std::copy_n(source.begin(), source.size(), destination->begin() + offset);
+        offset += source.size();
+    }
+
+    void fill(uint8_t value, size_t size) {
+        CHECK(offset < end);
+        CHECK(offset + size <= end);
+        std::fill_n(destination->begin() + offset, size, value);
+        offset += size;
+    }
+
+  private:
+    EdidBuilder::EdidBytes* destination;
+    size_t offset;
+    size_t end;
+};
+
+// Ref "3.4.1 ID Manufacturer Name: 2 Bytes" (address 08h - 09h)
+constexpr auto encodeManufacturerId(std::array<char, 3> value) -> uint16_t {
+    CHECK(value[0] >= 'A' && value[0] <= 'Z');
+    CHECK(value[1] >= 'A' && value[1] <= 'Z');
+    CHECK(value[2] >= 'A' && value[2] <= 'Z');
+
+    // Encode the three characters as three five bit values, where A=1 and Z=26.
+    // Each five bit value is packed into the bottom fifteen bits of a sixteen bit value.
+
+    // NOLINTBEGIN(*-magic-numbers)
+    uint16_t encoded = 0;
+    encoded |= select<0b11111, 0b11111'00000'00000>(value[0]);  // 1st char, top 5 bits
+    encoded |= select<0b11111, 0b00000'11111'00000>(value[1]);  // 2nd char, middle 5 bits
+    encoded |= select<0b11111, 0b00000'00000'11111>(value[2]);  // 3rd char, bottom 5 bits
+    // NOLINTEND(*-magic-numbers)
+
+    return encoded;
+}
+
+// Ref "3.6.1 Video Input Definition: 1 Byte" (address 14h)
+constexpr auto encodeDigitalVideoInputBitmap(EdidBuilder::ColorBitDepth depth,
+                                             EdidBuilder::DigitalInterface interface) -> uint8_t {
+    // Note: This is for the digital interface interpretation of the byte, indicated by the top bit
+    // (bit 7) of the byte being 1.
+    constexpr uint8_t kVideoInputDigitalBit = 0x80;
+
+    // NOLINTBEGIN(*-magic-numbers)
+    uint8_t encoded = kVideoInputDigitalBit;
+    encoded |= select<0b0111, 0b0111'0000>(ftl::to_underlying(depth));
+    encoded |= select<0b1111, 0b0000'1111>(ftl::to_underlying(interface));
+    // NOLINTEND(*-magic-numbers)
+
+    return encoded;
+}
+
+// Ref "3.6.3 Display Transfer Characteristics (GAMMA): 1 Byte" (address 17h)
+constexpr auto encodeGamma(float gamma) -> uint8_t {
+    constexpr float kGammaMin = 1;
+    constexpr float kGammaMax = 3.5390625;
+    constexpr float kGammaScale = 100;
+
+    CHECK(gamma >= kGammaMin && gamma <= kGammaMax);
+    return static_cast<uint8_t>((gamma - kGammaMin) * kGammaScale);
+}
+
+// Ref "3.6.4 Feature Support: 1 Byte" (address 18h)
+constexpr auto encodeFeatures(const EdidBuilder::DigitalDisplayFeatureSupport& support) -> uint8_t {
+    uint8_t encoded = 0;
+    // NOLINTBEGIN(*-magic-numbers)
+    encoded |= select<0x1, 0b1000'0000>(ftl::to_underlying(support.standby));
+    encoded |= select<0x1, 0b0100'0000>(ftl::to_underlying(support.suspend));
+    encoded |= select<0x1, 0b0010'0000>(ftl::to_underlying(support.activeOff));
+    encoded |= select<0x3, 0b0001'1000>(ftl::to_underlying(support.digitalFormats));
+    encoded |= select<0x1, 0b0000'0100>(ftl::to_underlying(support.srgb));
+    encoded |= select<0x1, 0b0000'0010>(ftl::to_underlying(support.preferredIsNative));
+    encoded |= select<0x1, 0b0000'0001>(ftl::to_underlying(support.continuousFrequency));
+    // NOLINTEND(*-magic-numbers)
+
+    return encoded;
+}
+
+// Ref "3.4 Vendor & Product ID: 10 Bytes (address 08h - 11h)
+constexpr void setVendor(EdidBuilder::EdidBytes& edid, const EdidBuilder::Vendor& values) {
+    constexpr unsigned kBlockBegin = 0x08;
+    constexpr unsigned kBlockEnd = 0x12;
+    auto write = Writer(edid, kBlockBegin, kBlockEnd);
+
+    // NOLINTBEGIN(*-magic-numbers)
+
+    const uint16_t encodedManufacturerId = encodeManufacturerId(values.manufacturerId);
+    // Store the 15 bit encoded id with most significant byte first (unlike most multibyte
+    // fields here)
+    write(select<0xff00>(encodedManufacturerId));
+    write(select<0x00ff>(encodedManufacturerId));
+
+    // Store the 16 bit product code, lsb first.
+    write(select<0x00ff>(values.manufacturerProductCode));
+    write(select<0xff00>(values.manufacturerProductCode));
+
+    // Store the 32 bit serial number, lsb first.
+    write(select<0x000000ff>(values.manufacturerSerialNumber));
+    write(select<0x0000ff00>(values.manufacturerSerialNumber));
+    write(select<0x00ff0000>(values.manufacturerSerialNumber));
+    write(select<0xff000000>(values.manufacturerSerialNumber));
+
+    // Store the 8 bit manufactured week
+    CHECK((values.manufacturedWeek <= 54) || (values.manufacturedWeek == 255));
+    write(values.manufacturedWeek);
+
+    // Store the encoded 8 bit year
+    constexpr int32_t kBaseYear = 1990;
+    const auto encodedYear = values.manufacturedYear - kBaseYear;
+    write(encodedYear);
+
+    // NOLINTEND(*-magic-numbers)
+}
+
+// Ref "3.5 EDID Structure Version & Revision: 2 Bytes" (address 12h - 13h)
+constexpr void setVersion(EdidBuilder::EdidBytes& edid, const EdidBuilder::EdidVersion& values) {
+    constexpr unsigned kBlockBegin = 0x12;
+    constexpr unsigned kBlockEnd = 0x14;
+    auto write = Writer(edid, kBlockBegin, kBlockEnd);
+
+    write(values.version);
+    write(values.revision);
+}
+
+// Ref "3.6 Basic Display Parameters and Features: 5 Bytes" (address 14h - 18h)
+constexpr void setBasic(EdidBuilder::EdidBytes& edid,
+                        const EdidBuilder::BasicDigitalDisplayParametersAndFeatures& values) {
+    constexpr unsigned kBlockBegin = 0x14;
+    constexpr unsigned kBlockEnd = 0x18;
+    auto write = Writer(edid, kBlockBegin, kBlockEnd);
+
+    // NOLINTBEGIN(*-magic-numbers)
+
+    // Store the encoded 8 bit video input bitmap
+    write(encodeDigitalVideoInputBitmap(values.depth, values.interface));
+
+    // Store the screen size in centimeters (8 bits each)
+    write(values.horizontalSizeCm);
+    write(values.verticalSizeCm);
+
+    // Store the encoded 8 bit gamma
+    write(encodeGamma(values.gamma));
+
+    // Store the encoded 8 bit feature flags
+    write(encodeFeatures(values.features));
+
+    // NOLINTEND(*-magic-numbers)
+}
+
+// Ref "3.10.2 Detailed Timing Descriptor: 18 bytes" (any optional display descriptor slot)
+constexpr void setDTD(EdidBuilder::EdidBytes& edid,
+                      EdidBuilder::DigitalSeparateDetailedTimingDescriptor descriptor) {
+    constexpr uint32_t kPixelClockDivisor = 10'000;  // 10 Khz
+    constexpr uint32_t kPixelClockMin = 0;
+    constexpr uint32_t kPixelClockMax = 655'350'000;  // 655.35 Mhz
+
+    constexpr size_t kMax12BitValue = 4095;
+    constexpr size_t kMax10BitValue = 1023;
+    constexpr size_t kMax6BitValue = 63;
+
+    // clang-format off
+    //
+    // Interpretation of timings, according to EDID 1.4. Ref "3.12 Note Regarding Borders"
+    //
+    // |-------------Active signal------------|----------------Blanking---------------|
+    // |-Border-|-Addressable Pixels-|-Border-|-Front Porch-|-Sync Pulse-|-Back Porch-|
+    //
+    // clang-format on
+
+    const uint16_t horizontalActive =
+            descriptor.timing.horizontal.addressable + (descriptor.timing.horizontal.border * 2);
+    const uint16_t horizontalBlanking = descriptor.timing.horizontal.frontPorch +
+                                        descriptor.timing.horizontal.syncPulse +
+                                        descriptor.timing.horizontal.backPorch;
+    const uint16_t verticalActive =
+            descriptor.timing.vertical.addressable + (descriptor.timing.vertical.border * 2);
+    const uint16_t verticalBlanking = descriptor.timing.vertical.frontPorch +
+                                      descriptor.timing.vertical.syncPulse +
+                                      descriptor.timing.vertical.backPorch;
+
+    CHECK(descriptor.timing.pixelClockMhz >= kPixelClockMin &&
+          descriptor.timing.pixelClockMhz <= kPixelClockMax);
+    CHECK(horizontalActive <= kMax12BitValue);
+    CHECK(horizontalBlanking <= kMax12BitValue);
+    CHECK(verticalActive <= kMax12BitValue);
+    CHECK(verticalBlanking <= kMax12BitValue);
+    CHECK(descriptor.timing.horizontal.frontPorch <= kMax12BitValue);
+    CHECK(descriptor.timing.horizontal.syncPulse <= kMax12BitValue);
+    CHECK(descriptor.timing.vertical.frontPorch <= kMax6BitValue);
+    CHECK(descriptor.timing.vertical.syncPulse <= kMax6BitValue);
+
+    auto write = Writer(edid, kDescriptor1Offset, kDescriptor1Offset + kDescriptorSize);
+
+    // NOLINTBEGIN(*-magic-numbers)
+
+    // The first two bytes contain the pixel clock, in units of 10Khz, little endian order.
+    write(select<0x00ff>(descriptor.timing.pixelClockMhz / kPixelClockDivisor));
+    write(select<0xff00>(descriptor.timing.pixelClockMhz / kPixelClockDivisor));
+
+    // The next byte contains the bottom 8 bits of the horizontal active pixels.
+    write(select<0x0ff>(horizontalActive));
+    // The next byte contains the bottom 8 bits of the horizontal blanking pixels.
+    write(select<0x0ff>(horizontalBlanking));
+    // The next byte contains the top 4 bits of the horizontal active pixels in its top 4 bits,
+    // and the top 4 bits of the horizontal blanking pixels in the bottom 4 bits.
+    write(select<0xf00, 0xf0>(horizontalActive) | select<0xf00, 0x0f>(horizontalBlanking));
+
+    // The next byte contains the bottom 8 bits of the vertical active lines.
+    write(select<0x0ff>(verticalActive));
+    // The next byte contains the bottom 8 bits of the vertical blanking lines.
+    write(select<0x0ff>(verticalBlanking));
+    // The next byte contains the top 4 bits of the vertical active lines in its top 4 bits,
+    // and the top 4 bits of the vertical blanking lines in the bottom 4 bits.
+    write(select<0xf00, 0xf0>(verticalActive) | select<0xf00, 0x0f>(verticalBlanking));
+
+    // The next byte contains the bottom 8 bits of the horizontal front porch.
+    write(select<0x0ff>(descriptor.timing.horizontal.frontPorch));
+    // The next byte contains the bottom 8 bits of the horizontal sync pulse.
+    write(select<0x0ff>(descriptor.timing.horizontal.syncPulse));
+    // The next byte contains the bottom 4 bits of the vertical front porch in the top 4 bits,
+    // and the bottom 4 bits of the vertical sync pulse in the bottom 4 bits.
+    write(select<0x0f, 0xf0>(descriptor.timing.vertical.frontPorch) |
+          select<0x0f, 0x0f>(descriptor.timing.vertical.syncPulse));
+    // The next byte contains:
+    // - the top 2 bits of the horizontal front porch in the top 2 bits
+    // - the top 2 bits of the horizontal sync pulse in the next 2 bits
+    // - the top 2 bits of the vertical front porch in the next 2 bits
+    // - the top 2 bits of the vertical sync pulse in the final 2 bits
+    write(select<0b11'0000'0000, 0b1100'0000>(descriptor.timing.horizontal.frontPorch) |
+          select<0b11'0000'0000, 0b0011'0000>(descriptor.timing.horizontal.syncPulse) |
+          select<0b00'0011'0000, 0b0000'1100>(descriptor.timing.vertical.frontPorch) |
+          select<0b00'0011'0000, 0b0000'0011>(descriptor.timing.vertical.syncPulse));
+
+    // The next byte contains the bottom 8 bits of the horizontal image size in mm.
+    write(select<0x0ff>(descriptor.horizontalImageSizeMm));
+    // The next byte contains the bottom 8 bits of the vertical image size in mm.
+    write(select<0x0ff>(descriptor.verticalImageSizeMm));
+    // The next byte contains:
+    // - the top 4 bits of the horizontal image size in the top 4 bits
+    // - the top 4 bits of the vertical image size in the final 4 bits
+    write((select<0xf00, 0xf0>(descriptor.horizontalImageSizeMm) |
+           select<0xf00, 0x0f>(descriptor.verticalImageSizeMm)));
+
+    // The next byte contains the horizontal border size in pixels.
+    write(descriptor.timing.horizontal.border);
+    // The next byte contains the vertical border size in lines.
+    write(descriptor.timing.vertical.border);
+
+    constexpr int32_t kDigitalSync = 1;
+    constexpr int32_t kDigitalSeparateSync = 1;
+
+    // The final byte contains a bunch of feature bits, some of which are interpreted
+    // differently depending on how bits 4 and 3 are set. We just configure digital/separate
+    // sync for simplicity.
+    uint32_t featureBitmap = 0;
+    featureBitmap |= select<0x1, 0x80>(ftl::to_underlying(descriptor.signalInterlace));
+    featureBitmap |= select<0x6, 0x60>(ftl::to_underlying(descriptor.stereoMode));
+    featureBitmap |= select<0x1, 0x10>(kDigitalSync);
+    featureBitmap |= select<0x1, 0x08>(kDigitalSeparateSync);
+    featureBitmap |= select<0x1, 0x04>(ftl::to_underlying(descriptor.timing.vertical.syncPolarity));
+    featureBitmap |=
+            select<0x1, 0x02>(ftl::to_underlying(descriptor.timing.horizontal.syncPolarity));
+    featureBitmap |= select<0x1, 0x01>(ftl::to_underlying(descriptor.stereoMode));
+    write(featureBitmap);
+
+    // NOLINTEND(*-magic-numbers)
+};
+
+// Ref "3.3 Header: 8 Bytes" (address 00h - 07h)
+constexpr void setHeader(EdidBuilder::EdidBytes& edid) {
+    constexpr auto kHeaderBegin = 0;
+    constexpr auto kHeaderEnd = 8;
+    auto write = Writer(edid, kHeaderBegin, kHeaderEnd);
+
+    // NOLINTBEGIN(*-magic-numbers)
+    // The header is a fixed pattern of eight bytes.
+    write(0);
+    write.fill(0xff, 6);
+    write(0);
+    // NOLINTEND(*-magic-numbers)
+}
+
+// Ref "3.7 Display x, y Chromaticity Coordinates: 10 Bytes" (address 19h - 22h)
+constexpr void setChromaticityDefaults(EdidBuilder::EdidBytes& edid) {
+    constexpr auto kBlockBegin = 25;
+    constexpr auto kBlockEnd = 35;
+    auto write = Writer(edid, kBlockBegin, kBlockEnd);
+
+    constexpr auto encodeChromaticity = [](double value) -> int {
+        constexpr auto kNumEncodeBits = 10;
+        return (static_cast<int>((1 << (kNumEncodeBits + 1)) * value) + 1) >> 1;
+    };
+
+    // NOLINTBEGIN(*-magic-numbers)
+
+    constexpr auto packed8BitsFrom4xBottom2Bits = [](uint32_t value0, uint32_t value1,
+                                                     uint32_t value2, uint32_t value3) -> uint32_t {
+        return (select<0b11, 0b1100'0000>(value0) | select<0b11, 0b0011'0000>(value1) |
+                select<0b11, 0b0000'1100>(value2) | select<0b11, 0b0000'0011>(value3));
+    };
+
+    constexpr auto packed8BitsFromTop8Bits = [](uint32_t value) -> uint32_t {
+        return select<0b11'1111'1100>(value);
+    };
+
+    // NOLINTEND(*-magic-numbers)
+
+    // These chromaticity points are taken from the VESA EDID Structure Version 1, Revision 4
+    // standard description, from the first example EDID in Appendix A.
+
+    constexpr auto kChromaticityRedX = 0.627;
+    constexpr auto kChromaticityRedY = 0.341;
+    constexpr auto kChromaticityGreenX = 0.292;
+    constexpr auto kChromaticityGreenY = 0.605;
+    constexpr auto kChromaticityBlueX = 0.149;
+    constexpr auto kChromaticityBlueY = 0.072;
+    constexpr auto kChromaticityWhiteX = 0.283;
+    constexpr auto kChromaticityWhiteY = 0.297;
+
+    constexpr int encodedRX = encodeChromaticity(kChromaticityRedX);
+    constexpr int encodedRY = encodeChromaticity(kChromaticityRedY);
+    constexpr int encodedGX = encodeChromaticity(kChromaticityGreenX);
+    constexpr int encodedGY = encodeChromaticity(kChromaticityGreenY);
+    constexpr int encodedBX = encodeChromaticity(kChromaticityBlueX);
+    constexpr int encodedBY = encodeChromaticity(kChromaticityBlueY);
+    constexpr int encodedWX = encodeChromaticity(kChromaticityWhiteX);
+    constexpr int encodedWY = encodeChromaticity(kChromaticityWhiteY);
+
+    const int lowBitsRG = packed8BitsFrom4xBottom2Bits(encodedRX, encodedRY, encodedGX, encodedGY);
+    const int lowBitsBW = packed8BitsFrom4xBottom2Bits(encodedBX, encodedBY, encodedWX, encodedWY);
+
+    write(lowBitsRG);
+    write(lowBitsBW);
+    write(packed8BitsFromTop8Bits(encodedRX));
+    write(packed8BitsFromTop8Bits(encodedRY));
+    write(packed8BitsFromTop8Bits(encodedGX));
+    write(packed8BitsFromTop8Bits(encodedGY));
+    write(packed8BitsFromTop8Bits(encodedBX));
+    write(packed8BitsFromTop8Bits(encodedBY));
+    write(packed8BitsFromTop8Bits(encodedWX));
+    write(packed8BitsFromTop8Bits(encodedWY));
+}
+
+// Ref "3.8 Established Timings I & II: 3 bytes" (address 23h - 25h)
+constexpr void setEstablishedTimingsDefaults(EdidBuilder::EdidBytes& edid) {
+    constexpr auto kBlockBegin = 35;
+    constexpr auto kBlockEnd = 38;
+    auto write = Writer(edid, kBlockBegin, kBlockEnd);
+
+    // NOLINTBEGIN(*-magic-numbers)
+
+    // These three bytes are bitmasks that indicate support for specific, established display
+    // modes as defined by the EDID standard.
+    // We fill with zero to indicate no support for these modes for simplicity.
+    write.fill(0, kBlockEnd - kBlockBegin);
+
+    // NOLINTEND(*-magic-numbers)
+}
+
+// Ref "3.9 Standard Timings: 16 Bytes" (address 26h - 35h)
+constexpr void setStandardTimingsDefaults(EdidBuilder::EdidBytes& edid) {
+    constexpr auto kBlockBegin = 38;
+    constexpr auto kBlockEnd = 53;
+    auto write = Writer(edid, kBlockBegin, kBlockEnd);
+
+    // NOLINTBEGIN(*-magic-numbers)
+
+    // These 16 bytes are eight two-byte compactly encoded entries for modes that are supported.
+    // See the EDID specification for details. While we might be able to indicate that an
+    // injected fake display has a mode that can be represented through this table, we instead
+    // just fill it with (1, 1) entries to indicate that those entries are not used.
+    write.fill(1, kBlockEnd - kBlockBegin);
+
+    // NOLINTEND(*-magic-numbers)
+}
+
+// Ref "3.10 18 Byte Descriptors - 72 Bytes" (addresses 36h - 7dh, four 18 byte slots)
+constexpr void setUnusedDescriptors(EdidBuilder::EdidBytes& edid, size_t nextDescriptorOffset) {
+    constexpr uint8_t kTagUnused = 0x10;
+
+    while (nextDescriptorOffset < kDescriptorEndOffset) {
+        auto write = Writer(edid, nextDescriptorOffset, nextDescriptorOffset + kDescriptorSize);
+        nextDescriptorOffset += kDescriptorSize;
+
+        // NOLINTBEGIN(*-magic-numbers)
+        write.fill(0, 3);
+        write(kTagUnused);
+        write.fill(0, 14);
+        // NOLINTEND(*-magic-numbers)
+    }
+}
+
+// Ref "3.11 EXTENSION Flag and Checksum" {address 7eh)
+constexpr void setNoExtensionBlocks(EdidBuilder::EdidBytes& edid) {
+    // Sets the extension flag byte to indicate there are no extension blocks after base EDID block.
+    constexpr unsigned kExtensionFlagOffset = 126;
+    edid[kExtensionFlagOffset] = 0;
+}
+
+// Ref "3.11 EXTENSION Flag and Checksum" {address 7fh)
+constexpr void updateChecksum(EdidBuilder::EdidBytes& edid) {
+    // Sets the checksum byte so that the sum of all 128 bytes is zero.
+    constexpr unsigned kChecksumOffset = 127;
+    const int sum = std::accumulate(edid.begin(), edid.end() - 1, 0);
+    edid[kChecksumOffset] = static_cast<uint8_t>(-sum);
+}
+
+}  // namespace
+
+// Note: This value is exposed for use as a public default, as well as being used as a starting
+// value for the builder.
+const EdidBuilder::EdidBytes EdidBuilder::kDefaultEdid = {
+        // clang-format off
+    // https://en.wikipedia.org/wiki/Extended_Display_Identification_Data
+    /*  0 -  3 */ 0x00, 0xff, 0xff, 0xff,   // Fixed Header pattern 1
+    /*  4 -  7 */ 0xff, 0xff, 0xff, 0x00,   // Fixed Header pattern 2
+
+    /* Vendor block */
+    /*  8 -  9 */ 0x1c, 0xec,               // Manufacturer ID (3x 5-bit chars) (default: "GGL")
+    /* 10 - 11 */ 0x01, 0x00,               // Manufacturer product code (default: 1)
+    /* 12 - 15 */ 0x01, 0x00, 0x00, 0x00,   // Serial Number (default: 1)
+    /* 16 - 17 */ 0xff, 0x23,               // Manufactured Week, Year-1990 (default: No week, 2025)
+
+    /* Version block */
+    /* 18 - 19 */ 0x01, 0x04,               // EDID Version 1.4
+
+    /* Video input definition block */
+    /*      20 */ 0xb0,                     // Video params bitmap (default: digital, 10 bit color depth, undefined interface)
+    /* 21 - 22 */ 0x40, 0x24,               // Screen size in cm (default: 64 cm x 36 cm)
+    /*      23 */ 0x82,                     // Gamma (default: 1.30)
+    /*      24 */ 0x02,                     // Supported features bitmap (default: None with format RGB4444)
+
+    /* Chromaticity block */
+    /* 25 - 26 */ 0x9c, 0x68,               // Bottom two bits for each of Rx/y, Gx/y, Bx/y, Wx/y
+    /* 27 - 28 */ 0xa0, 0x57,               // Rx, Ry top 8 bits
+    /* 29 - 30 */ 0x4a, 0x9b,               // Gx, Ry top 8 bits
+    /* 31 - 32 */ 0x26, 0x12,               // Bx, By top 8 bits
+    /* 33 - 34 */ 0x48, 0x4c,               // Wx, Wy top 8 bits
+
+    /* Standard timings block */
+    /* 35 - 37 */ 0x00, 0x00, 0x00,         // Standard mode support bitmap (default: None)
+    /* 38 - 39 */ 0x01, 0x01,               // Standard timing 1 (default: Unused)
+    /* 40 - 41 */ 0x01, 0x01,               // Standard timing 1 (default: Unused)
+    /* 42 - 43 */ 0x01, 0x01,               // Standard timing 2 (default: Unused)
+    /* 44 - 45 */ 0x01, 0x01,               // Standard timing 3 (default: Unused)
+    /* 46 - 47 */ 0x01, 0x01,               // Standard timing 4 (default: Unused)
+    /* 48 - 49 */ 0x01, 0x01,               // Standard timing 5 (default: Unused)
+    /* 50 - 41 */ 0x01, 0x01,               // Standard timing 6 (default: Unused)
+    /* 52 - 53 */ 0x01, 0x01,               // Standard timing 7 (default: Unused)
+
+    /* 54 - 71 : Detailed Timing Descriptor (required with EDID 1.4) */
+    /* These values are defaults for a 1920x1080 60Hz display */
+    /* + 0 -  1 */ 0x02, 0x3a,              // Pixel clock
+    /* + 2 -  4 */ 0x80, 0x18, 0x71,        // Horizontal timing
+    /* + 5 -  7 */ 0x38, 0x2d, 0x40,        // Vertical timing
+    /* + 8 - 11 */ 0x58, 0x2c, 0x45, 0x00,  // H/V front porch, pulse info
+    /* +12 - 14 */ 0x80, 0x68, 0x21,        // H/V image size mm
+    /* +15 - 16 */ 0x00, 0x00,              // H/V border pixels
+    /* +     17 */ 0x1e,                    // Features bitmap
+
+    /* 72 - 89 : Descriptor 2 */
+    /* + 0 -  3 */ 0x00, 0x00, 0x00, 0x10,  // Not Used Descriptor
+    /* +      4 */ 0x00,                    // Reserved
+    /* + 5 -  8 */ 0x00, 0x00, 0x00, 0x00,
+    /* + 9 - 12 */ 0x00, 0x00, 0x00, 0x00,
+    /* +13 - 16 */ 0x00, 0x00, 0x00, 0x00,
+    /* +     17 */ 0x00,
+
+    /* 90 - 107 : Descriptor 3 */
+    /* + 0 -  3 */ 0x00, 0x00, 0x00, 0x10,  // Not Used Descriptor
+    /* +      4 */ 0x00,                    // Reserved
+    /* + 5 -  8 */ 0x00, 0x00, 0x00, 0x00,
+    /* + 9 - 12 */ 0x00, 0x00, 0x00, 0x00,
+    /* +13 - 16 */ 0x00, 0x00, 0x00, 0x00,
+    /* +     17 */ 0x00,
+
+    /* 108 - 125 : Descriptor 4 */
+    /* + 0 -  3 */ 0x00, 0x00, 0x00, 0x10,  // Not Used Descriptor
+    /* +      4 */ 0x00,                    // Reserved
+    /* + 5 -  8 */ 0x00, 0x00, 0x00, 0x00,
+    /* + 9 - 12 */ 0x00, 0x00, 0x00, 0x00,
+    /* +13 - 16 */ 0x00, 0x00, 0x00, 0x00,
+    /* +     17 */ 0x00,
+
+    /*      126 */ 0x00,                    // Number of extensions (zero)
+    /*      127 */ 0x77,                    // Checksum (Sum of bytes 0-127 should be zero!)
+        // clang-format on
+};
+
+EdidBuilder::EdidBuilder()
+    : edid(kDefaultEdid), nextDescriptorOffset(kDescriptor1Offset + kDescriptorSize) {}
+
+// NOLINTBEGIN(readability-convert-member-functions-to-static)
+// clang-tidy incorrectly shows this error for C++23 "deducing this" methods.
+
+auto EdidBuilder::set(this EdidBuilder&& self, const Version1r4Required& values) -> EdidBuilder&& {
+    setVersion(self.edid, {.version = 1, .revision = 4});
+    setVendor(self.edid, values.vendor);
+    setBasic(self.edid, values.parametersAndFeatures);
+    setDTD(self.edid, values.preferred);
+
+    return std::move(self);
+}
+
+// Ref "3.10.3.4 Display Product Name (ASCII) String Descriptor Definition (tag #FCh)"
+// Note: The string value is truncated if more than 13 characters are given.
+auto EdidBuilder::addDisplayProductNameStringDescriptor(this EdidBuilder&& self,
+                                                        std::string_view value) -> EdidBuilder&& {
+    const size_t descriptorOffset = self.nextDescriptorOffset;
+    CHECK(descriptorOffset < kDescriptorEndOffset);
+    self.nextDescriptorOffset += kDescriptorSize;
+
+    auto write = Writer(self.edid, descriptorOffset, descriptorOffset + kDescriptorSize);
+
+    constexpr uint8_t kTag = 0xfc;
+    constexpr size_t kMaxStringLength = kMaxProductNameStringLength;
+    constexpr uint8_t kStringTerminator = 0x0a;
+    constexpr uint8_t kPaddingByte = 0x20;
+
+    write(0);
+    write(0);
+    write(0);
+    write(kTag);
+    write(0);
+
+    write.strncpy(value.begin(), std::min(value.size(), kMaxStringLength));
+    if (value.size() < kMaxStringLength) {
+        write(kStringTerminator);
+        if (value.size() < kMaxStringLength - 1) {
+            // Pad out the rest of the descriptor with ASCII spaces (0x20) characters.
+            write.fill(kPaddingByte, kMaxStringLength - 1 - value.size());
+        }
+    }
+
+    return std::move(self);
+};
+
+auto EdidBuilder::build(this EdidBuilder&& self) -> EdidBuilder::EdidBytes {
+    setHeader(self.edid);
+    setChromaticityDefaults(self.edid);
+    setEstablishedTimingsDefaults(self.edid);
+    setStandardTimingsDefaults(self.edid);
+    setUnusedDescriptors(self.edid, self.nextDescriptorOffset);
+    setNoExtensionBlocks(self.edid);
+
+    // Must be last.
+    updateChecksum(self.edid);
+
+    const auto result = self.edid;
+    std::ignore = std::move(self);  // NOLINT(performance-move-const-arg)
+    return result;
+}
+
+// NOLINTEND(readability-convert-member-functions-to-static)
+
+auto EdidBuilder::DigitalSeparateDetailedTimingDescriptor::Timing::synthesize(
+        ui::Size displayed, int refreshRate) -> Timing {
+    // This function synthesizes a valid DTD for a given pixel size and refresh rate, for
+    // use with injecting fake/simulated displays with vkms.
+    //
+    // IMPORTANT: This is not part of the EDID standard, and further is not intended to be
+    // used to generate the timing values for a real display.
+    //
+    // How this works:
+    //
+    // We want a pixelClock that is an even multiple of 1000.
+    //
+    // The pixelClock value is the product of total horizontal pixels (displayed + blanking), the
+    // total vertical lines (displayed + blanking), and the refresh rate (assumed here to be a
+    // simple integer, so 59.994Hz for TV's is not possible with this function)
+    //
+    // One way of doing that is to make sure the horizontal total pixels is a multiple of 400, and
+    // the vertical total pixels is a multiple of 25, which means that the product of those two
+    // values alone will be a multiple of 1000.
+    //
+    // That means we must choose (nonzero) values for the horizontal and vertical blanking to meet
+    // that constraint. We also use those values as the minimum amount of blanking.
+
+    const int horizontalAddressable = displayed.width;
+    const int verticalAddressable = displayed.height;
+
+    constexpr auto kHorizontalMultiple = 400;
+    constexpr auto kVerticalMultiple = 25;
+
+    const auto horizontalBlanking =
+            (2 * kHorizontalMultiple) - (horizontalAddressable % kHorizontalMultiple);
+    const auto verticalBlanking =
+            (2 * kVerticalMultiple) - (verticalAddressable % kVerticalMultiple);
+    CHECK_GE(horizontalBlanking, kHorizontalMultiple);
+    CHECK_GE(verticalBlanking, kVerticalMultiple);
+
+    const auto horizontalTotal = horizontalAddressable + horizontalBlanking;
+    const auto verticalTotal = verticalAddressable + verticalBlanking;
+    CHECK(horizontalTotal % kHorizontalMultiple == 0) << horizontalTotal;
+    CHECK(verticalTotal % kVerticalMultiple == 0) << verticalTotal;
+
+    const int pixelClockMhz = horizontalTotal * verticalTotal * refreshRate;
+    CHECK(pixelClockMhz % 1000 == 0) << pixelClockMhz;
+
+    // With a real world device there are probably some additional constraints around these values.
+    // Here we just use some of the values for a standard 1920x1080x60Hz signal, adjusting the back
+    // porch values to fill the total blank times.
+    constexpr auto kHorizontalFrontPorch = 88;
+    constexpr auto kHorizontalSyncPulse = 44;
+    constexpr auto kVerticalFrontPorch = 4;
+    constexpr auto kVerticalSyncPulse = 5;
+    const int horizontalBackPorch =
+            horizontalBlanking - (kHorizontalFrontPorch + kHorizontalSyncPulse);
+    const int verticalBackPorch = verticalBlanking - (kVerticalFrontPorch + kVerticalSyncPulse);
+    CHECK_GE(horizontalBackPorch, kHorizontalFrontPorch);
+    CHECK_GE(verticalBackPorch, kVerticalFrontPorch);
+
+    return {.pixelClockMhz = static_cast<uint32_t>(pixelClockMhz),
+            .horizontal =
+                    {
+                            .addressable = static_cast<uint16_t>(horizontalAddressable),
+                            .border = 0,
+                            .frontPorch = kHorizontalFrontPorch,
+                            .syncPulse = kHorizontalSyncPulse,
+                            .backPorch = static_cast<uint16_t>(horizontalBackPorch),
+                            .syncPolarity = SyncPolarity::Positive,
+                    },
+            .vertical = {
+                    .addressable = static_cast<uint16_t>(verticalAddressable),
+                    .border = 0,
+                    .frontPorch = kVerticalFrontPorch,
+                    .syncPulse = kVerticalSyncPulse,
+                    .backPorch = static_cast<uint16_t>(verticalBackPorch),
+                    .syncPolarity = SyncPolarity::Positive,
+            }};
+}
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::core
\ No newline at end of file
diff --git a/services/surfaceflinger/tests/end2end/test_framework/core/EdidBuilder.h b/services/surfaceflinger/tests/end2end/test_framework/core/EdidBuilder.h
new file mode 100644
index 0000000000..b50455fb35
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/core/EdidBuilder.h
@@ -0,0 +1,240 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <array>
+#include <cstddef>
+#include <cstdint>
+#include <string_view>
+
+#include <ui/Size.h>
+
+namespace android::surfaceflinger::tests::end2end::test_framework::core {
+
+/**
+ * Builds a 128 byte binary EDID 1.4 blob from a more human readable set of arguments.
+ *
+ * Note: Definitions here are based on the "E-EDID A.2_revised_2020.pdf", dated December 31, 2020,
+ * as obtained from the download link for this and a few other public standards at
+ * https://vesa.org/vesa-standards/.
+ *
+ * The introduction page for the revised version just notes some minor changes from the original
+ * "Release A, Revision 2" document from September 25, 2006 (which can be found from other
+ * unofficial sources as "ESA-EEDID-A2.pdf"), namely:
+ *
+ *  - Rewording the language used in one sentence in section 2.2.4 about VESA maintaining the list
+ *    of extension block tag numbers.
+ *  - Updating contact information.
+ */
+struct EdidBuilder final {
+    static constexpr size_t kEdidByteCount = 128;
+
+    static constexpr size_t kMaxProductNameStringLength = 13;
+
+    using EdidBytes = std::array<uint8_t, kEdidByteCount>;
+
+    // A prebuilt EDID useful as a default value.
+    static const EdidBytes kDefaultEdid;
+
+  public:
+    // Ref: "3.4 Vendor and Product Id: 10 Bytes"
+    struct Vendor final {
+        static constexpr uint8_t kYearIsModelYear = 255;
+        static constexpr int16_t kDefaultYear = 2025;
+
+        std::array<char, 3> manufacturerId = {'G', 'G', 'L'};
+        uint16_t manufacturerProductCode = 1;
+        uint32_t manufacturerSerialNumber = 1;
+        // 0 = unused, 1...54 = week of the year, 255 = Year is model year.
+        uint8_t manufacturedWeek = kYearIsModelYear;
+        // 1990...2245
+        int16_t manufacturedYear = kDefaultYear;
+    };
+
+    enum class ColorBitDepth : uint8_t {
+        Undefined = 0,
+        Six = 1,
+        Eight = 2,
+        Ten = 3,
+        Twelve = 4,
+        Fourteen = 5,
+        Sixteen = 6,
+    };
+
+    enum class DigitalInterface : uint8_t {
+        Undefined = 0,
+        DVI = 1,
+        HDMIa = 2,
+        HDMIb = 3,
+        MDDI = 4,
+        DisplayPort = 5,
+    };
+
+    enum class Supported : uint8_t {
+        No = 0,
+        Yes = 1,
+    };
+
+    enum class DigitalSupportedColorEncodingFormats : uint8_t {
+        RGB444 = 0,
+        RGB444PlusYCrCb444 = 1,
+        RGB444PlusYCrCb422 = 2,
+        RGB444PlusYCrCb444PlusYCrCb422 = 3,
+    };
+
+    // Ref: "3.5 EDID Struct Version & Revision: 2 Bytes"
+    struct EdidVersion final {
+        uint8_t version;
+        uint8_t revision;
+    };
+
+    // Ref: "3.6.4 Feature Support: 1 Byte",
+    // Note: Variant of the structure for a digital display
+    struct DigitalDisplayFeatureSupport final {
+        Supported standby = Supported::No;
+        Supported suspend = Supported::No;
+        Supported activeOff = Supported::No;
+        DigitalSupportedColorEncodingFormats digitalFormats =
+                DigitalSupportedColorEncodingFormats::RGB444;
+        Supported srgb = Supported::No;
+        Supported preferredIsNative = Supported::Yes;
+        Supported continuousFrequency = Supported::No;
+    };
+
+    // Ref: "3.6 Basic Display Parameters and Features: 5 Bytes"
+    // Note: Variant of the structure for a digital display
+    struct BasicDigitalDisplayParametersAndFeatures final {
+        static constexpr auto kDefaultGamma = 2.3F;
+        static constexpr auto kDefaultHorizontalSizeCm = 64;
+        static constexpr auto kDefaultVerticalSizeCm = 36;
+
+        ColorBitDepth depth = ColorBitDepth::Ten;
+        DigitalInterface interface = DigitalInterface::Undefined;
+        uint8_t horizontalSizeCm = kDefaultHorizontalSizeCm;
+        uint8_t verticalSizeCm = kDefaultVerticalSizeCm;
+        float gamma = kDefaultGamma;
+        DigitalDisplayFeatureSupport features;
+    };
+
+    enum class SignalInterlace : uint8_t {
+        NotInterlaced = 0,
+        Interlaced = 1,
+    };
+
+    enum class StereoMode : uint8_t {
+        NoStereo = 0b000,     // Low bit is a don't care.
+        NoStereoAlt = 0b001,  //
+        FieldSequentialRight = 0b010,
+        FieldSequentialLeft = 0b100,
+        Interleaved2WayRight = 0b011,
+        Interleaved2WayLeft = 0b101,
+        Interleaved4Way = 0b110,
+        SideBySide = 0b111,
+    };
+
+    enum class SyncPolarity : uint8_t {
+        Negative = 0,
+        Positive = 1,
+    };
+
+    // Ref: "3.10.2 Detailed Timing Descriptor: 18 bytes"
+    // Note: Variant of the structure for a digital display
+    struct DigitalSeparateDetailedTimingDescriptor final {
+        struct Timing {
+            struct InnerTiming {
+                uint16_t addressable = 0;
+                uint8_t border = 0;
+                uint16_t frontPorch = 0;
+                uint16_t syncPulse = 0;
+                uint16_t backPorch = 0;
+                SyncPolarity syncPolarity = SyncPolarity::Positive;
+            };
+
+            uint32_t pixelClockMhz = 0;
+            InnerTiming horizontal;
+            InnerTiming vertical;
+
+            // This function synthesizes a valid DTD for a given pixel size and refresh rate, for
+            // use with injecting fake/simulated displays with vkms.
+            //
+            // IMPORTANT: This is not part of the EDID standard, and further is not intended to be
+            // used to generate the timing values for a real display.
+            static auto synthesize(ui::Size displayed, int refreshRate) -> Timing;
+        };
+
+        // These timing values are the standard timings for a 1920x1080 panel running at 60Hz.
+        static constexpr Timing k1920x1080x60HzStandard = {
+                .pixelClockMhz = 148'500'000,  // 148.5 Mhz
+                .horizontal =
+                        {
+                                .addressable = 1920,
+                                .border = 0,
+                                .frontPorch = 88,
+                                .syncPulse = 44,
+                                .backPorch = 148,
+                                .syncPolarity = SyncPolarity::Positive,
+                        },
+                .vertical =
+                        {
+                                .addressable = 1080,
+                                .border = 0,
+                                .frontPorch = 4,
+                                .syncPulse = 5,
+                                .backPorch = 36,
+                                .syncPolarity = SyncPolarity::Positive,
+                        },
+        };
+
+        static constexpr uint16_t kDefaultHorizontalImageSizeMm = 640;
+        static constexpr uint16_t kDefaultVerticalImageSizeMm = 360;
+
+        Timing timing = k1920x1080x60HzStandard;
+        uint16_t horizontalImageSizeMm = kDefaultHorizontalImageSizeMm;
+        uint16_t verticalImageSizeMm = kDefaultVerticalImageSizeMm;
+        SignalInterlace signalInterlace = SignalInterlace::NotInterlaced;
+        StereoMode stereoMode = StereoMode::NoStereo;
+    };
+
+    // The required portion of the base 1.4 EDID, lacking only the three optional descriptors.
+    struct Version1r4Required {
+        Vendor vendor;
+        BasicDigitalDisplayParametersAndFeatures parametersAndFeatures;
+        DigitalSeparateDetailedTimingDescriptor preferred;
+    };
+
+    EdidBuilder();
+
+    // NOLINTBEGIN(readability-convert-member-functions-to-static)
+    // clang-tidy incorrectly shows this error for C++23 "deducing this" methods.
+    auto set(this EdidBuilder&& self, const Version1r4Required& values) -> EdidBuilder&&;
+
+    // Note: The string value is truncated if more than kMaxProductNameStringLength characters are
+    // given.
+    auto addDisplayProductNameStringDescriptor(this EdidBuilder&& self,
+                                               std::string_view value) -> EdidBuilder&&;
+
+    auto build(this EdidBuilder&& self) -> EdidBytes;
+    // NOLINTEND(readability-convert-member-functions-to-static)
+
+  private:
+    EdidBytes edid;
+
+    // Descriptor1 must be a Detailed Timing Descriptor. Any additional descriptors start after.
+    size_t nextDescriptorOffset;
+};
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::core
diff --git a/services/surfaceflinger/tests/end2end/test_framework/core/GuardedSharedState.h b/services/surfaceflinger/tests/end2end/test_framework/core/GuardedSharedState.h
new file mode 100644
index 0000000000..b884125d5c
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/core/GuardedSharedState.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <functional>
+#include <mutex>
+#include <shared_mutex>
+#include <type_traits>
+
+namespace android::surfaceflinger::tests::end2end::test_framework::core {
+
+// Ensures all access to a state structure `SharedState` is done while holding an appropriate
+// `std::shared_mutex` lock.
+//
+// This works around limitations with Clang thread safety analysis when using `std::shared_lock`, as
+// there will be a compiler diagnostic despite acquiring the lock.
+template <typename SharedState>
+class GuardedSharedState final {
+  public:
+    // Allows shared read-only access to the state. The lambda is invoked with a `const
+    // SharedState&` first argument referencing the state.
+    template <typename F>
+    auto withSharedLock(F&& continuation) const -> std::invoke_result_t<F, const SharedState&> {
+        const std::shared_lock lock(mMutex);
+        return std::invoke(std::forward<F>(continuation), mState);
+    }
+
+    // Allows exclusive read/write access to the state. The lambda is invoked with a `SharedState&`
+    // first argument referencing the state.
+    template <typename F>
+    auto withExclusiveLock(F&& continuation) -> std::invoke_result_t<F, SharedState&> {
+        const std::lock_guard lock(mMutex);
+        return std::invoke(std::forward<F>(continuation), mState);
+    }
+
+  private:
+    mutable std::shared_mutex mMutex;
+    SharedState mState;
+};
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::core
diff --git a/services/surfaceflinger/tests/end2end/test_framework/core/TestService.cpp b/services/surfaceflinger/tests/end2end/test_framework/core/TestService.cpp
index 0531f18527..474030515f 100644
--- a/services/surfaceflinger/tests/end2end/test_framework/core/TestService.cpp
+++ b/services/surfaceflinger/tests/end2end/test_framework/core/TestService.cpp
@@ -25,7 +25,7 @@
 
 #include "test_framework/core/DisplayConfiguration.h"
 #include "test_framework/core/TestService.h"
-#include "test_framework/fake_hwc3/Hwc3Controller.h"
+#include "test_framework/hwc3/Hwc3Controller.h"
 #include "test_framework/surfaceflinger/SFController.h"
 
 namespace android::surfaceflinger::tests::end2end::test_framework::core {
@@ -56,7 +56,7 @@ auto TestService::init(std::span<const DisplayConfiguration> displays)
         -> base::expected<void, std::string> {
     using namespace std::string_literals;
 
-    auto hwcResult = fake_hwc3::Hwc3Controller::make(displays);
+    auto hwcResult = hwc3::Hwc3Controller::make(displays);
     if (!hwcResult) {
         return base::unexpected(std::move(hwcResult).error());
     }
@@ -68,7 +68,7 @@ auto TestService::init(std::span<const DisplayConfiguration> displays)
     }
     auto flinger = *std::move(flingerResult);
 
-    surfaceflinger::SFController::useHwcService(fake_hwc3::Hwc3Controller::getServiceName());
+    surfaceflinger::SFController::useHwcService(hwc3::Hwc3Controller::getServiceName());
 
     if (auto result = flinger->startAndConnect(); !result) {
         return base::unexpected(std::move(result).error());
diff --git a/services/surfaceflinger/tests/end2end/test_framework/core/TestService.h b/services/surfaceflinger/tests/end2end/test_framework/core/TestService.h
index 21e6426406..faf2cf53b3 100644
--- a/services/surfaceflinger/tests/end2end/test_framework/core/TestService.h
+++ b/services/surfaceflinger/tests/end2end/test_framework/core/TestService.h
@@ -34,11 +34,11 @@ class SFController;
 
 }  // namespace surfaceflinger
 
-namespace fake_hwc3 {
+namespace hwc3 {
 
 class Hwc3Controller;
 
-}  // namespace fake_hwc3
+}  // namespace hwc3
 
 namespace core {
 
@@ -53,7 +53,7 @@ class TestService final {
     explicit TestService(Passkey passkey);
 
     // Obtains the HWC3 back-end controller
-    [[nodiscard]] auto hwc() -> fake_hwc3::Hwc3Controller& {
+    [[nodiscard]] auto hwc() -> hwc3::Hwc3Controller& {
         CHECK(mHwc);
         return *mHwc;
     }
@@ -68,7 +68,7 @@ class TestService final {
     [[nodiscard]] auto init(std::span<const DisplayConfiguration> displays)
             -> base::expected<void, std::string>;
 
-    std::shared_ptr<fake_hwc3::Hwc3Controller> mHwc;
+    std::shared_ptr<hwc3::Hwc3Controller> mHwc;
     std::shared_ptr<surfaceflinger::SFController> mFlinger;
 };
 
diff --git a/services/surfaceflinger/tests/end2end/test_framework/core/TimeInterval.h b/services/surfaceflinger/tests/end2end/test_framework/core/TimeInterval.h
new file mode 100644
index 0000000000..61423beee5
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/core/TimeInterval.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <chrono>
+#include <string>
+
+#include <fmt/chrono.h>  // NOLINT(misc-include-cleaner)
+#include <fmt/format.h>
+
+namespace android::surfaceflinger::tests::end2end::test_framework::core {
+
+// Represents a span of time between two absolute points in time.
+// The interval is half-open, including the beginning point, but not the end point.
+// Note: "interval" is used to be consistent with the mathematical definition of the term.
+// NOLINTBEGIN(misc-non-private-member-variables-in-classes)
+struct TimeInterval final {
+    using TimePoint = std::chrono::steady_clock::time_point;
+
+    // The half-open interval [begin, end), where the end time is not included.
+    TimePoint begin;
+    TimePoint end;
+
+    [[nodiscard]] auto empty() const -> bool { return begin == end; }
+    friend auto operator==(const TimeInterval&, const TimeInterval&) -> bool = default;
+};
+// NOLINTEND(misc-non-private-member-variables-in-classes)
+
+inline auto toString(const TimeInterval& value) -> std::string {
+    return fmt::format("[{}, {})", value.begin.time_since_epoch(), value.end.time_since_epoch());
+}
+
+inline auto format_as(const TimeInterval& event) -> std::string {
+    return toString(event);
+}
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::core
diff --git a/services/surfaceflinger/tests/end2end/test_framework/fake_hwc3/Hwc3Composer.cpp b/services/surfaceflinger/tests/end2end/test_framework/fake_hwc3/Hwc3Composer.cpp
deleted file mode 100644
index 5349ef0b58..0000000000
--- a/services/surfaceflinger/tests/end2end/test_framework/fake_hwc3/Hwc3Composer.cpp
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Copyright 2025 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <cstdint>
-#include <memory>
-#include <string>
-#include <string_view>
-#include <utility>
-#include <vector>
-
-#include <aidl/android/hardware/graphics/composer3/BnComposer.h>
-#include <aidl/android/hardware/graphics/composer3/Capability.h>
-#include <aidl/android/hardware/graphics/composer3/IComposer.h>
-#include <aidl/android/hardware/graphics/composer3/PowerMode.h>
-
-#include <android-base/expected.h>
-#include <android-base/logging.h>
-#include <android/binder_auto_utils.h>
-#include <android/binder_interface_utils.h>
-#include <android/binder_status.h>
-#include <ftl/ignore.h>
-
-#include "test_framework/core/DisplayConfiguration.h"
-#include "test_framework/fake_hwc3/Hwc3Composer.h"
-
-namespace android::surfaceflinger::tests::end2end::test_framework::fake_hwc3 {
-
-class Hwc3Composer::Hwc3ComposerImpl final
-    : public aidl::android::hardware::graphics::composer3::BnComposer {
-    using Capability = aidl::android::hardware::graphics::composer3::Capability;
-    using IComposerClient = aidl::android::hardware::graphics::composer3::IComposerClient;
-    using Hwc3PowerMode = aidl::android::hardware::graphics::composer3::PowerMode;
-
-    // begin IComposer overrides
-
-    auto dump(int dumpFd, const char** args, uint32_t num_args) -> binder_status_t override {
-        UNIMPLEMENTED(WARNING);
-        ftl::ignore(dumpFd, args, num_args);
-        return static_cast<binder_status_t>(STATUS_NO_MEMORY);
-    }
-
-    auto createClient(std::shared_ptr<IComposerClient>* out_client) -> ndk::ScopedAStatus override {
-        UNIMPLEMENTED(WARNING);
-        ftl::ignore(out_client);
-        return ndk::ScopedAStatus::fromServiceSpecificErrorWithMessage(
-                IComposer::EX_NO_RESOURCES, "Client failed to initialize");
-    }
-
-    auto getCapabilities(std::vector<Capability>* out_capabilities) -> ndk::ScopedAStatus override {
-        UNIMPLEMENTED(WARNING);
-        ftl::ignore(out_capabilities);
-        return ndk::ScopedAStatus::ok();
-    }
-
-    // end IComposer overrides
-};
-
-struct Hwc3Composer::Passkey final {};
-
-auto Hwc3Composer::getServiceName(std::string_view baseServiceName) -> std::string {
-    return Hwc3ComposerImpl::makeServiceName(baseServiceName);
-}
-
-auto Hwc3Composer::make() -> base::expected<std::shared_ptr<Hwc3Composer>, std::string> {
-    using namespace std::string_literals;
-
-    auto composer = std::make_shared<Hwc3Composer>(Passkey{});
-    if (composer == nullptr) {
-        return base::unexpected("Failed to construct the Hwc3Composer instance."s);
-    }
-
-    if (auto result = composer->init(); !result) {
-        return base::unexpected("Failed to init the Hwc3Composer instance: "s + result.error());
-    }
-
-    return composer;
-}
-
-Hwc3Composer::Hwc3Composer(Hwc3Composer::Passkey passkey) {
-    ftl::ignore(passkey);
-}
-
-auto Hwc3Composer::init() -> base::expected<void, std::string> {
-    using namespace std::string_literals;
-
-    auto impl = ndk::SharedRefBase::make<Hwc3ComposerImpl>();
-    if (!impl) {
-        return base::unexpected("Failed to construct the Hwc3ComposerImpl instance."s);
-    }
-
-    mImpl = std::move(impl);
-
-    return {};
-}
-
-auto Hwc3Composer::getComposer() -> std::shared_ptr<Hwc3IComposer> {
-    return mImpl;
-}
-
-void Hwc3Composer::addDisplay(const core::DisplayConfiguration& display) {
-    UNIMPLEMENTED(WARNING);
-    ftl::ignore(display, mImpl);
-}
-
-void Hwc3Composer::removeDisplay(core::DisplayConfiguration::Id displayId) {
-    UNIMPLEMENTED(WARNING);
-    ftl::ignore(displayId, mImpl);
-}
-
-}  // namespace android::surfaceflinger::tests::end2end::test_framework::fake_hwc3
diff --git a/services/surfaceflinger/tests/end2end/test_framework/hwc3/DisplayVSyncEventService.cpp b/services/surfaceflinger/tests/end2end/test_framework/hwc3/DisplayVSyncEventService.cpp
new file mode 100644
index 0000000000..13f1fd8648
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/hwc3/DisplayVSyncEventService.cpp
@@ -0,0 +1,106 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <memory>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include <android-base/expected.h>
+#include <android-base/logging.h>
+#include <ftl/ignore.h>
+
+#include "test_framework/core/GuardedSharedState.h"
+#include "test_framework/hwc3/DisplayVSyncEventService.h"
+#include "test_framework/hwc3/MultiDisplayRefreshEventGenerator.h"
+#include "test_framework/hwc3/SingleDisplayRefreshSchedule.h"
+#include "test_framework/hwc3/TimeKeeperThread.h"
+#include "test_framework/hwc3/events/VSync.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::hwc3 {
+
+struct DisplayVSyncEventService::Passkey final {};
+
+auto DisplayVSyncEventService::make()
+        -> base::expected<std::shared_ptr<DisplayVSyncEventService>, std::string> {
+    using namespace std::string_literals;
+
+    auto service = std::make_unique<DisplayVSyncEventService>(Passkey{});
+    if (service == nullptr) {
+        return base::unexpected("Failed to construct the DisplayVSyncEventService"s);
+    }
+    if (auto result = service->init(); !result) {
+        return base::unexpected("Failed to init the DisplayVSyncEventService: "s + result.error());
+    }
+    return service;
+}
+
+DisplayVSyncEventService::DisplayVSyncEventService(Passkey passkey) {
+    ftl::ignore(passkey);
+}
+
+auto DisplayVSyncEventService::init() -> base::expected<void, std::string> {
+    auto timekeeperMake = TimeKeeperThread::make();
+    if (!timekeeperMake) {
+        return base::unexpected(std::move(timekeeperMake.error()));
+    }
+
+    mTimeKeeper = *std::move(timekeeperMake);
+    mTimeKeeper->editCallbacks().onWakeup.set(
+            [this](TimeInterval sleeping) -> TimePoint { return onWakeup(sleeping); })();
+    return {};
+}
+
+auto DisplayVSyncEventService::editCallbacks() -> Callbacks& {
+    return mCallbacks;
+}
+
+void DisplayVSyncEventService::addDisplay(DisplayId displayId,
+                                          SingleDisplayRefreshSchedule schedule) {
+    mGenerator.withExclusiveLock([displayId, schedule](auto& generator) {
+        LOG(VERBOSE) << "addDisplay: " << displayId << " schedule: " << toString(schedule);
+        generator.addDisplay(displayId, schedule);
+    });
+
+    mTimeKeeper->wakeNow();
+}
+
+void DisplayVSyncEventService::removeDisplay(DisplayId displayId) {
+    mGenerator.withExclusiveLock([displayId](auto& generator) {
+        LOG(VERBOSE) << "remove " << displayId;
+        generator.removeDisplay(displayId);
+    });
+}
+
+auto DisplayVSyncEventService::onWakeup(TimeInterval elapsed) -> TimePoint {
+    // Obtain all the events to emit.
+    auto result = mGenerator.withExclusiveLock(
+            [elapsed](auto& generator) { return generator.generateEventsFor(elapsed); });
+
+    // Emit them via the connector interface.
+    LOG(VERBOSE) << "emitting " << result.events.size() << " events";
+    for (const auto& event : result.events) {
+        LOG(VERBOSE) << "displayId: " << event.displayId
+                     << " timestamp: " << event.expectedAt.time_since_epoch()
+                     << " period: " << event.expectedPeriod;
+        mCallbacks.onVSync(event);
+    }
+
+    LOG(VERBOSE) << "next wakeup " << result.nextRefreshAt.time_since_epoch();
+    return result.nextRefreshAt;
+}
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::hwc3
diff --git a/services/surfaceflinger/tests/end2end/test_framework/hwc3/DisplayVSyncEventService.h b/services/surfaceflinger/tests/end2end/test_framework/hwc3/DisplayVSyncEventService.h
new file mode 100644
index 0000000000..78e6c17f0b
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/hwc3/DisplayVSyncEventService.h
@@ -0,0 +1,74 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <chrono>
+#include <memory>
+#include <string>
+
+#include <android-base/expected.h>
+
+#include "test_framework/core/DisplayConfiguration.h"
+#include "test_framework/core/GuardedSharedState.h"
+#include "test_framework/core/TimeInterval.h"
+#include "test_framework/hwc3/MultiDisplayRefreshEventGenerator.h"
+#include "test_framework/hwc3/SingleDisplayRefreshSchedule.h"
+#include "test_framework/hwc3/events/VSync.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::hwc3 {
+
+class TimeKeeperThread;
+
+class DisplayVSyncEventService final {
+    struct Passkey;  // Uses the passkey idiom to restrict construction.
+
+  public:
+    struct Callbacks final {
+        events::VSync::AsyncConnector onVSync;
+    };
+
+    using DisplayId = core::DisplayConfiguration::Id;
+
+    [[nodiscard]] static auto make()
+            -> base::expected<std::shared_ptr<DisplayVSyncEventService>, std::string>;
+
+    explicit DisplayVSyncEventService(Passkey passkey);
+
+    [[nodiscard]] auto editCallbacks() -> Callbacks&;
+
+    void addDisplay(DisplayId displayId, SingleDisplayRefreshSchedule schedule);
+
+    void removeDisplay(DisplayId displayId);
+
+  private:
+    using TimePoint = std::chrono::steady_clock::time_point;
+    using Duration = std::chrono::steady_clock::duration;
+    using TimeInterval = core::TimeInterval;
+
+    auto init() -> base::expected<void, std::string>;
+    auto onWakeup(TimeInterval elapsed) -> TimePoint;
+
+    core::GuardedSharedState<MultiDisplayRefreshEventGenerator> mGenerator;
+
+    // No mutex needed.
+    Callbacks mCallbacks;
+
+    // Note: The time keeper thread should be destroyed first, so is declared last.
+    std::unique_ptr<TimeKeeperThread> mTimeKeeper;
+};
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::hwc3
diff --git a/services/surfaceflinger/tests/end2end/test_framework/hwc3/FakeComposer.cpp b/services/surfaceflinger/tests/end2end/test_framework/hwc3/FakeComposer.cpp
new file mode 100644
index 0000000000..25fdacd6af
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/hwc3/FakeComposer.cpp
@@ -0,0 +1,829 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <algorithm>
+#include <array>
+#include <chrono>
+#include <cstddef>
+#include <cstdint>
+#include <functional>
+#include <initializer_list>
+#include <memory>
+#include <optional>
+#include <ratio>
+#include <source_location>
+#include <string>
+#include <string_view>
+#include <unordered_map>
+#include <utility>
+#include <vector>
+
+#include <aidl/android/hardware/graphics/common/DisplayHotplugEvent.h>
+#include <aidl/android/hardware/graphics/common/Transform.h>
+#include <aidl/android/hardware/graphics/composer3/Capability.h>
+#include <aidl/android/hardware/graphics/composer3/ColorMode.h>
+#include <aidl/android/hardware/graphics/composer3/CommandResultPayload.h>
+#include <aidl/android/hardware/graphics/composer3/ContentType.h>
+#include <aidl/android/hardware/graphics/composer3/DisplayCapability.h>
+#include <aidl/android/hardware/graphics/composer3/DisplayCommand.h>
+#include <aidl/android/hardware/graphics/composer3/DisplayConnectionType.h>
+#include <aidl/android/hardware/graphics/composer3/IComposer.h>
+#include <aidl/android/hardware/graphics/composer3/IComposerCallback.h>
+#include <aidl/android/hardware/graphics/composer3/IComposerClient.h>
+#include <aidl/android/hardware/graphics/composer3/PerFrameMetadataKey.h>
+#include <aidl/android/hardware/graphics/composer3/PowerMode.h>
+#include <aidl/android/hardware/graphics/composer3/PresentOrValidate.h>
+#include <aidl/android/hardware/graphics/composer3/RenderIntent.h>
+#include <android-base/expected.h>
+#include <android-base/logging.h>
+#include <android/binder_auto_utils.h>
+#include <android/binder_interface_utils.h>
+#include <android/binder_status.h>
+#include <fmt/format.h>
+#include <ftl/ignore.h>
+
+#include "test_framework/core/AsyncFunction.h"
+#include "test_framework/core/DisplayConfiguration.h"
+#include "test_framework/core/EdidBuilder.h"
+#include "test_framework/core/GuardedSharedState.h"
+#include "test_framework/hwc3/DisplayVSyncEventService.h"
+#include "test_framework/hwc3/FakeComposer.h"
+#include "test_framework/hwc3/FakeDisplayConfiguration.h"
+#include "test_framework/hwc3/SingleDisplayRefreshSchedule.h"
+#include "test_framework/hwc3/delegators/Composer.h"
+#include "test_framework/hwc3/delegators/ComposerClient.h"
+#include "test_framework/hwc3/events/VSync.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::hwc3 {
+
+using Capability = aidl::android::hardware::graphics::composer3::Capability;
+using CommandError = aidl::android::hardware::graphics::composer3::CommandError;
+using CommandResultPayload = aidl::android::hardware::graphics::composer3::CommandResultPayload;
+using DisplayCommand = aidl::android::hardware::graphics::composer3::DisplayCommand;
+using IComposer = aidl::android::hardware::graphics::composer3::IComposer;
+using IComposerCallback = aidl::android::hardware::graphics::composer3::IComposerCallback;
+using IComposerClient = aidl::android::hardware::graphics::composer3::IComposerClient;
+using PresentOrValidate = aidl::android::hardware::graphics::composer3::PresentOrValidate;
+
+class ValueName {
+    template <auto Value>
+    static consteval auto pretty() -> std::string_view {
+        return __PRETTY_FUNCTION__;
+    }
+
+    static constexpr void exemplar();  // Intentionally declared but not defined.
+
+    static consteval auto trim(std::string_view name) -> std::string_view {
+        constexpr std::string_view expected = "&std::source_location::line";
+        constexpr std::string_view ref = pretty<&std::source_location::line>();
+        constexpr size_t prefixLength = ref.rfind(expected);
+        static_assert(prefixLength != std::string_view::npos);
+        constexpr size_t suffixLength = ref.size() - prefixLength - expected.size();
+        static_assert(prefixLength + suffixLength + expected.size() == ref.size());
+
+        name = name.substr(prefixLength, name.size() - suffixLength - prefixLength);
+        if (name.starts_with('&')) {
+            name = name.substr(1);
+        }
+        if (auto prefix = name.rfind("::"); prefix != std::string_view::npos) {
+            name = name.substr(prefix + 2);
+        }
+        return name;
+    }
+
+    template <size_t... Indices>
+    static consteval auto copy(std::string_view input, std::index_sequence<Indices...> sequence)
+            -> std::array<char, 1 + sizeof...(Indices)> {
+        ftl::ignore(sequence);
+        return {input[Indices]..., 0};
+    }
+
+    template <auto Value>
+    static consteval auto operator()() -> std::string_view {
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wdeprecated-declarations"
+        constexpr auto name = trim(pretty<Value>());
+#pragma clang diagnostic pop
+        static constexpr auto copied = copy(name, std::make_index_sequence<name.size()>{});
+        return copied.data();
+    }
+
+  public:
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wdeprecated-declarations"
+    template <auto Value>
+    static constexpr auto value = operator()<Value>();
+#pragma clang diagnostic pop
+};
+
+template <typename Interface, template <typename> typename Delegator>
+class FatalIfUnhandled : public Delegator<FatalIfUnhandled<Interface, Delegator>> {
+  public:
+    // Attempts to extract just the base function name from a source_location::function_name()
+    constexpr static auto terseFunctionName(std::string_view input) {
+        auto suffix = input.find('(');
+        if (suffix != std::string_view::npos) {
+            auto remainder = input.substr(0, suffix);
+            auto prefix = remainder.rfind("::");
+            if (prefix != std::string_view::npos) {
+                return remainder.substr(prefix + 2);
+            }
+        }
+        return input;
+    }
+
+    [[nodiscard]] static auto makeIgnoredMessage(std::string_view functionName) -> std::string {
+        return fmt::format("Ignoring {}.", functionName);
+    }
+
+    [[nodiscard]] static auto ignore(
+            const std::string& message = makeIgnoredMessage(terseFunctionName(
+                    std::source_location::current().function_name()))) -> ndk::ScopedAStatus {
+        LOG(DEBUG) << message;
+        return ndk::ScopedAStatus::ok();
+    }
+
+    [[nodiscard]] static auto makeUnsupportedMessage(std::string_view functionName) -> std::string {
+        return fmt::format("{} is not implemented by the test fake.",
+                           terseFunctionName(functionName));
+    }
+
+    [[nodiscard]] static auto unsupported(
+            const std::string& message = makeUnsupportedMessage(terseFunctionName(
+                    std::source_location::current().function_name()))) -> ndk::ScopedAStatus {
+        LOG(DEBUG) << message;
+        return ndk::ScopedAStatus::fromExceptionCodeWithMessage(EX_UNSUPPORTED_OPERATION,
+                                                                message.c_str());
+    }
+
+    [[nodiscard]] static auto unsupportedFatal(
+            const std::string& message = makeUnsupportedMessage(
+                    std::source_location::current().function_name())) -> ndk::ScopedAStatus {
+        LOG(FATAL) << message;
+        return ndk::ScopedAStatus::fromExceptionCodeWithMessage(EX_UNSUPPORTED_OPERATION,
+                                                                message.c_str());
+    }
+
+    template <auto MemberFn, typename... Args>
+    auto operator()(Args&&... args) -> ndk::ScopedAStatus {
+        ftl::ignore(std::forward<decltype(args)>(args)...);
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wdeprecated-declarations"
+        return unsupportedFatal(makeUnsupportedMessage(ValueName::value<MemberFn>));
+#pragma clang diagnostic pop
+    }
+};
+
+using DefaultComposerClientImpl = FatalIfUnhandled<IComposerClient, delegators::ComposerClient>;
+
+using DefaultComposerImpl = FatalIfUnhandled<IComposer, delegators::Composer>;
+
+// Local simplified fork of ComposerServiceWriter from
+// android/hardware/graphics/composer3/ComposerServiceWriter.h
+//
+// Using that header library directly assumes the latest version of the AIDL interfaces, but that
+// conflicts with the choice here to use an older but stable version of the interface.
+struct ComposerServiceWriter {
+    void setError(int32_t index, int32_t errorCode) {
+        mCommandsResults.emplace_back(CommandError{.commandIndex = index, .errorCode = errorCode});
+    }
+
+    void setPresentOrValidateResult(int64_t display, PresentOrValidate::Result result) {
+        mCommandsResults.emplace_back(PresentOrValidate{.display = display, .result = result});
+    }
+
+    auto getPendingCommandResults() -> std::vector<CommandResultPayload> {
+        return std::move(mCommandsResults);
+    }
+
+  private:
+    std::vector<CommandResultPayload> mCommandsResults;
+};
+
+struct ClientImpl final : public DefaultComposerClientImpl {
+    struct Callbacks final {
+        using OptDisplayConfiguration = std::optional<FakeDisplayConfiguration>;
+
+        using GetDisplayAsyncConnector =
+                core::AsyncFunctionStd<auto(int64_t displayId)->OptDisplayConfiguration>;
+        using GetDisplayIdsAsyncConnector = core::AsyncFunctionStd<auto()->std::vector<int64_t>>;
+
+        // Invoked by the client to get the information for a display, in response to a SF query.
+        GetDisplayAsyncConnector onGetDisplay;
+
+        // Invoked when the client needs to get the connected displays, in response to a SF query.
+        GetDisplayIdsAsyncConnector onGetDisplayIds;
+
+        // Convenience function to reset all the callbacks to have no target/receiver.
+        friend void clearAll(Callbacks& callbacks) {
+            callbacks.onGetDisplay.clear()();
+            callbacks.onGetDisplayIds.clear()();
+        }
+    };
+
+    auto editCallbacks() -> Callbacks& { return mClientCallbacks; }
+
+    auto getComposerClient() -> std::shared_ptr<IComposerClient> { return ref<ClientImpl>(); }
+
+    void sendDisplayAdded(int64_t displayId) {
+        mState.withSharedLock([displayId](const auto& state) {
+            using aidl::android::hardware::graphics::common::DisplayHotplugEvent::CONNECTED;
+            state.composerCallbacks->onHotplugEvent(displayId, CONNECTED);
+        });
+    }
+
+    void sendDisplayRemoved(int64_t displayId) {
+        mState.withSharedLock([displayId](const auto& state) {
+            using aidl::android::hardware::graphics::common::DisplayHotplugEvent::DISCONNECTED;
+            state.composerCallbacks->onHotplugEvent(displayId, DISCONNECTED);
+        });
+    }
+
+    void sendVSync(events::VSync event) {
+        mState.withSharedLock([event](const auto& state) {
+            state.composerCallbacks->onVsync(
+                    event.displayId, event.expectedAt.time_since_epoch().count(),
+                    std::chrono::duration_cast<std::chrono::duration<int32_t, std::nano>>(
+                            event.expectedPeriod)
+                            .count());
+        });
+    }
+
+    // begin IComposerClient overrides
+    // NOLINTBEGIN(bugprone-easily-swappable-parameters)
+
+    auto registerCallback(const std::shared_ptr<IComposerCallback>& in_callback)
+            -> ndk::ScopedAStatus override {
+        LOG(VERBOSE) << __func__;
+
+        mState.withExclusiveLock(
+                [in_callback](auto& state) { state.composerCallbacks = in_callback; });
+
+        const auto optDisplayIds = mClientCallbacks.onGetDisplayIds();
+        CHECK(!!optDisplayIds);
+        const auto& displayIds = *optDisplayIds;
+        mState.withSharedLock([&displayIds](const auto& state) {
+            using aidl::android::hardware::graphics::common::DisplayHotplugEvent::CONNECTED;
+            for (auto displayId : displayIds) {
+                state.composerCallbacks->onHotplugEvent(displayId, CONNECTED);
+            }
+        });
+
+        return ndk::ScopedAStatus::ok();
+    }
+
+    auto executeCommands(const std::vector<DisplayCommand>& in_commands,
+                         std::vector<CommandResultPayload>* out_results)
+            -> ndk::ScopedAStatus override {
+        LOG(VERBOSE) << __func__;
+
+        ComposerServiceWriter writer;
+
+        for (const auto& cmd : in_commands) {
+            LOG(VERBOSE) << cmd.toString();
+
+            // We expect cmd.presentOrValidateDisplay to be true and none of the other flags.
+            if (cmd.validateDisplay || cmd.acceptDisplayChanges || cmd.presentDisplay ||
+                !cmd.presentOrValidateDisplay) {
+                // Assert since this is an unexpected command.
+                return unsupportedFatal(
+                        fmt::format("{}: Unexpected command. cmd={}.", __func__, cmd.toString()));
+            }
+
+            writer.setPresentOrValidateResult(cmd.display, PresentOrValidate::Result::Presented);
+        }
+
+        *out_results = writer.getPendingCommandResults();
+
+        return ndk::ScopedAStatus::ok();
+    }
+
+    auto setClientTargetSlotCount(int64_t in_display,
+                                  int32_t in_clientTargetSlotCount) -> ndk::ScopedAStatus override {
+        return ignore(fmt::format("Ignoring {} for display {} with count {}", __func__, in_display,
+                                  in_clientTargetSlotCount));
+    }
+
+    auto setColorMode(int64_t in_display,
+                      aidl::android::hardware::graphics::composer3::ColorMode in_mode,
+                      aidl::android::hardware::graphics::composer3::RenderIntent in_intent)
+            -> ndk::ScopedAStatus override {
+        return ignore(fmt::format("Ignoring {} for display {} with mode {} and intent {}", __func__,
+                                  in_display, toString(in_mode), toString(in_intent)));
+    }
+
+    auto setPowerMode(int64_t in_display,
+                      aidl::android::hardware::graphics::composer3::PowerMode in_mode)
+            -> ndk::ScopedAStatus override {
+        return ignore(fmt::format("Ignoring {} for display {} with mode {}", __func__, in_display,
+                                  toString(in_mode)));
+    }
+
+    auto setVsyncEnabled(int64_t in_display, bool in_enabled) -> ndk::ScopedAStatus override {
+        return ignore(fmt::format("Ignoring {} for display {} with enabled {}", __func__,
+                                  in_display, in_enabled));
+    }
+
+    auto getActiveConfig(int64_t in_display, int32_t* out_config) -> ndk::ScopedAStatus override {
+        auto result = lookupDisplay(in_display);
+        if (!result) {
+            return std::move(result.error());
+        }
+        const auto& displayConfig = *result;
+        *out_config = displayConfig.activeConfig;
+        return ndk::ScopedAStatus::ok();
+    }
+
+    auto getColorModes(int64_t in_display,
+                       std::vector<aidl::android::hardware::graphics::composer3::ColorMode>*
+                               out_modes) -> ndk::ScopedAStatus override {
+        auto result = lookupDisplay(in_display);
+        if (!result) {
+            return std::move(result.error());
+        }
+        const auto& displayConfig = *result;
+
+        out_modes->clear();
+        out_modes->reserve(displayConfig.renderIntentsForColorMode.size());
+        for (const auto& [mode, _] : displayConfig.renderIntentsForColorMode) {
+            out_modes->push_back(mode);
+        }
+        return ndk::ScopedAStatus::ok();
+    }
+
+    auto getDisplayCapabilities(
+            int64_t in_display,
+            std::vector<aidl::android::hardware::graphics::composer3::DisplayCapability>*
+                    out_capabilities) -> ndk::ScopedAStatus override {
+        auto result = lookupDisplay(in_display);
+        if (!result) {
+            return std::move(result.error());
+        }
+        const auto& displayConfig = *result;
+
+        *out_capabilities = displayConfig.capabilities;
+        return ndk::ScopedAStatus::ok();
+    }
+
+    auto getDisplayConfigs(int64_t in_display,
+                           std::vector<int32_t>* out_configs) -> ndk::ScopedAStatus override {
+        auto result = lookupDisplay(in_display);
+        if (!result) {
+            return std::move(result.error());
+        }
+        const auto& displayConfig = *result;
+
+        out_configs->clear();
+        out_configs->reserve(displayConfig.displayConfigs.size());
+        for (const auto& mode : displayConfig.displayConfigs) {
+            out_configs->push_back(mode.configId);
+        }
+        return ndk::ScopedAStatus::ok();
+    }
+
+    auto getDisplayConnectionType(
+            int64_t in_display,
+            aidl::android::hardware::graphics::composer3::DisplayConnectionType* out_type)
+            -> ndk::ScopedAStatus override {
+        auto result = lookupDisplay(in_display);
+        if (!result) {
+            return std::move(result.error());
+        }
+        const auto& displayConfig = *result;
+        *out_type = displayConfig.connectionType;
+        return ndk::ScopedAStatus::ok();
+    }
+
+    auto getDisplayIdentificationData(
+            int64_t in_display,
+            aidl::android::hardware::graphics::composer3::DisplayIdentification* out_identification)
+            -> ndk::ScopedAStatus override {
+        auto result = lookupDisplay(in_display);
+        if (!result) {
+            return std::move(result.error());
+        }
+        const auto& displayConfig = *result;
+        *out_identification = displayConfig.identification;
+        return ndk::ScopedAStatus::ok();
+    }
+    auto getDisplayVsyncPeriod(int64_t in_display,
+                               int32_t* out_period) -> ndk::ScopedAStatus override {
+        auto result = lookupDisplay(in_display);
+        if (!result) {
+            return std::move(result.error());
+        }
+        const auto& displayConfig = *result;
+
+        const auto found = std::ranges::find_if(
+                displayConfig.displayConfigs, [&displayConfig](const auto& config) {
+                    return config.configId == displayConfig.activeConfig;
+                });
+
+        CHECK(found != displayConfig.displayConfigs.end())
+                << "getDisplayVsyncPeriod internal error. Unable to find config for "
+                   "activeConfig.";
+
+        *out_period = found->vsyncPeriod;
+
+        return ndk::ScopedAStatus::ok();
+    }
+
+    auto getDisplayPhysicalOrientation(int64_t in_display,
+                                       aidl::android::hardware::graphics::common::Transform*
+                                               out_orientation) -> ndk::ScopedAStatus override {
+        auto result = lookupDisplay(in_display);
+        if (!result) {
+            return std::move(result.error());
+        }
+        const auto& displayConfig = *result;
+
+        *out_orientation = displayConfig.transform;
+        return ndk::ScopedAStatus::ok();
+    }
+
+    auto getHdrCapabilities(int64_t in_display,
+                            aidl::android::hardware::graphics::composer3::HdrCapabilities*
+                                    out_capabilities) -> ndk::ScopedAStatus override {
+        auto result = lookupDisplay(in_display);
+        if (!result) {
+            return std::move(result.error());
+        }
+        const auto& displayConfig = *result;
+
+        *out_capabilities = displayConfig.hdrCapabilities;
+        return ndk::ScopedAStatus::ok();
+    }
+
+    auto getPerFrameMetadataKeys(
+            int64_t in_display,
+            std::vector<aidl::android::hardware::graphics::composer3::PerFrameMetadataKey>*
+                    out_metadataKeys) -> ndk::ScopedAStatus override {
+        auto result = lookupDisplay(in_display);
+        if (!result) {
+            return std::move(result.error());
+        }
+        const auto& displayConfig = *result;
+
+        *out_metadataKeys = displayConfig.perFrameMetadataKeys;
+        return ndk::ScopedAStatus::ok();
+    }
+
+    auto getRenderIntents(int64_t in_display,
+                          aidl::android::hardware::graphics::composer3::ColorMode in_mode,
+                          std::vector<aidl::android::hardware::graphics::composer3::RenderIntent>*
+                                  out_intents) -> ndk::ScopedAStatus override {
+        auto result = lookupDisplay(in_display);
+        if (!result) {
+            return std::move(result.error());
+        }
+        const auto& displayConfig = *result;
+
+        if (auto found = displayConfig.renderIntentsForColorMode.find(in_mode);
+            found != displayConfig.renderIntentsForColorMode.end()) {
+            *out_intents = found->second;
+            return ndk::ScopedAStatus::ok();
+        }
+        return ndk::ScopedAStatus::fromServiceSpecificError(ClientImpl::EX_BAD_PARAMETER);
+    }
+
+    auto getSupportedContentTypes(
+            int64_t in_display,
+            std::vector<aidl::android::hardware::graphics::composer3::ContentType>* out_types)
+            -> ndk::ScopedAStatus override {
+        auto result = lookupDisplay(in_display);
+        if (!result) {
+            return std::move(result.error());
+        }
+        const auto& displayConfig = *result;
+
+        *out_types = displayConfig.supportedContentTypes;
+        return ndk::ScopedAStatus::ok();
+    }
+
+    auto getDisplayConfigurations(
+            int64_t in_display, int32_t in_maxFrameIntervalNs,
+            std::vector<aidl::android::hardware::graphics::composer3::DisplayConfiguration>*
+                    out_configurations) -> ndk::ScopedAStatus override {
+        auto result = lookupDisplay(in_display);
+        if (!result) {
+            return std::move(result.error());
+        }
+        const auto& displayConfig = *result;
+
+        const auto maxFrameInterval = std::chrono::nanoseconds(in_maxFrameIntervalNs);
+        out_configurations->clear();
+        out_configurations->reserve(displayConfig.displayConfigs.size());
+        for (const auto& mode : displayConfig.displayConfigs) {
+            if (mode.vsyncPeriod <= maxFrameInterval.count()) {
+                out_configurations->push_back(mode);
+            }
+        }
+
+        return ndk::ScopedAStatus::ok();
+    }
+
+    auto getOverlaySupport(aidl::android::hardware::graphics::composer3::OverlayProperties*
+                                   out_properties) -> ndk::ScopedAStatus override {
+        ftl::ignore(out_properties);
+        return unsupported();
+    }
+
+    auto getHdrConversionCapabilities(
+            std::vector<aidl::android::hardware::graphics::common::HdrConversionCapability>*
+                    out_capabilities) -> ndk::ScopedAStatus override {
+        ftl::ignore(out_capabilities);
+        return unsupported();
+    }
+
+    // NOLINTEND(bugprone-easily-swappable-parameters)
+    // end IComposerClient overrides
+
+  private:
+    [[nodiscard]] auto lookupDisplay(
+            int64_t display, std::source_location location = std::source_location::current()) const
+            -> base::expected<FakeDisplayConfiguration, ndk::ScopedAStatus> {
+        // Obtains the display configuration from the FakeComposerImpl instance.
+        LOG(VERBOSE) << terseFunctionName(location.function_name()) << " looking up display "
+                     << display;
+        const auto optOptDisplayConfig = mClientCallbacks.onGetDisplay(display);
+
+        // The first optional is nullopt when the callback isn't connected.
+        CHECK(!!optOptDisplayConfig) << terseFunctionName(location.function_name())
+                                     << ": Display lookup failed - no composer for client.";
+
+        // The second optional is nullopt when the display id is invalid.
+        const auto& optDisplayConfig = *optOptDisplayConfig;
+        if (!optDisplayConfig) {
+            LOG(INFO) << terseFunctionName(location.function_name())
+                      << " was invoked with an unrecognized display id " << display << ".";
+            return base::unexpected(
+                    ndk::ScopedAStatus::fromServiceSpecificError(ClientImpl::EX_BAD_DISPLAY));
+        }
+        return *optDisplayConfig;
+    }
+
+    struct State {
+        std::shared_ptr<IComposerCallback> composerCallbacks;
+    };
+    core::GuardedSharedState<State> mState;
+    Callbacks mClientCallbacks;
+};
+
+struct FakeComposer::ComposerImpl final : public DefaultComposerImpl {
+    auto init() -> base::expected<void, std::string> {
+        auto displayVsyncEventServiceResult = DisplayVSyncEventService::make();
+        if (!displayVsyncEventServiceResult) {
+            return base::unexpected(std::move(displayVsyncEventServiceResult).error());
+        }
+
+        mDisplayVSyncEventService = *std::move(displayVsyncEventServiceResult);
+        mDisplayVSyncEventService->editCallbacks().onVSync.set(
+                [this](auto event) { onVsyncEventGenerated(event); })();
+
+        return {};
+    }
+
+    auto getComposer() -> std::shared_ptr<IComposer> { return ref<ComposerImpl>(); }
+
+    void addDisplay(const core::DisplayConfiguration& display) {
+        auto client = mState.withExclusiveLock([&display](auto& state) {
+            if (!state.initialDisplayId) {
+                state.initialDisplayId = display.id;
+            }
+
+            const std::string kMagicPrefix = "fake";
+            const std::string encodedId = fmt::format("{}{}", kMagicPrefix, display.id);
+            CHECK(encodedId.size() < core::EdidBuilder::kMaxProductNameStringLength);
+
+            const auto timing = core::EdidBuilder::DigitalSeparateDetailedTimingDescriptor::
+                    k1920x1080x60HzStandard;
+            const auto edid = core::EdidBuilder()
+                                      .set({.preferred = {.timing = timing}})
+                                      .addDisplayProductNameStringDescriptor(encodedId)
+                                      .build();
+
+            state.configuredDisplays[display.id] =
+                    hwc3::FakeDisplayConfiguration::Builder().setIdentification({
+                            .port = 0,
+                            .data = {edid.begin(), edid.end()},
+                    })();
+
+            return state.client;
+        });
+
+        if (client) {
+            client->sendDisplayAdded(display.id);
+        }
+    }
+
+    void removeDisplay(core::DisplayConfiguration::Id displayId) {
+        mDisplayVSyncEventService->removeDisplay(displayId);
+
+        auto client = mState.withExclusiveLock([displayId](auto& state) {
+            if (state.initialDisplayId == displayId) {
+                state.initialDisplayId.reset();
+            }
+            state.configuredDisplays.erase(displayId);
+            return state.client;
+        });
+
+        if (client) {
+            client->sendDisplayRemoved(displayId);
+        }
+    }
+
+  private:
+    // begin IComposer overrides
+
+    auto dump(int dumpFd, const char** args, uint32_t num_args) -> binder_status_t override {
+        ftl::ignore(dumpFd, args, num_args);
+        ftl::ignore = unsupported();
+        return STATUS_INVALID_OPERATION;
+    }
+
+    auto createClient(std::shared_ptr<IComposerClient>* out_client) -> ndk::ScopedAStatus override {
+        const bool expired =
+                mState.withSharedLock([](auto& state) { return state.client == nullptr; });
+
+        if (!expired) {
+            return ndk::ScopedAStatus::fromServiceSpecificErrorWithMessage(
+                    IComposer::EX_NO_RESOURCES, "Client already created and valid");
+        }
+
+        auto client = ndk::SharedRefBase::make<ClientImpl>();
+        if (!client) {
+            LOG(ERROR) << "Failed to allocate a FakeClient instance.";
+            return ndk::ScopedAStatus::fromServiceSpecificErrorWithMessage(
+                    IComposer::EX_NO_RESOURCES, "Client failed to initialize");
+        }
+
+        auto& callbacks = client->editCallbacks();
+        using Self = ComposerImpl;
+        callbacks.onGetDisplay.set(std::bind_front(&Self::getDisplay, this))();
+        callbacks.onGetDisplayIds.set(std::bind_front(&Self::getDisplayIds, this))();
+
+        *out_client = client->getComposerClient();
+        mState.withExclusiveLock(
+                [client = std::move(client)](auto& state) { state.client = client; });
+
+        return ndk::ScopedAStatus::ok();
+    }
+
+    auto getCapabilities(std::vector<Capability>* out_capabilities) -> ndk::ScopedAStatus override {
+        out_capabilities->assign({
+                Capability::PRESENT_FENCE_IS_NOT_RELIABLE,
+                Capability::LAYER_LIFECYCLE_BATCH_COMMAND,
+        });
+        return ndk::ScopedAStatus::ok();
+    }
+
+    // end IComposer overrides
+
+    auto getDisplay(int64_t displayId) const -> std::optional<FakeDisplayConfiguration> {
+        return mState.withSharedLock([displayId](auto& state) {
+            const auto found = state.configuredDisplays.find(displayId);
+            return (found != state.configuredDisplays.end()) ? std::make_optional(found->second)
+                                                             : std::nullopt;
+        });
+    }
+
+    auto getDisplayIds() const -> std::vector<int64_t> {
+        return mState.withSharedLock([&](auto& state) {
+            std::vector<int64_t> ids;
+            ids.reserve(state.configuredDisplays.size());
+            if (state.initialDisplayId) {
+                ids.push_back(*state.initialDisplayId);
+            }
+            for (const auto& [id, config] : state.configuredDisplays) {
+                if (id != state.initialDisplayId) {
+                    ids.push_back(id);
+                }
+            }
+            return ids;
+        });
+    }
+
+    void onVsyncEventGenerated(events::VSync event) {
+        if (auto client = mState.withSharedLock([](const auto& state) { return state.client; })) {
+            client->sendVSync(event);
+        }
+    }
+
+    void onVsyncEnabledChanged(int64_t displayId, bool enable) const {
+        LOG(VERBOSE) << __func__;
+        mState.withSharedLock([this, displayId, enable](const auto& state) {
+            LOG(INFO) << "displayId: " << displayId << " enable: " << enable;
+            if (!enable) {
+                mDisplayVSyncEventService->removeDisplay(displayId);
+                return;
+            }
+
+            auto found = state.configuredDisplays.find(displayId);
+            if (found == state.configuredDisplays.end()) {
+                LOG(WARNING) << "No display " << displayId << " to configure vsync generation.";
+                return;
+            }
+            const auto& display = found->second;
+            auto foundConfig = std::ranges::find_if(
+                    display.displayConfigs, [configId = display.activeConfig](const auto& config) {
+                        return config.configId == configId;
+                    });
+            if (foundConfig == display.displayConfigs.end()) {
+                LOG(WARNING) << "No config " << display.activeConfig << " for display " << displayId
+                             << " to configure vsync generation.";
+                return;
+            }
+            const auto& config = *foundConfig;
+
+            using TimePoint = std::chrono::steady_clock::time_point;
+            using Duration = std::chrono::steady_clock::duration;
+
+            LOG(WARNING) << "Assuming a base of zero for vsync timing!";
+            const TimePoint base{Duration(0)};
+            const auto period = Duration(config.vsyncPeriod);
+            mDisplayVSyncEventService->addDisplay(
+                    displayId, SingleDisplayRefreshSchedule{.base = base, .period = period});
+        });
+    }
+
+    std::shared_ptr<DisplayVSyncEventService> mDisplayVSyncEventService;
+
+    struct State {
+        std::shared_ptr<ClientImpl> client;
+        std::optional<int64_t> initialDisplayId;
+        std::unordered_map<int64_t, FakeDisplayConfiguration> configuredDisplays;
+    };
+    core::GuardedSharedState<State> mState;
+};
+
+struct FakeComposer::Passkey final {};
+
+auto FakeComposer::getServiceName(std::string_view baseServiceName) -> std::string {
+    return ComposerImpl::makeServiceName(baseServiceName);
+}
+
+auto FakeComposer::make() -> base::expected<std::shared_ptr<FakeComposer>, std::string> {
+    using namespace std::string_literals;
+
+    auto composer = std::make_shared<FakeComposer>(Passkey{});
+    if (composer == nullptr) {
+        return base::unexpected("Failed to construct the FakeComposer instance."s);
+    }
+
+    if (auto result = composer->init(); !result) {
+        return base::unexpected("Failed to init the FakeComposer instance: "s + result.error());
+    }
+
+    return composer;
+}
+
+FakeComposer::FakeComposer(FakeComposer::Passkey passkey) {
+    ftl::ignore(passkey);
+}
+
+auto FakeComposer::init() -> base::expected<void, std::string> {
+    using namespace std::string_literals;
+
+    auto impl = ndk::SharedRefBase::make<ComposerImpl>();
+    if (!impl) {
+        return base::unexpected("Failed to construct the ComposerImpl instance."s);
+    }
+
+    if (auto result = impl->init(); !result) {
+        return base::unexpected("Failed to init the ComposerImpl instance: "s + result.error());
+    }
+
+    mImpl = std::move(impl);
+
+    return {};
+}
+
+auto FakeComposer::getComposer() -> std::shared_ptr<IComposer> {
+    CHECK(mImpl != nullptr);
+    return mImpl;
+}
+
+void FakeComposer::addDisplay(const core::DisplayConfiguration& display) {
+    CHECK(mImpl != nullptr);
+    mImpl->addDisplay(display);
+}
+
+void FakeComposer::removeDisplay(core::DisplayConfiguration::Id displayId) {
+    CHECK(mImpl != nullptr);
+    mImpl->removeDisplay(displayId);
+}
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::hwc3
diff --git a/services/surfaceflinger/tests/end2end/test_framework/fake_hwc3/Hwc3Composer.h b/services/surfaceflinger/tests/end2end/test_framework/hwc3/FakeComposer.h
similarity index 79%
rename from services/surfaceflinger/tests/end2end/test_framework/fake_hwc3/Hwc3Composer.h
rename to services/surfaceflinger/tests/end2end/test_framework/hwc3/FakeComposer.h
index 6d6b7374c6..70a6db32f4 100644
--- a/services/surfaceflinger/tests/end2end/test_framework/fake_hwc3/Hwc3Composer.h
+++ b/services/surfaceflinger/tests/end2end/test_framework/hwc3/FakeComposer.h
@@ -25,26 +25,26 @@
 
 #include "test_framework/core/DisplayConfiguration.h"
 
-namespace android::surfaceflinger::tests::end2end::test_framework::fake_hwc3 {
+namespace android::surfaceflinger::tests::end2end::test_framework::hwc3 {
 
-class Hwc3Composer final {
+class FakeComposer final {
     struct Passkey;  // Uses the passkey idiom to restrict construction.
 
-    class Hwc3ComposerImpl;  // An internal class implements the AIDL interface.
+    struct ComposerImpl;  // An internal class implements the AIDL interface.
 
   public:
-    using Hwc3IComposer = aidl::android::hardware::graphics::composer3::IComposer;
+    using IComposer = aidl::android::hardware::graphics::composer3::IComposer;
 
     // Gets the full qualified service name given a base name for the service.
     [[nodiscard]] static auto getServiceName(std::string_view baseServiceName) -> std::string;
 
-    // Constructs a Hwc3Composer instance.
-    [[nodiscard]] static auto make() -> base::expected<std::shared_ptr<Hwc3Composer>, std::string>;
+    // Constructs a FakeComposer instance.
+    [[nodiscard]] static auto make() -> base::expected<std::shared_ptr<FakeComposer>, std::string>;
 
-    explicit Hwc3Composer(Passkey passkey);
+    explicit FakeComposer(Passkey passkey);
 
     // Obtains the AIDL composer3::IComposer interface for the internal instance.
-    [[nodiscard]] auto getComposer() -> std::shared_ptr<Hwc3IComposer>;
+    [[nodiscard]] auto getComposer() -> std::shared_ptr<IComposer>;
 
     // Adds a display to the composer. This will sent a hotplug connect event.
     void addDisplay(const core::DisplayConfiguration& display);
@@ -55,7 +55,7 @@ class Hwc3Composer final {
   private:
     [[nodiscard]] auto init() -> base::expected<void, std::string>;
 
-    std::shared_ptr<Hwc3ComposerImpl> mImpl;
+    std::shared_ptr<ComposerImpl> mImpl;
 };
 
-}  // namespace android::surfaceflinger::tests::end2end::test_framework::fake_hwc3
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::hwc3
diff --git a/services/surfaceflinger/tests/end2end/test_framework/hwc3/FakeDisplayConfiguration.h b/services/surfaceflinger/tests/end2end/test_framework/hwc3/FakeDisplayConfiguration.h
new file mode 100644
index 0000000000..933a91b77a
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/hwc3/FakeDisplayConfiguration.h
@@ -0,0 +1,296 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <algorithm>
+#include <chrono>
+#include <cstdint>
+#include <initializer_list>
+#include <optional>
+#include <unordered_map>
+#include <utility>
+#include <vector>
+
+#include <aidl/android/hardware/graphics/common/Transform.h>
+#include <aidl/android/hardware/graphics/composer3/ColorMode.h>
+#include <aidl/android/hardware/graphics/composer3/ContentType.h>
+#include <aidl/android/hardware/graphics/composer3/DisplayCapability.h>
+#include <aidl/android/hardware/graphics/composer3/DisplayConfiguration.h>
+#include <aidl/android/hardware/graphics/composer3/DisplayConnectionType.h>
+#include <aidl/android/hardware/graphics/composer3/DisplayIdentification.h>
+#include <aidl/android/hardware/graphics/composer3/HdrCapabilities.h>
+#include <aidl/android/hardware/graphics/composer3/PerFrameMetadataKey.h>
+#include <aidl/android/hardware/graphics/composer3/RenderIntent.h>
+#include <android-base/logging.h>
+#include <ftl/ignore.h>
+#include <ui/Size.h>
+
+#include "test_framework/core/EdidBuilder.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::hwc3 {
+
+// An interface for tests to control the fake HWC implementation.
+struct FakeDisplayConfiguration final {
+    using Hwc3ColorMode = aidl::android::hardware::graphics::composer3::ColorMode;
+    using Hwc3ContentType = aidl::android::hardware::graphics::composer3::ContentType;
+    using Hwc3DisplayCapability = aidl::android::hardware::graphics::composer3::DisplayCapability;
+    using Hwc3DisplayConfiguration =
+            aidl::android::hardware::graphics::composer3::DisplayConfiguration;
+    using Hwc3DisplayConnectionType =
+            aidl::android::hardware::graphics::composer3::DisplayConnectionType;
+    using Hwc3DisplayIdentification =
+            aidl::android::hardware::graphics::composer3::DisplayIdentification;
+    using Hwc3HdrCapabilities = aidl::android::hardware::graphics::composer3::HdrCapabilities;
+    using Hwc3PerFrameMetadataKey =
+            aidl::android::hardware::graphics::composer3::PerFrameMetadataKey;
+    using Hwc3RenderIntent = aidl::android::hardware::graphics::composer3::RenderIntent;
+    using Hwc3Transform = aidl::android::hardware::graphics::common::Transform;
+    using Hwc3VrrConfig = aidl::android::hardware::graphics::composer3::VrrConfig;
+
+    using Hwc3DisplayCapabilities = std::vector<Hwc3DisplayCapability>;
+    using Hwc3DisplayConfigurations = std::vector<Hwc3DisplayConfiguration>;
+    using Hwc3PerFrameMetadataKeys = std::vector<Hwc3PerFrameMetadataKey>;
+    using Hwc3ContentTypes = std::vector<Hwc3ContentType>;
+
+    struct Builder final {
+        // NOLINTBEGIN(readability-convert-member-functions-to-static)
+        // clang-tidy incorrectly shows this error for C++23 "deducing this" methods.
+
+        [[nodiscard]] auto activeConfigId(this Builder&& self,
+                                          int32_t activeConfigId) -> Builder&& {
+            self.mActiveConfig = activeConfigId;
+            return std::move(self);
+        }
+
+        [[nodiscard]] auto setCapabilities(this Builder&& self,
+                                           Hwc3DisplayCapabilities& values) -> Builder&& {
+            self.mCapabilities = std::move(values);
+            return std::move(self);
+        }
+
+        [[nodiscard]] auto setConnectionType(this Builder&& self,
+                                             Hwc3DisplayConnectionType value) -> Builder&& {
+            self.mConnectionType = value;
+            return std::move(self);
+        }
+
+        [[nodiscard]] auto addDisplayConfig(this Builder&& self, int32_t configId,
+                                            ui::Size physicalPixels,
+                                            int32_t refreshRateHz) -> Builder&& {
+            constexpr auto kDefaultDpi = 160;
+            constexpr std::optional<Hwc3VrrConfig> kDefaultVrrConfig = {};
+            constexpr auto kDefaultConfigGroup = 0;
+
+            const auto vsyncPeriod =
+                    (std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::seconds(1)) /
+                     refreshRateHz);
+
+            self.mDisplayConfigs.push_back(Hwc3DisplayConfiguration{
+                    .configId = configId,
+                    .width = physicalPixels.width,
+                    .height = physicalPixels.height,
+                    .dpi = Hwc3DisplayConfiguration::Dpi{.x = kDefaultDpi, .y = kDefaultDpi},
+                    .configGroup = kDefaultConfigGroup,
+                    .vsyncPeriod = static_cast<int32_t>(vsyncPeriod.count()),
+                    .vrrConfig = kDefaultVrrConfig,
+            });
+
+            return std::move(self);
+        }
+
+        [[nodiscard]] auto setHdrCapabilities(this Builder&& self,
+                                              Hwc3HdrCapabilities& value) -> Builder&& {
+            self.mHdrCapabilities = std::move(value);
+            return std::move(self);
+        }
+
+        [[nodiscard]] auto setIdentification(this Builder&& self,
+                                             Hwc3DisplayIdentification value) -> Builder&& {
+            self.mIdentification = std::move(value);
+            return std::move(self);
+        }
+
+        [[nodiscard]] auto setPerFrameMetadataKeys(this Builder&& self,
+                                                   Hwc3PerFrameMetadataKeys& value) -> Builder&& {
+            self.mPerFrameMetadataKeys = std::move(value);
+            return std::move(self);
+        }
+
+        [[nodiscard]] auto addColorModeAndRenderIntents(
+                this Builder&& self, Hwc3ColorMode colorMode,
+                std::vector<Hwc3RenderIntent> renderIntents) -> Builder&& {
+            self.mRenderIntentsForColorMode.emplace(colorMode, std::move(renderIntents));
+            return std::move(self);
+        }
+
+        [[nodiscard]] auto setPerFrameMetadataKeys(this Builder&& self,
+                                                   Hwc3Transform value) -> Builder&& {
+            self.mTransform = value;
+            return std::move(self);
+        }
+
+        [[nodiscard]] auto setSupportedContentTypes(this Builder&& self,
+                                                    Hwc3ContentTypes values) -> Builder&& {
+            self.mSupportedContentTypes = std::move(values);
+            return std::move(self);
+        }
+
+        [[nodiscard]] auto operator()(this Builder&& self) -> FakeDisplayConfiguration {
+            auto initCapabilities =
+                    !self.mCapabilities.empty() ? self.mCapabilities : getDefaultCapabilities();
+
+            auto initDisplayConfigs = getDefaultDisplayConfigs();
+            CHECK(!initDisplayConfigs.empty());
+            const auto initActiveConfigId =
+                    self.mActiveConfig.value_or(initDisplayConfigs[0].configId);
+
+            const bool activeConfigIsAConfig = std::ranges::any_of(
+                    initDisplayConfigs, [initActiveConfigId](const auto& config) {
+                        return initActiveConfigId == config.configId;
+                    });
+            CHECK(activeConfigIsAConfig);
+
+            auto initHdrCapabilities = self.mHdrCapabilities.value_or(getDefaultHdrCapabilities());
+
+            auto initIdentification =
+                    self.mIdentification.value_or(getDefaultDisplayIdentification());
+
+            auto initPerFrameMetadataKeys = self.mPerFrameMetadataKeys.empty()
+                                                    ? self.mPerFrameMetadataKeys
+                                                    : getDefaultPerFrameMetadataKeys();
+
+            auto initRenderIntentMap = !self.mRenderIntentsForColorMode.empty()
+                                               ? self.mRenderIntentsForColorMode
+                                               : getDefaultRenderIntentMap();
+
+            auto initSupportedContentTypes = !self.mSupportedContentTypes.empty()
+                                                     ? self.mSupportedContentTypes
+                                                     : getDefaultSupportedContentTypes();
+
+            auto result = FakeDisplayConfiguration{
+                    .activeConfig = initActiveConfigId,
+                    .capabilities = std::move(initCapabilities),
+                    .connectionType = self.mConnectionType,
+                    .displayConfigs = std::move(initDisplayConfigs),
+                    .hdrCapabilities = std::move(initHdrCapabilities),
+                    .identification = std::move(initIdentification),
+                    .perFrameMetadataKeys = std::move(initPerFrameMetadataKeys),
+                    .renderIntentsForColorMode = std::move(initRenderIntentMap),
+                    .transform = self.mTransform,
+                    .supportedContentTypes = std::move(initSupportedContentTypes)};
+            ftl::ignore(std::move(self));
+            return result;
+        }
+
+        // NOLINTEND(readability-convert-member-functions-to-static)
+
+      private:
+        [[nodiscard]] static constexpr auto getDefaultCapabilities()
+                -> std::vector<Hwc3DisplayCapability> {
+            return {Hwc3DisplayCapability::PROTECTED_CONTENTS,
+                    Hwc3DisplayCapability::MULTI_THREADED_PRESENT};
+        }
+
+        [[nodiscard]] static auto getDefaultDisplayConfigs()
+                -> std::vector<Hwc3DisplayConfiguration> {
+            constexpr auto kDefaultWidth = 3840;
+            constexpr auto kDefaultHeight = 2160;
+            constexpr auto kDefaultDpi = 160;
+            constexpr auto kDefaultHz = 60;
+            constexpr auto kDefaultPeriod =
+                    (std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::seconds(1)) /
+                     kDefaultHz);
+            constexpr std::optional<Hwc3VrrConfig> kDefaultVrrConfig = {};
+
+            return {
+                    Hwc3DisplayConfiguration{
+                            .configId = 0,
+                            .width = kDefaultWidth,
+                            .height = kDefaultHeight,
+                            .dpi = Hwc3DisplayConfiguration::Dpi{.x = kDefaultDpi,
+                                                                 .y = kDefaultDpi},
+                            .configGroup = 0,
+                            .vsyncPeriod = kDefaultPeriod.count(),
+                            .vrrConfig = kDefaultVrrConfig,
+                    },
+            };
+        }
+
+        [[nodiscard]] static constexpr auto getDefaultDisplayIdentification()
+                -> Hwc3DisplayIdentification {
+            constexpr auto displayPort = 0;
+            const auto& displayEdid = core::EdidBuilder::kDefaultEdid;
+            return {
+                    .port = displayPort,
+                    .data = {displayEdid.begin(), displayEdid.end()},
+            };
+        }
+
+        [[nodiscard]] static constexpr auto getDefaultHdrCapabilities() -> Hwc3HdrCapabilities {
+            constexpr auto defaultMaxLuminance = 0.0F;
+            constexpr auto defaultMaxAverageLuminance = 0.0F;
+            constexpr auto defaultMinLuminance = 0.0F;
+
+            return {
+                    .types = {},
+                    .maxLuminance = defaultMaxLuminance,
+                    .maxAverageLuminance = defaultMaxAverageLuminance,
+                    .minLuminance = defaultMinLuminance,
+            };
+        }
+
+        [[nodiscard]] static constexpr auto getDefaultPerFrameMetadataKeys()
+                -> std::vector<Hwc3PerFrameMetadataKey> {
+            return {};
+        }
+
+        [[nodiscard]] static auto getDefaultRenderIntentMap()
+                -> std::unordered_map<Hwc3ColorMode, std::vector<Hwc3RenderIntent>> {
+            return {{Hwc3ColorMode::NATIVE, {Hwc3RenderIntent::ENHANCE}}};
+        }
+
+        [[nodiscard]] static auto getDefaultSupportedContentTypes()
+                -> std::vector<Hwc3ContentType> {
+            return {Hwc3ContentType::GRAPHICS, Hwc3ContentType::PHOTO, Hwc3ContentType::CINEMA,
+                    Hwc3ContentType::GAME};
+        }
+
+        std::optional<int32_t> mActiveConfig;
+        Hwc3DisplayCapabilities mCapabilities;
+        Hwc3DisplayConnectionType mConnectionType = Hwc3DisplayConnectionType::INTERNAL;
+        Hwc3DisplayConfigurations mDisplayConfigs;
+        std::optional<Hwc3HdrCapabilities> mHdrCapabilities;
+        std::optional<Hwc3DisplayIdentification> mIdentification;
+        Hwc3PerFrameMetadataKeys mPerFrameMetadataKeys;
+        std::unordered_map<Hwc3ColorMode, std::vector<Hwc3RenderIntent>> mRenderIntentsForColorMode;
+        Hwc3Transform mTransform = Hwc3Transform::NONE;
+        Hwc3ContentTypes mSupportedContentTypes;
+    };
+
+    int32_t activeConfig = 0;
+    Hwc3DisplayCapabilities capabilities;
+    Hwc3DisplayConnectionType connectionType = Hwc3DisplayConnectionType::INTERNAL;
+    Hwc3DisplayConfigurations displayConfigs;
+    Hwc3HdrCapabilities hdrCapabilities;
+    Hwc3DisplayIdentification identification;
+    Hwc3PerFrameMetadataKeys perFrameMetadataKeys;
+    std::unordered_map<Hwc3ColorMode, std::vector<Hwc3RenderIntent>> renderIntentsForColorMode;
+    Hwc3Transform transform = Hwc3Transform::NONE;
+    Hwc3ContentTypes supportedContentTypes;
+};
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::hwc3
diff --git a/services/surfaceflinger/tests/end2end/test_framework/fake_hwc3/Hwc3Controller.cpp b/services/surfaceflinger/tests/end2end/test_framework/hwc3/Hwc3Controller.cpp
similarity index 64%
rename from services/surfaceflinger/tests/end2end/test_framework/fake_hwc3/Hwc3Controller.cpp
rename to services/surfaceflinger/tests/end2end/test_framework/hwc3/Hwc3Controller.cpp
index ea985c09b4..99b0dc7170 100644
--- a/services/surfaceflinger/tests/end2end/test_framework/fake_hwc3/Hwc3Controller.cpp
+++ b/services/surfaceflinger/tests/end2end/test_framework/hwc3/Hwc3Controller.cpp
@@ -28,18 +28,19 @@
 #include <ftl/ignore.h>
 
 #include "test_framework/core/DisplayConfiguration.h"
-#include "test_framework/fake_hwc3/Hwc3Composer.h"
-#include "test_framework/fake_hwc3/Hwc3Controller.h"
+#include "test_framework/hwc3/FakeComposer.h"
+#include "test_framework/hwc3/Hwc3Controller.h"
+#include "test_framework/hwc3/ObservingComposer.h"
 
-namespace android::surfaceflinger::tests::end2end::test_framework::fake_hwc3 {
+namespace android::surfaceflinger::tests::end2end::test_framework::hwc3 {
 
 struct Hwc3Controller::Passkey final {};
 
 auto Hwc3Controller::make(std::span<const core::DisplayConfiguration> displays)
-        -> base::expected<std::shared_ptr<fake_hwc3::Hwc3Controller>, std::string> {
+        -> base::expected<std::shared_ptr<hwc3::Hwc3Controller>, std::string> {
     using namespace std::string_literals;
 
-    auto controller = std::make_unique<Hwc3Controller>(Passkey{});
+    auto controller = std::make_shared<Hwc3Controller>(Passkey{});
     if (controller == nullptr) {
         return base::unexpected("Failed to construct the Hwc3Controller instance"s);
     }
@@ -60,19 +61,25 @@ auto Hwc3Controller::init(const std::span<const core::DisplayConfiguration> disp
         -> base::expected<void, std::string> {
     using namespace std::string_literals;
 
-    auto qualifiedServiceName = Hwc3Composer::getServiceName(baseServiceName);
-
-    auto composerResult = Hwc3Composer::make();
-    if (!composerResult) {
-        return base::unexpected(std::move(composerResult).error());
+    auto fakeComposerResult = FakeComposer::make();
+    if (!fakeComposerResult) {
+        return base::unexpected(std::move(fakeComposerResult).error());
     }
-    auto composer = *std::move(composerResult);
+    auto fakeComposer = *std::move(fakeComposerResult);
 
     for (const auto& display : displays) {
-        composer->addDisplay(display);
+        fakeComposer->addDisplay(display);
+    }
+
+    auto observingComposerResult =
+            ObservingComposer::make(shared_from_this(), fakeComposer->getComposer());
+    if (!observingComposerResult) {
+        return base::unexpected(std::move(observingComposerResult).error());
     }
+    auto observingComposer = *std::move(observingComposerResult);
 
-    auto binder = composer->getComposer()->asBinder();
+    const auto qualifiedServiceName = ObservingComposer::getServiceName(baseServiceName);
+    auto binder = observingComposer->getComposer()->asBinder();
 
     // This downgrade allows us to use the fake service name without it being defined in the
     // VINTF manifest.
@@ -85,22 +92,31 @@ auto Hwc3Controller::init(const std::span<const core::DisplayConfiguration> disp
     }
     LOG(INFO) << "Registered service " << qualifiedServiceName << ". Error: " << status;
 
-    mComposer = std::move(composer);
+    mFakeComposer = std::move(fakeComposer);
+    mObservingComposer = std::move(observingComposer);
     return {};
 }
 
+auto Hwc3Controller::editCallbacks() -> Callbacks& {
+    return mCallbacks;
+}
+
+auto Hwc3Controller::callbacks() const -> const Callbacks& {
+    return mCallbacks;
+}
+
 auto Hwc3Controller::getServiceName() -> std::string {
-    return Hwc3Composer::getServiceName(baseServiceName);
+    return FakeComposer::getServiceName(baseServiceName);
 }
 
 void Hwc3Controller::addDisplay(const core::DisplayConfiguration& config) {
-    CHECK(mComposer);
-    mComposer->addDisplay(config);
+    CHECK(mFakeComposer);
+    mFakeComposer->addDisplay(config);
 }
 
 void Hwc3Controller::removeDisplay(core::DisplayConfiguration::Id displayId) {
-    CHECK(mComposer);
-    mComposer->removeDisplay(displayId);
+    CHECK(mFakeComposer);
+    mFakeComposer->removeDisplay(displayId);
 }
 
-}  // namespace android::surfaceflinger::tests::end2end::test_framework::fake_hwc3
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::hwc3
diff --git a/services/surfaceflinger/tests/end2end/test_framework/fake_hwc3/Hwc3Controller.h b/services/surfaceflinger/tests/end2end/test_framework/hwc3/Hwc3Controller.h
similarity index 51%
rename from services/surfaceflinger/tests/end2end/test_framework/fake_hwc3/Hwc3Controller.h
rename to services/surfaceflinger/tests/end2end/test_framework/hwc3/Hwc3Controller.h
index e53d2cfc48..936327b075 100644
--- a/services/surfaceflinger/tests/end2end/test_framework/fake_hwc3/Hwc3Controller.h
+++ b/services/surfaceflinger/tests/end2end/test_framework/hwc3/Hwc3Controller.h
@@ -23,24 +23,57 @@
 #include <android-base/expected.h>
 
 #include "test_framework/core/DisplayConfiguration.h"
+#include "test_framework/hwc3/events/ClientDestroyed.h"
+#include "test_framework/hwc3/events/DisplayPresented.h"
+#include "test_framework/hwc3/events/PendingBufferSwap.h"
+#include "test_framework/hwc3/events/PowerMode.h"
+#include "test_framework/hwc3/events/VSync.h"
+#include "test_framework/hwc3/events/VSyncEnabled.h"
 
-namespace android::surfaceflinger::tests::end2end::test_framework::fake_hwc3 {
+namespace android::surfaceflinger::tests::end2end::test_framework::hwc3 {
 
-class Hwc3Composer;
+class FakeComposer;
+class ObservingComposer;
 
-class Hwc3Controller final {
+class Hwc3Controller final : public std::enable_shared_from_this<Hwc3Controller> {
     struct Passkey;  // Uses the passkey idiom to restrict construction.
 
   public:
+    struct Callbacks final {
+        // Invoked when SF destroys its HWC client connection.
+        events::ClientDestroyed::AsyncConnector onClientDestroyed;
+
+        // Invoked when SF configures the power mode for a display.
+        events::PowerMode::AsyncConnector onPowerModeChanged;
+
+        // Invoked when SF enables or disables vsync callbacks for a display.
+        events::VSyncEnabled::AsyncConnector onVsyncEnabledChanged;
+
+        // Invoked when SF presents a display.
+        events::DisplayPresented::AsyncConnector onDisplayPresented;
+
+        // Invoked when SF is swapping the buffer content of a hardware overlay.
+        events::PendingBufferSwap::AsyncConnector onPendingBufferSwap;
+
+        // Invoked when the client sends SF a vsync callback.
+        events::VSync::AsyncConnector onVSyncCallbackSent;
+    };
+
     // Gets the service name for the HWC3 instance that will be created and registered
     [[nodiscard]] static auto getServiceName() -> std::string;
 
     // Makes the HWC3 controller instance.
     [[nodiscard]] static auto make(std::span<const core::DisplayConfiguration> displays)
-            -> base::expected<std::shared_ptr<fake_hwc3::Hwc3Controller>, std::string>;
+            -> base::expected<std::shared_ptr<hwc3::Hwc3Controller>, std::string>;
 
     explicit Hwc3Controller(Passkey passkey);
 
+    // Allows the callbacks to be routed.
+    [[nodiscard]] auto editCallbacks() -> Callbacks&;
+
+    // Allows the callbacks to be sent.
+    [[nodiscard]] auto callbacks() const -> const Callbacks&;
+
     // Adds a new display to the HWC3, which will become a hotplug connect event.
     void addDisplay(const core::DisplayConfiguration& config);
 
@@ -53,7 +86,9 @@ class Hwc3Controller final {
     [[nodiscard]] auto init(std::span<const core::DisplayConfiguration> displays)
             -> base::expected<void, std::string>;
 
-    std::shared_ptr<Hwc3Composer> mComposer;
+    std::shared_ptr<FakeComposer> mFakeComposer;
+    std::shared_ptr<ObservingComposer> mObservingComposer;
+    Callbacks mCallbacks;
 };
 
-}  // namespace android::surfaceflinger::tests::end2end::test_framework::fake_hwc3
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::hwc3
diff --git a/services/surfaceflinger/tests/end2end/test_framework/hwc3/MultiDisplayRefreshEventGenerator.cpp b/services/surfaceflinger/tests/end2end/test_framework/hwc3/MultiDisplayRefreshEventGenerator.cpp
new file mode 100644
index 0000000000..719c421bba
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/hwc3/MultiDisplayRefreshEventGenerator.cpp
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <algorithm>
+#include <utility>
+
+#include "test_framework/hwc3/MultiDisplayRefreshEventGenerator.h"
+#include "test_framework/hwc3/SingleDisplayRefreshSchedule.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::hwc3 {
+
+void MultiDisplayRefreshEventGenerator::addDisplay(DisplayId displayId,
+                                                   SingleDisplayRefreshSchedule schedule) {
+    generators[displayId] = {.id = displayId, .schedule = schedule};
+}
+
+void MultiDisplayRefreshEventGenerator::removeDisplay(DisplayId displayId) {
+    generators.erase(displayId);
+}
+
+auto MultiDisplayRefreshEventGenerator::generateEventsFor(TimeInterval elapsed) const
+        -> GenerateResult {
+    GenerateResult multiDisplayResult{};
+
+    for (const auto& [_, generator] : generators) {
+        auto singleDisplayResult = generator.generateEventsFor(elapsed);
+        multiDisplayResult.nextRefreshAt =
+                std::min(multiDisplayResult.nextRefreshAt, singleDisplayResult.nextRefreshAt);
+        multiDisplayResult.events.append_range(std::move(singleDisplayResult.events));
+    }
+
+    return multiDisplayResult;
+}
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::hwc3
\ No newline at end of file
diff --git a/services/surfaceflinger/tests/end2end/test_framework/hwc3/MultiDisplayRefreshEventGenerator.h b/services/surfaceflinger/tests/end2end/test_framework/hwc3/MultiDisplayRefreshEventGenerator.h
new file mode 100644
index 0000000000..25a3847600
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/hwc3/MultiDisplayRefreshEventGenerator.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <chrono>
+#include <map>
+#include <vector>
+
+#include <android-base/logging.h>
+
+#include "test_framework/core/DisplayConfiguration.h"
+#include "test_framework/core/TimeInterval.h"
+#include "test_framework/hwc3/SingleDisplayRefreshEventGenerator.h"
+#include "test_framework/hwc3/SingleDisplayRefreshSchedule.h"
+#include "test_framework/hwc3/events/VSync.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::hwc3 {
+
+class MultiDisplayRefreshEventGenerator final {
+  public:
+    using DisplayId = core::DisplayConfiguration::Id;
+    using TimeInterval = core::TimeInterval;
+    using TimePoint = std::chrono::steady_clock::time_point;
+
+    void addDisplay(DisplayId displayId, SingleDisplayRefreshSchedule schedule);
+    void removeDisplay(DisplayId displayId);
+
+    // The result from generateEventsFor().
+    struct GenerateResult {
+        // The clock time at which the next refresh events should be generated
+        TimePoint nextRefreshAt{TimePoint::max()};
+
+        // The refresh events that were generated.
+        std::vector<events::VSync> events;
+
+        friend auto operator==(const GenerateResult&, const GenerateResult&) -> bool = default;
+    };
+
+    [[nodiscard]] auto generateEventsFor(TimeInterval elapsed) const -> GenerateResult;
+
+  private:
+    // Note: map instead of unordered_map so traversal is consistent.
+    std::map<DisplayId, SingleDisplayRefreshEventGenerator> generators;
+};
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::hwc3
\ No newline at end of file
diff --git a/services/surfaceflinger/tests/end2end/test_framework/hwc3/ObservingComposer.cpp b/services/surfaceflinger/tests/end2end/test_framework/hwc3/ObservingComposer.cpp
new file mode 100644
index 0000000000..974f93d543
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/hwc3/ObservingComposer.cpp
@@ -0,0 +1,523 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <algorithm>
+#include <array>
+#include <chrono>
+#include <cstddef>
+#include <cstdint>
+#include <memory>
+#include <mutex>
+#include <optional>
+#include <string>
+#include <string_view>
+#include <unordered_map>
+#include <utility>
+#include <vector>
+
+#include <aidl/android/hardware/graphics/composer3/CommandResultPayload.h>
+#include <aidl/android/hardware/graphics/composer3/DisplayCommand.h>
+#include <aidl/android/hardware/graphics/composer3/IComposer.h>
+#include <aidl/android/hardware/graphics/composer3/IComposerCallback.h>
+#include <aidl/android/hardware/graphics/composer3/IComposerClient.h>
+#include <aidl/android/hardware/graphics/composer3/LayerCommand.h>
+#include <aidl/android/hardware/graphics/composer3/LayerLifecycleBatchCommandType.h>
+#include <aidl/android/hardware/graphics/composer3/PowerMode.h>
+#include <android-base/expected.h>
+#include <android-base/logging.h>
+#include <android-base/thread_annotations.h>  // NOLINT(misc-include-cleaner)
+#include <android/binder_auto_utils.h>
+#include <android/binder_interface_utils.h>
+#include <fmt/format.h>
+#include <ftl/finalizer.h>
+#include <ftl/ignore.h>
+#include <utils/Mutex.h>
+
+#include "test_framework/core/BufferId.h"
+#include "test_framework/hwc3/Hwc3Controller.h"
+#include "test_framework/hwc3/ObservingComposer.h"
+#include "test_framework/hwc3/delegators/Composer.h"
+#include "test_framework/hwc3/delegators/ComposerCallback.h"
+#include "test_framework/hwc3/delegators/ComposerClient.h"
+#include "test_framework/hwc3/events/ClientDestroyed.h"
+#include "test_framework/hwc3/events/DisplayPresented.h"
+#include "test_framework/hwc3/events/PendingBufferSwap.h"
+#include "test_framework/hwc3/events/PowerMode.h"
+#include "test_framework/hwc3/events/VSync.h"
+#include "test_framework/hwc3/events/VSyncEnabled.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::hwc3 {
+
+using aidl::android::hardware::graphics::composer3::CommandResultPayload;
+using aidl::android::hardware::graphics::composer3::DisplayCommand;
+using aidl::android::hardware::graphics::composer3::IComposer;
+using aidl::android::hardware::graphics::composer3::IComposerCallback;
+using aidl::android::hardware::graphics::composer3::IComposerClient;
+using aidl::android::hardware::graphics::composer3::LayerCommand;
+using aidl::android::hardware::graphics::composer3::LayerLifecycleBatchCommandType;
+using aidl::android::hardware::graphics::composer3::PowerMode;
+
+namespace {
+
+class InterfaceName {
+    template <typename T>
+    static consteval auto pretty() -> std::string_view {
+        return __PRETTY_FUNCTION__;
+    }
+
+    static consteval auto trim(std::string_view name) -> std::string_view {
+        constexpr std::string_view expected = "std::string_view";
+        constexpr std::string_view ref = pretty<std::string_view>();
+        constexpr size_t prefixLength = ref.rfind(expected);
+        static_assert(prefixLength != std::string_view::npos);
+        constexpr size_t suffixLength = ref.size() - prefixLength - expected.size();
+        static_assert(prefixLength + suffixLength + expected.size() == ref.size());
+
+        return name.substr(prefixLength, name.size() - suffixLength - prefixLength);
+    }
+
+    template <size_t... Indices>
+    static consteval auto copy(std::string_view input, std::index_sequence<Indices...> sequence)
+            -> std::array<char, 1 + sizeof...(Indices)> {
+        ftl::ignore(sequence);
+        return {input[Indices]..., 0};
+    }
+
+    template <typename T>
+    static consteval auto operator()() -> std::string_view {
+        constexpr auto name = trim(pretty<T>());
+        static constexpr auto copied = copy(name, std::make_index_sequence<name.size()>{});
+        return copied.data();
+    }
+
+  public:
+    template <typename T>
+    static constexpr auto value = operator()<T>();
+};
+
+// Implements a generic forwarder for an interface, given also an matching delegator.
+template <typename Interface, template <typename> typename Delegator, bool VersionMustMatch = true>
+struct Forwarder : public Delegator<Forwarder<Interface, Delegator, VersionMustMatch>> {
+    using Base = Delegator<Forwarder<Interface, Delegator, VersionMustMatch>>;
+
+    auto init(std::shared_ptr<Interface> destination) -> base::expected<void, std::string> {
+        int32_t destinationVersion = 0;
+        if (!destination->getInterfaceVersion(&destinationVersion).isOk()) {
+            return base::unexpected("Failed to get destination interface version");
+        }
+
+        if constexpr (VersionMustMatch) {
+            if (destinationVersion != Interface::version) {
+                return base::unexpected(fmt::format(
+                        "{} forwarding interface version mismatch. Destination uses {}, "
+                        "forwarder uses {}, and they must be the same.",
+                        InterfaceName::value<Interface>, destinationVersion, Interface::version));
+            }
+        } else {
+            if (destinationVersion < Interface::version) {
+                return base::unexpected(fmt::format(
+                        "{} forwarding interface version mismatch. Destination uses {}, "
+                        "forwarder uses {} and must not be newer.",
+                        InterfaceName::value<Interface>, destinationVersion, Interface::version));
+            }
+        }
+
+        mDestination = std::move(destination);
+        return {};
+    }
+
+    auto getComposerClient() -> std::shared_ptr<Interface> {
+        return Base::template ref<Forwarder>();
+    }
+
+    template <auto MemberFn, typename... Args>
+    auto operator()(Args&&... args) -> ::ndk::ScopedAStatus {
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wdeprecated-declarations"
+        // Uniformly forwards all calls through the appropriate member function.
+        return (mDestination.get()->*MemberFn)(std::forward<decltype(args)>(args)...);
+#pragma clang diagnostic pop
+    }
+
+  private:
+    // All requests are forwarded through this interface.
+    std::shared_ptr<Interface> mDestination;
+};
+
+// Each of these will by default forward calls for that interface to another target.
+using ComposerForwarder = Forwarder<IComposer, delegators::Composer>;
+using ComposerClientForwarder = Forwarder<IComposerClient, delegators::ComposerClient>;
+// Note: SurfaceFlinger's ComposerCallback can be newer than the IComposerCallback used here.
+using ComposerCallbackForwarder =
+        Forwarder<IComposerCallback, delegators::ComposerCallback, /*VersionMustMatch=*/false>;
+
+// The observer only overrides the interface functions that need to be observed.
+// The calls are otherwise forwarded, using the base forwarder class.
+struct ComposerClientObserver final : public ComposerClientForwarder {
+    using Base = ComposerClientForwarder;
+
+  public:
+    struct ComposerCallbackObserver final : public ComposerCallbackForwarder {
+        using Base = ComposerCallbackForwarder;
+
+        auto init(std::weak_ptr<const Hwc3Controller> controller,
+                  std::shared_ptr<IComposerCallback> destination)
+                -> base::expected<void, std::string> {
+            if (auto result = Base::init(std::move(destination)); !result) {
+                return base::unexpected(std::move(result).error());
+            }
+
+            mController = std::move(controller);
+            return {};
+        }
+
+        // begin IComposerCallback overrides
+
+        auto onVsync(int64_t in_display, int64_t in_timestamp,
+                     int32_t in_vsyncPeriodNanos) -> ::ndk::ScopedAStatus override {
+            if (auto controller = mController.lock()) {
+                controller->callbacks().onVSyncCallbackSent(events::VSync{
+                        .displayId = in_display,
+                        .expectedAt =
+                                events::VSync::TimePoint(std::chrono::nanoseconds(in_timestamp)),
+                        .expectedPeriod = std::chrono::nanoseconds(in_vsyncPeriodNanos),
+                        .receivedAt = std::chrono::steady_clock::now(),
+                });
+            }
+
+            return Base::onVsync(in_display, in_timestamp, in_vsyncPeriodNanos);
+        }
+
+        // end IComposerCallback overrides
+
+      private:
+        std::weak_ptr<const Hwc3Controller> mController;
+    };
+
+    auto init(std::weak_ptr<const Hwc3Controller> controller,
+              std::shared_ptr<IComposerClient> destination) -> base::expected<void, std::string> {
+        if (auto result = Base::init(std::move(destination)); !result) {
+            return base::unexpected(std::move(result).error());
+        }
+
+        mController = std::move(controller);
+        return {};
+    }
+
+    // begin IComposerClient overrides
+    // NOLINTBEGIN(bugprone-easily-swappable-parameters)
+
+    auto destroyLayer(int64_t in_display, int64_t in_layer) -> ndk::ScopedAStatus override {
+        LOG(VERBOSE) << __func__;
+        handleLayerDestroyed(in_display, in_layer);
+        return Base::destroyLayer(in_display, in_layer);
+    }
+
+    auto executeCommands(const std::vector<DisplayCommand>& in_commands,
+                         std::vector<CommandResultPayload>* out_results)
+            -> ndk::ScopedAStatus override {
+        LOG(VERBOSE) << __func__;
+        handleExecuteCommands(in_commands);
+        return Base::executeCommands(in_commands, out_results);
+    }
+
+    auto setPowerMode(int64_t in_display, PowerMode in_mode) -> ndk::ScopedAStatus override {
+        LOG(VERBOSE) << __func__;
+        if (auto observer = mController.lock()) {
+            observer->callbacks().onPowerModeChanged(
+                    events::PowerMode{.displayId = in_display, .mode = in_mode});
+        }
+
+        return Base::setPowerMode(in_display, in_mode);
+    }
+
+    auto setVsyncEnabled(int64_t in_display, bool in_enabled) -> ndk::ScopedAStatus override {
+        LOG(VERBOSE) << __func__;
+        if (auto observer = mController.lock()) {
+            observer->callbacks().onVsyncEnabledChanged(
+                    events::VSyncEnabled{.displayId = in_display, .enabled = in_enabled});
+        }
+        return Base::setVsyncEnabled(in_display, in_enabled);
+    }
+
+    auto registerCallback(const std::shared_ptr<IComposerCallback>& in_callback)
+            -> ndk::ScopedAStatus override {
+        LOG(VERBOSE) << __func__;
+        const std::lock_guard lock(mMutex);
+
+        // Set up an observer to intercept the callback events sent from the client implementation.
+        auto composerCallback = ndk::SharedRefBase::make<ComposerCallbackObserver>();
+        if (auto result = composerCallback->init(mController, in_callback); !result) {
+            LOG(ERROR) << "Failed to create a ComposerCallbackObserver instance: "
+                       << result.error();
+            return ndk::ScopedAStatus::fromServiceSpecificErrorWithMessage(
+                    IComposer::EX_NO_RESOURCES, "Callback interception failed.");
+        }
+        mComposerCallback = composerCallback;
+
+        // Pass our callback observer interface to the implementation, rather than the original
+        // interface.
+        return Base::registerCallback(composerCallback);
+    }
+
+    // NOLINTEND(bugprone-easily-swappable-parameters)
+    // end IComposerClient overrides
+
+  private:
+    struct LayerState {
+        std::optional<core::BufferId> current;
+        std::unordered_map<int32_t, core::BufferId> cache;
+    };
+    struct DisplayState {
+        std::unordered_map<uint64_t, LayerState> layers;
+    };
+    using DisplaysState = std::unordered_map<uint64_t, DisplayState>;
+
+    void handleBufferChanges(const LayerCommand& cmd, events::DisplayPresented eventTemplate)
+            REQUIRES(mMutex) {
+        if (!cmd.buffer) {
+            return;
+        }
+
+        const auto layerId = cmd.layer;
+        const auto& buffer = *cmd.buffer;
+        const auto slot = buffer.slot;
+        auto& layerState = mDisplaysState[eventTemplate.displayId].layers[layerId];
+
+        if (buffer.handle) {
+            auto bufferId = core::toBufferId(*buffer.handle);
+
+            LOG(VERBOSE) << "layer " << layerId << " buffer slot " << slot << " set to "
+                         << toString(bufferId);
+            layerState.cache.emplace(slot, bufferId);
+
+        } else {
+            LOG(VERBOSE) << "layer " << layerId << " buffer slot " << slot;
+        }
+
+        const auto displayed = layerState.cache[slot];
+        const auto released = std::exchange(layerState.current, displayed);
+
+        if (auto observer = mController.lock()) {
+            observer->callbacks().onPendingBufferSwap(events::PendingBufferSwap{
+                    .displayId = eventTemplate.displayId,
+                    .layerId = layerId,
+                    .pendingDisplay = displayed,
+                    .pendingRelease = released,
+                    .expectedPresentTime = eventTemplate.expectedPresentTime,
+                    .receivedAt = eventTemplate.receivedAt,
+            });
+        }
+
+        LOG(VERBOSE) << "Displaying buffer " << toString(displayed);
+        LOG_IF(VERBOSE, released.has_value()) << "Releasing buffer " << toString(*released);
+    }
+
+    void handleLayerDestroyedCommon(int64_t layerId, events::DisplayPresented eventTemplate)
+            REQUIRES(mMutex) {
+        auto& layerState = mDisplaysState[eventTemplate.displayId].layers[layerId];
+        constexpr auto displayed = std::nullopt;
+        const auto released = std::exchange(layerState.current, displayed);
+
+        if (released) {
+            if (auto observer = mController.lock()) {
+                observer->callbacks().onPendingBufferSwap(events::PendingBufferSwap{
+                        .displayId = eventTemplate.displayId,
+                        .layerId = layerId,
+                        .pendingDisplay = displayed,
+                        .pendingRelease = released,
+                        .expectedPresentTime = eventTemplate.expectedPresentTime,
+                        .receivedAt = eventTemplate.receivedAt,
+                });
+            }
+        }
+
+        LOG_IF(VERBOSE, released.has_value()) << "Releasing buffer " << toString(*released);
+        LOG(VERBOSE) << "layer " << layerId << " destroy";
+        mDisplaysState[eventTemplate.displayId].layers.erase(layerId);
+    }
+
+    void handleLayerDestroyed(int64_t in_display, int64_t in_layer) {
+        const std::lock_guard lock(mMutex);
+
+        handleLayerDestroyedCommon(
+                in_layer,
+                events::DisplayPresented{
+                        .displayId = in_display,
+                        .expectedPresentTime = std::chrono::steady_clock::time_point::min()});
+    };
+
+    void executeLayerCommand(const LayerCommand& cmd, events::DisplayPresented eventTemplate)
+            REQUIRES(mMutex) {
+        LOG(VERBOSE) << "LayerCommand:" << toString(cmd.layerLifecycleBatchCommandType) << " layer "
+                     << cmd.layer;
+
+        handleBufferChanges(cmd, eventTemplate);
+
+        if (cmd.layerLifecycleBatchCommandType == LayerLifecycleBatchCommandType::DESTROY) {
+            handleLayerDestroyedCommon(cmd.layer, eventTemplate);
+        }
+    }
+
+    void handleExecuteCommands(const std::vector<DisplayCommand>& in_commands) {
+        const std::lock_guard lock(mMutex);
+
+        const auto receivedTime = std::chrono::steady_clock::now();
+        for (const auto& cmd : in_commands) {
+            LOG(VERBOSE) << cmd.toString();
+
+            using Timestamp = std::chrono::steady_clock::time_point;
+
+            const auto expectedPresentTime =
+                    cmd.expectedPresentTime
+                            .transform([](auto value) {
+                                return Timestamp(std::chrono::nanoseconds(value.timestampNanos));
+                            })
+                            .value_or(Timestamp::min());
+
+            for (const auto& layerCommand : cmd.layers) {
+                executeLayerCommand(layerCommand,
+                                    events::DisplayPresented{
+                                            .displayId = cmd.display,
+                                            .expectedPresentTime = expectedPresentTime,
+                                            .receivedAt = receivedTime,
+                                    });
+            }
+
+            if (cmd.presentOrValidateDisplay) {
+                if (auto observer = mController.lock()) {
+                    observer->callbacks().onDisplayPresented(
+                            events::DisplayPresented{.displayId = cmd.display,
+                                                     .expectedPresentTime = expectedPresentTime,
+                                                     .receivedAt = receivedTime});
+                }
+            }
+        }
+    }
+
+    std::weak_ptr<const Hwc3Controller> mController;
+
+    mutable std::mutex mMutex;
+    std::shared_ptr<IComposerCallback> mComposerCallback GUARDED_BY(mMutex);
+    DisplaysState mDisplaysState GUARDED_BY(mMutex);
+};
+
+}  // namespace
+
+struct ObservingComposer::ObservingComposerImpl final : public ComposerForwarder {
+    using Base = ComposerForwarder;
+
+    auto init(std::weak_ptr<const Hwc3Controller> controller,
+              std::shared_ptr<IComposer> destination) -> base::expected<void, std::string> {
+        if (auto result = Base::init(std::move(destination)); !result) {
+            return base::unexpected(std::move(result).error());
+        }
+
+        mController = std::move(controller);
+        return {};
+    }
+
+    // begin IComposer overrides
+
+    auto createClient(std::shared_ptr<IComposerClient>* out_client) -> ndk::ScopedAStatus override {
+        auto status = Base::createClient(out_client);
+        if (!status.isOk()) {
+            return status;
+        }
+
+        auto client = ndk::SharedRefBase::make<ComposerClientObserver>();
+        if (auto result = client->init(mController, *out_client); !result) {
+            *out_client = nullptr;
+            LOG(ERROR) << "Failed to create a ComposerClientObserver instance: " << result.error();
+            return ndk::ScopedAStatus::fromServiceSpecificErrorWithMessage(
+                    IComposer::EX_NO_RESOURCES, "Client failed to initialize");
+        }
+
+        const std::lock_guard lock(mMutex);
+        mComposerClient = client;
+        *out_client = std::move(client);
+        return ndk::ScopedAStatus::ok();
+    }
+
+    // end IComposer overrides
+
+  private:
+    std::weak_ptr<const Hwc3Controller> mController;
+
+    mutable std::mutex mMutex;
+    std::shared_ptr<IComposerClient> mComposerClient GUARDED_BY(mMutex);
+
+    // Finalizers should be last so their destructors are invoked first.
+    ftl::FinalizerFtl1 mCleanup{[this] {
+        if (auto controller = mController.lock()) {
+            controller->callbacks().onClientDestroyed(events::ClientDestroyed{});
+        }
+    }};
+};
+
+struct ObservingComposer::Passkey final {};
+
+auto ObservingComposer::getServiceName(std::string_view baseServiceName) -> std::string {
+    return ObservingComposerImpl::makeServiceName(baseServiceName);
+}
+
+auto ObservingComposer::make(std::weak_ptr<const Hwc3Controller> controller,
+                             std::shared_ptr<IComposer> destination)
+        -> base::expected<std::shared_ptr<ObservingComposer>, std::string> {
+    using namespace std::string_literals;
+
+    auto composer = std::make_shared<ObservingComposer>(Passkey{});
+    if (composer == nullptr) {
+        return base::unexpected("Failed to construct the ObservingComposer instance."s);
+    }
+
+    if (auto result = composer->init(std::move(controller), std::move(destination)); !result) {
+        return base::unexpected("Failed to init the ObservingComposer instance: "s +
+                                result.error());
+    }
+
+    return composer;
+}
+
+ObservingComposer::ObservingComposer(Passkey passkey) {
+    ftl::ignore(passkey);
+}
+
+auto ObservingComposer::init(std::weak_ptr<const Hwc3Controller> controller,
+                             std::shared_ptr<IComposer> destination)
+        -> base::expected<void, std::string> {
+    using namespace std::string_literals;
+
+    auto impl = ndk::SharedRefBase::make<ObservingComposerImpl>();
+    if (!impl) {
+        return base::unexpected("Failed to construct the Hwc3ComposerImpl instance."s);
+    }
+
+    if (auto result = impl->init(std::move(controller), std::move(destination)); !result) {
+        return base::unexpected(std::move(result).error());
+    }
+
+    mImpl = std::move(impl);
+
+    return {};
+}
+
+auto ObservingComposer::getComposer() -> std::shared_ptr<IComposer> {
+    CHECK(mImpl != nullptr);
+    return mImpl;
+}
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::hwc3
diff --git a/services/surfaceflinger/tests/end2end/test_framework/hwc3/ObservingComposer.h b/services/surfaceflinger/tests/end2end/test_framework/hwc3/ObservingComposer.h
new file mode 100644
index 0000000000..06fdba8a7e
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/hwc3/ObservingComposer.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <memory>
+#include <string>
+#include <string_view>
+
+#include <aidl/android/hardware/graphics/composer3/IComposer.h>
+#include <android-base/expected.h>
+
+namespace android::surfaceflinger::tests::end2end::test_framework::hwc3 {
+
+class Hwc3Controller;
+
+class ObservingComposer final {
+    struct Passkey;  // Uses the passkey idiom to restrict construction.
+
+  public:
+    struct ObservingComposerImpl;  // An internal class implements the AIDL interface.
+
+    using IComposer = aidl::android::hardware::graphics::composer3::IComposer;
+
+    // Gets the full qualified service name given a base name for the service.
+    [[nodiscard]] static auto getServiceName(std::string_view baseServiceName) -> std::string;
+
+    // Constructs a ObservingComposer instance.
+    [[nodiscard]] static auto make(std::weak_ptr<const Hwc3Controller> controller,
+                                   std::shared_ptr<IComposer> destination)
+            -> base::expected<std::shared_ptr<ObservingComposer>, std::string>;
+
+    explicit ObservingComposer(Passkey passkey);
+
+    // Obtains the AIDL composer3::IComposer interface for the internal instance.
+    [[nodiscard]] auto getComposer() -> std::shared_ptr<IComposer>;
+
+  private:
+    [[nodiscard]] auto init(std::weak_ptr<const Hwc3Controller> controller,
+                            std::shared_ptr<IComposer> destination)
+            -> base::expected<void, std::string>;
+
+    std::shared_ptr<ObservingComposerImpl> mImpl;
+};
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::hwc3
diff --git a/services/surfaceflinger/tests/end2end/test_framework/hwc3/SingleDisplayRefreshEventGenerator.cpp b/services/surfaceflinger/tests/end2end/test_framework/hwc3/SingleDisplayRefreshEventGenerator.cpp
new file mode 100644
index 0000000000..98e1740583
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/hwc3/SingleDisplayRefreshEventGenerator.cpp
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <algorithm>
+#include <chrono>
+#include <utility>
+#include <vector>
+
+#include <android-base/logging.h>
+
+#include "test_framework/core/TimeInterval.h"
+#include "test_framework/hwc3/SingleDisplayRefreshEventGenerator.h"
+#include "test_framework/hwc3/SingleDisplayRefreshSchedule.h"
+#include "test_framework/hwc3/events/VSync.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::hwc3 {
+
+namespace {
+
+[[nodiscard]] auto getEventInterval(const SingleDisplayRefreshSchedule& schedule,
+                                    const core::TimeInterval& input) -> core::TimeInterval {
+    // Transform the input interval into an interval for the next event times for each endpoint in
+    // the input interval.
+    auto interval = core::TimeInterval{
+            .begin = schedule.nextEvent(input.begin),
+            .end = schedule.nextEvent(input.end),
+    };
+
+    // Get the timepoint for the refresh event just before the last one in the interval.
+    const auto oneBeforeEnd = interval.end - schedule.period;
+
+    // We try to catch up on events since the start of the elapsed time. However if there are
+    // too many we limit the past events to just the single most recent one.
+    const auto catchUpLimit = schedule.period * 4;
+    const auto catchUpBegin =
+            (interval.begin + catchUpLimit >= oneBeforeEnd) ? interval.begin : oneBeforeEnd;
+
+    // Ensure lastReturnedEndPoint is not in the returned interval, so we only emit events
+    // after that time.
+    interval.begin = std::max(interval.begin, catchUpBegin);
+
+    // Verify that the two end points exactly correspond to refresh event times, which also
+    // means they are an integer multiple of the period apart.
+    CHECK(schedule.nextEvent(interval.begin) == interval.begin + schedule.period);
+    CHECK(schedule.nextEvent(interval.end) == interval.end + schedule.period);
+    CHECK(interval.begin <= interval.end);  // Check an invariant.
+
+    return interval;
+}
+
+}  // namespace
+
+auto SingleDisplayRefreshEventGenerator::generateEventsFor(TimeInterval elapsed) const
+        -> GenerateResult {
+    auto generation = getEventInterval(schedule, elapsed);
+
+    LOG(VERBOSE) << "unemitted events for " << id << " are  " << toString(generation);
+
+    std::vector<events::VSync> events;
+    for (auto eventTime = generation.begin; eventTime < generation.end;
+         eventTime += schedule.period) {
+        events.push_back({id, eventTime, schedule.period, elapsed.end});
+    }
+
+    return {.nextRefreshAt = generation.end, .events = std::move(events)};
+}
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::hwc3
\ No newline at end of file
diff --git a/services/surfaceflinger/tests/end2end/test_framework/hwc3/SingleDisplayRefreshEventGenerator.h b/services/surfaceflinger/tests/end2end/test_framework/hwc3/SingleDisplayRefreshEventGenerator.h
new file mode 100644
index 0000000000..dd65c52157
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/hwc3/SingleDisplayRefreshEventGenerator.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <chrono>
+#include <vector>
+
+#include "test_framework/core/DisplayConfiguration.h"
+#include "test_framework/core/TimeInterval.h"
+#include "test_framework/hwc3/SingleDisplayRefreshSchedule.h"
+#include "test_framework/hwc3/events/VSync.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::hwc3 {
+
+// NOLINTBEGIN(misc-non-private-member-variables-in-classes)
+struct SingleDisplayRefreshEventGenerator final {
+    using DisplayId = core::DisplayConfiguration::Id;
+    using TimeInterval = core::TimeInterval;
+    using TimePoint = std::chrono::steady_clock::time_point;
+
+    // The identifier for this display.
+    DisplayId id{};
+
+    // The current schedule for refresh events for this display.
+    SingleDisplayRefreshSchedule schedule;
+
+    // The result from generateEventsFor().
+    struct GenerateResult {
+        // The clock time at which the next refresh events should be generated
+        TimePoint nextRefreshAt{TimePoint::max()};
+
+        // The refresh events that were generated.
+        std::vector<events::VSync> events;
+
+        friend auto operator==(const GenerateResult&, const GenerateResult&) -> bool = default;
+    };
+
+    [[nodiscard]] auto generateEventsFor(TimeInterval elapsed) const -> GenerateResult;
+};
+// NOLINTEND(misc-non-private-member-variables-in-classes)
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::hwc3
\ No newline at end of file
diff --git a/services/surfaceflinger/tests/end2end/test_framework/hwc3/SingleDisplayRefreshSchedule.cpp b/services/surfaceflinger/tests/end2end/test_framework/hwc3/SingleDisplayRefreshSchedule.cpp
new file mode 100644
index 0000000000..079450f0a1
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/hwc3/SingleDisplayRefreshSchedule.cpp
@@ -0,0 +1,158 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <bit>
+#include <chrono>
+#include <cstdint>
+#include <limits>
+#include <string>
+
+#include <android-base/logging.h>
+#include <fmt/chrono.h>  // NOLINT(misc-include-cleaner)
+#include <fmt/format.h>
+
+#include "test_framework/hwc3/SingleDisplayRefreshSchedule.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::hwc3 {
+
+namespace {
+
+using TimePoint = std::chrono::steady_clock::time_point;
+
+// std::chrono::steady_clock uses signed 64 bit values for time points, but that complicates
+// this computation. We offset those by this amount so TimePoint::min() becomes zero, and
+// TimePoint::max() becomes UINT64_MAX.
+constexpr auto kSignedToUnsignedOffset = std::numeric_limits<uint64_t>::max() / 2 + 1;
+
+// Converts a TimePoint to a bare uint64_t count.
+[[nodiscard]] constexpr auto timePointToUnsigned(TimePoint value) -> uint64_t {
+    return std::bit_cast<uint64_t>(value.time_since_epoch().count()) + kSignedToUnsignedOffset;
+};
+
+// Converts a bare uint64_t count to a TimePoint.
+[[nodiscard]] constexpr auto timePointFromUnsigned(uint64_t value) -> TimePoint {
+    return TimePoint{TimePoint::duration(std::bit_cast<int64_t>(value - kSignedToUnsignedOffset))};
+};
+
+// Computes the next event time after the input (forTimeNs), given the period and phase offset for
+// the event schedule.
+[[nodiscard]] constexpr auto computeNextEventTime(uint64_t periodNs, uint64_t phaseOffsetNs,
+                                                  uint64_t forTimeNs) -> uint64_t {
+    // By adding or not adding periodNs, we can eliminate underflow and overflow in the modulus
+    // portion of the computation, as doing so does not change the post-modulus result.
+    const uint64_t avoidUnderAndOverflow = (forTimeNs < periodNs) ? periodNs : 0;
+
+    // Note that adding periodNs here overflows if the next event time is greater than UINT64_MAX.
+    return forTimeNs + periodNs - ((forTimeNs + avoidUnderAndOverflow - phaseOffsetNs) % periodNs);
+}
+
+// NOLINTBEGIN(*-magic-numbers)
+
+// These compile time checks ensure the computations are free of undefined behavior.
+
+// Ensure timePointToUnsigned maps TimePoint::min() to zero
+static_assert(timePointToUnsigned(TimePoint::min()) == 0);
+
+// Ensure timePointToUnsigned maps TimePoint::max() to UINT64_MAX
+static_assert(timePointToUnsigned(TimePoint::max()) == std::numeric_limits<uint64_t>::max());
+
+// Ensure timePointFromUnsigned maps zero to TimePoint::min()
+static_assert(timePointFromUnsigned(0) == TimePoint::min());
+
+// Ensure timePointFromUnsigned maps UINT64_MAX to TimePoint::max()
+static_assert(timePointFromUnsigned(std::numeric_limits<uint64_t>::max()) == TimePoint::max());
+
+// Events with a period of 5ms and a phase offset of 0ms should happen at (5ms, 10ms, 15ms...)
+static_assert(computeNextEventTime(5'000'000, 0'000'000, 0'000'000U) == 5'000'000U);
+static_assert(computeNextEventTime(5'000'000, 0'000'000, 4'999'999U) == 5'000'000U);
+static_assert(computeNextEventTime(5'000'000, 0'000'000, 5'000'000U) == 10'000'000U);
+static_assert(computeNextEventTime(5'000'000, 0'000'000, 9'999'999U) == 10'000'000U);
+static_assert(computeNextEventTime(5'000'000, 0'000'000, 10'000'000U) == 15'000'000U);
+
+// Events with a period of 5ms and a phase offset of 1ms should happen at (1ms, 6ms, 11ms, ...)
+static_assert(computeNextEventTime(5'000'000, 1'000'000, 0'000'000U) == 1'000'000U);
+static_assert(computeNextEventTime(5'000'000, 1'000'000, 999'999U) == 1'000'000U);
+static_assert(computeNextEventTime(5'000'000, 1'000'000, 1'000'000U) == 6'000'000U);
+static_assert(computeNextEventTime(5'000'000, 1'000'000, 5'999'999U) == 6'000'000U);
+static_assert(computeNextEventTime(5'000'000, 1'000'000, 6'000'000U) == 11'000'000U);
+
+// Events with a period of 4ms and a phase offset of 1ms should happen at (1ms, 5ms, 9ms, ...)
+static_assert(computeNextEventTime(4'000'000, 1'000'000, 0'000'000U) == 1'000'000U);
+static_assert(computeNextEventTime(4'000'000, 1'000'000, 999'999U) == 1'000'000U);
+static_assert(computeNextEventTime(4'000'000, 1'000'000, 1'000'000U) == 5'000'000U);
+static_assert(computeNextEventTime(4'000'000, 1'000'000, 4'999'999U) == 5'000'000U);
+static_assert(computeNextEventTime(4'000'000, 1'000'000, 5'000'000U) == 9'000'000U);
+
+// Events with a period of 5ms and a phase offset of 2ms should happen at (2ms, 7ms, 12ms, ...)
+static_assert(computeNextEventTime(5'000'000, 2'000'000, 0'000'000U) == 2'000'000U);
+static_assert(computeNextEventTime(5'000'000, 2'000'000, 1'999'999U) == 2'000'000U);
+static_assert(computeNextEventTime(5'000'000, 2'000'000, 2'000'000U) == 7'000'000U);
+static_assert(computeNextEventTime(5'000'000, 2'000'000, 6'999'999U) == 7'000'000U);
+static_assert(computeNextEventTime(5'000'000, 2'000'000, 7'000'000U) == 12'000'000U);
+
+// Test the upper bound of the computation with forTimes near the uint64_t maximum of
+// UINT64_MAX (18'446'544'073'709'551'614).
+
+// Input values between the next to last representable event time and up the last representable
+// event time  should compute the last representable event time.
+static_assert(computeNextEventTime(5'000'000, 2'000'000, 18'446'744'073'702'000'000U) ==
+              18'446'744'073'707'000'000U);
+static_assert(computeNextEventTime(5'000'000, 2'000'000, 18'446'744'073'706'999'999U) ==
+              18'446'744'073'707'000'000U);
+
+// Values greater from the last representable event time up to UINT64_MAX will unavoidably overflow
+// as the next event time is beyond UINT64_MAX. Instead a small truncated value will be returned.
+static_assert(computeNextEventTime(5'000'000, 2'000'000, 18'446'744'073'707'000'000U) == 2'448'384);
+static_assert(computeNextEventTime(5'000'000, 2'000'000, 18'446'744'073'709'551'615U) == 2'448'384);
+
+// If the next event time happens to be representable as UINT64_MAX, that value is returned.
+static_assert(computeNextEventTime(1'00'000, 551'615, 18'446'744'073'709'551'614U) ==
+              18'446'744'073'709'551'615U);
+
+// NOLINTEND(*-magic-numbers)
+
+}  // namespace
+
+[[nodiscard]] auto SingleDisplayRefreshSchedule::nextEvent(TimePoint forTime) const -> TimePoint {
+    // The period must be positive (and not zero).
+    CHECK_GT(period, TimePoint::duration(0));
+    const auto periodNs = static_cast<uint64_t>(period.count());
+
+    // Convert and reduce the base timestamp to a phase offset value in the interval [0, period) by
+    // computing the remainder. This minimizes the overflow range.
+    const auto phaseOffsetNs = timePointToUnsigned(base) % periodNs;
+
+    // Convert the input timestamp.
+    const auto forTimeNs = timePointToUnsigned(forTime);
+
+    // Compute the next event time after the input time.
+    const auto nextTimeNs = computeNextEventTime(periodNs, phaseOffsetNs, forTimeNs);
+
+    // Ensure that the next time point is actually after the input time point. The only time this
+    // check should trigger is for times near TimePoint::max() (317 years since the epoch), where
+    // the computation of nextTimeNs exceeds TimePoint::max().
+    CHECK_GT(nextTimeNs, forTimeNs);
+
+    // Convert back to a signed TimePoint value.
+    return timePointFromUnsigned(nextTimeNs);
+}
+
+auto toString(const SingleDisplayRefreshSchedule& schedule) -> std::string {
+    return fmt::format("SingleDisplayRefreshSchedule{{base: {}, period: {}}}",
+                       schedule.base.time_since_epoch(), schedule.period);
+}
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::hwc3
diff --git a/services/surfaceflinger/tests/end2end/test_framework/hwc3/SingleDisplayRefreshSchedule.h b/services/surfaceflinger/tests/end2end/test_framework/hwc3/SingleDisplayRefreshSchedule.h
new file mode 100644
index 0000000000..de45731870
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/hwc3/SingleDisplayRefreshSchedule.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <chrono>
+#include <string>
+
+namespace android::surfaceflinger::tests::end2end::test_framework::hwc3 {
+
+// A simple fixed schedule for refresh (VSync) events for a single display
+// NOLINTBEGIN(misc-non-private-member-variables-in-classes)
+struct SingleDisplayRefreshSchedule final {
+    using TimePoint = std::chrono::steady_clock::time_point;
+    using Duration = std::chrono::steady_clock::duration;
+
+    // The base time for the refresh schedule. Each refresh occurs at (base + period * N) for some
+    // integer value N. Note: This time can be in the past or in the future, either should work
+    // fine. Refresh events will be generated according to the current time.
+    TimePoint base;
+
+    // The period for the refresh schedule. Each refresh occurs this amount of time after the prior
+    // refresh time point.
+    Duration period{};
+
+    [[nodiscard]] auto nextEvent(TimePoint forTime) const -> TimePoint;
+
+    friend auto operator==(const SingleDisplayRefreshSchedule&,
+                           const SingleDisplayRefreshSchedule&) -> bool = default;
+};
+// NOLINTEND(misc-non-private-member-variables-in-classes)
+
+auto toString(const SingleDisplayRefreshSchedule& schedule) -> std::string;
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::hwc3
diff --git a/services/surfaceflinger/tests/end2end/test_framework/hwc3/TimeKeeperThread.cpp b/services/surfaceflinger/tests/end2end/test_framework/hwc3/TimeKeeperThread.cpp
new file mode 100644
index 0000000000..9017b09217
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/hwc3/TimeKeeperThread.cpp
@@ -0,0 +1,96 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <atomic>
+#include <chrono>
+#include <memory>
+#include <semaphore>
+#include <string>
+#include <thread>
+
+#include <android-base/expected.h>
+#include <android-base/logging.h>
+#include <ftl/finalizer.h>
+#include <ftl/ignore.h>
+
+#include "test_framework/hwc3/TimeKeeperThread.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::hwc3 {
+
+struct TimeKeeperThread::Passkey final {};
+
+auto TimeKeeperThread::make() -> base::expected<std::unique_ptr<TimeKeeperThread>, std::string> {
+    using namespace std::string_literals;
+
+    auto instance = std::make_unique<TimeKeeperThread>(Passkey{});
+    if (instance == nullptr) {
+        return base::unexpected("Failed to construct the TimeKeeperThread"s);
+    }
+    if (auto result = instance->init(); !result) {
+        return base::unexpected("Failed to initialize the TimeKeeperThread: "s + result.error());
+    }
+    return instance;
+}
+
+TimeKeeperThread::TimeKeeperThread(Passkey passkey) {
+    ftl::ignore(passkey);
+}
+
+auto TimeKeeperThread::editCallbacks() -> Callbacks& {
+    return mCallbacks;
+}
+
+void TimeKeeperThread::wakeNow() {
+    mSemaphore.release();
+}
+
+auto TimeKeeperThread::init() -> base::expected<void, std::string> {
+    mThread = std::thread(&TimeKeeperThread::threadMain, this);
+    mCleanup = ftl::Finalizer([this]() { stopThread(); });
+    return {};
+}
+
+void TimeKeeperThread::stopThread() {
+    if (mThread.joinable()) {
+        mStop = true;
+        wakeNow();
+        LOG(VERBOSE) << "Waiting for thread to stop...";
+        mThread.join();
+        LOG(VERBOSE) << "Stopped.";
+    }
+}
+
+void TimeKeeperThread::threadMain() {
+    constexpr auto kNever = TimePoint::max();
+    auto targetWakeTime = kNever;
+    auto lastSleepEnded = std::chrono::steady_clock::now();
+
+    while (!mStop) {
+        if (targetWakeTime == kNever) {
+            mSemaphore.acquire();
+        } else {
+            mSemaphore.try_acquire_until(targetWakeTime);
+        }
+
+        const auto currentSleepEnded = std::chrono::steady_clock::now();
+        const auto range = TimeInterval{.begin = lastSleepEnded, .end = currentSleepEnded};
+        targetWakeTime = mCallbacks.onWakeup(range).value_or(kNever);
+
+        lastSleepEnded = currentSleepEnded;
+    }
+}
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::hwc3
diff --git a/services/surfaceflinger/tests/end2end/test_framework/hwc3/TimeKeeperThread.h b/services/surfaceflinger/tests/end2end/test_framework/hwc3/TimeKeeperThread.h
new file mode 100644
index 0000000000..f15f3ac963
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/hwc3/TimeKeeperThread.h
@@ -0,0 +1,80 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <atomic>
+#include <chrono>
+#include <memory>
+#include <semaphore>
+#include <string>
+#include <thread>
+
+#include <android-base/expected.h>
+#include <ftl/finalizer.h>
+
+#include "test_framework/core/AsyncFunction.h"
+#include "test_framework/core/TimeInterval.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::hwc3 {
+
+// Interface to a Timekeeper Thread.
+//
+// A Timekeeper thread spends most of its time sleeping. It wakes up either `wakeNow()` is invoked,
+// or at the last time returned by the `getNextWakeTime()` callback.
+//
+// Whenever it wakes up, it calls getNextWakeTime() with the range of time points for the time
+// that has elapsed.
+class TimeKeeperThread final {
+    struct Passkey;  // Uses the passkey idiom to restrict construction.
+
+  public:
+    using TimePoint = std::chrono::steady_clock::time_point;
+    using Duration = std::chrono::steady_clock::duration;
+    using TimeInterval = core::TimeInterval;
+
+    struct Callbacks final {
+        using OnWakeupConnector = core::AsyncFunctionStd<auto(TimeInterval)->TimePoint>;
+
+        // Called when the time keeper thread wakes up with the time interval spent sleeping.
+        // Returns the time the thread should next wake up.
+        OnWakeupConnector onWakeup;
+    };
+
+    [[nodiscard]] static auto make()
+            -> base::expected<std::unique_ptr<TimeKeeperThread>, std::string>;
+
+    explicit TimeKeeperThread(Passkey passkey);
+
+    auto editCallbacks() -> Callbacks&;
+
+    void wakeNow();
+
+  private:
+    auto init() -> base::expected<void, std::string>;
+    void stopThread();
+    void threadMain();
+
+    Callbacks mCallbacks;
+    std::thread mThread;
+    std::binary_semaphore mSemaphore{0};
+    std::atomic_bool mStop{false};
+
+    // Finalizers should be last so their destructors are invoked first.
+    ftl::FinalizerFtl1 mCleanup;
+};
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::hwc3
diff --git a/services/surfaceflinger/tests/end2end/test_framework/hwc3/delegators/Composer.h b/services/surfaceflinger/tests/end2end/test_framework/hwc3/delegators/Composer.h
new file mode 100644
index 0000000000..84d04a304d
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/hwc3/delegators/Composer.h
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <memory>
+#include <vector>
+
+#include <aidl/android/hardware/graphics/composer3/BnComposer.h>
+#include <aidl/android/hardware/graphics/composer3/Capability.h>
+#include <aidl/android/hardware/graphics/composer3/IComposer.h>
+#include <aidl/android/hardware/graphics/composer3/IComposerClient.h>
+#include <android/binder_auto_utils.h>
+
+namespace android::surfaceflinger::tests::end2end::test_framework::hwc3::delegators {
+
+// Implements the complete Composer interface in such a way that the default behavior can be
+// specified by defining a templated `operator()` in the derived class `Derived`.
+//
+// The derived class should override all interface functions where the default behavior isn't
+// desired, or where an extension to the default is needed. This can lead to a leaner derived class
+// especially when only a handful of interface functions need to be overridden.
+//
+// Example:
+//
+//   class MyDelegator : public hwc3::delegators::Composer<MyDelegator> {
+//      template <auto MemberFn, typename... Args>
+//      auto operator()(Args&& args...) -> ::ndk::ScopedAStatus {
+//        // A forwarding delegator would do something like:
+//        // return (mImpl.get()->*MemberFn)(std::forward<decltype(args)>(args)...);
+//
+//        // A no-op stub might just return a default status, like:
+//        return ::ndk::ScopedAStatus::ok();
+//      }
+//   };
+//
+template <class Derived>
+class Composer : public ::aidl::android::hardware::graphics::composer3::BnComposer {
+    friend Derived;
+    Composer() = default;
+
+  public:
+    auto delegator() -> Derived* { return static_cast<Derived*>(this); }
+
+    // clang-format off
+    #pragma clang diagnostic push
+    #pragma clang diagnostic ignored "-Wdeprecated-declarations"
+
+    auto createClient(std::shared_ptr<::aidl::android::hardware::graphics::composer3::IComposerClient>* _aidl_return) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposer::createClient>(_aidl_return);
+    }
+    auto getCapabilities(std::vector<::aidl::android::hardware::graphics::composer3::Capability>* _aidl_return) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposer::getCapabilities>(_aidl_return);
+    }
+
+    // Note: When updating this interface, a useful starting point is the generated
+    // ::aidl::android::hardware::graphics::composer3::IComposerDelegator class defined in
+    // BnComposer.h
+
+    #pragma clang diagnostic pop
+    // clang-format on
+};
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::hwc3::delegators
diff --git a/services/surfaceflinger/tests/end2end/test_framework/hwc3/delegators/ComposerCallback.h b/services/surfaceflinger/tests/end2end/test_framework/hwc3/delegators/ComposerCallback.h
new file mode 100644
index 0000000000..18dba467e3
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/hwc3/delegators/ComposerCallback.h
@@ -0,0 +1,93 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <cstdint>
+
+#include <aidl/android/hardware/graphics/common/DisplayHotplugEvent.h>
+#include <aidl/android/hardware/graphics/composer3/BnComposerCallback.h>
+#include <aidl/android/hardware/graphics/composer3/IComposerCallback.h>
+#include <android/binder_auto_utils.h>
+
+namespace android::surfaceflinger::tests::end2end::test_framework::hwc3::delegators {
+
+// Implements the complete ComposerCallback interface in such a way that the default behavior can be
+// specified by defining a templated `operator()` in the derived class `Derived`.
+//
+// The derived class should override all interface functions where the default behavior isn't
+// desired, or where an extension to the default is needed. This can lead to a leaner derived class
+// especially when only a handful of interface functions need to be overridden.
+//
+// Example:
+//
+//   class MyDelegator : public hwc3::delegators::ComposerCallback<MyDelegator> {
+//      template <auto MemberFn, typename... Args>
+//      auto operator()(Args&& args...) -> ::ndk::ScopedAStatus {
+//        // A forwarding delegator would do something like:
+//        // return (mImpl.get()->*MemberFn)(std::forward<decltype(args)>(args)...);
+//
+//        // A no-op stub might just return a default status, like:
+//        return ::ndk::ScopedAStatus::ok();
+//      }
+//   };
+//
+template <class Delegator>
+class ComposerCallback : public ::aidl::android::hardware::graphics::composer3::BnComposerCallback {
+    friend Delegator;
+    ComposerCallback() = default;
+
+  public:
+    auto delegator() -> Delegator* { return static_cast<Delegator*>(this); }
+
+    // clang-format off
+    #pragma clang diagnostic push
+    #pragma clang diagnostic ignored "-Wdeprecated-declarations"
+
+    auto onHotplug(int64_t in_display, bool in_connected) -> ::ndk::ScopedAStatus override __attribute__((deprecated(": Use instead onHotplugEvent"))) {
+        return delegator()->template operator()<&IComposerCallback::onHotplug>(in_display, in_connected);
+    }
+    auto onRefresh(int64_t in_display) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerCallback::onRefresh>(in_display);
+    }
+    auto onSeamlessPossible(int64_t in_display) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerCallback::onSeamlessPossible>(in_display);
+    }
+    auto onVsync(int64_t in_display, int64_t in_timestamp, int32_t in_vsyncPeriodNanos) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerCallback::onVsync>(in_display, in_timestamp, in_vsyncPeriodNanos);
+    }
+    auto onVsyncPeriodTimingChanged(int64_t in_display, const ::aidl::android::hardware::graphics::composer3::VsyncPeriodChangeTimeline& in_updatedTimeline) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerCallback::onVsyncPeriodTimingChanged>(in_display, in_updatedTimeline);
+    }
+    auto onVsyncIdle(int64_t in_display) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerCallback::onVsyncIdle>(in_display);
+    }
+    auto onRefreshRateChangedDebug(const ::aidl::android::hardware::graphics::composer3::RefreshRateChangedDebugData& in_data) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerCallback::onRefreshRateChangedDebug>(in_data);
+    }
+    auto onHotplugEvent(int64_t in_display, ::aidl::android::hardware::graphics::common::DisplayHotplugEvent in_event) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerCallback::onHotplugEvent>(in_display, in_event);
+    }
+
+    // Note: When updating this interface, a useful starting point is the generated
+    // ::aidl::android::hardware::graphics::composer3::IComposerCallbackDelegator class defined in
+    // BnComposerCallback.h
+
+    #pragma clang diagnostic pop
+    // clang-format on
+};
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::hwc3::delegators
diff --git a/services/surfaceflinger/tests/end2end/test_framework/hwc3/delegators/ComposerClient.h b/services/surfaceflinger/tests/end2end/test_framework/hwc3/delegators/ComposerClient.h
new file mode 100644
index 0000000000..46edc5f0c1
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/hwc3/delegators/ComposerClient.h
@@ -0,0 +1,229 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <cstdint>
+#include <memory>
+#include <optional>
+#include <string>
+#include <vector>
+
+#include <aidl/android/hardware/graphics/common/Dataspace.h>
+
+#include <aidl/android/hardware/graphics/common/Hdr.h>
+#include <aidl/android/hardware/graphics/common/HdrConversionStrategy.h>
+#include <aidl/android/hardware/graphics/common/PixelFormat.h>
+#include <aidl/android/hardware/graphics/common/Transform.h>
+#include <aidl/android/hardware/graphics/composer3/BnComposerClient.h>
+#include <aidl/android/hardware/graphics/composer3/ColorMode.h>
+#include <aidl/android/hardware/graphics/composer3/CommandResultPayload.h>
+#include <aidl/android/hardware/graphics/composer3/ContentType.h>
+#include <aidl/android/hardware/graphics/composer3/DisplayAttribute.h>
+#include <aidl/android/hardware/graphics/composer3/DisplayCapability.h>
+#include <aidl/android/hardware/graphics/composer3/DisplayConnectionType.h>
+#include <aidl/android/hardware/graphics/composer3/FormatColorComponent.h>
+#include <aidl/android/hardware/graphics/composer3/IComposerClient.h>
+#include <aidl/android/hardware/graphics/composer3/PerFrameMetadataKey.h>
+#include <aidl/android/hardware/graphics/composer3/PowerMode.h>
+#include <aidl/android/hardware/graphics/composer3/RenderIntent.h>
+#include <android/binder_auto_utils.h>
+
+namespace android::surfaceflinger::tests::end2end::test_framework::hwc3::delegators {
+
+// Implements the complete ComposerClient interface in such a way that the default behavior can be
+// specified by defining a templated `operator()` in the derived class `Derived`.
+//
+// The derived class should override all interface functions where the default behavior isn't
+// desired, or where an extension to the default is needed. This can lead to a leaner derived class
+// especially when only a handful of interface functions need to be overridden.
+//
+// Example:
+//
+//   class MyDelegator : public hwc3::delegators::ComposerClient<MyDelegator> {
+//      template <auto MemberFn, typename... Args>
+//      auto operator()(Args&& args...) -> ::ndk::ScopedAStatus {
+//        // A forwarding delegator would do something like:
+//        // return (mImpl.get()->*MemberFn)(std::forward<decltype(args)>(args)...);
+//
+//        // A no-op stub might just return a default status, like:
+//        return ::ndk::ScopedAStatus::ok();
+//      }
+//   };
+//
+template <class Delegator>
+class ComposerClient : public ::aidl::android::hardware::graphics::composer3::BnComposerClient {
+    friend Delegator;
+    ComposerClient() = default;
+
+  public:
+    auto delegator() -> Delegator* { return static_cast<Delegator*>(this); }
+
+    // clang-format off
+    #pragma clang diagnostic push
+    #pragma clang diagnostic ignored "-Wdeprecated-declarations"
+
+    auto createLayer(int64_t in_display, int32_t in_bufferSlotCount, int64_t* _aidl_return) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::createLayer>(in_display, in_bufferSlotCount, _aidl_return);
+    }
+    auto createVirtualDisplay(int32_t in_width, int32_t in_height, ::aidl::android::hardware::graphics::common::PixelFormat in_formatHint, int32_t in_outputBufferSlotCount, ::aidl::android::hardware::graphics::composer3::VirtualDisplay* _aidl_return) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::createVirtualDisplay>(in_width, in_height, in_formatHint, in_outputBufferSlotCount, _aidl_return);
+    }
+    auto destroyLayer(int64_t in_display, int64_t in_layer) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::destroyLayer>(in_display, in_layer);
+    }
+    auto destroyVirtualDisplay(int64_t in_display) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::destroyVirtualDisplay>(in_display);
+    }
+    auto executeCommands(const std::vector<::aidl::android::hardware::graphics::composer3::DisplayCommand>& in_commands, std::vector<::aidl::android::hardware::graphics::composer3::CommandResultPayload>* _aidl_return) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::executeCommands>(in_commands, _aidl_return);
+    }
+    auto getActiveConfig(int64_t in_display, int32_t* _aidl_return) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::getActiveConfig>(in_display, _aidl_return);
+    }
+    auto getColorModes(int64_t in_display, std::vector<::aidl::android::hardware::graphics::composer3::ColorMode>* _aidl_return) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::getColorModes>(in_display, _aidl_return);
+    }
+    auto getDataspaceSaturationMatrix(::aidl::android::hardware::graphics::common::Dataspace in_dataspace, std::vector<float>* _aidl_return) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::getDataspaceSaturationMatrix>(in_dataspace, _aidl_return);
+    }
+    auto getDisplayAttribute(int64_t in_display, int32_t in_config, ::aidl::android::hardware::graphics::composer3::DisplayAttribute in_attribute, int32_t* _aidl_return) -> ::ndk::ScopedAStatus override __attribute__((deprecated("use getDisplayConfigurations instead. Returns a display attribute value for a particular display configuration. For legacy support getDisplayAttribute should return valid values for any requested DisplayAttribute, and for all of the configs obtained either through getDisplayConfigs or getDisplayConfigurations."))) {
+        return delegator()->template operator()<&IComposerClient::getDisplayAttribute>(in_display, in_config, in_attribute, _aidl_return);
+    }
+    auto getDisplayCapabilities(int64_t in_display, std::vector<::aidl::android::hardware::graphics::composer3::DisplayCapability>* _aidl_return) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::getDisplayCapabilities>(in_display, _aidl_return);
+    }
+    auto getDisplayConfigs(int64_t in_display, std::vector<int32_t>* _aidl_return) -> ::ndk::ScopedAStatus override __attribute__((deprecated("use getDisplayConfigurations instead. For legacy support getDisplayConfigs should return at least one valid config. All the configs returned from the getDisplayConfigs should also be returned from getDisplayConfigurations."))) {
+        return delegator()->template operator()<&IComposerClient::getDisplayConfigs>(in_display, _aidl_return);
+    }
+    auto getDisplayConnectionType(int64_t in_display, ::aidl::android::hardware::graphics::composer3::DisplayConnectionType* _aidl_return) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::getDisplayConnectionType>(in_display, _aidl_return);
+    }
+    auto getDisplayIdentificationData(int64_t in_display, ::aidl::android::hardware::graphics::composer3::DisplayIdentification* _aidl_return) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::getDisplayIdentificationData>(in_display, _aidl_return);
+    }
+    auto getDisplayName(int64_t in_display, std::string* _aidl_return) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::getDisplayName>(in_display, _aidl_return);
+    }
+    auto getDisplayVsyncPeriod(int64_t in_display, int32_t* _aidl_return) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::getDisplayVsyncPeriod>(in_display, _aidl_return);
+    }
+    auto getDisplayedContentSample(int64_t in_display, int64_t in_maxFrames, int64_t in_timestamp, ::aidl::android::hardware::graphics::composer3::DisplayContentSample* _aidl_return) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::getDisplayedContentSample>(in_display, in_maxFrames, in_timestamp, _aidl_return);
+    }
+    auto getDisplayedContentSamplingAttributes(int64_t in_display, ::aidl::android::hardware::graphics::composer3::DisplayContentSamplingAttributes* _aidl_return) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::getDisplayedContentSamplingAttributes>(in_display, _aidl_return);
+    }
+    auto getDisplayPhysicalOrientation(int64_t in_display, ::aidl::android::hardware::graphics::common::Transform* _aidl_return) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::getDisplayPhysicalOrientation>(in_display, _aidl_return);
+    }
+    auto getHdrCapabilities(int64_t in_display, ::aidl::android::hardware::graphics::composer3::HdrCapabilities* _aidl_return) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::getHdrCapabilities>(in_display, _aidl_return);
+    }
+    auto getMaxVirtualDisplayCount(int32_t* _aidl_return) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::getMaxVirtualDisplayCount>(_aidl_return);
+    }
+    auto getPerFrameMetadataKeys(int64_t in_display, std::vector<::aidl::android::hardware::graphics::composer3::PerFrameMetadataKey>* _aidl_return) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::getPerFrameMetadataKeys>(in_display, _aidl_return);
+    }
+    auto getReadbackBufferAttributes(int64_t in_display, ::aidl::android::hardware::graphics::composer3::ReadbackBufferAttributes* _aidl_return) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::getReadbackBufferAttributes>(in_display, _aidl_return);
+    }
+    auto getReadbackBufferFence(int64_t in_display, ::ndk::ScopedFileDescriptor* _aidl_return) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::getReadbackBufferFence>(in_display, _aidl_return);
+    }
+    auto getRenderIntents(int64_t in_display, ::aidl::android::hardware::graphics::composer3::ColorMode in_mode, std::vector<::aidl::android::hardware::graphics::composer3::RenderIntent>* _aidl_return) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::getRenderIntents>(in_display, in_mode, _aidl_return);
+    }
+    auto getSupportedContentTypes(int64_t in_display, std::vector<::aidl::android::hardware::graphics::composer3::ContentType>* _aidl_return) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::getSupportedContentTypes>(in_display, _aidl_return);
+    }
+    auto getDisplayDecorationSupport(int64_t in_display, std::optional<::aidl::android::hardware::graphics::common::DisplayDecorationSupport>* _aidl_return) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::getDisplayDecorationSupport>(in_display, _aidl_return);
+    }
+    auto registerCallback(const std::shared_ptr<::aidl::android::hardware::graphics::composer3::IComposerCallback>& in_callback) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::registerCallback>(in_callback);
+    }
+    auto setActiveConfig(int64_t in_display, int32_t in_config) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::setActiveConfig>(in_display, in_config);
+    }
+    auto setActiveConfigWithConstraints(int64_t in_display, int32_t in_config, const ::aidl::android::hardware::graphics::composer3::VsyncPeriodChangeConstraints& in_vsyncPeriodChangeConstraints, ::aidl::android::hardware::graphics::composer3::VsyncPeriodChangeTimeline* _aidl_return) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::setActiveConfigWithConstraints>(in_display, in_config, in_vsyncPeriodChangeConstraints, _aidl_return);
+    }
+    auto setBootDisplayConfig(int64_t in_display, int32_t in_config) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::setBootDisplayConfig>(in_display, in_config);
+    }
+    auto clearBootDisplayConfig(int64_t in_display) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::clearBootDisplayConfig>(in_display);
+    }
+    auto getPreferredBootDisplayConfig(int64_t in_display, int32_t* _aidl_return) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::getPreferredBootDisplayConfig>(in_display, _aidl_return);
+    }
+    auto setAutoLowLatencyMode(int64_t in_display, bool in_on) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::setAutoLowLatencyMode>(in_display, in_on);
+    }
+    auto setClientTargetSlotCount(int64_t in_display, int32_t in_clientTargetSlotCount) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::setClientTargetSlotCount>(in_display, in_clientTargetSlotCount);
+    }
+    auto setColorMode(int64_t in_display, ::aidl::android::hardware::graphics::composer3::ColorMode in_mode, ::aidl::android::hardware::graphics::composer3::RenderIntent in_intent) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::setColorMode>(in_display, in_mode, in_intent);
+    }
+    auto setContentType(int64_t in_display, ::aidl::android::hardware::graphics::composer3::ContentType in_type) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::setContentType>(in_display, in_type);
+    }
+    auto setDisplayedContentSamplingEnabled(int64_t in_display, bool in_enable, ::aidl::android::hardware::graphics::composer3::FormatColorComponent in_componentMask, int64_t in_maxFrames) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::setDisplayedContentSamplingEnabled>(in_display, in_enable, in_componentMask, in_maxFrames);
+    }
+    auto setPowerMode(int64_t in_display, ::aidl::android::hardware::graphics::composer3::PowerMode in_mode) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::setPowerMode>(in_display, in_mode);
+    }
+    auto setReadbackBuffer(int64_t in_display, const ::aidl::android::hardware::common::NativeHandle& in_buffer, const ::ndk::ScopedFileDescriptor& in_releaseFence) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::setReadbackBuffer>(in_display, in_buffer, in_releaseFence);
+    }
+    auto setVsyncEnabled(int64_t in_display, bool in_enabled) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::setVsyncEnabled>(in_display, in_enabled);
+    }
+    auto setIdleTimerEnabled(int64_t in_display, int32_t in_timeoutMs) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::setIdleTimerEnabled>(in_display, in_timeoutMs);
+    }
+    auto getOverlaySupport(::aidl::android::hardware::graphics::composer3::OverlayProperties* _aidl_return) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::getOverlaySupport>(_aidl_return);
+    }
+    auto getHdrConversionCapabilities(std::vector<::aidl::android::hardware::graphics::common::HdrConversionCapability>* _aidl_return) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::getHdrConversionCapabilities>(_aidl_return);
+    }
+    auto setHdrConversionStrategy(const ::aidl::android::hardware::graphics::common::HdrConversionStrategy& in_conversionStrategy, ::aidl::android::hardware::graphics::common::Hdr* _aidl_return) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::setHdrConversionStrategy>(in_conversionStrategy, _aidl_return);
+    }
+    auto setRefreshRateChangedCallbackDebugEnabled(int64_t in_display, bool in_enabled) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::setRefreshRateChangedCallbackDebugEnabled>(in_display, in_enabled);
+    }
+    auto getDisplayConfigurations(int64_t in_display, int32_t in_maxFrameIntervalNs, std::vector<::aidl::android::hardware::graphics::composer3::DisplayConfiguration>* _aidl_return) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::getDisplayConfigurations>(in_display, in_maxFrameIntervalNs, _aidl_return);
+    }
+    auto notifyExpectedPresent(int64_t in_display, const ::aidl::android::hardware::graphics::composer3::ClockMonotonicTimestamp& in_expectedPresentTime, int32_t in_frameIntervalNs) -> ::ndk::ScopedAStatus override {
+        return delegator()->template operator()<&IComposerClient::notifyExpectedPresent>(in_display, in_expectedPresentTime, in_frameIntervalNs);
+    }
+
+    // Note: When updating this interface, a useful starting point is the generated
+    // ::aidl::android::hardware::graphics::composer3::IComposerClientDelegator class defined in
+    // BnComposerClient.h
+
+    #pragma clang diagnostic pop
+    // clang-format on
+};
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::hwc3::delegators
\ No newline at end of file
diff --git a/services/surfaceflinger/tests/end2end/test_framework/hwc3/events/ClientDestroyed.h b/services/surfaceflinger/tests/end2end/test_framework/hwc3/events/ClientDestroyed.h
new file mode 100644
index 0000000000..26b3e3b3d1
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/hwc3/events/ClientDestroyed.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <string>
+
+#include <ftl/ignore.h>
+
+#include "test_framework/core/AsyncFunction.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::hwc3::events {
+
+struct ClientDestroyed final {
+    using AsyncConnector = core::AsyncFunctionStd<void(ClientDestroyed)>;
+};
+
+inline auto toString(const ClientDestroyed& event) -> std::string {
+    ftl::ignore(event);
+    return "hwcClientDestroyed{}";
+}
+
+inline auto format_as(const ClientDestroyed& event) -> std::string {
+    return toString(event);
+}
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::hwc3::events
diff --git a/services/surfaceflinger/tests/end2end/test_framework/hwc3/events/DisplayPresented.h b/services/surfaceflinger/tests/end2end/test_framework/hwc3/events/DisplayPresented.h
new file mode 100644
index 0000000000..df2d683f38
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/hwc3/events/DisplayPresented.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <chrono>
+
+#include <fmt/chrono.h>  // NOLINT(misc-include-cleaner)
+#include <fmt/format.h>
+
+#include "test_framework/core/AsyncFunction.h"
+#include "test_framework/core/DisplayConfiguration.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::hwc3::events {
+
+struct DisplayPresented final {
+    using AsyncConnector = core::AsyncFunctionStd<void(DisplayPresented)>;
+
+    using DisplayId = core::DisplayConfiguration::Id;
+    using TimePoint = std::chrono::steady_clock::time_point;
+
+    DisplayId displayId{};
+    TimePoint expectedPresentTime;
+    TimePoint receivedAt{std::chrono::steady_clock::now()};
+
+    friend auto operator==(const DisplayPresented&, const DisplayPresented&) -> bool = default;
+};
+
+inline auto toString(const DisplayPresented& event) -> std::string {
+    return fmt::format(
+            "hwcDisplayPresented{{"
+            " displayId: {},"
+            " expectedPresentTime: {}"
+            " receivedAt: {}"
+            " }}",
+            event.displayId, event.expectedPresentTime.time_since_epoch(),
+            event.receivedAt.time_since_epoch());
+}
+
+inline auto format_as(const DisplayPresented& event) -> std::string {
+    return toString(event);
+}
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::hwc3::events
diff --git a/services/surfaceflinger/tests/end2end/test_framework/hwc3/events/PendingBufferSwap.h b/services/surfaceflinger/tests/end2end/test_framework/hwc3/events/PendingBufferSwap.h
new file mode 100644
index 0000000000..2a0bfcdd34
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/hwc3/events/PendingBufferSwap.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <chrono>
+#include <cstdint>
+#include <optional>
+#include <string>
+
+#include <fmt/chrono.h>  // NOLINT(misc-include-cleaner)
+#include <fmt/format.h>
+#include <fmt/std.h>
+
+#include "test_framework/core/AsyncFunction.h"
+#include "test_framework/core/BufferId.h"
+#include "test_framework/core/DisplayConfiguration.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::hwc3::events {
+
+struct PendingBufferSwap final {
+    using AsyncConnector = core::AsyncFunctionStd<void(PendingBufferSwap)>;
+
+    using DisplayId = core::DisplayConfiguration::Id;
+    using LayerId = int64_t;
+    using TimePoint = std::chrono::steady_clock::time_point;
+
+    DisplayId displayId{};
+    LayerId layerId{};
+    std::optional<core::BufferId> pendingDisplay;
+    std::optional<core::BufferId> pendingRelease;
+    TimePoint expectedPresentTime;
+    TimePoint receivedAt{std::chrono::steady_clock::now()};
+
+    friend auto operator==(const PendingBufferSwap&, const PendingBufferSwap&) -> bool = default;
+};
+
+inline auto toString(const PendingBufferSwap& event) -> std::string {
+    const auto valueToString = [](const auto& value) { return toString(value); };
+    return fmt::format(
+            "hwcPendingBufferSwap{{"
+            " displayId: {},"
+            " layerId: {},"
+            " pendingDisplay: {}"
+            " pendingRelease: {}"
+            " expectedPresentTime: {}"
+            " receivedAt: {}"
+            " }}",
+            event.displayId, event.layerId, event.pendingDisplay.transform(valueToString),
+            event.pendingRelease.transform(valueToString),
+            event.expectedPresentTime.time_since_epoch(), event.receivedAt.time_since_epoch());
+}
+
+inline auto format_as(const PendingBufferSwap& event) -> std::string {
+    return toString(event);
+}
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::hwc3::events
diff --git a/services/surfaceflinger/tests/end2end/test_framework/hwc3/events/PowerMode.h b/services/surfaceflinger/tests/end2end/test_framework/hwc3/events/PowerMode.h
new file mode 100644
index 0000000000..968a830167
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/hwc3/events/PowerMode.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <chrono>
+#include <string>
+
+#include <aidl/android/hardware/graphics/composer3/PowerMode.h>
+#include <fmt/format.h>
+#include <ftl/enum.h>
+
+#include "test_framework/core/AsyncFunction.h"
+#include "test_framework/core/DisplayConfiguration.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::hwc3::events {
+
+struct PowerMode final {
+    using AsyncConnector = core::AsyncFunctionStd<void(PowerMode)>;
+
+    using DisplayId = core::DisplayConfiguration::Id;
+    using Hwc3PowerMode = aidl::android::hardware::graphics::composer3::PowerMode;
+    using TimePoint = std::chrono::steady_clock::time_point;
+
+    DisplayId displayId{};
+    Hwc3PowerMode mode{};
+    TimePoint receivedAt{std::chrono::steady_clock::now()};
+
+    friend auto operator==(const PowerMode&, const PowerMode&) -> bool = default;
+};
+
+inline auto toString(const PowerMode& event) -> std::string {
+    return fmt::format(
+            "hwcPowerMode{{"
+            " displayId: {},"
+            " mode: {}"
+            " receivedAt: {}"
+            " }}",
+            event.displayId, toString(event.mode), event.receivedAt.time_since_epoch());
+}
+
+inline auto format_as(const PowerMode& event) -> std::string {
+    return toString(event);
+}
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::hwc3::events
diff --git a/services/surfaceflinger/tests/end2end/test_framework/hwc3/events/VSync.h b/services/surfaceflinger/tests/end2end/test_framework/hwc3/events/VSync.h
new file mode 100644
index 0000000000..4db52a909b
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/hwc3/events/VSync.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <chrono>
+#include <string>
+
+#include <fmt/chrono.h>  // NOLINT(misc-include-cleaner)
+#include <fmt/format.h>
+
+#include "test_framework/core/AsyncFunction.h"
+#include "test_framework/core/DisplayConfiguration.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::hwc3::events {
+
+struct VSync final {
+    using AsyncConnector = core::AsyncFunctionStd<void(VSync)>;
+
+    using DisplayId = core::DisplayConfiguration::Id;
+    using TimePoint = std::chrono::steady_clock::time_point;
+    using Duration = std::chrono::steady_clock::duration;
+
+    DisplayId displayId{};
+    TimePoint expectedAt;
+    Duration expectedPeriod{};
+    TimePoint receivedAt{std::chrono::steady_clock::now()};
+
+    friend auto operator==(const VSync&, const VSync&) -> bool = default;
+};
+
+inline auto toString(const VSync& event) -> std::string {
+    return fmt::format(
+            "hwcVSync{{"
+            " displayId: {},"
+            " expectedAt: {},"
+            " expectedPeriod: {},"
+            " receivedAt: {}"
+            " }}",
+            event.displayId, event.expectedAt.time_since_epoch(), event.expectedPeriod,
+            event.receivedAt.time_since_epoch());
+}
+
+inline auto format_as(const VSync& event) -> std::string {
+    return toString(event);
+}
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::hwc3::events
diff --git a/services/surfaceflinger/tests/end2end/test_framework/hwc3/events/VSyncEnabled.h b/services/surfaceflinger/tests/end2end/test_framework/hwc3/events/VSyncEnabled.h
new file mode 100644
index 0000000000..25f6ea44ff
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/hwc3/events/VSyncEnabled.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <chrono>
+#include <cstdint>
+#include <string>
+
+#include <fmt/chrono.h>  // NOLINT(misc-include-cleaner)
+#include <fmt/format.h>
+
+#include "test_framework/core/AsyncFunction.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::hwc3::events {
+
+struct VSyncEnabled final {
+    using AsyncConnector = core::AsyncFunctionStd<void(VSyncEnabled)>;
+
+    using TimePoint = std::chrono::steady_clock::time_point;
+
+    int64_t displayId{};
+    bool enabled{};
+    TimePoint receivedAt{std::chrono::steady_clock::now()};
+
+    friend auto operator==(const VSyncEnabled&, const VSyncEnabled&) -> bool = default;
+};
+
+inline auto toString(const VSyncEnabled& event) -> std::string {
+    return fmt::format(
+            "hwcVSyncEnabled{{"
+            " displayId: {},"
+            " enabled: {},"
+            " receivedAt: {}"
+            " }}",
+            event.displayId, event.enabled, event.receivedAt.time_since_epoch());
+}
+
+inline auto format_as(const VSyncEnabled& event) -> std::string {
+    return toString(event);
+}
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::hwc3::events
diff --git a/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/DisplayEventReceiver.cpp b/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/DisplayEventReceiver.cpp
new file mode 100644
index 0000000000..662ccf7472
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/DisplayEventReceiver.cpp
@@ -0,0 +1,294 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <array>
+#include <bit>
+#include <chrono>
+#include <cstddef>
+#include <cstdint>
+#include <memory>
+#include <optional>
+#include <span>
+#include <string>
+#include <utility>
+
+#include <sys/types.h>
+
+#include <android-base/expected.h>
+#include <android-base/logging.h>
+#include <android/gui/IDisplayEventConnection.h>
+#include <android/gui/ISurfaceComposer.h>
+#include <binder/IBinder.h>
+#include <fmt/format.h>
+#include <ftl/finalizer.h>
+#include <ftl/flags.h>
+#include <ftl/ignore.h>
+#include <gui/DisplayEventReceiver.h>
+#include <private/gui/BitTube.h>
+#include <ui/DisplayId.h>
+#include <utils/StrongPointer.h>
+
+#include "test_framework/core/DisplayConfiguration.h"
+#include "test_framework/surfaceflinger/DisplayEventReceiver.h"
+#include "test_framework/surfaceflinger/PollFdThread.h"
+#include "test_framework/surfaceflinger/SFController.h"
+#include "test_framework/surfaceflinger/events/Hotplug.h"
+#include "test_framework/surfaceflinger/events/VSyncTiming.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger {
+
+struct DisplayEventReceiver::Passkey final {};
+
+auto DisplayEventReceiver::make(std::weak_ptr<SFController> controller,
+                                const sp<gui::ISurfaceComposer>& client, PollFdThread& pollFdThread,
+                                gui::ISurfaceComposer::VsyncSource source,
+                                const sp<IBinder>& layerHandle,
+                                const ftl::Flags<gui::ISurfaceComposer::EventRegistration>& events)
+        -> base::expected<std::shared_ptr<DisplayEventReceiver>, std::string> {
+    using namespace std::string_literals;
+
+    auto instance = std::make_unique<DisplayEventReceiver>(Passkey{});
+    if (instance == nullptr) {
+        return base::unexpected("Failed to construct a DisplayEventReceiver"s);
+    }
+    if (auto result = instance->init(std::move(controller), client, pollFdThread, source,
+                                     layerHandle, events);
+        !result) {
+        return base::unexpected("Failed to init a DisplayEventReceiver: " + result.error());
+    }
+    return std::move(instance);
+}
+
+DisplayEventReceiver::DisplayEventReceiver(Passkey passkey) {
+    ftl::ignore(passkey);
+}
+
+[[nodiscard]] auto DisplayEventReceiver::init(
+        std::weak_ptr<SFController> controller, const sp<gui::ISurfaceComposer>& client,
+        PollFdThread& pollFdThread,
+
+        gui::ISurfaceComposer::VsyncSource source, const sp<IBinder>& layerHandle,
+        const ftl::Flags<gui::ISurfaceComposer::EventRegistration>& events)
+        -> base::expected<void, std::string> {
+    using namespace std::string_literals;
+
+    sp<gui::IDisplayEventConnection> displayEventConnection;
+    auto result = client->createDisplayEventConnection(
+            source, std::bit_cast<gui::ISurfaceComposer::EventRegistration>(events.get()),
+            layerHandle, &displayEventConnection);
+
+    if (!result.isOk() || displayEventConnection == nullptr) {
+        return base::unexpected("failed to create the display event connection"s);
+    }
+    auto dataChannel = std::make_unique<gui::BitTube>();
+    result = displayEventConnection->stealReceiveChannel(dataChannel.get());
+    if (!result.isOk()) {
+        return base::unexpected("failed to steal the receive channel"s);
+    }
+
+    mController = std::move(controller);
+    mPollFdThread = &pollFdThread;
+    mDisplayEventConnection = std::move(displayEventConnection);
+    mDataChannel = std::move(dataChannel);
+    pollFdThread.addFileDescriptor(mDataChannel->getFd(), {PollFdThread::PollFlags::IN},
+                                   [this]() { processReceivedEvents(); });
+
+    mCleanup = ftl::Finalizer(
+            [this]() { mPollFdThread->removeFileDescriptor(mDataChannel->getFd()); });
+
+    LOG(VERBOSE) << "initialized";
+    return {};
+}
+
+auto DisplayEventReceiver::editCallbacks() -> Callbacks& {
+    return mCallbacks;
+}
+
+void DisplayEventReceiver::setVsyncRate(int32_t count) const {
+    LOG(VERBOSE) << __func__ << " count " << count;
+    CHECK(count >= 0);
+    mDisplayEventConnection->setVsyncRate(count);
+}
+
+void DisplayEventReceiver::requestNextVsync() const {
+    LOG(VERBOSE) << __func__;
+    mDisplayEventConnection->requestNextVsync();
+}
+
+[[nodiscard]] auto DisplayEventReceiver::getLatestVsyncEventData() const
+        -> std::optional<ParcelableVsyncEventData> {
+    LOG(VERBOSE) << __func__;
+    ParcelableVsyncEventData data;
+    auto status = mDisplayEventConnection->getLatestVsyncEventData(&data);
+    if (!status.isOk()) {
+        LOG(ERROR) << "Failed to get latest vsync event data: " << status.toString8();
+        return {};
+    }
+    return data;
+}
+
+void DisplayEventReceiver::processReceivedEvents() {
+    for (;;) {
+        constexpr auto kMaxEventBatchSize = 10;
+        std::array<Event, kMaxEventBatchSize> events{};
+        const ssize_t eventCount =
+                gui::BitTube::recvObjects(mDataChannel.get(), events.data(), events.size());
+        LOG(VERBOSE) << __func__ << " received " << eventCount << " events";
+        CHECK(eventCount >= 0);
+        if (eventCount == 0) {
+            return;
+        }
+        processReceivedEvents({events.data(), static_cast<size_t>(eventCount)});
+    }
+}
+
+void DisplayEventReceiver::processReceivedEvents(std::span<Event> events) {
+    LOG(VERBOSE) << __func__ << " " << events.size() << " events";
+    for (const auto& event : events) {
+        LOG(VERBOSE) << fmt::format("event {:#x}", fmt::underlying(event.header.type));
+
+        auto timestamp = Timestamp(std::chrono::steady_clock::duration(event.header.timestamp));
+
+        // NOLINTBEGIN(cppcoreguidelines-pro-type-union-access)
+        switch (event.header.type) {
+            default:
+                LOG(FATAL) << fmt::format("Unknown event type {:#x}",
+                                          fmt::underlying(event.header.type));
+                break;
+
+            case EventType::DISPLAY_EVENT_FRAME_RATE_OVERRIDE_FLUSH:
+                LOG(FATAL) << "Unexpected DISPLAY_EVENT_FRAME_RATE_OVERRIDE_FLUSH event";
+                break;
+
+            case EventType::DISPLAY_EVENT_VSYNC:
+                onVsync(event.header.displayId, timestamp, event.vsync.count,
+                        event.vsync.vsyncData);
+                break;
+
+            case EventType::DISPLAY_EVENT_HOTPLUG:
+                onHotplug(event.header.displayId, timestamp, event.hotplug.connected,
+                          event.hotplug.connectionError);
+                break;
+
+            case EventType::DISPLAY_EVENT_MODE_CHANGE:
+                onModeChange(event.header.displayId, timestamp, event.modeChange.modeId,
+                             std::chrono::nanoseconds(event.modeChange.vsyncPeriod));
+                break;
+
+            case EventType::DISPLAY_EVENT_FRAME_RATE_OVERRIDE:
+                onFrameRateOverride(event.header.displayId, timestamp, event.frameRateOverride.uid,
+                                    event.frameRateOverride.frameRateHz);
+                break;
+
+            case EventType::DISPLAY_EVENT_HDCP_LEVELS_CHANGE:
+                onHdcpLevelsChange(event.header.displayId, timestamp,
+                                   event.hdcpLevelsChange.connectedLevel,
+                                   event.hdcpLevelsChange.maxLevel);
+                break;
+        }
+        // NOLINTEND(cppcoreguidelines-pro-type-union-access)
+    }
+}
+
+auto DisplayEventReceiver::mapPhysicalDisplayIdToTestDisplayId(PhysicalDisplayId displayId)
+        -> std::optional<core::DisplayConfiguration::Id> {
+    auto controller = mController.lock();
+    if (!controller) {
+        LOG(WARNING) << "Unable to map physical displayId " << displayId
+                     << " to a test display id. SFController gone.";
+        return {};
+    }
+
+    auto testDisplayId = controller->mapPhysicalDisplayIdToTestDisplayId(displayId);
+    if (!testDisplayId) {
+        LOG(WARNING) << "Unable to map physical displayId " << displayId << " to a test display id";
+        return {};
+    }
+
+    return testDisplayId;
+}
+
+void DisplayEventReceiver::onVsync(DisplayId displayId, Timestamp timestamp, uint32_t count,
+                                   VsyncEventData vsyncData) {
+    ftl::ignore(displayId, timestamp, count, vsyncData);
+    LOG(VERBOSE) << "onVsync() display " << displayId << " timestamp "
+                 << timestamp.time_since_epoch() << " count " << count;
+
+    auto testDisplayId = mapPhysicalDisplayIdToTestDisplayId(displayId);
+    if (!testDisplayId) {
+        return;
+    }
+
+    mCallbacks.onVSyncTiming(events::VSyncTiming{
+            .receiver = this,
+            .displayId = *testDisplayId,
+            .sfEventAt = timestamp,
+            .count = count,
+            .data = vsyncData,
+    });
+}
+
+void DisplayEventReceiver::onHotplug(DisplayId displayId, Timestamp timestamp, bool connected,
+                                     int32_t connectionError) {
+    ftl::ignore(displayId, timestamp, connected, connectionError);
+    LOG(VERBOSE) << "onHotplug() display " << displayId << " timestamp "
+                 << timestamp.time_since_epoch() << " connected " << connected
+                 << " connectionError " << connectionError;
+
+    if (auto controller = mController.lock()) {
+        controller->onDisplayConnectionChanged(displayId, connected);
+    }
+
+    auto testDisplayId = mapPhysicalDisplayIdToTestDisplayId(displayId);
+    if (!testDisplayId) {
+        return;
+    }
+
+    if (connectionError == 0) {
+        mCallbacks.onHotplug(events::Hotplug{
+                .receiver = this,
+                .displayId = *testDisplayId,
+                .sfEventAt = timestamp,
+                .connected = connected,
+        });
+    }
+}
+
+void DisplayEventReceiver::onModeChange(DisplayId displayId, Timestamp timestamp, int32_t modeId,
+                                        std::chrono::nanoseconds vsyncPeriod) {
+    ftl::ignore(displayId, timestamp, modeId, vsyncPeriod);
+    LOG(VERBOSE) << "onModeChange() display " << displayId << " timestamp "
+                 << timestamp.time_since_epoch() << " modeId " << modeId << " vsyncPeriod "
+                 << vsyncPeriod;
+}
+
+void DisplayEventReceiver::onFrameRateOverride(DisplayId displayId, Timestamp timestamp, uid_t uid,
+                                               float framerateHz) {
+    ftl::ignore(displayId, timestamp, uid, framerateHz);
+    LOG(VERBOSE) << "onFrameRateOverride() display " << displayId << " timestamp "
+                 << timestamp.time_since_epoch() << " uid " << uid << " framerateHz "
+                 << framerateHz;
+}
+
+void DisplayEventReceiver::onHdcpLevelsChange(DisplayId displayId, Timestamp timestamp,
+                                              int32_t connectedLevel, int32_t maxLevel) {
+    ftl::ignore(displayId, timestamp, connectedLevel, maxLevel);
+    LOG(VERBOSE) << "onHdcpLevelsChange() display " << displayId << " timestamp "
+                 << timestamp.time_since_epoch() << " connectedLevel " << connectedLevel
+                 << " maxLevel " << maxLevel;
+}
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger
diff --git a/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/DisplayEventReceiver.h b/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/DisplayEventReceiver.h
new file mode 100644
index 0000000000..f1dbf31417
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/DisplayEventReceiver.h
@@ -0,0 +1,129 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <chrono>
+#include <cstdint>
+#include <memory>
+#include <optional>
+#include <span>
+#include <string>
+
+#include <sys/types.h>
+
+#include <android-base/expected.h>
+#include <android/gui/ISurfaceComposer.h>
+#include <binder/IBinder.h>
+#include <ftl/finalizer.h>
+#include <ftl/flags.h>
+#include <ftl/function.h>
+#include <gui/DisplayEventReceiver.h>
+#include <gui/VsyncEventData.h>
+#include <ui/DisplayId.h>
+#include <utils/StrongPointer.h>
+
+#include "test_framework/core/DisplayConfiguration.h"
+#include "test_framework/surfaceflinger/PollFdThread.h"
+#include "test_framework/surfaceflinger/events/Hotplug.h"
+#include "test_framework/surfaceflinger/events/VSyncTiming.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger {
+
+class SFController;
+class PollFdThread;
+
+class DisplayEventReceiver final {
+    struct Passkey;  // Uses the passkey idiom to restrict construction.
+
+  public:
+    // The callbacks provided from a surface instance.
+    struct Callbacks final {
+        using Timestamp = std::chrono::steady_clock::time_point;
+
+        // The vsync timing display event from SurfaceFlinger (slightly simplified).
+        events::VSyncTiming::AsyncConnector onVSyncTiming;
+
+        // The hotplug display event from SurfaceFlinger (slightly simplified).
+        events::Hotplug::AsyncConnector onHotplug;
+    };
+
+    using PhysicalIdToTestDisplayId = ftl::Function<
+            auto(PhysicalDisplayId)->std::optional<test_framework::core::DisplayConfiguration::Id>>;
+
+    [[nodiscard]] static auto make(
+            std::weak_ptr<SFController> controller, const sp<gui::ISurfaceComposer>& client,
+            PollFdThread& pollFdThread, gui::ISurfaceComposer::VsyncSource source,
+            const sp<IBinder>& layerHandle,
+            const ftl::Flags<gui::ISurfaceComposer::EventRegistration>& events)
+            -> base::expected<std::shared_ptr<DisplayEventReceiver>, std::string>;
+
+    explicit DisplayEventReceiver(Passkey pass);
+
+    // Allows the callbacks to be set by the caller, by modifying the values in the returned
+    // structure.
+    [[nodiscard]] auto editCallbacks() -> Callbacks&;
+
+    // Sets the vsync rate for events.
+    void setVsyncRate(int32_t count) const;
+
+    // Requests a vsync callback.
+    void requestNextVsync() const;
+
+    // Obtains the latest vsync data immediately.
+    [[nodiscard]] auto getLatestVsyncEventData() const -> std::optional<ParcelableVsyncEventData>;
+
+  private:
+    using Event = android::DisplayEventReceiver::Event;
+    using EventType = android::DisplayEventType;
+    using DisplayId = PhysicalDisplayId;
+    using Timestamp = std::chrono::steady_clock::time_point;
+    using VsyncEventData = android::VsyncEventData;
+
+    [[nodiscard]] auto init(std::weak_ptr<SFController> controller,
+                            const sp<gui::ISurfaceComposer>& client, PollFdThread& pollFdThread,
+                            gui::ISurfaceComposer::VsyncSource source,
+                            const sp<IBinder>& layerHandle,
+                            const ftl::Flags<gui::ISurfaceComposer::EventRegistration>& events)
+            -> base::expected<void, std::string>;
+
+    void processReceivedEvents();
+    void processReceivedEvents(std::span<Event> events);
+    auto mapPhysicalDisplayIdToTestDisplayId(PhysicalDisplayId displayId)
+            -> std::optional<core::DisplayConfiguration::Id>;
+    void onVsync(DisplayId displayId, Timestamp timestamp, uint32_t count,
+                 VsyncEventData vsyncData);
+    void onHotplug(DisplayId displayId, Timestamp timestamp, bool connected,
+                   int32_t connectionError);
+    static void onModeChange(DisplayId displayId, Timestamp timestamp, int32_t modeId,
+                             std::chrono::nanoseconds vsyncPeriod);
+    static void onFrameRateOverride(DisplayId displayId, Timestamp timestamp, uid_t uid,
+                                    float framerateHz);
+    static void onHdcpLevelsChange(DisplayId displayId, Timestamp timestamp, int32_t connectedLevel,
+                                   int32_t maxLevel);
+
+    std::weak_ptr<SFController> mController;
+    Callbacks mCallbacks;
+
+    sp<gui::IDisplayEventConnection> mDisplayEventConnection;
+    std::unique_ptr<gui::BitTube> mDataChannel;
+    PollFdThread* mPollFdThread = nullptr;
+
+    // Finalizers should be last so their destructors are invoked first.
+    ftl::FinalizerFtl mCleanup;
+};
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger
diff --git a/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/PollFdThread.cpp b/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/PollFdThread.cpp
new file mode 100644
index 0000000000..646df87d6b
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/PollFdThread.cpp
@@ -0,0 +1,172 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include <unistd.h>
+#include <array>
+#include <atomic>
+#include <cerrno>
+#include <cstdint>
+#include <cstring>
+#include <memory>
+#include <mutex>
+#include <string>
+#include <system_error>
+#include <thread>
+#include <unordered_map>
+#include <utility>
+
+#include <bits/epoll_event.h>
+#include <linux/eventfd.h>
+#include <linux/eventpoll.h>
+#include <sys/epoll.h>
+#include <sys/eventfd.h>
+
+#include <android-base/expected.h>
+#include <android-base/logging.h>
+#include <android-base/thread_annotations.h>  // NOLINT(misc-include-cleaner)
+#include <android-base/unique_fd.h>
+#include <fmt/format.h>
+#include <ftl/finalizer.h>
+#include <ftl/ignore.h>
+
+#include "test_framework/core/AsyncFunction.h"
+#include "test_framework/surfaceflinger/PollFdThread.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger {
+
+static_assert(EPOLLIN == static_cast<int>(PollFdThread::PollFlags::IN));
+static_assert(EPOLLOUT == static_cast<int>(PollFdThread::PollFlags::OUT));
+static_assert(EPOLLERR == static_cast<int>(PollFdThread::PollFlags::ERR));
+
+struct PollFdThread::Passkey final {};
+
+auto PollFdThread::make() -> base::expected<std::shared_ptr<PollFdThread>, std::string> {
+    using namespace std::string_literals;
+
+    auto instance = std::make_unique<PollFdThread>(Passkey{});
+    if (instance == nullptr) {
+        return base::unexpected("Failed to construct a PollFdThread"s);
+    }
+    if (auto result = instance->init(); !result) {
+        return base::unexpected("Failed to init a PollFdThread: " + result.error());
+    }
+    return std::move(instance);
+}
+
+PollFdThread::PollFdThread(Passkey passkey) {
+    ftl::ignore(passkey);
+}
+
+auto PollFdThread::init() -> base::expected<void, std::string> {
+    mEventFd = base::unique_fd(eventfd(0, EFD_CLOEXEC | EFD_NONBLOCK));
+    CHECK(mEventFd.get() >= 0);
+    mPollFd = base::unique_fd(epoll_create1(EPOLL_CLOEXEC));
+    CHECK(mPollFd.get() >= 0);
+    addFileDescriptor(mEventFd.get(), {PollFlags::IN, PollFlags::ERR}, [this]() {
+        int64_t ignoredCount = 0;
+        read(mEventFd.get(), &ignoredCount, sizeof(ignoredCount));
+    });
+
+    mThread = std::thread(&PollFdThread::threadMain, this);
+
+    mCleanup = ftl::Finalizer([this]() {
+        stopThread();
+
+        const std::lock_guard lock(mMutex);
+        mCallbacks.erase(mEventFd.get());
+        CHECK(mCallbacks.empty()) << "Not all finalizers were called.";
+    });
+
+    return {};
+}
+
+// PollFlagMask (ftl::Flags) is not trivially copyable, but should be.
+// NOLINTNEXTLINE(performance-unnecessary-value-param)
+void PollFdThread::addFileDescriptor(int descriptor, PollFlagMask flags, EventCallback callback) {
+    LOG(VERBOSE) << __func__ << " descriptor " << descriptor << " mask " << flags.string();
+
+    ftl::FinalizerStd cleanup;
+    {
+        const std::lock_guard lock(mMutex);
+        cleanup = mCallbacks[descriptor].set(callback);
+    }
+    cleanup();
+
+    epoll_event event{.events = flags.get(), .data = {.fd = descriptor}};
+    const int result = epoll_ctl(mPollFd.get(), EPOLL_CTL_ADD, descriptor, &event);
+
+    if (result != 0) {
+        auto err = std::generic_category().default_error_condition(errno);
+        LOG(FATAL) << fmt::format("Result {} errno: {} ({})", result, err.message(), err.value());
+    }
+}
+
+void PollFdThread::removeFileDescriptor(int descriptor) {
+    LOG(VERBOSE) << __func__ << " descriptor " << descriptor;
+
+    {
+        const std::lock_guard lock(mMutex);
+        mCallbacks.erase(descriptor);
+    }
+
+    CHECK(epoll_ctl(mPollFd.get(), EPOLL_CTL_DEL, descriptor, nullptr) == 0);
+}
+
+void PollFdThread::threadMain() {
+    LOG(VERBOSE) << __func__ << " begins";
+    while (!mStop) {
+        constexpr int kMaxEvents = 10;
+        std::array<epoll_event, kMaxEvents> events = {};
+        LOG(VERBOSE) << __func__ << " epoll_wait()";
+        const int eventCount = epoll_wait(mPollFd.get(), events.data(), kMaxEvents, -1);
+        if (eventCount < 0 && errno == EINTR) {
+            LOG(VERBOSE) << "epoll_wait() interrupted";
+            continue;
+        }
+        LOG(VERBOSE) << __func__ << " " << eventCount << " events";
+
+        if (eventCount < 0) {
+            auto err = std::generic_category().default_error_condition(errno);
+            LOG(FATAL) << fmt::format("Result {} errno: {} ({})", eventCount, err.message(),
+                                      err.value());
+        }
+
+        const std::lock_guard lock(mMutex);
+        for (int i = 0; i < eventCount; ++i) {
+            // NOLINTNEXTLINE(cppcoreguidelines-pro-bounds-constant-array-index)
+            if (const auto found = mCallbacks.find(events[i].data.fd); found != mCallbacks.end()) {
+                found->second();
+            }
+        }
+    }
+    LOG(VERBOSE) << __func__ << " ends";
+}
+
+void PollFdThread::wakeNow() {
+    const int64_t one = 1;
+    write(mEventFd.get(), &one, sizeof(one));
+}
+
+void PollFdThread::stopThread() {
+    if (mThread.joinable()) {
+        mStop = true;
+        wakeNow();
+        LOG(VERBOSE) << "Waiting for thread to stop...";
+        mThread.join();
+        LOG(VERBOSE) << "Stopped.";
+    }
+}
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger
diff --git a/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/PollFdThread.h b/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/PollFdThread.h
new file mode 100644
index 0000000000..ada2939059
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/PollFdThread.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <atomic>
+#include <cstdint>
+#include <memory>
+#include <mutex>
+#include <string>
+#include <thread>
+#include <unordered_map>
+
+#include <android-base/expected.h>
+#include <android-base/thread_annotations.h>
+#include <android-base/unique_fd.h>
+#include <ftl/finalizer.h>
+#include <ftl/flags.h>
+#include <ftl/function.h>
+
+#include "test_framework/core/AsyncFunction.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger {
+
+class PollFdThread final {
+    struct Passkey;  // Uses the passkey idiom to restrict construction.
+
+  public:
+    enum class PollFlags : uint8_t {
+        IN = 0x01,   // EPOLLIN
+        OUT = 0x04,  // EPOLLOUT
+        ERR = 0x08,  // EPOLLERR
+    };
+    using PollFlagMask = ftl::Flags<PollFlags>;
+
+    using EventCallback = ftl::Function<void()>;
+
+    [[nodiscard]] static auto make() -> base::expected<std::shared_ptr<PollFdThread>, std::string>;
+
+    explicit PollFdThread(Passkey passkey);
+
+    // Adds the given file descriptor to the polling set, and invokes the event callback for events.
+    void addFileDescriptor(int descriptor, PollFlagMask flags, EventCallback callback);
+
+    // Removes the given file descriptor from the polling set.
+    void removeFileDescriptor(int descriptor);
+
+  private:
+    using AsyncEventCallback = core::AsyncFunctionStd<void()>;
+    using CallbackMap = std::unordered_map<int, AsyncEventCallback>;
+
+    [[nodiscard]] auto init() -> base::expected<void, std::string>;
+
+    void threadMain();
+    void wakeNow();
+    void stopThread();
+
+    base::unique_fd mEventFd;
+    base::unique_fd mPollFd;
+    std::thread mThread;
+    std::atomic_bool mStop{false};
+    std::mutex mMutex;
+    CallbackMap mCallbacks GUARDED_BY(mMutex);
+
+    // Finalizers should be last so their destructors are invoked first.
+    ftl::FinalizerFtl mCleanup;
+};
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger
diff --git a/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/SFController.cpp b/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/SFController.cpp
index 1cf49c5750..6e1f7e1cdb 100644
--- a/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/SFController.cpp
+++ b/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/SFController.cpp
@@ -15,15 +15,20 @@
  */
 
 #include <chrono>
+#include <cstdint>
 #include <cstdlib>
 #include <memory>
+#include <mutex>
+#include <optional>
 #include <string>
 #include <string_view>
 #include <thread>
 #include <utility>
+#include <vector>
 
 #include <android-base/expected.h>
 #include <android-base/logging.h>
+#include <android-base/parseint.h>
 #include <android-base/properties.h>
 #include <android/gui/ISurfaceComposer.h>
 #include <binder/IBinder.h>
@@ -31,14 +36,20 @@
 #include <binder/IServiceManager.h>
 #include <binder/Status.h>
 #include <ftl/finalizer.h>
+#include <ftl/flags.h>
 #include <ftl/ignore.h>
 #include <gui/Surface.h>
 #include <gui/SurfaceComposerClient.h>
+#include <ui/DisplayId.h>
 #include <utils/String16.h>
 #include <utils/String8.h>
 #include <utils/StrongPointer.h>
 
+#include "test_framework/core/DisplayConfiguration.h"
+#include "test_framework/surfaceflinger/DisplayEventReceiver.h"
+#include "test_framework/surfaceflinger/PollFdThread.h"
 #include "test_framework/surfaceflinger/SFController.h"
+#include "test_framework/surfaceflinger/Surface.h"
 
 namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger {
 
@@ -95,10 +106,18 @@ SFController::SFController(Passkey passkey) {
 }
 
 auto SFController::init() -> base::expected<void, std::string> {
+    using namespace std::string_literals;
+
     LOG(INFO) << "Stopping everything to prepare for tests";
-    // NOLINTBEGIN(cert-env33-c)
+    // NOLINTBEGIN(cert-env33-c, concurrency-mt-unsafe)
     system("stop");
-    // NOLINTEND(cert-env33-c)
+    // NOLINTEND(cert-env33-c, concurrency-mt-unsafe)
+
+    auto pollFdThreadResult = PollFdThread::make();
+    if (!pollFdThreadResult) {
+        return base::unexpected(std::move(pollFdThreadResult).error());
+    }
+    mPollFdThread = *std::move(pollFdThreadResult);
 
     mCleanup = ftl::Finalizer([this]() { stop(); });
 
@@ -129,9 +148,21 @@ auto SFController::startAndConnect() -> base::expected<void, std::string> {
                 "Failed to construct a surfaceComposerClient around the aidl interface."s);
     }
 
+    // We need an internal display event receiver so we can listen for hotplug events.
+    auto displayEventReceiverResult = DisplayEventReceiver::make(
+            shared_from_this(), surfaceComposerAidl, *mPollFdThread,
+            gui::ISurfaceComposer::VsyncSource::eVsyncSourceApp, nullptr, {});
+    if (!displayEventReceiverResult) {
+        return base::unexpected(std::move(displayEventReceiverResult).error());
+    }
+    auto displayEventReceiver = *std::move(displayEventReceiverResult);
+
     mSurfaceComposerAidl = std::move(surfaceComposerAidl);
     mSurfaceComposerClientAidl = std::move(surfaceComposerClientAidl);
     mSurfaceComposerClient = std::move(surfaceComposerClient);
+    mDisplayEventReceiver = std::move(displayEventReceiver);
+
+    initializeDisplayIdMapping();
 
     LOG(INFO) << "Connected to surfaceflinger";
     return {};
@@ -139,16 +170,16 @@ auto SFController::startAndConnect() -> base::expected<void, std::string> {
 
 void SFController::start() {
     LOG(INFO) << "Starting surfaceflinger";
-    // NOLINTBEGIN(cert-env33-c)
+    // NOLINTBEGIN(cert-env33-c, concurrency-mt-unsafe)
     system("start surfaceflinger");
-    // NOLINTEND(cert-env33-c)
+    // NOLINTEND(cert-env33-c, concurrency-mt-unsafe)
 }
 
 void SFController::stop() {
     LOG(INFO) << "Stopping surfaceflinger";
-    // NOLINTBEGIN(cert-env33-c)
+    // NOLINTBEGIN(cert-env33-c, concurrency-mt-unsafe)
     system("stop surfaceflinger");
-    // NOLINTEND(cert-env33-c)
+    // NOLINTEND(cert-env33-c, concurrency-mt-unsafe)
 
     if (mSurfaceComposerAidl != nullptr) {
         LOG(INFO) << "Waiting for SF AIDL interface to die";
@@ -173,9 +204,79 @@ void SFController::stop() {
         std::this_thread::sleep_for(kShutdownWait);
     }
 
+    mDisplayEventReceiver = nullptr;
     mSurfaceComposerClient = nullptr;
     mSurfaceComposerClientAidl = nullptr;
     mSurfaceComposerAidl = nullptr;
 }
 
+auto SFController::makeDisplayEventReceiver()
+        -> base::expected<std::shared_ptr<DisplayEventReceiver>, std::string> {
+    CHECK(mSurfaceComposerAidl != nullptr);
+    return DisplayEventReceiver::make(shared_from_this(), mSurfaceComposerAidl, *mPollFdThread,
+                                      gui::ISurfaceComposer::VsyncSource::eVsyncSourceApp, nullptr,
+                                      {gui::ISurfaceComposer::EventRegistration::frameRateOverride,
+                                       gui::ISurfaceComposer::EventRegistration::modeChanged});
+}
+
+auto SFController::makeSurface(const Surface::CreationArgs& args)
+        -> base::expected<std::shared_ptr<Surface>, std::string> {
+    CHECK(mSurfaceComposerClient != nullptr);
+    return Surface::make(mSurfaceComposerClient, args);
+}
+
+auto SFController::mapPhysicalDisplayIdToTestDisplayId(PhysicalDisplayId displayId)
+        -> std::optional<core::DisplayConfiguration::Id> {
+    const std::lock_guard lock(mMutex);
+    auto iter = mPhysicalDisplayIdToTestDisplayId.find(displayId);
+    return (iter != mPhysicalDisplayIdToTestDisplayId.end()) ? std::make_optional(iter->second)
+                                                             : std::nullopt;
+}
+
+void SFController::addDisplayIdToMapping(PhysicalDisplayId displayId) {
+    gui::StaticDisplayInfo staticInfo;
+    CHECK(mSurfaceComposerAidl->getStaticDisplayInfo(displayId.value, &staticInfo).isOk());
+
+    auto name = staticInfo.deviceProductInfo.and_then(
+            [](const auto& info) -> std::optional<std::string> { return info.name; });
+
+    constexpr std::string kMagicPrefix = "fake";
+    if (!name || !name->starts_with(kMagicPrefix)) {
+        LOG(ERROR) << "Unexpected: physical display id " << displayId
+                   << " is not a test fake display: " << name.value_or("<missing>");
+        return;
+    }
+
+    auto remainder = name->substr(kMagicPrefix.size());
+
+    uint32_t testId = 0;
+    if (!android::base::ParseUint(remainder.c_str(), &testId)) {
+        LOG(ERROR) << "Failed to parse as int: " << remainder;
+        return;
+    }
+
+    const std::lock_guard lock(mMutex);
+    mPhysicalDisplayIdToTestDisplayId[displayId] = testId;
+}
+
+void SFController::onDisplayConnectionChanged(PhysicalDisplayId displayId, bool connected) {
+    if (connected) {
+        addDisplayIdToMapping(displayId);
+    } else {
+        const std::lock_guard lock(mMutex);
+        mPhysicalDisplayIdToTestDisplayId.erase(displayId);
+    }
+}
+
+void SFController::initializeDisplayIdMapping() {
+    CHECK(mSurfaceComposerAidl);
+
+    std::vector<int64_t> rawDisplayIds;
+    CHECK(mSurfaceComposerAidl->getPhysicalDisplayIds(&rawDisplayIds).isOk());
+
+    for (auto displayIdValue : rawDisplayIds) {
+        addDisplayIdToMapping(PhysicalDisplayId::fromValue(displayIdValue));
+    }
+}
+
 }  // namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger
diff --git a/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/SFController.h b/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/SFController.h
index 58bac9197f..89fee14781 100644
--- a/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/SFController.h
+++ b/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/SFController.h
@@ -17,13 +17,23 @@
 #pragma once
 
 #include <memory>
+#include <mutex>
+#include <optional>
 #include <string>
 #include <string_view>
+#include <unordered_map>
 
 #include <android-base/expected.h>
+#include <android-base/thread_annotations.h>
 #include <ftl/finalizer.h>
+#include <ui/DisplayId.h>
+#include <utils/Mutex.h>
 #include <utils/StrongPointer.h>
 
+#include "test_framework/core/DisplayConfiguration.h"
+#include "test_framework/surfaceflinger/PollFdThread.h"
+#include "test_framework/surfaceflinger/Surface.h"
+
 namespace android::gui {
 
 class ISurfaceComposer;
@@ -39,7 +49,10 @@ class SurfaceComposerClient;
 
 namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger {
 
-class SFController final {
+class DisplayEventReceiver;
+class PollFdThread;
+
+class SFController final : public std::enable_shared_from_this<SFController> {
     struct Passkey;  // Uses the passkey idiom to restrict construction.
 
   public:
@@ -54,14 +67,32 @@ class SFController final {
     // Starts SurfaceFlinger and establishes the AIDL interface connections.
     [[nodiscard]] auto startAndConnect() -> base::expected<void, std::string>;
 
+    auto makeDisplayEventReceiver()
+            -> base::expected<std::shared_ptr<DisplayEventReceiver>, std::string>;
+
+    auto makeSurface(const Surface::CreationArgs& args)
+            -> base::expected<std::shared_ptr<Surface>, std::string>;
+
+    void onDisplayConnectionChanged(PhysicalDisplayId displayId, bool connected);
+    auto mapPhysicalDisplayIdToTestDisplayId(PhysicalDisplayId displayId)
+            -> std::optional<core::DisplayConfiguration::Id>;
+
   private:
     [[nodiscard]] auto init() -> base::expected<void, std::string>;
     static void start();
     void stop();
+    void initializeDisplayIdMapping();
+    void addDisplayIdToMapping(PhysicalDisplayId displayId);
 
+    std::shared_ptr<PollFdThread> mPollFdThread;
     sp<gui::ISurfaceComposer> mSurfaceComposerAidl;
     sp<gui::ISurfaceComposerClient> mSurfaceComposerClientAidl;
     sp<SurfaceComposerClient> mSurfaceComposerClient;
+    std::shared_ptr<DisplayEventReceiver> mDisplayEventReceiver;
+
+    mutable std::mutex mMutex;
+    std::unordered_map<PhysicalDisplayId, core::DisplayConfiguration::Id>
+            mPhysicalDisplayIdToTestDisplayId GUARDED_BY(mMutex);
 
     // Finalizers should be last so their destructors are invoked first.
     ftl::FinalizerFtl mCleanup;
diff --git a/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/SimpleBufferPool.cpp b/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/SimpleBufferPool.cpp
new file mode 100644
index 0000000000..417a52a947
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/SimpleBufferPool.cpp
@@ -0,0 +1,101 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <bit>
+#include <cstddef>
+#include <cstdint>
+#include <memory>
+#include <string>
+#include <utility>
+
+#include <android-base/expected.h>
+#include <android-base/logging.h>
+#include <ftl/ignore.h>
+#include <ui/GraphicBuffer.h>
+#include <ui/GraphicBufferAllocator.h>
+#include <ui/PixelFormat.h>
+#include <ui/Size.h>
+#include <utils/StrongPointer.h>
+
+#include "test_framework/core/GuardedSharedState.h"
+#include "test_framework/surfaceflinger/SimpleBufferPool.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger {
+
+struct SimpleBufferPool::Passkey final {};
+
+auto SimpleBufferPool::make(size_t count, ui::Size size, PixelFormat format)
+        -> base::expected<std::shared_ptr<SimpleBufferPool>, std::string> {
+    using namespace std::string_literals;
+
+    auto instance = std::make_unique<SimpleBufferPool>(Passkey{});
+    if (instance == nullptr) {
+        return base::unexpected("Failed to construct a SimpleBufferPool"s);
+    }
+    if (auto result = instance->init(count, size, format); !result) {
+        return base::unexpected("Failed to init a SimpleBufferPool: " + result.error());
+    }
+    return std::move(instance);
+}
+
+SimpleBufferPool::SimpleBufferPool(Passkey passkey) {
+    ftl::ignore(passkey);
+}
+
+auto SimpleBufferPool::init(size_t count, ui::Size size,
+                            PixelFormat format) -> base::expected<void, std::string> {
+    return mState.withExclusiveLock(
+            [count, size, format](auto& state) -> base::expected<void, std::string> {
+                for (size_t i = 0; i < count; i++) {
+                    constexpr auto kLayers = 1;
+                    constexpr auto kUsage = GraphicBuffer::USAGE_HW_COMPOSER;
+                    const GraphicBufferAllocator::AllocationRequest request{
+                            .importBuffer = false,
+                            .width = std::bit_cast<uint32_t>(size.width),
+                            .height = std::bit_cast<uint32_t>(size.height),
+                            .format = format,
+                            .layerCount = kLayers,
+                            .usage = kUsage,
+                            .requestorName = "test",
+                            .extras = {},
+                    };
+                    state.pool.push_back(sp<GraphicBuffer>::make(request));
+                    CHECK(state.pool.back() != nullptr);
+                }
+                return {};
+            });
+}
+
+auto SimpleBufferPool::dequeue() -> sp<GraphicBuffer> {
+    return mState.withExclusiveLock([](auto& state) -> sp<GraphicBuffer> {
+        if (state.pool.empty()) {
+            return nullptr;
+        }
+        auto buffer = state.pool.front();
+        CHECK(buffer != nullptr);
+        state.pool.pop_front();
+        return buffer;
+    });
+};
+
+void SimpleBufferPool::enqueue(sp<GraphicBuffer> buffer) {
+    CHECK(buffer != nullptr);
+    mState.withExclusiveLock([buffer = std::move(buffer)](auto& state) mutable {
+        state.pool.push_back(std::move(buffer));
+    });
+};
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger
diff --git a/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/SimpleBufferPool.h b/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/SimpleBufferPool.h
new file mode 100644
index 0000000000..fae63f4bf3
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/SimpleBufferPool.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <cstddef>
+#include <deque>
+#include <memory>
+#include <string>
+
+#include <android-base/expected.h>
+#include <ui/GraphicBuffer.h>
+#include <ui/PixelFormat.h>
+#include <ui/Size.h>
+#include <utils/Mutex.h>
+#include <utils/StrongPointer.h>
+
+#include "test_framework/core/GuardedSharedState.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger {
+
+class SimpleBufferPool final {
+    struct Passkey;  // Uses the passkey idiom to restrict construction.
+
+  public:
+    [[nodiscard]] static auto make(size_t count, ui::Size size, PixelFormat format)
+            -> base::expected<std::shared_ptr<SimpleBufferPool>, std::string>;
+
+    explicit SimpleBufferPool(Passkey passkey);
+
+    auto dequeue() -> sp<GraphicBuffer>;
+    void enqueue(sp<GraphicBuffer> buffer);
+
+  private:
+    [[nodiscard]] auto init(size_t count, ui::Size size,
+                            PixelFormat format) -> base::expected<void, std::string>;
+
+    struct State {
+        std::deque<sp<GraphicBuffer>> pool;
+    };
+    core::GuardedSharedState<State> mState;
+};
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger
diff --git a/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/Surface.cpp b/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/Surface.cpp
new file mode 100644
index 0000000000..33a75d8614
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/Surface.cpp
@@ -0,0 +1,277 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <chrono>
+#include <cstdint>
+#include <future>
+#include <memory>
+#include <optional>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include <android-base/expected.h>
+#include <android-base/logging.h>
+#include <android/gui/ISurfaceComposerClient.h>
+#include <ftl/finalizer.h>
+#include <ftl/ignore.h>
+#include <gui/ITransactionCompletedListener.h>
+#include <gui/SurfaceComposerClient.h>
+#include <gui/SurfaceControl.h>
+#include <ui/Fence.h>
+#include <ui/GraphicBuffer.h>
+#include <ui/GraphicBufferAllocator.h>
+#include <ui/PixelFormat.h>
+#include <ui/Rect.h>
+#include <ui/Size.h>
+#include <utils/String8.h>
+#include <utils/StrongPointer.h>
+#include <utils/Timers.h>
+
+#include "test_framework/core/BufferId.h"
+#include "test_framework/surfaceflinger/SimpleBufferPool.h"
+#include "test_framework/surfaceflinger/Surface.h"
+#include "test_framework/surfaceflinger/events/BufferReleased.h"
+#include "test_framework/surfaceflinger/events/TransactionCompleted.h"
+#include "test_framework/surfaceflinger/events/TransactionInitiated.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger {
+
+struct Surface::Passkey final {};
+
+auto Surface::make(const sp<SurfaceComposerClient>& flinger, const Surface::CreationArgs& args)
+        -> base::expected<std::shared_ptr<Surface>, std::string> {
+    using namespace std::string_literals;
+
+    auto instance = std::make_shared<Surface>(Passkey{});
+    if (instance == nullptr) {
+        return base::unexpected("Failed to construct a Surface"s);
+    }
+    if (auto result = instance->init(flinger, args); !result) {
+        return base::unexpected("Failed to init a Surface: " + result.error());
+    }
+    return std::move(instance);
+}
+
+Surface::Surface(Passkey passkey) {
+    ftl::ignore(passkey);
+}
+
+auto Surface::init(const sp<SurfaceComposerClient>& flinger,
+                   const Surface::CreationArgs& args) -> base::expected<void, std::string> {
+    using namespace std::string_literals;
+
+    constexpr auto kFlags = gui::ISurfaceComposerClient::eOpaque;
+    sp<SurfaceControl> surfaceControl =
+            flinger->createSurface(String8(args.name.c_str()), args.size.width, args.size.height,
+                                   args.pixelFormat, kFlags, args.parent);
+
+    if (surfaceControl == nullptr) {
+        return base::unexpected("Failed to create a SF Surface");
+    }
+
+    auto bufferPool = SimpleBufferPool::make(args.bufferPoolSize, args.size, args.pixelFormat);
+    if (!bufferPool) {
+        return base::unexpected(bufferPool.error());
+    }
+
+    {
+        SurfaceComposerClient::Transaction transaction;
+        transaction.show(surfaceControl);
+        transaction.setPosition(surfaceControl, 0, 0);
+        transaction.setLayerStack(surfaceControl, {args.layerStackId});
+        constexpr bool synchronous = true;
+        transaction.apply(synchronous);
+    }
+
+    mSurfaceControl = std::move(surfaceControl);
+    mSurfaceSize = args.size;
+    mBufferPool = *std::move(bufferPool);
+
+    mCleanup = ftl::Finalizer([this]() { ensureCallbacksCompletedBeforeShutdown(); });
+
+    return {};
+}
+
+auto Surface::editCallbacks() -> Callbacks& {
+    return mCallbacks;
+}
+
+auto Surface::commitNextBuffer() -> uint64_t {
+    const auto frameNumber = mNextFrameNumber++;
+    auto buffer = mBufferPool->dequeue();
+    auto bufferId = core::toBufferId(buffer);
+
+    LOG(VERBOSE) << __func__ << " framenumber " << frameNumber << " buffer "
+                 << (buffer ? buffer->getId() : 0) << " " << toString(bufferId) << " wxh "
+                 << mSurfaceSize.width << "x" << mSurfaceSize.height;
+
+    commitBufferInternal(
+            frameNumber, buffer,
+            [weak = weak_from_this(), buffer, bufferId, frameNumber](
+                    const ReleaseCallbackId& callbackId, const sp<Fence>& releaseFence,
+                    std::optional<uint32_t> currentMaxAcquiredBufferCount) {
+                ftl::ignore(callbackId, releaseFence, currentMaxAcquiredBufferCount);
+                if (auto self = weak.lock()) {
+                    self->onBufferRelease(frameNumber, buffer, bufferId);
+                } else {
+                    LOG(DEBUG) << "Target surface for buffer release callback is dead";
+                }
+            },
+            [weak = weak_from_this(), frameNumber, bufferId](
+                    void* context, nsecs_t latchTime, const sp<Fence>& presentFence,
+                    const std::vector<SurfaceControlStats>& stats) {
+                ftl::ignore(context, presentFence, stats);
+                if (auto self = weak.lock()) {
+                    const auto timestamp = Timestamp(std::chrono::nanoseconds(latchTime));
+                    self->onTransactionCompleted(frameNumber, bufferId, timestamp);
+                } else {
+                    LOG(DEBUG) << "Target surface for transaction completed callback is dead.";
+                }
+            });
+
+    mCallbacks.onTransactionInitiated(events::TransactionInitiated{
+            .surface = this,
+            .frameNumber = frameNumber,
+            .bufferId = bufferId,
+    });
+
+    return frameNumber;
+}
+
+void Surface::commitBufferInternal(
+        uint64_t frameNumber, const sp<GraphicBuffer>& buffer,
+        ReleaseBufferCallback releaseCallback,
+        TransactionCompletedCallbackTakesContext transactionCompletedCallback) {
+    SurfaceComposerClient::Transaction transaction;
+
+    transaction.setSurfaceDamageRegion(mSurfaceControl,
+                                       Region(Rect(0, 0, mSurfaceSize.width, mSurfaceSize.height)));
+
+    const std::optional<sp<Fence>> fence{};
+    constexpr int producerId = 0;
+    transaction.setBuffer(mSurfaceControl, buffer, fence, frameNumber, producerId,
+                          std::move(releaseCallback));
+
+    // Note: transaction.setBuffer() internally and unconditionally sets a no-op transaction
+    // completion callback. We must set ours AFTER that call, not before.
+    transaction.addTransactionCompletedCallback(std::move(transactionCompletedCallback), nullptr);
+
+    transaction.apply();
+}
+
+void Surface::onBufferRelease(uint64_t frameNumber, sp<GraphicBuffer> buffer,
+                              core::BufferId bufferId) {
+    LOG(VERBOSE) << __func__ << " framenumber " << frameNumber << " buffer "
+                 << (buffer ? buffer->getId() : 0);
+    mBufferPool->enqueue(std::move(buffer));
+    mCallbacks.onBufferReleased(events::BufferReleased{
+            .surface = this,
+            .frameNumber = frameNumber,
+            .bufferId = bufferId,
+    });
+}
+
+void Surface::onTransactionCompleted(uint64_t frameNumber, core::BufferId bufferId,
+                                     Timestamp latchTime) {
+    LOG(VERBOSE) << __func__ << " framenumber " << frameNumber << " latchTime "
+                 << latchTime.time_since_epoch();
+    mCallbacks.onTransactionCompleted(events::TransactionCompleted{
+            .surface = this,
+            .frameNumber = frameNumber,
+            .bufferId = bufferId,
+            .latchTime = latchTime,
+    });
+}
+
+void Surface::ensureCallbacksCompletedBeforeShutdown() {
+    // If we just shut down the test without this special cleanup, there is a chance for a runtime
+    // crash on shutdown in the SurfaceComposerClient buffer cache singleton, from callbacks to it
+    // being invoked after being destroyed.
+    //
+    // There is also a TransactionCompletedListener singleton which can be destroyed after the
+    // buffer cache singleton. If there are outstanding transaction completion callbacks, and those
+    // have a reference to a GraphicBuffer, when those are destroyed, the GraphicBuffer destructor
+    // tries to clear itself from the buffer cache.
+    //
+    // To work around this, we intentionally submit for some final transactions on the surface to
+    // ensure all prior callbacks are complete, and for those use lambdas that do not capture
+    // GraphicBuffers.
+
+    auto buffer = sp<GraphicBuffer>::make(GraphicBufferAllocator::AllocationRequest{
+            .importBuffer = false,
+            .width = 1,
+            .height = 1,
+            .format = PIXEL_FORMAT_RGBA_8888,
+            .layerCount = 1,
+            .usage = GraphicBuffer::USAGE_HW_COMPOSER,
+            .requestorName = "test",
+            .extras = {},
+    });
+
+    std::promise<void> firstTransactionPromise;
+    auto firstTransactionComplete = firstTransactionPromise.get_future();
+
+    commitBufferInternal(
+            mNextFrameNumber++, buffer,
+            [](const ReleaseCallbackId& callbackId, const sp<Fence>& releaseFence,
+               std::optional<uint32_t> currentMaxAcquiredBufferCount) {
+                LOG(VERBOSE) << "first cleanup transaction buffer released";
+                ftl::ignore(callbackId, releaseFence, currentMaxAcquiredBufferCount);
+                // Note: We don't signal a promise as this doesn't actually seem to be invoked by
+                // the next transaction!
+            },
+            [&firstTransactionPromise](void* context, nsecs_t latchTime,
+                                       const sp<Fence>& presentFence,
+                                       const std::vector<SurfaceControlStats>& stats) {
+                ftl::ignore(context, latchTime, presentFence, stats);
+                LOG(VERBOSE) << "first cleanup transaction complete";
+                firstTransactionPromise.set_value();
+            });
+
+    // Now commit a custom second transaction to unset the buffer.
+    SurfaceComposerClient::Transaction transaction;
+    transaction.unsetBuffer(mSurfaceControl);
+
+    std::promise<void> hideSurfaceTransactionPromise;
+    auto hideSurfaceTransactionComplete = hideSurfaceTransactionPromise.get_future();
+    transaction.addTransactionCompletedCallback(
+            [&hideSurfaceTransactionPromise](void* context, nsecs_t latchTime,
+                                             const sp<Fence>& presentFence,
+                                             const std::vector<SurfaceControlStats>& stats) {
+                ftl::ignore(context, latchTime, presentFence, stats);
+                LOG(VERBOSE) << "second cleanup transaction complete";
+                hideSurfaceTransactionPromise.set_value();
+            },
+            nullptr);
+
+    constexpr bool synchronous = true;
+    transaction.apply(synchronous);
+
+    // Wait for a more than reasonable amount of time for everything to complete.
+    // If we timeout
+    constexpr auto kWaitTimeout = std::chrono::milliseconds(1000);
+    LOG(VERBOSE) << "waiting for cleanup transactions to complete...";
+    LOG_IF(FATAL, firstTransactionComplete.wait_for(kWaitTimeout) != std::future_status::ready)
+            << "timed out waiting for the first transaction to complete. Fatal since the lambda "
+               "holds a reference to a local!";
+    LOG_IF(FATAL,
+           hideSurfaceTransactionComplete.wait_for(kWaitTimeout) != std::future_status::ready)
+            << "timed out waiting for the second transaction to complete. Fatal since the lambda "
+               "holds a reference to a local!";
+}
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger
diff --git a/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/Surface.h b/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/Surface.h
new file mode 100644
index 0000000000..a42655e9cc
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/Surface.h
@@ -0,0 +1,110 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <atomic>
+#include <chrono>
+#include <cstddef>
+#include <cstdint>
+#include <memory>
+#include <string>
+
+#include <android-base/expected.h>
+#include <binder/IBinder.h>
+#include <ftl/finalizer.h>
+#include <gui/SurfaceComposerClient.h>
+#include <gui/SurfaceControl.h>
+#include <ui/GraphicBuffer.h>
+#include <ui/PixelFormat.h>
+#include <ui/Size.h>
+#include <utils/StrongPointer.h>
+
+#include "test_framework/core/BufferId.h"
+#include "test_framework/surfaceflinger/events/BufferReleased.h"
+#include "test_framework/surfaceflinger/events/TransactionCompleted.h"
+#include "test_framework/surfaceflinger/events/TransactionInitiated.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger {
+
+class SimpleBufferPool;
+
+// Wrapper around a gui::SurfaceControl
+class Surface final : public std::enable_shared_from_this<Surface> {
+    struct Passkey;  // Uses the passkey idiom to restrict construction.
+
+  public:
+    using Timestamp = std::chrono::steady_clock::time_point;
+
+    // The creation arguments for a surface, with reasonable default values.
+    struct CreationArgs final {
+        std::string name;
+        ui::Size size{1, 1};
+        PixelFormat pixelFormat = PIXEL_FORMAT_RGBA_8888;
+        sp<IBinder> parent = nullptr;
+        size_t bufferPoolSize = 3;
+        uint32_t layerStackId = 0;
+    };
+
+    // The callbacks provided from a surface instance.
+    struct Callbacks final {
+        // Sent when a transaction is initiated for the surface.
+        events::TransactionInitiated::AsyncConnector onTransactionInitiated;
+
+        // Sent when a buffer release event was received for the surface.
+        events::BufferReleased::AsyncConnector onBufferReleased;
+
+        // Sent when a transaction complete event is received for the surface.
+        events::TransactionCompleted::AsyncConnector onTransactionCompleted;
+    };
+
+    [[nodiscard]] static auto make(const sp<SurfaceComposerClient>& flinger,
+                                   const Surface::CreationArgs& args)
+            -> base::expected<std::shared_ptr<Surface>, std::string>;
+
+    explicit Surface(Passkey passkey);
+
+    // Allows the caller to set handlers for the callbacks emitted by this class.
+    [[nodiscard]] auto editCallbacks() -> Callbacks&;
+
+    // Commits the next available buffer from the buffer pool. Returns the frame number associated
+    // with the commit.
+    [[nodiscard]] auto commitNextBuffer() -> uint64_t;
+
+  private:
+    [[nodiscard]] auto init(const sp<SurfaceComposerClient>& flinger,
+                            const Surface::CreationArgs& args) -> base::expected<void, std::string>;
+    void commitBufferInternal(
+            uint64_t frameNumber, const sp<GraphicBuffer>& buffer,
+            ReleaseBufferCallback releaseCallback,
+            TransactionCompletedCallbackTakesContext transactionCompletedCallback);
+
+    void onBufferRelease(uint64_t frameNumber, sp<GraphicBuffer> buffer, core::BufferId bufferId);
+    void onTransactionCompleted(uint64_t frameNumber, core::BufferId bufferId, Timestamp latchTime);
+    void ensureCallbacksCompletedBeforeShutdown();
+
+    Callbacks mCallbacks;
+
+    ui::Size mSurfaceSize;
+    std::shared_ptr<SimpleBufferPool> mBufferPool;
+    sp<SurfaceControl> mSurfaceControl;
+    std::atomic_uint64_t mNextFrameNumber{0};
+
+    // Finalizers should be last so their destructors are invoked first.
+    ftl::FinalizerFtl mCleanup;
+};
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger
diff --git a/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/events/BufferReleased.h b/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/events/BufferReleased.h
new file mode 100644
index 0000000000..bc1bd5c7c9
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/events/BufferReleased.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <chrono>
+#include <cstdint>
+#include <string>
+
+#include <fmt/chrono.h>  // NOLINT(misc-include-cleaner)
+#include <fmt/format.h>
+
+#include "test_framework/core/AsyncFunction.h"
+#include "test_framework/core/BufferId.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger {
+
+class Surface;
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger
+
+namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger::events {
+
+struct BufferReleased final {
+    using AsyncConnector = core::AsyncFunctionStd<void(BufferReleased)>;
+
+    using TimePoint = std::chrono::steady_clock::time_point;
+
+    Surface* surface{};
+    uint64_t frameNumber{};
+    core::BufferId bufferId{};
+    TimePoint receivedAt{std::chrono::steady_clock::now()};
+
+    friend auto operator==(const BufferReleased&, const BufferReleased&) -> bool = default;
+};
+
+inline auto toString(const BufferReleased& event) -> std::string {
+    return fmt::format(
+            "sfBufferReleased{{"
+            " surface: {},"
+            " frameNumber: {},"
+            " bufferId: {}"
+            " receivedAt: {}"
+            " }}",
+            static_cast<void*>(event.surface), event.frameNumber, toString(event.bufferId),
+            event.receivedAt.time_since_epoch());
+}
+
+inline auto format_as(const BufferReleased& event) -> std::string {
+    return toString(event);
+}
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger::events
diff --git a/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/events/Hotplug.h b/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/events/Hotplug.h
new file mode 100644
index 0000000000..e4e43f1abd
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/events/Hotplug.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <chrono>
+#include <string>
+
+#include <fmt/chrono.h>  // NOLINT(misc-include-cleaner)
+#include <fmt/format.h>
+
+#include "test_framework/core/AsyncFunction.h"
+#include "test_framework/core/DisplayConfiguration.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger {
+
+class DisplayEventReceiver;
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger
+
+namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger::events {
+
+struct Hotplug final {
+    using AsyncConnector = core::AsyncFunctionStd<void(Hotplug)>;
+
+    using DisplayId = core::DisplayConfiguration::Id;
+    using TimePoint = std::chrono::steady_clock::time_point;
+
+    DisplayEventReceiver* receiver{};
+    DisplayId displayId{};
+    TimePoint sfEventAt;
+    bool connected{};
+    TimePoint receivedAt{std::chrono::steady_clock::now()};
+
+    friend auto operator==(const Hotplug&, const Hotplug&) -> bool = default;
+};
+
+inline auto toString(const Hotplug& event) -> std::string {
+    return fmt::format(
+            "sfHotplug{{"
+            " receiver: {},"
+            " displayId: {},"
+            " sfEventAt: {}"
+            " connected: {}"
+            " receivedAt: {}"
+            " }}",
+            static_cast<void*>(event.receiver), event.displayId, event.sfEventAt.time_since_epoch(),
+            event.connected, event.receivedAt.time_since_epoch());
+}
+
+inline auto format_as(const Hotplug& event) -> std::string {
+    return toString(event);
+}
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger::events
diff --git a/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/events/TransactionCompleted.h b/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/events/TransactionCompleted.h
new file mode 100644
index 0000000000..f75a24e58d
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/events/TransactionCompleted.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <chrono>
+#include <cstdint>
+#include <string>
+
+#include <fmt/chrono.h>  // NOLINT(misc-include-cleaner)
+#include <fmt/format.h>
+
+#include "test_framework/core/AsyncFunction.h"
+#include "test_framework/core/BufferId.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger {
+
+class Surface;
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger
+
+namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger::events {
+
+struct TransactionCompleted final {
+    using AsyncConnector = core::AsyncFunctionStd<void(TransactionCompleted)>;
+
+    using Timestamp = std::chrono::steady_clock::time_point;
+
+    Surface* surface{};
+    uint64_t frameNumber{};
+    core::BufferId bufferId{};
+    Timestamp latchTime{};
+    Timestamp receivedAt{std::chrono::steady_clock::now()};
+
+    friend auto operator==(const TransactionCompleted&,
+                           const TransactionCompleted&) -> bool = default;
+};
+
+inline auto toString(const TransactionCompleted& event) -> std::string {
+    return fmt::format(
+            "sfTransactionCompleted{{"
+            " surface: {},"
+            " frameNumber: {},"
+            " bufferId: {}"
+            " latchTime: {}"
+            " receivedAt: {}"
+            " }}",
+            static_cast<void*>(event.surface), event.frameNumber, toString(event.bufferId),
+            event.latchTime.time_since_epoch(), event.receivedAt.time_since_epoch());
+}
+
+inline auto format_as(const TransactionCompleted& event) -> std::string {
+    return toString(event);
+}
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger::events
diff --git a/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/events/TransactionInitiated.h b/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/events/TransactionInitiated.h
new file mode 100644
index 0000000000..5a0b650eb4
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/events/TransactionInitiated.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <chrono>
+#include <cstdint>
+#include <string>
+
+#include <fmt/chrono.h>  // NOLINT(misc-include-cleaner)
+#include <fmt/format.h>
+
+#include "test_framework/core/AsyncFunction.h"
+#include "test_framework/core/BufferId.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger {
+
+class Surface;
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger
+
+namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger::events {
+
+struct TransactionInitiated final {
+    using AsyncConnector = core::AsyncFunctionStd<void(TransactionInitiated)>;
+
+    using Timestamp = std::chrono::steady_clock::time_point;
+
+    Surface* surface{};
+    uint64_t frameNumber{};
+    core::BufferId bufferId{};
+    Timestamp receivedAt{std::chrono::steady_clock::now()};
+
+    friend auto operator==(const TransactionInitiated&,
+                           const TransactionInitiated&) -> bool = default;
+};
+
+inline auto toString(const TransactionInitiated& event) -> std::string {
+    return fmt::format(
+            "sfTransactionInitiated{{"
+            " surface: {},"
+            " frameNumber: {},"
+            " bufferId: {}"
+            " receivedAt: {}"
+            " }}",
+            static_cast<void*>(event.surface), event.frameNumber, toString(event.bufferId),
+            event.receivedAt.time_since_epoch());
+}
+
+inline auto format_as(const TransactionInitiated& event) -> std::string {
+    return toString(event);
+}
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger::events
diff --git a/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/events/VSyncTiming.h b/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/events/VSyncTiming.h
new file mode 100644
index 0000000000..42a5600e59
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/test_framework/surfaceflinger/events/VSyncTiming.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#include <chrono>
+#include <cstdint>
+#include <string>
+
+#include <fmt/chrono.h>  // NOLINT(misc-include-cleaner)
+#include <fmt/format.h>
+#include <gui/VsyncEventData.h>
+
+#include "test_framework/core/AsyncFunction.h"
+#include "test_framework/core/DisplayConfiguration.h"
+
+namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger {
+
+class DisplayEventReceiver;
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger
+
+namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger::events {
+
+struct VSyncTiming final {
+    using AsyncConnector = core::AsyncFunctionStd<void(VSyncTiming)>;
+
+    using DisplayId = core::DisplayConfiguration::Id;
+    using Timestamp = std::chrono::steady_clock::time_point;
+
+    DisplayEventReceiver* receiver{};
+    DisplayId displayId{};
+    Timestamp sfEventAt;
+    uint32_t count{};
+    gui::VsyncEventData data{};
+    Timestamp receivedAt{std::chrono::steady_clock::now()};
+};
+
+inline auto toString(const VSyncTiming& event) -> std::string {
+    return fmt::format(
+            "sfVSyncTiming{{"
+            " receiver: {},"
+            " displayId: {},"
+            " sfEventAt: {}"
+            " count: {}"
+            " data: ..."
+            " receivedAt: {}"
+            " }}",
+            static_cast<void*>(event.receiver), event.displayId, event.sfEventAt.time_since_epoch(),
+            event.count, event.receivedAt.time_since_epoch());
+}
+
+inline auto format_as(const VSyncTiming& event) -> std::string {
+    return toString(event);
+}
+
+}  // namespace android::surfaceflinger::tests::end2end::test_framework::surfaceflinger::events
diff --git a/services/surfaceflinger/tests/end2end/tests/Placeholder_test.cpp b/services/surfaceflinger/tests/end2end/tests/Placeholder_test.cpp
index 3c4277f8a0..eb942fbeb7 100644
--- a/services/surfaceflinger/tests/end2end/tests/Placeholder_test.cpp
+++ b/services/surfaceflinger/tests/end2end/tests/Placeholder_test.cpp
@@ -14,15 +14,46 @@
  * limitations under the License.
  */
 
-#include <gtest/gtest.h>
+#include <chrono>
+#include <cstddef>
+#include <memory>
+#include <thread>
+#include <utility>
 
 #include <android-base/logging.h>
+#include <fmt/format.h>
+#include <gtest/gtest.h>
 
 #include "test_framework/core/TestService.h"
+#include "test_framework/hwc3/Hwc3Controller.h"
+#include "test_framework/hwc3/ObservingComposer.h"
+#include "test_framework/hwc3/events/DisplayPresented.h"
+#include "test_framework/hwc3/events/PendingBufferSwap.h"
+#include "test_framework/hwc3/events/VSyncEnabled.h"
+#include "test_framework/surfaceflinger/DisplayEventReceiver.h"
+#include "test_framework/surfaceflinger/SFController.h"
+#include "test_framework/surfaceflinger/Surface.h"
+#include "test_framework/surfaceflinger/events/BufferReleased.h"
+#include "test_framework/surfaceflinger/events/Hotplug.h"
+#include "test_framework/surfaceflinger/events/TransactionCompleted.h"
+#include "test_framework/surfaceflinger/events/TransactionInitiated.h"
+#include "test_framework/surfaceflinger/events/VSyncTiming.h"
+
+#define TRY_OR_ASSERT(expr)                       \
+    ({                                            \
+        auto result_ = (expr);                    \
+        if (!result_) {                           \
+            FAIL() << std::move(result_).error(); \
+            return;                               \
+        }                                         \
+        *std::move(result_);                      \
+    })
 
 namespace android::surfaceflinger::tests::end2end {
 namespace {
 
+using Timestamp = std::chrono::steady_clock::time_point;
+
 struct Placeholder : public ::testing::Test {};
 
 TEST_F(Placeholder, Bringup) {
@@ -33,6 +64,80 @@ TEST_F(Placeholder, Bringup) {
         LOG(WARNING) << "End2End service not available. " << serviceResult.error();
         GTEST_SKIP() << "End2End service not available. " << serviceResult.error();
     }
+
+    auto service = *std::move(serviceResult);
+
+    service->hwc().editCallbacks().onVsyncEnabledChanged.set(
+            [&](test_framework::hwc3::events::VSyncEnabled event) {
+                LOG(INFO) << fmt::format("onVsyncEnabledChanged {}", event);
+            })();
+    service->hwc().editCallbacks().onDisplayPresented.set(
+            [&](test_framework::hwc3::events::DisplayPresented event) {
+                LOG(INFO) << fmt::format("onDisplayPresented {}", event);
+            })();
+    service->hwc().editCallbacks().onPendingBufferSwap.set(
+            [&](test_framework::hwc3::events::PendingBufferSwap event) {
+                LOG(INFO) << fmt::format("onPendingBufferSwap {}", event);
+            })();
+
+    auto displayEvents = TRY_OR_ASSERT(service->flinger().makeDisplayEventReceiver());
+    displayEvents->setVsyncRate(1);
+
+    displayEvents->editCallbacks().onHotplug.set(
+            [](test_framework::surfaceflinger::events::Hotplug event) {
+                LOG(INFO) << fmt::format("onHotplug {}", event);
+            })();
+    size_t vsyncCount = 0;
+    displayEvents->editCallbacks().onVSyncTiming.set(
+            [&](test_framework::surfaceflinger::events::VSyncTiming event) {
+                ++vsyncCount;
+                LOG(INFO) << fmt::format("onVSyncTiming {}", event);
+            })();
+
+    auto surface =
+            TRY_OR_ASSERT(service->flinger().makeSurface({.name = "test", .size = {100, 100}}));
+
+    size_t bufferReleaseCount = 0;
+    surface->editCallbacks().onBufferReleased.set(
+            [&](test_framework::surfaceflinger::events::BufferReleased event) {
+                ++bufferReleaseCount;
+                LOG(INFO) << fmt::format("onBufferReleased {}", event);
+            })();
+
+    size_t transactionInitiatedCount = 0;
+    surface->editCallbacks().onTransactionInitiated.set(
+            [&](test_framework::surfaceflinger::events::TransactionInitiated event) {
+                ++transactionInitiatedCount;
+                LOG(INFO) << fmt::format("onTransactionInitiated {}", event);
+            })();
+
+    size_t transactionCompleteCount = 0;
+    surface->editCallbacks().onTransactionCompleted.set(
+            [&](test_framework::surfaceflinger::events::TransactionCompleted event) {
+                ++transactionCompleteCount;
+                LOG(INFO) << fmt::format("onTransactionCompleted {}", event);
+                // Commit a new frame now that the previous one has completed.
+                // This is ONE possible way an app can continue to submit new frames.
+                auto nextFrameNumber = surface->commitNextBuffer();
+            })();
+
+    // Trigger the first commit to get things started.
+    auto firstFrameNumber = surface->commitNextBuffer();
+    LOG(INFO) << "firstFrameNumber " << firstFrameNumber;
+
+    // This sleep should allow multiple frames to be generated, though we don't know how many.
+    constexpr auto kSleepTime = std::chrono::milliseconds(100);
+    LOG(INFO) << "Waiting for " << kSleepTime << "....";
+    std::this_thread::sleep_for(kSleepTime);
+    LOG(INFO) << "Done waiting for " << kSleepTime << "....";
+
+    EXPECT_GT(vsyncCount, 0) << "Expected at least one vsync timing callback. Zero observed.";
+    EXPECT_GT(bufferReleaseCount, 0)
+            << "Expected at least one buffer release callback. Zero observed.";
+    EXPECT_GT(transactionInitiatedCount, 0)
+            << "Expected at least one transaction initiated callback. Zero observed.";
+    EXPECT_GT(transactionCompleteCount, 0)
+            << "Expected at least one transaction complete callback. Zero observed.";
 }
 
 }  // namespace
diff --git a/services/surfaceflinger/tests/end2end/tests/internal/AsyncFunction_test.cpp b/services/surfaceflinger/tests/end2end/tests/internal/AsyncFunction_test.cpp
new file mode 100644
index 0000000000..d4e7dd3321
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/tests/internal/AsyncFunction_test.cpp
@@ -0,0 +1,226 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <chrono>
+#include <future>
+#include <memory>
+#include <mutex>
+#include <thread>
+#include <tuple>
+#include <type_traits>
+#include <utility>
+
+#include <gtest/gtest.h>
+
+#include "test_framework/core/AsyncFunction.h"
+
+namespace android::surfaceflinger::tests::end2end {
+namespace {
+
+template <typename T>
+using AsyncFunction = test_framework::core::AsyncFunction<T>;
+
+template <typename T>
+using AsyncFunctionStd = test_framework::core::AsyncFunctionStd<T>;
+
+template <typename T>
+using AsyncFunctionFtl = test_framework::core::AsyncFunctionFtl<T>;
+
+TEST(AsyncFunction, DefaultConstructionOfVoidFunctionIsANoOpWhenInvoked) {
+    const AsyncFunctionStd<void(int)> afn;
+    afn(123);
+}
+
+TEST(AsyncFunction, DefaultConstructionOfIntFunctionIsANoOpWhenInvoked) {
+    const AsyncFunctionStd<int(int)> afn;
+    const auto result = afn(123);
+    EXPECT_FALSE(result.has_value());
+}
+
+TEST(AsyncFunction, NulledVoidFunctionIsANoOpWhenInvoked) {
+    int callArg = 0;
+    AsyncFunctionStd<void(int)> afn{[&](auto value) { callArg = value; }};
+    afn.set(nullptr)();
+
+    EXPECT_EQ(callArg, 0);
+    afn(345);
+    EXPECT_EQ(callArg, 0);
+    EXPECT_TRUE(std::is_void_v<decltype(afn(345))>);
+}
+
+TEST(AsyncFunction, NulledIntFunctionIsANoOpWhenInvoked) {
+    int callArg = 0;
+    AsyncFunctionStd<int(int)> afn{[&](auto value) {
+        callArg = value;
+        return value + 123;
+    }};
+    afn.set(nullptr)();
+
+    EXPECT_EQ(callArg, 0);
+    const auto result = afn(345);
+    EXPECT_EQ(callArg, 0);
+    EXPECT_FALSE(result.has_value());
+}
+
+TEST(AsyncFunction, VoidFunctionWorksWhenInvoked) {
+    int callArg = 0;
+    const AsyncFunctionStd<void(int)> afn{[&](auto value) { callArg = value; }};
+
+    EXPECT_EQ(callArg, 0);
+    afn(345);
+    EXPECT_EQ(callArg, 345);
+    EXPECT_TRUE(std::is_void_v<decltype(afn(345))>);
+}
+
+TEST(AsyncFunction, IntFunctionWorksWhenInvoked) {
+    int callArg = 0;
+    const AsyncFunctionStd<int(int)> afn{[&](auto value) {
+        callArg = value;
+        return value + 123;
+    }};
+
+    EXPECT_EQ(callArg, 0);
+    const auto result = afn(345);
+    EXPECT_EQ(callArg, 345);
+    EXPECT_TRUE(result == 468);
+}
+
+TEST(AsyncFunction, NulledIntFtlFunctionIsANoOpWhenInvoked) {
+    int callArg = 0;
+    AsyncFunctionFtl<int(int)> afn{[&](auto value) {
+        callArg = value;
+        return value + 123;
+    }};
+    afn.set(nullptr)();
+
+    EXPECT_EQ(callArg, 0);
+    const auto result = afn(345);
+    EXPECT_EQ(callArg, 0);
+    EXPECT_FALSE(result.has_value());
+}
+
+TEST(AsyncFunction, IntFtlFunctionWorksWhenInvoked) {
+    int callArg = 0;
+    const AsyncFunctionFtl<int(int)> afn{[&](auto value) {
+        callArg = value;
+        return value + 123;
+    }};
+
+    EXPECT_EQ(callArg, 0);
+    const auto result = afn(345);
+    EXPECT_EQ(callArg, 345);
+    EXPECT_TRUE(result == 468);
+}
+
+TEST(AsyncFunction, CalledFunctionCanReplaceItselfWithoutHanging) {
+    AsyncFunctionStd<void()> afn;
+    afn.set([&] { afn.set([] {})(); })();
+    afn();
+}
+
+TEST(AsyncFunction, FinalizerDestroysCaptureWhenManuallyInvoked) {
+    auto shared = std::make_shared<int>(0);
+    const std::weak_ptr<int> weak = shared;
+    AsyncFunctionStd<void()> afn = [context = std::move(shared)] {};
+
+    EXPECT_FALSE(weak.expired());
+    auto finalizer = afn.clear();
+    EXPECT_FALSE(weak.expired());
+    finalizer();
+    EXPECT_TRUE(weak.expired());
+}
+
+TEST(AsyncFunction, FinalizerDestroysCaptureWhenDestroyed) {
+    auto shared = std::make_shared<int>(0);
+    const std::weak_ptr<int> weak = shared;
+
+    {
+        AsyncFunctionStd<void()> afn = [context = std::move(shared)] {};
+        EXPECT_FALSE(weak.expired());
+        std::ignore = afn.clear();
+        EXPECT_TRUE(weak.expired());
+    }
+}
+
+TEST(AsyncFunctionStd, CanSafelyReplaceFunctionViaAssignmentWhileBeingCalled) {
+    // This has a good but not guaranteed chance of catching a problem, but with continuous runs of
+    // this test we should eventually see a failure. Increase this value to increase the chance of
+    // catching errors when running locally.
+    static constexpr auto kRunFor = std::chrono::milliseconds(10);
+
+    // This test ensures that the wrapper does what it says it does:
+    // 1) Allows the function to be replaced at any time.
+    // 2) Includes a barrier that the replaced function is no longer used past a point that can be
+    //    controlled by the caller so that a wait can be done outside of any locks that might be
+    //    acquired by the replaced function,
+
+    // We intentionally use a mutex to guard `state` rather than using an atomic integer.
+    std::mutex mutex;
+    AsyncFunctionStd<void()> afn;  // GUARDED_BY(mutex)
+    int state = 0;                 // GUARDED_BY(mutex)
+
+    auto setState = [&](int value) {
+        const std::lock_guard lock(mutex);
+        state = value;
+    };
+
+    auto setStateTemporarily = [&](int value) {
+        static constexpr auto kDelayBeforeSwitching = std::chrono::microseconds(10);
+        setState(value);
+        std::this_thread::sleep_for(kDelayBeforeSwitching);
+        setState(0);
+    };
+
+    auto getState = [&] -> int {
+        const std::lock_guard lock(mutex);
+        return state;
+    };
+
+    auto expectStateIsZeroOr = [&](int expected) {
+        const auto value = getState();
+        EXPECT_TRUE(value == 0 || value == expected)
+                << "Expected zero or " << expected << " but observed " << value;
+    };
+
+    auto setAsyncFunction = [&](auto newFunction) -> AsyncFunctionStd<void()>::Finalizer {
+        const std::lock_guard lock(mutex);
+        return afn.set(newFunction);
+    };
+
+    // Continuously invoke the current function via the wrapper in a separate thread, for kRunFor
+    // time.
+    const std::future<void> future = std::async(std::launch::async, [&afn] {
+        const auto endAt = std::chrono::steady_clock::now() + kRunFor;
+        while (std::chrono::steady_clock::now() < endAt) {
+            afn();
+        }
+    });
+
+    // While the callback is being called, switch the callback between two functions.
+    // The first callback sets the state to either 0 or 1.
+    // The second callback sets the state to either 0 or 2.
+    constexpr auto kWaitFor = std::chrono::microseconds(0);
+    while (future.wait_for(kWaitFor) != std::future_status::ready) {
+        auto cleanup1 = setAsyncFunction([&] { setStateTemporarily(1); });
+        cleanup1();
+        expectStateIsZeroOr(1);
+        setAsyncFunction([&] { setStateTemporarily(2); })();
+        expectStateIsZeroOr(2);
+    }
+}
+
+}  // namespace
+}  // namespace android::surfaceflinger::tests::end2end
diff --git a/services/surfaceflinger/tests/end2end/tests/internal/DisplayRefresh_test.cpp b/services/surfaceflinger/tests/end2end/tests/internal/DisplayRefresh_test.cpp
new file mode 100644
index 0000000000..e170e4b48c
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/tests/internal/DisplayRefresh_test.cpp
@@ -0,0 +1,422 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <bit>
+#include <chrono>
+#include <cstdint>
+#include <initializer_list>
+#include <map>
+#include <string>
+
+#include <fmt/chrono.h>  // NOLINT(misc-include-cleaner)
+#include <fmt/format.h>
+#include <fmt/ranges.h>
+#include <gtest/gtest.h>
+
+#include "test_framework/core/DisplayConfiguration.h"
+#include "test_framework/core/TimeInterval.h"
+#include "test_framework/hwc3/MultiDisplayRefreshEventGenerator.h"
+#include "test_framework/hwc3/SingleDisplayRefreshEventGenerator.h"
+#include "test_framework/hwc3/SingleDisplayRefreshSchedule.h"
+
+namespace android::surfaceflinger::tests::end2end {
+namespace {
+
+using TimePoint = std::chrono::steady_clock::time_point;
+using TimeInterval = test_framework::core::TimeInterval;
+using SingleDisplayRefreshSchedule = test_framework::hwc3::SingleDisplayRefreshSchedule;
+using SingleDisplayRefreshEventGenerator = test_framework::hwc3::SingleDisplayRefreshEventGenerator;
+using MultiDisplayRefreshEventGenerator = test_framework::hwc3::MultiDisplayRefreshEventGenerator;
+
+// Helper to compute a monotonic clock time point from a integer value for the count of
+// nanoseconds since the epoch.
+constexpr auto operator""_ticks(unsigned long long value) -> TimePoint {
+    return TimePoint{std::chrono::nanoseconds(std::bit_cast<int64_t>(value))};
+}
+
+constexpr auto operator""_ms(unsigned long long value) -> std::chrono::milliseconds {
+    return std::chrono::milliseconds(std::bit_cast<int64_t>(value));
+}
+
+auto toString(const SingleDisplayRefreshEventGenerator::GenerateResult& result) -> std::string {
+    return fmt::format("Result{{nextRefreshAt: {}, events:\n     {}\n  }}",
+                       result.nextRefreshAt.time_since_epoch(),
+                       fmt::join(result.events, ",\n     "));
+}
+
+auto toString(const MultiDisplayRefreshEventGenerator::GenerateResult& result) -> std::string {
+    return fmt::format("Result{{nextRefreshAt: {}, events:\n     {}\n  }}",
+                       result.nextRefreshAt.time_since_epoch(),
+                       fmt::join(result.events, ",\n     "));
+}
+
+TEST(SingleDisplayRefreshSchedule, NextRefreshEventComputesNext) {
+    // Set up a fixed refresh schedule where events happen every 5ms, anchored to a clock time of
+    // 22ms. So refresh events happen at [..., 12ms, 17ms, 22ms, 27ms, 32ms, ...]
+    static constexpr SingleDisplayRefreshSchedule schedule{
+            .base = 22'000'000_ticks,
+            .period = 5_ms,
+    };
+
+    struct TestCase {
+        int64_t input;
+        int64_t expected;
+    };
+
+    // The implementation assumes that it is called with increasing input clock times.
+    const auto testCases = std::initializer_list<TestCase>{
+            // Clock times 1ms apart should always round up to an event time after the input time.
+            // These values are to show that the rounding occurs to the 5ms refresh period.
+            {.input = 12'000'000, .expected = 17'000'000},
+            {.input = 13'000'000, .expected = 17'000'000},
+            {.input = 14'000'000, .expected = 17'000'000},
+            {.input = 15'000'000, .expected = 17'000'000},
+            {.input = 16'000'000, .expected = 17'000'000},
+            {.input = 17'000'000, .expected = 22'000'000},
+            {.input = 18'000'000, .expected = 22'000'000},
+            {.input = 19'000'000, .expected = 22'000'000},
+            {.input = 20'000'000, .expected = 22'000'000},
+            {.input = 21'000'000, .expected = 22'000'000},  // ^ Past events
+            {.input = 22'000'000, .expected = 27'000'000},  // = At Base tme
+            {.input = 23'000'000, .expected = 27'000'000},  // v Future events
+            {.input = 24'000'000, .expected = 27'000'000},
+            {.input = 25'000'000, .expected = 27'000'000},
+            {.input = 26'000'000, .expected = 27'000'000},
+            {.input = 27'000'000, .expected = 32'000'000},
+            {.input = 28'000'000, .expected = 32'000'000},
+            {.input = 29'000'000, .expected = 32'000'000},
+            {.input = 30'000'000, .expected = 32'000'000},
+            {.input = 31'000'000, .expected = 32'000'000},
+
+            // Past clock times near the rounding point should correctly round up.
+            {.input = 11'999'000, .expected = 12'000'000},
+            {.input = 12'000'000, .expected = 17'000'000},
+            {.input = 12'001'000, .expected = 17'000'000},
+
+            // clock times near the base time should correctly round up.
+            {.input = 21'999'000, .expected = 22'000'000},
+            {.input = 22'000'000, .expected = 27'000'000},
+            {.input = 22'001'000, .expected = 27'000'000},
+
+            // Future clock times near the rounding point should correctly round up.
+            {.input = 31'999'000, .expected = 32'000'000},
+            {.input = 32'000'000, .expected = 37'000'000},
+            {.input = 32'001'000, .expected = 37'000'000},
+
+            // TimePoint::min() (-9'223'372'036'854'775'808) should be accepted, and should compute
+            // a correct value.
+            {
+                    .input = TimePoint::min().time_since_epoch().count(),
+                    .expected = -9'223'372'036'853'000'000,
+            },
+            {
+                    .input = -9'223'372'036'853'000'001,
+                    .expected = -9'223'372'036'853'000'000,
+            },
+            {
+                    .input = -9'223'372'036'853'000'000,
+                    .expected = -9'223'372'036'848'000'000,
+            },
+
+            // The largest valid input value is one less than the last representable event time.
+            // Passing in the last representable event time would require returning an event time
+            // greater than TimePoint::max() (9'223'372'036'854'775'807), which is not possible.
+            {
+                    .input = 9'223'372'036'847'000'000,  // The second to last representable event.
+                    .expected = 9'223'372'036'852'000'000,  // The last representable event time.
+            },
+            {
+                    .input = 9'223'372'036'851'999'999,  // The last representable event time - 1.
+                    .expected = 9'223'372'036'852'000'000,  // The last representable event time.
+            },
+            // Note: The implementation asserts when the output value would not be representable,
+            // rather than returning a truncated value.
+    };
+
+    for (const auto& testCase : testCases) {
+        const auto actual = schedule.nextEvent(TimePoint{std::chrono::nanoseconds(testCase.input)})
+                                    .time_since_epoch()
+                                    .count();
+        if (actual != testCase.expected) {
+            FAIL() << fmt::format("For input: {:} expected: {}, actual: {})", testCase.input,
+                                  testCase.expected, actual);
+        }
+    }
+}
+
+TEST(SingleDisplayRefreshEventGenerator, GeneratesEvents) {
+    using GenerateResult = SingleDisplayRefreshEventGenerator::GenerateResult;
+    struct TestCase {
+        std::string name;
+        SingleDisplayRefreshEventGenerator generator;
+        TimeInterval input;
+        GenerateResult expected;
+    };
+    // The implementation assumes that it is called with increasing input clock times.
+    const auto testCases = std::initializer_list<TestCase>{
+            {
+                    // The first request should yield a single event for the first
+                    // refresh before the input time.
+                    .name = "First",
+                    .generator = {.id = 0, .schedule = {.base = 22'000'000_ticks, .period = 5_ms}},
+                    .input = {.begin = TimePoint::min(), .end = 10'000'000_ticks},
+                    .expected = {.nextRefreshAt = 12'000'000_ticks,
+                                 .events = {{
+                                         .displayId = 0,
+                                         .expectedAt = 7'000'000_ticks,
+                                         .expectedPeriod = 5_ms,
+                                         .receivedAt = 10'000'000_ticks,
+                                 }}},
+            },
+            {
+                    // A typical incremental update would just yield a single event for one refresh
+                    // in the elapsed time since the last time the generator is invoked and the
+                    // input time.
+                    .name = "Incremental",
+                    .generator = {.id = 0, .schedule = {.base = 22'000'000_ticks, .period = 5_ms}},
+                    .input = {.begin = 10'000'000_ticks, .end = 12'100'000_ticks},
+                    .expected = {.nextRefreshAt = 17'000'000_ticks,
+                                 .events = {{
+                                         .displayId = 0,
+                                         .expectedAt = 12'000'000_ticks,
+                                         .expectedPeriod = 5_ms,
+                                         .receivedAt = 12'100'000_ticks,
+                                 }}},
+            },
+            {
+                    // If the generator is invoked early, no events should be generated, but the
+                    // next refresh time should still refer to the correct time for the next event.
+                    .name = "Early",
+                    .generator = {.id = 0, .schedule = {.base = 22'000'000_ticks, .period = 5_ms}},
+                    .input = {.begin = 12'100'000_ticks, .end = 16'100'000_ticks},
+                    .expected = {.nextRefreshAt = 17'000'000_ticks, .events = {}},
+            },
+            {
+                    // If the generator is invoked with an input time more than one period in the
+                    // future (but not too far), the returned interval will cover all the missed
+                    // events.
+                    .name = "Small jump",
+                    .generator = {.id = 0, .schedule = {.base = 22'000'000_ticks, .period = 5_ms}},
+                    .input = {.begin = 16'100'000_ticks, .end = 40'000'000_ticks},
+                    .expected = {.nextRefreshAt = 42'000'000_ticks,
+                                 .events = {{
+                                                    .displayId = 0,
+                                                    .expectedAt = 17'000'000_ticks,
+                                                    .expectedPeriod = 5_ms,
+                                                    .receivedAt = 40'000'000_ticks,
+                                            },
+                                            {
+                                                    .displayId = 0,
+                                                    .expectedAt = 22'000'000_ticks,
+                                                    .expectedPeriod = 5_ms,
+                                                    .receivedAt = 40'000'000_ticks,
+                                            },
+                                            {
+                                                    .displayId = 0,
+                                                    .expectedAt = 27'000'000_ticks,
+                                                    .expectedPeriod = 5_ms,
+                                                    .receivedAt = 40'000'000_ticks,
+                                            },
+                                            {
+                                                    .displayId = 0,
+                                                    .expectedAt = 32'000'000_ticks,
+                                                    .expectedPeriod = 5_ms,
+                                                    .receivedAt = 40'000'000_ticks,
+                                            },
+                                            {
+                                                    .displayId = 0,
+                                                    .expectedAt = 37'000'000_ticks,
+                                                    .expectedPeriod = 5_ms,
+                                                    .receivedAt = 40'000'000_ticks,
+                                            }}},
+            },
+            {
+                    // If the generator is invoked with an input time substantially in the future,
+                    // rather than returning an interval with all the missed events, the interval
+                    // will only contain the most recent event.
+                    .name = "Large jump",
+                    .generator = {.id = 0, .schedule = {.base = 22'000'000_ticks, .period = 5_ms}},
+                    .input = {.begin = 40'000'000_ticks, .end = 4'002'100'000_ticks},
+                    .expected = {.nextRefreshAt = 4'007'000'000_ticks,
+                                 .events = {{
+                                         .displayId = 0,
+                                         .expectedAt = 4'002'000'000_ticks,
+                                         .expectedPeriod = 5_ms,
+                                         .receivedAt = 4'002'100'000_ticks,
+                                 }}},
+            },
+    };
+
+    for (const auto& testCase : testCases) {
+        const auto actual = testCase.generator.generateEventsFor(testCase.input);
+        if (actual != testCase.expected) {
+            FAIL() << fmt::format("Case name: {}: input: {},\n  expected: {},\n  actual: {})",
+                                  testCase.name, toString(testCase.input),
+                                  toString(testCase.expected), toString(actual));
+        }
+    }
+}
+
+TEST(MultiDisplayRefreshEventGenerator, GeneratesEvents) {
+    using DisplayId = test_framework::core::DisplayConfiguration::Id;
+    using GenerateResult = MultiDisplayRefreshEventGenerator::GenerateResult;
+    struct TestCase {
+        std::string name;
+        std::map<DisplayId, SingleDisplayRefreshSchedule> displays;
+        TimeInterval input;
+        GenerateResult expected;
+    };
+    // The implementation assumes that it is called with increasing input clock times.
+    const auto testCases = std::initializer_list<TestCase>{
+            {
+                    .name = "2x @5ms in-phase",
+                    .displays = {{0, {.base = 0_ticks, .period = 5_ms}},
+                                 {1, {.base = 0_ticks, .period = 5_ms}}},
+                    .input = {.begin = 0'000'000_ticks, .end = 20'100'000_ticks},
+                    .expected =
+                            {
+                                    .nextRefreshAt = 25'000'000_ticks,
+                                    .events = {{
+                                                       .displayId = 0,
+                                                       .expectedAt = 5'000'000_ticks,
+                                                       .expectedPeriod = 5_ms,
+                                                       .receivedAt = 20'100'000_ticks,
+                                               },
+                                               {
+                                                       .displayId = 0,
+                                                       .expectedAt = 10'000'000_ticks,
+                                                       .expectedPeriod = 5_ms,
+                                                       .receivedAt = 20'100'000_ticks,
+                                               },
+                                               {
+                                                       .displayId = 0,
+                                                       .expectedAt = 15'000'000_ticks,
+                                                       .expectedPeriod = 5_ms,
+                                                       .receivedAt = 20'100'000_ticks,
+                                               },
+                                               {
+                                                       .displayId = 0,
+                                                       .expectedAt = 20'000'000_ticks,
+                                                       .expectedPeriod = 5_ms,
+                                                       .receivedAt = 20'100'000_ticks,
+                                               },
+                                               {
+                                                       .displayId = 1,
+                                                       .expectedAt = 5'000'000_ticks,
+                                                       .expectedPeriod = 5_ms,
+                                                       .receivedAt = 20'100'000_ticks,
+                                               },
+                                               {
+                                                       .displayId = 1,
+                                                       .expectedAt = 10'000'000_ticks,
+                                                       .expectedPeriod = 5_ms,
+                                                       .receivedAt = 20'100'000_ticks,
+                                               },
+                                               {
+                                                       .displayId = 1,
+                                                       .expectedAt = 15'000'000_ticks,
+                                                       .expectedPeriod = 5_ms,
+                                                       .receivedAt = 20'100'000_ticks,
+                                               },
+                                               {
+                                                       .displayId = 1,
+                                                       .expectedAt = 20'000'000_ticks,
+                                                       .expectedPeriod = 5_ms,
+                                                       .receivedAt = 20'100'000_ticks,
+                                               }},
+                            },
+            },
+            {
+                    .name = "2x @5ms out-of-phase",
+                    .displays =
+                            {
+                                    {0, {.base = 0'000'000_ticks, .period = 5_ms}},
+                                    {1, {.base = 2'500'000_ticks, .period = 5_ms}},
+                            },
+                    .input = {.begin = 0'000'000_ticks, .end = 20'100'000_ticks},
+                    .expected =
+                            {
+                                    .nextRefreshAt = 22'500'000_ticks,
+                                    .events = {{
+                                                       .displayId = 0,
+                                                       .expectedAt = 5'000'000_ticks,
+                                                       .expectedPeriod = 5_ms,
+                                                       .receivedAt = 20'100'000_ticks,
+                                               },
+                                               {
+                                                       .displayId = 0,
+                                                       .expectedAt = 10'000'000_ticks,
+                                                       .expectedPeriod = 5_ms,
+                                                       .receivedAt = 20'100'000_ticks,
+                                               },
+                                               {
+                                                       .displayId = 0,
+                                                       .expectedAt = 15'000'000_ticks,
+                                                       .expectedPeriod = 5_ms,
+                                                       .receivedAt = 20'100'000_ticks,
+                                               },
+                                               {
+                                                       .displayId = 0,
+                                                       .expectedAt = 20'000'000_ticks,
+                                                       .expectedPeriod = 5_ms,
+                                                       .receivedAt = 20'100'000_ticks,
+                                               },
+                                               {
+                                                       .displayId = 1,
+                                                       .expectedAt = 2'500'000_ticks,
+                                                       .expectedPeriod = 5_ms,
+                                                       .receivedAt = 20'100'000_ticks,
+                                               },
+                                               {
+                                                       .displayId = 1,
+                                                       .expectedAt = 7'500'000_ticks,
+                                                       .expectedPeriod = 5_ms,
+                                                       .receivedAt = 20'100'000_ticks,
+                                               },
+                                               {
+                                                       .displayId = 1,
+                                                       .expectedAt = 12'500'000_ticks,
+                                                       .expectedPeriod = 5_ms,
+                                                       .receivedAt = 20'100'000_ticks,
+                                               },
+                                               {
+                                                       .displayId = 1,
+                                                       .expectedAt = 17'500'000_ticks,
+                                                       .expectedPeriod = 5_ms,
+                                                       .receivedAt = 20'100'000_ticks,
+                                               }},
+                            },
+            },
+    };
+
+    for (const auto& testCase : testCases) {
+        MultiDisplayRefreshEventGenerator generator;
+        for (const auto& [displayId, schedule] : testCase.displays) {
+            generator.addDisplay(displayId, schedule);
+        }
+
+        const auto actual = generator.generateEventsFor(testCase.input);
+
+        if (actual != testCase.expected) {
+            FAIL() << fmt::format("Case name: {}: input: {},\n  expected: {},\n  actual: {})",
+                                  testCase.name, toString(testCase.input),
+                                  toString(testCase.expected), toString(actual));
+        }
+    }
+}
+
+}  // namespace
+}  // namespace android::surfaceflinger::tests::end2end
diff --git a/services/surfaceflinger/tests/end2end/tests/internal/EdidBuilder_test.cpp b/services/surfaceflinger/tests/end2end/tests/internal/EdidBuilder_test.cpp
new file mode 100644
index 0000000000..eaa2464ef8
--- /dev/null
+++ b/services/surfaceflinger/tests/end2end/tests/internal/EdidBuilder_test.cpp
@@ -0,0 +1,117 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <algorithm>
+#include <array>
+#include <iterator>
+
+#include <fmt/format.h>
+#include <gtest/gtest.h>
+#include <ui/Size.h>
+
+#include "test_framework/core/EdidBuilder.h"
+
+namespace android::surfaceflinger::tests::end2end {
+namespace {
+
+using namespace std::string_view_literals;
+
+using EdidBuilder = end2end::test_framework::core::EdidBuilder;
+
+TEST(EdidBuilderSynthesizeTiming, for1920x1080x60Hz) {
+    using Timing = EdidBuilder::DigitalSeparateDetailedTimingDescriptor::Timing;
+
+    const auto result = Timing::synthesize({1920, 1080}, 60);
+
+    EXPECT_EQ(result.pixelClockMhz, 162'000'000);
+
+    EXPECT_EQ(result.horizontal.addressable, 1920);
+    EXPECT_EQ(result.horizontal.border, 0);
+    EXPECT_EQ(result.horizontal.frontPorch, 88);
+    EXPECT_EQ(result.horizontal.syncPulse, 44);
+    EXPECT_EQ(result.horizontal.backPorch, 348);
+    EXPECT_EQ(result.horizontal.syncPolarity, EdidBuilder::SyncPolarity::Positive);
+
+    EXPECT_EQ(result.vertical.addressable, 1080);
+    EXPECT_EQ(result.vertical.border, 0);
+    EXPECT_EQ(result.vertical.frontPorch, 4);
+    EXPECT_EQ(result.vertical.syncPulse, 5);
+    EXPECT_EQ(result.vertical.backPorch, 36);
+    EXPECT_EQ(result.vertical.syncPolarity, EdidBuilder::SyncPolarity::Positive);
+}
+
+TEST(EdidBuilderSynthesizeTiming, for1920x1080x144Hz) {
+    using Timing = EdidBuilder::DigitalSeparateDetailedTimingDescriptor::Timing;
+
+    const auto result = Timing::synthesize({1920, 1080}, 144);
+
+    EXPECT_EQ(result.pixelClockMhz, 388'800'000);
+
+    EXPECT_EQ(result.horizontal.addressable, 1920);
+    EXPECT_EQ(result.horizontal.border, 0);
+    EXPECT_EQ(result.horizontal.frontPorch, 88);
+    EXPECT_EQ(result.horizontal.syncPulse, 44);
+    EXPECT_EQ(result.horizontal.backPorch, 348);
+    EXPECT_EQ(result.horizontal.syncPolarity, EdidBuilder::SyncPolarity::Positive);
+
+    EXPECT_EQ(result.vertical.addressable, 1080);
+    EXPECT_EQ(result.vertical.border, 0);
+    EXPECT_EQ(result.vertical.frontPorch, 4);
+    EXPECT_EQ(result.vertical.syncPulse, 5);
+    EXPECT_EQ(result.vertical.backPorch, 36);
+    EXPECT_EQ(result.vertical.syncPolarity, EdidBuilder::SyncPolarity::Positive);
+}
+
+TEST(EdidBuilderSynthesizeTiming, for3840x2160x60Hz) {
+    using Timing = EdidBuilder::DigitalSeparateDetailedTimingDescriptor::Timing;
+
+    const auto result = Timing::synthesize({3840, 2160}, 60);
+
+    EXPECT_EQ(result.pixelClockMhz, 580'800'000);
+
+    EXPECT_EQ(result.horizontal.addressable, 3840);
+    EXPECT_EQ(result.horizontal.border, 0);
+    EXPECT_EQ(result.horizontal.frontPorch, 88);
+    EXPECT_EQ(result.horizontal.syncPulse, 44);
+    EXPECT_EQ(result.horizontal.backPorch, 428);
+    EXPECT_EQ(result.horizontal.syncPolarity, EdidBuilder::SyncPolarity::Positive);
+
+    EXPECT_EQ(result.vertical.addressable, 2160);
+    EXPECT_EQ(result.vertical.border, 0);
+    EXPECT_EQ(result.vertical.frontPorch, 4);
+    EXPECT_EQ(result.vertical.syncPulse, 5);
+    EXPECT_EQ(result.vertical.backPorch, 31);
+    EXPECT_EQ(result.vertical.syncPolarity, EdidBuilder::SyncPolarity::Positive);
+}
+
+TEST(EdidBuilder, DefaultPrebuiltMatchesDefaultWhenBuilt) {
+    const auto prebuilt = EdidBuilder::kDefaultEdid;
+    const auto built = EdidBuilder().set(EdidBuilder::Version1r4Required{}).build();
+
+    const auto result = std::ranges::mismatch(prebuilt, built);
+    const auto prebuiltIndex = std::distance(prebuilt.begin(), result.in1);
+    const auto builtIndex = std::distance(built.begin(), result.in2);
+
+    // NOLINTBEGIN(cppcoreguidelines-pro-bounds-constant-array-index)
+    EXPECT_EQ(prebuilt, built) << fmt::format(
+            "Difference at prebuilt index {} with byte 0x{:x} vs built index {} with byte 0x{:x} ",
+            prebuiltIndex, prebuiltIndex < prebuilt.size() ? prebuilt[prebuiltIndex] : 0,
+            builtIndex, builtIndex < built.size() ? built[builtIndex] : 0);
+    // NOLINTEND(cppcoreguidelines-pro-bounds-constant-array-index)
+}
+
+}  // namespace
+}  // namespace android::surfaceflinger::tests::end2end
diff --git a/services/surfaceflinger/tests/testdata/CropElevationShadowByParent.png b/services/surfaceflinger/tests/testdata/CropElevationShadowByParent.png
new file mode 100644
index 0000000000..95499abb28
Binary files /dev/null and b/services/surfaceflinger/tests/testdata/CropElevationShadowByParent.png differ
diff --git a/services/surfaceflinger/tests/testdata/SetBorderSettings_Cropped.png b/services/surfaceflinger/tests/testdata/SetBorderSettings_Cropped.png
index b52d517299..c082ae37dc 100644
Binary files a/services/surfaceflinger/tests/testdata/SetBorderSettings_Cropped.png and b/services/surfaceflinger/tests/testdata/SetBorderSettings_Cropped.png differ
diff --git a/services/surfaceflinger/tests/testdata/SetBoxShadowSettings_LargeBlur.png b/services/surfaceflinger/tests/testdata/SetBoxShadowSettings_LargeBlur.png
new file mode 100644
index 0000000000..4e56dea027
Binary files /dev/null and b/services/surfaceflinger/tests/testdata/SetBoxShadowSettings_LargeBlur.png differ
diff --git a/services/surfaceflinger/tests/testdata/SetBoxShadowSettings_LayerAlpha.png b/services/surfaceflinger/tests/testdata/SetBoxShadowSettings_LayerAlpha.png
new file mode 100644
index 0000000000..291a8f1255
Binary files /dev/null and b/services/surfaceflinger/tests/testdata/SetBoxShadowSettings_LayerAlpha.png differ
diff --git a/services/surfaceflinger/tests/testdata/SetBoxShadowSettings_Multiple.png b/services/surfaceflinger/tests/testdata/SetBoxShadowSettings_Multiple.png
new file mode 100644
index 0000000000..63bedd519b
Binary files /dev/null and b/services/surfaceflinger/tests/testdata/SetBoxShadowSettings_Multiple.png differ
diff --git a/services/surfaceflinger/tests/testdata/SetBoxShadowSettings_SmallBlur.png b/services/surfaceflinger/tests/testdata/SetBoxShadowSettings_SmallBlur.png
new file mode 100644
index 0000000000..4fdfa39519
Binary files /dev/null and b/services/surfaceflinger/tests/testdata/SetBoxShadowSettings_SmallBlur.png differ
diff --git a/services/surfaceflinger/tests/testdata/SetBoxShadowSettings_Square.png b/services/surfaceflinger/tests/testdata/SetBoxShadowSettings_Square.png
new file mode 100644
index 0000000000..eadf095341
Binary files /dev/null and b/services/surfaceflinger/tests/testdata/SetBoxShadowSettings_Square.png differ
diff --git a/services/surfaceflinger/tests/testdata/Shadow_ROTATION_0.png b/services/surfaceflinger/tests/testdata/Shadow_ROTATION_0.png
new file mode 100644
index 0000000000..8a1e09364a
Binary files /dev/null and b/services/surfaceflinger/tests/testdata/Shadow_ROTATION_0.png differ
diff --git a/services/surfaceflinger/tests/testdata/Shadow_ROTATION_180.png b/services/surfaceflinger/tests/testdata/Shadow_ROTATION_180.png
new file mode 100644
index 0000000000..9d67cf7916
Binary files /dev/null and b/services/surfaceflinger/tests/testdata/Shadow_ROTATION_180.png differ
diff --git a/services/surfaceflinger/tests/testdata/Shadow_ROTATION_270.png b/services/surfaceflinger/tests/testdata/Shadow_ROTATION_270.png
new file mode 100644
index 0000000000..d0b9ce291f
Binary files /dev/null and b/services/surfaceflinger/tests/testdata/Shadow_ROTATION_270.png differ
diff --git a/services/surfaceflinger/tests/testdata/Shadow_ROTATION_90.png b/services/surfaceflinger/tests/testdata/Shadow_ROTATION_90.png
new file mode 100644
index 0000000000..3e0b227c71
Binary files /dev/null and b/services/surfaceflinger/tests/testdata/Shadow_ROTATION_90.png differ
diff --git a/services/surfaceflinger/tests/unittests/Android.bp b/services/surfaceflinger/tests/unittests/Android.bp
index f1c1549dbc..2308951913 100644
--- a/services/surfaceflinger/tests/unittests/Android.bp
+++ b/services/surfaceflinger/tests/unittests/Android.bp
@@ -156,7 +156,7 @@ cc_defaults {
         "libpowermanager",
         "libprocessgroup",
         "libprotobuf-cpp-lite",
-        "libstatslog_surfaceflinger",
+        "libstatslog_surfaceflinger_bootstrap",
         "libsync",
         "libtracing_perfetto",
         "libui",
diff --git a/services/surfaceflinger/tests/unittests/CompositionTest.cpp b/services/surfaceflinger/tests/unittests/CompositionTest.cpp
index c342e1eebb..c70d6312a0 100644
--- a/services/surfaceflinger/tests/unittests/CompositionTest.cpp
+++ b/services/surfaceflinger/tests/unittests/CompositionTest.cpp
@@ -196,10 +196,9 @@ void CompositionTest::captureScreenComposition() {
     mFlinger.commit();
 
     const Rect sourceCrop(0, 0, DEFAULT_DISPLAY_WIDTH, DEFAULT_DISPLAY_HEIGHT);
-    constexpr bool regionSampling = false;
 
-    auto getLayerSnapshotsFn = mFlinger.getLayerSnapshotsForScreenshotsFn(mDisplay->getLayerStack(),
-                                                                          CaptureArgs::UNSET_UID);
+    auto layers =
+            mFlinger.getLayerSnapshotsForScreenshots(mDisplay->getLayerStack(), gui::Uid::INVALID);
 
     const uint32_t usage = GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN |
             GRALLOC_USAGE_HW_RENDER | GRALLOC_USAGE_HW_TEXTURE;
@@ -209,9 +208,9 @@ void CompositionTest::captureScreenComposition() {
                                                                       HAL_PIXEL_FORMAT_RGBA_8888, 1,
                                                                       usage);
 
-    auto future = mFlinger.renderScreenImpl(mDisplay, sourceCrop, ui::Dataspace::V0_SRGB,
-                                            getLayerSnapshotsFn, mCaptureScreenBuffer,
-                                            regionSampling, mDisplay->isSecure(),
+    auto future = mFlinger.renderScreenImpl(mDisplay, sourceCrop, ui::Dataspace::V0_SRGB, layers,
+                                            mCaptureScreenBuffer,
+                                            /* disableBlur */ false, mDisplay->isSecure(),
                                             /* seamlessTransition */ true);
     ASSERT_TRUE(future.valid());
     const auto fenceResult = future.get();
diff --git a/services/surfaceflinger/tests/unittests/DisplayIdentificationTestHelpers.h b/services/surfaceflinger/tests/unittests/DisplayIdentificationTestHelpers.h
index 975bc128c0..c5326df3c3 100644
--- a/services/surfaceflinger/tests/unittests/DisplayIdentificationTestHelpers.h
+++ b/services/surfaceflinger/tests/unittests/DisplayIdentificationTestHelpers.h
@@ -16,16 +16,16 @@
 
 #pragma once
 
-#include <ui/DisplayIdentification.h>
+#include "Display/DisplayIdentification.h"
 
 namespace android {
 
 template <size_t N>
-DisplayIdentificationData asDisplayIdentificationData(const unsigned char (&bytes)[N]) {
-    return DisplayIdentificationData(bytes, bytes + N - 1);
+display::DisplayIdentificationData asDisplayIdentificationData(const unsigned char (&bytes)[N]) {
+    return display::DisplayIdentificationData(bytes, bytes + N - 1);
 }
 
-inline const DisplayIdentificationData& getInternalEdid() {
+inline const display::DisplayIdentificationData& getInternalEdid() {
     static constexpr unsigned char kInternalEdid[] =
             "\x00\xff\xff\xff\xff\xff\xff\x00\x4c\xa3\x42\x31\x00\x00\x00\x00"
             "\x00\x15\x01\x03\x80\x1a\x10\x78\x0a\xd3\xe5\x95\x5c\x60\x90\x27"
@@ -35,11 +35,12 @@ inline const DisplayIdentificationData& getInternalEdid() {
             "\x00\x00\x00\x00\x00\x23\x87\x02\x64\x00\x00\x00\x00\xfe\x00\x53"
             "\x41\x4d\x53\x55\x4e\x47\x0a\x20\x20\x20\x20\x20\x00\x00\x00\xfe"
             "\x00\x31\x32\x31\x41\x54\x31\x31\x2d\x38\x30\x31\x0a\x20\x00\x45";
-    static const DisplayIdentificationData data = asDisplayIdentificationData(kInternalEdid);
+    static const display::DisplayIdentificationData data =
+            asDisplayIdentificationData(kInternalEdid);
     return data;
 }
 
-inline const DisplayIdentificationData& getExternalEdid() {
+inline const display::DisplayIdentificationData& getExternalEdid() {
     static constexpr unsigned char kExternalEdid[] =
             "\x00\xff\xff\xff\xff\xff\xff\x00\x22\xf0\x6c\x28\x01\x01\x01\x01"
             "\x02\x16\x01\x04\xb5\x40\x28\x78\xe2\x8d\x85\xad\x4f\x35\xb1\x25"
@@ -49,11 +50,12 @@ inline const DisplayIdentificationData& getExternalEdid() {
             "\x30\x20\x36\x00\x81\x90\x21\x00\x00\x1a\x00\x00\x00\xfc\x00\x48"
             "\x50\x20\x5a\x52\x33\x30\x77\x0a\x20\x20\x20\x20\x00\x00\x00\xff"
             "\x00\x43\x4e\x34\x32\x30\x32\x31\x33\x37\x51\x0a\x20\x20\x00\x71";
-    static const DisplayIdentificationData data = asDisplayIdentificationData(kExternalEdid);
+    static const display::DisplayIdentificationData data =
+            asDisplayIdentificationData(kExternalEdid);
     return data;
 }
 
-inline const DisplayIdentificationData& getExternalEedid() {
+inline const display::DisplayIdentificationData& getExternalEedid() {
     // Extended EDID with timing extension.
     static constexpr unsigned char kExternalEedid[] =
             "\x00\xff\xff\xff\xff\xff\xff\x00\x4c\x2d\xfe\x08\x00\x00\x00\x00"
@@ -72,8 +74,9 @@ inline const DisplayIdentificationData& getExternalEedid() {
             "\x5a\x00\x00\x00\x18\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
             "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
             "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc6";
-    static const DisplayIdentificationData data = asDisplayIdentificationData(kExternalEedid);
+    static const display::DisplayIdentificationData data =
+            asDisplayIdentificationData(kExternalEedid);
     return data;
 }
 
-} // namespace android
\ No newline at end of file
+} // namespace android
diff --git a/libs/ui/tests/DisplayIdentification_test.cpp b/services/surfaceflinger/tests/unittests/DisplayIdentification_test.cpp
similarity index 82%
rename from libs/ui/tests/DisplayIdentification_test.cpp
rename to services/surfaceflinger/tests/unittests/DisplayIdentification_test.cpp
index 75c71a598e..40d64818af 100644
--- a/libs/ui/tests/DisplayIdentification_test.cpp
+++ b/services/surfaceflinger/tests/unittests/DisplayIdentification_test.cpp
@@ -18,17 +18,18 @@
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Wextra"
 
-#include <functional>
 #include <string_view>
 
 #include <ftl/hash.h>
 #include <gmock/gmock.h>
 #include <gtest/gtest.h>
-#include <ui/DisplayIdentification.h>
+#include <ui/ScreenPartStatus.h>
+
+#include "Display/DisplayIdentification.h"
 
 using ::testing::ElementsAre;
 
-namespace android {
+namespace android::display {
 
 namespace {
 
@@ -129,6 +130,16 @@ const unsigned char kCtlDisplayEdid[] =
         "\x10\x3e\x96\x00\x09\x25\x21\x00\x00\x18\x00\x00\x00\x00\x00\x00"
         "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xf4";
 
+const unsigned char kEdidWithMissingDescriptors[] =
+        "\x00\xff\xff\xff\xff\xff\xff\x00\x09\xe5\x76\x0a\x00\x00\x00\x00"
+        "\x19\x1f\x01\x04\xa5\x1c\x13\x78\x03\xee\x95\xa3\x54\x4c\x99\x26"
+        "\x0f\x50\x54\x00\x00\x00\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01"
+        "\x01\x01\x01\x01\x01\x01\x12\x5c\xd0\x18\x81\xe0\x2d\x50\x30\x20"
+        "\x36\x00\x1d\xbe\x10\x00\x00\x1a\x62\x3d\xd0\x18\x81\xe0\x2d\x50"
+        "\x30\x20\x36\x00\x1d\xbe\x10\x00\x00\x1a\x00\x00\x00\x00\x00\x00"
+        "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02"
+        "\x00\x0d\x28\xff\x0a\x3c\xc8\x0f\x0b\x23\xc8\x00\x00\x00\x00\xcc";
+
 template <size_t N>
 DisplayIdentificationData asDisplayIdentificationData(const unsigned char (&bytes)[N]) {
     return DisplayIdentificationData(bytes, bytes + N - 1);
@@ -170,6 +181,12 @@ const DisplayIdentificationData& getCtlDisplayEdid() {
     return data;
 }
 
+const DisplayIdentificationData& getEdidWithMissingDescriptors() {
+    static const DisplayIdentificationData data =
+            asDisplayIdentificationData(kEdidWithMissingDescriptors);
+    return data;
+}
+
 TEST(DisplayIdentificationTest, isEdid) {
     EXPECT_FALSE(isEdid({}));
 
@@ -327,6 +344,27 @@ TEST(DisplayIdentificationTest, parseEdid) {
     EXPECT_EQ(768, edid->preferredDetailedTimingDescriptor->pixelSizeCount.height);
     EXPECT_EQ(521, edid->preferredDetailedTimingDescriptor->physicalSizeInMm.width);
     EXPECT_EQ(293, edid->preferredDetailedTimingDescriptor->physicalSizeInMm.height);
+
+    edid = parseEdid(getEdidWithMissingDescriptors());
+    ASSERT_TRUE(edid);
+    EXPECT_EQ("", edid->displayName);
+    EXPECT_TRUE(!edid->hashedBlockZeroSerialNumberOpt.has_value());
+    EXPECT_FALSE(edid->hashedDescriptorBlockSerialNumberOpt.has_value());
+    EXPECT_EQ(2533, edid->manufacturerId);
+    EXPECT_STREQ("BOE", edid->pnpId.data());
+    EXPECT_EQ(2678, edid->productId);
+    // modelHash derived from PNP ID and Product ID since descriptors are missing.
+    EXPECT_EQ(hash("BOE2678"), edid->modelHash);
+    EXPECT_EQ(hash("BOE2678"), 565221063);
+    EXPECT_EQ(31, edid->manufactureOrModelYear);
+    EXPECT_EQ(25, edid->manufactureWeek);
+    EXPECT_EQ(28, edid->physicalSizeInCm.width);
+    EXPECT_EQ(19, edid->physicalSizeInCm.height);
+    ASSERT_TRUE(!edid->cea861Block);
+    EXPECT_EQ(2256, edid->preferredDetailedTimingDescriptor->pixelSizeCount.width);
+    EXPECT_EQ(1504, edid->preferredDetailedTimingDescriptor->pixelSizeCount.height);
+    EXPECT_EQ(285, edid->preferredDetailedTimingDescriptor->physicalSizeInMm.width);
+    EXPECT_EQ(190, edid->preferredDetailedTimingDescriptor->physicalSizeInMm.height);
 }
 
 TEST(DisplayIdentificationTest, parseInvalidEdid) {
@@ -361,13 +399,18 @@ TEST(DisplayIdentificationTest, getPnpId) {
 }
 
 TEST(DisplayIdentificationTest, parseDisplayIdentificationData) {
-    const auto primaryInfo = parseDisplayIdentificationData(0, getInternalEdid());
+    const auto primaryInfo = parseDisplayIdentificationData(0, getInternalEdid(),
+                                                            android::ScreenPartStatus::UNSUPPORTED);
     ASSERT_TRUE(primaryInfo);
 
-    const auto secondaryInfo = parseDisplayIdentificationData(1, getExternalEdid());
+    const auto secondaryInfo =
+            parseDisplayIdentificationData(1, getExternalEdid(),
+                                           android::ScreenPartStatus::UNSUPPORTED);
     ASSERT_TRUE(secondaryInfo);
 
-    const auto tertiaryInfo = parseDisplayIdentificationData(2, getExternalEedid());
+    const auto tertiaryInfo =
+            parseDisplayIdentificationData(2, getExternalEedid(),
+                                           android::ScreenPartStatus::UNSUPPORTED);
     ASSERT_TRUE(tertiaryInfo);
 
     // Display IDs should be unique.
@@ -376,6 +419,26 @@ TEST(DisplayIdentificationTest, parseDisplayIdentificationData) {
     EXPECT_EQ(4633127902230889474, tertiaryInfo->id.value);
 }
 
+TEST(DisplayIdentificationTest, resolveDisplayIdCollision) {
+    // 1280000 is a value such that when ORd with uint8_t decimal values, it'll show it clearly in
+    // its 3 LSB digits. So 1280000 | 12 == 1280012.
+    const auto id = PhysicalDisplayId::fromValue(1280000u);
+    constexpr uint8_t kPort = 1;
+
+    // ID should be resolved by adding port 1 to the LSBs of the ID, resulting in 1280001.
+    const auto resolvedId = resolveDisplayIdCollision(id, kPort);
+    EXPECT_NE(resolvedId, id);
+    EXPECT_EQ(1280001, resolvedId.value);
+
+    // Since the 8 LSBs of resolvedId already match the given port 1, it should be resolved by
+    // inverting the port value. The inversion of unit8_t 1 is 11111110b, which is 254 - so the
+    // expected ID is 1280254u.
+    const auto resolvedIdWithInvertedPort = resolveDisplayIdCollision(resolvedId, kPort);
+    EXPECT_NE(resolvedIdWithInvertedPort, resolvedId);
+    EXPECT_NE(resolvedIdWithInvertedPort, id);
+    EXPECT_EQ(1280254u, resolvedIdWithInvertedPort.value);
+}
+
 TEST(DisplayIdentificationTest, generateEdidDisplayId) {
     const auto firstExternalDisplayEdidOpt = parseEdid(getExternalEdid());
     ASSERT_TRUE(firstExternalDisplayEdidOpt);
@@ -398,7 +461,9 @@ TEST(DisplayIdentificationTest, deviceProductInfo) {
     using ModelYear = DeviceProductInfo::ModelYear;
 
     {
-        const auto displayIdInfo = parseDisplayIdentificationData(0, getInternalEdid());
+        const auto displayIdInfo =
+                parseDisplayIdentificationData(0, getInternalEdid(),
+                                               android::ScreenPartStatus::UNSUPPORTED);
         ASSERT_TRUE(displayIdInfo);
         ASSERT_TRUE(displayIdInfo->deviceProductInfo);
         const auto& info = *displayIdInfo->deviceProductInfo;
@@ -410,7 +475,9 @@ TEST(DisplayIdentificationTest, deviceProductInfo) {
         EXPECT_TRUE(info.relativeAddress.empty());
     }
     {
-        const auto displayIdInfo = parseDisplayIdentificationData(0, getExternalEdid());
+        const auto displayIdInfo =
+                parseDisplayIdentificationData(0, getExternalEdid(),
+                                               android::ScreenPartStatus::UNSUPPORTED);
         ASSERT_TRUE(displayIdInfo);
         ASSERT_TRUE(displayIdInfo->deviceProductInfo);
         const auto& info = *displayIdInfo->deviceProductInfo;
@@ -424,7 +491,9 @@ TEST(DisplayIdentificationTest, deviceProductInfo) {
         EXPECT_TRUE(info.relativeAddress.empty());
     }
     {
-        const auto displayIdInfo = parseDisplayIdentificationData(0, getExternalEedid());
+        const auto displayIdInfo =
+                parseDisplayIdentificationData(0, getExternalEedid(),
+                                               android::ScreenPartStatus::UNSUPPORTED);
         ASSERT_TRUE(displayIdInfo);
         ASSERT_TRUE(displayIdInfo->deviceProductInfo);
         const auto& info = *displayIdInfo->deviceProductInfo;
@@ -438,7 +507,9 @@ TEST(DisplayIdentificationTest, deviceProductInfo) {
         EXPECT_THAT(info.relativeAddress, ElementsAre(2, 0, 0, 0));
     }
     {
-        const auto displayIdInfo = parseDisplayIdentificationData(0, getPanasonicTvEdid());
+        const auto displayIdInfo =
+                parseDisplayIdentificationData(0, getPanasonicTvEdid(),
+                                               android::ScreenPartStatus::UNSUPPORTED);
         ASSERT_TRUE(displayIdInfo);
         ASSERT_TRUE(displayIdInfo->deviceProductInfo);
         const auto& info = *displayIdInfo->deviceProductInfo;
@@ -451,7 +522,9 @@ TEST(DisplayIdentificationTest, deviceProductInfo) {
         EXPECT_THAT(info.relativeAddress, ElementsAre(2, 0, 0, 0));
     }
     {
-        const auto displayIdInfo = parseDisplayIdentificationData(0, getHisenseTvEdid());
+        const auto displayIdInfo =
+                parseDisplayIdentificationData(0, getHisenseTvEdid(),
+                                               android::ScreenPartStatus::UNSUPPORTED);
         ASSERT_TRUE(displayIdInfo);
         ASSERT_TRUE(displayIdInfo->deviceProductInfo);
         const auto& info = *displayIdInfo->deviceProductInfo;
@@ -465,7 +538,9 @@ TEST(DisplayIdentificationTest, deviceProductInfo) {
         EXPECT_THAT(info.relativeAddress, ElementsAre(1, 2, 3, 4));
     }
     {
-        const auto displayIdInfo = parseDisplayIdentificationData(0, getCtlDisplayEdid());
+        const auto displayIdInfo =
+                parseDisplayIdentificationData(0, getCtlDisplayEdid(),
+                                               android::ScreenPartStatus::UNSUPPORTED);
         ASSERT_TRUE(displayIdInfo);
         ASSERT_TRUE(displayIdInfo->deviceProductInfo);
         const auto& info = *displayIdInfo->deviceProductInfo;
@@ -478,7 +553,7 @@ TEST(DisplayIdentificationTest, deviceProductInfo) {
     }
 }
 
-} // namespace android
+} // namespace android::display
 
 // TODO(b/129481165): remove the #pragma below and fix conversion issues
 #pragma clang diagnostic pop // ignored "-Wextra"
diff --git a/services/surfaceflinger/tests/unittests/DisplayModeControllerTest.cpp b/services/surfaceflinger/tests/unittests/DisplayModeControllerTest.cpp
index 84dc5fc4b7..8fd362e598 100644
--- a/services/surfaceflinger/tests/unittests/DisplayModeControllerTest.cpp
+++ b/services/surfaceflinger/tests/unittests/DisplayModeControllerTest.cpp
@@ -30,6 +30,7 @@
 #include <ftl/fake_guard.h>
 #include <gmock/gmock.h>
 #include <gtest/gtest.h>
+#include <ui/ScreenPartStatus.h>
 
 #define EXPECT_DISPLAY_MODE_REQUEST(expected, requestOpt)                               \
     ASSERT_TRUE(requestOpt);                                                            \
@@ -58,7 +59,7 @@ public:
                 });
 
         constexpr uint8_t kPort = 111;
-        EXPECT_CALL(*mComposerHal, getDisplayIdentificationData(kHwcDisplayId, _, _))
+        EXPECT_CALL(*mComposerHal, getDisplayIdentificationData(kHwcDisplayId, _, _, _))
                 .WillOnce(DoAll(SetArgPointee<1>(kPort), SetArgPointee<2>(getInternalEdid()),
                                 Return(hal::Error::NONE)));
 
@@ -72,7 +73,9 @@ public:
         ASSERT_TRUE(infoOpt);
 
         mDisplayId = infoOpt->id;
-        mDisplaySnapshotOpt.emplace(mDisplayId, infoOpt->port, ui::DisplayConnectionType::Internal,
+        mDisplaySnapshotOpt.emplace(mDisplayId, infoOpt->port,
+                                    android::ScreenPartStatus::UNSUPPORTED,
+                                    ui::DisplayConnectionType::Internal,
                                     makeModes(kMode60, kMode90, kMode120), ui::ColorModes{},
                                     std::nullopt);
 
diff --git a/services/surfaceflinger/tests/unittests/DisplayTransactionTestHelpers.h b/services/surfaceflinger/tests/unittests/DisplayTransactionTestHelpers.h
index 75182e5fbb..99675bd5ec 100644
--- a/services/surfaceflinger/tests/unittests/DisplayTransactionTestHelpers.h
+++ b/services/surfaceflinger/tests/unittests/DisplayTransactionTestHelpers.h
@@ -22,6 +22,7 @@
 #pragma clang diagnostic ignored "-Wextra"
 
 #include <type_traits>
+#include "Display/DisplayIdentification.h"
 #include "DisplayIdentificationTestHelpers.h"
 
 #include <binder/IPCThreadState.h>
@@ -189,10 +190,10 @@ struct DisplayIdGetter<PhysicalDisplayIdType<PhysicalDisplay>> {
                                                        ? LEGACY_DISPLAY_TYPE_PRIMARY
                                                        : LEGACY_DISPLAY_TYPE_EXTERNAL);
         }
-
         const auto info =
-                parseDisplayIdentificationData(PhysicalDisplay::PORT,
-                                               PhysicalDisplay::GET_IDENTIFICATION_DATA());
+                display::parseDisplayIdentificationData(PhysicalDisplay::PORT,
+                                                        PhysicalDisplay::GET_IDENTIFICATION_DATA(),
+                                                        android::ScreenPartStatus::UNSUPPORTED);
         return info ? info->id : PhysicalDisplayId::fromPort(PhysicalDisplay::PORT);
     }
 };
@@ -491,12 +492,12 @@ struct HwcDisplayVariant {
         setupHwcGetConfigsCallExpectations(test);
 
         if (PhysicalDisplay::HAS_IDENTIFICATION_DATA) {
-            EXPECT_CALL(*test->mComposer, getDisplayIdentificationData(HWC_DISPLAY_ID, _, _))
+            EXPECT_CALL(*test->mComposer, getDisplayIdentificationData(HWC_DISPLAY_ID, _, _, _))
                     .WillOnce(DoAll(SetArgPointee<1>(PhysicalDisplay::PORT),
                                     SetArgPointee<2>(PhysicalDisplay::GET_IDENTIFICATION_DATA()),
                                     Return(Error::NONE)));
         } else {
-            EXPECT_CALL(*test->mComposer, getDisplayIdentificationData(HWC_DISPLAY_ID, _, _))
+            EXPECT_CALL(*test->mComposer, getDisplayIdentificationData(HWC_DISPLAY_ID, _, _, _))
                     .WillOnce(Return(Error::UNSUPPORTED));
         }
     }
diff --git a/services/surfaceflinger/tests/unittests/DualDisplayTransactionTest.h b/services/surfaceflinger/tests/unittests/DualDisplayTransactionTest.h
index edcb639f82..3120d3050d 100644
--- a/services/surfaceflinger/tests/unittests/DualDisplayTransactionTest.h
+++ b/services/surfaceflinger/tests/unittests/DualDisplayTransactionTest.h
@@ -27,7 +27,7 @@ struct DualDisplayTransactionTest : DisplayTransactionTest {
     DualDisplayTransactionTest() : DisplayTransactionTest(kWithMockScheduler) {}
 
     void SetUp() override {
-        injectMockScheduler(kInnerDisplayId);
+        injectMockScheduler(getInnerDisplayId());
 
         {
             InnerDisplayVariant::injectHwcDisplay<kInnerDisplayPowerMode, kExpectSetPowerModeOnce>(
@@ -48,10 +48,17 @@ struct DualDisplayTransactionTest : DisplayTransactionTest {
         }
     }
 
-    static inline PhysicalDisplayId kInnerDisplayId =
-            asPhysicalDisplayId(InnerDisplayVariant::DISPLAY_ID::get()).value();
-    static inline PhysicalDisplayId kOuterDisplayId =
-            asPhysicalDisplayId(OuterDisplayVariant::DISPLAY_ID::get()).value();
+    static PhysicalDisplayId getInnerDisplayId() {
+        static PhysicalDisplayId kInnerDisplayId =
+                asPhysicalDisplayId(InnerDisplayVariant::DISPLAY_ID::get()).value();
+        return kInnerDisplayId;
+    }
+
+    static PhysicalDisplayId getOuterDisplayId() {
+        static PhysicalDisplayId kOuterDisplayId =
+                asPhysicalDisplayId(OuterDisplayVariant::DISPLAY_ID::get()).value();
+        return kOuterDisplayId;
+    }
 
     sp<DisplayDevice> mInnerDisplay, mOuterDisplay;
 };
diff --git a/services/surfaceflinger/tests/unittests/EventThreadTest.cpp b/services/surfaceflinger/tests/unittests/EventThreadTest.cpp
index 76e01a6e7d..f89bde1f5d 100644
--- a/services/surfaceflinger/tests/unittests/EventThreadTest.cpp
+++ b/services/surfaceflinger/tests/unittests/EventThreadTest.cpp
@@ -21,20 +21,24 @@
 #undef LOG_TAG
 #define LOG_TAG "LibSurfaceFlingerUnittests"
 
+#include <common/test/FlagUtils.h>
 #include <gmock/gmock.h>
 #include <gtest/gtest.h>
 #include <log/log.h>
 #include <scheduler/VsyncConfig.h>
 #include <utils/Errors.h>
 
+#include <com_android_graphics_surfaceflinger_flags.h>
+
 #include "AsyncCallRecorder.h"
 #include "DisplayHardware/DisplayMode.h"
-#include "FrameTimeline/FrameTimeline.h"
 #include "Scheduler/EventThread.h"
+#include "Scheduler/FrameTimeline.h"
 #include "mock/MockVSyncDispatch.h"
 #include "mock/MockVSyncTracker.h"
 #include "mock/MockVsyncController.h"
 
+using namespace com::android::graphics::surfaceflinger;
 using namespace std::chrono_literals;
 using namespace std::placeholders;
 
@@ -62,8 +66,34 @@ constexpr int HDCP_V2 = 3;
 
 class EventThreadTest : public testing::Test, public IEventThreadCallback {
 protected:
-    static constexpr std::chrono::nanoseconds kWorkDuration = 0ms;
-    static constexpr std::chrono::nanoseconds kReadyDuration = 3ms;
+    using nanos = std::chrono::nanoseconds;
+    static constexpr nanos kWorkDuration = 0ms;
+    static constexpr nanos kReadyDuration = 3ms;
+    enum {
+        SF_OFFSET_LATE,
+        APP_OFFSET_LATE,
+        SF_DURATION_LATE,
+        APP_DURATION_LATE,
+        SF_OFFSET_EARLY,
+        APP_OFFSET_EARLY,
+        SF_DURATION_EARLY,
+        APP_DURATION_EARLY,
+        SF_OFFSET_EARLY_GPU,
+        APP_OFFSET_EARLY_GPU,
+        SF_DURATION_EARLY_GPU,
+        APP_DURATION_EARLY_GPU,
+        HWC_MIN_WORK_DURATION,
+    };
+
+    const scheduler::VsyncConfig kEarly{SF_OFFSET_EARLY, APP_OFFSET_EARLY, nanos(SF_DURATION_LATE),
+                                        nanos(APP_DURATION_LATE)};
+    const scheduler::VsyncConfig kEarlyGpu{SF_OFFSET_EARLY_GPU, APP_OFFSET_EARLY_GPU,
+                                           nanos(SF_DURATION_EARLY), nanos(APP_DURATION_EARLY)};
+    const scheduler::VsyncConfig kLate{SF_OFFSET_LATE, APP_OFFSET_LATE,
+                                       nanos(SF_DURATION_EARLY_GPU), nanos(APP_DURATION_EARLY_GPU)};
+
+    const scheduler::VsyncConfigSet mOffsets = {kEarly, kEarlyGpu, kLate,
+                                                nanos(HWC_MIN_WORK_DURATION)};
 
     class MockEventThreadConnection : public EventThreadConnection {
     public:
@@ -93,8 +123,7 @@ protected:
                                                    uid_t ownerUid = mConnectionUid);
 
     void expectVSyncCallbackScheduleReceived(bool expectState);
-    void expectVSyncSetDurationCallReceived(std::chrono::nanoseconds expectedDuration,
-                                            std::chrono::nanoseconds expectedReadyDuration);
+    void expectVSyncSetDurationCallReceived(nanos expectedDuration, nanos expectedReadyDuration);
     void expectVsyncEventReceivedByConnection(const char* name,
                                               ConnectionEventRecorder& connectionEventRecorder,
                                               nsecs_t expectedTimestamp, unsigned expectedCount);
@@ -106,11 +135,15 @@ protected:
                                                 bool expectedConnected);
     void expectConfigChangedEventReceivedByConnection(PhysicalDisplayId expectedDisplayId,
                                                       int32_t expectedConfigId,
-                                                      nsecs_t expectedVsyncPeriod);
+                                                      nsecs_t expectedVsyncPeriod,
+                                                      nsecs_t expectedAppOffset,
+                                                      nsecs_t expectedPresentationDeadline);
     void expectThrottleVsyncReceived(nsecs_t expectedTimestamp, uid_t);
     void expectOnExpectedPresentTimePosted(nsecs_t expectedPresentTime);
-    void expectUidFrameRateMappingEventReceivedByConnection(PhysicalDisplayId expectedDisplayId,
-                                                            std::vector<FrameRateOverride>);
+    void expectUidFrameRateMappingEventReceivedByConnection(
+            PhysicalDisplayId expectedDisplayId, std::vector<FrameRateOverride>,
+            DisplayEventType expectedEventType =
+                    DisplayEventType::DISPLAY_EVENT_FRAME_RATE_OVERRIDE_FLUSH);
 
     void onVSyncEvent(nsecs_t timestamp, nsecs_t expectedPresentationTime,
                       nsecs_t deadlineTimestamp) {
@@ -143,9 +176,9 @@ protected:
     std::unique_ptr<impl::EventThread> mThread;
     sp<MockEventThreadConnection> mConnection;
     sp<MockEventThreadConnection> mThrottledConnection;
-    std::unique_ptr<frametimeline::impl::TokenManager> mTokenManager;
+    std::unique_ptr<scheduler::impl::TokenManager> mTokenManager;
 
-    std::chrono::nanoseconds mVsyncPeriod;
+    nanos mVsyncPeriod;
 
     static constexpr uid_t mConnectionUid = 443;
     static constexpr uid_t mThrottledConnectionUid = 177;
@@ -200,7 +233,7 @@ void EventThreadTest::onExpectedPresentTimePosted(TimePoint expectedPresentTime)
 }
 
 void EventThreadTest::setupEventThread() {
-    mTokenManager = std::make_unique<frametimeline::impl::TokenManager>();
+    mTokenManager = std::make_unique<scheduler::impl::TokenManager>();
     mThread = std::make_unique<impl::EventThread>("EventThreadTest", mVsyncSchedule,
                                                   mTokenManager.get(), *this, kWorkDuration,
                                                   kReadyDuration);
@@ -238,8 +271,8 @@ void EventThreadTest::expectVSyncCallbackScheduleReceived(bool expectState) {
     }
 }
 
-void EventThreadTest::expectVSyncSetDurationCallReceived(
-        std::chrono::nanoseconds expectedDuration, std::chrono::nanoseconds expectedReadyDuration) {
+void EventThreadTest::expectVSyncSetDurationCallReceived(nanos expectedDuration,
+                                                         nanos expectedReadyDuration) {
     auto args = mVSyncCallbackUpdateRecorder.waitForCall();
     ASSERT_TRUE(args.has_value());
     EXPECT_EQ(expectedDuration.count(), std::get<1>(args.value()).workDuration);
@@ -346,8 +379,8 @@ void EventThreadTest::expectHotplugEventReceivedByConnection(PhysicalDisplayId e
 }
 
 void EventThreadTest::expectConfigChangedEventReceivedByConnection(
-        PhysicalDisplayId expectedDisplayId, int32_t expectedConfigId,
-        nsecs_t expectedVsyncPeriod) {
+        PhysicalDisplayId expectedDisplayId, int32_t expectedConfigId, nsecs_t expectedVsyncPeriod,
+        nsecs_t expectedAppOffset, nsecs_t expectedPresentationDeadline) {
     auto args = mConnectionEventCallRecorder.waitForCall();
     ASSERT_TRUE(args.has_value());
     const auto& event = std::get<0>(args.value());
@@ -355,10 +388,13 @@ void EventThreadTest::expectConfigChangedEventReceivedByConnection(
     EXPECT_EQ(expectedDisplayId, event.header.displayId);
     EXPECT_EQ(expectedConfigId, event.modeChange.modeId);
     EXPECT_EQ(expectedVsyncPeriod, event.modeChange.vsyncPeriod);
+    EXPECT_EQ(expectedAppOffset, event.modeChange.appVsyncOffset);
+    EXPECT_EQ(expectedPresentationDeadline, event.modeChange.presentationDeadline);
 }
 
 void EventThreadTest::expectUidFrameRateMappingEventReceivedByConnection(
-        PhysicalDisplayId expectedDisplayId, std::vector<FrameRateOverride> expectedOverrides) {
+        PhysicalDisplayId expectedDisplayId, std::vector<FrameRateOverride> expectedOverrides,
+        DisplayEventType expectedEventType) {
     for (const auto [uid, frameRateHz] : expectedOverrides) {
         auto args = mConnectionEventCallRecorder.waitForCall();
         ASSERT_TRUE(args.has_value());
@@ -372,7 +408,7 @@ void EventThreadTest::expectUidFrameRateMappingEventReceivedByConnection(
     auto args = mConnectionEventCallRecorder.waitForCall();
     ASSERT_TRUE(args.has_value());
     const auto& event = std::get<0>(args.value());
-    EXPECT_EQ(DisplayEventType::DISPLAY_EVENT_FRAME_RATE_OVERRIDE_FLUSH, event.header.type);
+    EXPECT_EQ(expectedEventType, event.header.type);
     EXPECT_EQ(expectedDisplayId, event.header.displayId);
 }
 
@@ -737,8 +773,10 @@ TEST_F(EventThreadTest, postConfigChangedPrimary) {
                               .build();
     const Fps fps = mode->getPeakFps() / 2;
 
-    mThread->onModeChanged({fps, ftl::as_non_null(mode)});
-    expectConfigChangedEventReceivedByConnection(INTERNAL_DISPLAY_ID, 7, fps.getPeriodNsecs());
+    mThread->onModeChanged({fps, ftl::as_non_null(mode)}, mOffsets);
+    expectConfigChangedEventReceivedByConnection(INTERNAL_DISPLAY_ID, 7, fps.getPeriodNsecs(),
+                                                 APP_OFFSET_LATE,
+                                                 /*presentationDeadline*/ 34333332);
 }
 
 TEST_F(EventThreadTest, postConfigChangedExternal) {
@@ -751,8 +789,10 @@ TEST_F(EventThreadTest, postConfigChangedExternal) {
                               .build();
     const Fps fps = mode->getPeakFps() / 2;
 
-    mThread->onModeChanged({fps, ftl::as_non_null(mode)});
-    expectConfigChangedEventReceivedByConnection(EXTERNAL_DISPLAY_ID, 5, fps.getPeriodNsecs());
+    mThread->onModeChanged({fps, ftl::as_non_null(mode)}, mOffsets);
+    expectConfigChangedEventReceivedByConnection(EXTERNAL_DISPLAY_ID, 5, fps.getPeriodNsecs(),
+                                                 APP_OFFSET_LATE,
+                                                 /*presentationDeadline*/ 34333332);
 }
 
 TEST_F(EventThreadTest, postConfigChangedPrimary64bit) {
@@ -764,8 +804,10 @@ TEST_F(EventThreadTest, postConfigChangedPrimary64bit) {
                               .setVsyncPeriod(16666666)
                               .build();
     const Fps fps = mode->getPeakFps() / 2;
-    mThread->onModeChanged({fps, ftl::as_non_null(mode)});
-    expectConfigChangedEventReceivedByConnection(DISPLAY_ID_64BIT, 7, fps.getPeriodNsecs());
+    mThread->onModeChanged({fps, ftl::as_non_null(mode)}, mOffsets);
+    expectConfigChangedEventReceivedByConnection(DISPLAY_ID_64BIT, 7, fps.getPeriodNsecs(),
+                                                 APP_OFFSET_LATE,
+                                                 /*presentationDeadline*/ 34333332);
 }
 
 TEST_F(EventThreadTest, suppressConfigChanged) {
@@ -782,8 +824,10 @@ TEST_F(EventThreadTest, suppressConfigChanged) {
                               .build();
     const Fps fps = mode->getPeakFps() / 2;
 
-    mThread->onModeChanged({fps, ftl::as_non_null(mode)});
-    expectConfigChangedEventReceivedByConnection(INTERNAL_DISPLAY_ID, 9, fps.getPeriodNsecs());
+    mThread->onModeChanged({fps, ftl::as_non_null(mode)}, mOffsets);
+    expectConfigChangedEventReceivedByConnection(INTERNAL_DISPLAY_ID, 9, fps.getPeriodNsecs(),
+                                                 APP_OFFSET_LATE,
+                                                 /*presentationDeadline*/ 34333332);
 
     auto args = suppressConnectionEventRecorder.waitForCall();
     ASSERT_FALSE(args.has_value());
@@ -868,6 +912,28 @@ TEST_F(EventThreadTest, postHcpLevelsChanged) {
     EXPECT_EQ(HDCP_V2, event.hdcpLevelsChange.maxLevel);
 }
 
+TEST_F(EventThreadTest, postOnModeChangedAndFrameRateOverride) {
+    SET_FLAG_FOR_TEST(flags::unify_refresh_rate_callbacks, true);
+    setupEventThread();
+    const std::vector<FrameRateOverride> overrides = {
+            {.uid = 1, .frameRateHz = 20},
+            {.uid = 3, .frameRateHz = 40},
+            {.uid = 5, .frameRateHz = 60},
+    };
+    const auto mode = DisplayMode::Builder(hal::HWConfigId(0))
+                              .setPhysicalDisplayId(EXTERNAL_DISPLAY_ID)
+                              .setId(DisplayModeId(5))
+                              .setVsyncPeriod(16666666)
+                              .build();
+    const Fps fps = mode->getPeakFps() / 2;
+
+    mThread->onModeAndFrameRateOverridesChanged(EXTERNAL_DISPLAY_ID, {fps, ftl::as_non_null(mode)},
+                                                overrides, mOffsets);
+    expectUidFrameRateMappingEventReceivedByConnection(
+            EXTERNAL_DISPLAY_ID, overrides,
+            DisplayEventType::DISPLAY_EVENT_MODE_AND_FRAME_RATE_CHANGE);
+}
+
 } // namespace
 } // namespace android
 
diff --git a/services/surfaceflinger/tests/unittests/FlagManagerTest.cpp b/services/surfaceflinger/tests/unittests/FlagManagerTest.cpp
index c6da1a1a79..702fe3d01b 100644
--- a/services/surfaceflinger/tests/unittests/FlagManagerTest.cpp
+++ b/services/surfaceflinger/tests/unittests/FlagManagerTest.cpp
@@ -33,7 +33,7 @@ using testing::Return;
 
 class TestableFlagManager : public FlagManager {
 public:
-    TestableFlagManager() : FlagManager(ConstructorTag{}) { markBootCompleted(); }
+    TestableFlagManager() { markBootCompleted(); }
     ~TestableFlagManager() = default;
 
     MOCK_METHOD(std::optional<bool>, getBoolProperty, (const char*), (const, override));
@@ -62,11 +62,6 @@ TEST_F(FlagManagerTest, isSingleton) {
     EXPECT_EQ(&FlagManager::getInstance(), &FlagManager::getInstance());
 }
 
-TEST_F(FlagManagerTest, legacyCreashesIfQueriedBeforeBoot) {
-    mFlagManager.markBootIncomplete();
-    EXPECT_DEATH(FlagManager::getInstance().test_flag(), "");
-}
-
 TEST_F(FlagManagerTest, legacyReturnsOverride) {
     EXPECT_CALL(mFlagManager, getBoolProperty).WillOnce(Return(true));
     EXPECT_EQ(true, mFlagManager.test_flag());
@@ -99,15 +94,6 @@ TEST_F(FlagManagerTest, returnsOverrideTrue) {
     EXPECT_TRUE(mFlagManager.refresh_rate_overlay_on_external_display());
 }
 
-TEST_F(FlagManagerTest, returnsOverrideReadonly) {
-    SET_FLAG_FOR_TEST(flags::add_sf_skipped_frames_to_trace, false);
-
-    // This is stored in a static variable, so this test depends on the fact
-    // that this flag has not been read in this process.
-    EXPECT_CALL(mFlagManager, getBoolProperty).WillOnce(Return(true));
-    EXPECT_TRUE(mFlagManager.add_sf_skipped_frames_to_trace());
-}
-
 // disabling this test since we need to use a unique flag for this test,
 // but we only one server flag currently. Re-enable once we have a new flag
 // and change this test to use a unique flag.
@@ -156,13 +142,13 @@ TEST_F(FlagManagerTest, readonlyReturnsValue) {
     EXPECT_CALL(mFlagManager, getBoolProperty).WillRepeatedly(Return(std::nullopt));
 
     {
-        SET_FLAG_FOR_TEST(flags::misc1, true);
-        EXPECT_EQ(true, mFlagManager.misc1());
+        SET_FLAG_FOR_TEST(flags::hdcp_level_hal, true);
+        EXPECT_EQ(true, mFlagManager.hdcp_level_hal());
     }
 
     {
-        SET_FLAG_FOR_TEST(flags::misc1, false);
-        EXPECT_EQ(false, mFlagManager.misc1());
+        SET_FLAG_FOR_TEST(flags::hdcp_level_hal, false);
+        EXPECT_EQ(false, mFlagManager.hdcp_level_hal());
     }
 }
 
diff --git a/services/surfaceflinger/tests/unittests/FpsReporterTest.cpp b/services/surfaceflinger/tests/unittests/FpsReporterTest.cpp
index 9e8e306621..43535de302 100644
--- a/services/surfaceflinger/tests/unittests/FpsReporterTest.cpp
+++ b/services/surfaceflinger/tests/unittests/FpsReporterTest.cpp
@@ -78,8 +78,6 @@ protected:
     static constexpr uint32_t LAYER_FLAGS = 0;
     static constexpr int32_t PRIORITY_UNSET = -1;
 
-    sp<Layer> createBufferStateLayer(LayerMetadata metadata);
-
     LayerCreationArgs createArgs(uint32_t id, bool canBeRoot, uint32_t parentId,
                                  LayerMetadata metadata);
 
diff --git a/services/surfaceflinger/tests/unittests/FrameTimelineTest.cpp b/services/surfaceflinger/tests/unittests/FrameTimelineTest.cpp
index 54f225901e..d8ebecaa98 100644
--- a/services/surfaceflinger/tests/unittests/FrameTimelineTest.cpp
+++ b/services/surfaceflinger/tests/unittests/FrameTimelineTest.cpp
@@ -23,7 +23,7 @@
 #undef LOG_TAG
 #define LOG_TAG "LibSurfaceFlingerUnittests"
 
-#include <FrameTimeline/FrameTimeline.h>
+#include <Scheduler/FrameTimeline.h>
 #include <gtest/gtest.h>
 #include <log/log.h>
 #include <perfetto/trace/trace.pb.h>
@@ -46,7 +46,7 @@ using ProtoJankType = perfetto::protos::FrameTimelineEvent_JankType;
 using ProtoJankSeverityType = perfetto::protos::FrameTimelineEvent_JankSeverityType;
 using ProtoPredictionType = perfetto::protos::FrameTimelineEvent_PredictionType;
 
-namespace android::frametimeline {
+namespace android::scheduler {
 
 static const std::string sLayerNameOne = "layer1";
 static const std::string sLayerNameTwo = "layer2";
@@ -1273,9 +1273,6 @@ TEST_F(FrameTimelineTest, traceDisplayFrameNoSkipped) {
 }
 
 TEST_F(FrameTimelineTest, traceDisplayFrameSkipped) {
-    SET_FLAG_FOR_TEST(com::android::graphics::surfaceflinger::flags::add_sf_skipped_frames_to_trace,
-                      true);
-
     // setup 2 display frames
     // DF 1: [22,40] -> [5, 40]
     // DF  : [36, 70] (Skipped one, added by the trace)
@@ -2873,4 +2870,4 @@ TEST_F(FrameTimelineTest, surfaceFrameRenderRateUsingAppFrameRate) {
 
     EXPECT_EQ(surfaceFrame->getRenderRate().getPeriodNsecs(), 30);
 }
-} // namespace android::frametimeline
+} // namespace android::scheduler
diff --git a/services/surfaceflinger/tests/unittests/ActiveDisplayRotationFlagsTest.cpp b/services/surfaceflinger/tests/unittests/FrontInternalDisplayRotationFlagsTest.cpp
similarity index 72%
rename from services/surfaceflinger/tests/unittests/ActiveDisplayRotationFlagsTest.cpp
rename to services/surfaceflinger/tests/unittests/FrontInternalDisplayRotationFlagsTest.cpp
index b17b529793..3a23f3afaa 100644
--- a/services/surfaceflinger/tests/unittests/ActiveDisplayRotationFlagsTest.cpp
+++ b/services/surfaceflinger/tests/unittests/FrontInternalDisplayRotationFlagsTest.cpp
@@ -25,7 +25,7 @@
 namespace android {
 namespace {
 
-struct ActiveDisplayRotationFlagsTest
+struct FrontInternalDisplayRotationFlagsTest
       : DualDisplayTransactionTest<hal::PowerMode::ON, hal::PowerMode::OFF> {
     void SetUp() override {
         DualDisplayTransactionTest::SetUp();
@@ -35,42 +35,44 @@ struct ActiveDisplayRotationFlagsTest
         // flags so we can restore them on teardown. This isn't perfect - the
         // phone may have been rotated during the test, so we're restoring the
         // wrong flags. But if the phone is rotated, this may also fail the test.
-        mOldRotationFlags = mFlinger.mutableActiveDisplayRotationFlags();
+        mOldRotationFlags = mFlinger.mutableFrontInternalDisplayRotationFlags();
 
         // Reset to the expected default state.
-        mFlinger.mutableActiveDisplayRotationFlags() = ui::Transform::ROT_0;
+        mFlinger.mutableFrontInternalDisplayRotationFlags() = ui::Transform::ROT_0;
     }
 
-    void TearDown() override { mFlinger.mutableActiveDisplayRotationFlags() = mOldRotationFlags; }
+    void TearDown() override {
+        mFlinger.mutableFrontInternalDisplayRotationFlags() = mOldRotationFlags;
+    }
 
     ui::Transform::RotationFlags mOldRotationFlags;
 };
 
-TEST_F(ActiveDisplayRotationFlagsTest, defaultRotation) {
-    ASSERT_EQ(ui::Transform::ROT_0, SurfaceFlinger::getActiveDisplayRotationFlags());
+TEST_F(FrontInternalDisplayRotationFlagsTest, defaultRotation) {
+    ASSERT_EQ(ui::Transform::ROT_0, SurfaceFlinger::getFrontInternalDisplayRotationFlags());
 }
 
-TEST_F(ActiveDisplayRotationFlagsTest, rotate90) {
+TEST_F(FrontInternalDisplayRotationFlagsTest, rotateFrontDisplay90) {
     auto displayToken = mInnerDisplay->getDisplayToken().promote();
     mFlinger.mutableDrawingState().displays.editValueFor(displayToken).orientation = ui::ROTATION_0;
     mFlinger.mutableCurrentState().displays.editValueFor(displayToken).orientation =
             ui::ROTATION_90;
 
     mFlinger.commitTransactionsLocked(eDisplayTransactionNeeded);
-    ASSERT_EQ(ui::Transform::ROT_90, SurfaceFlinger::getActiveDisplayRotationFlags());
+    ASSERT_EQ(ui::Transform::ROT_90, SurfaceFlinger::getFrontInternalDisplayRotationFlags());
 }
 
-TEST_F(ActiveDisplayRotationFlagsTest, rotate90inactive) {
+TEST_F(FrontInternalDisplayRotationFlagsTest, rotateRearDisplay90) {
     auto displayToken = mOuterDisplay->getDisplayToken().promote();
     mFlinger.mutableDrawingState().displays.editValueFor(displayToken).orientation = ui::ROTATION_0;
     mFlinger.mutableCurrentState().displays.editValueFor(displayToken).orientation =
             ui::ROTATION_90;
 
     mFlinger.commitTransactionsLocked(eDisplayTransactionNeeded);
-    ASSERT_EQ(ui::Transform::ROT_0, SurfaceFlinger::getActiveDisplayRotationFlags());
+    ASSERT_EQ(ui::Transform::ROT_0, SurfaceFlinger::getFrontInternalDisplayRotationFlags());
 }
 
-TEST_F(ActiveDisplayRotationFlagsTest, rotateBothInnerActive) {
+TEST_F(FrontInternalDisplayRotationFlagsTest, rotateBothWhenInnerIsFront) {
     auto displayToken = mInnerDisplay->getDisplayToken().promote();
     mFlinger.mutableDrawingState().displays.editValueFor(displayToken).orientation = ui::ROTATION_0;
     mFlinger.mutableCurrentState().displays.editValueFor(displayToken).orientation =
@@ -82,11 +84,11 @@ TEST_F(ActiveDisplayRotationFlagsTest, rotateBothInnerActive) {
             ui::ROTATION_270;
 
     mFlinger.commitTransactionsLocked(eDisplayTransactionNeeded);
-    ASSERT_EQ(ui::Transform::ROT_180, SurfaceFlinger::getActiveDisplayRotationFlags());
+    ASSERT_EQ(ui::Transform::ROT_180, SurfaceFlinger::getFrontInternalDisplayRotationFlags());
 }
 
-TEST_F(ActiveDisplayRotationFlagsTest, rotateBothOuterActive) {
-    mFlinger.mutableActiveDisplayId() = kOuterDisplayId;
+TEST_F(FrontInternalDisplayRotationFlagsTest, rotateBothWhenOuterIsFront) {
+    mFlinger.mutableFrontInternalDisplayId() = getOuterDisplayId();
     auto displayToken = mInnerDisplay->getDisplayToken().promote();
     mFlinger.mutableDrawingState().displays.editValueFor(displayToken).orientation = ui::ROTATION_0;
     mFlinger.mutableCurrentState().displays.editValueFor(displayToken).orientation =
@@ -98,10 +100,10 @@ TEST_F(ActiveDisplayRotationFlagsTest, rotateBothOuterActive) {
             ui::ROTATION_270;
 
     mFlinger.commitTransactionsLocked(eDisplayTransactionNeeded);
-    ASSERT_EQ(ui::Transform::ROT_270, SurfaceFlinger::getActiveDisplayRotationFlags());
+    ASSERT_EQ(ui::Transform::ROT_270, SurfaceFlinger::getFrontInternalDisplayRotationFlags());
 }
 
-TEST_F(ActiveDisplayRotationFlagsTest, onActiveDisplayChanged) {
+TEST_F(FrontInternalDisplayRotationFlagsTest, onNewFrontInternalDisplay) {
     auto displayToken = mInnerDisplay->getDisplayToken().promote();
     mFlinger.mutableDrawingState().displays.editValueFor(displayToken).orientation = ui::ROTATION_0;
     mFlinger.mutableCurrentState().displays.editValueFor(displayToken).orientation =
@@ -113,10 +115,10 @@ TEST_F(ActiveDisplayRotationFlagsTest, onActiveDisplayChanged) {
             ui::ROTATION_270;
 
     mFlinger.commitTransactionsLocked(eDisplayTransactionNeeded);
-    ASSERT_EQ(ui::Transform::ROT_180, SurfaceFlinger::getActiveDisplayRotationFlags());
+    ASSERT_EQ(ui::Transform::ROT_180, SurfaceFlinger::getFrontInternalDisplayRotationFlags());
 
-    mFlinger.onActiveDisplayChanged(mInnerDisplay.get(), *mOuterDisplay);
-    ASSERT_EQ(ui::Transform::ROT_270, SurfaceFlinger::getActiveDisplayRotationFlags());
+    mFlinger.onNewFrontInternalDisplay(mInnerDisplay.get(), *mOuterDisplay);
+    ASSERT_EQ(ui::Transform::ROT_270, SurfaceFlinger::getFrontInternalDisplayRotationFlags());
 }
 
 } // namespace
diff --git a/services/surfaceflinger/tests/unittests/HWComposerTest.cpp b/services/surfaceflinger/tests/unittests/HWComposerTest.cpp
index b34de1a516..cd62889640 100644
--- a/services/surfaceflinger/tests/unittests/HWComposerTest.cpp
+++ b/services/surfaceflinger/tests/unittests/HWComposerTest.cpp
@@ -32,6 +32,7 @@
 #pragma clang diagnostic pop
 
 #include <common/FlagManager.h>
+#include <common/test/FlagUtils.h>
 #include <gui/LayerMetadata.h>
 #include <log/log.h>
 #include <chrono>
@@ -74,11 +75,11 @@ struct HWComposerTest : testing::Test {
     Hwc2::mock::Composer* const mHal = new StrictMock<Hwc2::mock::Composer>();
     impl::HWComposer mHwc{std::unique_ptr<Hwc2::Composer>(mHal)};
 
-    void expectHotplugConnect(hal::HWDisplayId hwcDisplayId) {
-        constexpr uint8_t kPort = 255;
-        EXPECT_CALL(*mHal, getDisplayIdentificationData(hwcDisplayId, _, _))
-                .WillOnce(DoAll(SetArgPointee<1>(kPort),
-                                SetArgPointee<2>(getExternalEdid()), Return(HalError::NONE)));
+    void expectHotplugConnect(hal::HWDisplayId hwcDisplayId, uint8_t port = 255,
+                              const display::DisplayIdentificationData& data = getExternalEdid()) {
+        EXPECT_CALL(*mHal, getDisplayIdentificationData(hwcDisplayId, _, _, _))
+                .WillOnce(DoAll(SetArgPointee<1>(port), SetArgPointee<2>(data),
+                                Return(HalError::NONE)));
 
         EXPECT_CALL(*mHal, setClientTargetSlotCount(_));
         EXPECT_CALL(*mHal, setVsyncEnabled(hwcDisplayId, Hwc2::IComposerClient::Vsync::DISABLE));
@@ -476,6 +477,148 @@ TEST_F(HWComposerTest, onVsyncInvalid) {
     EXPECT_FALSE(displayIdOpt);
 }
 
+TEST_F(HWComposerTest, propagateHotplugReconnectStatus) {
+    constexpr hal::HWDisplayId kHwcDisplayId = 1;
+    constexpr uint8_t kPort = 0;
+    expectHotplugConnect(kHwcDisplayId, kPort, getExternalEdid());
+
+    const auto info1 = mHwc.onHotplug(kHwcDisplayId, HWComposer::HotplugEvent::Connected);
+    ASSERT_TRUE(info1);
+    EXPECT_EQ(display::HotplugStatus::Connected, info1->hotplugStatus);
+
+    // Emit another hotplug event on the same display, but with a different EDID. This should
+    // trigger a hotplug reconnect. Display identification data should not be fetched.
+    EXPECT_CALL(*mHal, getDisplayIdentificationData(kHwcDisplayId, _, _, _)).Times(0);
+    const auto info2 = mHwc.onHotplug(kHwcDisplayId, HWComposer::HotplugEvent::Connected);
+    ASSERT_TRUE(info2);
+
+    EXPECT_EQ(display::HotplugStatus::Reconnected, info2->hotplugStatus);
+    EXPECT_EQ(info1->id, info2->id);
+}
+
+TEST_F(HWComposerTest, displayIdConflictResolution) {
+    // Two different displays (connected to two different ports) produce the same EDID,
+    // which will result in the same EDID-based display ID.
+
+    SET_FLAG_FOR_TEST(com::android::graphics::surfaceflinger::flags::stable_edid_ids, true);
+
+    // First display is assigned a display ID with no issues.
+    constexpr hal::HWDisplayId kHwcDisplayId1 = 1;
+    constexpr uint8_t kPort1 = 1;
+    expectHotplugConnect(kHwcDisplayId1, kPort1, getExternalEdid());
+
+    const auto info1 = mHwc.onHotplug(kHwcDisplayId1, HWComposer::HotplugEvent::Connected);
+    ASSERT_TRUE(info1);
+
+    constexpr uint64_t kExpectedDisplayId1 = 4067182673952280501;
+    const auto physicalDisplayId1 = info1->id;
+    EXPECT_EQ(kExpectedDisplayId1, physicalDisplayId1.value);
+
+    // Second display's ID has to be modified due to conflict.
+    constexpr hal::HWDisplayId kHwcDisplayId2 = 2;
+    constexpr uint8_t kPort2 = 2;
+    expectHotplugConnect(kHwcDisplayId2, kPort2, getExternalEdid());
+
+    const auto info2 = mHwc.onHotplug(kHwcDisplayId2, HWComposer::HotplugEvent::Connected);
+    ASSERT_TRUE(info2);
+
+    // The resulting display's ID should be equal to the one it conflicted with, but with the 8 LSBs
+    // assigned as its port ID.
+    constexpr uint64_t kDisplayId1WithDisplayPort2 = (kExpectedDisplayId1 & ~0xFFULL) | kPort2;
+    const auto physicalDisplayId2 = info2->id;
+    EXPECT_NE(physicalDisplayId1, physicalDisplayId2);
+    EXPECT_EQ(kDisplayId1WithDisplayPort2, physicalDisplayId2.value);
+    EXPECT_EQ(info2->port, static_cast<uint8_t>(info2->id.value));
+}
+
+TEST_F(HWComposerTest, displayIdConflictResolutionWithInvertedPortBits) {
+    // Two different displays (connected to two different ports) produce the same EDID,
+    // which will result in the same EDID-based display ID.
+
+    SET_FLAG_FOR_TEST(com::android::graphics::surfaceflinger::flags::stable_edid_ids, true);
+
+    // First display is assigned a display ID with no issues.
+    constexpr hal::HWDisplayId kHwcDisplayId1 = 1;
+    constexpr uint8_t kPort1 = 1;
+    expectHotplugConnect(kHwcDisplayId1, kPort1, getExternalEdid());
+
+    const auto info1 = mHwc.onHotplug(kHwcDisplayId1, HWComposer::HotplugEvent::Connected);
+    ASSERT_TRUE(info1);
+
+    constexpr uint64_t kExpectedDisplayId1 = 4067182673952280501;
+    const auto physicalDisplayId1 = info1->id;
+    EXPECT_EQ(kExpectedDisplayId1, physicalDisplayId1.value);
+
+    // Second display's ID has to be modified due to conflict. However the 8 LSBs of the conflicting
+    // ID happen to be equal to its port ID (i.e. 181 in this case), so the resolution will invert
+    // the port ID.
+    constexpr hal::HWDisplayId kHwcDisplayId2 = 2;
+    constexpr uint8_t kPort2 = 181;
+    expectHotplugConnect(kHwcDisplayId2, kPort2, getExternalEdid());
+
+    const auto info2 = mHwc.onHotplug(kHwcDisplayId2, HWComposer::HotplugEvent::Connected);
+    ASSERT_TRUE(info2);
+
+    // The resulting display's ID should be equal to the one it conflicted with, but with the 8 LSBs
+    // assigned as its port ID.
+    constexpr uint64_t kDisplayId1WithInvertedDisplayPort2 =
+            (kExpectedDisplayId1 & ~0xFFULL) | static_cast<uint8_t>(~kPort2);
+    const auto physicalDisplayId2 = info2->id;
+    EXPECT_NE(physicalDisplayId1, physicalDisplayId2);
+    EXPECT_EQ(kDisplayId1WithInvertedDisplayPort2, physicalDisplayId2.value);
+    EXPECT_EQ(static_cast<uint8_t>(~info2->port), static_cast<uint8_t>(info2->id.value));
+}
+
+TEST_F(HWComposerTest, displayIdConflictResolutionFails) {
+    // Three different displays (connected to three different ports) produce the same EDID,
+    // which will result in the same EDID-based display ID.
+
+    SET_FLAG_FOR_TEST(com::android::graphics::surfaceflinger::flags::stable_edid_ids, true);
+
+    // First display is assigned a display ID with no issues.
+    constexpr hal::HWDisplayId kHwcDisplayId1 = 1;
+    constexpr uint8_t kPort1 = 1;
+    expectHotplugConnect(kHwcDisplayId1, kPort1, getExternalEdid());
+
+    const auto info1 = mHwc.onHotplug(kHwcDisplayId1, HWComposer::HotplugEvent::Connected);
+    ASSERT_TRUE(info1);
+
+    constexpr uint64_t kExpectedDisplayId1 = 4067182673952280501;
+    const auto physicalDisplayId1 = info1->id;
+    EXPECT_EQ(kExpectedDisplayId1, physicalDisplayId1.value);
+
+    // Second display's ID has to be modified due to conflict with the first display's ID. Use the
+    // port value 74, which is the inverted value of 181.
+    constexpr hal::HWDisplayId kHwcDisplayId2 = 2;
+    constexpr uint8_t kPort2 = 74;
+    expectHotplugConnect(kHwcDisplayId2, kPort2, getExternalEdid());
+
+    const auto info2 = mHwc.onHotplug(kHwcDisplayId2, HWComposer::HotplugEvent::Connected);
+    ASSERT_TRUE(info2);
+
+    // The resulting display's ID should be equal to the one it conflicted with, but with the 8 LSBs
+    // assigned as its port ID 74.
+    constexpr uint64_t kDisplayId1WithDisplayPort2 = (kExpectedDisplayId1 & ~0xFFULL) | kPort2;
+    const auto physicalDisplayId2 = info2->id;
+    EXPECT_NE(physicalDisplayId1, physicalDisplayId2);
+    EXPECT_EQ(kDisplayId1WithDisplayPort2, physicalDisplayId2.value);
+    EXPECT_EQ(info2->port, static_cast<uint8_t>(info2->id.value));
+
+    // Third display's ID has to be modified due to conflict. However the 8 LSBs of the conflicting
+    // ID happen to be equal to its port ID (i.e. 181 in this case), so the resolution will invert
+    // the port ID to 74 and use that.
+    constexpr hal::HWDisplayId kHwcDisplayId3 = 3;
+    constexpr uint8_t kPort3 = 181;
+    EXPECT_CALL(*mHal, getDisplayIdentificationData(kHwcDisplayId3, _, _, _))
+            .WillOnce(DoAll(SetArgPointee<1>(kPort3), SetArgPointee<2>(getExternalEdid()),
+                            Return(HalError::NONE)));
+
+    // Creation of the display should fail, since a display with an ID seeded with 74 in its 8 LSBs
+    // already exists.
+    const auto info3 = mHwc.onHotplug(kHwcDisplayId3, HWComposer::HotplugEvent::Connected);
+    ASSERT_FALSE(info3);
+}
+
 struct MockHWC2ComposerCallback final : StrictMock<HWC2::ComposerCallback> {
     MOCK_METHOD(void, onComposerHalHotplugEvent, (hal::HWDisplayId, DisplayHotplugEvent),
                 (override));
diff --git a/services/surfaceflinger/tests/unittests/LayerHistoryIntegrationTest.cpp b/services/surfaceflinger/tests/unittests/LayerHistoryIntegrationTest.cpp
index f3d6dccc17..0fe676c4cf 100644
--- a/services/surfaceflinger/tests/unittests/LayerHistoryIntegrationTest.cpp
+++ b/services/surfaceflinger/tests/unittests/LayerHistoryIntegrationTest.cpp
@@ -1023,8 +1023,6 @@ TEST_F(LayerHistoryIntegrationTest, oneLayerExplicitVoteWithCategory) {
 }
 
 TEST_F(LayerHistoryIntegrationTest, oneLayerExplicitVoteWithCategoryNotVisibleDoesNotVote) {
-    SET_FLAG_FOR_TEST(flags::misc1, true);
-
     auto layer = createLegacyAndFrontedEndLayer(1);
     hideLayer(1);
     setFrameRate(1, (12.34_Hz).getValue(), ANATIVEWINDOW_FRAME_RATE_COMPATIBILITY_DEFAULT,
@@ -1047,36 +1045,7 @@ TEST_F(LayerHistoryIntegrationTest, oneLayerExplicitVoteWithCategoryNotVisibleDo
     EXPECT_EQ(0, frequentLayerCount(time));
 }
 
-TEST_F(LayerHistoryIntegrationTest, invisibleExplicitLayer) {
-    SET_FLAG_FOR_TEST(flags::misc1, false);
-
-    auto explicitVisiblelayer = createLegacyAndFrontedEndLayer(1);
-    showLayer(1);
-    setFrameRate(1, (60_Hz).getValue(), ANATIVEWINDOW_FRAME_RATE_COMPATIBILITY_FIXED_SOURCE, 0);
-
-    auto explicitInvisiblelayer = createLegacyAndFrontedEndLayer(2);
-    hideLayer(2);
-    setFrameRate(2, (90_Hz).getValue(), ANATIVEWINDOW_FRAME_RATE_COMPATIBILITY_FIXED_SOURCE, 0);
-
-    nsecs_t time = systemTime();
-
-    // Post a buffer to the layers to make them active
-    setBuffer(1);
-    setBuffer(2);
-    updateLayerSnapshotsAndLayerHistory(time);
-
-    EXPECT_EQ(2u, layerCount());
-    ASSERT_EQ(1u, summarizeLayerHistory(time).size());
-    EXPECT_EQ(LayerHistory::LayerVoteType::ExplicitExactOrMultiple,
-              summarizeLayerHistory(time)[0].vote);
-    EXPECT_EQ(60_Hz, summarizeLayerHistory(time)[0].desiredRefreshRate);
-    EXPECT_EQ(2u, activeLayerCount());
-    EXPECT_EQ(2, frequentLayerCount(time));
-}
-
 TEST_F(LayerHistoryIntegrationTest, invisibleExplicitLayerDoesNotVote) {
-    SET_FLAG_FOR_TEST(flags::misc1, true);
-
     auto explicitVisiblelayer = createLegacyAndFrontedEndLayer(1);
     showLayer(1);
     setFrameRate(1, (60_Hz).getValue(), ANATIVEWINDOW_FRAME_RATE_COMPATIBILITY_FIXED_SOURCE, 0);
@@ -1401,34 +1370,7 @@ TEST_F(LayerHistoryIntegrationTest, inactiveLayers) {
     EXPECT_EQ(1, frequentLayerCount(time));
 }
 
-TEST_F(LayerHistoryIntegrationTest, invisibleExplicitLayerIsActive) {
-    SET_FLAG_FOR_TEST(flags::misc1, false);
-
-    auto explicitVisiblelayer = createLegacyAndFrontedEndLayer(1);
-    auto explicitInvisiblelayer = createLegacyAndFrontedEndLayer(2);
-    hideLayer(2);
-    setFrameRate(1, 60.0f, ANATIVEWINDOW_FRAME_RATE_COMPATIBILITY_FIXED_SOURCE,
-                 ANATIVEWINDOW_CHANGE_FRAME_RATE_ONLY_IF_SEAMLESS);
-    setFrameRate(2, 90.0f, ANATIVEWINDOW_FRAME_RATE_COMPATIBILITY_FIXED_SOURCE,
-                 ANATIVEWINDOW_CHANGE_FRAME_RATE_ONLY_IF_SEAMLESS);
-    nsecs_t time = systemTime();
-
-    // Post a buffer to the layers to make them active
-    setBufferWithPresentTime(explicitVisiblelayer, time);
-    setBufferWithPresentTime(explicitInvisiblelayer, time);
-
-    EXPECT_EQ(2u, layerCount());
-    ASSERT_EQ(1u, summarizeLayerHistory(time).size());
-    EXPECT_EQ(LayerHistory::LayerVoteType::ExplicitExactOrMultiple,
-              summarizeLayerHistory(time)[0].vote);
-    EXPECT_EQ(60_Hz, summarizeLayerHistory(time)[0].desiredRefreshRate);
-    EXPECT_EQ(2u, activeLayerCount());
-    EXPECT_EQ(2, frequentLayerCount(time));
-}
-
 TEST_F(LayerHistoryIntegrationTest, invisibleExplicitLayerIsNotActive) {
-    SET_FLAG_FOR_TEST(flags::misc1, true);
-
     auto explicitVisiblelayer = createLegacyAndFrontedEndLayer(1);
     auto explicitInvisiblelayer = createLegacyAndFrontedEndLayer(2);
     hideLayer(2);
@@ -1829,7 +1771,7 @@ TEST_F(LayerHistoryIntegrationTest, updatingGeometryUpdatesWeight) {
                       renderengine::mock::FakeExternalTexture>(100U /*width*/, 100U /*height*/, 1,
                                                                HAL_PIXEL_FORMAT_RGBA_8888,
                                                                GRALLOC_USAGE_PROTECTED /*usage*/));
-    mFlinger.setLayerHistoryDisplayArea(100 * 100);
+    mFlinger.setLayerHistoryDisplaySize(ui::Size(100, 100));
     updateLayerSnapshotsAndLayerHistory(time);
     auto summary = summarizeLayerHistory(time);
     ASSERT_EQ(1u, summary.size());
@@ -1924,7 +1866,7 @@ protected:
         mappings.push_back(std::make_pair(kAppId1, kThreshold1));
         mappings.push_back(std::make_pair(kAppId2, kThreshold2));
 
-        mScheduler->onActiveDisplayAreaChanged(DISPLAY_WIDTH * DISPLAY_HEIGHT);
+        mScheduler->onPacesetterDisplaySizeChanged(ui::Size(DISPLAY_WIDTH, DISPLAY_HEIGHT));
         mScheduler->updateSmallAreaDetection(mappings);
     }
 
diff --git a/services/surfaceflinger/tests/unittests/LayerLifecycleManagerTest.cpp b/services/surfaceflinger/tests/unittests/LayerLifecycleManagerTest.cpp
index 35ec536d14..4ae132c48d 100644
--- a/services/surfaceflinger/tests/unittests/LayerLifecycleManagerTest.cpp
+++ b/services/surfaceflinger/tests/unittests/LayerLifecycleManagerTest.cpp
@@ -108,13 +108,16 @@ TEST_F(LayerLifecycleManagerTest, updateLayerStates) {
     transactions.emplace_back();
     transactions.back().states.push_back({});
     transactions.back().states.front().state.backgroundBlurRadius = 22;
-    transactions.back().states.front().state.what = layer_state_t::eBackgroundBlurRadiusChanged;
+    transactions.back().states.front().state.backgroundBlurScale = 0.5f;
+    transactions.back().states.front().state.what |= layer_state_t::eBackgroundBlurRadiusChanged;
+    transactions.back().states.front().state.what |= layer_state_t::eBackgroundBlurScaleChanged;
     transactions.back().states.front().layerId = 1;
     lifecycleManager.applyTransactions(transactions);
     EXPECT_FALSE(lifecycleManager.getGlobalChanges().test(RequestedLayerState::Changes::Hierarchy));
     lifecycleManager.commitChanges();
     EXPECT_FALSE(lifecycleManager.getGlobalChanges().test(RequestedLayerState::Changes::Hierarchy));
     EXPECT_EQ(managedLayers.front()->backgroundBlurRadius, 22u);
+    EXPECT_EQ(managedLayers.front()->backgroundBlurScale, 0.5f);
 }
 
 TEST_F(LayerLifecycleManagerTest, layerWithoutHandleIsDestroyed) {
diff --git a/services/surfaceflinger/tests/unittests/LayerSnapshotTest.cpp b/services/surfaceflinger/tests/unittests/LayerSnapshotTest.cpp
index d045eb884d..a8f13f57e0 100644
--- a/services/surfaceflinger/tests/unittests/LayerSnapshotTest.cpp
+++ b/services/surfaceflinger/tests/unittests/LayerSnapshotTest.cpp
@@ -2189,4 +2189,138 @@ TEST_F(LayerSnapshotTest, shouldUpdatePictureProfilePriorityFromAppContentPriori
     }
 }
 
+// Test that child layers of the stop layer are hidden.
+TEST_F(LayerSnapshotTest, stopLayer_hidesChildren) {
+    SET_FLAG_FOR_TEST(com::android::graphics::surfaceflinger::flags::stop_layer, true);
+    setStopLayer(1, 122);
+
+    std::vector<uint32_t> expected = {1, 11, 111, 12, 121, 2};
+    UPDATE_AND_VERIFY(mSnapshotBuilder, expected);
+}
+
+// Test that if a layer specifies itself as a stop layer, then it is hidden.
+TEST_F(LayerSnapshotTest, stopLayer_hidesSelf) {
+    SET_FLAG_FOR_TEST(com::android::graphics::surfaceflinger::flags::stop_layer, true);
+    setStopLayer(122, 122);
+
+    std::vector<uint32_t> expected = {1, 11, 111, 12, 121, 13, 2};
+    UPDATE_AND_VERIFY(mSnapshotBuilder, expected);
+}
+
+// Test that siblings z-ordered above a stop layer are hidden.
+TEST_F(LayerSnapshotTest, stopLayer_hidesSiblings) {
+    SET_FLAG_FOR_TEST(com::android::graphics::surfaceflinger::flags::stop_layer, true);
+    setStopLayer(1, 121);
+
+    std::vector<uint32_t> expected = {1, 11, 111, 12, 2};
+    UPDATE_AND_VERIFY(mSnapshotBuilder, expected);
+}
+
+// Test that children z-ordered below the stop layer aren't hidden.
+TEST_F(LayerSnapshotTest, stopLayer_doesntHideZOrderedBelowChildren) {
+    SET_FLAG_FOR_TEST(com::android::graphics::surfaceflinger::flags::stop_layer, true);
+    setZ(121, -1);
+    setStopLayer(1, 12);
+
+    std::vector<uint32_t> expected = {1, 11, 111, 121, 2};
+    UPDATE_AND_VERIFY(mSnapshotBuilder, expected);
+}
+
+// Test that relative children are hidden by the stop layer.
+TEST_F(LayerSnapshotTest, stopLayer_hidesRelativeChild) {
+    SET_FLAG_FOR_TEST(com::android::graphics::surfaceflinger::flags::stop_layer, true);
+    reparentRelativeLayer(111, 12);
+    setStopLayer(1, 12);
+
+    std::vector<uint32_t> expected = {1, 11, 2};
+    UPDATE_AND_VERIFY(mSnapshotBuilder, expected);
+}
+
+// Test that detached children aren't hidden by the stop layer.
+TEST_F(LayerSnapshotTest, stopLayer_doesntHideDetachedChildren) {
+    SET_FLAG_FOR_TEST(com::android::graphics::surfaceflinger::flags::stop_layer, true);
+    reparentRelativeLayer(121, 11);
+    setStopLayer(1, 12);
+
+    std::vector<uint32_t> expected = {1, 11, 111, 121, 2};
+    UPDATE_AND_VERIFY(mSnapshotBuilder, expected);
+}
+
+// Test that stop layers work on hierarchies with a single root layer.
+TEST_F(LayerSnapshotTest, stopLayer_singleRoot) {
+    SET_FLAG_FOR_TEST(com::android::graphics::surfaceflinger::flags::stop_layer, true);
+    setStopLayer(1, 11);
+
+    LayerHierarchy root = mHierarchyBuilder.getPartialHierarchy(1, /*childrenOnly=*/false);
+    LayerSnapshotBuilder::Args args{.root = root,
+                                    .layerLifecycleManager = mLifecycleManager,
+                                    .includeMetadata = false,
+                                    .displays = mFrontEndDisplayInfos,
+                                    .displayChanges = false,
+                                    .globalShadowSettings = globalShadowSettings,
+                                    .supportsBlur = true,
+                                    .supportedLayerGenericMetadata = {},
+                                    .genericLayerMetadataKeyMap = {}};
+    mSnapshotBuilder.update(args);
+
+    std::vector<uint32_t> expectedVisibleLayers = {1};
+    std::vector<uint32_t> actualVisibleLayers;
+    mSnapshotBuilder.forEachVisibleSnapshot([&actualVisibleLayers](const LayerSnapshot& snapshot) {
+        actualVisibleLayers.push_back(snapshot.path.id);
+    });
+    EXPECT_EQ(expectedVisibleLayers, actualVisibleLayers);
+}
+
+// Test two stop layers where there's no interaction between the two stop layers.
+TEST_F(LayerSnapshotTest, stopLayer_multipleStopLayers_parentAfterChild) {
+    SET_FLAG_FOR_TEST(com::android::graphics::surfaceflinger::flags::stop_layer, true);
+    setStopLayer(1, 13);
+    setStopLayer(11, 111);
+
+    std::vector<uint32_t> expected = {1, 11, 12, 121, 122, 1221, 2};
+    UPDATE_AND_VERIFY(mSnapshotBuilder, expected);
+}
+
+// Test two stop layers where the hierarchy containing the second stop layer is hidden.
+TEST_F(LayerSnapshotTest, stopLayer_multipleStopLayers_childHidden) {
+    SET_FLAG_FOR_TEST(com::android::graphics::surfaceflinger::flags::stop_layer, true);
+    setStopLayer(1, 12);
+    setStopLayer(12, 122);
+
+    std::vector<uint32_t> expected = {1, 11, 111, 2};
+    UPDATE_AND_VERIFY(mSnapshotBuilder, expected);
+}
+
+// Test two stop layers where the stop layer specified lower in the hierarchy overrides
+// the stop layer specified higher in the hierarchy.
+TEST_F(LayerSnapshotTest, stopLayer_multipleStopLayers_childStopLayerOverridden) {
+    SET_FLAG_FOR_TEST(com::android::graphics::surfaceflinger::flags::stop_layer, true);
+    setStopLayer(1, 121);
+    setStopLayer(12, 122);
+
+    std::vector<uint32_t> expected = {1, 11, 111, 12, 2};
+    UPDATE_AND_VERIFY(mSnapshotBuilder, expected);
+}
+
+// Test two stop layers where the stop layer specified higher in the hierarchy applies because
+// it appears before the stop layer applied lower in the hierarchy.
+TEST_F(LayerSnapshotTest, stopLayer_multipleStopLayers_childApplied) {
+    SET_FLAG_FOR_TEST(com::android::graphics::surfaceflinger::flags::stop_layer, true);
+    setStopLayer(1, 13);
+    setStopLayer(11, 111);
+
+    std::vector<uint32_t> expected = {1, 11, 12, 121, 122, 1221, 2};
+    UPDATE_AND_VERIFY(mSnapshotBuilder, expected);
+}
+
+// Test that the stop layer works on mirrored hierarchies.
+TEST_F(LayerSnapshotTest, stopLayer_mirrorHierarchy) {
+    SET_FLAG_FOR_TEST(com::android::graphics::surfaceflinger::flags::stop_layer, true);
+    createDisplayMirrorLayer(3, ui::LayerStack::fromValue(0), 121);
+    setLayerStack(3, 1);
+
+    std::vector<uint32_t> expected = {1, 11, 111, 12, 121, 122, 1221, 13, 2, 3, 1, 11, 111, 12};
+    UPDATE_AND_VERIFY(mSnapshotBuilder, expected);
+}
+
 } // namespace android::surfaceflinger::frontend
diff --git a/services/surfaceflinger/tests/unittests/MessageQueueTest.cpp b/services/surfaceflinger/tests/unittests/MessageQueueTest.cpp
index e9b86b270a..5710e63b28 100644
--- a/services/surfaceflinger/tests/unittests/MessageQueueTest.cpp
+++ b/services/surfaceflinger/tests/unittests/MessageQueueTest.cpp
@@ -22,7 +22,7 @@
 
 #include <scheduler/interface/ICompositor.h>
 
-#include "FrameTimeline/FrameTimeline.h"
+#include "Scheduler/FrameTimeline.h"
 #include "Scheduler/MessageQueue.h"
 #include "mock/MockVSyncDispatch.h"
 #include "utils/Timers.h"
@@ -68,9 +68,9 @@ public:
     const sp<MockHandler> mHandler;
 };
 
-struct MockTokenManager : frametimeline::TokenManager {
-    MOCK_METHOD1(generateTokenForPredictions, int64_t(frametimeline::TimelineItem&& prediction));
-    MOCK_CONST_METHOD1(getPredictionsForToken, std::optional<frametimeline::TimelineItem>(int64_t));
+struct MockTokenManager : scheduler::TokenManager {
+    MOCK_METHOD1(generateTokenForPredictions, int64_t(scheduler::TimelineItem&& prediction));
+    MOCK_CONST_METHOD1(getPredictionsForToken, std::optional<scheduler::TimelineItem>(int64_t));
 };
 
 struct MessageQueueTest : testing::Test {
@@ -159,9 +159,9 @@ TEST_F(MessageQueueTest, commitTwiceWithCallback) {
     constexpr VsyncId vsyncId{42};
 
     EXPECT_CALL(mTokenManager,
-                generateTokenForPredictions(
-                        frametimeline::TimelineItem(kStartTime.ns(), kEndTime.ns(),
-                                                    kPresentTime.ns(), kPresentTime.ns())))
+                generateTokenForPredictions(scheduler::TimelineItem(kStartTime.ns(), kEndTime.ns(),
+                                                                    kPresentTime.ns(),
+                                                                    kPresentTime.ns())))
             .WillOnce(Return(ftl::to_underlying(vsyncId)));
     EXPECT_CALL(*mEventQueue.mHandler, dispatchFrame(vsyncId, kPresentTime)).Times(1);
     EXPECT_NO_FATAL_FAILURE(
diff --git a/services/surfaceflinger/tests/unittests/RegionSamplingTest.cpp b/services/surfaceflinger/tests/unittests/RegionSamplingTest.cpp
index 409e1ef5d7..eed4a28db4 100644
--- a/services/surfaceflinger/tests/unittests/RegionSamplingTest.cpp
+++ b/services/surfaceflinger/tests/unittests/RegionSamplingTest.cpp
@@ -39,20 +39,19 @@ public:
     static int constexpr kWidth = 98;
     static int constexpr kStride = 100;
     static int constexpr kHeight = 29;
-    static int constexpr kOrientation = ui::Transform::ROT_0;
     std::array<uint32_t, kHeight * kStride> buffer;
     Rect const whole_area{0, 0, kWidth, kHeight};
 };
 
 TEST_F(RegionSamplingTest, calculate_mean_white) {
     std::fill(buffer.begin(), buffer.end(), kWhite);
-    EXPECT_THAT(sampleArea(buffer.data(), kWidth, kHeight, kStride, kOrientation, whole_area),
+    EXPECT_THAT(sampleArea(buffer.data(), kWidth, kHeight, kStride, whole_area),
                 testing::FloatEq(1.0f));
 }
 
 TEST_F(RegionSamplingTest, calculate_mean_black) {
     std::fill(buffer.begin(), buffer.end(), kBlack);
-    EXPECT_THAT(sampleArea(buffer.data(), kWidth, kHeight, kStride, kOrientation, whole_area),
+    EXPECT_THAT(sampleArea(buffer.data(), kWidth, kHeight, kStride, whole_area),
                 testing::FloatEq(0.0f));
 }
 
@@ -63,7 +62,7 @@ TEST_F(RegionSamplingTest, calculate_mean_partial_region) {
                                  whole_area.top + halfway_down};
     std::fill(buffer.begin(), buffer.begin() + half, 0);
     std::fill(buffer.begin() + half, buffer.end(), kWhite);
-    EXPECT_THAT(sampleArea(buffer.data(), kWidth, kHeight, kStride, kOrientation, partial_region),
+    EXPECT_THAT(sampleArea(buffer.data(), kWidth, kHeight, kStride, partial_region),
                 testing::FloatEq(0.0f));
 }
 
@@ -74,14 +73,14 @@ TEST_F(RegionSamplingTest, calculate_mean_mixed_values) {
         return pixel;
     });
 
-    EXPECT_THAT(sampleArea(buffer.data(), kWidth, kHeight, kStride, kOrientation, whole_area),
+    EXPECT_THAT(sampleArea(buffer.data(), kWidth, kHeight, kStride, whole_area),
                 testing::FloatNear(0.16f, 0.01f));
 }
 
 TEST_F(RegionSamplingTest, bimodal_tiebreaker) {
     std::generate(buffer.begin(), buffer.end(),
                   [n = 0]() mutable { return (n++ % 2) ? kBlack : kWhite; });
-    EXPECT_THAT(sampleArea(buffer.data(), kWidth, kHeight, kStride, kOrientation, whole_area),
+    EXPECT_THAT(sampleArea(buffer.data(), kWidth, kHeight, kStride, whole_area),
                 testing::FloatEq(0.5f));
 }
 
@@ -90,19 +89,19 @@ TEST_F(RegionSamplingTest, bounds_checking) {
                   [n = 0]() mutable { return (n++ > (kStride * kHeight >> 1)) ? kBlack : kWhite; });
 
     Rect invalid_region{0, 0, 4, kHeight + 1};
-    EXPECT_THAT(sampleArea(buffer.data(), kWidth, kHeight, kStride, kOrientation, invalid_region),
+    EXPECT_THAT(sampleArea(buffer.data(), kWidth, kHeight, kStride, invalid_region),
                 testing::Eq(0.0));
 
     invalid_region = Rect{0, 0, -4, kHeight};
-    EXPECT_THAT(sampleArea(buffer.data(), kWidth, kHeight, kStride, kOrientation, invalid_region),
+    EXPECT_THAT(sampleArea(buffer.data(), kWidth, kHeight, kStride, invalid_region),
                 testing::Eq(0.0));
 
     invalid_region = Rect{3, 0, 2, 0};
-    EXPECT_THAT(sampleArea(buffer.data(), kWidth, kHeight, kStride, kOrientation, invalid_region),
+    EXPECT_THAT(sampleArea(buffer.data(), kWidth, kHeight, kStride, invalid_region),
                 testing::Eq(0.0));
 
     invalid_region = Rect{0, 3, 0, 2};
-    EXPECT_THAT(sampleArea(buffer.data(), kWidth, kHeight, kStride, kOrientation, invalid_region),
+    EXPECT_THAT(sampleArea(buffer.data(), kWidth, kHeight, kStride, invalid_region),
                 testing::Eq(0.0));
 }
 
diff --git a/services/surfaceflinger/tests/unittests/SchedulerTest.cpp b/services/surfaceflinger/tests/unittests/SchedulerTest.cpp
index 116fcd9f6d..f04b666212 100644
--- a/services/surfaceflinger/tests/unittests/SchedulerTest.cpp
+++ b/services/surfaceflinger/tests/unittests/SchedulerTest.cpp
@@ -185,8 +185,8 @@ TEST_F(SchedulerTest, chooseRefreshRateForContentIsNoopWhenModeSwitchingIsNotSup
     constexpr hal::PowerMode kPowerModeOn = hal::PowerMode::ON;
     FTL_FAKE_GUARD(kMainThreadContext, mScheduler->setDisplayPowerMode(kDisplayId1, kPowerModeOn));
 
-    constexpr uint32_t kDisplayArea = 999'999;
-    mScheduler->onActiveDisplayAreaChanged(kDisplayArea);
+    const ui::Size kDisplaySize = ui::Size(9, 111'111);
+    mScheduler->onPacesetterDisplaySizeChanged(kDisplaySize);
 
     EXPECT_CALL(mSchedulerCallback, requestDisplayModes(_)).Times(0);
     mScheduler->chooseRefreshRateForContent(/*LayerHierarchy*/ nullptr,
@@ -219,6 +219,7 @@ TEST_F(SchedulerTest, updateDisplayModes) {
 }
 
 TEST_F(SchedulerTest, emitModeChangeEvent) {
+    SET_FLAG_FOR_TEST(flags::unify_refresh_rate_callbacks, false);
     const auto selectorPtr =
             std::make_shared<RefreshRateSelector>(kDisplay1Modes, kDisplay1Mode120->getId());
     mScheduler->registerDisplay(kDisplayId1, selectorPtr);
@@ -227,7 +228,7 @@ TEST_F(SchedulerTest, emitModeChangeEvent) {
     mScheduler->setContentRequirements({kLayer});
 
     // No event is emitted in response to idle.
-    EXPECT_CALL(*mEventThread, onModeChanged(_)).Times(0);
+    EXPECT_CALL(*mEventThread, onModeChanged(_, _)).Times(0);
 
     using TimerState = TestableScheduler::TimerState;
 
@@ -240,19 +241,111 @@ TEST_F(SchedulerTest, emitModeChangeEvent) {
     mScheduler->setContentRequirements({layer});
 
     // An event is emitted implicitly despite choosing the same mode as when idle.
-    EXPECT_CALL(*mEventThread, onModeChanged(kDisplay1Mode60_60)).Times(1);
+    EXPECT_CALL(*mEventThread, onModeChanged(kDisplay1Mode60_60, _)).Times(1);
 
     mScheduler->idleTimerCallback(TimerState::Reset);
 
     mScheduler->setContentRequirements({kLayer});
 
     // An event is emitted explicitly for the mode change.
-    EXPECT_CALL(*mEventThread, onModeChanged(kDisplay1Mode120_120)).Times(1);
+    EXPECT_CALL(*mEventThread, onModeChanged(kDisplay1Mode120_120, _)).Times(1);
 
     mScheduler->touchTimerCallback(TimerState::Reset);
     mScheduler->onDisplayModeChanged(kDisplayId1, kDisplay1Mode120_120, true);
 }
 
+TEST_F(SchedulerTest, emitModeChangeEvent_unifyRefreshRateCallbacksEnabled) {
+    SET_FLAG_FOR_TEST(flags::unify_refresh_rate_callbacks, true);
+    const auto selectorPtr =
+            std::make_shared<RefreshRateSelector>(kDisplay1Modes, kDisplay1Mode120->getId());
+    mScheduler->registerDisplay(kDisplayId1, selectorPtr);
+    mScheduler->onDisplayModeChanged(kDisplayId1, kDisplay1Mode120_120, true);
+
+    mScheduler->setContentRequirements({kLayer});
+
+    // No event is emitted in response to idle.
+    EXPECT_CALL(*mEventThread, onModeAndFrameRateOverridesChanged(_, _, _, _)).Times(0);
+
+    using TimerState = TestableScheduler::TimerState;
+
+    mScheduler->idleTimerCallback(TimerState::Expired);
+    selectorPtr->setActiveMode(kDisplay1Mode60->getId(), 60_Hz);
+
+    auto layer = kLayer;
+    layer.vote = RefreshRateSelector::LayerVoteType::ExplicitExact;
+    layer.desiredRefreshRate = 60_Hz;
+    mScheduler->setContentRequirements({layer});
+
+    // An event is emitted implicitly despite choosing the same mode as when idle.
+    EXPECT_CALL(*mEventThread, onModeAndFrameRateOverridesChanged(_, kDisplay1Mode60_60, _, _))
+            .Times(1);
+
+    mScheduler->idleTimerCallback(TimerState::Reset);
+
+    mScheduler->setContentRequirements({kLayer});
+
+    // An event is emitted explicitly for the mode change.
+    EXPECT_CALL(*mEventThread, onModeAndFrameRateOverridesChanged(_, kDisplay1Mode120_120, _, _))
+            .Times(1);
+
+    mScheduler->touchTimerCallback(TimerState::Reset);
+}
+
+TEST_F(SchedulerTest, emitModeAndFrameRateOverrideChangeEvent) {
+    SET_FLAG_FOR_TEST(flags::unify_refresh_rate_callbacks, true);
+    const auto selectorPtr = std::make_shared<
+            RefreshRateSelector>(kDisplay1Modes, kDisplay1Mode60->getId(),
+                                 RefreshRateSelector::
+                                         Config{.enableFrameRateOverride = RefreshRateSelector::
+                                                        Config::FrameRateOverride::Enabled,
+                                                .kernelIdleTimerController = {}});
+    mScheduler->registerDisplay(kDisplayId1, selectorPtr);
+    std::vector<RefreshRateSelector::LayerRequirement> layers = {kLayer, kLayer};
+    auto& lr1 = layers[0];
+    auto& lr2 = layers[1];
+    lr1.vote = RefreshRateSelector::LayerVoteType::ExplicitExact;
+    lr1.desiredRefreshRate = 120_Hz;
+    lr1.name = "120Hz ExplicitExactOrMultiple";
+    lr2.vote = RefreshRateSelector::LayerVoteType::ExplicitExactOrMultiple;
+    lr2.desiredRefreshRate = 60_Hz;
+    lr2.name = "60Hz ExplicitExactOrMultiple";
+
+    // Emit Mode and Frame Rate override changed call
+    EXPECT_CALL(*mEventThread, onModeAndFrameRateOverridesChanged(_, kDisplay1Mode120_120, _, _))
+            .Times(1);
+    mScheduler->setContentRequirements(layers);
+    mScheduler->touchTimerCallback(TestableScheduler::TimerState::Reset);
+}
+
+TEST_F(SchedulerTest, emitModeChangeEventOnReloadPhaseConfiguration) {
+    SET_FLAG_FOR_TEST(flags::unify_refresh_rate_callbacks, false);
+    const auto selectorPtr =
+            std::make_shared<RefreshRateSelector>(kDisplay1Modes, kDisplay1Mode120->getId());
+    mScheduler->registerDisplay(kDisplayId1, selectorPtr);
+    constexpr auto kMinSfDuration = Duration::fromNs(1000000);
+    constexpr auto kMaxSfDuration = Duration::fromNs(2000000);
+    constexpr auto kAppDuration = Duration::fromNs(1500000);
+
+    EXPECT_CALL(*mEventThread, onModeChanged(kDisplay1Mode120_120, _)).Times(1);
+    mScheduler->reloadPhaseConfiguration(kDisplay1Mode120_120, kMinSfDuration, kMaxSfDuration,
+                                         kAppDuration);
+}
+
+TEST_F(SchedulerTest, emitModeChangeEventOnReloadPhaseConfiguration_unifyRefreshRateCallbacks) {
+    SET_FLAG_FOR_TEST(flags::unify_refresh_rate_callbacks, true);
+    const auto selectorPtr =
+            std::make_shared<RefreshRateSelector>(kDisplay1Modes, kDisplay1Mode120->getId());
+    mScheduler->registerDisplay(kDisplayId1, selectorPtr);
+    constexpr auto kMinSfDuration = Duration::fromNs(1000000);
+    constexpr auto kMaxSfDuration = Duration::fromNs(2000000);
+    constexpr auto kAppDuration = Duration::fromNs(1500000);
+
+    EXPECT_CALL(*mEventThread, onModeAndFrameRateOverridesChanged(_, kDisplay1Mode120_120, _, _))
+            .Times(1);
+    mScheduler->reloadPhaseConfiguration(kDisplay1Mode120_120, kMinSfDuration, kMaxSfDuration,
+                                         kAppDuration);
+}
+
 TEST_F(SchedulerTest, calculateMaxAcquiredBufferCount) {
     struct TestCase {
         Fps refreshRate;
@@ -318,8 +411,8 @@ TEST_F(SchedulerTest, chooseRefreshRateForContentSelectsMaxRefreshRate) {
     constexpr hal::PowerMode kPowerModeOn = hal::PowerMode::ON;
     FTL_FAKE_GUARD(kMainThreadContext, mScheduler->setDisplayPowerMode(kDisplayId1, kPowerModeOn));
 
-    constexpr uint32_t kDisplayArea = 999'999;
-    mScheduler->onActiveDisplayAreaChanged(kDisplayArea);
+    const ui::Size kDisplaySize = ui::Size(9, 111'111);
+    mScheduler->onPacesetterDisplaySizeChanged(kDisplaySize);
 
     EXPECT_CALL(mSchedulerCallback, requestDisplayModes(Is120Hz())).Times(1);
     mScheduler->chooseRefreshRateForContent(/*LayerHierarchy*/ nullptr,
@@ -761,6 +854,71 @@ TEST_F(SchedulerTest, resyncAllSkipsOffDisplays) FTL_FAKE_GUARD(kMainThreadConte
     mScheduler->resyncAllToHardwareVsync(kAllowToEnable);
 }
 
+TEST_F(SchedulerTest, enablesLayerCachingTexturePoolForPacesetter) {
+    SET_FLAG_FOR_TEST(flags::pacesetter_selection, true);
+
+    mScheduler->setDisplayPowerMode(kDisplayId1, hal::PowerMode::ON);
+    mScheduler->registerDisplay(kDisplayId2,
+                                std::make_shared<RefreshRateSelector>(kDisplay2Modes,
+                                                                      kDisplay2Mode60->getId()));
+    mScheduler->setDisplayPowerMode(kDisplayId2, hal::PowerMode::ON);
+
+    EXPECT_EQ(mScheduler->pacesetterDisplayId(), kDisplayId2);
+
+    EXPECT_CALL(mSchedulerCallback, enableLayerCachingTexturePool(kDisplayId1, true));
+    EXPECT_CALL(mSchedulerCallback, enableLayerCachingTexturePool(kDisplayId2, false));
+    mScheduler->setPacesetterDisplay(kDisplayId1);
+}
+
+TEST_F(SchedulerTest, pendingModeChangeSingleDisplay) {
+    SET_FLAG_FOR_TEST(flags::pacesetter_selection, true);
+
+    mScheduler->setDisplayPowerMode(kDisplayId1, hal::PowerMode::ON);
+
+    EXPECT_FALSE(mScheduler->layerHistoryModeChangePending());
+
+    mScheduler->setModeChangePending(kDisplayId1, true);
+    EXPECT_TRUE(mScheduler->layerHistoryModeChangePending());
+
+    mScheduler->setModeChangePending(kDisplayId1, false);
+    EXPECT_FALSE(mScheduler->layerHistoryModeChangePending());
+}
+
+TEST_F(SchedulerTest, pendingModeChangeMultiDisplay) {
+    SET_FLAG_FOR_TEST(flags::pacesetter_selection, true);
+    SET_FLAG_FOR_TEST(flags::pacesetter_selection, true);
+
+    mScheduler->registerDisplay(kDisplayId2,
+                                std::make_shared<RefreshRateSelector>(kDisplay2Modes,
+                                                                      kDisplay2Mode60->getId()));
+    mScheduler->setDisplayPowerMode(kDisplayId1, hal::PowerMode::ON);
+    mScheduler->setDisplayPowerMode(kDisplayId2, hal::PowerMode::ON);
+
+    EXPECT_FALSE(mScheduler->layerHistoryModeChangePending());
+
+    mScheduler->setModeChangePending(kDisplayId1, true);
+    EXPECT_TRUE(mScheduler->layerHistoryModeChangePending());
+
+    mScheduler->setModeChangePending(kDisplayId2, true);
+    EXPECT_TRUE(mScheduler->layerHistoryModeChangePending());
+
+    mScheduler->setModeChangePending(kDisplayId1, false);
+    EXPECT_TRUE(mScheduler->layerHistoryModeChangePending());
+
+    mScheduler->setModeChangePending(kDisplayId2, false);
+    EXPECT_FALSE(mScheduler->layerHistoryModeChangePending());
+}
+
+TEST_F(SchedulerTest, pendingModeChangeInvalidDisplay) {
+    SET_FLAG_FOR_TEST(flags::pacesetter_selection, true);
+
+    EXPECT_FALSE(mScheduler->layerHistoryModeChangePending());
+
+    PhysicalDisplayId invalidDisplayId = PhysicalDisplayId::fromPort(123);
+    mScheduler->setModeChangePending(invalidDisplayId, true);
+    EXPECT_FALSE(mScheduler->layerHistoryModeChangePending());
+}
+
 class AttachedChoreographerTest : public SchedulerTest {
 protected:
     void frameRateTestScenario(Fps layerFps, int8_t frameRateCompatibility, Fps displayFps,
diff --git a/services/surfaceflinger/tests/unittests/SurfaceFlinger_DisplayModeSwitching.cpp b/services/surfaceflinger/tests/unittests/SurfaceFlinger_DisplayModeSwitching.cpp
index 3f710fdf6b..94b6dc8d6e 100644
--- a/services/surfaceflinger/tests/unittests/SurfaceFlinger_DisplayModeSwitching.cpp
+++ b/services/surfaceflinger/tests/unittests/SurfaceFlinger_DisplayModeSwitching.cpp
@@ -187,6 +187,50 @@ protected:
 
     static inline const DisplayModes kModes =
             makeModes(kMode60, kMode90, kMode120, kMode90_4K, kMode60_8K);
+
+    void setupChangeRefreshRateTests(bool allowGroupSwitching = false) {
+        EXPECT_THAT(mDisplay, ModeSettledTo(&dmc(), kModeId60));
+
+        EXPECT_EQ(NO_ERROR,
+                  mFlinger.setDesiredDisplayModeSpecs(
+                          mDisplay->getDisplayToken().promote(),
+                          mock::createDisplayModeSpecs(kModeId90, 120_Hz, allowGroupSwitching)));
+
+        EXPECT_THAT(mDisplay, ModeSwitchingTo(&mFlinger, kModeId90));
+
+        // Verify that next commit will call setActiveConfigWithConstraints in HWC
+        const VsyncPeriodChangeTimeline timeline{.refreshRequired = true};
+        EXPECT_SET_ACTIVE_CONFIG(kInnerDisplayHwcId, kModeId90);
+
+        mFlinger.commit();
+        Mock::VerifyAndClearExpectations(mComposer);
+
+        EXPECT_THAT(mDisplay, ModeSwitchingTo(&mFlinger, kModeId90));
+    }
+
+    void setupChangeRefreshRateOnTwoDisplays(sp<DisplayDevice> innerDisplay,
+                                             sp<DisplayDevice> outerDisplay) {
+        EXPECT_THAT(innerDisplay, ModeSettledTo(&dmc(), kModeId60));
+        EXPECT_THAT(outerDisplay, ModeSettledTo(&dmc(), kModeId120));
+
+        EXPECT_EQ(NO_ERROR,
+                  mFlinger.setDesiredDisplayModeSpecs(innerDisplay->getDisplayToken().promote(),
+                                                      mock::createDisplayModeSpecs(kModeId90,
+                                                                                   120_Hz, true)));
+        EXPECT_EQ(NO_ERROR,
+                  mFlinger.setDesiredDisplayModeSpecs(outerDisplay->getDisplayToken().promote(),
+                                                      mock::createDisplayModeSpecs(kModeId60, 60_Hz,
+                                                                                   true)));
+
+        EXPECT_THAT(innerDisplay, ModeSwitchingTo(&mFlinger, kModeId90));
+        EXPECT_THAT(outerDisplay, ModeSwitchingTo(&mFlinger, kModeId60));
+
+        // Verify that next commit will call setActiveConfigWithConstraints in HWC
+        // and complete the mode change.
+        const VsyncPeriodChangeTimeline timeline{.refreshRequired = false};
+        EXPECT_SET_ACTIVE_CONFIG(kInnerDisplayHwcId, kModeId90);
+        EXPECT_SET_ACTIVE_CONFIG(kOuterDisplayHwcId, kModeId60);
+    }
 };
 
 void DisplayModeSwitchingTest::setupScheduler(
@@ -213,28 +257,44 @@ void DisplayModeSwitchingTest::setupScheduler(
 }
 
 TEST_F(DisplayModeSwitchingTest, changeRefreshRateWithRefreshRequired) {
-    EXPECT_THAT(mDisplay, ModeSettledTo(&dmc(), kModeId60));
+    SET_FLAG_FOR_TEST(flags::unify_refresh_rate_callbacks, false);
+    EXPECT_NO_FATAL_FAILURE(setupChangeRefreshRateTests());
 
-    EXPECT_EQ(NO_ERROR,
-              mFlinger.setDesiredDisplayModeSpecs(mDisplay->getDisplayToken().promote(),
-                                                  mock::createDisplayModeSpecs(kModeId90, 120_Hz)));
+    // Verify that the next commit will complete the mode change and send
+    // a onModeChanged event to the framework.
+    EXPECT_CALL(*mAppEventThread,
+                onModeChanged(scheduler::FrameRateMode{90_Hz, ftl::as_non_null(kMode90)}, _));
 
-    EXPECT_THAT(mDisplay, ModeSwitchingTo(&mFlinger, kModeId90));
+    mFlinger.commit();
+    Mock::VerifyAndClearExpectations(mAppEventThread);
 
-    // Verify that next commit will call setActiveConfigWithConstraints in HWC
-    const VsyncPeriodChangeTimeline timeline{.refreshRequired = true};
-    EXPECT_SET_ACTIVE_CONFIG(kInnerDisplayHwcId, kModeId90);
+    EXPECT_THAT(mDisplay, ModeSettledTo(&dmc(), kModeId90));
+}
+
+TEST_F(DisplayModeSwitchingTest, changeRefreshRateWithoutRefreshRequired) {
+    SET_FLAG_FOR_TEST(flags::unify_refresh_rate_callbacks, false);
+    EXPECT_NO_FATAL_FAILURE(setupChangeRefreshRateTests(true));
+
+    EXPECT_CALL(*mAppEventThread,
+                onModeChanged(scheduler::FrameRateMode{90_Hz, ftl::as_non_null(kMode90)}, _));
 
     mFlinger.commit();
-    Mock::VerifyAndClearExpectations(mComposer);
 
-    EXPECT_THAT(mDisplay, ModeSwitchingTo(&mFlinger, kModeId90));
+    EXPECT_THAT(mDisplay, ModeSettledTo(&dmc(), kModeId90));
+}
+
+TEST_F(DisplayModeSwitchingTest, changeRefreshRateWithRefreshRequired_unifyRefreshRateCallbacks) {
+    SET_FLAG_FOR_TEST(flags::unify_refresh_rate_callbacks, true);
+    EXPECT_NO_FATAL_FAILURE(setupChangeRefreshRateTests());
 
     // Verify that the next commit will complete the mode change and send
     // a onModeChanged event to the framework.
-
     EXPECT_CALL(*mAppEventThread,
-                onModeChanged(scheduler::FrameRateMode{90_Hz, ftl::as_non_null(kMode90)}));
+                onModeAndFrameRateOverridesChanged(_,
+                                                   scheduler::FrameRateMode{90_Hz,
+                                                                            ftl::as_non_null(
+                                                                                    kMode90)},
+                                                   _, _));
 
     mFlinger.commit();
     Mock::VerifyAndClearExpectations(mAppEventThread);
@@ -242,24 +302,17 @@ TEST_F(DisplayModeSwitchingTest, changeRefreshRateWithRefreshRequired) {
     EXPECT_THAT(mDisplay, ModeSettledTo(&dmc(), kModeId90));
 }
 
-TEST_F(DisplayModeSwitchingTest, changeRefreshRateWithoutRefreshRequired) {
-    EXPECT_THAT(mDisplay, ModeSettledTo(&dmc(), kModeId60));
-
-    constexpr bool kAllowGroupSwitching = true;
-    EXPECT_EQ(NO_ERROR,
-              mFlinger.setDesiredDisplayModeSpecs(
-                      mDisplay->getDisplayToken().promote(),
-                      mock::createDisplayModeSpecs(kModeId90, 120_Hz, kAllowGroupSwitching)));
-
-    EXPECT_THAT(mDisplay, ModeSwitchingTo(&mFlinger, kModeId90));
-
-    // Verify that next commit will call setActiveConfigWithConstraints in HWC
-    // and complete the mode change.
-    const VsyncPeriodChangeTimeline timeline{.refreshRequired = false};
-    EXPECT_SET_ACTIVE_CONFIG(kInnerDisplayHwcId, kModeId90);
+TEST_F(DisplayModeSwitchingTest,
+       changeRefreshRateWithoutRefreshRequired_unifyRefreshRateCallbacks) {
+    SET_FLAG_FOR_TEST(flags::unify_refresh_rate_callbacks, true);
+    EXPECT_NO_FATAL_FAILURE(setupChangeRefreshRateTests(true));
 
     EXPECT_CALL(*mAppEventThread,
-                onModeChanged(scheduler::FrameRateMode{90_Hz, ftl::as_non_null(kMode90)}));
+                onModeAndFrameRateOverridesChanged(_,
+                                                   scheduler::FrameRateMode{90_Hz,
+                                                                            ftl::as_non_null(
+                                                                                    kMode90)},
+                                                   _, _));
 
     mFlinger.commit();
 
@@ -267,30 +320,25 @@ TEST_F(DisplayModeSwitchingTest, changeRefreshRateWithoutRefreshRequired) {
 }
 
 TEST_F(DisplayModeSwitchingTest, changeRefreshRateOnTwoDisplaysWithoutRefreshRequired) {
+    SET_FLAG_FOR_TEST(flags::unify_refresh_rate_callbacks, false);
     const auto [innerDisplay, outerDisplay] = injectOuterDisplay();
+    EXPECT_NO_FATAL_FAILURE(setupChangeRefreshRateOnTwoDisplays(innerDisplay, outerDisplay));
 
-    EXPECT_THAT(innerDisplay, ModeSettledTo(&dmc(), kModeId60));
-    EXPECT_THAT(outerDisplay, ModeSettledTo(&dmc(), kModeId120));
+    EXPECT_CALL(*mAppEventThread, onModeChanged(_, _)).Times(2);
 
-    EXPECT_EQ(NO_ERROR,
-              mFlinger.setDesiredDisplayModeSpecs(innerDisplay->getDisplayToken().promote(),
-                                                  mock::createDisplayModeSpecs(kModeId90, 120_Hz,
-                                                                               true)));
-    EXPECT_EQ(NO_ERROR,
-              mFlinger.setDesiredDisplayModeSpecs(outerDisplay->getDisplayToken().promote(),
-                                                  mock::createDisplayModeSpecs(kModeId60, 60_Hz,
-                                                                               true)));
+    mFlinger.commit();
 
-    EXPECT_THAT(innerDisplay, ModeSwitchingTo(&mFlinger, kModeId90));
-    EXPECT_THAT(outerDisplay, ModeSwitchingTo(&mFlinger, kModeId60));
+    EXPECT_THAT(innerDisplay, ModeSettledTo(&dmc(), kModeId90));
+    EXPECT_THAT(outerDisplay, ModeSettledTo(&dmc(), kModeId60));
+}
 
-    // Verify that next commit will call setActiveConfigWithConstraints in HWC
-    // and complete the mode change.
-    const VsyncPeriodChangeTimeline timeline{.refreshRequired = false};
-    EXPECT_SET_ACTIVE_CONFIG(kInnerDisplayHwcId, kModeId90);
-    EXPECT_SET_ACTIVE_CONFIG(kOuterDisplayHwcId, kModeId60);
+TEST_F(DisplayModeSwitchingTest,
+       changeRefreshRateOnTwoDisplaysWithoutRefreshRequired_unifyRefreshRateCallbacks) {
+    SET_FLAG_FOR_TEST(flags::unify_refresh_rate_callbacks, true);
+    const auto [innerDisplay, outerDisplay] = injectOuterDisplay();
+    EXPECT_NO_FATAL_FAILURE(setupChangeRefreshRateOnTwoDisplays(innerDisplay, outerDisplay));
 
-    EXPECT_CALL(*mAppEventThread, onModeChanged(_)).Times(2);
+    EXPECT_CALL(*mAppEventThread, onModeAndFrameRateOverridesChanged(_, _, _, _)).Times(2);
 
     mFlinger.commit();
 
diff --git a/services/surfaceflinger/tests/unittests/SurfaceFlinger_DisplayTransactionCommitTest.cpp b/services/surfaceflinger/tests/unittests/SurfaceFlinger_DisplayTransactionCommitTest.cpp
index eac5a8e9c5..234eab1d2a 100644
--- a/services/surfaceflinger/tests/unittests/SurfaceFlinger_DisplayTransactionCommitTest.cpp
+++ b/services/surfaceflinger/tests/unittests/SurfaceFlinger_DisplayTransactionCommitTest.cpp
@@ -17,6 +17,8 @@
 #undef LOG_TAG
 #define LOG_TAG "LibSurfaceFlingerUnittests"
 
+#include <ui/ScreenPartStatus.h>
+
 #include "DisplayTransactionTestHelpers.h"
 
 namespace android {
@@ -225,7 +227,7 @@ void DisplayTransactionCommitTest::processesHotplugDisconnectCommon() {
     // --------------------------------------------------------------------
     // Call Expectations
 
-    EXPECT_CALL(*mComposer, getDisplayIdentificationData(Case::Display::HWC_DISPLAY_ID, _, _))
+    EXPECT_CALL(*mComposer, getDisplayIdentificationData(Case::Display::HWC_DISPLAY_ID, _, _, _))
             .Times(0);
 
     setupCommonCallExpectationsForDisconnectProcessing<Case>();
@@ -275,9 +277,10 @@ TEST_F(DisplayTransactionCommitTest, ignoresHotplugConnectIfPrimaryAndExternalAl
 
     // TODO: This is an unnecessary call.
     EXPECT_CALL(*mComposer,
-                getDisplayIdentificationData(TertiaryDisplayVariant::HWC_DISPLAY_ID, _, _))
+                getDisplayIdentificationData(TertiaryDisplayVariant::HWC_DISPLAY_ID, _, _, _))
             .WillOnce(DoAll(SetArgPointee<1>(TertiaryDisplay<kSecure>::PORT),
                             SetArgPointee<2>(TertiaryDisplay<kSecure>::GET_IDENTIFICATION_DATA()),
+                            SetArgPointee<3>(android::ScreenPartStatus::UNSUPPORTED),
                             Return(Error::NONE)));
 
     ignoresHotplugConnectCommon<SimpleTertiaryDisplayCase>();
@@ -291,9 +294,10 @@ TEST_F(DisplayTransactionCommitTest,
 
     // TODO: This is an unnecessary call.
     EXPECT_CALL(*mComposer,
-                getDisplayIdentificationData(TertiaryDisplayVariant::HWC_DISPLAY_ID, _, _))
+                getDisplayIdentificationData(TertiaryDisplayVariant::HWC_DISPLAY_ID, _, _, _))
             .WillOnce(DoAll(SetArgPointee<1>(TertiaryDisplay<kSecure>::PORT),
                             SetArgPointee<2>(TertiaryDisplay<kSecure>::GET_IDENTIFICATION_DATA()),
+                            SetArgPointee<3>(android::ScreenPartStatus::UNSUPPORTED),
                             Return(Error::NONE)));
 
     ignoresHotplugConnectCommon<SimpleTertiaryDisplayNonSecureCase>();
diff --git a/services/surfaceflinger/tests/unittests/SurfaceFlinger_FoldableTest.cpp b/services/surfaceflinger/tests/unittests/SurfaceFlinger_FoldableTest.cpp
index 8972840c8a..ab50437dc4 100644
--- a/services/surfaceflinger/tests/unittests/SurfaceFlinger_FoldableTest.cpp
+++ b/services/surfaceflinger/tests/unittests/SurfaceFlinger_FoldableTest.cpp
@@ -35,11 +35,11 @@ struct FoldableTest : DualDisplayTransactionTest<hal::PowerMode::OFF, hal::Power
 
 TEST_F(FoldableTest, promotesPacesetterOnBoot) {
     // When the device boots, the inner display should be the pacesetter.
-    ASSERT_EQ(mFlinger.scheduler()->pacesetterDisplayId(), kInnerDisplayId);
+    ASSERT_EQ(mFlinger.scheduler()->pacesetterDisplayId(), getInnerDisplayId());
 
     // ...and should still be after powering on.
     mFlinger.setPhysicalDisplayPowerMode(mInnerDisplay, PowerMode::ON);
-    ASSERT_EQ(mFlinger.scheduler()->pacesetterDisplayId(), kInnerDisplayId);
+    ASSERT_EQ(mFlinger.scheduler()->pacesetterDisplayId(), getInnerDisplayId());
 }
 
 TEST_F(FoldableTest, promotesPacesetterOnFoldUnfold) {
@@ -48,12 +48,12 @@ TEST_F(FoldableTest, promotesPacesetterOnFoldUnfold) {
     // The outer display should become the pacesetter after folding.
     mFlinger.setPhysicalDisplayPowerMode(mInnerDisplay, PowerMode::OFF);
     mFlinger.setPhysicalDisplayPowerMode(mOuterDisplay, PowerMode::ON);
-    ASSERT_EQ(mFlinger.scheduler()->pacesetterDisplayId(), kOuterDisplayId);
+    ASSERT_EQ(mFlinger.scheduler()->pacesetterDisplayId(), getOuterDisplayId());
 
     // The inner display should become the pacesetter after unfolding.
     mFlinger.setPhysicalDisplayPowerMode(mOuterDisplay, PowerMode::OFF);
     mFlinger.setPhysicalDisplayPowerMode(mInnerDisplay, PowerMode::ON);
-    ASSERT_EQ(mFlinger.scheduler()->pacesetterDisplayId(), kInnerDisplayId);
+    ASSERT_EQ(mFlinger.scheduler()->pacesetterDisplayId(), getInnerDisplayId());
 }
 
 TEST_F(FoldableTest, promotesPacesetterOnConcurrentPowerOn) {
@@ -62,15 +62,15 @@ TEST_F(FoldableTest, promotesPacesetterOnConcurrentPowerOn) {
     // The inner display should stay the pacesetter if both are powered on.
     // TODO(b/255635821): The pacesetter should depend on the displays' refresh rates.
     mFlinger.setPhysicalDisplayPowerMode(mOuterDisplay, PowerMode::ON);
-    ASSERT_EQ(mFlinger.scheduler()->pacesetterDisplayId(), kInnerDisplayId);
+    ASSERT_EQ(mFlinger.scheduler()->pacesetterDisplayId(), getInnerDisplayId());
 
     // The outer display should become the pacesetter if designated.
-    mFlinger.scheduler()->setPacesetterDisplay(kOuterDisplayId);
-    ASSERT_EQ(mFlinger.scheduler()->pacesetterDisplayId(), kOuterDisplayId);
+    mFlinger.scheduler()->setPacesetterDisplay(getOuterDisplayId());
+    ASSERT_EQ(mFlinger.scheduler()->pacesetterDisplayId(), getOuterDisplayId());
 
     // The inner display should become the pacesetter if designated.
-    mFlinger.scheduler()->setPacesetterDisplay(kInnerDisplayId);
-    ASSERT_EQ(mFlinger.scheduler()->pacesetterDisplayId(), kInnerDisplayId);
+    mFlinger.scheduler()->setPacesetterDisplay(getInnerDisplayId());
+    ASSERT_EQ(mFlinger.scheduler()->pacesetterDisplayId(), getInnerDisplayId());
 }
 
 TEST_F(FoldableTest, promotesPacesetterOnConcurrentPowerOff) {
@@ -79,38 +79,38 @@ TEST_F(FoldableTest, promotesPacesetterOnConcurrentPowerOff) {
 
     // The outer display should become the pacesetter if the inner display powers off.
     mFlinger.setPhysicalDisplayPowerMode(mInnerDisplay, PowerMode::OFF);
-    ASSERT_EQ(mFlinger.scheduler()->pacesetterDisplayId(), kOuterDisplayId);
+    ASSERT_EQ(mFlinger.scheduler()->pacesetterDisplayId(), getOuterDisplayId());
 
     // The outer display should stay the pacesetter if both are powered on.
     // TODO(b/255635821): The pacesetter should depend on the displays' refresh rates.
     mFlinger.setPhysicalDisplayPowerMode(mInnerDisplay, PowerMode::ON);
-    ASSERT_EQ(mFlinger.scheduler()->pacesetterDisplayId(), kOuterDisplayId);
+    ASSERT_EQ(mFlinger.scheduler()->pacesetterDisplayId(), getOuterDisplayId());
 
     // The inner display should become the pacesetter if the outer display powers off.
     mFlinger.setPhysicalDisplayPowerMode(mOuterDisplay, PowerMode::OFF);
-    ASSERT_EQ(mFlinger.scheduler()->pacesetterDisplayId(), kInnerDisplayId);
+    ASSERT_EQ(mFlinger.scheduler()->pacesetterDisplayId(), getInnerDisplayId());
 }
 
 TEST_F(FoldableTest, doesNotRequestHardwareVsyncIfPoweredOff) {
     // Both displays are powered off.
-    EXPECT_CALL(mFlinger.mockSchedulerCallback(), requestHardwareVsync(kInnerDisplayId, _))
+    EXPECT_CALL(mFlinger.mockSchedulerCallback(), requestHardwareVsync(getInnerDisplayId(), _))
             .Times(0);
-    EXPECT_CALL(mFlinger.mockSchedulerCallback(), requestHardwareVsync(kOuterDisplayId, _))
+    EXPECT_CALL(mFlinger.mockSchedulerCallback(), requestHardwareVsync(getOuterDisplayId(), _))
             .Times(0);
 
     EXPECT_FALSE(mInnerDisplay->isPoweredOn());
     EXPECT_FALSE(mOuterDisplay->isPoweredOn());
 
     auto& scheduler = *mFlinger.scheduler();
-    scheduler.onHardwareVsyncRequest(kInnerDisplayId, true);
-    scheduler.onHardwareVsyncRequest(kOuterDisplayId, true);
+    scheduler.onHardwareVsyncRequest(getInnerDisplayId(), true);
+    scheduler.onHardwareVsyncRequest(getOuterDisplayId(), true);
 }
 
 TEST_F(FoldableTest, requestsHardwareVsyncForInnerDisplay) {
     // Only inner display is powered on.
-    EXPECT_CALL(mFlinger.mockSchedulerCallback(), requestHardwareVsync(kInnerDisplayId, true))
+    EXPECT_CALL(mFlinger.mockSchedulerCallback(), requestHardwareVsync(getInnerDisplayId(), true))
             .Times(1);
-    EXPECT_CALL(mFlinger.mockSchedulerCallback(), requestHardwareVsync(kOuterDisplayId, _))
+    EXPECT_CALL(mFlinger.mockSchedulerCallback(), requestHardwareVsync(getOuterDisplayId(), _))
             .Times(0);
 
     // The injected VsyncSchedule uses TestableScheduler::mockRequestHardwareVsync, so no calls to
@@ -121,15 +121,15 @@ TEST_F(FoldableTest, requestsHardwareVsyncForInnerDisplay) {
     EXPECT_FALSE(mOuterDisplay->isPoweredOn());
 
     auto& scheduler = *mFlinger.scheduler();
-    scheduler.onHardwareVsyncRequest(kInnerDisplayId, true);
-    scheduler.onHardwareVsyncRequest(kOuterDisplayId, true);
+    scheduler.onHardwareVsyncRequest(getInnerDisplayId(), true);
+    scheduler.onHardwareVsyncRequest(getOuterDisplayId(), true);
 }
 
 TEST_F(FoldableTest, requestsHardwareVsyncForOuterDisplay) {
     // Only outer display is powered on.
-    EXPECT_CALL(mFlinger.mockSchedulerCallback(), requestHardwareVsync(kInnerDisplayId, _))
+    EXPECT_CALL(mFlinger.mockSchedulerCallback(), requestHardwareVsync(getInnerDisplayId(), _))
             .Times(0);
-    EXPECT_CALL(mFlinger.mockSchedulerCallback(), requestHardwareVsync(kOuterDisplayId, true))
+    EXPECT_CALL(mFlinger.mockSchedulerCallback(), requestHardwareVsync(getOuterDisplayId(), true))
             .Times(1);
 
     // The injected VsyncSchedule uses TestableScheduler::mockRequestHardwareVsync, so no calls to
@@ -142,15 +142,15 @@ TEST_F(FoldableTest, requestsHardwareVsyncForOuterDisplay) {
     EXPECT_TRUE(mOuterDisplay->isPoweredOn());
 
     auto& scheduler = *mFlinger.scheduler();
-    scheduler.onHardwareVsyncRequest(kInnerDisplayId, true);
-    scheduler.onHardwareVsyncRequest(kOuterDisplayId, true);
+    scheduler.onHardwareVsyncRequest(getInnerDisplayId(), true);
+    scheduler.onHardwareVsyncRequest(getOuterDisplayId(), true);
 }
 
 TEST_F(FoldableTest, requestsHardwareVsyncForBothDisplays) {
     // Both displays are powered on.
-    EXPECT_CALL(mFlinger.mockSchedulerCallback(), requestHardwareVsync(kInnerDisplayId, true))
+    EXPECT_CALL(mFlinger.mockSchedulerCallback(), requestHardwareVsync(getInnerDisplayId(), true))
             .Times(1);
-    EXPECT_CALL(mFlinger.mockSchedulerCallback(), requestHardwareVsync(kOuterDisplayId, true))
+    EXPECT_CALL(mFlinger.mockSchedulerCallback(), requestHardwareVsync(getOuterDisplayId(), true))
             .Times(1);
 
     // The injected VsyncSchedule uses TestableScheduler::mockRequestHardwareVsync, so no calls to
@@ -167,9 +167,9 @@ TEST_F(FoldableTest, requestsHardwareVsyncForBothDisplays) {
 }
 
 TEST_F(FoldableTest, requestVsyncOnPowerOn) {
-    EXPECT_CALL(mFlinger.scheduler()->mockRequestHardwareVsync, Call(kInnerDisplayId, true))
+    EXPECT_CALL(mFlinger.scheduler()->mockRequestHardwareVsync, Call(getInnerDisplayId(), true))
             .Times(1);
-    EXPECT_CALL(mFlinger.scheduler()->mockRequestHardwareVsync, Call(kOuterDisplayId, true))
+    EXPECT_CALL(mFlinger.scheduler()->mockRequestHardwareVsync, Call(getOuterDisplayId(), true))
             .Times(1);
 
     mFlinger.setPhysicalDisplayPowerMode(mInnerDisplay, PowerMode::ON);
@@ -178,16 +178,16 @@ TEST_F(FoldableTest, requestVsyncOnPowerOn) {
 
 TEST_F(FoldableTest, disableVsyncOnPowerOffPacesetter) {
     // When the device boots, the inner display should be the pacesetter.
-    ASSERT_EQ(mFlinger.scheduler()->pacesetterDisplayId(), kInnerDisplayId);
+    ASSERT_EQ(mFlinger.scheduler()->pacesetterDisplayId(), getInnerDisplayId());
 
     testing::InSequence seq;
-    EXPECT_CALL(mFlinger.scheduler()->mockRequestHardwareVsync, Call(kInnerDisplayId, true))
+    EXPECT_CALL(mFlinger.scheduler()->mockRequestHardwareVsync, Call(getInnerDisplayId(), true))
             .Times(1);
-    EXPECT_CALL(mFlinger.scheduler()->mockRequestHardwareVsync, Call(kOuterDisplayId, true))
+    EXPECT_CALL(mFlinger.scheduler()->mockRequestHardwareVsync, Call(getOuterDisplayId(), true))
             .Times(1);
 
     // Turning off the pacesetter will result in disabling VSYNC.
-    EXPECT_CALL(mFlinger.scheduler()->mockRequestHardwareVsync, Call(kInnerDisplayId, false))
+    EXPECT_CALL(mFlinger.scheduler()->mockRequestHardwareVsync, Call(getInnerDisplayId(), false))
             .Times(1);
 
     mFlinger.setPhysicalDisplayPowerMode(mInnerDisplay, PowerMode::ON);
@@ -196,7 +196,34 @@ TEST_F(FoldableTest, disableVsyncOnPowerOffPacesetter) {
     mFlinger.setPhysicalDisplayPowerMode(mInnerDisplay, PowerMode::OFF);
 
     // Other display is now the pacesetter.
-    ASSERT_EQ(mFlinger.scheduler()->pacesetterDisplayId(), kOuterDisplayId);
+    ASSERT_EQ(mFlinger.scheduler()->pacesetterDisplayId(), getOuterDisplayId());
+}
+
+TEST_F(FoldableTest, layerCachingTexturePoolOnFrontInternal) {
+    ASSERT_EQ(mFlinger.scheduler()->pacesetterDisplayId(), getInnerDisplayId());
+
+    // In order for TexturePool to be enabled, layer caching needs to be enabled.
+    mInnerDisplay->getCompositionDisplay()->setLayerCachingEnabled(true);
+    mOuterDisplay->getCompositionDisplay()->setLayerCachingEnabled(true);
+
+    mFlinger.setPhysicalDisplayPowerMode(mOuterDisplay, PowerMode::OFF);
+    mFlinger.setPhysicalDisplayPowerMode(mInnerDisplay, PowerMode::ON);
+
+    // Switching to outer display as the front-internal display should disable the inner display's
+    // pool and enable the outer display's pool.
+    mFlinger.setPhysicalDisplayPowerMode(mOuterDisplay, PowerMode::ON);
+    mFlinger.setPhysicalDisplayPowerMode(mInnerDisplay, PowerMode::OFF);
+
+    ASSERT_EQ(mFlinger.scheduler()->pacesetterDisplayId(), getOuterDisplayId());
+
+    EXPECT_FALSE(mInnerDisplay->getCompositionDisplay()->plannerTexturePoolEnabled());
+    EXPECT_TRUE(mOuterDisplay->getCompositionDisplay()->plannerTexturePoolEnabled());
+
+    mFlinger.setPhysicalDisplayPowerMode(mOuterDisplay, PowerMode::OFF);
+    mFlinger.setPhysicalDisplayPowerMode(mInnerDisplay, PowerMode::ON);
+
+    EXPECT_TRUE(mInnerDisplay->getCompositionDisplay()->plannerTexturePoolEnabled());
+    EXPECT_FALSE(mOuterDisplay->getCompositionDisplay()->plannerTexturePoolEnabled());
 }
 
 } // namespace
diff --git a/services/surfaceflinger/tests/unittests/SurfaceFlinger_HotplugTest.cpp b/services/surfaceflinger/tests/unittests/SurfaceFlinger_HotplugTest.cpp
index b8b1b9527c..97e82187fe 100644
--- a/services/surfaceflinger/tests/unittests/SurfaceFlinger_HotplugTest.cpp
+++ b/services/surfaceflinger/tests/unittests/SurfaceFlinger_HotplugTest.cpp
@@ -295,7 +295,7 @@ TEST_F(HotplugTest, rejectsHotplugOnActivePortsDuplicate) {
     // We expect display identification to be fetched correctly, since EDID and
     // port are available and successfully retrieved from HAL.
     EXPECT_CALL(*mComposer,
-                getDisplayIdentificationData(DuplicatePortDisplay::HWC_DISPLAY_ID, _, _))
+                getDisplayIdentificationData(DuplicatePortDisplay::HWC_DISPLAY_ID, _, _, _))
             .WillOnce(DoAll(SetArgPointee<1>(*DuplicatePortDisplay::PORT::value),
                             SetArgPointee<2>(getExternalEedid()), Return(Error::NONE)));
 
diff --git a/services/surfaceflinger/tests/unittests/SurfaceFlinger_NotifyExpectedPresentTest.cpp b/services/surfaceflinger/tests/unittests/SurfaceFlinger_NotifyExpectedPresentTest.cpp
index 9c143fdd41..8191a3cc31 100644
--- a/services/surfaceflinger/tests/unittests/SurfaceFlinger_NotifyExpectedPresentTest.cpp
+++ b/services/surfaceflinger/tests/unittests/SurfaceFlinger_NotifyExpectedPresentTest.cpp
@@ -14,6 +14,7 @@
  * limitations under the License.
  */
 
+#include "gui/TransactionState.h"
 #undef LOG_TAG
 #define LOG_TAG "LibSurfaceFlingerUnittests"
 
@@ -45,15 +46,29 @@ protected:
     void setTransactionState() {
         ASSERT_TRUE(mFlinger.getTransactionQueue().isEmpty());
         TransactionInfo transaction;
-        mFlinger.setTransactionState(std::move(transaction));
+        mFlinger.setTransactionState(FrameTimelineInfo{}, transaction.mutableState,
+                                     transaction.flags, transaction.applyToken,
+                                     transaction.inputWindowCommands,
+                                     TimePoint::now().ns() + s2ns(1), transaction.isAutoTimestamp,
+                                     transaction.unCachedBuffers,
+                                     /*HasListenerCallbacks=*/false, transaction.callbacks,
+                                     transaction.id, transaction.mergedTransactionIds,
+                                     transaction.earlyWakeupInfos);
     }
 
-    struct TransactionInfo : public TransactionState {
-        TransactionInfo() {
-            mApplyToken = IInterface::asBinder(TransactionCompletedListener::getIInstance());
-            mIsAutoTimestamp = false;
-            mId = static_cast<uint64_t>(-1);
-        }
+    struct TransactionInfo {
+        MutableTransactionState mutableState;
+        uint32_t flags = 0;
+        sp<IBinder> applyToken = IInterface::asBinder(TransactionCompletedListener::getIInstance());
+        InputWindowCommands inputWindowCommands;
+        int64_t desiredPresentTime = 0;
+        bool isAutoTimestamp = false;
+        FrameTimelineInfo frameTimelineInfo{};
+        std::vector<client_cache_t> unCachedBuffers;
+        uint64_t id = static_cast<uint64_t>(-1);
+        std::vector<uint64_t> mergedTransactionIds;
+        std::vector<gui::EarlyWakeupInfo> earlyWakeupInfos;
+        std::vector<ListenerCallbacks> callbacks;
     };
 
     struct Compositor final : ICompositor {
diff --git a/services/surfaceflinger/tests/unittests/SurfaceFlinger_SetPhysicalDisplayPowerModeTest.cpp b/services/surfaceflinger/tests/unittests/SurfaceFlinger_SetPhysicalDisplayPowerModeTest.cpp
index d5c22a9601..6b05b7d162 100644
--- a/services/surfaceflinger/tests/unittests/SurfaceFlinger_SetPhysicalDisplayPowerModeTest.cpp
+++ b/services/surfaceflinger/tests/unittests/SurfaceFlinger_SetPhysicalDisplayPowerModeTest.cpp
@@ -17,6 +17,7 @@
 #undef LOG_TAG
 #define LOG_TAG "LibSurfaceFlingerUnittests"
 
+#include <android_companion_virtualdevice_flags.h>
 #include <com_android_graphics_surfaceflinger_flags.h>
 #include <common/test/FlagUtils.h>
 #include "DisplayTransactionTestHelpers.h"
@@ -67,40 +68,6 @@ struct DozeNotSupportedVariant {
     }
 };
 
-struct EventThreadBaseSupportedVariant {
-    static void setupVsyncNoCallExpectations(DisplayTransactionTest* test) {
-        // Expect no change to hardware nor synthetic VSYNC.
-        EXPECT_CALL(test->mFlinger.scheduler()->mockRequestHardwareVsync, Call(_, _)).Times(0);
-        EXPECT_CALL(*test->mEventThread, enableSyntheticVsync(_)).Times(0);
-    }
-};
-
-struct EventThreadNotSupportedVariant : public EventThreadBaseSupportedVariant {
-    static void setupEnableVsyncCallExpectations(DisplayTransactionTest* test) {
-        EXPECT_CALL(test->mFlinger.scheduler()->mockRequestHardwareVsync, Call(_, true)).Times(1);
-        EXPECT_CALL(*test->mEventThread, enableSyntheticVsync(_)).Times(0);
-    }
-
-    static void setupDisableVsyncCallExpectations(DisplayTransactionTest* test) {
-        EXPECT_CALL(test->mFlinger.scheduler()->mockRequestHardwareVsync, Call(_, false)).Times(1);
-        EXPECT_CALL(*test->mEventThread, enableSyntheticVsync(_)).Times(0);
-    }
-};
-
-struct EventThreadIsSupportedVariant : public EventThreadBaseSupportedVariant {
-    static void setupEnableVsyncCallExpectations(DisplayTransactionTest* test) {
-        // Expect to enable hardware VSYNC and disable synthetic VSYNC.
-        EXPECT_CALL(test->mFlinger.scheduler()->mockRequestHardwareVsync, Call(_, true)).Times(1);
-        EXPECT_CALL(*test->mEventThread, enableSyntheticVsync(false)).Times(1);
-    }
-
-    static void setupDisableVsyncCallExpectations(DisplayTransactionTest* test) {
-        // Expect to disable hardware VSYNC and enable synthetic VSYNC.
-        EXPECT_CALL(test->mFlinger.scheduler()->mockRequestHardwareVsync, Call(_, false)).Times(1);
-        EXPECT_CALL(*test->mEventThread, enableSyntheticVsync(true)).Times(1);
-    }
-};
-
 struct DispSyncIsSupportedVariant {
     static void setupResetModelCallExpectations(DisplayTransactionTest* test) {
         auto vsyncSchedule = test->mFlinger.scheduler()->getVsyncSchedule();
@@ -136,7 +103,7 @@ struct TransitionOffToOnVariant : public TransitionVariantCommon<PowerMode::OFF,
     template <typename Case>
     static void setupCallExpectations(DisplayTransactionTest* test) {
         Case::setupComposerCallExpectations(test, IComposerClient::PowerMode::ON);
-        Case::EventThread::setupEnableVsyncCallExpectations(test);
+        Case::setupEnableVsyncCallExpectations(test);
         Case::DispSync::setupResetModelCallExpectations(test);
         Case::setupRepaintEverythingCallExpectations(test);
     }
@@ -151,7 +118,7 @@ struct TransitionOffToDozeSuspendVariant
     template <typename Case>
     static void setupCallExpectations(DisplayTransactionTest* test) {
         Case::setupComposerCallExpectations(test, Case::Doze::ACTUAL_POWER_MODE_FOR_DOZE_SUSPEND);
-        Case::EventThread::setupVsyncNoCallExpectations(test);
+        Case::setupEnableSyntheticVsyncCallExpectations(test);
         Case::setupRepaintEverythingCallExpectations(test);
     }
 
@@ -163,7 +130,7 @@ struct TransitionOffToDozeSuspendVariant
 struct TransitionOnToOffVariant : public TransitionVariantCommon<PowerMode::ON, PowerMode::OFF> {
     template <typename Case>
     static void setupCallExpectations(DisplayTransactionTest* test) {
-        Case::EventThread::setupDisableVsyncCallExpectations(test);
+        Case::setupDisableVsyncCallExpectations(test);
         Case::setupComposerCallExpectations(test, IComposerClient::PowerMode::OFF);
     }
 
@@ -176,7 +143,7 @@ struct TransitionDozeSuspendToOffVariant
       : public TransitionVariantCommon<PowerMode::DOZE_SUSPEND, PowerMode::OFF> {
     template <typename Case>
     static void setupCallExpectations(DisplayTransactionTest* test) {
-        Case::EventThread::setupVsyncNoCallExpectations(test);
+        Case::setupEnableSyntheticVsyncCallExpectations(test);
         Case::setupComposerCallExpectations(test, IComposerClient::PowerMode::OFF);
     }
 
@@ -188,7 +155,7 @@ struct TransitionDozeSuspendToOffVariant
 struct TransitionOnToDozeVariant : public TransitionVariantCommon<PowerMode::ON, PowerMode::DOZE> {
     template <typename Case>
     static void setupCallExpectations(DisplayTransactionTest* test) {
-        Case::EventThread::setupVsyncNoCallExpectations(test);
+        Case::setupDisableSyntheticVsyncCallExpectations(test);
         Case::setupComposerCallExpectations(test, Case::Doze::ACTUAL_POWER_MODE_FOR_DOZE);
     }
 };
@@ -197,7 +164,7 @@ struct TransitionDozeSuspendToDozeVariant
       : public TransitionVariantCommon<PowerMode::DOZE_SUSPEND, PowerMode::DOZE> {
     template <typename Case>
     static void setupCallExpectations(DisplayTransactionTest* test) {
-        Case::EventThread::setupEnableVsyncCallExpectations(test);
+        Case::setupEnableVsyncCallExpectations(test);
         Case::DispSync::setupResetModelCallExpectations(test);
         Case::setupComposerCallExpectations(test, Case::Doze::ACTUAL_POWER_MODE_FOR_DOZE);
     }
@@ -206,7 +173,7 @@ struct TransitionDozeSuspendToDozeVariant
 struct TransitionDozeToOnVariant : public TransitionVariantCommon<PowerMode::DOZE, PowerMode::ON> {
     template <typename Case>
     static void setupCallExpectations(DisplayTransactionTest* test) {
-        Case::EventThread::setupVsyncNoCallExpectations(test);
+        Case::setupDisableSyntheticVsyncCallExpectations(test);
         Case::setupComposerCallExpectations(test, IComposerClient::PowerMode::ON);
     }
 };
@@ -215,7 +182,7 @@ struct TransitionDozeSuspendToOnVariant
       : public TransitionVariantCommon<PowerMode::DOZE_SUSPEND, PowerMode::ON> {
     template <typename Case>
     static void setupCallExpectations(DisplayTransactionTest* test) {
-        Case::EventThread::setupEnableVsyncCallExpectations(test);
+        Case::setupEnableVsyncCallExpectations(test);
         Case::DispSync::setupResetModelCallExpectations(test);
         Case::setupComposerCallExpectations(test, IComposerClient::PowerMode::ON);
     }
@@ -225,7 +192,7 @@ struct TransitionOnToDozeSuspendVariant
       : public TransitionVariantCommon<PowerMode::ON, PowerMode::DOZE_SUSPEND> {
     template <typename Case>
     static void setupCallExpectations(DisplayTransactionTest* test) {
-        Case::EventThread::setupDisableVsyncCallExpectations(test);
+        Case::setupDisableVsyncCallExpectations(test);
         Case::setupComposerCallExpectations(test, Case::Doze::ACTUAL_POWER_MODE_FOR_DOZE_SUSPEND);
     }
 };
@@ -234,7 +201,7 @@ struct TransitionOnToUnknownVariant
       : public TransitionVariantCommon<PowerMode::ON, static_cast<PowerMode>(POWER_MODE_LEET)> {
     template <typename Case>
     static void setupCallExpectations(DisplayTransactionTest* test) {
-        Case::EventThread::setupVsyncNoCallExpectations(test);
+        Case::setupDisableSyntheticVsyncCallExpectations(test);
         Case::setupNoComposerPowerModeCallExpectations(test);
     }
 };
@@ -247,12 +214,11 @@ struct TransitionOnToUnknownVariant
 // display type, and the other for another display type.
 // --------------------------------------------------------------------
 
-template <typename DisplayVariant, typename DozeVariant, typename EventThreadVariant,
-          typename DispSyncVariant, typename TransitionVariant>
+template <typename DisplayVariant, typename DozeVariant, typename DispSyncVariant,
+          typename TransitionVariant>
 struct DisplayPowerCase {
     using Display = DisplayVariant;
     using Doze = DozeVariant;
-    using EventThread = EventThreadVariant;
     using DispSync = DispSyncVariant;
     using Transition = TransitionVariant;
 
@@ -291,19 +257,41 @@ struct DisplayPowerCase {
     static void setupNoComposerPowerModeCallExpectations(DisplayTransactionTest* test) {
         EXPECT_CALL(*test->mComposer, setPowerMode(Display::HWC_DISPLAY_ID, _)).Times(0);
     }
+
+    static void setupVsyncNoCallExpectations(DisplayTransactionTest* test) {
+        // Expect no change to hardware nor synthetic VSYNC.
+        EXPECT_CALL(test->mFlinger.scheduler()->mockRequestHardwareVsync, Call(_, _)).Times(0);
+        EXPECT_CALL(*test->mEventThread, enableSyntheticVsync(_)).Times(0);
+    }
+
+    static void setupEnableVsyncCallExpectations(DisplayTransactionTest* test) {
+        // Expect to enable hardware VSYNC and disable synthetic VSYNC.
+        EXPECT_CALL(test->mFlinger.scheduler()->mockRequestHardwareVsync, Call(_, true)).Times(1);
+        setupDisableSyntheticVsyncCallExpectations(test);
+    }
+
+    static void setupDisableSyntheticVsyncCallExpectations(DisplayTransactionTest* test) {
+        EXPECT_CALL(*test->mEventThread, enableSyntheticVsync(false)).Times(1);
+    }
+
+    static void setupDisableVsyncCallExpectations(DisplayTransactionTest* test) {
+        // Expect to disable hardware VSYNC and enable synthetic VSYNC.
+        EXPECT_CALL(test->mFlinger.scheduler()->mockRequestHardwareVsync, Call(_, false)).Times(1);
+        setupEnableSyntheticVsyncCallExpectations(test);
+    }
+
+    static void setupEnableSyntheticVsyncCallExpectations(DisplayTransactionTest* test) {
+        EXPECT_CALL(*test->mEventThread, enableSyntheticVsync(true)).Times(1);
+    }
 };
 
-// A sample configuration for the primary display.
-// In addition to having event thread support, we emulate doze support.
+// A sample configuration for the primary display. We emulate doze support.
 template <typename TransitionVariant>
 using PrimaryDisplayPowerCase =
         DisplayPowerCase<PrimaryDisplayVariant, DozeIsSupportedVariant<PrimaryDisplayVariant>,
-                         EventThreadIsSupportedVariant, DispSyncIsSupportedVariant,
-                         TransitionVariant>;
+                         DispSyncIsSupportedVariant, TransitionVariant>;
 
-// A sample configuration for the external display.
-// In addition to not having event thread support, we emulate not having doze
-// support.
+// A sample configuration for the external display. We emulate not having doze support.
 // TODO (b/267483230): ExternalDisplay supports the features tracked in
 // DispSyncIsSupportedVariant, but is the follower, so the
 // expectations set by DispSyncIsSupportedVariant don't match (wrong schedule).
@@ -312,11 +300,13 @@ using PrimaryDisplayPowerCase =
 template <typename TransitionVariant>
 using ExternalDisplayPowerCase =
         DisplayPowerCase<ExternalDisplayVariant, DozeNotSupportedVariant<ExternalDisplayVariant>,
-                         EventThreadNotSupportedVariant, DispSyncNotSupportedVariant,
-                         TransitionVariant>;
+                         DispSyncNotSupportedVariant, TransitionVariant>;
 
 class SetPhysicalDisplayPowerModeTest : public DisplayTransactionTest {
 public:
+    static constexpr bool kWithMockScheduler = false;
+    SetPhysicalDisplayPowerModeTest() : DisplayTransactionTest(kWithMockScheduler) {}
+
     template <typename Case>
     void transitionDisplayCommon();
 };
@@ -335,6 +325,18 @@ void SetPhysicalDisplayPowerModeTest::transitionDisplayCommon() {
     // --------------------------------------------------------------------
     // Preconditions
 
+    SET_FLAG_FOR_TEST(android::companion::virtualdevice::flags::correct_virtual_display_power_state,
+                      true);
+    SET_FLAG_FOR_TEST(flags::disable_synthetic_vsync_for_performance, true);
+    SET_FLAG_FOR_TEST(flags::pacesetter_selection, true);
+
+    const auto displayIdOpt = asPhysicalDisplayId(Case::Display::DISPLAY_ID::get());
+    ASSERT_TRUE(displayIdOpt);
+    injectMockScheduler(*displayIdOpt);
+    // TODO: b/389983418 - Remove once the Scheduler is no longer dependent on front internal
+    // display.
+    mFlinger.mutableFrontInternalDisplayId() = *displayIdOpt;
+
     Case::Doze::setupComposerCallExpectations(this);
     auto display =
             Case::injectDisplayWithInitialPowerMode(this, Case::Transition::INITIAL_POWER_MODE);
diff --git a/services/surfaceflinger/tests/unittests/SurfaceFlinger_SetupNewDisplayDeviceInternalTest.cpp b/services/surfaceflinger/tests/unittests/SurfaceFlinger_SetupNewDisplayDeviceInternalTest.cpp
index 23e73de660..d5b7c946ff 100644
--- a/services/surfaceflinger/tests/unittests/SurfaceFlinger_SetupNewDisplayDeviceInternalTest.cpp
+++ b/services/surfaceflinger/tests/unittests/SurfaceFlinger_SetupNewDisplayDeviceInternalTest.cpp
@@ -18,6 +18,7 @@
 #define LOG_TAG "LibSurfaceFlingerUnittests"
 
 #include <ftl/fake_guard.h>
+#include <ui/ScreenPartStatus.h>
 
 #include "DisplayHardware/DisplayMode.h"
 
@@ -241,8 +242,6 @@ void SetupNewDisplayDeviceInternalTest::setupNewDisplayDeviceInternalTest() {
         ASSERT_TRUE(hwcDisplayId);
         const auto port = Case::Display::PORT::value;
         ASSERT_TRUE(port);
-        mFlinger.getHwComposer().allocatePhysicalDisplay(*hwcDisplayId, *displayId, *port,
-                                                         std::nullopt);
         DisplayModePtr activeMode = DisplayMode::Builder(Case::Display::HWC_ACTIVE_CONFIG_ID)
                                             .setResolution(Case::Display::RESOLUTION)
                                             .setVsyncPeriod(DEFAULT_VSYNC_PERIOD)
@@ -263,6 +262,7 @@ void SetupNewDisplayDeviceInternalTest::setupNewDisplayDeviceInternalTest() {
 
         const auto it = mFlinger.mutablePhysicalDisplays()
                                 .emplace_or_replace(*displayId, displayToken, *displayId, *port,
+                                                    android::ScreenPartStatus::UNSUPPORTED,
                                                     *kConnectionTypeOpt, makeModes(activeMode),
                                                     std::move(colorModes), std::nullopt)
                                 .first;
diff --git a/services/surfaceflinger/tests/unittests/TestableScheduler.h b/services/surfaceflinger/tests/unittests/TestableScheduler.h
index 9de3346fb0..80bb08d977 100644
--- a/services/surfaceflinger/tests/unittests/TestableScheduler.h
+++ b/services/surfaceflinger/tests/unittests/TestableScheduler.h
@@ -143,6 +143,8 @@ public:
         return mLayerHistory.mActiveLayerInfos.size();
     }
 
+    bool layerHistoryModeChangePending() const { return mLayerHistory.mModeChangePending; }
+
     void replaceTouchTimer(int64_t millis,
                            std::function<void(bool isReset)>&& testCallback = nullptr) {
         if (mTouchTimer) {
diff --git a/services/surfaceflinger/tests/unittests/TestableSurfaceFlinger.h b/services/surfaceflinger/tests/unittests/TestableSurfaceFlinger.h
index 13c32bdf08..1c8ee3a3be 100644
--- a/services/surfaceflinger/tests/unittests/TestableSurfaceFlinger.h
+++ b/services/surfaceflinger/tests/unittests/TestableSurfaceFlinger.h
@@ -20,11 +20,16 @@
 #include <memory>
 #include <variant>
 
+#include <android/gui/EarlyWakeupInfo.h>
 #include <ftl/fake_guard.h>
 #include <ftl/match.h>
 #include <gui/LayerMetadata.h>
+#include <gui/LayerState.h>
 #include <gui/ScreenCaptureResults.h>
+#include <gui/SimpleTransactionState.h>
+#include <gui/TransactionState.h>
 #include <ui/DynamicDisplayInfo.h>
+#include <ui/ScreenPartStatus.h>
 
 #include <compositionengine/Display.h>
 #include <compositionengine/LayerFECompositionState.h>
@@ -121,9 +126,7 @@ public:
         return compositionengine::impl::createCompositionEngine();
     }
 
-    sp<Layer> createBufferStateLayer(const LayerCreationArgs&) override { return nullptr; }
-
-    sp<Layer> createEffectLayer(const LayerCreationArgs&) override { return nullptr; }
+    sp<Layer> createLayer(const LayerCreationArgs&) override { return nullptr; }
 
     sp<LayerFE> createLayerFE(const std::string& layerName, const Layer* /* owner */) override {
         return sp<LayerFE>::make(layerName);
@@ -133,7 +136,7 @@ public:
         return std::make_unique<mock::FrameTracer>();
     }
 
-    std::unique_ptr<frametimeline::FrameTimeline> createFrameTimeline(
+    std::unique_ptr<scheduler::FrameTimeline> createFrameTimeline(
             std::shared_ptr<TimeStats> timeStats, pid_t surfaceFlingerPid = 0) override {
         return std::make_unique<mock::FrameTimeline>(timeStats, surfaceFlingerPid);
     }
@@ -234,7 +237,7 @@ public:
                 },
                 [](RefreshRateSelectorPtr selectorPtr) { return selectorPtr; });
 
-        mTokenManager = std::make_unique<frametimeline::impl::TokenManager>();
+        mTokenManager = std::make_unique<scheduler::impl::TokenManager>();
 
         using ISchedulerCallback = scheduler::ISchedulerCallback;
         ISchedulerCallback& schedulerCallback = callbackImpl == SchedulerCallbackImpl::kNoOp
@@ -321,7 +324,7 @@ public:
     void setLayerCompositionType(const sp<Layer>& layer,
                                  aidl::android::hardware::graphics::composer3::Composition type) {
         auto outputLayer = findOutputLayerForDisplay(static_cast<uint32_t>(layer->sequence),
-                                                     mFlinger->getDefaultDisplayDevice());
+                                                     mFlinger->getFrontInternalDisplay());
         LOG_ALWAYS_FATAL_IF(!outputLayer);
         auto& state = outputLayer->editState();
         LOG_ALWAYS_FATAL_IF(!outputLayer->getState().hwc);
@@ -469,37 +472,41 @@ public:
 
     auto renderScreenImpl(const sp<DisplayDevice> display, const Rect sourceCrop,
                           ui::Dataspace dataspace,
-                          SurfaceFlinger::GetLayerSnapshotsFunction getLayerSnapshotsFn,
+                          std::vector<std::pair<Layer*, sp<LayerFE>>>& layers,
                           const std::shared_ptr<renderengine::ExternalTexture>& buffer,
-                          bool regionSampling, bool isSecure, bool seamlessTransition) {
+                          bool disableBlur, bool isSecure, bool seamlessTransition) {
         Mutex::Autolock lock(mFlinger->mStateLock);
         ftl::FakeGuard guard(kMainThreadContext);
 
         ScreenCaptureResults captureResults;
         const auto& state = display->getCompositionDisplay()->getState();
-        auto layers = getLayerSnapshotsFn();
-
-        SurfaceFlinger::ScreenshotArgs screenshotArgs;
-        screenshotArgs.captureTypeVariant = display;
-        screenshotArgs.displayIdVariant = std::nullopt;
-        screenshotArgs.sourceCrop = sourceCrop;
-        screenshotArgs.reqSize = sourceCrop.getSize();
-        screenshotArgs.dataspace = dataspace;
-        screenshotArgs.isSecure = isSecure;
-        screenshotArgs.seamlessTransition = seamlessTransition;
-        screenshotArgs.displayBrightnessNits = state.displayBrightnessNits;
-        screenshotArgs.sdrWhitePointNits = state.sdrWhitePointNits;
-        screenshotArgs.renderIntent = state.renderIntent;
-        screenshotArgs.colorMode = state.colorMode;
-
-        return mFlinger->renderScreenImpl(screenshotArgs, buffer, regionSampling,
-                                          false /* grayscale */, false /* isProtected */,
-                                          captureResults, layers);
-    }
 
-    auto getLayerSnapshotsForScreenshotsFn(ui::LayerStack layerStack, uint32_t uid) {
-        return mFlinger->getLayerSnapshotsForScreenshots(layerStack, uid,
-                                                         std::unordered_set<uint32_t>{});
+        SurfaceFlinger::ScreenshotArgs screenshotArgs{.displayIdVariant = std::nullopt,
+                                                      .layers = layers,
+                                                      .sourceCrop = sourceCrop,
+                                                      .size = sourceCrop.getSize(),
+                                                      .dataspace = dataspace,
+                                                      .disableBlur = disableBlur,
+                                                      .isGrayscale = false,
+                                                      .isSecure = isSecure,
+                                                      .seamlessTransition = seamlessTransition,
+                                                      .displayBrightnessNits =
+                                                              state.displayBrightnessNits,
+                                                      .sdrWhitePointNits = state.sdrWhitePointNits,
+                                                      .colorMode = state.colorMode,
+                                                      .renderIntent = state.renderIntent,
+                                                      .debugName =
+                                                              "TestableSurfaceFlinger screenshot"};
+
+        return mFlinger->renderScreenImpl(screenshotArgs, buffer, captureResults);
+    }
+
+    auto getLayerSnapshotsForScreenshots(ui::LayerStack layerStack, gui::Uid uid) {
+        ftl::FakeGuard guard(kMainThreadContext);
+        SurfaceFlinger::SnapshotRequestArgs snapshotArgs;
+        snapshotArgs.layerStack = layerStack;
+        snapshotArgs.uid = uid;
+        return mFlinger->getLayerSnapshotsForScreenshots(snapshotArgs);
     }
 
     auto getDisplayNativePrimaries(const sp<IBinder>& displayToken,
@@ -519,8 +526,26 @@ public:
         return mFlinger->mTransactionHandler.mPendingTransactionCount.load();
     }
 
-    auto setTransactionState(TransactionState&& state) {
-        return mFlinger->setTransactionState(std::move(state));
+    auto setTransactionState(
+            const FrameTimelineInfo& frameTimelineInfo, MutableTransactionState& mutableState,
+            uint32_t flags, const sp<IBinder>& applyToken,
+            const InputWindowCommands& inputWindowCommands, int64_t desiredPresentTime,
+            bool isAutoTimestamp, const std::vector<client_cache_t>& uncacheBuffers,
+            bool hasListenerCallbacks, std::vector<ListenerCallbacks>& listenerCallbacks,
+            uint64_t transactionId, const std::vector<uint64_t>& mergedTransactionIds,
+            const std::vector<gui::EarlyWakeupInfo>& earlyWakeupInfos) {
+        ComplexTransactionState complexState;
+        complexState.mFrameTimelineInfo = frameTimelineInfo;
+        complexState.mUncacheBuffers = uncacheBuffers;
+        complexState.mMergedTransactionIds = mergedTransactionIds;
+        complexState.mCallbacks.mHasListenerCallbacks = hasListenerCallbacks;
+        complexState.mCallbacks.mFlattenedListenerCallbacks = listenerCallbacks;
+        complexState.mInputWindowCommands = inputWindowCommands;
+        complexState.mEarlyWakeupInfos = earlyWakeupInfos;
+        return mFlinger->setTransactionState(SimpleTransactionState(transactionId, flags,
+                                                                    desiredPresentTime,
+                                                                    isAutoTimestamp),
+                                             complexState, mutableState, applyToken);
     }
 
     auto setTransactionStateInternal(QueuedTransactionState& transaction) {
@@ -549,11 +574,11 @@ public:
         return mFlinger->setDesiredDisplayModeSpecs(displayToken, specs);
     }
 
-    void onActiveDisplayChanged(const DisplayDevice* inactiveDisplayPtr,
-                                const DisplayDevice& activeDisplay) {
+    void onNewFrontInternalDisplay(const DisplayDevice* oldFrontInternalDisplayPtr,
+                                   const DisplayDevice& newFrontInternalDisplay) {
         Mutex::Autolock lock(mFlinger->mStateLock);
         ftl::FakeGuard guard(kMainThreadContext);
-        mFlinger->onActiveDisplayChangedLocked(inactiveDisplayPtr, activeDisplay);
+        mFlinger->onNewFrontInternalDisplay(oldFrontInternalDisplayPtr, newFrontInternalDisplay);
     }
 
     auto createLayer(LayerCreationArgs& args, const sp<IBinder>& parentHandle,
@@ -563,8 +588,8 @@ public:
     }
 
     auto mirrorLayer(const LayerCreationArgs& args, const sp<IBinder>& mirrorFromHandle,
-                     gui::CreateSurfaceResult& outResult) {
-        return mFlinger->mirrorLayer(args, mirrorFromHandle, outResult);
+                     const sp<IBinder>& stopAtHandle, gui::CreateSurfaceResult& outResult) {
+        return mFlinger->mirrorLayer(args, mirrorFromHandle, stopAtHandle, outResult);
     }
 
     void getDynamicDisplayInfoFromToken(const sp<IBinder>& displayToken,
@@ -648,12 +673,12 @@ public:
         }
     }
 
-    auto setLayerHistoryDisplayArea(uint32_t displayArea) {
-        return mFlinger->mScheduler->onActiveDisplayAreaChanged(displayArea);
-    };
+    auto setLayerHistoryDisplaySize(ui::Size displaySize) {
+        return mFlinger->mScheduler->onPacesetterDisplaySizeChanged(displaySize);
+    }
     auto updateLayerHistory(nsecs_t now) {
         return FTL_FAKE_GUARD(kMainThreadContext, mFlinger->updateLayerHistory(now));
-    };
+    }
     auto setDaltonizerType(ColorBlindnessType type) {
         mFlinger->mDaltonizer.setType(type);
         return mFlinger->updateColorMatrixLocked();
@@ -702,11 +727,13 @@ public:
     auto& mutableHwcDisplayData() { return getHwComposer().mDisplayData; }
     auto& mutableHwcPhysicalDisplayIdMap() { return getHwComposer().mPhysicalDisplayIdMap; }
     auto& mutablePrimaryHwcDisplayId() { return getHwComposer().mPrimaryHwcDisplayId; }
-    auto& mutableActiveDisplayId() NO_THREAD_SAFETY_ANALYSIS { return mFlinger->mActiveDisplayId; }
+    auto& mutableFrontInternalDisplayId() NO_THREAD_SAFETY_ANALYSIS {
+        return mFlinger->mFrontInternalDisplayId;
+    }
     auto& mutablePreviouslyComposedLayers() { return mFlinger->mPreviouslyComposedLayers; }
 
-    auto& mutableActiveDisplayRotationFlags() {
-        return SurfaceFlinger::sActiveDisplayRotationFlags;
+    auto& mutableFrontInternalDisplayRotationFlags() {
+        return SurfaceFlinger::sFrontInternalDisplayRotationFlags;
     }
 
     auto& mutableMinAcquiredBuffers() { return SurfaceFlinger::minAcquiredBuffers; }
@@ -1084,7 +1111,7 @@ public:
                 LOG_ALWAYS_FATAL_IF(!mHwcDisplayId);
 
                 if (mCreationArgs.isPrimary) {
-                    mFlinger.mutableActiveDisplayId() = *physicalId;
+                    mFlinger.mutableFrontInternalDisplayId() = *physicalId;
                 }
 
                 if (!mCreationArgs.refreshRateSelector) {
@@ -1123,6 +1150,7 @@ public:
                 const auto it =
                         mFlinger.mutablePhysicalDisplays()
                                 .emplace_or_replace(*physicalId, mDisplayToken, *physicalId, *mPort,
+                                                    android::ScreenPartStatus::UNSUPPORTED,
                                                     *mConnectionType, std::move(modes),
                                                     ui::ColorModes(), std::nullopt)
                                 .first;
@@ -1138,7 +1166,7 @@ public:
                     mFlinger.scheduler()->registerDisplay(*physicalId,
                                                           mCreationArgs.refreshRateSelector,
                                                           std::move(controller), std::move(tracker),
-                                                          mFlinger.mutableActiveDisplayId());
+                                                          mFlinger.mutableFrontInternalDisplayId());
                 }
             }
 
@@ -1180,7 +1208,7 @@ private:
     sp<SurfaceFlinger> mFlinger;
     scheduler::mock::SchedulerCallback mSchedulerCallback;
     scheduler::mock::NoOpSchedulerCallback mNoOpSchedulerCallback;
-    std::unique_ptr<frametimeline::impl::TokenManager> mTokenManager;
+    std::unique_ptr<scheduler::impl::TokenManager> mTokenManager;
     scheduler::TestableScheduler* mScheduler = nullptr;
     adpf::mock::PowerAdvisor mPowerAdvisor;
 };
diff --git a/services/surfaceflinger/tests/unittests/TransactionApplicationTest.cpp b/services/surfaceflinger/tests/unittests/TransactionApplicationTest.cpp
index 1395fb6af3..7be274e814 100644
--- a/services/surfaceflinger/tests/unittests/TransactionApplicationTest.cpp
+++ b/services/surfaceflinger/tests/unittests/TransactionApplicationTest.cpp
@@ -14,11 +14,10 @@
  * limitations under the License.
  */
 
+#include "gui/TransactionState.h"
 #undef LOG_TAG
 #define LOG_TAG "TransactionApplicationTest"
 
-#include <cstdint>
-
 #include <binder/Binder.h>
 #include <common/test/FlagUtils.h>
 #include <compositionengine/Display.h>
@@ -71,32 +70,38 @@ public:
     TestableSurfaceFlinger mFlinger;
     renderengine::mock::RenderEngine* mRenderEngine = new renderengine::mock::RenderEngine();
 
-    struct TransactionInfo : public TransactionState {
-        TransactionInfo() {
-            mApplyToken = IInterface::asBinder(TransactionCompletedListener::getIInstance());
-            mId = static_cast<uint64_t>(-1);
-        }
+    struct TransactionInfo {
+        MutableTransactionState mutableState;
+        uint32_t flags = 0;
+        sp<IBinder> applyToken = IInterface::asBinder(TransactionCompletedListener::getIInstance());
+        InputWindowCommands inputWindowCommands;
+        int64_t desiredPresentTime = 0;
+        bool isAutoTimestamp = true;
+        FrameTimelineInfo frameTimelineInfo;
+        std::vector<client_cache_t> uncacheBuffers;
+        uint64_t id = static_cast<uint64_t>(-1);
+        std::vector<uint64_t> mergedTransactionIds;
+        static_assert(0xffffffffffffffff == static_cast<uint64_t>(-1));
+        std::vector<gui::EarlyWakeupInfo> earlyWakeupInfos;
     };
 
-    void checkEqual(const TransactionInfo& info, const QueuedTransactionState& state) {
-        EXPECT_EQ(0u, info.mComposerStates.size());
+    void checkEqual(TransactionInfo info, QueuedTransactionState state) {
+        EXPECT_EQ(0u, info.mutableState.mComposerStates.size());
         EXPECT_EQ(0u, state.states.size());
 
-        EXPECT_EQ(0u, info.mDisplayStates.size());
+        EXPECT_EQ(0u, info.mutableState.mDisplayStates.size());
         EXPECT_EQ(0u, state.displays.size());
-        EXPECT_EQ(info.mFlags, state.flags);
-        EXPECT_EQ(info.mDesiredPresentTime, state.desiredPresentTime);
+        EXPECT_EQ(info.flags, state.flags);
+        EXPECT_EQ(info.desiredPresentTime, state.desiredPresentTime);
     }
 
     void setupSingle(TransactionInfo& transaction, uint32_t flags, int64_t desiredPresentTime,
                      bool isAutoTimestamp, const FrameTimelineInfo& frameTimelineInfo) {
         mTransactionNumber++;
-        transaction.mFlags |= flags;
-        transaction.mDesiredPresentTime = desiredPresentTime;
-        transaction.mIsAutoTimestamp = isAutoTimestamp;
-        transaction.mFrameTimelineInfo = frameTimelineInfo;
-        transaction.mHasListenerCallbacks = mHasListenerCallbacks;
-        transaction.mListenerCallbacks = mCallbacks;
+        transaction.flags |= flags;
+        transaction.desiredPresentTime = desiredPresentTime;
+        transaction.isAutoTimestamp = isAutoTimestamp;
+        transaction.frameTimelineInfo = frameTimelineInfo;
     }
 
     void NotPlacedOnTransactionQueue(uint32_t flags) {
@@ -107,7 +112,13 @@ public:
                     /*desiredPresentTime*/ systemTime(), /*isAutoTimestamp*/ true,
                     FrameTimelineInfo{});
         nsecs_t applicationTime = systemTime();
-        mFlinger.setTransactionState(std::move(transaction));
+        mFlinger.setTransactionState(transaction.frameTimelineInfo, transaction.mutableState,
+                                     transaction.flags, transaction.applyToken,
+                                     transaction.inputWindowCommands,
+                                     transaction.desiredPresentTime, transaction.isAutoTimestamp,
+                                     transaction.uncacheBuffers, mHasListenerCallbacks, mCallbacks,
+                                     transaction.id, transaction.mergedTransactionIds,
+                                     transaction.earlyWakeupInfos);
 
         // If transaction is synchronous, SF applyTransactionState should time out (5s) wating for
         // SF to commit the transaction. If this is animation, it should not time out waiting.
@@ -129,7 +140,13 @@ public:
         setupSingle(transaction, flags, /*desiredPresentTime*/ time + s2ns(1), false,
                     FrameTimelineInfo{});
         nsecs_t applicationSentTime = systemTime();
-        mFlinger.setTransactionState(std::move(transaction));
+        mFlinger.setTransactionState(transaction.frameTimelineInfo, transaction.mutableState,
+                                     transaction.flags, transaction.applyToken,
+                                     transaction.inputWindowCommands,
+                                     transaction.desiredPresentTime, transaction.isAutoTimestamp,
+                                     transaction.uncacheBuffers, mHasListenerCallbacks, mCallbacks,
+                                     transaction.id, transaction.mergedTransactionIds,
+                                     transaction.earlyWakeupInfos);
 
         nsecs_t returnedTime = systemTime();
         EXPECT_LE(returnedTime, applicationSentTime + TRANSACTION_TIMEOUT);
@@ -155,7 +172,13 @@ public:
                     /*isAutoTimestamp*/ true, FrameTimelineInfo{});
 
         nsecs_t applicationSentTime = systemTime();
-        mFlinger.setTransactionState(std::move(transactionA));
+        mFlinger.setTransactionState(transactionA.frameTimelineInfo, transactionA.mutableState,
+                                     transactionA.flags, transactionA.applyToken,
+                                     transactionA.inputWindowCommands,
+                                     transactionA.desiredPresentTime, transactionA.isAutoTimestamp,
+                                     transactionA.uncacheBuffers, mHasListenerCallbacks, mCallbacks,
+                                     transactionA.id, transactionA.mergedTransactionIds,
+                                     transactionA.earlyWakeupInfos);
 
         // This thread should not have been blocked by the above transaction
         // (5s is the timeout period that applyTransactionState waits for SF to
@@ -165,7 +188,13 @@ public:
         mFlinger.flushTransactionQueues();
 
         applicationSentTime = systemTime();
-        mFlinger.setTransactionState(std::move(transactionB));
+        mFlinger.setTransactionState(transactionB.frameTimelineInfo, transactionB.mutableState,
+                                     transactionB.flags, transactionB.applyToken,
+                                     transactionB.inputWindowCommands,
+                                     transactionB.desiredPresentTime, transactionB.isAutoTimestamp,
+                                     transactionB.uncacheBuffers, mHasListenerCallbacks, mCallbacks,
+                                     transactionB.id, transactionB.mergedTransactionIds,
+                                     transactionB.earlyWakeupInfos);
 
         // this thread should have been blocked by the above transaction
         // if this is an animation, this thread should be blocked for 5s
@@ -198,7 +227,12 @@ TEST_F(TransactionApplicationTest, AddToPendingQueue) {
     TransactionInfo transactionA; // transaction to go on pending queue
     setupSingle(transactionA, /*flags*/ 0, /*desiredPresentTime*/ s2ns(1), false,
                 FrameTimelineInfo{});
-    mFlinger.setTransactionState(std::move(transactionA));
+    mFlinger.setTransactionState(transactionA.frameTimelineInfo, transactionA.mutableState,
+                                 transactionA.flags, transactionA.applyToken,
+                                 transactionA.inputWindowCommands, transactionA.desiredPresentTime,
+                                 transactionA.isAutoTimestamp, transactionA.uncacheBuffers,
+                                 mHasListenerCallbacks, mCallbacks, transactionA.id,
+                                 transactionA.mergedTransactionIds, transactionA.earlyWakeupInfos);
 
     auto& transactionQueue = mFlinger.getTransactionQueue();
     ASSERT_FALSE(transactionQueue.isEmpty());
@@ -214,7 +248,12 @@ TEST_F(TransactionApplicationTest, Flush_RemovesFromQueue) {
     TransactionInfo transactionA; // transaction to go on pending queue
     setupSingle(transactionA, /*flags*/ 0, /*desiredPresentTime*/ s2ns(1), false,
                 FrameTimelineInfo{});
-    mFlinger.setTransactionState(std::move(transactionA));
+    mFlinger.setTransactionState(transactionA.frameTimelineInfo, transactionA.mutableState,
+                                 transactionA.flags, transactionA.applyToken,
+                                 transactionA.inputWindowCommands, transactionA.desiredPresentTime,
+                                 transactionA.isAutoTimestamp, transactionA.uncacheBuffers,
+                                 mHasListenerCallbacks, mCallbacks, transactionA.id,
+                                 transactionA.mergedTransactionIds, transactionA.earlyWakeupInfos);
 
     auto& transactionQueue = mFlinger.getTransactionQueue();
     ASSERT_FALSE(transactionQueue.isEmpty());
@@ -223,10 +262,12 @@ TEST_F(TransactionApplicationTest, Flush_RemovesFromQueue) {
     // transaction here (sending a null applyToken to fake it as from a
     // different process) to re-query and reset the cached expected present time
     TransactionInfo empty;
-    empty.mApplyToken = sp<IBinder>();
-    empty.mHasListenerCallbacks = mHasListenerCallbacks;
-    empty.mListenerCallbacks = mCallbacks;
-    mFlinger.setTransactionState(std::move(empty));
+    empty.applyToken = sp<IBinder>();
+    mFlinger.setTransactionState(empty.frameTimelineInfo, empty.mutableState, empty.flags,
+                                 empty.applyToken, empty.inputWindowCommands,
+                                 empty.desiredPresentTime, empty.isAutoTimestamp,
+                                 empty.uncacheBuffers, mHasListenerCallbacks, mCallbacks, empty.id,
+                                 empty.mergedTransactionIds, empty.earlyWakeupInfos);
 
     // flush transaction queue should flush as desiredPresentTime has
     // passed
@@ -370,9 +411,9 @@ public:
         const auto kFrameTimelineInfo = FrameTimelineInfo{};
 
         setupSingle(transaction, kFlags, kDesiredPresentTime, kIsAutoTimestamp, kFrameTimelineInfo);
-        transaction.mApplyToken = applyToken;
+        transaction.applyToken = applyToken;
         for (const auto& state : states) {
-            transaction.mComposerStates.push_back(state);
+            transaction.mutableState.mComposerStates.push_back(state);
         }
 
         return transaction;
@@ -383,8 +424,8 @@ public:
         EXPECT_TRUE(mFlinger.getTransactionQueue().isEmpty());
         EXPECT_EQ(0u, mFlinger.getPendingTransactionQueue().size());
         std::unordered_set<uint32_t> createdLayers;
-        for (auto& transaction : transactions) {
-            for (auto& state : transaction.mComposerStates) {
+        for (auto transaction : transactions) {
+            for (auto& state : transaction.mutableState.mComposerStates) {
                 auto layerId = static_cast<uint32_t>(state.state.layerId);
                 if (createdLayers.find(layerId) == createdLayers.end()) {
                     mFlinger.addLayer(layerId);
@@ -398,8 +439,8 @@ public:
 
         for (auto transaction : transactions) {
             std::vector<ResolvedComposerState> resolvedStates;
-            resolvedStates.reserve(transaction.mComposerStates.size());
-            for (auto& state : transaction.mComposerStates) {
+            resolvedStates.reserve(transaction.mutableState.mComposerStates.size());
+            for (auto& state : transaction.mutableState.mComposerStates) {
                 ResolvedComposerState resolvedState;
                 resolvedState.state = std::move(state.state);
                 resolvedState.externalTexture =
@@ -410,9 +451,16 @@ public:
                 resolvedStates.emplace_back(resolvedState);
             }
 
-            QueuedTransactionState transactionState(std::move(transaction),
-                                                    std::move(resolvedStates), {}, systemTime(),
-                                                    getpid(), static_cast<int>(getuid()));
+            QueuedTransactionState transactionState(transaction.frameTimelineInfo, resolvedStates,
+                                                    transaction.mutableState.mDisplayStates,
+                                                    transaction.flags, transaction.applyToken,
+                                                    transaction.inputWindowCommands,
+                                                    transaction.desiredPresentTime,
+                                                    transaction.isAutoTimestamp, {}, systemTime(),
+                                                    mHasListenerCallbacks, mCallbacks, getpid(),
+                                                    static_cast<int>(getuid()), transaction.id,
+                                                    transaction.mergedTransactionIds,
+                                                    transaction.earlyWakeupInfos);
             mFlinger.setTransactionStateInternal(transactionState);
         }
         mFlinger.flushTransactionQueues();
@@ -475,27 +523,7 @@ TEST_F(LatchUnsignaledAutoSingleLayerTest, Flush_KeepsUnSignaledInTheQueue_NonBu
     setTransactionStates({unsignaledTransaction}, kExpectedTransactionsPending);
 }
 
-TEST_F(LatchUnsignaledAutoSingleLayerTest, Flush_KeepsUnSignaledInTheQueue_AutoRefreshChanged) {
-    SET_FLAG_FOR_TEST(flags::latch_unsignaled_with_auto_refresh_changed, false);
-    const sp<IBinder> kApplyToken =
-            IInterface::asBinder(TransactionCompletedListener::getIInstance());
-    const auto kLayerId = 1;
-    const auto kExpectedTransactionsPending = 1u;
-
-    const auto unsignaledTransaction =
-            createTransactionInfo(kApplyToken,
-                                  {
-                                          createComposerState(kLayerId,
-                                                              fence(Fence::Status::Unsignaled),
-                                                              layer_state_t::eAutoRefreshChanged |
-                                                                      layer_state_t::
-                                                                              eBufferChanged),
-                                  });
-    setTransactionStates({unsignaledTransaction}, kExpectedTransactionsPending);
-}
-
 TEST_F(LatchUnsignaledAutoSingleLayerTest, Flush_RemovesUnSignaledInTheQueue_AutoRefreshChanged) {
-    SET_FLAG_FOR_TEST(flags::latch_unsignaled_with_auto_refresh_changed, true);
     const sp<IBinder> kApplyToken =
             IInterface::asBinder(TransactionCompletedListener::getIInstance());
     const auto kLayerId = 1;
diff --git a/services/surfaceflinger/tests/unittests/TransactionFrameTracerTest.cpp b/services/surfaceflinger/tests/unittests/TransactionFrameTracerTest.cpp
index abfab9ad95..d28ec9692b 100644
--- a/services/surfaceflinger/tests/unittests/TransactionFrameTracerTest.cpp
+++ b/services/surfaceflinger/tests/unittests/TransactionFrameTracerTest.cpp
@@ -35,7 +35,7 @@ using testing::_;
 using testing::Mock;
 using testing::Return;
 
-using PresentState = frametimeline::SurfaceFrame::PresentState;
+using PresentState = scheduler::SurfaceFrame::PresentState;
 
 class TransactionFrameTracerTest : public testing::Test {
 public:
diff --git a/services/surfaceflinger/tests/unittests/TransactionProtoParserTest.cpp b/services/surfaceflinger/tests/unittests/TransactionProtoParserTest.cpp
index b36ad213c8..d3eec5c6f3 100644
--- a/services/surfaceflinger/tests/unittests/TransactionProtoParserTest.cpp
+++ b/services/surfaceflinger/tests/unittests/TransactionProtoParserTest.cpp
@@ -66,7 +66,7 @@ TEST(TransactionProtoParserTest, parse) {
             display.token = nullptr;
         }
         display.width = 85;
-        t1.displays.push_back(display);
+        t1.displays.add(display);
     }
 
     class TestMapper : public TransactionProtoParser::FlingerDataMapper {
diff --git a/services/surfaceflinger/tests/unittests/TransactionSurfaceFrameTest.cpp b/services/surfaceflinger/tests/unittests/TransactionSurfaceFrameTest.cpp
index 9a68d75d55..df46535a2a 100644
--- a/services/surfaceflinger/tests/unittests/TransactionSurfaceFrameTest.cpp
+++ b/services/surfaceflinger/tests/unittests/TransactionSurfaceFrameTest.cpp
@@ -35,7 +35,7 @@ using testing::_;
 using testing::Mock;
 using testing::Return;
 
-using PresentState = frametimeline::SurfaceFrame::PresentState;
+using PresentState = scheduler::SurfaceFrame::PresentState;
 
 class TransactionSurfaceFrameTest : public testing::Test {
 public:
@@ -407,7 +407,7 @@ public:
 
     void MultipleCommitsBeforeLatch() {
         sp<Layer> layer = createLayer();
-        std::vector<std::shared_ptr<frametimeline::SurfaceFrame>> surfaceFrames;
+        std::vector<std::shared_ptr<scheduler::SurfaceFrame>> surfaceFrames;
         for (int i = 0; i < 10; i += 2) {
             sp<Fence> fence(sp<Fence>::make());
             BufferData bufferData;
diff --git a/services/surfaceflinger/tests/unittests/VSyncDispatchRealtimeTest.cpp b/services/surfaceflinger/tests/unittests/VSyncDispatchRealtimeTest.cpp
index b63f29990e..946fe93bc9 100644
--- a/services/surfaceflinger/tests/unittests/VSyncDispatchRealtimeTest.cpp
+++ b/services/surfaceflinger/tests/unittests/VSyncDispatchRealtimeTest.cpp
@@ -51,7 +51,7 @@ public:
     bool needsMoreSamples() const final { return false; }
     bool isVSyncInPhase(nsecs_t, Fps) final { return false; }
     void setDisplayModePtr(ftl::NonNull<DisplayModePtr>) final {}
-    void setRenderRate(Fps, bool) final {}
+    void setRenderRate(Fps, bool, std::vector<FrameRateOverride>) final {}
     void onFrameBegin(TimePoint, scheduler::FrameTime) final {}
     void onFrameMissed(TimePoint) final {}
     void dump(std::string&) const final {}
diff --git a/services/surfaceflinger/tests/unittests/VSyncDispatchTimerQueueTest.cpp b/services/surfaceflinger/tests/unittests/VSyncDispatchTimerQueueTest.cpp
index 9b70d92eac..a1b97d2cbb 100644
--- a/services/surfaceflinger/tests/unittests/VSyncDispatchTimerQueueTest.cpp
+++ b/services/surfaceflinger/tests/unittests/VSyncDispatchTimerQueueTest.cpp
@@ -746,32 +746,8 @@ TEST_F(VSyncDispatchTimerQueueTest, canMoveCallbackBackwardsInTime) {
     EXPECT_EQ(1000, result->vsyncTime.ns());
 }
 
-// b/1450138150
-TEST_F(VSyncDispatchTimerQueueTest, doesNotMoveCallbackBackwardsAndSkipAScheduledTargetVSync) {
-    SET_FLAG_FOR_TEST(flags::dont_skip_on_early_ro, false);
-
-    EXPECT_CALL(mMockClock, alarmAt(_, 500));
-    CountingCallback cb(mDispatch);
-    auto result =
-            mDispatch->schedule(cb, {.workDuration = 500, .readyDuration = 0, .lastVsync = 1000});
-    EXPECT_TRUE(result.has_value());
-    EXPECT_EQ(500, result->callbackTime.ns());
-    EXPECT_EQ(1000, result->vsyncTime.ns());
-    mMockClock.advanceBy(400);
-
-    result = mDispatch->schedule(cb, {.workDuration = 800, .readyDuration = 0, .lastVsync = 1000});
-    EXPECT_TRUE(result.has_value());
-    EXPECT_EQ(1200, result->callbackTime.ns());
-    EXPECT_EQ(2000, result->vsyncTime.ns());
-
-    advanceToNextCallback();
-    ASSERT_THAT(cb.mCalls.size(), Eq(1));
-}
-
 // b/1450138150
 TEST_F(VSyncDispatchTimerQueueTest, movesCallbackBackwardsAndSkipAScheduledTargetVSync) {
-    SET_FLAG_FOR_TEST(flags::dont_skip_on_early_ro, true);
-
     Sequence seq;
     EXPECT_CALL(mMockClock, alarmAt(_, 500)).InSequence(seq);
     EXPECT_CALL(mMockClock, alarmAt(_, 400)).InSequence(seq);
@@ -844,29 +820,7 @@ TEST_F(VSyncDispatchTimerQueueTest, canScheduleLargeNegativeOffset) {
     EXPECT_EQ(3000, result->vsyncTime.ns());
 }
 
-TEST_F(VSyncDispatchTimerQueueTest, scheduleUpdatesDoesNotAffectSchedulingState) {
-    SET_FLAG_FOR_TEST(flags::dont_skip_on_early_ro, false);
-
-    EXPECT_CALL(mMockClock, alarmAt(_, 600));
-
-    CountingCallback cb(mDispatch);
-    auto result =
-            mDispatch->schedule(cb, {.workDuration = 400, .readyDuration = 0, .lastVsync = 1000});
-    EXPECT_TRUE(result.has_value());
-    EXPECT_EQ(600, result->callbackTime.ns());
-    EXPECT_EQ(1000, result->vsyncTime.ns());
-
-    result = mDispatch->schedule(cb, {.workDuration = 1400, .readyDuration = 0, .lastVsync = 1000});
-    EXPECT_TRUE(result.has_value());
-    EXPECT_EQ(600, result->callbackTime.ns());
-    EXPECT_EQ(2000, result->vsyncTime.ns());
-
-    advanceToNextCallback();
-}
-
 TEST_F(VSyncDispatchTimerQueueTest, scheduleUpdatesDoesAffectSchedulingState) {
-    SET_FLAG_FOR_TEST(flags::dont_skip_on_early_ro, true);
-
     Sequence seq;
     EXPECT_CALL(mMockClock, alarmAt(_, 600)).InSequence(seq);
     EXPECT_CALL(mMockClock, alarmAt(_, 0)).InSequence(seq);
@@ -943,41 +897,10 @@ TEST_F(VSyncDispatchTimerQueueTest, skipsSchedulingIfTimerReschedulingIsImminent
     EXPECT_THAT(cb2.mCalls.size(), Eq(0));
 }
 
-// b/154303580.
-// If the same callback tries to reschedule itself after it's too late, timer opts to apply the
-// update later, as opposed to blocking the calling thread.
-TEST_F(VSyncDispatchTimerQueueTest, skipsSchedulingIfTimerReschedulingIsImminentSameCallback) {
-    SET_FLAG_FOR_TEST(flags::dont_skip_on_early_ro, false);
-
-    Sequence seq;
-    EXPECT_CALL(mMockClock, alarmAt(_, 600)).InSequence(seq);
-    EXPECT_CALL(mMockClock, alarmAt(_, 1630)).InSequence(seq);
-    CountingCallback cb(mDispatch);
-
-    auto result =
-            mDispatch->schedule(cb, {.workDuration = 400, .readyDuration = 0, .lastVsync = 1000});
-    EXPECT_TRUE(result.has_value());
-    EXPECT_EQ(600, result->callbackTime.ns());
-    EXPECT_EQ(1000, result->vsyncTime.ns());
-
-    mMockClock.setLag(100);
-    mMockClock.advanceBy(620);
-
-    result = mDispatch->schedule(cb, {.workDuration = 370, .readyDuration = 0, .lastVsync = 2000});
-    EXPECT_TRUE(result.has_value());
-    EXPECT_EQ(1630, result->callbackTime.ns());
-    EXPECT_EQ(2000, result->vsyncTime.ns());
-    mMockClock.advanceBy(80);
-
-    EXPECT_THAT(cb.mCalls.size(), Eq(1));
-}
-
 // b/154303580.
 // If the same callback tries to reschedule itself after it's too late, timer opts to apply the
 // update later, as opposed to blocking the calling thread.
 TEST_F(VSyncDispatchTimerQueueTest, doesntSkipSchedulingIfTimerReschedulingIsImminentSameCallback) {
-    SET_FLAG_FOR_TEST(flags::dont_skip_on_early_ro, true);
-
     Sequence seq;
     EXPECT_CALL(mMockClock, alarmAt(_, 600)).InSequence(seq);
     EXPECT_CALL(mMockClock, alarmAt(_, 1630)).InSequence(seq);
@@ -1124,32 +1047,7 @@ TEST_F(VSyncDispatchTimerQueueTest, basicAlarmSettingFutureWithReadyDuration) {
     EXPECT_THAT(cb.mReadyTime[0], 970);
 }
 
-TEST_F(VSyncDispatchTimerQueueTest, updatesVsyncTimeForCloseWakeupTime) {
-    SET_FLAG_FOR_TEST(flags::dont_skip_on_early_ro, false);
-
-    Sequence seq;
-    EXPECT_CALL(mMockClock, alarmAt(_, 600)).InSequence(seq);
-
-    CountingCallback cb(mDispatch);
-
-    mDispatch->schedule(cb, {.workDuration = 400, .readyDuration = 0, .lastVsync = 1000});
-    mDispatch->schedule(cb, {.workDuration = 1400, .readyDuration = 0, .lastVsync = 1000});
-
-    advanceToNextCallback();
-
-    advanceToNextCallback();
-
-    ASSERT_THAT(cb.mCalls.size(), Eq(1));
-    EXPECT_THAT(cb.mCalls[0], Eq(2000));
-    ASSERT_THAT(cb.mWakeupTime.size(), Eq(1));
-    EXPECT_THAT(cb.mWakeupTime[0], Eq(600));
-    ASSERT_THAT(cb.mReadyTime.size(), Eq(1));
-    EXPECT_THAT(cb.mReadyTime[0], Eq(2000));
-}
-
 TEST_F(VSyncDispatchTimerQueueTest, doesNotUpdatesVsyncTimeForCloseWakeupTime) {
-    SET_FLAG_FOR_TEST(flags::dont_skip_on_early_ro, true);
-
     Sequence seq;
     EXPECT_CALL(mMockClock, alarmAt(_, 600)).InSequence(seq);
     EXPECT_CALL(mMockClock, alarmAt(_, 0)).InSequence(seq);
@@ -1171,30 +1069,7 @@ TEST_F(VSyncDispatchTimerQueueTest, doesNotUpdatesVsyncTimeForCloseWakeupTime) {
     EXPECT_THAT(cb.mReadyTime[0], Eq(1000));
 }
 
-TEST_F(VSyncDispatchTimerQueueTest, skipAVsyc) {
-    SET_FLAG_FOR_TEST(flags::dont_skip_on_early_ro, false);
-
-    EXPECT_CALL(mMockClock, alarmAt(_, 500));
-    CountingCallback cb(mDispatch);
-    auto result =
-            mDispatch->schedule(cb, {.workDuration = 500, .readyDuration = 0, .lastVsync = 1000});
-    EXPECT_TRUE(result.has_value());
-    EXPECT_EQ(500, result->callbackTime.ns());
-    EXPECT_EQ(1000, result->vsyncTime.ns());
-    mMockClock.advanceBy(300);
-
-    result = mDispatch->schedule(cb, {.workDuration = 800, .readyDuration = 0, .lastVsync = 1000});
-    EXPECT_TRUE(result.has_value());
-    EXPECT_EQ(1200, result->callbackTime.ns());
-    EXPECT_EQ(2000, result->vsyncTime.ns());
-
-    advanceToNextCallback();
-    ASSERT_THAT(cb.mCalls.size(), Eq(1));
-}
-
 TEST_F(VSyncDispatchTimerQueueTest, dontskipAVsyc) {
-    SET_FLAG_FOR_TEST(flags::dont_skip_on_early_ro, true);
-
     Sequence seq;
     EXPECT_CALL(mMockClock, alarmAt(_, 500)).InSequence(seq);
     EXPECT_CALL(mMockClock, alarmAt(_, 300)).InSequence(seq);
@@ -1437,20 +1312,11 @@ TEST_F(VSyncDispatchTimerQueueEntryTest, reportsScheduledIfStillTime) {
               entry.schedule({.workDuration = 50, .readyDuration = 0, .lastVsync = 500},
                              *mStubTracker, 0)
                       .callbackTime.ns());
-    {
-        SET_FLAG_FOR_TEST(flags::dont_skip_on_early_ro, true);
-        EXPECT_EQ(0,
-                  entry.schedule({.workDuration = 1200, .readyDuration = 0, .lastVsync = 500},
-                                 *mStubTracker, 0)
-                          .callbackTime.ns());
-    }
-    {
-        SET_FLAG_FOR_TEST(flags::dont_skip_on_early_ro, false);
-        EXPECT_EQ(800,
-                  entry.schedule({.workDuration = 1200, .readyDuration = 0, .lastVsync = 500},
-                                 *mStubTracker, 0)
-                          .callbackTime.ns());
-    }
+    EXPECT_EQ(0,
+              entry.schedule({.workDuration = 1200, .readyDuration = 0, .lastVsync = 500},
+                           *mStubTracker, 0)
+                      .callbackTime.ns());
+
 }
 
 TEST_F(VSyncDispatchTimerQueueEntryTest, storesPendingUpdatesUntilUpdateAndDontSkip) {
diff --git a/services/surfaceflinger/tests/unittests/VSyncPredictorTest.cpp b/services/surfaceflinger/tests/unittests/VSyncPredictorTest.cpp
index ccf6a9c7f6..e9b1143207 100644
--- a/services/surfaceflinger/tests/unittests/VSyncPredictorTest.cpp
+++ b/services/surfaceflinger/tests/unittests/VSyncPredictorTest.cpp
@@ -315,7 +315,7 @@ TEST_F(VSyncPredictorTest, recoverAfterDriftedVSyncAreReplacedWithCorrectVSync)
             ftl::as_non_null(createVrrDisplayMode(DisplayModeId(0), idealPeriod, vrrConfig));
     VSyncPredictor vrrTracker{std::make_unique<ClockWrapper>(mClock), mode, kHistorySize,
                               kMinimumSamplesForPrediction, kOutlierTolerancePercent};
-    vrrTracker.setRenderRate(minFrameRate, /*applyImmediately*/ true);
+    vrrTracker.setRenderRate(minFrameRate, /*applyImmediately*/ true, /*frameRateOverrides*/ {});
     // Curated list of VSyncs that causes the VSync drift.
     std::vector<nsecs_t> const simulatedVsyncs{74473665741, 74481774375, 74489911818, 74497993491,
                                                74506000833, 74510002150, 74513904390, 74517748707,
@@ -579,7 +579,6 @@ TEST_F(VSyncPredictorTest, isVSyncInPhase) {
 }
 
 TEST_F(VSyncPredictorTest, isVSyncInPhaseWithRenderRate) {
-    SET_FLAG_FOR_TEST(flags::vrr_bugfix_24q4, true);
     auto last = mNow;
     for (auto i = 0u; i < kMinimumSamplesForPrediction; i++) {
         EXPECT_THAT(tracker.nextAnticipatedVSyncTimeFrom(mNow), Eq(last + mPeriod));
@@ -592,7 +591,7 @@ TEST_F(VSyncPredictorTest, isVSyncInPhaseWithRenderRate) {
     EXPECT_THAT(tracker.nextAnticipatedVSyncTimeFrom(mNow + mPeriod), Eq(mNow + 2 * mPeriod));
 
     const auto renderRateFps = Fps::fromPeriodNsecs(mPeriod * 2);
-    tracker.setRenderRate(renderRateFps, /*applyImmediately*/ true);
+    tracker.setRenderRate(renderRateFps, /*applyImmediately*/ true, /*frameRateOverrides*/ {});
 
     EXPECT_FALSE(tracker.isVSyncInPhase(mNow, renderRateFps));
     EXPECT_TRUE(tracker.isVSyncInPhase(mNow + mPeriod, renderRateFps));
@@ -685,7 +684,8 @@ TEST_F(VSyncPredictorTest, setRenderRateIsRespected) {
         tracker.addVsyncTimestamp(mNow);
     }
 
-    tracker.setRenderRate(Fps::fromPeriodNsecs(3 * mPeriod), /*applyImmediately*/ false);
+    tracker.setRenderRate(Fps::fromPeriodNsecs(3 * mPeriod), /*applyImmediately*/ false,
+                          /*frameRateOverrides*/ {});
 
     EXPECT_THAT(tracker.nextAnticipatedVSyncTimeFrom(mNow), Eq(mNow + 3 * mPeriod));
     EXPECT_THAT(tracker.nextAnticipatedVSyncTimeFrom(mNow + 100), Eq(mNow + 3 * mPeriod));
@@ -705,7 +705,8 @@ TEST_F(VSyncPredictorTest, setRenderRateIsIgnoredIfNotDivisor) {
         tracker.addVsyncTimestamp(mNow);
     }
 
-    tracker.setRenderRate(Fps::fromPeriodNsecs(3.5f * mPeriod), /*applyImmediately*/ false);
+    tracker.setRenderRate(Fps::fromPeriodNsecs(3.5f * mPeriod), /*applyImmediately*/ false,
+                          /*frameRateOverrides*/ {});
 
     EXPECT_THAT(tracker.nextAnticipatedVSyncTimeFrom(mNow), Eq(mNow + mPeriod));
     EXPECT_THAT(tracker.nextAnticipatedVSyncTimeFrom(mNow + 100), Eq(mNow + mPeriod));
@@ -718,7 +719,6 @@ TEST_F(VSyncPredictorTest, setRenderRateIsIgnoredIfNotDivisor) {
 
 TEST_F(VSyncPredictorTest, setRenderRateWhenRenderRateGoesDown) {
     SET_FLAG_FOR_TEST(flags::vrr_config, true);
-    SET_FLAG_FOR_TEST(flags::vrr_bugfix_24q4, true);
 
     const int32_t kGroup = 0;
     const auto kResolution = ui::Size(1920, 1080);
@@ -736,13 +736,13 @@ TEST_F(VSyncPredictorTest, setRenderRateWhenRenderRateGoesDown) {
                               kMinimumSamplesForPrediction, kOutlierTolerancePercent};
 
     Fps frameRate = Fps::fromPeriodNsecs(1000);
-    vrrTracker.setRenderRate(frameRate, /*applyImmediately*/ false);
+    vrrTracker.setRenderRate(frameRate, /*applyImmediately*/ false, /*frameRateOverrides*/ {});
     vrrTracker.addVsyncTimestamp(0);
     EXPECT_EQ(1000, vrrTracker.nextAnticipatedVSyncTimeFrom(700));
     EXPECT_EQ(2000, vrrTracker.nextAnticipatedVSyncTimeFrom(1000, 1000));
 
     frameRate = Fps::fromPeriodNsecs(3000);
-    vrrTracker.setRenderRate(frameRate, /*applyImmediately*/ false);
+    vrrTracker.setRenderRate(frameRate, /*applyImmediately*/ false, /*frameRateOverrides*/ {});
     EXPECT_TRUE(vrrTracker.isVSyncInPhase(2000, frameRate));
 }
 
@@ -764,7 +764,8 @@ TEST_F(VSyncPredictorTest, setRenderRateHighIsAppliedImmediately) {
     VSyncPredictor vrrTracker{std::make_unique<ClockWrapper>(mClock), kMode, kHistorySize,
                               kMinimumSamplesForPrediction, kOutlierTolerancePercent};
 
-    vrrTracker.setRenderRate(Fps::fromPeriodNsecs(1000), /*applyImmediately*/ false);
+    vrrTracker.setRenderRate(Fps::fromPeriodNsecs(1000), /*applyImmediately*/ false,
+                             /*frameRateOverrides*/ {});
     vrrTracker.addVsyncTimestamp(0);
     EXPECT_EQ(1000, vrrTracker.nextAnticipatedVSyncTimeFrom(700));
     EXPECT_EQ(2000, vrrTracker.nextAnticipatedVSyncTimeFrom(1000, 1000));
@@ -772,14 +773,16 @@ TEST_F(VSyncPredictorTest, setRenderRateHighIsAppliedImmediately) {
     // commit to a vsync in the future
     EXPECT_EQ(6000, vrrTracker.nextAnticipatedVSyncTimeFrom(5000, 5000));
 
-    vrrTracker.setRenderRate(Fps::fromPeriodNsecs(2000), /*applyImmediately*/ false);
+    vrrTracker.setRenderRate(Fps::fromPeriodNsecs(2000), /*applyImmediately*/ false,
+                             /*frameRateOverrides*/ {});
     EXPECT_EQ(5000, vrrTracker.nextAnticipatedVSyncTimeFrom(4000, 4000));
     EXPECT_EQ(6000, vrrTracker.nextAnticipatedVSyncTimeFrom(5000, 5000));
     EXPECT_EQ(8000, vrrTracker.nextAnticipatedVSyncTimeFrom(6000, 6000));
 
     EXPECT_EQ(12000, vrrTracker.nextAnticipatedVSyncTimeFrom(10000, 10000));
 
-    vrrTracker.setRenderRate(Fps::fromPeriodNsecs(3500), /*applyImmediately*/ false);
+    vrrTracker.setRenderRate(Fps::fromPeriodNsecs(3500), /*applyImmediately*/ false,
+                             /*frameRateOverrides*/ {});
     EXPECT_EQ(5000, vrrTracker.nextAnticipatedVSyncTimeFrom(4000, 4000));
     EXPECT_EQ(6000, vrrTracker.nextAnticipatedVSyncTimeFrom(5000, 5000));
     EXPECT_EQ(8000, vrrTracker.nextAnticipatedVSyncTimeFrom(6000, 6000));
@@ -788,7 +791,8 @@ TEST_F(VSyncPredictorTest, setRenderRateHighIsAppliedImmediately) {
     EXPECT_EQ(15500, vrrTracker.nextAnticipatedVSyncTimeFrom(12000, 12000));
     EXPECT_EQ(19000, vrrTracker.nextAnticipatedVSyncTimeFrom(15500, 15500));
 
-    vrrTracker.setRenderRate(Fps::fromPeriodNsecs(2500), /*applyImmediately*/ false);
+    vrrTracker.setRenderRate(Fps::fromPeriodNsecs(2500), /*applyImmediately*/ false,
+                             /*frameRateOverrides*/ {});
     EXPECT_EQ(5000, vrrTracker.nextAnticipatedVSyncTimeFrom(4000, 4000));
     EXPECT_EQ(6000, vrrTracker.nextAnticipatedVSyncTimeFrom(5000, 5000));
     EXPECT_EQ(8000, vrrTracker.nextAnticipatedVSyncTimeFrom(6000, 6000));
@@ -798,7 +802,8 @@ TEST_F(VSyncPredictorTest, setRenderRateHighIsAppliedImmediately) {
     EXPECT_EQ(19000, vrrTracker.nextAnticipatedVSyncTimeFrom(15500, 15500));
     EXPECT_EQ(21500, vrrTracker.nextAnticipatedVSyncTimeFrom(19000, 19000));
 
-    vrrTracker.setRenderRate(Fps::fromPeriodNsecs(1000), /*applyImmediately*/ false);
+    vrrTracker.setRenderRate(Fps::fromPeriodNsecs(1000), /*applyImmediately*/ false,
+                             /*frameRateOverrides*/ {});
     EXPECT_EQ(5500, vrrTracker.nextAnticipatedVSyncTimeFrom(4000, 4000));
     EXPECT_EQ(6500, vrrTracker.nextAnticipatedVSyncTimeFrom(5000, 5000));
     EXPECT_EQ(7500, vrrTracker.nextAnticipatedVSyncTimeFrom(6000, 6000));
@@ -830,7 +835,8 @@ TEST_F(VSyncPredictorTest, minFramePeriodDoesntApplyWhenSameWithRefreshRate) {
     VSyncPredictor vrrTracker{std::make_unique<ClockWrapper>(mClock), kMode, kHistorySize,
                               kMinimumSamplesForPrediction, kOutlierTolerancePercent};
 
-    vrrTracker.setRenderRate(Fps::fromPeriodNsecs(1000), /*applyImmediately*/ false);
+    vrrTracker.setRenderRate(Fps::fromPeriodNsecs(1000), /*applyImmediately*/ false,
+                             /*frameRateOverrides*/ {});
     vrrTracker.addVsyncTimestamp(0);
     EXPECT_EQ(1000, vrrTracker.nextAnticipatedVSyncTimeFrom(700));
     EXPECT_EQ(2000, vrrTracker.nextAnticipatedVSyncTimeFrom(1000, 1000));
@@ -857,7 +863,8 @@ TEST_F(VSyncPredictorTest, setRenderRateExplicitAppliedImmediately) {
     VSyncPredictor vrrTracker{std::make_unique<ClockWrapper>(mClock), kMode, kHistorySize,
                               kMinimumSamplesForPrediction, kOutlierTolerancePercent};
 
-    vrrTracker.setRenderRate(Fps::fromPeriodNsecs(1000), /*applyImmediately*/ false);
+    vrrTracker.setRenderRate(Fps::fromPeriodNsecs(1000), /*applyImmediately*/ false,
+                             /*frameRateOverrides*/ {});
     vrrTracker.addVsyncTimestamp(0);
     EXPECT_EQ(1000, vrrTracker.nextAnticipatedVSyncTimeFrom(700));
     EXPECT_EQ(2000, vrrTracker.nextAnticipatedVSyncTimeFrom(1000, 1000));
@@ -865,12 +872,47 @@ TEST_F(VSyncPredictorTest, setRenderRateExplicitAppliedImmediately) {
     // commit to a vsync in the future
     EXPECT_EQ(6000, vrrTracker.nextAnticipatedVSyncTimeFrom(5000, 2000));
 
-    vrrTracker.setRenderRate(Fps::fromPeriodNsecs(2000), /*applyImmediately*/ true);
+    vrrTracker.setRenderRate(Fps::fromPeriodNsecs(2000), /*applyImmediately*/ true,
+                             /*frameRateOverrides*/ {});
     EXPECT_EQ(5000, vrrTracker.nextAnticipatedVSyncTimeFrom(4000));
     EXPECT_EQ(7000, vrrTracker.nextAnticipatedVSyncTimeFrom(5000, 5000));
     EXPECT_EQ(9000, vrrTracker.nextAnticipatedVSyncTimeFrom(7000, 7000));
 }
 
+TEST_F(VSyncPredictorTest, setRenderRateFreezesAtAlignedSequence) {
+    SET_FLAG_FOR_TEST(flags::vsync_predictor_rate_change_with_aligned_sequence, true);
+    const auto refreshRate = Fps::fromPeriodNsecs(500);
+    auto minFrameRate = Fps::fromPeriodNsecs(1000);
+    const auto override1 = Fps::fromPeriodNsecs(2000);
+    const auto override2 = Fps::fromPeriodNsecs(4000);
+    const std::vector<FrameRateOverride> frameRateOverrides =
+            {{.uid = 1, .frameRateHz = override1.getValue()},
+             {.uid = 2, .frameRateHz = override2.getValue()}};
+
+    hal::VrrConfig vrrConfig{.minFrameIntervalNs =
+                                     static_cast<int32_t>(minFrameRate.getPeriodNsecs())};
+
+    ftl::NonNull<DisplayModePtr> mode =
+            ftl::as_non_null(createVrrDisplayMode(DisplayModeId(0), refreshRate, vrrConfig));
+    VSyncPredictor vrrTracker{std::make_unique<ClockWrapper>(mClock), mode, kHistorySize,
+                              kMinimumSamplesForPrediction, kOutlierTolerancePercent};
+    vrrTracker.setRenderRate(override1, /*applyImmediately*/ false, frameRateOverrides);
+
+    EXPECT_THAT(vrrTracker.nextAnticipatedVSyncTimeFrom(500), Eq(1000));
+    EXPECT_THAT(vrrTracker.nextAnticipatedVSyncTimeFrom(1000), Eq(3000));
+
+    vrrTracker.setRenderRate(override2, /*applyImmediately*/ false, frameRateOverrides);
+    EXPECT_THAT(vrrTracker.nextAnticipatedVSyncTimeFrom(3000), Eq(5000));
+    // Aligns on the second vsync after setRenderRate and now rate is 4000
+    EXPECT_THAT(vrrTracker.nextAnticipatedVSyncTimeFrom(5000), Eq(9000));
+    EXPECT_THAT(vrrTracker.nextAnticipatedVSyncTimeFrom(9000), Eq(13000));
+
+    vrrTracker.setRenderRate(override1, /*applyImmediately*/ false, frameRateOverrides);
+    // Aligns immediately for 2000 rate as it aligns on each 4000
+    EXPECT_THAT(vrrTracker.nextAnticipatedVSyncTimeFrom(13000), Eq(15000));
+    EXPECT_THAT(vrrTracker.nextAnticipatedVSyncTimeFrom(15000), Eq(17000));
+}
+
 TEST_F(VSyncPredictorTest, selectsClosestVsyncAfterInactivity) {
     SET_FLAG_FOR_TEST(flags::vrr_config, true);
 
@@ -889,7 +931,8 @@ TEST_F(VSyncPredictorTest, selectsClosestVsyncAfterInactivity) {
     VSyncPredictor vrrTracker{std::make_unique<ClockWrapper>(mClock), kMode, kHistorySize,
                               kMinimumSamplesForPrediction, kOutlierTolerancePercent};
 
-    vrrTracker.setRenderRate(Fps::fromPeriodNsecs(5000), /*applyImmediately*/ false);
+    vrrTracker.setRenderRate(Fps::fromPeriodNsecs(5000), /*applyImmediately*/ false,
+                             /*frameRateOverrides*/ {});
     vrrTracker.addVsyncTimestamp(0);
     EXPECT_EQ(5000, vrrTracker.nextAnticipatedVSyncTimeFrom(4700));
     EXPECT_EQ(10000, vrrTracker.nextAnticipatedVSyncTimeFrom(5000, 5000));
@@ -916,7 +959,8 @@ TEST_F(VSyncPredictorTest, returnsCorrectVsyncWhenLastIsNot) {
     VSyncPredictor vrrTracker{std::make_unique<ClockWrapper>(mClock), kMode, kHistorySize,
                               kMinimumSamplesForPrediction, kOutlierTolerancePercent};
 
-    vrrTracker.setRenderRate(Fps::fromPeriodNsecs(1000), /*applyImmediately*/ false);
+    vrrTracker.setRenderRate(Fps::fromPeriodNsecs(1000), /*applyImmediately*/ false,
+                             /*frameRateOverrides*/ {});
     vrrTracker.addVsyncTimestamp(0);
     EXPECT_EQ(2500, vrrTracker.nextAnticipatedVSyncTimeFrom(1234, 1234));
 }
@@ -939,7 +983,7 @@ TEST_F(VSyncPredictorTest, adjustsVrrTimeline) {
     VSyncPredictor vrrTracker{std::make_unique<ClockWrapper>(mClock), kMode, kHistorySize,
                               kMinimumSamplesForPrediction, kOutlierTolerancePercent};
 
-    vrrTracker.setRenderRate(minFrameRate, /*applyImmediately*/ false);
+    vrrTracker.setRenderRate(minFrameRate, /*applyImmediately*/ false, /*frameRateOverrides*/ {});
     vrrTracker.addVsyncTimestamp(0);
     EXPECT_EQ(1000, vrrTracker.nextAnticipatedVSyncTimeFrom(700));
     EXPECT_EQ(2000, vrrTracker.nextAnticipatedVSyncTimeFrom(1000));
@@ -980,7 +1024,7 @@ TEST_F(VSyncPredictorTest, adjustsVrrTimelineTwoClients) {
     VSyncPredictor vrrTracker{std::make_unique<ClockWrapper>(mClock), kMode, kHistorySize,
                               kMinimumSamplesForPrediction, kOutlierTolerancePercent};
 
-    vrrTracker.setRenderRate(minFrameRate, /*applyImmediately*/ false);
+    vrrTracker.setRenderRate(minFrameRate, /*applyImmediately*/ false, /*frameRateOverrides*/ {});
     vrrTracker.addVsyncTimestamp(0);
 
     // App runs ahead
@@ -1022,7 +1066,8 @@ TEST_F(VSyncPredictorTest, renderRateIsPreservedForCommittedVsyncs) {
     EXPECT_THAT(tracker.nextAnticipatedVSyncTimeFrom(5001), Eq(6000));
     EXPECT_THAT(tracker.nextAnticipatedVSyncTimeFrom(6001), Eq(7000));
 
-    tracker.setRenderRate(Fps::fromPeriodNsecs(2000), /*applyImmediately*/ false);
+    tracker.setRenderRate(Fps::fromPeriodNsecs(2000), /*applyImmediately*/ false,
+                          /*frameRateOverrides*/ {});
     EXPECT_THAT(tracker.nextAnticipatedVSyncTimeFrom(1), Eq(1000));
     EXPECT_THAT(tracker.nextAnticipatedVSyncTimeFrom(5001), Eq(6000));
     EXPECT_THAT(tracker.nextAnticipatedVSyncTimeFrom(6001), Eq(7000));
@@ -1031,7 +1076,8 @@ TEST_F(VSyncPredictorTest, renderRateIsPreservedForCommittedVsyncs) {
     EXPECT_THAT(tracker.nextAnticipatedVSyncTimeFrom(9001), Eq(11000));
     EXPECT_THAT(tracker.nextAnticipatedVSyncTimeFrom(10001), Eq(11000));
 
-    tracker.setRenderRate(Fps::fromPeriodNsecs(3000), /*applyImmediately*/ false);
+    tracker.setRenderRate(Fps::fromPeriodNsecs(3000), /*applyImmediately*/ false,
+                          /*frameRateOverrides*/ {});
     EXPECT_THAT(tracker.nextAnticipatedVSyncTimeFrom(1), Eq(1000));
     EXPECT_THAT(tracker.nextAnticipatedVSyncTimeFrom(5001), Eq(6000));
     EXPECT_THAT(tracker.nextAnticipatedVSyncTimeFrom(6001), Eq(7000));
@@ -1057,12 +1103,14 @@ TEST_F(VSyncPredictorTest, renderRateChangeAfterAppliedImmediately) {
     EXPECT_THAT(tracker.nextAnticipatedVSyncTimeFrom(1001), Eq(2000));
     EXPECT_THAT(tracker.nextAnticipatedVSyncTimeFrom(2001), Eq(3000));
 
-    tracker.setRenderRate(Fps::fromPeriodNsecs(2000), /*applyImmediately*/ true);
+    tracker.setRenderRate(Fps::fromPeriodNsecs(2000), /*applyImmediately*/ true,
+                          /*frameRateOverrides*/ {});
     EXPECT_THAT(tracker.nextAnticipatedVSyncTimeFrom(1), Eq(1000));
     EXPECT_THAT(tracker.nextAnticipatedVSyncTimeFrom(1001), Eq(3000));
     EXPECT_THAT(tracker.nextAnticipatedVSyncTimeFrom(3001), Eq(5000));
 
-    tracker.setRenderRate(Fps::fromPeriodNsecs(4000), /*applyImmediately*/ false);
+    tracker.setRenderRate(Fps::fromPeriodNsecs(4000), /*applyImmediately*/ false,
+                          /*frameRateOverrides*/ {});
     EXPECT_THAT(tracker.nextAnticipatedVSyncTimeFrom(1), Eq(1000));
     EXPECT_THAT(tracker.nextAnticipatedVSyncTimeFrom(1001), Eq(3000));
     EXPECT_THAT(tracker.nextAnticipatedVSyncTimeFrom(3001), Eq(5000));
@@ -1088,7 +1136,7 @@ TEST_F(VSyncPredictorTest, timelineNotAdjustedForEarlyPresent) {
     VSyncPredictor vrrTracker{std::make_unique<ClockWrapper>(mClock), kMode, kHistorySize,
                               kMinimumSamplesForPrediction, kOutlierTolerancePercent};
 
-    vrrTracker.setRenderRate(minFrameRate, /*applyImmediately*/ false);
+    vrrTracker.setRenderRate(minFrameRate, /*applyImmediately*/ false, /*frameRateOverrides*/ {});
     vrrTracker.addVsyncTimestamp(0);
     EXPECT_EQ(1000, vrrTracker.nextAnticipatedVSyncTimeFrom(700));
 
@@ -1109,7 +1157,7 @@ TEST_F(VSyncPredictorTest, adjustsOnlyMinFrameViolatingVrrTimeline) {
             ftl::as_non_null(createVrrDisplayMode(DisplayModeId(0), refreshRate, vrrConfig));
     VSyncPredictor vrrTracker{std::make_unique<ClockWrapper>(mClock), mode, kHistorySize,
                               kMinimumSamplesForPrediction, kOutlierTolerancePercent};
-    vrrTracker.setRenderRate(minFrameRate, /*applyImmediately*/ false);
+    vrrTracker.setRenderRate(minFrameRate, /*applyImmediately*/ false, /*frameRateOverrides*/ {});
     vrrTracker.addVsyncTimestamp(0);
 
     EXPECT_EQ(1000, vrrTracker.nextAnticipatedVSyncTimeFrom(700));
@@ -1121,7 +1169,7 @@ TEST_F(VSyncPredictorTest, adjustsOnlyMinFrameViolatingVrrTimeline) {
     EXPECT_EQ(3500, vrrTracker.nextAnticipatedVSyncTimeFrom(3000, 1500));
 
     minFrameRate = Fps::fromPeriodNsecs(2000);
-    vrrTracker.setRenderRate(minFrameRate, /*applyImmediately*/ false);
+    vrrTracker.setRenderRate(minFrameRate, /*applyImmediately*/ false, /*frameRateOverrides*/ {});
     lastConfirmedSignalTime = TimePoint::fromNs(2500);
     lastConfirmedExpectedPresentTime = TimePoint::fromNs(2500);
     vrrTracker.onFrameBegin(TimePoint::fromNs(3000),
diff --git a/services/surfaceflinger/tests/unittests/VsyncModulatorTest.cpp b/services/surfaceflinger/tests/unittests/VsyncModulatorTest.cpp
index 8acbd6fa03..4b66d25f0f 100644
--- a/services/surfaceflinger/tests/unittests/VsyncModulatorTest.cpp
+++ b/services/surfaceflinger/tests/unittests/VsyncModulatorTest.cpp
@@ -68,6 +68,13 @@ protected:
     sp<TestableVsyncModulator> mVsyncModulator = sp<TestableVsyncModulator>::make(mOffsets, Now);
 
     void SetUp() override { EXPECT_EQ(kLate, mVsyncModulator->setVsyncConfigSet(mOffsets)); }
+
+    gui::EarlyWakeupInfo createTestEarlyWakeupInfo() {
+        gui::EarlyWakeupInfo earlyWakeupInfo;
+        earlyWakeupInfo.token = sp<BBinder>::make();
+        earlyWakeupInfo.trace = "example calling trace";
+        return earlyWakeupInfo;
+    }
 };
 
 #define CHECK_COMMIT(result, configs)                          \
@@ -88,8 +95,12 @@ TEST_F(VsyncModulatorTest, Late) {
 }
 
 TEST_F(VsyncModulatorTest, EarlyEnd) {
-    const auto token = sp<BBinder>::make();
-    EXPECT_EQ(kEarly, mVsyncModulator->setTransactionSchedule(Schedule::EarlyEnd, token));
+    std::vector<gui::EarlyWakeupInfo> earlyWakeupInfos;
+    gui::EarlyWakeupInfo info = createTestEarlyWakeupInfo();
+    info.isStartRequest = false;
+    earlyWakeupInfos.push_back(info);
+    EXPECT_EQ(kEarly,
+              mVsyncModulator->setTransactionSchedule(Schedule::EarlyEnd, earlyWakeupInfos));
 
     CHECK_COMMIT(kEarly, kEarly);
     CHECK_REFRESH(MIN_EARLY_TRANSACTION_FRAMES - 1, kEarly, kEarly);
@@ -97,13 +108,18 @@ TEST_F(VsyncModulatorTest, EarlyEnd) {
 }
 
 TEST_F(VsyncModulatorTest, EarlyStart) {
-    const auto token = sp<BBinder>::make();
-    EXPECT_EQ(kEarly, mVsyncModulator->setTransactionSchedule(Schedule::EarlyStart, token));
+    std::vector<gui::EarlyWakeupInfo> earlyWakeupInfos;
+    gui::EarlyWakeupInfo info = createTestEarlyWakeupInfo();
+    info.isStartRequest = true;
+    earlyWakeupInfos.push_back(info);
+    EXPECT_EQ(kEarly,
+              mVsyncModulator->setTransactionSchedule(Schedule::EarlyStart, earlyWakeupInfos));
 
     CHECK_COMMIT(kEarly, kEarly);
     CHECK_REFRESH(5 * MIN_EARLY_TRANSACTION_FRAMES, std::nullopt, kEarly);
 
-    EXPECT_EQ(kEarly, mVsyncModulator->setTransactionSchedule(Schedule::EarlyEnd, token));
+    EXPECT_EQ(kEarly,
+              mVsyncModulator->setTransactionSchedule(Schedule::EarlyEnd, earlyWakeupInfos));
 
     CHECK_COMMIT(kEarly, kEarly);
     CHECK_REFRESH(MIN_EARLY_TRANSACTION_FRAMES - 1, kEarly, kEarly);
@@ -111,8 +127,12 @@ TEST_F(VsyncModulatorTest, EarlyStart) {
 }
 
 TEST_F(VsyncModulatorTest, EarlyStartWithMoreTransactions) {
-    const auto token = sp<BBinder>::make();
-    EXPECT_EQ(kEarly, mVsyncModulator->setTransactionSchedule(Schedule::EarlyStart, token));
+    std::vector<gui::EarlyWakeupInfo> earlyWakeupInfos;
+    gui::EarlyWakeupInfo info = createTestEarlyWakeupInfo();
+    info.isStartRequest = true;
+    earlyWakeupInfos.push_back(info);
+    EXPECT_EQ(kEarly,
+              mVsyncModulator->setTransactionSchedule(Schedule::EarlyStart, earlyWakeupInfos));
 
     CHECK_COMMIT(kEarly, kEarly);
 
@@ -121,7 +141,8 @@ TEST_F(VsyncModulatorTest, EarlyStartWithMoreTransactions) {
         CHECK_REFRESH(1, std::nullopt, kEarly);
     }
 
-    EXPECT_EQ(kEarly, mVsyncModulator->setTransactionSchedule(Schedule::EarlyEnd, token));
+    EXPECT_EQ(kEarly,
+              mVsyncModulator->setTransactionSchedule(Schedule::EarlyEnd, earlyWakeupInfos));
 
     CHECK_COMMIT(kEarly, kEarly);
     CHECK_REFRESH(MIN_EARLY_TRANSACTION_FRAMES - 1, kEarly, kEarly);
@@ -129,19 +150,25 @@ TEST_F(VsyncModulatorTest, EarlyStartWithMoreTransactions) {
 }
 
 TEST_F(VsyncModulatorTest, EarlyStartAfterEarlyEnd) {
-    const auto token = sp<BBinder>::make();
-    EXPECT_EQ(kEarly, mVsyncModulator->setTransactionSchedule(Schedule::EarlyEnd, token));
+    std::vector<gui::EarlyWakeupInfo> earlyWakeupInfos;
+    gui::EarlyWakeupInfo info = createTestEarlyWakeupInfo();
+    info.isStartRequest = true;
+    earlyWakeupInfos.push_back(info);
+    EXPECT_EQ(kEarly,
+              mVsyncModulator->setTransactionSchedule(Schedule::EarlyEnd, earlyWakeupInfos));
 
     CHECK_COMMIT(kEarly, kEarly);
     CHECK_REFRESH(MIN_EARLY_TRANSACTION_FRAMES - 1, kEarly, kEarly);
 
-    EXPECT_EQ(kEarly, mVsyncModulator->setTransactionSchedule(Schedule::EarlyStart, token));
+    EXPECT_EQ(kEarly,
+              mVsyncModulator->setTransactionSchedule(Schedule::EarlyStart, earlyWakeupInfos));
 
     CHECK_COMMIT(kEarly, kEarly);
     CHECK_REFRESH(1, kEarly, kEarly);
     CHECK_REFRESH(5 * MIN_EARLY_TRANSACTION_FRAMES, std::nullopt, kEarly);
 
-    EXPECT_EQ(kEarly, mVsyncModulator->setTransactionSchedule(Schedule::EarlyEnd, token));
+    EXPECT_EQ(kEarly,
+              mVsyncModulator->setTransactionSchedule(Schedule::EarlyEnd, earlyWakeupInfos));
 
     CHECK_COMMIT(kEarly, kEarly);
     CHECK_REFRESH(MIN_EARLY_TRANSACTION_FRAMES - 1, kEarly, kEarly);
@@ -149,13 +176,18 @@ TEST_F(VsyncModulatorTest, EarlyStartAfterEarlyEnd) {
 }
 
 TEST_F(VsyncModulatorTest, EarlyStartAfterEarlyEndWithMoreTransactions) {
-    const auto token = sp<BBinder>::make();
-    EXPECT_EQ(kEarly, mVsyncModulator->setTransactionSchedule(Schedule::EarlyEnd, token));
+    std::vector<gui::EarlyWakeupInfo> earlyWakeupInfos;
+    gui::EarlyWakeupInfo info = createTestEarlyWakeupInfo();
+    info.isStartRequest = true;
+    earlyWakeupInfos.push_back(info);
+    EXPECT_EQ(kEarly,
+              mVsyncModulator->setTransactionSchedule(Schedule::EarlyEnd, earlyWakeupInfos));
 
     CHECK_COMMIT(kEarly, kEarly);
     CHECK_REFRESH(MIN_EARLY_TRANSACTION_FRAMES - 1, kEarly, kEarly);
 
-    EXPECT_EQ(kEarly, mVsyncModulator->setTransactionSchedule(Schedule::EarlyStart, token));
+    EXPECT_EQ(kEarly,
+              mVsyncModulator->setTransactionSchedule(Schedule::EarlyStart, earlyWakeupInfos));
 
     CHECK_COMMIT(kEarly, kEarly);
     CHECK_REFRESH(1, kEarly, kEarly);
@@ -165,7 +197,8 @@ TEST_F(VsyncModulatorTest, EarlyStartAfterEarlyEndWithMoreTransactions) {
         CHECK_REFRESH(1, std::nullopt, kEarly);
     }
 
-    EXPECT_EQ(kEarly, mVsyncModulator->setTransactionSchedule(Schedule::EarlyEnd, token));
+    EXPECT_EQ(kEarly,
+              mVsyncModulator->setTransactionSchedule(Schedule::EarlyEnd, earlyWakeupInfos));
 
     CHECK_COMMIT(kEarly, kEarly);
     CHECK_REFRESH(MIN_EARLY_TRANSACTION_FRAMES - 1, kEarly, kEarly);
@@ -173,24 +206,36 @@ TEST_F(VsyncModulatorTest, EarlyStartAfterEarlyEndWithMoreTransactions) {
 }
 
 TEST_F(VsyncModulatorTest, EarlyStartDifferentClients) {
-    const auto token1 = sp<BBinder>::make();
-    const auto token2 = sp<BBinder>::make();
-    EXPECT_EQ(kEarly, mVsyncModulator->setTransactionSchedule(Schedule::EarlyStart, token1));
+    std::vector<gui::EarlyWakeupInfo> earlyWakeupInfos1;
+    gui::EarlyWakeupInfo info = createTestEarlyWakeupInfo();
+    info.isStartRequest = true;
+    earlyWakeupInfos1.push_back(info);
+
+    std::vector<gui::EarlyWakeupInfo> earlyWakeupInfos2;
+    info = createTestEarlyWakeupInfo();
+    info.isStartRequest = true;
+    earlyWakeupInfos2.push_back(info);
+
+    EXPECT_EQ(kEarly,
+              mVsyncModulator->setTransactionSchedule(Schedule::EarlyStart, earlyWakeupInfos1));
 
     CHECK_COMMIT(kEarly, kEarly);
     CHECK_REFRESH(5 * MIN_EARLY_TRANSACTION_FRAMES, std::nullopt, kEarly);
 
-    EXPECT_EQ(kEarly, mVsyncModulator->setTransactionSchedule(Schedule::EarlyStart, token2));
+    EXPECT_EQ(kEarly,
+              mVsyncModulator->setTransactionSchedule(Schedule::EarlyStart, earlyWakeupInfos2));
 
     CHECK_COMMIT(kEarly, kEarly);
     CHECK_REFRESH(5 * MIN_EARLY_TRANSACTION_FRAMES, std::nullopt, kEarly);
 
-    EXPECT_EQ(kEarly, mVsyncModulator->setTransactionSchedule(Schedule::EarlyEnd, token1));
+    EXPECT_EQ(kEarly,
+              mVsyncModulator->setTransactionSchedule(Schedule::EarlyEnd, earlyWakeupInfos1));
 
     CHECK_COMMIT(kEarly, kEarly);
     CHECK_REFRESH(5 * MIN_EARLY_TRANSACTION_FRAMES, std::nullopt, kEarly);
 
-    EXPECT_EQ(kEarly, mVsyncModulator->setTransactionSchedule(Schedule::EarlyEnd, token2));
+    EXPECT_EQ(kEarly,
+              mVsyncModulator->setTransactionSchedule(Schedule::EarlyEnd, earlyWakeupInfos2));
 
     CHECK_COMMIT(kEarly, kEarly);
     CHECK_REFRESH(MIN_EARLY_TRANSACTION_FRAMES - 1, kEarly, kEarly);
@@ -198,13 +243,17 @@ TEST_F(VsyncModulatorTest, EarlyStartDifferentClients) {
 }
 
 TEST_F(VsyncModulatorTest, EarlyStartWithBinderDeath) {
-    const auto token = sp<BBinder>::make();
-    EXPECT_EQ(kEarly, mVsyncModulator->setTransactionSchedule(Schedule::EarlyStart, token));
+    std::vector<gui::EarlyWakeupInfo> earlyWakeupInfos;
+    gui::EarlyWakeupInfo info = createTestEarlyWakeupInfo();
+    info.isStartRequest = true;
+    earlyWakeupInfos.push_back(info);
+    EXPECT_EQ(kEarly,
+              mVsyncModulator->setTransactionSchedule(Schedule::EarlyStart, earlyWakeupInfos));
 
     CHECK_COMMIT(kEarly, kEarly);
     CHECK_REFRESH(5 * MIN_EARLY_TRANSACTION_FRAMES, std::nullopt, kEarly);
 
-    mVsyncModulator->binderDied(token);
+    mVsyncModulator->binderDied(earlyWakeupInfos[0].token);
 
     CHECK_COMMIT(std::nullopt, kLate);
 }
diff --git a/services/surfaceflinger/tests/unittests/mock/DisplayHardware/MockComposer.h b/services/surfaceflinger/tests/unittests/mock/DisplayHardware/MockComposer.h
index 00e4cc6818..bd163555a2 100644
--- a/services/surfaceflinger/tests/unittests/mock/DisplayHardware/MockComposer.h
+++ b/services/surfaceflinger/tests/unittests/mock/DisplayHardware/MockComposer.h
@@ -18,6 +18,8 @@
 
 #include <gmock/gmock.h>
 
+#include <ui/ScreenPartStatus.h>
+
 #include "DisplayHardware/ComposerHal.h"
 #include "DisplayHardware/HWC2.h"
 #include "DisplayHardware/Hal.h"
@@ -83,7 +85,8 @@ public:
     MOCK_METHOD1(getPerFrameMetadataKeys,
                  std::vector<IComposerClient::PerFrameMetadataKey>(Display));
     MOCK_METHOD2(getDataspaceSaturationMatrix, Error(Dataspace, mat4*));
-    MOCK_METHOD3(getDisplayIdentificationData, Error(Display, uint8_t*, std::vector<uint8_t>*));
+    MOCK_METHOD4(getDisplayIdentificationData,
+                 Error(Display, uint8_t*, std::vector<uint8_t>*, android::ScreenPartStatus*));
     MOCK_METHOD3(getReleaseFences, Error(Display, std::vector<Layer>*, std::vector<int>*));
     MOCK_METHOD2(presentDisplay, Error(Display, int*));
     MOCK_METHOD2(setActiveConfig, Error(Display, Config));
@@ -197,6 +200,10 @@ public:
                  std::vector<aidl::android::hardware::graphics::composer3::Luts>*));
     MOCK_METHOD4(getLayerPresentFences,
                  Error(Display, std::vector<Layer>*, std::vector<int>*, std::vector<int64_t>*));
+    MOCK_METHOD(Error, getReadbackBufferAttributes,
+                (Display, aidl::android::hardware::graphics::composer3::ReadbackBufferAttributes*));
+    MOCK_METHOD(Error, setReadbackBuffer, (Display, const sp<GraphicBuffer>&, int));
+    MOCK_METHOD(Error, getReadbackBufferFence, (Display, int*));
 };
 
 } // namespace Hwc2::mock
diff --git a/services/surfaceflinger/tests/unittests/mock/DisplayHardware/MockHWC2.h b/services/surfaceflinger/tests/unittests/mock/DisplayHardware/MockHWC2.h
index a20b9e1f0d..8974ee8297 100644
--- a/services/surfaceflinger/tests/unittests/mock/DisplayHardware/MockHWC2.h
+++ b/services/surfaceflinger/tests/unittests/mock/DisplayHardware/MockHWC2.h
@@ -122,6 +122,12 @@ public:
                 (const std::vector<android::sp<android::GraphicBuffer>>&,
                  std::vector<aidl::android::hardware::graphics::composer3::Luts>*),
                 (override));
+    MOCK_METHOD(hal::Error, getReadbackBufferAttributes,
+                (aidl::android::hardware::graphics::composer3::ReadbackBufferAttributes*),
+                (override));
+    MOCK_METHOD(hal::Error, setReadbackBuffer,
+                (const sp<GraphicBuffer>&, const android::sp<android::Fence>&), (override));
+    MOCK_METHOD(hal::Error, getReadbackBufferFence, (android::sp<android::Fence>*), (override));
 };
 
 class Layer : public HWC2::Layer {
diff --git a/services/surfaceflinger/tests/unittests/mock/DisplayHardware/MockHWComposer.h b/services/surfaceflinger/tests/unittests/mock/DisplayHardware/MockHWComposer.h
index 449c45bc0a..5c8dfd0fc1 100644
--- a/services/surfaceflinger/tests/unittests/mock/DisplayHardware/MockHWComposer.h
+++ b/services/surfaceflinger/tests/unittests/mock/DisplayHardware/MockHWComposer.h
@@ -18,6 +18,7 @@
 
 #include <gmock/gmock.h>
 
+#include "Display/DisplayIdentification.h"
 #include "DisplayHardware/HWComposer.h"
 
 namespace android::mock {
@@ -32,7 +33,9 @@ public:
 
     MOCK_METHOD(void, setCallback, (HWC2::ComposerCallback&), (override));
     MOCK_METHOD(bool, getDisplayIdentificationData,
-                (HWDisplayId, uint8_t*, DisplayIdentificationData*), (const, override));
+                (HWDisplayId, uint8_t*, display::DisplayIdentificationData*,
+                 android::ScreenPartStatus*),
+                (const, override));
     MOCK_METHOD(bool, hasCapability, (aidl::android::hardware::graphics::composer3::Capability),
                 (const, override));
     MOCK_METHOD(bool, hasDisplayCapability,
@@ -81,7 +84,7 @@ public:
     MOCK_METHOD(ftl::Future<status_t>, setDisplayBrightness,
                 (PhysicalDisplayId, float, float, const Hwc2::Composer::DisplayBrightnessOptions&),
                 (override));
-    MOCK_METHOD(std::optional<DisplayIdentificationInfo>, onHotplug,
+    MOCK_METHOD(std::optional<display::DisplayIdentificationInfo>, onHotplug,
                 (hal::HWDisplayId, HWComposer::HotplugEvent), (override));
     MOCK_METHOD(bool, updatesDeviceProductInfoOnHotplugReconnect, (), (const, override));
     MOCK_METHOD(std::optional<PhysicalDisplayId>, onVsync, (hal::HWDisplayId, int64_t));
@@ -157,6 +160,13 @@ public:
     MOCK_METHOD(status_t, getLuts,
                 (PhysicalDisplayId, const std::vector<sp<GraphicBuffer>>&,
                  std::vector<aidl::android::hardware::graphics::composer3::Luts>*));
+
+    MOCK_METHOD(status_t, getReadbackBufferAttributes,
+                (PhysicalDisplayId,
+                 aidl::android::hardware::graphics::composer3::ReadbackBufferAttributes*));
+    MOCK_METHOD(status_t, setReadbackBuffer,
+                (PhysicalDisplayId, const sp<GraphicBuffer>&, const android::sp<android::Fence>&));
+    MOCK_METHOD(sp<Fence>, getReadbackBufferFence, (PhysicalDisplayId));
 };
 
 } // namespace android::mock
diff --git a/services/surfaceflinger/tests/unittests/mock/MockEventThread.h b/services/surfaceflinger/tests/unittests/mock/MockEventThread.h
index cce4d2aba8..512252a137 100644
--- a/services/surfaceflinger/tests/unittests/mock/MockEventThread.h
+++ b/services/surfaceflinger/tests/unittests/mock/MockEventThread.h
@@ -33,11 +33,16 @@ public:
     MOCK_METHOD(void, omitVsyncDispatching, (bool), (override));
     MOCK_METHOD(void, onHotplugReceived, (PhysicalDisplayId, bool), (override));
     MOCK_METHOD(void, onHotplugConnectionError, (int32_t), (override));
-    MOCK_METHOD(void, onModeChanged, (const scheduler::FrameRateMode&), (override));
+    MOCK_METHOD(void, onModeChanged, (const scheduler::FrameRateMode&, scheduler::VsyncConfigSet),
+                (override));
     MOCK_METHOD(void, onModeRejected, (PhysicalDisplayId displayId, DisplayModeId modeId),
                 (override));
     MOCK_METHOD(void, onFrameRateOverridesChanged,
                 (PhysicalDisplayId, std::vector<FrameRateOverride>), (override));
+    MOCK_METHOD(void, onModeAndFrameRateOverridesChanged,
+                (PhysicalDisplayId, const scheduler::FrameRateMode&,
+                 std::vector<FrameRateOverride> overrides, scheduler::VsyncConfigSet),
+                (override));
     MOCK_METHOD(void, dump, (std::string&), (const, override));
     MOCK_METHOD(void, setDuration,
                 (std::chrono::nanoseconds workDuration, std::chrono::nanoseconds readyDuration),
diff --git a/services/surfaceflinger/tests/unittests/mock/MockFrameTimeline.cpp b/services/surfaceflinger/tests/unittests/mock/MockFrameTimeline.cpp
index ff005a0756..4f32d80d6f 100644
--- a/services/surfaceflinger/tests/unittests/mock/MockFrameTimeline.cpp
+++ b/services/surfaceflinger/tests/unittests/mock/MockFrameTimeline.cpp
@@ -20,7 +20,7 @@ namespace android::mock {
 
 // Explicit default instantiation is recommended.
 FrameTimeline::FrameTimeline(std::shared_ptr<TimeStats> timeStats, pid_t surfaceFlingerPid)
-      : android::frametimeline::impl::FrameTimeline(timeStats, surfaceFlingerPid) {}
+      : android::scheduler::impl::FrameTimeline(timeStats, surfaceFlingerPid) {}
 FrameTimeline::~FrameTimeline() = default;
 
 } // namespace android::mock
diff --git a/services/surfaceflinger/tests/unittests/mock/MockFrameTimeline.h b/services/surfaceflinger/tests/unittests/mock/MockFrameTimeline.h
index 3f2a917ddc..c25e69c243 100644
--- a/services/surfaceflinger/tests/unittests/mock/MockFrameTimeline.h
+++ b/services/surfaceflinger/tests/unittests/mock/MockFrameTimeline.h
@@ -18,11 +18,11 @@
 
 #include <gmock/gmock.h>
 
-#include "FrameTimeline/FrameTimeline.h"
+#include "Scheduler/FrameTimeline.h"
 
 namespace android::mock {
 
-class FrameTimeline : public android::frametimeline::impl::FrameTimeline {
+class FrameTimeline : public android::scheduler::impl::FrameTimeline {
     // No need to create mocks for SurfaceFrame and TokenManager yet. They are very small components
     // and do not have external dependencies like perfetto.
 public:
@@ -30,7 +30,7 @@ public:
     ~FrameTimeline();
 
     MOCK_METHOD0(onBootFinished, void());
-    MOCK_METHOD1(addSurfaceFrame, void(std::shared_ptr<frametimeline::SurfaceFrame>));
+    MOCK_METHOD1(addSurfaceFrame, void(std::shared_ptr<scheduler::SurfaceFrame>));
     MOCK_METHOD4(setSfWakeUp, void(int64_t, nsecs_t, Fps, Fps));
     MOCK_METHOD3(setSfPresent,
                  void(nsecs_t, const std::shared_ptr<FenceTime>&,
diff --git a/services/surfaceflinger/tests/unittests/mock/MockSchedulerCallback.h b/services/surfaceflinger/tests/unittests/mock/MockSchedulerCallback.h
index 25dd68e1ca..60278a2592 100644
--- a/services/surfaceflinger/tests/unittests/mock/MockSchedulerCallback.h
+++ b/services/surfaceflinger/tests/unittests/mock/MockSchedulerCallback.h
@@ -30,7 +30,8 @@ struct SchedulerCallback final : ISchedulerCallback {
     MOCK_METHOD(void, onExpectedPresentTimePosted, (TimePoint, ftl::NonNull<DisplayModePtr>, Fps),
                 (override));
     MOCK_METHOD(void, onCommitNotComposited, (), (override));
-    MOCK_METHOD(void, vrrDisplayIdle, (bool), (override));
+    MOCK_METHOD(void, vrrDisplayIdle, (PhysicalDisplayId, bool), (override));
+    MOCK_METHOD(void, enableLayerCachingTexturePool, (PhysicalDisplayId, bool), (override));
 };
 
 struct NoOpSchedulerCallback final : ISchedulerCallback {
@@ -40,7 +41,8 @@ struct NoOpSchedulerCallback final : ISchedulerCallback {
     void onChoreographerAttached() override {}
     void onExpectedPresentTimePosted(TimePoint, ftl::NonNull<DisplayModePtr>, Fps) override {}
     void onCommitNotComposited() override {}
-    void vrrDisplayIdle(bool) override {}
+    void vrrDisplayIdle(PhysicalDisplayId, bool) override {}
+    void enableLayerCachingTexturePool(PhysicalDisplayId, bool) override {}
 };
 
 } // namespace android::scheduler::mock
diff --git a/services/surfaceflinger/tests/unittests/mock/MockVSyncTracker.h b/services/surfaceflinger/tests/unittests/mock/MockVSyncTracker.h
index 8d6d1d3cdc..859079534d 100644
--- a/services/surfaceflinger/tests/unittests/mock/MockVSyncTracker.h
+++ b/services/surfaceflinger/tests/unittests/mock/MockVSyncTracker.h
@@ -22,7 +22,10 @@
 
 #include "Scheduler/VSyncTracker.h"
 
+#include <gui/DisplayEventReceiver.h>
+
 namespace android::mock {
+using FrameRateOverride = DisplayEventReceiver::Event::FrameRateOverride;
 
 class VSyncTracker : public android::scheduler::VSyncTracker {
 public:
@@ -38,7 +41,7 @@ public:
     MOCK_METHOD(bool, needsMoreSamples, (), (const, override));
     MOCK_METHOD(bool, isVSyncInPhase, (nsecs_t, Fps), (override));
     MOCK_METHOD(void, setDisplayModePtr, (ftl::NonNull<DisplayModePtr>), (override));
-    MOCK_METHOD(void, setRenderRate, (Fps, bool), (override));
+    MOCK_METHOD(void, setRenderRate, (Fps, bool, std::vector<FrameRateOverride>), (override));
     MOCK_METHOD(void, onFrameBegin, (TimePoint, scheduler::FrameTime), (override));
     MOCK_METHOD(void, onFrameMissed, (TimePoint), (override));
     MOCK_METHOD(void, dump, (std::string&), (const, override));
diff --git a/services/surfaceflinger/tests/utils/ScreenshotUtils.h b/services/surfaceflinger/tests/utils/ScreenshotUtils.h
index 02c3ecd587..55f809706e 100644
--- a/services/surfaceflinger/tests/utils/ScreenshotUtils.h
+++ b/services/surfaceflinger/tests/utils/ScreenshotUtils.h
@@ -281,8 +281,8 @@ public:
         ASSERT_LE(rect.right, bufferWidth);
         ASSERT_LE(rect.bottom, bufferHeight);
 
-        ASSERT_LE(rect.right, imageWidth);
-        ASSERT_LE(rect.bottom, imageHeight);
+        ASSERT_LE(rect.right - rect.left, imageWidth);
+        ASSERT_LE(rect.bottom - rect.top, imageHeight);
 
         int tolerance = 4; // arbitrary
         for (int32_t y = rect.top; y < rect.bottom; y++) {
@@ -308,11 +308,13 @@ public:
                     writeGraphicBufferToPng(outPath, mOutBuffer);
 
                     ASSERT_TRUE(pixelMatches)
-                            << String8::format("pixel @ (%3d, %3d): "
+                            << String8::format("Inside rect (%d, %d, %d, %d), " //
+                                               "pixel @ (%3d, %3d): "           //
                                                "expected [%3d, %3d, %3d, %3d], got [%3d, %3d, %3d, "
-                                               "%3d], "
+                                               "%3d], " //
                                                "wrote screenshot to '%s'",
-                                               x, y, imagePixel[0], imagePixel[1], imagePixel[2],
+                                               rect.left, rect.top, rect.right, rect.bottom, x, y,
+                                               imagePixel[0], imagePixel[1], imagePixel[2],
                                                imagePixel[3], bufferPixel[0], bufferPixel[1],
                                                bufferPixel[2], bufferPixel[3], outPath.c_str())
                                        .c_str();
diff --git a/services/surfaceflinger/tests/utils/WindowInfosListenerUtils.h b/services/surfaceflinger/tests/utils/WindowInfosListenerUtils.h
index 11723c7509..6f0246ca22 100644
--- a/services/surfaceflinger/tests/utils/WindowInfosListenerUtils.h
+++ b/services/surfaceflinger/tests/utils/WindowInfosListenerUtils.h
@@ -14,6 +14,7 @@
  * limitations under the License.
  */
 
+#include <android-base/logging.h>
 #include <android-base/properties.h>
 #include <gtest/gtest.h>
 #include <gui/SurfaceComposerClient.h>
@@ -36,7 +37,10 @@ public:
     bool waitForWindowInfosPredicate(const WindowInfosPredicate& predicate) {
         std::promise<void> promise;
         auto listener = sp<WindowInfosListener>::make(std::move(predicate), promise);
-        mClient->addWindowInfosListener(listener);
+        android::base::Result<gui::WindowInfosUpdate> result =
+                mClient->addWindowInfosListener(listener);
+        LOG_IF(FATAL, !result.ok()) << "can't register listener";
+        listener->onWindowInfosChanged(*result);
         auto future = promise.get_future();
         bool satisfied = future.wait_for(std::chrono::seconds{5 * HwTimeoutMultiplier()}) ==
                 std::future_status::ready;
diff --git a/services/vibratorservice/include/vibratorservice/VibratorCallbackScheduler.h b/services/vibratorservice/include/vibratorservice/VibratorCallbackScheduler.h
index c8ec15d414..64acb7f52f 100644
--- a/services/vibratorservice/include/vibratorservice/VibratorCallbackScheduler.h
+++ b/services/vibratorservice/include/vibratorservice/VibratorCallbackScheduler.h
@@ -20,6 +20,7 @@
 #include <android-base/thread_annotations.h>
 #include <chrono>
 #include <condition_variable>
+#include <functional>
 #include <queue>
 #include <thread>
 
diff --git a/vulkan/libvulkan/debug_report.cpp b/vulkan/libvulkan/debug_report.cpp
index 40ba1e5bc5..9e10d6c32c 100644
--- a/vulkan/libvulkan/debug_report.cpp
+++ b/vulkan/libvulkan/debug_report.cpp
@@ -16,6 +16,8 @@
 
 #include "driver.h"
 
+#include <mutex>
+
 namespace vulkan {
 namespace driver {
 
diff --git a/vulkan/nulldrv/null_driver.cpp b/vulkan/nulldrv/null_driver.cpp
index 48de3d6d33..cac36b147e 100644
--- a/vulkan/nulldrv/null_driver.cpp
+++ b/vulkan/nulldrv/null_driver.cpp
@@ -14,6 +14,11 @@
  * limitations under the License.
  */
 
+// (b/291762537): This code uses malloc_usable_size(), and thus can't be
+// built with _FORTIFY_SOURCE=3.
+#undef _FORTIFY_SOURCE
+#define _FORTIFY_SOURCE 2
+
 #include <android/hardware_buffer.h>
 #include <hardware/hwvulkan.h>
 
diff --git a/vulkan/scripts/Android.bp b/vulkan/scripts/Android.bp
new file mode 100644
index 0000000000..5a2b1a340c
--- /dev/null
+++ b/vulkan/scripts/Android.bp
@@ -0,0 +1,23 @@
+// Copyright (C) 2025 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package {
+    default_team: "trendy_team_android_gpu",
+    default_applicable_licenses: ["frameworks_native_license"],
+}
+
+python_library_host {
+    name: "native_vulkan_scripts_lib",
+    srcs: ["*.py"],
+}
diff --git a/vulkan/scripts/code_generator.py b/vulkan/scripts/code_generator.py
index 051816de87..d3913f72ca 100755
--- a/vulkan/scripts/code_generator.py
+++ b/vulkan/scripts/code_generator.py
@@ -22,6 +22,7 @@ import driver_generator
 import generator_common
 import null_generator
 import vkjson_generator
+import vk_parser
 
 if __name__ == '__main__':
   generator_common.parse_vulkan_registry()
@@ -31,6 +32,8 @@ if __name__ == '__main__':
   driver_generator.gen_cpp()
   null_generator.gen_h()
   null_generator.gen_cpp()
+  vk_parser.gen_vk()
+  vkjson_generator.re_import_vk()
   vkjson_generator.gen_h()
   vkjson_generator.gen_cc()
-  vkjson_generator.gen_instance_cc()
+  vkjson_generator.gen_instance_cc()
\ No newline at end of file
diff --git a/vulkan/scripts/test/Android.bp b/vulkan/scripts/test/Android.bp
new file mode 100644
index 0000000000..36f60e6025
--- /dev/null
+++ b/vulkan/scripts/test/Android.bp
@@ -0,0 +1,28 @@
+// Copyright (C) 2025 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package {
+    default_team: "trendy_team_android_gpu",
+    default_applicable_licenses: ["frameworks_native_license"],
+}
+
+python_test_host {
+    name: "native_vulkan_scripts_test",
+    main: "test_main.py",
+    srcs: ["*.py"],
+    libs: ["native_vulkan_scripts_lib"],
+    test_options: {
+        unit_test: true,
+    },
+}
diff --git a/vulkan/scripts/test/base_test_helper.py b/vulkan/scripts/test/base_test_helper.py
new file mode 100644
index 0000000000..408e5fe53d
--- /dev/null
+++ b/vulkan/scripts/test/base_test_helper.py
@@ -0,0 +1,82 @@
+#!/usr/bin/env python3
+#
+# Copyright 2025 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import difflib
+import re
+import unittest
+from unittest.mock import Mock
+
+
+class BaseCodeAssertTest(unittest.TestCase):
+
+    @staticmethod
+    def normalise_for_code_compare(code: str):
+        return re.sub(r'\s+', '', code)
+
+    @staticmethod
+    def normalise_for_diff_compare(code: str):
+        return [
+            line.strip()
+            for line in code.splitlines()
+        ]
+
+    def assertCodeEqual(self, expected_code_str: str, actual_code_str: str):
+        """
+        This code comparator lacks semantic awareness and performs a naive normalization by
+        stripping all whitespace characters, without distinguishing between executable code,
+        string literals, or comments.
+
+        Eg: It would treat "Hello world" and "Helloworld" as identical.
+        """
+
+        expected_normalised = self.normalise_for_code_compare(expected_code_str)
+        actual_normalised = self.normalise_for_code_compare(actual_code_str)
+
+        if expected_normalised == actual_normalised:
+            pass
+        else:
+            expected_for_diff = self.normalise_for_diff_compare(expected_code_str)
+            actual_for_diff = self.normalise_for_diff_compare(actual_code_str)
+
+            diff_generator = difflib.unified_diff(
+                expected_for_diff,
+                actual_for_diff,
+                fromfile="Expected Code",
+                tofile="Actual Code",
+                lineterm="",
+                n=1
+            )
+
+            diff_output = "\n".join(diff_generator)
+            standard_message = (
+                f"Test failed: Non-whitespace code differences detected."
+                f"---------------------------------------------------\n"
+                f"{diff_output}\n"
+                f"---------------------------------------------------"
+            )
+
+            failure_message = self._formatMessage(None, standard_message)
+            self.fail(failure_message)
+
+
+class BaseMockCodeFileTest(BaseCodeAssertTest):
+
+    def setUp(self):
+        self.mock_file = Mock()
+
+    def assertCodeFileWrite(self, expected_code_str: str):
+        actual_code_str = "".join([c.args[0] for c in self.mock_file.write.call_args_list])
+        self.assertCodeEqual(expected_code_str, actual_code_str)
diff --git a/vulkan/scripts/test/test_main.py b/vulkan/scripts/test/test_main.py
new file mode 100644
index 0000000000..25611b7b9a
--- /dev/null
+++ b/vulkan/scripts/test/test_main.py
@@ -0,0 +1,29 @@
+#!/usr/bin/env python3
+#
+# Copyright 2025 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import unittest
+import test_vkjson_gen_util
+import test_vkjson_generator
+
+if __name__ == "__main__":
+    loader = unittest.TestLoader()
+    testsuite = unittest.suite.TestSuite()
+    testsuite.addTest(loader.loadTestsFromModule(test_vkjson_gen_util))
+    testsuite.addTest(loader.loadTestsFromModule(test_vkjson_generator))
+    assert testsuite.countTestCases()
+
+    # To avoid python logs parser failing due to high verbosity
+    unittest.TextTestRunner(verbosity=2).run(testsuite)
diff --git a/vulkan/scripts/test/test_vkjson_gen_util.py b/vulkan/scripts/test/test_vkjson_gen_util.py
new file mode 100644
index 0000000000..0914550a82
--- /dev/null
+++ b/vulkan/scripts/test/test_vkjson_gen_util.py
@@ -0,0 +1,1218 @@
+#!/usr/bin/env python3
+#
+# Copyright 2025 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+"""
+This file contains unit tests for vkjson_gen_util.py
+Each test class focuses on one specific util function.
+"""
+import ctypes
+import unittest
+
+from dataclasses import dataclass
+from enum import Enum
+from typing import List
+from unittest.mock import patch
+
+import base_test_helper as helper
+import vkjson_gen_util as src
+
+
+class TestGetCopyrightWarnings(unittest.TestCase):
+
+    def test_checks_for_c_comment_format(self):
+        stripped_block = src.get_copyright_warnings().strip()
+        is_block_comment = stripped_block.startswith("/*") and stripped_block.endswith("*/")
+
+        is_line_comment = all(
+            not line.strip() or line.strip().startswith("//")
+            for line in stripped_block.splitlines()
+        )
+
+        self.assertTrue(is_block_comment or is_line_comment)
+
+    def test_checks_for_essential_components(self):
+        result = src.get_copyright_warnings()
+
+        self.assertTrue("Copyright (c) 2015-2016 The Khronos Group Inc." in result)
+        self.assertTrue("Copyright (c) 2015-2016 Valve Corporation" in result)
+        self.assertTrue("Copyright (c) 2015-2016 LunarG, Inc." in result)
+        self.assertTrue("Copyright (c) 2015-2016 Google, Inc." in result)
+        self.assertTrue("Licensed under the Apache License, Version 2.0" in result)
+        self.assertTrue("http://www.apache.org/licenses/LICENSE-2.0" in result)
+        self.assertTrue("WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND" in result)
+
+
+class TestGetVkjsonStructName(unittest.TestCase):
+
+    def test_KHR_extension(self):
+        self.assertEqual(
+            "VkJsonKHRShaderFloat16Int8",
+            src.get_vkjson_struct_name("VK_KHR_shader_float16_int8")
+        )
+
+    def test_EXT_extension(self):
+        self.assertEqual(
+            "VkJsonExtTransformFeedback",
+            src.get_vkjson_struct_name("VK_EXT_transform_feedback"),
+        )
+
+    def test_IMG_extension(self):
+        self.assertEqual(
+            "VkJsonIMGRelaxedLineRasterization",
+            src.get_vkjson_struct_name("VK_IMG_relaxed_line_rasterization")
+        )
+
+    def test_extension_with_unknown_prefix(self):
+        self.assertEqual(
+            "VkJsonExtVKFUCHSIAExternalSemaphore",
+            src.get_vkjson_struct_name("VK_FUCHSIA_external_semaphore")
+        )
+
+    def test_extension_with_numeric_suffixes(self):
+        self.assertEqual(
+            "VkJsonExtImage2dViewOf3d",
+            src.get_vkjson_struct_name("VK_EXT_image_2d_view_of_3d")
+        )
+
+
+class TestGetVkjsonStructVariableName(unittest.TestCase):
+
+    def test_KHR_extension(self):
+        self.assertEqual(
+            "khr_shader_float16_int8",
+            src.get_vkjson_struct_variable_name("VK_KHR_shader_float16_int8"),
+        )
+
+    def test_EXT_extension(self):
+        self.assertEqual(
+            "ext_transform_feedback",
+            src.get_vkjson_struct_variable_name("VK_EXT_transform_feedback"),
+        )
+
+    def test_IMG_extension(self):
+        self.assertEqual(
+            "img_relaxed_line_rasterization",
+            src.get_vkjson_struct_variable_name("VK_IMG_relaxed_line_rasterization")
+        )
+
+    def test_extension_with_unknown_prefix(self):
+        self.assertEqual(
+            "vk_fuchsia_external_semaphore",
+            src.get_vkjson_struct_variable_name("VK_FUCHSIA_external_semaphore")
+        )
+
+    def test_extension_with_numeric_prefixes(self):
+        self.assertEqual(
+            "ext_image_2d_view_of_3d",
+            src.get_vkjson_struct_variable_name("VK_EXT_image_2d_view_of_3d"),
+        )
+
+
+class TestGetStructName(unittest.TestCase):
+
+    def test_single_word_suffix(self):
+        self.assertEqual(
+            "properties",
+            src.get_struct_name("VkPhysicalDeviceProperties"),
+        )
+
+    def test_multi_word_suffix(self):
+        self.assertEqual(
+            "sampler_ycbcr_conversion_features",
+            src.get_struct_name("VkPhysicalDeviceSamplerYcbcrConversionFeatures"),
+        )
+
+    def test_KHR_suffix(self):
+        self.assertEqual(
+            "float_controls_properties_khr",
+            src.get_struct_name("VkPhysicalDeviceFloatControlsPropertiesKHR"),
+        )
+
+    def test_EXT_suffix(self):
+        self.assertEqual(
+            "line_rasterization_features_ext",
+            src.get_struct_name("VkPhysicalDeviceLineRasterizationFeaturesEXT")
+        )
+
+    def test_IMG_suffix(self):
+        self.assertEqual(
+            "relaxed_line_rasterization_features_img",
+            src.get_struct_name("VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG")
+        )
+
+    def test_suffix_starting_with_ID(self):
+        self.assertEqual(
+            "id_properties",
+            src.get_struct_name("VkPhysicalDeviceIDProperties")
+        )
+        # TODO (b/401184058)- Fix source code
+        # self.assertEqual(
+        #     "id_features",
+        #     src.get_struct_name("VkPhysicalDeviceIDFeatures")
+        # )
+
+    def test_suffix_containing_number(self):
+        self.assertEqual(
+            "vulkan11_properties",
+            src.get_struct_name("VkPhysicalDeviceVulkan11Properties"),
+        )
+
+    def test_suffix_starting_with_2d(self):
+        self.assertEqual(
+            "_2d_view_features_ext",
+            src.get_struct_name("VkPhysicalDevice2DViewFeaturesEXT"),
+        )
+
+    def test_suffix_starting_with_3d(self):
+        self.assertEqual(
+            "_3d_features_ext",
+            src.get_struct_name("VkPhysicalDevice3DFeaturesEXT"),
+        )
+
+    def test_suffix_containing_2d_3d(self):
+        self.assertEqual(
+            "image_2d_view_of_3d_features_ext",
+            src.get_struct_name("VkPhysicalDeviceImage2DViewOf3DFeaturesEXT")
+        )
+
+    def test_suffix_starting_with_8bit_16bit(self):
+        self.assertEqual(
+            "bit8_storage_features_khr",
+            src.get_struct_name("VkPhysicalDevice8BitStorageFeaturesKHR"),
+        )
+        # TODO (b/401184058)- Fix source code
+        # self.assertEqual(
+        #     "bit16_storage_properties",
+        #     src.get_struct_name("VkPhysicalDevice16BitStorageProperties")
+        # )
+
+    def test_special_case_of_memory_properties(self):
+        self.assertEqual(
+            "memory",
+            src.get_struct_name("VkPhysicalDeviceMemoryProperties"),
+        )
+
+
+class TestGenerateExtensionStructDefinition(helper.BaseMockCodeFileTest):
+
+    @patch('vkjson_gen_util.VK')
+    def test_extension_with_single_struct(self, mock_vk):
+        mock_vk.VULKAN_EXTENSIONS_AND_STRUCTS_MAPPING = {
+            "extensions": {
+                "VK_KHR_driver_state": [
+                    {"VkPhysicalDeviceDriverPropertiesKHR": "VK_STRUCT_DRIVER"}
+                ]
+            }
+        }
+
+        extension_struct = src.get_vkjson_struct_name("VK_KHR_driver_state")
+        struct_name = src.get_struct_name("VkPhysicalDeviceDriverPropertiesKHR")
+
+        expected_lines = (
+            f"""struct {extension_struct} {{
+              {extension_struct}() {{
+                reported = false;
+                memset(&{struct_name}, 0, sizeof(VkPhysicalDeviceDriverPropertiesKHR));
+              }}
+              bool reported;
+              VkPhysicalDeviceDriverPropertiesKHR {struct_name};
+            }};"""
+        )
+
+        self.assertEqual(
+            [f"{extension_struct} {src.get_vkjson_struct_variable_name("VK_KHR_driver_state")}"],
+            src.generate_extension_struct_definition(self.mock_file)
+        )
+        self.assertCodeFileWrite(expected_lines)
+
+    @patch('vkjson_gen_util.VK')
+    def test_extension_with_multiple_structs(self, mock_vk):
+        mock_vk.VULKAN_EXTENSIONS_AND_STRUCTS_MAPPING = {
+            "extensions": {
+                "VK_KHR_variable_pointers": [
+                    {"VkPhysicalDeviceVariablePointerFeaturesKHR": "VK_STRUCT_VARIABLE",
+                     "VkPhysicalDeviceVariablePointersFeaturesKHR": "VK_STRUCT_VARIABLES"},
+                    {"SomeThingElse": "SOME_OTHER_STRUCT"}
+                ]
+            }
+        }
+
+        extension_struct = src.get_vkjson_struct_name("VK_KHR_variable_pointers")
+        struct_1_name = src.get_struct_name("VkPhysicalDeviceVariablePointerFeaturesKHR")
+        struct_2_name = src.get_struct_name("VkPhysicalDeviceVariablePointersFeaturesKHR")
+        struct_3_name = src.get_struct_name("SomeThingElse")
+
+        expected_lines = (
+            f"""struct {extension_struct} {{
+              {extension_struct}() {{
+                reported = false;
+                memset(&{struct_1_name}, 0, sizeof(VkPhysicalDeviceVariablePointerFeaturesKHR));
+                memset(&{struct_2_name}, 0, sizeof(VkPhysicalDeviceVariablePointersFeaturesKHR));
+                memset(&{struct_3_name}, 0, sizeof(SomeThingElse));
+              }}
+              bool reported;
+              VkPhysicalDeviceVariablePointerFeaturesKHR {struct_1_name};
+              VkPhysicalDeviceVariablePointersFeaturesKHR {struct_2_name};
+              SomeThingElse {struct_3_name};
+            }};"""
+        )
+
+        self.assertEqual(
+            [
+                f"{extension_struct} {src.get_vkjson_struct_variable_name("VK_KHR_variable_pointers")}"],
+            src.generate_extension_struct_definition(self.mock_file)
+        )
+        self.assertCodeFileWrite(expected_lines)
+
+    @patch('vkjson_gen_util.VK')
+    def test_extension_without_structs(self, mock_vk):
+        mock_vk.VULKAN_EXTENSIONS_AND_STRUCTS_MAPPING = {
+            "extensions": {
+                "VK_EXT_image_2d_view_of_3d": []
+            }
+        }
+
+        extension_struct = src.get_vkjson_struct_name("VK_EXT_image_2d_view_of_3d")
+
+        expected_lines = (
+            f"""struct {extension_struct} {{
+              {extension_struct}() {{
+                reported = false;
+              }}
+              bool reported;
+            }};"""
+        )
+
+        self.assertEqual(
+            [
+                f"{extension_struct} {src.get_vkjson_struct_variable_name("VK_EXT_image_2d_view_of_3d")}"],
+            src.generate_extension_struct_definition(self.mock_file)
+        )
+        self.assertCodeFileWrite(expected_lines)
+
+    @patch('vkjson_gen_util.VK')
+    def test_multiple_extensions(self, mock_vk):
+        mock_vk.VULKAN_EXTENSIONS_AND_STRUCTS_MAPPING = {
+            "extensions": {
+                "VK_EXT_custom_border_color": [
+                    {"VkPhysicalDeviceCustomBorderColorFeatsEXT": "VK_STRUCT_COLOR"}
+                ],
+                "VK_KHR_shader_float_controls": [
+                    {"VkPhysicalDeviceFloatControlsFeatsKHR": "VK_STRUCT_FLOAT"}
+                ]
+            }
+        }
+
+        extension_1_struct = src.get_vkjson_struct_name("VK_EXT_custom_border_color")
+        struct_1_name = src.get_struct_name("VkPhysicalDeviceCustomBorderColorFeatsEXT")
+        extension_2_struct = src.get_vkjson_struct_name("VK_KHR_shader_float_controls")
+        struct_2_name = src.get_struct_name("VkPhysicalDeviceFloatControlsFeatsKHR")
+
+        expected_lines = (
+            f"""struct {extension_1_struct} {{
+              {extension_1_struct}() {{
+                reported = false;
+                memset(&{struct_1_name}, 0, sizeof(VkPhysicalDeviceCustomBorderColorFeatsEXT));
+              }}
+              bool reported;
+              VkPhysicalDeviceCustomBorderColorFeatsEXT {struct_1_name};
+            }};
+
+            struct {extension_2_struct} {{
+              {extension_2_struct}() {{
+                reported = false;
+                memset(&{struct_2_name}, 0, sizeof(VkPhysicalDeviceFloatControlsFeatsKHR));
+              }}
+              bool reported;
+              VkPhysicalDeviceFloatControlsFeatsKHR {struct_2_name};
+            }};"""
+        )
+
+        self.assertEqual(
+            [
+                f"{extension_1_struct} {src.get_vkjson_struct_variable_name("VK_EXT_custom_border_color")}",
+                f"{extension_2_struct} {src.get_vkjson_struct_variable_name("VK_KHR_shader_float_controls")}",
+            ],
+            src.generate_extension_struct_definition(self.mock_file)
+        )
+        self.assertCodeFileWrite(expected_lines)
+
+    @patch('vkjson_gen_util.VK')
+    def test_empty_extensions(self, mock_vk):
+        mock_vk.VULKAN_EXTENSIONS_AND_STRUCTS_MAPPING = {
+            "extensions": {}
+        }
+
+        self.assertEqual([], src.generate_extension_struct_definition(self.mock_file))
+        self.assertCodeFileWrite("")
+
+
+class TestGenerateVkCoreStructDefinition(helper.BaseMockCodeFileTest):
+
+    @patch('vkjson_gen_util.VK')
+    def test_core_with_single_struct(self, mock_vk):
+        mock_vk.VULKAN_CORES_AND_STRUCTS_MAPPING = {
+            "versions": {
+                "Core11": [
+                    {"VkVulkan11Properties": "VK_STRUCT_TYPE_VULKAN_1_1_PROPERTIES"}
+                ]
+            }
+        }
+
+        expected_lines = (
+            """struct VkJsonCore11 {
+              VkJsonCore11() {
+                memset(&properties, 0, sizeof(VkVulkan11Properties));
+              }
+              VkVulkan11Properties properties;
+            };"""
+        )
+
+        self.assertEqual(
+            ["VkJsonCore11 core11"],
+            src.generate_vk_core_struct_definition(self.mock_file)
+        )
+        self.assertCodeFileWrite(expected_lines)
+
+    @patch('vkjson_gen_util.VK')
+    def test_core_with_multiple_structs(self, mock_vk):
+        mock_vk.VULKAN_CORES_AND_STRUCTS_MAPPING = {
+            "versions": {
+                "Core13": [
+                    {"VkVulkan13Features": "VK_STRUCT_TYPE_VULKAN_1_3_FEATURES",
+                     "VkVulkan13Properties": "VK_STRUCT_TYPE_VULKAN_1_3_PROPERTIES"}
+                ]
+            }
+        }
+
+        expected_lines = (
+            """struct VkJsonCore13 {
+              VkJsonCore13() {
+                memset(&features, 0, sizeof(VkVulkan13Features));
+                memset(&properties, 0, sizeof(VkVulkan13Properties));
+              }
+              VkVulkan13Features features;
+              VkVulkan13Properties properties;
+            };"""
+        )
+
+        self.assertEqual(
+            ["VkJsonCore13 core13"],
+            src.generate_vk_core_struct_definition(self.mock_file)
+        )
+        self.assertCodeFileWrite(expected_lines)
+
+    @patch('vkjson_gen_util.VK')
+    def test_core14(self, mock_vk):
+        mock_vk.VULKAN_CORES_AND_STRUCTS_MAPPING = {
+            "versions": {
+                "Core14": [
+                    {"VkVulkan14Properties": "VK_STRUCT_TYPE_VULKAN_1_4_PROPERTIES"},
+                    {"VkVulkan14Features": "VK_STRUCT_TYPE_VULKAN_1_4_FEATURES"}
+                ]
+            }
+        }
+
+        expected_lines = (
+            """struct VkJsonCore14 {
+              VkJsonCore14() {
+                memset(&properties, 0, sizeof(VkVulkan14Properties));
+                memset(&features, 0, sizeof(VkVulkan14Features));
+              }
+              VkVulkan14Properties properties;
+              VkVulkan14Features features;
+              std::vector<VkImageLayout> copy_src_layouts;
+              std::vector<VkImageLayout> copy_dst_layouts;
+            };"""
+        )
+
+        self.assertEqual(
+            ["VkJsonCore14 core14"],
+            src.generate_vk_core_struct_definition(self.mock_file)
+        )
+        self.assertCodeFileWrite(expected_lines)
+
+    @patch('vkjson_gen_util.VK')
+    def test_core_without_structs(self, mock_vk):
+        mock_vk.VULKAN_CORES_AND_STRUCTS_MAPPING = {
+            "versions": {
+                "Core10": []
+            }
+        }
+
+        expected_lines = (
+            """struct VkJsonCore10 {
+              VkJsonCore10() { }
+            };"""
+        )
+
+        self.assertEqual(
+            ["VkJsonCore10 core10"],
+            src.generate_vk_core_struct_definition(self.mock_file)
+        )
+        self.assertCodeFileWrite(expected_lines)
+
+    @patch('vkjson_gen_util.VK')
+    def test_multiple_cores(self, mock_vk):
+        mock_vk.VULKAN_CORES_AND_STRUCTS_MAPPING = {
+            "versions": {
+                "Core11": [
+                    {"VkVulkan11Properties": "VK_STRUCT_TYPE_VULKAN_1_1_PROPERTIES"}
+                ],
+                "Core12": [
+                    {"VkVulkan12Features": "VK_STRUCT_TYPE_VULKAN_1_2_FEATURES"}
+                ]
+            }
+        }
+
+        expected_lines = (
+            """struct VkJsonCore11 {
+              VkJsonCore11() {
+                memset(&properties, 0, sizeof(VkVulkan11Properties));
+              }
+              VkVulkan11Properties properties;
+            };
+
+            struct VkJsonCore12 {
+              VkJsonCore12() {
+                memset(&features, 0, sizeof(VkVulkan12Features));
+              }
+              VkVulkan12Features features;
+            };"""
+        )
+
+        self.assertEqual(
+            [
+                "VkJsonCore11 core11",
+                "VkJsonCore12 core12"
+            ],
+            src.generate_vk_core_struct_definition(self.mock_file)
+        )
+        self.assertCodeFileWrite(expected_lines)
+
+    @patch('vkjson_gen_util.VK')
+    def test_no_cores(self, mock_vk):
+        mock_vk.VULKAN_CORES_AND_STRUCTS_MAPPING = {
+            "versions": {}
+        }
+
+        self.assertEqual([], src.generate_vk_core_struct_definition(self.mock_file))
+        self.assertCodeFileWrite("")
+
+
+class TestGenerateMemsetStatements(helper.BaseMockCodeFileTest):
+
+    @patch('vkjson_gen_util.VK')
+    def test_multiple_structs(self, mock_vk):
+        mock_vk.EXTENSION_INDEPENDENT_STRUCTS = [
+            'VkCustomExtension1',
+            'VkCustomExtension2',
+            'VkCustomExtension3'
+        ]
+        mock_vk.ADDITIONAL_EXTENSION_INDEPENDENT_STRUCTS = []
+
+        struct_1_name = src.get_struct_name("VkCustomExtension1")
+        struct_2_name = src.get_struct_name("VkCustomExtension2")
+        struct_3_name = src.get_struct_name("VkCustomExtension3")
+
+        expected_lines = (
+            f"""memset(&{struct_1_name}, 0, sizeof(VkCustomExtension1));
+            memset(&{struct_2_name}, 0, sizeof(VkCustomExtension2));
+            memset(&{struct_3_name}, 0, sizeof(VkCustomExtension3));
+            """
+        )
+
+        self.assertEqual(
+            [
+                f"VkCustomExtension1 {struct_1_name}",
+                f"VkCustomExtension2 {struct_2_name}",
+                f"VkCustomExtension3 {struct_3_name}",
+            ],
+            src.generate_memset_statements(self.mock_file)
+        )
+
+        self.assertCodeFileWrite(expected_lines)
+
+    @patch('vkjson_gen_util.VK')
+    def test_no_structs(self, mock_vk):
+        mock_vk.EXTENSION_INDEPENDENT_STRUCTS = []
+
+        self.assertEqual([], src.generate_memset_statements(self.mock_file))
+        self.assertCodeFileWrite("")
+
+
+class TestGenerateExtensionStructTemplate(helper.BaseCodeAssertTest):
+
+    @patch('vkjson_gen_util.VK')
+    def test_extension_with_single_struct(self, mock_vk):
+        mock_vk.VULKAN_EXTENSIONS_AND_STRUCTS_MAPPING = {
+            "extensions": {
+                "VK_KHR_driver_state": [
+                    {"VkPhysicalDeviceDriverPropertiesKHR": "VK_STRUCT_DRIVER"}
+                ]
+            }
+        }
+
+        self.assertCodeEqual(
+            f"""template <typename Visitor>
+            inline bool Iterate(Visitor* visitor, {src.get_vkjson_struct_name("VK_KHR_driver_state")}* structs) {{
+              return visitor->Visit("driverPropertiesKHR", &structs->{src.get_struct_name("VkPhysicalDeviceDriverPropertiesKHR")});
+            }}""",
+            src.generate_extension_struct_template()
+        )
+
+    # TODO (b/401184058)- Fix source code
+    @patch('vkjson_gen_util.VK')
+    def extension_with_multiple_structs(self, mock_vk):
+        mock_vk.VULKAN_EXTENSIONS_AND_STRUCTS_MAPPING = {
+            "extensions": {
+                "VK_KHR_variable_pointers": [
+                    {"VkPhysicalDeviceShader": "VK_STRUCT_SHADER",
+                     "SomeThingElse": "SOME_OTHER_STRUCT"},
+                    {"VkPhysicalDeviceVulkan11Properties": "VK_STRUCT_VULKAN"},
+                    {"VkPhysicalDevice16BitStorageFeaturesKHR": "VK_STRUCT_STORAGE"}
+                ]
+            }
+        }
+
+        self.assertCodeEqual(
+            f"""template <typename Visitor>
+            inline bool Iterate(Visitor* visitor, {src.get_vkjson_struct_name("VK_KHR_variable_pointers")}* structs) {{
+              return visitor->Visit("shader", &structs->{src.get_struct_name("VkPhysicalDeviceShader")})&&
+                    visitor->Visit("someThingElse", &structs->{src.get_struct_name("SomeThingElse")})&&
+                    visitor->Visit("vulkan11Properties", &structs->{src.get_struct_name("VkPhysicalDeviceVulkan11Properties")})&&
+                    visitor->Visit("bit16StorageFeaturesKHR", &structs->{src.get_struct_name("VkPhysicalDevice16BitStorageFeaturesKHR")});
+            }}""",
+            src.generate_extension_struct_template()
+        )
+
+    @patch('vkjson_gen_util.VK')
+    def test_extension_without_structs(self, mock_vk):
+        mock_vk.VULKAN_EXTENSIONS_AND_STRUCTS_MAPPING = {
+            "extensions": {
+                "VK_EXT_image_2d_view_of_3d": []
+            }
+        }
+
+        self.assertCodeEqual(
+            f"""template <typename Visitor>
+            inline bool Iterate(Visitor* visitor, {src.get_vkjson_struct_name("VK_EXT_image_2d_view_of_3d")}* structs) {{
+              return;
+            }}""",
+            src.generate_extension_struct_template()
+        )
+
+    @patch('vkjson_gen_util.VK')
+    def test_multiple_extensions(self, mock_vk):
+        mock_vk.VULKAN_EXTENSIONS_AND_STRUCTS_MAPPING = {
+            "extensions": {
+                "VK_EXT_custom_border_color": [
+                    {"VkPhysicalDeviceCustomBorderColorFeatsEXT": "VK_STRUCT_COLOR"}
+                ],
+                "VK_KHR_shader_float_controls": [
+                    {"VkPhysicalDeviceFloatControlsFeatsKHR": "VK_STRUCT_FLOAT"}
+                ]
+            }
+        }
+
+        self.assertCodeEqual(
+            f"""template <typename Visitor>
+            inline bool Iterate(Visitor* visitor, {src.get_vkjson_struct_name("VK_EXT_custom_border_color")}* structs) {{
+              return visitor->Visit("customBorderColorFeatsEXT", &structs->{src.get_struct_name("VkPhysicalDeviceCustomBorderColorFeatsEXT")});
+            }}
+
+            template <typename Visitor>
+            inline bool Iterate(Visitor* visitor, {src.get_vkjson_struct_name("VK_KHR_shader_float_controls")}* structs) {{
+              return visitor->Visit("floatControlsFeatsKHR", &structs->{src.get_struct_name("VkPhysicalDeviceFloatControlsFeatsKHR")});
+            }}""",
+            src.generate_extension_struct_template()
+        )
+
+    @patch('vkjson_gen_util.VK')
+    def test_empty_extensions(self, mock_vk):
+        mock_vk.VULKAN_EXTENSIONS_AND_STRUCTS_MAPPING = {
+            "extensions": {}
+        }
+
+        self.assertEqual("", src.generate_extension_struct_template())
+
+
+class TestGenerateCoreTemplate(helper.BaseCodeAssertTest):
+
+    @patch('vkjson_gen_util.VK')
+    def test_core_with_single_struct(self, mock_vk):
+        mock_vk.VULKAN_CORES_AND_STRUCTS_MAPPING = {
+            "versions": {
+                "Core11": [
+                    {"VkVulkan11Properties": "VK_STRUCT_TYPE_VULKAN_1_1_PROPERTIES"}
+                ]
+            }
+        }
+
+        self.assertCodeEqual(
+            f"""template <typename Visitor>
+            inline bool Iterate(Visitor* visitor, VkJsonCore11* core) {{
+              return visitor->Visit("properties", &core->properties);
+            }}""",
+            src.generate_core_template()
+        )
+
+    @patch('vkjson_gen_util.VK')
+    def test_core_with_multiple_structs(self, mock_vk):
+        mock_vk.VULKAN_CORES_AND_STRUCTS_MAPPING = {
+            "versions": {
+                "Core13": [
+                    {"VkVulkan13Features": "VK_STRUCT_TYPE_VULKAN_1_3_FEATURES",
+                     "VkVulkan13Properties": "VK_STRUCT_TYPE_VULKAN_1_3_PROPERTIES"}
+                ]
+            }
+        }
+
+        self.assertCodeEqual(
+            f"""template <typename Visitor>
+            inline bool Iterate(Visitor* visitor, VkJsonCore13* core) {{
+              return visitor->Visit("features", &core->features) &&
+                    visitor->Visit("properties", &core->properties);
+            }}""",
+            src.generate_core_template()
+        )
+
+    @patch('vkjson_gen_util.VK')
+    def test_multiple_cores(self, mock_vk):
+        mock_vk.VULKAN_CORES_AND_STRUCTS_MAPPING = {
+            "versions": {
+                "Core11": [
+                    {"VkVulkan11Properties": "VK_STRUCT_TYPE_VULKAN_1_1_PROPERTIES"}
+                ],
+                "Core12": [
+                    {"VkVulkan12Features": "VK_STRUCT_TYPE_VULKAN_1_2_FEATURES"}
+                ]
+            }
+        }
+
+        self.assertCodeEqual(
+            f"""template <typename Visitor>
+            inline bool Iterate(Visitor* visitor, VkJsonCore11* core) {{
+              return visitor->Visit("properties", &core->properties);
+            }}
+
+            template <typename Visitor>
+            inline bool Iterate(Visitor* visitor, VkJsonCore12* core) {{
+              return visitor->Visit("features", &core->features);
+            }}""",
+            src.generate_core_template()
+        )
+
+    @patch('vkjson_gen_util.VK')
+    def test_core_without_structs(self, mock_vk):
+        mock_vk.VULKAN_CORES_AND_STRUCTS_MAPPING = {
+            "versions": {
+                "Core10": []
+            }
+        }
+
+        self.assertCodeEqual(
+            f"""template <typename Visitor>
+            inline bool Iterate(Visitor* visitor, VkJsonCore10* core) {{
+              return;
+            }}""",
+            src.generate_core_template()
+        )
+
+
+# Testing custom field types
+test_uint8 = ctypes.c_uint8
+test_uint32 = ctypes.c_uint32
+VkTestBool = bool
+VkTestFlag = VkTestBool
+
+
+class VkTestEnum(Enum):
+    VK_TEST_TYPE_1D = 0
+    VK_TEST_TYPE_2D = 1
+    VK_IMAGE_TYPE_3D = 2
+
+
+class VkTestField:
+    pass
+
+
+class TestGenerateStructTemplate(helper.BaseCodeAssertTest):
+    @dataclass
+    class SimpleProperties:
+        intField: int
+
+    @dataclass
+    class SimpleLimits:
+        strField: str
+
+    @dataclass
+    class TwoFieldFeatures:
+        boolField: bool
+        floatField: float
+
+    @dataclass
+    class MultiFieldProperties:
+        field1: test_uint32 * 2
+        field2: test_uint8
+        field3: VkTestBool
+        field4: VkTestFlag
+        field5: VkTestEnum
+        field6: VkTestField
+
+    @dataclass
+    class TestSomethingElse:
+        anyField: VkTestBool
+
+    @dataclass
+    class NoFieldLimits:
+        pass
+
+    @dataclass
+    class ListFieldFeatures:
+        listField: List[VkTestFlag]
+        anyField: VkTestFlag
+
+    # Testing struct aliases
+    SimplePropertiesAlias1 = SimpleProperties
+    SimplePropertiesAlias2 = SimplePropertiesAlias1
+
+    def test_struct_with_single_field(self):
+        mock_input = [self.SimpleProperties]
+
+        self.assertCodeEqual(
+            f"""template <typename Visitor>
+            inline bool Iterate(Visitor* visitor, SimpleProperties* properties) {{
+              return visitor->Visit("intField", &properties->intField);
+            }}""",
+            src.generate_struct_template(mock_input)
+        )
+
+    def test_struct_with_multiple_fields(self):
+        mock_input = [self.MultiFieldProperties]
+
+        self.assertCodeEqual(
+            f"""template <typename Visitor>
+            inline bool Iterate(Visitor* visitor, MultiFieldProperties* properties) {{
+              return visitor->Visit("field1", &properties->field1) &&
+                  visitor->Visit("field2", &properties->field2) &&
+                  visitor->Visit("field3", &properties->field3) &&
+                  visitor->Visit("field4", &properties->field4) &&
+                  visitor->Visit("field5", &properties->field5) &&
+                  visitor->Visit("field6", &properties->field6);
+            }}""",
+            src.generate_struct_template(mock_input)
+        )
+
+    @patch('vkjson_gen_util.VK')
+    def test_struct_with_list_field(self, mock_vk):
+        mock_vk.LIST_TYPE_FIELD_AND_SIZE_MAPPING = {
+            "listField": "copyListField"
+        }
+
+        mock_input = [self.ListFieldFeatures]
+
+        self.assertCodeEqual(
+            f"""template <typename Visitor>
+            inline bool Iterate(Visitor* visitor, ListFieldFeatures* features) {{
+              return visitor->VisitArray("listField", features->copyListField, &features->listField) &&
+                    visitor->Visit("anyField", &features->anyField);
+            }}""",
+            src.generate_struct_template(mock_input)
+        )
+
+    def test_struct_without_fields(self):
+        mock_input = [self.NoFieldLimits]
+
+        self.assertCodeEqual(
+            f"""template <typename Visitor>
+            inline bool Iterate(Visitor* visitor, NoFieldLimits* limits) {{
+              return;
+            }}""",
+            src.generate_struct_template(mock_input)
+        )
+
+    def test_multiple_known_structs(self):
+        mock_input = [
+            self.SimpleLimits,
+            self.TwoFieldFeatures,
+            self.SimpleProperties
+        ]
+
+        self.assertCodeEqual(
+            f"""template <typename Visitor>
+            inline bool Iterate(Visitor* visitor, SimpleLimits* limits) {{
+              return visitor->Visit("strField", &limits->strField);
+            }}
+
+            template <typename Visitor>
+            inline bool Iterate(Visitor* visitor, TwoFieldFeatures* features) {{
+              return visitor->Visit("boolField", &features->boolField) &&
+                    visitor->Visit("floatField", &features->floatField);
+            }}
+
+            template <typename Visitor>
+            inline bool Iterate(Visitor* visitor, SimpleProperties* properties) {{
+              return visitor->Visit("intField", &properties->intField);
+            }}""",
+            src.generate_struct_template(mock_input)
+        )
+
+    # TODO (b/401184058): Fix source code
+    def disabled_test_filters_out_unknown_structs(self):
+        mock_input = [
+            self.TestSomethingElse,
+            self.SimpleLimits
+        ]
+        self.assertCodeEqual(
+            f"""template <typename Visitor>
+            inline bool Iterate(Visitor* visitor, SimpleLimits* limits) {{
+              return visitor->Visit("strField", &limits->strField);
+            }}""",
+            src.generate_struct_template(mock_input)
+        )
+
+    def test_duplicate_structs(self):
+        mock_input = [
+            self.SimplePropertiesAlias1,
+            self.SimplePropertiesAlias2,
+            self.SimpleProperties
+        ]
+
+        self.assertCodeEqual(
+            f"""template <typename Visitor>
+            inline bool Iterate(Visitor* visitor, SimpleProperties* properties) {{
+              return visitor->Visit("intField", &properties->intField);
+            }}""",
+            src.generate_struct_template(mock_input)
+        )
+
+    def test_no_structs(self):
+        mock_input = []
+        self.assertCodeEqual("", src.generate_struct_template(mock_input))
+
+
+class TestEmitStructVisitsByVkVersion(helper.BaseMockCodeFileTest):
+
+    def setUp(self):
+        super().setUp()
+        self.mock_vk_patcher = patch('vkjson_gen_util.VK')
+        self.mock_get_struct_name_patcher = patch('vkjson_gen_util.get_struct_name')
+
+        get_struct_name_return_map = {
+            "VkPhysicalDeviceLineFeatures": "line_features",
+            "VkPhysicalDeviceSubgroupProperties": "subgroup_properties",
+            "VkPhysicalDeviceMultiviewProperties": "multiview_properties",
+            "VkPhysicalDeviceIDProperties": "id_properties",
+            "VkPhysicalDeviceMultiviewFeatures": "multiview_features"
+        }
+        self.mock_get_struct_name = self.mock_get_struct_name_patcher.start()
+        self.mock_get_struct_name.side_effect = lambda struct_name: get_struct_name_return_map[struct_name]
+
+        mock_vk = self.mock_vk_patcher.start()
+        mock_vk.VULKAN_VERSIONS_AND_STRUCTS_MAPPING = {
+            "VK_VERSION_1_0": [
+                {"VkPhysicalDeviceLineFeatures": ""}
+            ],
+            "VK_VERSION_1_1": [
+                {
+                    "VkPhysicalDeviceSubgroupProperties": "VK_STRUCT_SUBGROUP"
+                }
+            ],
+            "VK_VERSION_1_2": [
+                {
+                    "VkPhysicalDeviceMultiviewProperties": "VK_STRUCT_MULTIVIEW",
+                    "VkPhysicalDeviceIDProperties": "VK_STRUCT_DEVICE_ID"
+                },
+                {
+                    "VkPhysicalDeviceMultiviewFeatures": "VK_STRUCT_MULTIVIEW_FEATURES"
+                }
+            ]
+        }
+
+    def tearDown(self):
+        self.mock_vk_patcher.stop()
+        self.mock_get_struct_name_patcher.stop()
+
+    def test_handles_single_matching_struct(self):
+        expected_lines = (
+            'visitor->Visit("subgroupProperties", &device->subgroup_properties) &&'
+        )
+
+        src.emit_struct_visits_by_vk_version(self.mock_file, "VK_VERSION_1_1")
+        self.assertCodeFileWrite(expected_lines)
+
+    def test_handles_multiple_matching_structs(self):
+        expected_lines = (
+            """visitor->Visit("multiviewProperties", &device->multiview_properties) &&
+            visitor->Visit("idProperties", &device->id_properties) &&
+            visitor->Visit("multiviewFeatures", &device->multiview_features) &&
+            """
+        )
+
+        src.emit_struct_visits_by_vk_version(self.mock_file, "VK_VERSION_1_2")
+        self.assertCodeFileWrite(expected_lines)
+
+    def test_handles_empty_struct_type(self):
+        expected_lines = 'visitor->Visit("lineFeatures", &device->line_features) &&'
+
+        src.emit_struct_visits_by_vk_version(self.mock_file, "VK_VERSION_1_0")
+        self.assertCodeFileWrite(expected_lines)
+
+    def test_handles_struct_var_with_single_word(self):
+        self.mock_get_struct_name.side_effect = None
+        self.mock_get_struct_name.return_value = "memory"
+        expected_lines = 'visitor->Visit("memory", &device->memory) &&'
+
+        src.emit_struct_visits_by_vk_version(self.mock_file, "VK_VERSION_1_1")
+        self.assertCodeFileWrite(expected_lines)
+
+    def test_handles_struct_var_contains_number(self):
+        self.mock_get_struct_name.side_effect = None
+        self.mock_get_struct_name.return_value = "image_2d_view_of_3d_features_ext"
+
+        # Considered acceptable
+        expected_lines = 'visitor->Visit("image_2dViewOf_3dFeaturesExt", &device->image_2d_view_of_3d_features_ext) &&'
+
+        src.emit_struct_visits_by_vk_version(self.mock_file, "VK_VERSION_1_1")
+        self.assertCodeFileWrite(expected_lines)
+
+    def test_handles_struct_var_starts_with_underscore(self):
+        self.mock_get_struct_name.side_effect = None
+        self.mock_get_struct_name.return_value = "_3d_features_ext"
+        expected_lines = 'visitor->Visit("_3dFeaturesExt", &device->_3d_features_ext) &&'
+
+        src.emit_struct_visits_by_vk_version(self.mock_file, "VK_VERSION_1_1")
+        self.assertCodeFileWrite(expected_lines)
+
+
+class TestGenerateVkCoreStructsInitCode(unittest.TestCase):
+
+    def setUp(self):
+        self.mock_vk_patcher = patch('vkjson_gen_util.VK')
+        mock_vk = self.mock_vk_patcher.start()
+        mock_vk.STRUCT_EXTENDS_MAPPING = {
+            "VkPhysicalDeviceVulkan11Features": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+            "VkPhysicalDeviceVulkan11Properties": "VkPhysicalDeviceProperties2",
+            "VkPhysicalDeviceVulkan12Features1": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+            "VkPhysicalDeviceVulkan12Properties1": "VkPhysicalDeviceProperties2",
+            "VkPhysicalDeviceVulkan12Features2": "VkPhysicalDeviceFeatures2",
+            "VkPhysicalDeviceVulkan12Properties2":"VkPhysicalDeviceProperties2",
+        }
+        mock_vk.VULKAN_CORES_AND_STRUCTS_MAPPING = {
+            "versions": {
+                "Core11": [
+                    {"VkPhysicalDeviceVulkan11Properties": "VK_TYPE_11_PROPS"},
+                    {"VkPhysicalDeviceVulkan11Features": "VK_TYPE_11_FEATS"}
+                ],
+                "Core12": [
+                    {"VkPhysicalDeviceVulkan12Properties1": "VK_TYPE_12_PROPS_1"},
+                    {"VkPhysicalDeviceVulkan12Features1": "VK_TYPE_12_FEATS_1"},
+                    {"VkPhysicalDeviceVulkan12Properties2": "VK_TYPE_12_PROPS_2"},
+                    {"VkPhysicalDeviceVulkan12Features2": "VK_TYPE_12_FEATS_2"}
+                ]
+            }
+        }
+
+    def tearDown(self):
+        self.mock_vk_patcher.stop()
+
+    def test_handles_single_matching_struct(self):
+        actual_props, actual_feats = src.generate_vk_core_structs_init_code("Core11")
+
+        self.assertEqual(
+            (
+                "device.core11.properties.sType = VK_TYPE_11_PROPS;\n"
+                "device.core11.properties.pNext = properties.pNext;\n"
+                "properties.pNext = &device.core11.properties;\n\n"
+            ),
+            actual_props
+        )
+        self.assertEqual(
+            (
+                "device.core11.features.sType = VK_TYPE_11_FEATS;\n"
+                "device.core11.features.pNext = features.pNext;\n"
+                "features.pNext = &device.core11.features;\n\n"
+            ),
+            actual_feats
+        )
+
+    def test_handles_multiple_matching_structs(self):
+        actual_props, actual_feats = src.generate_vk_core_structs_init_code("Core12")
+
+        self.assertEqual(
+            (
+                "device.core12.properties.sType = VK_TYPE_12_PROPS_1;\n"
+                "device.core12.properties.pNext = properties.pNext;\n"
+                "properties.pNext = &device.core12.properties;\n\n\n"
+                "device.core12.properties.sType = VK_TYPE_12_PROPS_2;\n"
+                "device.core12.properties.pNext = properties.pNext;\n"
+                "properties.pNext = &device.core12.properties;\n\n"
+            ),
+            actual_props
+        )
+        self.assertEqual(
+            (
+                "device.core12.features.sType = VK_TYPE_12_FEATS_1;\n"
+                "device.core12.features.pNext = features.pNext;\n"
+                "features.pNext = &device.core12.features;\n\n\n"
+                "device.core12.features.sType = VK_TYPE_12_FEATS_2;\n"
+                "device.core12.features.pNext = features.pNext;\n"
+                "features.pNext = &device.core12.features;\n\n"
+            ),
+            actual_feats
+        )
+
+    def test_handles_no_matching_struct(self):
+        actual_props, actual_feats = src.generate_vk_core_structs_init_code("Core13")
+
+        self.assertEqual("", actual_props)
+        self.assertEqual("", actual_feats)
+
+
+class TestGenerateVkExtensionStructsInitCode(unittest.TestCase):
+
+    @classmethod
+    def setUpClass(cls):
+        cls.mapping = {
+            "VK_KHR_driver_state": [
+                {"VkPhysicalDeviceDriverPropertiesKHR": "VK_STRUCT_DRIVER"}
+            ],
+            "VK_KHR_variable_pointers": [
+                {"VkPhysicalDeviceVariablePointerFeaturesKHR": "VK_STRUCT_VARIABLE"},
+                {"VkPhysicalDeviceVariablePointersFeaturesKHR": "VK_STRUCT_VARIABLES"},
+                {"SomeThingElse": "SOME_OTHER_STRUCT"}
+            ]
+        }
+
+    def test_handles_single_extension_single_struct(self):
+        extension_var = src.get_vkjson_struct_variable_name("VK_KHR_driver_state")
+        struct_name = src.get_struct_name("VkPhysicalDeviceDriverPropertiesKHR")
+
+        self.assertEqual(
+            (
+                '  if (HasExtension("VK_KHR_driver_state", device.extensions)) {\n'
+                f"    device.{extension_var}.reported = true;\n"
+                f"    device.{extension_var}.{struct_name}.sType = VK_STRUCT_DRIVER;\n"
+                f"    device.{extension_var}.{struct_name}.pNext = properties.pNext;\n"
+                f"    properties.pNext = &device.{extension_var}.{struct_name};\n"
+                '  }\n'
+            ),
+            src.generate_vk_extension_structs_init_code(self.mapping, "Properties")
+        )
+
+    def test_handles_single_extension_multiple_structs(self):
+        extension_var = src.get_vkjson_struct_variable_name("VK_KHR_variable_pointers")
+        struct_name1 = src.get_struct_name("VkPhysicalDeviceVariablePointerFeaturesKHR")
+        struct_name2 = src.get_struct_name("VkPhysicalDeviceVariablePointersFeaturesKHR")
+
+        self.assertEqual(
+            (
+                '  if (HasExtension("VK_KHR_variable_pointers", device.extensions)) {\n'
+                f"    device.{extension_var}.reported = true;\n"
+                f"    device.{extension_var}.{struct_name1}.sType = VK_STRUCT_VARIABLE;\n"
+                f"    device.{extension_var}.{struct_name1}.pNext = features.pNext;\n"
+                f"    features.pNext = &device.{extension_var}.{struct_name1};\n"
+                f"    device.{extension_var}.{struct_name2}.sType = VK_STRUCT_VARIABLES;\n"
+                f"    device.{extension_var}.{struct_name2}.pNext = features.pNext;\n"
+                f"    features.pNext = &device.{extension_var}.{struct_name2};\n"
+                '  }\n'
+            ),
+            src.generate_vk_extension_structs_init_code(self.mapping, "Features")
+        )
+
+    def test_handles_no_matching_struct(self):
+        self.assertRaises(
+            Exception,
+            src.generate_vk_extension_structs_init_code(self.mapping, "Extension")
+        )
+
+    def test_handles_multiple_extensions(self):
+        # Resetting mapping as we only want extensions containing feature structs with valid structextends mapping
+        self.mapping = {
+            "VK_KHR_vulkan_memory_model": [{"VkPhysicalDeviceVulkanMemoryModelFeaturesKHR": "VK_STRUCT_MEMORY"}],
+            "VK_KHR_video_maintenance1": [{"VkPhysicalDeviceVideoMaintenance1FeaturesKHR": "VK_STRUCT_VIDEO"}],
+        }
+        extension_var1 = src.get_vkjson_struct_variable_name("VK_KHR_vulkan_memory_model")
+        struct_name1 = src.get_struct_name("VkPhysicalDeviceVulkanMemoryModelFeaturesKHR")
+
+        extension_var2 = src.get_vkjson_struct_variable_name("VK_KHR_video_maintenance1")
+        struct_name2 = src.get_struct_name("VkPhysicalDeviceVideoMaintenance1FeaturesKHR")
+        self.assertEqual(
+            (
+                '  if (HasExtension("VK_KHR_vulkan_memory_model", device.extensions)) {\n'
+                f"    device.{extension_var1}.reported = true;\n"
+                f"    device.{extension_var1}.{struct_name1}.sType = VK_STRUCT_MEMORY;\n"
+                f"    device.{extension_var1}.{struct_name1}.pNext = features.pNext;\n"
+                f"    features.pNext = &device.{extension_var1}.{struct_name1};\n"
+                '  }\n\n'
+                '  if (HasExtension("VK_KHR_video_maintenance1", device.extensions)) {\n'
+                f"    device.{extension_var2}.reported = true;\n"
+                f"    device.{extension_var2}.{struct_name2}.sType = VK_STRUCT_VIDEO;\n"
+                f"    device.{extension_var2}.{struct_name2}.pNext = features.pNext;\n"
+                f"    features.pNext = &device.{extension_var2}.{struct_name2};\n"
+                '  }\n'
+            ),
+            src.generate_vk_extension_structs_init_code(self.mapping, "Features")
+        )
+
+
+class TestGenerateVkVersionStructsInitialization(unittest.TestCase):
+
+    @classmethod
+    def setUpClass(cls):
+        cls.version_data = [
+            {
+                "VkPhysicalDeviceIDProperties": "VK_STRUCTURE_TYPE_DEVICE_ID",
+                "VkPhysicalDeviceMultiviewFeatures": "VK_STRUCTURE_TYPE_MULTIVIEW"
+            },
+            {
+                "VkPhysicalDeviceMaintenance3Properties": "VK_STRUCTURE_TYPE_MAINTENANCE_3"
+            }
+        ]
+
+        cls.prop1_struct_name = src.get_struct_name("VkPhysicalDeviceIDProperties")
+        cls.prop2_struct_name = src.get_struct_name("VkPhysicalDeviceMaintenance3Properties")
+        cls.feat_struct_name = src.get_struct_name("VkPhysicalDeviceMultiviewFeatures")
+
+    def test_handles_single_matching_struct(self):
+        self.assertEqual(
+            (
+                f"device.{self.feat_struct_name}.sType = VK_STRUCTURE_TYPE_MULTIVIEW;\n"
+                f"device.{self.feat_struct_name}.pNext = features.pNext;\n"
+                f"features.pNext = &device.{self.feat_struct_name};\n"
+            ),
+            src.generate_vk_version_structs_initialization(self.version_data, "Features")
+        )
+
+    def test_handles_multiple_matching_structs(self):
+        self.assertEqual(
+            (
+                f"device.{self.prop1_struct_name}.sType = VK_STRUCTURE_TYPE_DEVICE_ID;\n"
+                f"device.{self.prop1_struct_name}.pNext = properties.pNext;\n"
+                f"properties.pNext = &device.{self.prop1_struct_name};\n\n"
+                f"device.{self.prop2_struct_name}.sType = VK_STRUCTURE_TYPE_MAINTENANCE_3;\n"
+                f"device.{self.prop2_struct_name}.pNext = properties.pNext;\n"
+                f"properties.pNext = &device.{self.prop2_struct_name};\n"
+            ),
+            src.generate_vk_version_structs_initialization(self.version_data, "Properties")
+        )
+
+    def test_handles_no_matching_struct(self):
+        self.assertEqual(
+            "",
+            src.generate_vk_version_structs_initialization(self.version_data, "Custom")
+        )
diff --git a/vulkan/scripts/test/test_vkjson_generator.py b/vulkan/scripts/test/test_vkjson_generator.py
new file mode 100644
index 0000000000..b9b839d352
--- /dev/null
+++ b/vulkan/scripts/test/test_vkjson_generator.py
@@ -0,0 +1,166 @@
+#!/usr/bin/env python3
+#
+# Copyright 2025 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+from unittest.mock import ANY, mock_open, patch
+
+import os
+import base_test_helper as helper
+import vkjson_generator as src
+
+"""
+This file contains unit tests for vkjson_generator.py
+Each test class focuses on one generated file.
+"""
+
+
+class TestGenH(helper.BaseMockCodeFileTest):
+
+    @patch('builtins.open', new_callable=mock_open)
+    @patch('vkjson_generator.util')
+    @patch('vkjson_generator.gencom')
+    def test_header_file_generation(self, _, mock_util, mock_file_open):
+        expected_abs_file_path = os.path.abspath(
+            os.path.join(os.path.dirname(src.__file__), "..", "vkjson", "vkjson.h"))
+
+        self.mock_file = mock_file_open.return_value
+        mock_util.get_copyright_warnings.return_value = "\n// Copyright generated here\n"
+        mock_util.generate_extension_struct_definition.side_effect = lambda *args, **kwargs: (
+            self.mock_file.write("\n// Extension struct definitions generated here\n"),
+            ["VkJsonExtension1 ext1", "VkJsonExtension2 ext2"]
+        )[1]
+        mock_util.generate_vk_core_struct_definition.side_effect = lambda *args, **kwargs: (
+            self.mock_file.write("\n// Core struct definitions generated here\n"),
+            ["VkJsonCore1 core1", "VkJsonCore2 core2"]
+        )[1]
+        mock_util.generate_memset_statements.side_effect = lambda *args, **kwargs: (
+            self.mock_file.write(
+                "\n// Memset statements for extension independent structs generated here\n"),
+            ["VkPhysicalDeviceProperties properties", "VkPhysicalDeviceFeatures features"]
+        )[1]
+
+        src.gen_h()
+        mock_file_open.assert_called_once_with(ANY, "w")
+        self.assertEqual(
+            expected_abs_file_path,
+            os.path.abspath(mock_file_open.call_args_list[0][0][0])
+        )
+
+        expected_lines = (
+            """// Copyright generated here
+
+            #ifndef VKJSON_H_
+            #define VKJSON_H_
+
+            #ifndef VK_USE_PLATFORM_ANDROID_KHR
+            #define VK_USE_PLATFORM_ANDROID_KHR
+            #endif
+
+            #include <string.h>
+            #include <vulkan/vulkan.h>
+
+            #include <map>
+            #include <string>
+            #include <vector>
+
+            #ifdef WIN32
+            #undef min
+            #undef max
+            #endif
+
+            /*
+             * This file is autogenerated by vkjson_generator.py. Do not edit directly.
+             */
+            struct VkJsonLayer {
+              VkLayerProperties properties;
+              std::vector<VkExtensionProperties> extensions;
+            };
+
+            // Extension struct definitions generated here
+
+            // Core struct definitions generated here
+
+            struct VkJsonDevice {
+              VkJsonDevice() {
+                // Memset statements for extension independent structs generated here
+              }
+              VkJsonExtension1 ext1;
+              VkJsonExtension2 ext2;
+              VkJsonCore1 core1;
+              VkJsonCore2 core2;
+              VkPhysicalDeviceProperties properties;
+              VkPhysicalDeviceFeatures features;
+              std::vector<VkQueueFamilyProperties> queues;
+              std::vector<VkExtensionProperties> extensions;
+              std::vector<VkLayerProperties> layers;
+              std::map<VkFormat, VkFormatProperties> formats;
+              std::map<VkExternalFenceHandleTypeFlagBits, VkExternalFenceProperties> external_fence_properties;
+              std::map<VkExternalSemaphoreHandleTypeFlagBits, VkExternalSemaphoreProperties> external_semaphore_properties;
+            };
+
+            struct VkJsonDeviceGroup {
+              VkJsonDeviceGroup() {
+                memset(&properties, 0, sizeof(VkPhysicalDeviceGroupProperties));
+              }
+              VkPhysicalDeviceGroupProperties properties;
+              std::vector<uint32_t> device_inds;
+            };
+
+            struct VkJsonInstance {
+              VkJsonInstance() : api_version(0) {}
+              uint32_t api_version;
+              std::vector<VkJsonLayer> layers;
+              std::vector<VkExtensionProperties> extensions;
+              std::vector<VkJsonDevice> devices;
+              std::vector<VkJsonDeviceGroup> device_groups;
+            };
+
+            VkJsonInstance VkJsonGetInstance();
+            std::string VkJsonInstanceToJson(const VkJsonInstance& instance);
+            bool VkJsonInstanceFromJson(const std::string& json,
+                                        VkJsonInstance* instance,
+                                        std::string* errors);
+
+            VkJsonDevice VkJsonGetDevice(VkPhysicalDevice device);
+            std::string VkJsonDeviceToJson(const VkJsonDevice& device);
+            bool VkJsonDeviceFromJson(const std::string& json,
+                                      VkJsonDevice* device,
+                                      std::string* errors);
+
+            std::string VkJsonImageFormatPropertiesToJson(
+            const VkImageFormatProperties& properties);
+            bool VkJsonImageFormatPropertiesFromJson(const std::string& json,
+                                         VkImageFormatProperties* properties,
+                                         std::string* errors);
+
+            // Backward-compatibility aliases
+            typedef VkJsonDevice VkJsonAllProperties;
+            inline VkJsonAllProperties VkJsonGetAllProperties(VkPhysicalDevice physicalDevice) {
+              return VkJsonGetDevice(physicalDevice);
+            }
+            inline std::string VkJsonAllPropertiesToJson(const VkJsonAllProperties& properties) {
+              return VkJsonDeviceToJson(properties);
+            }
+            inline bool VkJsonAllPropertiesFromJson(const std::string& json,
+                                            VkJsonAllProperties* properties,
+                                            std::string* errors) {
+              return VkJsonDeviceFromJson(json, properties, errors);
+            }
+
+            #endif  // VKJSON_H_"""
+        )
+
+        self.assertCodeFileWrite(expected_lines)
+        self.mock_file.close.assert_called()
diff --git a/vulkan/scripts/vk.py b/vulkan/scripts/vk.py
index a68a99dda7..26c39147a6 100644
--- a/vulkan/scripts/vk.py
+++ b/vulkan/scripts/vk.py
@@ -1,968 +1,5236 @@
-import ctypes
+# Copyright 2025 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+from dataclasses import dataclass
+from enum import Enum
 import dataclasses
-import enum
-from typing import List
 
 dataclass = dataclasses.dataclass
-Enum = enum.Enum
+from typing import List
+import ctypes
 
-# TODO(b/401184058): Automate this file for generating the vulkan structs graph from vk.xml
-VK_UUID_SIZE = 16
-VK_LUID_SIZE = 16
+# --- Adding Pre-Defined Constants ---
 
-VkImageLayout = Enum
 uint8_t = ctypes.c_uint8
 uint32_t = ctypes.c_uint32
 VkFlags = uint32_t
-VkMemoryPropertyFlags = VkFlags
-VkMemoryHeapFlags = VkFlags
 int32_t = int
 uint64_t = ctypes.c_uint64
 VkBool32 = bool
 VkDeviceSize = ctypes.c_uint64
-size_t = int
-VkSampleCountFlags = ctypes.c_uint32
-VkFormatFeatureFlags = ctypes.c_uint32
-VkQueueFlags = ctypes.c_uint32
-VkShaderStageFlags = ctypes.c_uint32
-VkSubgroupFeatureFlags = ctypes.c_uint32
-VkResolveModeFlags = ctypes.c_uint32
+size_t = ctypes.c_uint64
 float_t = ctypes.c_float
-VkShaderFloatControlsIndependence = Enum
-VkPointClippingBehavior = Enum
-VkPhysicalDeviceType = Enum
-VkDriverId = Enum
-VkPipelineRobustnessBufferBehavior = Enum
+int64_t = ctypes.c_int64
+uint16_t = ctypes.c_uint16
+VkFlags64 = uint64_t
+
+
+# --- Enum Definitions ---
+class VkImageLayout(Enum):
+    VK_IMAGE_LAYOUT_UNDEFINED = 0
+    VK_IMAGE_LAYOUT_GENERAL = 1
+    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2
+    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3
+    VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4
+    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5
+    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6
+    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7
+    VK_IMAGE_LAYOUT_PREINITIALIZED = 8
+
+
+class VkImageType(Enum):
+    VK_IMAGE_TYPE_1D = 0
+    VK_IMAGE_TYPE_2D = 1
+    VK_IMAGE_TYPE_3D = 2
+
+
+class VkImageTiling(Enum):
+    VK_IMAGE_TILING_OPTIMAL = 0
+    VK_IMAGE_TILING_LINEAR = 1
+
+
+class VkPhysicalDeviceType(Enum):
+    VK_PHYSICAL_DEVICE_TYPE_OTHER = 0
+    VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1
+    VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2
+    VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3
+    VK_PHYSICAL_DEVICE_TYPE_CPU = 4
+
+
+class VkFormat(Enum):
+    VK_FORMAT_UNDEFINED = 0
+    VK_FORMAT_R4G4_UNORM_PACK8 = 1
+    VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2
+    VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3
+    VK_FORMAT_R5G6B5_UNORM_PACK16 = 4
+    VK_FORMAT_B5G6R5_UNORM_PACK16 = 5
+    VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6
+    VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7
+    VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8
+    VK_FORMAT_R8_UNORM = 9
+    VK_FORMAT_R8_SNORM = 10
+    VK_FORMAT_R8_USCALED = 11
+    VK_FORMAT_R8_SSCALED = 12
+    VK_FORMAT_R8_UINT = 13
+    VK_FORMAT_R8_SINT = 14
+    VK_FORMAT_R8_SRGB = 15
+    VK_FORMAT_R8G8_UNORM = 16
+    VK_FORMAT_R8G8_SNORM = 17
+    VK_FORMAT_R8G8_USCALED = 18
+    VK_FORMAT_R8G8_SSCALED = 19
+    VK_FORMAT_R8G8_UINT = 20
+    VK_FORMAT_R8G8_SINT = 21
+    VK_FORMAT_R8G8_SRGB = 22
+    VK_FORMAT_R8G8B8_UNORM = 23
+    VK_FORMAT_R8G8B8_SNORM = 24
+    VK_FORMAT_R8G8B8_USCALED = 25
+    VK_FORMAT_R8G8B8_SSCALED = 26
+    VK_FORMAT_R8G8B8_UINT = 27
+    VK_FORMAT_R8G8B8_SINT = 28
+    VK_FORMAT_R8G8B8_SRGB = 29
+    VK_FORMAT_B8G8R8_UNORM = 30
+    VK_FORMAT_B8G8R8_SNORM = 31
+    VK_FORMAT_B8G8R8_USCALED = 32
+    VK_FORMAT_B8G8R8_SSCALED = 33
+    VK_FORMAT_B8G8R8_UINT = 34
+    VK_FORMAT_B8G8R8_SINT = 35
+    VK_FORMAT_B8G8R8_SRGB = 36
+    VK_FORMAT_R8G8B8A8_UNORM = 37
+    VK_FORMAT_R8G8B8A8_SNORM = 38
+    VK_FORMAT_R8G8B8A8_USCALED = 39
+    VK_FORMAT_R8G8B8A8_SSCALED = 40
+    VK_FORMAT_R8G8B8A8_UINT = 41
+    VK_FORMAT_R8G8B8A8_SINT = 42
+    VK_FORMAT_R8G8B8A8_SRGB = 43
+    VK_FORMAT_B8G8R8A8_UNORM = 44
+    VK_FORMAT_B8G8R8A8_SNORM = 45
+    VK_FORMAT_B8G8R8A8_USCALED = 46
+    VK_FORMAT_B8G8R8A8_SSCALED = 47
+    VK_FORMAT_B8G8R8A8_UINT = 48
+    VK_FORMAT_B8G8R8A8_SINT = 49
+    VK_FORMAT_B8G8R8A8_SRGB = 50
+    VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51
+    VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52
+    VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53
+    VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54
+    VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55
+    VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56
+    VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57
+    VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58
+    VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59
+    VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60
+    VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61
+    VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62
+    VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63
+    VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64
+    VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65
+    VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66
+    VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67
+    VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68
+    VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69
+    VK_FORMAT_R16_UNORM = 70
+    VK_FORMAT_R16_SNORM = 71
+    VK_FORMAT_R16_USCALED = 72
+    VK_FORMAT_R16_SSCALED = 73
+    VK_FORMAT_R16_UINT = 74
+    VK_FORMAT_R16_SINT = 75
+    VK_FORMAT_R16_SFLOAT = 76
+    VK_FORMAT_R16G16_UNORM = 77
+    VK_FORMAT_R16G16_SNORM = 78
+    VK_FORMAT_R16G16_USCALED = 79
+    VK_FORMAT_R16G16_SSCALED = 80
+    VK_FORMAT_R16G16_UINT = 81
+    VK_FORMAT_R16G16_SINT = 82
+    VK_FORMAT_R16G16_SFLOAT = 83
+    VK_FORMAT_R16G16B16_UNORM = 84
+    VK_FORMAT_R16G16B16_SNORM = 85
+    VK_FORMAT_R16G16B16_USCALED = 86
+    VK_FORMAT_R16G16B16_SSCALED = 87
+    VK_FORMAT_R16G16B16_UINT = 88
+    VK_FORMAT_R16G16B16_SINT = 89
+    VK_FORMAT_R16G16B16_SFLOAT = 90
+    VK_FORMAT_R16G16B16A16_UNORM = 91
+    VK_FORMAT_R16G16B16A16_SNORM = 92
+    VK_FORMAT_R16G16B16A16_USCALED = 93
+    VK_FORMAT_R16G16B16A16_SSCALED = 94
+    VK_FORMAT_R16G16B16A16_UINT = 95
+    VK_FORMAT_R16G16B16A16_SINT = 96
+    VK_FORMAT_R16G16B16A16_SFLOAT = 97
+    VK_FORMAT_R32_UINT = 98
+    VK_FORMAT_R32_SINT = 99
+    VK_FORMAT_R32_SFLOAT = 100
+    VK_FORMAT_R32G32_UINT = 101
+    VK_FORMAT_R32G32_SINT = 102
+    VK_FORMAT_R32G32_SFLOAT = 103
+    VK_FORMAT_R32G32B32_UINT = 104
+    VK_FORMAT_R32G32B32_SINT = 105
+    VK_FORMAT_R32G32B32_SFLOAT = 106
+    VK_FORMAT_R32G32B32A32_UINT = 107
+    VK_FORMAT_R32G32B32A32_SINT = 108
+    VK_FORMAT_R32G32B32A32_SFLOAT = 109
+    VK_FORMAT_R64_UINT = 110
+    VK_FORMAT_R64_SINT = 111
+    VK_FORMAT_R64_SFLOAT = 112
+    VK_FORMAT_R64G64_UINT = 113
+    VK_FORMAT_R64G64_SINT = 114
+    VK_FORMAT_R64G64_SFLOAT = 115
+    VK_FORMAT_R64G64B64_UINT = 116
+    VK_FORMAT_R64G64B64_SINT = 117
+    VK_FORMAT_R64G64B64_SFLOAT = 118
+    VK_FORMAT_R64G64B64A64_UINT = 119
+    VK_FORMAT_R64G64B64A64_SINT = 120
+    VK_FORMAT_R64G64B64A64_SFLOAT = 121
+    VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122
+    VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123
+    VK_FORMAT_D16_UNORM = 124
+    VK_FORMAT_X8_D24_UNORM_PACK32 = 125
+    VK_FORMAT_D32_SFLOAT = 126
+    VK_FORMAT_S8_UINT = 127
+    VK_FORMAT_D16_UNORM_S8_UINT = 128
+    VK_FORMAT_D24_UNORM_S8_UINT = 129
+    VK_FORMAT_D32_SFLOAT_S8_UINT = 130
+    VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131
+    VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132
+    VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133
+    VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134
+    VK_FORMAT_BC2_UNORM_BLOCK = 135
+    VK_FORMAT_BC2_SRGB_BLOCK = 136
+    VK_FORMAT_BC3_UNORM_BLOCK = 137
+    VK_FORMAT_BC3_SRGB_BLOCK = 138
+    VK_FORMAT_BC4_UNORM_BLOCK = 139
+    VK_FORMAT_BC4_SNORM_BLOCK = 140
+    VK_FORMAT_BC5_UNORM_BLOCK = 141
+    VK_FORMAT_BC5_SNORM_BLOCK = 142
+    VK_FORMAT_BC6H_UFLOAT_BLOCK = 143
+    VK_FORMAT_BC6H_SFLOAT_BLOCK = 144
+    VK_FORMAT_BC7_UNORM_BLOCK = 145
+    VK_FORMAT_BC7_SRGB_BLOCK = 146
+    VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147
+    VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148
+    VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149
+    VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150
+    VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151
+    VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152
+    VK_FORMAT_EAC_R11_UNORM_BLOCK = 153
+    VK_FORMAT_EAC_R11_SNORM_BLOCK = 154
+    VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155
+    VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156
+    VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157
+    VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158
+    VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159
+    VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160
+    VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161
+    VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162
+    VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163
+    VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164
+    VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165
+    VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166
+    VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167
+    VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168
+    VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169
+    VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170
+    VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171
+    VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172
+    VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173
+    VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174
+    VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175
+    VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176
+    VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177
+    VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178
+    VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179
+    VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180
+    VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181
+    VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182
+    VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183
+    VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184
+    VK_FORMAT_G8B8G8R8_422_UNORM = 1000156000
+    VK_FORMAT_B8G8R8G8_422_UNORM = 1000156001
+    VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM = 1000156002
+    VK_FORMAT_G8_B8R8_2PLANE_420_UNORM = 1000156003
+    VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM = 1000156004
+    VK_FORMAT_G8_B8R8_2PLANE_422_UNORM = 1000156005
+    VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM = 1000156006
+    VK_FORMAT_R10X6_UNORM_PACK16 = 1000156007
+    VK_FORMAT_R10X6G10X6_UNORM_2PACK16 = 1000156008
+    VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009
+    VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010
+    VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011
+    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012
+    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013
+    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014
+    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015
+    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016
+    VK_FORMAT_R12X4_UNORM_PACK16 = 1000156017
+    VK_FORMAT_R12X4G12X4_UNORM_2PACK16 = 1000156018
+    VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019
+    VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020
+    VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021
+    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022
+    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023
+    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024
+    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025
+    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026
+    VK_FORMAT_G16B16G16R16_422_UNORM = 1000156027
+    VK_FORMAT_B16G16R16G16_422_UNORM = 1000156028
+    VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM = 1000156029
+    VK_FORMAT_G16_B16R16_2PLANE_420_UNORM = 1000156030
+    VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM = 1000156031
+    VK_FORMAT_G16_B16R16_2PLANE_422_UNORM = 1000156032
+    VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM = 1000156033
+    VK_FORMAT_G8_B8R8_2PLANE_444_UNORM = 1000330000
+    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16 = 1000330001
+    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16 = 1000330002
+    VK_FORMAT_G16_B16R16_2PLANE_444_UNORM = 1000330003
+    VK_FORMAT_A4R4G4B4_UNORM_PACK16 = 1000340000
+    VK_FORMAT_A4B4G4R4_UNORM_PACK16 = 1000340001
+    VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK = 1000066000
+    VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK = 1000066001
+    VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK = 1000066002
+    VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK = 1000066003
+    VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK = 1000066004
+    VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK = 1000066005
+    VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK = 1000066006
+    VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK = 1000066007
+    VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK = 1000066008
+    VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK = 1000066009
+    VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK = 1000066010
+    VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK = 1000066011
+    VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK = 1000066012
+    VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK = 1000066013
+    VK_FORMAT_A1B5G5R5_UNORM_PACK16 = 1000470000
+    VK_FORMAT_A8_UNORM = 1000470001
+    VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000
+    VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001
+    VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002
+    VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003
+    VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004
+    VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005
+    VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006
+    VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007
+    VK_FORMAT_R16G16_SFIXED5_NV = 1000464000
+
+
+class VkRayTracingInvocationReorderModeNV(Enum):
+    VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV = 0
+    VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV = 1
+
+
+class VkSampleCountFlagBits(Enum):
+    VK_SAMPLE_COUNT_1_BIT = 0
+    VK_SAMPLE_COUNT_2_BIT = 1
+    VK_SAMPLE_COUNT_4_BIT = 2
+    VK_SAMPLE_COUNT_8_BIT = 3
+    VK_SAMPLE_COUNT_16_BIT = 4
+    VK_SAMPLE_COUNT_32_BIT = 5
+    VK_SAMPLE_COUNT_64_BIT = 6
+
+
+class VkExternalMemoryHandleTypeFlagBits(Enum):
+    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT = 0
+    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT = 1
+    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 2
+    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT = 3
+    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT = 4
+    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT = 5
+    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT = 6
+
+
+class VkExternalSemaphoreHandleTypeFlagBits(Enum):
+    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT = 0
+    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 1
+    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 2
+    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT = 3
+    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 4
+
+
+class VkExternalFenceHandleTypeFlagBits(Enum):
+    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT = 0
+    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 1
+    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 2
+    VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 3
+
+
+class VkPointClippingBehavior(Enum):
+    VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES = 0
+    VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY = 1
+
+
+class VkChromaLocation(Enum):
+    VK_CHROMA_LOCATION_COSITED_EVEN = 0
+    VK_CHROMA_LOCATION_MIDPOINT = 1
+
+
+class VkDriverId(Enum):
+    VK_DRIVER_ID_AMD_PROPRIETARY = 1
+    VK_DRIVER_ID_AMD_OPEN_SOURCE = 2
+    VK_DRIVER_ID_MESA_RADV = 3
+    VK_DRIVER_ID_NVIDIA_PROPRIETARY = 4
+    VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS = 5
+    VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA = 6
+    VK_DRIVER_ID_IMAGINATION_PROPRIETARY = 7
+    VK_DRIVER_ID_QUALCOMM_PROPRIETARY = 8
+    VK_DRIVER_ID_ARM_PROPRIETARY = 9
+    VK_DRIVER_ID_GOOGLE_SWIFTSHADER = 10
+    VK_DRIVER_ID_GGP_PROPRIETARY = 11
+    VK_DRIVER_ID_BROADCOM_PROPRIETARY = 12
+    VK_DRIVER_ID_MESA_LLVMPIPE = 13
+    VK_DRIVER_ID_MOLTENVK = 14
+    VK_DRIVER_ID_COREAVI_PROPRIETARY = 15
+    VK_DRIVER_ID_JUICE_PROPRIETARY = 16
+    VK_DRIVER_ID_VERISILICON_PROPRIETARY = 17
+    VK_DRIVER_ID_MESA_TURNIP = 18
+    VK_DRIVER_ID_MESA_V3DV = 19
+    VK_DRIVER_ID_MESA_PANVK = 20
+    VK_DRIVER_ID_SAMSUNG_PROPRIETARY = 21
+    VK_DRIVER_ID_MESA_VENUS = 22
+    VK_DRIVER_ID_MESA_DOZEN = 23
+    VK_DRIVER_ID_MESA_NVK = 24
+    VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA = 25
+    VK_DRIVER_ID_MESA_HONEYKRISP = 26
+    VK_DRIVER_ID_RESERVED_27 = 27
+
+
+class VkShaderFloatControlsIndependence(Enum):
+    VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY = 0
+    VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL = 1
+    VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE = 2
+
+
+class VkPipelineRobustnessBufferBehavior(Enum):
+    VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT = 0
+    VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED = 1
+    VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS = 2
+    VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2 = 3
+
+
+class VkPipelineRobustnessImageBehavior(Enum):
+    VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT = 0
+    VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED = 1
+    VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS = 2
+    VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2 = 3
+
+
+class VkPhysicalDeviceLayeredApiKHR(Enum):
+    VK_PHYSICAL_DEVICE_LAYERED_API_VULKAN_KHR = 0
+    VK_PHYSICAL_DEVICE_LAYERED_API_D3D12_KHR = 1
+    VK_PHYSICAL_DEVICE_LAYERED_API_METAL_KHR = 2
+    VK_PHYSICAL_DEVICE_LAYERED_API_OPENGL_KHR = 3
+    VK_PHYSICAL_DEVICE_LAYERED_API_OPENGLES_KHR = 4
+
+
+class VkLayeredDriverUnderlyingApiMSFT(Enum):
+    VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT = 0
+    VK_LAYERED_DRIVER_UNDERLYING_API_D3D12_MSFT = 1
+
+
+# --- API Constant values extracted from vk.xml ---
+
+VK_MAX_PHYSICAL_DEVICE_NAME_SIZE = 256
+VK_UUID_SIZE = 16
+VK_LUID_SIZE = 8
+VK_MAX_EXTENSION_NAME_SIZE = 256
+VK_MAX_DESCRIPTION_SIZE = 256
+VK_MAX_MEMORY_TYPES = 32
+VK_MAX_MEMORY_HEAPS = 16
+VK_LOD_CLAMP_NONE = 1000.0
+VK_REMAINING_MIP_LEVELS = 4294967295
+VK_REMAINING_ARRAY_LAYERS = 4294967295
+VK_REMAINING_3D_SLICES_EXT = 4294967295
+VK_WHOLE_SIZE = 0xFFFFFFFFFFFFFFFF
+VK_ATTACHMENT_UNUSED = 4294967295
+VK_TRUE = 1
+VK_FALSE = 0
+VK_QUEUE_FAMILY_IGNORED = 4294967295
+VK_QUEUE_FAMILY_EXTERNAL = 4294967294
+VK_QUEUE_FAMILY_FOREIGN_EXT = 4294967293
+VK_SUBPASS_EXTERNAL = 4294967295
+VK_MAX_DEVICE_GROUP_SIZE = 32
+VK_MAX_DRIVER_NAME_SIZE = 256
+VK_MAX_DRIVER_INFO_SIZE = 256
+VK_SHADER_UNUSED_KHR = 4294967295
+VK_MAX_GLOBAL_PRIORITY_SIZE = 16
+VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT = 32
+VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR = 32
+VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR = 7
+VK_SHADER_INDEX_UNUSED_AMDX = 4294967295
+
+
+# --- Computed VK_API_VERSION Constants ---
+
+VK_API_VERSION = 4194304
+VK_API_VERSION_1_0 = 4194304
+VK_API_VERSION_1_1 = 4198400
+VK_API_VERSION_1_2 = 4202496
+VK_API_VERSION_1_3 = 4206592
+VK_API_VERSION_1_4 = 4210688
+
+
+# --- VkFlags Type Aliases ---
+
+VkFramebufferCreateFlags = VkFlags
+VkQueryPoolCreateFlags = VkFlags
+VkRenderPassCreateFlags = VkFlags
+VkSamplerCreateFlags = VkFlags
+VkPipelineCacheCreateFlags = VkFlags
+VkPipelineDepthStencilStateCreateFlags = VkFlags
+VkPipelineDynamicStateCreateFlags = VkFlags
+VkPipelineColorBlendStateCreateFlags = VkFlags
+VkPipelineMultisampleStateCreateFlags = VkFlags
+VkPipelineRasterizationStateCreateFlags = VkFlags
+VkPipelineViewportStateCreateFlags = VkFlags
+VkPipelineTessellationStateCreateFlags = VkFlags
+VkPipelineInputAssemblyStateCreateFlags = VkFlags
+VkPipelineVertexInputStateCreateFlags = VkFlags
+VkPipelineShaderStageCreateFlags = VkFlags
+VkDescriptorSetLayoutCreateFlags = VkFlags
+VkBufferViewCreateFlags = VkFlags
+VkInstanceCreateFlags = VkFlags
+VkDeviceCreateFlags = VkFlags
+VkDeviceQueueCreateFlags = VkFlags
+VkQueueFlags = VkFlags
+VkMemoryPropertyFlags = VkFlags
+VkMemoryHeapFlags = VkFlags
+VkAccessFlags = VkFlags
+VkBufferUsageFlags = VkFlags
+VkBufferCreateFlags = VkFlags
+VkShaderStageFlags = VkFlags
+VkImageUsageFlags = VkFlags
+VkImageCreateFlags = VkFlags
+VkImageViewCreateFlags = VkFlags
+VkColorComponentFlags = VkFlags
+VkFenceCreateFlags = VkFlags
+VkSemaphoreCreateFlags = VkFlags
+VkFormatFeatureFlags = VkFlags
+VkQueryControlFlags = VkFlags
+VkEventCreateFlags = VkFlags
+VkCommandPoolCreateFlags = VkFlags
+VkCommandBufferUsageFlags = VkFlags
+VkQueryPipelineStatisticFlags = VkFlags
+VkMemoryMapFlags = VkFlags
+VkMemoryUnmapFlags = VkFlags
+VkImageAspectFlags = VkFlags
+VkSparseMemoryBindFlags = VkFlags
+VkSparseImageFormatFlags = VkFlags
+VkSubpassDescriptionFlags = VkFlags
+VkPipelineStageFlags = VkFlags
+VkSampleCountFlags = VkFlags
+VkAttachmentDescriptionFlags = VkFlags
+VkCullModeFlags = VkFlags
+VkDescriptorPoolCreateFlags = VkFlags
+VkDependencyFlags = VkFlags
+VkSubgroupFeatureFlags = VkFlags
+VkPrivateDataSlotCreateFlags = VkFlags
+VkDescriptorUpdateTemplateCreateFlags = VkFlags
+VkPipelineCreationFeedbackFlags = VkFlags
+VkSemaphoreWaitFlags = VkFlags
+VkShaderCorePropertiesFlagsAMD = VkFlags
+VkAccessFlags2 = VkFlags64
+VkPipelineStageFlags2 = VkFlags64
+VkFormatFeatureFlags2 = VkFlags64
+VkRenderingFlags = VkFlags
+VkMemoryDecompressionMethodFlagsNV = VkFlags64
+VkSurfaceTransformFlagsKHR = VkFlags
+VkExternalMemoryHandleTypeFlagsNV = VkFlags
+VkExternalMemoryFeatureFlagsNV = VkFlags
+VkExternalMemoryHandleTypeFlags = VkFlags
+VkExternalMemoryFeatureFlags = VkFlags
+VkExternalSemaphoreHandleTypeFlags = VkFlags
+VkExternalSemaphoreFeatureFlags = VkFlags
+VkExternalFenceHandleTypeFlags = VkFlags
+VkExternalFenceFeatureFlags = VkFlags
+VkResolveModeFlags = VkFlags
+VkToolPurposeFlags = VkFlags
+VkSubmitFlags = VkFlags
+VkHostImageCopyFlags = VkFlags
+VkOpticalFlowGridSizeFlagsNV = VkFlags
+VkPhysicalDeviceSchedulingControlsFlagsARM = VkFlags64
+
+
+# --- Empty Handle Dataclasses ---
 
 
 @dataclass
-class ConformanceVersion:
-  major: uint8_t
-  minor: uint8_t
-  subminor: uint8_t
-  patch: uint8_t
+class VkPhysicalDevice:
+    pass
+
+
+# --- Pre-defined Struct Definitions ---
 
 
 @dataclass
 class VkExtent3D:
-  width: uint32_t
-  height: uint32_t
-  depth: uint32_t
+    width: uint32_t
+    height: uint32_t
+    depth: uint32_t
 
 
 @dataclass
-class VkPhysicalDeviceLimits:
-  maxImageDimension1D: uint32_t
-  maxImageDimension2D: uint32_t
-  maxImageDimension3D: uint32_t
-  maxImageDimensionCube: uint32_t
-  maxImageArrayLayers: uint32_t
-  maxTexelBufferElements: uint32_t
-  maxUniformBufferRange: uint32_t
-  maxStorageBufferRange: uint32_t
-  maxPushConstantsSize: uint32_t
-  maxMemoryAllocationCount: uint32_t
-  maxSamplerAllocationCount: uint32_t
-  bufferImageGranularity: VkDeviceSize
-  sparseAddressSpaceSize: VkDeviceSize
-  maxBoundDescriptorSets: uint32_t
-  maxPerStageDescriptorSamplers: uint32_t
-  maxPerStageDescriptorUniformBuffers: uint32_t
-  maxPerStageDescriptorStorageBuffers: uint32_t
-  maxPerStageDescriptorSampledImages: uint32_t
-  maxPerStageDescriptorStorageImages: uint32_t
-  maxPerStageDescriptorInputAttachments: uint32_t
-  maxPerStageResources: uint32_t
-  maxDescriptorSetSamplers: uint32_t
-  maxDescriptorSetUniformBuffers: uint32_t
-  maxDescriptorSetUniformBuffersDynamic: uint32_t
-  maxDescriptorSetStorageBuffers: uint32_t
-  maxDescriptorSetStorageBuffersDynamic: uint32_t
-  maxDescriptorSetSampledImages: uint32_t
-  maxDescriptorSetStorageImages: uint32_t
-  maxDescriptorSetInputAttachments: uint32_t
-  maxVertexInputAttributes: uint32_t
-  maxVertexInputBindings: uint32_t
-  maxVertexInputAttributeOffset: uint32_t
-  maxVertexInputBindingStride: uint32_t
-  maxVertexOutputComponents: uint32_t
-  maxTessellationGenerationLevel: uint32_t
-  maxTessellationPatchSize: uint32_t
-  maxTessellationControlPerVertexInputComponents: uint32_t
-  maxTessellationControlPerVertexOutputComponents: uint32_t
-  maxTessellationControlPerPatchOutputComponents: uint32_t
-  maxTessellationControlTotalOutputComponents: uint32_t
-  maxTessellationEvaluationInputComponents: uint32_t
-  maxTessellationEvaluationOutputComponents: uint32_t
-  maxGeometryShaderInvocations: uint32_t
-  maxGeometryInputComponents: uint32_t
-  maxGeometryOutputComponents: uint32_t
-  maxGeometryOutputVertices: uint32_t
-  maxGeometryTotalOutputComponents: uint32_t
-  maxFragmentInputComponents: uint32_t
-  maxFragmentOutputAttachments: uint32_t
-  maxFragmentDualSrcAttachments: uint32_t
-  maxFragmentCombinedOutputResources: uint32_t
-  maxComputeSharedMemorySize: uint32_t
-  maxComputeWorkGroupCount: uint32_t*3
-  maxComputeWorkGroupInvocations: uint32_t
-  maxComputeWorkGroupSize: uint32_t*3
-  subPixelPrecisionBits: uint32_t
-  subTexelPrecisionBits: uint32_t
-  mipmapPrecisionBits: uint32_t
-  maxDrawIndexedIndexValue: uint32_t
-  maxDrawIndirectCount: uint32_t
-  maxSamplerLodBias: float
-  maxSamplerAnisotropy: float
-  maxViewports: uint32_t
-  maxViewportDimensions: uint32_t*2
-  viewportBoundsRange: float_t*2
-  viewportSubPixelBits: uint32_t
-  minMemoryMapAlignment: size_t
-  minTexelBufferOffsetAlignment: VkDeviceSize
-  minUniformBufferOffsetAlignment: VkDeviceSize
-  minStorageBufferOffsetAlignment: VkDeviceSize
-  minTexelOffset: int32_t
-  maxTexelOffset: uint32_t
-  minTexelGatherOffset: int32_t
-  maxTexelGatherOffset: uint32_t
-  minInterpolationOffset: float
-  maxInterpolationOffset: float
-  subPixelInterpolationOffsetBits: uint32_t
-  maxFramebufferWidth: uint32_t
-  maxFramebufferHeight: uint32_t
-  maxFramebufferLayers: uint32_t
-  framebufferColorSampleCounts: VkSampleCountFlags
-  framebufferDepthSampleCounts: VkSampleCountFlags
-  framebufferStencilSampleCounts: VkSampleCountFlags
-  framebufferNoAttachmentsSampleCounts: VkSampleCountFlags
-  maxColorAttachments: uint32_t
-  sampledImageColorSampleCounts: VkSampleCountFlags
-  sampledImageIntegerSampleCounts: VkSampleCountFlags
-  sampledImageDepthSampleCounts: VkSampleCountFlags
-  sampledImageStencilSampleCounts: VkSampleCountFlags
-  storageImageSampleCounts: VkSampleCountFlags
-  maxSampleMaskWords: uint32_t
-  timestampComputeAndGraphics: VkBool32
-  timestampPeriod: float
-  maxClipDistances: uint32_t
-  maxCullDistances: uint32_t
-  maxCombinedClipAndCullDistances: uint32_t
-  discreteQueuePriorities: uint32_t
-  pointSizeRange: float_t*2
-  lineWidthRange: float_t*2
-  pointSizeGranularity: float
-  lineWidthGranularity: float
-  strictLines: VkBool32
-  standardSampleLocations: VkBool32
-  optimalBufferCopyOffsetAlignment: VkDeviceSize
-  optimalBufferCopyRowPitchAlignment: VkDeviceSize
-  nonCoherentAtomSize: VkDeviceSize
-
-
-@dataclass
-class VkPhysicalDeviceShaderDrawParameterFeatures:
-  shaderDrawParameters: VkBool32
+class VkImageFormatProperties:
+    maxExtent: VkExtent3D
+    maxMipLevels: uint32_t
+    maxArrayLayers: uint32_t
+    sampleCounts: VkSampleCountFlags
+    maxResourceSize: VkDeviceSize
 
 
 @dataclass
 class VkExtensionProperties:
-  extensionName: str
-  specVersion: uint32_t
+    extensionName: str
+    specVersion: uint32_t
 
 
 @dataclass
 class VkFormatProperties:
-  linearTilingFeatures: VkFormatFeatureFlags
-  optimalTilingFeatures: VkFormatFeatureFlags
-  bufferFeatures: VkFormatFeatureFlags
+    linearTilingFeatures: VkFormatFeatureFlags
+    optimalTilingFeatures: VkFormatFeatureFlags
+    bufferFeatures: VkFormatFeatureFlags
 
 
 @dataclass
 class VkLayerProperties:
-  layerName: str
-  specVersion: uint32_t
-  implementationVersion: uint32_t
-  description: str
+    layerName: str
+    specVersion: uint32_t
+    implementationVersion: uint32_t
+    description: str
 
 
 @dataclass
 class VkQueueFamilyProperties:
-  queueFlags: VkQueueFlags
-  queueCount: uint32_t
-  timestampValidBits: uint32_t
-  minImageTransferGranularity: VkExtent3D
+    queueFlags: VkQueueFlags
+    queueCount: uint32_t
+    timestampValidBits: uint32_t
+    minImageTransferGranularity: VkExtent3D
+
+
+# --- Vulkan Struct Definitions (Dependencies first, then PhysicalDevice structs) ---
+
+
+@dataclass
+class VkExtent2D:
+    width: uint32_t
+    height: uint32_t
+
+
+@dataclass
+class VkMemoryType:
+    propertyFlags: VkMemoryPropertyFlags
+    heapIndex: uint32_t
+
+
+@dataclass
+class VkMemoryHeap:
+    size: VkDeviceSize
+    flags: VkMemoryHeapFlags
 
 
 @dataclass
 class VkPhysicalDeviceSparseProperties:
-  residencyStandard2DBlockShape: VkBool32
-  residencyStandard2DMultisampleBlockShape: VkBool32
-  residencyStandard3DBlockShape: VkBool32
-  residencyAlignedMipSize: VkBool32
-  residencyNonResidentStrict: VkBool32
+    residencyStandard2DBlockShape: VkBool32
+    residencyStandard2DMultisampleBlockShape: VkBool32
+    residencyStandard3DBlockShape: VkBool32
+    residencyAlignedMipSize: VkBool32
+    residencyNonResidentStrict: VkBool32
 
 
 @dataclass
-class VkImageFormatProperties:
-  maxExtent: VkExtent3D
-  maxMipLevels: uint32_t
-  maxArrayLayers: uint32_t
-  sampleCounts: VkSampleCountFlags
-  maxResourceSize: VkDeviceSize
+class VkPhysicalDeviceLimits:
+    maxImageDimension1D: uint32_t
+    maxImageDimension2D: uint32_t
+    maxImageDimension3D: uint32_t
+    maxImageDimensionCube: uint32_t
+    maxImageArrayLayers: uint32_t
+    maxTexelBufferElements: uint32_t
+    maxUniformBufferRange: uint32_t
+    maxStorageBufferRange: uint32_t
+    maxPushConstantsSize: uint32_t
+    maxMemoryAllocationCount: uint32_t
+    maxSamplerAllocationCount: uint32_t
+    bufferImageGranularity: VkDeviceSize
+    sparseAddressSpaceSize: VkDeviceSize
+    maxBoundDescriptorSets: uint32_t
+    maxPerStageDescriptorSamplers: uint32_t
+    maxPerStageDescriptorUniformBuffers: uint32_t
+    maxPerStageDescriptorStorageBuffers: uint32_t
+    maxPerStageDescriptorSampledImages: uint32_t
+    maxPerStageDescriptorStorageImages: uint32_t
+    maxPerStageDescriptorInputAttachments: uint32_t
+    maxPerStageResources: uint32_t
+    maxDescriptorSetSamplers: uint32_t
+    maxDescriptorSetUniformBuffers: uint32_t
+    maxDescriptorSetUniformBuffersDynamic: uint32_t
+    maxDescriptorSetStorageBuffers: uint32_t
+    maxDescriptorSetStorageBuffersDynamic: uint32_t
+    maxDescriptorSetSampledImages: uint32_t
+    maxDescriptorSetStorageImages: uint32_t
+    maxDescriptorSetInputAttachments: uint32_t
+    maxVertexInputAttributes: uint32_t
+    maxVertexInputBindings: uint32_t
+    maxVertexInputAttributeOffset: uint32_t
+    maxVertexInputBindingStride: uint32_t
+    maxVertexOutputComponents: uint32_t
+    maxTessellationGenerationLevel: uint32_t
+    maxTessellationPatchSize: uint32_t
+    maxTessellationControlPerVertexInputComponents: uint32_t
+    maxTessellationControlPerVertexOutputComponents: uint32_t
+    maxTessellationControlPerPatchOutputComponents: uint32_t
+    maxTessellationControlTotalOutputComponents: uint32_t
+    maxTessellationEvaluationInputComponents: uint32_t
+    maxTessellationEvaluationOutputComponents: uint32_t
+    maxGeometryShaderInvocations: uint32_t
+    maxGeometryInputComponents: uint32_t
+    maxGeometryOutputComponents: uint32_t
+    maxGeometryOutputVertices: uint32_t
+    maxGeometryTotalOutputComponents: uint32_t
+    maxFragmentInputComponents: uint32_t
+    maxFragmentOutputAttachments: uint32_t
+    maxFragmentDualSrcAttachments: uint32_t
+    maxFragmentCombinedOutputResources: uint32_t
+    maxComputeSharedMemorySize: uint32_t
+    maxComputeWorkGroupCount: uint32_t * 3
+    maxComputeWorkGroupInvocations: uint32_t
+    maxComputeWorkGroupSize: uint32_t * 3
+    subPixelPrecisionBits: uint32_t
+    subTexelPrecisionBits: uint32_t
+    mipmapPrecisionBits: uint32_t
+    maxDrawIndexedIndexValue: uint32_t
+    maxDrawIndirectCount: uint32_t
+    maxSamplerLodBias: float
+    maxSamplerAnisotropy: float
+    maxViewports: uint32_t
+    maxViewportDimensions: uint32_t * 2
+    viewportBoundsRange: float_t * 2
+    viewportSubPixelBits: uint32_t
+    minMemoryMapAlignment: size_t
+    minTexelBufferOffsetAlignment: VkDeviceSize
+    minUniformBufferOffsetAlignment: VkDeviceSize
+    minStorageBufferOffsetAlignment: VkDeviceSize
+    minTexelOffset: int32_t
+    maxTexelOffset: uint32_t
+    minTexelGatherOffset: int32_t
+    maxTexelGatherOffset: uint32_t
+    minInterpolationOffset: float
+    maxInterpolationOffset: float
+    subPixelInterpolationOffsetBits: uint32_t
+    maxFramebufferWidth: uint32_t
+    maxFramebufferHeight: uint32_t
+    maxFramebufferLayers: uint32_t
+    framebufferColorSampleCounts: VkSampleCountFlags
+    framebufferDepthSampleCounts: VkSampleCountFlags
+    framebufferStencilSampleCounts: VkSampleCountFlags
+    framebufferNoAttachmentsSampleCounts: VkSampleCountFlags
+    maxColorAttachments: uint32_t
+    sampledImageColorSampleCounts: VkSampleCountFlags
+    sampledImageIntegerSampleCounts: VkSampleCountFlags
+    sampledImageDepthSampleCounts: VkSampleCountFlags
+    sampledImageStencilSampleCounts: VkSampleCountFlags
+    storageImageSampleCounts: VkSampleCountFlags
+    maxSampleMaskWords: uint32_t
+    timestampComputeAndGraphics: VkBool32
+    timestampPeriod: float
+    maxClipDistances: uint32_t
+    maxCullDistances: uint32_t
+    maxCombinedClipAndCullDistances: uint32_t
+    discreteQueuePriorities: uint32_t
+    pointSizeRange: float_t * 2
+    lineWidthRange: float_t * 2
+    pointSizeGranularity: float
+    lineWidthGranularity: float
+    strictLines: VkBool32
+    standardSampleLocations: VkBool32
+    optimalBufferCopyOffsetAlignment: VkDeviceSize
+    optimalBufferCopyRowPitchAlignment: VkDeviceSize
+    nonCoherentAtomSize: VkDeviceSize
 
 
 @dataclass
-class VkPhysicalDeviceSamplerYcbcrConversionFeatures:
-  samplerYcbcrConversion: VkBool32
+class VkConformanceVersion:
+    major: uint8_t
+    minor: uint8_t
+    subminor: uint8_t
+    patch: uint8_t
+
+
+@dataclass
+class VkPhysicalDeviceLayeredApiPropertiesKHR:
+    vendorID: uint32_t
+    deviceID: uint32_t
+    layeredAPI: VkPhysicalDeviceLayeredApiKHR
+    deviceName: str
+
+
+@dataclass
+class VkPhysicalDeviceProperties:
+    apiVersion: uint32_t
+    driverVersion: uint32_t
+    vendorID: uint32_t
+    deviceID: uint32_t
+    deviceType: VkPhysicalDeviceType
+    deviceName: str
+    pipelineCacheUUID: uint8_t * VK_UUID_SIZE
+    limits: VkPhysicalDeviceLimits
+    sparseProperties: VkPhysicalDeviceSparseProperties
+
+
+@dataclass
+class VkPhysicalDeviceMemoryProperties:
+    memoryTypeCount: uint32_t
+    memoryTypes: List[VkMemoryType]
+    memoryHeapCount: uint32_t
+    memoryHeaps: List[VkMemoryHeap]
+
+
+@dataclass
+class VkPhysicalDeviceFeatures:
+    robustBufferAccess: VkBool32
+    fullDrawIndexUint32: VkBool32
+    imageCubeArray: VkBool32
+    independentBlend: VkBool32
+    geometryShader: VkBool32
+    tessellationShader: VkBool32
+    sampleRateShading: VkBool32
+    dualSrcBlend: VkBool32
+    logicOp: VkBool32
+    multiDrawIndirect: VkBool32
+    drawIndirectFirstInstance: VkBool32
+    depthClamp: VkBool32
+    depthBiasClamp: VkBool32
+    fillModeNonSolid: VkBool32
+    depthBounds: VkBool32
+    wideLines: VkBool32
+    largePoints: VkBool32
+    alphaToOne: VkBool32
+    multiViewport: VkBool32
+    samplerAnisotropy: VkBool32
+    textureCompressionETC2: VkBool32
+    textureCompressionASTC_LDR: VkBool32
+    textureCompressionBC: VkBool32
+    occlusionQueryPrecise: VkBool32
+    pipelineStatisticsQuery: VkBool32
+    vertexPipelineStoresAndAtomics: VkBool32
+    fragmentStoresAndAtomics: VkBool32
+    shaderTessellationAndGeometryPointSize: VkBool32
+    shaderImageGatherExtended: VkBool32
+    shaderStorageImageExtendedFormats: VkBool32
+    shaderStorageImageMultisample: VkBool32
+    shaderStorageImageReadWithoutFormat: VkBool32
+    shaderStorageImageWriteWithoutFormat: VkBool32
+    shaderUniformBufferArrayDynamicIndexing: VkBool32
+    shaderSampledImageArrayDynamicIndexing: VkBool32
+    shaderStorageBufferArrayDynamicIndexing: VkBool32
+    shaderStorageImageArrayDynamicIndexing: VkBool32
+    shaderClipDistance: VkBool32
+    shaderCullDistance: VkBool32
+    shaderFloat64: VkBool32
+    shaderInt64: VkBool32
+    shaderInt16: VkBool32
+    shaderResourceResidency: VkBool32
+    shaderResourceMinLod: VkBool32
+    sparseBinding: VkBool32
+    sparseResidencyBuffer: VkBool32
+    sparseResidencyImage2D: VkBool32
+    sparseResidencyImage3D: VkBool32
+    sparseResidency2Samples: VkBool32
+    sparseResidency4Samples: VkBool32
+    sparseResidency8Samples: VkBool32
+    sparseResidency16Samples: VkBool32
+    sparseResidencyAliased: VkBool32
+    variableMultisampleRate: VkBool32
+    inheritedQueries: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV:
+    deviceGeneratedCommands: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV:
+    deviceGeneratedCompute: VkBool32
+    deviceGeneratedComputePipelines: VkBool32
+    deviceGeneratedComputeCaptureReplay: VkBool32
+
+
+@dataclass
+class VkPhysicalDevicePrivateDataFeatures:
+    privateData: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV:
+    maxGraphicsShaderGroupCount: uint32_t
+    maxIndirectSequenceCount: uint32_t
+    maxIndirectCommandsTokenCount: uint32_t
+    maxIndirectCommandsStreamCount: uint32_t
+    maxIndirectCommandsTokenOffset: uint32_t
+    maxIndirectCommandsStreamStride: uint32_t
+    minSequencesCountBufferOffsetAlignment: uint32_t
+    minSequencesIndexBufferOffsetAlignment: uint32_t
+    minIndirectCommandsBufferOffsetAlignment: uint32_t
+
+
+@dataclass
+class VkPhysicalDeviceMultiDrawPropertiesEXT:
+    maxMultiDrawCount: uint32_t
+
+
+@dataclass
+class VkPhysicalDeviceProperties2:
+    properties: VkPhysicalDeviceProperties
+
+
+@dataclass
+class VkPhysicalDeviceImageFormatInfo2:
+    format: VkFormat
+    type: VkImageType
+    tiling: VkImageTiling
+    usage: VkImageUsageFlags
+    flags: VkImageCreateFlags
+
+
+@dataclass
+class VkPhysicalDeviceMemoryProperties2:
+    memoryProperties: VkPhysicalDeviceMemoryProperties
+
+
+@dataclass
+class VkPhysicalDeviceSparseImageFormatInfo2:
+    format: VkFormat
+    type: VkImageType
+    samples: VkSampleCountFlagBits
+    usage: VkImageUsageFlags
+    tiling: VkImageTiling
+
+
+@dataclass
+class VkPhysicalDevicePushDescriptorProperties:
+    maxPushDescriptors: uint32_t
+
+
+@dataclass
+class VkPhysicalDeviceDriverProperties:
+    driverID: VkDriverId
+    driverName: str
+    driverInfo: str
+    conformanceVersion: VkConformanceVersion
+
+
+@dataclass
+class VkPhysicalDeviceVariablePointersFeatures:
+    variablePointersStorageBuffer: VkBool32
+    variablePointers: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceExternalBufferInfo:
+    flags: VkBufferCreateFlags
+    usage: VkBufferUsageFlags
+    handleType: VkExternalMemoryHandleTypeFlagBits
 
 
 @dataclass
 class VkPhysicalDeviceIDProperties:
-  deviceUUID: uint8_t*VK_UUID_SIZE
-  driverUUID: uint8_t*VK_UUID_SIZE
-  deviceLUID: uint8_t*VK_LUID_SIZE
-  deviceNodeMask: uint32_t
-  deviceLUIDValid: VkBool32
+    deviceUUID: uint8_t * VK_UUID_SIZE
+    driverUUID: uint8_t * VK_UUID_SIZE
+    deviceLUID: uint8_t * VK_LUID_SIZE
+    deviceNodeMask: uint32_t
+    deviceLUIDValid: VkBool32
 
 
 @dataclass
-class VkPhysicalDeviceMaintenance3Properties:
-  maxPerSetDescriptors: uint32_t
-  maxMemoryAllocationSize: VkDeviceSize
+class VkPhysicalDeviceExternalSemaphoreInfo:
+    handleType: VkExternalSemaphoreHandleTypeFlagBits
 
 
 @dataclass
-class VkPhysicalDevice16BitStorageFeatures:
-  storageBuffer16BitAccess: VkBool32
-  uniformAndStorageBuffer16BitAccess: VkBool32
-  storagePushConstant16: VkBool32
-  storageInputOutput16: VkBool32
+class VkPhysicalDeviceExternalFenceInfo:
+    handleType: VkExternalFenceHandleTypeFlagBits
 
 
 @dataclass
 class VkPhysicalDeviceMultiviewFeatures:
-  multiview: VkBool32
-  multiviewGeometryShader: VkBool32
-  multiviewTessellationShader: VkBool32
+    multiview: VkBool32
+    multiviewGeometryShader: VkBool32
+    multiviewTessellationShader: VkBool32
 
 
 @dataclass
-class VkPhysicalDeviceSubgroupProperties:
-  subgroupSize: uint32_t
-  supportedStages: VkShaderStageFlags
-  supportedOperations: VkSubgroupFeatureFlags
-  quadOperationsInAllStages: VkBool32
+class VkPhysicalDeviceMultiviewProperties:
+    maxMultiviewViewCount: uint32_t
+    maxMultiviewInstanceIndex: uint32_t
 
 
 @dataclass
-class VkPhysicalDevicePointClippingProperties:
-  pointClippingBehavior: VkPointClippingBehavior
+class VkPhysicalDeviceGroupProperties:
+    physicalDeviceCount: uint32_t
+    physicalDevices: List[VkPhysicalDevice]
+    subsetAllocation: VkBool32
 
 
 @dataclass
-class VkPhysicalDeviceMultiviewProperties:
-  maxMultiviewViewCount: uint32_t
-  maxMultiviewInstanceIndex: uint32_t
+class VkPhysicalDevicePresentIdFeaturesKHR:
+    presentId: VkBool32
 
 
 @dataclass
-class VkMemoryType:
-  propertyFlags: VkMemoryPropertyFlags
-  heapIndex: uint32_t
+class VkPhysicalDevicePresentWaitFeaturesKHR:
+    presentWait: VkBool32
 
 
 @dataclass
-class VkMemoryHeap:
-  size: VkDeviceSize
-  flags: VkMemoryHeapFlags
+class VkPhysicalDeviceDiscardRectanglePropertiesEXT:
+    maxDiscardRectangles: uint32_t
 
 
 @dataclass
-class VkPhysicalDeviceMemoryProperties:
-  memoryTypeCount: uint32_t
-  memoryTypes: List[VkMemoryType]
-  memoryHeapCount: uint32_t
-  memoryHeaps: List[VkMemoryHeap]
+class VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX:
+    perViewPositionAllComponents: VkBool32
 
 
 @dataclass
-class VkPhysicalDeviceProperties:
-  apiVersion: uint32_t
-  driverVersion: uint32_t
-  vendorID: uint32_t
-  deviceID: uint32_t
-  deviceType: VkPhysicalDeviceType
-  deviceName: str
-  pipelineCacheUUID: uint8_t
-  limits: VkPhysicalDeviceLimits
-  sparseProperties: VkPhysicalDeviceSparseProperties
+class VkPhysicalDevice16BitStorageFeatures:
+    storageBuffer16BitAccess: VkBool32
+    uniformAndStorageBuffer16BitAccess: VkBool32
+    storagePushConstant16: VkBool32
+    storageInputOutput16: VkBool32
 
 
 @dataclass
-class VkPhysicalDeviceFeatures:
-  robustBufferAccess: VkBool32
-  fullDrawIndexUint32: VkBool32
-  imageCubeArray: VkBool32
-  independentBlend: VkBool32
-  geometryShader: VkBool32
-  tessellationShader: VkBool32
-  sampleRateShading: VkBool32
-  dualSrcBlend: VkBool32
-  logicOp: VkBool32
-  multiDrawIndirect: VkBool32
-  drawIndirectFirstInstance: VkBool32
-  depthClamp: VkBool32
-  depthBiasClamp: VkBool32
-  fillModeNonSolid: VkBool32
-  depthBounds: VkBool32
-  wideLines: VkBool32
-  largePoints: VkBool32
-  alphaToOne: VkBool32
-  multiViewport: VkBool32
-  samplerAnisotropy: VkBool32
-  textureCompressionETC2: VkBool32
-  textureCompressionASTC_LDR: VkBool32
-  textureCompressionBC: VkBool32
-  occlusionQueryPrecise: VkBool32
-  pipelineStatisticsQuery: VkBool32
-  vertexPipelineStoresAndAtomics: VkBool32
-  fragmentStoresAndAtomics: VkBool32
-  shaderTessellationAndGeometryPointSize: VkBool32
-  shaderImageGatherExtended: VkBool32
-  shaderStorageImageExtendedFormats: VkBool32
-  shaderStorageImageMultisample: VkBool32
-  shaderStorageImageReadWithoutFormat: VkBool32
-  shaderStorageImageWriteWithoutFormat: VkBool32
-  shaderUniformBufferArrayDynamicIndexing: VkBool32
-  shaderSampledImageArrayDynamicIndexing: VkBool32
-  shaderStorageBufferArrayDynamicIndexing: VkBool32
-  shaderStorageImageArrayDynamicIndexing: VkBool32
-  shaderClipDistance: VkBool32
-  shaderCullDistance: VkBool32
-  shaderFloat64: VkBool32
-  shaderInt64: VkBool32
-  shaderInt16: VkBool32
-  shaderResourceResidency: VkBool32
-  shaderResourceMinLod: VkBool32
-  sparseBinding: VkBool32
-  sparseResidencyBuffer: VkBool32
-  sparseResidencyImage2D: VkBool32
-  sparseResidencyImage3D: VkBool32
-  sparseResidency2Samples: VkBool32
-  sparseResidency4Samples: VkBool32
-  sparseResidency8Samples: VkBool32
-  sparseResidency16Samples: VkBool32
-  sparseResidencyAliased: VkBool32
-  variableMultisampleRate: VkBool32
-  inheritedQueries: VkBool32
+class VkPhysicalDeviceSubgroupProperties:
+    subgroupSize: uint32_t
+    supportedStages: VkShaderStageFlags
+    supportedOperations: VkSubgroupFeatureFlags
+    quadOperationsInAllStages: VkBool32
 
 
 @dataclass
-class VkPhysicalDeviceShaderFloat16Int8Features:
-  shaderFloat16: VkBool32
-  shaderInt8: VkBool32
+class VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures:
+    shaderSubgroupExtendedTypes: VkBool32
+
+
+@dataclass
+class VkPhysicalDevicePointClippingProperties:
+    pointClippingBehavior: VkPointClippingBehavior
+
+
+@dataclass
+class VkPhysicalDeviceSamplerYcbcrConversionFeatures:
+    samplerYcbcrConversion: VkBool32
 
 
 @dataclass
 class VkPhysicalDeviceProtectedMemoryFeatures:
-  protectedMemory: VkBool32
+    protectedMemory: VkBool32
 
 
 @dataclass
-class VkPhysicalDeviceVariablePointersFeatures:
-  variablePointersStorageBuffer: VkBool32
-  variablePointers: VkBool32
+class VkPhysicalDeviceProtectedMemoryProperties:
+    protectedNoFault: VkBool32
 
 
 @dataclass
-class VkPhysicalDeviceImage2DViewOf3DFeaturesEXT:
-  image2DViewOf3D: VkBool32
-  sampler2DViewOf3D: VkBool32
+class VkPhysicalDeviceSamplerFilterMinmaxProperties:
+    filterMinmaxSingleComponentFormats: VkBool32
+    filterMinmaxImageComponentMapping: VkBool32
 
 
 @dataclass
-class VkPhysicalDeviceCustomBorderColorFeaturesEXT:
-  customBorderColors: VkBool32
-  customBorderColorWithoutFormat: VkBool32
+class VkPhysicalDeviceSampleLocationsPropertiesEXT:
+    sampleLocationSampleCounts: VkSampleCountFlags
+    maxSampleLocationGridSize: VkExtent2D
+    sampleLocationCoordinateRange: float_t * 2
+    sampleLocationSubPixelBits: uint32_t
+    variableSampleLocations: VkBool32
 
 
 @dataclass
-class VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT:
-  primitiveTopologyListRestart: VkBool32
-  primitiveTopologyPatchListRestart: VkBool32
+class VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT:
+    advancedBlendCoherentOperations: VkBool32
 
 
 @dataclass
-class VkPhysicalDeviceProvokingVertexFeaturesEXT:
-  provokingVertexLast: VkBool32
-  transformFeedbackPreservesProvokingVertex: VkBool32
+class VkPhysicalDeviceMultiDrawFeaturesEXT:
+    multiDraw: VkBool32
 
 
 @dataclass
-class VkPhysicalDeviceIndexTypeUint8Features:
-  indexTypeUint8: VkBool32
+class VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT:
+    advancedBlendMaxColorAttachments: uint32_t
+    advancedBlendIndependentBlend: VkBool32
+    advancedBlendNonPremultipliedSrcColor: VkBool32
+    advancedBlendNonPremultipliedDstColor: VkBool32
+    advancedBlendCorrelatedOverlap: VkBool32
+    advancedBlendAllOperations: VkBool32
 
 
 @dataclass
-class VkPhysicalDeviceVertexAttributeDivisorFeatures:
-  vertexAttributeInstanceRateDivisor: VkBool32
-  vertexAttributeInstanceRateZeroDivisor: VkBool32
+class VkPhysicalDeviceInlineUniformBlockFeatures:
+    inlineUniformBlock: VkBool32
+    descriptorBindingInlineUniformBlockUpdateAfterBind: VkBool32
 
 
 @dataclass
-class VkPhysicalDeviceTransformFeedbackFeaturesEXT:
-  transformFeedback: VkBool32
-  geometryStreams: VkBool32
+class VkPhysicalDeviceInlineUniformBlockProperties:
+    maxInlineUniformBlockSize: uint32_t
+    maxPerStageDescriptorInlineUniformBlocks: uint32_t
+    maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: uint32_t
+    maxDescriptorSetInlineUniformBlocks: uint32_t
+    maxDescriptorSetUpdateAfterBindInlineUniformBlocks: uint32_t
 
 
 @dataclass
-class VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR:
-  shaderSubgroupUniformControlFlow: VkBool32
+class VkPhysicalDeviceMaintenance3Properties:
+    maxPerSetDescriptors: uint32_t
+    maxMemoryAllocationSize: VkDeviceSize
 
 
 @dataclass
-class VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures:
-  shaderSubgroupExtendedTypes: VkBool32
+class VkPhysicalDeviceMaintenance4Features:
+    maintenance4: VkBool32
 
 
 @dataclass
-class VkPhysicalDevice8BitStorageFeatures:
-  storageBuffer8BitAccess: VkBool32
-  uniformAndStorageBuffer8BitAccess: VkBool32
-  storagePushConstant8: VkBool32
+class VkPhysicalDeviceMaintenance4Properties:
+    maxBufferSize: VkDeviceSize
 
 
 @dataclass
-class VkPhysicalDeviceShaderIntegerDotProductFeatures:
-  shaderIntegerDotProduct: VkBool32
+class VkPhysicalDeviceMaintenance5Features:
+    maintenance5: VkBool32
 
 
 @dataclass
-class VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG:
-  relaxedLineRasterization: VkBool32
+class VkPhysicalDeviceMaintenance5Properties:
+    earlyFragmentMultisampleCoverageAfterSampleCounting: VkBool32
+    earlyFragmentSampleMaskTestBeforeSampleCounting: VkBool32
+    depthStencilSwizzleOneSupport: VkBool32
+    polygonModePointSize: VkBool32
+    nonStrictSinglePixelWideLinesUseParallelogram: VkBool32
+    nonStrictWideLinesUseParallelogram: VkBool32
 
 
 @dataclass
-class VkPhysicalDeviceLineRasterizationFeatures:
-  rectangularLines: VkBool32
-  bresenhamLines: VkBool32
-  smoothLines: VkBool32
-  stippledRectangularLines: VkBool32
-  stippledBresenhamLines: VkBool32
-  stippledSmoothLines: VkBool32
+class VkPhysicalDeviceMaintenance6Features:
+    maintenance6: VkBool32
 
 
 @dataclass
-class VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT:
-  primitivesGeneratedQuery: VkBool32
-  primitivesGeneratedQueryWithRasterizerDiscard: VkBool32
-  primitivesGeneratedQueryWithNonZeroStreams: VkBool32
+class VkPhysicalDeviceMaintenance6Properties:
+    blockTexelViewCompatibleMultipleLayers: VkBool32
+    maxCombinedImageSamplerDescriptorCount: uint32_t
+    fragmentShadingRateClampCombinerInputs: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceMaintenance7FeaturesKHR:
+    maintenance7: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceMaintenance7PropertiesKHR:
+    robustFragmentShadingRateAttachmentAccess: VkBool32
+    separateDepthStencilAttachmentAccess: VkBool32
+    maxDescriptorSetTotalUniformBuffersDynamic: uint32_t
+    maxDescriptorSetTotalStorageBuffersDynamic: uint32_t
+    maxDescriptorSetTotalBuffersDynamic: uint32_t
+    maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic: uint32_t
+    maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic: uint32_t
+    maxDescriptorSetUpdateAfterBindTotalBuffersDynamic: uint32_t
+
+
+@dataclass
+class VkPhysicalDeviceLayeredApiPropertiesListKHR:
+    layeredApiCount: uint32_t
+    pLayeredApis: List[VkPhysicalDeviceLayeredApiPropertiesKHR]
+
+
+@dataclass
+class VkPhysicalDeviceShaderDrawParametersFeatures:
+    shaderDrawParameters: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceShaderFloat16Int8Features:
+    shaderFloat16: VkBool32
+    shaderInt8: VkBool32
 
 
 @dataclass
 class VkPhysicalDeviceFloatControlsProperties:
-  denormBehaviorIndependence : VkShaderFloatControlsIndependence
-  roundingModeIndependence : VkShaderFloatControlsIndependence
-  shaderSignedZeroInfNanPreserveFloat16 : VkBool32
-  shaderSignedZeroInfNanPreserveFloat32 : VkBool32
-  shaderSignedZeroInfNanPreserveFloat64 : VkBool32
-  shaderDenormPreserveFloat16 : VkBool32
-  shaderDenormPreserveFloat32 : VkBool32
-  shaderDenormPreserveFloat64 : VkBool32
-  shaderDenormFlushToZeroFloat16 : VkBool32
-  shaderDenormFlushToZeroFloat32 : VkBool32
-  shaderDenormFlushToZeroFloat64 : VkBool32
-  shaderRoundingModeRTEFloat16 : VkBool32
-  shaderRoundingModeRTEFloat32 : VkBool32
-  shaderRoundingModeRTEFloat64 :VkBool32
-  shaderRoundingModeRTZFloat16 : VkBool32
-  shaderRoundingModeRTZFloat32 : VkBool32
-  shaderRoundingModeRTZFloat64 : VkBool32
+    denormBehaviorIndependence: VkShaderFloatControlsIndependence
+    roundingModeIndependence: VkShaderFloatControlsIndependence
+    shaderSignedZeroInfNanPreserveFloat16: VkBool32
+    shaderSignedZeroInfNanPreserveFloat32: VkBool32
+    shaderSignedZeroInfNanPreserveFloat64: VkBool32
+    shaderDenormPreserveFloat16: VkBool32
+    shaderDenormPreserveFloat32: VkBool32
+    shaderDenormPreserveFloat64: VkBool32
+    shaderDenormFlushToZeroFloat16: VkBool32
+    shaderDenormFlushToZeroFloat32: VkBool32
+    shaderDenormFlushToZeroFloat64: VkBool32
+    shaderRoundingModeRTEFloat16: VkBool32
+    shaderRoundingModeRTEFloat32: VkBool32
+    shaderRoundingModeRTEFloat64: VkBool32
+    shaderRoundingModeRTZFloat16: VkBool32
+    shaderRoundingModeRTZFloat32: VkBool32
+    shaderRoundingModeRTZFloat64: VkBool32
 
 
 @dataclass
-class VkPhysicalDeviceVulkan11Properties:
-  deviceUUID : uint8_t*VK_UUID_SIZE
-  driverUUID : uint8_t*VK_UUID_SIZE
-  deviceLUID : uint8_t*VK_LUID_SIZE
-  deviceNodeMask : uint32_t
-  deviceLUIDValid : VkBool32
-  subgroupSize : uint32_t
-  subgroupSupportedStages : VkShaderStageFlags
-  subgroupSupportedOperations : VkSubgroupFeatureFlags
-  subgroupQuadOperationsInAllStages : VkBool32
-  pointClippingBehavior : VkPointClippingBehavior
-  maxMultiviewViewCount : uint32_t
-  maxMultiviewInstanceIndex :uint32_t
-  protectedNoFault : VkBool32
-  maxPerSetDescriptors : uint32_t
-  maxMemoryAllocationSize : VkDeviceSize
+class VkPhysicalDeviceHostQueryResetFeatures:
+    hostQueryReset: VkBool32
 
 
 @dataclass
-class VkPhysicalDeviceVulkan11Features:
-  storageBuffer16BitAccess: VkBool32
-  uniformAndStorageBuffer16BitAccess: VkBool32
-  storagePushConstant16: VkBool32
-  storageInputOutput16: VkBool32
-  multiview: VkBool32
-  multiviewGeometryShader: VkBool32
-  multiviewTessellationShader: VkBool32
-  variablePointersStorageBuffer: VkBool32
-  variablePointers: VkBool32
-  protectedMemory: VkBool32
-  samplerYcbcrConversion: VkBool32
-  shaderDrawParameters: VkBool32
+class VkPhysicalDeviceGlobalPriorityQueryFeatures:
+    globalPriorityQuery: VkBool32
 
 
 @dataclass
-class VkPhysicalDeviceVulkan12Properties:
-  driverID: VkDriverId
-  driverName: str
-  driverInfo: str
-  conformanceVersion: ConformanceVersion
-  denormBehaviorIndependence: VkShaderFloatControlsIndependence
-  roundingModeIndependence: VkShaderFloatControlsIndependence
-  shaderSignedZeroInfNanPreserveFloat16: VkBool32
-  shaderSignedZeroInfNanPreserveFloat32: VkBool32
-  shaderSignedZeroInfNanPreserveFloat64: VkBool32
-  shaderDenormPreserveFloat16: VkBool32
-  shaderDenormPreserveFloat32: VkBool32
-  shaderDenormPreserveFloat64: VkBool32
-  shaderDenormFlushToZeroFloat16: VkBool32
-  shaderDenormFlushToZeroFloat32: VkBool32
-  shaderDenormFlushToZeroFloat64: VkBool32
-  shaderRoundingModeRTEFloat16: VkBool32
-  shaderRoundingModeRTEFloat32: VkBool32
-  shaderRoundingModeRTEFloat64: VkBool32
-  shaderRoundingModeRTZFloat16: VkBool32
-  shaderRoundingModeRTZFloat32: VkBool32
-  shaderRoundingModeRTZFloat64: VkBool32
-  maxUpdateAfterBindDescriptorsInAllPools: uint32_t
-  shaderUniformBufferArrayNonUniformIndexingNative: VkBool32
-  shaderSampledImageArrayNonUniformIndexingNative: VkBool32
-  shaderStorageBufferArrayNonUniformIndexingNative: VkBool32
-  shaderStorageImageArrayNonUniformIndexingNative: VkBool32
-  shaderInputAttachmentArrayNonUniformIndexingNative: VkBool32
-  robustBufferAccessUpdateAfterBind: VkBool32
-  quadDivergentImplicitLod: VkBool32
-  maxPerStageDescriptorUpdateAfterBindSamplers: uint32_t
-  maxPerStageDescriptorUpdateAfterBindUniformBuffers: uint32_t
-  maxPerStageDescriptorUpdateAfterBindStorageBuffers: uint32_t
-  maxPerStageDescriptorUpdateAfterBindSampledImages: uint32_t
-  maxPerStageDescriptorUpdateAfterBindStorageImages: uint32_t
-  maxPerStageDescriptorUpdateAfterBindInputAttachments: uint32_t
-  maxPerStageUpdateAfterBindResources: uint32_t
-  maxDescriptorSetUpdateAfterBindSamplers: uint32_t
-  maxDescriptorSetUpdateAfterBindUniformBuffers: uint32_t
-  maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: uint32_t
-  maxDescriptorSetUpdateAfterBindStorageBuffers: uint32_t
-  maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: uint32_t
-  maxDescriptorSetUpdateAfterBindSampledImages: uint32_t
-  maxDescriptorSetUpdateAfterBindStorageImages: uint32_t
-  maxDescriptorSetUpdateAfterBindInputAttachments: uint32_t
-  supportedDepthResolveModes: VkResolveModeFlags
-  supportedStencilResolveModes: VkResolveModeFlags
-  independentResolveNone: VkBool32
-  independentResolve: VkBool32
-  filterMinmaxSingleComponentFormats: VkBool32
-  filterMinmaxImageComponentMapping: VkBool32
-  maxTimelineSemaphoreValueDifference: uint64_t
-  framebufferIntegerColorSampleCounts: VkSampleCountFlags
+class VkPhysicalDeviceDeviceMemoryReportFeaturesEXT:
+    deviceMemoryReport: VkBool32
 
 
 @dataclass
-class VkPhysicalDeviceVulkan12Features:
-  samplerMirrorClampToEdge: VkBool32
-  drawIndirectCount: VkBool32
-  storageBuffer8BitAccess: VkBool32
-  uniformAndStorageBuffer8BitAccess: VkBool32
-  storagePushConstant8: VkBool32
-  shaderBufferInt64Atomics: VkBool32
-  shaderSharedInt64Atomics: VkBool32
-  shaderFloat16: VkBool32
-  shaderInt8: VkBool32
-  descriptorIndexing: VkBool32
-  shaderInputAttachmentArrayDynamicIndexing: VkBool32
-  shaderUniformTexelBufferArrayDynamicIndexing: VkBool32
-  shaderStorageTexelBufferArrayDynamicIndexing: VkBool32
-  shaderUniformBufferArrayNonUniformIndexing: VkBool32
-  shaderSampledImageArrayNonUniformIndexing: VkBool32
-  shaderStorageBufferArrayNonUniformIndexing: VkBool32
-  shaderStorageImageArrayNonUniformIndexing: VkBool32
-  shaderInputAttachmentArrayNonUniformIndexing: VkBool32
-  shaderUniformTexelBufferArrayNonUniformIndexing: VkBool32
-  shaderStorageTexelBufferArrayNonUniformIndexing: VkBool32
-  descriptorBindingUniformBufferUpdateAfterBind: VkBool32
-  descriptorBindingSampledImageUpdateAfterBind: VkBool32
-  descriptorBindingStorageImageUpdateAfterBind: VkBool32
-  descriptorBindingStorageBufferUpdateAfterBind: VkBool32
-  descriptorBindingUniformTexelBufferUpdateAfterBind: VkBool32
-  descriptorBindingStorageTexelBufferUpdateAfterBind: VkBool32
-  descriptorBindingUpdateUnusedWhilePending: VkBool32
-  descriptorBindingPartiallyBound: VkBool32
-  descriptorBindingVariableDescriptorCount: VkBool32
-  runtimeDescriptorArray: VkBool32
-  samplerFilterMinmax: VkBool32
-  scalarBlockLayout: VkBool32
-  imagelessFramebuffer: VkBool32
-  uniformBufferStandardLayout: VkBool32
-  shaderSubgroupExtendedTypes: VkBool32
-  separateDepthStencilLayouts: VkBool32
-  hostQueryReset: VkBool32
-  timelineSemaphore: VkBool32
-  bufferDeviceAddress: VkBool32
-  bufferDeviceAddressCaptureReplay: VkBool32
-  bufferDeviceAddressMultiDevice: VkBool32
-  vulkanMemoryModel: VkBool32
-  vulkanMemoryModelDeviceScope: VkBool32
-  vulkanMemoryModelAvailabilityVisibilityChains: VkBool32
-  shaderOutputViewportIndex: VkBool32
-  shaderOutputLayer: VkBool32
-  subgroupBroadcastDynamicId: VkBool32
+class VkPhysicalDeviceExternalMemoryHostPropertiesEXT:
+    minImportedHostPointerAlignment: VkDeviceSize
 
 
 @dataclass
-class VkPhysicalDeviceVulkan13Properties:
-  minSubgroupSize: uint32_t
-  maxSubgroupSize: uint32_t
-  maxComputeWorkgroupSubgroups: uint32_t
-  requiredSubgroupSizeStages: VkShaderStageFlags
-  maxInlineUniformBlockSize: uint32_t
-  maxPerStageDescriptorInlineUniformBlocks: uint32_t
-  maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: uint32_t
-  maxDescriptorSetInlineUniformBlocks: uint32_t
-  maxDescriptorSetUpdateAfterBindInlineUniformBlocks: uint32_t
-  maxInlineUniformTotalSize: uint32_t
-  integerDotProduct8BitUnsignedAccelerated: VkBool32
-  integerDotProduct8BitSignedAccelerated: VkBool32
-  integerDotProduct8BitMixedSignednessAccelerated: VkBool32
-  integerDotProduct4x8BitPackedUnsignedAccelerated: VkBool32
-  integerDotProduct4x8BitPackedSignedAccelerated: VkBool32
-  integerDotProduct4x8BitPackedMixedSignednessAccelerated: VkBool32
-  integerDotProduct16BitUnsignedAccelerated: VkBool32
-  integerDotProduct16BitSignedAccelerated: VkBool32
-  integerDotProduct16BitMixedSignednessAccelerated: VkBool32
-  integerDotProduct32BitUnsignedAccelerated: VkBool32
-  integerDotProduct32BitSignedAccelerated: VkBool32
-  integerDotProduct32BitMixedSignednessAccelerated: VkBool32
-  integerDotProduct64BitUnsignedAccelerated: VkBool32
-  integerDotProduct64BitSignedAccelerated: VkBool32
-  integerDotProduct64BitMixedSignednessAccelerated: VkBool32
-  integerDotProductAccumulatingSaturating8BitUnsignedAccelerated: VkBool32
-  integerDotProductAccumulatingSaturating8BitSignedAccelerated: VkBool32
-  integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated: VkBool32
-  integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated: VkBool32
-  integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated: VkBool32
-  integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated: VkBool32
-  integerDotProductAccumulatingSaturating16BitUnsignedAccelerated: VkBool32
-  integerDotProductAccumulatingSaturating16BitSignedAccelerated: VkBool32
-  integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated: VkBool32
-  integerDotProductAccumulatingSaturating32BitUnsignedAccelerated: VkBool32
-  integerDotProductAccumulatingSaturating32BitSignedAccelerated: VkBool32
-  integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated: VkBool32
-  integerDotProductAccumulatingSaturating64BitUnsignedAccelerated: VkBool32
-  integerDotProductAccumulatingSaturating64BitSignedAccelerated: VkBool32
-  integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated: VkBool32
-  storageTexelBufferOffsetAlignmentBytes: VkDeviceSize
-  storageTexelBufferOffsetSingleTexelAlignment: VkBool32
-  uniformTexelBufferOffsetAlignmentBytes: VkDeviceSize
-  uniformTexelBufferOffsetSingleTexelAlignment: VkBool32
-  maxBufferSize: VkDeviceSize
+class VkPhysicalDeviceConservativeRasterizationPropertiesEXT:
+    primitiveOverestimationSize: float
+    maxExtraPrimitiveOverestimationSize: float
+    extraPrimitiveOverestimationSizeGranularity: float
+    primitiveUnderestimation: VkBool32
+    conservativePointAndLineRasterization: VkBool32
+    degenerateTrianglesRasterized: VkBool32
+    degenerateLinesRasterized: VkBool32
+    fullyCoveredFragmentShaderInputVariable: VkBool32
+    conservativeRasterizationPostDepthCoverage: VkBool32
 
 
 @dataclass
-class VkPhysicalDeviceVulkan13Features:
-  robustImageAccess: VkBool32
-  inlineUniformBlock: VkBool32
-  descriptorBindingInlineUniformBlockUpdateAfterBind: VkBool32
-  pipelineCreationCacheControl: VkBool32
-  privateData: VkBool32
-  shaderDemoteToHelperInvocation: VkBool32
-  shaderTerminateInvocation: VkBool32
-  subgroupSizeControl: VkBool32
-  computeFullSubgroups: VkBool32
-  synchronization2: VkBool32
-  textureCompressionASTC_HDR: VkBool32
-  shaderZeroInitializeWorkgroupMemory: VkBool32
-  dynamicRendering: VkBool32
-  shaderIntegerDotProduct: VkBool32
-  maintenance4: VkBool32
+class VkPhysicalDeviceShaderCorePropertiesAMD:
+    shaderEngineCount: uint32_t
+    shaderArraysPerEngineCount: uint32_t
+    computeUnitsPerShaderArray: uint32_t
+    simdPerComputeUnit: uint32_t
+    wavefrontsPerSimd: uint32_t
+    wavefrontSize: uint32_t
+    sgprsPerSimd: uint32_t
+    minSgprAllocation: uint32_t
+    maxSgprAllocation: uint32_t
+    sgprAllocationGranularity: uint32_t
+    vgprsPerSimd: uint32_t
+    minVgprAllocation: uint32_t
+    maxVgprAllocation: uint32_t
+    vgprAllocationGranularity: uint32_t
 
 
 @dataclass
-class VkPhysicalDeviceVulkan14Properties:
-  lineSubPixelPrecisionBits: uint32_t
-  maxVertexAttribDivisor: uint32_t
-  supportsNonZeroFirstInstance: VkBool32
-  maxPushDescriptors: uint32_t
-  dynamicRenderingLocalReadDepthStencilAttachments: VkBool32
-  dynamicRenderingLocalReadMultisampledAttachments: VkBool32
-  earlyFragmentMultisampleCoverageAfterSampleCounting: VkBool32
-  earlyFragmentSampleMaskTestBeforeSampleCounting: VkBool32
-  depthStencilSwizzleOneSupport: VkBool32
-  polygonModePointSize: VkBool32
-  nonStrictSinglePixelWideLinesUseParallelogram: VkBool32
-  nonStrictWideLinesUseParallelogram: VkBool32
-  blockTexelViewCompatibleMultipleLayers: VkBool32
-  maxCombinedImageSamplerDescriptorCount: uint32_t
-  fragmentShadingRateClampCombinerInputs: VkBool32
-  defaultRobustnessStorageBuffers: VkPipelineRobustnessBufferBehavior
-  defaultRobustnessUniformBuffers: VkPipelineRobustnessBufferBehavior
-  defaultRobustnessVertexInputs: VkPipelineRobustnessBufferBehavior
-  defaultRobustnessImages: VkPipelineRobustnessBufferBehavior
-  copySrcLayoutCount: uint32_t
-  pCopySrcLayouts: List[VkImageLayout]
-  copyDstLayoutCount: uint32_t
-  pCopyDstLayouts: List[VkImageLayout]
-  optimalTilingLayoutUUID: uint8_t
-  identicalMemoryTypeRequirements: VkBool32
+class VkPhysicalDeviceShaderCoreProperties2AMD:
+    shaderCoreFeatures: VkShaderCorePropertiesFlagsAMD
+    activeComputeUnitCount: uint32_t
 
 
 @dataclass
-class VkPhysicalDeviceVulkan14Features:
-  globalPriorityQuery: VkBool32
-  shaderSubgroupRotate: VkBool32
-  shaderSubgroupRotateClustered: VkBool32
-  shaderFloatControls2: VkBool32
-  shaderExpectAssume: VkBool32
-  rectangularLines: VkBool32
-  bresenhamLines: VkBool32
-  smoothLines: VkBool32
-  stippledRectangularLines: VkBool32
-  stippledBresenhamLines: VkBool32
-  stippledSmoothLines: VkBool32
-  vertexAttributeInstanceRateDivisor: VkBool32
-  vertexAttributeInstanceRateZeroDivisor: VkBool32
-  indexTypeUint8: VkBool32
-  dynamicRenderingLocalRead: VkBool32
-  maintenance5: VkBool32
-  maintenance6: VkBool32
-  pipelineProtectedAccess: VkBool32
-  pipelineRobustness: VkBool32
-  hostImageCopy: VkBool32
-  pushDescriptor: VkBool32
+class VkPhysicalDeviceDescriptorIndexingFeatures:
+    shaderInputAttachmentArrayDynamicIndexing: VkBool32
+    shaderUniformTexelBufferArrayDynamicIndexing: VkBool32
+    shaderStorageTexelBufferArrayDynamicIndexing: VkBool32
+    shaderUniformBufferArrayNonUniformIndexing: VkBool32
+    shaderSampledImageArrayNonUniformIndexing: VkBool32
+    shaderStorageBufferArrayNonUniformIndexing: VkBool32
+    shaderStorageImageArrayNonUniformIndexing: VkBool32
+    shaderInputAttachmentArrayNonUniformIndexing: VkBool32
+    shaderUniformTexelBufferArrayNonUniformIndexing: VkBool32
+    shaderStorageTexelBufferArrayNonUniformIndexing: VkBool32
+    descriptorBindingUniformBufferUpdateAfterBind: VkBool32
+    descriptorBindingSampledImageUpdateAfterBind: VkBool32
+    descriptorBindingStorageImageUpdateAfterBind: VkBool32
+    descriptorBindingStorageBufferUpdateAfterBind: VkBool32
+    descriptorBindingUniformTexelBufferUpdateAfterBind: VkBool32
+    descriptorBindingStorageTexelBufferUpdateAfterBind: VkBool32
+    descriptorBindingUpdateUnusedWhilePending: VkBool32
+    descriptorBindingPartiallyBound: VkBool32
+    descriptorBindingVariableDescriptorCount: VkBool32
+    runtimeDescriptorArray: VkBool32
 
 
 @dataclass
-class VkPhysicalDeviceDriverProperties:
-  driverID: VkDriverId
-  driverName: str
-  driverInfo: str
-  conformanceVersion: ConformanceVersion
+class VkPhysicalDeviceDescriptorIndexingProperties:
+    maxUpdateAfterBindDescriptorsInAllPools: uint32_t
+    shaderUniformBufferArrayNonUniformIndexingNative: VkBool32
+    shaderSampledImageArrayNonUniformIndexingNative: VkBool32
+    shaderStorageBufferArrayNonUniformIndexingNative: VkBool32
+    shaderStorageImageArrayNonUniformIndexingNative: VkBool32
+    shaderInputAttachmentArrayNonUniformIndexingNative: VkBool32
+    robustBufferAccessUpdateAfterBind: VkBool32
+    quadDivergentImplicitLod: VkBool32
+    maxPerStageDescriptorUpdateAfterBindSamplers: uint32_t
+    maxPerStageDescriptorUpdateAfterBindUniformBuffers: uint32_t
+    maxPerStageDescriptorUpdateAfterBindStorageBuffers: uint32_t
+    maxPerStageDescriptorUpdateAfterBindSampledImages: uint32_t
+    maxPerStageDescriptorUpdateAfterBindStorageImages: uint32_t
+    maxPerStageDescriptorUpdateAfterBindInputAttachments: uint32_t
+    maxPerStageUpdateAfterBindResources: uint32_t
+    maxDescriptorSetUpdateAfterBindSamplers: uint32_t
+    maxDescriptorSetUpdateAfterBindUniformBuffers: uint32_t
+    maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: uint32_t
+    maxDescriptorSetUpdateAfterBindStorageBuffers: uint32_t
+    maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: uint32_t
+    maxDescriptorSetUpdateAfterBindSampledImages: uint32_t
+    maxDescriptorSetUpdateAfterBindStorageImages: uint32_t
+    maxDescriptorSetUpdateAfterBindInputAttachments: uint32_t
 
-# Defining alias for structures
-VkPhysicalDeviceLineRasterizationFeaturesEXT = VkPhysicalDeviceLineRasterizationFeatures
-VkPhysicalDeviceLineRasterizationFeaturesKHR = VkPhysicalDeviceLineRasterizationFeatures
-VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR = VkPhysicalDeviceShaderIntegerDotProductFeatures
-VkPhysicalDevice8BitStorageFeaturesKHR = VkPhysicalDevice8BitStorageFeatures
-VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR = VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures
-VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR = VkPhysicalDeviceVertexAttributeDivisorFeatures
-VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT = VkPhysicalDeviceVertexAttributeDivisorFeatures
-VkPhysicalDeviceIndexTypeUint8FeaturesKHR = VkPhysicalDeviceIndexTypeUint8Features
-VkPhysicalDeviceIndexTypeUint8FeaturesEXT = VkPhysicalDeviceIndexTypeUint8Features
-VkPhysicalDeviceVariablePointerFeatures = VkPhysicalDeviceVariablePointersFeatures
-VkPhysicalDeviceVariablePointersFeaturesKHR = VkPhysicalDeviceVariablePointersFeatures
-VkPhysicalDeviceVariablePointerFeaturesKHR = VkPhysicalDeviceVariablePointersFeatures
-VkPhysicalDeviceFloat16Int8FeaturesKHR = VkPhysicalDeviceShaderFloat16Int8Features
-VkPhysicalDeviceShaderFloat16Int8FeaturesKHR = VkPhysicalDeviceShaderFloat16Int8Features
-VkPhysicalDeviceFloatControlsPropertiesKHR = VkPhysicalDeviceFloatControlsProperties
-VkPhysicalDeviceShaderDrawParametersFeatures = VkPhysicalDeviceShaderDrawParameterFeatures
-VkPhysicalDeviceDriverPropertiesKHR = VkPhysicalDeviceDriverProperties
 
-# Defining dependency of structures on extensions
-VULKAN_EXTENSIONS_AND_STRUCTS_MAPPING = {
-  "extensions": {
-    "VK_KHR_variable_pointers": [
-      { "VkPhysicalDeviceVariablePointerFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES" },
-      { "VkPhysicalDeviceVariablePointersFeaturesKHR" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES"},
-    ],
-    "VK_KHR_shader_float16_int8": [
-      { "VkPhysicalDeviceShaderFloat16Int8FeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES" },
-      {"VkPhysicalDeviceFloat16Int8FeaturesKHR" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES"},
-    ],
-    "VK_EXT_image_2d_view_of_3d" : [
-      {"VkPhysicalDeviceImage2DViewOf3DFeaturesEXT" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT"},
-    ],
-    "VK_EXT_custom_border_color" : [
-      {"VkPhysicalDeviceCustomBorderColorFeaturesEXT" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT"},
-    ],
-    "VK_EXT_primitive_topology_list_restart": [
-      {"VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT"},
-    ],
-    "VK_EXT_provoking_vertex" : [
-      {"VkPhysicalDeviceProvokingVertexFeaturesEXT" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT"},
-    ],
-    "VK_KHR_index_type_uint8" : [
-      {"VkPhysicalDeviceIndexTypeUint8FeaturesKHR" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES"},
-    ],
-    "VK_EXT_index_type_uint8"  : [
-      {"VkPhysicalDeviceIndexTypeUint8FeaturesEXT" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES"},
-    ],
-    "VK_KHR_vertex_attribute_divisor" : [
-      {"VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES"},
-    ],
-    "VK_EXT_vertex_attribute_divisor" : [
-      {"VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES"},
-    ],
-    "VK_EXT_transform_feedback" : [
-      {"VkPhysicalDeviceTransformFeedbackFeaturesEXT" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT"},
-    ],
-    "VK_KHR_shader_subgroup_uniform_control_flow" : [
-      {"VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR"},
-    ],
-    "VK_KHR_shader_subgroup_extended_types" : [
-      {"VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES"},
-    ],
-    "VK_KHR_8bit_storage" : [
-      {"VkPhysicalDevice8BitStorageFeaturesKHR" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES"},
-    ],
-    "VK_KHR_shader_integer_dot_product" : [
-      {"VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES"},
-    ],
-    "VK_IMG_relaxed_line_rasterization" : [
-      {"VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG"},
-    ],
-    "VK_KHR_line_rasterization" : [
-      {"VkPhysicalDeviceLineRasterizationFeaturesKHR" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES"},
-    ],
-    "VK_EXT_line_rasterization" : [
-      {"VkPhysicalDeviceLineRasterizationFeaturesEXT" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES"},
-    ],
-    "VK_EXT_primitives_generated_query" : [
-      {"VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT"},
-    ],
-    "VK_KHR_shader_float_controls" : [
-      {"VkPhysicalDeviceFloatControlsPropertiesKHR" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES"},
-    ],
-    "VK_KHR_driver_properties" : [
-      {"VkPhysicalDeviceDriverPropertiesKHR" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES"},
-    ]
-  }
-}
+@dataclass
+class VkPhysicalDeviceTimelineSemaphoreFeatures:
+    timelineSemaphore: VkBool32
 
-# Defining dependency of structures on vulkan cores
-VULKAN_CORES_AND_STRUCTS_MAPPING = {
-  "versions" : {
-    "Core11" : [
-      {"VkPhysicalDeviceVulkan11Properties" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES"},
-      {"VkPhysicalDeviceVulkan11Features" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES"},
-    ],
-    "Core12" : [
-      {"VkPhysicalDeviceVulkan12Properties" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES"},
-      {"VkPhysicalDeviceVulkan12Features" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES"},
-    ],
-    "Core13" : [
-      {"VkPhysicalDeviceVulkan13Properties" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES"},
-      {"VkPhysicalDeviceVulkan13Features" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES"},
-    ],
-    "Core14" : [
-      {"VkPhysicalDeviceVulkan14Properties" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES"},
-      {"VkPhysicalDeviceVulkan14Features" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES"},
-    ]
-  }
-}
 
-# Defining map for list type members mapped to its size
-LIST_TYPE_FIELD_AND_SIZE_MAPPING = {
-  "pCopySrcLayouts": "copySrcLayoutCount",
-  "pCopyDstLayouts": "copyDstLayoutCount",
-  "memoryTypes": "memoryTypeCount",
-  "memoryHeaps": "memoryHeapCount",
-}
+@dataclass
+class VkPhysicalDeviceTimelineSemaphoreProperties:
+    maxTimelineSemaphoreValueDifference: uint64_t
 
-# Defining dependency of structures on vulkan api version
-VULKAN_VERSIONS_AND_STRUCTS_MAPPING = {
-  "VK_VERSION_1_0" : [
-    {"VkPhysicalDeviceProperties" : "" },
-    {"VkPhysicalDeviceFeatures" : ""},
-    {"VkPhysicalDeviceMemoryProperties" : ""},
-  ],
-  "VK_VERSION_1_1" : [
-    {"VkPhysicalDeviceSubgroupProperties" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES"},
-    {"VkPhysicalDevicePointClippingProperties" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES"},
-    {"VkPhysicalDeviceMultiviewProperties" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES"},
-    {"VkPhysicalDeviceIDProperties" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES"},
-    {"VkPhysicalDeviceMaintenance3Properties" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES"},
-    {"VkPhysicalDeviceMultiviewFeatures" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES"},
-    {"VkPhysicalDeviceVariablePointersFeatures" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES"},
-    {"VkPhysicalDeviceProtectedMemoryFeatures" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES"},
-    {"VkPhysicalDeviceSamplerYcbcrConversionFeatures" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES"},
-    {"VkPhysicalDeviceShaderDrawParameterFeatures" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES"},
-    {"VkPhysicalDevice16BitStorageFeatures" : "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES"},
-  ]
-}
 
-# List of structures that are not dependent on extensions
-EXTENSION_INDEPENDENT_STRUCTS = [
-  VkPhysicalDeviceProperties,
-  VkPhysicalDeviceFeatures,
-  VkPhysicalDeviceMemoryProperties,
-  VkPhysicalDeviceSubgroupProperties,
-  VkPhysicalDevicePointClippingProperties,
-  VkPhysicalDeviceMultiviewProperties,
-  VkPhysicalDeviceIDProperties,
-  VkPhysicalDeviceMaintenance3Properties,
-  VkPhysicalDevice16BitStorageFeatures,
-  VkPhysicalDeviceMultiviewFeatures,
-  VkPhysicalDeviceVariablePointersFeatures,
-  VkPhysicalDeviceProtectedMemoryFeatures,
-  VkPhysicalDeviceSamplerYcbcrConversionFeatures,
-  VkPhysicalDeviceShaderDrawParameterFeatures,
-]
+@dataclass
+class VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT:
+    maxVertexAttribDivisor: uint32_t
 
-# List of all the structures for vkjson
-ALL_STRUCTS = [
-  VkPhysicalDeviceFloatControlsPropertiesKHR,
-  VkPhysicalDeviceProperties,
-  VkPhysicalDeviceMemoryProperties,
-  VkPhysicalDeviceSubgroupProperties,
-  VkPhysicalDevicePointClippingProperties,
-  VkPhysicalDeviceMultiviewProperties,
-  VkPhysicalDeviceIDProperties,
-  VkPhysicalDeviceMaintenance3Properties,
-  VkPhysicalDeviceSparseProperties,
-  VkImageFormatProperties,
-  VkQueueFamilyProperties,
-  VkExtensionProperties,
-  VkLayerProperties,
-  VkFormatProperties,
-  VkPhysicalDeviceVariablePointerFeaturesKHR,
-  VkPhysicalDeviceVariablePointersFeaturesKHR,
-  VkPhysicalDeviceShaderFloat16Int8FeaturesKHR,
-  VkPhysicalDeviceFloat16Int8FeaturesKHR,
-  VkPhysicalDeviceImage2DViewOf3DFeaturesEXT,
-  VkPhysicalDeviceCustomBorderColorFeaturesEXT,
-  VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT,
-  VkPhysicalDeviceProvokingVertexFeaturesEXT,
-  VkPhysicalDeviceIndexTypeUint8FeaturesKHR,
-  VkPhysicalDeviceIndexTypeUint8FeaturesEXT,
-  VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR,
-  VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT,
-  VkPhysicalDeviceTransformFeedbackFeaturesEXT,
-  VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR,
-  VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR,
-  VkPhysicalDevice8BitStorageFeaturesKHR,
-  VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR,
-  VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG,
-  VkPhysicalDeviceLineRasterizationFeaturesKHR,
-  VkPhysicalDeviceLineRasterizationFeaturesEXT,
-  VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT,
-  VkPhysicalDevice16BitStorageFeatures,
-  VkPhysicalDeviceMultiviewFeatures,
-  VkPhysicalDeviceProtectedMemoryFeatures,
-  VkPhysicalDeviceSamplerYcbcrConversionFeatures,
-  VkPhysicalDeviceShaderDrawParameterFeatures,
-  VkPhysicalDeviceLimits,
-  VkPhysicalDeviceFeatures,
-  VkPhysicalDeviceVulkan11Properties,
-  VkPhysicalDeviceVulkan11Features,
-  VkPhysicalDeviceVulkan12Properties,
-  VkPhysicalDeviceVulkan12Features,
-  VkPhysicalDeviceVulkan13Properties,
-  VkPhysicalDeviceVulkan13Features,
-  VkPhysicalDeviceVulkan14Properties,
-  VkPhysicalDeviceVulkan14Features,
-  VkPhysicalDeviceDriverProperties,
-]
+
+@dataclass
+class VkPhysicalDeviceVertexAttributeDivisorProperties:
+    maxVertexAttribDivisor: uint32_t
+    supportsNonZeroFirstInstance: VkBool32
+
+
+@dataclass
+class VkPhysicalDevicePCIBusInfoPropertiesEXT:
+    pciDomain: uint32_t
+    pciBus: uint32_t
+    pciDevice: uint32_t
+    pciFunction: uint32_t
+
+
+@dataclass
+class VkPhysicalDevice8BitStorageFeatures:
+    storageBuffer8BitAccess: VkBool32
+    uniformAndStorageBuffer8BitAccess: VkBool32
+    storagePushConstant8: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceConditionalRenderingFeaturesEXT:
+    conditionalRendering: VkBool32
+    inheritedConditionalRendering: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceVulkanMemoryModelFeatures:
+    vulkanMemoryModel: VkBool32
+    vulkanMemoryModelDeviceScope: VkBool32
+    vulkanMemoryModelAvailabilityVisibilityChains: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceShaderAtomicInt64Features:
+    shaderBufferInt64Atomics: VkBool32
+    shaderSharedInt64Atomics: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceShaderAtomicFloatFeaturesEXT:
+    shaderBufferFloat32Atomics: VkBool32
+    shaderBufferFloat32AtomicAdd: VkBool32
+    shaderBufferFloat64Atomics: VkBool32
+    shaderBufferFloat64AtomicAdd: VkBool32
+    shaderSharedFloat32Atomics: VkBool32
+    shaderSharedFloat32AtomicAdd: VkBool32
+    shaderSharedFloat64Atomics: VkBool32
+    shaderSharedFloat64AtomicAdd: VkBool32
+    shaderImageFloat32Atomics: VkBool32
+    shaderImageFloat32AtomicAdd: VkBool32
+    sparseImageFloat32Atomics: VkBool32
+    sparseImageFloat32AtomicAdd: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT:
+    shaderBufferFloat16Atomics: VkBool32
+    shaderBufferFloat16AtomicAdd: VkBool32
+    shaderBufferFloat16AtomicMinMax: VkBool32
+    shaderBufferFloat32AtomicMinMax: VkBool32
+    shaderBufferFloat64AtomicMinMax: VkBool32
+    shaderSharedFloat16Atomics: VkBool32
+    shaderSharedFloat16AtomicAdd: VkBool32
+    shaderSharedFloat16AtomicMinMax: VkBool32
+    shaderSharedFloat32AtomicMinMax: VkBool32
+    shaderSharedFloat64AtomicMinMax: VkBool32
+    shaderImageFloat32AtomicMinMax: VkBool32
+    sparseImageFloat32AtomicMinMax: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceVertexAttributeDivisorFeatures:
+    vertexAttributeInstanceRateDivisor: VkBool32
+    vertexAttributeInstanceRateZeroDivisor: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceDepthStencilResolveProperties:
+    supportedDepthResolveModes: VkResolveModeFlags
+    supportedStencilResolveModes: VkResolveModeFlags
+    independentResolveNone: VkBool32
+    independentResolve: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceASTCDecodeFeaturesEXT:
+    decodeModeSharedExponent: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceTransformFeedbackFeaturesEXT:
+    transformFeedback: VkBool32
+    geometryStreams: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceTransformFeedbackPropertiesEXT:
+    maxTransformFeedbackStreams: uint32_t
+    maxTransformFeedbackBuffers: uint32_t
+    maxTransformFeedbackBufferSize: VkDeviceSize
+    maxTransformFeedbackStreamDataSize: uint32_t
+    maxTransformFeedbackBufferDataSize: uint32_t
+    maxTransformFeedbackBufferDataStride: uint32_t
+    transformFeedbackQueries: VkBool32
+    transformFeedbackStreamsLinesTriangles: VkBool32
+    transformFeedbackRasterizationStreamSelect: VkBool32
+    transformFeedbackDraw: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV:
+    representativeFragmentTest: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceExclusiveScissorFeaturesNV:
+    exclusiveScissor: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceCornerSampledImageFeaturesNV:
+    cornerSampledImage: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceComputeShaderDerivativesFeaturesNV:
+    computeDerivativeGroupQuads: VkBool32
+    computeDerivativeGroupLinear: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceShaderImageFootprintFeaturesNV:
+    imageFootprint: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV:
+    dedicatedAllocationImageAliasing: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceCopyMemoryIndirectFeaturesNV:
+    indirectCopy: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceCopyMemoryIndirectPropertiesNV:
+    supportedQueues: VkQueueFlags
+
+
+@dataclass
+class VkPhysicalDeviceMemoryDecompressionFeaturesNV:
+    memoryDecompression: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceMemoryDecompressionPropertiesNV:
+    decompressionMethods: VkMemoryDecompressionMethodFlagsNV
+    maxDecompressionIndirectCount: uint64_t
+
+
+@dataclass
+class VkPhysicalDeviceShadingRateImageFeaturesNV:
+    shadingRateImage: VkBool32
+    shadingRateCoarseSampleOrder: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceShadingRateImagePropertiesNV:
+    shadingRateTexelSize: VkExtent2D
+    shadingRatePaletteSize: uint32_t
+    shadingRateMaxCoarseSamples: uint32_t
+
+
+@dataclass
+class VkPhysicalDeviceInvocationMaskFeaturesHUAWEI:
+    invocationMask: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceMeshShaderFeaturesNV:
+    taskShader: VkBool32
+    meshShader: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceMeshShaderPropertiesNV:
+    maxDrawMeshTasksCount: uint32_t
+    maxTaskWorkGroupInvocations: uint32_t
+    maxTaskWorkGroupSize: uint32_t * 3
+    maxTaskTotalMemorySize: uint32_t
+    maxTaskOutputCount: uint32_t
+    maxMeshWorkGroupInvocations: uint32_t
+    maxMeshWorkGroupSize: uint32_t * 3
+    maxMeshTotalMemorySize: uint32_t
+    maxMeshOutputVertices: uint32_t
+    maxMeshOutputPrimitives: uint32_t
+    maxMeshMultiviewViewCount: uint32_t
+    meshOutputPerVertexGranularity: uint32_t
+    meshOutputPerPrimitiveGranularity: uint32_t
+
+
+@dataclass
+class VkPhysicalDeviceMeshShaderFeaturesEXT:
+    taskShader: VkBool32
+    meshShader: VkBool32
+    multiviewMeshShader: VkBool32
+    primitiveFragmentShadingRateMeshShader: VkBool32
+    meshShaderQueries: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceMeshShaderPropertiesEXT:
+    maxTaskWorkGroupTotalCount: uint32_t
+    maxTaskWorkGroupCount: uint32_t * 3
+    maxTaskWorkGroupInvocations: uint32_t
+    maxTaskWorkGroupSize: uint32_t * 3
+    maxTaskPayloadSize: uint32_t
+    maxTaskSharedMemorySize: uint32_t
+    maxTaskPayloadAndSharedMemorySize: uint32_t
+    maxMeshWorkGroupTotalCount: uint32_t
+    maxMeshWorkGroupCount: uint32_t * 3
+    maxMeshWorkGroupInvocations: uint32_t
+    maxMeshWorkGroupSize: uint32_t * 3
+    maxMeshSharedMemorySize: uint32_t
+    maxMeshPayloadAndSharedMemorySize: uint32_t
+    maxMeshOutputMemorySize: uint32_t
+    maxMeshPayloadAndOutputMemorySize: uint32_t
+    maxMeshOutputComponents: uint32_t
+    maxMeshOutputVertices: uint32_t
+    maxMeshOutputPrimitives: uint32_t
+    maxMeshOutputLayers: uint32_t
+    maxMeshMultiviewViewCount: uint32_t
+    meshOutputPerVertexGranularity: uint32_t
+    meshOutputPerPrimitiveGranularity: uint32_t
+    maxPreferredTaskWorkGroupInvocations: uint32_t
+    maxPreferredMeshWorkGroupInvocations: uint32_t
+    prefersLocalInvocationVertexOutput: VkBool32
+    prefersLocalInvocationPrimitiveOutput: VkBool32
+    prefersCompactVertexOutput: VkBool32
+    prefersCompactPrimitiveOutput: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceAccelerationStructureFeaturesKHR:
+    accelerationStructure: VkBool32
+    accelerationStructureCaptureReplay: VkBool32
+    accelerationStructureIndirectBuild: VkBool32
+    accelerationStructureHostCommands: VkBool32
+    descriptorBindingAccelerationStructureUpdateAfterBind: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceRayTracingPipelineFeaturesKHR:
+    rayTracingPipeline: VkBool32
+    rayTracingPipelineShaderGroupHandleCaptureReplay: VkBool32
+    rayTracingPipelineShaderGroupHandleCaptureReplayMixed: VkBool32
+    rayTracingPipelineTraceRaysIndirect: VkBool32
+    rayTraversalPrimitiveCulling: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceRayQueryFeaturesKHR:
+    rayQuery: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceAccelerationStructurePropertiesKHR:
+    maxGeometryCount: uint64_t
+    maxInstanceCount: uint64_t
+    maxPrimitiveCount: uint64_t
+    maxPerStageDescriptorAccelerationStructures: uint32_t
+    maxPerStageDescriptorUpdateAfterBindAccelerationStructures: uint32_t
+    maxDescriptorSetAccelerationStructures: uint32_t
+    maxDescriptorSetUpdateAfterBindAccelerationStructures: uint32_t
+    minAccelerationStructureScratchOffsetAlignment: uint32_t
+
+
+@dataclass
+class VkPhysicalDeviceRayTracingPipelinePropertiesKHR:
+    shaderGroupHandleSize: uint32_t
+    maxRayRecursionDepth: uint32_t
+    maxShaderGroupStride: uint32_t
+    shaderGroupBaseAlignment: uint32_t
+    shaderGroupHandleCaptureReplaySize: uint32_t
+    maxRayDispatchInvocationCount: uint32_t
+    shaderGroupHandleAlignment: uint32_t
+    maxRayHitAttributeSize: uint32_t
+
+
+@dataclass
+class VkPhysicalDeviceRayTracingPropertiesNV:
+    shaderGroupHandleSize: uint32_t
+    maxRecursionDepth: uint32_t
+    maxShaderGroupStride: uint32_t
+    shaderGroupBaseAlignment: uint32_t
+    maxGeometryCount: uint64_t
+    maxInstanceCount: uint64_t
+    maxTriangleCount: uint64_t
+    maxDescriptorSetAccelerationStructures: uint32_t
+
+
+@dataclass
+class VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR:
+    rayTracingMaintenance1: VkBool32
+    rayTracingPipelineTraceRaysIndirect2: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceFragmentDensityMapFeaturesEXT:
+    fragmentDensityMap: VkBool32
+    fragmentDensityMapDynamic: VkBool32
+    fragmentDensityMapNonSubsampledImages: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceFragmentDensityMap2FeaturesEXT:
+    fragmentDensityMapDeferred: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM:
+    fragmentDensityMapOffset: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceFragmentDensityMapPropertiesEXT:
+    minFragmentDensityTexelSize: VkExtent2D
+    maxFragmentDensityTexelSize: VkExtent2D
+    fragmentDensityInvocations: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceFragmentDensityMap2PropertiesEXT:
+    subsampledLoads: VkBool32
+    subsampledCoarseReconstructionEarlyAccess: VkBool32
+    maxSubsampledArrayLayers: uint32_t
+    maxDescriptorSetSubsampledSamplers: uint32_t
+
+
+@dataclass
+class VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM:
+    fragmentDensityOffsetGranularity: VkExtent2D
+
+
+@dataclass
+class VkPhysicalDeviceScalarBlockLayoutFeatures:
+    scalarBlockLayout: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceUniformBufferStandardLayoutFeatures:
+    uniformBufferStandardLayout: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceDepthClipEnableFeaturesEXT:
+    depthClipEnable: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceMemoryPriorityFeaturesEXT:
+    memoryPriority: VkBool32
+
+
+@dataclass
+class VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT:
+    pageableDeviceLocalMemory: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceBufferDeviceAddressFeatures:
+    bufferDeviceAddress: VkBool32
+    bufferDeviceAddressCaptureReplay: VkBool32
+    bufferDeviceAddressMultiDevice: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceBufferDeviceAddressFeaturesEXT:
+    bufferDeviceAddress: VkBool32
+    bufferDeviceAddressCaptureReplay: VkBool32
+    bufferDeviceAddressMultiDevice: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceImagelessFramebufferFeatures:
+    imagelessFramebuffer: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceTextureCompressionASTCHDRFeatures:
+    textureCompressionASTC_HDR: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceCooperativeMatrixFeaturesNV:
+    cooperativeMatrix: VkBool32
+    cooperativeMatrixRobustBufferAccess: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceCooperativeMatrixPropertiesNV:
+    cooperativeMatrixSupportedStages: VkShaderStageFlags
+
+
+@dataclass
+class VkPhysicalDeviceYcbcrImageArraysFeaturesEXT:
+    ycbcrImageArrays: VkBool32
+
+
+@dataclass
+class VkPhysicalDevicePresentBarrierFeaturesNV:
+    presentBarrier: VkBool32
+
+
+@dataclass
+class VkPhysicalDevicePerformanceQueryFeaturesKHR:
+    performanceCounterQueryPools: VkBool32
+    performanceCounterMultipleQueryPools: VkBool32
+
+
+@dataclass
+class VkPhysicalDevicePerformanceQueryPropertiesKHR:
+    allowCommandBufferQueryCopies: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceCoverageReductionModeFeaturesNV:
+    coverageReductionMode: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL:
+    shaderIntegerFunctions2: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceShaderClockFeaturesKHR:
+    shaderSubgroupClock: VkBool32
+    shaderDeviceClock: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceIndexTypeUint8Features:
+    indexTypeUint8: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceShaderSMBuiltinsPropertiesNV:
+    shaderSMCount: uint32_t
+    shaderWarpsPerSM: uint32_t
+
+
+@dataclass
+class VkPhysicalDeviceShaderSMBuiltinsFeaturesNV:
+    shaderSMBuiltins: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT:
+    fragmentShaderSampleInterlock: VkBool32
+    fragmentShaderPixelInterlock: VkBool32
+    fragmentShaderShadingRateInterlock: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures:
+    separateDepthStencilLayouts: VkBool32
+
+
+@dataclass
+class VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT:
+    primitiveTopologyListRestart: VkBool32
+    primitiveTopologyPatchListRestart: VkBool32
+
+
+@dataclass
+class VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR:
+    pipelineExecutableInfo: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures:
+    shaderDemoteToHelperInvocation: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT:
+    texelBufferAlignment: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceTexelBufferAlignmentProperties:
+    storageTexelBufferOffsetAlignmentBytes: VkDeviceSize
+    storageTexelBufferOffsetSingleTexelAlignment: VkBool32
+    uniformTexelBufferOffsetAlignmentBytes: VkDeviceSize
+    uniformTexelBufferOffsetSingleTexelAlignment: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceSubgroupSizeControlFeatures:
+    subgroupSizeControl: VkBool32
+    computeFullSubgroups: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceSubgroupSizeControlProperties:
+    minSubgroupSize: uint32_t
+    maxSubgroupSize: uint32_t
+    maxComputeWorkgroupSubgroups: uint32_t
+    requiredSubgroupSizeStages: VkShaderStageFlags
+
+
+@dataclass
+class VkPhysicalDeviceSubpassShadingPropertiesHUAWEI:
+    maxSubpassShadingWorkgroupSizeAspectRatio: uint32_t
+
+
+@dataclass
+class VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI:
+    maxWorkGroupCount: uint32_t * 3
+    maxWorkGroupSize: uint32_t * 3
+    maxOutputClusterCount: uint32_t
+    indirectBufferOffsetAlignment: VkDeviceSize
+
+
+@dataclass
+class VkPhysicalDeviceLineRasterizationFeatures:
+    rectangularLines: VkBool32
+    bresenhamLines: VkBool32
+    smoothLines: VkBool32
+    stippledRectangularLines: VkBool32
+    stippledBresenhamLines: VkBool32
+    stippledSmoothLines: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceLineRasterizationProperties:
+    lineSubPixelPrecisionBits: uint32_t
+
+
+@dataclass
+class VkPhysicalDevicePipelineCreationCacheControlFeatures:
+    pipelineCreationCacheControl: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceVulkan11Features:
+    storageBuffer16BitAccess: VkBool32
+    uniformAndStorageBuffer16BitAccess: VkBool32
+    storagePushConstant16: VkBool32
+    storageInputOutput16: VkBool32
+    multiview: VkBool32
+    multiviewGeometryShader: VkBool32
+    multiviewTessellationShader: VkBool32
+    variablePointersStorageBuffer: VkBool32
+    variablePointers: VkBool32
+    protectedMemory: VkBool32
+    samplerYcbcrConversion: VkBool32
+    shaderDrawParameters: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceVulkan11Properties:
+    deviceUUID: uint8_t * VK_UUID_SIZE
+    driverUUID: uint8_t * VK_UUID_SIZE
+    deviceLUID: uint8_t * VK_LUID_SIZE
+    deviceNodeMask: uint32_t
+    deviceLUIDValid: VkBool32
+    subgroupSize: uint32_t
+    subgroupSupportedStages: VkShaderStageFlags
+    subgroupSupportedOperations: VkSubgroupFeatureFlags
+    subgroupQuadOperationsInAllStages: VkBool32
+    pointClippingBehavior: VkPointClippingBehavior
+    maxMultiviewViewCount: uint32_t
+    maxMultiviewInstanceIndex: uint32_t
+    protectedNoFault: VkBool32
+    maxPerSetDescriptors: uint32_t
+    maxMemoryAllocationSize: VkDeviceSize
+
+
+@dataclass
+class VkPhysicalDeviceVulkan12Features:
+    samplerMirrorClampToEdge: VkBool32
+    drawIndirectCount: VkBool32
+    storageBuffer8BitAccess: VkBool32
+    uniformAndStorageBuffer8BitAccess: VkBool32
+    storagePushConstant8: VkBool32
+    shaderBufferInt64Atomics: VkBool32
+    shaderSharedInt64Atomics: VkBool32
+    shaderFloat16: VkBool32
+    shaderInt8: VkBool32
+    descriptorIndexing: VkBool32
+    shaderInputAttachmentArrayDynamicIndexing: VkBool32
+    shaderUniformTexelBufferArrayDynamicIndexing: VkBool32
+    shaderStorageTexelBufferArrayDynamicIndexing: VkBool32
+    shaderUniformBufferArrayNonUniformIndexing: VkBool32
+    shaderSampledImageArrayNonUniformIndexing: VkBool32
+    shaderStorageBufferArrayNonUniformIndexing: VkBool32
+    shaderStorageImageArrayNonUniformIndexing: VkBool32
+    shaderInputAttachmentArrayNonUniformIndexing: VkBool32
+    shaderUniformTexelBufferArrayNonUniformIndexing: VkBool32
+    shaderStorageTexelBufferArrayNonUniformIndexing: VkBool32
+    descriptorBindingUniformBufferUpdateAfterBind: VkBool32
+    descriptorBindingSampledImageUpdateAfterBind: VkBool32
+    descriptorBindingStorageImageUpdateAfterBind: VkBool32
+    descriptorBindingStorageBufferUpdateAfterBind: VkBool32
+    descriptorBindingUniformTexelBufferUpdateAfterBind: VkBool32
+    descriptorBindingStorageTexelBufferUpdateAfterBind: VkBool32
+    descriptorBindingUpdateUnusedWhilePending: VkBool32
+    descriptorBindingPartiallyBound: VkBool32
+    descriptorBindingVariableDescriptorCount: VkBool32
+    runtimeDescriptorArray: VkBool32
+    samplerFilterMinmax: VkBool32
+    scalarBlockLayout: VkBool32
+    imagelessFramebuffer: VkBool32
+    uniformBufferStandardLayout: VkBool32
+    shaderSubgroupExtendedTypes: VkBool32
+    separateDepthStencilLayouts: VkBool32
+    hostQueryReset: VkBool32
+    timelineSemaphore: VkBool32
+    bufferDeviceAddress: VkBool32
+    bufferDeviceAddressCaptureReplay: VkBool32
+    bufferDeviceAddressMultiDevice: VkBool32
+    vulkanMemoryModel: VkBool32
+    vulkanMemoryModelDeviceScope: VkBool32
+    vulkanMemoryModelAvailabilityVisibilityChains: VkBool32
+    shaderOutputViewportIndex: VkBool32
+    shaderOutputLayer: VkBool32
+    subgroupBroadcastDynamicId: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceVulkan12Properties:
+    driverID: VkDriverId
+    driverName: str
+    driverInfo: str
+    conformanceVersion: VkConformanceVersion
+    denormBehaviorIndependence: VkShaderFloatControlsIndependence
+    roundingModeIndependence: VkShaderFloatControlsIndependence
+    shaderSignedZeroInfNanPreserveFloat16: VkBool32
+    shaderSignedZeroInfNanPreserveFloat32: VkBool32
+    shaderSignedZeroInfNanPreserveFloat64: VkBool32
+    shaderDenormPreserveFloat16: VkBool32
+    shaderDenormPreserveFloat32: VkBool32
+    shaderDenormPreserveFloat64: VkBool32
+    shaderDenormFlushToZeroFloat16: VkBool32
+    shaderDenormFlushToZeroFloat32: VkBool32
+    shaderDenormFlushToZeroFloat64: VkBool32
+    shaderRoundingModeRTEFloat16: VkBool32
+    shaderRoundingModeRTEFloat32: VkBool32
+    shaderRoundingModeRTEFloat64: VkBool32
+    shaderRoundingModeRTZFloat16: VkBool32
+    shaderRoundingModeRTZFloat32: VkBool32
+    shaderRoundingModeRTZFloat64: VkBool32
+    maxUpdateAfterBindDescriptorsInAllPools: uint32_t
+    shaderUniformBufferArrayNonUniformIndexingNative: VkBool32
+    shaderSampledImageArrayNonUniformIndexingNative: VkBool32
+    shaderStorageBufferArrayNonUniformIndexingNative: VkBool32
+    shaderStorageImageArrayNonUniformIndexingNative: VkBool32
+    shaderInputAttachmentArrayNonUniformIndexingNative: VkBool32
+    robustBufferAccessUpdateAfterBind: VkBool32
+    quadDivergentImplicitLod: VkBool32
+    maxPerStageDescriptorUpdateAfterBindSamplers: uint32_t
+    maxPerStageDescriptorUpdateAfterBindUniformBuffers: uint32_t
+    maxPerStageDescriptorUpdateAfterBindStorageBuffers: uint32_t
+    maxPerStageDescriptorUpdateAfterBindSampledImages: uint32_t
+    maxPerStageDescriptorUpdateAfterBindStorageImages: uint32_t
+    maxPerStageDescriptorUpdateAfterBindInputAttachments: uint32_t
+    maxPerStageUpdateAfterBindResources: uint32_t
+    maxDescriptorSetUpdateAfterBindSamplers: uint32_t
+    maxDescriptorSetUpdateAfterBindUniformBuffers: uint32_t
+    maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: uint32_t
+    maxDescriptorSetUpdateAfterBindStorageBuffers: uint32_t
+    maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: uint32_t
+    maxDescriptorSetUpdateAfterBindSampledImages: uint32_t
+    maxDescriptorSetUpdateAfterBindStorageImages: uint32_t
+    maxDescriptorSetUpdateAfterBindInputAttachments: uint32_t
+    supportedDepthResolveModes: VkResolveModeFlags
+    supportedStencilResolveModes: VkResolveModeFlags
+    independentResolveNone: VkBool32
+    independentResolve: VkBool32
+    filterMinmaxSingleComponentFormats: VkBool32
+    filterMinmaxImageComponentMapping: VkBool32
+    maxTimelineSemaphoreValueDifference: uint64_t
+    framebufferIntegerColorSampleCounts: VkSampleCountFlags
+
+
+@dataclass
+class VkPhysicalDeviceVulkan13Features:
+    robustImageAccess: VkBool32
+    inlineUniformBlock: VkBool32
+    descriptorBindingInlineUniformBlockUpdateAfterBind: VkBool32
+    pipelineCreationCacheControl: VkBool32
+    privateData: VkBool32
+    shaderDemoteToHelperInvocation: VkBool32
+    shaderTerminateInvocation: VkBool32
+    subgroupSizeControl: VkBool32
+    computeFullSubgroups: VkBool32
+    synchronization2: VkBool32
+    textureCompressionASTC_HDR: VkBool32
+    shaderZeroInitializeWorkgroupMemory: VkBool32
+    dynamicRendering: VkBool32
+    shaderIntegerDotProduct: VkBool32
+    maintenance4: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceVulkan13Properties:
+    minSubgroupSize: uint32_t
+    maxSubgroupSize: uint32_t
+    maxComputeWorkgroupSubgroups: uint32_t
+    requiredSubgroupSizeStages: VkShaderStageFlags
+    maxInlineUniformBlockSize: uint32_t
+    maxPerStageDescriptorInlineUniformBlocks: uint32_t
+    maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks: uint32_t
+    maxDescriptorSetInlineUniformBlocks: uint32_t
+    maxDescriptorSetUpdateAfterBindInlineUniformBlocks: uint32_t
+    maxInlineUniformTotalSize: uint32_t
+    integerDotProduct8BitUnsignedAccelerated: VkBool32
+    integerDotProduct8BitSignedAccelerated: VkBool32
+    integerDotProduct8BitMixedSignednessAccelerated: VkBool32
+    integerDotProduct4x8BitPackedUnsignedAccelerated: VkBool32
+    integerDotProduct4x8BitPackedSignedAccelerated: VkBool32
+    integerDotProduct4x8BitPackedMixedSignednessAccelerated: VkBool32
+    integerDotProduct16BitUnsignedAccelerated: VkBool32
+    integerDotProduct16BitSignedAccelerated: VkBool32
+    integerDotProduct16BitMixedSignednessAccelerated: VkBool32
+    integerDotProduct32BitUnsignedAccelerated: VkBool32
+    integerDotProduct32BitSignedAccelerated: VkBool32
+    integerDotProduct32BitMixedSignednessAccelerated: VkBool32
+    integerDotProduct64BitUnsignedAccelerated: VkBool32
+    integerDotProduct64BitSignedAccelerated: VkBool32
+    integerDotProduct64BitMixedSignednessAccelerated: VkBool32
+    integerDotProductAccumulatingSaturating8BitUnsignedAccelerated: VkBool32
+    integerDotProductAccumulatingSaturating8BitSignedAccelerated: VkBool32
+    integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated: VkBool32
+    integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated: VkBool32
+    integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated: VkBool32
+    integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated: VkBool32
+    integerDotProductAccumulatingSaturating16BitUnsignedAccelerated: VkBool32
+    integerDotProductAccumulatingSaturating16BitSignedAccelerated: VkBool32
+    integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated: VkBool32
+    integerDotProductAccumulatingSaturating32BitUnsignedAccelerated: VkBool32
+    integerDotProductAccumulatingSaturating32BitSignedAccelerated: VkBool32
+    integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated: VkBool32
+    integerDotProductAccumulatingSaturating64BitUnsignedAccelerated: VkBool32
+    integerDotProductAccumulatingSaturating64BitSignedAccelerated: VkBool32
+    integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated: VkBool32
+    storageTexelBufferOffsetAlignmentBytes: VkDeviceSize
+    storageTexelBufferOffsetSingleTexelAlignment: VkBool32
+    uniformTexelBufferOffsetAlignmentBytes: VkDeviceSize
+    uniformTexelBufferOffsetSingleTexelAlignment: VkBool32
+    maxBufferSize: VkDeviceSize
+
+
+@dataclass
+class VkPhysicalDeviceVulkan14Features:
+    globalPriorityQuery: VkBool32
+    shaderSubgroupRotate: VkBool32
+    shaderSubgroupRotateClustered: VkBool32
+    shaderFloatControls2: VkBool32
+    shaderExpectAssume: VkBool32
+    rectangularLines: VkBool32
+    bresenhamLines: VkBool32
+    smoothLines: VkBool32
+    stippledRectangularLines: VkBool32
+    stippledBresenhamLines: VkBool32
+    stippledSmoothLines: VkBool32
+    vertexAttributeInstanceRateDivisor: VkBool32
+    vertexAttributeInstanceRateZeroDivisor: VkBool32
+    indexTypeUint8: VkBool32
+    dynamicRenderingLocalRead: VkBool32
+    maintenance5: VkBool32
+    maintenance6: VkBool32
+    pipelineProtectedAccess: VkBool32
+    pipelineRobustness: VkBool32
+    hostImageCopy: VkBool32
+    pushDescriptor: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceVulkan14Properties:
+    lineSubPixelPrecisionBits: uint32_t
+    maxVertexAttribDivisor: uint32_t
+    supportsNonZeroFirstInstance: VkBool32
+    maxPushDescriptors: uint32_t
+    dynamicRenderingLocalReadDepthStencilAttachments: VkBool32
+    dynamicRenderingLocalReadMultisampledAttachments: VkBool32
+    earlyFragmentMultisampleCoverageAfterSampleCounting: VkBool32
+    earlyFragmentSampleMaskTestBeforeSampleCounting: VkBool32
+    depthStencilSwizzleOneSupport: VkBool32
+    polygonModePointSize: VkBool32
+    nonStrictSinglePixelWideLinesUseParallelogram: VkBool32
+    nonStrictWideLinesUseParallelogram: VkBool32
+    blockTexelViewCompatibleMultipleLayers: VkBool32
+    maxCombinedImageSamplerDescriptorCount: uint32_t
+    fragmentShadingRateClampCombinerInputs: VkBool32
+    defaultRobustnessStorageBuffers: VkPipelineRobustnessBufferBehavior
+    defaultRobustnessUniformBuffers: VkPipelineRobustnessBufferBehavior
+    defaultRobustnessVertexInputs: VkPipelineRobustnessBufferBehavior
+    defaultRobustnessImages: VkPipelineRobustnessImageBehavior
+    copySrcLayoutCount: uint32_t
+    pCopySrcLayouts: List[VkImageLayout]
+    copyDstLayoutCount: uint32_t
+    pCopyDstLayouts: List[VkImageLayout]
+    optimalTilingLayoutUUID: uint8_t * VK_UUID_SIZE
+    identicalMemoryTypeRequirements: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceCoherentMemoryFeaturesAMD:
+    deviceCoherentMemory: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceToolProperties:
+    name: str
+    version: str
+    purposes: VkToolPurposeFlags
+    description: str
+    layer: str
+
+
+@dataclass
+class VkPhysicalDeviceCustomBorderColorPropertiesEXT:
+    maxCustomBorderColorSamplers: uint32_t
+
+
+@dataclass
+class VkPhysicalDeviceCustomBorderColorFeaturesEXT:
+    customBorderColors: VkBool32
+    customBorderColorWithoutFormat: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceBorderColorSwizzleFeaturesEXT:
+    borderColorSwizzle: VkBool32
+    borderColorSwizzleFromImage: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceExtendedDynamicStateFeaturesEXT:
+    extendedDynamicState: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceExtendedDynamicState2FeaturesEXT:
+    extendedDynamicState2: VkBool32
+    extendedDynamicState2LogicOp: VkBool32
+    extendedDynamicState2PatchControlPoints: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceExtendedDynamicState3FeaturesEXT:
+    extendedDynamicState3TessellationDomainOrigin: VkBool32
+    extendedDynamicState3DepthClampEnable: VkBool32
+    extendedDynamicState3PolygonMode: VkBool32
+    extendedDynamicState3RasterizationSamples: VkBool32
+    extendedDynamicState3SampleMask: VkBool32
+    extendedDynamicState3AlphaToCoverageEnable: VkBool32
+    extendedDynamicState3AlphaToOneEnable: VkBool32
+    extendedDynamicState3LogicOpEnable: VkBool32
+    extendedDynamicState3ColorBlendEnable: VkBool32
+    extendedDynamicState3ColorBlendEquation: VkBool32
+    extendedDynamicState3ColorWriteMask: VkBool32
+    extendedDynamicState3RasterizationStream: VkBool32
+    extendedDynamicState3ConservativeRasterizationMode: VkBool32
+    extendedDynamicState3ExtraPrimitiveOverestimationSize: VkBool32
+    extendedDynamicState3DepthClipEnable: VkBool32
+    extendedDynamicState3SampleLocationsEnable: VkBool32
+    extendedDynamicState3ColorBlendAdvanced: VkBool32
+    extendedDynamicState3ProvokingVertexMode: VkBool32
+    extendedDynamicState3LineRasterizationMode: VkBool32
+    extendedDynamicState3LineStippleEnable: VkBool32
+    extendedDynamicState3DepthClipNegativeOneToOne: VkBool32
+    extendedDynamicState3ViewportWScalingEnable: VkBool32
+    extendedDynamicState3ViewportSwizzle: VkBool32
+    extendedDynamicState3CoverageToColorEnable: VkBool32
+    extendedDynamicState3CoverageToColorLocation: VkBool32
+    extendedDynamicState3CoverageModulationMode: VkBool32
+    extendedDynamicState3CoverageModulationTableEnable: VkBool32
+    extendedDynamicState3CoverageModulationTable: VkBool32
+    extendedDynamicState3CoverageReductionMode: VkBool32
+    extendedDynamicState3RepresentativeFragmentTestEnable: VkBool32
+    extendedDynamicState3ShadingRateImageEnable: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceExtendedDynamicState3PropertiesEXT:
+    dynamicPrimitiveTopologyUnrestricted: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceDiagnosticsConfigFeaturesNV:
+    diagnosticsConfig: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures:
+    shaderZeroInitializeWorkgroupMemory: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR:
+    shaderSubgroupUniformControlFlow: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceRobustness2FeaturesEXT:
+    robustBufferAccess2: VkBool32
+    robustImageAccess2: VkBool32
+    nullDescriptor: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceRobustness2PropertiesEXT:
+    robustStorageBufferAccessSizeAlignment: VkDeviceSize
+    robustUniformBufferAccessSizeAlignment: VkDeviceSize
+
+
+@dataclass
+class VkPhysicalDeviceImageRobustnessFeatures:
+    robustImageAccess: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR:
+    workgroupMemoryExplicitLayout: VkBool32
+    workgroupMemoryExplicitLayoutScalarBlockLayout: VkBool32
+    workgroupMemoryExplicitLayout8BitAccess: VkBool32
+    workgroupMemoryExplicitLayout16BitAccess: VkBool32
+
+
+@dataclass
+class VkPhysicalDevice4444FormatsFeaturesEXT:
+    formatA4R4G4B4: VkBool32
+    formatA4B4G4R4: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceSubpassShadingFeaturesHUAWEI:
+    subpassShading: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI:
+    clustercullingShader: VkBool32
+    multiviewClusterCullingShader: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT:
+    shaderImageInt64Atomics: VkBool32
+    sparseImageInt64Atomics: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceFragmentShadingRateFeaturesKHR:
+    pipelineFragmentShadingRate: VkBool32
+    primitiveFragmentShadingRate: VkBool32
+    attachmentFragmentShadingRate: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceFragmentShadingRatePropertiesKHR:
+    minFragmentShadingRateAttachmentTexelSize: VkExtent2D
+    maxFragmentShadingRateAttachmentTexelSize: VkExtent2D
+    maxFragmentShadingRateAttachmentTexelSizeAspectRatio: uint32_t
+    primitiveFragmentShadingRateWithMultipleViewports: VkBool32
+    layeredShadingRateAttachments: VkBool32
+    fragmentShadingRateNonTrivialCombinerOps: VkBool32
+    maxFragmentSize: VkExtent2D
+    maxFragmentSizeAspectRatio: uint32_t
+    maxFragmentShadingRateCoverageSamples: uint32_t
+    maxFragmentShadingRateRasterizationSamples: VkSampleCountFlagBits
+    fragmentShadingRateWithShaderDepthStencilWrites: VkBool32
+    fragmentShadingRateWithSampleMask: VkBool32
+    fragmentShadingRateWithShaderSampleMask: VkBool32
+    fragmentShadingRateWithConservativeRasterization: VkBool32
+    fragmentShadingRateWithFragmentShaderInterlock: VkBool32
+    fragmentShadingRateWithCustomSampleLocations: VkBool32
+    fragmentShadingRateStrictMultiplyCombiner: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceShaderTerminateInvocationFeatures:
+    shaderTerminateInvocation: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV:
+    fragmentShadingRateEnums: VkBool32
+    supersampleFragmentShadingRates: VkBool32
+    noInvocationFragmentShadingRates: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV:
+    maxFragmentShadingRateInvocationCount: VkSampleCountFlagBits
+
+
+@dataclass
+class VkPhysicalDeviceImage2DViewOf3DFeaturesEXT:
+    image2DViewOf3D: VkBool32
+    sampler2DViewOf3D: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT:
+    imageSlicedViewOf3D: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT:
+    attachmentFeedbackLoopDynamicState: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT:
+    legacyVertexAttributes: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT:
+    nativeUnalignedPerformance: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT:
+    mutableDescriptorType: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceDepthClipControlFeaturesEXT:
+    depthClipControl: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT:
+    vertexInputDynamicState: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceExternalMemoryRDMAFeaturesNV:
+    externalMemoryRDMA: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR:
+    shaderRelaxedExtendedInstruction: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceColorWriteEnableFeaturesEXT:
+    colorWriteEnable: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceSynchronization2Features:
+    synchronization2: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceHostImageCopyFeatures:
+    hostImageCopy: VkBool32
+
+
+@dataclass
+class VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT:
+    primitivesGeneratedQuery: VkBool32
+    primitivesGeneratedQueryWithRasterizerDiscard: VkBool32
+    primitivesGeneratedQueryWithNonZeroStreams: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceLegacyDitheringFeaturesEXT:
+    legacyDithering: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT:
+    multisampledRenderToSingleSampled: VkBool32
+
+
+@dataclass
+class VkPhysicalDevicePipelineProtectedAccessFeatures:
+    pipelineProtectedAccess: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceVideoMaintenance1FeaturesKHR:
+    videoMaintenance1: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceInheritedViewportScissorFeaturesNV:
+    inheritedViewportScissor2D: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT:
+    ycbcr2plane444Formats: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceProvokingVertexFeaturesEXT:
+    provokingVertexLast: VkBool32
+    transformFeedbackPreservesProvokingVertex: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceProvokingVertexPropertiesEXT:
+    provokingVertexModePerPipeline: VkBool32
+    transformFeedbackPreservesTriangleFanProvokingVertex: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceDescriptorBufferFeaturesEXT:
+    descriptorBuffer: VkBool32
+    descriptorBufferCaptureReplay: VkBool32
+    descriptorBufferImageLayoutIgnored: VkBool32
+    descriptorBufferPushDescriptors: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceDescriptorBufferPropertiesEXT:
+    combinedImageSamplerDescriptorSingleArray: VkBool32
+    bufferlessPushDescriptors: VkBool32
+    allowSamplerImageViewPostSubmitCreation: VkBool32
+    descriptorBufferOffsetAlignment: VkDeviceSize
+    maxDescriptorBufferBindings: uint32_t
+    maxResourceDescriptorBufferBindings: uint32_t
+    maxSamplerDescriptorBufferBindings: uint32_t
+    maxEmbeddedImmutableSamplerBindings: uint32_t
+    maxEmbeddedImmutableSamplers: uint32_t
+    bufferCaptureReplayDescriptorDataSize: size_t
+    imageCaptureReplayDescriptorDataSize: size_t
+    imageViewCaptureReplayDescriptorDataSize: size_t
+    samplerCaptureReplayDescriptorDataSize: size_t
+    accelerationStructureCaptureReplayDescriptorDataSize: size_t
+    samplerDescriptorSize: size_t
+    combinedImageSamplerDescriptorSize: size_t
+    sampledImageDescriptorSize: size_t
+    storageImageDescriptorSize: size_t
+    uniformTexelBufferDescriptorSize: size_t
+    robustUniformTexelBufferDescriptorSize: size_t
+    storageTexelBufferDescriptorSize: size_t
+    robustStorageTexelBufferDescriptorSize: size_t
+    uniformBufferDescriptorSize: size_t
+    robustUniformBufferDescriptorSize: size_t
+    storageBufferDescriptorSize: size_t
+    robustStorageBufferDescriptorSize: size_t
+    inputAttachmentDescriptorSize: size_t
+    accelerationStructureDescriptorSize: size_t
+    maxSamplerDescriptorBufferRange: VkDeviceSize
+    maxResourceDescriptorBufferRange: VkDeviceSize
+    samplerDescriptorBufferAddressSpaceSize: VkDeviceSize
+    resourceDescriptorBufferAddressSpaceSize: VkDeviceSize
+    descriptorBufferAddressSpaceSize: VkDeviceSize
+
+
+@dataclass
+class VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT:
+    combinedImageSamplerDensityMapDescriptorSize: size_t
+
+
+@dataclass
+class VkPhysicalDeviceShaderIntegerDotProductFeatures:
+    shaderIntegerDotProduct: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceShaderIntegerDotProductProperties:
+    integerDotProduct8BitUnsignedAccelerated: VkBool32
+    integerDotProduct8BitSignedAccelerated: VkBool32
+    integerDotProduct8BitMixedSignednessAccelerated: VkBool32
+    integerDotProduct4x8BitPackedUnsignedAccelerated: VkBool32
+    integerDotProduct4x8BitPackedSignedAccelerated: VkBool32
+    integerDotProduct4x8BitPackedMixedSignednessAccelerated: VkBool32
+    integerDotProduct16BitUnsignedAccelerated: VkBool32
+    integerDotProduct16BitSignedAccelerated: VkBool32
+    integerDotProduct16BitMixedSignednessAccelerated: VkBool32
+    integerDotProduct32BitUnsignedAccelerated: VkBool32
+    integerDotProduct32BitSignedAccelerated: VkBool32
+    integerDotProduct32BitMixedSignednessAccelerated: VkBool32
+    integerDotProduct64BitUnsignedAccelerated: VkBool32
+    integerDotProduct64BitSignedAccelerated: VkBool32
+    integerDotProduct64BitMixedSignednessAccelerated: VkBool32
+    integerDotProductAccumulatingSaturating8BitUnsignedAccelerated: VkBool32
+    integerDotProductAccumulatingSaturating8BitSignedAccelerated: VkBool32
+    integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated: VkBool32
+    integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated: VkBool32
+    integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated: VkBool32
+    integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated: VkBool32
+    integerDotProductAccumulatingSaturating16BitUnsignedAccelerated: VkBool32
+    integerDotProductAccumulatingSaturating16BitSignedAccelerated: VkBool32
+    integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated: VkBool32
+    integerDotProductAccumulatingSaturating32BitUnsignedAccelerated: VkBool32
+    integerDotProductAccumulatingSaturating32BitSignedAccelerated: VkBool32
+    integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated: VkBool32
+    integerDotProductAccumulatingSaturating64BitUnsignedAccelerated: VkBool32
+    integerDotProductAccumulatingSaturating64BitSignedAccelerated: VkBool32
+    integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceDrmPropertiesEXT:
+    hasPrimary: VkBool32
+    hasRender: VkBool32
+    primaryMajor: int64_t
+    primaryMinor: int64_t
+    renderMajor: int64_t
+    renderMinor: int64_t
+
+
+@dataclass
+class VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR:
+    fragmentShaderBarycentric: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR:
+    triStripVertexOrderIndependentOfProvokingVertex: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceRayTracingMotionBlurFeaturesNV:
+    rayTracingMotionBlur: VkBool32
+    rayTracingMotionBlurPipelineTraceRaysIndirect: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceRayTracingValidationFeaturesNV:
+    rayTracingValidation: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT:
+    formatRgba10x6WithoutYCbCrSampler: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceDynamicRenderingFeatures:
+    dynamicRendering: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceImageViewMinLodFeaturesEXT:
+    minLod: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT:
+    rasterizationOrderColorAttachmentAccess: VkBool32
+    rasterizationOrderDepthAttachmentAccess: VkBool32
+    rasterizationOrderStencilAttachmentAccess: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceLinearColorAttachmentFeaturesNV:
+    linearColorAttachment: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT:
+    graphicsPipelineLibrary: VkBool32
+
+
+@dataclass
+class VkPhysicalDevicePipelineBinaryFeaturesKHR:
+    pipelineBinaries: VkBool32
+
+
+@dataclass
+class VkPhysicalDevicePipelineBinaryPropertiesKHR:
+    pipelineBinaryInternalCache: VkBool32
+    pipelineBinaryInternalCacheControl: VkBool32
+    pipelineBinaryPrefersInternalCache: VkBool32
+    pipelineBinaryPrecompiledInternalCache: VkBool32
+    pipelineBinaryCompressedData: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT:
+    graphicsPipelineLibraryFastLinking: VkBool32
+    graphicsPipelineLibraryIndependentInterpolationDecoration: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE:
+    descriptorSetHostMapping: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceNestedCommandBufferFeaturesEXT:
+    nestedCommandBuffer: VkBool32
+    nestedCommandBufferRendering: VkBool32
+    nestedCommandBufferSimultaneousUse: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceNestedCommandBufferPropertiesEXT:
+    maxCommandBufferNestingLevel: uint32_t
+
+
+@dataclass
+class VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT:
+    shaderModuleIdentifier: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT:
+    shaderModuleIdentifierAlgorithmUUID: uint8_t * VK_UUID_SIZE
+
+
+@dataclass
+class VkPhysicalDeviceImageCompressionControlFeaturesEXT:
+    imageCompressionControl: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT:
+    imageCompressionControlSwapchain: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT:
+    subpassMergeFeedback: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceOpacityMicromapFeaturesEXT:
+    micromap: VkBool32
+    micromapCaptureReplay: VkBool32
+    micromapHostCommands: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceOpacityMicromapPropertiesEXT:
+    maxOpacity2StateSubdivisionLevel: uint32_t
+    maxOpacity4StateSubdivisionLevel: uint32_t
+
+
+@dataclass
+class VkPhysicalDevicePipelinePropertiesFeaturesEXT:
+    pipelinePropertiesIdentifier: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD:
+    shaderEarlyAndLateFragmentTests: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT:
+    nonSeamlessCubeMap: VkBool32
+
+
+@dataclass
+class VkPhysicalDevicePipelineRobustnessFeatures:
+    pipelineRobustness: VkBool32
+
+
+@dataclass
+class VkPhysicalDevicePipelineRobustnessProperties:
+    defaultRobustnessStorageBuffers: VkPipelineRobustnessBufferBehavior
+    defaultRobustnessUniformBuffers: VkPipelineRobustnessBufferBehavior
+    defaultRobustnessVertexInputs: VkPipelineRobustnessBufferBehavior
+    defaultRobustnessImages: VkPipelineRobustnessImageBehavior
+
+
+@dataclass
+class VkPhysicalDeviceImageProcessingFeaturesQCOM:
+    textureSampleWeighted: VkBool32
+    textureBoxFilter: VkBool32
+    textureBlockMatch: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceImageProcessingPropertiesQCOM:
+    maxWeightFilterPhases: uint32_t
+    maxWeightFilterDimension: VkExtent2D
+    maxBlockMatchRegion: VkExtent2D
+    maxBoxFilterBlockSize: VkExtent2D
+
+
+@dataclass
+class VkPhysicalDeviceTilePropertiesFeaturesQCOM:
+    tileProperties: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceAmigoProfilingFeaturesSEC:
+    amigoProfiling: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT:
+    attachmentFeedbackLoopLayout: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceDepthClampZeroOneFeaturesEXT:
+    depthClampZeroOne: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceAddressBindingReportFeaturesEXT:
+    reportAddressBinding: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceOpticalFlowFeaturesNV:
+    opticalFlow: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceOpticalFlowPropertiesNV:
+    supportedOutputGridSizes: VkOpticalFlowGridSizeFlagsNV
+    supportedHintGridSizes: VkOpticalFlowGridSizeFlagsNV
+    hintSupported: VkBool32
+    costSupported: VkBool32
+    bidirectionalFlowSupported: VkBool32
+    globalFlowSupported: VkBool32
+    minWidth: uint32_t
+    minHeight: uint32_t
+    maxWidth: uint32_t
+    maxHeight: uint32_t
+    maxNumRegionsOfInterest: uint32_t
+
+
+@dataclass
+class VkPhysicalDeviceFaultFeaturesEXT:
+    deviceFault: VkBool32
+    deviceFaultVendorBinary: VkBool32
+
+
+@dataclass
+class VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT:
+    pipelineLibraryGroupHandles: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM:
+    shaderCoreMask: uint64_t
+    shaderCoreCount: uint32_t
+    shaderWarpsPerCore: uint32_t
+
+
+@dataclass
+class VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM:
+    shaderCoreBuiltins: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceFrameBoundaryFeaturesEXT:
+    frameBoundary: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT:
+    dynamicRenderingUnusedAttachments: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT:
+    swapchainMaintenance1: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceDepthBiasControlFeaturesEXT:
+    depthBiasControl: VkBool32
+    leastRepresentableValueForceUnormRepresentation: VkBool32
+    floatRepresentation: VkBool32
+    depthBiasExact: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV:
+    rayTracingInvocationReorder: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV:
+    rayTracingInvocationReorderReorderingHint: VkRayTracingInvocationReorderModeNV
+
+
+@dataclass
+class VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV:
+    extendedSparseAddressSpace: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV:
+    extendedSparseAddressSpaceSize: VkDeviceSize
+    extendedSparseImageUsageFlags: VkImageUsageFlags
+    extendedSparseBufferUsageFlags: VkBufferUsageFlags
+
+
+@dataclass
+class VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM:
+    multiviewPerViewViewports: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR:
+    rayTracingPositionFetch: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceShaderCorePropertiesARM:
+    pixelRate: uint32_t
+    texelRate: uint32_t
+    fmaRate: uint32_t
+
+
+@dataclass
+class VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM:
+    multiviewPerViewRenderAreas: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceShaderObjectFeaturesEXT:
+    shaderObject: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceShaderObjectPropertiesEXT:
+    shaderBinaryUUID: uint8_t * VK_UUID_SIZE
+    shaderBinaryVersion: uint32_t
+
+
+@dataclass
+class VkPhysicalDeviceShaderTileImageFeaturesEXT:
+    shaderTileImageColorReadAccess: VkBool32
+    shaderTileImageDepthReadAccess: VkBool32
+    shaderTileImageStencilReadAccess: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceShaderTileImagePropertiesEXT:
+    shaderTileImageCoherentReadAccelerated: VkBool32
+    shaderTileImageReadSampleFromPixelRateInvocation: VkBool32
+    shaderTileImageReadFromHelperInvocation: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceCooperativeMatrixFeaturesKHR:
+    cooperativeMatrix: VkBool32
+    cooperativeMatrixRobustBufferAccess: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceCooperativeMatrixPropertiesKHR:
+    cooperativeMatrixSupportedStages: VkShaderStageFlags
+
+
+@dataclass
+class VkPhysicalDeviceAntiLagFeaturesAMD:
+    antiLag: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceCubicClampFeaturesQCOM:
+    cubicRangeClamp: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceYcbcrDegammaFeaturesQCOM:
+    ycbcrDegamma: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceCubicWeightsFeaturesQCOM:
+    selectableCubicWeights: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceImageProcessing2FeaturesQCOM:
+    textureBlockMatch2: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceImageProcessing2PropertiesQCOM:
+    maxBlockMatchWindow: VkExtent2D
+
+
+@dataclass
+class VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV:
+    descriptorPoolOverallocation: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceLayeredDriverPropertiesMSFT:
+    underlyingAPI: VkLayeredDriverUnderlyingApiMSFT
+
+
+@dataclass
+class VkPhysicalDevicePerStageDescriptorSetFeaturesNV:
+    perStageDescriptorSet: VkBool32
+    dynamicPipelineLayout: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceExternalFormatResolveFeaturesANDROID:
+    externalFormatResolve: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceExternalFormatResolvePropertiesANDROID:
+    nullColorAttachmentWithExternalFormatResolve: VkBool32
+    externalFormatResolveChromaOffsetX: VkChromaLocation
+    externalFormatResolveChromaOffsetY: VkChromaLocation
+
+
+@dataclass
+class VkPhysicalDeviceCudaKernelLaunchFeaturesNV:
+    cudaKernelLaunchFeatures: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceCudaKernelLaunchPropertiesNV:
+    computeCapabilityMinor: uint32_t
+    computeCapabilityMajor: uint32_t
+
+
+@dataclass
+class VkPhysicalDeviceSchedulingControlsFeaturesARM:
+    schedulingControls: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceSchedulingControlsPropertiesARM:
+    schedulingControlsFlags: VkPhysicalDeviceSchedulingControlsFlagsARM
+
+
+@dataclass
+class VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG:
+    relaxedLineRasterization: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceRenderPassStripedFeaturesARM:
+    renderPassStriped: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceRenderPassStripedPropertiesARM:
+    renderPassStripeGranularity: VkExtent2D
+    maxRenderPassStripes: uint32_t
+
+
+@dataclass
+class VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR:
+    shaderMaximalReconvergence: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceShaderSubgroupRotateFeatures:
+    shaderSubgroupRotate: VkBool32
+    shaderSubgroupRotateClustered: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceShaderExpectAssumeFeatures:
+    shaderExpectAssume: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceShaderFloatControls2Features:
+    shaderFloatControls2: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceDynamicRenderingLocalReadFeatures:
+    dynamicRenderingLocalRead: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceShaderQuadControlFeaturesKHR:
+    shaderQuadControl: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV:
+    shaderFloat16VectorAtomics: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceMapMemoryPlacedFeaturesEXT:
+    memoryMapPlaced: VkBool32
+    memoryMapRangePlaced: VkBool32
+    memoryUnmapReserve: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceMapMemoryPlacedPropertiesEXT:
+    minPlacedMemoryMapAlignment: VkDeviceSize
+
+
+@dataclass
+class VkPhysicalDeviceRawAccessChainsFeaturesNV:
+    shaderRawAccessChains: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceCommandBufferInheritanceFeaturesNV:
+    commandBufferInheritance: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceImageAlignmentControlFeaturesMESA:
+    imageAlignmentControl: VkBool32
+
+
+@dataclass
+class VkPhysicalDeviceImageAlignmentControlPropertiesMESA:
+    supportedImageAlignmentMask: uint32_t
+
+
+@dataclass
+class VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT:
+    shaderReplicatedComposites: VkBool32
+
+
+# --- Physical Device Struct Aliases ---
+
+VkPhysicalDevicePrivateDataFeaturesEXT = VkPhysicalDevicePrivateDataFeatures
+VkPhysicalDeviceProperties2KHR = VkPhysicalDeviceProperties2
+VkPhysicalDeviceMemoryProperties2KHR = VkPhysicalDeviceMemoryProperties2
+VkPhysicalDevicePushDescriptorPropertiesKHR = VkPhysicalDevicePushDescriptorProperties
+VkPhysicalDeviceDriverPropertiesKHR = VkPhysicalDeviceDriverProperties
+VkPhysicalDeviceVariablePointersFeaturesKHR = VkPhysicalDeviceVariablePointersFeatures
+VkPhysicalDeviceVariablePointerFeaturesKHR = VkPhysicalDeviceVariablePointersFeatures
+VkPhysicalDeviceVariablePointerFeatures = VkPhysicalDeviceVariablePointersFeatures
+VkPhysicalDeviceIDPropertiesKHR = VkPhysicalDeviceIDProperties
+VkPhysicalDeviceMultiviewFeaturesKHR = VkPhysicalDeviceMultiviewFeatures
+VkPhysicalDeviceMultiviewPropertiesKHR = VkPhysicalDeviceMultiviewProperties
+VkPhysicalDeviceGroupPropertiesKHR = VkPhysicalDeviceGroupProperties
+VkPhysicalDevice16BitStorageFeaturesKHR = VkPhysicalDevice16BitStorageFeatures
+VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR = VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures
+VkPhysicalDevicePointClippingPropertiesKHR = VkPhysicalDevicePointClippingProperties
+VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR = VkPhysicalDeviceSamplerYcbcrConversionFeatures
+VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT = VkPhysicalDeviceSamplerFilterMinmaxProperties
+VkPhysicalDeviceInlineUniformBlockFeaturesEXT = VkPhysicalDeviceInlineUniformBlockFeatures
+VkPhysicalDeviceInlineUniformBlockPropertiesEXT = VkPhysicalDeviceInlineUniformBlockProperties
+VkPhysicalDeviceMaintenance3PropertiesKHR = VkPhysicalDeviceMaintenance3Properties
+VkPhysicalDeviceMaintenance4FeaturesKHR = VkPhysicalDeviceMaintenance4Features
+VkPhysicalDeviceMaintenance4PropertiesKHR = VkPhysicalDeviceMaintenance4Properties
+VkPhysicalDeviceMaintenance5FeaturesKHR = VkPhysicalDeviceMaintenance5Features
+VkPhysicalDeviceMaintenance5PropertiesKHR = VkPhysicalDeviceMaintenance5Properties
+VkPhysicalDeviceMaintenance6FeaturesKHR = VkPhysicalDeviceMaintenance6Features
+VkPhysicalDeviceMaintenance6PropertiesKHR = VkPhysicalDeviceMaintenance6Properties
+VkPhysicalDeviceShaderDrawParameterFeatures = VkPhysicalDeviceShaderDrawParametersFeatures
+VkPhysicalDeviceShaderFloat16Int8FeaturesKHR = VkPhysicalDeviceShaderFloat16Int8Features
+VkPhysicalDeviceFloat16Int8FeaturesKHR = VkPhysicalDeviceShaderFloat16Int8Features
+VkPhysicalDeviceFloatControlsPropertiesKHR = VkPhysicalDeviceFloatControlsProperties
+VkPhysicalDeviceHostQueryResetFeaturesEXT = VkPhysicalDeviceHostQueryResetFeatures
+VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR = VkPhysicalDeviceGlobalPriorityQueryFeatures
+VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT = VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR
+VkPhysicalDeviceDescriptorIndexingFeaturesEXT = VkPhysicalDeviceDescriptorIndexingFeatures
+VkPhysicalDeviceDescriptorIndexingPropertiesEXT = VkPhysicalDeviceDescriptorIndexingProperties
+VkPhysicalDeviceTimelineSemaphoreFeaturesKHR = VkPhysicalDeviceTimelineSemaphoreFeatures
+VkPhysicalDeviceTimelineSemaphorePropertiesKHR = VkPhysicalDeviceTimelineSemaphoreProperties
+VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR = VkPhysicalDeviceVertexAttributeDivisorProperties
+VkPhysicalDevice8BitStorageFeaturesKHR = VkPhysicalDevice8BitStorageFeatures
+VkPhysicalDeviceVulkanMemoryModelFeaturesKHR = VkPhysicalDeviceVulkanMemoryModelFeatures
+VkPhysicalDeviceShaderAtomicInt64FeaturesKHR = VkPhysicalDeviceShaderAtomicInt64Features
+VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR = VkPhysicalDeviceVertexAttributeDivisorFeatures
+VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT = VkPhysicalDeviceVertexAttributeDivisorFeatures
+VkPhysicalDeviceDepthStencilResolvePropertiesKHR = VkPhysicalDeviceDepthStencilResolveProperties
+VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV = VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR
+VkPhysicalDeviceScalarBlockLayoutFeaturesEXT = VkPhysicalDeviceScalarBlockLayoutFeatures
+VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR = VkPhysicalDeviceUniformBufferStandardLayoutFeatures
+VkPhysicalDeviceBufferDeviceAddressFeaturesKHR = VkPhysicalDeviceBufferDeviceAddressFeatures
+VkPhysicalDeviceBufferAddressFeaturesEXT = VkPhysicalDeviceBufferDeviceAddressFeaturesEXT
+VkPhysicalDeviceImagelessFramebufferFeaturesKHR = VkPhysicalDeviceImagelessFramebufferFeatures
+VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT = VkPhysicalDeviceTextureCompressionASTCHDRFeatures
+VkPhysicalDeviceIndexTypeUint8FeaturesKHR = VkPhysicalDeviceIndexTypeUint8Features
+VkPhysicalDeviceIndexTypeUint8FeaturesEXT = VkPhysicalDeviceIndexTypeUint8Features
+VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR = VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures
+VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT = VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures
+VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT = VkPhysicalDeviceTexelBufferAlignmentProperties
+VkPhysicalDeviceSubgroupSizeControlFeaturesEXT = VkPhysicalDeviceSubgroupSizeControlFeatures
+VkPhysicalDeviceSubgroupSizeControlPropertiesEXT = VkPhysicalDeviceSubgroupSizeControlProperties
+VkPhysicalDeviceLineRasterizationFeaturesKHR = VkPhysicalDeviceLineRasterizationFeatures
+VkPhysicalDeviceLineRasterizationFeaturesEXT = VkPhysicalDeviceLineRasterizationFeaturesKHR
+VkPhysicalDeviceLineRasterizationPropertiesKHR = VkPhysicalDeviceLineRasterizationProperties
+VkPhysicalDeviceLineRasterizationPropertiesEXT = VkPhysicalDeviceLineRasterizationPropertiesKHR
+VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT = VkPhysicalDevicePipelineCreationCacheControlFeatures
+VkPhysicalDeviceToolPropertiesEXT = VkPhysicalDeviceToolProperties
+VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR = VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures
+VkPhysicalDeviceImageRobustnessFeaturesEXT = VkPhysicalDeviceImageRobustnessFeatures
+VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR = VkPhysicalDeviceShaderTerminateInvocationFeatures
+VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE = VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT
+VkPhysicalDeviceSynchronization2FeaturesKHR = VkPhysicalDeviceSynchronization2Features
+VkPhysicalDeviceHostImageCopyFeaturesEXT = VkPhysicalDeviceHostImageCopyFeatures
+VkPhysicalDevicePipelineProtectedAccessFeaturesEXT = VkPhysicalDevicePipelineProtectedAccessFeatures
+VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR = VkPhysicalDeviceShaderIntegerDotProductFeatures
+VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR = VkPhysicalDeviceShaderIntegerDotProductProperties
+VkPhysicalDeviceDynamicRenderingFeaturesKHR = VkPhysicalDeviceDynamicRenderingFeatures
+VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM = VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT
+VkPhysicalDevicePipelineRobustnessFeaturesEXT = VkPhysicalDevicePipelineRobustnessFeatures
+VkPhysicalDevicePipelineRobustnessPropertiesEXT = VkPhysicalDevicePipelineRobustnessProperties
+VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR = VkPhysicalDeviceShaderSubgroupRotateFeatures
+VkPhysicalDeviceShaderExpectAssumeFeaturesKHR = VkPhysicalDeviceShaderExpectAssumeFeatures
+VkPhysicalDeviceShaderFloatControls2FeaturesKHR = VkPhysicalDeviceShaderFloatControls2Features
+VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR = VkPhysicalDeviceDynamicRenderingLocalReadFeatures
+
+
+# --- List of All Processed Physical Device Structs ---
+# Includes structs that:
+# 1. Are not in 'disabled_structs' (implicitly, via VK_PHYSICAL_STRUCT_NAMES population).
+# 2. Extend "VkPhysicalDeviceProperties2" or "VkPhysicalDeviceFeatures2"
+#    (i.e., are in 'structs_with_valid_extends').
+
+ALL_STRUCTS_EXTENDING_FEATURES_OR_PROPERTIES = [
+    VkPhysicalDevice16BitStorageFeatures,
+    VkPhysicalDevice16BitStorageFeaturesKHR,
+    VkPhysicalDevice4444FormatsFeaturesEXT,
+    VkPhysicalDevice8BitStorageFeatures,
+    VkPhysicalDevice8BitStorageFeaturesKHR,
+    VkPhysicalDeviceASTCDecodeFeaturesEXT,
+    VkPhysicalDeviceAccelerationStructureFeaturesKHR,
+    VkPhysicalDeviceAccelerationStructurePropertiesKHR,
+    VkPhysicalDeviceAddressBindingReportFeaturesEXT,
+    VkPhysicalDeviceAmigoProfilingFeaturesSEC,
+    VkPhysicalDeviceAntiLagFeaturesAMD,
+    VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT,
+    VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT,
+    VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT,
+    VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT,
+    VkPhysicalDeviceBorderColorSwizzleFeaturesEXT,
+    VkPhysicalDeviceBufferAddressFeaturesEXT,
+    VkPhysicalDeviceBufferDeviceAddressFeatures,
+    VkPhysicalDeviceBufferDeviceAddressFeaturesEXT,
+    VkPhysicalDeviceBufferDeviceAddressFeaturesKHR,
+    VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI,
+    VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI,
+    VkPhysicalDeviceCoherentMemoryFeaturesAMD,
+    VkPhysicalDeviceColorWriteEnableFeaturesEXT,
+    VkPhysicalDeviceCommandBufferInheritanceFeaturesNV,
+    VkPhysicalDeviceComputeShaderDerivativesFeaturesNV,
+    VkPhysicalDeviceConditionalRenderingFeaturesEXT,
+    VkPhysicalDeviceConservativeRasterizationPropertiesEXT,
+    VkPhysicalDeviceCooperativeMatrixFeaturesKHR,
+    VkPhysicalDeviceCooperativeMatrixFeaturesNV,
+    VkPhysicalDeviceCooperativeMatrixPropertiesKHR,
+    VkPhysicalDeviceCooperativeMatrixPropertiesNV,
+    VkPhysicalDeviceCopyMemoryIndirectFeaturesNV,
+    VkPhysicalDeviceCopyMemoryIndirectPropertiesNV,
+    VkPhysicalDeviceCornerSampledImageFeaturesNV,
+    VkPhysicalDeviceCoverageReductionModeFeaturesNV,
+    VkPhysicalDeviceCubicClampFeaturesQCOM,
+    VkPhysicalDeviceCubicWeightsFeaturesQCOM,
+    VkPhysicalDeviceCudaKernelLaunchFeaturesNV,
+    VkPhysicalDeviceCudaKernelLaunchPropertiesNV,
+    VkPhysicalDeviceCustomBorderColorFeaturesEXT,
+    VkPhysicalDeviceCustomBorderColorPropertiesEXT,
+    VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV,
+    VkPhysicalDeviceDepthBiasControlFeaturesEXT,
+    VkPhysicalDeviceDepthClampZeroOneFeaturesEXT,
+    VkPhysicalDeviceDepthClipControlFeaturesEXT,
+    VkPhysicalDeviceDepthClipEnableFeaturesEXT,
+    VkPhysicalDeviceDepthStencilResolveProperties,
+    VkPhysicalDeviceDepthStencilResolvePropertiesKHR,
+    VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT,
+    VkPhysicalDeviceDescriptorBufferFeaturesEXT,
+    VkPhysicalDeviceDescriptorBufferPropertiesEXT,
+    VkPhysicalDeviceDescriptorIndexingFeatures,
+    VkPhysicalDeviceDescriptorIndexingFeaturesEXT,
+    VkPhysicalDeviceDescriptorIndexingProperties,
+    VkPhysicalDeviceDescriptorIndexingPropertiesEXT,
+    VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV,
+    VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE,
+    VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV,
+    VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV,
+    VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV,
+    VkPhysicalDeviceDeviceMemoryReportFeaturesEXT,
+    VkPhysicalDeviceDiagnosticsConfigFeaturesNV,
+    VkPhysicalDeviceDiscardRectanglePropertiesEXT,
+    VkPhysicalDeviceDriverProperties,
+    VkPhysicalDeviceDriverPropertiesKHR,
+    VkPhysicalDeviceDrmPropertiesEXT,
+    VkPhysicalDeviceDynamicRenderingFeatures,
+    VkPhysicalDeviceDynamicRenderingFeaturesKHR,
+    VkPhysicalDeviceDynamicRenderingLocalReadFeatures,
+    VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR,
+    VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT,
+    VkPhysicalDeviceExclusiveScissorFeaturesNV,
+    VkPhysicalDeviceExtendedDynamicState2FeaturesEXT,
+    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT,
+    VkPhysicalDeviceExtendedDynamicState3PropertiesEXT,
+    VkPhysicalDeviceExtendedDynamicStateFeaturesEXT,
+    VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV,
+    VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV,
+    VkPhysicalDeviceExternalFormatResolveFeaturesANDROID,
+    VkPhysicalDeviceExternalFormatResolvePropertiesANDROID,
+    VkPhysicalDeviceExternalMemoryHostPropertiesEXT,
+    VkPhysicalDeviceExternalMemoryRDMAFeaturesNV,
+    VkPhysicalDeviceFaultFeaturesEXT,
+    VkPhysicalDeviceFloat16Int8FeaturesKHR,
+    VkPhysicalDeviceFloatControlsProperties,
+    VkPhysicalDeviceFloatControlsPropertiesKHR,
+    VkPhysicalDeviceFragmentDensityMap2FeaturesEXT,
+    VkPhysicalDeviceFragmentDensityMap2PropertiesEXT,
+    VkPhysicalDeviceFragmentDensityMapFeaturesEXT,
+    VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM,
+    VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM,
+    VkPhysicalDeviceFragmentDensityMapPropertiesEXT,
+    VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR,
+    VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR,
+    VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT,
+    VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV,
+    VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV,
+    VkPhysicalDeviceFragmentShadingRateFeaturesKHR,
+    VkPhysicalDeviceFragmentShadingRatePropertiesKHR,
+    VkPhysicalDeviceFrameBoundaryFeaturesEXT,
+    VkPhysicalDeviceGlobalPriorityQueryFeatures,
+    VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT,
+    VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR,
+    VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT,
+    VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT,
+    VkPhysicalDeviceHostImageCopyFeatures,
+    VkPhysicalDeviceHostImageCopyFeaturesEXT,
+    VkPhysicalDeviceHostQueryResetFeatures,
+    VkPhysicalDeviceHostQueryResetFeaturesEXT,
+    VkPhysicalDeviceIDProperties,
+    VkPhysicalDeviceIDPropertiesKHR,
+    VkPhysicalDeviceImage2DViewOf3DFeaturesEXT,
+    VkPhysicalDeviceImageAlignmentControlFeaturesMESA,
+    VkPhysicalDeviceImageAlignmentControlPropertiesMESA,
+    VkPhysicalDeviceImageCompressionControlFeaturesEXT,
+    VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT,
+    VkPhysicalDeviceImageProcessing2FeaturesQCOM,
+    VkPhysicalDeviceImageProcessing2PropertiesQCOM,
+    VkPhysicalDeviceImageProcessingFeaturesQCOM,
+    VkPhysicalDeviceImageProcessingPropertiesQCOM,
+    VkPhysicalDeviceImageRobustnessFeatures,
+    VkPhysicalDeviceImageRobustnessFeaturesEXT,
+    VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT,
+    VkPhysicalDeviceImageViewMinLodFeaturesEXT,
+    VkPhysicalDeviceImagelessFramebufferFeatures,
+    VkPhysicalDeviceImagelessFramebufferFeaturesKHR,
+    VkPhysicalDeviceIndexTypeUint8Features,
+    VkPhysicalDeviceIndexTypeUint8FeaturesEXT,
+    VkPhysicalDeviceIndexTypeUint8FeaturesKHR,
+    VkPhysicalDeviceInheritedViewportScissorFeaturesNV,
+    VkPhysicalDeviceInlineUniformBlockFeatures,
+    VkPhysicalDeviceInlineUniformBlockFeaturesEXT,
+    VkPhysicalDeviceInlineUniformBlockProperties,
+    VkPhysicalDeviceInlineUniformBlockPropertiesEXT,
+    VkPhysicalDeviceInvocationMaskFeaturesHUAWEI,
+    VkPhysicalDeviceLayeredApiPropertiesListKHR,
+    VkPhysicalDeviceLayeredDriverPropertiesMSFT,
+    VkPhysicalDeviceLegacyDitheringFeaturesEXT,
+    VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT,
+    VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT,
+    VkPhysicalDeviceLineRasterizationFeatures,
+    VkPhysicalDeviceLineRasterizationFeaturesEXT,
+    VkPhysicalDeviceLineRasterizationFeaturesKHR,
+    VkPhysicalDeviceLineRasterizationProperties,
+    VkPhysicalDeviceLineRasterizationPropertiesEXT,
+    VkPhysicalDeviceLineRasterizationPropertiesKHR,
+    VkPhysicalDeviceLinearColorAttachmentFeaturesNV,
+    VkPhysicalDeviceMaintenance3Properties,
+    VkPhysicalDeviceMaintenance3PropertiesKHR,
+    VkPhysicalDeviceMaintenance4Features,
+    VkPhysicalDeviceMaintenance4FeaturesKHR,
+    VkPhysicalDeviceMaintenance4Properties,
+    VkPhysicalDeviceMaintenance4PropertiesKHR,
+    VkPhysicalDeviceMaintenance5Features,
+    VkPhysicalDeviceMaintenance5FeaturesKHR,
+    VkPhysicalDeviceMaintenance5Properties,
+    VkPhysicalDeviceMaintenance5PropertiesKHR,
+    VkPhysicalDeviceMaintenance6Features,
+    VkPhysicalDeviceMaintenance6FeaturesKHR,
+    VkPhysicalDeviceMaintenance6Properties,
+    VkPhysicalDeviceMaintenance6PropertiesKHR,
+    VkPhysicalDeviceMaintenance7FeaturesKHR,
+    VkPhysicalDeviceMaintenance7PropertiesKHR,
+    VkPhysicalDeviceMapMemoryPlacedFeaturesEXT,
+    VkPhysicalDeviceMapMemoryPlacedPropertiesEXT,
+    VkPhysicalDeviceMemoryDecompressionFeaturesNV,
+    VkPhysicalDeviceMemoryDecompressionPropertiesNV,
+    VkPhysicalDeviceMemoryPriorityFeaturesEXT,
+    VkPhysicalDeviceMeshShaderFeaturesEXT,
+    VkPhysicalDeviceMeshShaderFeaturesNV,
+    VkPhysicalDeviceMeshShaderPropertiesEXT,
+    VkPhysicalDeviceMeshShaderPropertiesNV,
+    VkPhysicalDeviceMultiDrawFeaturesEXT,
+    VkPhysicalDeviceMultiDrawPropertiesEXT,
+    VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT,
+    VkPhysicalDeviceMultiviewFeatures,
+    VkPhysicalDeviceMultiviewFeaturesKHR,
+    VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX,
+    VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM,
+    VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM,
+    VkPhysicalDeviceMultiviewProperties,
+    VkPhysicalDeviceMultiviewPropertiesKHR,
+    VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT,
+    VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE,
+    VkPhysicalDeviceNestedCommandBufferFeaturesEXT,
+    VkPhysicalDeviceNestedCommandBufferPropertiesEXT,
+    VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT,
+    VkPhysicalDeviceOpacityMicromapFeaturesEXT,
+    VkPhysicalDeviceOpacityMicromapPropertiesEXT,
+    VkPhysicalDeviceOpticalFlowFeaturesNV,
+    VkPhysicalDeviceOpticalFlowPropertiesNV,
+    VkPhysicalDevicePCIBusInfoPropertiesEXT,
+    VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT,
+    VkPhysicalDevicePerStageDescriptorSetFeaturesNV,
+    VkPhysicalDevicePerformanceQueryFeaturesKHR,
+    VkPhysicalDevicePerformanceQueryPropertiesKHR,
+    VkPhysicalDevicePipelineBinaryFeaturesKHR,
+    VkPhysicalDevicePipelineBinaryPropertiesKHR,
+    VkPhysicalDevicePipelineCreationCacheControlFeatures,
+    VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT,
+    VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR,
+    VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT,
+    VkPhysicalDevicePipelinePropertiesFeaturesEXT,
+    VkPhysicalDevicePipelineProtectedAccessFeatures,
+    VkPhysicalDevicePipelineProtectedAccessFeaturesEXT,
+    VkPhysicalDevicePipelineRobustnessFeatures,
+    VkPhysicalDevicePipelineRobustnessFeaturesEXT,
+    VkPhysicalDevicePipelineRobustnessProperties,
+    VkPhysicalDevicePipelineRobustnessPropertiesEXT,
+    VkPhysicalDevicePointClippingProperties,
+    VkPhysicalDevicePointClippingPropertiesKHR,
+    VkPhysicalDevicePresentBarrierFeaturesNV,
+    VkPhysicalDevicePresentIdFeaturesKHR,
+    VkPhysicalDevicePresentWaitFeaturesKHR,
+    VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT,
+    VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT,
+    VkPhysicalDevicePrivateDataFeatures,
+    VkPhysicalDevicePrivateDataFeaturesEXT,
+    VkPhysicalDeviceProtectedMemoryFeatures,
+    VkPhysicalDeviceProtectedMemoryProperties,
+    VkPhysicalDeviceProvokingVertexFeaturesEXT,
+    VkPhysicalDeviceProvokingVertexPropertiesEXT,
+    VkPhysicalDevicePushDescriptorProperties,
+    VkPhysicalDevicePushDescriptorPropertiesKHR,
+    VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT,
+    VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM,
+    VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT,
+    VkPhysicalDeviceRawAccessChainsFeaturesNV,
+    VkPhysicalDeviceRayQueryFeaturesKHR,
+    VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV,
+    VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV,
+    VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR,
+    VkPhysicalDeviceRayTracingMotionBlurFeaturesNV,
+    VkPhysicalDeviceRayTracingPipelineFeaturesKHR,
+    VkPhysicalDeviceRayTracingPipelinePropertiesKHR,
+    VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR,
+    VkPhysicalDeviceRayTracingPropertiesNV,
+    VkPhysicalDeviceRayTracingValidationFeaturesNV,
+    VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG,
+    VkPhysicalDeviceRenderPassStripedFeaturesARM,
+    VkPhysicalDeviceRenderPassStripedPropertiesARM,
+    VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV,
+    VkPhysicalDeviceRobustness2FeaturesEXT,
+    VkPhysicalDeviceRobustness2PropertiesEXT,
+    VkPhysicalDeviceSampleLocationsPropertiesEXT,
+    VkPhysicalDeviceSamplerFilterMinmaxProperties,
+    VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT,
+    VkPhysicalDeviceSamplerYcbcrConversionFeatures,
+    VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR,
+    VkPhysicalDeviceScalarBlockLayoutFeatures,
+    VkPhysicalDeviceScalarBlockLayoutFeaturesEXT,
+    VkPhysicalDeviceSchedulingControlsFeaturesARM,
+    VkPhysicalDeviceSchedulingControlsPropertiesARM,
+    VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures,
+    VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR,
+    VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV,
+    VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT,
+    VkPhysicalDeviceShaderAtomicFloatFeaturesEXT,
+    VkPhysicalDeviceShaderAtomicInt64Features,
+    VkPhysicalDeviceShaderAtomicInt64FeaturesKHR,
+    VkPhysicalDeviceShaderClockFeaturesKHR,
+    VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM,
+    VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM,
+    VkPhysicalDeviceShaderCoreProperties2AMD,
+    VkPhysicalDeviceShaderCorePropertiesAMD,
+    VkPhysicalDeviceShaderCorePropertiesARM,
+    VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures,
+    VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT,
+    VkPhysicalDeviceShaderDrawParameterFeatures,
+    VkPhysicalDeviceShaderDrawParametersFeatures,
+    VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD,
+    VkPhysicalDeviceShaderExpectAssumeFeatures,
+    VkPhysicalDeviceShaderExpectAssumeFeaturesKHR,
+    VkPhysicalDeviceShaderFloat16Int8Features,
+    VkPhysicalDeviceShaderFloat16Int8FeaturesKHR,
+    VkPhysicalDeviceShaderFloatControls2Features,
+    VkPhysicalDeviceShaderFloatControls2FeaturesKHR,
+    VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT,
+    VkPhysicalDeviceShaderImageFootprintFeaturesNV,
+    VkPhysicalDeviceShaderIntegerDotProductFeatures,
+    VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR,
+    VkPhysicalDeviceShaderIntegerDotProductProperties,
+    VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR,
+    VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL,
+    VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR,
+    VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT,
+    VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT,
+    VkPhysicalDeviceShaderObjectFeaturesEXT,
+    VkPhysicalDeviceShaderObjectPropertiesEXT,
+    VkPhysicalDeviceShaderQuadControlFeaturesKHR,
+    VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR,
+    VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT,
+    VkPhysicalDeviceShaderSMBuiltinsFeaturesNV,
+    VkPhysicalDeviceShaderSMBuiltinsPropertiesNV,
+    VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures,
+    VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR,
+    VkPhysicalDeviceShaderSubgroupRotateFeatures,
+    VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR,
+    VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR,
+    VkPhysicalDeviceShaderTerminateInvocationFeatures,
+    VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR,
+    VkPhysicalDeviceShaderTileImageFeaturesEXT,
+    VkPhysicalDeviceShaderTileImagePropertiesEXT,
+    VkPhysicalDeviceShadingRateImageFeaturesNV,
+    VkPhysicalDeviceShadingRateImagePropertiesNV,
+    VkPhysicalDeviceSubgroupProperties,
+    VkPhysicalDeviceSubgroupSizeControlFeatures,
+    VkPhysicalDeviceSubgroupSizeControlFeaturesEXT,
+    VkPhysicalDeviceSubgroupSizeControlProperties,
+    VkPhysicalDeviceSubgroupSizeControlPropertiesEXT,
+    VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT,
+    VkPhysicalDeviceSubpassShadingFeaturesHUAWEI,
+    VkPhysicalDeviceSubpassShadingPropertiesHUAWEI,
+    VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT,
+    VkPhysicalDeviceSynchronization2Features,
+    VkPhysicalDeviceSynchronization2FeaturesKHR,
+    VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT,
+    VkPhysicalDeviceTexelBufferAlignmentProperties,
+    VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT,
+    VkPhysicalDeviceTextureCompressionASTCHDRFeatures,
+    VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT,
+    VkPhysicalDeviceTilePropertiesFeaturesQCOM,
+    VkPhysicalDeviceTimelineSemaphoreFeatures,
+    VkPhysicalDeviceTimelineSemaphoreFeaturesKHR,
+    VkPhysicalDeviceTimelineSemaphoreProperties,
+    VkPhysicalDeviceTimelineSemaphorePropertiesKHR,
+    VkPhysicalDeviceTransformFeedbackFeaturesEXT,
+    VkPhysicalDeviceTransformFeedbackPropertiesEXT,
+    VkPhysicalDeviceUniformBufferStandardLayoutFeatures,
+    VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR,
+    VkPhysicalDeviceVariablePointerFeatures,
+    VkPhysicalDeviceVariablePointerFeaturesKHR,
+    VkPhysicalDeviceVariablePointersFeatures,
+    VkPhysicalDeviceVariablePointersFeaturesKHR,
+    VkPhysicalDeviceVertexAttributeDivisorFeatures,
+    VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT,
+    VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR,
+    VkPhysicalDeviceVertexAttributeDivisorProperties,
+    VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT,
+    VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR,
+    VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT,
+    VkPhysicalDeviceVideoMaintenance1FeaturesKHR,
+    VkPhysicalDeviceVulkan11Features,
+    VkPhysicalDeviceVulkan11Properties,
+    VkPhysicalDeviceVulkan12Features,
+    VkPhysicalDeviceVulkan12Properties,
+    VkPhysicalDeviceVulkan13Features,
+    VkPhysicalDeviceVulkan13Properties,
+    VkPhysicalDeviceVulkan14Features,
+    VkPhysicalDeviceVulkan14Properties,
+    VkPhysicalDeviceVulkanMemoryModelFeatures,
+    VkPhysicalDeviceVulkanMemoryModelFeaturesKHR,
+    VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR,
+    VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT,
+    VkPhysicalDeviceYcbcrDegammaFeaturesQCOM,
+    VkPhysicalDeviceYcbcrImageArraysFeaturesEXT,
+    VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures,
+    VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR,
+]
+
+
+# --- Vulkan Extension to Struct Mappings ---
+# VULKAN_EXTENSIONS_AND_STRUCTS_MAPPING: Maps enabled extension names to their PhysicalDevice structs.
+# Extension Filters:
+# - 'supported' is not "disabled".
+# - 'platform' (if present) is "android".
+# Struct Filters (per extension):
+# - Not in global 'disabled_structs'.
+# - Extends "VkPhysicalDeviceProperties2" or "VkPhysicalDeviceFeatures2".
+# Format: {ext_name: [{struct_name: sType_enum_value}, ...]}
+
+VULKAN_EXTENSIONS_AND_STRUCTS_MAPPING = {
+    "extensions": {
+        "VK_AMD_anti_lag": [{"VkPhysicalDeviceAntiLagFeaturesAMD": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD"}],
+        "VK_AMD_device_coherent_memory": [{"VkPhysicalDeviceCoherentMemoryFeaturesAMD": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD"}],
+        "VK_AMD_shader_core_properties": [{"VkPhysicalDeviceShaderCorePropertiesAMD": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD"}],
+        "VK_AMD_shader_core_properties2": [{"VkPhysicalDeviceShaderCoreProperties2AMD": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD"}],
+        "VK_AMD_shader_early_and_late_fragment_tests": [
+            {"VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD"}
+        ],
+        "VK_ANDROID_external_format_resolve": [
+            {"VkPhysicalDeviceExternalFormatResolveFeaturesANDROID": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID"},
+            {"VkPhysicalDeviceExternalFormatResolvePropertiesANDROID": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID"},
+        ],
+        "VK_ARM_rasterization_order_attachment_access": [
+            {"VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT"}
+        ],
+        "VK_ARM_render_pass_striped": [
+            {"VkPhysicalDeviceRenderPassStripedFeaturesARM": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM"},
+            {"VkPhysicalDeviceRenderPassStripedPropertiesARM": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM"},
+        ],
+        "VK_ARM_scheduling_controls": [
+            {"VkPhysicalDeviceSchedulingControlsFeaturesARM": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM"},
+            {"VkPhysicalDeviceSchedulingControlsPropertiesARM": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM"},
+        ],
+        "VK_ARM_shader_core_builtins": [
+            {"VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM"},
+            {"VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM"},
+        ],
+        "VK_ARM_shader_core_properties": [{"VkPhysicalDeviceShaderCorePropertiesARM": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM"}],
+        "VK_EXT_4444_formats": [{"VkPhysicalDevice4444FormatsFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT"}],
+        "VK_EXT_astc_decode_mode": [{"VkPhysicalDeviceASTCDecodeFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT"}],
+        "VK_EXT_attachment_feedback_loop_dynamic_state": [
+            {"VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT"}
+        ],
+        "VK_EXT_attachment_feedback_loop_layout": [{"VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT"}],
+        "VK_EXT_blend_operation_advanced": [
+            {"VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT"},
+            {"VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT"},
+        ],
+        "VK_EXT_border_color_swizzle": [{"VkPhysicalDeviceBorderColorSwizzleFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT"}],
+        "VK_EXT_buffer_device_address": [
+            {"VkPhysicalDeviceBufferAddressFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT"},
+            {"VkPhysicalDeviceBufferDeviceAddressFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT"},
+        ],
+        "VK_EXT_color_write_enable": [{"VkPhysicalDeviceColorWriteEnableFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT"}],
+        "VK_EXT_conditional_rendering": [{"VkPhysicalDeviceConditionalRenderingFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT"}],
+        "VK_EXT_conservative_rasterization": [{"VkPhysicalDeviceConservativeRasterizationPropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT"}],
+        "VK_EXT_custom_border_color": [
+            {"VkPhysicalDeviceCustomBorderColorPropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT"},
+            {"VkPhysicalDeviceCustomBorderColorFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT"},
+        ],
+        "VK_EXT_depth_bias_control": [{"VkPhysicalDeviceDepthBiasControlFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT"}],
+        "VK_EXT_depth_clamp_zero_one": [{"VkPhysicalDeviceDepthClampZeroOneFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT"}],
+        "VK_EXT_depth_clip_control": [{"VkPhysicalDeviceDepthClipControlFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT"}],
+        "VK_EXT_depth_clip_enable": [{"VkPhysicalDeviceDepthClipEnableFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT"}],
+        "VK_EXT_descriptor_buffer": [
+            {"VkPhysicalDeviceDescriptorBufferPropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT"},
+            {"VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT"},
+            {"VkPhysicalDeviceDescriptorBufferFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT"},
+        ],
+        "VK_EXT_descriptor_indexing": [
+            {"VkPhysicalDeviceDescriptorIndexingFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES"},
+            {"VkPhysicalDeviceDescriptorIndexingPropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES"},
+        ],
+        "VK_EXT_device_address_binding_report": [{"VkPhysicalDeviceAddressBindingReportFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT"}],
+        "VK_EXT_device_fault": [{"VkPhysicalDeviceFaultFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT"}],
+        "VK_EXT_device_memory_report": [{"VkPhysicalDeviceDeviceMemoryReportFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT"}],
+        "VK_EXT_discard_rectangles": [{"VkPhysicalDeviceDiscardRectanglePropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT"}],
+        "VK_EXT_dynamic_rendering_unused_attachments": [
+            {"VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT"}
+        ],
+        "VK_EXT_extended_dynamic_state": [{"VkPhysicalDeviceExtendedDynamicStateFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT"}],
+        "VK_EXT_extended_dynamic_state2": [{"VkPhysicalDeviceExtendedDynamicState2FeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT"}],
+        "VK_EXT_extended_dynamic_state3": [
+            {"VkPhysicalDeviceExtendedDynamicState3FeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT"},
+            {"VkPhysicalDeviceExtendedDynamicState3PropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT"},
+        ],
+        "VK_EXT_external_memory_host": [{"VkPhysicalDeviceExternalMemoryHostPropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT"}],
+        "VK_EXT_fragment_density_map": [
+            {"VkPhysicalDeviceFragmentDensityMapFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT"},
+            {"VkPhysicalDeviceFragmentDensityMapPropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT"},
+        ],
+        "VK_EXT_fragment_density_map2": [
+            {"VkPhysicalDeviceFragmentDensityMap2FeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT"},
+            {"VkPhysicalDeviceFragmentDensityMap2PropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT"},
+        ],
+        "VK_EXT_fragment_shader_interlock": [{"VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT"}],
+        "VK_EXT_frame_boundary": [{"VkPhysicalDeviceFrameBoundaryFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT"}],
+        "VK_EXT_global_priority_query": [{"VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES"}],
+        "VK_EXT_graphics_pipeline_library": [
+            {"VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT"},
+            {"VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT"},
+        ],
+        "VK_EXT_host_image_copy": [{"VkPhysicalDeviceHostImageCopyFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES"}],
+        "VK_EXT_host_query_reset": [{"VkPhysicalDeviceHostQueryResetFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES"}],
+        "VK_EXT_image_2d_view_of_3d": [{"VkPhysicalDeviceImage2DViewOf3DFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT"}],
+        "VK_EXT_image_compression_control": [{"VkPhysicalDeviceImageCompressionControlFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT"}],
+        "VK_EXT_image_compression_control_swapchain": [
+            {"VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT"}
+        ],
+        "VK_EXT_image_robustness": [{"VkPhysicalDeviceImageRobustnessFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES"}],
+        "VK_EXT_image_sliced_view_of_3d": [{"VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT"}],
+        "VK_EXT_image_view_min_lod": [{"VkPhysicalDeviceImageViewMinLodFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT"}],
+        "VK_EXT_index_type_uint8": [{"VkPhysicalDeviceIndexTypeUint8FeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES"}],
+        "VK_EXT_inline_uniform_block": [
+            {"VkPhysicalDeviceInlineUniformBlockFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES"},
+            {"VkPhysicalDeviceInlineUniformBlockPropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES"},
+        ],
+        "VK_EXT_legacy_dithering": [{"VkPhysicalDeviceLegacyDitheringFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT"}],
+        "VK_EXT_legacy_vertex_attributes": [
+            {"VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT"},
+            {"VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT"},
+        ],
+        "VK_EXT_line_rasterization": [
+            {"VkPhysicalDeviceLineRasterizationFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES"},
+            {"VkPhysicalDeviceLineRasterizationPropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES"},
+        ],
+        "VK_EXT_map_memory_placed": [
+            {"VkPhysicalDeviceMapMemoryPlacedFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT"},
+            {"VkPhysicalDeviceMapMemoryPlacedPropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT"},
+        ],
+        "VK_EXT_memory_priority": [{"VkPhysicalDeviceMemoryPriorityFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT"}],
+        "VK_EXT_mesh_shader": [
+            {"VkPhysicalDeviceMeshShaderFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT"},
+            {"VkPhysicalDeviceMeshShaderPropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT"},
+        ],
+        "VK_EXT_multi_draw": [
+            {"VkPhysicalDeviceMultiDrawFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT"},
+            {"VkPhysicalDeviceMultiDrawPropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT"},
+        ],
+        "VK_EXT_multisampled_render_to_single_sampled": [
+            {"VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT"}
+        ],
+        "VK_EXT_mutable_descriptor_type": [{"VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT"}],
+        "VK_EXT_nested_command_buffer": [
+            {"VkPhysicalDeviceNestedCommandBufferFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT"},
+            {"VkPhysicalDeviceNestedCommandBufferPropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT"},
+        ],
+        "VK_EXT_non_seamless_cube_map": [{"VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT"}],
+        "VK_EXT_opacity_micromap": [
+            {"VkPhysicalDeviceOpacityMicromapFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT"},
+            {"VkPhysicalDeviceOpacityMicromapPropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT"},
+        ],
+        "VK_EXT_pageable_device_local_memory": [{"VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT"}],
+        "VK_EXT_pci_bus_info": [{"VkPhysicalDevicePCIBusInfoPropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT"}],
+        "VK_EXT_physical_device_drm": [{"VkPhysicalDeviceDrmPropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT"}],
+        "VK_EXT_pipeline_creation_cache_control": [{"VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES"}],
+        "VK_EXT_pipeline_library_group_handles": [{"VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT"}],
+        "VK_EXT_pipeline_properties": [{"VkPhysicalDevicePipelinePropertiesFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT"}],
+        "VK_EXT_pipeline_protected_access": [{"VkPhysicalDevicePipelineProtectedAccessFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES"}],
+        "VK_EXT_pipeline_robustness": [
+            {"VkPhysicalDevicePipelineRobustnessFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES"},
+            {"VkPhysicalDevicePipelineRobustnessPropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES"},
+        ],
+        "VK_EXT_primitive_topology_list_restart": [{"VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT"}],
+        "VK_EXT_primitives_generated_query": [{"VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT"}],
+        "VK_EXT_private_data": [{"VkPhysicalDevicePrivateDataFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES"}],
+        "VK_EXT_provoking_vertex": [
+            {"VkPhysicalDeviceProvokingVertexFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT"},
+            {"VkPhysicalDeviceProvokingVertexPropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT"},
+        ],
+        "VK_EXT_rasterization_order_attachment_access": [
+            {"VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT"}
+        ],
+        "VK_EXT_rgba10x6_formats": [{"VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT"}],
+        "VK_EXT_robustness2": [
+            {"VkPhysicalDeviceRobustness2FeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT"},
+            {"VkPhysicalDeviceRobustness2PropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT"},
+        ],
+        "VK_EXT_sample_locations": [{"VkPhysicalDeviceSampleLocationsPropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT"}],
+        "VK_EXT_sampler_filter_minmax": [{"VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES"}],
+        "VK_EXT_scalar_block_layout": [{"VkPhysicalDeviceScalarBlockLayoutFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES"}],
+        "VK_EXT_shader_atomic_float": [{"VkPhysicalDeviceShaderAtomicFloatFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT"}],
+        "VK_EXT_shader_atomic_float2": [{"VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT"}],
+        "VK_EXT_shader_demote_to_helper_invocation": [{"VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES"}],
+        "VK_EXT_shader_image_atomic_int64": [{"VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT"}],
+        "VK_EXT_shader_module_identifier": [
+            {"VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT"},
+            {"VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT"},
+        ],
+        "VK_EXT_shader_object": [
+            {"VkPhysicalDeviceShaderObjectFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT"},
+            {"VkPhysicalDeviceShaderObjectPropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT"},
+        ],
+        "VK_EXT_shader_replicated_composites": [{"VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT"}],
+        "VK_EXT_shader_tile_image": [
+            {"VkPhysicalDeviceShaderTileImageFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT"},
+            {"VkPhysicalDeviceShaderTileImagePropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT"},
+        ],
+        "VK_EXT_subgroup_size_control": [
+            {"VkPhysicalDeviceSubgroupSizeControlFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES"},
+            {"VkPhysicalDeviceSubgroupSizeControlPropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES"},
+        ],
+        "VK_EXT_subpass_merge_feedback": [{"VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT"}],
+        "VK_EXT_swapchain_maintenance1": [{"VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT"}],
+        "VK_EXT_texel_buffer_alignment": [
+            {"VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT"},
+            {"VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES"},
+        ],
+        "VK_EXT_texture_compression_astc_hdr": [{"VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES"}],
+        "VK_EXT_transform_feedback": [
+            {"VkPhysicalDeviceTransformFeedbackFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT"},
+            {"VkPhysicalDeviceTransformFeedbackPropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT"},
+        ],
+        "VK_EXT_vertex_attribute_divisor": [
+            {"VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT"},
+            {"VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES"},
+        ],
+        "VK_EXT_vertex_input_dynamic_state": [{"VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT"}],
+        "VK_EXT_ycbcr_2plane_444_formats": [{"VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT"}],
+        "VK_EXT_ycbcr_image_arrays": [{"VkPhysicalDeviceYcbcrImageArraysFeaturesEXT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT"}],
+        "VK_HUAWEI_cluster_culling_shader": [
+            {"VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI"},
+            {"VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI"},
+        ],
+        "VK_HUAWEI_invocation_mask": [{"VkPhysicalDeviceInvocationMaskFeaturesHUAWEI": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI"}],
+        "VK_HUAWEI_subpass_shading": [
+            {"VkPhysicalDeviceSubpassShadingFeaturesHUAWEI": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI"},
+            {"VkPhysicalDeviceSubpassShadingPropertiesHUAWEI": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI"},
+        ],
+        "VK_IMG_relaxed_line_rasterization": [{"VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG"}],
+        "VK_INTEL_shader_integer_functions2": [{"VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL"}],
+        "VK_KHR_16bit_storage": [{"VkPhysicalDevice16BitStorageFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES"}],
+        "VK_KHR_8bit_storage": [{"VkPhysicalDevice8BitStorageFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES"}],
+        "VK_KHR_acceleration_structure": [
+            {"VkPhysicalDeviceAccelerationStructureFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR"},
+            {"VkPhysicalDeviceAccelerationStructurePropertiesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR"},
+        ],
+        "VK_KHR_buffer_device_address": [{"VkPhysicalDeviceBufferDeviceAddressFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES"}],
+        "VK_KHR_cooperative_matrix": [
+            {"VkPhysicalDeviceCooperativeMatrixFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR"},
+            {"VkPhysicalDeviceCooperativeMatrixPropertiesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR"},
+        ],
+        "VK_KHR_depth_stencil_resolve": [{"VkPhysicalDeviceDepthStencilResolvePropertiesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES"}],
+        "VK_KHR_driver_properties": [{"VkPhysicalDeviceDriverPropertiesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES"}],
+        "VK_KHR_dynamic_rendering": [{"VkPhysicalDeviceDynamicRenderingFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES"}],
+        "VK_KHR_dynamic_rendering_local_read": [{"VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES"}],
+        "VK_KHR_external_memory_capabilities": [{"VkPhysicalDeviceIDPropertiesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES"}],
+        "VK_KHR_fragment_shader_barycentric": [
+            {"VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR"},
+            {"VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR"},
+        ],
+        "VK_KHR_fragment_shading_rate": [
+            {"VkPhysicalDeviceFragmentShadingRateFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR"},
+            {"VkPhysicalDeviceFragmentShadingRatePropertiesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR"},
+        ],
+        "VK_KHR_global_priority": [{"VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES"}],
+        "VK_KHR_imageless_framebuffer": [{"VkPhysicalDeviceImagelessFramebufferFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES"}],
+        "VK_KHR_index_type_uint8": [{"VkPhysicalDeviceIndexTypeUint8FeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES"}],
+        "VK_KHR_line_rasterization": [
+            {"VkPhysicalDeviceLineRasterizationFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES"},
+            {"VkPhysicalDeviceLineRasterizationPropertiesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES"},
+        ],
+        "VK_KHR_maintenance2": [{"VkPhysicalDevicePointClippingPropertiesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES"}],
+        "VK_KHR_maintenance3": [{"VkPhysicalDeviceMaintenance3PropertiesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES"}],
+        "VK_KHR_maintenance4": [
+            {"VkPhysicalDeviceMaintenance4FeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES"},
+            {"VkPhysicalDeviceMaintenance4PropertiesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES"},
+        ],
+        "VK_KHR_maintenance5": [
+            {"VkPhysicalDeviceMaintenance5FeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES"},
+            {"VkPhysicalDeviceMaintenance5PropertiesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES"},
+        ],
+        "VK_KHR_maintenance6": [
+            {"VkPhysicalDeviceMaintenance6FeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES"},
+            {"VkPhysicalDeviceMaintenance6PropertiesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES"},
+        ],
+        "VK_KHR_maintenance7": [
+            {"VkPhysicalDeviceMaintenance7FeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR"},
+            {"VkPhysicalDeviceMaintenance7PropertiesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR"},
+            {"VkPhysicalDeviceLayeredApiPropertiesListKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR"},
+        ],
+        "VK_KHR_multiview": [
+            {"VkPhysicalDeviceMultiviewFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES"},
+            {"VkPhysicalDeviceMultiviewPropertiesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES"},
+        ],
+        "VK_KHR_performance_query": [
+            {"VkPhysicalDevicePerformanceQueryFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR"},
+            {"VkPhysicalDevicePerformanceQueryPropertiesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR"},
+        ],
+        "VK_KHR_pipeline_binary": [
+            {"VkPhysicalDevicePipelineBinaryFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR"},
+            {"VkPhysicalDevicePipelineBinaryPropertiesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR"},
+        ],
+        "VK_KHR_pipeline_executable_properties": [{"VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR"}],
+        "VK_KHR_present_id": [{"VkPhysicalDevicePresentIdFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR"}],
+        "VK_KHR_present_wait": [{"VkPhysicalDevicePresentWaitFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR"}],
+        "VK_KHR_push_descriptor": [{"VkPhysicalDevicePushDescriptorPropertiesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES"}],
+        "VK_KHR_ray_query": [{"VkPhysicalDeviceRayQueryFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR"}],
+        "VK_KHR_ray_tracing_maintenance1": [{"VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR"}],
+        "VK_KHR_ray_tracing_pipeline": [
+            {"VkPhysicalDeviceRayTracingPipelineFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR"},
+            {"VkPhysicalDeviceRayTracingPipelinePropertiesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR"},
+        ],
+        "VK_KHR_ray_tracing_position_fetch": [{"VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR"}],
+        "VK_KHR_sampler_ycbcr_conversion": [{"VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES"}],
+        "VK_KHR_separate_depth_stencil_layouts": [{"VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES"}],
+        "VK_KHR_shader_atomic_int64": [{"VkPhysicalDeviceShaderAtomicInt64FeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES"}],
+        "VK_KHR_shader_clock": [{"VkPhysicalDeviceShaderClockFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR"}],
+        "VK_KHR_shader_expect_assume": [{"VkPhysicalDeviceShaderExpectAssumeFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES"}],
+        "VK_KHR_shader_float16_int8": [
+            {"VkPhysicalDeviceShaderFloat16Int8FeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES"},
+            {"VkPhysicalDeviceFloat16Int8FeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES"},
+        ],
+        "VK_KHR_shader_float_controls": [{"VkPhysicalDeviceFloatControlsPropertiesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES"}],
+        "VK_KHR_shader_float_controls2": [{"VkPhysicalDeviceShaderFloatControls2FeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES"}],
+        "VK_KHR_shader_integer_dot_product": [
+            {"VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES"},
+            {"VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES"},
+        ],
+        "VK_KHR_shader_maximal_reconvergence": [{"VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR"}],
+        "VK_KHR_shader_quad_control": [{"VkPhysicalDeviceShaderQuadControlFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR"}],
+        "VK_KHR_shader_relaxed_extended_instruction": [
+            {"VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR"}
+        ],
+        "VK_KHR_shader_subgroup_extended_types": [{"VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES"}],
+        "VK_KHR_shader_subgroup_rotate": [{"VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES"}],
+        "VK_KHR_shader_subgroup_uniform_control_flow": [
+            {"VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR"}
+        ],
+        "VK_KHR_shader_terminate_invocation": [{"VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES"}],
+        "VK_KHR_synchronization2": [{"VkPhysicalDeviceSynchronization2FeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES"}],
+        "VK_KHR_timeline_semaphore": [
+            {"VkPhysicalDeviceTimelineSemaphoreFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES"},
+            {"VkPhysicalDeviceTimelineSemaphorePropertiesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES"},
+        ],
+        "VK_KHR_uniform_buffer_standard_layout": [{"VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES"}],
+        "VK_KHR_variable_pointers": [
+            {"VkPhysicalDeviceVariablePointerFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES"},
+            {"VkPhysicalDeviceVariablePointersFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES"},
+        ],
+        "VK_KHR_vertex_attribute_divisor": [
+            {"VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES"},
+            {"VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES"},
+        ],
+        "VK_KHR_video_maintenance1": [{"VkPhysicalDeviceVideoMaintenance1FeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR"}],
+        "VK_KHR_vulkan_memory_model": [{"VkPhysicalDeviceVulkanMemoryModelFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES"}],
+        "VK_KHR_workgroup_memory_explicit_layout": [{"VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR"}],
+        "VK_KHR_zero_initialize_workgroup_memory": [{"VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES"}],
+        "VK_MESA_image_alignment_control": [
+            {"VkPhysicalDeviceImageAlignmentControlFeaturesMESA": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA"},
+            {"VkPhysicalDeviceImageAlignmentControlPropertiesMESA": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA"},
+        ],
+        "VK_MSFT_layered_driver": [{"VkPhysicalDeviceLayeredDriverPropertiesMSFT": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT"}],
+        "VK_NVX_multiview_per_view_attributes": [{"VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX"}],
+        "VK_NV_command_buffer_inheritance": [{"VkPhysicalDeviceCommandBufferInheritanceFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV"}],
+        "VK_NV_compute_shader_derivatives": [{"VkPhysicalDeviceComputeShaderDerivativesFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV"}],
+        "VK_NV_cooperative_matrix": [
+            {"VkPhysicalDeviceCooperativeMatrixFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV"},
+            {"VkPhysicalDeviceCooperativeMatrixPropertiesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV"},
+        ],
+        "VK_NV_copy_memory_indirect": [
+            {"VkPhysicalDeviceCopyMemoryIndirectFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV"},
+            {"VkPhysicalDeviceCopyMemoryIndirectPropertiesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV"},
+        ],
+        "VK_NV_corner_sampled_image": [{"VkPhysicalDeviceCornerSampledImageFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV"}],
+        "VK_NV_coverage_reduction_mode": [{"VkPhysicalDeviceCoverageReductionModeFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV"}],
+        "VK_NV_cuda_kernel_launch": [
+            {"VkPhysicalDeviceCudaKernelLaunchFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV"},
+            {"VkPhysicalDeviceCudaKernelLaunchPropertiesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV"},
+        ],
+        "VK_NV_dedicated_allocation_image_aliasing": [
+            {"VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV"}
+        ],
+        "VK_NV_descriptor_pool_overallocation": [{"VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV"}],
+        "VK_NV_device_diagnostics_config": [{"VkPhysicalDeviceDiagnosticsConfigFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV"}],
+        "VK_NV_device_generated_commands": [
+            {"VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV"},
+            {"VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV"},
+        ],
+        "VK_NV_device_generated_commands_compute": [{"VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV"}],
+        "VK_NV_extended_sparse_address_space": [
+            {"VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV"},
+            {"VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV"},
+        ],
+        "VK_NV_external_memory_rdma": [{"VkPhysicalDeviceExternalMemoryRDMAFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV"}],
+        "VK_NV_fragment_shading_rate_enums": [
+            {"VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV"},
+            {"VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV"},
+        ],
+        "VK_NV_inherited_viewport_scissor": [{"VkPhysicalDeviceInheritedViewportScissorFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV"}],
+        "VK_NV_linear_color_attachment": [{"VkPhysicalDeviceLinearColorAttachmentFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV"}],
+        "VK_NV_memory_decompression": [
+            {"VkPhysicalDeviceMemoryDecompressionFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV"},
+            {"VkPhysicalDeviceMemoryDecompressionPropertiesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV"},
+        ],
+        "VK_NV_mesh_shader": [
+            {"VkPhysicalDeviceMeshShaderFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV"},
+            {"VkPhysicalDeviceMeshShaderPropertiesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV"},
+        ],
+        "VK_NV_optical_flow": [
+            {"VkPhysicalDeviceOpticalFlowFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV"},
+            {"VkPhysicalDeviceOpticalFlowPropertiesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV"},
+        ],
+        "VK_NV_per_stage_descriptor_set": [{"VkPhysicalDevicePerStageDescriptorSetFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV"}],
+        "VK_NV_present_barrier": [{"VkPhysicalDevicePresentBarrierFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV"}],
+        "VK_NV_raw_access_chains": [{"VkPhysicalDeviceRawAccessChainsFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV"}],
+        "VK_NV_ray_tracing": [{"VkPhysicalDeviceRayTracingPropertiesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV"}],
+        "VK_NV_ray_tracing_invocation_reorder": [
+            {"VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV"},
+            {"VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV"},
+        ],
+        "VK_NV_ray_tracing_motion_blur": [{"VkPhysicalDeviceRayTracingMotionBlurFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV"}],
+        "VK_NV_ray_tracing_validation": [{"VkPhysicalDeviceRayTracingValidationFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV"}],
+        "VK_NV_representative_fragment_test": [{"VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV"}],
+        "VK_NV_scissor_exclusive": [{"VkPhysicalDeviceExclusiveScissorFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV"}],
+        "VK_NV_shader_atomic_float16_vector": [{"VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV"}],
+        "VK_NV_shader_image_footprint": [{"VkPhysicalDeviceShaderImageFootprintFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV"}],
+        "VK_NV_shader_sm_builtins": [
+            {"VkPhysicalDeviceShaderSMBuiltinsPropertiesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV"},
+            {"VkPhysicalDeviceShaderSMBuiltinsFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV"},
+        ],
+        "VK_NV_shading_rate_image": [
+            {"VkPhysicalDeviceShadingRateImageFeaturesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV"},
+            {"VkPhysicalDeviceShadingRateImagePropertiesNV": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV"},
+        ],
+        "VK_QCOM_filter_cubic_clamp": [{"VkPhysicalDeviceCubicClampFeaturesQCOM": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM"}],
+        "VK_QCOM_filter_cubic_weights": [{"VkPhysicalDeviceCubicWeightsFeaturesQCOM": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM"}],
+        "VK_QCOM_fragment_density_map_offset": [
+            {"VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM"},
+            {"VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM"},
+        ],
+        "VK_QCOM_image_processing": [
+            {"VkPhysicalDeviceImageProcessingFeaturesQCOM": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM"},
+            {"VkPhysicalDeviceImageProcessingPropertiesQCOM": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM"},
+        ],
+        "VK_QCOM_image_processing2": [
+            {"VkPhysicalDeviceImageProcessing2FeaturesQCOM": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM"},
+            {"VkPhysicalDeviceImageProcessing2PropertiesQCOM": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM"},
+        ],
+        "VK_QCOM_multiview_per_view_render_areas": [{"VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM"}],
+        "VK_QCOM_multiview_per_view_viewports": [{"VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM"}],
+        "VK_QCOM_tile_properties": [{"VkPhysicalDeviceTilePropertiesFeaturesQCOM": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM"}],
+        "VK_QCOM_ycbcr_degamma": [{"VkPhysicalDeviceYcbcrDegammaFeaturesQCOM": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM"}],
+        "VK_SEC_amigo_profiling": [{"VkPhysicalDeviceAmigoProfilingFeaturesSEC": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC"}],
+        "VK_VALVE_descriptor_set_host_mapping": [{"VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE"}],
+        "VK_VALVE_mutable_descriptor_type": [{"VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT"}],
+    }
+}
+
+# --- Vulkan Feature to Struct Mappings ---
+# VULKAN_VERSIONS_AND_STRUCTS_MAPPING: Maps API features (e.g., "VK_API_VERSION_1_1")
+# from "vulkan" API to PhysicalDevice structs they introduce.
+# Excludes core version structs (e.g., VkPhysicalDeviceVulkan11Properties), see VULKAN_CORES_AND_STRUCTS_MAPPING.
+# Struct Filters (per feature):
+# - Name: Starts "VkPhysicalDevice".
+# - Not in global 'disabled_structs'.
+# - Extends "VkPhysicalDeviceProperties2" or "VkPhysicalDeviceFeatures2".
+# - Not in CORE_MAPPING_STRUCT_LIST.
+# NOTE:
+# VK_VERSION_1_0" is empty as it does not map to any structure which passes our structure-filter criteria.
+# We have hardcoded the code-block for VK_VERSION_1_0 in vkjson_generator.py
+# Format: {feature_name: [{struct_name: sType_enum_value}, ...]}
+
+VULKAN_VERSIONS_AND_STRUCTS_MAPPING = {
+    "VK_VERSION_1_0": [],
+    "VK_VERSION_1_1": [
+        {"VkPhysicalDeviceSubgroupProperties": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES"},
+        {"VkPhysicalDevice16BitStorageFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES"},
+        {"VkPhysicalDevicePointClippingProperties": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES"},
+        {"VkPhysicalDeviceMultiviewFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES"},
+        {"VkPhysicalDeviceMultiviewProperties": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES"},
+        {"VkPhysicalDeviceVariablePointerFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES"},
+        {"VkPhysicalDeviceVariablePointersFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES"},
+        {"VkPhysicalDeviceProtectedMemoryFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES"},
+        {"VkPhysicalDeviceProtectedMemoryProperties": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES"},
+        {"VkPhysicalDeviceSamplerYcbcrConversionFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES"},
+        {"VkPhysicalDeviceIDProperties": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES"},
+        {"VkPhysicalDeviceMaintenance3Properties": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES"},
+        {"VkPhysicalDeviceShaderDrawParameterFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES"},
+        {"VkPhysicalDeviceShaderDrawParametersFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES"},
+    ],
+    "VK_VERSION_1_2": [
+        {"VkPhysicalDevice8BitStorageFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES"},
+        {"VkPhysicalDeviceDriverProperties": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES"},
+        {"VkPhysicalDeviceShaderAtomicInt64Features": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES"},
+        {"VkPhysicalDeviceShaderFloat16Int8Features": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES"},
+        {"VkPhysicalDeviceFloatControlsProperties": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES"},
+        {"VkPhysicalDeviceDescriptorIndexingFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES"},
+        {"VkPhysicalDeviceDescriptorIndexingProperties": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES"},
+        {"VkPhysicalDeviceDepthStencilResolveProperties": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES"},
+        {"VkPhysicalDeviceScalarBlockLayoutFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES"},
+        {"VkPhysicalDeviceSamplerFilterMinmaxProperties": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES"},
+        {"VkPhysicalDeviceVulkanMemoryModelFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES"},
+        {"VkPhysicalDeviceImagelessFramebufferFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES"},
+        {"VkPhysicalDeviceUniformBufferStandardLayoutFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES"},
+        {"VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES"},
+        {"VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES"},
+        {"VkPhysicalDeviceHostQueryResetFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES"},
+        {"VkPhysicalDeviceTimelineSemaphoreFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES"},
+        {"VkPhysicalDeviceTimelineSemaphoreProperties": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES"},
+        {"VkPhysicalDeviceBufferDeviceAddressFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES"},
+    ],
+    "VK_VERSION_1_3": [
+        {"VkPhysicalDeviceShaderTerminateInvocationFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES"},
+        {"VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES"},
+        {"VkPhysicalDevicePrivateDataFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES"},
+        {"VkPhysicalDevicePipelineCreationCacheControlFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES"},
+        {"VkPhysicalDeviceSynchronization2Features": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES"},
+        {"VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES"},
+        {"VkPhysicalDeviceImageRobustnessFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES"},
+        {"VkPhysicalDeviceSubgroupSizeControlFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES"},
+        {"VkPhysicalDeviceSubgroupSizeControlProperties": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES"},
+        {"VkPhysicalDeviceInlineUniformBlockFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES"},
+        {"VkPhysicalDeviceInlineUniformBlockProperties": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES"},
+        {"VkPhysicalDeviceTextureCompressionASTCHDRFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES"},
+        {"VkPhysicalDeviceDynamicRenderingFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES"},
+        {"VkPhysicalDeviceShaderIntegerDotProductFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES"},
+        {"VkPhysicalDeviceShaderIntegerDotProductProperties": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES"},
+        {"VkPhysicalDeviceTexelBufferAlignmentProperties": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES"},
+        {"VkPhysicalDeviceMaintenance4Features": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES"},
+        {"VkPhysicalDeviceMaintenance4Properties": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES"},
+    ],
+    "VK_VERSION_1_4": [
+        {"VkPhysicalDeviceGlobalPriorityQueryFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES"},
+        {"VkPhysicalDeviceShaderSubgroupRotateFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES"},
+        {"VkPhysicalDeviceShaderFloatControls2Features": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES"},
+        {"VkPhysicalDeviceShaderExpectAssumeFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES"},
+        {"VkPhysicalDeviceLineRasterizationFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES"},
+        {"VkPhysicalDeviceLineRasterizationProperties": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES"},
+        {"VkPhysicalDeviceVertexAttributeDivisorProperties": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES"},
+        {"VkPhysicalDeviceVertexAttributeDivisorFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES"},
+        {"VkPhysicalDeviceIndexTypeUint8Features": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES"},
+        {"VkPhysicalDeviceMaintenance5Features": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES"},
+        {"VkPhysicalDeviceMaintenance5Properties": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES"},
+        {"VkPhysicalDevicePushDescriptorProperties": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES"},
+        {"VkPhysicalDeviceDynamicRenderingLocalReadFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES"},
+        {"VkPhysicalDeviceMaintenance6Features": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES"},
+        {"VkPhysicalDeviceMaintenance6Properties": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES"},
+        {"VkPhysicalDevicePipelineProtectedAccessFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES"},
+        {"VkPhysicalDevicePipelineRobustnessFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES"},
+        {"VkPhysicalDevicePipelineRobustnessProperties": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES"},
+        {"VkPhysicalDeviceHostImageCopyFeatures": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES"},
+    ],
+}
+
+
+# --- Extension Independent Structs ---
+# These are PhysicalDevice structs that meet the following criteria:
+# 1. Sourced from VK_PHYSICAL_STRUCT_NAMES.
+# 2. Not in the global 'disabled_structs' list.
+# 3. Extend "VkPhysicalDeviceProperties2" or "VkPhysicalDeviceFeatures2" (in 'structs_with_valid_extends').
+# 4. Not core version-specific (not in CORE_MAPPING_STRUCT_LIST).
+# 5. Not required by any enabled Vulkan extension (not in 'structs_in_extensions').
+
+EXTENSION_INDEPENDENT_STRUCTS = [
+    "VkPhysicalDevice16BitStorageFeatures",
+    "VkPhysicalDevice8BitStorageFeatures",
+    "VkPhysicalDeviceBufferDeviceAddressFeatures",
+    "VkPhysicalDeviceDepthStencilResolveProperties",
+    "VkPhysicalDeviceDescriptorIndexingFeatures",
+    "VkPhysicalDeviceDescriptorIndexingProperties",
+    "VkPhysicalDeviceDriverProperties",
+    "VkPhysicalDeviceDynamicRenderingFeatures",
+    "VkPhysicalDeviceDynamicRenderingLocalReadFeatures",
+    "VkPhysicalDeviceFloatControlsProperties",
+    "VkPhysicalDeviceGlobalPriorityQueryFeatures",
+    "VkPhysicalDeviceHostImageCopyFeatures",
+    "VkPhysicalDeviceHostQueryResetFeatures",
+    "VkPhysicalDeviceIDProperties",
+    "VkPhysicalDeviceImageRobustnessFeatures",
+    "VkPhysicalDeviceImagelessFramebufferFeatures",
+    "VkPhysicalDeviceIndexTypeUint8Features",
+    "VkPhysicalDeviceInlineUniformBlockFeatures",
+    "VkPhysicalDeviceInlineUniformBlockProperties",
+    "VkPhysicalDeviceLineRasterizationFeatures",
+    "VkPhysicalDeviceLineRasterizationProperties",
+    "VkPhysicalDeviceMaintenance3Properties",
+    "VkPhysicalDeviceMaintenance4Features",
+    "VkPhysicalDeviceMaintenance4Properties",
+    "VkPhysicalDeviceMaintenance5Features",
+    "VkPhysicalDeviceMaintenance5Properties",
+    "VkPhysicalDeviceMaintenance6Features",
+    "VkPhysicalDeviceMaintenance6Properties",
+    "VkPhysicalDeviceMultiviewFeatures",
+    "VkPhysicalDeviceMultiviewProperties",
+    "VkPhysicalDevicePipelineCreationCacheControlFeatures",
+    "VkPhysicalDevicePipelineProtectedAccessFeatures",
+    "VkPhysicalDevicePipelineRobustnessFeatures",
+    "VkPhysicalDevicePipelineRobustnessProperties",
+    "VkPhysicalDevicePointClippingProperties",
+    "VkPhysicalDevicePrivateDataFeatures",
+    "VkPhysicalDeviceProtectedMemoryFeatures",
+    "VkPhysicalDeviceProtectedMemoryProperties",
+    "VkPhysicalDevicePushDescriptorProperties",
+    "VkPhysicalDeviceSamplerFilterMinmaxProperties",
+    "VkPhysicalDeviceSamplerYcbcrConversionFeatures",
+    "VkPhysicalDeviceScalarBlockLayoutFeatures",
+    "VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures",
+    "VkPhysicalDeviceShaderAtomicInt64Features",
+    "VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures",
+    "VkPhysicalDeviceShaderDrawParameterFeatures",
+    "VkPhysicalDeviceShaderDrawParametersFeatures",
+    "VkPhysicalDeviceShaderExpectAssumeFeatures",
+    "VkPhysicalDeviceShaderFloat16Int8Features",
+    "VkPhysicalDeviceShaderFloatControls2Features",
+    "VkPhysicalDeviceShaderIntegerDotProductFeatures",
+    "VkPhysicalDeviceShaderIntegerDotProductProperties",
+    "VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures",
+    "VkPhysicalDeviceShaderSubgroupRotateFeatures",
+    "VkPhysicalDeviceShaderTerminateInvocationFeatures",
+    "VkPhysicalDeviceSubgroupProperties",
+    "VkPhysicalDeviceSubgroupSizeControlFeatures",
+    "VkPhysicalDeviceSubgroupSizeControlProperties",
+    "VkPhysicalDeviceSynchronization2Features",
+    "VkPhysicalDeviceTexelBufferAlignmentProperties",
+    "VkPhysicalDeviceTextureCompressionASTCHDRFeatures",
+    "VkPhysicalDeviceTimelineSemaphoreFeatures",
+    "VkPhysicalDeviceTimelineSemaphoreProperties",
+    "VkPhysicalDeviceUniformBufferStandardLayoutFeatures",
+    "VkPhysicalDeviceVariablePointerFeatures",
+    "VkPhysicalDeviceVariablePointersFeatures",
+    "VkPhysicalDeviceVertexAttributeDivisorFeatures",
+    "VkPhysicalDeviceVertexAttributeDivisorProperties",
+    "VkPhysicalDeviceVulkanMemoryModelFeatures",
+    "VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures",
+]
+
+
+# --- Vulkan Core Version to Struct Mappings ---
+# VULKAN_CORES_AND_STRUCTS_MAPPING: Maps core Vulkan versions (e.g., "Core11") to their
+# specific PhysicalDevice Properties and Features structs.
+# Struct Filters:
+# - Name matches "VkPhysicalDeviceVulkan<Version><Properties|Features>" (from CORE_MAPPING_STRUCT_LIST).
+# - sType is programmatically derived.
+# Format: {"versions": {core_version_key: [{struct_name: sType_enum_value}, ...]}}
+
+VULKAN_CORES_AND_STRUCTS_MAPPING = {
+    "versions": {
+        "Core11": [
+            {"VkPhysicalDeviceVulkan11Features": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES"},
+            {"VkPhysicalDeviceVulkan11Properties": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES"},
+        ],
+        "Core12": [
+            {"VkPhysicalDeviceVulkan12Features": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES"},
+            {"VkPhysicalDeviceVulkan12Properties": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES"},
+        ],
+        "Core13": [
+            {"VkPhysicalDeviceVulkan13Features": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES"},
+            {"VkPhysicalDeviceVulkan13Properties": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES"},
+        ],
+        "Core14": [
+            {"VkPhysicalDeviceVulkan14Features": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES"},
+            {"VkPhysicalDeviceVulkan14Properties": "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES"},
+        ],
+    }
+}
+
+# --- List Size Mappings (Field name to size field name) ---
+
+LIST_TYPE_FIELD_AND_SIZE_MAPPING = {
+    "memoryHeaps": "memoryHeapCount",
+    "memoryTypes": "memoryTypeCount",
+    "pCopyDstLayouts": "copyDstLayoutCount",
+    "pCopySrcLayouts": "copySrcLayoutCount",
+    "pLayeredApis": "layeredApiCount",
+    "physicalDevices": "physicalDeviceCount",
+}
+
+
+# --- STRUCTS USED BY VULKAN_API_1_0 ---
+
+VULKAN_API_1_0_STRUCTS = [
+    VkPhysicalDeviceProperties,
+    VkPhysicalDeviceMemoryProperties,
+    VkPhysicalDeviceSparseProperties,
+    VkImageFormatProperties,
+    VkQueueFamilyProperties,
+    VkExtensionProperties,
+    VkLayerProperties,
+    VkFormatProperties,
+    VkPhysicalDeviceLimits,
+    VkPhysicalDeviceFeatures,
+]
+
+
+# --- ADDITIONAL EXTENSION INDEPENDENT STRUCTS ---
+
+ADDITIONAL_EXTENSION_INDEPENDENT_STRUCTS = ["VkPhysicalDeviceProperties", "VkPhysicalDeviceFeatures", "VkPhysicalDeviceMemoryProperties"]
+
+
+# --- STRUCT EXTENDS MAPPINGS ---
+
+STRUCT_EXTENDS_MAPPING = {
+    "VkPhysicalDevice16BitStorageFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDevice16BitStorageFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDevice4444FormatsFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDevice8BitStorageFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDevice8BitStorageFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceASTCDecodeFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceAccelerationStructureFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceAccelerationStructurePropertiesKHR": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceAddressBindingReportFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceAmigoProfilingFeaturesSEC": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceAntiLagFeaturesAMD": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceBorderColorSwizzleFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceBufferAddressFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceBufferDeviceAddressFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceBufferDeviceAddressFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceBufferDeviceAddressFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceCoherentMemoryFeaturesAMD": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceColorWriteEnableFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceCommandBufferInheritanceFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceComputeShaderDerivativesFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceConditionalRenderingFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceConservativeRasterizationPropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceCooperativeMatrixFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceCooperativeMatrixFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceCooperativeMatrixPropertiesKHR": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceCooperativeMatrixPropertiesNV": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceCopyMemoryIndirectFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceCopyMemoryIndirectPropertiesNV": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceCornerSampledImageFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceCoverageReductionModeFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceCubicClampFeaturesQCOM": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceCubicWeightsFeaturesQCOM": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceCudaKernelLaunchFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceCudaKernelLaunchPropertiesNV": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceCustomBorderColorFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceCustomBorderColorPropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceDepthBiasControlFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceDepthClampZeroOneFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceDepthClipControlFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceDepthClipEnableFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceDepthStencilResolveProperties": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceDepthStencilResolvePropertiesKHR": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceDescriptorBufferFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceDescriptorBufferPropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceDescriptorIndexingFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceDescriptorIndexingFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceDescriptorIndexingProperties": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceDescriptorIndexingPropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceDeviceMemoryReportFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceDiagnosticsConfigFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceDiscardRectanglePropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceDriverProperties": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceDriverPropertiesKHR": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceDrmPropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceDynamicRenderingFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceDynamicRenderingFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceDynamicRenderingLocalReadFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceExclusiveScissorFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceExtendedDynamicState2FeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceExtendedDynamicState3FeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceExtendedDynamicState3PropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceExtendedDynamicStateFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceExternalFormatResolveFeaturesANDROID": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceExternalFormatResolvePropertiesANDROID": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceExternalMemoryHostPropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceExternalMemoryRDMAFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceFaultFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceFloat16Int8FeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceFloatControlsProperties": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceFloatControlsPropertiesKHR": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceFragmentDensityMap2FeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceFragmentDensityMap2PropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceFragmentDensityMapFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceFragmentDensityMapPropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceFragmentShadingRateFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceFragmentShadingRatePropertiesKHR": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceFrameBoundaryFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceGlobalPriorityQueryFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceHostImageCopyFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceHostImageCopyFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceHostQueryResetFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceHostQueryResetFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceIDProperties": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceIDPropertiesKHR": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceImage2DViewOf3DFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceImageAlignmentControlFeaturesMESA": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceImageAlignmentControlPropertiesMESA": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceImageCompressionControlFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceImageProcessing2FeaturesQCOM": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceImageProcessing2PropertiesQCOM": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceImageProcessingFeaturesQCOM": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceImageProcessingPropertiesQCOM": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceImageRobustnessFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceImageRobustnessFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceImageViewMinLodFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceImagelessFramebufferFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceImagelessFramebufferFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceIndexTypeUint8Features": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceIndexTypeUint8FeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceIndexTypeUint8FeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceInheritedViewportScissorFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceInlineUniformBlockFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceInlineUniformBlockFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceInlineUniformBlockProperties": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceInlineUniformBlockPropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceInvocationMaskFeaturesHUAWEI": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceLayeredApiPropertiesListKHR": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceLayeredDriverPropertiesMSFT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceLegacyDitheringFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceLineRasterizationFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceLineRasterizationFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceLineRasterizationFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceLineRasterizationProperties": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceLineRasterizationPropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceLineRasterizationPropertiesKHR": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceLinearColorAttachmentFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceMaintenance3Properties": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceMaintenance3PropertiesKHR": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceMaintenance4Features": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceMaintenance4FeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceMaintenance4Properties": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceMaintenance4PropertiesKHR": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceMaintenance5Features": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceMaintenance5FeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceMaintenance5Properties": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceMaintenance5PropertiesKHR": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceMaintenance6Features": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceMaintenance6FeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceMaintenance6Properties": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceMaintenance6PropertiesKHR": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceMaintenance7FeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceMaintenance7PropertiesKHR": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceMapMemoryPlacedFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceMapMemoryPlacedPropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceMemoryDecompressionFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceMemoryDecompressionPropertiesNV": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceMemoryPriorityFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceMeshShaderFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceMeshShaderFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceMeshShaderPropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceMeshShaderPropertiesNV": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceMultiDrawFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceMultiDrawPropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceMultiviewFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceMultiviewFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceMultiviewProperties": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceMultiviewPropertiesKHR": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceNestedCommandBufferFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceNestedCommandBufferPropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceOpacityMicromapFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceOpacityMicromapPropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceOpticalFlowFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceOpticalFlowPropertiesNV": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDevicePCIBusInfoPropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDevicePerStageDescriptorSetFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDevicePerformanceQueryFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDevicePerformanceQueryPropertiesKHR": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDevicePipelineBinaryFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDevicePipelineBinaryPropertiesKHR": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDevicePipelineCreationCacheControlFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDevicePipelinePropertiesFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDevicePipelineProtectedAccessFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDevicePipelineProtectedAccessFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDevicePipelineRobustnessFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDevicePipelineRobustnessFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDevicePipelineRobustnessProperties": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDevicePipelineRobustnessPropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDevicePointClippingProperties": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDevicePointClippingPropertiesKHR": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDevicePresentBarrierFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDevicePresentIdFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDevicePresentWaitFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDevicePrivateDataFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDevicePrivateDataFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceProtectedMemoryFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceProtectedMemoryProperties": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceProvokingVertexFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceProvokingVertexPropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDevicePushDescriptorProperties": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDevicePushDescriptorPropertiesKHR": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceRawAccessChainsFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceRayQueryFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceRayTracingMotionBlurFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceRayTracingPipelineFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceRayTracingPipelinePropertiesKHR": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceRayTracingPropertiesNV": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceRayTracingValidationFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceRenderPassStripedFeaturesARM": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceRenderPassStripedPropertiesARM": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceRobustness2FeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceRobustness2PropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceSampleLocationsPropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceSamplerFilterMinmaxProperties": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceSamplerYcbcrConversionFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceScalarBlockLayoutFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceScalarBlockLayoutFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceSchedulingControlsFeaturesARM": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceSchedulingControlsPropertiesARM": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderAtomicFloatFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderAtomicInt64Features": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderAtomicInt64FeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderClockFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceShaderCoreProperties2AMD": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceShaderCorePropertiesAMD": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceShaderCorePropertiesARM": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderDrawParameterFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderDrawParametersFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderExpectAssumeFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderExpectAssumeFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderFloat16Int8Features": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderFloat16Int8FeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderFloatControls2Features": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderFloatControls2FeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderImageFootprintFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderIntegerDotProductFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderIntegerDotProductProperties": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceShaderObjectFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderObjectPropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceShaderQuadControlFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderSMBuiltinsFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderSMBuiltinsPropertiesNV": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderSubgroupRotateFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderTerminateInvocationFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderTileImageFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShaderTileImagePropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceShadingRateImageFeaturesNV": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceShadingRateImagePropertiesNV": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceSubgroupProperties": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceSubgroupSizeControlFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceSubgroupSizeControlFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceSubgroupSizeControlProperties": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceSubgroupSizeControlPropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceSubpassShadingFeaturesHUAWEI": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceSubpassShadingPropertiesHUAWEI": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceSynchronization2Features": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceSynchronization2FeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceTexelBufferAlignmentProperties": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceTextureCompressionASTCHDRFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceTilePropertiesFeaturesQCOM": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceTimelineSemaphoreFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceTimelineSemaphoreFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceTimelineSemaphoreProperties": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceTimelineSemaphorePropertiesKHR": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceTransformFeedbackFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceTransformFeedbackPropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceUniformBufferStandardLayoutFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceVariablePointerFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceVariablePointerFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceVariablePointersFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceVariablePointersFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceVertexAttributeDivisorFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceVertexAttributeDivisorProperties": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceVideoMaintenance1FeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceVulkan11Features": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceVulkan11Properties": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceVulkan12Features": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceVulkan12Properties": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceVulkan13Features": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceVulkan13Properties": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceVulkan14Features": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceVulkan14Properties": "VkPhysicalDeviceProperties2",
+    "VkPhysicalDeviceVulkanMemoryModelFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceVulkanMemoryModelFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceYcbcrDegammaFeaturesQCOM": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceYcbcrImageArraysFeaturesEXT": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+    "VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR": "VkPhysicalDeviceFeatures2,VkDeviceCreateInfo",
+}
+
+
+# --- Enum Traits Mapping ---
+
+ENUM_TRAITS_MAPPING = {
+    "VkImageLayout": {
+        "VK_IMAGE_LAYOUT_UNDEFINED": "0",
+        "VK_IMAGE_LAYOUT_GENERAL": "1",
+        "VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL": "2",
+        "VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL": "3",
+        "VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL": "4",
+        "VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL": "5",
+        "VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL": "6",
+        "VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL": "7",
+        "VK_IMAGE_LAYOUT_PREINITIALIZED": "8",
+    },
+    "VkImageType": {"VK_IMAGE_TYPE_1D": "0", "VK_IMAGE_TYPE_2D": "1", "VK_IMAGE_TYPE_3D": "2"},
+    "VkImageTiling": {"VK_IMAGE_TILING_OPTIMAL": "0", "VK_IMAGE_TILING_LINEAR": "1"},
+    "VkPhysicalDeviceType": {
+        "VK_PHYSICAL_DEVICE_TYPE_OTHER": "0",
+        "VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU": "1",
+        "VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU": "2",
+        "VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU": "3",
+        "VK_PHYSICAL_DEVICE_TYPE_CPU": "4",
+    },
+    "VkFormat": {
+        "VK_FORMAT_UNDEFINED": "0",
+        "VK_FORMAT_R4G4_UNORM_PACK8": "1",
+        "VK_FORMAT_R4G4B4A4_UNORM_PACK16": "2",
+        "VK_FORMAT_B4G4R4A4_UNORM_PACK16": "3",
+        "VK_FORMAT_R5G6B5_UNORM_PACK16": "4",
+        "VK_FORMAT_B5G6R5_UNORM_PACK16": "5",
+        "VK_FORMAT_R5G5B5A1_UNORM_PACK16": "6",
+        "VK_FORMAT_B5G5R5A1_UNORM_PACK16": "7",
+        "VK_FORMAT_A1R5G5B5_UNORM_PACK16": "8",
+        "VK_FORMAT_R8_UNORM": "9",
+        "VK_FORMAT_R8_SNORM": "10",
+        "VK_FORMAT_R8_USCALED": "11",
+        "VK_FORMAT_R8_SSCALED": "12",
+        "VK_FORMAT_R8_UINT": "13",
+        "VK_FORMAT_R8_SINT": "14",
+        "VK_FORMAT_R8_SRGB": "15",
+        "VK_FORMAT_R8G8_UNORM": "16",
+        "VK_FORMAT_R8G8_SNORM": "17",
+        "VK_FORMAT_R8G8_USCALED": "18",
+        "VK_FORMAT_R8G8_SSCALED": "19",
+        "VK_FORMAT_R8G8_UINT": "20",
+        "VK_FORMAT_R8G8_SINT": "21",
+        "VK_FORMAT_R8G8_SRGB": "22",
+        "VK_FORMAT_R8G8B8_UNORM": "23",
+        "VK_FORMAT_R8G8B8_SNORM": "24",
+        "VK_FORMAT_R8G8B8_USCALED": "25",
+        "VK_FORMAT_R8G8B8_SSCALED": "26",
+        "VK_FORMAT_R8G8B8_UINT": "27",
+        "VK_FORMAT_R8G8B8_SINT": "28",
+        "VK_FORMAT_R8G8B8_SRGB": "29",
+        "VK_FORMAT_B8G8R8_UNORM": "30",
+        "VK_FORMAT_B8G8R8_SNORM": "31",
+        "VK_FORMAT_B8G8R8_USCALED": "32",
+        "VK_FORMAT_B8G8R8_SSCALED": "33",
+        "VK_FORMAT_B8G8R8_UINT": "34",
+        "VK_FORMAT_B8G8R8_SINT": "35",
+        "VK_FORMAT_B8G8R8_SRGB": "36",
+        "VK_FORMAT_R8G8B8A8_UNORM": "37",
+        "VK_FORMAT_R8G8B8A8_SNORM": "38",
+        "VK_FORMAT_R8G8B8A8_USCALED": "39",
+        "VK_FORMAT_R8G8B8A8_SSCALED": "40",
+        "VK_FORMAT_R8G8B8A8_UINT": "41",
+        "VK_FORMAT_R8G8B8A8_SINT": "42",
+        "VK_FORMAT_R8G8B8A8_SRGB": "43",
+        "VK_FORMAT_B8G8R8A8_UNORM": "44",
+        "VK_FORMAT_B8G8R8A8_SNORM": "45",
+        "VK_FORMAT_B8G8R8A8_USCALED": "46",
+        "VK_FORMAT_B8G8R8A8_SSCALED": "47",
+        "VK_FORMAT_B8G8R8A8_UINT": "48",
+        "VK_FORMAT_B8G8R8A8_SINT": "49",
+        "VK_FORMAT_B8G8R8A8_SRGB": "50",
+        "VK_FORMAT_A8B8G8R8_UNORM_PACK32": "51",
+        "VK_FORMAT_A8B8G8R8_SNORM_PACK32": "52",
+        "VK_FORMAT_A8B8G8R8_USCALED_PACK32": "53",
+        "VK_FORMAT_A8B8G8R8_SSCALED_PACK32": "54",
+        "VK_FORMAT_A8B8G8R8_UINT_PACK32": "55",
+        "VK_FORMAT_A8B8G8R8_SINT_PACK32": "56",
+        "VK_FORMAT_A8B8G8R8_SRGB_PACK32": "57",
+        "VK_FORMAT_A2R10G10B10_UNORM_PACK32": "58",
+        "VK_FORMAT_A2R10G10B10_SNORM_PACK32": "59",
+        "VK_FORMAT_A2R10G10B10_USCALED_PACK32": "60",
+        "VK_FORMAT_A2R10G10B10_SSCALED_PACK32": "61",
+        "VK_FORMAT_A2R10G10B10_UINT_PACK32": "62",
+        "VK_FORMAT_A2R10G10B10_SINT_PACK32": "63",
+        "VK_FORMAT_A2B10G10R10_UNORM_PACK32": "64",
+        "VK_FORMAT_A2B10G10R10_SNORM_PACK32": "65",
+        "VK_FORMAT_A2B10G10R10_USCALED_PACK32": "66",
+        "VK_FORMAT_A2B10G10R10_SSCALED_PACK32": "67",
+        "VK_FORMAT_A2B10G10R10_UINT_PACK32": "68",
+        "VK_FORMAT_A2B10G10R10_SINT_PACK32": "69",
+        "VK_FORMAT_R16_UNORM": "70",
+        "VK_FORMAT_R16_SNORM": "71",
+        "VK_FORMAT_R16_USCALED": "72",
+        "VK_FORMAT_R16_SSCALED": "73",
+        "VK_FORMAT_R16_UINT": "74",
+        "VK_FORMAT_R16_SINT": "75",
+        "VK_FORMAT_R16_SFLOAT": "76",
+        "VK_FORMAT_R16G16_UNORM": "77",
+        "VK_FORMAT_R16G16_SNORM": "78",
+        "VK_FORMAT_R16G16_USCALED": "79",
+        "VK_FORMAT_R16G16_SSCALED": "80",
+        "VK_FORMAT_R16G16_UINT": "81",
+        "VK_FORMAT_R16G16_SINT": "82",
+        "VK_FORMAT_R16G16_SFLOAT": "83",
+        "VK_FORMAT_R16G16B16_UNORM": "84",
+        "VK_FORMAT_R16G16B16_SNORM": "85",
+        "VK_FORMAT_R16G16B16_USCALED": "86",
+        "VK_FORMAT_R16G16B16_SSCALED": "87",
+        "VK_FORMAT_R16G16B16_UINT": "88",
+        "VK_FORMAT_R16G16B16_SINT": "89",
+        "VK_FORMAT_R16G16B16_SFLOAT": "90",
+        "VK_FORMAT_R16G16B16A16_UNORM": "91",
+        "VK_FORMAT_R16G16B16A16_SNORM": "92",
+        "VK_FORMAT_R16G16B16A16_USCALED": "93",
+        "VK_FORMAT_R16G16B16A16_SSCALED": "94",
+        "VK_FORMAT_R16G16B16A16_UINT": "95",
+        "VK_FORMAT_R16G16B16A16_SINT": "96",
+        "VK_FORMAT_R16G16B16A16_SFLOAT": "97",
+        "VK_FORMAT_R32_UINT": "98",
+        "VK_FORMAT_R32_SINT": "99",
+        "VK_FORMAT_R32_SFLOAT": "100",
+        "VK_FORMAT_R32G32_UINT": "101",
+        "VK_FORMAT_R32G32_SINT": "102",
+        "VK_FORMAT_R32G32_SFLOAT": "103",
+        "VK_FORMAT_R32G32B32_UINT": "104",
+        "VK_FORMAT_R32G32B32_SINT": "105",
+        "VK_FORMAT_R32G32B32_SFLOAT": "106",
+        "VK_FORMAT_R32G32B32A32_UINT": "107",
+        "VK_FORMAT_R32G32B32A32_SINT": "108",
+        "VK_FORMAT_R32G32B32A32_SFLOAT": "109",
+        "VK_FORMAT_R64_UINT": "110",
+        "VK_FORMAT_R64_SINT": "111",
+        "VK_FORMAT_R64_SFLOAT": "112",
+        "VK_FORMAT_R64G64_UINT": "113",
+        "VK_FORMAT_R64G64_SINT": "114",
+        "VK_FORMAT_R64G64_SFLOAT": "115",
+        "VK_FORMAT_R64G64B64_UINT": "116",
+        "VK_FORMAT_R64G64B64_SINT": "117",
+        "VK_FORMAT_R64G64B64_SFLOAT": "118",
+        "VK_FORMAT_R64G64B64A64_UINT": "119",
+        "VK_FORMAT_R64G64B64A64_SINT": "120",
+        "VK_FORMAT_R64G64B64A64_SFLOAT": "121",
+        "VK_FORMAT_B10G11R11_UFLOAT_PACK32": "122",
+        "VK_FORMAT_E5B9G9R9_UFLOAT_PACK32": "123",
+        "VK_FORMAT_D16_UNORM": "124",
+        "VK_FORMAT_X8_D24_UNORM_PACK32": "125",
+        "VK_FORMAT_D32_SFLOAT": "126",
+        "VK_FORMAT_S8_UINT": "127",
+        "VK_FORMAT_D16_UNORM_S8_UINT": "128",
+        "VK_FORMAT_D24_UNORM_S8_UINT": "129",
+        "VK_FORMAT_D32_SFLOAT_S8_UINT": "130",
+        "VK_FORMAT_BC1_RGB_UNORM_BLOCK": "131",
+        "VK_FORMAT_BC1_RGB_SRGB_BLOCK": "132",
+        "VK_FORMAT_BC1_RGBA_UNORM_BLOCK": "133",
+        "VK_FORMAT_BC1_RGBA_SRGB_BLOCK": "134",
+        "VK_FORMAT_BC2_UNORM_BLOCK": "135",
+        "VK_FORMAT_BC2_SRGB_BLOCK": "136",
+        "VK_FORMAT_BC3_UNORM_BLOCK": "137",
+        "VK_FORMAT_BC3_SRGB_BLOCK": "138",
+        "VK_FORMAT_BC4_UNORM_BLOCK": "139",
+        "VK_FORMAT_BC4_SNORM_BLOCK": "140",
+        "VK_FORMAT_BC5_UNORM_BLOCK": "141",
+        "VK_FORMAT_BC5_SNORM_BLOCK": "142",
+        "VK_FORMAT_BC6H_UFLOAT_BLOCK": "143",
+        "VK_FORMAT_BC6H_SFLOAT_BLOCK": "144",
+        "VK_FORMAT_BC7_UNORM_BLOCK": "145",
+        "VK_FORMAT_BC7_SRGB_BLOCK": "146",
+        "VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK": "147",
+        "VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK": "148",
+        "VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK": "149",
+        "VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK": "150",
+        "VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK": "151",
+        "VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK": "152",
+        "VK_FORMAT_EAC_R11_UNORM_BLOCK": "153",
+        "VK_FORMAT_EAC_R11_SNORM_BLOCK": "154",
+        "VK_FORMAT_EAC_R11G11_UNORM_BLOCK": "155",
+        "VK_FORMAT_EAC_R11G11_SNORM_BLOCK": "156",
+        "VK_FORMAT_ASTC_4x4_UNORM_BLOCK": "157",
+        "VK_FORMAT_ASTC_4x4_SRGB_BLOCK": "158",
+        "VK_FORMAT_ASTC_5x4_UNORM_BLOCK": "159",
+        "VK_FORMAT_ASTC_5x4_SRGB_BLOCK": "160",
+        "VK_FORMAT_ASTC_5x5_UNORM_BLOCK": "161",
+        "VK_FORMAT_ASTC_5x5_SRGB_BLOCK": "162",
+        "VK_FORMAT_ASTC_6x5_UNORM_BLOCK": "163",
+        "VK_FORMAT_ASTC_6x5_SRGB_BLOCK": "164",
+        "VK_FORMAT_ASTC_6x6_UNORM_BLOCK": "165",
+        "VK_FORMAT_ASTC_6x6_SRGB_BLOCK": "166",
+        "VK_FORMAT_ASTC_8x5_UNORM_BLOCK": "167",
+        "VK_FORMAT_ASTC_8x5_SRGB_BLOCK": "168",
+        "VK_FORMAT_ASTC_8x6_UNORM_BLOCK": "169",
+        "VK_FORMAT_ASTC_8x6_SRGB_BLOCK": "170",
+        "VK_FORMAT_ASTC_8x8_UNORM_BLOCK": "171",
+        "VK_FORMAT_ASTC_8x8_SRGB_BLOCK": "172",
+        "VK_FORMAT_ASTC_10x5_UNORM_BLOCK": "173",
+        "VK_FORMAT_ASTC_10x5_SRGB_BLOCK": "174",
+        "VK_FORMAT_ASTC_10x6_UNORM_BLOCK": "175",
+        "VK_FORMAT_ASTC_10x6_SRGB_BLOCK": "176",
+        "VK_FORMAT_ASTC_10x8_UNORM_BLOCK": "177",
+        "VK_FORMAT_ASTC_10x8_SRGB_BLOCK": "178",
+        "VK_FORMAT_ASTC_10x10_UNORM_BLOCK": "179",
+        "VK_FORMAT_ASTC_10x10_SRGB_BLOCK": "180",
+        "VK_FORMAT_ASTC_12x10_UNORM_BLOCK": "181",
+        "VK_FORMAT_ASTC_12x10_SRGB_BLOCK": "182",
+        "VK_FORMAT_ASTC_12x12_UNORM_BLOCK": "183",
+        "VK_FORMAT_ASTC_12x12_SRGB_BLOCK": "184",
+        "VK_FORMAT_G8B8G8R8_422_UNORM": "1000156000",
+        "VK_FORMAT_B8G8R8G8_422_UNORM": "1000156001",
+        "VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM": "1000156002",
+        "VK_FORMAT_G8_B8R8_2PLANE_420_UNORM": "1000156003",
+        "VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM": "1000156004",
+        "VK_FORMAT_G8_B8R8_2PLANE_422_UNORM": "1000156005",
+        "VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM": "1000156006",
+        "VK_FORMAT_R10X6_UNORM_PACK16": "1000156007",
+        "VK_FORMAT_R10X6G10X6_UNORM_2PACK16": "1000156008",
+        "VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16": "1000156009",
+        "VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16": "1000156010",
+        "VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16": "1000156011",
+        "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16": "1000156012",
+        "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16": "1000156013",
+        "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16": "1000156014",
+        "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16": "1000156015",
+        "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16": "1000156016",
+        "VK_FORMAT_R12X4_UNORM_PACK16": "1000156017",
+        "VK_FORMAT_R12X4G12X4_UNORM_2PACK16": "1000156018",
+        "VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16": "1000156019",
+        "VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16": "1000156020",
+        "VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16": "1000156021",
+        "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16": "1000156022",
+        "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16": "1000156023",
+        "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16": "1000156024",
+        "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16": "1000156025",
+        "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16": "1000156026",
+        "VK_FORMAT_G16B16G16R16_422_UNORM": "1000156027",
+        "VK_FORMAT_B16G16R16G16_422_UNORM": "1000156028",
+        "VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM": "1000156029",
+        "VK_FORMAT_G16_B16R16_2PLANE_420_UNORM": "1000156030",
+        "VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM": "1000156031",
+        "VK_FORMAT_G16_B16R16_2PLANE_422_UNORM": "1000156032",
+        "VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM": "1000156033",
+        "VK_FORMAT_G8_B8R8_2PLANE_444_UNORM": "1000330000",
+        "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16": "1000330001",
+        "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16": "1000330002",
+        "VK_FORMAT_G16_B16R16_2PLANE_444_UNORM": "1000330003",
+        "VK_FORMAT_A4R4G4B4_UNORM_PACK16": "1000340000",
+        "VK_FORMAT_A4B4G4R4_UNORM_PACK16": "1000340001",
+        "VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK": "1000066000",
+        "VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK": "1000066001",
+        "VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK": "1000066002",
+        "VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK": "1000066003",
+        "VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK": "1000066004",
+        "VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK": "1000066005",
+        "VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK": "1000066006",
+        "VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK": "1000066007",
+        "VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK": "1000066008",
+        "VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK": "1000066009",
+        "VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK": "1000066010",
+        "VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK": "1000066011",
+        "VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK": "1000066012",
+        "VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK": "1000066013",
+        "VK_FORMAT_A1B5G5R5_UNORM_PACK16": "1000470000",
+        "VK_FORMAT_A8_UNORM": "1000470001",
+        "VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG": "1000054000",
+        "VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG": "1000054001",
+        "VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG": "1000054002",
+        "VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG": "1000054003",
+        "VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG": "1000054004",
+        "VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG": "1000054005",
+        "VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG": "1000054006",
+        "VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG": "1000054007",
+        "VK_FORMAT_R16G16_SFIXED5_NV": "1000464000",
+    },
+    "VkRayTracingInvocationReorderModeNV": {"VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV": "0", "VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV": "1"},
+    "VkSampleCountFlagBits": {
+        "VK_SAMPLE_COUNT_1_BIT": "0",
+        "VK_SAMPLE_COUNT_2_BIT": "1",
+        "VK_SAMPLE_COUNT_4_BIT": "2",
+        "VK_SAMPLE_COUNT_8_BIT": "3",
+        "VK_SAMPLE_COUNT_16_BIT": "4",
+        "VK_SAMPLE_COUNT_32_BIT": "5",
+        "VK_SAMPLE_COUNT_64_BIT": "6",
+    },
+    "VkExternalMemoryHandleTypeFlagBits": {
+        "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT": "0",
+        "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT": "1",
+        "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT": "2",
+        "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT": "3",
+        "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT": "4",
+        "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT": "5",
+        "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT": "6",
+    },
+    "VkExternalSemaphoreHandleTypeFlagBits": {
+        "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT": "0",
+        "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT": "1",
+        "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT": "2",
+        "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT": "3",
+        "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT": "4",
+    },
+    "VkExternalFenceHandleTypeFlagBits": {
+        "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT": "0",
+        "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT": "1",
+        "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT": "2",
+        "VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT": "3",
+    },
+    "VkPointClippingBehavior": {"VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES": "0", "VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY": "1"},
+    "VkChromaLocation": {"VK_CHROMA_LOCATION_COSITED_EVEN": "0", "VK_CHROMA_LOCATION_MIDPOINT": "1"},
+    "VkDriverId": {
+        "VK_DRIVER_ID_AMD_PROPRIETARY": "1",
+        "VK_DRIVER_ID_AMD_OPEN_SOURCE": "2",
+        "VK_DRIVER_ID_MESA_RADV": "3",
+        "VK_DRIVER_ID_NVIDIA_PROPRIETARY": "4",
+        "VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS": "5",
+        "VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA": "6",
+        "VK_DRIVER_ID_IMAGINATION_PROPRIETARY": "7",
+        "VK_DRIVER_ID_QUALCOMM_PROPRIETARY": "8",
+        "VK_DRIVER_ID_ARM_PROPRIETARY": "9",
+        "VK_DRIVER_ID_GOOGLE_SWIFTSHADER": "10",
+        "VK_DRIVER_ID_GGP_PROPRIETARY": "11",
+        "VK_DRIVER_ID_BROADCOM_PROPRIETARY": "12",
+        "VK_DRIVER_ID_MESA_LLVMPIPE": "13",
+        "VK_DRIVER_ID_MOLTENVK": "14",
+        "VK_DRIVER_ID_COREAVI_PROPRIETARY": "15",
+        "VK_DRIVER_ID_JUICE_PROPRIETARY": "16",
+        "VK_DRIVER_ID_VERISILICON_PROPRIETARY": "17",
+        "VK_DRIVER_ID_MESA_TURNIP": "18",
+        "VK_DRIVER_ID_MESA_V3DV": "19",
+        "VK_DRIVER_ID_MESA_PANVK": "20",
+        "VK_DRIVER_ID_SAMSUNG_PROPRIETARY": "21",
+        "VK_DRIVER_ID_MESA_VENUS": "22",
+        "VK_DRIVER_ID_MESA_DOZEN": "23",
+        "VK_DRIVER_ID_MESA_NVK": "24",
+        "VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA": "25",
+        "VK_DRIVER_ID_MESA_HONEYKRISP": "26",
+        "VK_DRIVER_ID_RESERVED_27": "27",
+    },
+    "VkShaderFloatControlsIndependence": {
+        "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY": "0",
+        "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL": "1",
+        "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE": "2",
+    },
+    "VkPipelineRobustnessBufferBehavior": {
+        "VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT": "0",
+        "VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED": "1",
+        "VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS": "2",
+        "VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2": "3",
+    },
+    "VkPipelineRobustnessImageBehavior": {
+        "VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT": "0",
+        "VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED": "1",
+        "VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS": "2",
+        "VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2": "3",
+    },
+    "VkPhysicalDeviceLayeredApiKHR": {
+        "VK_PHYSICAL_DEVICE_LAYERED_API_VULKAN_KHR": "0",
+        "VK_PHYSICAL_DEVICE_LAYERED_API_D3D12_KHR": "1",
+        "VK_PHYSICAL_DEVICE_LAYERED_API_METAL_KHR": "2",
+        "VK_PHYSICAL_DEVICE_LAYERED_API_OPENGL_KHR": "3",
+        "VK_PHYSICAL_DEVICE_LAYERED_API_OPENGLES_KHR": "4",
+    },
+    "VkLayeredDriverUnderlyingApiMSFT": {"VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT": "0", "VK_LAYERED_DRIVER_UNDERLYING_API_D3D12_MSFT": "1"},
+}
+
+
+# --- VK Format Mapping ---
+
+VK_FORMAT_MAPPING = {
+    "VK_VERSION_1_1": [
+        ("VK_FORMAT_G8B8G8R8_422_UNORM", 1000156000),
+        ("VK_FORMAT_B8G8R8G8_422_UNORM", 1000156001),
+        ("VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM", 1000156002),
+        ("VK_FORMAT_G8_B8R8_2PLANE_420_UNORM", 1000156003),
+        ("VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM", 1000156004),
+        ("VK_FORMAT_G8_B8R8_2PLANE_422_UNORM", 1000156005),
+        ("VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM", 1000156006),
+        ("VK_FORMAT_R10X6_UNORM_PACK16", 1000156007),
+        ("VK_FORMAT_R10X6G10X6_UNORM_2PACK16", 1000156008),
+        ("VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16", 1000156009),
+        ("VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16", 1000156010),
+        ("VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16", 1000156011),
+        ("VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16", 1000156012),
+        ("VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16", 1000156013),
+        ("VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16", 1000156014),
+        ("VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16", 1000156015),
+        ("VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16", 1000156016),
+        ("VK_FORMAT_R12X4_UNORM_PACK16", 1000156017),
+        ("VK_FORMAT_R12X4G12X4_UNORM_2PACK16", 1000156018),
+        ("VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16", 1000156019),
+        ("VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16", 1000156020),
+        ("VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16", 1000156021),
+        ("VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16", 1000156022),
+        ("VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16", 1000156023),
+        ("VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16", 1000156024),
+        ("VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16", 1000156025),
+        ("VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16", 1000156026),
+        ("VK_FORMAT_G16B16G16R16_422_UNORM", 1000156027),
+        ("VK_FORMAT_B16G16R16G16_422_UNORM", 1000156028),
+        ("VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM", 1000156029),
+        ("VK_FORMAT_G16_B16R16_2PLANE_420_UNORM", 1000156030),
+        ("VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM", 1000156031),
+        ("VK_FORMAT_G16_B16R16_2PLANE_422_UNORM", 1000156032),
+        ("VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM", 1000156033),
+    ],
+    "VK_VERSION_1_3": [
+        ("VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK", 1000066000),
+        ("VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK", 1000066001),
+        ("VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK", 1000066002),
+        ("VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK", 1000066003),
+        ("VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK", 1000066004),
+        ("VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK", 1000066005),
+        ("VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK", 1000066006),
+        ("VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK", 1000066007),
+        ("VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK", 1000066008),
+        ("VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK", 1000066009),
+        ("VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK", 1000066010),
+        ("VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK", 1000066011),
+        ("VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK", 1000066012),
+        ("VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK", 1000066013),
+        ("VK_FORMAT_G8_B8R8_2PLANE_444_UNORM", 1000330000),
+        ("VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16", 1000330001),
+        ("VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16", 1000330002),
+        ("VK_FORMAT_G16_B16R16_2PLANE_444_UNORM", 1000330003),
+        ("VK_FORMAT_A4R4G4B4_UNORM_PACK16", 1000340000),
+        ("VK_FORMAT_A4B4G4R4_UNORM_PACK16", 1000340001),
+    ],
+    "VK_VERSION_1_4": [("VK_FORMAT_A1B5G5R5_UNORM_PACK16", 1000470000), ("VK_FORMAT_A8_UNORM", 1000470001)],
+    "VK_IMG_format_pvrtc": [
+        ("VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG", 1000054000),
+        ("VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG", 1000054001),
+        ("VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG", 1000054002),
+        ("VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG", 1000054003),
+        ("VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG", 1000054004),
+        ("VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG", 1000054005),
+        ("VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG", 1000054006),
+        ("VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG", 1000054007),
+    ],
+    "VK_EXT_texture_compression_astc_hdr": [
+        ("VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT", 1000066000),
+        ("VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT", 1000066001),
+        ("VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT", 1000066002),
+        ("VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT", 1000066003),
+        ("VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT", 1000066004),
+        ("VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT", 1000066005),
+        ("VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT", 1000066006),
+        ("VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT", 1000066007),
+        ("VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT", 1000066008),
+        ("VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT", 1000066009),
+        ("VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT", 1000066010),
+        ("VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT", 1000066011),
+        ("VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT", 1000066012),
+        ("VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT", 1000066013),
+    ],
+    "VK_KHR_sampler_ycbcr_conversion": [
+        ("VK_FORMAT_G8B8G8R8_422_UNORM_KHR", 1000156000),
+        ("VK_FORMAT_B8G8R8G8_422_UNORM_KHR", 1000156001),
+        ("VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR", 1000156002),
+        ("VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR", 1000156003),
+        ("VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR", 1000156004),
+        ("VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR", 1000156005),
+        ("VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR", 1000156006),
+        ("VK_FORMAT_R10X6_UNORM_PACK16_KHR", 1000156007),
+        ("VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR", 1000156008),
+        ("VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR", 1000156009),
+        ("VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR", 1000156010),
+        ("VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR", 1000156011),
+        ("VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR", 1000156012),
+        ("VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR", 1000156013),
+        ("VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR", 1000156014),
+        ("VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR", 1000156015),
+        ("VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR", 1000156016),
+        ("VK_FORMAT_R12X4_UNORM_PACK16_KHR", 1000156017),
+        ("VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR", 1000156018),
+        ("VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR", 1000156019),
+        ("VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR", 1000156020),
+        ("VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR", 1000156021),
+        ("VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR", 1000156022),
+        ("VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR", 1000156023),
+        ("VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR", 1000156024),
+        ("VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR", 1000156025),
+        ("VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR", 1000156026),
+        ("VK_FORMAT_G16B16G16R16_422_UNORM_KHR", 1000156027),
+        ("VK_FORMAT_B16G16R16G16_422_UNORM_KHR", 1000156028),
+        ("VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR", 1000156029),
+        ("VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR", 1000156030),
+        ("VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR", 1000156031),
+        ("VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR", 1000156032),
+        ("VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR", 1000156033),
+    ],
+    "VK_EXT_ycbcr_2plane_444_formats": [
+        ("VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT", 1000330000),
+        ("VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT", 1000330001),
+        ("VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT", 1000330002),
+        ("VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT", 1000330003),
+    ],
+    "VK_EXT_4444_formats": [("VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT", 1000340000), ("VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT", 1000340001)],
+    "VK_NV_optical_flow": [("VK_FORMAT_R16G16_SFIXED5_NV", 1000464000), ("VK_FORMAT_R16G16_S10_5_NV", 1000464000)],
+    "VK_KHR_maintenance5": [("VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR", 1000470000), ("VK_FORMAT_A8_UNORM_KHR", 1000470001)],
+    "VK_VERSION_1_0": [
+        ("VK_FORMAT_R4G4_UNORM_PACK8", 1),
+        ("VK_FORMAT_R4G4B4A4_UNORM_PACK16", 2),
+        ("VK_FORMAT_B4G4R4A4_UNORM_PACK16", 3),
+        ("VK_FORMAT_R5G6B5_UNORM_PACK16", 4),
+        ("VK_FORMAT_B5G6R5_UNORM_PACK16", 5),
+        ("VK_FORMAT_R5G5B5A1_UNORM_PACK16", 6),
+        ("VK_FORMAT_B5G5R5A1_UNORM_PACK16", 7),
+        ("VK_FORMAT_A1R5G5B5_UNORM_PACK16", 8),
+        ("VK_FORMAT_R8_UNORM", 9),
+        ("VK_FORMAT_R8_SNORM", 10),
+        ("VK_FORMAT_R8_USCALED", 11),
+        ("VK_FORMAT_R8_SSCALED", 12),
+        ("VK_FORMAT_R8_UINT", 13),
+        ("VK_FORMAT_R8_SINT", 14),
+        ("VK_FORMAT_R8_SRGB", 15),
+        ("VK_FORMAT_R8G8_UNORM", 16),
+        ("VK_FORMAT_R8G8_SNORM", 17),
+        ("VK_FORMAT_R8G8_USCALED", 18),
+        ("VK_FORMAT_R8G8_SSCALED", 19),
+        ("VK_FORMAT_R8G8_UINT", 20),
+        ("VK_FORMAT_R8G8_SINT", 21),
+        ("VK_FORMAT_R8G8_SRGB", 22),
+        ("VK_FORMAT_R8G8B8_UNORM", 23),
+        ("VK_FORMAT_R8G8B8_SNORM", 24),
+        ("VK_FORMAT_R8G8B8_USCALED", 25),
+        ("VK_FORMAT_R8G8B8_SSCALED", 26),
+        ("VK_FORMAT_R8G8B8_UINT", 27),
+        ("VK_FORMAT_R8G8B8_SINT", 28),
+        ("VK_FORMAT_R8G8B8_SRGB", 29),
+        ("VK_FORMAT_B8G8R8_UNORM", 30),
+        ("VK_FORMAT_B8G8R8_SNORM", 31),
+        ("VK_FORMAT_B8G8R8_USCALED", 32),
+        ("VK_FORMAT_B8G8R8_SSCALED", 33),
+        ("VK_FORMAT_B8G8R8_UINT", 34),
+        ("VK_FORMAT_B8G8R8_SINT", 35),
+        ("VK_FORMAT_B8G8R8_SRGB", 36),
+        ("VK_FORMAT_R8G8B8A8_UNORM", 37),
+        ("VK_FORMAT_R8G8B8A8_SNORM", 38),
+        ("VK_FORMAT_R8G8B8A8_USCALED", 39),
+        ("VK_FORMAT_R8G8B8A8_SSCALED", 40),
+        ("VK_FORMAT_R8G8B8A8_UINT", 41),
+        ("VK_FORMAT_R8G8B8A8_SINT", 42),
+        ("VK_FORMAT_R8G8B8A8_SRGB", 43),
+        ("VK_FORMAT_B8G8R8A8_UNORM", 44),
+        ("VK_FORMAT_B8G8R8A8_SNORM", 45),
+        ("VK_FORMAT_B8G8R8A8_USCALED", 46),
+        ("VK_FORMAT_B8G8R8A8_SSCALED", 47),
+        ("VK_FORMAT_B8G8R8A8_UINT", 48),
+        ("VK_FORMAT_B8G8R8A8_SINT", 49),
+        ("VK_FORMAT_B8G8R8A8_SRGB", 50),
+        ("VK_FORMAT_A8B8G8R8_UNORM_PACK32", 51),
+        ("VK_FORMAT_A8B8G8R8_SNORM_PACK32", 52),
+        ("VK_FORMAT_A8B8G8R8_USCALED_PACK32", 53),
+        ("VK_FORMAT_A8B8G8R8_SSCALED_PACK32", 54),
+        ("VK_FORMAT_A8B8G8R8_UINT_PACK32", 55),
+        ("VK_FORMAT_A8B8G8R8_SINT_PACK32", 56),
+        ("VK_FORMAT_A8B8G8R8_SRGB_PACK32", 57),
+        ("VK_FORMAT_A2R10G10B10_UNORM_PACK32", 58),
+        ("VK_FORMAT_A2R10G10B10_SNORM_PACK32", 59),
+        ("VK_FORMAT_A2R10G10B10_USCALED_PACK32", 60),
+        ("VK_FORMAT_A2R10G10B10_SSCALED_PACK32", 61),
+        ("VK_FORMAT_A2R10G10B10_UINT_PACK32", 62),
+        ("VK_FORMAT_A2R10G10B10_SINT_PACK32", 63),
+        ("VK_FORMAT_A2B10G10R10_UNORM_PACK32", 64),
+        ("VK_FORMAT_A2B10G10R10_SNORM_PACK32", 65),
+        ("VK_FORMAT_A2B10G10R10_USCALED_PACK32", 66),
+        ("VK_FORMAT_A2B10G10R10_SSCALED_PACK32", 67),
+        ("VK_FORMAT_A2B10G10R10_UINT_PACK32", 68),
+        ("VK_FORMAT_A2B10G10R10_SINT_PACK32", 69),
+        ("VK_FORMAT_R16_UNORM", 70),
+        ("VK_FORMAT_R16_SNORM", 71),
+        ("VK_FORMAT_R16_USCALED", 72),
+        ("VK_FORMAT_R16_SSCALED", 73),
+        ("VK_FORMAT_R16_UINT", 74),
+        ("VK_FORMAT_R16_SINT", 75),
+        ("VK_FORMAT_R16_SFLOAT", 76),
+        ("VK_FORMAT_R16G16_UNORM", 77),
+        ("VK_FORMAT_R16G16_SNORM", 78),
+        ("VK_FORMAT_R16G16_USCALED", 79),
+        ("VK_FORMAT_R16G16_SSCALED", 80),
+        ("VK_FORMAT_R16G16_UINT", 81),
+        ("VK_FORMAT_R16G16_SINT", 82),
+        ("VK_FORMAT_R16G16_SFLOAT", 83),
+        ("VK_FORMAT_R16G16B16_UNORM", 84),
+        ("VK_FORMAT_R16G16B16_SNORM", 85),
+        ("VK_FORMAT_R16G16B16_USCALED", 86),
+        ("VK_FORMAT_R16G16B16_SSCALED", 87),
+        ("VK_FORMAT_R16G16B16_UINT", 88),
+        ("VK_FORMAT_R16G16B16_SINT", 89),
+        ("VK_FORMAT_R16G16B16_SFLOAT", 90),
+        ("VK_FORMAT_R16G16B16A16_UNORM", 91),
+        ("VK_FORMAT_R16G16B16A16_SNORM", 92),
+        ("VK_FORMAT_R16G16B16A16_USCALED", 93),
+        ("VK_FORMAT_R16G16B16A16_SSCALED", 94),
+        ("VK_FORMAT_R16G16B16A16_UINT", 95),
+        ("VK_FORMAT_R16G16B16A16_SINT", 96),
+        ("VK_FORMAT_R16G16B16A16_SFLOAT", 97),
+        ("VK_FORMAT_R32_UINT", 98),
+        ("VK_FORMAT_R32_SINT", 99),
+        ("VK_FORMAT_R32_SFLOAT", 100),
+        ("VK_FORMAT_R32G32_UINT", 101),
+        ("VK_FORMAT_R32G32_SINT", 102),
+        ("VK_FORMAT_R32G32_SFLOAT", 103),
+        ("VK_FORMAT_R32G32B32_UINT", 104),
+        ("VK_FORMAT_R32G32B32_SINT", 105),
+        ("VK_FORMAT_R32G32B32_SFLOAT", 106),
+        ("VK_FORMAT_R32G32B32A32_UINT", 107),
+        ("VK_FORMAT_R32G32B32A32_SINT", 108),
+        ("VK_FORMAT_R32G32B32A32_SFLOAT", 109),
+        ("VK_FORMAT_R64_UINT", 110),
+        ("VK_FORMAT_R64_SINT", 111),
+        ("VK_FORMAT_R64_SFLOAT", 112),
+        ("VK_FORMAT_R64G64_UINT", 113),
+        ("VK_FORMAT_R64G64_SINT", 114),
+        ("VK_FORMAT_R64G64_SFLOAT", 115),
+        ("VK_FORMAT_R64G64B64_UINT", 116),
+        ("VK_FORMAT_R64G64B64_SINT", 117),
+        ("VK_FORMAT_R64G64B64_SFLOAT", 118),
+        ("VK_FORMAT_R64G64B64A64_UINT", 119),
+        ("VK_FORMAT_R64G64B64A64_SINT", 120),
+        ("VK_FORMAT_R64G64B64A64_SFLOAT", 121),
+        ("VK_FORMAT_B10G11R11_UFLOAT_PACK32", 122),
+        ("VK_FORMAT_E5B9G9R9_UFLOAT_PACK32", 123),
+        ("VK_FORMAT_D16_UNORM", 124),
+        ("VK_FORMAT_X8_D24_UNORM_PACK32", 125),
+        ("VK_FORMAT_D32_SFLOAT", 126),
+        ("VK_FORMAT_S8_UINT", 127),
+        ("VK_FORMAT_D16_UNORM_S8_UINT", 128),
+        ("VK_FORMAT_D24_UNORM_S8_UINT", 129),
+        ("VK_FORMAT_D32_SFLOAT_S8_UINT", 130),
+        ("VK_FORMAT_BC1_RGB_UNORM_BLOCK", 131),
+        ("VK_FORMAT_BC1_RGB_SRGB_BLOCK", 132),
+        ("VK_FORMAT_BC1_RGBA_UNORM_BLOCK", 133),
+        ("VK_FORMAT_BC1_RGBA_SRGB_BLOCK", 134),
+        ("VK_FORMAT_BC2_UNORM_BLOCK", 135),
+        ("VK_FORMAT_BC2_SRGB_BLOCK", 136),
+        ("VK_FORMAT_BC3_UNORM_BLOCK", 137),
+        ("VK_FORMAT_BC3_SRGB_BLOCK", 138),
+        ("VK_FORMAT_BC4_UNORM_BLOCK", 139),
+        ("VK_FORMAT_BC4_SNORM_BLOCK", 140),
+        ("VK_FORMAT_BC5_UNORM_BLOCK", 141),
+        ("VK_FORMAT_BC5_SNORM_BLOCK", 142),
+        ("VK_FORMAT_BC6H_UFLOAT_BLOCK", 143),
+        ("VK_FORMAT_BC6H_SFLOAT_BLOCK", 144),
+        ("VK_FORMAT_BC7_UNORM_BLOCK", 145),
+        ("VK_FORMAT_BC7_SRGB_BLOCK", 146),
+        ("VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK", 147),
+        ("VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK", 148),
+        ("VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK", 149),
+        ("VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK", 150),
+        ("VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK", 151),
+        ("VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK", 152),
+        ("VK_FORMAT_EAC_R11_UNORM_BLOCK", 153),
+        ("VK_FORMAT_EAC_R11_SNORM_BLOCK", 154),
+        ("VK_FORMAT_EAC_R11G11_UNORM_BLOCK", 155),
+        ("VK_FORMAT_EAC_R11G11_SNORM_BLOCK", 156),
+        ("VK_FORMAT_ASTC_4x4_UNORM_BLOCK", 157),
+        ("VK_FORMAT_ASTC_4x4_SRGB_BLOCK", 158),
+        ("VK_FORMAT_ASTC_5x4_UNORM_BLOCK", 159),
+        ("VK_FORMAT_ASTC_5x4_SRGB_BLOCK", 160),
+        ("VK_FORMAT_ASTC_5x5_UNORM_BLOCK", 161),
+        ("VK_FORMAT_ASTC_5x5_SRGB_BLOCK", 162),
+        ("VK_FORMAT_ASTC_6x5_UNORM_BLOCK", 163),
+        ("VK_FORMAT_ASTC_6x5_SRGB_BLOCK", 164),
+        ("VK_FORMAT_ASTC_6x6_UNORM_BLOCK", 165),
+        ("VK_FORMAT_ASTC_6x6_SRGB_BLOCK", 166),
+        ("VK_FORMAT_ASTC_8x5_UNORM_BLOCK", 167),
+        ("VK_FORMAT_ASTC_8x5_SRGB_BLOCK", 168),
+        ("VK_FORMAT_ASTC_8x6_UNORM_BLOCK", 169),
+        ("VK_FORMAT_ASTC_8x6_SRGB_BLOCK", 170),
+        ("VK_FORMAT_ASTC_8x8_UNORM_BLOCK", 171),
+        ("VK_FORMAT_ASTC_8x8_SRGB_BLOCK", 172),
+        ("VK_FORMAT_ASTC_10x5_UNORM_BLOCK", 173),
+        ("VK_FORMAT_ASTC_10x5_SRGB_BLOCK", 174),
+        ("VK_FORMAT_ASTC_10x6_UNORM_BLOCK", 175),
+        ("VK_FORMAT_ASTC_10x6_SRGB_BLOCK", 176),
+        ("VK_FORMAT_ASTC_10x8_UNORM_BLOCK", 177),
+        ("VK_FORMAT_ASTC_10x8_SRGB_BLOCK", 178),
+        ("VK_FORMAT_ASTC_10x10_UNORM_BLOCK", 179),
+        ("VK_FORMAT_ASTC_10x10_SRGB_BLOCK", 180),
+        ("VK_FORMAT_ASTC_12x10_UNORM_BLOCK", 181),
+        ("VK_FORMAT_ASTC_12x10_SRGB_BLOCK", 182),
+        ("VK_FORMAT_ASTC_12x12_UNORM_BLOCK", 183),
+        ("VK_FORMAT_ASTC_12x12_SRGB_BLOCK", 184),
+    ],
+}
diff --git a/vulkan/scripts/vk_parser.py b/vulkan/scripts/vk_parser.py
new file mode 100644
index 0000000000..f4b2e31fe7
--- /dev/null
+++ b/vulkan/scripts/vk_parser.py
@@ -0,0 +1,1420 @@
+# Copyright 2025 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import xml.etree.ElementTree as ET
+from collections import defaultdict
+import re
+from datetime import datetime
+from typing import Dict, Optional, List, Any, Tuple, Set, IO
+from pathlib import Path
+import pprint
+import copy
+import generator_common as gencom
+
+# --- FILE PATHS & OUTPUT CONFIGURATION ---
+VULKAN_XML_FILE_PATH = Path("../../../../external/vulkan-headers/registry/vk.xml")
+OUTPUT_VK_PY_PATH = Path("vk.py")
+
+# Output file initial content
+INIT_CONTENT = """\n\nfrom dataclasses import dataclass
+from enum import Enum
+import dataclasses
+dataclass = dataclasses.dataclass
+from typing import List
+import ctypes
+"""
+
+INIT_CONSTANTS_CONTENT = """
+# --- Adding Pre-Defined Constants ---\n
+uint8_t = ctypes.c_uint8
+uint32_t = ctypes.c_uint32
+VkFlags = uint32_t
+int32_t = int
+uint64_t = ctypes.c_uint64
+VkBool32 = bool
+VkDeviceSize = ctypes.c_uint64
+size_t = ctypes.c_uint64
+float_t = ctypes.c_float
+int64_t = ctypes.c_int64
+uint16_t = ctypes.c_uint16
+VkFlags64 = uint64_t
+
+"""
+# TODO: b/415706521 (Refactor EXTRA_STRUCTURES_CONTENT Logic to Use XML Generation)
+EXTRA_STRUCTURES_CONTENT = """
+@dataclass
+class VkExtent3D:
+  width: uint32_t
+  height: uint32_t
+  depth: uint32_t
+
+@dataclass
+class VkImageFormatProperties:
+  maxExtent: VkExtent3D
+  maxMipLevels: uint32_t
+  maxArrayLayers: uint32_t
+  sampleCounts: VkSampleCountFlags
+  maxResourceSize: VkDeviceSize
+
+@dataclass
+class VkExtensionProperties:
+  extensionName: str
+  specVersion: uint32_t
+
+@dataclass
+class VkFormatProperties:
+  linearTilingFeatures: VkFormatFeatureFlags
+  optimalTilingFeatures: VkFormatFeatureFlags
+  bufferFeatures: VkFormatFeatureFlags
+
+@dataclass
+class VkLayerProperties:
+  layerName: str
+  specVersion: uint32_t
+  implementationVersion: uint32_t
+  description: str
+
+@dataclass
+class VkQueueFamilyProperties:
+  queueFlags: VkQueueFlags
+  queueCount: uint32_t
+  timestampValidBits: uint32_t
+  minImageTransferGranularity: VkExtent3D
+\n\n"""
+
+# TODO: b/415706507 (Find a way to identify this structs from vk.xml API_1_0 tag)
+VULKAN_API_1_0_STRUCTS_CONTENT = """# --- STRUCTS USED BY VULKAN_API_1_0 ---
+\nVULKAN_API_1_0_STRUCTS = [VkPhysicalDeviceProperties,
+VkPhysicalDeviceMemoryProperties,
+VkPhysicalDeviceSparseProperties,
+VkImageFormatProperties,
+VkQueueFamilyProperties,
+VkExtensionProperties,
+VkLayerProperties,
+VkFormatProperties,
+VkPhysicalDeviceLimits,
+VkPhysicalDeviceFeatures]"""
+
+ADDITIONAL_EXTENSION_INDEPENDENT_STRUCTS_CONTENT = """# --- ADDITIONAL EXTENSION INDEPENDENT STRUCTS ---
+\nADDITIONAL_EXTENSION_INDEPENDENT_STRUCTS = ['VkPhysicalDeviceProperties',
+'VkPhysicalDeviceFeatures',
+'VkPhysicalDeviceMemoryProperties']"""
+
+# --- GENERAL CONSTANTS ---
+PRIMITIVE_DATA_TYPE = [
+    "float_t",
+    "uint32_t",
+    "uint8_t",
+    "int32_t",
+    "uint64_t",
+    "size_t",
+    "float",
+    "VkBool32",
+    "int64_t",
+    "str",
+    "VkDeviceSize",
+    "uint16_t",
+]
+FLOAT_ARRAY_REPLACEMENT_TYPE = "float_t"
+
+# --- VULKAN SPECIFIC CONSTANTS & KEYWORDS ---
+PHYSICAL_DEVICE_PREFIX = "VkPhysicalDevice"
+STANDARD_MEMBER_NAMES_TO_SKIP = ("sType", "pNext")
+VALID_ALIAS_FLAGS = ("VkFlags", "VkFlags64")
+
+VK_STRUCTURE_TYPE = "VkStructureType"
+VK_API_CONSTANTS = "API Constants"
+
+VK_API_FILTER = "vulkan,vulkansc"
+VK_VULKAN_FILTER = "vulkan"
+VK_VULKAN_SC_FILTER = "vulkansc"
+
+# --- XML SPECIFIC CONSTANTS ---
+# XML Element/Attribute Names
+TAG_TYPE = "type"
+TAG_MEMBER = "member"
+TAG_ENUM = "enum"
+TAG_ENUMS = "enums"
+TAG_EXTENSION = "extension"
+TAG_FEATURE = "feature"
+TAG_REQUIRE = "require"
+TAG_NAME = "name"
+
+ATTR_NAME = "name"
+ATTR_SUPPORTED = "supported"
+ATTR_PLATFORM = "platform"
+ATTR_CATEGORY = "category"
+ATTR_DEFINE = "define"
+ATTR_ALIAS = "alias"
+ATTR_STRUCT_EXTENDS = "structextends"
+ATTR_VALUES = "values"
+ATTR_VALUE = "value"
+ATTR_TYPE = "type"
+ATTR_LEN = "len"
+ATTR_API = "api"
+
+# XML Categories
+CAT_STRUCT = "struct"
+CAT_HANDLE = "handle"
+
+# --- REGULAR EXPRESSIONS ---
+# Pointer Regex Helpers
+CONST_POINTER_REGEX = re.compile(r"^const\s+([\w\s]+?)\s*\*\s*$")  # Matches 'const <type> *'
+VOID_POINTER_REGEX = re.compile(r"\bvoid\s*\*")  # Matches 'void*' as whole word
+CHAR_POINTER_REGEX = re.compile(r"\bchar\s*\*")  # Matches 'char *'
+CONST_CHAR_POINTER_REGEX = re.compile(r"\bconst\s+char\s*\*")  # Matches 'const char *'
+# Other Regex
+CORE_VERSION_REGEX = re.compile(r"^(VkPhysicalDevice)(Vulkan)(\d+)(Properties|Features)$")
+ARRAY_TAIL_REGEX = re.compile(r"\[\s*([^\]]+)\s*\]")  # Matches array notation like [VK_UUID_SIZE]
+
+# --- GLOBAL DATA STRUCTURES (Parsed Data Storage) ---
+
+VK_PHYSICAL_STRUCT_NAMES = []  # Stores names starting with PHYSICAL_DEVICE_PREFIX
+ALL_STRUCT_NAMES = []
+ALL_ENUM_NAMES = []  # Stores all unique enum type names found
+ALL_ALIAS_NAMES = []  # Stores all unique alias names found
+ALL_CONSTANTS = [  # Base types considered 'constant' or primitive-like
+    "uint8_t",
+    "uint32_t",
+    "VkFlags",
+    "int32_t",
+    "uint64_t",
+    "VkBool32",
+    "VkDeviceSize",
+    "size_t",
+    "float_t",
+    "int64_t",
+    "uint16_t",
+    "VkFlags64",
+    "float",
+    "str",
+    "int",
+    "double",
+]
+
+NECESSARY_ENUMS = []
+CORE_MAPPING_STRUCT_LIST = []  # Physical device structs that match the CORE_VERSION_REGEX pattern
+VK_PHYSICAL_DEVICE_DEPENDENT_STRUCTURES_LIST = []  # Structs that physical device structs depend on
+REQUIRED_STRUCT_NAMES = []  # All structs deemed necessary (physical device + dependencies)
+REQUIRED_DATA_MEMBERS = []
+
+# Mappings derived from parsing
+alias_map: Dict[str, str] = {}  # Maps alias name to original name
+feature_api_map: Dict[str, List[Dict[str, str]]] = defaultdict(list)  # Maps feature name to list of {struct: type_enum}
+disabled_structs = ["VkPhysicalDeviceHostImageCopyProperties"]  # TODO:- b/415705512 handle VkPhysicalDeviceHostImageCopyProperties
+structs_with_valid_extends = []
+enum_member_map = {}
+additional_vk_format_values = {}
+# --- GENERAL UTILITY FUNCTIONS ---
+
+
+def write_py_file(file_handle: IO[str], content: str):
+    """Writes the given content to the provided open file handle."""
+    file_handle.write(content)
+
+
+def get_element_text(element: Optional[ET.Element]) -> Optional[str]:
+    """Safely retrieves and strips the text content from an XML element."""
+    if element is not None and element.text:
+        return element.text.strip()
+    return None
+
+
+def find_next_tag(parent: ET.Element, element: ET.Element) -> Optional[ET.Element]:
+    """Finds the immediate next sibling XML element within the same parent."""
+    children = list(parent)
+    try:
+        index = children.index(element)
+        if index + 1 < len(children):
+            return children[index + 1]
+    except ValueError:
+        pass
+    return None
+
+
+# --- XML LOADING FUNCTION ---
+
+
+def load_xml_registry(xml_file_path: Path) -> Optional[ET.Element]:
+    """Loads and parses the Vulkan XML registry file into an ElementTree root object."""
+    if not xml_file_path.exists():
+        return None
+    try:
+        tree = ET.parse(xml_file_path)
+        return tree.getroot()
+    except ET.ParseError as e:
+        return None
+
+
+# --- API CONSTANT & VERSION NUMBER PROCESSING ---
+
+
+def clean_api_constant_value(value: str, type_str: Optional[str]) -> str:
+    """Cleans C-style suffixes and resolves specific Vulkan constants (like ~0) to their values."""
+    original_value = value
+    # Remove common C numeric suffixes
+    cleaned_value = value.replace("F", "").replace("f", "").replace("U", "").replace("L", "")
+
+    # Handle special Vulkan max value constants
+    if cleaned_value == "(~0)":
+        if type_str == "uint32_t":
+            return "4294967295"  # 2^32 - 1
+        elif type_str == "uint64_t":
+            return "0xFFFFFFFFFFFFFFFF"  # 2^64 - 1
+    elif cleaned_value == "(~1)":
+        if type_str == "uint32_t":
+            return "4294967294"  # 2^32 - 2
+    elif cleaned_value == "(~2)":
+        if type_str == "uint32_t":
+            return "4294967293"  # 2^32 - 3
+    elif cleaned_value.startswith("(~"):
+        # Unhandled bitwise negation, return original to avoid incorrect interpretation
+        return original_value
+    # Attempt to validate/return as hex, float, or int
+    try:
+        if cleaned_value.startswith("0x") or cleaned_value.startswith("0X"):
+            int(cleaned_value, 16)
+            return cleaned_value
+        else:
+            try:
+                float(cleaned_value)
+                return cleaned_value
+            except ValueError:
+                int(cleaned_value)
+                return cleaned_value
+    except ValueError:
+        return original_value
+
+
+def write_constants(root: ET.Element, vk_py_file_handle: IO[str]):
+    """Extracts and writes constants defined in the 'API Constants' section of the XML."""
+    api_constants: Dict[str, str] = {}
+    # Find the specific <enums> tag for API constants
+    api_constants_element = root.find(f'.//enums[@{ATTR_NAME}="{VK_API_CONSTANTS}"]')
+
+    if api_constants_element is None:
+        return api_constants
+
+    # Iterate through each <enum> defining a constant
+    for enum_element in api_constants_element.findall(f"./{TAG_ENUM}"):
+        name = enum_element.get(ATTR_NAME)
+        value = enum_element.get(ATTR_VALUE)
+        type_str = enum_element.get(ATTR_TYPE)  # Used by cleaner
+
+        if name and value:
+            # Clean the value (handle suffixes, special constants)
+            cleaned_value = clean_api_constant_value(value, type_str)
+            api_constants[name] = cleaned_value
+        elif name and enum_element.get(ATTR_ALIAS):
+            # Skip aliased constants here; they aren't assigned values directly
+            pass
+
+    content = "# --- API Constant values extracted from vk.xml ---\n\n"
+    for name, value in api_constants.items():
+        content += f"{name} = {value}\n"
+    content += "\n\n"
+    write_py_file(vk_py_file_handle, content)
+
+
+def vk_make_api_version(variant: int, major: int, minor: int, patch: int) -> int:
+    """Replicates the VK_MAKE_API_VERSION C macro logic to pack version numbers into an integer."""
+    # Bitwise operations to pack variant, major, minor, patch into a 32-bit integer
+    packed_version = (variant << 29) | (major << 22) | (minor << 12) | patch
+    return packed_version
+
+
+def extract_make_api_versions(root: ET.Element):
+    """Extracts VK_API_VERSION_* defines and their corresponding (variant, major, minor, patch) tuples."""
+    version_defines = {}  # {define_name: (variant, major, minor, patch)}
+    # Find <type> tags categorized as 'define' that likely contain VK_MAKE_API_VERSION
+    for type_tag in root.findall(f".//{TAG_TYPE}[@{ATTR_CATEGORY}='{ATTR_DEFINE}']"):
+        name_elem = type_tag.find(ATTR_NAME)  # The #define name (e.g., VK_API_VERSION_1_0)
+        macro_elem = type_tag.find(ATTR_TYPE)  # Should ideally contain 'VK_MAKE_API_VERSION'
+
+        if name_elem is not None and macro_elem is not None:
+            name = get_element_text(name_elem)
+            macro_text = get_element_text(macro_elem)
+            match_name = re.search(r"VK_API_VERSION(?:_\d+_\d+)?", name or "")
+            if not match_name:
+                continue
+
+            full_text = "".join(type_tag.itertext())
+            macro_pattern = re.escape(macro_text) if macro_text else r"VK_MAKE_API_VERSION"
+            match_args = re.search(rf"{macro_pattern}\s*\(([^)]*)\)", full_text)
+
+            if match_args:
+                version_tuple = tuple(map(int, match_args.group(1).split(",")))
+                if len(version_tuple) == 4:
+                    version_defines[name] = version_tuple
+    return version_defines
+
+
+def write_api_constants(xml_root: ET.Element, vk_py_file_handle: IO[str]):
+    """Extracts VK_API_VERSION defines, computes their integer values, and writes them to vk.py."""
+    version_defines = extract_make_api_versions(xml_root)
+    version_content = "# --- Computed VK_API_VERSION Constants --- \n\n"
+    for name, version in version_defines.items():
+        packed_value = vk_make_api_version(version[0], version[1], version[2], version[3])
+        version_content += f"{name} = {packed_value}\n"
+    version_content += "\n\n"
+    write_py_file(vk_py_file_handle, version_content)
+
+
+# --- ALIAS EXTRACTION & WRITING FUNCTIONS ---
+
+
+def fetch_flags_aliases(root: ET.Element) -> dict[str, str]:
+    """Extracts C typedefs specifically for VkFlags and VkFlags64 aliases."""
+    vk_flags_aliases: dict[str, str] = {}
+    # Find all <type> elements potentially containing typedefs
+    for type_tag in root.findall(f".//{TAG_TYPE}"):
+        # Check the element's text content for 'typedef' keyword
+        if type_tag.text and "typedef" in type_tag.text:
+            original_type_elem = type_tag.find(f"{TAG_TYPE}")  # The original type being aliased
+            alias_elem = type_tag.find(f"{TAG_NAME}")  # The new alias name
+            if original_type_elem is not None and alias_elem is not None:
+                original_type = get_element_text(original_type_elem)
+                alias = get_element_text(alias_elem)
+                # Only capture aliases for types listed in VALID_ALIAS_FLAGS
+                if original_type in VALID_ALIAS_FLAGS:
+                    if alias not in ALL_ALIAS_NAMES:
+                        ALL_ALIAS_NAMES.append(alias)
+                    vk_flags_aliases[alias] = original_type  # Store {alias_name: original_type}
+
+    return vk_flags_aliases
+
+
+def write_aliases(
+    vk_py_file_handle: IO[str],
+    aliases: dict[str, str],
+    comment: str,
+    filter_required_data_members: bool = False,
+) -> None:
+    """Writes extracted type aliases (VkFlags or struct aliases) as Python assignments to a file."""
+    content = ""
+    content += f"{comment}\n\n"
+    if filter_required_data_members:
+        content += "\n".join(f"{alias} = {original}" for alias, original in aliases.items() if alias in REQUIRED_DATA_MEMBERS)
+    else:
+        content += "\n".join(f"{alias} = {original}" for alias, original in aliases.items() if is_valid_struct_name(original))
+    content += "\n\n"
+    write_py_file(vk_py_file_handle, content)
+
+
+# --- ENUM EXTRACTION & WRITING FUNCTIONS ---
+
+
+def fetch_enums_with_type_attribute(root: ET.Element):
+    """Parses all <enums> blocks (except API constants) to extract enum members and values."""
+    parsed_enums: Dict[str, Dict[str, Optional[str]]] = defaultdict(dict)
+    processed_enums = set()  # Keep track of processed enum types to avoid duplicates
+
+    for enums_tag in root.findall(f"{TAG_ENUMS}"):
+        enum_type_name = enums_tag.get(ATTR_NAME)  # Name of the enum type (e.g., VkResult)
+        # Skip if no name or if it's the special API constants block
+        if not enum_type_name or enum_type_name == VK_API_CONSTANTS:
+            continue
+
+        if enum_type_name in processed_enums:
+            continue
+
+        # Add to global list if it's a newly encountered enum type
+        if enum_type_name not in ALL_ENUM_NAMES:
+            ALL_ENUM_NAMES.append(enum_type_name)
+
+        enum_map = {}  # Stores {member_name: value/bitpos} for the current enum type
+        # Iterate through individual <enum> members within the <enums> block
+        for enum_tag in enums_tag.findall(f"{TAG_ENUM}"):
+            name = enum_tag.get(ATTR_NAME)  # Enum member name (e.g., VK_SUCCESS)
+            value = enum_tag.get(ATTR_VALUE)  # Explicit value
+            bitPos = enum_tag.get("bitpos")  # Bit position (for bitmasks)
+
+            if name is not None and (value is not None or bitPos is not None):
+                # Prefer bitpos if value is missing (common for bitmasks)
+                if not value and bitPos:
+                    enum_map[name] = bitPos
+                else:
+                    enum_map[name] = value
+        parsed_enums[enum_type_name] = enum_map
+        processed_enums.add(enum_type_name)
+
+    return parsed_enums
+
+
+def write_enums(vk_py_file_handle: IO[str], enums: dict[str, dict[str, Optional[str]]]) -> None:
+    """Writes necessary enum definitions as Python Enum classes and generates C++ traits string."""
+    content = "# --- Enum Definitions ---\n"
+    # Iterate through all parsed enum types
+    for enum_name, members in enums.items():
+        # Only generate code for enums that were deemed necessary (used by structs)
+        if enum_name not in NECESSARY_ENUMS:
+            continue
+
+        enum_member_map[enum_name] = members
+        # --- Python Enum class generation ---
+        content += f"class {enum_name}(Enum):\n"
+        if members:
+            for member, value in members.items():
+                # Ensure both member name and value/bitpos exist
+                if value is not None and member:
+                    content += f"    {member} = {value}\n"
+            if enum_name == "VkFormat":
+                enum_member_map[enum_name].update(additional_vk_format_values)
+                for member, value in additional_vk_format_values.items():
+                    # Ensure both member name and value/bitpos exist
+                    if value is not None and member:
+                        content += f"    {member} = {int(value)}\n"
+        else:
+            content += "    pass\n"
+        content += "\n"
+    content += "\n"
+    write_py_file(vk_py_file_handle, content)
+
+
+# --- HANDLE EXTRACTION & WRITING FUNCTIONS ---
+
+
+def fetch_struct_handles(root: ET.Element):
+    """Extracts a list of names for types categorized as 'handle' in the XML."""
+    created_class_names = []
+    # Find all <type> tags with category='handle'
+    for type_tag in root.findall(f".//{TAG_TYPE}[@{ATTR_CATEGORY}='{CAT_HANDLE}']"):
+        name_tag = type_tag.find("name")  # Find the <name> child element
+        if name_tag is not None and name_tag.text:
+            # Basic sanitization: remove non-alphanumeric characters (except underscore)
+            class_name = re.sub(r"[^a-zA-Z0-9_]", "", name_tag.text.strip())
+            if class_name and class_name not in created_class_names:
+                created_class_names.append(class_name)
+                # Add handle names to the global list of all struct-like types
+                if class_name not in ALL_STRUCT_NAMES:
+                    ALL_STRUCT_NAMES.append(class_name)
+    return created_class_names
+
+
+def write_empty_dataclasses(dataclasses_list: List[str], vk_py_file_handle: IO[str]):
+    """Generates empty Python dataclasses for Vulkan handle types and adds predefined common structs."""
+    created_class_names = set()  # Track generated classes to avoid duplicates
+    content_to_append = "\n# --- Empty Handle Dataclasses ---\n\n"
+
+    # Generate empty dataclasses only for handles that are dependencies of physical device structs
+    for class_name in dataclasses_list:
+        if class_name not in VK_PHYSICAL_DEVICE_DEPENDENT_STRUCTURES_LIST:
+            continue
+        if class_name not in created_class_names:
+            content_to_append += f"@dataclass\n"
+            content_to_append += f"class {class_name}:\n"
+            content_to_append += f"    pass\n\n"
+            created_class_names.add(class_name)
+
+    # Add manually defined common Vulkan struct definitions
+    content_to_append += "# --- Pre-defined Struct Definitions ---\n"
+    content_to_append += EXTRA_STRUCTURES_CONTENT
+    write_py_file(vk_py_file_handle, content_to_append)
+
+
+# --- STRUCT DEFINITION PROCESSING (Parsing & Writing vk_definitions.py content) ---
+
+
+# --- Struct Validation Helpers ---
+def is_valid_struct_name(struct_name):
+    """Checks if a struct name starts with the physical device prefix and is not invalid."""
+    return struct_name.startswith(PHYSICAL_DEVICE_PREFIX)
+
+
+def check_valid_struct_extends(struct_extends):
+    """Validates if a struct extends one of the base physical device property/feature structs."""
+    return "VkPhysicalDeviceProperties2" in struct_extends or "VkPhysicalDeviceFeatures2" in struct_extends
+
+
+def check_if_valid_struct(struct_name, alias_name):
+    """Determines if a struct or its alias is considered valid for processing (not None or disabled)."""
+    if not struct_name:
+        return False
+    # Check both original and alias name against the disabled list
+    if struct_name in disabled_structs or alias_name in disabled_structs:
+        return False
+    return True
+
+
+# --- Type Formatting for Struct Members ---
+def format_data_types(c_type: str, array_size_str: Optional[str], struct_name_context: str) -> str:
+    """Converts C type strings (including pointers, arrays) into Python type hints."""
+    py_type_hint = c_type  # Default to original C type if no specific rule matches
+    is_list = False  # Flag indicating if the type should be List[...]
+    shouldSkipCheck = False  # Flag to bypass the unknown type check
+
+    # 1. Handle specific pointer types first
+    if CONST_CHAR_POINTER_REGEX.search(c_type) or CHAR_POINTER_REGEX.search(c_type):
+        py_type_hint = "str"  # 'const char*' or 'char*' maps to Python 'str'
+    elif VOID_POINTER_REGEX.search(c_type):
+        py_type_hint = "object"  # 'void*' maps to Python 'object' (or could use 'Any')
+
+    # 2. Handle general 'const <type> *' (pointer to const) -> 'List[<type>]'
+    elif const_ptr_match := CONST_POINTER_REGEX.match(c_type):
+        base_type = const_ptr_match.group(1).strip()  # Extract the base type
+        py_type_hint = base_type
+        is_list = True  # Pointers generally map to lists
+
+    # 3. Handle general non-const '<type> *' -> 'List[<type>]'
+    elif c_type.strip().endswith("*") and not py_type_hint == "object":
+        base_type = c_type.strip().replace("*", "").strip()
+        py_type_hint = base_type
+        is_list = True  # Pointers map to lists
+
+    # 4. Handle C-style arrays '[SIZE]' if 'array_size_str' is provided
+    elif array_size_str:
+        base_type = c_type  # Type before the brackets
+        if base_type == "float":
+            # Represent float arrays using a specific type hint format if needed
+            py_type_hint = f"{FLOAT_ARRAY_REPLACEMENT_TYPE} * {array_size_str}"
+            shouldSkipCheck = True  # Skip check for this specific format
+        elif base_type == "char":
+            # Fixed-size char arrays in C often represent strings
+            py_type_hint = "str"
+        elif base_type in PRIMITIVE_DATA_TYPE:
+            # Represent primitive arrays using a specific format if needed (e.g., for ctypes)
+            py_type_hint = f"{base_type} * {array_size_str}"
+            shouldSkipCheck = True
+        else:
+            # Assume arrays of non-primitives (structs, enums) map to List
+            py_type_hint = base_type
+            is_list = True
+
+    # 5. If none of the above, it's a simple type name (e.g., uint32_t, VkResult)
+    else:
+        py_type_hint = c_type  # Use the C type name directly
+
+    # --- Clean up and Final Check ---
+    py_type_hint = py_type_hint.replace("const ", "").strip()  # Remove 'const ' prefix
+    core_type_for_check = py_type_hint  # The base type after initial conversion
+
+    # Verify the resulting base Python type hint is known (primitive, struct, enum, alias)
+    if (
+        not shouldSkipCheck
+        and core_type_for_check not in ALL_STRUCT_NAMES
+        and core_type_for_check not in ALL_ENUM_NAMES
+        and core_type_for_check not in ALL_ALIAS_NAMES
+        and core_type_for_check not in ALL_CONSTANTS
+    ):
+        raise Exception(f"Warning: Unknown base type '{core_type_for_check}' derived from C type '{c_type}' " f"in struct '{struct_name_context}'")
+
+    if is_list:
+        py_type_hint = f"List[{py_type_hint}]"
+
+    return py_type_hint
+
+
+# --- Core Struct Parsing ---
+
+
+def fetch_all_structs_and_aliases(
+    struct_elements: List[ET.Element],
+) -> Tuple[Dict[str, List[Tuple[str, str, Optional[str]]]], Dict[str, str]]:
+    """
+    Parses VkPhysicalDevice struct definitions and aliases from XML.
+    Extracts member details (name, C type, array size) for each struct,
+    handles aliases, and populates global lists for dependency tracking
+    (e.g., `VK_PHYSICAL_STRUCT_NAMES`, `REQUIRED_STRUCT_NAMES`, `NECESSARY_ENUMS`).
+    """
+    parsed_structs: Dict[str, List[Tuple[str, str, Optional[str]]]] = {}  # {struct_name: [(member_name, c_type, array_size)]}
+    struct_alias_data = {}  # Stores {alias_name: original_struct_name}
+
+    for struct_elem in struct_elements:
+        struct_name = struct_elem.get(ATTR_NAME)
+        alias_name = struct_elem.get(ATTR_ALIAS)
+        is_struct_of_interest = is_valid_struct_name(struct_name)
+
+        # Skip if the struct (or its alias) is invalid or disabled
+        if not check_if_valid_struct(struct_name, alias_name):
+            continue
+
+        # Add if structs has valid structextends ('VkPhysicalDeviceProperties2' or 'VkPhysicalDeviceFeatures2')
+        if struct_name in structs_with_valid_extends:
+            if struct_name not in VK_PHYSICAL_STRUCT_NAMES:
+                VK_PHYSICAL_STRUCT_NAMES.append(struct_name)
+
+        # --- Handle Aliases ---
+        if alias_name:
+            struct_alias_data[struct_name] = alias_name
+            continue  # Don't process members for the alias tag itself
+
+        # --- Process Actual Struct Definitions ---
+
+        if is_struct_of_interest:
+            if struct_name not in REQUIRED_STRUCT_NAMES:
+                REQUIRED_STRUCT_NAMES.append(struct_name)
+
+        struct_members: List[Tuple[str, str, Optional[str]]] = []
+        # Iterate through <member> tags within the struct definition
+        for member_elem in struct_elem.findall(TAG_MEMBER):
+            member_type_tag = member_elem.find(TAG_TYPE)
+            member_name_tag = member_elem.find(TAG_NAME)
+
+            member_type = get_element_text(member_type_tag)  # C type (e.g., 'uint32_t', 'const char*')
+            member_name = get_element_text(member_name_tag)  # Member variable name
+            member_array_size: Optional[str] = None  # Extracted array size (like 'VK_UUID_SIZE')
+            member_type_c = member_type  # Keep the original C type string
+
+            # Skip standard Vulkan struct members (sType, pNext)
+            if member_name in STANDARD_MEMBER_NAMES_TO_SKIP:
+                continue
+
+            # Determine base type for dependency checking (strip const/pointer)
+            base_type_for_necessity_check = member_type_c.replace("const", "").replace("*", "").strip()
+
+            # --- Determine Array Size (from 'len' attribute or '[size]' notation) ---
+            len_attr = member_elem.get(ATTR_LEN)
+            if len_attr and len_attr.strip().lower() != "null-terminated":
+                member_array_size = len_attr.strip()
+            elif member_name_tag is not None:  # Check for '[size]' notation after <name> tag
+                tail_text = member_name_tag.tail.strip() if member_name_tag.tail else ""
+                next_tag = find_next_tag(member_elem, member_name_tag)
+                # Case 2a: Size defined by an adjacent <enum> tag: <name>type_name</name>[<enum>SIZE</enum>]
+                if tail_text.startswith("[") and next_tag is not None and next_tag.tag == TAG_ENUM:
+                    enum_text = get_element_text(next_tag)
+                    enum_tail = next_tag.tail.strip() if next_tag.tail else ""
+                    if enum_text and enum_tail.endswith("]"):
+                        member_array_size = enum_text
+                # Case 2b: Size defined in plain text in tail: <name>type_name</name>[32]
+                elif not member_array_size:
+                    match = ARRAY_TAIL_REGEX.search(tail_text)
+                    if match:
+                        member_array_size = match.group(1).strip()
+
+            # --- Dependency Tracking ---
+            # If parsing a physical device struct and a member is a non-primitive type,
+            # mark that type as a required dependency.
+            if is_struct_of_interest and base_type_for_necessity_check not in PRIMITIVE_DATA_TYPE:
+                if (
+                    base_type_for_necessity_check and base_type_for_necessity_check != "void" and base_type_for_necessity_check not in REQUIRED_STRUCT_NAMES
+                ):  # Check if the type is valid, not void, and not already required
+                    REQUIRED_STRUCT_NAMES.append(base_type_for_necessity_check)
+                    # Also track as a direct dependency of physical device structs
+                    if base_type_for_necessity_check not in VK_PHYSICAL_DEVICE_DEPENDENT_STRUCTURES_LIST:
+                        VK_PHYSICAL_DEVICE_DEPENDENT_STRUCTURES_LIST.append(base_type_for_necessity_check)
+
+            if member_type and member_name:
+                if struct_name in REQUIRED_STRUCT_NAMES:
+                    # Adding all required ENUMs
+                    if base_type_for_necessity_check in ALL_ENUM_NAMES and base_type_for_necessity_check not in NECESSARY_ENUMS:
+                        NECESSARY_ENUMS.append(base_type_for_necessity_check)
+                if base_type_for_necessity_check not in REQUIRED_DATA_MEMBERS:
+                    REQUIRED_DATA_MEMBERS.append(base_type_for_necessity_check)
+                struct_members.append((member_name, member_type, member_array_size))
+
+        if struct_name:
+            parsed_structs[struct_name] = struct_members
+
+    return parsed_structs, struct_alias_data
+
+
+# --- Writing Struct Dataclasses ---
+def write_structs(vk_py_file_handle: IO[str], structs: Dict[str, List[Tuple[str, str, Optional[str]]]]) -> None:
+    """Writes Python dataclass definitions for parsed structs, ensuring dependencies are written first."""
+    content = "# --- Vulkan Struct Definitions (Dependencies first, then PhysicalDevice structs) ---\n\n"
+    local_content = ""
+
+    # Helper function to generate the @dataclass string for a single struct
+    def process_struct(class_name: str, member_list: List[Tuple[str, str, Optional[str]]]):
+        nonlocal local_content
+        local_content += "@dataclass\n"
+        local_content += f"class {class_name}:\n"
+        if member_list:
+            for member_name, member_type_c, size_val in member_list:
+                # Convert the C type to a Python type hint
+                python_type_hint = format_data_types(member_type_c, size_val, class_name)
+                local_content += f"    {member_name}: {python_type_hint}\n"  # Add member line
+        else:
+            # Handle structs with no members (e.g., placeholder structs)
+            local_content += "    pass\n"
+        local_content += "\n"  # Add blank line after class definition
+
+    # --- Write Structs in Dependency Order ---
+    # First pass: Write structs that are dependencies of physical device structs
+    for class_name, member_list in structs.items():
+        if class_name in VK_PHYSICAL_DEVICE_DEPENDENT_STRUCTURES_LIST:
+            process_struct(class_name, member_list)
+
+    # Second pass: Write the required physical device structs themselves (if not already written as dependencies)
+    for class_name, member_list in structs.items():
+        if class_name in REQUIRED_STRUCT_NAMES and class_name not in VK_PHYSICAL_DEVICE_DEPENDENT_STRUCTURES_LIST:
+            process_struct(class_name, member_list)
+
+    # Combine the initial comment with the generated struct definitions
+    content += local_content
+    if not local_content.endswith("\n\n"):
+        if local_content.endswith("\n"):
+            content += "\n"
+        else:
+            content += "\n\n"
+
+    write_py_file(vk_py_file_handle, content)
+
+
+# --- STRUCT & EXTENSION MAPPING LOGIC (Processing for vk.py content) ---
+
+
+# --- Initial Filtering based on XML attributes/API types ---
+def create_disabled_struct_list(struct_elements: List[ET.Element]) -> None:
+    """Identifies structs to disable based on invalid suffixes or if they don't extend expected base structs."""
+    for type_element in struct_elements:
+        struct_name = type_element.get(ATTR_NAME)
+        structextends = type_element.get(ATTR_STRUCT_EXTENDS)  # Check the 'structextends' attribute
+
+        # Condition for disabling a struct:
+        # 1. It has a 'structextends' attribute, but it doesn't reference the valid base structs ('VkPhysicalDeviceProperties2' or 'VkPhysicalDeviceFeatures2')
+        is_invalid_extends = structextends and not check_valid_struct_extends(struct_extends=structextends)
+
+        if is_invalid_extends:
+            if struct_name and struct_name not in disabled_structs:
+                disabled_structs.append(struct_name)
+
+
+def extract_vulkan_sc_features(root: ET.Element):
+    """Identifies physical device structs required only by Vulkan SC API and adds them to the disabled list."""
+    # Find <feature> tags specific to the 'vulkansc' API
+    feature_tags = root.findall(f'.//{TAG_FEATURE}[@{ATTR_API}="{VK_VULKAN_SC_FILTER}"]')
+    for feature in feature_tags:
+        feature_name = feature.get(ATTR_NAME)
+        if not feature_name:
+            continue
+        # Find types required by this Vulkan SC feature
+        for require_tag in feature.findall(f"./{TAG_REQUIRE}"):
+            for type_tag in require_tag.findall(f"./{TAG_TYPE}"):
+                type_name = type_tag.get(ATTR_NAME)
+                # If it's a physical device struct, add it to the disabled list
+                if type_name and type_name.startswith(PHYSICAL_DEVICE_PREFIX):
+                    if type_name not in disabled_structs:
+                        disabled_structs.append(type_name)
+
+
+# --- Core Mappings for Structs ---
+def extract_struct_to_type_mapping(struct_elements: List[ET.Element]) -> Dict[str, str]:
+    """
+    Maps Vulkan struct names (including aliases) to their VkStructureType enum strings.
+    Identifies core version structs for `CORE_MAPPING_STRUCT_LIST` and structs
+    with valid 'structextends' attributes for `structs_with_valid_extends`.
+    Resolves aliases to find their sType values.
+    """
+    struct_to_type_map: Dict[str, str] = {}  # {struct_name: sType_enum_value}
+
+    # --- First Pass: Extract Direct sType Values ---
+    for type_elem in struct_elements:
+        struct_name = type_elem.get(ATTR_NAME)
+        alias_name = type_elem.get(ATTR_ALIAS)
+        struct_extends = type_elem.get(ATTR_STRUCT_EXTENDS)
+
+        if struct_name not in ALL_STRUCT_NAMES:
+            ALL_STRUCT_NAMES.append(struct_name)
+
+        # Skip invalid, disabled, or non-physical device structs
+        if not check_if_valid_struct(struct_name, alias_name) or not is_valid_struct_name(struct_name):
+            continue
+
+        # Handle Aliases: Store alias mapping and skip member processing for this tag
+        if alias_name:
+            alias_map[struct_name] = alias_name  # Store {alias: original}
+            if alias_name in structs_with_valid_extends:
+                if struct_name not in structs_with_valid_extends:
+                    structs_with_valid_extends.append(struct_name)
+            continue
+
+        # Track structs that don't extend the expected base types
+        if struct_extends and check_valid_struct_extends(struct_extends=struct_extends):
+            if struct_name not in structs_with_valid_extends:
+                structs_with_valid_extends.append(struct_name)
+
+        # Track core physical device structs (e.g., VkPhysicalDeviceVulkan11Properties) separately
+        if struct_name not in CORE_MAPPING_STRUCT_LIST:
+            match = CORE_VERSION_REGEX.match(struct_name)
+            if match:
+                CORE_MAPPING_STRUCT_LIST.append(struct_name)
+
+        # Find the 'sType' member to get the structure type enum value
+        for member_elem in type_elem.findall(TAG_MEMBER):
+            name_elem = member_elem.find(TAG_NAME)
+            if get_element_text(name_elem) == "sType":
+                values = member_elem.get(ATTR_VALUES)
+                if values:
+                    struct_to_type_map[struct_name] = values  # Store {struct_name: sType_value}
+                    break
+
+    # --- Second Pass: Resolve Aliases ---
+    # Helper function to recursively find the sType value by following alias chains
+    def resolve_alias_chain(alias: str, visited=None) -> Optional[str]:
+        if visited is None:
+            visited = set()
+        if alias in visited:
+            return None
+
+        visited.add(alias)
+        target = alias_map.get(alias)  # Get the name the alias points to
+        if not target:
+            return None
+
+        if target in struct_to_type_map:
+            return struct_to_type_map[target]
+        # Otherwise, if the target is itself an alias, resolve it recursively
+        elif target in alias_map:
+            return resolve_alias_chain(target, visited)
+        else:
+            return None
+
+    # Resolve sType values for all found struct aliases and add them to the map
+    resolved_aliases = {}
+    for alias, original in alias_map.items():
+        # Only resolve if the original struct is a relevant physical device struct
+        if is_valid_struct_name(original):
+            resolved_value = resolve_alias_chain(alias)
+            if resolved_value:
+                resolved_aliases[alias] = resolved_value
+
+    struct_to_type_map.update(resolved_aliases)
+    return struct_to_type_map
+
+
+def extract_struct_extends_mapping(struct_elements: List[ET.Element]) -> Dict[str, str]:
+    alias_struct_name_to_target_name_map: Dict[str, str] = {}  # {alias_name: name_it_points_to}
+    # Stores structextends for non-alias structs that define it
+    defined_struct_name_to_struct_extends_map: Dict[str, str] = {}
+    all_declared_struct_names: Set[str] = set()  # Stores all names from type_elem.get(ATTR_NAME)
+
+    # --- First Pass: Collect direct structextends and alias definitions ---
+    for type_elem in struct_elements:
+        struct_name = type_elem.get(ATTR_NAME)
+
+        if not check_if_valid_struct(struct_name, None):
+            continue
+
+        all_declared_struct_names.add(struct_name)
+        alias_target = type_elem.get(ATTR_ALIAS)
+        struct_extends_value = type_elem.get(ATTR_STRUCT_EXTENDS)
+
+        if struct_extends_value and not check_valid_struct_extends(struct_extends_value):
+            continue
+
+        if alias_target:
+            # This struct_name is an alias for alias_target
+            alias_struct_name_to_target_name_map[struct_name] = alias_target
+        elif struct_extends_value:
+            # This struct is not an alias and has a structextends attribute directly
+            defined_struct_name_to_struct_extends_map[struct_name] = struct_extends_value
+
+    # --- Second Pass: Resolve structextends for all struct names (including aliases) ---
+    final_struct_name_to_resolved_struct_extends_map: Dict[str, str] = {}
+
+    def get_resolved_struct_extends(name_to_resolve: str, visited_in_chain: Set[str]) -> Optional[str]:
+        """
+        Recursively resolves the structextends value for a given name.
+        - If name_to_resolve has a direct structextends, returns it.
+        - If name_to_resolve is an alias, follows the alias chain.
+        - Returns None if no structextends is found or a cycle is detected.
+        """
+        if name_to_resolve in visited_in_chain:
+            # Cycle detected in alias chain
+            return None
+        visited_in_chain.add(name_to_resolve)
+
+        # Case 1: The name_to_resolve is a non-alias struct that directly defines structextends
+        if name_to_resolve in defined_struct_name_to_struct_extends_map:
+            return defined_struct_name_to_struct_extends_map[name_to_resolve]
+
+        # Case 2: The name_to_resolve is an alias. Follow the chain.
+        if name_to_resolve in alias_struct_name_to_target_name_map:
+            target_name = alias_struct_name_to_target_name_map[name_to_resolve]
+            return get_resolved_struct_extends(target_name, visited_in_chain)
+
+        # Case 3: The name is not an alias we know of, and not in the direct map.
+        # This means it's an original struct without 'structextends', or an unresolvable name.
+        return None
+
+    # Iterate through all unique struct names found in the XML
+    for name in all_declared_struct_names:
+        resolved_extends_value = get_resolved_struct_extends(name, set())
+
+        if resolved_extends_value:
+            final_struct_name_to_resolved_struct_extends_map[name] = resolved_extends_value
+
+    return final_struct_name_to_resolved_struct_extends_map
+
+
+def write_structs_extends_mapping(struct_elements: List[ET.Element], vk_py_file_handle: IO[str]):
+    struct_extends_mapping_dict = extract_struct_extends_mapping(struct_elements)
+    struct_extends_mapping_str = pprint.pformat(struct_extends_mapping_dict, indent=2, width=100)
+    content = f"\n# --- STRUCT EXTENDS MAPPINGS ---\n\nSTRUCT_EXTENDS_MAPPING = {struct_extends_mapping_str}\n\n"
+    write_py_file(vk_py_file_handle, content)
+
+
+# --- Feature/Extension/Core Version Based Mappings ---
+def extract_feature_struct_mapping(root: ET.Element, struct_to_type_map: Dict[str, str], api_filter: str):
+    """
+    Maps Vulkan API features (e.g., VK_API_VERSION_1_1) to PhysicalDevice structs they introduce.
+    Populates the global `feature_api_map`. Filters structs based on:
+    - Validity (PhysicalDevice, not disabled).
+    - Having valid 'structextends' (in `structs_with_valid_extends`).
+    - Not being a core version struct (not in `CORE_MAPPING_STRUCT_LIST`).
+    """
+    # Find <feature> tags matching the specified API filter (e.g., 'vulkan')
+    feature_tags = root.findall(f'.//{TAG_FEATURE}[@{ATTR_API}="{api_filter}"]')
+
+    for feature in feature_tags:
+        feature_name = feature.get(ATTR_NAME)  # e.g., "VK_API_VERSION_1_1"
+        if not feature_name:
+            continue
+
+        if feature_name not in feature_api_map:
+            feature_api_map[feature_name] = []
+
+        # Find <require> blocks within the feature
+        for require_tag in feature.findall(f"./{TAG_REQUIRE}"):
+            # Find <type> tags specifying required types (structs, enums, etc.)
+            for type_tag in require_tag.findall(f"./{TAG_TYPE}"):
+                type_name = type_tag.get(ATTR_NAME)
+                is_struct_of_interest = is_valid_struct_name(type_name)
+
+                # --- Skip if not relevant ---
+                if type_name in disabled_structs:
+                    continue
+
+                if type_name not in structs_with_valid_extends:
+                    continue
+
+                if type_name in CORE_MAPPING_STRUCT_LIST:
+                    continue  # Core structs handled separately
+                # --- Process relevant structs ---
+                if type_name and is_struct_of_interest:
+                    structure_type = struct_to_type_map.get(type_name)
+                    if not structure_type:  # Skip if sType couldn't be found (shouldn't happen for valid structs)
+                        continue
+                    # Create the mapping {struct_name: sType_value}
+                    struct_map = {type_name: structure_type}
+                    if struct_map not in feature_api_map[feature_name]:
+                        feature_api_map[feature_name].append(struct_map)
+
+
+def extract_extension_struct_mapping(root: ET.Element, struct_to_type_map: Dict[str, str]) -> Tuple[Dict[str, List[Dict[str, str]]], Set[str]]:
+    """
+    Maps enabled Vulkan extensions to their required PhysicalDevice structs.
+    Filters extensions (e.g., not 'disabled', 'android' platform). Structs from
+    skipped extensions are added to `disabled_structs`.
+    For included extensions, structs must be:
+    - Valid PhysicalDevice structs (not disabled).
+    - Have valid 'structextends' (in `structs_with_valid_extends`).
+    """
+    extension_map: Dict[str, List[Dict[str, str]]] = defaultdict(list)  # {ext_name: [{struct: sType}]}
+    extensions_found = root.findall(f".//{TAG_EXTENSION}")  # Find all <extension> tags
+    processed_structs: Set[str] = set()
+
+    for extension in extensions_found:
+        ext_name = extension.get(ATTR_NAME)  # Extension name (e.g., "VK_KHR_surface")
+        supported = extension.get(ATTR_SUPPORTED)  # Usually "vulkan", "disabled", etc.
+        platform = extension.get(ATTR_PLATFORM)  # e.g., "android", "win32"
+        if not ext_name:
+            continue
+
+        # --- Filter out disabled, non-standard, or unsupported platform extensions ---
+        is_disabled_or_unsupported = supported == "disabled" or (platform and platform != "android")
+
+        if is_disabled_or_unsupported:
+            # If extension is skipped, add its required types to the global disabled list
+            for require_tag in extension.findall(f"./{TAG_REQUIRE}"):
+                type_names_list = [type_tag.get(ATTR_NAME) for type_tag in require_tag.findall(f"./{TAG_TYPE}") if type_tag.get(ATTR_NAME)]
+                for type_name in type_names_list:
+                    if type_name not in disabled_structs:
+                        disabled_structs.append(type_name)
+            continue  # Skip processing this extension further
+
+        # --- Process enabled/supported extensions ---
+        current_ext_structs: List[Dict[str, str]] = []  # Structs required by *this* specific extension
+        for require_tag in extension.findall(f"./{TAG_REQUIRE}"):
+            # Get names of all types required by this section of the extension
+            type_names_list = [type_tag.get(ATTR_NAME) for type_tag in require_tag.findall(f"./{TAG_TYPE}") if type_tag.get(ATTR_NAME)]
+            for type_name in type_names_list:
+
+                # Skip disabled structs
+                if type_name in disabled_structs:
+                    continue
+
+                # Process only relevant physical device structs not already added to the map
+                if type_name not in processed_structs and type_name in ALL_STRUCT_NAMES:
+                    if "Properties" not in type_name and "Features" not in type_name:
+                        if type_name not in disabled_structs:
+                            disabled_structs.append(type_name)
+                        continue
+                    if type_name not in structs_with_valid_extends:
+                        continue
+                    # Look up the sType value from the precomputed map
+                    structure_type = struct_to_type_map.get(type_name)
+                    if structure_type:
+                        struct_map = {type_name: structure_type}
+                        # Add to this extension's list if not already present
+                        if struct_map not in current_ext_structs:
+                            current_ext_structs.append(struct_map)
+                            processed_structs.add(type_name)  # Mark struct as processed globally
+
+        if current_ext_structs:
+            extension_map[ext_name] = current_ext_structs
+
+    return dict(extension_map), processed_structs
+
+
+def generate_core_struct_mapping(struct_names: list[str], vk_py_file_handle: IO[str]) -> dict:
+    """
+    Generates and writes the VULKAN_CORES_AND_STRUCTS_MAPPING dictionary.
+    This map links core Vulkan versions (e.g., "Core11") to their specific
+    PhysicalDevice Properties and Features structs (e.g., VkPhysicalDeviceVulkan11Features).
+    It processes struct names from the `CORE_MAPPING_STRUCT_LIST`.
+    """
+    STRUCTURE_TYPE_PREFIX_PART = "PHYSICAL_DEVICE"
+    versions_map = defaultdict(list)  # { "Core11": [{struct: sType}], ... }
+
+    # Process struct names matching the core version pattern (e.g., VkPhysicalDeviceVulkan11Properties)
+    for struct_name in struct_names:
+        match = CORE_VERSION_REGEX.match(struct_name)
+        if match:
+            # Extract version digits (e.g., "11") and suffix (e.g., "Properties")
+            _, _, version_digits, suffix = match.groups()
+            core_key = f"Core{version_digits}"  # Create key like "Core11", "Core12"
+
+            # Format version for the enum name (e.g., "11" -> "1_1")
+            if len(version_digits) == 2:
+                version_snake = f"{version_digits[0]}_{version_digits[1]}"
+            else:  # Unlikely based on current vk.xml naming
+                version_snake = version_digits
+
+            # Construct the expected VkStructureType enum value name based on convention
+            suffix_upper = suffix.upper()  # "Properties" -> "PROPERTIES"
+            structure_type_value = f"VK_STRUCTURE_TYPE_{STRUCTURE_TYPE_PREFIX_PART}_VULKAN_{version_snake}_{suffix_upper}"
+
+            inner_map = {struct_name: structure_type_value}
+            versions_map[core_key].append(inner_map)
+
+    sorted_versions_map = dict(sorted(versions_map.items(), key=lambda item: int(item[0][4:])))
+
+    core_comment = """\
+# VULKAN_CORES_AND_STRUCTS_MAPPING: Maps core Vulkan versions (e.g., "Core11") to their
+# specific PhysicalDevice Properties and Features structs.
+# Struct Filters:
+# - Name matches "VkPhysicalDeviceVulkan<Version><Properties|Features>" (from CORE_MAPPING_STRUCT_LIST).
+# - sType is programmatically derived.
+# Format: {"versions": {core_version_key: [{struct_name: sType_enum_value}, ...]}}\n"""
+
+    allStructInfo = "\n# --- Vulkan Core Version to Struct Mappings ---\n"
+    allStructInfo += core_comment + "\n"  # Add the comment
+    allStructInfo += """VULKAN_CORES_AND_STRUCTS_MAPPING = {"versions":"""
+    allStructInfo += f"{pprint.pformat(sorted_versions_map, indent=2, width=100)}\n"
+    allStructInfo += "}\n\n"
+    write_py_file(vk_py_file_handle, allStructInfo)
+
+    return {"versions": sorted_versions_map}
+
+
+# --- Ancillary Mappings & Lists for vk.py ---
+def extract_list_size_mapping(struct_elements: List[ET.Element]) -> Dict[str, str]:
+    """Extracts mappings from list members to their corresponding size-indicating members within structs."""
+    member_map = {}  # Stores {list_member_name: size_member_name}
+    for type_element in struct_elements:
+        struct_name = type_element.get(ATTR_NAME)
+        # Skip invalid or non-physical device structs
+        if not check_if_valid_struct(struct_name, None) or not is_valid_struct_name(struct_name):
+            continue
+
+        # Find members within the struct that have a 'len' attribute
+        for member_element in type_element.findall(f"./{TAG_MEMBER}[@{ATTR_LEN}]"):
+            len_attribute_value = member_element.get(ATTR_LEN)  # Name of the member holding the size
+            name_tag = member_element.find(TAG_NAME)
+            name_value = get_element_text(name_tag)  # Name of the list/array member
+            # Store the mapping if valid (names exist, len is not "null-terminated")
+            if name_value and len_attribute_value and len_attribute_value.strip().lower() != "null-terminated":
+                member_map[name_value] = len_attribute_value.strip()
+    return member_map
+
+
+def write_list_size_mapping(struct_elements: List[ET.Element], vk_py_file_handle: IO[str]):
+    """Extracts and writes the list-member-to-size-member mapping to a Python file."""
+    list_size_map = extract_list_size_mapping(struct_elements)
+    content = "# --- List Size Mappings (Field name to size field name) ---\n\n"
+    list_size_str = pprint.pformat(list_size_map, indent=2, width=100)
+    content += f"""LIST_TYPE_FIELD_AND_SIZE_MAPPING = {list_size_str}\n\n"""
+    write_py_file(vk_py_file_handle, content)
+
+
+def write_all_structs(vk_py_file_handle: IO[str]) -> None:
+    """Writes a Python list of all processed PhysicalDevice struct names."""
+    VK_PHYSICAL_STRUCT_NAMES.sort()
+    comment = (
+        "\n# --- List of All Processed Physical Device Structs ---\n"
+        "# Includes structs that:\n"
+        "# 1. Are not in 'disabled_structs' (implicitly, via VK_PHYSICAL_STRUCT_NAMES population).\n"
+        '# 2. Extend "VkPhysicalDeviceProperties2" or "VkPhysicalDeviceFeatures2"\n'
+        "#    (i.e., are in 'structs_with_valid_extends').\n\n"
+    )
+    allStructInfo = comment
+    allStructInfo += """ALL_STRUCTS_EXTENDING_FEATURES_OR_PROPERTIES = [\n"""
+    # Add each physical device struct name as a string element in the list
+    for class_name in VK_PHYSICAL_STRUCT_NAMES:
+
+        allStructInfo += f"    {class_name},\n"
+    allStructInfo += f"]\n\n"
+    write_py_file(vk_py_file_handle, allStructInfo)
+
+
+def write_extension_independent_structs(structs_in_extensions: Set[str], vk_py_file_handle: IO[str]):
+    """Writes a list of PhysicalDevice structs not tied to specific features or enabled extensions."""
+    all_physical_device_structs = VK_PHYSICAL_STRUCT_NAMES
+    # Find structs that are not disabled and not explicitly required by features/extensions
+    independent_structs = [
+        struct
+        for struct in all_physical_device_structs
+        if struct not in disabled_structs and struct in structs_with_valid_extends and struct not in CORE_MAPPING_STRUCT_LIST and struct not in structs_in_extensions
+    ]
+
+    independent_structs.sort()
+    comment = (
+        "\n# --- Extension Independent Structs ---\n"
+        "# These are PhysicalDevice structs that meet the following criteria:\n"
+        "# 1. Sourced from VK_PHYSICAL_STRUCT_NAMES.\n"
+        "# 2. Not in the global 'disabled_structs' list.\n"
+        '# 3. Extend "VkPhysicalDeviceProperties2" or "VkPhysicalDeviceFeatures2" (in \'structs_with_valid_extends\').\n'
+        "# 4. Not core version-specific (not in CORE_MAPPING_STRUCT_LIST).\n"
+        "# 5. Not required by any enabled Vulkan extension (not in 'structs_in_extensions').\n\n"
+    )
+    content = comment
+    independent_structs_str = pprint.pformat(independent_structs, indent=2, width=100)
+    content += f"""EXTENSION_INDEPENDENT_STRUCTS = {independent_structs_str}\n\n"""
+    write_py_file(vk_py_file_handle, content)
+
+
+# --- Orchestration & Content Generation for Mappings ---
+def parse_structs_and_extensions(xml_root: ET.Element, struct_elements: List[ET.Element]):
+    """
+    Helps in extraction of key mappings for Vulkan structs, features, and extensions.
+    Calls helpers to:
+    1. Map structs to sTypes (`extract_struct_to_type_mapping`).
+    2. Map features to their structs (`extract_feature_struct_mapping`).
+    3. Map extensions to their structs (`extract_extension_struct_mapping`).
+    Populates global lists/dicts as a side effect.
+    """
+    # 1. Create the mapping from struct names (including aliases) to sType values
+    struct_to_type_map = extract_struct_to_type_mapping(struct_elements)
+
+    # 2. Extract feature-to-struct using api filters
+    extract_feature_struct_mapping(xml_root, struct_to_type_map, VK_API_FILTER)
+    extract_feature_struct_mapping(xml_root, struct_to_type_map, VK_VULKAN_FILTER)
+
+    # 3. Extract extension-to-struct mappings for enabled extensions, also getting the set of structs used in extensions
+    extension_map_data, structs_in_extensions = extract_extension_struct_mapping(xml_root, struct_to_type_map)
+    return structs_in_extensions, dict(feature_api_map), extension_map_data
+
+
+def generate_vk_py_content(
+    feature_map: Dict[str, List[Dict[str, str]]],
+    extension_map: Dict[str, List[Dict[str, str]]],
+) -> str:
+    """
+    Formats feature and extension struct mappings for vk.py.
+    Generates Python dictionary string definitions for:
+    - VULKAN_EXTENSIONS_AND_STRUCTS_MAPPING
+    - VULKAN_VERSIONS_AND_STRUCTS_MAPPING
+    Includes comments detailing their generation filters.
+    """
+    # --- Vulkan Extension to Struct Mappings ---
+    extension_comment = """\
+# VULKAN_EXTENSIONS_AND_STRUCTS_MAPPING: Maps enabled extension names to their PhysicalDevice structs.
+# Extension Filters:
+# - 'supported' is not "disabled".
+# - 'platform' (if present) is "android".
+# Struct Filters (per extension):
+# - Not in global 'disabled_structs'.
+# - Extends "VkPhysicalDeviceProperties2" or "VkPhysicalDeviceFeatures2".
+# Format: {ext_name: [{struct_name: sType_enum_value}, ...]}\n"""
+    content = "\n# --- Vulkan Extension to Struct Mappings ---\n"
+    content += extension_comment + "\n"
+    sorted_data = dict(sorted(extension_map.items()))
+    extension_map_str = pprint.pformat(sorted_data, indent=2, width=100)
+    content += """VULKAN_EXTENSIONS_AND_STRUCTS_MAPPING = {"extensions": """
+    content += f"""{extension_map_str}"""
+    content += "}\n\n"
+
+    # --- Vulkan Feature to Struct Mappings ---
+    feature_comment = """\
+# VULKAN_VERSIONS_AND_STRUCTS_MAPPING: Maps API features (e.g., "VK_API_VERSION_1_1")
+# from "vulkan" API to PhysicalDevice structs they introduce.
+# Excludes core version structs (e.g., VkPhysicalDeviceVulkan11Properties), see VULKAN_CORES_AND_STRUCTS_MAPPING.
+# Struct Filters (per feature):
+# - Name: Starts "VkPhysicalDevice".
+# - Not in global 'disabled_structs'.
+# - Extends "VkPhysicalDeviceProperties2" or "VkPhysicalDeviceFeatures2".
+# - Not in CORE_MAPPING_STRUCT_LIST.
+# NOTE:
+# VK_VERSION_1_0" is empty as it does not map to any structure which passes our structure-filter criteria.
+# We have hardcoded the code-block for VK_VERSION_1_0 in vkjson_generator.py
+# Format: {feature_name: [{struct_name: sType_enum_value}, ...]}\n"""
+    content += "# --- Vulkan Feature to Struct Mappings ---\n"
+    content += feature_comment + "\n"
+    feature_map_str = pprint.pformat(feature_map, indent=2, width=100)
+    content += f"""VULKAN_VERSIONS_AND_STRUCTS_MAPPING = {feature_map_str}\n\n"""
+    return content
+
+
+def write_initial_content(vk_py_file_handle: IO[str]):
+    copyright_header = (
+        gencom.copyright_and_warning(datetime.now().year).replace("*/", "").replace("/*", "").replace("*", "#").replace("// WARNING: This file is generated. See ../README.md for instructions.", "").strip()
+    )
+    write_py_file(vk_py_file_handle, copyright_header)
+    write_py_file(vk_py_file_handle, INIT_CONTENT + INIT_CONSTANTS_CONTENT)
+
+
+def extract_vkformat_enums(xml_root):
+    """
+    Parses an XML root element to find <feature> and <extension> tags,
+    and extracts names from specific <enum extends="VkFormat"> tags within them.
+    """
+    result_map = {}
+    format_offset_mapping = {}
+    # Iterate over <feature> tags
+    for feature_tag in xml_root.findall(f".//{TAG_FEATURE}"):
+        feature_name = feature_tag.get(f"{ATTR_NAME}")
+        if not feature_name:
+            continue  # Skip if feature tag has no name
+
+        enum_names = []
+        for require_tag in feature_tag.findall(f".//{TAG_REQUIRE}"):
+            for enum_tag in require_tag.findall(f'.//enum[@extends="VkFormat"]'):
+                enum_name = enum_tag.get(f"{ATTR_NAME}")
+                ext_number = enum_tag.get("extnumber")
+                ext_offset = enum_tag.get("offset")
+                calculated_extension = 0
+                if not ext_number or not ext_offset:
+                    raise Exception(f"Invalid Extension Found: {enum_name}")
+                else:
+                    calculated_extension = 1000000000 + ((int(ext_number) - 1) * 1000) + int(ext_offset)
+                format_offset_mapping[enum_name] = calculated_extension
+                additional_vk_format_values[enum_name] = str(calculated_extension)
+                if enum_name:
+                    enum_names.append((enum_name, calculated_extension))
+
+        if enum_names:  # Only add if there are relevant enums
+            if feature_name in result_map:
+                result_map[feature_name].extend(enum_names)
+            else:
+                result_map[feature_name] = enum_names
+
+    # Iterate over <extension> tags
+    for extension_tag in xml_root.findall(f".//{TAG_EXTENSION}"):
+        extension_name = extension_tag.get(f"{ATTR_NAME}")
+        supported = extension_tag.get(ATTR_SUPPORTED)  # Usually "vulkan", "disabled", etc.
+        if supported == "disabled":
+            continue
+        ext_number = extension_tag.get("number")
+        calculated_extension = 0
+        if not extension_name:
+            continue  # Skip if extension tag has no name
+
+        enum_names = []
+        for require_tag in extension_tag.findall(f".//{TAG_REQUIRE}"):
+            for enum_tag in require_tag.findall('.//enum[@extends="VkFormat"]'):
+                enum_name = enum_tag.get(f"{ATTR_NAME}")
+                ext_offset = enum_tag.get("offset")
+                ext_alias = enum_tag.get("alias")
+                if not ext_number:
+                    raise Exception(f"Invalid Extension Found: {enum_name}")
+                else:
+                    if not ext_offset:
+                        if format_offset_mapping.get(ext_alias):
+                            calculated_extension = format_offset_mapping[ext_alias]
+                    else:
+                        calculated_extension = 1000000000 + ((int(ext_number) - 1) * 1000) + int(ext_offset)
+
+                if not ext_alias:
+                    additional_vk_format_values[enum_name] = str(calculated_extension)
+
+                if enum_name:
+                    enum_names.append((enum_name, calculated_extension))
+
+        if enum_names:  # Only add if there are relevant enums
+            if extension_name in result_map:
+                result_map[extension_name].extend(enum_names)
+            else:
+                result_map[extension_name] = enum_names
+
+    # Remove duplicates from lists if any were introduced by multiple require tags
+    for key in result_map:
+        result_map[key] = list(set(result_map[key]))
+        result_map[key] = sorted(result_map[key], key=lambda x: x[1])
+
+    return result_map
+
+
+def copy_vulkan_1_0_enums(enums_data, vk_format_map):
+    copy_vulkan_1_0_vkformats = copy.copy(enums_data["VkFormat"])
+    for name, value in copy_vulkan_1_0_vkformats.items():
+        if not vk_format_map.get("VK_VERSION_1_0"):
+            vk_format_map["VK_VERSION_1_0"] = []
+        if int(value) == 0:
+            continue
+        vk_format_map["VK_VERSION_1_0"].append((name, int(value)))
+
+
+# --- CODEGEN EXECUTION ---
+def gen_vk():
+    """
+    Orchestrates parsing of Vulkan XML registry and generation of vk.py.
+
+    Loads vk.xml, then calls a sequence of functions to:
+    1. Filter and identify structs (e.g., disable SC-specific ones).
+    2. Extract mappings: struct-to-sType, feature-to-structs, extension-to-structs.
+    3. Fetch detailed definitions for enums, aliases, structs, and handles.
+    4. Write all parsed and processed data into vk.py, including dataclasses,
+       constants, aliases, and various mapping dictionaries.
+    """
+    # Ensure output directory exists
+    OUTPUT_VK_PY_PATH.parent.mkdir(parents=True, exist_ok=True)
+
+    with open(OUTPUT_VK_PY_PATH, "w", encoding="utf-8") as vk_py_file_handle:
+        write_initial_content(vk_py_file_handle)
+        xml_root = load_xml_registry(VULKAN_XML_FILE_PATH)
+        if xml_root is None:
+            return
+
+        all_struct_type_elements = xml_root.findall(f".//{TAG_TYPE}[@{ATTR_CATEGORY}='{CAT_STRUCT}']")
+        create_disabled_struct_list(all_struct_type_elements)
+        extract_vulkan_sc_features(xml_root)
+        empty_dataclass_names = fetch_struct_handles(xml_root)
+        structs_in_extensions, feature_map_data, extension_map_data = parse_structs_and_extensions(xml_root, all_struct_type_elements)
+        vk_format_map = extract_vkformat_enums(xml_root)
+        enums_data = fetch_enums_with_type_attribute(xml_root)
+        aliases_vk_flags_data = fetch_flags_aliases(xml_root)
+        all_structs_data, struct_alias_data = fetch_all_structs_and_aliases(all_struct_type_elements)
+        copy_vulkan_1_0_enums(enums_data, vk_format_map)
+
+        write_enums(vk_py_file_handle, enums_data)
+        write_constants(xml_root, vk_py_file_handle)
+        write_api_constants(xml_root, vk_py_file_handle)
+        write_aliases(vk_py_file_handle, aliases_vk_flags_data, "# --- VkFlags Type Aliases ---", filter_required_data_members=True)
+        write_empty_dataclasses(empty_dataclass_names, vk_py_file_handle)
+        write_structs(vk_py_file_handle, all_structs_data)
+        write_aliases(vk_py_file_handle, struct_alias_data, "\n# --- Physical Device Struct Aliases ---")
+        write_all_structs(vk_py_file_handle)
+        write_py_file(vk_py_file_handle, generate_vk_py_content(feature_map=feature_map_data, extension_map=extension_map_data))
+        write_extension_independent_structs(structs_in_extensions, vk_py_file_handle)
+        generate_core_struct_mapping(CORE_MAPPING_STRUCT_LIST, vk_py_file_handle)
+        write_list_size_mapping(all_struct_type_elements, vk_py_file_handle)
+        write_py_file(vk_py_file_handle, "\n" + VULKAN_API_1_0_STRUCTS_CONTENT + "\n\n")
+        write_py_file(vk_py_file_handle, "\n" + ADDITIONAL_EXTENSION_INDEPENDENT_STRUCTS_CONTENT + "\n\n")
+        write_structs_extends_mapping(all_struct_type_elements, vk_py_file_handle)
+        enum_traits_content = f"\n# --- Enum Traits Mapping ---\n\nENUM_TRAITS_MAPPING = {pprint.pformat(enum_member_map, indent=2, width=100, sort_dicts=False)}\n\n"
+        write_py_file(vk_py_file_handle, enum_traits_content)
+        vk_formats_content = f"\n# --- VK Format Mapping ---\n\nVK_FORMAT_MAPPING = {pprint.pformat(vk_format_map, indent=2, width=100, sort_dicts=False)}\n\n"
+        write_py_file(vk_py_file_handle, vk_formats_content)
\ No newline at end of file
diff --git a/vulkan/scripts/vkjson_gen_util.py b/vulkan/scripts/vkjson_gen_util.py
new file mode 100644
index 0000000000..3bda25879b
--- /dev/null
+++ b/vulkan/scripts/vkjson_gen_util.py
@@ -0,0 +1,640 @@
+#!/usr/bin/env python3
+#
+# Copyright 2019 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+"""
+This file contains all supporting utility functions for vkjson_generator.py
+"""
+
+import dataclasses
+import re
+import vk as VK
+from typing import get_origin
+
+CONST_PHYSICAL_DEVICE_FEATURE_2 = "VkPhysicalDeviceFeatures2"
+CONST_PHYSICAL_DEVICE_PROPERTIES_2 = "VkPhysicalDeviceProperties2"
+
+COPYRIGHT_WARNINGS = """///////////////////////////////////////////////////////////////////////////////
+//
+// Copyright (c) 2015-2016 The Khronos Group Inc.
+// Copyright (c) 2015-2016 Valve Corporation
+// Copyright (c) 2015-2016 LunarG, Inc.
+// Copyright (c) 2015-2016 Google, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+///////////////////////////////////////////////////////////////////////////////
+"""
+
+VK_FORMAT_RANGE_MAPPING = {}
+
+def get_copyright_warnings():
+    return COPYRIGHT_WARNINGS
+
+
+def get_vkjson_struct_name(extension_name):
+    """Gets the corresponding structure name from a Vulkan extension name.
+    Example: "VK_KHR_shader_float16_int8"  "VkJsonKHRShaderFloat16Int8"
+    """
+    prefix_map = {
+        "VK_KHR": "VkJsonKHR",
+        "VK_EXT": "VkJsonExt",
+        "VK_IMG": "VkJsonIMG",
+        "VK_ANDROID": "VkJsonANDROID",
+        "VK_AMD": "VkJsonAMD",
+        "VK_MESA": "VkJsonMESA",
+        "VK_NV": "VkJsonNV",
+        "VK_QCOM": "VkJsonQCOM",
+        "VK_ARM": "VkJsonARM",
+        "VK_HUAWEI": "VkJsonHUAWEI",
+        "VK_VALVE": "VkJsonVALVE",
+        "VK_MSFT": "VkJsonMSFT",
+        "VK_SEC": "VkJsonSEC",
+        "VK_NVX": "VKJsonNVX",
+    }
+
+    for prefix, replacement in prefix_map.items():
+        if extension_name.startswith(prefix):
+            struct_name = replacement + extension_name[len(prefix) :]
+            break
+    else:
+        struct_name = f"VkJsonExt{extension_name}"
+
+    # Convert underscores to camel case
+    # Example: "VK_KHR_shader_float16_int8"  "VkJsonKHRShaderFloat16Int8"
+    struct_name = re.sub(r"_(.)", lambda m: m.group(1).upper(), struct_name)
+
+    return struct_name
+
+
+def get_vkjson_struct_variable_name(extension_name):
+    """Gets corresponding instance name from a Vulkan extension name.
+    Example: "VK_KHR_shader_float16_int8"  "khr_shader_float16_int8"
+    """
+    prefix_map = {
+        "VK_KHR_": "khr_",
+        "VK_EXT_": "ext_",
+        "VK_IMG_": "img_",
+        "VK_ANDROID_": "android_",
+        "VK_AMD_": "amd_",
+        "VK_MESA_": "mesa_",
+        "VK_NV_": "nv_",
+        "VK_QCOM_": "qcom_",
+        "VK_ARM_": "arm_",
+        "VK_HUAWEI_": "huawei_",
+        "VK_VALVE_": "valve_",
+        "VK_MSFT_": "msft_",
+        "VK_SEC_": "sec_",
+        "VK_NVX_": "nvx_",
+    }
+
+    for prefix, replacement in prefix_map.items():
+        if extension_name.startswith(prefix):
+            # Match: word1_digits_word2 => word1_word2_digits (Example: ext_4444_formats -> ext_formats_4444)
+            return re.sub(r"^([a-zA-Z]+)_(\d+)_([a-zA-Z]+)", r"\1_\3_\2", replacement + extension_name[len(prefix) :])
+    return extension_name.lower()  # Default case if no known prefix matches
+
+
+def normalize_variable_name(name, base_name):
+    # Convert CamelCase to snake_case
+    # Example: "ShaderFloat16Int8Features"  "shader_float16_int8_features"
+
+    # Add underscore around digit+D (e.g., 2D, 3D)
+    base_name = re.sub(r"(\d)(D)", r"_\1\2_", base_name)
+
+    # Add underscore before any uppercase letter that follows a lowercase letter or digit
+    initialString = re.sub(r"(?<=[a-z0-9])([A-Z])", r"_\1", base_name)
+
+    # Add underscore between consecutive uppercase letters followed by a lowercase letter
+    name = re.sub(r"([A-Z]+)([A-Z][a-z])", r"\1_\2", initialString).lower()
+
+    # Replace X_d_  Xd_
+    name = re.sub(r"(\d+)_d_", r"\1d_", name)
+
+    # Replace i_d_ or similar  id_
+    name = re.sub(r"\bi_d_", "id_", name)
+
+    # Replace X_bit_  bitX_
+    name = re.sub(r"(\d+)_bit_", r"bit\1_", name)
+
+    # Replace 9_XX  XX_9
+    if re.match(r"^\d", name):
+        name = re.sub(r"^(\d+)_([a-zA-Z]+)", r"\2_\1", name)
+
+    # Prefix with underscore if starting with digit
+    if re.match(r"^\d", name):
+        name = "_" + name
+    return name
+
+
+def get_struct_name(struct_name):
+    """Gets corresponding instance name
+    Example: "VkPhysicalDeviceShaderFloat16Int8FeaturesKHR"  "shader_float16_int8_features_khr"
+    """
+    # Remove "VkPhysicalDevice" prefix and any of the known suffixes
+    prefixes_suffixes_to_remove = ("VkPhysicalDevice", "KHR", "EXT", "IMG", "ANDROID", "AMD", "MESA", "NV", "QCOM", "ARM", "HUAWEI", "VALVE", "MSFT")
+    base_name = struct_name
+
+    for affix in prefixes_suffixes_to_remove:
+        base_name = base_name.removeprefix(affix).removesuffix(affix)
+    variable_name = ""
+    # Fix special cases
+    variable_name = normalize_variable_name(variable_name, base_name)
+
+    # Add back the correct suffix if it was removed
+    suffix_map = {
+        "KHR": "_khr",
+        "EXT": "_ext",
+        "IMG": "_img",
+        "ANDROID": "_android",
+        "AMD": "_amd",
+        "NV": "_nv",
+        "MESA": "_mesa",
+        "VALVE": "_valve",
+        "MSFT": "_msft",
+        "QCOM": "_qcom",
+        "ARM": "_arm",
+        "HUAWEI": "_huawei",
+    }
+    for suffix, replacement in suffix_map.items():
+        if struct_name.endswith(suffix):
+            variable_name += replacement
+            break
+
+    # Handle specific exceptions
+    special_cases = {"memory_properties": "memory", "ycbcr2_plane444_formats_features_ext": "ycbcr_2plane_444_formats_features_ext"}
+
+    return special_cases.get(variable_name, variable_name)
+
+
+def generate_extension_struct_definition(f):
+    """Generates struct definition code for extension based structs
+    Example:
+    struct VkJsonKHRShaderFloatControls {
+      VkJsonKHRShaderFloatControls() {
+        reported = false;
+        memset(&float_controls_properties_khr, 0,
+              sizeof(VkPhysicalDeviceFloatControlsPropertiesKHR));
+      }
+      bool reported;
+      VkPhysicalDeviceFloatControlsPropertiesKHR float_controls_properties_khr;
+    };
+    """
+    vkjson_entries = []
+
+    for extension_name, struct_list in VK.VULKAN_EXTENSIONS_AND_STRUCTS_MAPPING["extensions"].items():
+        vkjson_struct_name = get_vkjson_struct_name(extension_name)
+        vkjson_struct_variable_name = get_vkjson_struct_variable_name(extension_name)
+        vkjson_entries.append(f"{vkjson_struct_name} {vkjson_struct_variable_name}")
+
+        struct_entries = []
+
+        f.write(f"struct {vkjson_struct_name} {{\n")
+        f.write(f"  {vkjson_struct_name}() {{\n")
+        f.write("    reported = false;\n")
+
+        for struct_map in struct_list:
+            for struct_name, _ in struct_map.items():
+                variable_name = get_struct_name(struct_name)
+                f.write(f"    memset(&{variable_name}, 0, sizeof({struct_name}));\n")
+                struct_entries.append(f"{struct_name} {variable_name}")
+
+        f.write("  }\n")  # End of constructor
+        f.write("  bool reported;\n")
+        for entry in struct_entries:
+            f.write(f"  {entry};\n")
+
+        f.write("};\n\n")  # End of struct
+
+    return vkjson_entries
+
+
+def generate_vk_core_struct_definition(f):
+    """Generates struct definition code for vulkan cores
+    Example:
+    struct VkJsonCore11 {
+      VkPhysicalDeviceVulkan11Properties properties;
+      VkPhysicalDeviceVulkan11Features features;
+    };
+    """
+    vkjson_core_entries = []
+
+    for version, items in VK.VULKAN_CORES_AND_STRUCTS_MAPPING["versions"].items():
+        struct_name = f"VkJson{version}"
+        vkjson_core_entries.append(f"{struct_name} {version.lower()}")
+
+        f.write(f"struct {struct_name} {{\n")
+        f.write(f"  {struct_name}() {{\n")  # Start of constructor
+        for item in items:
+            for struct_type, _ in item.items():
+                field_name = "properties" if "Properties" in struct_type else "features"
+                f.write(f" memset(&{field_name}, 0, sizeof({struct_type}));\n")
+        f.write("  }\n")  # End of constructor
+
+        for item in items:
+            for struct_type, _ in item.items():
+                field_name = "properties" if "Properties" in struct_type else "features"
+                f.write(f"  {struct_type} {field_name};\n")
+        if version == "Core14":
+            f.write(f"std::vector<VkImageLayout> copy_src_layouts;\n")
+            f.write(f"std::vector<VkImageLayout> copy_dst_layouts;\n")
+
+        f.write("};\n\n")
+
+    return vkjson_core_entries
+
+
+def generate_memset_statements(f):
+    """Generates memset statements for all independent Vulkan structs and core Vulkan versions.
+    This initializes struct instances to zero before use.
+
+    Example:
+      memset(&properties, 0, sizeof(VkPhysicalDeviceProperties));
+      VkPhysicalDeviceProperties properties;
+    """
+    entries = []
+    processed_entries = set()
+    all_extension_independent_structs = VK.EXTENSION_INDEPENDENT_STRUCTS + VK.ADDITIONAL_EXTENSION_INDEPENDENT_STRUCTS
+    # Process independent structs
+    for dataclass_type in all_extension_independent_structs:
+        class_name = dataclass_type
+        variable_name = get_struct_name(class_name)
+        # EDIT: updated as we are now taking the dataclass_type as 'string'
+        key_str = f"{variable_name}@{class_name}"
+        if key_str in processed_entries:
+            continue
+        f.write(f"memset(&{variable_name}, 0, sizeof({class_name}));\n")
+        processed_entries.add(key_str)
+        entries.append(f"{class_name} {variable_name}")
+
+    return entries
+
+
+def generate_extension_struct_template():
+    """Generates templates for extensions
+    Example:
+      template <typename Visitor>
+      inline bool Iterate(Visitor* visitor, VkJsonKHRVariablePointers* structs) {
+        return visitor->Visit("variablePointerFeaturesKHR",
+                              &structs->variable_pointer_features_khr) &&
+              visitor->Visit("variablePointersFeaturesKHR",
+                              &structs->variable_pointers_features_khr);
+      }
+    """
+    template_code = []
+
+    for extension, struct_mappings in VK.VULKAN_EXTENSIONS_AND_STRUCTS_MAPPING["extensions"].items():
+        struct_type = get_vkjson_struct_name(extension)
+
+        template_code.append(f"template <typename Visitor>")
+        template_code.append(f"inline bool Iterate(Visitor* visitor, {struct_type}* structs) {{")
+        template_code.append("  return ")
+
+        visitor_calls = []
+        for struct_map in struct_mappings:
+            for struct_name in struct_map:
+                json_field_name = struct_name.replace("VkPhysicalDevice", "")
+                json_field_name = json_field_name[0].lower() + json_field_name[1:]
+
+                # Move the leading digits after the first capitalized word
+                json_field_name = re.sub(r"^(\d+)([A-Z][a-z]*)", r"\2\1", json_field_name)
+                # Lowercase the first character
+                json_field_name = json_field_name[0].lower() + json_field_name[1:] if json_field_name else json_field_name
+
+                visitor_calls.append(f'visitor->Visit("{json_field_name}", &structs->{get_struct_name(struct_name)})')
+
+        template_code.append(" &&\n         ".join(visitor_calls) + ";")
+        template_code.append("}\n")
+
+    return "\n".join(template_code)
+
+
+def generate_core_template():
+    """Generates templates for vulkan cores.
+    template <typename Visitor>
+    inline bool Iterate(Visitor* visitor, VkJsonCore11* core) {
+      return visitor->Visit("properties", &core->properties) &&
+            visitor->Visit("features", &core->features);
+    }
+    """
+    template_code = []
+
+    for version, struct_list in VK.VULKAN_CORES_AND_STRUCTS_MAPPING["versions"].items():
+        struct_type = f"VkJson{version}"
+
+        template_code.append(f"template <typename Visitor>")
+        template_code.append(f"inline bool Iterate(Visitor* visitor, {struct_type}* core) {{")
+        template_code.append("  return")
+
+        visitor_calls = []
+        for struct_map in struct_list:
+            for struct_name in struct_map:
+                member_name = "properties" if "Properties" in struct_name else "features"
+                visitor_calls.append(f'visitor->Visit("{member_name}", &core->{member_name})')
+
+        template_code.append(" &&\n         ".join(visitor_calls) + ";")
+        template_code.append("}\n")
+
+    return "\n".join(template_code)
+
+
+def generate_struct_template(data_classes):
+    """Generates templates for all the structs
+    template <typename Visitor>
+    inline bool Iterate(Visitor* visitor,
+                        VkPhysicalDevicePointClippingProperties* properties) {
+      return visitor->Visit("pointClippingBehavior",
+                            &properties->pointClippingBehavior);
+    }
+    """
+    template_code = []
+    processed_classes = set()  # Track processed class names
+
+    for dataclass_type in data_classes:
+        struct_name = dataclass_type.__name__
+
+        if struct_name in processed_classes:
+            continue  # Skip already processed struct
+        processed_classes.add(struct_name)
+
+        struct_fields = dataclasses.fields(dataclass_type)
+
+        # Determine the correct variable name based on the struct type
+        struct_var = "properties" if "Properties" in struct_name else "features" if "Features" in struct_name else "limits" if "Limits" in struct_name else None
+
+        if not struct_var:
+            continue  # Skip structs that don't match expected patterns
+
+        template_code.append("template <typename Visitor>")
+        template_code.append(f"inline bool Iterate(Visitor* visitor, {struct_name}* {struct_var}) {{")
+        template_code.append(f"return\n")
+
+        visitor_calls = []
+        for struct_field in struct_fields:
+            field_name = struct_field.name
+            field_type = struct_field.type
+
+            if get_origin(field_type) is list:
+                # Handle list types (VisitArray)
+                size_field_name = VK.LIST_TYPE_FIELD_AND_SIZE_MAPPING[field_name]
+                visitor_calls.append(f'visitor->VisitArray("{field_name}", {struct_var}->{size_field_name}, &{struct_var}->{field_name})')
+            else:
+                # Handle other types (Visit)
+                visitor_calls.append(f'visitor->Visit("{field_name}", &{struct_var}->{field_name})')
+
+        template_code.append(" &&\n         ".join(visitor_calls) + ";")
+        template_code.append("}\n\n")
+
+    return "\n".join(template_code)
+
+
+def emit_struct_visits_by_vk_version(f, version):
+    """Emits visitor calls for Vulkan version structs"""
+    for struct_map in VK.VULKAN_VERSIONS_AND_STRUCTS_MAPPING[version]:
+        for struct_name, _ in struct_map.items():
+            struct_var = get_struct_name(struct_name)
+            # Converts struct_var from snake_case (e.g., point_clipping_properties)
+            # to camelCase (e.g., pointClippingProperties) for struct_display_name.
+            struct_display_name = re.sub(r"_([a-z])", lambda match: match.group(1).upper(), struct_var)
+            f.write(f'visitor->Visit("{struct_display_name}", &device->{struct_var}) &&\n')
+
+
+def generate_enum_traits():
+    """Writes necessary enum definitions as Python Enum classes and generates C++ traits string."""
+    cpp_enum_traits_content = ""
+    # Iterate through all parsed enum types
+    for enum_name, members in VK.ENUM_TRAITS_MAPPING.items():
+        cpp_enum_traits_content += "\n"
+        # --- C++ EnumTraits generation (skip for these enums as they are differently defined in xml) ---
+        if enum_name == "VkImageLayout":
+            continue
+        cpp_enum_traits_content += f"template <>\nstruct EnumTraits<{enum_name}> {{\n"
+        cpp_enum_traits_content += f"  static bool exist(uint32_t e) {{\n"
+        cpp_enum_traits_content += f"    switch (e) {{\n"
+        if members:
+            for member, value in members.items():
+                if value is not None and member:
+                    cpp_enum_traits_content += f"      case {member}:\n"
+        cpp_enum_traits_content += f"        return true;\n"
+        cpp_enum_traits_content += f"    }}\n"
+        cpp_enum_traits_content += f"    return false;\n"
+        cpp_enum_traits_content += f"  }}\n"
+        cpp_enum_traits_content += f"}};\n\n"
+
+    return cpp_enum_traits_content
+
+
+def generate_vk_core_structs_init_code(version):
+    """Generates code to initialize properties and features
+    for structs based on its vulkan API version dependency.
+    """
+    properties_code, features_code = [], []
+
+    for item in VK.VULKAN_CORES_AND_STRUCTS_MAPPING["versions"].get(version, []):
+        for struct_name, struct_type in item.items():
+            version_lower = version.lower()
+            target_code_list = None
+            struct_field_name = None
+            mapping_name = VK.STRUCT_EXTENDS_MAPPING.get(struct_name)
+            if mapping_name and CONST_PHYSICAL_DEVICE_FEATURE_2 in mapping_name:
+                target_code_list = features_code
+                struct_field_name = "features"
+            elif mapping_name and CONST_PHYSICAL_DEVICE_PROPERTIES_2 in mapping_name:
+                target_code_list = properties_code
+                struct_field_name = "properties"
+            else:
+                # TODO: b/415707715 (Add tests for exceptions for structs not extending (VkPhysicalDeviceProperties2/VkPhysicalDeviceFeatures2))
+                raise Exception(f"Warning: Unknown Mapping: ' " f"for struct '{struct_name}'")
+
+            if target_code_list is not None:
+                target_code_list.extend(
+                    [
+                        f"device.{version_lower}.{struct_field_name}.sType = {struct_type};",
+                        f"device.{version_lower}.{struct_field_name}.pNext = {struct_field_name}.pNext;",
+                        f"{struct_field_name}.pNext = &device.{version_lower}.{struct_field_name};\n\n",
+                    ]
+                )
+
+    return "\n".join(properties_code), "\n".join(features_code)
+
+
+def generate_vk_extension_structs_init_code(mapping, struct_category):
+    """Generates Vulkan struct initialization code for given struct category (Properties/Features)
+    based on its extension dependency.
+    """
+    generated_code = []
+    next_pointer = struct_category.lower()
+
+    for extension, struct_mappings in mapping.items():
+        struct_var_name = get_vkjson_struct_variable_name(extension)
+        extension_code = [f'  if (HasExtension("{extension}", device.extensions)) {{', f"    device.{struct_var_name}.reported = true;"]
+        struct_count = 0
+        for struct_mapping in struct_mappings:
+            for struct_name, struct_type in struct_mapping.items():
+                # EDIT: Category detection improved using structextends mapping (VK.STRUCT_EXTENDS_MAPPING).
+                # Correctly handles structs with ambiguous names (e.g., VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR)
+                # that might contain 'Properties'/'Features' in name but extend only one (Features2/Properties2).
+                mapping_name = VK.STRUCT_EXTENDS_MAPPING.get(struct_name)
+                is_valid_struct_category = False
+                if mapping_name:
+                    is_valid_struct_category = (CONST_PHYSICAL_DEVICE_PROPERTIES_2 in mapping_name and struct_category == "Properties") or (
+                        CONST_PHYSICAL_DEVICE_FEATURE_2 in mapping_name and struct_category == "Features"
+                    )
+                elif struct_category.lower() in struct_name.lower():
+                    raise Exception(f"Warning: Unknown Mapping: ' " f"for struct '{struct_name}'")
+
+                if is_valid_struct_category:
+                    struct_count += 1
+                    struct_instance = get_struct_name(struct_name)
+                    extension_code.extend(
+                        [
+                            f"    device.{struct_var_name}.{struct_instance}.sType = {struct_type};",
+                            f"    device.{struct_var_name}.{struct_instance}.pNext = {next_pointer}.pNext;",
+                            f"    {next_pointer}.pNext = &device.{struct_var_name}.{struct_instance};",
+                        ]
+                    )
+
+        extension_code.append("  }\n")
+
+        if struct_count > 0:
+            generated_code.extend(extension_code)
+
+    return "\n".join(generated_code)
+
+
+def generate_vk_version_structs_initialization(version_data, struct_type_keyword):
+    """Generates Vulkan struct initialization code for given struct category (Properties/Features)
+    of vulkan api version s.
+    """
+    struct_initialization_code = []
+    next_pointer = struct_type_keyword.lower()
+
+    for struct_mapping in version_data:
+        for struct_name, struct_type in struct_mapping.items():
+            if struct_type_keyword in struct_name:
+                struct_variable = get_struct_name(struct_name)
+                struct_initialization_code.extend(
+                    [f"device.{struct_variable}.sType = {struct_type};", f"device.{struct_variable}.pNext = {next_pointer}.pNext;", f"{next_pointer}.pNext = &device.{struct_variable};\n"]
+                )
+
+    return "\n".join(struct_initialization_code)
+
+
+def find_contiguous_ranges(format_data):
+  """Finds contiguous ranges of format values from a list of enums for a given extension or Vulkan API version.
+    For example, for the format data for the below extension:
+        "VK_EXT_ycbcr_2plane_444_formats": [
+            ("VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT", 1000330000),
+            ("VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT", 1000330001),
+            ("VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT", 1000330002),
+            ("VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT", 1000330003),
+        ]
+
+    The range of formats is:
+    [(VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT,VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT)]
+    """
+  sorted_data = sorted(format_data, key=lambda x: x[1])
+  contiguous_ranges = []
+  start_name, start_val = sorted_data[0]
+  prev_name, prev_val = start_name, start_val
+  for name, val in sorted_data[1:]:
+    if val != prev_val + 1:
+      # Range break
+      contiguous_ranges.append((start_name, prev_name))
+      start_name = name
+    prev_name, prev_val = name, val
+
+  # Append the final range
+  contiguous_ranges.append((start_name, prev_name))
+  return contiguous_ranges
+
+
+def generate_format_range_map():
+  """Returns a map from Vulkan API versions and extensions to their contiguous ranges of format enums.
+
+    For example, for 'VK_VERSION_1_3', the map contains:
+    'VK_VERSION_1_3': [
+        ('VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK', 'VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK'),
+        ('VK_FORMAT_G8_B8R8_2PLANE_444_UNORM', 'VK_FORMAT_G16_B16R16_2PLANE_444_UNORM'),
+        ('VK_FORMAT_A4R4G4B4_UNORM_PACK16', 'VK_FORMAT_A4B4G4R4_UNORM_PACK16')
+    ]
+    """
+  for key, format_data in VK.VK_FORMAT_MAPPING.items():
+    VK_FORMAT_RANGE_MAPPING[key] = find_contiguous_ranges(format_data)
+
+
+def generate_vk_format_init_code(vk_version_api: str = None):
+    """
+    Generates C++ code to initialize Vulkan format enums based on either a Vulkan API version
+    or an extension name.
+
+    If `vk_version_api` is None, the function processes all extensions in `VK_FORMAT_RANGE_MAPPING`.
+    Otherwise, it generates code for the specified Vulkan version.
+
+    Example output for an extension:
+        if (HasExtension("VK_EXT_texture_compression_astc_hdr", device.extensions)) {
+          ...
+        }
+    """
+    generated_code = []
+
+    def generate_format_block(start_format: str, end_format: str):
+        if start_format != end_format:
+            return [
+                f"  for (VkFormat format = {start_format};",
+                f"       format <= {end_format};",
+                f"       format = static_cast<VkFormat>(format + 1)) {{",
+                f"    vkGetPhysicalDeviceFormatProperties(physical_device, format,",
+                f"                                       &format_properties);",
+                f"    device.formats.insert(std::make_pair(format, format_properties));",
+                f"  }}"
+            ]
+        else:
+            return [
+                f"  VkFormat format = {start_format};",
+                f"  vkGetPhysicalDeviceFormatProperties(physical_device, format,",
+                f"                                       &format_properties);",
+                f"  device.formats.insert(std::make_pair(format, format_properties));"
+            ]
+
+    if not vk_version_api:
+        # Process all extensions
+        for key, format_ranges in VK_FORMAT_RANGE_MAPPING.items():
+            if key.startswith("VK_VERSION_"):
+                continue
+            for start_format, end_format in format_ranges:
+                format_code = [f'if (HasExtension("{key}", device.extensions)) {{']
+                format_code.extend(generate_format_block(start_format, end_format))
+                format_code.append("}\n")
+                generated_code.extend(format_code)
+    else:
+        # Process a specific Vulkan version
+        if vk_version_api not in VK_FORMAT_RANGE_MAPPING:
+            return ""
+        for start_format, end_format in VK_FORMAT_RANGE_MAPPING[vk_version_api]:
+            format_code = generate_format_block(start_format, end_format)
+            format_code.append("")  # Add newline after each block
+            generated_code.extend(format_code)
+
+    return "\n".join(generated_code + [""])
\ No newline at end of file
diff --git a/vulkan/scripts/vkjson_generator.py b/vulkan/scripts/vkjson_generator.py
index 6f621a1542..911e9ac41b 100644
--- a/vulkan/scripts/vkjson_generator.py
+++ b/vulkan/scripts/vkjson_generator.py
@@ -16,214 +16,15 @@
 
 """Generates the vkjson files.
 """
-import dataclasses
 import os
-import re
-from typing import get_origin
 
 import generator_common as gencom
+import vkjson_gen_util as util
 import vk as VK
+import importlib
 
-dataclass_field = dataclasses.field
-
-
-COPYRIGHT_WARNINGS = """///////////////////////////////////////////////////////////////////////////////
-//
-// Copyright (c) 2015-2016 The Khronos Group Inc.
-// Copyright (c) 2015-2016 Valve Corporation
-// Copyright (c) 2015-2016 LunarG, Inc.
-// Copyright (c) 2015-2016 Google, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-///////////////////////////////////////////////////////////////////////////////
-"""
-
-
-def get_copyright_warnings():
-  return COPYRIGHT_WARNINGS
-
-
-def get_vkjson_struct_name(extension_name):
-  """Gets the corresponding structure name from a Vulkan extension name.
-  Example: "VK_KHR_shader_float16_int8"  "VkJsonKHRShaderFloat16Int8"
-  """
-  prefix_map = {
-    "VK_KHR": "VkJsonKHR",
-    "VK_EXT": "VkJsonExt",
-    "VK_IMG": "VkJsonIMG"
-  }
-
-  for prefix, replacement in prefix_map.items():
-    if extension_name.startswith(prefix):
-      struct_name = replacement + extension_name[len(prefix):]
-      break
-  else:
-    struct_name = f"VkJsonExt{extension_name}"
-
-  # Convert underscores to camel case
-  # Example: "VK_KHR_shader_float16_int8"  "VkJsonKHRShaderFloat16Int8"
-  struct_name = re.sub(r"_(.)", lambda m: m.group(1).upper(), struct_name)
-
-  return struct_name
-
-
-def get_vkjson_struct_variable_name(extension_name):
-  """Gets corresponding instance name from a Vulkan extension name.
-  Example: "VK_KHR_shader_float16_int8"  "khr_shader_float16_int8"
-  """
-  prefix_map = {
-    "VK_KHR_": "khr_",
-    "VK_EXT_": "ext_",
-    "VK_IMG_": "img_"
-  }
-
-  for prefix, replacement in prefix_map.items():
-    if extension_name.startswith(prefix):
-      return replacement + extension_name[len(prefix):]
-
-  return extension_name.lower()  # Default case if no known prefix matches
-
-
-def get_struct_name(struct_name):
-  """Gets corresponding instance name
-  Example: "VkPhysicalDeviceShaderFloat16Int8FeaturesKHR"  "shader_float16_int8_features_khr"
-  """
-  # Remove "VkPhysicalDevice" prefix and any of the known suffixes
-  base_name = struct_name.removeprefix("VkPhysicalDevice").removesuffix("KHR").removesuffix("EXT").removesuffix("IMG")
-
-  # Convert CamelCase to snake_case
-  # Example: "ShaderFloat16Int8Features"  "shader_float16_int8_features"
-  variable_name = re.sub(r"(?<!^)(?=[A-Z])", "_", base_name).lower()
-
-  # Fix special cases
-  variable_name = variable_name.replace("2_d_", "_2d_").replace("3_d_", "_3d_")
-
-  # Add back the correct suffix if it was removed
-  suffix_map = {"KHR": "_khr", "EXT": "_ext", "IMG": "_img"}
-  for suffix, replacement in suffix_map.items():
-    if struct_name.endswith(suffix):
-      variable_name += replacement
-      break
-
-  # Handle specific exceptions
-  special_cases = {
-    "8_bit_storage_features_khr": "bit8_storage_features_khr",
-    "memory_properties": "memory",
-    "16_bit_storage_features": "bit16_storage_features",
-    "i_d_properties": "id_properties"
-  }
-
-  return special_cases.get(variable_name, variable_name)
-
-
-def generate_extension_struct_definition(f):
-  """Generates struct definition code for extension based structs
-  Example:
-  struct VkJsonKHRShaderFloatControls {
-    VkJsonKHRShaderFloatControls() {
-      reported = false;
-      memset(&float_controls_properties_khr, 0,
-            sizeof(VkPhysicalDeviceFloatControlsPropertiesKHR));
-    }
-    bool reported;
-    VkPhysicalDeviceFloatControlsPropertiesKHR float_controls_properties_khr;
-  };
-  """
-  vkJson_entries = []
-
-  for extension_name, struct_list in VK.VULKAN_EXTENSIONS_AND_STRUCTS_MAPPING["extensions"].items():
-    vkjson_struct_name = get_vkjson_struct_name(extension_name)
-    vkjson_struct_variable_name = get_vkjson_struct_variable_name(extension_name)
-    vkJson_entries.append(f"{vkjson_struct_name} {vkjson_struct_variable_name}")
-
-    struct_entries = []
-
-    f.write(f"struct {vkjson_struct_name} {{\n")
-    f.write(f"  {vkjson_struct_name}() {{\n")
-    f.write("    reported = false;\n")
-
-    for struct_map in struct_list:
-      for struct_name, _ in struct_map.items():
-        variable_name = get_struct_name(struct_name)
-        f.write(f"    memset(&{variable_name}, 0, sizeof({struct_name}));\n")
-        struct_entries.append(f"{struct_name} {variable_name}")
-
-    f.write("  }\n")  # End of constructor
-    f.write("  bool reported;\n")
-
-    for entry in struct_entries:
-      f.write(f"  {entry};\n")
-
-    f.write("};\n\n")  # End of struct
-
-  return vkJson_entries
-
-
-def generate_vk_core_struct_definition(f):
-  """Generates struct definition code for vulkan cores
-  Example:
-  struct VkJsonCore11 {
-    VkPhysicalDeviceVulkan11Properties properties;
-    VkPhysicalDeviceVulkan11Features features;
-  };
-  """
-  vkJson_core_entries = []
-
-  for version, items in VK.VULKAN_CORES_AND_STRUCTS_MAPPING["versions"].items():
-    struct_name = f"VkJson{version}"
-    vkJson_core_entries.append(f"{struct_name} {version.lower()}")
-
-    f.write(f"struct {struct_name} {{\n")
-    f.write(f"  {struct_name}() {{\n") # Start of constructor
-    for item in items:
-      for struct_type, _ in item.items():
-        field_name = "properties" if "Properties" in struct_type else "features"
-        f.write(f" memset(&{field_name}, 0, sizeof({struct_type}));\n")
-    f.write("  }\n")  # End of constructor
-
-    for item in items:
-      for struct_type, _ in item.items():
-        field_name = "properties" if "Properties" in struct_type else "features"
-        f.write(f"  {struct_type} {field_name};\n")
-
-    if version == "Core14":
-      f.write(f"std::vector<VkImageLayout> copy_src_layouts;\n")
-      f.write(f"std::vector<VkImageLayout> copy_dst_layouts;\n")
-
-    f.write("};\n\n")
-
-  return vkJson_core_entries
-
-
-def generate_memset_statements(f):
-  """Generates memset statements for all independent Vulkan structs and core Vulkan versions.
-  This initializes struct instances to zero before use.
-
-  Example:
-    memset(&properties, 0, sizeof(VkPhysicalDeviceProperties));
-    VkPhysicalDeviceProperties properties;
-  """
-  entries = []
-
-  # Process independent structs
-  for dataclass_type in VK.EXTENSION_INDEPENDENT_STRUCTS:
-    class_name = dataclass_type.__name__
-    variable_name = get_struct_name(class_name)
-    f.write(f"memset(&{variable_name}, 0, sizeof({class_name}));\n")
-    entries.append(f"{class_name} {variable_name}")
-
-  return entries
-
+def re_import_vk():
+  importlib.reload(VK)
 
 def gen_h():
   """Generates vkjson.h file.
@@ -232,12 +33,16 @@ def gen_h():
                          "..", "vkjson", "vkjson.h")
 
   with open(genfile, "w") as f:
-    f.write(f'{get_copyright_warnings()}\n')
+    f.write(f'{util.get_copyright_warnings()}\n')
 
     f.write("""\
 #ifndef VKJSON_H_
 #define VKJSON_H_
 
+#ifndef VK_USE_PLATFORM_ANDROID_KHR
+#define VK_USE_PLATFORM_ANDROID_KHR
+#endif
+
 #include <string.h>
 #include <vulkan/vulkan.h>
 
@@ -260,14 +65,14 @@ struct VkJsonLayer {
 
 \n""")
 
-    vkjson_extension_structs = generate_extension_struct_definition(f)
-    vkjson_core_structs = generate_vk_core_struct_definition(f)
+    vkjson_extension_structs = util.generate_extension_struct_definition(f)
+    vkjson_core_structs = util.generate_vk_core_struct_definition(f)
 
     f.write("""\
 struct VkJsonDevice {
   VkJsonDevice() {""")
 
-    feature_property_structs = generate_memset_statements(f)
+    feature_property_structs = util.generate_memset_statements(f)
 
     f.write("""\
   }\n""")
@@ -343,137 +148,6 @@ inline bool VkJsonAllPropertiesFromJson(const std::string& json,
   gencom.run_clang_format(genfile)
 
 
-def generate_extension_struct_template():
-  """Generates templates for extensions
-  Example:
-    template <typename Visitor>
-    inline bool Iterate(Visitor* visitor, VkJsonKHRVariablePointers* structs) {
-      return visitor->Visit("variablePointerFeaturesKHR",
-                            &structs->variable_pointer_features_khr) &&
-            visitor->Visit("variablePointersFeaturesKHR",
-                            &structs->variable_pointers_features_khr);
-    }
-  """
-  template_code = []
-
-  for extension, struct_mappings in VK.VULKAN_EXTENSIONS_AND_STRUCTS_MAPPING["extensions"].items():
-    struct_type = get_vkjson_struct_name(extension)
-
-    template_code.append(f"template <typename Visitor>")
-    template_code.append(f"inline bool Iterate(Visitor* visitor, {struct_type}* structs) {{")
-    template_code.append("  return ")
-
-    visitor_calls = []
-    for struct_map in struct_mappings:
-      for struct_name in struct_map:
-        json_field_name = struct_name.replace("VkPhysicalDevice", "")
-        json_field_name = json_field_name[0].lower() + json_field_name[1:]
-
-        # Special case renaming
-        if json_field_name == "8BitStorageFeaturesKHR":
-          json_field_name = "bit8StorageFeaturesKHR"
-
-        visitor_calls.append(
-            f'visitor->Visit("{json_field_name}", &structs->{get_struct_name(struct_name)})'
-        )
-
-    template_code.append(" &&\n         ".join(visitor_calls) + ";")
-    template_code.append("}\n")
-
-  return "\n".join(template_code)
-
-
-def generate_core_template():
-  """Generates templates for vulkan cores.
-  template <typename Visitor>
-  inline bool Iterate(Visitor* visitor, VkJsonCore11* core) {
-    return visitor->Visit("properties", &core->properties) &&
-          visitor->Visit("features", &core->features);
-  }
-  """
-  template_code = []
-
-  for version, struct_list in VK.VULKAN_CORES_AND_STRUCTS_MAPPING["versions"].items():
-    struct_type = f"VkJson{version}"
-
-    template_code.append(f"template <typename Visitor>")
-    template_code.append(f"inline bool Iterate(Visitor* visitor, {struct_type}* core) {{")
-    template_code.append("  return")
-
-    visitor_calls = []
-    for struct_map in struct_list:
-      for struct_name in struct_map:
-        member_name = "properties" if "Properties" in struct_name else "features"
-        visitor_calls.append(f'visitor->Visit("{member_name}", &core->{member_name})')
-
-    template_code.append(" &&\n         ".join(visitor_calls) + ";")
-    template_code.append("}\n")
-
-  return "\n".join(template_code)
-
-
-def generate_struct_template(data_classes):
-  """Generates templates for all the structs
-  template <typename Visitor>
-  inline bool Iterate(Visitor* visitor,
-                      VkPhysicalDevicePointClippingProperties* properties) {
-    return visitor->Visit("pointClippingBehavior",
-                          &properties->pointClippingBehavior);
-  }
-  """
-  template_code = []
-  processed_classes = set()  # Track processed class names
-
-  for dataclass_type in data_classes:
-    struct_name = dataclass_type.__name__
-
-    if struct_name in processed_classes:
-      continue  # Skip already processed struct
-    processed_classes.add(struct_name)
-
-    struct_fields = dataclasses.fields(dataclass_type)
-    template_code.append("template <typename Visitor>")
-
-    # Determine the correct variable name based on the struct type
-    struct_var = "properties" if "Properties" in struct_name else "features" if "Features" in struct_name else "limits" if "Limits" in struct_name else None
-
-    if not struct_var:
-      continue  # Skip structs that don't match expected patterns
-
-    template_code.append(f"inline bool Iterate(Visitor* visitor, {struct_name}* {struct_var}) {{")
-    template_code.append(f"return\n")
-
-    visitor_calls = []
-    for struct_field in struct_fields:
-      field_name = struct_field.name
-      field_type = struct_field.type
-
-      if get_origin(field_type) is list:
-        # Handle list types (VisitArray)
-        size_field_name = VK.LIST_TYPE_FIELD_AND_SIZE_MAPPING[field_name]
-        visitor_calls.append(f'visitor->VisitArray("{field_name}", {struct_var}->{size_field_name}, &{struct_var}->{field_name})')
-      else:
-        # Handle other types (Visit)
-        visitor_calls.append(f'visitor->Visit("{field_name}", &{struct_var}->{field_name})')
-
-    template_code.append(" &&\n         ".join(visitor_calls) + ";")
-    template_code.append("}\n\n")
-
-  return "\n".join(template_code)
-
-
-def emit_struct_visits_by_vk_version(f, version):
-  """Emits visitor calls for Vulkan version structs
-  """
-  for struct_map in VK.VULKAN_VERSIONS_AND_STRUCTS_MAPPING[version]:
-    for struct_name, _ in struct_map.items():
-      struct_var = get_struct_name(struct_name)
-      # Converts struct_var from snake_case (e.g., point_clipping_properties)
-      # to camelCase (e.g., pointClippingProperties) for struct_display_name.
-      struct_display_name = re.sub(r"_([a-z])", lambda match: match.group(1).upper(), struct_var)
-      f.write(f'visitor->Visit("{struct_display_name}", &device->{struct_var}) &&\n')
-
-
 def gen_cc():
   """Generates vkjson.cc file.
   """
@@ -482,7 +156,7 @@ def gen_cc():
 
   with open(genfile, "w") as f:
 
-    f.write(get_copyright_warnings())
+    f.write(util.get_copyright_warnings())
     f.write("\n")
 
     f.write("""\
@@ -533,377 +207,6 @@ static const double SAFE_DOUBLE_MAX = 0.99 * std::numeric_limits<double>::max();
 static const double SAFE_DOUBLE_MIN = -SAFE_DOUBLE_MAX;
 
 template <typename T> struct EnumTraits;
-template <> struct EnumTraits<VkPhysicalDeviceType> {
-  static bool exist(uint32_t e) {
-    switch (e) {
-      case VK_PHYSICAL_DEVICE_TYPE_OTHER:
-      case VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU:
-      case VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU:
-      case VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU:
-      case VK_PHYSICAL_DEVICE_TYPE_CPU:
-        return true;
-    }
-    return false;
-  }
-};
-
-template <> struct EnumTraits<VkFormat> {
-  static bool exist(uint32_t e) {
-    switch (e) {
-      case VK_FORMAT_UNDEFINED:
-      case VK_FORMAT_R4G4_UNORM_PACK8:
-      case VK_FORMAT_R4G4B4A4_UNORM_PACK16:
-      case VK_FORMAT_B4G4R4A4_UNORM_PACK16:
-      case VK_FORMAT_R5G6B5_UNORM_PACK16:
-      case VK_FORMAT_B5G6R5_UNORM_PACK16:
-      case VK_FORMAT_R5G5B5A1_UNORM_PACK16:
-      case VK_FORMAT_B5G5R5A1_UNORM_PACK16:
-      case VK_FORMAT_A1R5G5B5_UNORM_PACK16:
-      case VK_FORMAT_R8_UNORM:
-      case VK_FORMAT_R8_SNORM:
-      case VK_FORMAT_R8_USCALED:
-      case VK_FORMAT_R8_SSCALED:
-      case VK_FORMAT_R8_UINT:
-      case VK_FORMAT_R8_SINT:
-      case VK_FORMAT_R8_SRGB:
-      case VK_FORMAT_R8G8_UNORM:
-      case VK_FORMAT_R8G8_SNORM:
-      case VK_FORMAT_R8G8_USCALED:
-      case VK_FORMAT_R8G8_SSCALED:
-      case VK_FORMAT_R8G8_UINT:
-      case VK_FORMAT_R8G8_SINT:
-      case VK_FORMAT_R8G8_SRGB:
-      case VK_FORMAT_R8G8B8_UNORM:
-      case VK_FORMAT_R8G8B8_SNORM:
-      case VK_FORMAT_R8G8B8_USCALED:
-      case VK_FORMAT_R8G8B8_SSCALED:
-      case VK_FORMAT_R8G8B8_UINT:
-      case VK_FORMAT_R8G8B8_SINT:
-      case VK_FORMAT_R8G8B8_SRGB:
-      case VK_FORMAT_B8G8R8_UNORM:
-      case VK_FORMAT_B8G8R8_SNORM:
-      case VK_FORMAT_B8G8R8_USCALED:
-      case VK_FORMAT_B8G8R8_SSCALED:
-      case VK_FORMAT_B8G8R8_UINT:
-      case VK_FORMAT_B8G8R8_SINT:
-      case VK_FORMAT_B8G8R8_SRGB:
-      case VK_FORMAT_R8G8B8A8_UNORM:
-      case VK_FORMAT_R8G8B8A8_SNORM:
-      case VK_FORMAT_R8G8B8A8_USCALED:
-      case VK_FORMAT_R8G8B8A8_SSCALED:
-      case VK_FORMAT_R8G8B8A8_UINT:
-      case VK_FORMAT_R8G8B8A8_SINT:
-      case VK_FORMAT_R8G8B8A8_SRGB:
-      case VK_FORMAT_B8G8R8A8_UNORM:
-      case VK_FORMAT_B8G8R8A8_SNORM:
-      case VK_FORMAT_B8G8R8A8_USCALED:
-      case VK_FORMAT_B8G8R8A8_SSCALED:
-      case VK_FORMAT_B8G8R8A8_UINT:
-      case VK_FORMAT_B8G8R8A8_SINT:
-      case VK_FORMAT_B8G8R8A8_SRGB:
-      case VK_FORMAT_A8B8G8R8_UNORM_PACK32:
-      case VK_FORMAT_A8B8G8R8_SNORM_PACK32:
-      case VK_FORMAT_A8B8G8R8_USCALED_PACK32:
-      case VK_FORMAT_A8B8G8R8_SSCALED_PACK32:
-      case VK_FORMAT_A8B8G8R8_UINT_PACK32:
-      case VK_FORMAT_A8B8G8R8_SINT_PACK32:
-      case VK_FORMAT_A8B8G8R8_SRGB_PACK32:
-      case VK_FORMAT_A2R10G10B10_UNORM_PACK32:
-      case VK_FORMAT_A2R10G10B10_SNORM_PACK32:
-      case VK_FORMAT_A2R10G10B10_USCALED_PACK32:
-      case VK_FORMAT_A2R10G10B10_SSCALED_PACK32:
-      case VK_FORMAT_A2R10G10B10_UINT_PACK32:
-      case VK_FORMAT_A2R10G10B10_SINT_PACK32:
-      case VK_FORMAT_A2B10G10R10_UNORM_PACK32:
-      case VK_FORMAT_A2B10G10R10_SNORM_PACK32:
-      case VK_FORMAT_A2B10G10R10_USCALED_PACK32:
-      case VK_FORMAT_A2B10G10R10_SSCALED_PACK32:
-      case VK_FORMAT_A2B10G10R10_UINT_PACK32:
-      case VK_FORMAT_A2B10G10R10_SINT_PACK32:
-      case VK_FORMAT_R16_UNORM:
-      case VK_FORMAT_R16_SNORM:
-      case VK_FORMAT_R16_USCALED:
-      case VK_FORMAT_R16_SSCALED:
-      case VK_FORMAT_R16_UINT:
-      case VK_FORMAT_R16_SINT:
-      case VK_FORMAT_R16_SFLOAT:
-      case VK_FORMAT_R16G16_UNORM:
-      case VK_FORMAT_R16G16_SNORM:
-      case VK_FORMAT_R16G16_USCALED:
-      case VK_FORMAT_R16G16_SSCALED:
-      case VK_FORMAT_R16G16_UINT:
-      case VK_FORMAT_R16G16_SINT:
-      case VK_FORMAT_R16G16_SFLOAT:
-      case VK_FORMAT_R16G16B16_UNORM:
-      case VK_FORMAT_R16G16B16_SNORM:
-      case VK_FORMAT_R16G16B16_USCALED:
-      case VK_FORMAT_R16G16B16_SSCALED:
-      case VK_FORMAT_R16G16B16_UINT:
-      case VK_FORMAT_R16G16B16_SINT:
-      case VK_FORMAT_R16G16B16_SFLOAT:
-      case VK_FORMAT_R16G16B16A16_UNORM:
-      case VK_FORMAT_R16G16B16A16_SNORM:
-      case VK_FORMAT_R16G16B16A16_USCALED:
-      case VK_FORMAT_R16G16B16A16_SSCALED:
-      case VK_FORMAT_R16G16B16A16_UINT:
-      case VK_FORMAT_R16G16B16A16_SINT:
-      case VK_FORMAT_R16G16B16A16_SFLOAT:
-      case VK_FORMAT_R32_UINT:
-      case VK_FORMAT_R32_SINT:
-      case VK_FORMAT_R32_SFLOAT:
-      case VK_FORMAT_R32G32_UINT:
-      case VK_FORMAT_R32G32_SINT:
-      case VK_FORMAT_R32G32_SFLOAT:
-      case VK_FORMAT_R32G32B32_UINT:
-      case VK_FORMAT_R32G32B32_SINT:
-      case VK_FORMAT_R32G32B32_SFLOAT:
-      case VK_FORMAT_R32G32B32A32_UINT:
-      case VK_FORMAT_R32G32B32A32_SINT:
-      case VK_FORMAT_R32G32B32A32_SFLOAT:
-      case VK_FORMAT_R64_UINT:
-      case VK_FORMAT_R64_SINT:
-      case VK_FORMAT_R64_SFLOAT:
-      case VK_FORMAT_R64G64_UINT:
-      case VK_FORMAT_R64G64_SINT:
-      case VK_FORMAT_R64G64_SFLOAT:
-      case VK_FORMAT_R64G64B64_UINT:
-      case VK_FORMAT_R64G64B64_SINT:
-      case VK_FORMAT_R64G64B64_SFLOAT:
-      case VK_FORMAT_R64G64B64A64_UINT:
-      case VK_FORMAT_R64G64B64A64_SINT:
-      case VK_FORMAT_R64G64B64A64_SFLOAT:
-      case VK_FORMAT_B10G11R11_UFLOAT_PACK32:
-      case VK_FORMAT_E5B9G9R9_UFLOAT_PACK32:
-      case VK_FORMAT_D16_UNORM:
-      case VK_FORMAT_X8_D24_UNORM_PACK32:
-      case VK_FORMAT_D32_SFLOAT:
-      case VK_FORMAT_S8_UINT:
-      case VK_FORMAT_D16_UNORM_S8_UINT:
-      case VK_FORMAT_D24_UNORM_S8_UINT:
-      case VK_FORMAT_D32_SFLOAT_S8_UINT:
-      case VK_FORMAT_BC1_RGB_UNORM_BLOCK:
-      case VK_FORMAT_BC1_RGB_SRGB_BLOCK:
-      case VK_FORMAT_BC1_RGBA_UNORM_BLOCK:
-      case VK_FORMAT_BC1_RGBA_SRGB_BLOCK:
-      case VK_FORMAT_BC2_UNORM_BLOCK:
-      case VK_FORMAT_BC2_SRGB_BLOCK:
-      case VK_FORMAT_BC3_UNORM_BLOCK:
-      case VK_FORMAT_BC3_SRGB_BLOCK:
-      case VK_FORMAT_BC4_UNORM_BLOCK:
-      case VK_FORMAT_BC4_SNORM_BLOCK:
-      case VK_FORMAT_BC5_UNORM_BLOCK:
-      case VK_FORMAT_BC5_SNORM_BLOCK:
-      case VK_FORMAT_BC6H_UFLOAT_BLOCK:
-      case VK_FORMAT_BC6H_SFLOAT_BLOCK:
-      case VK_FORMAT_BC7_UNORM_BLOCK:
-      case VK_FORMAT_BC7_SRGB_BLOCK:
-      case VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK:
-      case VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK:
-      case VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK:
-      case VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK:
-      case VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK:
-      case VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK:
-      case VK_FORMAT_EAC_R11_UNORM_BLOCK:
-      case VK_FORMAT_EAC_R11_SNORM_BLOCK:
-      case VK_FORMAT_EAC_R11G11_UNORM_BLOCK:
-      case VK_FORMAT_EAC_R11G11_SNORM_BLOCK:
-      case VK_FORMAT_ASTC_4x4_UNORM_BLOCK:
-      case VK_FORMAT_ASTC_4x4_SRGB_BLOCK:
-      case VK_FORMAT_ASTC_5x4_UNORM_BLOCK:
-      case VK_FORMAT_ASTC_5x4_SRGB_BLOCK:
-      case VK_FORMAT_ASTC_5x5_UNORM_BLOCK:
-      case VK_FORMAT_ASTC_5x5_SRGB_BLOCK:
-      case VK_FORMAT_ASTC_6x5_UNORM_BLOCK:
-      case VK_FORMAT_ASTC_6x5_SRGB_BLOCK:
-      case VK_FORMAT_ASTC_6x6_UNORM_BLOCK:
-      case VK_FORMAT_ASTC_6x6_SRGB_BLOCK:
-      case VK_FORMAT_ASTC_8x5_UNORM_BLOCK:
-      case VK_FORMAT_ASTC_8x5_SRGB_BLOCK:
-      case VK_FORMAT_ASTC_8x6_UNORM_BLOCK:
-      case VK_FORMAT_ASTC_8x6_SRGB_BLOCK:
-      case VK_FORMAT_ASTC_8x8_UNORM_BLOCK:
-      case VK_FORMAT_ASTC_8x8_SRGB_BLOCK:
-      case VK_FORMAT_ASTC_10x5_UNORM_BLOCK:
-      case VK_FORMAT_ASTC_10x5_SRGB_BLOCK:
-      case VK_FORMAT_ASTC_10x6_UNORM_BLOCK:
-      case VK_FORMAT_ASTC_10x6_SRGB_BLOCK:
-      case VK_FORMAT_ASTC_10x8_UNORM_BLOCK:
-      case VK_FORMAT_ASTC_10x8_SRGB_BLOCK:
-      case VK_FORMAT_ASTC_10x10_UNORM_BLOCK:
-      case VK_FORMAT_ASTC_10x10_SRGB_BLOCK:
-      case VK_FORMAT_ASTC_12x10_UNORM_BLOCK:
-      case VK_FORMAT_ASTC_12x10_SRGB_BLOCK:
-      case VK_FORMAT_ASTC_12x12_UNORM_BLOCK:
-      case VK_FORMAT_ASTC_12x12_SRGB_BLOCK:
-      case VK_FORMAT_G8B8G8R8_422_UNORM:
-      case VK_FORMAT_B8G8R8G8_422_UNORM:
-      case VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM:
-      case VK_FORMAT_G8_B8R8_2PLANE_420_UNORM:
-      case VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM:
-      case VK_FORMAT_G8_B8R8_2PLANE_422_UNORM:
-      case VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM:
-      case VK_FORMAT_R10X6_UNORM_PACK16:
-      case VK_FORMAT_R10X6G10X6_UNORM_2PACK16:
-      case VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16:
-      case VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16:
-      case VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16:
-      case VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16:
-      case VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16:
-      case VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16:
-      case VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16:
-      case VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16:
-      case VK_FORMAT_R12X4_UNORM_PACK16:
-      case VK_FORMAT_R12X4G12X4_UNORM_2PACK16:
-      case VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16:
-      case VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16:
-      case VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16:
-      case VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16:
-      case VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16:
-      case VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16:
-      case VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16:
-      case VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16:
-      case VK_FORMAT_G16B16G16R16_422_UNORM:
-      case VK_FORMAT_B16G16R16G16_422_UNORM:
-      case VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM:
-      case VK_FORMAT_G16_B16R16_2PLANE_420_UNORM:
-      case VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM:
-      case VK_FORMAT_G16_B16R16_2PLANE_422_UNORM:
-      case VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM:
-      case VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG:
-      case VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG:
-      case VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG:
-      case VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG:
-      case VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG:
-      case VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG:
-      case VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG:
-      case VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG:
-      case VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT:
-      case VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT:
-      case VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT:
-      case VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT:
-      case VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT:
-      case VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT:
-      case VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT:
-      case VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT:
-      case VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT:
-      case VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT:
-      case VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT:
-      case VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT:
-      case VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT:
-      case VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT:
-      case VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT:
-      case VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT:
-        return true;
-    }
-    return false;
-  }
-};
-
-template <>
-struct EnumTraits<VkPointClippingBehavior> {
-  static bool exist(uint32_t e) {
-    switch (e) {
-      case VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES:
-      case VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY:
-        return true;
-    }
-    return false;
-  }
-};
-
-template <>
-struct EnumTraits<VkExternalFenceHandleTypeFlagBits> {
-  static bool exist(uint32_t e) {
-    switch (e) {
-      case VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT:
-      case VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT:
-      case VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
-      case VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT:
-        return true;
-    }
-    return false;
-  }
-};
-
-template <>
-struct EnumTraits<VkExternalSemaphoreHandleTypeFlagBits> {
-  static bool exist(uint32_t e) {
-    switch (e) {
-      case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT:
-      case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT:
-      case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
-      case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT:
-      case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT:
-        return true;
-    }
-    return false;
-  }
-};
-
-template <>
-struct EnumTraits<VkDriverIdKHR> {
-  static bool exist(uint32_t e) {
-    switch (e) {
-      case VK_DRIVER_ID_AMD_PROPRIETARY:
-      case VK_DRIVER_ID_AMD_OPEN_SOURCE:
-      case VK_DRIVER_ID_MESA_RADV:
-      case VK_DRIVER_ID_NVIDIA_PROPRIETARY:
-      case VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS:
-      case VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA:
-      case VK_DRIVER_ID_IMAGINATION_PROPRIETARY:
-      case VK_DRIVER_ID_QUALCOMM_PROPRIETARY:
-      case VK_DRIVER_ID_ARM_PROPRIETARY:
-      case VK_DRIVER_ID_GOOGLE_SWIFTSHADER:
-      case VK_DRIVER_ID_GGP_PROPRIETARY:
-      case VK_DRIVER_ID_BROADCOM_PROPRIETARY:
-      case VK_DRIVER_ID_MESA_LLVMPIPE:
-      case VK_DRIVER_ID_MOLTENVK:
-        return true;
-    }
-    return false;
-  }
-};
-
-template <>
-struct EnumTraits<VkShaderFloatControlsIndependence> {
-  static bool exist(uint32_t e) {
-    switch (e) {
-      case VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY:
-      case VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL:
-      case VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE:
-        return true;
-    }
-    return false;
-  }
-};
-
-template <>
-struct EnumTraits<VkPipelineRobustnessBufferBehavior> {
-  static bool exist(uint32_t e) {
-    switch (e) {
-      case VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT:
-      case VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED:
-      case VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS:
-      case VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2:
-        return true;
-    }
-    return false;
-  }
-};
-
-template <>
-struct EnumTraits<VkPipelineRobustnessImageBehavior> {
-  static bool exist(uint32_t e) {
-    switch (e) {
-      case VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT:
-      case VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED:
-      case VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS:
-      case VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2:
-        return true;
-    }
-    return false;
-  }
-};
 
 template <>
 struct EnumTraits<VkImageLayout> {
@@ -948,9 +251,9 @@ struct EnumTraits<VkImageLayout> {
     return false;
   }
 };
-
-// VkSparseImageFormatProperties
-
+\n\n""")
+    f.write(f"{util.generate_enum_traits()}")
+    f.write("""
 template <typename Visitor>
 inline bool Iterate(Visitor* visitor, VkExtent3D* extents) {
   return
@@ -959,6 +262,23 @@ inline bool Iterate(Visitor* visitor, VkExtent3D* extents) {
     visitor->Visit("depth", &extents->depth);
 }
 
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceLayeredApiPropertiesKHR* properties) {
+  return
+      visitor->Visit("vendorID", &properties->vendorID) &&
+      visitor->Visit("deviceID", &properties->deviceID) &&
+      visitor->Visit("layeredAPI", &properties->layeredAPI) &&
+      visitor->Visit("deviceName", &properties->deviceName);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkExtent2D* extents) {
+  return
+    visitor->Visit("width", &extents->width) &&
+    visitor->Visit("height", &extents->height);
+}
+
 template <typename Visitor>
 inline bool Iterate(Visitor* visitor,
                     VkConformanceVersionKHR* version) {
@@ -982,9 +302,9 @@ inline bool Iterate(Visitor* visitor, VkMemoryHeap* heap) {
     visitor->Visit("flags", &heap->flags);
 }\n\n""")
 
-    f.write(f"{generate_core_template()}\n\n{generate_extension_struct_template()}\n\n")
-    f.write(generate_struct_template(VK.ALL_STRUCTS))
-
+    f.write(f"{util.generate_core_template()}\n\n{util.generate_extension_struct_template()}\n\n")
+    f.write(util.generate_struct_template(VK.ALL_STRUCTS_EXTENDING_FEATURES_OR_PROPERTIES))
+    f.write(util.generate_struct_template(VK.VULKAN_API_1_0_STRUCTS))
     f.write("""\
 template <typename Visitor>
 inline bool Iterate(Visitor* visitor, VkExternalFenceProperties* properties) {
@@ -1026,19 +346,29 @@ inline bool Iterate(Visitor* visitor, VkJsonDevice* device) {
   switch (device->properties.apiVersion ^
           VK_API_VERSION_PATCH(device->properties.apiVersion)) {
     case VK_API_VERSION_1_4:
-      ret &= visitor->Visit("core14", &device->core14);
+      ret &=
+      """)
+     # TODO:- b/415707479 (Update generator to handle new Vulkan API versions automatically.)
+    util.emit_struct_visits_by_vk_version(f, "VK_VERSION_1_4")
+    f.write("""visitor->Visit("core14", &device->core14);
       FALLTHROUGH_INTENDED;
     case VK_API_VERSION_1_3:
-      ret &= visitor->Visit("core13", &device->core13);
+      ret &= """)
+    util.emit_struct_visits_by_vk_version(f, "VK_VERSION_1_3")
+    f.write("""visitor->Visit("core13", &device->core13);
       FALLTHROUGH_INTENDED;
     case VK_API_VERSION_1_2:
-      ret &= visitor->Visit("core11", &device->core11);
+      ret &=
+            """)
+    util.emit_struct_visits_by_vk_version(f, "VK_VERSION_1_2")
+    f.write("""
+      visitor->Visit("core11", &device->core11);
       ret &= visitor->Visit("core12", &device->core12);
       FALLTHROUGH_INTENDED;
     case VK_API_VERSION_1_1:
       ret &=\n""")
 
-    emit_struct_visits_by_vk_version(f, "VK_VERSION_1_1")
+    util.emit_struct_visits_by_vk_version(f, "VK_VERSION_1_1")
 
     f.write("""\
           visitor->Visit("externalFenceProperties",
@@ -1049,16 +379,19 @@ inline bool Iterate(Visitor* visitor, VkJsonDevice* device) {
     case VK_API_VERSION_1_0:
       ret &=\n""")
 
-    emit_struct_visits_by_vk_version(f, "VK_VERSION_1_0")
+    util.emit_struct_visits_by_vk_version(f, "VK_VERSION_1_0")
 
     f.write("""\
+             visitor->Visit("properties", &device->properties) &&
+             visitor->Visit("features", &device->features) &&
+             visitor->Visit("memory", &device->memory) &&
              visitor->Visit("queues", &device->queues) &&
              visitor->Visit("extensions", &device->extensions) &&
              visitor->Visit("layers", &device->layers) &&
              visitor->Visit("formats", &device->formats);\n\n""")
 
     for extension_name, _ in VK.VULKAN_EXTENSIONS_AND_STRUCTS_MAPPING["extensions"].items():
-      struct_var = get_vkjson_struct_variable_name(extension_name)
+      struct_var = util.get_vkjson_struct_variable_name(extension_name)
       f.write(f"  if (device->{struct_var}.reported) {{\n")
       f.write(f"    ret &= visitor->Visit(\"{extension_name}\", &device->{struct_var});\n")
       f.write("  }\n")
@@ -1081,12 +414,9 @@ inline bool Iterate(Visitor* visitor, VkJsonInstance* instance) {
       ret &= visitor->Visit("deviceGroups", &instance->device_groups);
       FALLTHROUGH_INTENDED;
     case VK_API_VERSION_1_0:
-      char depString[] =
-          "vkjson is deprecated, and will be replaced in a future release";
       ret &= visitor->Visit("layers", &instance->layers) &&
              visitor->Visit("extensions", &instance->extensions) &&
-             visitor->Visit("devices", &instance->devices) &&
-             visitor->Visit("_comment", &depString);
+             visitor->Visit("devices", &instance->devices);
   }
   return ret;
 }
@@ -1219,6 +549,18 @@ inline bool AsValue(Json::Value* json_value, int32_t* value) {
   return true;
 }
 
+inline bool AsValue(Json::Value* json_value, int64_t* value) {
+  if (json_value->type() != Json::realValue)
+    return false;
+  double d = json_value->asDouble();
+  if (!IsIntegral(d) ||
+      d < static_cast<double>(std::numeric_limits<int64_t>::min()) ||
+      d > static_cast<double>(std::numeric_limits<int64_t>::max()))
+    return false;
+  *value = static_cast<int64_t>(d);
+  return true;
+}
+
 inline bool AsValue(Json::Value* json_value, uint64_t* value) {
   if (json_value->type() != Json::stringValue) return false;
   int result =
@@ -1455,85 +797,6 @@ bool VkJsonImageFormatPropertiesFromJson(const std::string& json,
   gencom.run_clang_format(genfile)
 
 
-def generate_vk_core_structs_init_code(version):
-  """Generates code to initialize properties and features
-  for structs based on its vulkan API version dependency.
-  """
-  properties_code, features_code = [], []
-
-  for item in VK.VULKAN_CORES_AND_STRUCTS_MAPPING["versions"].get(version, []):
-    for struct_name, struct_type in item.items():
-      version_lower = version.lower()
-
-      if "Properties" in struct_name:
-        properties_code.extend([
-            f"device.{version_lower}.properties.sType = {struct_type};",
-            f"device.{version_lower}.properties.pNext = properties.pNext;",
-            f"properties.pNext = &device.{version_lower}.properties;\n\n"
-        ])
-
-      elif "Features" in struct_name:
-        features_code.extend([
-            f"device.{version_lower}.features.sType = {struct_type};",
-            f"device.{version_lower}.features.pNext = features.pNext;",
-            f"features.pNext = &device.{version_lower}.features;\n\n"
-        ])
-
-  return "\n".join(properties_code), "\n".join(features_code)
-
-
-def generate_vk_extension_structs_init_code(mapping, struct_category, next_pointer):
-  """Generates Vulkan struct initialization code for given struct category (Properties/Features)
-  based on its extension dependency.
-  """
-  generated_code = []
-
-  for extension, struct_mappings in mapping.items():
-    struct_var_name = get_vkjson_struct_variable_name(extension)
-    extension_code = [
-        f"  if (HasExtension(\"{extension}\", device.extensions)) {{",
-        f"    device.{struct_var_name}.reported = true;"
-    ]
-
-    struct_count = 0
-    for struct_mapping in struct_mappings:
-      for struct_name, struct_type in struct_mapping.items():
-        if struct_category in struct_name:
-          struct_count += 1
-          struct_instance = get_struct_name(struct_name)
-          extension_code.extend([
-              f"    device.{struct_var_name}.{struct_instance}.sType = {struct_type};",
-              f"    device.{struct_var_name}.{struct_instance}.pNext = {next_pointer}.pNext;",
-              f"    {next_pointer}.pNext = &device.{struct_var_name}.{struct_instance};"
-          ])
-
-    extension_code.append("  }\n")
-
-    if struct_count > 0:
-      generated_code.extend(extension_code)
-
-  return "\n".join(generated_code)
-
-
-def generate_vk_version_structs_initialization(version_data, struct_type_keyword, next_pointer):
-  """Generates Vulkan struct initialization code for given struct category (Properties/Features)
-  of vulkan api version s.
-  """
-  struct_initialization_code = []
-
-  for struct_mapping in version_data:
-    for struct_name, struct_type in struct_mapping.items():
-      if struct_type_keyword in struct_name:
-        struct_variable = get_struct_name(struct_name)
-        struct_initialization_code.extend([
-            f"device.{struct_variable}.sType = {struct_type};",
-            f"device.{struct_variable}.pNext = {next_pointer}.pNext;",
-            f"{next_pointer}.pNext = &device.{struct_variable};\n"
-        ])
-
-  return "\n".join(struct_initialization_code)
-
-
 def gen_instance_cc():
   """Generates vkjson_instance.cc file.
   """
@@ -1541,7 +804,7 @@ def gen_instance_cc():
                          "..", "vkjson", "vkjson_instance.cc")
 
   with open(genfile, "w") as f:
-    f.write(get_copyright_warnings())
+    f.write(util.get_copyright_warnings())
     f.write("\n")
 
     f.write("""\
@@ -1610,9 +873,8 @@ VkJsonDevice VkJsonGetDevice(VkPhysicalDevice physical_device) {
       {},
   };\n\n""")
 
-    cc_code_properties = generate_vk_extension_structs_init_code(
-    VK.VULKAN_EXTENSIONS_AND_STRUCTS_MAPPING["extensions"], "Properties", "properties"
-    )
+    cc_code_properties = util.generate_vk_extension_structs_init_code(
+    VK.VULKAN_EXTENSIONS_AND_STRUCTS_MAPPING["extensions"], "Properties")
     f.write(f'{cc_code_properties}\n')
 
     f.write("""\
@@ -1626,9 +888,8 @@ VkJsonDevice VkJsonGetDevice(VkPhysicalDevice physical_device) {
       {},
   };\n\n""")
 
-    cc_code_features = generate_vk_extension_structs_init_code(
-      VK.VULKAN_EXTENSIONS_AND_STRUCTS_MAPPING["extensions"], "Features", "features"
-    )
+    cc_code_features = util.generate_vk_extension_structs_init_code(
+      VK.VULKAN_EXTENSIONS_AND_STRUCTS_MAPPING["extensions"], "Features")
     f.write(f'{cc_code_features}\n')
 
     f.write("""\
@@ -1647,44 +908,22 @@ VkJsonDevice VkJsonGetDevice(VkPhysicalDevice physical_device) {
         physical_device, &queue_family_count, device.queues.data());
   }
 
-  VkFormatProperties format_properties = {};
-  for (VkFormat format = VK_FORMAT_R4G4_UNORM_PACK8;
-       // TODO(http://b/171403054): avoid hard-coding last value in the
-       // contiguous range
-       format <= VK_FORMAT_ASTC_12x12_SRGB_BLOCK;
-       format = static_cast<VkFormat>(format + 1)) {
-    vkGetPhysicalDeviceFormatProperties(physical_device, format,
-                                        &format_properties);
-    if (format_properties.linearTilingFeatures ||
-        format_properties.optimalTilingFeatures ||
-        format_properties.bufferFeatures) {
-      device.formats.insert(std::make_pair(format, format_properties));
-    }
-  }
-
-  if (device.properties.apiVersion >= VK_API_VERSION_1_1) {
-    for (VkFormat format = VK_FORMAT_G8B8G8R8_422_UNORM;
-         // TODO(http://b/171403054): avoid hard-coding last value in the
-         // contiguous range
-         format <= VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM;
-         format = static_cast<VkFormat>(format + 1)) {
-      vkGetPhysicalDeviceFormatProperties(physical_device, format,
-                                          &format_properties);
-      if (format_properties.linearTilingFeatures ||
-          format_properties.optimalTilingFeatures ||
-          format_properties.bufferFeatures) {
-        device.formats.insert(std::make_pair(format, format_properties));
-      }
-    }\n\n""")
+  VkFormatProperties format_properties = {};\n""")
+    util.generate_format_range_map()
+    f.write(util.generate_vk_format_init_code("VK_VERSION_1_0"))
+    f.write(util.generate_vk_format_init_code())
+    f.write("""\
+    if (device.properties.apiVersion >= VK_API_VERSION_1_1) {\n""")
+    f.write(util.generate_vk_format_init_code("VK_VERSION_1_1"))
 
     # Vulkan version data for VK_VERSION_1_1
     vk_version_data = VK.VULKAN_VERSIONS_AND_STRUCTS_MAPPING["VK_VERSION_1_1"]
-    f.write(generate_vk_version_structs_initialization(vk_version_data, "Properties", "properties") + "\n")
+    f.write(util.generate_vk_version_structs_initialization(vk_version_data, "Properties") + "\n")
 
     f.write("""\
     vkGetPhysicalDeviceProperties2(physical_device, &properties);\n\n""")
 
-    features_initialization_code = generate_vk_version_structs_initialization(vk_version_data, "Features", "features")
+    features_initialization_code = util.generate_vk_version_structs_initialization(vk_version_data, "Features")
     f.write(features_initialization_code)
 
     f.write("""\
@@ -1736,48 +975,68 @@ VkJsonDevice VkJsonGetDevice(VkPhysicalDevice physical_device) {
   }
 
   if (device.properties.apiVersion >= VK_API_VERSION_1_2) {\n""")
-
-    cc_code_properties_11, cc_code_features_11 = generate_vk_core_structs_init_code("Core11")
-    cc_code_properties_12, cc_code_features_12 = generate_vk_core_structs_init_code("Core12")
-    cc_code_properties_13, cc_code_features_13 = generate_vk_core_structs_init_code("Core13")
-    cc_code_properties_14, cc_code_features_14 = generate_vk_core_structs_init_code("Core14")
+    f.write(util.generate_vk_format_init_code("VK_VERSION_1_2"))
+    cc_code_properties_11, cc_code_features_11 = util.generate_vk_core_structs_init_code("Core11")
+    cc_code_properties_12, cc_code_features_12 = util.generate_vk_core_structs_init_code("Core12")
+    # Vulkan version data for VK_VERSION_1_2
+    vk_version_data = VK.VULKAN_VERSIONS_AND_STRUCTS_MAPPING["VK_VERSION_1_2"]
 
     f.write(cc_code_properties_11)
     f.write(cc_code_properties_12)
+    f.write(util.generate_vk_version_structs_initialization(vk_version_data, "Properties") + "\n")
+
     f.write(f"vkGetPhysicalDeviceProperties2(physical_device, &properties);\n\n")
+
     f.write(cc_code_features_11)
     f.write(cc_code_features_12)
+    f.write(util.generate_vk_version_structs_initialization(vk_version_data, "Features"))
+
     f.write(f"vkGetPhysicalDeviceFeatures2(physical_device, &features);\n\n")
     f.write("""\
   }
 
   if (device.properties.apiVersion >= VK_API_VERSION_1_3) {\n""")
+    f.write(util.generate_vk_format_init_code("VK_VERSION_1_3"))
+    cc_code_properties_13, cc_code_features_13 = util.generate_vk_core_structs_init_code("Core13")
+    cc_code_properties_14, cc_code_features_14 = util.generate_vk_core_structs_init_code("Core14")
+
+    # Vulkan version data for VK_VERSION_1_3
+    vk_version_data = VK.VULKAN_VERSIONS_AND_STRUCTS_MAPPING["VK_VERSION_1_3"]
+
+    f.write(util.generate_vk_version_structs_initialization(vk_version_data, "Properties") + "\n")
     f.write(cc_code_properties_13)
     f.write(f"vkGetPhysicalDeviceProperties2(physical_device, &properties);\n\n")
+
     f.write(cc_code_features_13)
+    f.write(f"{util.generate_vk_version_structs_initialization(vk_version_data, "Features")}\n")
     f.write(f"vkGetPhysicalDeviceFeatures2(physical_device, &features);\n\n")
     f.write("""\
   }
 
   if (device.properties.apiVersion >= VK_API_VERSION_1_4) {\n""")
+    f.write(util.generate_vk_format_init_code("VK_VERSION_1_4"))
+
+    # Vulkan version data for VK_VERSION_1_4
+    vk_version_data = VK.VULKAN_VERSIONS_AND_STRUCTS_MAPPING["VK_VERSION_1_4"]
+    f.write(util.generate_vk_version_structs_initialization(vk_version_data, "Properties") + "\n")
     f.write(cc_code_properties_14)
     f.write(f"vkGetPhysicalDeviceProperties2(physical_device, &properties);\n\n")
 
     f.write("""\
-if (device.core14.properties.copySrcLayoutCount > 0 || device.core14.properties.copyDstLayoutCount > 0 ) {
-  if (device.core14.properties.copySrcLayoutCount > 0) {
-    device.core14.copy_src_layouts.resize(device.core14.properties.copySrcLayoutCount);
-    device.core14.properties.pCopySrcLayouts = device.core14.copy_src_layouts.data();
-  }
-  if (device.core14.properties.copyDstLayoutCount > 0) {
-    device.core14.copy_dst_layouts.resize(device.core14.properties.copyDstLayoutCount);
-    device.core14.properties.pCopyDstLayouts = device.core14.copy_dst_layouts.data();
-  }
-  vkGetPhysicalDeviceProperties2(physical_device, &properties);
-}
+    if (device.core14.properties.copySrcLayoutCount > 0 || device.core14.properties.copyDstLayoutCount > 0 ) {
+      if (device.core14.properties.copySrcLayoutCount > 0) {
+        device.core14.copy_src_layouts.resize(device.core14.properties.copySrcLayoutCount);
+        device.core14.properties.pCopySrcLayouts = device.core14.copy_src_layouts.data();
+      }
+      if (device.core14.properties.copyDstLayoutCount > 0) {
+        device.core14.copy_dst_layouts.resize(device.core14.properties.copyDstLayoutCount);
+        device.core14.properties.pCopyDstLayouts = device.core14.copy_dst_layouts.data();
+      }
+      vkGetPhysicalDeviceProperties2(physical_device, &properties);
+    }
     \n""")
-
     f.write(cc_code_features_14)
+    f.write(f"{util.generate_vk_version_structs_initialization(vk_version_data, "Features")}\n")
     f.write(f"vkGetPhysicalDeviceFeatures2(physical_device, &features);\n\n")
     f.write("""\
   }
diff --git a/vulkan/vkjson/OWNERS b/vulkan/vkjson/OWNERS
new file mode 100644
index 0000000000..6289a71bce
--- /dev/null
+++ b/vulkan/vkjson/OWNERS
@@ -0,0 +1,2 @@
+include ../OWNERS
+nikigupta@google.com
diff --git a/vulkan/vkjson/vkjson.cc b/vulkan/vkjson/vkjson.cc
index 45fb46c09c..3a2eb8d9b9 100644
--- a/vulkan/vkjson/vkjson.cc
+++ b/vulkan/vkjson/vkjson.cc
@@ -66,6 +66,76 @@ static const double SAFE_DOUBLE_MIN = -SAFE_DOUBLE_MAX;
 
 template <typename T>
 struct EnumTraits;
+
+template <>
+struct EnumTraits<VkImageLayout> {
+  static bool exist(uint32_t e) {
+    switch (e) {
+      case VK_IMAGE_LAYOUT_UNDEFINED:
+      case VK_IMAGE_LAYOUT_GENERAL:
+      case VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL:
+      case VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL:
+      case VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL:
+      case VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL:
+      case VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL:
+      case VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL:
+      case VK_IMAGE_LAYOUT_PREINITIALIZED:
+      case VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL:
+      case VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL:
+      case VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL:
+      case VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL:
+      case VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL:
+      case VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL:
+      case VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL:
+      case VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL:
+      case VK_IMAGE_LAYOUT_PRESENT_SRC_KHR:
+      case VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR:
+      case VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR:
+      case VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR:
+      case VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR:
+      case VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT:
+      case VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR:
+#ifdef VK_ENABLE_BETA_EXTENSIONS
+      case VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR:
+#endif
+#ifdef VK_ENABLE_BETA_EXTENSIONS
+      case VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR:
+#endif
+#ifdef VK_ENABLE_BETA_EXTENSIONS
+      case VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR:
+#endif
+      case VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT:
+        return true;
+    }
+    return false;
+  }
+};
+
+template <>
+struct EnumTraits<VkImageType> {
+  static bool exist(uint32_t e) {
+    switch (e) {
+      case VK_IMAGE_TYPE_1D:
+      case VK_IMAGE_TYPE_2D:
+      case VK_IMAGE_TYPE_3D:
+        return true;
+    }
+    return false;
+  }
+};
+
+template <>
+struct EnumTraits<VkImageTiling> {
+  static bool exist(uint32_t e) {
+    switch (e) {
+      case VK_IMAGE_TILING_OPTIMAL:
+      case VK_IMAGE_TILING_LINEAR:
+        return true;
+    }
+    return false;
+  }
+};
+
 template <>
 struct EnumTraits<VkPhysicalDeviceType> {
   static bool exist(uint32_t e) {
@@ -304,6 +374,28 @@ struct EnumTraits<VkFormat> {
       case VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM:
       case VK_FORMAT_G16_B16R16_2PLANE_422_UNORM:
       case VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM:
+      case VK_FORMAT_G8_B8R8_2PLANE_444_UNORM:
+      case VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16:
+      case VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16:
+      case VK_FORMAT_G16_B16R16_2PLANE_444_UNORM:
+      case VK_FORMAT_A4R4G4B4_UNORM_PACK16:
+      case VK_FORMAT_A4B4G4R4_UNORM_PACK16:
+      case VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK:
+      case VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK:
+      case VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK:
+      case VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK:
+      case VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK:
+      case VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK:
+      case VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK:
+      case VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK:
+      case VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK:
+      case VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK:
+      case VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK:
+      case VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK:
+      case VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK:
+      case VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK:
+      case VK_FORMAT_A1B5G5R5_UNORM_PACK16:
+      case VK_FORMAT_A8_UNORM:
       case VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG:
       case VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG:
       case VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG:
@@ -312,22 +404,7 @@ struct EnumTraits<VkFormat> {
       case VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG:
       case VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG:
       case VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG:
-      case VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT:
-      case VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT:
-      case VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT:
-      case VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT:
-      case VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT:
-      case VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT:
-      case VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT:
-      case VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT:
-      case VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT:
-      case VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT:
-      case VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT:
-      case VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT:
-      case VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT:
-      case VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT:
-      case VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT:
-      case VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT:
+      case VK_FORMAT_R16G16_SFIXED5_NV:
         return true;
     }
     return false;
@@ -335,11 +412,11 @@ struct EnumTraits<VkFormat> {
 };
 
 template <>
-struct EnumTraits<VkPointClippingBehavior> {
+struct EnumTraits<VkRayTracingInvocationReorderModeNV> {
   static bool exist(uint32_t e) {
     switch (e) {
-      case VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES:
-      case VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY:
+      case VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV:
+      case VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV:
         return true;
     }
     return false;
@@ -347,13 +424,33 @@ struct EnumTraits<VkPointClippingBehavior> {
 };
 
 template <>
-struct EnumTraits<VkExternalFenceHandleTypeFlagBits> {
+struct EnumTraits<VkSampleCountFlagBits> {
   static bool exist(uint32_t e) {
     switch (e) {
-      case VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT:
-      case VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT:
-      case VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
-      case VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT:
+      case VK_SAMPLE_COUNT_1_BIT:
+      case VK_SAMPLE_COUNT_2_BIT:
+      case VK_SAMPLE_COUNT_4_BIT:
+      case VK_SAMPLE_COUNT_8_BIT:
+      case VK_SAMPLE_COUNT_16_BIT:
+      case VK_SAMPLE_COUNT_32_BIT:
+      case VK_SAMPLE_COUNT_64_BIT:
+        return true;
+    }
+    return false;
+  }
+};
+
+template <>
+struct EnumTraits<VkExternalMemoryHandleTypeFlagBits> {
+  static bool exist(uint32_t e) {
+    switch (e) {
+      case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT:
+      case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT:
+      case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
+      case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT:
+      case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT:
+      case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT:
+      case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT:
         return true;
     }
     return false;
@@ -376,7 +473,45 @@ struct EnumTraits<VkExternalSemaphoreHandleTypeFlagBits> {
 };
 
 template <>
-struct EnumTraits<VkDriverIdKHR> {
+struct EnumTraits<VkExternalFenceHandleTypeFlagBits> {
+  static bool exist(uint32_t e) {
+    switch (e) {
+      case VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT:
+      case VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT:
+      case VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
+      case VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT:
+        return true;
+    }
+    return false;
+  }
+};
+
+template <>
+struct EnumTraits<VkPointClippingBehavior> {
+  static bool exist(uint32_t e) {
+    switch (e) {
+      case VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES:
+      case VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY:
+        return true;
+    }
+    return false;
+  }
+};
+
+template <>
+struct EnumTraits<VkChromaLocation> {
+  static bool exist(uint32_t e) {
+    switch (e) {
+      case VK_CHROMA_LOCATION_COSITED_EVEN:
+      case VK_CHROMA_LOCATION_MIDPOINT:
+        return true;
+    }
+    return false;
+  }
+};
+
+template <>
+struct EnumTraits<VkDriverId> {
   static bool exist(uint32_t e) {
     switch (e) {
       case VK_DRIVER_ID_AMD_PROPRIETARY:
@@ -393,6 +528,19 @@ struct EnumTraits<VkDriverIdKHR> {
       case VK_DRIVER_ID_BROADCOM_PROPRIETARY:
       case VK_DRIVER_ID_MESA_LLVMPIPE:
       case VK_DRIVER_ID_MOLTENVK:
+      case VK_DRIVER_ID_COREAVI_PROPRIETARY:
+      case VK_DRIVER_ID_JUICE_PROPRIETARY:
+      case VK_DRIVER_ID_VERISILICON_PROPRIETARY:
+      case VK_DRIVER_ID_MESA_TURNIP:
+      case VK_DRIVER_ID_MESA_V3DV:
+      case VK_DRIVER_ID_MESA_PANVK:
+      case VK_DRIVER_ID_SAMSUNG_PROPRIETARY:
+      case VK_DRIVER_ID_MESA_VENUS:
+      case VK_DRIVER_ID_MESA_DOZEN:
+      case VK_DRIVER_ID_MESA_NVK:
+      case VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA:
+      case VK_DRIVER_ID_MESA_HONEYKRISP:
+      case VK_DRIVER_ID_RESERVED_27:
         return true;
     }
     return false;
@@ -441,50 +589,31 @@ struct EnumTraits<VkPipelineRobustnessImageBehavior> {
 };
 
 template <>
-struct EnumTraits<VkImageLayout> {
+struct EnumTraits<VkPhysicalDeviceLayeredApiKHR> {
   static bool exist(uint32_t e) {
     switch (e) {
-      case VK_IMAGE_LAYOUT_UNDEFINED:
-      case VK_IMAGE_LAYOUT_GENERAL:
-      case VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL:
-      case VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL:
-      case VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL:
-      case VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL:
-      case VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL:
-      case VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL:
-      case VK_IMAGE_LAYOUT_PREINITIALIZED:
-      case VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL:
-      case VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL:
-      case VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL:
-      case VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL:
-      case VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL:
-      case VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL:
-      case VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL:
-      case VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL:
-      case VK_IMAGE_LAYOUT_PRESENT_SRC_KHR:
-      case VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR:
-      case VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR:
-      case VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR:
-      case VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR:
-      case VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT:
-      case VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR:
-#ifdef VK_ENABLE_BETA_EXTENSIONS
-      case VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR:
-#endif
-#ifdef VK_ENABLE_BETA_EXTENSIONS
-      case VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR:
-#endif
-#ifdef VK_ENABLE_BETA_EXTENSIONS
-      case VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR:
-#endif
-      case VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT:
+      case VK_PHYSICAL_DEVICE_LAYERED_API_VULKAN_KHR:
+      case VK_PHYSICAL_DEVICE_LAYERED_API_D3D12_KHR:
+      case VK_PHYSICAL_DEVICE_LAYERED_API_METAL_KHR:
+      case VK_PHYSICAL_DEVICE_LAYERED_API_OPENGL_KHR:
+      case VK_PHYSICAL_DEVICE_LAYERED_API_OPENGLES_KHR:
         return true;
     }
     return false;
   }
 };
 
-// VkSparseImageFormatProperties
+template <>
+struct EnumTraits<VkLayeredDriverUnderlyingApiMSFT> {
+  static bool exist(uint32_t e) {
+    switch (e) {
+      case VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT:
+      case VK_LAYERED_DRIVER_UNDERLYING_API_D3D12_MSFT:
+        return true;
+    }
+    return false;
+  }
+};
 
 template <typename Visitor>
 inline bool Iterate(Visitor* visitor, VkExtent3D* extents) {
@@ -493,6 +622,21 @@ inline bool Iterate(Visitor* visitor, VkExtent3D* extents) {
          visitor->Visit("depth", &extents->depth);
 }
 
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceLayeredApiPropertiesKHR* properties) {
+  return visitor->Visit("vendorID", &properties->vendorID) &&
+         visitor->Visit("deviceID", &properties->deviceID) &&
+         visitor->Visit("layeredAPI", &properties->layeredAPI) &&
+         visitor->Visit("deviceName", &properties->deviceName);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkExtent2D* extents) {
+  return visitor->Visit("width", &extents->width) &&
+         visitor->Visit("height", &extents->height);
+}
+
 template <typename Visitor>
 inline bool Iterate(Visitor* visitor, VkConformanceVersionKHR* version) {
   return visitor->Visit("major", &version->major) &&
@@ -515,846 +659,4934 @@ inline bool Iterate(Visitor* visitor, VkMemoryHeap* heap) {
 
 template <typename Visitor>
 inline bool Iterate(Visitor* visitor, VkJsonCore11* core) {
-  return visitor->Visit("properties", &core->properties) &&
-         visitor->Visit("features", &core->features);
+  return visitor->Visit("features", &core->features) &&
+         visitor->Visit("properties", &core->properties);
 }
 
 template <typename Visitor>
 inline bool Iterate(Visitor* visitor, VkJsonCore12* core) {
-  return visitor->Visit("properties", &core->properties) &&
-         visitor->Visit("features", &core->features);
+  return visitor->Visit("features", &core->features) &&
+         visitor->Visit("properties", &core->properties);
 }
 
 template <typename Visitor>
 inline bool Iterate(Visitor* visitor, VkJsonCore13* core) {
-  return visitor->Visit("properties", &core->properties) &&
-         visitor->Visit("features", &core->features);
+  return visitor->Visit("features", &core->features) &&
+         visitor->Visit("properties", &core->properties);
 }
 
 template <typename Visitor>
 inline bool Iterate(Visitor* visitor, VkJsonCore14* core) {
-  return visitor->Visit("properties", &core->properties) &&
-         visitor->Visit("features", &core->features);
+  return visitor->Visit("features", &core->features) &&
+         visitor->Visit("properties", &core->properties);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor, VkJsonKHRVariablePointers* structs) {
-  return visitor->Visit("variablePointerFeaturesKHR",
-                        &structs->variable_pointer_features_khr) &&
-         visitor->Visit("variablePointersFeaturesKHR",
-                        &structs->variable_pointers_features_khr);
+inline bool Iterate(Visitor* visitor, VkJsonAMDAntiLag* structs) {
+  return visitor->Visit("antiLagFeaturesAMD", &structs->anti_lag_features_amd);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor, VkJsonKHRShaderFloat16Int8* structs) {
-  return visitor->Visit("shaderFloat16Int8FeaturesKHR",
-                        &structs->shader_float16_int8_features_khr) &&
-         visitor->Visit("float16Int8FeaturesKHR",
-                        &structs->float16_int8_features_khr);
+inline bool Iterate(Visitor* visitor, VkJsonAMDDeviceCoherentMemory* structs) {
+  return visitor->Visit("coherentMemoryFeaturesAMD",
+                        &structs->coherent_memory_features_amd);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor, VkJsonExtImage2dViewOf3d* structs) {
-  return visitor->Visit("image2DViewOf3DFeaturesEXT",
-                        &structs->image_2d_view_of_3d_features_ext);
+inline bool Iterate(Visitor* visitor, VkJsonAMDShaderCoreProperties* structs) {
+  return visitor->Visit("shaderCorePropertiesAMD",
+                        &structs->shader_core_properties_amd);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor, VkJsonExtCustomBorderColor* structs) {
-  return visitor->Visit("customBorderColorFeaturesEXT",
-                        &structs->custom_border_color_features_ext);
+inline bool Iterate(Visitor* visitor, VkJsonAMDShaderCoreProperties2* structs) {
+  return visitor->Visit("shaderCoreProperties2AMD",
+                        &structs->shader_core_properties2_amd);
 }
 
 template <typename Visitor>
 inline bool Iterate(Visitor* visitor,
-                    VkJsonExtPrimitiveTopologyListRestart* structs) {
-  return visitor->Visit("primitiveTopologyListRestartFeaturesEXT",
-                        &structs->primitive_topology_list_restart_features_ext);
+                    VkJsonAMDShaderEarlyAndLateFragmentTests* structs) {
+  return visitor->Visit(
+      "shaderEarlyAndLateFragmentTestsFeaturesAMD",
+      &structs->shader_early_and_late_fragment_tests_features_amd);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor, VkJsonExtProvokingVertex* structs) {
-  return visitor->Visit("provokingVertexFeaturesEXT",
-                        &structs->provoking_vertex_features_ext);
+inline bool Iterate(Visitor* visitor,
+                    VkJsonANDROIDExternalFormatResolve* structs) {
+  return visitor->Visit("externalFormatResolveFeaturesANDROID",
+                        &structs->external_format_resolve_features_android) &&
+         visitor->Visit("externalFormatResolvePropertiesANDROID",
+                        &structs->external_format_resolve_properties_android);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor, VkJsonKHRIndexTypeUint8* structs) {
-  return visitor->Visit("indexTypeUint8FeaturesKHR",
-                        &structs->index_type_uint8_features_khr);
+inline bool Iterate(Visitor* visitor,
+                    VkJsonARMRasterizationOrderAttachmentAccess* structs) {
+  return visitor->Visit(
+      "rasterizationOrderAttachmentAccessFeaturesARM",
+      &structs->rasterization_order_attachment_access_features_arm);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor, VkJsonExtIndexTypeUint8* structs) {
-  return visitor->Visit("indexTypeUint8FeaturesEXT",
-                        &structs->index_type_uint8_features_ext);
+inline bool Iterate(Visitor* visitor, VkJsonARMRenderPassStriped* structs) {
+  return visitor->Visit("renderPassStripedFeaturesARM",
+                        &structs->render_pass_striped_features_arm) &&
+         visitor->Visit("renderPassStripedPropertiesARM",
+                        &structs->render_pass_striped_properties_arm);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor,
-                    VkJsonKHRVertexAttributeDivisor* structs) {
-  return visitor->Visit("vertexAttributeDivisorFeaturesKHR",
-                        &structs->vertex_attribute_divisor_features_khr);
+inline bool Iterate(Visitor* visitor, VkJsonARMSchedulingControls* structs) {
+  return visitor->Visit("schedulingControlsFeaturesARM",
+                        &structs->scheduling_controls_features_arm) &&
+         visitor->Visit("schedulingControlsPropertiesARM",
+                        &structs->scheduling_controls_properties_arm);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor,
-                    VkJsonExtVertexAttributeDivisor* structs) {
-  return visitor->Visit("vertexAttributeDivisorFeaturesEXT",
-                        &structs->vertex_attribute_divisor_features_ext);
+inline bool Iterate(Visitor* visitor, VkJsonARMShaderCoreBuiltins* structs) {
+  return visitor->Visit("shaderCoreBuiltinsFeaturesARM",
+                        &structs->shader_core_builtins_features_arm) &&
+         visitor->Visit("shaderCoreBuiltinsPropertiesARM",
+                        &structs->shader_core_builtins_properties_arm);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor, VkJsonExtTransformFeedback* structs) {
-  return visitor->Visit("transformFeedbackFeaturesEXT",
-                        &structs->transform_feedback_features_ext);
+inline bool Iterate(Visitor* visitor, VkJsonARMShaderCoreProperties* structs) {
+  return visitor->Visit("shaderCorePropertiesARM",
+                        &structs->shader_core_properties_arm);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExt4444Formats* structs) {
+  return visitor->Visit("formats4444FeaturesEXT",
+                        &structs->formats_4444_features_ext);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtAstcDecodeMode* structs) {
+  return visitor->Visit("aSTCDecodeFeaturesEXT",
+                        &structs->astc_decode_features_ext);
 }
 
 template <typename Visitor>
 inline bool Iterate(Visitor* visitor,
-                    VkJsonKHRShaderSubgroupUniformControlFlow* structs) {
+                    VkJsonExtAttachmentFeedbackLoopDynamicState* structs) {
   return visitor->Visit(
-      "shaderSubgroupUniformControlFlowFeaturesKHR",
-      &structs->shader_subgroup_uniform_control_flow_features_khr);
+      "attachmentFeedbackLoopDynamicStateFeaturesEXT",
+      &structs->attachment_feedback_loop_dynamic_state_features_ext);
 }
 
 template <typename Visitor>
 inline bool Iterate(Visitor* visitor,
-                    VkJsonKHRShaderSubgroupExtendedTypes* structs) {
-  return visitor->Visit("shaderSubgroupExtendedTypesFeaturesKHR",
-                        &structs->shader_subgroup_extended_types_features_khr);
+                    VkJsonExtAttachmentFeedbackLoopLayout* structs) {
+  return visitor->Visit("attachmentFeedbackLoopLayoutFeaturesEXT",
+                        &structs->attachment_feedback_loop_layout_features_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor, VkJsonKHR8bitStorage* structs) {
-  return visitor->Visit("bit8StorageFeaturesKHR",
-                        &structs->bit8_storage_features_khr);
+inline bool Iterate(Visitor* visitor,
+                    VkJsonExtBlendOperationAdvanced* structs) {
+  return visitor->Visit("blendOperationAdvancedFeaturesEXT",
+                        &structs->blend_operation_advanced_features_ext) &&
+         visitor->Visit("blendOperationAdvancedPropertiesEXT",
+                        &structs->blend_operation_advanced_properties_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor,
-                    VkJsonKHRShaderIntegerDotProduct* structs) {
-  return visitor->Visit("shaderIntegerDotProductFeaturesKHR",
-                        &structs->shader_integer_dot_product_features_khr);
+inline bool Iterate(Visitor* visitor, VkJsonExtBorderColorSwizzle* structs) {
+  return visitor->Visit("borderColorSwizzleFeaturesEXT",
+                        &structs->border_color_swizzle_features_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor,
-                    VkJsonIMGRelaxedLineRasterization* structs) {
-  return visitor->Visit("relaxedLineRasterizationFeaturesIMG",
-                        &structs->relaxed_line_rasterization_features_img);
+inline bool Iterate(Visitor* visitor, VkJsonExtBufferDeviceAddress* structs) {
+  return visitor->Visit("bufferAddressFeaturesEXT",
+                        &structs->buffer_address_features_ext) &&
+         visitor->Visit("bufferDeviceAddressFeaturesEXT",
+                        &structs->buffer_device_address_features_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor, VkJsonKHRLineRasterization* structs) {
-  return visitor->Visit("lineRasterizationFeaturesKHR",
-                        &structs->line_rasterization_features_khr);
+inline bool Iterate(Visitor* visitor, VkJsonExtColorWriteEnable* structs) {
+  return visitor->Visit("colorWriteEnableFeaturesEXT",
+                        &structs->color_write_enable_features_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor, VkJsonExtLineRasterization* structs) {
-  return visitor->Visit("lineRasterizationFeaturesEXT",
-                        &structs->line_rasterization_features_ext);
+inline bool Iterate(Visitor* visitor, VkJsonExtConditionalRendering* structs) {
+  return visitor->Visit("conditionalRenderingFeaturesEXT",
+                        &structs->conditional_rendering_features_ext);
 }
 
 template <typename Visitor>
 inline bool Iterate(Visitor* visitor,
-                    VkJsonExtPrimitivesGeneratedQuery* structs) {
-  return visitor->Visit("primitivesGeneratedQueryFeaturesEXT",
-                        &structs->primitives_generated_query_features_ext);
+                    VkJsonExtConservativeRasterization* structs) {
+  return visitor->Visit("conservativeRasterizationPropertiesEXT",
+                        &structs->conservative_rasterization_properties_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor, VkJsonKHRShaderFloatControls* structs) {
-  return visitor->Visit("floatControlsPropertiesKHR",
-                        &structs->float_controls_properties_khr);
+inline bool Iterate(Visitor* visitor, VkJsonExtCustomBorderColor* structs) {
+  return visitor->Visit("customBorderColorPropertiesEXT",
+                        &structs->custom_border_color_properties_ext) &&
+         visitor->Visit("customBorderColorFeaturesEXT",
+                        &structs->custom_border_color_features_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor, VkJsonKHRDriverProperties* structs) {
-  return visitor->Visit("driverPropertiesKHR", &structs->driver_properties_khr);
+inline bool Iterate(Visitor* visitor, VkJsonExtDepthBiasControl* structs) {
+  return visitor->Visit("depthBiasControlFeaturesEXT",
+                        &structs->depth_bias_control_features_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor,
-                    VkPhysicalDeviceFloatControlsProperties* properties) {
-  return
+inline bool Iterate(Visitor* visitor, VkJsonExtDepthClampZeroOne* structs) {
+  return visitor->Visit("depthClampZeroOneFeaturesEXT",
+                        &structs->depth_clamp_zero_one_features_ext);
+}
 
-      visitor->Visit("denormBehaviorIndependence",
-                     &properties->denormBehaviorIndependence) &&
-      visitor->Visit("roundingModeIndependence",
-                     &properties->roundingModeIndependence) &&
-      visitor->Visit("shaderSignedZeroInfNanPreserveFloat16",
-                     &properties->shaderSignedZeroInfNanPreserveFloat16) &&
-      visitor->Visit("shaderSignedZeroInfNanPreserveFloat32",
-                     &properties->shaderSignedZeroInfNanPreserveFloat32) &&
-      visitor->Visit("shaderSignedZeroInfNanPreserveFloat64",
-                     &properties->shaderSignedZeroInfNanPreserveFloat64) &&
-      visitor->Visit("shaderDenormPreserveFloat16",
-                     &properties->shaderDenormPreserveFloat16) &&
-      visitor->Visit("shaderDenormPreserveFloat32",
-                     &properties->shaderDenormPreserveFloat32) &&
-      visitor->Visit("shaderDenormPreserveFloat64",
-                     &properties->shaderDenormPreserveFloat64) &&
-      visitor->Visit("shaderDenormFlushToZeroFloat16",
-                     &properties->shaderDenormFlushToZeroFloat16) &&
-      visitor->Visit("shaderDenormFlushToZeroFloat32",
-                     &properties->shaderDenormFlushToZeroFloat32) &&
-      visitor->Visit("shaderDenormFlushToZeroFloat64",
-                     &properties->shaderDenormFlushToZeroFloat64) &&
-      visitor->Visit("shaderRoundingModeRTEFloat16",
-                     &properties->shaderRoundingModeRTEFloat16) &&
-      visitor->Visit("shaderRoundingModeRTEFloat32",
-                     &properties->shaderRoundingModeRTEFloat32) &&
-      visitor->Visit("shaderRoundingModeRTEFloat64",
-                     &properties->shaderRoundingModeRTEFloat64) &&
-      visitor->Visit("shaderRoundingModeRTZFloat16",
-                     &properties->shaderRoundingModeRTZFloat16) &&
-      visitor->Visit("shaderRoundingModeRTZFloat32",
-                     &properties->shaderRoundingModeRTZFloat32) &&
-      visitor->Visit("shaderRoundingModeRTZFloat64",
-                     &properties->shaderRoundingModeRTZFloat64);
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtDepthClipControl* structs) {
+  return visitor->Visit("depthClipControlFeaturesEXT",
+                        &structs->depth_clip_control_features_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor, VkPhysicalDeviceProperties* properties) {
-  return
-
-      visitor->Visit("apiVersion", &properties->apiVersion) &&
-      visitor->Visit("driverVersion", &properties->driverVersion) &&
-      visitor->Visit("vendorID", &properties->vendorID) &&
-      visitor->Visit("deviceID", &properties->deviceID) &&
-      visitor->Visit("deviceType", &properties->deviceType) &&
-      visitor->Visit("deviceName", &properties->deviceName) &&
-      visitor->Visit("pipelineCacheUUID", &properties->pipelineCacheUUID) &&
-      visitor->Visit("limits", &properties->limits) &&
-      visitor->Visit("sparseProperties", &properties->sparseProperties);
+inline bool Iterate(Visitor* visitor, VkJsonExtDepthClipEnable* structs) {
+  return visitor->Visit("depthClipEnableFeaturesEXT",
+                        &structs->depth_clip_enable_features_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor,
-                    VkPhysicalDeviceMemoryProperties* properties) {
-  return
-
-      visitor->Visit("memoryTypeCount", &properties->memoryTypeCount) &&
-      visitor->VisitArray("memoryTypes", properties->memoryTypeCount,
-                          &properties->memoryTypes) &&
-      visitor->Visit("memoryHeapCount", &properties->memoryHeapCount) &&
-      visitor->VisitArray("memoryHeaps", properties->memoryHeapCount,
-                          &properties->memoryHeaps);
+inline bool Iterate(Visitor* visitor, VkJsonExtDescriptorBuffer* structs) {
+  return visitor->Visit("descriptorBufferPropertiesEXT",
+                        &structs->descriptor_buffer_properties_ext) &&
+         visitor->Visit(
+             "descriptorBufferDensityMapPropertiesEXT",
+             &structs->descriptor_buffer_density_map_properties_ext) &&
+         visitor->Visit("descriptorBufferFeaturesEXT",
+                        &structs->descriptor_buffer_features_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor,
-                    VkPhysicalDeviceSubgroupProperties* properties) {
-  return
-
-      visitor->Visit("subgroupSize", &properties->subgroupSize) &&
-      visitor->Visit("supportedStages", &properties->supportedStages) &&
-      visitor->Visit("supportedOperations", &properties->supportedOperations) &&
-      visitor->Visit("quadOperationsInAllStages",
-                     &properties->quadOperationsInAllStages);
+inline bool Iterate(Visitor* visitor, VkJsonExtDescriptorIndexing* structs) {
+  return visitor->Visit("descriptorIndexingFeaturesEXT",
+                        &structs->descriptor_indexing_features_ext) &&
+         visitor->Visit("descriptorIndexingPropertiesEXT",
+                        &structs->descriptor_indexing_properties_ext);
 }
 
 template <typename Visitor>
 inline bool Iterate(Visitor* visitor,
-                    VkPhysicalDevicePointClippingProperties* properties) {
-  return
-
-      visitor->Visit("pointClippingBehavior",
-                     &properties->pointClippingBehavior);
+                    VkJsonExtDeviceAddressBindingReport* structs) {
+  return visitor->Visit("addressBindingReportFeaturesEXT",
+                        &structs->address_binding_report_features_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor,
-                    VkPhysicalDeviceMultiviewProperties* properties) {
-  return
-
-      visitor->Visit("maxMultiviewViewCount",
-                     &properties->maxMultiviewViewCount) &&
-      visitor->Visit("maxMultiviewInstanceIndex",
-                     &properties->maxMultiviewInstanceIndex);
+inline bool Iterate(Visitor* visitor, VkJsonExtDeviceFault* structs) {
+  return visitor->Visit("faultFeaturesEXT", &structs->fault_features_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor,
-                    VkPhysicalDeviceIDProperties* properties) {
-  return
+inline bool Iterate(Visitor* visitor, VkJsonExtDeviceMemoryReport* structs) {
+  return visitor->Visit("deviceMemoryReportFeaturesEXT",
+                        &structs->device_memory_report_features_ext);
+}
 
-      visitor->Visit("deviceUUID", &properties->deviceUUID) &&
-      visitor->Visit("driverUUID", &properties->driverUUID) &&
-      visitor->Visit("deviceLUID", &properties->deviceLUID) &&
-      visitor->Visit("deviceNodeMask", &properties->deviceNodeMask) &&
-      visitor->Visit("deviceLUIDValid", &properties->deviceLUIDValid);
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtDiscardRectangles* structs) {
+  return visitor->Visit("discardRectanglePropertiesEXT",
+                        &structs->discard_rectangle_properties_ext);
 }
 
 template <typename Visitor>
 inline bool Iterate(Visitor* visitor,
-                    VkPhysicalDeviceMaintenance3Properties* properties) {
-  return
+                    VkJsonExtDynamicRenderingUnusedAttachments* structs) {
+  return visitor->Visit(
+      "dynamicRenderingUnusedAttachmentsFeaturesEXT",
+      &structs->dynamic_rendering_unused_attachments_features_ext);
+}
 
-      visitor->Visit("maxPerSetDescriptors",
-                     &properties->maxPerSetDescriptors) &&
-      visitor->Visit("maxMemoryAllocationSize",
-                     &properties->maxMemoryAllocationSize);
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtExtendedDynamicState* structs) {
+  return visitor->Visit("extendedDynamicStateFeaturesEXT",
+                        &structs->extended_dynamic_state_features_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor,
-                    VkPhysicalDeviceSparseProperties* properties) {
-  return
+inline bool Iterate(Visitor* visitor, VkJsonExtExtendedDynamicState2* structs) {
+  return visitor->Visit("extendedDynamicState2FeaturesEXT",
+                        &structs->extended_dynamic_state2_features_ext);
+}
 
-      visitor->Visit("residencyStandard2DBlockShape",
-                     &properties->residencyStandard2DBlockShape) &&
-      visitor->Visit("residencyStandard2DMultisampleBlockShape",
-                     &properties->residencyStandard2DMultisampleBlockShape) &&
-      visitor->Visit("residencyStandard3DBlockShape",
-                     &properties->residencyStandard3DBlockShape) &&
-      visitor->Visit("residencyAlignedMipSize",
-                     &properties->residencyAlignedMipSize) &&
-      visitor->Visit("residencyNonResidentStrict",
-                     &properties->residencyNonResidentStrict);
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtExtendedDynamicState3* structs) {
+  return visitor->Visit("extendedDynamicState3FeaturesEXT",
+                        &structs->extended_dynamic_state3_features_ext) &&
+         visitor->Visit("extendedDynamicState3PropertiesEXT",
+                        &structs->extended_dynamic_state3_properties_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor, VkImageFormatProperties* properties) {
-  return
+inline bool Iterate(Visitor* visitor, VkJsonExtExternalMemoryHost* structs) {
+  return visitor->Visit("externalMemoryHostPropertiesEXT",
+                        &structs->external_memory_host_properties_ext);
+}
 
-      visitor->Visit("maxExtent", &properties->maxExtent) &&
-      visitor->Visit("maxMipLevels", &properties->maxMipLevels) &&
-      visitor->Visit("maxArrayLayers", &properties->maxArrayLayers) &&
-      visitor->Visit("sampleCounts", &properties->sampleCounts) &&
-      visitor->Visit("maxResourceSize", &properties->maxResourceSize);
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtFragmentDensityMap* structs) {
+  return visitor->Visit("fragmentDensityMapFeaturesEXT",
+                        &structs->fragment_density_map_features_ext) &&
+         visitor->Visit("fragmentDensityMapPropertiesEXT",
+                        &structs->fragment_density_map_properties_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor, VkQueueFamilyProperties* properties) {
-  return
+inline bool Iterate(Visitor* visitor, VkJsonExtFragmentDensityMap2* structs) {
+  return visitor->Visit("fragmentDensityMap2FeaturesEXT",
+                        &structs->fragment_density_map2_features_ext) &&
+         visitor->Visit("fragmentDensityMap2PropertiesEXT",
+                        &structs->fragment_density_map2_properties_ext);
+}
 
-      visitor->Visit("queueFlags", &properties->queueFlags) &&
-      visitor->Visit("queueCount", &properties->queueCount) &&
-      visitor->Visit("timestampValidBits", &properties->timestampValidBits) &&
-      visitor->Visit("minImageTransferGranularity",
-                     &properties->minImageTransferGranularity);
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonExtFragmentShaderInterlock* structs) {
+  return visitor->Visit("fragmentShaderInterlockFeaturesEXT",
+                        &structs->fragment_shader_interlock_features_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor, VkExtensionProperties* properties) {
-  return
+inline bool Iterate(Visitor* visitor, VkJsonExtFrameBoundary* structs) {
+  return visitor->Visit("frameBoundaryFeaturesEXT",
+                        &structs->frame_boundary_features_ext);
+}
 
-      visitor->Visit("extensionName", &properties->extensionName) &&
-      visitor->Visit("specVersion", &properties->specVersion);
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtGlobalPriorityQuery* structs) {
+  return visitor->Visit("globalPriorityQueryFeaturesEXT",
+                        &structs->global_priority_query_features_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor, VkLayerProperties* properties) {
-  return
+inline bool Iterate(Visitor* visitor,
+                    VkJsonExtGraphicsPipelineLibrary* structs) {
+  return visitor->Visit("graphicsPipelineLibraryFeaturesEXT",
+                        &structs->graphics_pipeline_library_features_ext) &&
+         visitor->Visit("graphicsPipelineLibraryPropertiesEXT",
+                        &structs->graphics_pipeline_library_properties_ext);
+}
 
-      visitor->Visit("layerName", &properties->layerName) &&
-      visitor->Visit("specVersion", &properties->specVersion) &&
-      visitor->Visit("implementationVersion",
-                     &properties->implementationVersion) &&
-      visitor->Visit("description", &properties->description);
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtHostImageCopy* structs) {
+  return visitor->Visit("hostImageCopyFeaturesEXT",
+                        &structs->host_image_copy_features_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor, VkFormatProperties* properties) {
-  return
+inline bool Iterate(Visitor* visitor, VkJsonExtHostQueryReset* structs) {
+  return visitor->Visit("hostQueryResetFeaturesEXT",
+                        &structs->host_query_reset_features_ext);
+}
 
-      visitor->Visit("linearTilingFeatures",
-                     &properties->linearTilingFeatures) &&
-      visitor->Visit("optimalTilingFeatures",
-                     &properties->optimalTilingFeatures) &&
-      visitor->Visit("bufferFeatures", &properties->bufferFeatures);
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtImage2dViewOf3d* structs) {
+  return visitor->Visit("image2DViewOf3DFeaturesEXT",
+                        &structs->image_2d_view_of_3d_features_ext);
 }
 
 template <typename Visitor>
 inline bool Iterate(Visitor* visitor,
-                    VkPhysicalDeviceVariablePointersFeatures* features) {
-  return
-
-      visitor->Visit("variablePointersStorageBuffer",
-                     &features->variablePointersStorageBuffer) &&
-      visitor->Visit("variablePointers", &features->variablePointers);
+                    VkJsonExtImageCompressionControl* structs) {
+  return visitor->Visit("imageCompressionControlFeaturesEXT",
+                        &structs->image_compression_control_features_ext);
 }
 
 template <typename Visitor>
 inline bool Iterate(Visitor* visitor,
-                    VkPhysicalDeviceShaderFloat16Int8Features* features) {
-  return
-
-      visitor->Visit("shaderFloat16", &features->shaderFloat16) &&
-      visitor->Visit("shaderInt8", &features->shaderInt8);
+                    VkJsonExtImageCompressionControlSwapchain* structs) {
+  return visitor->Visit(
+      "imageCompressionControlSwapchainFeaturesEXT",
+      &structs->image_compression_control_swapchain_features_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor,
-                    VkPhysicalDeviceImage2DViewOf3DFeaturesEXT* features) {
-  return
+inline bool Iterate(Visitor* visitor, VkJsonExtImageRobustness* structs) {
+  return visitor->Visit("imageRobustnessFeaturesEXT",
+                        &structs->image_robustness_features_ext);
+}
 
-      visitor->Visit("image2DViewOf3D", &features->image2DViewOf3D) &&
-      visitor->Visit("sampler2DViewOf3D", &features->sampler2DViewOf3D);
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtImageSlicedViewOf3d* structs) {
+  return visitor->Visit("imageSlicedViewOf3DFeaturesEXT",
+                        &structs->image_sliced_view_of_3d_features_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor,
-                    VkPhysicalDeviceCustomBorderColorFeaturesEXT* features) {
-  return
+inline bool Iterate(Visitor* visitor, VkJsonExtImageViewMinLod* structs) {
+  return visitor->Visit("imageViewMinLodFeaturesEXT",
+                        &structs->image_view_min_lod_features_ext);
+}
 
-      visitor->Visit("customBorderColors", &features->customBorderColors) &&
-      visitor->Visit("customBorderColorWithoutFormat",
-                     &features->customBorderColorWithoutFormat);
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtIndexTypeUint8* structs) {
+  return visitor->Visit("indexTypeUint8FeaturesEXT",
+                        &structs->index_type_uint8_features_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(
-    Visitor* visitor,
-    VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT* features) {
-  return
+inline bool Iterate(Visitor* visitor, VkJsonExtInlineUniformBlock* structs) {
+  return visitor->Visit("inlineUniformBlockFeaturesEXT",
+                        &structs->inline_uniform_block_features_ext) &&
+         visitor->Visit("inlineUniformBlockPropertiesEXT",
+                        &structs->inline_uniform_block_properties_ext);
+}
 
-      visitor->Visit("primitiveTopologyListRestart",
-                     &features->primitiveTopologyListRestart) &&
-      visitor->Visit("primitiveTopologyPatchListRestart",
-                     &features->primitiveTopologyPatchListRestart);
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtLegacyDithering* structs) {
+  return visitor->Visit("legacyDitheringFeaturesEXT",
+                        &structs->legacy_dithering_features_ext);
 }
 
 template <typename Visitor>
 inline bool Iterate(Visitor* visitor,
-                    VkPhysicalDeviceProvokingVertexFeaturesEXT* features) {
-  return
+                    VkJsonExtLegacyVertexAttributes* structs) {
+  return visitor->Visit("legacyVertexAttributesFeaturesEXT",
+                        &structs->legacy_vertex_attributes_features_ext) &&
+         visitor->Visit("legacyVertexAttributesPropertiesEXT",
+                        &structs->legacy_vertex_attributes_properties_ext);
+}
 
-      visitor->Visit("provokingVertexLast", &features->provokingVertexLast) &&
-      visitor->Visit("transformFeedbackPreservesProvokingVertex",
-                     &features->transformFeedbackPreservesProvokingVertex);
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtLineRasterization* structs) {
+  return visitor->Visit("lineRasterizationFeaturesEXT",
+                        &structs->line_rasterization_features_ext) &&
+         visitor->Visit("lineRasterizationPropertiesEXT",
+                        &structs->line_rasterization_properties_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor,
-                    VkPhysicalDeviceIndexTypeUint8Features* features) {
-  return
+inline bool Iterate(Visitor* visitor, VkJsonExtMapMemoryPlaced* structs) {
+  return visitor->Visit("mapMemoryPlacedFeaturesEXT",
+                        &structs->map_memory_placed_features_ext) &&
+         visitor->Visit("mapMemoryPlacedPropertiesEXT",
+                        &structs->map_memory_placed_properties_ext);
+}
 
-      visitor->Visit("indexTypeUint8", &features->indexTypeUint8);
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtMemoryPriority* structs) {
+  return visitor->Visit("memoryPriorityFeaturesEXT",
+                        &structs->memory_priority_features_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor,
-                    VkPhysicalDeviceVertexAttributeDivisorFeatures* features) {
-  return
+inline bool Iterate(Visitor* visitor, VkJsonExtMeshShader* structs) {
+  return visitor->Visit("meshShaderFeaturesEXT",
+                        &structs->mesh_shader_features_ext) &&
+         visitor->Visit("meshShaderPropertiesEXT",
+                        &structs->mesh_shader_properties_ext);
+}
 
-      visitor->Visit("vertexAttributeInstanceRateDivisor",
-                     &features->vertexAttributeInstanceRateDivisor) &&
-      visitor->Visit("vertexAttributeInstanceRateZeroDivisor",
-                     &features->vertexAttributeInstanceRateZeroDivisor);
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtMultiDraw* structs) {
+  return visitor->Visit("multiDrawFeaturesEXT",
+                        &structs->multi_draw_features_ext) &&
+         visitor->Visit("multiDrawPropertiesEXT",
+                        &structs->multi_draw_properties_ext);
 }
 
 template <typename Visitor>
 inline bool Iterate(Visitor* visitor,
-                    VkPhysicalDeviceTransformFeedbackFeaturesEXT* features) {
-  return
-
-      visitor->Visit("transformFeedback", &features->transformFeedback) &&
-      visitor->Visit("geometryStreams", &features->geometryStreams);
+                    VkJsonExtMultisampledRenderToSingleSampled* structs) {
+  return visitor->Visit(
+      "multisampledRenderToSingleSampledFeaturesEXT",
+      &structs->multisampled_render_to_single_sampled_features_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(
-    Visitor* visitor,
-    VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR* features) {
-  return
-
-      visitor->Visit("shaderSubgroupUniformControlFlow",
-                     &features->shaderSubgroupUniformControlFlow);
+inline bool Iterate(Visitor* visitor, VkJsonExtMutableDescriptorType* structs) {
+  return visitor->Visit("mutableDescriptorTypeFeaturesEXT",
+                        &structs->mutable_descriptor_type_features_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(
-    Visitor* visitor,
-    VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures* features) {
-  return
-
-      visitor->Visit("shaderSubgroupExtendedTypes",
-                     &features->shaderSubgroupExtendedTypes);
+inline bool Iterate(Visitor* visitor, VkJsonExtNestedCommandBuffer* structs) {
+  return visitor->Visit("nestedCommandBufferFeaturesEXT",
+                        &structs->nested_command_buffer_features_ext) &&
+         visitor->Visit("nestedCommandBufferPropertiesEXT",
+                        &structs->nested_command_buffer_properties_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor,
-                    VkPhysicalDevice8BitStorageFeatures* features) {
-  return
+inline bool Iterate(Visitor* visitor, VkJsonExtNonSeamlessCubeMap* structs) {
+  return visitor->Visit("nonSeamlessCubeMapFeaturesEXT",
+                        &structs->non_seamless_cube_map_features_ext);
+}
 
-      visitor->Visit("storageBuffer8BitAccess",
-                     &features->storageBuffer8BitAccess) &&
-      visitor->Visit("uniformAndStorageBuffer8BitAccess",
-                     &features->uniformAndStorageBuffer8BitAccess) &&
-      visitor->Visit("storagePushConstant8", &features->storagePushConstant8);
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtOpacityMicromap* structs) {
+  return visitor->Visit("opacityMicromapFeaturesEXT",
+                        &structs->opacity_micromap_features_ext) &&
+         visitor->Visit("opacityMicromapPropertiesEXT",
+                        &structs->opacity_micromap_properties_ext);
 }
 
 template <typename Visitor>
 inline bool Iterate(Visitor* visitor,
-                    VkPhysicalDeviceShaderIntegerDotProductFeatures* features) {
-  return
-
-      visitor->Visit("shaderIntegerDotProduct",
-                     &features->shaderIntegerDotProduct);
+                    VkJsonExtPageableDeviceLocalMemory* structs) {
+  return visitor->Visit("pageableDeviceLocalMemoryFeaturesEXT",
+                        &structs->pageable_device_local_memory_features_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(
-    Visitor* visitor,
-    VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG* features) {
-  return
+inline bool Iterate(Visitor* visitor, VkJsonExtPciBusInfo* structs) {
+  return visitor->Visit("pCIBusInfoPropertiesEXT",
+                        &structs->pci_bus_info_properties_ext);
+}
 
-      visitor->Visit("relaxedLineRasterization",
-                     &features->relaxedLineRasterization);
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtPhysicalDeviceDrm* structs) {
+  return visitor->Visit("drmPropertiesEXT", &structs->drm_properties_ext);
 }
 
 template <typename Visitor>
 inline bool Iterate(Visitor* visitor,
-                    VkPhysicalDeviceLineRasterizationFeatures* features) {
-  return
-
-      visitor->Visit("rectangularLines", &features->rectangularLines) &&
-      visitor->Visit("bresenhamLines", &features->bresenhamLines) &&
-      visitor->Visit("smoothLines", &features->smoothLines) &&
-      visitor->Visit("stippledRectangularLines",
-                     &features->stippledRectangularLines) &&
-      visitor->Visit("stippledBresenhamLines",
-                     &features->stippledBresenhamLines) &&
-      visitor->Visit("stippledSmoothLines", &features->stippledSmoothLines);
+                    VkJsonExtPipelineCreationCacheControl* structs) {
+  return visitor->Visit("pipelineCreationCacheControlFeaturesEXT",
+                        &structs->pipeline_creation_cache_control_features_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(
-    Visitor* visitor,
-    VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT* features) {
-  return
+inline bool Iterate(Visitor* visitor,
+                    VkJsonExtPipelineLibraryGroupHandles* structs) {
+  return visitor->Visit("pipelineLibraryGroupHandlesFeaturesEXT",
+                        &structs->pipeline_library_group_handles_features_ext);
+}
 
-      visitor->Visit("primitivesGeneratedQuery",
-                     &features->primitivesGeneratedQuery) &&
-      visitor->Visit(
-          "primitivesGeneratedQueryWithRasterizerDiscard",
-          &features->primitivesGeneratedQueryWithRasterizerDiscard) &&
-      visitor->Visit("primitivesGeneratedQueryWithNonZeroStreams",
-                     &features->primitivesGeneratedQueryWithNonZeroStreams);
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtPipelineProperties* structs) {
+  return visitor->Visit("pipelinePropertiesFeaturesEXT",
+                        &structs->pipeline_properties_features_ext);
 }
 
 template <typename Visitor>
 inline bool Iterate(Visitor* visitor,
-                    VkPhysicalDevice16BitStorageFeatures* features) {
-  return
+                    VkJsonExtPipelineProtectedAccess* structs) {
+  return visitor->Visit("pipelineProtectedAccessFeaturesEXT",
+                        &structs->pipeline_protected_access_features_ext);
+}
 
-      visitor->Visit("storageBuffer16BitAccess",
-                     &features->storageBuffer16BitAccess) &&
-      visitor->Visit("uniformAndStorageBuffer16BitAccess",
-                     &features->uniformAndStorageBuffer16BitAccess) &&
-      visitor->Visit("storagePushConstant16",
-                     &features->storagePushConstant16) &&
-      visitor->Visit("storageInputOutput16", &features->storageInputOutput16);
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtPipelineRobustness* structs) {
+  return visitor->Visit("pipelineRobustnessFeaturesEXT",
+                        &structs->pipeline_robustness_features_ext) &&
+         visitor->Visit("pipelineRobustnessPropertiesEXT",
+                        &structs->pipeline_robustness_properties_ext);
 }
 
 template <typename Visitor>
 inline bool Iterate(Visitor* visitor,
-                    VkPhysicalDeviceMultiviewFeatures* features) {
-  return
-
-      visitor->Visit("multiview", &features->multiview) &&
-      visitor->Visit("multiviewGeometryShader",
-                     &features->multiviewGeometryShader) &&
-      visitor->Visit("multiviewTessellationShader",
-                     &features->multiviewTessellationShader);
+                    VkJsonExtPrimitiveTopologyListRestart* structs) {
+  return visitor->Visit("primitiveTopologyListRestartFeaturesEXT",
+                        &structs->primitive_topology_list_restart_features_ext);
 }
 
 template <typename Visitor>
 inline bool Iterate(Visitor* visitor,
-                    VkPhysicalDeviceProtectedMemoryFeatures* features) {
-  return
+                    VkJsonExtPrimitivesGeneratedQuery* structs) {
+  return visitor->Visit("primitivesGeneratedQueryFeaturesEXT",
+                        &structs->primitives_generated_query_features_ext);
+}
 
-      visitor->Visit("protectedMemory", &features->protectedMemory);
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtPrivateData* structs) {
+  return visitor->Visit("privateDataFeaturesEXT",
+                        &structs->private_data_features_ext);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtProvokingVertex* structs) {
+  return visitor->Visit("provokingVertexFeaturesEXT",
+                        &structs->provoking_vertex_features_ext) &&
+         visitor->Visit("provokingVertexPropertiesEXT",
+                        &structs->provoking_vertex_properties_ext);
 }
 
 template <typename Visitor>
 inline bool Iterate(Visitor* visitor,
-                    VkPhysicalDeviceSamplerYcbcrConversionFeatures* features) {
-  return
+                    VkJsonExtRasterizationOrderAttachmentAccess* structs) {
+  return visitor->Visit(
+      "rasterizationOrderAttachmentAccessFeaturesEXT",
+      &structs->rasterization_order_attachment_access_features_ext);
+}
 
-      visitor->Visit("samplerYcbcrConversion",
-                     &features->samplerYcbcrConversion);
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtRgba10x6Formats* structs) {
+  return visitor->Visit("rGBA10X6FormatsFeaturesEXT",
+                        &structs->rgba10_x6_formats_features_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor,
-                    VkPhysicalDeviceShaderDrawParameterFeatures* features) {
-  return
+inline bool Iterate(Visitor* visitor, VkJsonExtRobustness2* structs) {
+  return visitor->Visit("robustness2FeaturesEXT",
+                        &structs->robustness2_features_ext) &&
+         visitor->Visit("robustness2PropertiesEXT",
+                        &structs->robustness2_properties_ext);
+}
 
-      visitor->Visit("shaderDrawParameters", &features->shaderDrawParameters);
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtSampleLocations* structs) {
+  return visitor->Visit("sampleLocationsPropertiesEXT",
+                        &structs->sample_locations_properties_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor, VkPhysicalDeviceLimits* limits) {
-  return
+inline bool Iterate(Visitor* visitor, VkJsonExtSamplerFilterMinmax* structs) {
+  return visitor->Visit("samplerFilterMinmaxPropertiesEXT",
+                        &structs->sampler_filter_minmax_properties_ext);
+}
 
-      visitor->Visit("maxImageDimension1D", &limits->maxImageDimension1D) &&
-      visitor->Visit("maxImageDimension2D", &limits->maxImageDimension2D) &&
-      visitor->Visit("maxImageDimension3D", &limits->maxImageDimension3D) &&
-      visitor->Visit("maxImageDimensionCube", &limits->maxImageDimensionCube) &&
-      visitor->Visit("maxImageArrayLayers", &limits->maxImageArrayLayers) &&
-      visitor->Visit("maxTexelBufferElements",
-                     &limits->maxTexelBufferElements) &&
-      visitor->Visit("maxUniformBufferRange", &limits->maxUniformBufferRange) &&
-      visitor->Visit("maxStorageBufferRange", &limits->maxStorageBufferRange) &&
-      visitor->Visit("maxPushConstantsSize", &limits->maxPushConstantsSize) &&
-      visitor->Visit("maxMemoryAllocationCount",
-                     &limits->maxMemoryAllocationCount) &&
-      visitor->Visit("maxSamplerAllocationCount",
-                     &limits->maxSamplerAllocationCount) &&
-      visitor->Visit("bufferImageGranularity",
-                     &limits->bufferImageGranularity) &&
-      visitor->Visit("sparseAddressSpaceSize",
-                     &limits->sparseAddressSpaceSize) &&
-      visitor->Visit("maxBoundDescriptorSets",
-                     &limits->maxBoundDescriptorSets) &&
-      visitor->Visit("maxPerStageDescriptorSamplers",
-                     &limits->maxPerStageDescriptorSamplers) &&
-      visitor->Visit("maxPerStageDescriptorUniformBuffers",
-                     &limits->maxPerStageDescriptorUniformBuffers) &&
-      visitor->Visit("maxPerStageDescriptorStorageBuffers",
-                     &limits->maxPerStageDescriptorStorageBuffers) &&
-      visitor->Visit("maxPerStageDescriptorSampledImages",
-                     &limits->maxPerStageDescriptorSampledImages) &&
-      visitor->Visit("maxPerStageDescriptorStorageImages",
-                     &limits->maxPerStageDescriptorStorageImages) &&
-      visitor->Visit("maxPerStageDescriptorInputAttachments",
-                     &limits->maxPerStageDescriptorInputAttachments) &&
-      visitor->Visit("maxPerStageResources", &limits->maxPerStageResources) &&
-      visitor->Visit("maxDescriptorSetSamplers",
-                     &limits->maxDescriptorSetSamplers) &&
-      visitor->Visit("maxDescriptorSetUniformBuffers",
-                     &limits->maxDescriptorSetUniformBuffers) &&
-      visitor->Visit("maxDescriptorSetUniformBuffersDynamic",
-                     &limits->maxDescriptorSetUniformBuffersDynamic) &&
-      visitor->Visit("maxDescriptorSetStorageBuffers",
-                     &limits->maxDescriptorSetStorageBuffers) &&
-      visitor->Visit("maxDescriptorSetStorageBuffersDynamic",
-                     &limits->maxDescriptorSetStorageBuffersDynamic) &&
-      visitor->Visit("maxDescriptorSetSampledImages",
-                     &limits->maxDescriptorSetSampledImages) &&
-      visitor->Visit("maxDescriptorSetStorageImages",
-                     &limits->maxDescriptorSetStorageImages) &&
-      visitor->Visit("maxDescriptorSetInputAttachments",
-                     &limits->maxDescriptorSetInputAttachments) &&
-      visitor->Visit("maxVertexInputAttributes",
-                     &limits->maxVertexInputAttributes) &&
-      visitor->Visit("maxVertexInputBindings",
-                     &limits->maxVertexInputBindings) &&
-      visitor->Visit("maxVertexInputAttributeOffset",
-                     &limits->maxVertexInputAttributeOffset) &&
-      visitor->Visit("maxVertexInputBindingStride",
-                     &limits->maxVertexInputBindingStride) &&
-      visitor->Visit("maxVertexOutputComponents",
-                     &limits->maxVertexOutputComponents) &&
-      visitor->Visit("maxTessellationGenerationLevel",
-                     &limits->maxTessellationGenerationLevel) &&
-      visitor->Visit("maxTessellationPatchSize",
-                     &limits->maxTessellationPatchSize) &&
-      visitor->Visit("maxTessellationControlPerVertexInputComponents",
-                     &limits->maxTessellationControlPerVertexInputComponents) &&
-      visitor->Visit(
-          "maxTessellationControlPerVertexOutputComponents",
-          &limits->maxTessellationControlPerVertexOutputComponents) &&
-      visitor->Visit("maxTessellationControlPerPatchOutputComponents",
-                     &limits->maxTessellationControlPerPatchOutputComponents) &&
-      visitor->Visit("maxTessellationControlTotalOutputComponents",
-                     &limits->maxTessellationControlTotalOutputComponents) &&
-      visitor->Visit("maxTessellationEvaluationInputComponents",
-                     &limits->maxTessellationEvaluationInputComponents) &&
-      visitor->Visit("maxTessellationEvaluationOutputComponents",
-                     &limits->maxTessellationEvaluationOutputComponents) &&
-      visitor->Visit("maxGeometryShaderInvocations",
-                     &limits->maxGeometryShaderInvocations) &&
-      visitor->Visit("maxGeometryInputComponents",
-                     &limits->maxGeometryInputComponents) &&
-      visitor->Visit("maxGeometryOutputComponents",
-                     &limits->maxGeometryOutputComponents) &&
-      visitor->Visit("maxGeometryOutputVertices",
-                     &limits->maxGeometryOutputVertices) &&
-      visitor->Visit("maxGeometryTotalOutputComponents",
-                     &limits->maxGeometryTotalOutputComponents) &&
-      visitor->Visit("maxFragmentInputComponents",
-                     &limits->maxFragmentInputComponents) &&
-      visitor->Visit("maxFragmentOutputAttachments",
-                     &limits->maxFragmentOutputAttachments) &&
-      visitor->Visit("maxFragmentDualSrcAttachments",
-                     &limits->maxFragmentDualSrcAttachments) &&
-      visitor->Visit("maxFragmentCombinedOutputResources",
-                     &limits->maxFragmentCombinedOutputResources) &&
-      visitor->Visit("maxComputeSharedMemorySize",
-                     &limits->maxComputeSharedMemorySize) &&
-      visitor->Visit("maxComputeWorkGroupCount",
-                     &limits->maxComputeWorkGroupCount) &&
-      visitor->Visit("maxComputeWorkGroupInvocations",
-                     &limits->maxComputeWorkGroupInvocations) &&
-      visitor->Visit("maxComputeWorkGroupSize",
-                     &limits->maxComputeWorkGroupSize) &&
-      visitor->Visit("subPixelPrecisionBits", &limits->subPixelPrecisionBits) &&
-      visitor->Visit("subTexelPrecisionBits", &limits->subTexelPrecisionBits) &&
-      visitor->Visit("mipmapPrecisionBits", &limits->mipmapPrecisionBits) &&
-      visitor->Visit("maxDrawIndexedIndexValue",
-                     &limits->maxDrawIndexedIndexValue) &&
-      visitor->Visit("maxDrawIndirectCount", &limits->maxDrawIndirectCount) &&
-      visitor->Visit("maxSamplerLodBias", &limits->maxSamplerLodBias) &&
-      visitor->Visit("maxSamplerAnisotropy", &limits->maxSamplerAnisotropy) &&
-      visitor->Visit("maxViewports", &limits->maxViewports) &&
-      visitor->Visit("maxViewportDimensions", &limits->maxViewportDimensions) &&
-      visitor->Visit("viewportBoundsRange", &limits->viewportBoundsRange) &&
-      visitor->Visit("viewportSubPixelBits", &limits->viewportSubPixelBits) &&
-      visitor->Visit("minMemoryMapAlignment", &limits->minMemoryMapAlignment) &&
-      visitor->Visit("minTexelBufferOffsetAlignment",
-                     &limits->minTexelBufferOffsetAlignment) &&
-      visitor->Visit("minUniformBufferOffsetAlignment",
-                     &limits->minUniformBufferOffsetAlignment) &&
-      visitor->Visit("minStorageBufferOffsetAlignment",
-                     &limits->minStorageBufferOffsetAlignment) &&
-      visitor->Visit("minTexelOffset", &limits->minTexelOffset) &&
-      visitor->Visit("maxTexelOffset", &limits->maxTexelOffset) &&
-      visitor->Visit("minTexelGatherOffset", &limits->minTexelGatherOffset) &&
-      visitor->Visit("maxTexelGatherOffset", &limits->maxTexelGatherOffset) &&
-      visitor->Visit("minInterpolationOffset",
-                     &limits->minInterpolationOffset) &&
-      visitor->Visit("maxInterpolationOffset",
-                     &limits->maxInterpolationOffset) &&
-      visitor->Visit("subPixelInterpolationOffsetBits",
-                     &limits->subPixelInterpolationOffsetBits) &&
-      visitor->Visit("maxFramebufferWidth", &limits->maxFramebufferWidth) &&
-      visitor->Visit("maxFramebufferHeight", &limits->maxFramebufferHeight) &&
-      visitor->Visit("maxFramebufferLayers", &limits->maxFramebufferLayers) &&
-      visitor->Visit("framebufferColorSampleCounts",
-                     &limits->framebufferColorSampleCounts) &&
-      visitor->Visit("framebufferDepthSampleCounts",
-                     &limits->framebufferDepthSampleCounts) &&
-      visitor->Visit("framebufferStencilSampleCounts",
-                     &limits->framebufferStencilSampleCounts) &&
-      visitor->Visit("framebufferNoAttachmentsSampleCounts",
-                     &limits->framebufferNoAttachmentsSampleCounts) &&
-      visitor->Visit("maxColorAttachments", &limits->maxColorAttachments) &&
-      visitor->Visit("sampledImageColorSampleCounts",
-                     &limits->sampledImageColorSampleCounts) &&
-      visitor->Visit("sampledImageIntegerSampleCounts",
-                     &limits->sampledImageIntegerSampleCounts) &&
-      visitor->Visit("sampledImageDepthSampleCounts",
-                     &limits->sampledImageDepthSampleCounts) &&
-      visitor->Visit("sampledImageStencilSampleCounts",
-                     &limits->sampledImageStencilSampleCounts) &&
-      visitor->Visit("storageImageSampleCounts",
-                     &limits->storageImageSampleCounts) &&
-      visitor->Visit("maxSampleMaskWords", &limits->maxSampleMaskWords) &&
-      visitor->Visit("timestampComputeAndGraphics",
-                     &limits->timestampComputeAndGraphics) &&
-      visitor->Visit("timestampPeriod", &limits->timestampPeriod) &&
-      visitor->Visit("maxClipDistances", &limits->maxClipDistances) &&
-      visitor->Visit("maxCullDistances", &limits->maxCullDistances) &&
-      visitor->Visit("maxCombinedClipAndCullDistances",
-                     &limits->maxCombinedClipAndCullDistances) &&
-      visitor->Visit("discreteQueuePriorities",
-                     &limits->discreteQueuePriorities) &&
-      visitor->Visit("pointSizeRange", &limits->pointSizeRange) &&
-      visitor->Visit("lineWidthRange", &limits->lineWidthRange) &&
-      visitor->Visit("pointSizeGranularity", &limits->pointSizeGranularity) &&
-      visitor->Visit("lineWidthGranularity", &limits->lineWidthGranularity) &&
-      visitor->Visit("strictLines", &limits->strictLines) &&
-      visitor->Visit("standardSampleLocations",
-                     &limits->standardSampleLocations) &&
-      visitor->Visit("optimalBufferCopyOffsetAlignment",
-                     &limits->optimalBufferCopyOffsetAlignment) &&
-      visitor->Visit("optimalBufferCopyRowPitchAlignment",
-                     &limits->optimalBufferCopyRowPitchAlignment) &&
-      visitor->Visit("nonCoherentAtomSize", &limits->nonCoherentAtomSize);
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtScalarBlockLayout* structs) {
+  return visitor->Visit("scalarBlockLayoutFeaturesEXT",
+                        &structs->scalar_block_layout_features_ext);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor, VkPhysicalDeviceFeatures* features) {
-  return
+inline bool Iterate(Visitor* visitor, VkJsonExtShaderAtomicFloat* structs) {
+  return visitor->Visit("shaderAtomicFloatFeaturesEXT",
+                        &structs->shader_atomic_float_features_ext);
+}
 
-      visitor->Visit("robustBufferAccess", &features->robustBufferAccess) &&
-      visitor->Visit("fullDrawIndexUint32", &features->fullDrawIndexUint32) &&
-      visitor->Visit("imageCubeArray", &features->imageCubeArray) &&
-      visitor->Visit("independentBlend", &features->independentBlend) &&
-      visitor->Visit("geometryShader", &features->geometryShader) &&
-      visitor->Visit("tessellationShader", &features->tessellationShader) &&
-      visitor->Visit("sampleRateShading", &features->sampleRateShading) &&
-      visitor->Visit("dualSrcBlend", &features->dualSrcBlend) &&
-      visitor->Visit("logicOp", &features->logicOp) &&
-      visitor->Visit("multiDrawIndirect", &features->multiDrawIndirect) &&
-      visitor->Visit("drawIndirectFirstInstance",
-                     &features->drawIndirectFirstInstance) &&
-      visitor->Visit("depthClamp", &features->depthClamp) &&
-      visitor->Visit("depthBiasClamp", &features->depthBiasClamp) &&
-      visitor->Visit("fillModeNonSolid", &features->fillModeNonSolid) &&
-      visitor->Visit("depthBounds", &features->depthBounds) &&
-      visitor->Visit("wideLines", &features->wideLines) &&
-      visitor->Visit("largePoints", &features->largePoints) &&
-      visitor->Visit("alphaToOne", &features->alphaToOne) &&
-      visitor->Visit("multiViewport", &features->multiViewport) &&
-      visitor->Visit("samplerAnisotropy", &features->samplerAnisotropy) &&
-      visitor->Visit("textureCompressionETC2",
-                     &features->textureCompressionETC2) &&
-      visitor->Visit("textureCompressionASTC_LDR",
-                     &features->textureCompressionASTC_LDR) &&
-      visitor->Visit("textureCompressionBC", &features->textureCompressionBC) &&
-      visitor->Visit("occlusionQueryPrecise",
-                     &features->occlusionQueryPrecise) &&
-      visitor->Visit("pipelineStatisticsQuery",
-                     &features->pipelineStatisticsQuery) &&
-      visitor->Visit("vertexPipelineStoresAndAtomics",
-                     &features->vertexPipelineStoresAndAtomics) &&
-      visitor->Visit("fragmentStoresAndAtomics",
-                     &features->fragmentStoresAndAtomics) &&
-      visitor->Visit("shaderTessellationAndGeometryPointSize",
-                     &features->shaderTessellationAndGeometryPointSize) &&
-      visitor->Visit("shaderImageGatherExtended",
-                     &features->shaderImageGatherExtended) &&
-      visitor->Visit("shaderStorageImageExtendedFormats",
-                     &features->shaderStorageImageExtendedFormats) &&
-      visitor->Visit("shaderStorageImageMultisample",
-                     &features->shaderStorageImageMultisample) &&
-      visitor->Visit("shaderStorageImageReadWithoutFormat",
-                     &features->shaderStorageImageReadWithoutFormat) &&
-      visitor->Visit("shaderStorageImageWriteWithoutFormat",
-                     &features->shaderStorageImageWriteWithoutFormat) &&
-      visitor->Visit("shaderUniformBufferArrayDynamicIndexing",
-                     &features->shaderUniformBufferArrayDynamicIndexing) &&
-      visitor->Visit("shaderSampledImageArrayDynamicIndexing",
-                     &features->shaderSampledImageArrayDynamicIndexing) &&
-      visitor->Visit("shaderStorageBufferArrayDynamicIndexing",
-                     &features->shaderStorageBufferArrayDynamicIndexing) &&
-      visitor->Visit("shaderStorageImageArrayDynamicIndexing",
-                     &features->shaderStorageImageArrayDynamicIndexing) &&
-      visitor->Visit("shaderClipDistance", &features->shaderClipDistance) &&
-      visitor->Visit("shaderCullDistance", &features->shaderCullDistance) &&
-      visitor->Visit("shaderFloat64", &features->shaderFloat64) &&
-      visitor->Visit("shaderInt64", &features->shaderInt64) &&
-      visitor->Visit("shaderInt16", &features->shaderInt16) &&
-      visitor->Visit("shaderResourceResidency",
-                     &features->shaderResourceResidency) &&
-      visitor->Visit("shaderResourceMinLod", &features->shaderResourceMinLod) &&
-      visitor->Visit("sparseBinding", &features->sparseBinding) &&
-      visitor->Visit("sparseResidencyBuffer",
-                     &features->sparseResidencyBuffer) &&
-      visitor->Visit("sparseResidencyImage2D",
-                     &features->sparseResidencyImage2D) &&
-      visitor->Visit("sparseResidencyImage3D",
-                     &features->sparseResidencyImage3D) &&
-      visitor->Visit("sparseResidency2Samples",
-                     &features->sparseResidency2Samples) &&
-      visitor->Visit("sparseResidency4Samples",
-                     &features->sparseResidency4Samples) &&
-      visitor->Visit("sparseResidency8Samples",
-                     &features->sparseResidency8Samples) &&
-      visitor->Visit("sparseResidency16Samples",
-                     &features->sparseResidency16Samples) &&
-      visitor->Visit("sparseResidencyAliased",
-                     &features->sparseResidencyAliased) &&
-      visitor->Visit("variableMultisampleRate",
-                     &features->variableMultisampleRate) &&
-      visitor->Visit("inheritedQueries", &features->inheritedQueries);
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtShaderAtomicFloat2* structs) {
+  return visitor->Visit("shaderAtomicFloat2FeaturesEXT",
+                        &structs->shader_atomic_float2_features_ext);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonExtShaderDemoteToHelperInvocation* structs) {
+  return visitor->Visit(
+      "shaderDemoteToHelperInvocationFeaturesEXT",
+      &structs->shader_demote_to_helper_invocation_features_ext);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonExtShaderImageAtomicInt64* structs) {
+  return visitor->Visit("shaderImageAtomicInt64FeaturesEXT",
+                        &structs->shader_image_atomic_int64_features_ext);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonExtShaderModuleIdentifier* structs) {
+  return visitor->Visit("shaderModuleIdentifierFeaturesEXT",
+                        &structs->shader_module_identifier_features_ext) &&
+         visitor->Visit("shaderModuleIdentifierPropertiesEXT",
+                        &structs->shader_module_identifier_properties_ext);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtShaderObject* structs) {
+  return visitor->Visit("shaderObjectFeaturesEXT",
+                        &structs->shader_object_features_ext) &&
+         visitor->Visit("shaderObjectPropertiesEXT",
+                        &structs->shader_object_properties_ext);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonExtShaderReplicatedComposites* structs) {
+  return visitor->Visit("shaderReplicatedCompositesFeaturesEXT",
+                        &structs->shader_replicated_composites_features_ext);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtShaderTileImage* structs) {
+  return visitor->Visit("shaderTileImageFeaturesEXT",
+                        &structs->shader_tile_image_features_ext) &&
+         visitor->Visit("shaderTileImagePropertiesEXT",
+                        &structs->shader_tile_image_properties_ext);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtSubgroupSizeControl* structs) {
+  return visitor->Visit("subgroupSizeControlFeaturesEXT",
+                        &structs->subgroup_size_control_features_ext) &&
+         visitor->Visit("subgroupSizeControlPropertiesEXT",
+                        &structs->subgroup_size_control_properties_ext);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtSubpassMergeFeedback* structs) {
+  return visitor->Visit("subpassMergeFeedbackFeaturesEXT",
+                        &structs->subpass_merge_feedback_features_ext);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtSwapchainMaintenance1* structs) {
+  return visitor->Visit("swapchainMaintenance1FeaturesEXT",
+                        &structs->swapchain_maintenance1_features_ext);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtTexelBufferAlignment* structs) {
+  return visitor->Visit("texelBufferAlignmentFeaturesEXT",
+                        &structs->texel_buffer_alignment_features_ext) &&
+         visitor->Visit("texelBufferAlignmentPropertiesEXT",
+                        &structs->texel_buffer_alignment_properties_ext);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonExtTextureCompressionAstcHdr* structs) {
+  return visitor->Visit("textureCompressionASTCHDRFeaturesEXT",
+                        &structs->texture_compression_astchdr_features_ext);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtTransformFeedback* structs) {
+  return visitor->Visit("transformFeedbackFeaturesEXT",
+                        &structs->transform_feedback_features_ext) &&
+         visitor->Visit("transformFeedbackPropertiesEXT",
+                        &structs->transform_feedback_properties_ext);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonExtVertexAttributeDivisor* structs) {
+  return visitor->Visit("vertexAttributeDivisorPropertiesEXT",
+                        &structs->vertex_attribute_divisor_properties_ext) &&
+         visitor->Visit("vertexAttributeDivisorFeaturesEXT",
+                        &structs->vertex_attribute_divisor_features_ext);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonExtVertexInputDynamicState* structs) {
+  return visitor->Visit("vertexInputDynamicStateFeaturesEXT",
+                        &structs->vertex_input_dynamic_state_features_ext);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtYcbcr2plane444Formats* structs) {
+  return visitor->Visit("ycbcr2Plane444FormatsFeaturesEXT",
+                        &structs->ycbcr_2plane_444_formats_features_ext);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonExtYcbcrImageArrays* structs) {
+  return visitor->Visit("ycbcrImageArraysFeaturesEXT",
+                        &structs->ycbcr_image_arrays_features_ext);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonHUAWEIClusterCullingShader* structs) {
+  return visitor->Visit("clusterCullingShaderFeaturesHUAWEI",
+                        &structs->cluster_culling_shader_features_huawei) &&
+         visitor->Visit("clusterCullingShaderPropertiesHUAWEI",
+                        &structs->cluster_culling_shader_properties_huawei);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonHUAWEIInvocationMask* structs) {
+  return visitor->Visit("invocationMaskFeaturesHUAWEI",
+                        &structs->invocation_mask_features_huawei);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonHUAWEISubpassShading* structs) {
+  return visitor->Visit("subpassShadingFeaturesHUAWEI",
+                        &structs->subpass_shading_features_huawei) &&
+         visitor->Visit("subpassShadingPropertiesHUAWEI",
+                        &structs->subpass_shading_properties_huawei);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonIMGRelaxedLineRasterization* structs) {
+  return visitor->Visit("relaxedLineRasterizationFeaturesIMG",
+                        &structs->relaxed_line_rasterization_features_img);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonExtVKINTELShaderIntegerFunctions2* structs) {
+  return visitor->Visit("shaderIntegerFunctions2FeaturesINTEL",
+                        &structs->shader_integer_functions2_features_intel);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHR16bitStorage* structs) {
+  return visitor->Visit("bit16StorageFeaturesKHR",
+                        &structs->bit16_storage_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHR8bitStorage* structs) {
+  return visitor->Visit("bit8StorageFeaturesKHR",
+                        &structs->bit8_storage_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRAccelerationStructure* structs) {
+  return visitor->Visit("accelerationStructureFeaturesKHR",
+                        &structs->acceleration_structure_features_khr) &&
+         visitor->Visit("accelerationStructurePropertiesKHR",
+                        &structs->acceleration_structure_properties_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRBufferDeviceAddress* structs) {
+  return visitor->Visit("bufferDeviceAddressFeaturesKHR",
+                        &structs->buffer_device_address_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRCooperativeMatrix* structs) {
+  return visitor->Visit("cooperativeMatrixFeaturesKHR",
+                        &structs->cooperative_matrix_features_khr) &&
+         visitor->Visit("cooperativeMatrixPropertiesKHR",
+                        &structs->cooperative_matrix_properties_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRDepthStencilResolve* structs) {
+  return visitor->Visit("depthStencilResolvePropertiesKHR",
+                        &structs->depth_stencil_resolve_properties_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRDriverProperties* structs) {
+  return visitor->Visit("driverPropertiesKHR", &structs->driver_properties_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRDynamicRendering* structs) {
+  return visitor->Visit("dynamicRenderingFeaturesKHR",
+                        &structs->dynamic_rendering_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonKHRDynamicRenderingLocalRead* structs) {
+  return visitor->Visit("dynamicRenderingLocalReadFeaturesKHR",
+                        &structs->dynamic_rendering_local_read_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonKHRExternalMemoryCapabilities* structs) {
+  return visitor->Visit("iDPropertiesKHR", &structs->id_properties_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonKHRFragmentShaderBarycentric* structs) {
+  return visitor->Visit("fragmentShaderBarycentricFeaturesKHR",
+                        &structs->fragment_shader_barycentric_features_khr) &&
+         visitor->Visit("fragmentShaderBarycentricPropertiesKHR",
+                        &structs->fragment_shader_barycentric_properties_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRFragmentShadingRate* structs) {
+  return visitor->Visit("fragmentShadingRateFeaturesKHR",
+                        &structs->fragment_shading_rate_features_khr) &&
+         visitor->Visit("fragmentShadingRatePropertiesKHR",
+                        &structs->fragment_shading_rate_properties_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRGlobalPriority* structs) {
+  return visitor->Visit("globalPriorityQueryFeaturesKHR",
+                        &structs->global_priority_query_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRImagelessFramebuffer* structs) {
+  return visitor->Visit("imagelessFramebufferFeaturesKHR",
+                        &structs->imageless_framebuffer_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRIndexTypeUint8* structs) {
+  return visitor->Visit("indexTypeUint8FeaturesKHR",
+                        &structs->index_type_uint8_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRLineRasterization* structs) {
+  return visitor->Visit("lineRasterizationFeaturesKHR",
+                        &structs->line_rasterization_features_khr) &&
+         visitor->Visit("lineRasterizationPropertiesKHR",
+                        &structs->line_rasterization_properties_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRMaintenance2* structs) {
+  return visitor->Visit("pointClippingPropertiesKHR",
+                        &structs->point_clipping_properties_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRMaintenance3* structs) {
+  return visitor->Visit("maintenance3PropertiesKHR",
+                        &structs->maintenance3_properties_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRMaintenance4* structs) {
+  return visitor->Visit("maintenance4FeaturesKHR",
+                        &structs->maintenance4_features_khr) &&
+         visitor->Visit("maintenance4PropertiesKHR",
+                        &structs->maintenance4_properties_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRMaintenance5* structs) {
+  return visitor->Visit("maintenance5FeaturesKHR",
+                        &structs->maintenance5_features_khr) &&
+         visitor->Visit("maintenance5PropertiesKHR",
+                        &structs->maintenance5_properties_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRMaintenance6* structs) {
+  return visitor->Visit("maintenance6FeaturesKHR",
+                        &structs->maintenance6_features_khr) &&
+         visitor->Visit("maintenance6PropertiesKHR",
+                        &structs->maintenance6_properties_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRMaintenance7* structs) {
+  return visitor->Visit("maintenance7FeaturesKHR",
+                        &structs->maintenance7_features_khr) &&
+         visitor->Visit("maintenance7PropertiesKHR",
+                        &structs->maintenance7_properties_khr) &&
+         visitor->Visit("layeredApiPropertiesListKHR",
+                        &structs->layered_api_properties_list_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRMultiview* structs) {
+  return visitor->Visit("multiviewFeaturesKHR",
+                        &structs->multiview_features_khr) &&
+         visitor->Visit("multiviewPropertiesKHR",
+                        &structs->multiview_properties_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRPerformanceQuery* structs) {
+  return visitor->Visit("performanceQueryFeaturesKHR",
+                        &structs->performance_query_features_khr) &&
+         visitor->Visit("performanceQueryPropertiesKHR",
+                        &structs->performance_query_properties_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRPipelineBinary* structs) {
+  return visitor->Visit("pipelineBinaryFeaturesKHR",
+                        &structs->pipeline_binary_features_khr) &&
+         visitor->Visit("pipelineBinaryPropertiesKHR",
+                        &structs->pipeline_binary_properties_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonKHRPipelineExecutableProperties* structs) {
+  return visitor->Visit("pipelineExecutablePropertiesFeaturesKHR",
+                        &structs->pipeline_executable_properties_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRPresentId* structs) {
+  return visitor->Visit("presentIdFeaturesKHR",
+                        &structs->present_id_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRPresentWait* structs) {
+  return visitor->Visit("presentWaitFeaturesKHR",
+                        &structs->present_wait_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRPushDescriptor* structs) {
+  return visitor->Visit("pushDescriptorPropertiesKHR",
+                        &structs->push_descriptor_properties_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRRayQuery* structs) {
+  return visitor->Visit("rayQueryFeaturesKHR",
+                        &structs->ray_query_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonKHRRayTracingMaintenance1* structs) {
+  return visitor->Visit("rayTracingMaintenance1FeaturesKHR",
+                        &structs->ray_tracing_maintenance1_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRRayTracingPipeline* structs) {
+  return visitor->Visit("rayTracingPipelineFeaturesKHR",
+                        &structs->ray_tracing_pipeline_features_khr) &&
+         visitor->Visit("rayTracingPipelinePropertiesKHR",
+                        &structs->ray_tracing_pipeline_properties_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonKHRRayTracingPositionFetch* structs) {
+  return visitor->Visit("rayTracingPositionFetchFeaturesKHR",
+                        &structs->ray_tracing_position_fetch_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonKHRSamplerYcbcrConversion* structs) {
+  return visitor->Visit("samplerYcbcrConversionFeaturesKHR",
+                        &structs->sampler_ycbcr_conversion_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonKHRSeparateDepthStencilLayouts* structs) {
+  return visitor->Visit("separateDepthStencilLayoutsFeaturesKHR",
+                        &structs->separate_depth_stencil_layouts_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRShaderAtomicInt64* structs) {
+  return visitor->Visit("shaderAtomicInt64FeaturesKHR",
+                        &structs->shader_atomic_int64_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRShaderClock* structs) {
+  return visitor->Visit("shaderClockFeaturesKHR",
+                        &structs->shader_clock_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRShaderExpectAssume* structs) {
+  return visitor->Visit("shaderExpectAssumeFeaturesKHR",
+                        &structs->shader_expect_assume_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRShaderFloat16Int8* structs) {
+  return visitor->Visit("shaderFloat16Int8FeaturesKHR",
+                        &structs->shader_float16_int8_features_khr) &&
+         visitor->Visit("float16Int8FeaturesKHR",
+                        &structs->float16_int8_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRShaderFloatControls* structs) {
+  return visitor->Visit("floatControlsPropertiesKHR",
+                        &structs->float_controls_properties_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRShaderFloatControls2* structs) {
+  return visitor->Visit("shaderFloatControls2FeaturesKHR",
+                        &structs->shader_float_controls2_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonKHRShaderIntegerDotProduct* structs) {
+  return visitor->Visit("shaderIntegerDotProductFeaturesKHR",
+                        &structs->shader_integer_dot_product_features_khr) &&
+         visitor->Visit("shaderIntegerDotProductPropertiesKHR",
+                        &structs->shader_integer_dot_product_properties_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonKHRShaderMaximalReconvergence* structs) {
+  return visitor->Visit("shaderMaximalReconvergenceFeaturesKHR",
+                        &structs->shader_maximal_reconvergence_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRShaderQuadControl* structs) {
+  return visitor->Visit("shaderQuadControlFeaturesKHR",
+                        &structs->shader_quad_control_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonKHRShaderRelaxedExtendedInstruction* structs) {
+  return visitor->Visit(
+      "shaderRelaxedExtendedInstructionFeaturesKHR",
+      &structs->shader_relaxed_extended_instruction_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonKHRShaderSubgroupExtendedTypes* structs) {
+  return visitor->Visit("shaderSubgroupExtendedTypesFeaturesKHR",
+                        &structs->shader_subgroup_extended_types_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRShaderSubgroupRotate* structs) {
+  return visitor->Visit("shaderSubgroupRotateFeaturesKHR",
+                        &structs->shader_subgroup_rotate_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonKHRShaderSubgroupUniformControlFlow* structs) {
+  return visitor->Visit(
+      "shaderSubgroupUniformControlFlowFeaturesKHR",
+      &structs->shader_subgroup_uniform_control_flow_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonKHRShaderTerminateInvocation* structs) {
+  return visitor->Visit("shaderTerminateInvocationFeaturesKHR",
+                        &structs->shader_terminate_invocation_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRSynchronization2* structs) {
+  return visitor->Visit("synchronization2FeaturesKHR",
+                        &structs->synchronization2_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRTimelineSemaphore* structs) {
+  return visitor->Visit("timelineSemaphoreFeaturesKHR",
+                        &structs->timeline_semaphore_features_khr) &&
+         visitor->Visit("timelineSemaphorePropertiesKHR",
+                        &structs->timeline_semaphore_properties_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonKHRUniformBufferStandardLayout* structs) {
+  return visitor->Visit("uniformBufferStandardLayoutFeaturesKHR",
+                        &structs->uniform_buffer_standard_layout_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRVariablePointers* structs) {
+  return visitor->Visit("variablePointerFeaturesKHR",
+                        &structs->variable_pointer_features_khr) &&
+         visitor->Visit("variablePointersFeaturesKHR",
+                        &structs->variable_pointers_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonKHRVertexAttributeDivisor* structs) {
+  return visitor->Visit("vertexAttributeDivisorPropertiesKHR",
+                        &structs->vertex_attribute_divisor_properties_khr) &&
+         visitor->Visit("vertexAttributeDivisorFeaturesKHR",
+                        &structs->vertex_attribute_divisor_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRVideoMaintenance1* structs) {
+  return visitor->Visit("videoMaintenance1FeaturesKHR",
+                        &structs->video_maintenance1_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonKHRVulkanMemoryModel* structs) {
+  return visitor->Visit("vulkanMemoryModelFeaturesKHR",
+                        &structs->vulkan_memory_model_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonKHRWorkgroupMemoryExplicitLayout* structs) {
+  return visitor->Visit(
+      "workgroupMemoryExplicitLayoutFeaturesKHR",
+      &structs->workgroup_memory_explicit_layout_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonKHRZeroInitializeWorkgroupMemory* structs) {
+  return visitor->Visit(
+      "zeroInitializeWorkgroupMemoryFeaturesKHR",
+      &structs->zero_initialize_workgroup_memory_features_khr);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonMESAImageAlignmentControl* structs) {
+  return visitor->Visit("imageAlignmentControlFeaturesMESA",
+                        &structs->image_alignment_control_features_mesa) &&
+         visitor->Visit("imageAlignmentControlPropertiesMESA",
+                        &structs->image_alignment_control_properties_mesa);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonMSFTLayeredDriver* structs) {
+  return visitor->Visit("layeredDriverPropertiesMSFT",
+                        &structs->layered_driver_properties_msft);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonNVXMultiviewPerViewAttributes* structs) {
+  return visitor->Visit("multiviewPerViewAttributesPropertiesNVX",
+                        &structs->multiview_per_view_attributes_properties_nvx);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonNVCommandBufferInheritance* structs) {
+  return visitor->Visit("commandBufferInheritanceFeaturesNV",
+                        &structs->command_buffer_inheritance_features_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonNVComputeShaderDerivatives* structs) {
+  return visitor->Visit("computeShaderDerivativesFeaturesNV",
+                        &structs->compute_shader_derivatives_features_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonNVCooperativeMatrix* structs) {
+  return visitor->Visit("cooperativeMatrixFeaturesNV",
+                        &structs->cooperative_matrix_features_nv) &&
+         visitor->Visit("cooperativeMatrixPropertiesNV",
+                        &structs->cooperative_matrix_properties_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonNVCopyMemoryIndirect* structs) {
+  return visitor->Visit("copyMemoryIndirectFeaturesNV",
+                        &structs->copy_memory_indirect_features_nv) &&
+         visitor->Visit("copyMemoryIndirectPropertiesNV",
+                        &structs->copy_memory_indirect_properties_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonNVCornerSampledImage* structs) {
+  return visitor->Visit("cornerSampledImageFeaturesNV",
+                        &structs->corner_sampled_image_features_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonNVCoverageReductionMode* structs) {
+  return visitor->Visit("coverageReductionModeFeaturesNV",
+                        &structs->coverage_reduction_mode_features_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonNVCudaKernelLaunch* structs) {
+  return visitor->Visit("cudaKernelLaunchFeaturesNV",
+                        &structs->cuda_kernel_launch_features_nv) &&
+         visitor->Visit("cudaKernelLaunchPropertiesNV",
+                        &structs->cuda_kernel_launch_properties_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonNVDedicatedAllocationImageAliasing* structs) {
+  return visitor->Visit(
+      "dedicatedAllocationImageAliasingFeaturesNV",
+      &structs->dedicated_allocation_image_aliasing_features_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonNVDescriptorPoolOverallocation* structs) {
+  return visitor->Visit("descriptorPoolOverallocationFeaturesNV",
+                        &structs->descriptor_pool_overallocation_features_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonNVDeviceDiagnosticsConfig* structs) {
+  return visitor->Visit("diagnosticsConfigFeaturesNV",
+                        &structs->diagnostics_config_features_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonNVDeviceGeneratedCommands* structs) {
+  return visitor->Visit("deviceGeneratedCommandsPropertiesNV",
+                        &structs->device_generated_commands_properties_nv) &&
+         visitor->Visit("deviceGeneratedCommandsFeaturesNV",
+                        &structs->device_generated_commands_features_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonNVDeviceGeneratedCommandsCompute* structs) {
+  return visitor->Visit(
+      "deviceGeneratedCommandsComputeFeaturesNV",
+      &structs->device_generated_commands_compute_features_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonNVExtendedSparseAddressSpace* structs) {
+  return visitor->Visit("extendedSparseAddressSpaceFeaturesNV",
+                        &structs->extended_sparse_address_space_features_nv) &&
+         visitor->Visit("extendedSparseAddressSpacePropertiesNV",
+                        &structs->extended_sparse_address_space_properties_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonNVExternalMemoryRdma* structs) {
+  return visitor->Visit("externalMemoryRDMAFeaturesNV",
+                        &structs->external_memory_rdma_features_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonNVFragmentShadingRateEnums* structs) {
+  return visitor->Visit("fragmentShadingRateEnumsFeaturesNV",
+                        &structs->fragment_shading_rate_enums_features_nv) &&
+         visitor->Visit("fragmentShadingRateEnumsPropertiesNV",
+                        &structs->fragment_shading_rate_enums_properties_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonNVInheritedViewportScissor* structs) {
+  return visitor->Visit("inheritedViewportScissorFeaturesNV",
+                        &structs->inherited_viewport_scissor_features_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonNVLinearColorAttachment* structs) {
+  return visitor->Visit("linearColorAttachmentFeaturesNV",
+                        &structs->linear_color_attachment_features_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonNVMemoryDecompression* structs) {
+  return visitor->Visit("memoryDecompressionFeaturesNV",
+                        &structs->memory_decompression_features_nv) &&
+         visitor->Visit("memoryDecompressionPropertiesNV",
+                        &structs->memory_decompression_properties_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonNVMeshShader* structs) {
+  return visitor->Visit("meshShaderFeaturesNV",
+                        &structs->mesh_shader_features_nv) &&
+         visitor->Visit("meshShaderPropertiesNV",
+                        &structs->mesh_shader_properties_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonNVOpticalFlow* structs) {
+  return visitor->Visit("opticalFlowFeaturesNV",
+                        &structs->optical_flow_features_nv) &&
+         visitor->Visit("opticalFlowPropertiesNV",
+                        &structs->optical_flow_properties_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonNVPerStageDescriptorSet* structs) {
+  return visitor->Visit("perStageDescriptorSetFeaturesNV",
+                        &structs->per_stage_descriptor_set_features_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonNVPresentBarrier* structs) {
+  return visitor->Visit("presentBarrierFeaturesNV",
+                        &structs->present_barrier_features_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonNVRawAccessChains* structs) {
+  return visitor->Visit("rawAccessChainsFeaturesNV",
+                        &structs->raw_access_chains_features_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonNVRayTracing* structs) {
+  return visitor->Visit("rayTracingPropertiesNV",
+                        &structs->ray_tracing_properties_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonNVRayTracingInvocationReorder* structs) {
+  return visitor->Visit(
+             "rayTracingInvocationReorderPropertiesNV",
+             &structs->ray_tracing_invocation_reorder_properties_nv) &&
+         visitor->Visit("rayTracingInvocationReorderFeaturesNV",
+                        &structs->ray_tracing_invocation_reorder_features_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonNVRayTracingMotionBlur* structs) {
+  return visitor->Visit("rayTracingMotionBlurFeaturesNV",
+                        &structs->ray_tracing_motion_blur_features_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonNVRayTracingValidation* structs) {
+  return visitor->Visit("rayTracingValidationFeaturesNV",
+                        &structs->ray_tracing_validation_features_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonNVRepresentativeFragmentTest* structs) {
+  return visitor->Visit("representativeFragmentTestFeaturesNV",
+                        &structs->representative_fragment_test_features_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonNVScissorExclusive* structs) {
+  return visitor->Visit("exclusiveScissorFeaturesNV",
+                        &structs->exclusive_scissor_features_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonNVShaderAtomicFloat16Vector* structs) {
+  return visitor->Visit("shaderAtomicFloat16VectorFeaturesNV",
+                        &structs->shader_atomic_float16_vector_features_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonNVShaderImageFootprint* structs) {
+  return visitor->Visit("shaderImageFootprintFeaturesNV",
+                        &structs->shader_image_footprint_features_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonNVShaderSmBuiltins* structs) {
+  return visitor->Visit("shaderSMBuiltinsPropertiesNV",
+                        &structs->shader_sm_builtins_properties_nv) &&
+         visitor->Visit("shaderSMBuiltinsFeaturesNV",
+                        &structs->shader_sm_builtins_features_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonNVShadingRateImage* structs) {
+  return visitor->Visit("shadingRateImageFeaturesNV",
+                        &structs->shading_rate_image_features_nv) &&
+         visitor->Visit("shadingRateImagePropertiesNV",
+                        &structs->shading_rate_image_properties_nv);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonQCOMFilterCubicClamp* structs) {
+  return visitor->Visit("cubicClampFeaturesQCOM",
+                        &structs->cubic_clamp_features_qcom);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonQCOMFilterCubicWeights* structs) {
+  return visitor->Visit("cubicWeightsFeaturesQCOM",
+                        &structs->cubic_weights_features_qcom);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonQCOMFragmentDensityMapOffset* structs) {
+  return visitor->Visit("fragmentDensityMapOffsetFeaturesQCOM",
+                        &structs->fragment_density_map_offset_features_qcom) &&
+         visitor->Visit("fragmentDensityMapOffsetPropertiesQCOM",
+                        &structs->fragment_density_map_offset_properties_qcom);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonQCOMImageProcessing* structs) {
+  return visitor->Visit("imageProcessingFeaturesQCOM",
+                        &structs->image_processing_features_qcom) &&
+         visitor->Visit("imageProcessingPropertiesQCOM",
+                        &structs->image_processing_properties_qcom);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonQCOMImageProcessing2* structs) {
+  return visitor->Visit("imageProcessing2FeaturesQCOM",
+                        &structs->image_processing2_features_qcom) &&
+         visitor->Visit("imageProcessing2PropertiesQCOM",
+                        &structs->image_processing2_properties_qcom);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonQCOMMultiviewPerViewRenderAreas* structs) {
+  return visitor->Visit(
+      "multiviewPerViewRenderAreasFeaturesQCOM",
+      &structs->multiview_per_view_render_areas_features_qcom);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonQCOMMultiviewPerViewViewports* structs) {
+  return visitor->Visit("multiviewPerViewViewportsFeaturesQCOM",
+                        &structs->multiview_per_view_viewports_features_qcom);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonQCOMTileProperties* structs) {
+  return visitor->Visit("tilePropertiesFeaturesQCOM",
+                        &structs->tile_properties_features_qcom);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonQCOMYcbcrDegamma* structs) {
+  return visitor->Visit("ycbcrDegammaFeaturesQCOM",
+                        &structs->ycbcr_degamma_features_qcom);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkJsonSECAmigoProfiling* structs) {
+  return visitor->Visit("amigoProfilingFeaturesSEC",
+                        &structs->amigo_profiling_features_sec);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonVALVEDescriptorSetHostMapping* structs) {
+  return visitor->Visit("descriptorSetHostMappingFeaturesVALVE",
+                        &structs->descriptor_set_host_mapping_features_valve);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkJsonVALVEMutableDescriptorType* structs) {
+  return visitor->Visit("mutableDescriptorTypeFeaturesVALVE",
+                        &structs->mutable_descriptor_type_features_valve);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDevice16BitStorageFeatures* features) {
+  return
+
+      visitor->Visit("storageBuffer16BitAccess",
+                     &features->storageBuffer16BitAccess) &&
+      visitor->Visit("uniformAndStorageBuffer16BitAccess",
+                     &features->uniformAndStorageBuffer16BitAccess) &&
+      visitor->Visit("storagePushConstant16",
+                     &features->storagePushConstant16) &&
+      visitor->Visit("storageInputOutput16", &features->storageInputOutput16);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDevice4444FormatsFeaturesEXT* features) {
+  return
+
+      visitor->Visit("formatA4R4G4B4", &features->formatA4R4G4B4) &&
+      visitor->Visit("formatA4B4G4R4", &features->formatA4B4G4R4);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDevice8BitStorageFeatures* features) {
+  return
+
+      visitor->Visit("storageBuffer8BitAccess",
+                     &features->storageBuffer8BitAccess) &&
+      visitor->Visit("uniformAndStorageBuffer8BitAccess",
+                     &features->uniformAndStorageBuffer8BitAccess) &&
+      visitor->Visit("storagePushConstant8", &features->storagePushConstant8);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceASTCDecodeFeaturesEXT* features) {
+  return
+
+      visitor->Visit("decodeModeSharedExponent",
+                     &features->decodeModeSharedExponent);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceAccelerationStructureFeaturesKHR* features) {
+  return
+
+      visitor->Visit("accelerationStructure",
+                     &features->accelerationStructure) &&
+      visitor->Visit("accelerationStructureCaptureReplay",
+                     &features->accelerationStructureCaptureReplay) &&
+      visitor->Visit("accelerationStructureIndirectBuild",
+                     &features->accelerationStructureIndirectBuild) &&
+      visitor->Visit("accelerationStructureHostCommands",
+                     &features->accelerationStructureHostCommands) &&
+      visitor->Visit(
+          "descriptorBindingAccelerationStructureUpdateAfterBind",
+          &features->descriptorBindingAccelerationStructureUpdateAfterBind);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceAccelerationStructurePropertiesKHR* properties) {
+  return
+
+      visitor->Visit("maxGeometryCount", &properties->maxGeometryCount) &&
+      visitor->Visit("maxInstanceCount", &properties->maxInstanceCount) &&
+      visitor->Visit("maxPrimitiveCount", &properties->maxPrimitiveCount) &&
+      visitor->Visit(
+          "maxPerStageDescriptorAccelerationStructures",
+          &properties->maxPerStageDescriptorAccelerationStructures) &&
+      visitor->Visit(
+          "maxPerStageDescriptorUpdateAfterBindAccelerationStructures",
+          &properties
+               ->maxPerStageDescriptorUpdateAfterBindAccelerationStructures) &&
+      visitor->Visit("maxDescriptorSetAccelerationStructures",
+                     &properties->maxDescriptorSetAccelerationStructures) &&
+      visitor->Visit(
+          "maxDescriptorSetUpdateAfterBindAccelerationStructures",
+          &properties->maxDescriptorSetUpdateAfterBindAccelerationStructures) &&
+      visitor->Visit(
+          "minAccelerationStructureScratchOffsetAlignment",
+          &properties->minAccelerationStructureScratchOffsetAlignment);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceAddressBindingReportFeaturesEXT* features) {
+  return
+
+      visitor->Visit("reportAddressBinding", &features->reportAddressBinding);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceAmigoProfilingFeaturesSEC* features) {
+  return
+
+      visitor->Visit("amigoProfiling", &features->amigoProfiling);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceAntiLagFeaturesAMD* features) {
+  return
+
+      visitor->Visit("antiLag", &features->antiLag);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT* features) {
+  return
+
+      visitor->Visit("attachmentFeedbackLoopDynamicState",
+                     &features->attachmentFeedbackLoopDynamicState);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT* features) {
+  return
+
+      visitor->Visit("attachmentFeedbackLoopLayout",
+                     &features->attachmentFeedbackLoopLayout);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* features) {
+  return
+
+      visitor->Visit("advancedBlendCoherentOperations",
+                     &features->advancedBlendCoherentOperations);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* properties) {
+  return
+
+      visitor->Visit("advancedBlendMaxColorAttachments",
+                     &properties->advancedBlendMaxColorAttachments) &&
+      visitor->Visit("advancedBlendIndependentBlend",
+                     &properties->advancedBlendIndependentBlend) &&
+      visitor->Visit("advancedBlendNonPremultipliedSrcColor",
+                     &properties->advancedBlendNonPremultipliedSrcColor) &&
+      visitor->Visit("advancedBlendNonPremultipliedDstColor",
+                     &properties->advancedBlendNonPremultipliedDstColor) &&
+      visitor->Visit("advancedBlendCorrelatedOverlap",
+                     &properties->advancedBlendCorrelatedOverlap) &&
+      visitor->Visit("advancedBlendAllOperations",
+                     &properties->advancedBlendAllOperations);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceBorderColorSwizzleFeaturesEXT* features) {
+  return
+
+      visitor->Visit("borderColorSwizzle", &features->borderColorSwizzle) &&
+      visitor->Visit("borderColorSwizzleFromImage",
+                     &features->borderColorSwizzleFromImage);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceBufferDeviceAddressFeaturesEXT* features) {
+  return
+
+      visitor->Visit("bufferDeviceAddress", &features->bufferDeviceAddress) &&
+      visitor->Visit("bufferDeviceAddressCaptureReplay",
+                     &features->bufferDeviceAddressCaptureReplay) &&
+      visitor->Visit("bufferDeviceAddressMultiDevice",
+                     &features->bufferDeviceAddressMultiDevice);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceBufferDeviceAddressFeatures* features) {
+  return
+
+      visitor->Visit("bufferDeviceAddress", &features->bufferDeviceAddress) &&
+      visitor->Visit("bufferDeviceAddressCaptureReplay",
+                     &features->bufferDeviceAddressCaptureReplay) &&
+      visitor->Visit("bufferDeviceAddressMultiDevice",
+                     &features->bufferDeviceAddressMultiDevice);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI* features) {
+  return
+
+      visitor->Visit("clustercullingShader", &features->clustercullingShader) &&
+      visitor->Visit("multiviewClusterCullingShader",
+                     &features->multiviewClusterCullingShader);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI* properties) {
+  return
+
+      visitor->Visit("maxWorkGroupCount", &properties->maxWorkGroupCount) &&
+      visitor->Visit("maxWorkGroupSize", &properties->maxWorkGroupSize) &&
+      visitor->Visit("maxOutputClusterCount",
+                     &properties->maxOutputClusterCount) &&
+      visitor->Visit("indirectBufferOffsetAlignment",
+                     &properties->indirectBufferOffsetAlignment);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceCoherentMemoryFeaturesAMD* features) {
+  return
+
+      visitor->Visit("deviceCoherentMemory", &features->deviceCoherentMemory);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceColorWriteEnableFeaturesEXT* features) {
+  return
+
+      visitor->Visit("colorWriteEnable", &features->colorWriteEnable);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceCommandBufferInheritanceFeaturesNV* features) {
+  return
+
+      visitor->Visit("commandBufferInheritance",
+                     &features->commandBufferInheritance);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceComputeShaderDerivativesFeaturesNV* features) {
+  return
+
+      visitor->Visit("computeDerivativeGroupQuads",
+                     &features->computeDerivativeGroupQuads) &&
+      visitor->Visit("computeDerivativeGroupLinear",
+                     &features->computeDerivativeGroupLinear);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceConditionalRenderingFeaturesEXT* features) {
+  return
+
+      visitor->Visit("conditionalRendering", &features->conditionalRendering) &&
+      visitor->Visit("inheritedConditionalRendering",
+                     &features->inheritedConditionalRendering);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceConservativeRasterizationPropertiesEXT* properties) {
+  return
+
+      visitor->Visit("primitiveOverestimationSize",
+                     &properties->primitiveOverestimationSize) &&
+      visitor->Visit("maxExtraPrimitiveOverestimationSize",
+                     &properties->maxExtraPrimitiveOverestimationSize) &&
+      visitor->Visit(
+          "extraPrimitiveOverestimationSizeGranularity",
+          &properties->extraPrimitiveOverestimationSizeGranularity) &&
+      visitor->Visit("primitiveUnderestimation",
+                     &properties->primitiveUnderestimation) &&
+      visitor->Visit("conservativePointAndLineRasterization",
+                     &properties->conservativePointAndLineRasterization) &&
+      visitor->Visit("degenerateTrianglesRasterized",
+                     &properties->degenerateTrianglesRasterized) &&
+      visitor->Visit("degenerateLinesRasterized",
+                     &properties->degenerateLinesRasterized) &&
+      visitor->Visit("fullyCoveredFragmentShaderInputVariable",
+                     &properties->fullyCoveredFragmentShaderInputVariable) &&
+      visitor->Visit("conservativeRasterizationPostDepthCoverage",
+                     &properties->conservativeRasterizationPostDepthCoverage);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceCooperativeMatrixFeaturesKHR* features) {
+  return
+
+      visitor->Visit("cooperativeMatrix", &features->cooperativeMatrix) &&
+      visitor->Visit("cooperativeMatrixRobustBufferAccess",
+                     &features->cooperativeMatrixRobustBufferAccess);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceCooperativeMatrixFeaturesNV* features) {
+  return
+
+      visitor->Visit("cooperativeMatrix", &features->cooperativeMatrix) &&
+      visitor->Visit("cooperativeMatrixRobustBufferAccess",
+                     &features->cooperativeMatrixRobustBufferAccess);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceCooperativeMatrixPropertiesKHR* properties) {
+  return
+
+      visitor->Visit("cooperativeMatrixSupportedStages",
+                     &properties->cooperativeMatrixSupportedStages);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceCooperativeMatrixPropertiesNV* properties) {
+  return
+
+      visitor->Visit("cooperativeMatrixSupportedStages",
+                     &properties->cooperativeMatrixSupportedStages);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceCopyMemoryIndirectFeaturesNV* features) {
+  return
+
+      visitor->Visit("indirectCopy", &features->indirectCopy);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceCopyMemoryIndirectPropertiesNV* properties) {
+  return
+
+      visitor->Visit("supportedQueues", &properties->supportedQueues);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceCornerSampledImageFeaturesNV* features) {
+  return
+
+      visitor->Visit("cornerSampledImage", &features->cornerSampledImage);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceCoverageReductionModeFeaturesNV* features) {
+  return
+
+      visitor->Visit("coverageReductionMode", &features->coverageReductionMode);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceCubicClampFeaturesQCOM* features) {
+  return
+
+      visitor->Visit("cubicRangeClamp", &features->cubicRangeClamp);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceCubicWeightsFeaturesQCOM* features) {
+  return
+
+      visitor->Visit("selectableCubicWeights",
+                     &features->selectableCubicWeights);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceCudaKernelLaunchFeaturesNV* features) {
+  return
+
+      visitor->Visit("cudaKernelLaunchFeatures",
+                     &features->cudaKernelLaunchFeatures);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceCudaKernelLaunchPropertiesNV* properties) {
+  return
+
+      visitor->Visit("computeCapabilityMinor",
+                     &properties->computeCapabilityMinor) &&
+      visitor->Visit("computeCapabilityMajor",
+                     &properties->computeCapabilityMajor);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceCustomBorderColorFeaturesEXT* features) {
+  return
+
+      visitor->Visit("customBorderColors", &features->customBorderColors) &&
+      visitor->Visit("customBorderColorWithoutFormat",
+                     &features->customBorderColorWithoutFormat);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceCustomBorderColorPropertiesEXT* properties) {
+  return
+
+      visitor->Visit("maxCustomBorderColorSamplers",
+                     &properties->maxCustomBorderColorSamplers);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* features) {
+  return
+
+      visitor->Visit("dedicatedAllocationImageAliasing",
+                     &features->dedicatedAllocationImageAliasing);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceDepthBiasControlFeaturesEXT* features) {
+  return
+
+      visitor->Visit("depthBiasControl", &features->depthBiasControl) &&
+      visitor->Visit(
+          "leastRepresentableValueForceUnormRepresentation",
+          &features->leastRepresentableValueForceUnormRepresentation) &&
+      visitor->Visit("floatRepresentation", &features->floatRepresentation) &&
+      visitor->Visit("depthBiasExact", &features->depthBiasExact);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceDepthClampZeroOneFeaturesEXT* features) {
+  return
+
+      visitor->Visit("depthClampZeroOne", &features->depthClampZeroOne);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceDepthClipControlFeaturesEXT* features) {
+  return
+
+      visitor->Visit("depthClipControl", &features->depthClipControl);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceDepthClipEnableFeaturesEXT* features) {
+  return
+
+      visitor->Visit("depthClipEnable", &features->depthClipEnable);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceDepthStencilResolveProperties* properties) {
+  return
+
+      visitor->Visit("supportedDepthResolveModes",
+                     &properties->supportedDepthResolveModes) &&
+      visitor->Visit("supportedStencilResolveModes",
+                     &properties->supportedStencilResolveModes) &&
+      visitor->Visit("independentResolveNone",
+                     &properties->independentResolveNone) &&
+      visitor->Visit("independentResolve", &properties->independentResolve);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT* properties) {
+  return
+
+      visitor->Visit("combinedImageSamplerDensityMapDescriptorSize",
+                     &properties->combinedImageSamplerDensityMapDescriptorSize);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceDescriptorBufferFeaturesEXT* features) {
+  return
+
+      visitor->Visit("descriptorBuffer", &features->descriptorBuffer) &&
+      visitor->Visit("descriptorBufferCaptureReplay",
+                     &features->descriptorBufferCaptureReplay) &&
+      visitor->Visit("descriptorBufferImageLayoutIgnored",
+                     &features->descriptorBufferImageLayoutIgnored) &&
+      visitor->Visit("descriptorBufferPushDescriptors",
+                     &features->descriptorBufferPushDescriptors);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceDescriptorBufferPropertiesEXT* properties) {
+  return
+
+      visitor->Visit("combinedImageSamplerDescriptorSingleArray",
+                     &properties->combinedImageSamplerDescriptorSingleArray) &&
+      visitor->Visit("bufferlessPushDescriptors",
+                     &properties->bufferlessPushDescriptors) &&
+      visitor->Visit("allowSamplerImageViewPostSubmitCreation",
+                     &properties->allowSamplerImageViewPostSubmitCreation) &&
+      visitor->Visit("descriptorBufferOffsetAlignment",
+                     &properties->descriptorBufferOffsetAlignment) &&
+      visitor->Visit("maxDescriptorBufferBindings",
+                     &properties->maxDescriptorBufferBindings) &&
+      visitor->Visit("maxResourceDescriptorBufferBindings",
+                     &properties->maxResourceDescriptorBufferBindings) &&
+      visitor->Visit("maxSamplerDescriptorBufferBindings",
+                     &properties->maxSamplerDescriptorBufferBindings) &&
+      visitor->Visit("maxEmbeddedImmutableSamplerBindings",
+                     &properties->maxEmbeddedImmutableSamplerBindings) &&
+      visitor->Visit("maxEmbeddedImmutableSamplers",
+                     &properties->maxEmbeddedImmutableSamplers) &&
+      visitor->Visit("bufferCaptureReplayDescriptorDataSize",
+                     &properties->bufferCaptureReplayDescriptorDataSize) &&
+      visitor->Visit("imageCaptureReplayDescriptorDataSize",
+                     &properties->imageCaptureReplayDescriptorDataSize) &&
+      visitor->Visit("imageViewCaptureReplayDescriptorDataSize",
+                     &properties->imageViewCaptureReplayDescriptorDataSize) &&
+      visitor->Visit("samplerCaptureReplayDescriptorDataSize",
+                     &properties->samplerCaptureReplayDescriptorDataSize) &&
+      visitor->Visit(
+          "accelerationStructureCaptureReplayDescriptorDataSize",
+          &properties->accelerationStructureCaptureReplayDescriptorDataSize) &&
+      visitor->Visit("samplerDescriptorSize",
+                     &properties->samplerDescriptorSize) &&
+      visitor->Visit("combinedImageSamplerDescriptorSize",
+                     &properties->combinedImageSamplerDescriptorSize) &&
+      visitor->Visit("sampledImageDescriptorSize",
+                     &properties->sampledImageDescriptorSize) &&
+      visitor->Visit("storageImageDescriptorSize",
+                     &properties->storageImageDescriptorSize) &&
+      visitor->Visit("uniformTexelBufferDescriptorSize",
+                     &properties->uniformTexelBufferDescriptorSize) &&
+      visitor->Visit("robustUniformTexelBufferDescriptorSize",
+                     &properties->robustUniformTexelBufferDescriptorSize) &&
+      visitor->Visit("storageTexelBufferDescriptorSize",
+                     &properties->storageTexelBufferDescriptorSize) &&
+      visitor->Visit("robustStorageTexelBufferDescriptorSize",
+                     &properties->robustStorageTexelBufferDescriptorSize) &&
+      visitor->Visit("uniformBufferDescriptorSize",
+                     &properties->uniformBufferDescriptorSize) &&
+      visitor->Visit("robustUniformBufferDescriptorSize",
+                     &properties->robustUniformBufferDescriptorSize) &&
+      visitor->Visit("storageBufferDescriptorSize",
+                     &properties->storageBufferDescriptorSize) &&
+      visitor->Visit("robustStorageBufferDescriptorSize",
+                     &properties->robustStorageBufferDescriptorSize) &&
+      visitor->Visit("inputAttachmentDescriptorSize",
+                     &properties->inputAttachmentDescriptorSize) &&
+      visitor->Visit("accelerationStructureDescriptorSize",
+                     &properties->accelerationStructureDescriptorSize) &&
+      visitor->Visit("maxSamplerDescriptorBufferRange",
+                     &properties->maxSamplerDescriptorBufferRange) &&
+      visitor->Visit("maxResourceDescriptorBufferRange",
+                     &properties->maxResourceDescriptorBufferRange) &&
+      visitor->Visit("samplerDescriptorBufferAddressSpaceSize",
+                     &properties->samplerDescriptorBufferAddressSpaceSize) &&
+      visitor->Visit("resourceDescriptorBufferAddressSpaceSize",
+                     &properties->resourceDescriptorBufferAddressSpaceSize) &&
+      visitor->Visit("descriptorBufferAddressSpaceSize",
+                     &properties->descriptorBufferAddressSpaceSize);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceDescriptorIndexingFeatures* features) {
+  return
+
+      visitor->Visit("shaderInputAttachmentArrayDynamicIndexing",
+                     &features->shaderInputAttachmentArrayDynamicIndexing) &&
+      visitor->Visit("shaderUniformTexelBufferArrayDynamicIndexing",
+                     &features->shaderUniformTexelBufferArrayDynamicIndexing) &&
+      visitor->Visit("shaderStorageTexelBufferArrayDynamicIndexing",
+                     &features->shaderStorageTexelBufferArrayDynamicIndexing) &&
+      visitor->Visit("shaderUniformBufferArrayNonUniformIndexing",
+                     &features->shaderUniformBufferArrayNonUniformIndexing) &&
+      visitor->Visit("shaderSampledImageArrayNonUniformIndexing",
+                     &features->shaderSampledImageArrayNonUniformIndexing) &&
+      visitor->Visit("shaderStorageBufferArrayNonUniformIndexing",
+                     &features->shaderStorageBufferArrayNonUniformIndexing) &&
+      visitor->Visit("shaderStorageImageArrayNonUniformIndexing",
+                     &features->shaderStorageImageArrayNonUniformIndexing) &&
+      visitor->Visit("shaderInputAttachmentArrayNonUniformIndexing",
+                     &features->shaderInputAttachmentArrayNonUniformIndexing) &&
+      visitor->Visit(
+          "shaderUniformTexelBufferArrayNonUniformIndexing",
+          &features->shaderUniformTexelBufferArrayNonUniformIndexing) &&
+      visitor->Visit(
+          "shaderStorageTexelBufferArrayNonUniformIndexing",
+          &features->shaderStorageTexelBufferArrayNonUniformIndexing) &&
+      visitor->Visit(
+          "descriptorBindingUniformBufferUpdateAfterBind",
+          &features->descriptorBindingUniformBufferUpdateAfterBind) &&
+      visitor->Visit("descriptorBindingSampledImageUpdateAfterBind",
+                     &features->descriptorBindingSampledImageUpdateAfterBind) &&
+      visitor->Visit("descriptorBindingStorageImageUpdateAfterBind",
+                     &features->descriptorBindingStorageImageUpdateAfterBind) &&
+      visitor->Visit(
+          "descriptorBindingStorageBufferUpdateAfterBind",
+          &features->descriptorBindingStorageBufferUpdateAfterBind) &&
+      visitor->Visit(
+          "descriptorBindingUniformTexelBufferUpdateAfterBind",
+          &features->descriptorBindingUniformTexelBufferUpdateAfterBind) &&
+      visitor->Visit(
+          "descriptorBindingStorageTexelBufferUpdateAfterBind",
+          &features->descriptorBindingStorageTexelBufferUpdateAfterBind) &&
+      visitor->Visit("descriptorBindingUpdateUnusedWhilePending",
+                     &features->descriptorBindingUpdateUnusedWhilePending) &&
+      visitor->Visit("descriptorBindingPartiallyBound",
+                     &features->descriptorBindingPartiallyBound) &&
+      visitor->Visit("descriptorBindingVariableDescriptorCount",
+                     &features->descriptorBindingVariableDescriptorCount) &&
+      visitor->Visit("runtimeDescriptorArray",
+                     &features->runtimeDescriptorArray);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceDescriptorIndexingProperties* properties) {
+  return
+
+      visitor->Visit("maxUpdateAfterBindDescriptorsInAllPools",
+                     &properties->maxUpdateAfterBindDescriptorsInAllPools) &&
+      visitor->Visit(
+          "shaderUniformBufferArrayNonUniformIndexingNative",
+          &properties->shaderUniformBufferArrayNonUniformIndexingNative) &&
+      visitor->Visit(
+          "shaderSampledImageArrayNonUniformIndexingNative",
+          &properties->shaderSampledImageArrayNonUniformIndexingNative) &&
+      visitor->Visit(
+          "shaderStorageBufferArrayNonUniformIndexingNative",
+          &properties->shaderStorageBufferArrayNonUniformIndexingNative) &&
+      visitor->Visit(
+          "shaderStorageImageArrayNonUniformIndexingNative",
+          &properties->shaderStorageImageArrayNonUniformIndexingNative) &&
+      visitor->Visit(
+          "shaderInputAttachmentArrayNonUniformIndexingNative",
+          &properties->shaderInputAttachmentArrayNonUniformIndexingNative) &&
+      visitor->Visit("robustBufferAccessUpdateAfterBind",
+                     &properties->robustBufferAccessUpdateAfterBind) &&
+      visitor->Visit("quadDivergentImplicitLod",
+                     &properties->quadDivergentImplicitLod) &&
+      visitor->Visit(
+          "maxPerStageDescriptorUpdateAfterBindSamplers",
+          &properties->maxPerStageDescriptorUpdateAfterBindSamplers) &&
+      visitor->Visit(
+          "maxPerStageDescriptorUpdateAfterBindUniformBuffers",
+          &properties->maxPerStageDescriptorUpdateAfterBindUniformBuffers) &&
+      visitor->Visit(
+          "maxPerStageDescriptorUpdateAfterBindStorageBuffers",
+          &properties->maxPerStageDescriptorUpdateAfterBindStorageBuffers) &&
+      visitor->Visit(
+          "maxPerStageDescriptorUpdateAfterBindSampledImages",
+          &properties->maxPerStageDescriptorUpdateAfterBindSampledImages) &&
+      visitor->Visit(
+          "maxPerStageDescriptorUpdateAfterBindStorageImages",
+          &properties->maxPerStageDescriptorUpdateAfterBindStorageImages) &&
+      visitor->Visit(
+          "maxPerStageDescriptorUpdateAfterBindInputAttachments",
+          &properties->maxPerStageDescriptorUpdateAfterBindInputAttachments) &&
+      visitor->Visit("maxPerStageUpdateAfterBindResources",
+                     &properties->maxPerStageUpdateAfterBindResources) &&
+      visitor->Visit("maxDescriptorSetUpdateAfterBindSamplers",
+                     &properties->maxDescriptorSetUpdateAfterBindSamplers) &&
+      visitor->Visit(
+          "maxDescriptorSetUpdateAfterBindUniformBuffers",
+          &properties->maxDescriptorSetUpdateAfterBindUniformBuffers) &&
+      visitor->Visit(
+          "maxDescriptorSetUpdateAfterBindUniformBuffersDynamic",
+          &properties->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic) &&
+      visitor->Visit(
+          "maxDescriptorSetUpdateAfterBindStorageBuffers",
+          &properties->maxDescriptorSetUpdateAfterBindStorageBuffers) &&
+      visitor->Visit(
+          "maxDescriptorSetUpdateAfterBindStorageBuffersDynamic",
+          &properties->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic) &&
+      visitor->Visit(
+          "maxDescriptorSetUpdateAfterBindSampledImages",
+          &properties->maxDescriptorSetUpdateAfterBindSampledImages) &&
+      visitor->Visit(
+          "maxDescriptorSetUpdateAfterBindStorageImages",
+          &properties->maxDescriptorSetUpdateAfterBindStorageImages) &&
+      visitor->Visit(
+          "maxDescriptorSetUpdateAfterBindInputAttachments",
+          &properties->maxDescriptorSetUpdateAfterBindInputAttachments);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV* features) {
+  return
+
+      visitor->Visit("descriptorPoolOverallocation",
+                     &features->descriptorPoolOverallocation);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE* features) {
+  return
+
+      visitor->Visit("descriptorSetHostMapping",
+                     &features->descriptorSetHostMapping);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV* features) {
+  return
+
+      visitor->Visit("deviceGeneratedCompute",
+                     &features->deviceGeneratedCompute) &&
+      visitor->Visit("deviceGeneratedComputePipelines",
+                     &features->deviceGeneratedComputePipelines) &&
+      visitor->Visit("deviceGeneratedComputeCaptureReplay",
+                     &features->deviceGeneratedComputeCaptureReplay);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV* features) {
+  return
+
+      visitor->Visit("deviceGeneratedCommands",
+                     &features->deviceGeneratedCommands);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV* properties) {
+  return
+
+      visitor->Visit("maxGraphicsShaderGroupCount",
+                     &properties->maxGraphicsShaderGroupCount) &&
+      visitor->Visit("maxIndirectSequenceCount",
+                     &properties->maxIndirectSequenceCount) &&
+      visitor->Visit("maxIndirectCommandsTokenCount",
+                     &properties->maxIndirectCommandsTokenCount) &&
+      visitor->Visit("maxIndirectCommandsStreamCount",
+                     &properties->maxIndirectCommandsStreamCount) &&
+      visitor->Visit("maxIndirectCommandsTokenOffset",
+                     &properties->maxIndirectCommandsTokenOffset) &&
+      visitor->Visit("maxIndirectCommandsStreamStride",
+                     &properties->maxIndirectCommandsStreamStride) &&
+      visitor->Visit("minSequencesCountBufferOffsetAlignment",
+                     &properties->minSequencesCountBufferOffsetAlignment) &&
+      visitor->Visit("minSequencesIndexBufferOffsetAlignment",
+                     &properties->minSequencesIndexBufferOffsetAlignment) &&
+      visitor->Visit("minIndirectCommandsBufferOffsetAlignment",
+                     &properties->minIndirectCommandsBufferOffsetAlignment);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceDeviceMemoryReportFeaturesEXT* features) {
+  return
+
+      visitor->Visit("deviceMemoryReport", &features->deviceMemoryReport);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceDiagnosticsConfigFeaturesNV* features) {
+  return
+
+      visitor->Visit("diagnosticsConfig", &features->diagnosticsConfig);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceDiscardRectanglePropertiesEXT* properties) {
+  return
+
+      visitor->Visit("maxDiscardRectangles", &properties->maxDiscardRectangles);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceDriverProperties* properties) {
+  return
+
+      visitor->Visit("driverID", &properties->driverID) &&
+      visitor->Visit("driverName", &properties->driverName) &&
+      visitor->Visit("driverInfo", &properties->driverInfo) &&
+      visitor->Visit("conformanceVersion", &properties->conformanceVersion);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceDrmPropertiesEXT* properties) {
+  return
+
+      visitor->Visit("hasPrimary", &properties->hasPrimary) &&
+      visitor->Visit("hasRender", &properties->hasRender) &&
+      visitor->Visit("primaryMajor", &properties->primaryMajor) &&
+      visitor->Visit("primaryMinor", &properties->primaryMinor) &&
+      visitor->Visit("renderMajor", &properties->renderMajor) &&
+      visitor->Visit("renderMinor", &properties->renderMinor);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceDynamicRenderingFeatures* features) {
+  return
+
+      visitor->Visit("dynamicRendering", &features->dynamicRendering);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceDynamicRenderingLocalReadFeatures* features) {
+  return
+
+      visitor->Visit("dynamicRenderingLocalRead",
+                     &features->dynamicRenderingLocalRead);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT* features) {
+  return
+
+      visitor->Visit("dynamicRenderingUnusedAttachments",
+                     &features->dynamicRenderingUnusedAttachments);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceExclusiveScissorFeaturesNV* features) {
+  return
+
+      visitor->Visit("exclusiveScissor", &features->exclusiveScissor);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceExtendedDynamicState2FeaturesEXT* features) {
+  return
+
+      visitor->Visit("extendedDynamicState2",
+                     &features->extendedDynamicState2) &&
+      visitor->Visit("extendedDynamicState2LogicOp",
+                     &features->extendedDynamicState2LogicOp) &&
+      visitor->Visit("extendedDynamicState2PatchControlPoints",
+                     &features->extendedDynamicState2PatchControlPoints);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT* features) {
+  return
+
+      visitor->Visit(
+          "extendedDynamicState3TessellationDomainOrigin",
+          &features->extendedDynamicState3TessellationDomainOrigin) &&
+      visitor->Visit("extendedDynamicState3DepthClampEnable",
+                     &features->extendedDynamicState3DepthClampEnable) &&
+      visitor->Visit("extendedDynamicState3PolygonMode",
+                     &features->extendedDynamicState3PolygonMode) &&
+      visitor->Visit("extendedDynamicState3RasterizationSamples",
+                     &features->extendedDynamicState3RasterizationSamples) &&
+      visitor->Visit("extendedDynamicState3SampleMask",
+                     &features->extendedDynamicState3SampleMask) &&
+      visitor->Visit("extendedDynamicState3AlphaToCoverageEnable",
+                     &features->extendedDynamicState3AlphaToCoverageEnable) &&
+      visitor->Visit("extendedDynamicState3AlphaToOneEnable",
+                     &features->extendedDynamicState3AlphaToOneEnable) &&
+      visitor->Visit("extendedDynamicState3LogicOpEnable",
+                     &features->extendedDynamicState3LogicOpEnable) &&
+      visitor->Visit("extendedDynamicState3ColorBlendEnable",
+                     &features->extendedDynamicState3ColorBlendEnable) &&
+      visitor->Visit("extendedDynamicState3ColorBlendEquation",
+                     &features->extendedDynamicState3ColorBlendEquation) &&
+      visitor->Visit("extendedDynamicState3ColorWriteMask",
+                     &features->extendedDynamicState3ColorWriteMask) &&
+      visitor->Visit("extendedDynamicState3RasterizationStream",
+                     &features->extendedDynamicState3RasterizationStream) &&
+      visitor->Visit(
+          "extendedDynamicState3ConservativeRasterizationMode",
+          &features->extendedDynamicState3ConservativeRasterizationMode) &&
+      visitor->Visit(
+          "extendedDynamicState3ExtraPrimitiveOverestimationSize",
+          &features->extendedDynamicState3ExtraPrimitiveOverestimationSize) &&
+      visitor->Visit("extendedDynamicState3DepthClipEnable",
+                     &features->extendedDynamicState3DepthClipEnable) &&
+      visitor->Visit("extendedDynamicState3SampleLocationsEnable",
+                     &features->extendedDynamicState3SampleLocationsEnable) &&
+      visitor->Visit("extendedDynamicState3ColorBlendAdvanced",
+                     &features->extendedDynamicState3ColorBlendAdvanced) &&
+      visitor->Visit("extendedDynamicState3ProvokingVertexMode",
+                     &features->extendedDynamicState3ProvokingVertexMode) &&
+      visitor->Visit("extendedDynamicState3LineRasterizationMode",
+                     &features->extendedDynamicState3LineRasterizationMode) &&
+      visitor->Visit("extendedDynamicState3LineStippleEnable",
+                     &features->extendedDynamicState3LineStippleEnable) &&
+      visitor->Visit(
+          "extendedDynamicState3DepthClipNegativeOneToOne",
+          &features->extendedDynamicState3DepthClipNegativeOneToOne) &&
+      visitor->Visit("extendedDynamicState3ViewportWScalingEnable",
+                     &features->extendedDynamicState3ViewportWScalingEnable) &&
+      visitor->Visit("extendedDynamicState3ViewportSwizzle",
+                     &features->extendedDynamicState3ViewportSwizzle) &&
+      visitor->Visit("extendedDynamicState3CoverageToColorEnable",
+                     &features->extendedDynamicState3CoverageToColorEnable) &&
+      visitor->Visit("extendedDynamicState3CoverageToColorLocation",
+                     &features->extendedDynamicState3CoverageToColorLocation) &&
+      visitor->Visit("extendedDynamicState3CoverageModulationMode",
+                     &features->extendedDynamicState3CoverageModulationMode) &&
+      visitor->Visit(
+          "extendedDynamicState3CoverageModulationTableEnable",
+          &features->extendedDynamicState3CoverageModulationTableEnable) &&
+      visitor->Visit("extendedDynamicState3CoverageModulationTable",
+                     &features->extendedDynamicState3CoverageModulationTable) &&
+      visitor->Visit("extendedDynamicState3CoverageReductionMode",
+                     &features->extendedDynamicState3CoverageReductionMode) &&
+      visitor->Visit(
+          "extendedDynamicState3RepresentativeFragmentTestEnable",
+          &features->extendedDynamicState3RepresentativeFragmentTestEnable) &&
+      visitor->Visit("extendedDynamicState3ShadingRateImageEnable",
+                     &features->extendedDynamicState3ShadingRateImageEnable);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceExtendedDynamicState3PropertiesEXT* properties) {
+  return
+
+      visitor->Visit("dynamicPrimitiveTopologyUnrestricted",
+                     &properties->dynamicPrimitiveTopologyUnrestricted);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* features) {
+  return
+
+      visitor->Visit("extendedDynamicState", &features->extendedDynamicState);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV* features) {
+  return
+
+      visitor->Visit("extendedSparseAddressSpace",
+                     &features->extendedSparseAddressSpace);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV* properties) {
+  return
+
+      visitor->Visit("extendedSparseAddressSpaceSize",
+                     &properties->extendedSparseAddressSpaceSize) &&
+      visitor->Visit("extendedSparseImageUsageFlags",
+                     &properties->extendedSparseImageUsageFlags) &&
+      visitor->Visit("extendedSparseBufferUsageFlags",
+                     &properties->extendedSparseBufferUsageFlags);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceExternalFormatResolveFeaturesANDROID* features) {
+  return
+
+      visitor->Visit("externalFormatResolve", &features->externalFormatResolve);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceExternalFormatResolvePropertiesANDROID* properties) {
+  return
+
+      visitor->Visit(
+          "nullColorAttachmentWithExternalFormatResolve",
+          &properties->nullColorAttachmentWithExternalFormatResolve) &&
+      visitor->Visit("externalFormatResolveChromaOffsetX",
+                     &properties->externalFormatResolveChromaOffsetX) &&
+      visitor->Visit("externalFormatResolveChromaOffsetY",
+                     &properties->externalFormatResolveChromaOffsetY);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceExternalMemoryHostPropertiesEXT* properties) {
+  return
+
+      visitor->Visit("minImportedHostPointerAlignment",
+                     &properties->minImportedHostPointerAlignment);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceExternalMemoryRDMAFeaturesNV* features) {
+  return
+
+      visitor->Visit("externalMemoryRDMA", &features->externalMemoryRDMA);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceFaultFeaturesEXT* features) {
+  return
+
+      visitor->Visit("deviceFault", &features->deviceFault) &&
+      visitor->Visit("deviceFaultVendorBinary",
+                     &features->deviceFaultVendorBinary);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceShaderFloat16Int8Features* features) {
+  return
+
+      visitor->Visit("shaderFloat16", &features->shaderFloat16) &&
+      visitor->Visit("shaderInt8", &features->shaderInt8);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceFloatControlsProperties* properties) {
+  return
+
+      visitor->Visit("denormBehaviorIndependence",
+                     &properties->denormBehaviorIndependence) &&
+      visitor->Visit("roundingModeIndependence",
+                     &properties->roundingModeIndependence) &&
+      visitor->Visit("shaderSignedZeroInfNanPreserveFloat16",
+                     &properties->shaderSignedZeroInfNanPreserveFloat16) &&
+      visitor->Visit("shaderSignedZeroInfNanPreserveFloat32",
+                     &properties->shaderSignedZeroInfNanPreserveFloat32) &&
+      visitor->Visit("shaderSignedZeroInfNanPreserveFloat64",
+                     &properties->shaderSignedZeroInfNanPreserveFloat64) &&
+      visitor->Visit("shaderDenormPreserveFloat16",
+                     &properties->shaderDenormPreserveFloat16) &&
+      visitor->Visit("shaderDenormPreserveFloat32",
+                     &properties->shaderDenormPreserveFloat32) &&
+      visitor->Visit("shaderDenormPreserveFloat64",
+                     &properties->shaderDenormPreserveFloat64) &&
+      visitor->Visit("shaderDenormFlushToZeroFloat16",
+                     &properties->shaderDenormFlushToZeroFloat16) &&
+      visitor->Visit("shaderDenormFlushToZeroFloat32",
+                     &properties->shaderDenormFlushToZeroFloat32) &&
+      visitor->Visit("shaderDenormFlushToZeroFloat64",
+                     &properties->shaderDenormFlushToZeroFloat64) &&
+      visitor->Visit("shaderRoundingModeRTEFloat16",
+                     &properties->shaderRoundingModeRTEFloat16) &&
+      visitor->Visit("shaderRoundingModeRTEFloat32",
+                     &properties->shaderRoundingModeRTEFloat32) &&
+      visitor->Visit("shaderRoundingModeRTEFloat64",
+                     &properties->shaderRoundingModeRTEFloat64) &&
+      visitor->Visit("shaderRoundingModeRTZFloat16",
+                     &properties->shaderRoundingModeRTZFloat16) &&
+      visitor->Visit("shaderRoundingModeRTZFloat32",
+                     &properties->shaderRoundingModeRTZFloat32) &&
+      visitor->Visit("shaderRoundingModeRTZFloat64",
+                     &properties->shaderRoundingModeRTZFloat64);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceFragmentDensityMap2FeaturesEXT* features) {
+  return
+
+      visitor->Visit("fragmentDensityMapDeferred",
+                     &features->fragmentDensityMapDeferred);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceFragmentDensityMap2PropertiesEXT* properties) {
+  return
+
+      visitor->Visit("subsampledLoads", &properties->subsampledLoads) &&
+      visitor->Visit("subsampledCoarseReconstructionEarlyAccess",
+                     &properties->subsampledCoarseReconstructionEarlyAccess) &&
+      visitor->Visit("maxSubsampledArrayLayers",
+                     &properties->maxSubsampledArrayLayers) &&
+      visitor->Visit("maxDescriptorSetSubsampledSamplers",
+                     &properties->maxDescriptorSetSubsampledSamplers);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceFragmentDensityMapFeaturesEXT* features) {
+  return
+
+      visitor->Visit("fragmentDensityMap", &features->fragmentDensityMap) &&
+      visitor->Visit("fragmentDensityMapDynamic",
+                     &features->fragmentDensityMapDynamic) &&
+      visitor->Visit("fragmentDensityMapNonSubsampledImages",
+                     &features->fragmentDensityMapNonSubsampledImages);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM* features) {
+  return
+
+      visitor->Visit("fragmentDensityMapOffset",
+                     &features->fragmentDensityMapOffset);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM* properties) {
+  return
+
+      visitor->Visit("fragmentDensityOffsetGranularity",
+                     &properties->fragmentDensityOffsetGranularity);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceFragmentDensityMapPropertiesEXT* properties) {
+  return
+
+      visitor->Visit("minFragmentDensityTexelSize",
+                     &properties->minFragmentDensityTexelSize) &&
+      visitor->Visit("maxFragmentDensityTexelSize",
+                     &properties->maxFragmentDensityTexelSize) &&
+      visitor->Visit("fragmentDensityInvocations",
+                     &properties->fragmentDensityInvocations);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR* features) {
+  return
+
+      visitor->Visit("fragmentShaderBarycentric",
+                     &features->fragmentShaderBarycentric);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR* properties) {
+  return
+
+      visitor->Visit(
+          "triStripVertexOrderIndependentOfProvokingVertex",
+          &properties->triStripVertexOrderIndependentOfProvokingVertex);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT* features) {
+  return
+
+      visitor->Visit("fragmentShaderSampleInterlock",
+                     &features->fragmentShaderSampleInterlock) &&
+      visitor->Visit("fragmentShaderPixelInterlock",
+                     &features->fragmentShaderPixelInterlock) &&
+      visitor->Visit("fragmentShaderShadingRateInterlock",
+                     &features->fragmentShaderShadingRateInterlock);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV* features) {
+  return
+
+      visitor->Visit("fragmentShadingRateEnums",
+                     &features->fragmentShadingRateEnums) &&
+      visitor->Visit("supersampleFragmentShadingRates",
+                     &features->supersampleFragmentShadingRates) &&
+      visitor->Visit("noInvocationFragmentShadingRates",
+                     &features->noInvocationFragmentShadingRates);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV* properties) {
+  return
+
+      visitor->Visit("maxFragmentShadingRateInvocationCount",
+                     &properties->maxFragmentShadingRateInvocationCount);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceFragmentShadingRateFeaturesKHR* features) {
+  return
+
+      visitor->Visit("pipelineFragmentShadingRate",
+                     &features->pipelineFragmentShadingRate) &&
+      visitor->Visit("primitiveFragmentShadingRate",
+                     &features->primitiveFragmentShadingRate) &&
+      visitor->Visit("attachmentFragmentShadingRate",
+                     &features->attachmentFragmentShadingRate);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceFragmentShadingRatePropertiesKHR* properties) {
+  return
+
+      visitor->Visit("minFragmentShadingRateAttachmentTexelSize",
+                     &properties->minFragmentShadingRateAttachmentTexelSize) &&
+      visitor->Visit("maxFragmentShadingRateAttachmentTexelSize",
+                     &properties->maxFragmentShadingRateAttachmentTexelSize) &&
+      visitor->Visit(
+          "maxFragmentShadingRateAttachmentTexelSizeAspectRatio",
+          &properties->maxFragmentShadingRateAttachmentTexelSizeAspectRatio) &&
+      visitor->Visit(
+          "primitiveFragmentShadingRateWithMultipleViewports",
+          &properties->primitiveFragmentShadingRateWithMultipleViewports) &&
+      visitor->Visit("layeredShadingRateAttachments",
+                     &properties->layeredShadingRateAttachments) &&
+      visitor->Visit("fragmentShadingRateNonTrivialCombinerOps",
+                     &properties->fragmentShadingRateNonTrivialCombinerOps) &&
+      visitor->Visit("maxFragmentSize", &properties->maxFragmentSize) &&
+      visitor->Visit("maxFragmentSizeAspectRatio",
+                     &properties->maxFragmentSizeAspectRatio) &&
+      visitor->Visit("maxFragmentShadingRateCoverageSamples",
+                     &properties->maxFragmentShadingRateCoverageSamples) &&
+      visitor->Visit("maxFragmentShadingRateRasterizationSamples",
+                     &properties->maxFragmentShadingRateRasterizationSamples) &&
+      visitor->Visit(
+          "fragmentShadingRateWithShaderDepthStencilWrites",
+          &properties->fragmentShadingRateWithShaderDepthStencilWrites) &&
+      visitor->Visit("fragmentShadingRateWithSampleMask",
+                     &properties->fragmentShadingRateWithSampleMask) &&
+      visitor->Visit("fragmentShadingRateWithShaderSampleMask",
+                     &properties->fragmentShadingRateWithShaderSampleMask) &&
+      visitor->Visit(
+          "fragmentShadingRateWithConservativeRasterization",
+          &properties->fragmentShadingRateWithConservativeRasterization) &&
+      visitor->Visit(
+          "fragmentShadingRateWithFragmentShaderInterlock",
+          &properties->fragmentShadingRateWithFragmentShaderInterlock) &&
+      visitor->Visit(
+          "fragmentShadingRateWithCustomSampleLocations",
+          &properties->fragmentShadingRateWithCustomSampleLocations) &&
+      visitor->Visit("fragmentShadingRateStrictMultiplyCombiner",
+                     &properties->fragmentShadingRateStrictMultiplyCombiner);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceFrameBoundaryFeaturesEXT* features) {
+  return
+
+      visitor->Visit("frameBoundary", &features->frameBoundary);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceGlobalPriorityQueryFeatures* features) {
+  return
+
+      visitor->Visit("globalPriorityQuery", &features->globalPriorityQuery);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT* features) {
+  return
+
+      visitor->Visit("graphicsPipelineLibrary",
+                     &features->graphicsPipelineLibrary);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT* properties) {
+  return
+
+      visitor->Visit("graphicsPipelineLibraryFastLinking",
+                     &properties->graphicsPipelineLibraryFastLinking) &&
+      visitor->Visit(
+          "graphicsPipelineLibraryIndependentInterpolationDecoration",
+          &properties
+               ->graphicsPipelineLibraryIndependentInterpolationDecoration);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceHostImageCopyFeatures* features) {
+  return
+
+      visitor->Visit("hostImageCopy", &features->hostImageCopy);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceHostQueryResetFeatures* features) {
+  return
+
+      visitor->Visit("hostQueryReset", &features->hostQueryReset);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceIDProperties* properties) {
+  return
+
+      visitor->Visit("deviceUUID", &properties->deviceUUID) &&
+      visitor->Visit("driverUUID", &properties->driverUUID) &&
+      visitor->Visit("deviceLUID", &properties->deviceLUID) &&
+      visitor->Visit("deviceNodeMask", &properties->deviceNodeMask) &&
+      visitor->Visit("deviceLUIDValid", &properties->deviceLUIDValid);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceImage2DViewOf3DFeaturesEXT* features) {
+  return
+
+      visitor->Visit("image2DViewOf3D", &features->image2DViewOf3D) &&
+      visitor->Visit("sampler2DViewOf3D", &features->sampler2DViewOf3D);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceImageAlignmentControlFeaturesMESA* features) {
+  return
+
+      visitor->Visit("imageAlignmentControl", &features->imageAlignmentControl);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceImageAlignmentControlPropertiesMESA* properties) {
+  return
+
+      visitor->Visit("supportedImageAlignmentMask",
+                     &properties->supportedImageAlignmentMask);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceImageCompressionControlFeaturesEXT* features) {
+  return
+
+      visitor->Visit("imageCompressionControl",
+                     &features->imageCompressionControl);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT* features) {
+  return
+
+      visitor->Visit("imageCompressionControlSwapchain",
+                     &features->imageCompressionControlSwapchain);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceImageProcessing2FeaturesQCOM* features) {
+  return
+
+      visitor->Visit("textureBlockMatch2", &features->textureBlockMatch2);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceImageProcessing2PropertiesQCOM* properties) {
+  return
+
+      visitor->Visit("maxBlockMatchWindow", &properties->maxBlockMatchWindow);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceImageProcessingFeaturesQCOM* features) {
+  return
+
+      visitor->Visit("textureSampleWeighted",
+                     &features->textureSampleWeighted) &&
+      visitor->Visit("textureBoxFilter", &features->textureBoxFilter) &&
+      visitor->Visit("textureBlockMatch", &features->textureBlockMatch);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceImageProcessingPropertiesQCOM* properties) {
+  return
+
+      visitor->Visit("maxWeightFilterPhases",
+                     &properties->maxWeightFilterPhases) &&
+      visitor->Visit("maxWeightFilterDimension",
+                     &properties->maxWeightFilterDimension) &&
+      visitor->Visit("maxBlockMatchRegion", &properties->maxBlockMatchRegion) &&
+      visitor->Visit("maxBoxFilterBlockSize",
+                     &properties->maxBoxFilterBlockSize);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceImageRobustnessFeatures* features) {
+  return
+
+      visitor->Visit("robustImageAccess", &features->robustImageAccess);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT* features) {
+  return
+
+      visitor->Visit("imageSlicedViewOf3D", &features->imageSlicedViewOf3D);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceImageViewMinLodFeaturesEXT* features) {
+  return
+
+      visitor->Visit("minLod", &features->minLod);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceImagelessFramebufferFeatures* features) {
+  return
+
+      visitor->Visit("imagelessFramebuffer", &features->imagelessFramebuffer);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceIndexTypeUint8Features* features) {
+  return
+
+      visitor->Visit("indexTypeUint8", &features->indexTypeUint8);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceInheritedViewportScissorFeaturesNV* features) {
+  return
+
+      visitor->Visit("inheritedViewportScissor2D",
+                     &features->inheritedViewportScissor2D);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceInlineUniformBlockFeatures* features) {
+  return
+
+      visitor->Visit("inlineUniformBlock", &features->inlineUniformBlock) &&
+      visitor->Visit(
+          "descriptorBindingInlineUniformBlockUpdateAfterBind",
+          &features->descriptorBindingInlineUniformBlockUpdateAfterBind);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceInlineUniformBlockProperties* properties) {
+  return
+
+      visitor->Visit("maxInlineUniformBlockSize",
+                     &properties->maxInlineUniformBlockSize) &&
+      visitor->Visit("maxPerStageDescriptorInlineUniformBlocks",
+                     &properties->maxPerStageDescriptorInlineUniformBlocks) &&
+      visitor->Visit(
+          "maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks",
+          &properties
+               ->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks) &&
+      visitor->Visit("maxDescriptorSetInlineUniformBlocks",
+                     &properties->maxDescriptorSetInlineUniformBlocks) &&
+      visitor->Visit(
+          "maxDescriptorSetUpdateAfterBindInlineUniformBlocks",
+          &properties->maxDescriptorSetUpdateAfterBindInlineUniformBlocks);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceInvocationMaskFeaturesHUAWEI* features) {
+  return
+
+      visitor->Visit("invocationMask", &features->invocationMask);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceLayeredApiPropertiesListKHR* properties) {
+  return
+
+      visitor->Visit("layeredApiCount", &properties->layeredApiCount) &&
+      visitor->VisitArray("pLayeredApis", properties->layeredApiCount,
+                          &properties->pLayeredApis);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceLayeredDriverPropertiesMSFT* properties) {
+  return
+
+      visitor->Visit("underlyingAPI", &properties->underlyingAPI);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceLegacyDitheringFeaturesEXT* features) {
+  return
+
+      visitor->Visit("legacyDithering", &features->legacyDithering);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT* features) {
+  return
+
+      visitor->Visit("legacyVertexAttributes",
+                     &features->legacyVertexAttributes);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT* properties) {
+  return
+
+      visitor->Visit("nativeUnalignedPerformance",
+                     &properties->nativeUnalignedPerformance);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceLineRasterizationFeatures* features) {
+  return
+
+      visitor->Visit("rectangularLines", &features->rectangularLines) &&
+      visitor->Visit("bresenhamLines", &features->bresenhamLines) &&
+      visitor->Visit("smoothLines", &features->smoothLines) &&
+      visitor->Visit("stippledRectangularLines",
+                     &features->stippledRectangularLines) &&
+      visitor->Visit("stippledBresenhamLines",
+                     &features->stippledBresenhamLines) &&
+      visitor->Visit("stippledSmoothLines", &features->stippledSmoothLines);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceLineRasterizationProperties* properties) {
+  return
+
+      visitor->Visit("lineSubPixelPrecisionBits",
+                     &properties->lineSubPixelPrecisionBits);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceLinearColorAttachmentFeaturesNV* features) {
+  return
+
+      visitor->Visit("linearColorAttachment", &features->linearColorAttachment);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceMaintenance3Properties* properties) {
+  return
+
+      visitor->Visit("maxPerSetDescriptors",
+                     &properties->maxPerSetDescriptors) &&
+      visitor->Visit("maxMemoryAllocationSize",
+                     &properties->maxMemoryAllocationSize);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceMaintenance4Features* features) {
+  return
+
+      visitor->Visit("maintenance4", &features->maintenance4);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceMaintenance4Properties* properties) {
+  return
+
+      visitor->Visit("maxBufferSize", &properties->maxBufferSize);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceMaintenance5Features* features) {
+  return
+
+      visitor->Visit("maintenance5", &features->maintenance5);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceMaintenance5Properties* properties) {
+  return
+
+      visitor->Visit(
+          "earlyFragmentMultisampleCoverageAfterSampleCounting",
+          &properties->earlyFragmentMultisampleCoverageAfterSampleCounting) &&
+      visitor->Visit(
+          "earlyFragmentSampleMaskTestBeforeSampleCounting",
+          &properties->earlyFragmentSampleMaskTestBeforeSampleCounting) &&
+      visitor->Visit("depthStencilSwizzleOneSupport",
+                     &properties->depthStencilSwizzleOneSupport) &&
+      visitor->Visit("polygonModePointSize",
+                     &properties->polygonModePointSize) &&
+      visitor->Visit(
+          "nonStrictSinglePixelWideLinesUseParallelogram",
+          &properties->nonStrictSinglePixelWideLinesUseParallelogram) &&
+      visitor->Visit("nonStrictWideLinesUseParallelogram",
+                     &properties->nonStrictWideLinesUseParallelogram);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceMaintenance6Features* features) {
+  return
+
+      visitor->Visit("maintenance6", &features->maintenance6);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceMaintenance6Properties* properties) {
+  return
+
+      visitor->Visit("blockTexelViewCompatibleMultipleLayers",
+                     &properties->blockTexelViewCompatibleMultipleLayers) &&
+      visitor->Visit("maxCombinedImageSamplerDescriptorCount",
+                     &properties->maxCombinedImageSamplerDescriptorCount) &&
+      visitor->Visit("fragmentShadingRateClampCombinerInputs",
+                     &properties->fragmentShadingRateClampCombinerInputs);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceMaintenance7FeaturesKHR* features) {
+  return
+
+      visitor->Visit("maintenance7", &features->maintenance7);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceMaintenance7PropertiesKHR* properties) {
+  return
+
+      visitor->Visit("robustFragmentShadingRateAttachmentAccess",
+                     &properties->robustFragmentShadingRateAttachmentAccess) &&
+      visitor->Visit("separateDepthStencilAttachmentAccess",
+                     &properties->separateDepthStencilAttachmentAccess) &&
+      visitor->Visit("maxDescriptorSetTotalUniformBuffersDynamic",
+                     &properties->maxDescriptorSetTotalUniformBuffersDynamic) &&
+      visitor->Visit("maxDescriptorSetTotalStorageBuffersDynamic",
+                     &properties->maxDescriptorSetTotalStorageBuffersDynamic) &&
+      visitor->Visit("maxDescriptorSetTotalBuffersDynamic",
+                     &properties->maxDescriptorSetTotalBuffersDynamic) &&
+      visitor->Visit(
+          "maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic",
+          &properties
+               ->maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic) &&
+      visitor->Visit(
+          "maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic",
+          &properties
+               ->maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic) &&
+      visitor->Visit(
+          "maxDescriptorSetUpdateAfterBindTotalBuffersDynamic",
+          &properties->maxDescriptorSetUpdateAfterBindTotalBuffersDynamic);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceMapMemoryPlacedFeaturesEXT* features) {
+  return
+
+      visitor->Visit("memoryMapPlaced", &features->memoryMapPlaced) &&
+      visitor->Visit("memoryMapRangePlaced", &features->memoryMapRangePlaced) &&
+      visitor->Visit("memoryUnmapReserve", &features->memoryUnmapReserve);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceMapMemoryPlacedPropertiesEXT* properties) {
+  return
+
+      visitor->Visit("minPlacedMemoryMapAlignment",
+                     &properties->minPlacedMemoryMapAlignment);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceMemoryDecompressionFeaturesNV* features) {
+  return
+
+      visitor->Visit("memoryDecompression", &features->memoryDecompression);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceMemoryDecompressionPropertiesNV* properties) {
+  return
+
+      visitor->Visit("decompressionMethods",
+                     &properties->decompressionMethods) &&
+      visitor->Visit("maxDecompressionIndirectCount",
+                     &properties->maxDecompressionIndirectCount);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceMemoryPriorityFeaturesEXT* features) {
+  return
+
+      visitor->Visit("memoryPriority", &features->memoryPriority);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceMeshShaderFeaturesEXT* features) {
+  return
+
+      visitor->Visit("taskShader", &features->taskShader) &&
+      visitor->Visit("meshShader", &features->meshShader) &&
+      visitor->Visit("multiviewMeshShader", &features->multiviewMeshShader) &&
+      visitor->Visit("primitiveFragmentShadingRateMeshShader",
+                     &features->primitiveFragmentShadingRateMeshShader) &&
+      visitor->Visit("meshShaderQueries", &features->meshShaderQueries);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceMeshShaderFeaturesNV* features) {
+  return
+
+      visitor->Visit("taskShader", &features->taskShader) &&
+      visitor->Visit("meshShader", &features->meshShader);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceMeshShaderPropertiesEXT* properties) {
+  return
+
+      visitor->Visit("maxTaskWorkGroupTotalCount",
+                     &properties->maxTaskWorkGroupTotalCount) &&
+      visitor->Visit("maxTaskWorkGroupCount",
+                     &properties->maxTaskWorkGroupCount) &&
+      visitor->Visit("maxTaskWorkGroupInvocations",
+                     &properties->maxTaskWorkGroupInvocations) &&
+      visitor->Visit("maxTaskWorkGroupSize",
+                     &properties->maxTaskWorkGroupSize) &&
+      visitor->Visit("maxTaskPayloadSize", &properties->maxTaskPayloadSize) &&
+      visitor->Visit("maxTaskSharedMemorySize",
+                     &properties->maxTaskSharedMemorySize) &&
+      visitor->Visit("maxTaskPayloadAndSharedMemorySize",
+                     &properties->maxTaskPayloadAndSharedMemorySize) &&
+      visitor->Visit("maxMeshWorkGroupTotalCount",
+                     &properties->maxMeshWorkGroupTotalCount) &&
+      visitor->Visit("maxMeshWorkGroupCount",
+                     &properties->maxMeshWorkGroupCount) &&
+      visitor->Visit("maxMeshWorkGroupInvocations",
+                     &properties->maxMeshWorkGroupInvocations) &&
+      visitor->Visit("maxMeshWorkGroupSize",
+                     &properties->maxMeshWorkGroupSize) &&
+      visitor->Visit("maxMeshSharedMemorySize",
+                     &properties->maxMeshSharedMemorySize) &&
+      visitor->Visit("maxMeshPayloadAndSharedMemorySize",
+                     &properties->maxMeshPayloadAndSharedMemorySize) &&
+      visitor->Visit("maxMeshOutputMemorySize",
+                     &properties->maxMeshOutputMemorySize) &&
+      visitor->Visit("maxMeshPayloadAndOutputMemorySize",
+                     &properties->maxMeshPayloadAndOutputMemorySize) &&
+      visitor->Visit("maxMeshOutputComponents",
+                     &properties->maxMeshOutputComponents) &&
+      visitor->Visit("maxMeshOutputVertices",
+                     &properties->maxMeshOutputVertices) &&
+      visitor->Visit("maxMeshOutputPrimitives",
+                     &properties->maxMeshOutputPrimitives) &&
+      visitor->Visit("maxMeshOutputLayers", &properties->maxMeshOutputLayers) &&
+      visitor->Visit("maxMeshMultiviewViewCount",
+                     &properties->maxMeshMultiviewViewCount) &&
+      visitor->Visit("meshOutputPerVertexGranularity",
+                     &properties->meshOutputPerVertexGranularity) &&
+      visitor->Visit("meshOutputPerPrimitiveGranularity",
+                     &properties->meshOutputPerPrimitiveGranularity) &&
+      visitor->Visit("maxPreferredTaskWorkGroupInvocations",
+                     &properties->maxPreferredTaskWorkGroupInvocations) &&
+      visitor->Visit("maxPreferredMeshWorkGroupInvocations",
+                     &properties->maxPreferredMeshWorkGroupInvocations) &&
+      visitor->Visit("prefersLocalInvocationVertexOutput",
+                     &properties->prefersLocalInvocationVertexOutput) &&
+      visitor->Visit("prefersLocalInvocationPrimitiveOutput",
+                     &properties->prefersLocalInvocationPrimitiveOutput) &&
+      visitor->Visit("prefersCompactVertexOutput",
+                     &properties->prefersCompactVertexOutput) &&
+      visitor->Visit("prefersCompactPrimitiveOutput",
+                     &properties->prefersCompactPrimitiveOutput);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceMeshShaderPropertiesNV* properties) {
+  return
+
+      visitor->Visit("maxDrawMeshTasksCount",
+                     &properties->maxDrawMeshTasksCount) &&
+      visitor->Visit("maxTaskWorkGroupInvocations",
+                     &properties->maxTaskWorkGroupInvocations) &&
+      visitor->Visit("maxTaskWorkGroupSize",
+                     &properties->maxTaskWorkGroupSize) &&
+      visitor->Visit("maxTaskTotalMemorySize",
+                     &properties->maxTaskTotalMemorySize) &&
+      visitor->Visit("maxTaskOutputCount", &properties->maxTaskOutputCount) &&
+      visitor->Visit("maxMeshWorkGroupInvocations",
+                     &properties->maxMeshWorkGroupInvocations) &&
+      visitor->Visit("maxMeshWorkGroupSize",
+                     &properties->maxMeshWorkGroupSize) &&
+      visitor->Visit("maxMeshTotalMemorySize",
+                     &properties->maxMeshTotalMemorySize) &&
+      visitor->Visit("maxMeshOutputVertices",
+                     &properties->maxMeshOutputVertices) &&
+      visitor->Visit("maxMeshOutputPrimitives",
+                     &properties->maxMeshOutputPrimitives) &&
+      visitor->Visit("maxMeshMultiviewViewCount",
+                     &properties->maxMeshMultiviewViewCount) &&
+      visitor->Visit("meshOutputPerVertexGranularity",
+                     &properties->meshOutputPerVertexGranularity) &&
+      visitor->Visit("meshOutputPerPrimitiveGranularity",
+                     &properties->meshOutputPerPrimitiveGranularity);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceMultiDrawFeaturesEXT* features) {
+  return
+
+      visitor->Visit("multiDraw", &features->multiDraw);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceMultiDrawPropertiesEXT* properties) {
+  return
+
+      visitor->Visit("maxMultiDrawCount", &properties->maxMultiDrawCount);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT* features) {
+  return
+
+      visitor->Visit("multisampledRenderToSingleSampled",
+                     &features->multisampledRenderToSingleSampled);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceMultiviewFeatures* features) {
+  return
+
+      visitor->Visit("multiview", &features->multiview) &&
+      visitor->Visit("multiviewGeometryShader",
+                     &features->multiviewGeometryShader) &&
+      visitor->Visit("multiviewTessellationShader",
+                     &features->multiviewTessellationShader);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* properties) {
+  return
+
+      visitor->Visit("perViewPositionAllComponents",
+                     &properties->perViewPositionAllComponents);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM* features) {
+  return
+
+      visitor->Visit("multiviewPerViewRenderAreas",
+                     &features->multiviewPerViewRenderAreas);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM* features) {
+  return
+
+      visitor->Visit("multiviewPerViewViewports",
+                     &features->multiviewPerViewViewports);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceMultiviewProperties* properties) {
+  return
+
+      visitor->Visit("maxMultiviewViewCount",
+                     &properties->maxMultiviewViewCount) &&
+      visitor->Visit("maxMultiviewInstanceIndex",
+                     &properties->maxMultiviewInstanceIndex);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT* features) {
+  return
+
+      visitor->Visit("mutableDescriptorType", &features->mutableDescriptorType);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceNestedCommandBufferFeaturesEXT* features) {
+  return
+
+      visitor->Visit("nestedCommandBuffer", &features->nestedCommandBuffer) &&
+      visitor->Visit("nestedCommandBufferRendering",
+                     &features->nestedCommandBufferRendering) &&
+      visitor->Visit("nestedCommandBufferSimultaneousUse",
+                     &features->nestedCommandBufferSimultaneousUse);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceNestedCommandBufferPropertiesEXT* properties) {
+  return
+
+      visitor->Visit("maxCommandBufferNestingLevel",
+                     &properties->maxCommandBufferNestingLevel);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT* features) {
+  return
+
+      visitor->Visit("nonSeamlessCubeMap", &features->nonSeamlessCubeMap);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceOpacityMicromapFeaturesEXT* features) {
+  return
+
+      visitor->Visit("micromap", &features->micromap) &&
+      visitor->Visit("micromapCaptureReplay",
+                     &features->micromapCaptureReplay) &&
+      visitor->Visit("micromapHostCommands", &features->micromapHostCommands);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceOpacityMicromapPropertiesEXT* properties) {
+  return
+
+      visitor->Visit("maxOpacity2StateSubdivisionLevel",
+                     &properties->maxOpacity2StateSubdivisionLevel) &&
+      visitor->Visit("maxOpacity4StateSubdivisionLevel",
+                     &properties->maxOpacity4StateSubdivisionLevel);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceOpticalFlowFeaturesNV* features) {
+  return
+
+      visitor->Visit("opticalFlow", &features->opticalFlow);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceOpticalFlowPropertiesNV* properties) {
+  return
+
+      visitor->Visit("supportedOutputGridSizes",
+                     &properties->supportedOutputGridSizes) &&
+      visitor->Visit("supportedHintGridSizes",
+                     &properties->supportedHintGridSizes) &&
+      visitor->Visit("hintSupported", &properties->hintSupported) &&
+      visitor->Visit("costSupported", &properties->costSupported) &&
+      visitor->Visit("bidirectionalFlowSupported",
+                     &properties->bidirectionalFlowSupported) &&
+      visitor->Visit("globalFlowSupported", &properties->globalFlowSupported) &&
+      visitor->Visit("minWidth", &properties->minWidth) &&
+      visitor->Visit("minHeight", &properties->minHeight) &&
+      visitor->Visit("maxWidth", &properties->maxWidth) &&
+      visitor->Visit("maxHeight", &properties->maxHeight) &&
+      visitor->Visit("maxNumRegionsOfInterest",
+                     &properties->maxNumRegionsOfInterest);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDevicePCIBusInfoPropertiesEXT* properties) {
+  return
+
+      visitor->Visit("pciDomain", &properties->pciDomain) &&
+      visitor->Visit("pciBus", &properties->pciBus) &&
+      visitor->Visit("pciDevice", &properties->pciDevice) &&
+      visitor->Visit("pciFunction", &properties->pciFunction);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT* features) {
+  return
+
+      visitor->Visit("pageableDeviceLocalMemory",
+                     &features->pageableDeviceLocalMemory);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDevicePerStageDescriptorSetFeaturesNV* features) {
+  return
+
+      visitor->Visit("perStageDescriptorSet",
+                     &features->perStageDescriptorSet) &&
+      visitor->Visit("dynamicPipelineLayout", &features->dynamicPipelineLayout);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDevicePerformanceQueryFeaturesKHR* features) {
+  return
+
+      visitor->Visit("performanceCounterQueryPools",
+                     &features->performanceCounterQueryPools) &&
+      visitor->Visit("performanceCounterMultipleQueryPools",
+                     &features->performanceCounterMultipleQueryPools);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDevicePerformanceQueryPropertiesKHR* properties) {
+  return
+
+      visitor->Visit("allowCommandBufferQueryCopies",
+                     &properties->allowCommandBufferQueryCopies);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDevicePipelineBinaryFeaturesKHR* features) {
+  return
+
+      visitor->Visit("pipelineBinaries", &features->pipelineBinaries);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDevicePipelineBinaryPropertiesKHR* properties) {
+  return
+
+      visitor->Visit("pipelineBinaryInternalCache",
+                     &properties->pipelineBinaryInternalCache) &&
+      visitor->Visit("pipelineBinaryInternalCacheControl",
+                     &properties->pipelineBinaryInternalCacheControl) &&
+      visitor->Visit("pipelineBinaryPrefersInternalCache",
+                     &properties->pipelineBinaryPrefersInternalCache) &&
+      visitor->Visit("pipelineBinaryPrecompiledInternalCache",
+                     &properties->pipelineBinaryPrecompiledInternalCache) &&
+      visitor->Visit("pipelineBinaryCompressedData",
+                     &properties->pipelineBinaryCompressedData);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDevicePipelineCreationCacheControlFeatures* features) {
+  return
+
+      visitor->Visit("pipelineCreationCacheControl",
+                     &features->pipelineCreationCacheControl);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* properties) {
+  return
+
+      visitor->Visit("pipelineExecutableInfo",
+                     &properties->pipelineExecutableInfo);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT* features) {
+  return
+
+      visitor->Visit("pipelineLibraryGroupHandles",
+                     &features->pipelineLibraryGroupHandles);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDevicePipelinePropertiesFeaturesEXT* properties) {
+  return
+
+      visitor->Visit("pipelinePropertiesIdentifier",
+                     &properties->pipelinePropertiesIdentifier);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDevicePipelineProtectedAccessFeatures* features) {
+  return
+
+      visitor->Visit("pipelineProtectedAccess",
+                     &features->pipelineProtectedAccess);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDevicePipelineRobustnessFeatures* features) {
+  return
+
+      visitor->Visit("pipelineRobustness", &features->pipelineRobustness);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDevicePipelineRobustnessProperties* properties) {
+  return
+
+      visitor->Visit("defaultRobustnessStorageBuffers",
+                     &properties->defaultRobustnessStorageBuffers) &&
+      visitor->Visit("defaultRobustnessUniformBuffers",
+                     &properties->defaultRobustnessUniformBuffers) &&
+      visitor->Visit("defaultRobustnessVertexInputs",
+                     &properties->defaultRobustnessVertexInputs) &&
+      visitor->Visit("defaultRobustnessImages",
+                     &properties->defaultRobustnessImages);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDevicePointClippingProperties* properties) {
+  return
+
+      visitor->Visit("pointClippingBehavior",
+                     &properties->pointClippingBehavior);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDevicePresentBarrierFeaturesNV* features) {
+  return
+
+      visitor->Visit("presentBarrier", &features->presentBarrier);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDevicePresentIdFeaturesKHR* features) {
+  return
+
+      visitor->Visit("presentId", &features->presentId);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDevicePresentWaitFeaturesKHR* features) {
+  return
+
+      visitor->Visit("presentWait", &features->presentWait);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT* features) {
+  return
+
+      visitor->Visit("primitiveTopologyListRestart",
+                     &features->primitiveTopologyListRestart) &&
+      visitor->Visit("primitiveTopologyPatchListRestart",
+                     &features->primitiveTopologyPatchListRestart);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT* features) {
+  return
+
+      visitor->Visit("primitivesGeneratedQuery",
+                     &features->primitivesGeneratedQuery) &&
+      visitor->Visit(
+          "primitivesGeneratedQueryWithRasterizerDiscard",
+          &features->primitivesGeneratedQueryWithRasterizerDiscard) &&
+      visitor->Visit("primitivesGeneratedQueryWithNonZeroStreams",
+                     &features->primitivesGeneratedQueryWithNonZeroStreams);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDevicePrivateDataFeatures* features) {
+  return
+
+      visitor->Visit("privateData", &features->privateData);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceProtectedMemoryFeatures* features) {
+  return
+
+      visitor->Visit("protectedMemory", &features->protectedMemory);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceProtectedMemoryProperties* properties) {
+  return
+
+      visitor->Visit("protectedNoFault", &properties->protectedNoFault);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceProvokingVertexFeaturesEXT* features) {
+  return
+
+      visitor->Visit("provokingVertexLast", &features->provokingVertexLast) &&
+      visitor->Visit("transformFeedbackPreservesProvokingVertex",
+                     &features->transformFeedbackPreservesProvokingVertex);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceProvokingVertexPropertiesEXT* properties) {
+  return
+
+      visitor->Visit("provokingVertexModePerPipeline",
+                     &properties->provokingVertexModePerPipeline) &&
+      visitor->Visit(
+          "transformFeedbackPreservesTriangleFanProvokingVertex",
+          &properties->transformFeedbackPreservesTriangleFanProvokingVertex);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDevicePushDescriptorProperties* properties) {
+  return
+
+      visitor->Visit("maxPushDescriptors", &properties->maxPushDescriptors);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT* features) {
+  return
+
+      visitor->Visit("formatRgba10x6WithoutYCbCrSampler",
+                     &features->formatRgba10x6WithoutYCbCrSampler);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT* features) {
+  return
+
+      visitor->Visit("rasterizationOrderColorAttachmentAccess",
+                     &features->rasterizationOrderColorAttachmentAccess) &&
+      visitor->Visit("rasterizationOrderDepthAttachmentAccess",
+                     &features->rasterizationOrderDepthAttachmentAccess) &&
+      visitor->Visit("rasterizationOrderStencilAttachmentAccess",
+                     &features->rasterizationOrderStencilAttachmentAccess);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceRawAccessChainsFeaturesNV* features) {
+  return
+
+      visitor->Visit("shaderRawAccessChains", &features->shaderRawAccessChains);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceRayQueryFeaturesKHR* features) {
+  return
+
+      visitor->Visit("rayQuery", &features->rayQuery);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV* features) {
+  return
+
+      visitor->Visit("rayTracingInvocationReorder",
+                     &features->rayTracingInvocationReorder);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV* properties) {
+  return
+
+      visitor->Visit("rayTracingInvocationReorderReorderingHint",
+                     &properties->rayTracingInvocationReorderReorderingHint);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR* features) {
+  return
+
+      visitor->Visit("rayTracingMaintenance1",
+                     &features->rayTracingMaintenance1) &&
+      visitor->Visit("rayTracingPipelineTraceRaysIndirect2",
+                     &features->rayTracingPipelineTraceRaysIndirect2);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceRayTracingMotionBlurFeaturesNV* features) {
+  return
+
+      visitor->Visit("rayTracingMotionBlur", &features->rayTracingMotionBlur) &&
+      visitor->Visit("rayTracingMotionBlurPipelineTraceRaysIndirect",
+                     &features->rayTracingMotionBlurPipelineTraceRaysIndirect);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceRayTracingPipelineFeaturesKHR* features) {
+  return
+
+      visitor->Visit("rayTracingPipeline", &features->rayTracingPipeline) &&
+      visitor->Visit(
+          "rayTracingPipelineShaderGroupHandleCaptureReplay",
+          &features->rayTracingPipelineShaderGroupHandleCaptureReplay) &&
+      visitor->Visit(
+          "rayTracingPipelineShaderGroupHandleCaptureReplayMixed",
+          &features->rayTracingPipelineShaderGroupHandleCaptureReplayMixed) &&
+      visitor->Visit("rayTracingPipelineTraceRaysIndirect",
+                     &features->rayTracingPipelineTraceRaysIndirect) &&
+      visitor->Visit("rayTraversalPrimitiveCulling",
+                     &features->rayTraversalPrimitiveCulling);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceRayTracingPipelinePropertiesKHR* properties) {
+  return
+
+      visitor->Visit("shaderGroupHandleSize",
+                     &properties->shaderGroupHandleSize) &&
+      visitor->Visit("maxRayRecursionDepth",
+                     &properties->maxRayRecursionDepth) &&
+      visitor->Visit("maxShaderGroupStride",
+                     &properties->maxShaderGroupStride) &&
+      visitor->Visit("shaderGroupBaseAlignment",
+                     &properties->shaderGroupBaseAlignment) &&
+      visitor->Visit("shaderGroupHandleCaptureReplaySize",
+                     &properties->shaderGroupHandleCaptureReplaySize) &&
+      visitor->Visit("maxRayDispatchInvocationCount",
+                     &properties->maxRayDispatchInvocationCount) &&
+      visitor->Visit("shaderGroupHandleAlignment",
+                     &properties->shaderGroupHandleAlignment) &&
+      visitor->Visit("maxRayHitAttributeSize",
+                     &properties->maxRayHitAttributeSize);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR* features) {
+  return
+
+      visitor->Visit("rayTracingPositionFetch",
+                     &features->rayTracingPositionFetch);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceRayTracingPropertiesNV* properties) {
+  return
+
+      visitor->Visit("shaderGroupHandleSize",
+                     &properties->shaderGroupHandleSize) &&
+      visitor->Visit("maxRecursionDepth", &properties->maxRecursionDepth) &&
+      visitor->Visit("maxShaderGroupStride",
+                     &properties->maxShaderGroupStride) &&
+      visitor->Visit("shaderGroupBaseAlignment",
+                     &properties->shaderGroupBaseAlignment) &&
+      visitor->Visit("maxGeometryCount", &properties->maxGeometryCount) &&
+      visitor->Visit("maxInstanceCount", &properties->maxInstanceCount) &&
+      visitor->Visit("maxTriangleCount", &properties->maxTriangleCount) &&
+      visitor->Visit("maxDescriptorSetAccelerationStructures",
+                     &properties->maxDescriptorSetAccelerationStructures);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceRayTracingValidationFeaturesNV* features) {
+  return
+
+      visitor->Visit("rayTracingValidation", &features->rayTracingValidation);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG* features) {
+  return
+
+      visitor->Visit("relaxedLineRasterization",
+                     &features->relaxedLineRasterization);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceRenderPassStripedFeaturesARM* features) {
+  return
+
+      visitor->Visit("renderPassStriped", &features->renderPassStriped);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceRenderPassStripedPropertiesARM* properties) {
+  return
+
+      visitor->Visit("renderPassStripeGranularity",
+                     &properties->renderPassStripeGranularity) &&
+      visitor->Visit("maxRenderPassStripes", &properties->maxRenderPassStripes);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* features) {
+  return
+
+      visitor->Visit("representativeFragmentTest",
+                     &features->representativeFragmentTest);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceRobustness2FeaturesEXT* features) {
+  return
+
+      visitor->Visit("robustBufferAccess2", &features->robustBufferAccess2) &&
+      visitor->Visit("robustImageAccess2", &features->robustImageAccess2) &&
+      visitor->Visit("nullDescriptor", &features->nullDescriptor);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceRobustness2PropertiesEXT* properties) {
+  return
+
+      visitor->Visit("robustStorageBufferAccessSizeAlignment",
+                     &properties->robustStorageBufferAccessSizeAlignment) &&
+      visitor->Visit("robustUniformBufferAccessSizeAlignment",
+                     &properties->robustUniformBufferAccessSizeAlignment);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceSampleLocationsPropertiesEXT* properties) {
+  return
+
+      visitor->Visit("sampleLocationSampleCounts",
+                     &properties->sampleLocationSampleCounts) &&
+      visitor->Visit("maxSampleLocationGridSize",
+                     &properties->maxSampleLocationGridSize) &&
+      visitor->Visit("sampleLocationCoordinateRange",
+                     &properties->sampleLocationCoordinateRange) &&
+      visitor->Visit("sampleLocationSubPixelBits",
+                     &properties->sampleLocationSubPixelBits) &&
+      visitor->Visit("variableSampleLocations",
+                     &properties->variableSampleLocations);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceSamplerFilterMinmaxProperties* properties) {
+  return
+
+      visitor->Visit("filterMinmaxSingleComponentFormats",
+                     &properties->filterMinmaxSingleComponentFormats) &&
+      visitor->Visit("filterMinmaxImageComponentMapping",
+                     &properties->filterMinmaxImageComponentMapping);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceSamplerYcbcrConversionFeatures* features) {
+  return
+
+      visitor->Visit("samplerYcbcrConversion",
+                     &features->samplerYcbcrConversion);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceScalarBlockLayoutFeatures* features) {
+  return
+
+      visitor->Visit("scalarBlockLayout", &features->scalarBlockLayout);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceSchedulingControlsFeaturesARM* features) {
+  return
+
+      visitor->Visit("schedulingControls", &features->schedulingControls);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceSchedulingControlsPropertiesARM* properties) {
+  return
+
+      visitor->Visit("schedulingControlsFlags",
+                     &properties->schedulingControlsFlags);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* features) {
+  return
+
+      visitor->Visit("separateDepthStencilLayouts",
+                     &features->separateDepthStencilLayouts);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV* features) {
+  return
+
+      visitor->Visit("shaderFloat16VectorAtomics",
+                     &features->shaderFloat16VectorAtomics);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT* features) {
+  return
+
+      visitor->Visit("shaderBufferFloat16Atomics",
+                     &features->shaderBufferFloat16Atomics) &&
+      visitor->Visit("shaderBufferFloat16AtomicAdd",
+                     &features->shaderBufferFloat16AtomicAdd) &&
+      visitor->Visit("shaderBufferFloat16AtomicMinMax",
+                     &features->shaderBufferFloat16AtomicMinMax) &&
+      visitor->Visit("shaderBufferFloat32AtomicMinMax",
+                     &features->shaderBufferFloat32AtomicMinMax) &&
+      visitor->Visit("shaderBufferFloat64AtomicMinMax",
+                     &features->shaderBufferFloat64AtomicMinMax) &&
+      visitor->Visit("shaderSharedFloat16Atomics",
+                     &features->shaderSharedFloat16Atomics) &&
+      visitor->Visit("shaderSharedFloat16AtomicAdd",
+                     &features->shaderSharedFloat16AtomicAdd) &&
+      visitor->Visit("shaderSharedFloat16AtomicMinMax",
+                     &features->shaderSharedFloat16AtomicMinMax) &&
+      visitor->Visit("shaderSharedFloat32AtomicMinMax",
+                     &features->shaderSharedFloat32AtomicMinMax) &&
+      visitor->Visit("shaderSharedFloat64AtomicMinMax",
+                     &features->shaderSharedFloat64AtomicMinMax) &&
+      visitor->Visit("shaderImageFloat32AtomicMinMax",
+                     &features->shaderImageFloat32AtomicMinMax) &&
+      visitor->Visit("sparseImageFloat32AtomicMinMax",
+                     &features->sparseImageFloat32AtomicMinMax);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* features) {
+  return
+
+      visitor->Visit("shaderBufferFloat32Atomics",
+                     &features->shaderBufferFloat32Atomics) &&
+      visitor->Visit("shaderBufferFloat32AtomicAdd",
+                     &features->shaderBufferFloat32AtomicAdd) &&
+      visitor->Visit("shaderBufferFloat64Atomics",
+                     &features->shaderBufferFloat64Atomics) &&
+      visitor->Visit("shaderBufferFloat64AtomicAdd",
+                     &features->shaderBufferFloat64AtomicAdd) &&
+      visitor->Visit("shaderSharedFloat32Atomics",
+                     &features->shaderSharedFloat32Atomics) &&
+      visitor->Visit("shaderSharedFloat32AtomicAdd",
+                     &features->shaderSharedFloat32AtomicAdd) &&
+      visitor->Visit("shaderSharedFloat64Atomics",
+                     &features->shaderSharedFloat64Atomics) &&
+      visitor->Visit("shaderSharedFloat64AtomicAdd",
+                     &features->shaderSharedFloat64AtomicAdd) &&
+      visitor->Visit("shaderImageFloat32Atomics",
+                     &features->shaderImageFloat32Atomics) &&
+      visitor->Visit("shaderImageFloat32AtomicAdd",
+                     &features->shaderImageFloat32AtomicAdd) &&
+      visitor->Visit("sparseImageFloat32Atomics",
+                     &features->sparseImageFloat32Atomics) &&
+      visitor->Visit("sparseImageFloat32AtomicAdd",
+                     &features->sparseImageFloat32AtomicAdd);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceShaderAtomicInt64Features* features) {
+  return
+
+      visitor->Visit("shaderBufferInt64Atomics",
+                     &features->shaderBufferInt64Atomics) &&
+      visitor->Visit("shaderSharedInt64Atomics",
+                     &features->shaderSharedInt64Atomics);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceShaderClockFeaturesKHR* features) {
+  return
+
+      visitor->Visit("shaderSubgroupClock", &features->shaderSubgroupClock) &&
+      visitor->Visit("shaderDeviceClock", &features->shaderDeviceClock);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM* features) {
+  return
+
+      visitor->Visit("shaderCoreBuiltins", &features->shaderCoreBuiltins);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM* properties) {
+  return
+
+      visitor->Visit("shaderCoreMask", &properties->shaderCoreMask) &&
+      visitor->Visit("shaderCoreCount", &properties->shaderCoreCount) &&
+      visitor->Visit("shaderWarpsPerCore", &properties->shaderWarpsPerCore);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceShaderCoreProperties2AMD* properties) {
+  return
+
+      visitor->Visit("shaderCoreFeatures", &properties->shaderCoreFeatures) &&
+      visitor->Visit("activeComputeUnitCount",
+                     &properties->activeComputeUnitCount);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceShaderCorePropertiesAMD* properties) {
+  return
+
+      visitor->Visit("shaderEngineCount", &properties->shaderEngineCount) &&
+      visitor->Visit("shaderArraysPerEngineCount",
+                     &properties->shaderArraysPerEngineCount) &&
+      visitor->Visit("computeUnitsPerShaderArray",
+                     &properties->computeUnitsPerShaderArray) &&
+      visitor->Visit("simdPerComputeUnit", &properties->simdPerComputeUnit) &&
+      visitor->Visit("wavefrontsPerSimd", &properties->wavefrontsPerSimd) &&
+      visitor->Visit("wavefrontSize", &properties->wavefrontSize) &&
+      visitor->Visit("sgprsPerSimd", &properties->sgprsPerSimd) &&
+      visitor->Visit("minSgprAllocation", &properties->minSgprAllocation) &&
+      visitor->Visit("maxSgprAllocation", &properties->maxSgprAllocation) &&
+      visitor->Visit("sgprAllocationGranularity",
+                     &properties->sgprAllocationGranularity) &&
+      visitor->Visit("vgprsPerSimd", &properties->vgprsPerSimd) &&
+      visitor->Visit("minVgprAllocation", &properties->minVgprAllocation) &&
+      visitor->Visit("maxVgprAllocation", &properties->maxVgprAllocation) &&
+      visitor->Visit("vgprAllocationGranularity",
+                     &properties->vgprAllocationGranularity);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceShaderCorePropertiesARM* properties) {
+  return
+
+      visitor->Visit("pixelRate", &properties->pixelRate) &&
+      visitor->Visit("texelRate", &properties->texelRate) &&
+      visitor->Visit("fmaRate", &properties->fmaRate);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures* features) {
+  return
+
+      visitor->Visit("shaderDemoteToHelperInvocation",
+                     &features->shaderDemoteToHelperInvocation);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceShaderDrawParametersFeatures* features) {
+  return
+
+      visitor->Visit("shaderDrawParameters", &features->shaderDrawParameters);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD* features) {
+  return
+
+      visitor->Visit("shaderEarlyAndLateFragmentTests",
+                     &features->shaderEarlyAndLateFragmentTests);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceShaderExpectAssumeFeatures* features) {
+  return
+
+      visitor->Visit("shaderExpectAssume", &features->shaderExpectAssume);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceShaderFloatControls2Features* features) {
+  return
+
+      visitor->Visit("shaderFloatControls2", &features->shaderFloatControls2);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT* features) {
+  return
+
+      visitor->Visit("shaderImageInt64Atomics",
+                     &features->shaderImageInt64Atomics) &&
+      visitor->Visit("sparseImageInt64Atomics",
+                     &features->sparseImageInt64Atomics);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceShaderImageFootprintFeaturesNV* features) {
+  return
+
+      visitor->Visit("imageFootprint", &features->imageFootprint);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceShaderIntegerDotProductFeatures* features) {
+  return
+
+      visitor->Visit("shaderIntegerDotProduct",
+                     &features->shaderIntegerDotProduct);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceShaderIntegerDotProductProperties* properties) {
+  return
+
+      visitor->Visit("integerDotProduct8BitUnsignedAccelerated",
+                     &properties->integerDotProduct8BitUnsignedAccelerated) &&
+      visitor->Visit("integerDotProduct8BitSignedAccelerated",
+                     &properties->integerDotProduct8BitSignedAccelerated) &&
+      visitor->Visit(
+          "integerDotProduct8BitMixedSignednessAccelerated",
+          &properties->integerDotProduct8BitMixedSignednessAccelerated) &&
+      visitor->Visit(
+          "integerDotProduct4x8BitPackedUnsignedAccelerated",
+          &properties->integerDotProduct4x8BitPackedUnsignedAccelerated) &&
+      visitor->Visit(
+          "integerDotProduct4x8BitPackedSignedAccelerated",
+          &properties->integerDotProduct4x8BitPackedSignedAccelerated) &&
+      visitor->Visit(
+          "integerDotProduct4x8BitPackedMixedSignednessAccelerated",
+          &properties
+               ->integerDotProduct4x8BitPackedMixedSignednessAccelerated) &&
+      visitor->Visit("integerDotProduct16BitUnsignedAccelerated",
+                     &properties->integerDotProduct16BitUnsignedAccelerated) &&
+      visitor->Visit("integerDotProduct16BitSignedAccelerated",
+                     &properties->integerDotProduct16BitSignedAccelerated) &&
+      visitor->Visit(
+          "integerDotProduct16BitMixedSignednessAccelerated",
+          &properties->integerDotProduct16BitMixedSignednessAccelerated) &&
+      visitor->Visit("integerDotProduct32BitUnsignedAccelerated",
+                     &properties->integerDotProduct32BitUnsignedAccelerated) &&
+      visitor->Visit("integerDotProduct32BitSignedAccelerated",
+                     &properties->integerDotProduct32BitSignedAccelerated) &&
+      visitor->Visit(
+          "integerDotProduct32BitMixedSignednessAccelerated",
+          &properties->integerDotProduct32BitMixedSignednessAccelerated) &&
+      visitor->Visit("integerDotProduct64BitUnsignedAccelerated",
+                     &properties->integerDotProduct64BitUnsignedAccelerated) &&
+      visitor->Visit("integerDotProduct64BitSignedAccelerated",
+                     &properties->integerDotProduct64BitSignedAccelerated) &&
+      visitor->Visit(
+          "integerDotProduct64BitMixedSignednessAccelerated",
+          &properties->integerDotProduct64BitMixedSignednessAccelerated) &&
+      visitor->Visit(
+          "integerDotProductAccumulatingSaturating8BitUnsignedAccelerated",
+          &properties
+               ->integerDotProductAccumulatingSaturating8BitUnsignedAccelerated) &&
+      visitor->Visit(
+          "integerDotProductAccumulatingSaturating8BitSignedAccelerated",
+          &properties
+               ->integerDotProductAccumulatingSaturating8BitSignedAccelerated) &&
+      visitor->Visit(
+          "integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerate"
+          "d",
+          &properties
+               ->integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated) &&
+      visitor->Visit(
+          "integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerat"
+          "ed",
+          &properties
+               ->integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated) &&
+      visitor->Visit(
+          "integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerate"
+          "d",
+          &properties
+               ->integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated) &&
+      visitor->Visit(
+          "integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAc"
+          "celerated",
+          &properties
+               ->integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated) &&
+      visitor->Visit(
+          "integerDotProductAccumulatingSaturating16BitUnsignedAccelerated",
+          &properties
+               ->integerDotProductAccumulatingSaturating16BitUnsignedAccelerated) &&
+      visitor->Visit(
+          "integerDotProductAccumulatingSaturating16BitSignedAccelerated",
+          &properties
+               ->integerDotProductAccumulatingSaturating16BitSignedAccelerated) &&
+      visitor->Visit(
+          "integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerat"
+          "ed",
+          &properties
+               ->integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated) &&
+      visitor->Visit(
+          "integerDotProductAccumulatingSaturating32BitUnsignedAccelerated",
+          &properties
+               ->integerDotProductAccumulatingSaturating32BitUnsignedAccelerated) &&
+      visitor->Visit(
+          "integerDotProductAccumulatingSaturating32BitSignedAccelerated",
+          &properties
+               ->integerDotProductAccumulatingSaturating32BitSignedAccelerated) &&
+      visitor->Visit(
+          "integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerat"
+          "ed",
+          &properties
+               ->integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated) &&
+      visitor->Visit(
+          "integerDotProductAccumulatingSaturating64BitUnsignedAccelerated",
+          &properties
+               ->integerDotProductAccumulatingSaturating64BitUnsignedAccelerated) &&
+      visitor->Visit(
+          "integerDotProductAccumulatingSaturating64BitSignedAccelerated",
+          &properties
+               ->integerDotProductAccumulatingSaturating64BitSignedAccelerated) &&
+      visitor->Visit(
+          "integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerat"
+          "ed",
+          &properties
+               ->integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* features) {
+  return
+
+      visitor->Visit("shaderIntegerFunctions2",
+                     &features->shaderIntegerFunctions2);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR* features) {
+  return
+
+      visitor->Visit("shaderMaximalReconvergence",
+                     &features->shaderMaximalReconvergence);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT* features) {
+  return
+
+      visitor->Visit("shaderModuleIdentifier",
+                     &features->shaderModuleIdentifier);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT* properties) {
+  return
+
+      visitor->Visit("shaderModuleIdentifierAlgorithmUUID",
+                     &properties->shaderModuleIdentifierAlgorithmUUID);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceShaderObjectFeaturesEXT* features) {
+  return
+
+      visitor->Visit("shaderObject", &features->shaderObject);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceShaderObjectPropertiesEXT* properties) {
+  return
+
+      visitor->Visit("shaderBinaryUUID", &properties->shaderBinaryUUID) &&
+      visitor->Visit("shaderBinaryVersion", &properties->shaderBinaryVersion);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceShaderQuadControlFeaturesKHR* features) {
+  return
+
+      visitor->Visit("shaderQuadControl", &features->shaderQuadControl);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR* features) {
+  return
+
+      visitor->Visit("shaderRelaxedExtendedInstruction",
+                     &features->shaderRelaxedExtendedInstruction);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT* features) {
+  return
+
+      visitor->Visit("shaderReplicatedComposites",
+                     &features->shaderReplicatedComposites);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* features) {
+  return
+
+      visitor->Visit("shaderSMBuiltins", &features->shaderSMBuiltins);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceShaderSMBuiltinsPropertiesNV* properties) {
+  return
+
+      visitor->Visit("shaderSMCount", &properties->shaderSMCount) &&
+      visitor->Visit("shaderWarpsPerSM", &properties->shaderWarpsPerSM);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures* features) {
+  return
+
+      visitor->Visit("shaderSubgroupExtendedTypes",
+                     &features->shaderSubgroupExtendedTypes);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceShaderSubgroupRotateFeatures* features) {
+  return
+
+      visitor->Visit("shaderSubgroupRotate", &features->shaderSubgroupRotate) &&
+      visitor->Visit("shaderSubgroupRotateClustered",
+                     &features->shaderSubgroupRotateClustered);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR* features) {
+  return
+
+      visitor->Visit("shaderSubgroupUniformControlFlow",
+                     &features->shaderSubgroupUniformControlFlow);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceShaderTerminateInvocationFeatures* features) {
+  return
+
+      visitor->Visit("shaderTerminateInvocation",
+                     &features->shaderTerminateInvocation);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceShaderTileImageFeaturesEXT* features) {
+  return
+
+      visitor->Visit("shaderTileImageColorReadAccess",
+                     &features->shaderTileImageColorReadAccess) &&
+      visitor->Visit("shaderTileImageDepthReadAccess",
+                     &features->shaderTileImageDepthReadAccess) &&
+      visitor->Visit("shaderTileImageStencilReadAccess",
+                     &features->shaderTileImageStencilReadAccess);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceShaderTileImagePropertiesEXT* properties) {
+  return
+
+      visitor->Visit("shaderTileImageCoherentReadAccelerated",
+                     &properties->shaderTileImageCoherentReadAccelerated) &&
+      visitor->Visit(
+          "shaderTileImageReadSampleFromPixelRateInvocation",
+          &properties->shaderTileImageReadSampleFromPixelRateInvocation) &&
+      visitor->Visit("shaderTileImageReadFromHelperInvocation",
+                     &properties->shaderTileImageReadFromHelperInvocation);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceShadingRateImageFeaturesNV* features) {
+  return
+
+      visitor->Visit("shadingRateImage", &features->shadingRateImage) &&
+      visitor->Visit("shadingRateCoarseSampleOrder",
+                     &features->shadingRateCoarseSampleOrder);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceShadingRateImagePropertiesNV* properties) {
+  return
+
+      visitor->Visit("shadingRateTexelSize",
+                     &properties->shadingRateTexelSize) &&
+      visitor->Visit("shadingRatePaletteSize",
+                     &properties->shadingRatePaletteSize) &&
+      visitor->Visit("shadingRateMaxCoarseSamples",
+                     &properties->shadingRateMaxCoarseSamples);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceSubgroupProperties* properties) {
+  return
+
+      visitor->Visit("subgroupSize", &properties->subgroupSize) &&
+      visitor->Visit("supportedStages", &properties->supportedStages) &&
+      visitor->Visit("supportedOperations", &properties->supportedOperations) &&
+      visitor->Visit("quadOperationsInAllStages",
+                     &properties->quadOperationsInAllStages);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceSubgroupSizeControlFeatures* features) {
+  return
+
+      visitor->Visit("subgroupSizeControl", &features->subgroupSizeControl) &&
+      visitor->Visit("computeFullSubgroups", &features->computeFullSubgroups);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceSubgroupSizeControlProperties* properties) {
+  return
+
+      visitor->Visit("minSubgroupSize", &properties->minSubgroupSize) &&
+      visitor->Visit("maxSubgroupSize", &properties->maxSubgroupSize) &&
+      visitor->Visit("maxComputeWorkgroupSubgroups",
+                     &properties->maxComputeWorkgroupSubgroups) &&
+      visitor->Visit("requiredSubgroupSizeStages",
+                     &properties->requiredSubgroupSizeStages);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT* features) {
+  return
+
+      visitor->Visit("subpassMergeFeedback", &features->subpassMergeFeedback);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceSubpassShadingFeaturesHUAWEI* features) {
+  return
+
+      visitor->Visit("subpassShading", &features->subpassShading);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceSubpassShadingPropertiesHUAWEI* properties) {
+  return
+
+      visitor->Visit("maxSubpassShadingWorkgroupSizeAspectRatio",
+                     &properties->maxSubpassShadingWorkgroupSizeAspectRatio);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT* features) {
+  return
+
+      visitor->Visit("swapchainMaintenance1", &features->swapchainMaintenance1);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceSynchronization2Features* features) {
+  return
+
+      visitor->Visit("synchronization2", &features->synchronization2);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* features) {
+  return
+
+      visitor->Visit("texelBufferAlignment", &features->texelBufferAlignment);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceTexelBufferAlignmentProperties* properties) {
+  return
+
+      visitor->Visit("storageTexelBufferOffsetAlignmentBytes",
+                     &properties->storageTexelBufferOffsetAlignmentBytes) &&
+      visitor->Visit(
+          "storageTexelBufferOffsetSingleTexelAlignment",
+          &properties->storageTexelBufferOffsetSingleTexelAlignment) &&
+      visitor->Visit("uniformTexelBufferOffsetAlignmentBytes",
+                     &properties->uniformTexelBufferOffsetAlignmentBytes) &&
+      visitor->Visit("uniformTexelBufferOffsetSingleTexelAlignment",
+                     &properties->uniformTexelBufferOffsetSingleTexelAlignment);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceTextureCompressionASTCHDRFeatures* features) {
+  return
+
+      visitor->Visit("textureCompressionASTC_HDR",
+                     &features->textureCompressionASTC_HDR);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceTilePropertiesFeaturesQCOM* properties) {
+  return
+
+      visitor->Visit("tileProperties", &properties->tileProperties);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceTimelineSemaphoreFeatures* features) {
+  return
+
+      visitor->Visit("timelineSemaphore", &features->timelineSemaphore);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceTimelineSemaphoreProperties* properties) {
+  return
+
+      visitor->Visit("maxTimelineSemaphoreValueDifference",
+                     &properties->maxTimelineSemaphoreValueDifference);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceTransformFeedbackFeaturesEXT* features) {
+  return
+
+      visitor->Visit("transformFeedback", &features->transformFeedback) &&
+      visitor->Visit("geometryStreams", &features->geometryStreams);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceTransformFeedbackPropertiesEXT* properties) {
+  return
+
+      visitor->Visit("maxTransformFeedbackStreams",
+                     &properties->maxTransformFeedbackStreams) &&
+      visitor->Visit("maxTransformFeedbackBuffers",
+                     &properties->maxTransformFeedbackBuffers) &&
+      visitor->Visit("maxTransformFeedbackBufferSize",
+                     &properties->maxTransformFeedbackBufferSize) &&
+      visitor->Visit("maxTransformFeedbackStreamDataSize",
+                     &properties->maxTransformFeedbackStreamDataSize) &&
+      visitor->Visit("maxTransformFeedbackBufferDataSize",
+                     &properties->maxTransformFeedbackBufferDataSize) &&
+      visitor->Visit("maxTransformFeedbackBufferDataStride",
+                     &properties->maxTransformFeedbackBufferDataStride) &&
+      visitor->Visit("transformFeedbackQueries",
+                     &properties->transformFeedbackQueries) &&
+      visitor->Visit("transformFeedbackStreamsLinesTriangles",
+                     &properties->transformFeedbackStreamsLinesTriangles) &&
+      visitor->Visit("transformFeedbackRasterizationStreamSelect",
+                     &properties->transformFeedbackRasterizationStreamSelect) &&
+      visitor->Visit("transformFeedbackDraw",
+                     &properties->transformFeedbackDraw);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceUniformBufferStandardLayoutFeatures* features) {
+  return
+
+      visitor->Visit("uniformBufferStandardLayout",
+                     &features->uniformBufferStandardLayout);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceVariablePointersFeatures* features) {
+  return
+
+      visitor->Visit("variablePointersStorageBuffer",
+                     &features->variablePointersStorageBuffer) &&
+      visitor->Visit("variablePointers", &features->variablePointers);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceVertexAttributeDivisorFeatures* features) {
+  return
+
+      visitor->Visit("vertexAttributeInstanceRateDivisor",
+                     &features->vertexAttributeInstanceRateDivisor) &&
+      visitor->Visit("vertexAttributeInstanceRateZeroDivisor",
+                     &features->vertexAttributeInstanceRateZeroDivisor);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceVertexAttributeDivisorProperties* properties) {
+  return
+
+      visitor->Visit("maxVertexAttribDivisor",
+                     &properties->maxVertexAttribDivisor) &&
+      visitor->Visit("supportsNonZeroFirstInstance",
+                     &properties->supportsNonZeroFirstInstance);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* properties) {
+  return
+
+      visitor->Visit("maxVertexAttribDivisor",
+                     &properties->maxVertexAttribDivisor);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT* features) {
+  return
+
+      visitor->Visit("vertexInputDynamicState",
+                     &features->vertexInputDynamicState);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceVideoMaintenance1FeaturesKHR* features) {
+  return
+
+      visitor->Visit("videoMaintenance1", &features->videoMaintenance1);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceVulkan11Features* features) {
+  return
+
+      visitor->Visit("storageBuffer16BitAccess",
+                     &features->storageBuffer16BitAccess) &&
+      visitor->Visit("uniformAndStorageBuffer16BitAccess",
+                     &features->uniformAndStorageBuffer16BitAccess) &&
+      visitor->Visit("storagePushConstant16",
+                     &features->storagePushConstant16) &&
+      visitor->Visit("storageInputOutput16", &features->storageInputOutput16) &&
+      visitor->Visit("multiview", &features->multiview) &&
+      visitor->Visit("multiviewGeometryShader",
+                     &features->multiviewGeometryShader) &&
+      visitor->Visit("multiviewTessellationShader",
+                     &features->multiviewTessellationShader) &&
+      visitor->Visit("variablePointersStorageBuffer",
+                     &features->variablePointersStorageBuffer) &&
+      visitor->Visit("variablePointers", &features->variablePointers) &&
+      visitor->Visit("protectedMemory", &features->protectedMemory) &&
+      visitor->Visit("samplerYcbcrConversion",
+                     &features->samplerYcbcrConversion) &&
+      visitor->Visit("shaderDrawParameters", &features->shaderDrawParameters);
 }
 
 template <typename Visitor>
@@ -1389,28 +5621,97 @@ inline bool Iterate(Visitor* visitor,
 
 template <typename Visitor>
 inline bool Iterate(Visitor* visitor,
-                    VkPhysicalDeviceVulkan11Features* features) {
+                    VkPhysicalDeviceVulkan12Features* features) {
   return
 
-      visitor->Visit("storageBuffer16BitAccess",
-                     &features->storageBuffer16BitAccess) &&
-      visitor->Visit("uniformAndStorageBuffer16BitAccess",
-                     &features->uniformAndStorageBuffer16BitAccess) &&
-      visitor->Visit("storagePushConstant16",
-                     &features->storagePushConstant16) &&
-      visitor->Visit("storageInputOutput16", &features->storageInputOutput16) &&
-      visitor->Visit("multiview", &features->multiview) &&
-      visitor->Visit("multiviewGeometryShader",
-                     &features->multiviewGeometryShader) &&
-      visitor->Visit("multiviewTessellationShader",
-                     &features->multiviewTessellationShader) &&
-      visitor->Visit("variablePointersStorageBuffer",
-                     &features->variablePointersStorageBuffer) &&
-      visitor->Visit("variablePointers", &features->variablePointers) &&
-      visitor->Visit("protectedMemory", &features->protectedMemory) &&
-      visitor->Visit("samplerYcbcrConversion",
-                     &features->samplerYcbcrConversion) &&
-      visitor->Visit("shaderDrawParameters", &features->shaderDrawParameters);
+      visitor->Visit("samplerMirrorClampToEdge",
+                     &features->samplerMirrorClampToEdge) &&
+      visitor->Visit("drawIndirectCount", &features->drawIndirectCount) &&
+      visitor->Visit("storageBuffer8BitAccess",
+                     &features->storageBuffer8BitAccess) &&
+      visitor->Visit("uniformAndStorageBuffer8BitAccess",
+                     &features->uniformAndStorageBuffer8BitAccess) &&
+      visitor->Visit("storagePushConstant8", &features->storagePushConstant8) &&
+      visitor->Visit("shaderBufferInt64Atomics",
+                     &features->shaderBufferInt64Atomics) &&
+      visitor->Visit("shaderSharedInt64Atomics",
+                     &features->shaderSharedInt64Atomics) &&
+      visitor->Visit("shaderFloat16", &features->shaderFloat16) &&
+      visitor->Visit("shaderInt8", &features->shaderInt8) &&
+      visitor->Visit("descriptorIndexing", &features->descriptorIndexing) &&
+      visitor->Visit("shaderInputAttachmentArrayDynamicIndexing",
+                     &features->shaderInputAttachmentArrayDynamicIndexing) &&
+      visitor->Visit("shaderUniformTexelBufferArrayDynamicIndexing",
+                     &features->shaderUniformTexelBufferArrayDynamicIndexing) &&
+      visitor->Visit("shaderStorageTexelBufferArrayDynamicIndexing",
+                     &features->shaderStorageTexelBufferArrayDynamicIndexing) &&
+      visitor->Visit("shaderUniformBufferArrayNonUniformIndexing",
+                     &features->shaderUniformBufferArrayNonUniformIndexing) &&
+      visitor->Visit("shaderSampledImageArrayNonUniformIndexing",
+                     &features->shaderSampledImageArrayNonUniformIndexing) &&
+      visitor->Visit("shaderStorageBufferArrayNonUniformIndexing",
+                     &features->shaderStorageBufferArrayNonUniformIndexing) &&
+      visitor->Visit("shaderStorageImageArrayNonUniformIndexing",
+                     &features->shaderStorageImageArrayNonUniformIndexing) &&
+      visitor->Visit("shaderInputAttachmentArrayNonUniformIndexing",
+                     &features->shaderInputAttachmentArrayNonUniformIndexing) &&
+      visitor->Visit(
+          "shaderUniformTexelBufferArrayNonUniformIndexing",
+          &features->shaderUniformTexelBufferArrayNonUniformIndexing) &&
+      visitor->Visit(
+          "shaderStorageTexelBufferArrayNonUniformIndexing",
+          &features->shaderStorageTexelBufferArrayNonUniformIndexing) &&
+      visitor->Visit(
+          "descriptorBindingUniformBufferUpdateAfterBind",
+          &features->descriptorBindingUniformBufferUpdateAfterBind) &&
+      visitor->Visit("descriptorBindingSampledImageUpdateAfterBind",
+                     &features->descriptorBindingSampledImageUpdateAfterBind) &&
+      visitor->Visit("descriptorBindingStorageImageUpdateAfterBind",
+                     &features->descriptorBindingStorageImageUpdateAfterBind) &&
+      visitor->Visit(
+          "descriptorBindingStorageBufferUpdateAfterBind",
+          &features->descriptorBindingStorageBufferUpdateAfterBind) &&
+      visitor->Visit(
+          "descriptorBindingUniformTexelBufferUpdateAfterBind",
+          &features->descriptorBindingUniformTexelBufferUpdateAfterBind) &&
+      visitor->Visit(
+          "descriptorBindingStorageTexelBufferUpdateAfterBind",
+          &features->descriptorBindingStorageTexelBufferUpdateAfterBind) &&
+      visitor->Visit("descriptorBindingUpdateUnusedWhilePending",
+                     &features->descriptorBindingUpdateUnusedWhilePending) &&
+      visitor->Visit("descriptorBindingPartiallyBound",
+                     &features->descriptorBindingPartiallyBound) &&
+      visitor->Visit("descriptorBindingVariableDescriptorCount",
+                     &features->descriptorBindingVariableDescriptorCount) &&
+      visitor->Visit("runtimeDescriptorArray",
+                     &features->runtimeDescriptorArray) &&
+      visitor->Visit("samplerFilterMinmax", &features->samplerFilterMinmax) &&
+      visitor->Visit("scalarBlockLayout", &features->scalarBlockLayout) &&
+      visitor->Visit("imagelessFramebuffer", &features->imagelessFramebuffer) &&
+      visitor->Visit("uniformBufferStandardLayout",
+                     &features->uniformBufferStandardLayout) &&
+      visitor->Visit("shaderSubgroupExtendedTypes",
+                     &features->shaderSubgroupExtendedTypes) &&
+      visitor->Visit("separateDepthStencilLayouts",
+                     &features->separateDepthStencilLayouts) &&
+      visitor->Visit("hostQueryReset", &features->hostQueryReset) &&
+      visitor->Visit("timelineSemaphore", &features->timelineSemaphore) &&
+      visitor->Visit("bufferDeviceAddress", &features->bufferDeviceAddress) &&
+      visitor->Visit("bufferDeviceAddressCaptureReplay",
+                     &features->bufferDeviceAddressCaptureReplay) &&
+      visitor->Visit("bufferDeviceAddressMultiDevice",
+                     &features->bufferDeviceAddressMultiDevice) &&
+      visitor->Visit("vulkanMemoryModel", &features->vulkanMemoryModel) &&
+      visitor->Visit("vulkanMemoryModelDeviceScope",
+                     &features->vulkanMemoryModelDeviceScope) &&
+      visitor->Visit(
+          "vulkanMemoryModelAvailabilityVisibilityChains",
+          &features->vulkanMemoryModelAvailabilityVisibilityChains) &&
+      visitor->Visit("shaderOutputViewportIndex",
+                     &features->shaderOutputViewportIndex) &&
+      visitor->Visit("shaderOutputLayer", &features->shaderOutputLayer) &&
+      visitor->Visit("subgroupBroadcastDynamicId",
+                     &features->subgroupBroadcastDynamicId);
 }
 
 template <typename Visitor>
@@ -1539,97 +5840,32 @@ inline bool Iterate(Visitor* visitor,
 
 template <typename Visitor>
 inline bool Iterate(Visitor* visitor,
-                    VkPhysicalDeviceVulkan12Features* features) {
+                    VkPhysicalDeviceVulkan13Features* features) {
   return
 
-      visitor->Visit("samplerMirrorClampToEdge",
-                     &features->samplerMirrorClampToEdge) &&
-      visitor->Visit("drawIndirectCount", &features->drawIndirectCount) &&
-      visitor->Visit("storageBuffer8BitAccess",
-                     &features->storageBuffer8BitAccess) &&
-      visitor->Visit("uniformAndStorageBuffer8BitAccess",
-                     &features->uniformAndStorageBuffer8BitAccess) &&
-      visitor->Visit("storagePushConstant8", &features->storagePushConstant8) &&
-      visitor->Visit("shaderBufferInt64Atomics",
-                     &features->shaderBufferInt64Atomics) &&
-      visitor->Visit("shaderSharedInt64Atomics",
-                     &features->shaderSharedInt64Atomics) &&
-      visitor->Visit("shaderFloat16", &features->shaderFloat16) &&
-      visitor->Visit("shaderInt8", &features->shaderInt8) &&
-      visitor->Visit("descriptorIndexing", &features->descriptorIndexing) &&
-      visitor->Visit("shaderInputAttachmentArrayDynamicIndexing",
-                     &features->shaderInputAttachmentArrayDynamicIndexing) &&
-      visitor->Visit("shaderUniformTexelBufferArrayDynamicIndexing",
-                     &features->shaderUniformTexelBufferArrayDynamicIndexing) &&
-      visitor->Visit("shaderStorageTexelBufferArrayDynamicIndexing",
-                     &features->shaderStorageTexelBufferArrayDynamicIndexing) &&
-      visitor->Visit("shaderUniformBufferArrayNonUniformIndexing",
-                     &features->shaderUniformBufferArrayNonUniformIndexing) &&
-      visitor->Visit("shaderSampledImageArrayNonUniformIndexing",
-                     &features->shaderSampledImageArrayNonUniformIndexing) &&
-      visitor->Visit("shaderStorageBufferArrayNonUniformIndexing",
-                     &features->shaderStorageBufferArrayNonUniformIndexing) &&
-      visitor->Visit("shaderStorageImageArrayNonUniformIndexing",
-                     &features->shaderStorageImageArrayNonUniformIndexing) &&
-      visitor->Visit("shaderInputAttachmentArrayNonUniformIndexing",
-                     &features->shaderInputAttachmentArrayNonUniformIndexing) &&
-      visitor->Visit(
-          "shaderUniformTexelBufferArrayNonUniformIndexing",
-          &features->shaderUniformTexelBufferArrayNonUniformIndexing) &&
-      visitor->Visit(
-          "shaderStorageTexelBufferArrayNonUniformIndexing",
-          &features->shaderStorageTexelBufferArrayNonUniformIndexing) &&
-      visitor->Visit(
-          "descriptorBindingUniformBufferUpdateAfterBind",
-          &features->descriptorBindingUniformBufferUpdateAfterBind) &&
-      visitor->Visit("descriptorBindingSampledImageUpdateAfterBind",
-                     &features->descriptorBindingSampledImageUpdateAfterBind) &&
-      visitor->Visit("descriptorBindingStorageImageUpdateAfterBind",
-                     &features->descriptorBindingStorageImageUpdateAfterBind) &&
-      visitor->Visit(
-          "descriptorBindingStorageBufferUpdateAfterBind",
-          &features->descriptorBindingStorageBufferUpdateAfterBind) &&
-      visitor->Visit(
-          "descriptorBindingUniformTexelBufferUpdateAfterBind",
-          &features->descriptorBindingUniformTexelBufferUpdateAfterBind) &&
-      visitor->Visit(
-          "descriptorBindingStorageTexelBufferUpdateAfterBind",
-          &features->descriptorBindingStorageTexelBufferUpdateAfterBind) &&
-      visitor->Visit("descriptorBindingUpdateUnusedWhilePending",
-                     &features->descriptorBindingUpdateUnusedWhilePending) &&
-      visitor->Visit("descriptorBindingPartiallyBound",
-                     &features->descriptorBindingPartiallyBound) &&
-      visitor->Visit("descriptorBindingVariableDescriptorCount",
-                     &features->descriptorBindingVariableDescriptorCount) &&
-      visitor->Visit("runtimeDescriptorArray",
-                     &features->runtimeDescriptorArray) &&
-      visitor->Visit("samplerFilterMinmax", &features->samplerFilterMinmax) &&
-      visitor->Visit("scalarBlockLayout", &features->scalarBlockLayout) &&
-      visitor->Visit("imagelessFramebuffer", &features->imagelessFramebuffer) &&
-      visitor->Visit("uniformBufferStandardLayout",
-                     &features->uniformBufferStandardLayout) &&
-      visitor->Visit("shaderSubgroupExtendedTypes",
-                     &features->shaderSubgroupExtendedTypes) &&
-      visitor->Visit("separateDepthStencilLayouts",
-                     &features->separateDepthStencilLayouts) &&
-      visitor->Visit("hostQueryReset", &features->hostQueryReset) &&
-      visitor->Visit("timelineSemaphore", &features->timelineSemaphore) &&
-      visitor->Visit("bufferDeviceAddress", &features->bufferDeviceAddress) &&
-      visitor->Visit("bufferDeviceAddressCaptureReplay",
-                     &features->bufferDeviceAddressCaptureReplay) &&
-      visitor->Visit("bufferDeviceAddressMultiDevice",
-                     &features->bufferDeviceAddressMultiDevice) &&
-      visitor->Visit("vulkanMemoryModel", &features->vulkanMemoryModel) &&
-      visitor->Visit("vulkanMemoryModelDeviceScope",
-                     &features->vulkanMemoryModelDeviceScope) &&
+      visitor->Visit("robustImageAccess", &features->robustImageAccess) &&
+      visitor->Visit("inlineUniformBlock", &features->inlineUniformBlock) &&
       visitor->Visit(
-          "vulkanMemoryModelAvailabilityVisibilityChains",
-          &features->vulkanMemoryModelAvailabilityVisibilityChains) &&
-      visitor->Visit("shaderOutputViewportIndex",
-                     &features->shaderOutputViewportIndex) &&
-      visitor->Visit("shaderOutputLayer", &features->shaderOutputLayer) &&
-      visitor->Visit("subgroupBroadcastDynamicId",
-                     &features->subgroupBroadcastDynamicId);
+          "descriptorBindingInlineUniformBlockUpdateAfterBind",
+          &features->descriptorBindingInlineUniformBlockUpdateAfterBind) &&
+      visitor->Visit("pipelineCreationCacheControl",
+                     &features->pipelineCreationCacheControl) &&
+      visitor->Visit("privateData", &features->privateData) &&
+      visitor->Visit("shaderDemoteToHelperInvocation",
+                     &features->shaderDemoteToHelperInvocation) &&
+      visitor->Visit("shaderTerminateInvocation",
+                     &features->shaderTerminateInvocation) &&
+      visitor->Visit("subgroupSizeControl", &features->subgroupSizeControl) &&
+      visitor->Visit("computeFullSubgroups", &features->computeFullSubgroups) &&
+      visitor->Visit("synchronization2", &features->synchronization2) &&
+      visitor->Visit("textureCompressionASTC_HDR",
+                     &features->textureCompressionASTC_HDR) &&
+      visitor->Visit("shaderZeroInitializeWorkgroupMemory",
+                     &features->shaderZeroInitializeWorkgroupMemory) &&
+      visitor->Visit("dynamicRendering", &features->dynamicRendering) &&
+      visitor->Visit("shaderIntegerDotProduct",
+                     &features->shaderIntegerDotProduct) &&
+      visitor->Visit("maintenance4", &features->maintenance4);
 }
 
 template <typename Visitor>
@@ -1778,32 +6014,37 @@ inline bool Iterate(Visitor* visitor,
 
 template <typename Visitor>
 inline bool Iterate(Visitor* visitor,
-                    VkPhysicalDeviceVulkan13Features* features) {
-  return
-
-      visitor->Visit("robustImageAccess", &features->robustImageAccess) &&
-      visitor->Visit("inlineUniformBlock", &features->inlineUniformBlock) &&
-      visitor->Visit(
-          "descriptorBindingInlineUniformBlockUpdateAfterBind",
-          &features->descriptorBindingInlineUniformBlockUpdateAfterBind) &&
-      visitor->Visit("pipelineCreationCacheControl",
-                     &features->pipelineCreationCacheControl) &&
-      visitor->Visit("privateData", &features->privateData) &&
-      visitor->Visit("shaderDemoteToHelperInvocation",
-                     &features->shaderDemoteToHelperInvocation) &&
-      visitor->Visit("shaderTerminateInvocation",
-                     &features->shaderTerminateInvocation) &&
-      visitor->Visit("subgroupSizeControl", &features->subgroupSizeControl) &&
-      visitor->Visit("computeFullSubgroups", &features->computeFullSubgroups) &&
-      visitor->Visit("synchronization2", &features->synchronization2) &&
-      visitor->Visit("textureCompressionASTC_HDR",
-                     &features->textureCompressionASTC_HDR) &&
-      visitor->Visit("shaderZeroInitializeWorkgroupMemory",
-                     &features->shaderZeroInitializeWorkgroupMemory) &&
-      visitor->Visit("dynamicRendering", &features->dynamicRendering) &&
-      visitor->Visit("shaderIntegerDotProduct",
-                     &features->shaderIntegerDotProduct) &&
-      visitor->Visit("maintenance4", &features->maintenance4);
+                    VkPhysicalDeviceVulkan14Features* features) {
+  return
+
+      visitor->Visit("globalPriorityQuery", &features->globalPriorityQuery) &&
+      visitor->Visit("shaderSubgroupRotate", &features->shaderSubgroupRotate) &&
+      visitor->Visit("shaderSubgroupRotateClustered",
+                     &features->shaderSubgroupRotateClustered) &&
+      visitor->Visit("shaderFloatControls2", &features->shaderFloatControls2) &&
+      visitor->Visit("shaderExpectAssume", &features->shaderExpectAssume) &&
+      visitor->Visit("rectangularLines", &features->rectangularLines) &&
+      visitor->Visit("bresenhamLines", &features->bresenhamLines) &&
+      visitor->Visit("smoothLines", &features->smoothLines) &&
+      visitor->Visit("stippledRectangularLines",
+                     &features->stippledRectangularLines) &&
+      visitor->Visit("stippledBresenhamLines",
+                     &features->stippledBresenhamLines) &&
+      visitor->Visit("stippledSmoothLines", &features->stippledSmoothLines) &&
+      visitor->Visit("vertexAttributeInstanceRateDivisor",
+                     &features->vertexAttributeInstanceRateDivisor) &&
+      visitor->Visit("vertexAttributeInstanceRateZeroDivisor",
+                     &features->vertexAttributeInstanceRateZeroDivisor) &&
+      visitor->Visit("indexTypeUint8", &features->indexTypeUint8) &&
+      visitor->Visit("dynamicRenderingLocalRead",
+                     &features->dynamicRenderingLocalRead) &&
+      visitor->Visit("maintenance5", &features->maintenance5) &&
+      visitor->Visit("maintenance6", &features->maintenance6) &&
+      visitor->Visit("pipelineProtectedAccess",
+                     &features->pipelineProtectedAccess) &&
+      visitor->Visit("pipelineRobustness", &features->pipelineRobustness) &&
+      visitor->Visit("hostImageCopy", &features->hostImageCopy) &&
+      visitor->Visit("pushDescriptor", &features->pushDescriptor);
 }
 
 template <typename Visitor>
@@ -1867,48 +6108,432 @@ inline bool Iterate(Visitor* visitor,
 
 template <typename Visitor>
 inline bool Iterate(Visitor* visitor,
-                    VkPhysicalDeviceVulkan14Features* features) {
+                    VkPhysicalDeviceVulkanMemoryModelFeatures* features) {
   return
 
-      visitor->Visit("globalPriorityQuery", &features->globalPriorityQuery) &&
-      visitor->Visit("shaderSubgroupRotate", &features->shaderSubgroupRotate) &&
-      visitor->Visit("shaderSubgroupRotateClustered",
-                     &features->shaderSubgroupRotateClustered) &&
-      visitor->Visit("shaderFloatControls2", &features->shaderFloatControls2) &&
-      visitor->Visit("shaderExpectAssume", &features->shaderExpectAssume) &&
-      visitor->Visit("rectangularLines", &features->rectangularLines) &&
-      visitor->Visit("bresenhamLines", &features->bresenhamLines) &&
-      visitor->Visit("smoothLines", &features->smoothLines) &&
-      visitor->Visit("stippledRectangularLines",
-                     &features->stippledRectangularLines) &&
-      visitor->Visit("stippledBresenhamLines",
-                     &features->stippledBresenhamLines) &&
-      visitor->Visit("stippledSmoothLines", &features->stippledSmoothLines) &&
-      visitor->Visit("vertexAttributeInstanceRateDivisor",
-                     &features->vertexAttributeInstanceRateDivisor) &&
-      visitor->Visit("vertexAttributeInstanceRateZeroDivisor",
-                     &features->vertexAttributeInstanceRateZeroDivisor) &&
-      visitor->Visit("indexTypeUint8", &features->indexTypeUint8) &&
-      visitor->Visit("dynamicRenderingLocalRead",
-                     &features->dynamicRenderingLocalRead) &&
-      visitor->Visit("maintenance5", &features->maintenance5) &&
-      visitor->Visit("maintenance6", &features->maintenance6) &&
-      visitor->Visit("pipelineProtectedAccess",
-                     &features->pipelineProtectedAccess) &&
-      visitor->Visit("pipelineRobustness", &features->pipelineRobustness) &&
-      visitor->Visit("hostImageCopy", &features->hostImageCopy) &&
-      visitor->Visit("pushDescriptor", &features->pushDescriptor);
+      visitor->Visit("vulkanMemoryModel", &features->vulkanMemoryModel) &&
+      visitor->Visit("vulkanMemoryModelDeviceScope",
+                     &features->vulkanMemoryModelDeviceScope) &&
+      visitor->Visit("vulkanMemoryModelAvailabilityVisibilityChains",
+                     &features->vulkanMemoryModelAvailabilityVisibilityChains);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR* features) {
+  return
+
+      visitor->Visit("workgroupMemoryExplicitLayout",
+                     &features->workgroupMemoryExplicitLayout) &&
+      visitor->Visit(
+          "workgroupMemoryExplicitLayoutScalarBlockLayout",
+          &features->workgroupMemoryExplicitLayoutScalarBlockLayout) &&
+      visitor->Visit("workgroupMemoryExplicitLayout8BitAccess",
+                     &features->workgroupMemoryExplicitLayout8BitAccess) &&
+      visitor->Visit("workgroupMemoryExplicitLayout16BitAccess",
+                     &features->workgroupMemoryExplicitLayout16BitAccess);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT* features) {
+  return
+
+      visitor->Visit("ycbcr2plane444Formats", &features->ycbcr2plane444Formats);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceYcbcrDegammaFeaturesQCOM* features) {
+  return
+
+      visitor->Visit("ycbcrDegamma", &features->ycbcrDegamma);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* features) {
+  return
+
+      visitor->Visit("ycbcrImageArrays", &features->ycbcrImageArrays);
+}
+
+template <typename Visitor>
+inline bool Iterate(
+    Visitor* visitor,
+    VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures* features) {
+  return
+
+      visitor->Visit("shaderZeroInitializeWorkgroupMemory",
+                     &features->shaderZeroInitializeWorkgroupMemory);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkPhysicalDeviceProperties* properties) {
+  return
+
+      visitor->Visit("apiVersion", &properties->apiVersion) &&
+      visitor->Visit("driverVersion", &properties->driverVersion) &&
+      visitor->Visit("vendorID", &properties->vendorID) &&
+      visitor->Visit("deviceID", &properties->deviceID) &&
+      visitor->Visit("deviceType", &properties->deviceType) &&
+      visitor->Visit("deviceName", &properties->deviceName) &&
+      visitor->Visit("pipelineCacheUUID", &properties->pipelineCacheUUID) &&
+      visitor->Visit("limits", &properties->limits) &&
+      visitor->Visit("sparseProperties", &properties->sparseProperties);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceMemoryProperties* properties) {
+  return
+
+      visitor->Visit("memoryTypeCount", &properties->memoryTypeCount) &&
+      visitor->VisitArray("memoryTypes", properties->memoryTypeCount,
+                          &properties->memoryTypes) &&
+      visitor->Visit("memoryHeapCount", &properties->memoryHeapCount) &&
+      visitor->VisitArray("memoryHeaps", properties->memoryHeapCount,
+                          &properties->memoryHeaps);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor,
+                    VkPhysicalDeviceSparseProperties* properties) {
+  return
+
+      visitor->Visit("residencyStandard2DBlockShape",
+                     &properties->residencyStandard2DBlockShape) &&
+      visitor->Visit("residencyStandard2DMultisampleBlockShape",
+                     &properties->residencyStandard2DMultisampleBlockShape) &&
+      visitor->Visit("residencyStandard3DBlockShape",
+                     &properties->residencyStandard3DBlockShape) &&
+      visitor->Visit("residencyAlignedMipSize",
+                     &properties->residencyAlignedMipSize) &&
+      visitor->Visit("residencyNonResidentStrict",
+                     &properties->residencyNonResidentStrict);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkImageFormatProperties* properties) {
+  return
+
+      visitor->Visit("maxExtent", &properties->maxExtent) &&
+      visitor->Visit("maxMipLevels", &properties->maxMipLevels) &&
+      visitor->Visit("maxArrayLayers", &properties->maxArrayLayers) &&
+      visitor->Visit("sampleCounts", &properties->sampleCounts) &&
+      visitor->Visit("maxResourceSize", &properties->maxResourceSize);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkQueueFamilyProperties* properties) {
+  return
+
+      visitor->Visit("queueFlags", &properties->queueFlags) &&
+      visitor->Visit("queueCount", &properties->queueCount) &&
+      visitor->Visit("timestampValidBits", &properties->timestampValidBits) &&
+      visitor->Visit("minImageTransferGranularity",
+                     &properties->minImageTransferGranularity);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkExtensionProperties* properties) {
+  return
+
+      visitor->Visit("extensionName", &properties->extensionName) &&
+      visitor->Visit("specVersion", &properties->specVersion);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkLayerProperties* properties) {
+  return
+
+      visitor->Visit("layerName", &properties->layerName) &&
+      visitor->Visit("specVersion", &properties->specVersion) &&
+      visitor->Visit("implementationVersion",
+                     &properties->implementationVersion) &&
+      visitor->Visit("description", &properties->description);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkFormatProperties* properties) {
+  return
+
+      visitor->Visit("linearTilingFeatures",
+                     &properties->linearTilingFeatures) &&
+      visitor->Visit("optimalTilingFeatures",
+                     &properties->optimalTilingFeatures) &&
+      visitor->Visit("bufferFeatures", &properties->bufferFeatures);
+}
+
+template <typename Visitor>
+inline bool Iterate(Visitor* visitor, VkPhysicalDeviceLimits* limits) {
+  return
+
+      visitor->Visit("maxImageDimension1D", &limits->maxImageDimension1D) &&
+      visitor->Visit("maxImageDimension2D", &limits->maxImageDimension2D) &&
+      visitor->Visit("maxImageDimension3D", &limits->maxImageDimension3D) &&
+      visitor->Visit("maxImageDimensionCube", &limits->maxImageDimensionCube) &&
+      visitor->Visit("maxImageArrayLayers", &limits->maxImageArrayLayers) &&
+      visitor->Visit("maxTexelBufferElements",
+                     &limits->maxTexelBufferElements) &&
+      visitor->Visit("maxUniformBufferRange", &limits->maxUniformBufferRange) &&
+      visitor->Visit("maxStorageBufferRange", &limits->maxStorageBufferRange) &&
+      visitor->Visit("maxPushConstantsSize", &limits->maxPushConstantsSize) &&
+      visitor->Visit("maxMemoryAllocationCount",
+                     &limits->maxMemoryAllocationCount) &&
+      visitor->Visit("maxSamplerAllocationCount",
+                     &limits->maxSamplerAllocationCount) &&
+      visitor->Visit("bufferImageGranularity",
+                     &limits->bufferImageGranularity) &&
+      visitor->Visit("sparseAddressSpaceSize",
+                     &limits->sparseAddressSpaceSize) &&
+      visitor->Visit("maxBoundDescriptorSets",
+                     &limits->maxBoundDescriptorSets) &&
+      visitor->Visit("maxPerStageDescriptorSamplers",
+                     &limits->maxPerStageDescriptorSamplers) &&
+      visitor->Visit("maxPerStageDescriptorUniformBuffers",
+                     &limits->maxPerStageDescriptorUniformBuffers) &&
+      visitor->Visit("maxPerStageDescriptorStorageBuffers",
+                     &limits->maxPerStageDescriptorStorageBuffers) &&
+      visitor->Visit("maxPerStageDescriptorSampledImages",
+                     &limits->maxPerStageDescriptorSampledImages) &&
+      visitor->Visit("maxPerStageDescriptorStorageImages",
+                     &limits->maxPerStageDescriptorStorageImages) &&
+      visitor->Visit("maxPerStageDescriptorInputAttachments",
+                     &limits->maxPerStageDescriptorInputAttachments) &&
+      visitor->Visit("maxPerStageResources", &limits->maxPerStageResources) &&
+      visitor->Visit("maxDescriptorSetSamplers",
+                     &limits->maxDescriptorSetSamplers) &&
+      visitor->Visit("maxDescriptorSetUniformBuffers",
+                     &limits->maxDescriptorSetUniformBuffers) &&
+      visitor->Visit("maxDescriptorSetUniformBuffersDynamic",
+                     &limits->maxDescriptorSetUniformBuffersDynamic) &&
+      visitor->Visit("maxDescriptorSetStorageBuffers",
+                     &limits->maxDescriptorSetStorageBuffers) &&
+      visitor->Visit("maxDescriptorSetStorageBuffersDynamic",
+                     &limits->maxDescriptorSetStorageBuffersDynamic) &&
+      visitor->Visit("maxDescriptorSetSampledImages",
+                     &limits->maxDescriptorSetSampledImages) &&
+      visitor->Visit("maxDescriptorSetStorageImages",
+                     &limits->maxDescriptorSetStorageImages) &&
+      visitor->Visit("maxDescriptorSetInputAttachments",
+                     &limits->maxDescriptorSetInputAttachments) &&
+      visitor->Visit("maxVertexInputAttributes",
+                     &limits->maxVertexInputAttributes) &&
+      visitor->Visit("maxVertexInputBindings",
+                     &limits->maxVertexInputBindings) &&
+      visitor->Visit("maxVertexInputAttributeOffset",
+                     &limits->maxVertexInputAttributeOffset) &&
+      visitor->Visit("maxVertexInputBindingStride",
+                     &limits->maxVertexInputBindingStride) &&
+      visitor->Visit("maxVertexOutputComponents",
+                     &limits->maxVertexOutputComponents) &&
+      visitor->Visit("maxTessellationGenerationLevel",
+                     &limits->maxTessellationGenerationLevel) &&
+      visitor->Visit("maxTessellationPatchSize",
+                     &limits->maxTessellationPatchSize) &&
+      visitor->Visit("maxTessellationControlPerVertexInputComponents",
+                     &limits->maxTessellationControlPerVertexInputComponents) &&
+      visitor->Visit(
+          "maxTessellationControlPerVertexOutputComponents",
+          &limits->maxTessellationControlPerVertexOutputComponents) &&
+      visitor->Visit("maxTessellationControlPerPatchOutputComponents",
+                     &limits->maxTessellationControlPerPatchOutputComponents) &&
+      visitor->Visit("maxTessellationControlTotalOutputComponents",
+                     &limits->maxTessellationControlTotalOutputComponents) &&
+      visitor->Visit("maxTessellationEvaluationInputComponents",
+                     &limits->maxTessellationEvaluationInputComponents) &&
+      visitor->Visit("maxTessellationEvaluationOutputComponents",
+                     &limits->maxTessellationEvaluationOutputComponents) &&
+      visitor->Visit("maxGeometryShaderInvocations",
+                     &limits->maxGeometryShaderInvocations) &&
+      visitor->Visit("maxGeometryInputComponents",
+                     &limits->maxGeometryInputComponents) &&
+      visitor->Visit("maxGeometryOutputComponents",
+                     &limits->maxGeometryOutputComponents) &&
+      visitor->Visit("maxGeometryOutputVertices",
+                     &limits->maxGeometryOutputVertices) &&
+      visitor->Visit("maxGeometryTotalOutputComponents",
+                     &limits->maxGeometryTotalOutputComponents) &&
+      visitor->Visit("maxFragmentInputComponents",
+                     &limits->maxFragmentInputComponents) &&
+      visitor->Visit("maxFragmentOutputAttachments",
+                     &limits->maxFragmentOutputAttachments) &&
+      visitor->Visit("maxFragmentDualSrcAttachments",
+                     &limits->maxFragmentDualSrcAttachments) &&
+      visitor->Visit("maxFragmentCombinedOutputResources",
+                     &limits->maxFragmentCombinedOutputResources) &&
+      visitor->Visit("maxComputeSharedMemorySize",
+                     &limits->maxComputeSharedMemorySize) &&
+      visitor->Visit("maxComputeWorkGroupCount",
+                     &limits->maxComputeWorkGroupCount) &&
+      visitor->Visit("maxComputeWorkGroupInvocations",
+                     &limits->maxComputeWorkGroupInvocations) &&
+      visitor->Visit("maxComputeWorkGroupSize",
+                     &limits->maxComputeWorkGroupSize) &&
+      visitor->Visit("subPixelPrecisionBits", &limits->subPixelPrecisionBits) &&
+      visitor->Visit("subTexelPrecisionBits", &limits->subTexelPrecisionBits) &&
+      visitor->Visit("mipmapPrecisionBits", &limits->mipmapPrecisionBits) &&
+      visitor->Visit("maxDrawIndexedIndexValue",
+                     &limits->maxDrawIndexedIndexValue) &&
+      visitor->Visit("maxDrawIndirectCount", &limits->maxDrawIndirectCount) &&
+      visitor->Visit("maxSamplerLodBias", &limits->maxSamplerLodBias) &&
+      visitor->Visit("maxSamplerAnisotropy", &limits->maxSamplerAnisotropy) &&
+      visitor->Visit("maxViewports", &limits->maxViewports) &&
+      visitor->Visit("maxViewportDimensions", &limits->maxViewportDimensions) &&
+      visitor->Visit("viewportBoundsRange", &limits->viewportBoundsRange) &&
+      visitor->Visit("viewportSubPixelBits", &limits->viewportSubPixelBits) &&
+      visitor->Visit("minMemoryMapAlignment", &limits->minMemoryMapAlignment) &&
+      visitor->Visit("minTexelBufferOffsetAlignment",
+                     &limits->minTexelBufferOffsetAlignment) &&
+      visitor->Visit("minUniformBufferOffsetAlignment",
+                     &limits->minUniformBufferOffsetAlignment) &&
+      visitor->Visit("minStorageBufferOffsetAlignment",
+                     &limits->minStorageBufferOffsetAlignment) &&
+      visitor->Visit("minTexelOffset", &limits->minTexelOffset) &&
+      visitor->Visit("maxTexelOffset", &limits->maxTexelOffset) &&
+      visitor->Visit("minTexelGatherOffset", &limits->minTexelGatherOffset) &&
+      visitor->Visit("maxTexelGatherOffset", &limits->maxTexelGatherOffset) &&
+      visitor->Visit("minInterpolationOffset",
+                     &limits->minInterpolationOffset) &&
+      visitor->Visit("maxInterpolationOffset",
+                     &limits->maxInterpolationOffset) &&
+      visitor->Visit("subPixelInterpolationOffsetBits",
+                     &limits->subPixelInterpolationOffsetBits) &&
+      visitor->Visit("maxFramebufferWidth", &limits->maxFramebufferWidth) &&
+      visitor->Visit("maxFramebufferHeight", &limits->maxFramebufferHeight) &&
+      visitor->Visit("maxFramebufferLayers", &limits->maxFramebufferLayers) &&
+      visitor->Visit("framebufferColorSampleCounts",
+                     &limits->framebufferColorSampleCounts) &&
+      visitor->Visit("framebufferDepthSampleCounts",
+                     &limits->framebufferDepthSampleCounts) &&
+      visitor->Visit("framebufferStencilSampleCounts",
+                     &limits->framebufferStencilSampleCounts) &&
+      visitor->Visit("framebufferNoAttachmentsSampleCounts",
+                     &limits->framebufferNoAttachmentsSampleCounts) &&
+      visitor->Visit("maxColorAttachments", &limits->maxColorAttachments) &&
+      visitor->Visit("sampledImageColorSampleCounts",
+                     &limits->sampledImageColorSampleCounts) &&
+      visitor->Visit("sampledImageIntegerSampleCounts",
+                     &limits->sampledImageIntegerSampleCounts) &&
+      visitor->Visit("sampledImageDepthSampleCounts",
+                     &limits->sampledImageDepthSampleCounts) &&
+      visitor->Visit("sampledImageStencilSampleCounts",
+                     &limits->sampledImageStencilSampleCounts) &&
+      visitor->Visit("storageImageSampleCounts",
+                     &limits->storageImageSampleCounts) &&
+      visitor->Visit("maxSampleMaskWords", &limits->maxSampleMaskWords) &&
+      visitor->Visit("timestampComputeAndGraphics",
+                     &limits->timestampComputeAndGraphics) &&
+      visitor->Visit("timestampPeriod", &limits->timestampPeriod) &&
+      visitor->Visit("maxClipDistances", &limits->maxClipDistances) &&
+      visitor->Visit("maxCullDistances", &limits->maxCullDistances) &&
+      visitor->Visit("maxCombinedClipAndCullDistances",
+                     &limits->maxCombinedClipAndCullDistances) &&
+      visitor->Visit("discreteQueuePriorities",
+                     &limits->discreteQueuePriorities) &&
+      visitor->Visit("pointSizeRange", &limits->pointSizeRange) &&
+      visitor->Visit("lineWidthRange", &limits->lineWidthRange) &&
+      visitor->Visit("pointSizeGranularity", &limits->pointSizeGranularity) &&
+      visitor->Visit("lineWidthGranularity", &limits->lineWidthGranularity) &&
+      visitor->Visit("strictLines", &limits->strictLines) &&
+      visitor->Visit("standardSampleLocations",
+                     &limits->standardSampleLocations) &&
+      visitor->Visit("optimalBufferCopyOffsetAlignment",
+                     &limits->optimalBufferCopyOffsetAlignment) &&
+      visitor->Visit("optimalBufferCopyRowPitchAlignment",
+                     &limits->optimalBufferCopyRowPitchAlignment) &&
+      visitor->Visit("nonCoherentAtomSize", &limits->nonCoherentAtomSize);
 }
 
 template <typename Visitor>
-inline bool Iterate(Visitor* visitor,
-                    VkPhysicalDeviceDriverProperties* properties) {
+inline bool Iterate(Visitor* visitor, VkPhysicalDeviceFeatures* features) {
   return
 
-      visitor->Visit("driverID", &properties->driverID) &&
-      visitor->Visit("driverName", &properties->driverName) &&
-      visitor->Visit("driverInfo", &properties->driverInfo) &&
-      visitor->Visit("conformanceVersion", &properties->conformanceVersion);
+      visitor->Visit("robustBufferAccess", &features->robustBufferAccess) &&
+      visitor->Visit("fullDrawIndexUint32", &features->fullDrawIndexUint32) &&
+      visitor->Visit("imageCubeArray", &features->imageCubeArray) &&
+      visitor->Visit("independentBlend", &features->independentBlend) &&
+      visitor->Visit("geometryShader", &features->geometryShader) &&
+      visitor->Visit("tessellationShader", &features->tessellationShader) &&
+      visitor->Visit("sampleRateShading", &features->sampleRateShading) &&
+      visitor->Visit("dualSrcBlend", &features->dualSrcBlend) &&
+      visitor->Visit("logicOp", &features->logicOp) &&
+      visitor->Visit("multiDrawIndirect", &features->multiDrawIndirect) &&
+      visitor->Visit("drawIndirectFirstInstance",
+                     &features->drawIndirectFirstInstance) &&
+      visitor->Visit("depthClamp", &features->depthClamp) &&
+      visitor->Visit("depthBiasClamp", &features->depthBiasClamp) &&
+      visitor->Visit("fillModeNonSolid", &features->fillModeNonSolid) &&
+      visitor->Visit("depthBounds", &features->depthBounds) &&
+      visitor->Visit("wideLines", &features->wideLines) &&
+      visitor->Visit("largePoints", &features->largePoints) &&
+      visitor->Visit("alphaToOne", &features->alphaToOne) &&
+      visitor->Visit("multiViewport", &features->multiViewport) &&
+      visitor->Visit("samplerAnisotropy", &features->samplerAnisotropy) &&
+      visitor->Visit("textureCompressionETC2",
+                     &features->textureCompressionETC2) &&
+      visitor->Visit("textureCompressionASTC_LDR",
+                     &features->textureCompressionASTC_LDR) &&
+      visitor->Visit("textureCompressionBC", &features->textureCompressionBC) &&
+      visitor->Visit("occlusionQueryPrecise",
+                     &features->occlusionQueryPrecise) &&
+      visitor->Visit("pipelineStatisticsQuery",
+                     &features->pipelineStatisticsQuery) &&
+      visitor->Visit("vertexPipelineStoresAndAtomics",
+                     &features->vertexPipelineStoresAndAtomics) &&
+      visitor->Visit("fragmentStoresAndAtomics",
+                     &features->fragmentStoresAndAtomics) &&
+      visitor->Visit("shaderTessellationAndGeometryPointSize",
+                     &features->shaderTessellationAndGeometryPointSize) &&
+      visitor->Visit("shaderImageGatherExtended",
+                     &features->shaderImageGatherExtended) &&
+      visitor->Visit("shaderStorageImageExtendedFormats",
+                     &features->shaderStorageImageExtendedFormats) &&
+      visitor->Visit("shaderStorageImageMultisample",
+                     &features->shaderStorageImageMultisample) &&
+      visitor->Visit("shaderStorageImageReadWithoutFormat",
+                     &features->shaderStorageImageReadWithoutFormat) &&
+      visitor->Visit("shaderStorageImageWriteWithoutFormat",
+                     &features->shaderStorageImageWriteWithoutFormat) &&
+      visitor->Visit("shaderUniformBufferArrayDynamicIndexing",
+                     &features->shaderUniformBufferArrayDynamicIndexing) &&
+      visitor->Visit("shaderSampledImageArrayDynamicIndexing",
+                     &features->shaderSampledImageArrayDynamicIndexing) &&
+      visitor->Visit("shaderStorageBufferArrayDynamicIndexing",
+                     &features->shaderStorageBufferArrayDynamicIndexing) &&
+      visitor->Visit("shaderStorageImageArrayDynamicIndexing",
+                     &features->shaderStorageImageArrayDynamicIndexing) &&
+      visitor->Visit("shaderClipDistance", &features->shaderClipDistance) &&
+      visitor->Visit("shaderCullDistance", &features->shaderCullDistance) &&
+      visitor->Visit("shaderFloat64", &features->shaderFloat64) &&
+      visitor->Visit("shaderInt64", &features->shaderInt64) &&
+      visitor->Visit("shaderInt16", &features->shaderInt16) &&
+      visitor->Visit("shaderResourceResidency",
+                     &features->shaderResourceResidency) &&
+      visitor->Visit("shaderResourceMinLod", &features->shaderResourceMinLod) &&
+      visitor->Visit("sparseBinding", &features->sparseBinding) &&
+      visitor->Visit("sparseResidencyBuffer",
+                     &features->sparseResidencyBuffer) &&
+      visitor->Visit("sparseResidencyImage2D",
+                     &features->sparseResidencyImage2D) &&
+      visitor->Visit("sparseResidencyImage3D",
+                     &features->sparseResidencyImage3D) &&
+      visitor->Visit("sparseResidency2Samples",
+                     &features->sparseResidency2Samples) &&
+      visitor->Visit("sparseResidency4Samples",
+                     &features->sparseResidency4Samples) &&
+      visitor->Visit("sparseResidency8Samples",
+                     &features->sparseResidency8Samples) &&
+      visitor->Visit("sparseResidency16Samples",
+                     &features->sparseResidency16Samples) &&
+      visitor->Visit("sparseResidencyAliased",
+                     &features->sparseResidencyAliased) &&
+      visitor->Visit("variableMultisampleRate",
+                     &features->variableMultisampleRate) &&
+      visitor->Visit("inheritedQueries", &features->inheritedQueries);
 }
 
 template <typename Visitor>
@@ -1951,36 +6576,156 @@ inline bool Iterate(Visitor* visitor, VkJsonDevice* device) {
   switch (device->properties.apiVersion ^
           VK_API_VERSION_PATCH(device->properties.apiVersion)) {
     case VK_API_VERSION_1_4:
-      ret &= visitor->Visit("core14", &device->core14);
+      ret &= visitor->Visit("globalPriorityQueryFeatures",
+                            &device->global_priority_query_features) &&
+             visitor->Visit("shaderSubgroupRotateFeatures",
+                            &device->shader_subgroup_rotate_features) &&
+             visitor->Visit("shaderFloatControls2Features",
+                            &device->shader_float_controls2_features) &&
+             visitor->Visit("shaderExpectAssumeFeatures",
+                            &device->shader_expect_assume_features) &&
+             visitor->Visit("lineRasterizationFeatures",
+                            &device->line_rasterization_features) &&
+             visitor->Visit("lineRasterizationProperties",
+                            &device->line_rasterization_properties) &&
+             visitor->Visit("vertexAttributeDivisorProperties",
+                            &device->vertex_attribute_divisor_properties) &&
+             visitor->Visit("vertexAttributeDivisorFeatures",
+                            &device->vertex_attribute_divisor_features) &&
+             visitor->Visit("indexTypeUint8Features",
+                            &device->index_type_uint8_features) &&
+             visitor->Visit("maintenance5Features",
+                            &device->maintenance5_features) &&
+             visitor->Visit("maintenance5Properties",
+                            &device->maintenance5_properties) &&
+             visitor->Visit("pushDescriptorProperties",
+                            &device->push_descriptor_properties) &&
+             visitor->Visit("dynamicRenderingLocalReadFeatures",
+                            &device->dynamic_rendering_local_read_features) &&
+             visitor->Visit("maintenance6Features",
+                            &device->maintenance6_features) &&
+             visitor->Visit("maintenance6Properties",
+                            &device->maintenance6_properties) &&
+             visitor->Visit("pipelineProtectedAccessFeatures",
+                            &device->pipeline_protected_access_features) &&
+             visitor->Visit("pipelineRobustnessFeatures",
+                            &device->pipeline_robustness_features) &&
+             visitor->Visit("pipelineRobustnessProperties",
+                            &device->pipeline_robustness_properties) &&
+             visitor->Visit("hostImageCopyFeatures",
+                            &device->host_image_copy_features) &&
+             visitor->Visit("core14", &device->core14);
       FALLTHROUGH_INTENDED;
     case VK_API_VERSION_1_3:
-      ret &= visitor->Visit("core13", &device->core13);
+      ret &=
+          visitor->Visit("shaderTerminateInvocationFeatures",
+                         &device->shader_terminate_invocation_features) &&
+          visitor->Visit(
+              "shaderDemoteToHelperInvocationFeatures",
+              &device->shader_demote_to_helper_invocation_features) &&
+          visitor->Visit("privateDataFeatures",
+                         &device->private_data_features) &&
+          visitor->Visit("pipelineCreationCacheControlFeatures",
+                         &device->pipeline_creation_cache_control_features) &&
+          visitor->Visit("synchronization2Features",
+                         &device->synchronization2_features) &&
+          visitor->Visit("zeroInitializeWorkgroupMemoryFeatures",
+                         &device->zero_initialize_workgroup_memory_features) &&
+          visitor->Visit("imageRobustnessFeatures",
+                         &device->image_robustness_features) &&
+          visitor->Visit("subgroupSizeControlFeatures",
+                         &device->subgroup_size_control_features) &&
+          visitor->Visit("subgroupSizeControlProperties",
+                         &device->subgroup_size_control_properties) &&
+          visitor->Visit("inlineUniformBlockFeatures",
+                         &device->inline_uniform_block_features) &&
+          visitor->Visit("inlineUniformBlockProperties",
+                         &device->inline_uniform_block_properties) &&
+          visitor->Visit("textureCompressionAstchdrFeatures",
+                         &device->texture_compression_astchdr_features) &&
+          visitor->Visit("dynamicRenderingFeatures",
+                         &device->dynamic_rendering_features) &&
+          visitor->Visit("shaderIntegerDotProductFeatures",
+                         &device->shader_integer_dot_product_features) &&
+          visitor->Visit("shaderIntegerDotProductProperties",
+                         &device->shader_integer_dot_product_properties) &&
+          visitor->Visit("texelBufferAlignmentProperties",
+                         &device->texel_buffer_alignment_properties) &&
+          visitor->Visit("maintenance4Features",
+                         &device->maintenance4_features) &&
+          visitor->Visit("maintenance4Properties",
+                         &device->maintenance4_properties) &&
+          visitor->Visit("core13", &device->core13);
       FALLTHROUGH_INTENDED;
     case VK_API_VERSION_1_2:
-      ret &= visitor->Visit("core11", &device->core11);
+      ret &= visitor->Visit("bit8StorageFeatures",
+                            &device->bit8_storage_features) &&
+             visitor->Visit("driverProperties", &device->driver_properties) &&
+             visitor->Visit("shaderAtomicInt64Features",
+                            &device->shader_atomic_int64_features) &&
+             visitor->Visit("shaderFloat16Int8Features",
+                            &device->shader_float16_int8_features) &&
+             visitor->Visit("floatControlsProperties",
+                            &device->float_controls_properties) &&
+             visitor->Visit("descriptorIndexingFeatures",
+                            &device->descriptor_indexing_features) &&
+             visitor->Visit("descriptorIndexingProperties",
+                            &device->descriptor_indexing_properties) &&
+             visitor->Visit("depthStencilResolveProperties",
+                            &device->depth_stencil_resolve_properties) &&
+             visitor->Visit("scalarBlockLayoutFeatures",
+                            &device->scalar_block_layout_features) &&
+             visitor->Visit("samplerFilterMinmaxProperties",
+                            &device->sampler_filter_minmax_properties) &&
+             visitor->Visit("vulkanMemoryModelFeatures",
+                            &device->vulkan_memory_model_features) &&
+             visitor->Visit("imagelessFramebufferFeatures",
+                            &device->imageless_framebuffer_features) &&
+             visitor->Visit("uniformBufferStandardLayoutFeatures",
+                            &device->uniform_buffer_standard_layout_features) &&
+             visitor->Visit("shaderSubgroupExtendedTypesFeatures",
+                            &device->shader_subgroup_extended_types_features) &&
+             visitor->Visit("separateDepthStencilLayoutsFeatures",
+                            &device->separate_depth_stencil_layouts_features) &&
+             visitor->Visit("hostQueryResetFeatures",
+                            &device->host_query_reset_features) &&
+             visitor->Visit("timelineSemaphoreFeatures",
+                            &device->timeline_semaphore_features) &&
+             visitor->Visit("timelineSemaphoreProperties",
+                            &device->timeline_semaphore_properties) &&
+             visitor->Visit("bufferDeviceAddressFeatures",
+                            &device->buffer_device_address_features) &&
+
+             visitor->Visit("core11", &device->core11);
       ret &= visitor->Visit("core12", &device->core12);
       FALLTHROUGH_INTENDED;
     case VK_API_VERSION_1_1:
       ret &=
           visitor->Visit("subgroupProperties", &device->subgroup_properties) &&
+          visitor->Visit("bit16StorageFeatures",
+                         &device->bit16_storage_features) &&
           visitor->Visit("pointClippingProperties",
                          &device->point_clipping_properties) &&
+          visitor->Visit("multiviewFeatures", &device->multiview_features) &&
           visitor->Visit("multiviewProperties",
                          &device->multiview_properties) &&
-          visitor->Visit("idProperties", &device->id_properties) &&
-          visitor->Visit("maintenance3Properties",
-                         &device->maintenance3_properties) &&
-          visitor->Visit("multiviewFeatures", &device->multiview_features) &&
+          visitor->Visit("variablePointerFeatures",
+                         &device->variable_pointer_features) &&
           visitor->Visit("variablePointersFeatures",
                          &device->variable_pointers_features) &&
           visitor->Visit("protectedMemoryFeatures",
                          &device->protected_memory_features) &&
+          visitor->Visit("protectedMemoryProperties",
+                         &device->protected_memory_properties) &&
           visitor->Visit("samplerYcbcrConversionFeatures",
                          &device->sampler_ycbcr_conversion_features) &&
+          visitor->Visit("idProperties", &device->id_properties) &&
+          visitor->Visit("maintenance3Properties",
+                         &device->maintenance3_properties) &&
           visitor->Visit("shaderDrawParameterFeatures",
                          &device->shader_draw_parameter_features) &&
-          visitor->Visit("bit16StorageFeatures",
-                         &device->bit16_storage_features) &&
+          visitor->Visit("shaderDrawParametersFeatures",
+                         &device->shader_draw_parameters_features) &&
           visitor->Visit("externalFenceProperties",
                          &device->external_fence_properties) &&
           visitor->Visit("externalSemaphoreProperties",
@@ -1995,89 +6740,837 @@ inline bool Iterate(Visitor* visitor, VkJsonDevice* device) {
              visitor->Visit("layers", &device->layers) &&
              visitor->Visit("formats", &device->formats);
 
-      if (device->khr_variable_pointers.reported) {
-        ret &= visitor->Visit("VK_KHR_variable_pointers",
-                              &device->khr_variable_pointers);
+      if (device->amd_anti_lag.reported) {
+        ret &= visitor->Visit("VK_AMD_anti_lag", &device->amd_anti_lag);
+      }
+      if (device->amd_device_coherent_memory.reported) {
+        ret &= visitor->Visit("VK_AMD_device_coherent_memory",
+                              &device->amd_device_coherent_memory);
+      }
+      if (device->amd_shader_core_properties.reported) {
+        ret &= visitor->Visit("VK_AMD_shader_core_properties",
+                              &device->amd_shader_core_properties);
+      }
+      if (device->amd_shader_core_properties2.reported) {
+        ret &= visitor->Visit("VK_AMD_shader_core_properties2",
+                              &device->amd_shader_core_properties2);
+      }
+      if (device->amd_shader_early_and_late_fragment_tests.reported) {
+        ret &=
+            visitor->Visit("VK_AMD_shader_early_and_late_fragment_tests",
+                           &device->amd_shader_early_and_late_fragment_tests);
+      }
+      if (device->android_external_format_resolve.reported) {
+        ret &= visitor->Visit("VK_ANDROID_external_format_resolve",
+                              &device->android_external_format_resolve);
+      }
+      if (device->arm_rasterization_order_attachment_access.reported) {
+        ret &=
+            visitor->Visit("VK_ARM_rasterization_order_attachment_access",
+                           &device->arm_rasterization_order_attachment_access);
+      }
+      if (device->arm_render_pass_striped.reported) {
+        ret &= visitor->Visit("VK_ARM_render_pass_striped",
+                              &device->arm_render_pass_striped);
+      }
+      if (device->arm_scheduling_controls.reported) {
+        ret &= visitor->Visit("VK_ARM_scheduling_controls",
+                              &device->arm_scheduling_controls);
+      }
+      if (device->arm_shader_core_builtins.reported) {
+        ret &= visitor->Visit("VK_ARM_shader_core_builtins",
+                              &device->arm_shader_core_builtins);
+      }
+      if (device->arm_shader_core_properties.reported) {
+        ret &= visitor->Visit("VK_ARM_shader_core_properties",
+                              &device->arm_shader_core_properties);
+      }
+      if (device->ext_formats_4444.reported) {
+        ret &= visitor->Visit("VK_EXT_4444_formats", &device->ext_formats_4444);
+      }
+      if (device->ext_astc_decode_mode.reported) {
+        ret &= visitor->Visit("VK_EXT_astc_decode_mode",
+                              &device->ext_astc_decode_mode);
+      }
+      if (device->ext_attachment_feedback_loop_dynamic_state.reported) {
+        ret &=
+            visitor->Visit("VK_EXT_attachment_feedback_loop_dynamic_state",
+                           &device->ext_attachment_feedback_loop_dynamic_state);
+      }
+      if (device->ext_attachment_feedback_loop_layout.reported) {
+        ret &= visitor->Visit("VK_EXT_attachment_feedback_loop_layout",
+                              &device->ext_attachment_feedback_loop_layout);
+      }
+      if (device->ext_blend_operation_advanced.reported) {
+        ret &= visitor->Visit("VK_EXT_blend_operation_advanced",
+                              &device->ext_blend_operation_advanced);
+      }
+      if (device->ext_border_color_swizzle.reported) {
+        ret &= visitor->Visit("VK_EXT_border_color_swizzle",
+                              &device->ext_border_color_swizzle);
+      }
+      if (device->ext_buffer_device_address.reported) {
+        ret &= visitor->Visit("VK_EXT_buffer_device_address",
+                              &device->ext_buffer_device_address);
+      }
+      if (device->ext_color_write_enable.reported) {
+        ret &= visitor->Visit("VK_EXT_color_write_enable",
+                              &device->ext_color_write_enable);
+      }
+      if (device->ext_conditional_rendering.reported) {
+        ret &= visitor->Visit("VK_EXT_conditional_rendering",
+                              &device->ext_conditional_rendering);
+      }
+      if (device->ext_conservative_rasterization.reported) {
+        ret &= visitor->Visit("VK_EXT_conservative_rasterization",
+                              &device->ext_conservative_rasterization);
+      }
+      if (device->ext_custom_border_color.reported) {
+        ret &= visitor->Visit("VK_EXT_custom_border_color",
+                              &device->ext_custom_border_color);
+      }
+      if (device->ext_depth_bias_control.reported) {
+        ret &= visitor->Visit("VK_EXT_depth_bias_control",
+                              &device->ext_depth_bias_control);
+      }
+      if (device->ext_depth_clamp_zero_one.reported) {
+        ret &= visitor->Visit("VK_EXT_depth_clamp_zero_one",
+                              &device->ext_depth_clamp_zero_one);
+      }
+      if (device->ext_depth_clip_control.reported) {
+        ret &= visitor->Visit("VK_EXT_depth_clip_control",
+                              &device->ext_depth_clip_control);
+      }
+      if (device->ext_depth_clip_enable.reported) {
+        ret &= visitor->Visit("VK_EXT_depth_clip_enable",
+                              &device->ext_depth_clip_enable);
+      }
+      if (device->ext_descriptor_buffer.reported) {
+        ret &= visitor->Visit("VK_EXT_descriptor_buffer",
+                              &device->ext_descriptor_buffer);
       }
-      if (device->khr_shader_float16_int8.reported) {
-        ret &= visitor->Visit("VK_KHR_shader_float16_int8",
-                              &device->khr_shader_float16_int8);
+      if (device->ext_descriptor_indexing.reported) {
+        ret &= visitor->Visit("VK_EXT_descriptor_indexing",
+                              &device->ext_descriptor_indexing);
+      }
+      if (device->ext_device_address_binding_report.reported) {
+        ret &= visitor->Visit("VK_EXT_device_address_binding_report",
+                              &device->ext_device_address_binding_report);
+      }
+      if (device->ext_device_fault.reported) {
+        ret &= visitor->Visit("VK_EXT_device_fault", &device->ext_device_fault);
+      }
+      if (device->ext_device_memory_report.reported) {
+        ret &= visitor->Visit("VK_EXT_device_memory_report",
+                              &device->ext_device_memory_report);
+      }
+      if (device->ext_discard_rectangles.reported) {
+        ret &= visitor->Visit("VK_EXT_discard_rectangles",
+                              &device->ext_discard_rectangles);
+      }
+      if (device->ext_dynamic_rendering_unused_attachments.reported) {
+        ret &=
+            visitor->Visit("VK_EXT_dynamic_rendering_unused_attachments",
+                           &device->ext_dynamic_rendering_unused_attachments);
+      }
+      if (device->ext_extended_dynamic_state.reported) {
+        ret &= visitor->Visit("VK_EXT_extended_dynamic_state",
+                              &device->ext_extended_dynamic_state);
+      }
+      if (device->ext_extended_dynamic_state2.reported) {
+        ret &= visitor->Visit("VK_EXT_extended_dynamic_state2",
+                              &device->ext_extended_dynamic_state2);
+      }
+      if (device->ext_extended_dynamic_state3.reported) {
+        ret &= visitor->Visit("VK_EXT_extended_dynamic_state3",
+                              &device->ext_extended_dynamic_state3);
+      }
+      if (device->ext_external_memory_host.reported) {
+        ret &= visitor->Visit("VK_EXT_external_memory_host",
+                              &device->ext_external_memory_host);
+      }
+      if (device->ext_fragment_density_map.reported) {
+        ret &= visitor->Visit("VK_EXT_fragment_density_map",
+                              &device->ext_fragment_density_map);
+      }
+      if (device->ext_fragment_density_map2.reported) {
+        ret &= visitor->Visit("VK_EXT_fragment_density_map2",
+                              &device->ext_fragment_density_map2);
+      }
+      if (device->ext_fragment_shader_interlock.reported) {
+        ret &= visitor->Visit("VK_EXT_fragment_shader_interlock",
+                              &device->ext_fragment_shader_interlock);
+      }
+      if (device->ext_frame_boundary.reported) {
+        ret &= visitor->Visit("VK_EXT_frame_boundary",
+                              &device->ext_frame_boundary);
+      }
+      if (device->ext_global_priority_query.reported) {
+        ret &= visitor->Visit("VK_EXT_global_priority_query",
+                              &device->ext_global_priority_query);
+      }
+      if (device->ext_graphics_pipeline_library.reported) {
+        ret &= visitor->Visit("VK_EXT_graphics_pipeline_library",
+                              &device->ext_graphics_pipeline_library);
+      }
+      if (device->ext_host_image_copy.reported) {
+        ret &= visitor->Visit("VK_EXT_host_image_copy",
+                              &device->ext_host_image_copy);
+      }
+      if (device->ext_host_query_reset.reported) {
+        ret &= visitor->Visit("VK_EXT_host_query_reset",
+                              &device->ext_host_query_reset);
       }
       if (device->ext_image_2d_view_of_3d.reported) {
         ret &= visitor->Visit("VK_EXT_image_2d_view_of_3d",
                               &device->ext_image_2d_view_of_3d);
       }
-      if (device->ext_custom_border_color.reported) {
-        ret &= visitor->Visit("VK_EXT_custom_border_color",
-                              &device->ext_custom_border_color);
+      if (device->ext_image_compression_control.reported) {
+        ret &= visitor->Visit("VK_EXT_image_compression_control",
+                              &device->ext_image_compression_control);
+      }
+      if (device->ext_image_compression_control_swapchain.reported) {
+        ret &= visitor->Visit("VK_EXT_image_compression_control_swapchain",
+                              &device->ext_image_compression_control_swapchain);
+      }
+      if (device->ext_image_robustness.reported) {
+        ret &= visitor->Visit("VK_EXT_image_robustness",
+                              &device->ext_image_robustness);
+      }
+      if (device->ext_image_sliced_view_of_3d.reported) {
+        ret &= visitor->Visit("VK_EXT_image_sliced_view_of_3d",
+                              &device->ext_image_sliced_view_of_3d);
+      }
+      if (device->ext_image_view_min_lod.reported) {
+        ret &= visitor->Visit("VK_EXT_image_view_min_lod",
+                              &device->ext_image_view_min_lod);
+      }
+      if (device->ext_index_type_uint8.reported) {
+        ret &= visitor->Visit("VK_EXT_index_type_uint8",
+                              &device->ext_index_type_uint8);
+      }
+      if (device->ext_inline_uniform_block.reported) {
+        ret &= visitor->Visit("VK_EXT_inline_uniform_block",
+                              &device->ext_inline_uniform_block);
+      }
+      if (device->ext_legacy_dithering.reported) {
+        ret &= visitor->Visit("VK_EXT_legacy_dithering",
+                              &device->ext_legacy_dithering);
+      }
+      if (device->ext_legacy_vertex_attributes.reported) {
+        ret &= visitor->Visit("VK_EXT_legacy_vertex_attributes",
+                              &device->ext_legacy_vertex_attributes);
+      }
+      if (device->ext_line_rasterization.reported) {
+        ret &= visitor->Visit("VK_EXT_line_rasterization",
+                              &device->ext_line_rasterization);
+      }
+      if (device->ext_map_memory_placed.reported) {
+        ret &= visitor->Visit("VK_EXT_map_memory_placed",
+                              &device->ext_map_memory_placed);
+      }
+      if (device->ext_memory_priority.reported) {
+        ret &= visitor->Visit("VK_EXT_memory_priority",
+                              &device->ext_memory_priority);
+      }
+      if (device->ext_mesh_shader.reported) {
+        ret &= visitor->Visit("VK_EXT_mesh_shader", &device->ext_mesh_shader);
+      }
+      if (device->ext_multi_draw.reported) {
+        ret &= visitor->Visit("VK_EXT_multi_draw", &device->ext_multi_draw);
+      }
+      if (device->ext_multisampled_render_to_single_sampled.reported) {
+        ret &=
+            visitor->Visit("VK_EXT_multisampled_render_to_single_sampled",
+                           &device->ext_multisampled_render_to_single_sampled);
+      }
+      if (device->ext_mutable_descriptor_type.reported) {
+        ret &= visitor->Visit("VK_EXT_mutable_descriptor_type",
+                              &device->ext_mutable_descriptor_type);
+      }
+      if (device->ext_nested_command_buffer.reported) {
+        ret &= visitor->Visit("VK_EXT_nested_command_buffer",
+                              &device->ext_nested_command_buffer);
+      }
+      if (device->ext_non_seamless_cube_map.reported) {
+        ret &= visitor->Visit("VK_EXT_non_seamless_cube_map",
+                              &device->ext_non_seamless_cube_map);
+      }
+      if (device->ext_opacity_micromap.reported) {
+        ret &= visitor->Visit("VK_EXT_opacity_micromap",
+                              &device->ext_opacity_micromap);
+      }
+      if (device->ext_pageable_device_local_memory.reported) {
+        ret &= visitor->Visit("VK_EXT_pageable_device_local_memory",
+                              &device->ext_pageable_device_local_memory);
+      }
+      if (device->ext_pci_bus_info.reported) {
+        ret &= visitor->Visit("VK_EXT_pci_bus_info", &device->ext_pci_bus_info);
+      }
+      if (device->ext_physical_device_drm.reported) {
+        ret &= visitor->Visit("VK_EXT_physical_device_drm",
+                              &device->ext_physical_device_drm);
+      }
+      if (device->ext_pipeline_creation_cache_control.reported) {
+        ret &= visitor->Visit("VK_EXT_pipeline_creation_cache_control",
+                              &device->ext_pipeline_creation_cache_control);
+      }
+      if (device->ext_pipeline_library_group_handles.reported) {
+        ret &= visitor->Visit("VK_EXT_pipeline_library_group_handles",
+                              &device->ext_pipeline_library_group_handles);
+      }
+      if (device->ext_pipeline_properties.reported) {
+        ret &= visitor->Visit("VK_EXT_pipeline_properties",
+                              &device->ext_pipeline_properties);
+      }
+      if (device->ext_pipeline_protected_access.reported) {
+        ret &= visitor->Visit("VK_EXT_pipeline_protected_access",
+                              &device->ext_pipeline_protected_access);
+      }
+      if (device->ext_pipeline_robustness.reported) {
+        ret &= visitor->Visit("VK_EXT_pipeline_robustness",
+                              &device->ext_pipeline_robustness);
       }
       if (device->ext_primitive_topology_list_restart.reported) {
         ret &= visitor->Visit("VK_EXT_primitive_topology_list_restart",
                               &device->ext_primitive_topology_list_restart);
       }
+      if (device->ext_primitives_generated_query.reported) {
+        ret &= visitor->Visit("VK_EXT_primitives_generated_query",
+                              &device->ext_primitives_generated_query);
+      }
+      if (device->ext_private_data.reported) {
+        ret &= visitor->Visit("VK_EXT_private_data", &device->ext_private_data);
+      }
       if (device->ext_provoking_vertex.reported) {
         ret &= visitor->Visit("VK_EXT_provoking_vertex",
                               &device->ext_provoking_vertex);
       }
-      if (device->khr_index_type_uint8.reported) {
-        ret &= visitor->Visit("VK_KHR_index_type_uint8",
-                              &device->khr_index_type_uint8);
+      if (device->ext_rasterization_order_attachment_access.reported) {
+        ret &=
+            visitor->Visit("VK_EXT_rasterization_order_attachment_access",
+                           &device->ext_rasterization_order_attachment_access);
       }
-      if (device->ext_index_type_uint8.reported) {
-        ret &= visitor->Visit("VK_EXT_index_type_uint8",
-                              &device->ext_index_type_uint8);
+      if (device->ext_rgba10x6_formats.reported) {
+        ret &= visitor->Visit("VK_EXT_rgba10x6_formats",
+                              &device->ext_rgba10x6_formats);
       }
-      if (device->khr_vertex_attribute_divisor.reported) {
-        ret &= visitor->Visit("VK_KHR_vertex_attribute_divisor",
-                              &device->khr_vertex_attribute_divisor);
+      if (device->ext_robustness2.reported) {
+        ret &= visitor->Visit("VK_EXT_robustness2", &device->ext_robustness2);
       }
-      if (device->ext_vertex_attribute_divisor.reported) {
-        ret &= visitor->Visit("VK_EXT_vertex_attribute_divisor",
-                              &device->ext_vertex_attribute_divisor);
+      if (device->ext_sample_locations.reported) {
+        ret &= visitor->Visit("VK_EXT_sample_locations",
+                              &device->ext_sample_locations);
+      }
+      if (device->ext_sampler_filter_minmax.reported) {
+        ret &= visitor->Visit("VK_EXT_sampler_filter_minmax",
+                              &device->ext_sampler_filter_minmax);
+      }
+      if (device->ext_scalar_block_layout.reported) {
+        ret &= visitor->Visit("VK_EXT_scalar_block_layout",
+                              &device->ext_scalar_block_layout);
+      }
+      if (device->ext_shader_atomic_float.reported) {
+        ret &= visitor->Visit("VK_EXT_shader_atomic_float",
+                              &device->ext_shader_atomic_float);
+      }
+      if (device->ext_shader_atomic_float2.reported) {
+        ret &= visitor->Visit("VK_EXT_shader_atomic_float2",
+                              &device->ext_shader_atomic_float2);
+      }
+      if (device->ext_shader_demote_to_helper_invocation.reported) {
+        ret &= visitor->Visit("VK_EXT_shader_demote_to_helper_invocation",
+                              &device->ext_shader_demote_to_helper_invocation);
+      }
+      if (device->ext_shader_image_atomic_int64.reported) {
+        ret &= visitor->Visit("VK_EXT_shader_image_atomic_int64",
+                              &device->ext_shader_image_atomic_int64);
+      }
+      if (device->ext_shader_module_identifier.reported) {
+        ret &= visitor->Visit("VK_EXT_shader_module_identifier",
+                              &device->ext_shader_module_identifier);
+      }
+      if (device->ext_shader_object.reported) {
+        ret &=
+            visitor->Visit("VK_EXT_shader_object", &device->ext_shader_object);
+      }
+      if (device->ext_shader_replicated_composites.reported) {
+        ret &= visitor->Visit("VK_EXT_shader_replicated_composites",
+                              &device->ext_shader_replicated_composites);
+      }
+      if (device->ext_shader_tile_image.reported) {
+        ret &= visitor->Visit("VK_EXT_shader_tile_image",
+                              &device->ext_shader_tile_image);
+      }
+      if (device->ext_subgroup_size_control.reported) {
+        ret &= visitor->Visit("VK_EXT_subgroup_size_control",
+                              &device->ext_subgroup_size_control);
+      }
+      if (device->ext_subpass_merge_feedback.reported) {
+        ret &= visitor->Visit("VK_EXT_subpass_merge_feedback",
+                              &device->ext_subpass_merge_feedback);
+      }
+      if (device->ext_swapchain_maintenance1.reported) {
+        ret &= visitor->Visit("VK_EXT_swapchain_maintenance1",
+                              &device->ext_swapchain_maintenance1);
+      }
+      if (device->ext_texel_buffer_alignment.reported) {
+        ret &= visitor->Visit("VK_EXT_texel_buffer_alignment",
+                              &device->ext_texel_buffer_alignment);
+      }
+      if (device->ext_texture_compression_astc_hdr.reported) {
+        ret &= visitor->Visit("VK_EXT_texture_compression_astc_hdr",
+                              &device->ext_texture_compression_astc_hdr);
       }
       if (device->ext_transform_feedback.reported) {
         ret &= visitor->Visit("VK_EXT_transform_feedback",
                               &device->ext_transform_feedback);
       }
-      if (device->khr_shader_subgroup_uniform_control_flow.reported) {
-        ret &=
-            visitor->Visit("VK_KHR_shader_subgroup_uniform_control_flow",
-                           &device->khr_shader_subgroup_uniform_control_flow);
+      if (device->ext_vertex_attribute_divisor.reported) {
+        ret &= visitor->Visit("VK_EXT_vertex_attribute_divisor",
+                              &device->ext_vertex_attribute_divisor);
       }
-      if (device->khr_shader_subgroup_extended_types.reported) {
-        ret &= visitor->Visit("VK_KHR_shader_subgroup_extended_types",
-                              &device->khr_shader_subgroup_extended_types);
+      if (device->ext_vertex_input_dynamic_state.reported) {
+        ret &= visitor->Visit("VK_EXT_vertex_input_dynamic_state",
+                              &device->ext_vertex_input_dynamic_state);
       }
-      if (device->khr_8bit_storage.reported) {
-        ret &= visitor->Visit("VK_KHR_8bit_storage", &device->khr_8bit_storage);
+      if (device->ext_ycbcr_2plane_444_formats.reported) {
+        ret &= visitor->Visit("VK_EXT_ycbcr_2plane_444_formats",
+                              &device->ext_ycbcr_2plane_444_formats);
       }
-      if (device->khr_shader_integer_dot_product.reported) {
-        ret &= visitor->Visit("VK_KHR_shader_integer_dot_product",
-                              &device->khr_shader_integer_dot_product);
+      if (device->ext_ycbcr_image_arrays.reported) {
+        ret &= visitor->Visit("VK_EXT_ycbcr_image_arrays",
+                              &device->ext_ycbcr_image_arrays);
+      }
+      if (device->huawei_cluster_culling_shader.reported) {
+        ret &= visitor->Visit("VK_HUAWEI_cluster_culling_shader",
+                              &device->huawei_cluster_culling_shader);
+      }
+      if (device->huawei_invocation_mask.reported) {
+        ret &= visitor->Visit("VK_HUAWEI_invocation_mask",
+                              &device->huawei_invocation_mask);
+      }
+      if (device->huawei_subpass_shading.reported) {
+        ret &= visitor->Visit("VK_HUAWEI_subpass_shading",
+                              &device->huawei_subpass_shading);
       }
       if (device->img_relaxed_line_rasterization.reported) {
         ret &= visitor->Visit("VK_IMG_relaxed_line_rasterization",
                               &device->img_relaxed_line_rasterization);
       }
+      if (device->vk_intel_shader_integer_functions2.reported) {
+        ret &= visitor->Visit("VK_INTEL_shader_integer_functions2",
+                              &device->vk_intel_shader_integer_functions2);
+      }
+      if (device->khr_16bit_storage.reported) {
+        ret &=
+            visitor->Visit("VK_KHR_16bit_storage", &device->khr_16bit_storage);
+      }
+      if (device->khr_8bit_storage.reported) {
+        ret &= visitor->Visit("VK_KHR_8bit_storage", &device->khr_8bit_storage);
+      }
+      if (device->khr_acceleration_structure.reported) {
+        ret &= visitor->Visit("VK_KHR_acceleration_structure",
+                              &device->khr_acceleration_structure);
+      }
+      if (device->khr_buffer_device_address.reported) {
+        ret &= visitor->Visit("VK_KHR_buffer_device_address",
+                              &device->khr_buffer_device_address);
+      }
+      if (device->khr_cooperative_matrix.reported) {
+        ret &= visitor->Visit("VK_KHR_cooperative_matrix",
+                              &device->khr_cooperative_matrix);
+      }
+      if (device->khr_depth_stencil_resolve.reported) {
+        ret &= visitor->Visit("VK_KHR_depth_stencil_resolve",
+                              &device->khr_depth_stencil_resolve);
+      }
+      if (device->khr_driver_properties.reported) {
+        ret &= visitor->Visit("VK_KHR_driver_properties",
+                              &device->khr_driver_properties);
+      }
+      if (device->khr_dynamic_rendering.reported) {
+        ret &= visitor->Visit("VK_KHR_dynamic_rendering",
+                              &device->khr_dynamic_rendering);
+      }
+      if (device->khr_dynamic_rendering_local_read.reported) {
+        ret &= visitor->Visit("VK_KHR_dynamic_rendering_local_read",
+                              &device->khr_dynamic_rendering_local_read);
+      }
+      if (device->khr_external_memory_capabilities.reported) {
+        ret &= visitor->Visit("VK_KHR_external_memory_capabilities",
+                              &device->khr_external_memory_capabilities);
+      }
+      if (device->khr_fragment_shader_barycentric.reported) {
+        ret &= visitor->Visit("VK_KHR_fragment_shader_barycentric",
+                              &device->khr_fragment_shader_barycentric);
+      }
+      if (device->khr_fragment_shading_rate.reported) {
+        ret &= visitor->Visit("VK_KHR_fragment_shading_rate",
+                              &device->khr_fragment_shading_rate);
+      }
+      if (device->khr_global_priority.reported) {
+        ret &= visitor->Visit("VK_KHR_global_priority",
+                              &device->khr_global_priority);
+      }
+      if (device->khr_imageless_framebuffer.reported) {
+        ret &= visitor->Visit("VK_KHR_imageless_framebuffer",
+                              &device->khr_imageless_framebuffer);
+      }
+      if (device->khr_index_type_uint8.reported) {
+        ret &= visitor->Visit("VK_KHR_index_type_uint8",
+                              &device->khr_index_type_uint8);
+      }
       if (device->khr_line_rasterization.reported) {
         ret &= visitor->Visit("VK_KHR_line_rasterization",
                               &device->khr_line_rasterization);
       }
-      if (device->ext_line_rasterization.reported) {
-        ret &= visitor->Visit("VK_EXT_line_rasterization",
-                              &device->ext_line_rasterization);
+      if (device->khr_maintenance2.reported) {
+        ret &= visitor->Visit("VK_KHR_maintenance2", &device->khr_maintenance2);
       }
-      if (device->ext_primitives_generated_query.reported) {
-        ret &= visitor->Visit("VK_EXT_primitives_generated_query",
-                              &device->ext_primitives_generated_query);
+      if (device->khr_maintenance3.reported) {
+        ret &= visitor->Visit("VK_KHR_maintenance3", &device->khr_maintenance3);
+      }
+      if (device->khr_maintenance4.reported) {
+        ret &= visitor->Visit("VK_KHR_maintenance4", &device->khr_maintenance4);
+      }
+      if (device->khr_maintenance5.reported) {
+        ret &= visitor->Visit("VK_KHR_maintenance5", &device->khr_maintenance5);
+      }
+      if (device->khr_maintenance6.reported) {
+        ret &= visitor->Visit("VK_KHR_maintenance6", &device->khr_maintenance6);
+      }
+      if (device->khr_maintenance7.reported) {
+        ret &= visitor->Visit("VK_KHR_maintenance7", &device->khr_maintenance7);
+      }
+      if (device->khr_multiview.reported) {
+        ret &= visitor->Visit("VK_KHR_multiview", &device->khr_multiview);
+      }
+      if (device->khr_performance_query.reported) {
+        ret &= visitor->Visit("VK_KHR_performance_query",
+                              &device->khr_performance_query);
+      }
+      if (device->khr_pipeline_binary.reported) {
+        ret &= visitor->Visit("VK_KHR_pipeline_binary",
+                              &device->khr_pipeline_binary);
+      }
+      if (device->khr_pipeline_executable_properties.reported) {
+        ret &= visitor->Visit("VK_KHR_pipeline_executable_properties",
+                              &device->khr_pipeline_executable_properties);
+      }
+      if (device->khr_present_id.reported) {
+        ret &= visitor->Visit("VK_KHR_present_id", &device->khr_present_id);
+      }
+      if (device->khr_present_wait.reported) {
+        ret &= visitor->Visit("VK_KHR_present_wait", &device->khr_present_wait);
+      }
+      if (device->khr_push_descriptor.reported) {
+        ret &= visitor->Visit("VK_KHR_push_descriptor",
+                              &device->khr_push_descriptor);
+      }
+      if (device->khr_ray_query.reported) {
+        ret &= visitor->Visit("VK_KHR_ray_query", &device->khr_ray_query);
+      }
+      if (device->khr_ray_tracing_maintenance1.reported) {
+        ret &= visitor->Visit("VK_KHR_ray_tracing_maintenance1",
+                              &device->khr_ray_tracing_maintenance1);
+      }
+      if (device->khr_ray_tracing_pipeline.reported) {
+        ret &= visitor->Visit("VK_KHR_ray_tracing_pipeline",
+                              &device->khr_ray_tracing_pipeline);
+      }
+      if (device->khr_ray_tracing_position_fetch.reported) {
+        ret &= visitor->Visit("VK_KHR_ray_tracing_position_fetch",
+                              &device->khr_ray_tracing_position_fetch);
+      }
+      if (device->khr_sampler_ycbcr_conversion.reported) {
+        ret &= visitor->Visit("VK_KHR_sampler_ycbcr_conversion",
+                              &device->khr_sampler_ycbcr_conversion);
+      }
+      if (device->khr_separate_depth_stencil_layouts.reported) {
+        ret &= visitor->Visit("VK_KHR_separate_depth_stencil_layouts",
+                              &device->khr_separate_depth_stencil_layouts);
+      }
+      if (device->khr_shader_atomic_int64.reported) {
+        ret &= visitor->Visit("VK_KHR_shader_atomic_int64",
+                              &device->khr_shader_atomic_int64);
+      }
+      if (device->khr_shader_clock.reported) {
+        ret &= visitor->Visit("VK_KHR_shader_clock", &device->khr_shader_clock);
+      }
+      if (device->khr_shader_expect_assume.reported) {
+        ret &= visitor->Visit("VK_KHR_shader_expect_assume",
+                              &device->khr_shader_expect_assume);
+      }
+      if (device->khr_shader_float16_int8.reported) {
+        ret &= visitor->Visit("VK_KHR_shader_float16_int8",
+                              &device->khr_shader_float16_int8);
       }
       if (device->khr_shader_float_controls.reported) {
         ret &= visitor->Visit("VK_KHR_shader_float_controls",
                               &device->khr_shader_float_controls);
       }
-      if (device->khr_driver_properties.reported) {
-        ret &= visitor->Visit("VK_KHR_driver_properties",
-                              &device->khr_driver_properties);
+      if (device->khr_shader_float_controls2.reported) {
+        ret &= visitor->Visit("VK_KHR_shader_float_controls2",
+                              &device->khr_shader_float_controls2);
+      }
+      if (device->khr_shader_integer_dot_product.reported) {
+        ret &= visitor->Visit("VK_KHR_shader_integer_dot_product",
+                              &device->khr_shader_integer_dot_product);
+      }
+      if (device->khr_shader_maximal_reconvergence.reported) {
+        ret &= visitor->Visit("VK_KHR_shader_maximal_reconvergence",
+                              &device->khr_shader_maximal_reconvergence);
+      }
+      if (device->khr_shader_quad_control.reported) {
+        ret &= visitor->Visit("VK_KHR_shader_quad_control",
+                              &device->khr_shader_quad_control);
+      }
+      if (device->khr_shader_relaxed_extended_instruction.reported) {
+        ret &= visitor->Visit("VK_KHR_shader_relaxed_extended_instruction",
+                              &device->khr_shader_relaxed_extended_instruction);
+      }
+      if (device->khr_shader_subgroup_extended_types.reported) {
+        ret &= visitor->Visit("VK_KHR_shader_subgroup_extended_types",
+                              &device->khr_shader_subgroup_extended_types);
+      }
+      if (device->khr_shader_subgroup_rotate.reported) {
+        ret &= visitor->Visit("VK_KHR_shader_subgroup_rotate",
+                              &device->khr_shader_subgroup_rotate);
+      }
+      if (device->khr_shader_subgroup_uniform_control_flow.reported) {
+        ret &=
+            visitor->Visit("VK_KHR_shader_subgroup_uniform_control_flow",
+                           &device->khr_shader_subgroup_uniform_control_flow);
+      }
+      if (device->khr_shader_terminate_invocation.reported) {
+        ret &= visitor->Visit("VK_KHR_shader_terminate_invocation",
+                              &device->khr_shader_terminate_invocation);
+      }
+      if (device->khr_synchronization2.reported) {
+        ret &= visitor->Visit("VK_KHR_synchronization2",
+                              &device->khr_synchronization2);
+      }
+      if (device->khr_timeline_semaphore.reported) {
+        ret &= visitor->Visit("VK_KHR_timeline_semaphore",
+                              &device->khr_timeline_semaphore);
+      }
+      if (device->khr_uniform_buffer_standard_layout.reported) {
+        ret &= visitor->Visit("VK_KHR_uniform_buffer_standard_layout",
+                              &device->khr_uniform_buffer_standard_layout);
+      }
+      if (device->khr_variable_pointers.reported) {
+        ret &= visitor->Visit("VK_KHR_variable_pointers",
+                              &device->khr_variable_pointers);
+      }
+      if (device->khr_vertex_attribute_divisor.reported) {
+        ret &= visitor->Visit("VK_KHR_vertex_attribute_divisor",
+                              &device->khr_vertex_attribute_divisor);
+      }
+      if (device->khr_video_maintenance1.reported) {
+        ret &= visitor->Visit("VK_KHR_video_maintenance1",
+                              &device->khr_video_maintenance1);
+      }
+      if (device->khr_vulkan_memory_model.reported) {
+        ret &= visitor->Visit("VK_KHR_vulkan_memory_model",
+                              &device->khr_vulkan_memory_model);
+      }
+      if (device->khr_workgroup_memory_explicit_layout.reported) {
+        ret &= visitor->Visit("VK_KHR_workgroup_memory_explicit_layout",
+                              &device->khr_workgroup_memory_explicit_layout);
+      }
+      if (device->khr_zero_initialize_workgroup_memory.reported) {
+        ret &= visitor->Visit("VK_KHR_zero_initialize_workgroup_memory",
+                              &device->khr_zero_initialize_workgroup_memory);
+      }
+      if (device->mesa_image_alignment_control.reported) {
+        ret &= visitor->Visit("VK_MESA_image_alignment_control",
+                              &device->mesa_image_alignment_control);
+      }
+      if (device->msft_layered_driver.reported) {
+        ret &= visitor->Visit("VK_MSFT_layered_driver",
+                              &device->msft_layered_driver);
+      }
+      if (device->nvx_multiview_per_view_attributes.reported) {
+        ret &= visitor->Visit("VK_NVX_multiview_per_view_attributes",
+                              &device->nvx_multiview_per_view_attributes);
+      }
+      if (device->nv_command_buffer_inheritance.reported) {
+        ret &= visitor->Visit("VK_NV_command_buffer_inheritance",
+                              &device->nv_command_buffer_inheritance);
+      }
+      if (device->nv_compute_shader_derivatives.reported) {
+        ret &= visitor->Visit("VK_NV_compute_shader_derivatives",
+                              &device->nv_compute_shader_derivatives);
+      }
+      if (device->nv_cooperative_matrix.reported) {
+        ret &= visitor->Visit("VK_NV_cooperative_matrix",
+                              &device->nv_cooperative_matrix);
+      }
+      if (device->nv_copy_memory_indirect.reported) {
+        ret &= visitor->Visit("VK_NV_copy_memory_indirect",
+                              &device->nv_copy_memory_indirect);
+      }
+      if (device->nv_corner_sampled_image.reported) {
+        ret &= visitor->Visit("VK_NV_corner_sampled_image",
+                              &device->nv_corner_sampled_image);
+      }
+      if (device->nv_coverage_reduction_mode.reported) {
+        ret &= visitor->Visit("VK_NV_coverage_reduction_mode",
+                              &device->nv_coverage_reduction_mode);
+      }
+      if (device->nv_cuda_kernel_launch.reported) {
+        ret &= visitor->Visit("VK_NV_cuda_kernel_launch",
+                              &device->nv_cuda_kernel_launch);
+      }
+      if (device->nv_dedicated_allocation_image_aliasing.reported) {
+        ret &= visitor->Visit("VK_NV_dedicated_allocation_image_aliasing",
+                              &device->nv_dedicated_allocation_image_aliasing);
+      }
+      if (device->nv_descriptor_pool_overallocation.reported) {
+        ret &= visitor->Visit("VK_NV_descriptor_pool_overallocation",
+                              &device->nv_descriptor_pool_overallocation);
+      }
+      if (device->nv_device_diagnostics_config.reported) {
+        ret &= visitor->Visit("VK_NV_device_diagnostics_config",
+                              &device->nv_device_diagnostics_config);
+      }
+      if (device->nv_device_generated_commands.reported) {
+        ret &= visitor->Visit("VK_NV_device_generated_commands",
+                              &device->nv_device_generated_commands);
+      }
+      if (device->nv_device_generated_commands_compute.reported) {
+        ret &= visitor->Visit("VK_NV_device_generated_commands_compute",
+                              &device->nv_device_generated_commands_compute);
+      }
+      if (device->nv_extended_sparse_address_space.reported) {
+        ret &= visitor->Visit("VK_NV_extended_sparse_address_space",
+                              &device->nv_extended_sparse_address_space);
+      }
+      if (device->nv_external_memory_rdma.reported) {
+        ret &= visitor->Visit("VK_NV_external_memory_rdma",
+                              &device->nv_external_memory_rdma);
+      }
+      if (device->nv_fragment_shading_rate_enums.reported) {
+        ret &= visitor->Visit("VK_NV_fragment_shading_rate_enums",
+                              &device->nv_fragment_shading_rate_enums);
+      }
+      if (device->nv_inherited_viewport_scissor.reported) {
+        ret &= visitor->Visit("VK_NV_inherited_viewport_scissor",
+                              &device->nv_inherited_viewport_scissor);
+      }
+      if (device->nv_linear_color_attachment.reported) {
+        ret &= visitor->Visit("VK_NV_linear_color_attachment",
+                              &device->nv_linear_color_attachment);
+      }
+      if (device->nv_memory_decompression.reported) {
+        ret &= visitor->Visit("VK_NV_memory_decompression",
+                              &device->nv_memory_decompression);
+      }
+      if (device->nv_mesh_shader.reported) {
+        ret &= visitor->Visit("VK_NV_mesh_shader", &device->nv_mesh_shader);
+      }
+      if (device->nv_optical_flow.reported) {
+        ret &= visitor->Visit("VK_NV_optical_flow", &device->nv_optical_flow);
+      }
+      if (device->nv_per_stage_descriptor_set.reported) {
+        ret &= visitor->Visit("VK_NV_per_stage_descriptor_set",
+                              &device->nv_per_stage_descriptor_set);
+      }
+      if (device->nv_present_barrier.reported) {
+        ret &= visitor->Visit("VK_NV_present_barrier",
+                              &device->nv_present_barrier);
+      }
+      if (device->nv_raw_access_chains.reported) {
+        ret &= visitor->Visit("VK_NV_raw_access_chains",
+                              &device->nv_raw_access_chains);
+      }
+      if (device->nv_ray_tracing.reported) {
+        ret &= visitor->Visit("VK_NV_ray_tracing", &device->nv_ray_tracing);
+      }
+      if (device->nv_ray_tracing_invocation_reorder.reported) {
+        ret &= visitor->Visit("VK_NV_ray_tracing_invocation_reorder",
+                              &device->nv_ray_tracing_invocation_reorder);
+      }
+      if (device->nv_ray_tracing_motion_blur.reported) {
+        ret &= visitor->Visit("VK_NV_ray_tracing_motion_blur",
+                              &device->nv_ray_tracing_motion_blur);
+      }
+      if (device->nv_ray_tracing_validation.reported) {
+        ret &= visitor->Visit("VK_NV_ray_tracing_validation",
+                              &device->nv_ray_tracing_validation);
+      }
+      if (device->nv_representative_fragment_test.reported) {
+        ret &= visitor->Visit("VK_NV_representative_fragment_test",
+                              &device->nv_representative_fragment_test);
+      }
+      if (device->nv_scissor_exclusive.reported) {
+        ret &= visitor->Visit("VK_NV_scissor_exclusive",
+                              &device->nv_scissor_exclusive);
+      }
+      if (device->nv_shader_atomic_float16_vector.reported) {
+        ret &= visitor->Visit("VK_NV_shader_atomic_float16_vector",
+                              &device->nv_shader_atomic_float16_vector);
+      }
+      if (device->nv_shader_image_footprint.reported) {
+        ret &= visitor->Visit("VK_NV_shader_image_footprint",
+                              &device->nv_shader_image_footprint);
+      }
+      if (device->nv_shader_sm_builtins.reported) {
+        ret &= visitor->Visit("VK_NV_shader_sm_builtins",
+                              &device->nv_shader_sm_builtins);
+      }
+      if (device->nv_shading_rate_image.reported) {
+        ret &= visitor->Visit("VK_NV_shading_rate_image",
+                              &device->nv_shading_rate_image);
+      }
+      if (device->qcom_filter_cubic_clamp.reported) {
+        ret &= visitor->Visit("VK_QCOM_filter_cubic_clamp",
+                              &device->qcom_filter_cubic_clamp);
+      }
+      if (device->qcom_filter_cubic_weights.reported) {
+        ret &= visitor->Visit("VK_QCOM_filter_cubic_weights",
+                              &device->qcom_filter_cubic_weights);
+      }
+      if (device->qcom_fragment_density_map_offset.reported) {
+        ret &= visitor->Visit("VK_QCOM_fragment_density_map_offset",
+                              &device->qcom_fragment_density_map_offset);
+      }
+      if (device->qcom_image_processing.reported) {
+        ret &= visitor->Visit("VK_QCOM_image_processing",
+                              &device->qcom_image_processing);
+      }
+      if (device->qcom_image_processing2.reported) {
+        ret &= visitor->Visit("VK_QCOM_image_processing2",
+                              &device->qcom_image_processing2);
+      }
+      if (device->qcom_multiview_per_view_render_areas.reported) {
+        ret &= visitor->Visit("VK_QCOM_multiview_per_view_render_areas",
+                              &device->qcom_multiview_per_view_render_areas);
+      }
+      if (device->qcom_multiview_per_view_viewports.reported) {
+        ret &= visitor->Visit("VK_QCOM_multiview_per_view_viewports",
+                              &device->qcom_multiview_per_view_viewports);
+      }
+      if (device->qcom_tile_properties.reported) {
+        ret &= visitor->Visit("VK_QCOM_tile_properties",
+                              &device->qcom_tile_properties);
+      }
+      if (device->qcom_ycbcr_degamma.reported) {
+        ret &= visitor->Visit("VK_QCOM_ycbcr_degamma",
+                              &device->qcom_ycbcr_degamma);
+      }
+      if (device->sec_amigo_profiling.reported) {
+        ret &= visitor->Visit("VK_SEC_amigo_profiling",
+                              &device->sec_amigo_profiling);
+      }
+      if (device->valve_descriptor_set_host_mapping.reported) {
+        ret &= visitor->Visit("VK_VALVE_descriptor_set_host_mapping",
+                              &device->valve_descriptor_set_host_mapping);
+      }
+      if (device->valve_mutable_descriptor_type.reported) {
+        ret &= visitor->Visit("VK_VALVE_mutable_descriptor_type",
+                              &device->valve_mutable_descriptor_type);
       }
   }
   return ret;
@@ -2098,12 +7591,9 @@ inline bool Iterate(Visitor* visitor, VkJsonInstance* instance) {
       ret &= visitor->Visit("deviceGroups", &instance->device_groups);
       FALLTHROUGH_INTENDED;
     case VK_API_VERSION_1_0:
-      char depString[] =
-          "vkjson is deprecated, and will be replaced in a future release";
       ret &= visitor->Visit("layers", &instance->layers) &&
              visitor->Visit("extensions", &instance->extensions) &&
-             visitor->Visit("devices", &instance->devices) &&
-             visitor->Visit("_comment", &depString);
+             visitor->Visit("devices", &instance->devices);
   }
   return ret;
 }
@@ -2242,6 +7732,18 @@ inline bool AsValue(Json::Value* json_value, int32_t* value) {
   return true;
 }
 
+inline bool AsValue(Json::Value* json_value, int64_t* value) {
+  if (json_value->type() != Json::realValue)
+    return false;
+  double d = json_value->asDouble();
+  if (!IsIntegral(d) ||
+      d < static_cast<double>(std::numeric_limits<int64_t>::min()) ||
+      d > static_cast<double>(std::numeric_limits<int64_t>::max()))
+    return false;
+  *value = static_cast<int64_t>(d);
+  return true;
+}
+
 inline bool AsValue(Json::Value* json_value, uint64_t* value) {
   if (json_value->type() != Json::stringValue)
     return false;
diff --git a/vulkan/vkjson/vkjson.h b/vulkan/vkjson/vkjson.h
index cfba8c58d9..07f23e31f1 100644
--- a/vulkan/vkjson/vkjson.h
+++ b/vulkan/vkjson/vkjson.h
@@ -21,354 +21,3019 @@
 #ifndef VKJSON_H_
 #define VKJSON_H_
 
+#ifndef VK_USE_PLATFORM_ANDROID_KHR
+#define VK_USE_PLATFORM_ANDROID_KHR
+#endif
+
 #include <string.h>
 #include <vulkan/vulkan.h>
 
-#include <map>
-#include <string>
-#include <vector>
+#include <map>
+#include <string>
+#include <vector>
+
+#ifdef WIN32
+#undef min
+#undef max
+#endif
+
+/*
+ * This file is autogenerated by vkjson_generator.py. Do not edit directly.
+ */
+struct VkJsonLayer {
+  VkLayerProperties properties;
+  std::vector<VkExtensionProperties> extensions;
+};
+
+struct VkJsonAMDAntiLag {
+  VkJsonAMDAntiLag() {
+    reported = false;
+    memset(&anti_lag_features_amd, 0,
+           sizeof(VkPhysicalDeviceAntiLagFeaturesAMD));
+  }
+  bool reported;
+  VkPhysicalDeviceAntiLagFeaturesAMD anti_lag_features_amd;
+};
+
+struct VkJsonAMDDeviceCoherentMemory {
+  VkJsonAMDDeviceCoherentMemory() {
+    reported = false;
+    memset(&coherent_memory_features_amd, 0,
+           sizeof(VkPhysicalDeviceCoherentMemoryFeaturesAMD));
+  }
+  bool reported;
+  VkPhysicalDeviceCoherentMemoryFeaturesAMD coherent_memory_features_amd;
+};
+
+struct VkJsonAMDShaderCoreProperties {
+  VkJsonAMDShaderCoreProperties() {
+    reported = false;
+    memset(&shader_core_properties_amd, 0,
+           sizeof(VkPhysicalDeviceShaderCorePropertiesAMD));
+  }
+  bool reported;
+  VkPhysicalDeviceShaderCorePropertiesAMD shader_core_properties_amd;
+};
+
+struct VkJsonAMDShaderCoreProperties2 {
+  VkJsonAMDShaderCoreProperties2() {
+    reported = false;
+    memset(&shader_core_properties2_amd, 0,
+           sizeof(VkPhysicalDeviceShaderCoreProperties2AMD));
+  }
+  bool reported;
+  VkPhysicalDeviceShaderCoreProperties2AMD shader_core_properties2_amd;
+};
+
+struct VkJsonAMDShaderEarlyAndLateFragmentTests {
+  VkJsonAMDShaderEarlyAndLateFragmentTests() {
+    reported = false;
+    memset(&shader_early_and_late_fragment_tests_features_amd, 0,
+           sizeof(VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD));
+  }
+  bool reported;
+  VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD
+      shader_early_and_late_fragment_tests_features_amd;
+};
+
+struct VkJsonANDROIDExternalFormatResolve {
+  VkJsonANDROIDExternalFormatResolve() {
+    reported = false;
+    memset(&external_format_resolve_features_android, 0,
+           sizeof(VkPhysicalDeviceExternalFormatResolveFeaturesANDROID));
+    memset(&external_format_resolve_properties_android, 0,
+           sizeof(VkPhysicalDeviceExternalFormatResolvePropertiesANDROID));
+  }
+  bool reported;
+  VkPhysicalDeviceExternalFormatResolveFeaturesANDROID
+      external_format_resolve_features_android;
+  VkPhysicalDeviceExternalFormatResolvePropertiesANDROID
+      external_format_resolve_properties_android;
+};
+
+struct VkJsonARMRasterizationOrderAttachmentAccess {
+  VkJsonARMRasterizationOrderAttachmentAccess() {
+    reported = false;
+    memset(
+        &rasterization_order_attachment_access_features_arm, 0,
+        sizeof(VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM));
+  }
+  bool reported;
+  VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM
+      rasterization_order_attachment_access_features_arm;
+};
+
+struct VkJsonARMRenderPassStriped {
+  VkJsonARMRenderPassStriped() {
+    reported = false;
+    memset(&render_pass_striped_features_arm, 0,
+           sizeof(VkPhysicalDeviceRenderPassStripedFeaturesARM));
+    memset(&render_pass_striped_properties_arm, 0,
+           sizeof(VkPhysicalDeviceRenderPassStripedPropertiesARM));
+  }
+  bool reported;
+  VkPhysicalDeviceRenderPassStripedFeaturesARM render_pass_striped_features_arm;
+  VkPhysicalDeviceRenderPassStripedPropertiesARM
+      render_pass_striped_properties_arm;
+};
+
+struct VkJsonARMSchedulingControls {
+  VkJsonARMSchedulingControls() {
+    reported = false;
+    memset(&scheduling_controls_features_arm, 0,
+           sizeof(VkPhysicalDeviceSchedulingControlsFeaturesARM));
+    memset(&scheduling_controls_properties_arm, 0,
+           sizeof(VkPhysicalDeviceSchedulingControlsPropertiesARM));
+  }
+  bool reported;
+  VkPhysicalDeviceSchedulingControlsFeaturesARM
+      scheduling_controls_features_arm;
+  VkPhysicalDeviceSchedulingControlsPropertiesARM
+      scheduling_controls_properties_arm;
+};
+
+struct VkJsonARMShaderCoreBuiltins {
+  VkJsonARMShaderCoreBuiltins() {
+    reported = false;
+    memset(&shader_core_builtins_features_arm, 0,
+           sizeof(VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM));
+    memset(&shader_core_builtins_properties_arm, 0,
+           sizeof(VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM));
+  }
+  bool reported;
+  VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM
+      shader_core_builtins_features_arm;
+  VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM
+      shader_core_builtins_properties_arm;
+};
+
+struct VkJsonARMShaderCoreProperties {
+  VkJsonARMShaderCoreProperties() {
+    reported = false;
+    memset(&shader_core_properties_arm, 0,
+           sizeof(VkPhysicalDeviceShaderCorePropertiesARM));
+  }
+  bool reported;
+  VkPhysicalDeviceShaderCorePropertiesARM shader_core_properties_arm;
+};
+
+struct VkJsonExt4444Formats {
+  VkJsonExt4444Formats() {
+    reported = false;
+    memset(&formats_4444_features_ext, 0,
+           sizeof(VkPhysicalDevice4444FormatsFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDevice4444FormatsFeaturesEXT formats_4444_features_ext;
+};
+
+struct VkJsonExtAstcDecodeMode {
+  VkJsonExtAstcDecodeMode() {
+    reported = false;
+    memset(&astc_decode_features_ext, 0,
+           sizeof(VkPhysicalDeviceASTCDecodeFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceASTCDecodeFeaturesEXT astc_decode_features_ext;
+};
+
+struct VkJsonExtAttachmentFeedbackLoopDynamicState {
+  VkJsonExtAttachmentFeedbackLoopDynamicState() {
+    reported = false;
+    memset(
+        &attachment_feedback_loop_dynamic_state_features_ext, 0,
+        sizeof(VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT
+      attachment_feedback_loop_dynamic_state_features_ext;
+};
+
+struct VkJsonExtAttachmentFeedbackLoopLayout {
+  VkJsonExtAttachmentFeedbackLoopLayout() {
+    reported = false;
+    memset(&attachment_feedback_loop_layout_features_ext, 0,
+           sizeof(VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT
+      attachment_feedback_loop_layout_features_ext;
+};
+
+struct VkJsonExtBlendOperationAdvanced {
+  VkJsonExtBlendOperationAdvanced() {
+    reported = false;
+    memset(&blend_operation_advanced_features_ext, 0,
+           sizeof(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT));
+    memset(&blend_operation_advanced_properties_ext, 0,
+           sizeof(VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT
+      blend_operation_advanced_features_ext;
+  VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT
+      blend_operation_advanced_properties_ext;
+};
+
+struct VkJsonExtBorderColorSwizzle {
+  VkJsonExtBorderColorSwizzle() {
+    reported = false;
+    memset(&border_color_swizzle_features_ext, 0,
+           sizeof(VkPhysicalDeviceBorderColorSwizzleFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceBorderColorSwizzleFeaturesEXT
+      border_color_swizzle_features_ext;
+};
+
+struct VkJsonExtBufferDeviceAddress {
+  VkJsonExtBufferDeviceAddress() {
+    reported = false;
+    memset(&buffer_address_features_ext, 0,
+           sizeof(VkPhysicalDeviceBufferAddressFeaturesEXT));
+    memset(&buffer_device_address_features_ext, 0,
+           sizeof(VkPhysicalDeviceBufferDeviceAddressFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceBufferAddressFeaturesEXT buffer_address_features_ext;
+  VkPhysicalDeviceBufferDeviceAddressFeaturesEXT
+      buffer_device_address_features_ext;
+};
+
+struct VkJsonExtColorWriteEnable {
+  VkJsonExtColorWriteEnable() {
+    reported = false;
+    memset(&color_write_enable_features_ext, 0,
+           sizeof(VkPhysicalDeviceColorWriteEnableFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceColorWriteEnableFeaturesEXT color_write_enable_features_ext;
+};
+
+struct VkJsonExtConditionalRendering {
+  VkJsonExtConditionalRendering() {
+    reported = false;
+    memset(&conditional_rendering_features_ext, 0,
+           sizeof(VkPhysicalDeviceConditionalRenderingFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceConditionalRenderingFeaturesEXT
+      conditional_rendering_features_ext;
+};
+
+struct VkJsonExtConservativeRasterization {
+  VkJsonExtConservativeRasterization() {
+    reported = false;
+    memset(&conservative_rasterization_properties_ext, 0,
+           sizeof(VkPhysicalDeviceConservativeRasterizationPropertiesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceConservativeRasterizationPropertiesEXT
+      conservative_rasterization_properties_ext;
+};
+
+struct VkJsonExtCustomBorderColor {
+  VkJsonExtCustomBorderColor() {
+    reported = false;
+    memset(&custom_border_color_properties_ext, 0,
+           sizeof(VkPhysicalDeviceCustomBorderColorPropertiesEXT));
+    memset(&custom_border_color_features_ext, 0,
+           sizeof(VkPhysicalDeviceCustomBorderColorFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceCustomBorderColorPropertiesEXT
+      custom_border_color_properties_ext;
+  VkPhysicalDeviceCustomBorderColorFeaturesEXT custom_border_color_features_ext;
+};
+
+struct VkJsonExtDepthBiasControl {
+  VkJsonExtDepthBiasControl() {
+    reported = false;
+    memset(&depth_bias_control_features_ext, 0,
+           sizeof(VkPhysicalDeviceDepthBiasControlFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceDepthBiasControlFeaturesEXT depth_bias_control_features_ext;
+};
+
+struct VkJsonExtDepthClampZeroOne {
+  VkJsonExtDepthClampZeroOne() {
+    reported = false;
+    memset(&depth_clamp_zero_one_features_ext, 0,
+           sizeof(VkPhysicalDeviceDepthClampZeroOneFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceDepthClampZeroOneFeaturesEXT
+      depth_clamp_zero_one_features_ext;
+};
+
+struct VkJsonExtDepthClipControl {
+  VkJsonExtDepthClipControl() {
+    reported = false;
+    memset(&depth_clip_control_features_ext, 0,
+           sizeof(VkPhysicalDeviceDepthClipControlFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceDepthClipControlFeaturesEXT depth_clip_control_features_ext;
+};
+
+struct VkJsonExtDepthClipEnable {
+  VkJsonExtDepthClipEnable() {
+    reported = false;
+    memset(&depth_clip_enable_features_ext, 0,
+           sizeof(VkPhysicalDeviceDepthClipEnableFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceDepthClipEnableFeaturesEXT depth_clip_enable_features_ext;
+};
+
+struct VkJsonExtDescriptorBuffer {
+  VkJsonExtDescriptorBuffer() {
+    reported = false;
+    memset(&descriptor_buffer_properties_ext, 0,
+           sizeof(VkPhysicalDeviceDescriptorBufferPropertiesEXT));
+    memset(&descriptor_buffer_density_map_properties_ext, 0,
+           sizeof(VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT));
+    memset(&descriptor_buffer_features_ext, 0,
+           sizeof(VkPhysicalDeviceDescriptorBufferFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceDescriptorBufferPropertiesEXT
+      descriptor_buffer_properties_ext;
+  VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT
+      descriptor_buffer_density_map_properties_ext;
+  VkPhysicalDeviceDescriptorBufferFeaturesEXT descriptor_buffer_features_ext;
+};
+
+struct VkJsonExtDescriptorIndexing {
+  VkJsonExtDescriptorIndexing() {
+    reported = false;
+    memset(&descriptor_indexing_features_ext, 0,
+           sizeof(VkPhysicalDeviceDescriptorIndexingFeaturesEXT));
+    memset(&descriptor_indexing_properties_ext, 0,
+           sizeof(VkPhysicalDeviceDescriptorIndexingPropertiesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceDescriptorIndexingFeaturesEXT
+      descriptor_indexing_features_ext;
+  VkPhysicalDeviceDescriptorIndexingPropertiesEXT
+      descriptor_indexing_properties_ext;
+};
+
+struct VkJsonExtDeviceAddressBindingReport {
+  VkJsonExtDeviceAddressBindingReport() {
+    reported = false;
+    memset(&address_binding_report_features_ext, 0,
+           sizeof(VkPhysicalDeviceAddressBindingReportFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceAddressBindingReportFeaturesEXT
+      address_binding_report_features_ext;
+};
+
+struct VkJsonExtDeviceFault {
+  VkJsonExtDeviceFault() {
+    reported = false;
+    memset(&fault_features_ext, 0, sizeof(VkPhysicalDeviceFaultFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceFaultFeaturesEXT fault_features_ext;
+};
+
+struct VkJsonExtDeviceMemoryReport {
+  VkJsonExtDeviceMemoryReport() {
+    reported = false;
+    memset(&device_memory_report_features_ext, 0,
+           sizeof(VkPhysicalDeviceDeviceMemoryReportFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceDeviceMemoryReportFeaturesEXT
+      device_memory_report_features_ext;
+};
+
+struct VkJsonExtDiscardRectangles {
+  VkJsonExtDiscardRectangles() {
+    reported = false;
+    memset(&discard_rectangle_properties_ext, 0,
+           sizeof(VkPhysicalDeviceDiscardRectanglePropertiesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceDiscardRectanglePropertiesEXT
+      discard_rectangle_properties_ext;
+};
+
+struct VkJsonExtDynamicRenderingUnusedAttachments {
+  VkJsonExtDynamicRenderingUnusedAttachments() {
+    reported = false;
+    memset(
+        &dynamic_rendering_unused_attachments_features_ext, 0,
+        sizeof(VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT
+      dynamic_rendering_unused_attachments_features_ext;
+};
+
+struct VkJsonExtExtendedDynamicState {
+  VkJsonExtExtendedDynamicState() {
+    reported = false;
+    memset(&extended_dynamic_state_features_ext, 0,
+           sizeof(VkPhysicalDeviceExtendedDynamicStateFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceExtendedDynamicStateFeaturesEXT
+      extended_dynamic_state_features_ext;
+};
+
+struct VkJsonExtExtendedDynamicState2 {
+  VkJsonExtExtendedDynamicState2() {
+    reported = false;
+    memset(&extended_dynamic_state2_features_ext, 0,
+           sizeof(VkPhysicalDeviceExtendedDynamicState2FeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceExtendedDynamicState2FeaturesEXT
+      extended_dynamic_state2_features_ext;
+};
+
+struct VkJsonExtExtendedDynamicState3 {
+  VkJsonExtExtendedDynamicState3() {
+    reported = false;
+    memset(&extended_dynamic_state3_features_ext, 0,
+           sizeof(VkPhysicalDeviceExtendedDynamicState3FeaturesEXT));
+    memset(&extended_dynamic_state3_properties_ext, 0,
+           sizeof(VkPhysicalDeviceExtendedDynamicState3PropertiesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceExtendedDynamicState3FeaturesEXT
+      extended_dynamic_state3_features_ext;
+  VkPhysicalDeviceExtendedDynamicState3PropertiesEXT
+      extended_dynamic_state3_properties_ext;
+};
+
+struct VkJsonExtExternalMemoryHost {
+  VkJsonExtExternalMemoryHost() {
+    reported = false;
+    memset(&external_memory_host_properties_ext, 0,
+           sizeof(VkPhysicalDeviceExternalMemoryHostPropertiesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceExternalMemoryHostPropertiesEXT
+      external_memory_host_properties_ext;
+};
+
+struct VkJsonExtFragmentDensityMap {
+  VkJsonExtFragmentDensityMap() {
+    reported = false;
+    memset(&fragment_density_map_features_ext, 0,
+           sizeof(VkPhysicalDeviceFragmentDensityMapFeaturesEXT));
+    memset(&fragment_density_map_properties_ext, 0,
+           sizeof(VkPhysicalDeviceFragmentDensityMapPropertiesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceFragmentDensityMapFeaturesEXT
+      fragment_density_map_features_ext;
+  VkPhysicalDeviceFragmentDensityMapPropertiesEXT
+      fragment_density_map_properties_ext;
+};
+
+struct VkJsonExtFragmentDensityMap2 {
+  VkJsonExtFragmentDensityMap2() {
+    reported = false;
+    memset(&fragment_density_map2_features_ext, 0,
+           sizeof(VkPhysicalDeviceFragmentDensityMap2FeaturesEXT));
+    memset(&fragment_density_map2_properties_ext, 0,
+           sizeof(VkPhysicalDeviceFragmentDensityMap2PropertiesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceFragmentDensityMap2FeaturesEXT
+      fragment_density_map2_features_ext;
+  VkPhysicalDeviceFragmentDensityMap2PropertiesEXT
+      fragment_density_map2_properties_ext;
+};
+
+struct VkJsonExtFragmentShaderInterlock {
+  VkJsonExtFragmentShaderInterlock() {
+    reported = false;
+    memset(&fragment_shader_interlock_features_ext, 0,
+           sizeof(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT
+      fragment_shader_interlock_features_ext;
+};
+
+struct VkJsonExtFrameBoundary {
+  VkJsonExtFrameBoundary() {
+    reported = false;
+    memset(&frame_boundary_features_ext, 0,
+           sizeof(VkPhysicalDeviceFrameBoundaryFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceFrameBoundaryFeaturesEXT frame_boundary_features_ext;
+};
+
+struct VkJsonExtGlobalPriorityQuery {
+  VkJsonExtGlobalPriorityQuery() {
+    reported = false;
+    memset(&global_priority_query_features_ext, 0,
+           sizeof(VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT
+      global_priority_query_features_ext;
+};
+
+struct VkJsonExtGraphicsPipelineLibrary {
+  VkJsonExtGraphicsPipelineLibrary() {
+    reported = false;
+    memset(&graphics_pipeline_library_features_ext, 0,
+           sizeof(VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT));
+    memset(&graphics_pipeline_library_properties_ext, 0,
+           sizeof(VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT
+      graphics_pipeline_library_features_ext;
+  VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT
+      graphics_pipeline_library_properties_ext;
+};
+
+struct VkJsonExtHostImageCopy {
+  VkJsonExtHostImageCopy() {
+    reported = false;
+    memset(&host_image_copy_features_ext, 0,
+           sizeof(VkPhysicalDeviceHostImageCopyFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceHostImageCopyFeaturesEXT host_image_copy_features_ext;
+};
+
+struct VkJsonExtHostQueryReset {
+  VkJsonExtHostQueryReset() {
+    reported = false;
+    memset(&host_query_reset_features_ext, 0,
+           sizeof(VkPhysicalDeviceHostQueryResetFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceHostQueryResetFeaturesEXT host_query_reset_features_ext;
+};
+
+struct VkJsonExtImage2dViewOf3d {
+  VkJsonExtImage2dViewOf3d() {
+    reported = false;
+    memset(&image_2d_view_of_3d_features_ext, 0,
+           sizeof(VkPhysicalDeviceImage2DViewOf3DFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceImage2DViewOf3DFeaturesEXT image_2d_view_of_3d_features_ext;
+};
+
+struct VkJsonExtImageCompressionControl {
+  VkJsonExtImageCompressionControl() {
+    reported = false;
+    memset(&image_compression_control_features_ext, 0,
+           sizeof(VkPhysicalDeviceImageCompressionControlFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceImageCompressionControlFeaturesEXT
+      image_compression_control_features_ext;
+};
+
+struct VkJsonExtImageCompressionControlSwapchain {
+  VkJsonExtImageCompressionControlSwapchain() {
+    reported = false;
+    memset(&image_compression_control_swapchain_features_ext, 0,
+           sizeof(VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT
+      image_compression_control_swapchain_features_ext;
+};
+
+struct VkJsonExtImageRobustness {
+  VkJsonExtImageRobustness() {
+    reported = false;
+    memset(&image_robustness_features_ext, 0,
+           sizeof(VkPhysicalDeviceImageRobustnessFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceImageRobustnessFeaturesEXT image_robustness_features_ext;
+};
+
+struct VkJsonExtImageSlicedViewOf3d {
+  VkJsonExtImageSlicedViewOf3d() {
+    reported = false;
+    memset(&image_sliced_view_of_3d_features_ext, 0,
+           sizeof(VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT
+      image_sliced_view_of_3d_features_ext;
+};
+
+struct VkJsonExtImageViewMinLod {
+  VkJsonExtImageViewMinLod() {
+    reported = false;
+    memset(&image_view_min_lod_features_ext, 0,
+           sizeof(VkPhysicalDeviceImageViewMinLodFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceImageViewMinLodFeaturesEXT image_view_min_lod_features_ext;
+};
+
+struct VkJsonExtIndexTypeUint8 {
+  VkJsonExtIndexTypeUint8() {
+    reported = false;
+    memset(&index_type_uint8_features_ext, 0,
+           sizeof(VkPhysicalDeviceIndexTypeUint8FeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceIndexTypeUint8FeaturesEXT index_type_uint8_features_ext;
+};
+
+struct VkJsonExtInlineUniformBlock {
+  VkJsonExtInlineUniformBlock() {
+    reported = false;
+    memset(&inline_uniform_block_features_ext, 0,
+           sizeof(VkPhysicalDeviceInlineUniformBlockFeaturesEXT));
+    memset(&inline_uniform_block_properties_ext, 0,
+           sizeof(VkPhysicalDeviceInlineUniformBlockPropertiesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceInlineUniformBlockFeaturesEXT
+      inline_uniform_block_features_ext;
+  VkPhysicalDeviceInlineUniformBlockPropertiesEXT
+      inline_uniform_block_properties_ext;
+};
+
+struct VkJsonExtLegacyDithering {
+  VkJsonExtLegacyDithering() {
+    reported = false;
+    memset(&legacy_dithering_features_ext, 0,
+           sizeof(VkPhysicalDeviceLegacyDitheringFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceLegacyDitheringFeaturesEXT legacy_dithering_features_ext;
+};
+
+struct VkJsonExtLegacyVertexAttributes {
+  VkJsonExtLegacyVertexAttributes() {
+    reported = false;
+    memset(&legacy_vertex_attributes_features_ext, 0,
+           sizeof(VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT));
+    memset(&legacy_vertex_attributes_properties_ext, 0,
+           sizeof(VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT
+      legacy_vertex_attributes_features_ext;
+  VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT
+      legacy_vertex_attributes_properties_ext;
+};
+
+struct VkJsonExtLineRasterization {
+  VkJsonExtLineRasterization() {
+    reported = false;
+    memset(&line_rasterization_features_ext, 0,
+           sizeof(VkPhysicalDeviceLineRasterizationFeaturesEXT));
+    memset(&line_rasterization_properties_ext, 0,
+           sizeof(VkPhysicalDeviceLineRasterizationPropertiesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceLineRasterizationFeaturesEXT line_rasterization_features_ext;
+  VkPhysicalDeviceLineRasterizationPropertiesEXT
+      line_rasterization_properties_ext;
+};
+
+struct VkJsonExtMapMemoryPlaced {
+  VkJsonExtMapMemoryPlaced() {
+    reported = false;
+    memset(&map_memory_placed_features_ext, 0,
+           sizeof(VkPhysicalDeviceMapMemoryPlacedFeaturesEXT));
+    memset(&map_memory_placed_properties_ext, 0,
+           sizeof(VkPhysicalDeviceMapMemoryPlacedPropertiesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceMapMemoryPlacedFeaturesEXT map_memory_placed_features_ext;
+  VkPhysicalDeviceMapMemoryPlacedPropertiesEXT map_memory_placed_properties_ext;
+};
+
+struct VkJsonExtMemoryPriority {
+  VkJsonExtMemoryPriority() {
+    reported = false;
+    memset(&memory_priority_features_ext, 0,
+           sizeof(VkPhysicalDeviceMemoryPriorityFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceMemoryPriorityFeaturesEXT memory_priority_features_ext;
+};
+
+struct VkJsonExtMeshShader {
+  VkJsonExtMeshShader() {
+    reported = false;
+    memset(&mesh_shader_features_ext, 0,
+           sizeof(VkPhysicalDeviceMeshShaderFeaturesEXT));
+    memset(&mesh_shader_properties_ext, 0,
+           sizeof(VkPhysicalDeviceMeshShaderPropertiesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceMeshShaderFeaturesEXT mesh_shader_features_ext;
+  VkPhysicalDeviceMeshShaderPropertiesEXT mesh_shader_properties_ext;
+};
+
+struct VkJsonExtMultiDraw {
+  VkJsonExtMultiDraw() {
+    reported = false;
+    memset(&multi_draw_features_ext, 0,
+           sizeof(VkPhysicalDeviceMultiDrawFeaturesEXT));
+    memset(&multi_draw_properties_ext, 0,
+           sizeof(VkPhysicalDeviceMultiDrawPropertiesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceMultiDrawFeaturesEXT multi_draw_features_ext;
+  VkPhysicalDeviceMultiDrawPropertiesEXT multi_draw_properties_ext;
+};
+
+struct VkJsonExtMultisampledRenderToSingleSampled {
+  VkJsonExtMultisampledRenderToSingleSampled() {
+    reported = false;
+    memset(
+        &multisampled_render_to_single_sampled_features_ext, 0,
+        sizeof(VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT
+      multisampled_render_to_single_sampled_features_ext;
+};
+
+struct VkJsonExtMutableDescriptorType {
+  VkJsonExtMutableDescriptorType() {
+    reported = false;
+    memset(&mutable_descriptor_type_features_ext, 0,
+           sizeof(VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT
+      mutable_descriptor_type_features_ext;
+};
+
+struct VkJsonExtNestedCommandBuffer {
+  VkJsonExtNestedCommandBuffer() {
+    reported = false;
+    memset(&nested_command_buffer_features_ext, 0,
+           sizeof(VkPhysicalDeviceNestedCommandBufferFeaturesEXT));
+    memset(&nested_command_buffer_properties_ext, 0,
+           sizeof(VkPhysicalDeviceNestedCommandBufferPropertiesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceNestedCommandBufferFeaturesEXT
+      nested_command_buffer_features_ext;
+  VkPhysicalDeviceNestedCommandBufferPropertiesEXT
+      nested_command_buffer_properties_ext;
+};
+
+struct VkJsonExtNonSeamlessCubeMap {
+  VkJsonExtNonSeamlessCubeMap() {
+    reported = false;
+    memset(&non_seamless_cube_map_features_ext, 0,
+           sizeof(VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT
+      non_seamless_cube_map_features_ext;
+};
+
+struct VkJsonExtOpacityMicromap {
+  VkJsonExtOpacityMicromap() {
+    reported = false;
+    memset(&opacity_micromap_features_ext, 0,
+           sizeof(VkPhysicalDeviceOpacityMicromapFeaturesEXT));
+    memset(&opacity_micromap_properties_ext, 0,
+           sizeof(VkPhysicalDeviceOpacityMicromapPropertiesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceOpacityMicromapFeaturesEXT opacity_micromap_features_ext;
+  VkPhysicalDeviceOpacityMicromapPropertiesEXT opacity_micromap_properties_ext;
+};
+
+struct VkJsonExtPageableDeviceLocalMemory {
+  VkJsonExtPageableDeviceLocalMemory() {
+    reported = false;
+    memset(&pageable_device_local_memory_features_ext, 0,
+           sizeof(VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT
+      pageable_device_local_memory_features_ext;
+};
+
+struct VkJsonExtPciBusInfo {
+  VkJsonExtPciBusInfo() {
+    reported = false;
+    memset(&pci_bus_info_properties_ext, 0,
+           sizeof(VkPhysicalDevicePCIBusInfoPropertiesEXT));
+  }
+  bool reported;
+  VkPhysicalDevicePCIBusInfoPropertiesEXT pci_bus_info_properties_ext;
+};
+
+struct VkJsonExtPhysicalDeviceDrm {
+  VkJsonExtPhysicalDeviceDrm() {
+    reported = false;
+    memset(&drm_properties_ext, 0, sizeof(VkPhysicalDeviceDrmPropertiesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceDrmPropertiesEXT drm_properties_ext;
+};
+
+struct VkJsonExtPipelineCreationCacheControl {
+  VkJsonExtPipelineCreationCacheControl() {
+    reported = false;
+    memset(&pipeline_creation_cache_control_features_ext, 0,
+           sizeof(VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT
+      pipeline_creation_cache_control_features_ext;
+};
+
+struct VkJsonExtPipelineLibraryGroupHandles {
+  VkJsonExtPipelineLibraryGroupHandles() {
+    reported = false;
+    memset(&pipeline_library_group_handles_features_ext, 0,
+           sizeof(VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT
+      pipeline_library_group_handles_features_ext;
+};
+
+struct VkJsonExtPipelineProperties {
+  VkJsonExtPipelineProperties() {
+    reported = false;
+    memset(&pipeline_properties_features_ext, 0,
+           sizeof(VkPhysicalDevicePipelinePropertiesFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDevicePipelinePropertiesFeaturesEXT
+      pipeline_properties_features_ext;
+};
+
+struct VkJsonExtPipelineProtectedAccess {
+  VkJsonExtPipelineProtectedAccess() {
+    reported = false;
+    memset(&pipeline_protected_access_features_ext, 0,
+           sizeof(VkPhysicalDevicePipelineProtectedAccessFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDevicePipelineProtectedAccessFeaturesEXT
+      pipeline_protected_access_features_ext;
+};
+
+struct VkJsonExtPipelineRobustness {
+  VkJsonExtPipelineRobustness() {
+    reported = false;
+    memset(&pipeline_robustness_features_ext, 0,
+           sizeof(VkPhysicalDevicePipelineRobustnessFeaturesEXT));
+    memset(&pipeline_robustness_properties_ext, 0,
+           sizeof(VkPhysicalDevicePipelineRobustnessPropertiesEXT));
+  }
+  bool reported;
+  VkPhysicalDevicePipelineRobustnessFeaturesEXT
+      pipeline_robustness_features_ext;
+  VkPhysicalDevicePipelineRobustnessPropertiesEXT
+      pipeline_robustness_properties_ext;
+};
+
+struct VkJsonExtPrimitiveTopologyListRestart {
+  VkJsonExtPrimitiveTopologyListRestart() {
+    reported = false;
+    memset(&primitive_topology_list_restart_features_ext, 0,
+           sizeof(VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT
+      primitive_topology_list_restart_features_ext;
+};
+
+struct VkJsonExtPrimitivesGeneratedQuery {
+  VkJsonExtPrimitivesGeneratedQuery() {
+    reported = false;
+    memset(&primitives_generated_query_features_ext, 0,
+           sizeof(VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT
+      primitives_generated_query_features_ext;
+};
+
+struct VkJsonExtPrivateData {
+  VkJsonExtPrivateData() {
+    reported = false;
+    memset(&private_data_features_ext, 0,
+           sizeof(VkPhysicalDevicePrivateDataFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDevicePrivateDataFeaturesEXT private_data_features_ext;
+};
+
+struct VkJsonExtProvokingVertex {
+  VkJsonExtProvokingVertex() {
+    reported = false;
+    memset(&provoking_vertex_features_ext, 0,
+           sizeof(VkPhysicalDeviceProvokingVertexFeaturesEXT));
+    memset(&provoking_vertex_properties_ext, 0,
+           sizeof(VkPhysicalDeviceProvokingVertexPropertiesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceProvokingVertexFeaturesEXT provoking_vertex_features_ext;
+  VkPhysicalDeviceProvokingVertexPropertiesEXT provoking_vertex_properties_ext;
+};
+
+struct VkJsonExtRasterizationOrderAttachmentAccess {
+  VkJsonExtRasterizationOrderAttachmentAccess() {
+    reported = false;
+    memset(
+        &rasterization_order_attachment_access_features_ext, 0,
+        sizeof(VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT
+      rasterization_order_attachment_access_features_ext;
+};
+
+struct VkJsonExtRgba10x6Formats {
+  VkJsonExtRgba10x6Formats() {
+    reported = false;
+    memset(&rgba10_x6_formats_features_ext, 0,
+           sizeof(VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT rgba10_x6_formats_features_ext;
+};
+
+struct VkJsonExtRobustness2 {
+  VkJsonExtRobustness2() {
+    reported = false;
+    memset(&robustness2_features_ext, 0,
+           sizeof(VkPhysicalDeviceRobustness2FeaturesEXT));
+    memset(&robustness2_properties_ext, 0,
+           sizeof(VkPhysicalDeviceRobustness2PropertiesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceRobustness2FeaturesEXT robustness2_features_ext;
+  VkPhysicalDeviceRobustness2PropertiesEXT robustness2_properties_ext;
+};
+
+struct VkJsonExtSampleLocations {
+  VkJsonExtSampleLocations() {
+    reported = false;
+    memset(&sample_locations_properties_ext, 0,
+           sizeof(VkPhysicalDeviceSampleLocationsPropertiesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceSampleLocationsPropertiesEXT sample_locations_properties_ext;
+};
+
+struct VkJsonExtSamplerFilterMinmax {
+  VkJsonExtSamplerFilterMinmax() {
+    reported = false;
+    memset(&sampler_filter_minmax_properties_ext, 0,
+           sizeof(VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT
+      sampler_filter_minmax_properties_ext;
+};
+
+struct VkJsonExtScalarBlockLayout {
+  VkJsonExtScalarBlockLayout() {
+    reported = false;
+    memset(&scalar_block_layout_features_ext, 0,
+           sizeof(VkPhysicalDeviceScalarBlockLayoutFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceScalarBlockLayoutFeaturesEXT scalar_block_layout_features_ext;
+};
+
+struct VkJsonExtShaderAtomicFloat {
+  VkJsonExtShaderAtomicFloat() {
+    reported = false;
+    memset(&shader_atomic_float_features_ext, 0,
+           sizeof(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceShaderAtomicFloatFeaturesEXT shader_atomic_float_features_ext;
+};
+
+struct VkJsonExtShaderAtomicFloat2 {
+  VkJsonExtShaderAtomicFloat2() {
+    reported = false;
+    memset(&shader_atomic_float2_features_ext, 0,
+           sizeof(VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT
+      shader_atomic_float2_features_ext;
+};
+
+struct VkJsonExtShaderDemoteToHelperInvocation {
+  VkJsonExtShaderDemoteToHelperInvocation() {
+    reported = false;
+    memset(&shader_demote_to_helper_invocation_features_ext, 0,
+           sizeof(VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT
+      shader_demote_to_helper_invocation_features_ext;
+};
+
+struct VkJsonExtShaderImageAtomicInt64 {
+  VkJsonExtShaderImageAtomicInt64() {
+    reported = false;
+    memset(&shader_image_atomic_int64_features_ext, 0,
+           sizeof(VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT
+      shader_image_atomic_int64_features_ext;
+};
+
+struct VkJsonExtShaderModuleIdentifier {
+  VkJsonExtShaderModuleIdentifier() {
+    reported = false;
+    memset(&shader_module_identifier_features_ext, 0,
+           sizeof(VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT));
+    memset(&shader_module_identifier_properties_ext, 0,
+           sizeof(VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT
+      shader_module_identifier_features_ext;
+  VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT
+      shader_module_identifier_properties_ext;
+};
+
+struct VkJsonExtShaderObject {
+  VkJsonExtShaderObject() {
+    reported = false;
+    memset(&shader_object_features_ext, 0,
+           sizeof(VkPhysicalDeviceShaderObjectFeaturesEXT));
+    memset(&shader_object_properties_ext, 0,
+           sizeof(VkPhysicalDeviceShaderObjectPropertiesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceShaderObjectFeaturesEXT shader_object_features_ext;
+  VkPhysicalDeviceShaderObjectPropertiesEXT shader_object_properties_ext;
+};
+
+struct VkJsonExtShaderReplicatedComposites {
+  VkJsonExtShaderReplicatedComposites() {
+    reported = false;
+    memset(&shader_replicated_composites_features_ext, 0,
+           sizeof(VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT
+      shader_replicated_composites_features_ext;
+};
+
+struct VkJsonExtShaderTileImage {
+  VkJsonExtShaderTileImage() {
+    reported = false;
+    memset(&shader_tile_image_features_ext, 0,
+           sizeof(VkPhysicalDeviceShaderTileImageFeaturesEXT));
+    memset(&shader_tile_image_properties_ext, 0,
+           sizeof(VkPhysicalDeviceShaderTileImagePropertiesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceShaderTileImageFeaturesEXT shader_tile_image_features_ext;
+  VkPhysicalDeviceShaderTileImagePropertiesEXT shader_tile_image_properties_ext;
+};
+
+struct VkJsonExtSubgroupSizeControl {
+  VkJsonExtSubgroupSizeControl() {
+    reported = false;
+    memset(&subgroup_size_control_features_ext, 0,
+           sizeof(VkPhysicalDeviceSubgroupSizeControlFeaturesEXT));
+    memset(&subgroup_size_control_properties_ext, 0,
+           sizeof(VkPhysicalDeviceSubgroupSizeControlPropertiesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceSubgroupSizeControlFeaturesEXT
+      subgroup_size_control_features_ext;
+  VkPhysicalDeviceSubgroupSizeControlPropertiesEXT
+      subgroup_size_control_properties_ext;
+};
+
+struct VkJsonExtSubpassMergeFeedback {
+  VkJsonExtSubpassMergeFeedback() {
+    reported = false;
+    memset(&subpass_merge_feedback_features_ext, 0,
+           sizeof(VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT
+      subpass_merge_feedback_features_ext;
+};
+
+struct VkJsonExtSwapchainMaintenance1 {
+  VkJsonExtSwapchainMaintenance1() {
+    reported = false;
+    memset(&swapchain_maintenance1_features_ext, 0,
+           sizeof(VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT
+      swapchain_maintenance1_features_ext;
+};
+
+struct VkJsonExtTexelBufferAlignment {
+  VkJsonExtTexelBufferAlignment() {
+    reported = false;
+    memset(&texel_buffer_alignment_features_ext, 0,
+           sizeof(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT));
+    memset(&texel_buffer_alignment_properties_ext, 0,
+           sizeof(VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT
+      texel_buffer_alignment_features_ext;
+  VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT
+      texel_buffer_alignment_properties_ext;
+};
+
+struct VkJsonExtTextureCompressionAstcHdr {
+  VkJsonExtTextureCompressionAstcHdr() {
+    reported = false;
+    memset(&texture_compression_astchdr_features_ext, 0,
+           sizeof(VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT
+      texture_compression_astchdr_features_ext;
+};
+
+struct VkJsonExtTransformFeedback {
+  VkJsonExtTransformFeedback() {
+    reported = false;
+    memset(&transform_feedback_features_ext, 0,
+           sizeof(VkPhysicalDeviceTransformFeedbackFeaturesEXT));
+    memset(&transform_feedback_properties_ext, 0,
+           sizeof(VkPhysicalDeviceTransformFeedbackPropertiesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceTransformFeedbackFeaturesEXT transform_feedback_features_ext;
+  VkPhysicalDeviceTransformFeedbackPropertiesEXT
+      transform_feedback_properties_ext;
+};
+
+struct VkJsonExtVertexAttributeDivisor {
+  VkJsonExtVertexAttributeDivisor() {
+    reported = false;
+    memset(&vertex_attribute_divisor_properties_ext, 0,
+           sizeof(VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT));
+    memset(&vertex_attribute_divisor_features_ext, 0,
+           sizeof(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT
+      vertex_attribute_divisor_properties_ext;
+  VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT
+      vertex_attribute_divisor_features_ext;
+};
+
+struct VkJsonExtVertexInputDynamicState {
+  VkJsonExtVertexInputDynamicState() {
+    reported = false;
+    memset(&vertex_input_dynamic_state_features_ext, 0,
+           sizeof(VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT
+      vertex_input_dynamic_state_features_ext;
+};
+
+struct VkJsonExtYcbcr2plane444Formats {
+  VkJsonExtYcbcr2plane444Formats() {
+    reported = false;
+    memset(&ycbcr_2plane_444_formats_features_ext, 0,
+           sizeof(VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT
+      ycbcr_2plane_444_formats_features_ext;
+};
+
+struct VkJsonExtYcbcrImageArrays {
+  VkJsonExtYcbcrImageArrays() {
+    reported = false;
+    memset(&ycbcr_image_arrays_features_ext, 0,
+           sizeof(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT));
+  }
+  bool reported;
+  VkPhysicalDeviceYcbcrImageArraysFeaturesEXT ycbcr_image_arrays_features_ext;
+};
+
+struct VkJsonHUAWEIClusterCullingShader {
+  VkJsonHUAWEIClusterCullingShader() {
+    reported = false;
+    memset(&cluster_culling_shader_features_huawei, 0,
+           sizeof(VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI));
+    memset(&cluster_culling_shader_properties_huawei, 0,
+           sizeof(VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI));
+  }
+  bool reported;
+  VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI
+      cluster_culling_shader_features_huawei;
+  VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI
+      cluster_culling_shader_properties_huawei;
+};
+
+struct VkJsonHUAWEIInvocationMask {
+  VkJsonHUAWEIInvocationMask() {
+    reported = false;
+    memset(&invocation_mask_features_huawei, 0,
+           sizeof(VkPhysicalDeviceInvocationMaskFeaturesHUAWEI));
+  }
+  bool reported;
+  VkPhysicalDeviceInvocationMaskFeaturesHUAWEI invocation_mask_features_huawei;
+};
+
+struct VkJsonHUAWEISubpassShading {
+  VkJsonHUAWEISubpassShading() {
+    reported = false;
+    memset(&subpass_shading_features_huawei, 0,
+           sizeof(VkPhysicalDeviceSubpassShadingFeaturesHUAWEI));
+    memset(&subpass_shading_properties_huawei, 0,
+           sizeof(VkPhysicalDeviceSubpassShadingPropertiesHUAWEI));
+  }
+  bool reported;
+  VkPhysicalDeviceSubpassShadingFeaturesHUAWEI subpass_shading_features_huawei;
+  VkPhysicalDeviceSubpassShadingPropertiesHUAWEI
+      subpass_shading_properties_huawei;
+};
+
+struct VkJsonIMGRelaxedLineRasterization {
+  VkJsonIMGRelaxedLineRasterization() {
+    reported = false;
+    memset(&relaxed_line_rasterization_features_img, 0,
+           sizeof(VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG));
+  }
+  bool reported;
+  VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG
+      relaxed_line_rasterization_features_img;
+};
+
+struct VkJsonExtVKINTELShaderIntegerFunctions2 {
+  VkJsonExtVKINTELShaderIntegerFunctions2() {
+    reported = false;
+    memset(&shader_integer_functions2_features_intel, 0,
+           sizeof(VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL));
+  }
+  bool reported;
+  VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL
+      shader_integer_functions2_features_intel;
+};
+
+struct VkJsonKHR16bitStorage {
+  VkJsonKHR16bitStorage() {
+    reported = false;
+    memset(&bit16_storage_features_khr, 0,
+           sizeof(VkPhysicalDevice16BitStorageFeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDevice16BitStorageFeaturesKHR bit16_storage_features_khr;
+};
+
+struct VkJsonKHR8bitStorage {
+  VkJsonKHR8bitStorage() {
+    reported = false;
+    memset(&bit8_storage_features_khr, 0,
+           sizeof(VkPhysicalDevice8BitStorageFeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDevice8BitStorageFeaturesKHR bit8_storage_features_khr;
+};
+
+struct VkJsonKHRAccelerationStructure {
+  VkJsonKHRAccelerationStructure() {
+    reported = false;
+    memset(&acceleration_structure_features_khr, 0,
+           sizeof(VkPhysicalDeviceAccelerationStructureFeaturesKHR));
+    memset(&acceleration_structure_properties_khr, 0,
+           sizeof(VkPhysicalDeviceAccelerationStructurePropertiesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceAccelerationStructureFeaturesKHR
+      acceleration_structure_features_khr;
+  VkPhysicalDeviceAccelerationStructurePropertiesKHR
+      acceleration_structure_properties_khr;
+};
+
+struct VkJsonKHRBufferDeviceAddress {
+  VkJsonKHRBufferDeviceAddress() {
+    reported = false;
+    memset(&buffer_device_address_features_khr, 0,
+           sizeof(VkPhysicalDeviceBufferDeviceAddressFeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceBufferDeviceAddressFeaturesKHR
+      buffer_device_address_features_khr;
+};
+
+struct VkJsonKHRCooperativeMatrix {
+  VkJsonKHRCooperativeMatrix() {
+    reported = false;
+    memset(&cooperative_matrix_features_khr, 0,
+           sizeof(VkPhysicalDeviceCooperativeMatrixFeaturesKHR));
+    memset(&cooperative_matrix_properties_khr, 0,
+           sizeof(VkPhysicalDeviceCooperativeMatrixPropertiesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceCooperativeMatrixFeaturesKHR cooperative_matrix_features_khr;
+  VkPhysicalDeviceCooperativeMatrixPropertiesKHR
+      cooperative_matrix_properties_khr;
+};
+
+struct VkJsonKHRDepthStencilResolve {
+  VkJsonKHRDepthStencilResolve() {
+    reported = false;
+    memset(&depth_stencil_resolve_properties_khr, 0,
+           sizeof(VkPhysicalDeviceDepthStencilResolvePropertiesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceDepthStencilResolvePropertiesKHR
+      depth_stencil_resolve_properties_khr;
+};
+
+struct VkJsonKHRDriverProperties {
+  VkJsonKHRDriverProperties() {
+    reported = false;
+    memset(&driver_properties_khr, 0,
+           sizeof(VkPhysicalDeviceDriverPropertiesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceDriverPropertiesKHR driver_properties_khr;
+};
+
+struct VkJsonKHRDynamicRendering {
+  VkJsonKHRDynamicRendering() {
+    reported = false;
+    memset(&dynamic_rendering_features_khr, 0,
+           sizeof(VkPhysicalDeviceDynamicRenderingFeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceDynamicRenderingFeaturesKHR dynamic_rendering_features_khr;
+};
+
+struct VkJsonKHRDynamicRenderingLocalRead {
+  VkJsonKHRDynamicRenderingLocalRead() {
+    reported = false;
+    memset(&dynamic_rendering_local_read_features_khr, 0,
+           sizeof(VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR
+      dynamic_rendering_local_read_features_khr;
+};
+
+struct VkJsonKHRExternalMemoryCapabilities {
+  VkJsonKHRExternalMemoryCapabilities() {
+    reported = false;
+    memset(&id_properties_khr, 0, sizeof(VkPhysicalDeviceIDPropertiesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceIDPropertiesKHR id_properties_khr;
+};
+
+struct VkJsonKHRFragmentShaderBarycentric {
+  VkJsonKHRFragmentShaderBarycentric() {
+    reported = false;
+    memset(&fragment_shader_barycentric_features_khr, 0,
+           sizeof(VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR));
+    memset(&fragment_shader_barycentric_properties_khr, 0,
+           sizeof(VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR
+      fragment_shader_barycentric_features_khr;
+  VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR
+      fragment_shader_barycentric_properties_khr;
+};
+
+struct VkJsonKHRFragmentShadingRate {
+  VkJsonKHRFragmentShadingRate() {
+    reported = false;
+    memset(&fragment_shading_rate_features_khr, 0,
+           sizeof(VkPhysicalDeviceFragmentShadingRateFeaturesKHR));
+    memset(&fragment_shading_rate_properties_khr, 0,
+           sizeof(VkPhysicalDeviceFragmentShadingRatePropertiesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceFragmentShadingRateFeaturesKHR
+      fragment_shading_rate_features_khr;
+  VkPhysicalDeviceFragmentShadingRatePropertiesKHR
+      fragment_shading_rate_properties_khr;
+};
+
+struct VkJsonKHRGlobalPriority {
+  VkJsonKHRGlobalPriority() {
+    reported = false;
+    memset(&global_priority_query_features_khr, 0,
+           sizeof(VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR
+      global_priority_query_features_khr;
+};
+
+struct VkJsonKHRImagelessFramebuffer {
+  VkJsonKHRImagelessFramebuffer() {
+    reported = false;
+    memset(&imageless_framebuffer_features_khr, 0,
+           sizeof(VkPhysicalDeviceImagelessFramebufferFeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceImagelessFramebufferFeaturesKHR
+      imageless_framebuffer_features_khr;
+};
+
+struct VkJsonKHRIndexTypeUint8 {
+  VkJsonKHRIndexTypeUint8() {
+    reported = false;
+    memset(&index_type_uint8_features_khr, 0,
+           sizeof(VkPhysicalDeviceIndexTypeUint8FeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceIndexTypeUint8FeaturesKHR index_type_uint8_features_khr;
+};
+
+struct VkJsonKHRLineRasterization {
+  VkJsonKHRLineRasterization() {
+    reported = false;
+    memset(&line_rasterization_features_khr, 0,
+           sizeof(VkPhysicalDeviceLineRasterizationFeaturesKHR));
+    memset(&line_rasterization_properties_khr, 0,
+           sizeof(VkPhysicalDeviceLineRasterizationPropertiesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceLineRasterizationFeaturesKHR line_rasterization_features_khr;
+  VkPhysicalDeviceLineRasterizationPropertiesKHR
+      line_rasterization_properties_khr;
+};
+
+struct VkJsonKHRMaintenance2 {
+  VkJsonKHRMaintenance2() {
+    reported = false;
+    memset(&point_clipping_properties_khr, 0,
+           sizeof(VkPhysicalDevicePointClippingPropertiesKHR));
+  }
+  bool reported;
+  VkPhysicalDevicePointClippingPropertiesKHR point_clipping_properties_khr;
+};
+
+struct VkJsonKHRMaintenance3 {
+  VkJsonKHRMaintenance3() {
+    reported = false;
+    memset(&maintenance3_properties_khr, 0,
+           sizeof(VkPhysicalDeviceMaintenance3PropertiesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceMaintenance3PropertiesKHR maintenance3_properties_khr;
+};
+
+struct VkJsonKHRMaintenance4 {
+  VkJsonKHRMaintenance4() {
+    reported = false;
+    memset(&maintenance4_features_khr, 0,
+           sizeof(VkPhysicalDeviceMaintenance4FeaturesKHR));
+    memset(&maintenance4_properties_khr, 0,
+           sizeof(VkPhysicalDeviceMaintenance4PropertiesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceMaintenance4FeaturesKHR maintenance4_features_khr;
+  VkPhysicalDeviceMaintenance4PropertiesKHR maintenance4_properties_khr;
+};
+
+struct VkJsonKHRMaintenance5 {
+  VkJsonKHRMaintenance5() {
+    reported = false;
+    memset(&maintenance5_features_khr, 0,
+           sizeof(VkPhysicalDeviceMaintenance5FeaturesKHR));
+    memset(&maintenance5_properties_khr, 0,
+           sizeof(VkPhysicalDeviceMaintenance5PropertiesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceMaintenance5FeaturesKHR maintenance5_features_khr;
+  VkPhysicalDeviceMaintenance5PropertiesKHR maintenance5_properties_khr;
+};
+
+struct VkJsonKHRMaintenance6 {
+  VkJsonKHRMaintenance6() {
+    reported = false;
+    memset(&maintenance6_features_khr, 0,
+           sizeof(VkPhysicalDeviceMaintenance6FeaturesKHR));
+    memset(&maintenance6_properties_khr, 0,
+           sizeof(VkPhysicalDeviceMaintenance6PropertiesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceMaintenance6FeaturesKHR maintenance6_features_khr;
+  VkPhysicalDeviceMaintenance6PropertiesKHR maintenance6_properties_khr;
+};
+
+struct VkJsonKHRMaintenance7 {
+  VkJsonKHRMaintenance7() {
+    reported = false;
+    memset(&maintenance7_features_khr, 0,
+           sizeof(VkPhysicalDeviceMaintenance7FeaturesKHR));
+    memset(&maintenance7_properties_khr, 0,
+           sizeof(VkPhysicalDeviceMaintenance7PropertiesKHR));
+    memset(&layered_api_properties_list_khr, 0,
+           sizeof(VkPhysicalDeviceLayeredApiPropertiesListKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceMaintenance7FeaturesKHR maintenance7_features_khr;
+  VkPhysicalDeviceMaintenance7PropertiesKHR maintenance7_properties_khr;
+  VkPhysicalDeviceLayeredApiPropertiesListKHR layered_api_properties_list_khr;
+};
+
+struct VkJsonKHRMultiview {
+  VkJsonKHRMultiview() {
+    reported = false;
+    memset(&multiview_features_khr, 0,
+           sizeof(VkPhysicalDeviceMultiviewFeaturesKHR));
+    memset(&multiview_properties_khr, 0,
+           sizeof(VkPhysicalDeviceMultiviewPropertiesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceMultiviewFeaturesKHR multiview_features_khr;
+  VkPhysicalDeviceMultiviewPropertiesKHR multiview_properties_khr;
+};
+
+struct VkJsonKHRPerformanceQuery {
+  VkJsonKHRPerformanceQuery() {
+    reported = false;
+    memset(&performance_query_features_khr, 0,
+           sizeof(VkPhysicalDevicePerformanceQueryFeaturesKHR));
+    memset(&performance_query_properties_khr, 0,
+           sizeof(VkPhysicalDevicePerformanceQueryPropertiesKHR));
+  }
+  bool reported;
+  VkPhysicalDevicePerformanceQueryFeaturesKHR performance_query_features_khr;
+  VkPhysicalDevicePerformanceQueryPropertiesKHR
+      performance_query_properties_khr;
+};
+
+struct VkJsonKHRPipelineBinary {
+  VkJsonKHRPipelineBinary() {
+    reported = false;
+    memset(&pipeline_binary_features_khr, 0,
+           sizeof(VkPhysicalDevicePipelineBinaryFeaturesKHR));
+    memset(&pipeline_binary_properties_khr, 0,
+           sizeof(VkPhysicalDevicePipelineBinaryPropertiesKHR));
+  }
+  bool reported;
+  VkPhysicalDevicePipelineBinaryFeaturesKHR pipeline_binary_features_khr;
+  VkPhysicalDevicePipelineBinaryPropertiesKHR pipeline_binary_properties_khr;
+};
+
+struct VkJsonKHRPipelineExecutableProperties {
+  VkJsonKHRPipelineExecutableProperties() {
+    reported = false;
+    memset(&pipeline_executable_properties_features_khr, 0,
+           sizeof(VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR
+      pipeline_executable_properties_features_khr;
+};
+
+struct VkJsonKHRPresentId {
+  VkJsonKHRPresentId() {
+    reported = false;
+    memset(&present_id_features_khr, 0,
+           sizeof(VkPhysicalDevicePresentIdFeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDevicePresentIdFeaturesKHR present_id_features_khr;
+};
+
+struct VkJsonKHRPresentWait {
+  VkJsonKHRPresentWait() {
+    reported = false;
+    memset(&present_wait_features_khr, 0,
+           sizeof(VkPhysicalDevicePresentWaitFeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDevicePresentWaitFeaturesKHR present_wait_features_khr;
+};
+
+struct VkJsonKHRPushDescriptor {
+  VkJsonKHRPushDescriptor() {
+    reported = false;
+    memset(&push_descriptor_properties_khr, 0,
+           sizeof(VkPhysicalDevicePushDescriptorPropertiesKHR));
+  }
+  bool reported;
+  VkPhysicalDevicePushDescriptorPropertiesKHR push_descriptor_properties_khr;
+};
+
+struct VkJsonKHRRayQuery {
+  VkJsonKHRRayQuery() {
+    reported = false;
+    memset(&ray_query_features_khr, 0,
+           sizeof(VkPhysicalDeviceRayQueryFeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceRayQueryFeaturesKHR ray_query_features_khr;
+};
+
+struct VkJsonKHRRayTracingMaintenance1 {
+  VkJsonKHRRayTracingMaintenance1() {
+    reported = false;
+    memset(&ray_tracing_maintenance1_features_khr, 0,
+           sizeof(VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR
+      ray_tracing_maintenance1_features_khr;
+};
+
+struct VkJsonKHRRayTracingPipeline {
+  VkJsonKHRRayTracingPipeline() {
+    reported = false;
+    memset(&ray_tracing_pipeline_features_khr, 0,
+           sizeof(VkPhysicalDeviceRayTracingPipelineFeaturesKHR));
+    memset(&ray_tracing_pipeline_properties_khr, 0,
+           sizeof(VkPhysicalDeviceRayTracingPipelinePropertiesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceRayTracingPipelineFeaturesKHR
+      ray_tracing_pipeline_features_khr;
+  VkPhysicalDeviceRayTracingPipelinePropertiesKHR
+      ray_tracing_pipeline_properties_khr;
+};
+
+struct VkJsonKHRRayTracingPositionFetch {
+  VkJsonKHRRayTracingPositionFetch() {
+    reported = false;
+    memset(&ray_tracing_position_fetch_features_khr, 0,
+           sizeof(VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR
+      ray_tracing_position_fetch_features_khr;
+};
+
+struct VkJsonKHRSamplerYcbcrConversion {
+  VkJsonKHRSamplerYcbcrConversion() {
+    reported = false;
+    memset(&sampler_ycbcr_conversion_features_khr, 0,
+           sizeof(VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR
+      sampler_ycbcr_conversion_features_khr;
+};
+
+struct VkJsonKHRSeparateDepthStencilLayouts {
+  VkJsonKHRSeparateDepthStencilLayouts() {
+    reported = false;
+    memset(&separate_depth_stencil_layouts_features_khr, 0,
+           sizeof(VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR
+      separate_depth_stencil_layouts_features_khr;
+};
+
+struct VkJsonKHRShaderAtomicInt64 {
+  VkJsonKHRShaderAtomicInt64() {
+    reported = false;
+    memset(&shader_atomic_int64_features_khr, 0,
+           sizeof(VkPhysicalDeviceShaderAtomicInt64FeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceShaderAtomicInt64FeaturesKHR shader_atomic_int64_features_khr;
+};
+
+struct VkJsonKHRShaderClock {
+  VkJsonKHRShaderClock() {
+    reported = false;
+    memset(&shader_clock_features_khr, 0,
+           sizeof(VkPhysicalDeviceShaderClockFeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceShaderClockFeaturesKHR shader_clock_features_khr;
+};
+
+struct VkJsonKHRShaderExpectAssume {
+  VkJsonKHRShaderExpectAssume() {
+    reported = false;
+    memset(&shader_expect_assume_features_khr, 0,
+           sizeof(VkPhysicalDeviceShaderExpectAssumeFeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceShaderExpectAssumeFeaturesKHR
+      shader_expect_assume_features_khr;
+};
+
+struct VkJsonKHRShaderFloat16Int8 {
+  VkJsonKHRShaderFloat16Int8() {
+    reported = false;
+    memset(&shader_float16_int8_features_khr, 0,
+           sizeof(VkPhysicalDeviceShaderFloat16Int8FeaturesKHR));
+    memset(&float16_int8_features_khr, 0,
+           sizeof(VkPhysicalDeviceFloat16Int8FeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceShaderFloat16Int8FeaturesKHR shader_float16_int8_features_khr;
+  VkPhysicalDeviceFloat16Int8FeaturesKHR float16_int8_features_khr;
+};
+
+struct VkJsonKHRShaderFloatControls {
+  VkJsonKHRShaderFloatControls() {
+    reported = false;
+    memset(&float_controls_properties_khr, 0,
+           sizeof(VkPhysicalDeviceFloatControlsPropertiesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceFloatControlsPropertiesKHR float_controls_properties_khr;
+};
+
+struct VkJsonKHRShaderFloatControls2 {
+  VkJsonKHRShaderFloatControls2() {
+    reported = false;
+    memset(&shader_float_controls2_features_khr, 0,
+           sizeof(VkPhysicalDeviceShaderFloatControls2FeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceShaderFloatControls2FeaturesKHR
+      shader_float_controls2_features_khr;
+};
+
+struct VkJsonKHRShaderIntegerDotProduct {
+  VkJsonKHRShaderIntegerDotProduct() {
+    reported = false;
+    memset(&shader_integer_dot_product_features_khr, 0,
+           sizeof(VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR));
+    memset(&shader_integer_dot_product_properties_khr, 0,
+           sizeof(VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR
+      shader_integer_dot_product_features_khr;
+  VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR
+      shader_integer_dot_product_properties_khr;
+};
+
+struct VkJsonKHRShaderMaximalReconvergence {
+  VkJsonKHRShaderMaximalReconvergence() {
+    reported = false;
+    memset(&shader_maximal_reconvergence_features_khr, 0,
+           sizeof(VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR
+      shader_maximal_reconvergence_features_khr;
+};
+
+struct VkJsonKHRShaderQuadControl {
+  VkJsonKHRShaderQuadControl() {
+    reported = false;
+    memset(&shader_quad_control_features_khr, 0,
+           sizeof(VkPhysicalDeviceShaderQuadControlFeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceShaderQuadControlFeaturesKHR shader_quad_control_features_khr;
+};
+
+struct VkJsonKHRShaderRelaxedExtendedInstruction {
+  VkJsonKHRShaderRelaxedExtendedInstruction() {
+    reported = false;
+    memset(&shader_relaxed_extended_instruction_features_khr, 0,
+           sizeof(VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR
+      shader_relaxed_extended_instruction_features_khr;
+};
+
+struct VkJsonKHRShaderSubgroupExtendedTypes {
+  VkJsonKHRShaderSubgroupExtendedTypes() {
+    reported = false;
+    memset(&shader_subgroup_extended_types_features_khr, 0,
+           sizeof(VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR
+      shader_subgroup_extended_types_features_khr;
+};
+
+struct VkJsonKHRShaderSubgroupRotate {
+  VkJsonKHRShaderSubgroupRotate() {
+    reported = false;
+    memset(&shader_subgroup_rotate_features_khr, 0,
+           sizeof(VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR
+      shader_subgroup_rotate_features_khr;
+};
+
+struct VkJsonKHRShaderSubgroupUniformControlFlow {
+  VkJsonKHRShaderSubgroupUniformControlFlow() {
+    reported = false;
+    memset(&shader_subgroup_uniform_control_flow_features_khr, 0,
+           sizeof(VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR
+      shader_subgroup_uniform_control_flow_features_khr;
+};
+
+struct VkJsonKHRShaderTerminateInvocation {
+  VkJsonKHRShaderTerminateInvocation() {
+    reported = false;
+    memset(&shader_terminate_invocation_features_khr, 0,
+           sizeof(VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR
+      shader_terminate_invocation_features_khr;
+};
+
+struct VkJsonKHRSynchronization2 {
+  VkJsonKHRSynchronization2() {
+    reported = false;
+    memset(&synchronization2_features_khr, 0,
+           sizeof(VkPhysicalDeviceSynchronization2FeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceSynchronization2FeaturesKHR synchronization2_features_khr;
+};
+
+struct VkJsonKHRTimelineSemaphore {
+  VkJsonKHRTimelineSemaphore() {
+    reported = false;
+    memset(&timeline_semaphore_features_khr, 0,
+           sizeof(VkPhysicalDeviceTimelineSemaphoreFeaturesKHR));
+    memset(&timeline_semaphore_properties_khr, 0,
+           sizeof(VkPhysicalDeviceTimelineSemaphorePropertiesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceTimelineSemaphoreFeaturesKHR timeline_semaphore_features_khr;
+  VkPhysicalDeviceTimelineSemaphorePropertiesKHR
+      timeline_semaphore_properties_khr;
+};
+
+struct VkJsonKHRUniformBufferStandardLayout {
+  VkJsonKHRUniformBufferStandardLayout() {
+    reported = false;
+    memset(&uniform_buffer_standard_layout_features_khr, 0,
+           sizeof(VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR
+      uniform_buffer_standard_layout_features_khr;
+};
+
+struct VkJsonKHRVariablePointers {
+  VkJsonKHRVariablePointers() {
+    reported = false;
+    memset(&variable_pointer_features_khr, 0,
+           sizeof(VkPhysicalDeviceVariablePointerFeaturesKHR));
+    memset(&variable_pointers_features_khr, 0,
+           sizeof(VkPhysicalDeviceVariablePointersFeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceVariablePointerFeaturesKHR variable_pointer_features_khr;
+  VkPhysicalDeviceVariablePointersFeaturesKHR variable_pointers_features_khr;
+};
+
+struct VkJsonKHRVertexAttributeDivisor {
+  VkJsonKHRVertexAttributeDivisor() {
+    reported = false;
+    memset(&vertex_attribute_divisor_properties_khr, 0,
+           sizeof(VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR));
+    memset(&vertex_attribute_divisor_features_khr, 0,
+           sizeof(VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR
+      vertex_attribute_divisor_properties_khr;
+  VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR
+      vertex_attribute_divisor_features_khr;
+};
+
+struct VkJsonKHRVideoMaintenance1 {
+  VkJsonKHRVideoMaintenance1() {
+    reported = false;
+    memset(&video_maintenance1_features_khr, 0,
+           sizeof(VkPhysicalDeviceVideoMaintenance1FeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceVideoMaintenance1FeaturesKHR video_maintenance1_features_khr;
+};
+
+struct VkJsonKHRVulkanMemoryModel {
+  VkJsonKHRVulkanMemoryModel() {
+    reported = false;
+    memset(&vulkan_memory_model_features_khr, 0,
+           sizeof(VkPhysicalDeviceVulkanMemoryModelFeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceVulkanMemoryModelFeaturesKHR vulkan_memory_model_features_khr;
+};
+
+struct VkJsonKHRWorkgroupMemoryExplicitLayout {
+  VkJsonKHRWorkgroupMemoryExplicitLayout() {
+    reported = false;
+    memset(&workgroup_memory_explicit_layout_features_khr, 0,
+           sizeof(VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR
+      workgroup_memory_explicit_layout_features_khr;
+};
+
+struct VkJsonKHRZeroInitializeWorkgroupMemory {
+  VkJsonKHRZeroInitializeWorkgroupMemory() {
+    reported = false;
+    memset(&zero_initialize_workgroup_memory_features_khr, 0,
+           sizeof(VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR));
+  }
+  bool reported;
+  VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR
+      zero_initialize_workgroup_memory_features_khr;
+};
+
+struct VkJsonMESAImageAlignmentControl {
+  VkJsonMESAImageAlignmentControl() {
+    reported = false;
+    memset(&image_alignment_control_features_mesa, 0,
+           sizeof(VkPhysicalDeviceImageAlignmentControlFeaturesMESA));
+    memset(&image_alignment_control_properties_mesa, 0,
+           sizeof(VkPhysicalDeviceImageAlignmentControlPropertiesMESA));
+  }
+  bool reported;
+  VkPhysicalDeviceImageAlignmentControlFeaturesMESA
+      image_alignment_control_features_mesa;
+  VkPhysicalDeviceImageAlignmentControlPropertiesMESA
+      image_alignment_control_properties_mesa;
+};
+
+struct VkJsonMSFTLayeredDriver {
+  VkJsonMSFTLayeredDriver() {
+    reported = false;
+    memset(&layered_driver_properties_msft, 0,
+           sizeof(VkPhysicalDeviceLayeredDriverPropertiesMSFT));
+  }
+  bool reported;
+  VkPhysicalDeviceLayeredDriverPropertiesMSFT layered_driver_properties_msft;
+};
+
+struct VkJsonNVXMultiviewPerViewAttributes {
+  VkJsonNVXMultiviewPerViewAttributes() {
+    reported = false;
+    memset(&multiview_per_view_attributes_properties_nvx, 0,
+           sizeof(VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX));
+  }
+  bool reported;
+  VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX
+      multiview_per_view_attributes_properties_nvx;
+};
+
+struct VkJsonNVCommandBufferInheritance {
+  VkJsonNVCommandBufferInheritance() {
+    reported = false;
+    memset(&command_buffer_inheritance_features_nv, 0,
+           sizeof(VkPhysicalDeviceCommandBufferInheritanceFeaturesNV));
+  }
+  bool reported;
+  VkPhysicalDeviceCommandBufferInheritanceFeaturesNV
+      command_buffer_inheritance_features_nv;
+};
+
+struct VkJsonNVComputeShaderDerivatives {
+  VkJsonNVComputeShaderDerivatives() {
+    reported = false;
+    memset(&compute_shader_derivatives_features_nv, 0,
+           sizeof(VkPhysicalDeviceComputeShaderDerivativesFeaturesNV));
+  }
+  bool reported;
+  VkPhysicalDeviceComputeShaderDerivativesFeaturesNV
+      compute_shader_derivatives_features_nv;
+};
+
+struct VkJsonNVCooperativeMatrix {
+  VkJsonNVCooperativeMatrix() {
+    reported = false;
+    memset(&cooperative_matrix_features_nv, 0,
+           sizeof(VkPhysicalDeviceCooperativeMatrixFeaturesNV));
+    memset(&cooperative_matrix_properties_nv, 0,
+           sizeof(VkPhysicalDeviceCooperativeMatrixPropertiesNV));
+  }
+  bool reported;
+  VkPhysicalDeviceCooperativeMatrixFeaturesNV cooperative_matrix_features_nv;
+  VkPhysicalDeviceCooperativeMatrixPropertiesNV
+      cooperative_matrix_properties_nv;
+};
+
+struct VkJsonNVCopyMemoryIndirect {
+  VkJsonNVCopyMemoryIndirect() {
+    reported = false;
+    memset(&copy_memory_indirect_features_nv, 0,
+           sizeof(VkPhysicalDeviceCopyMemoryIndirectFeaturesNV));
+    memset(&copy_memory_indirect_properties_nv, 0,
+           sizeof(VkPhysicalDeviceCopyMemoryIndirectPropertiesNV));
+  }
+  bool reported;
+  VkPhysicalDeviceCopyMemoryIndirectFeaturesNV copy_memory_indirect_features_nv;
+  VkPhysicalDeviceCopyMemoryIndirectPropertiesNV
+      copy_memory_indirect_properties_nv;
+};
+
+struct VkJsonNVCornerSampledImage {
+  VkJsonNVCornerSampledImage() {
+    reported = false;
+    memset(&corner_sampled_image_features_nv, 0,
+           sizeof(VkPhysicalDeviceCornerSampledImageFeaturesNV));
+  }
+  bool reported;
+  VkPhysicalDeviceCornerSampledImageFeaturesNV corner_sampled_image_features_nv;
+};
+
+struct VkJsonNVCoverageReductionMode {
+  VkJsonNVCoverageReductionMode() {
+    reported = false;
+    memset(&coverage_reduction_mode_features_nv, 0,
+           sizeof(VkPhysicalDeviceCoverageReductionModeFeaturesNV));
+  }
+  bool reported;
+  VkPhysicalDeviceCoverageReductionModeFeaturesNV
+      coverage_reduction_mode_features_nv;
+};
+
+struct VkJsonNVCudaKernelLaunch {
+  VkJsonNVCudaKernelLaunch() {
+    reported = false;
+    memset(&cuda_kernel_launch_features_nv, 0,
+           sizeof(VkPhysicalDeviceCudaKernelLaunchFeaturesNV));
+    memset(&cuda_kernel_launch_properties_nv, 0,
+           sizeof(VkPhysicalDeviceCudaKernelLaunchPropertiesNV));
+  }
+  bool reported;
+  VkPhysicalDeviceCudaKernelLaunchFeaturesNV cuda_kernel_launch_features_nv;
+  VkPhysicalDeviceCudaKernelLaunchPropertiesNV cuda_kernel_launch_properties_nv;
+};
+
+struct VkJsonNVDedicatedAllocationImageAliasing {
+  VkJsonNVDedicatedAllocationImageAliasing() {
+    reported = false;
+    memset(&dedicated_allocation_image_aliasing_features_nv, 0,
+           sizeof(VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV));
+  }
+  bool reported;
+  VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV
+      dedicated_allocation_image_aliasing_features_nv;
+};
+
+struct VkJsonNVDescriptorPoolOverallocation {
+  VkJsonNVDescriptorPoolOverallocation() {
+    reported = false;
+    memset(&descriptor_pool_overallocation_features_nv, 0,
+           sizeof(VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV));
+  }
+  bool reported;
+  VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV
+      descriptor_pool_overallocation_features_nv;
+};
+
+struct VkJsonNVDeviceDiagnosticsConfig {
+  VkJsonNVDeviceDiagnosticsConfig() {
+    reported = false;
+    memset(&diagnostics_config_features_nv, 0,
+           sizeof(VkPhysicalDeviceDiagnosticsConfigFeaturesNV));
+  }
+  bool reported;
+  VkPhysicalDeviceDiagnosticsConfigFeaturesNV diagnostics_config_features_nv;
+};
+
+struct VkJsonNVDeviceGeneratedCommands {
+  VkJsonNVDeviceGeneratedCommands() {
+    reported = false;
+    memset(&device_generated_commands_properties_nv, 0,
+           sizeof(VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV));
+    memset(&device_generated_commands_features_nv, 0,
+           sizeof(VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV));
+  }
+  bool reported;
+  VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV
+      device_generated_commands_properties_nv;
+  VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV
+      device_generated_commands_features_nv;
+};
+
+struct VkJsonNVDeviceGeneratedCommandsCompute {
+  VkJsonNVDeviceGeneratedCommandsCompute() {
+    reported = false;
+    memset(&device_generated_commands_compute_features_nv, 0,
+           sizeof(VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV));
+  }
+  bool reported;
+  VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV
+      device_generated_commands_compute_features_nv;
+};
+
+struct VkJsonNVExtendedSparseAddressSpace {
+  VkJsonNVExtendedSparseAddressSpace() {
+    reported = false;
+    memset(&extended_sparse_address_space_features_nv, 0,
+           sizeof(VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV));
+    memset(&extended_sparse_address_space_properties_nv, 0,
+           sizeof(VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV));
+  }
+  bool reported;
+  VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV
+      extended_sparse_address_space_features_nv;
+  VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV
+      extended_sparse_address_space_properties_nv;
+};
+
+struct VkJsonNVExternalMemoryRdma {
+  VkJsonNVExternalMemoryRdma() {
+    reported = false;
+    memset(&external_memory_rdma_features_nv, 0,
+           sizeof(VkPhysicalDeviceExternalMemoryRDMAFeaturesNV));
+  }
+  bool reported;
+  VkPhysicalDeviceExternalMemoryRDMAFeaturesNV external_memory_rdma_features_nv;
+};
+
+struct VkJsonNVFragmentShadingRateEnums {
+  VkJsonNVFragmentShadingRateEnums() {
+    reported = false;
+    memset(&fragment_shading_rate_enums_features_nv, 0,
+           sizeof(VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV));
+    memset(&fragment_shading_rate_enums_properties_nv, 0,
+           sizeof(VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV));
+  }
+  bool reported;
+  VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV
+      fragment_shading_rate_enums_features_nv;
+  VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV
+      fragment_shading_rate_enums_properties_nv;
+};
+
+struct VkJsonNVInheritedViewportScissor {
+  VkJsonNVInheritedViewportScissor() {
+    reported = false;
+    memset(&inherited_viewport_scissor_features_nv, 0,
+           sizeof(VkPhysicalDeviceInheritedViewportScissorFeaturesNV));
+  }
+  bool reported;
+  VkPhysicalDeviceInheritedViewportScissorFeaturesNV
+      inherited_viewport_scissor_features_nv;
+};
+
+struct VkJsonNVLinearColorAttachment {
+  VkJsonNVLinearColorAttachment() {
+    reported = false;
+    memset(&linear_color_attachment_features_nv, 0,
+           sizeof(VkPhysicalDeviceLinearColorAttachmentFeaturesNV));
+  }
+  bool reported;
+  VkPhysicalDeviceLinearColorAttachmentFeaturesNV
+      linear_color_attachment_features_nv;
+};
 
-#ifdef WIN32
-#undef min
-#undef max
-#endif
+struct VkJsonNVMemoryDecompression {
+  VkJsonNVMemoryDecompression() {
+    reported = false;
+    memset(&memory_decompression_features_nv, 0,
+           sizeof(VkPhysicalDeviceMemoryDecompressionFeaturesNV));
+    memset(&memory_decompression_properties_nv, 0,
+           sizeof(VkPhysicalDeviceMemoryDecompressionPropertiesNV));
+  }
+  bool reported;
+  VkPhysicalDeviceMemoryDecompressionFeaturesNV
+      memory_decompression_features_nv;
+  VkPhysicalDeviceMemoryDecompressionPropertiesNV
+      memory_decompression_properties_nv;
+};
 
-/*
- * This file is autogenerated by vkjson_generator.py. Do not edit directly.
- */
-struct VkJsonLayer {
-  VkLayerProperties properties;
-  std::vector<VkExtensionProperties> extensions;
+struct VkJsonNVMeshShader {
+  VkJsonNVMeshShader() {
+    reported = false;
+    memset(&mesh_shader_features_nv, 0,
+           sizeof(VkPhysicalDeviceMeshShaderFeaturesNV));
+    memset(&mesh_shader_properties_nv, 0,
+           sizeof(VkPhysicalDeviceMeshShaderPropertiesNV));
+  }
+  bool reported;
+  VkPhysicalDeviceMeshShaderFeaturesNV mesh_shader_features_nv;
+  VkPhysicalDeviceMeshShaderPropertiesNV mesh_shader_properties_nv;
 };
 
-struct VkJsonKHRVariablePointers {
-  VkJsonKHRVariablePointers() {
+struct VkJsonNVOpticalFlow {
+  VkJsonNVOpticalFlow() {
     reported = false;
-    memset(&variable_pointer_features_khr, 0,
-           sizeof(VkPhysicalDeviceVariablePointerFeaturesKHR));
-    memset(&variable_pointers_features_khr, 0,
-           sizeof(VkPhysicalDeviceVariablePointersFeaturesKHR));
+    memset(&optical_flow_features_nv, 0,
+           sizeof(VkPhysicalDeviceOpticalFlowFeaturesNV));
+    memset(&optical_flow_properties_nv, 0,
+           sizeof(VkPhysicalDeviceOpticalFlowPropertiesNV));
   }
   bool reported;
-  VkPhysicalDeviceVariablePointerFeaturesKHR variable_pointer_features_khr;
-  VkPhysicalDeviceVariablePointersFeaturesKHR variable_pointers_features_khr;
+  VkPhysicalDeviceOpticalFlowFeaturesNV optical_flow_features_nv;
+  VkPhysicalDeviceOpticalFlowPropertiesNV optical_flow_properties_nv;
 };
 
-struct VkJsonKHRShaderFloat16Int8 {
-  VkJsonKHRShaderFloat16Int8() {
+struct VkJsonNVPerStageDescriptorSet {
+  VkJsonNVPerStageDescriptorSet() {
     reported = false;
-    memset(&shader_float16_int8_features_khr, 0,
-           sizeof(VkPhysicalDeviceShaderFloat16Int8FeaturesKHR));
-    memset(&float16_int8_features_khr, 0,
-           sizeof(VkPhysicalDeviceFloat16Int8FeaturesKHR));
+    memset(&per_stage_descriptor_set_features_nv, 0,
+           sizeof(VkPhysicalDevicePerStageDescriptorSetFeaturesNV));
   }
   bool reported;
-  VkPhysicalDeviceShaderFloat16Int8FeaturesKHR shader_float16_int8_features_khr;
-  VkPhysicalDeviceFloat16Int8FeaturesKHR float16_int8_features_khr;
+  VkPhysicalDevicePerStageDescriptorSetFeaturesNV
+      per_stage_descriptor_set_features_nv;
 };
 
-struct VkJsonExtImage2dViewOf3d {
-  VkJsonExtImage2dViewOf3d() {
+struct VkJsonNVPresentBarrier {
+  VkJsonNVPresentBarrier() {
     reported = false;
-    memset(&image_2d_view_of_3d_features_ext, 0,
-           sizeof(VkPhysicalDeviceImage2DViewOf3DFeaturesEXT));
+    memset(&present_barrier_features_nv, 0,
+           sizeof(VkPhysicalDevicePresentBarrierFeaturesNV));
   }
   bool reported;
-  VkPhysicalDeviceImage2DViewOf3DFeaturesEXT image_2d_view_of_3d_features_ext;
+  VkPhysicalDevicePresentBarrierFeaturesNV present_barrier_features_nv;
 };
 
-struct VkJsonExtCustomBorderColor {
-  VkJsonExtCustomBorderColor() {
+struct VkJsonNVRawAccessChains {
+  VkJsonNVRawAccessChains() {
     reported = false;
-    memset(&custom_border_color_features_ext, 0,
-           sizeof(VkPhysicalDeviceCustomBorderColorFeaturesEXT));
+    memset(&raw_access_chains_features_nv, 0,
+           sizeof(VkPhysicalDeviceRawAccessChainsFeaturesNV));
   }
   bool reported;
-  VkPhysicalDeviceCustomBorderColorFeaturesEXT custom_border_color_features_ext;
+  VkPhysicalDeviceRawAccessChainsFeaturesNV raw_access_chains_features_nv;
 };
 
-struct VkJsonExtPrimitiveTopologyListRestart {
-  VkJsonExtPrimitiveTopologyListRestart() {
+struct VkJsonNVRayTracing {
+  VkJsonNVRayTracing() {
     reported = false;
-    memset(&primitive_topology_list_restart_features_ext, 0,
-           sizeof(VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT));
+    memset(&ray_tracing_properties_nv, 0,
+           sizeof(VkPhysicalDeviceRayTracingPropertiesNV));
   }
   bool reported;
-  VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT
-      primitive_topology_list_restart_features_ext;
+  VkPhysicalDeviceRayTracingPropertiesNV ray_tracing_properties_nv;
 };
 
-struct VkJsonExtProvokingVertex {
-  VkJsonExtProvokingVertex() {
+struct VkJsonNVRayTracingInvocationReorder {
+  VkJsonNVRayTracingInvocationReorder() {
     reported = false;
-    memset(&provoking_vertex_features_ext, 0,
-           sizeof(VkPhysicalDeviceProvokingVertexFeaturesEXT));
+    memset(&ray_tracing_invocation_reorder_properties_nv, 0,
+           sizeof(VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV));
+    memset(&ray_tracing_invocation_reorder_features_nv, 0,
+           sizeof(VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV));
   }
   bool reported;
-  VkPhysicalDeviceProvokingVertexFeaturesEXT provoking_vertex_features_ext;
+  VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV
+      ray_tracing_invocation_reorder_properties_nv;
+  VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV
+      ray_tracing_invocation_reorder_features_nv;
 };
 
-struct VkJsonKHRIndexTypeUint8 {
-  VkJsonKHRIndexTypeUint8() {
+struct VkJsonNVRayTracingMotionBlur {
+  VkJsonNVRayTracingMotionBlur() {
     reported = false;
-    memset(&index_type_uint8_features_khr, 0,
-           sizeof(VkPhysicalDeviceIndexTypeUint8FeaturesKHR));
+    memset(&ray_tracing_motion_blur_features_nv, 0,
+           sizeof(VkPhysicalDeviceRayTracingMotionBlurFeaturesNV));
   }
   bool reported;
-  VkPhysicalDeviceIndexTypeUint8FeaturesKHR index_type_uint8_features_khr;
+  VkPhysicalDeviceRayTracingMotionBlurFeaturesNV
+      ray_tracing_motion_blur_features_nv;
 };
 
-struct VkJsonExtIndexTypeUint8 {
-  VkJsonExtIndexTypeUint8() {
+struct VkJsonNVRayTracingValidation {
+  VkJsonNVRayTracingValidation() {
     reported = false;
-    memset(&index_type_uint8_features_ext, 0,
-           sizeof(VkPhysicalDeviceIndexTypeUint8FeaturesEXT));
+    memset(&ray_tracing_validation_features_nv, 0,
+           sizeof(VkPhysicalDeviceRayTracingValidationFeaturesNV));
   }
   bool reported;
-  VkPhysicalDeviceIndexTypeUint8FeaturesEXT index_type_uint8_features_ext;
+  VkPhysicalDeviceRayTracingValidationFeaturesNV
+      ray_tracing_validation_features_nv;
 };
 
-struct VkJsonKHRVertexAttributeDivisor {
-  VkJsonKHRVertexAttributeDivisor() {
+struct VkJsonNVRepresentativeFragmentTest {
+  VkJsonNVRepresentativeFragmentTest() {
     reported = false;
-    memset(&vertex_attribute_divisor_features_khr, 0,
-           sizeof(VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR));
+    memset(&representative_fragment_test_features_nv, 0,
+           sizeof(VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV));
   }
   bool reported;
-  VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR
-      vertex_attribute_divisor_features_khr;
+  VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV
+      representative_fragment_test_features_nv;
 };
 
-struct VkJsonExtVertexAttributeDivisor {
-  VkJsonExtVertexAttributeDivisor() {
+struct VkJsonNVScissorExclusive {
+  VkJsonNVScissorExclusive() {
     reported = false;
-    memset(&vertex_attribute_divisor_features_ext, 0,
-           sizeof(VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT));
+    memset(&exclusive_scissor_features_nv, 0,
+           sizeof(VkPhysicalDeviceExclusiveScissorFeaturesNV));
   }
   bool reported;
-  VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT
-      vertex_attribute_divisor_features_ext;
+  VkPhysicalDeviceExclusiveScissorFeaturesNV exclusive_scissor_features_nv;
 };
 
-struct VkJsonExtTransformFeedback {
-  VkJsonExtTransformFeedback() {
+struct VkJsonNVShaderAtomicFloat16Vector {
+  VkJsonNVShaderAtomicFloat16Vector() {
     reported = false;
-    memset(&transform_feedback_features_ext, 0,
-           sizeof(VkPhysicalDeviceTransformFeedbackFeaturesEXT));
+    memset(&shader_atomic_float16_vector_features_nv, 0,
+           sizeof(VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV));
   }
   bool reported;
-  VkPhysicalDeviceTransformFeedbackFeaturesEXT transform_feedback_features_ext;
+  VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV
+      shader_atomic_float16_vector_features_nv;
 };
 
-struct VkJsonKHRShaderSubgroupUniformControlFlow {
-  VkJsonKHRShaderSubgroupUniformControlFlow() {
+struct VkJsonNVShaderImageFootprint {
+  VkJsonNVShaderImageFootprint() {
     reported = false;
-    memset(&shader_subgroup_uniform_control_flow_features_khr, 0,
-           sizeof(VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR));
+    memset(&shader_image_footprint_features_nv, 0,
+           sizeof(VkPhysicalDeviceShaderImageFootprintFeaturesNV));
   }
   bool reported;
-  VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR
-      shader_subgroup_uniform_control_flow_features_khr;
+  VkPhysicalDeviceShaderImageFootprintFeaturesNV
+      shader_image_footprint_features_nv;
 };
 
-struct VkJsonKHRShaderSubgroupExtendedTypes {
-  VkJsonKHRShaderSubgroupExtendedTypes() {
+struct VkJsonNVShaderSmBuiltins {
+  VkJsonNVShaderSmBuiltins() {
     reported = false;
-    memset(&shader_subgroup_extended_types_features_khr, 0,
-           sizeof(VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR));
+    memset(&shader_sm_builtins_properties_nv, 0,
+           sizeof(VkPhysicalDeviceShaderSMBuiltinsPropertiesNV));
+    memset(&shader_sm_builtins_features_nv, 0,
+           sizeof(VkPhysicalDeviceShaderSMBuiltinsFeaturesNV));
   }
   bool reported;
-  VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR
-      shader_subgroup_extended_types_features_khr;
+  VkPhysicalDeviceShaderSMBuiltinsPropertiesNV shader_sm_builtins_properties_nv;
+  VkPhysicalDeviceShaderSMBuiltinsFeaturesNV shader_sm_builtins_features_nv;
 };
 
-struct VkJsonKHR8bitStorage {
-  VkJsonKHR8bitStorage() {
+struct VkJsonNVShadingRateImage {
+  VkJsonNVShadingRateImage() {
     reported = false;
-    memset(&bit8_storage_features_khr, 0,
-           sizeof(VkPhysicalDevice8BitStorageFeaturesKHR));
+    memset(&shading_rate_image_features_nv, 0,
+           sizeof(VkPhysicalDeviceShadingRateImageFeaturesNV));
+    memset(&shading_rate_image_properties_nv, 0,
+           sizeof(VkPhysicalDeviceShadingRateImagePropertiesNV));
   }
   bool reported;
-  VkPhysicalDevice8BitStorageFeaturesKHR bit8_storage_features_khr;
+  VkPhysicalDeviceShadingRateImageFeaturesNV shading_rate_image_features_nv;
+  VkPhysicalDeviceShadingRateImagePropertiesNV shading_rate_image_properties_nv;
 };
 
-struct VkJsonKHRShaderIntegerDotProduct {
-  VkJsonKHRShaderIntegerDotProduct() {
+struct VkJsonQCOMFilterCubicClamp {
+  VkJsonQCOMFilterCubicClamp() {
     reported = false;
-    memset(&shader_integer_dot_product_features_khr, 0,
-           sizeof(VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR));
+    memset(&cubic_clamp_features_qcom, 0,
+           sizeof(VkPhysicalDeviceCubicClampFeaturesQCOM));
   }
   bool reported;
-  VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR
-      shader_integer_dot_product_features_khr;
+  VkPhysicalDeviceCubicClampFeaturesQCOM cubic_clamp_features_qcom;
 };
 
-struct VkJsonIMGRelaxedLineRasterization {
-  VkJsonIMGRelaxedLineRasterization() {
+struct VkJsonQCOMFilterCubicWeights {
+  VkJsonQCOMFilterCubicWeights() {
     reported = false;
-    memset(&relaxed_line_rasterization_features_img, 0,
-           sizeof(VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG));
+    memset(&cubic_weights_features_qcom, 0,
+           sizeof(VkPhysicalDeviceCubicWeightsFeaturesQCOM));
   }
   bool reported;
-  VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG
-      relaxed_line_rasterization_features_img;
+  VkPhysicalDeviceCubicWeightsFeaturesQCOM cubic_weights_features_qcom;
 };
 
-struct VkJsonKHRLineRasterization {
-  VkJsonKHRLineRasterization() {
+struct VkJsonQCOMFragmentDensityMapOffset {
+  VkJsonQCOMFragmentDensityMapOffset() {
     reported = false;
-    memset(&line_rasterization_features_khr, 0,
-           sizeof(VkPhysicalDeviceLineRasterizationFeaturesKHR));
+    memset(&fragment_density_map_offset_features_qcom, 0,
+           sizeof(VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM));
+    memset(&fragment_density_map_offset_properties_qcom, 0,
+           sizeof(VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM));
   }
   bool reported;
-  VkPhysicalDeviceLineRasterizationFeaturesKHR line_rasterization_features_khr;
+  VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM
+      fragment_density_map_offset_features_qcom;
+  VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM
+      fragment_density_map_offset_properties_qcom;
 };
 
-struct VkJsonExtLineRasterization {
-  VkJsonExtLineRasterization() {
+struct VkJsonQCOMImageProcessing {
+  VkJsonQCOMImageProcessing() {
     reported = false;
-    memset(&line_rasterization_features_ext, 0,
-           sizeof(VkPhysicalDeviceLineRasterizationFeaturesEXT));
+    memset(&image_processing_features_qcom, 0,
+           sizeof(VkPhysicalDeviceImageProcessingFeaturesQCOM));
+    memset(&image_processing_properties_qcom, 0,
+           sizeof(VkPhysicalDeviceImageProcessingPropertiesQCOM));
   }
   bool reported;
-  VkPhysicalDeviceLineRasterizationFeaturesEXT line_rasterization_features_ext;
+  VkPhysicalDeviceImageProcessingFeaturesQCOM image_processing_features_qcom;
+  VkPhysicalDeviceImageProcessingPropertiesQCOM
+      image_processing_properties_qcom;
 };
 
-struct VkJsonExtPrimitivesGeneratedQuery {
-  VkJsonExtPrimitivesGeneratedQuery() {
+struct VkJsonQCOMImageProcessing2 {
+  VkJsonQCOMImageProcessing2() {
     reported = false;
-    memset(&primitives_generated_query_features_ext, 0,
-           sizeof(VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT));
+    memset(&image_processing2_features_qcom, 0,
+           sizeof(VkPhysicalDeviceImageProcessing2FeaturesQCOM));
+    memset(&image_processing2_properties_qcom, 0,
+           sizeof(VkPhysicalDeviceImageProcessing2PropertiesQCOM));
   }
   bool reported;
-  VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT
-      primitives_generated_query_features_ext;
+  VkPhysicalDeviceImageProcessing2FeaturesQCOM image_processing2_features_qcom;
+  VkPhysicalDeviceImageProcessing2PropertiesQCOM
+      image_processing2_properties_qcom;
 };
 
-struct VkJsonKHRShaderFloatControls {
-  VkJsonKHRShaderFloatControls() {
+struct VkJsonQCOMMultiviewPerViewRenderAreas {
+  VkJsonQCOMMultiviewPerViewRenderAreas() {
     reported = false;
-    memset(&float_controls_properties_khr, 0,
-           sizeof(VkPhysicalDeviceFloatControlsPropertiesKHR));
+    memset(&multiview_per_view_render_areas_features_qcom, 0,
+           sizeof(VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM));
   }
   bool reported;
-  VkPhysicalDeviceFloatControlsPropertiesKHR float_controls_properties_khr;
+  VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM
+      multiview_per_view_render_areas_features_qcom;
 };
 
-struct VkJsonKHRDriverProperties {
-  VkJsonKHRDriverProperties() {
+struct VkJsonQCOMMultiviewPerViewViewports {
+  VkJsonQCOMMultiviewPerViewViewports() {
     reported = false;
-    memset(&driver_properties_khr, 0,
-           sizeof(VkPhysicalDeviceDriverPropertiesKHR));
+    memset(&multiview_per_view_viewports_features_qcom, 0,
+           sizeof(VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM));
   }
   bool reported;
-  VkPhysicalDeviceDriverPropertiesKHR driver_properties_khr;
+  VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM
+      multiview_per_view_viewports_features_qcom;
+};
+
+struct VkJsonQCOMTileProperties {
+  VkJsonQCOMTileProperties() {
+    reported = false;
+    memset(&tile_properties_features_qcom, 0,
+           sizeof(VkPhysicalDeviceTilePropertiesFeaturesQCOM));
+  }
+  bool reported;
+  VkPhysicalDeviceTilePropertiesFeaturesQCOM tile_properties_features_qcom;
+};
+
+struct VkJsonQCOMYcbcrDegamma {
+  VkJsonQCOMYcbcrDegamma() {
+    reported = false;
+    memset(&ycbcr_degamma_features_qcom, 0,
+           sizeof(VkPhysicalDeviceYcbcrDegammaFeaturesQCOM));
+  }
+  bool reported;
+  VkPhysicalDeviceYcbcrDegammaFeaturesQCOM ycbcr_degamma_features_qcom;
+};
+
+struct VkJsonSECAmigoProfiling {
+  VkJsonSECAmigoProfiling() {
+    reported = false;
+    memset(&amigo_profiling_features_sec, 0,
+           sizeof(VkPhysicalDeviceAmigoProfilingFeaturesSEC));
+  }
+  bool reported;
+  VkPhysicalDeviceAmigoProfilingFeaturesSEC amigo_profiling_features_sec;
+};
+
+struct VkJsonVALVEDescriptorSetHostMapping {
+  VkJsonVALVEDescriptorSetHostMapping() {
+    reported = false;
+    memset(&descriptor_set_host_mapping_features_valve, 0,
+           sizeof(VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE));
+  }
+  bool reported;
+  VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE
+      descriptor_set_host_mapping_features_valve;
+};
+
+struct VkJsonVALVEMutableDescriptorType {
+  VkJsonVALVEMutableDescriptorType() {
+    reported = false;
+    memset(&mutable_descriptor_type_features_valve, 0,
+           sizeof(VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE));
+  }
+  bool reported;
+  VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE
+      mutable_descriptor_type_features_valve;
 };
 
 struct VkJsonCore11 {
   VkJsonCore11() {
-    memset(&properties, 0, sizeof(VkPhysicalDeviceVulkan11Properties));
     memset(&features, 0, sizeof(VkPhysicalDeviceVulkan11Features));
+    memset(&properties, 0, sizeof(VkPhysicalDeviceVulkan11Properties));
   }
-  VkPhysicalDeviceVulkan11Properties properties;
   VkPhysicalDeviceVulkan11Features features;
+  VkPhysicalDeviceVulkan11Properties properties;
 };
 
 struct VkJsonCore12 {
   VkJsonCore12() {
-    memset(&properties, 0, sizeof(VkPhysicalDeviceVulkan12Properties));
     memset(&features, 0, sizeof(VkPhysicalDeviceVulkan12Features));
+    memset(&properties, 0, sizeof(VkPhysicalDeviceVulkan12Properties));
   }
-  VkPhysicalDeviceVulkan12Properties properties;
   VkPhysicalDeviceVulkan12Features features;
+  VkPhysicalDeviceVulkan12Properties properties;
 };
 
 struct VkJsonCore13 {
   VkJsonCore13() {
-    memset(&properties, 0, sizeof(VkPhysicalDeviceVulkan13Properties));
     memset(&features, 0, sizeof(VkPhysicalDeviceVulkan13Features));
+    memset(&properties, 0, sizeof(VkPhysicalDeviceVulkan13Properties));
   }
-  VkPhysicalDeviceVulkan13Properties properties;
   VkPhysicalDeviceVulkan13Features features;
+  VkPhysicalDeviceVulkan13Properties properties;
 };
 
 struct VkJsonCore14 {
   VkJsonCore14() {
-    memset(&properties, 0, sizeof(VkPhysicalDeviceVulkan14Properties));
     memset(&features, 0, sizeof(VkPhysicalDeviceVulkan14Features));
+    memset(&properties, 0, sizeof(VkPhysicalDeviceVulkan14Properties));
   }
-  VkPhysicalDeviceVulkan14Properties properties;
   VkPhysicalDeviceVulkan14Features features;
+  VkPhysicalDeviceVulkan14Properties properties;
   std::vector<VkImageLayout> copy_src_layouts;
   std::vector<VkImageLayout> copy_dst_layouts;
 };
 
 struct VkJsonDevice {
   VkJsonDevice() {
-    memset(&properties, 0, sizeof(VkPhysicalDeviceProperties));
-    memset(&features, 0, sizeof(VkPhysicalDeviceFeatures));
-    memset(&memory, 0, sizeof(VkPhysicalDeviceMemoryProperties));
-    memset(&subgroup_properties, 0, sizeof(VkPhysicalDeviceSubgroupProperties));
-    memset(&point_clipping_properties, 0,
-           sizeof(VkPhysicalDevicePointClippingProperties));
-    memset(&multiview_properties, 0,
-           sizeof(VkPhysicalDeviceMultiviewProperties));
+    memset(&bit16_storage_features, 0,
+           sizeof(VkPhysicalDevice16BitStorageFeatures));
+    memset(&bit8_storage_features, 0,
+           sizeof(VkPhysicalDevice8BitStorageFeatures));
+    memset(&buffer_device_address_features, 0,
+           sizeof(VkPhysicalDeviceBufferDeviceAddressFeatures));
+    memset(&depth_stencil_resolve_properties, 0,
+           sizeof(VkPhysicalDeviceDepthStencilResolveProperties));
+    memset(&descriptor_indexing_features, 0,
+           sizeof(VkPhysicalDeviceDescriptorIndexingFeatures));
+    memset(&descriptor_indexing_properties, 0,
+           sizeof(VkPhysicalDeviceDescriptorIndexingProperties));
+    memset(&driver_properties, 0, sizeof(VkPhysicalDeviceDriverProperties));
+    memset(&dynamic_rendering_features, 0,
+           sizeof(VkPhysicalDeviceDynamicRenderingFeatures));
+    memset(&dynamic_rendering_local_read_features, 0,
+           sizeof(VkPhysicalDeviceDynamicRenderingLocalReadFeatures));
+    memset(&float_controls_properties, 0,
+           sizeof(VkPhysicalDeviceFloatControlsProperties));
+    memset(&global_priority_query_features, 0,
+           sizeof(VkPhysicalDeviceGlobalPriorityQueryFeatures));
+    memset(&host_image_copy_features, 0,
+           sizeof(VkPhysicalDeviceHostImageCopyFeatures));
+    memset(&host_query_reset_features, 0,
+           sizeof(VkPhysicalDeviceHostQueryResetFeatures));
     memset(&id_properties, 0, sizeof(VkPhysicalDeviceIDProperties));
+    memset(&image_robustness_features, 0,
+           sizeof(VkPhysicalDeviceImageRobustnessFeatures));
+    memset(&imageless_framebuffer_features, 0,
+           sizeof(VkPhysicalDeviceImagelessFramebufferFeatures));
+    memset(&index_type_uint8_features, 0,
+           sizeof(VkPhysicalDeviceIndexTypeUint8Features));
+    memset(&inline_uniform_block_features, 0,
+           sizeof(VkPhysicalDeviceInlineUniformBlockFeatures));
+    memset(&inline_uniform_block_properties, 0,
+           sizeof(VkPhysicalDeviceInlineUniformBlockProperties));
+    memset(&line_rasterization_features, 0,
+           sizeof(VkPhysicalDeviceLineRasterizationFeatures));
+    memset(&line_rasterization_properties, 0,
+           sizeof(VkPhysicalDeviceLineRasterizationProperties));
     memset(&maintenance3_properties, 0,
            sizeof(VkPhysicalDeviceMaintenance3Properties));
-    memset(&bit16_storage_features, 0,
-           sizeof(VkPhysicalDevice16BitStorageFeatures));
+    memset(&maintenance4_features, 0,
+           sizeof(VkPhysicalDeviceMaintenance4Features));
+    memset(&maintenance4_properties, 0,
+           sizeof(VkPhysicalDeviceMaintenance4Properties));
+    memset(&maintenance5_features, 0,
+           sizeof(VkPhysicalDeviceMaintenance5Features));
+    memset(&maintenance5_properties, 0,
+           sizeof(VkPhysicalDeviceMaintenance5Properties));
+    memset(&maintenance6_features, 0,
+           sizeof(VkPhysicalDeviceMaintenance6Features));
+    memset(&maintenance6_properties, 0,
+           sizeof(VkPhysicalDeviceMaintenance6Properties));
     memset(&multiview_features, 0, sizeof(VkPhysicalDeviceMultiviewFeatures));
-    memset(&variable_pointers_features, 0,
-           sizeof(VkPhysicalDeviceVariablePointersFeatures));
+    memset(&multiview_properties, 0,
+           sizeof(VkPhysicalDeviceMultiviewProperties));
+    memset(&pipeline_creation_cache_control_features, 0,
+           sizeof(VkPhysicalDevicePipelineCreationCacheControlFeatures));
+    memset(&pipeline_protected_access_features, 0,
+           sizeof(VkPhysicalDevicePipelineProtectedAccessFeatures));
+    memset(&pipeline_robustness_features, 0,
+           sizeof(VkPhysicalDevicePipelineRobustnessFeatures));
+    memset(&pipeline_robustness_properties, 0,
+           sizeof(VkPhysicalDevicePipelineRobustnessProperties));
+    memset(&point_clipping_properties, 0,
+           sizeof(VkPhysicalDevicePointClippingProperties));
+    memset(&private_data_features, 0,
+           sizeof(VkPhysicalDevicePrivateDataFeatures));
     memset(&protected_memory_features, 0,
            sizeof(VkPhysicalDeviceProtectedMemoryFeatures));
+    memset(&protected_memory_properties, 0,
+           sizeof(VkPhysicalDeviceProtectedMemoryProperties));
+    memset(&push_descriptor_properties, 0,
+           sizeof(VkPhysicalDevicePushDescriptorProperties));
+    memset(&sampler_filter_minmax_properties, 0,
+           sizeof(VkPhysicalDeviceSamplerFilterMinmaxProperties));
     memset(&sampler_ycbcr_conversion_features, 0,
            sizeof(VkPhysicalDeviceSamplerYcbcrConversionFeatures));
+    memset(&scalar_block_layout_features, 0,
+           sizeof(VkPhysicalDeviceScalarBlockLayoutFeatures));
+    memset(&separate_depth_stencil_layouts_features, 0,
+           sizeof(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures));
+    memset(&shader_atomic_int64_features, 0,
+           sizeof(VkPhysicalDeviceShaderAtomicInt64Features));
+    memset(&shader_demote_to_helper_invocation_features, 0,
+           sizeof(VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures));
     memset(&shader_draw_parameter_features, 0,
            sizeof(VkPhysicalDeviceShaderDrawParameterFeatures));
+    memset(&shader_draw_parameters_features, 0,
+           sizeof(VkPhysicalDeviceShaderDrawParametersFeatures));
+    memset(&shader_expect_assume_features, 0,
+           sizeof(VkPhysicalDeviceShaderExpectAssumeFeatures));
+    memset(&shader_float16_int8_features, 0,
+           sizeof(VkPhysicalDeviceShaderFloat16Int8Features));
+    memset(&shader_float_controls2_features, 0,
+           sizeof(VkPhysicalDeviceShaderFloatControls2Features));
+    memset(&shader_integer_dot_product_features, 0,
+           sizeof(VkPhysicalDeviceShaderIntegerDotProductFeatures));
+    memset(&shader_integer_dot_product_properties, 0,
+           sizeof(VkPhysicalDeviceShaderIntegerDotProductProperties));
+    memset(&shader_subgroup_extended_types_features, 0,
+           sizeof(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures));
+    memset(&shader_subgroup_rotate_features, 0,
+           sizeof(VkPhysicalDeviceShaderSubgroupRotateFeatures));
+    memset(&shader_terminate_invocation_features, 0,
+           sizeof(VkPhysicalDeviceShaderTerminateInvocationFeatures));
+    memset(&subgroup_properties, 0, sizeof(VkPhysicalDeviceSubgroupProperties));
+    memset(&subgroup_size_control_features, 0,
+           sizeof(VkPhysicalDeviceSubgroupSizeControlFeatures));
+    memset(&subgroup_size_control_properties, 0,
+           sizeof(VkPhysicalDeviceSubgroupSizeControlProperties));
+    memset(&synchronization2_features, 0,
+           sizeof(VkPhysicalDeviceSynchronization2Features));
+    memset(&texel_buffer_alignment_properties, 0,
+           sizeof(VkPhysicalDeviceTexelBufferAlignmentProperties));
+    memset(&texture_compression_astchdr_features, 0,
+           sizeof(VkPhysicalDeviceTextureCompressionASTCHDRFeatures));
+    memset(&timeline_semaphore_features, 0,
+           sizeof(VkPhysicalDeviceTimelineSemaphoreFeatures));
+    memset(&timeline_semaphore_properties, 0,
+           sizeof(VkPhysicalDeviceTimelineSemaphoreProperties));
+    memset(&uniform_buffer_standard_layout_features, 0,
+           sizeof(VkPhysicalDeviceUniformBufferStandardLayoutFeatures));
+    memset(&variable_pointer_features, 0,
+           sizeof(VkPhysicalDeviceVariablePointerFeatures));
+    memset(&variable_pointers_features, 0,
+           sizeof(VkPhysicalDeviceVariablePointersFeatures));
+    memset(&vertex_attribute_divisor_features, 0,
+           sizeof(VkPhysicalDeviceVertexAttributeDivisorFeatures));
+    memset(&vertex_attribute_divisor_properties, 0,
+           sizeof(VkPhysicalDeviceVertexAttributeDivisorProperties));
+    memset(&vulkan_memory_model_features, 0,
+           sizeof(VkPhysicalDeviceVulkanMemoryModelFeatures));
+    memset(&zero_initialize_workgroup_memory_features, 0,
+           sizeof(VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures));
+    memset(&properties, 0, sizeof(VkPhysicalDeviceProperties));
+    memset(&features, 0, sizeof(VkPhysicalDeviceFeatures));
+    memset(&memory, 0, sizeof(VkPhysicalDeviceMemoryProperties));
   }
-  VkJsonKHRVariablePointers khr_variable_pointers;
-  VkJsonKHRShaderFloat16Int8 khr_shader_float16_int8;
-  VkJsonExtImage2dViewOf3d ext_image_2d_view_of_3d;
+  VkJsonAMDAntiLag amd_anti_lag;
+  VkJsonAMDDeviceCoherentMemory amd_device_coherent_memory;
+  VkJsonAMDShaderCoreProperties amd_shader_core_properties;
+  VkJsonAMDShaderCoreProperties2 amd_shader_core_properties2;
+  VkJsonAMDShaderEarlyAndLateFragmentTests
+      amd_shader_early_and_late_fragment_tests;
+  VkJsonANDROIDExternalFormatResolve android_external_format_resolve;
+  VkJsonARMRasterizationOrderAttachmentAccess
+      arm_rasterization_order_attachment_access;
+  VkJsonARMRenderPassStriped arm_render_pass_striped;
+  VkJsonARMSchedulingControls arm_scheduling_controls;
+  VkJsonARMShaderCoreBuiltins arm_shader_core_builtins;
+  VkJsonARMShaderCoreProperties arm_shader_core_properties;
+  VkJsonExt4444Formats ext_formats_4444;
+  VkJsonExtAstcDecodeMode ext_astc_decode_mode;
+  VkJsonExtAttachmentFeedbackLoopDynamicState
+      ext_attachment_feedback_loop_dynamic_state;
+  VkJsonExtAttachmentFeedbackLoopLayout ext_attachment_feedback_loop_layout;
+  VkJsonExtBlendOperationAdvanced ext_blend_operation_advanced;
+  VkJsonExtBorderColorSwizzle ext_border_color_swizzle;
+  VkJsonExtBufferDeviceAddress ext_buffer_device_address;
+  VkJsonExtColorWriteEnable ext_color_write_enable;
+  VkJsonExtConditionalRendering ext_conditional_rendering;
+  VkJsonExtConservativeRasterization ext_conservative_rasterization;
   VkJsonExtCustomBorderColor ext_custom_border_color;
+  VkJsonExtDepthBiasControl ext_depth_bias_control;
+  VkJsonExtDepthClampZeroOne ext_depth_clamp_zero_one;
+  VkJsonExtDepthClipControl ext_depth_clip_control;
+  VkJsonExtDepthClipEnable ext_depth_clip_enable;
+  VkJsonExtDescriptorBuffer ext_descriptor_buffer;
+  VkJsonExtDescriptorIndexing ext_descriptor_indexing;
+  VkJsonExtDeviceAddressBindingReport ext_device_address_binding_report;
+  VkJsonExtDeviceFault ext_device_fault;
+  VkJsonExtDeviceMemoryReport ext_device_memory_report;
+  VkJsonExtDiscardRectangles ext_discard_rectangles;
+  VkJsonExtDynamicRenderingUnusedAttachments
+      ext_dynamic_rendering_unused_attachments;
+  VkJsonExtExtendedDynamicState ext_extended_dynamic_state;
+  VkJsonExtExtendedDynamicState2 ext_extended_dynamic_state2;
+  VkJsonExtExtendedDynamicState3 ext_extended_dynamic_state3;
+  VkJsonExtExternalMemoryHost ext_external_memory_host;
+  VkJsonExtFragmentDensityMap ext_fragment_density_map;
+  VkJsonExtFragmentDensityMap2 ext_fragment_density_map2;
+  VkJsonExtFragmentShaderInterlock ext_fragment_shader_interlock;
+  VkJsonExtFrameBoundary ext_frame_boundary;
+  VkJsonExtGlobalPriorityQuery ext_global_priority_query;
+  VkJsonExtGraphicsPipelineLibrary ext_graphics_pipeline_library;
+  VkJsonExtHostImageCopy ext_host_image_copy;
+  VkJsonExtHostQueryReset ext_host_query_reset;
+  VkJsonExtImage2dViewOf3d ext_image_2d_view_of_3d;
+  VkJsonExtImageCompressionControl ext_image_compression_control;
+  VkJsonExtImageCompressionControlSwapchain
+      ext_image_compression_control_swapchain;
+  VkJsonExtImageRobustness ext_image_robustness;
+  VkJsonExtImageSlicedViewOf3d ext_image_sliced_view_of_3d;
+  VkJsonExtImageViewMinLod ext_image_view_min_lod;
+  VkJsonExtIndexTypeUint8 ext_index_type_uint8;
+  VkJsonExtInlineUniformBlock ext_inline_uniform_block;
+  VkJsonExtLegacyDithering ext_legacy_dithering;
+  VkJsonExtLegacyVertexAttributes ext_legacy_vertex_attributes;
+  VkJsonExtLineRasterization ext_line_rasterization;
+  VkJsonExtMapMemoryPlaced ext_map_memory_placed;
+  VkJsonExtMemoryPriority ext_memory_priority;
+  VkJsonExtMeshShader ext_mesh_shader;
+  VkJsonExtMultiDraw ext_multi_draw;
+  VkJsonExtMultisampledRenderToSingleSampled
+      ext_multisampled_render_to_single_sampled;
+  VkJsonExtMutableDescriptorType ext_mutable_descriptor_type;
+  VkJsonExtNestedCommandBuffer ext_nested_command_buffer;
+  VkJsonExtNonSeamlessCubeMap ext_non_seamless_cube_map;
+  VkJsonExtOpacityMicromap ext_opacity_micromap;
+  VkJsonExtPageableDeviceLocalMemory ext_pageable_device_local_memory;
+  VkJsonExtPciBusInfo ext_pci_bus_info;
+  VkJsonExtPhysicalDeviceDrm ext_physical_device_drm;
+  VkJsonExtPipelineCreationCacheControl ext_pipeline_creation_cache_control;
+  VkJsonExtPipelineLibraryGroupHandles ext_pipeline_library_group_handles;
+  VkJsonExtPipelineProperties ext_pipeline_properties;
+  VkJsonExtPipelineProtectedAccess ext_pipeline_protected_access;
+  VkJsonExtPipelineRobustness ext_pipeline_robustness;
   VkJsonExtPrimitiveTopologyListRestart ext_primitive_topology_list_restart;
+  VkJsonExtPrimitivesGeneratedQuery ext_primitives_generated_query;
+  VkJsonExtPrivateData ext_private_data;
   VkJsonExtProvokingVertex ext_provoking_vertex;
-  VkJsonKHRIndexTypeUint8 khr_index_type_uint8;
-  VkJsonExtIndexTypeUint8 ext_index_type_uint8;
-  VkJsonKHRVertexAttributeDivisor khr_vertex_attribute_divisor;
-  VkJsonExtVertexAttributeDivisor ext_vertex_attribute_divisor;
+  VkJsonExtRasterizationOrderAttachmentAccess
+      ext_rasterization_order_attachment_access;
+  VkJsonExtRgba10x6Formats ext_rgba10x6_formats;
+  VkJsonExtRobustness2 ext_robustness2;
+  VkJsonExtSampleLocations ext_sample_locations;
+  VkJsonExtSamplerFilterMinmax ext_sampler_filter_minmax;
+  VkJsonExtScalarBlockLayout ext_scalar_block_layout;
+  VkJsonExtShaderAtomicFloat ext_shader_atomic_float;
+  VkJsonExtShaderAtomicFloat2 ext_shader_atomic_float2;
+  VkJsonExtShaderDemoteToHelperInvocation
+      ext_shader_demote_to_helper_invocation;
+  VkJsonExtShaderImageAtomicInt64 ext_shader_image_atomic_int64;
+  VkJsonExtShaderModuleIdentifier ext_shader_module_identifier;
+  VkJsonExtShaderObject ext_shader_object;
+  VkJsonExtShaderReplicatedComposites ext_shader_replicated_composites;
+  VkJsonExtShaderTileImage ext_shader_tile_image;
+  VkJsonExtSubgroupSizeControl ext_subgroup_size_control;
+  VkJsonExtSubpassMergeFeedback ext_subpass_merge_feedback;
+  VkJsonExtSwapchainMaintenance1 ext_swapchain_maintenance1;
+  VkJsonExtTexelBufferAlignment ext_texel_buffer_alignment;
+  VkJsonExtTextureCompressionAstcHdr ext_texture_compression_astc_hdr;
   VkJsonExtTransformFeedback ext_transform_feedback;
-  VkJsonKHRShaderSubgroupUniformControlFlow
-      khr_shader_subgroup_uniform_control_flow;
-  VkJsonKHRShaderSubgroupExtendedTypes khr_shader_subgroup_extended_types;
-  VkJsonKHR8bitStorage khr_8bit_storage;
-  VkJsonKHRShaderIntegerDotProduct khr_shader_integer_dot_product;
+  VkJsonExtVertexAttributeDivisor ext_vertex_attribute_divisor;
+  VkJsonExtVertexInputDynamicState ext_vertex_input_dynamic_state;
+  VkJsonExtYcbcr2plane444Formats ext_ycbcr_2plane_444_formats;
+  VkJsonExtYcbcrImageArrays ext_ycbcr_image_arrays;
+  VkJsonHUAWEIClusterCullingShader huawei_cluster_culling_shader;
+  VkJsonHUAWEIInvocationMask huawei_invocation_mask;
+  VkJsonHUAWEISubpassShading huawei_subpass_shading;
   VkJsonIMGRelaxedLineRasterization img_relaxed_line_rasterization;
+  VkJsonExtVKINTELShaderIntegerFunctions2 vk_intel_shader_integer_functions2;
+  VkJsonKHR16bitStorage khr_16bit_storage;
+  VkJsonKHR8bitStorage khr_8bit_storage;
+  VkJsonKHRAccelerationStructure khr_acceleration_structure;
+  VkJsonKHRBufferDeviceAddress khr_buffer_device_address;
+  VkJsonKHRCooperativeMatrix khr_cooperative_matrix;
+  VkJsonKHRDepthStencilResolve khr_depth_stencil_resolve;
+  VkJsonKHRDriverProperties khr_driver_properties;
+  VkJsonKHRDynamicRendering khr_dynamic_rendering;
+  VkJsonKHRDynamicRenderingLocalRead khr_dynamic_rendering_local_read;
+  VkJsonKHRExternalMemoryCapabilities khr_external_memory_capabilities;
+  VkJsonKHRFragmentShaderBarycentric khr_fragment_shader_barycentric;
+  VkJsonKHRFragmentShadingRate khr_fragment_shading_rate;
+  VkJsonKHRGlobalPriority khr_global_priority;
+  VkJsonKHRImagelessFramebuffer khr_imageless_framebuffer;
+  VkJsonKHRIndexTypeUint8 khr_index_type_uint8;
   VkJsonKHRLineRasterization khr_line_rasterization;
-  VkJsonExtLineRasterization ext_line_rasterization;
-  VkJsonExtPrimitivesGeneratedQuery ext_primitives_generated_query;
+  VkJsonKHRMaintenance2 khr_maintenance2;
+  VkJsonKHRMaintenance3 khr_maintenance3;
+  VkJsonKHRMaintenance4 khr_maintenance4;
+  VkJsonKHRMaintenance5 khr_maintenance5;
+  VkJsonKHRMaintenance6 khr_maintenance6;
+  VkJsonKHRMaintenance7 khr_maintenance7;
+  VkJsonKHRMultiview khr_multiview;
+  VkJsonKHRPerformanceQuery khr_performance_query;
+  VkJsonKHRPipelineBinary khr_pipeline_binary;
+  VkJsonKHRPipelineExecutableProperties khr_pipeline_executable_properties;
+  VkJsonKHRPresentId khr_present_id;
+  VkJsonKHRPresentWait khr_present_wait;
+  VkJsonKHRPushDescriptor khr_push_descriptor;
+  VkJsonKHRRayQuery khr_ray_query;
+  VkJsonKHRRayTracingMaintenance1 khr_ray_tracing_maintenance1;
+  VkJsonKHRRayTracingPipeline khr_ray_tracing_pipeline;
+  VkJsonKHRRayTracingPositionFetch khr_ray_tracing_position_fetch;
+  VkJsonKHRSamplerYcbcrConversion khr_sampler_ycbcr_conversion;
+  VkJsonKHRSeparateDepthStencilLayouts khr_separate_depth_stencil_layouts;
+  VkJsonKHRShaderAtomicInt64 khr_shader_atomic_int64;
+  VkJsonKHRShaderClock khr_shader_clock;
+  VkJsonKHRShaderExpectAssume khr_shader_expect_assume;
+  VkJsonKHRShaderFloat16Int8 khr_shader_float16_int8;
   VkJsonKHRShaderFloatControls khr_shader_float_controls;
-  VkJsonKHRDriverProperties khr_driver_properties;
+  VkJsonKHRShaderFloatControls2 khr_shader_float_controls2;
+  VkJsonKHRShaderIntegerDotProduct khr_shader_integer_dot_product;
+  VkJsonKHRShaderMaximalReconvergence khr_shader_maximal_reconvergence;
+  VkJsonKHRShaderQuadControl khr_shader_quad_control;
+  VkJsonKHRShaderRelaxedExtendedInstruction
+      khr_shader_relaxed_extended_instruction;
+  VkJsonKHRShaderSubgroupExtendedTypes khr_shader_subgroup_extended_types;
+  VkJsonKHRShaderSubgroupRotate khr_shader_subgroup_rotate;
+  VkJsonKHRShaderSubgroupUniformControlFlow
+      khr_shader_subgroup_uniform_control_flow;
+  VkJsonKHRShaderTerminateInvocation khr_shader_terminate_invocation;
+  VkJsonKHRSynchronization2 khr_synchronization2;
+  VkJsonKHRTimelineSemaphore khr_timeline_semaphore;
+  VkJsonKHRUniformBufferStandardLayout khr_uniform_buffer_standard_layout;
+  VkJsonKHRVariablePointers khr_variable_pointers;
+  VkJsonKHRVertexAttributeDivisor khr_vertex_attribute_divisor;
+  VkJsonKHRVideoMaintenance1 khr_video_maintenance1;
+  VkJsonKHRVulkanMemoryModel khr_vulkan_memory_model;
+  VkJsonKHRWorkgroupMemoryExplicitLayout khr_workgroup_memory_explicit_layout;
+  VkJsonKHRZeroInitializeWorkgroupMemory khr_zero_initialize_workgroup_memory;
+  VkJsonMESAImageAlignmentControl mesa_image_alignment_control;
+  VkJsonMSFTLayeredDriver msft_layered_driver;
+  VkJsonNVXMultiviewPerViewAttributes nvx_multiview_per_view_attributes;
+  VkJsonNVCommandBufferInheritance nv_command_buffer_inheritance;
+  VkJsonNVComputeShaderDerivatives nv_compute_shader_derivatives;
+  VkJsonNVCooperativeMatrix nv_cooperative_matrix;
+  VkJsonNVCopyMemoryIndirect nv_copy_memory_indirect;
+  VkJsonNVCornerSampledImage nv_corner_sampled_image;
+  VkJsonNVCoverageReductionMode nv_coverage_reduction_mode;
+  VkJsonNVCudaKernelLaunch nv_cuda_kernel_launch;
+  VkJsonNVDedicatedAllocationImageAliasing
+      nv_dedicated_allocation_image_aliasing;
+  VkJsonNVDescriptorPoolOverallocation nv_descriptor_pool_overallocation;
+  VkJsonNVDeviceDiagnosticsConfig nv_device_diagnostics_config;
+  VkJsonNVDeviceGeneratedCommands nv_device_generated_commands;
+  VkJsonNVDeviceGeneratedCommandsCompute nv_device_generated_commands_compute;
+  VkJsonNVExtendedSparseAddressSpace nv_extended_sparse_address_space;
+  VkJsonNVExternalMemoryRdma nv_external_memory_rdma;
+  VkJsonNVFragmentShadingRateEnums nv_fragment_shading_rate_enums;
+  VkJsonNVInheritedViewportScissor nv_inherited_viewport_scissor;
+  VkJsonNVLinearColorAttachment nv_linear_color_attachment;
+  VkJsonNVMemoryDecompression nv_memory_decompression;
+  VkJsonNVMeshShader nv_mesh_shader;
+  VkJsonNVOpticalFlow nv_optical_flow;
+  VkJsonNVPerStageDescriptorSet nv_per_stage_descriptor_set;
+  VkJsonNVPresentBarrier nv_present_barrier;
+  VkJsonNVRawAccessChains nv_raw_access_chains;
+  VkJsonNVRayTracing nv_ray_tracing;
+  VkJsonNVRayTracingInvocationReorder nv_ray_tracing_invocation_reorder;
+  VkJsonNVRayTracingMotionBlur nv_ray_tracing_motion_blur;
+  VkJsonNVRayTracingValidation nv_ray_tracing_validation;
+  VkJsonNVRepresentativeFragmentTest nv_representative_fragment_test;
+  VkJsonNVScissorExclusive nv_scissor_exclusive;
+  VkJsonNVShaderAtomicFloat16Vector nv_shader_atomic_float16_vector;
+  VkJsonNVShaderImageFootprint nv_shader_image_footprint;
+  VkJsonNVShaderSmBuiltins nv_shader_sm_builtins;
+  VkJsonNVShadingRateImage nv_shading_rate_image;
+  VkJsonQCOMFilterCubicClamp qcom_filter_cubic_clamp;
+  VkJsonQCOMFilterCubicWeights qcom_filter_cubic_weights;
+  VkJsonQCOMFragmentDensityMapOffset qcom_fragment_density_map_offset;
+  VkJsonQCOMImageProcessing qcom_image_processing;
+  VkJsonQCOMImageProcessing2 qcom_image_processing2;
+  VkJsonQCOMMultiviewPerViewRenderAreas qcom_multiview_per_view_render_areas;
+  VkJsonQCOMMultiviewPerViewViewports qcom_multiview_per_view_viewports;
+  VkJsonQCOMTileProperties qcom_tile_properties;
+  VkJsonQCOMYcbcrDegamma qcom_ycbcr_degamma;
+  VkJsonSECAmigoProfiling sec_amigo_profiling;
+  VkJsonVALVEDescriptorSetHostMapping valve_descriptor_set_host_mapping;
+  VkJsonVALVEMutableDescriptorType valve_mutable_descriptor_type;
   VkJsonCore11 core11;
   VkJsonCore12 core12;
   VkJsonCore13 core13;
   VkJsonCore14 core14;
-  VkPhysicalDeviceProperties properties;
-  VkPhysicalDeviceFeatures features;
-  VkPhysicalDeviceMemoryProperties memory;
-  VkPhysicalDeviceSubgroupProperties subgroup_properties;
-  VkPhysicalDevicePointClippingProperties point_clipping_properties;
-  VkPhysicalDeviceMultiviewProperties multiview_properties;
+  VkPhysicalDevice16BitStorageFeatures bit16_storage_features;
+  VkPhysicalDevice8BitStorageFeatures bit8_storage_features;
+  VkPhysicalDeviceBufferDeviceAddressFeatures buffer_device_address_features;
+  VkPhysicalDeviceDepthStencilResolveProperties
+      depth_stencil_resolve_properties;
+  VkPhysicalDeviceDescriptorIndexingFeatures descriptor_indexing_features;
+  VkPhysicalDeviceDescriptorIndexingProperties descriptor_indexing_properties;
+  VkPhysicalDeviceDriverProperties driver_properties;
+  VkPhysicalDeviceDynamicRenderingFeatures dynamic_rendering_features;
+  VkPhysicalDeviceDynamicRenderingLocalReadFeatures
+      dynamic_rendering_local_read_features;
+  VkPhysicalDeviceFloatControlsProperties float_controls_properties;
+  VkPhysicalDeviceGlobalPriorityQueryFeatures global_priority_query_features;
+  VkPhysicalDeviceHostImageCopyFeatures host_image_copy_features;
+  VkPhysicalDeviceHostQueryResetFeatures host_query_reset_features;
   VkPhysicalDeviceIDProperties id_properties;
+  VkPhysicalDeviceImageRobustnessFeatures image_robustness_features;
+  VkPhysicalDeviceImagelessFramebufferFeatures imageless_framebuffer_features;
+  VkPhysicalDeviceIndexTypeUint8Features index_type_uint8_features;
+  VkPhysicalDeviceInlineUniformBlockFeatures inline_uniform_block_features;
+  VkPhysicalDeviceInlineUniformBlockProperties inline_uniform_block_properties;
+  VkPhysicalDeviceLineRasterizationFeatures line_rasterization_features;
+  VkPhysicalDeviceLineRasterizationProperties line_rasterization_properties;
   VkPhysicalDeviceMaintenance3Properties maintenance3_properties;
-  VkPhysicalDevice16BitStorageFeatures bit16_storage_features;
+  VkPhysicalDeviceMaintenance4Features maintenance4_features;
+  VkPhysicalDeviceMaintenance4Properties maintenance4_properties;
+  VkPhysicalDeviceMaintenance5Features maintenance5_features;
+  VkPhysicalDeviceMaintenance5Properties maintenance5_properties;
+  VkPhysicalDeviceMaintenance6Features maintenance6_features;
+  VkPhysicalDeviceMaintenance6Properties maintenance6_properties;
   VkPhysicalDeviceMultiviewFeatures multiview_features;
-  VkPhysicalDeviceVariablePointersFeatures variable_pointers_features;
+  VkPhysicalDeviceMultiviewProperties multiview_properties;
+  VkPhysicalDevicePipelineCreationCacheControlFeatures
+      pipeline_creation_cache_control_features;
+  VkPhysicalDevicePipelineProtectedAccessFeatures
+      pipeline_protected_access_features;
+  VkPhysicalDevicePipelineRobustnessFeatures pipeline_robustness_features;
+  VkPhysicalDevicePipelineRobustnessProperties pipeline_robustness_properties;
+  VkPhysicalDevicePointClippingProperties point_clipping_properties;
+  VkPhysicalDevicePrivateDataFeatures private_data_features;
   VkPhysicalDeviceProtectedMemoryFeatures protected_memory_features;
+  VkPhysicalDeviceProtectedMemoryProperties protected_memory_properties;
+  VkPhysicalDevicePushDescriptorProperties push_descriptor_properties;
+  VkPhysicalDeviceSamplerFilterMinmaxProperties
+      sampler_filter_minmax_properties;
   VkPhysicalDeviceSamplerYcbcrConversionFeatures
       sampler_ycbcr_conversion_features;
+  VkPhysicalDeviceScalarBlockLayoutFeatures scalar_block_layout_features;
+  VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures
+      separate_depth_stencil_layouts_features;
+  VkPhysicalDeviceShaderAtomicInt64Features shader_atomic_int64_features;
+  VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures
+      shader_demote_to_helper_invocation_features;
   VkPhysicalDeviceShaderDrawParameterFeatures shader_draw_parameter_features;
+  VkPhysicalDeviceShaderDrawParametersFeatures shader_draw_parameters_features;
+  VkPhysicalDeviceShaderExpectAssumeFeatures shader_expect_assume_features;
+  VkPhysicalDeviceShaderFloat16Int8Features shader_float16_int8_features;
+  VkPhysicalDeviceShaderFloatControls2Features shader_float_controls2_features;
+  VkPhysicalDeviceShaderIntegerDotProductFeatures
+      shader_integer_dot_product_features;
+  VkPhysicalDeviceShaderIntegerDotProductProperties
+      shader_integer_dot_product_properties;
+  VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures
+      shader_subgroup_extended_types_features;
+  VkPhysicalDeviceShaderSubgroupRotateFeatures shader_subgroup_rotate_features;
+  VkPhysicalDeviceShaderTerminateInvocationFeatures
+      shader_terminate_invocation_features;
+  VkPhysicalDeviceSubgroupProperties subgroup_properties;
+  VkPhysicalDeviceSubgroupSizeControlFeatures subgroup_size_control_features;
+  VkPhysicalDeviceSubgroupSizeControlProperties
+      subgroup_size_control_properties;
+  VkPhysicalDeviceSynchronization2Features synchronization2_features;
+  VkPhysicalDeviceTexelBufferAlignmentProperties
+      texel_buffer_alignment_properties;
+  VkPhysicalDeviceTextureCompressionASTCHDRFeatures
+      texture_compression_astchdr_features;
+  VkPhysicalDeviceTimelineSemaphoreFeatures timeline_semaphore_features;
+  VkPhysicalDeviceTimelineSemaphoreProperties timeline_semaphore_properties;
+  VkPhysicalDeviceUniformBufferStandardLayoutFeatures
+      uniform_buffer_standard_layout_features;
+  VkPhysicalDeviceVariablePointerFeatures variable_pointer_features;
+  VkPhysicalDeviceVariablePointersFeatures variable_pointers_features;
+  VkPhysicalDeviceVertexAttributeDivisorFeatures
+      vertex_attribute_divisor_features;
+  VkPhysicalDeviceVertexAttributeDivisorProperties
+      vertex_attribute_divisor_properties;
+  VkPhysicalDeviceVulkanMemoryModelFeatures vulkan_memory_model_features;
+  VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures
+      zero_initialize_workgroup_memory_features;
+  VkPhysicalDeviceProperties properties;
+  VkPhysicalDeviceFeatures features;
+  VkPhysicalDeviceMemoryProperties memory;
   std::vector<VkQueueFamilyProperties> queues;
   std::vector<VkExtensionProperties> extensions;
   std::vector<VkLayerProperties> layers;
diff --git a/vulkan/vkjson/vkjson_instance.cc b/vulkan/vkjson/vkjson_instance.cc
index 636c11933a..d13aa26073 100644
--- a/vulkan/vkjson/vkjson_instance.cc
+++ b/vulkan/vkjson/vkjson_instance.cc
@@ -83,6 +83,626 @@ VkJsonDevice VkJsonGetDevice(VkPhysicalDevice physical_device) {
       {},
   };
 
+  if (HasExtension("VK_AMD_shader_core_properties", device.extensions)) {
+    device.amd_shader_core_properties.reported = true;
+    device.amd_shader_core_properties.shader_core_properties_amd.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD;
+    device.amd_shader_core_properties.shader_core_properties_amd.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.amd_shader_core_properties.shader_core_properties_amd;
+  }
+
+  if (HasExtension("VK_AMD_shader_core_properties2", device.extensions)) {
+    device.amd_shader_core_properties2.reported = true;
+    device.amd_shader_core_properties2.shader_core_properties2_amd.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD;
+    device.amd_shader_core_properties2.shader_core_properties2_amd.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.amd_shader_core_properties2.shader_core_properties2_amd;
+  }
+
+  if (HasExtension("VK_ANDROID_external_format_resolve", device.extensions)) {
+    device.android_external_format_resolve.reported = true;
+    device.android_external_format_resolve
+        .external_format_resolve_properties_android.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID;
+    device.android_external_format_resolve
+        .external_format_resolve_properties_android.pNext = properties.pNext;
+    properties.pNext = &device.android_external_format_resolve
+                            .external_format_resolve_properties_android;
+  }
+
+  if (HasExtension("VK_ARM_render_pass_striped", device.extensions)) {
+    device.arm_render_pass_striped.reported = true;
+    device.arm_render_pass_striped.render_pass_striped_properties_arm.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM;
+    device.arm_render_pass_striped.render_pass_striped_properties_arm.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.arm_render_pass_striped.render_pass_striped_properties_arm;
+  }
+
+  if (HasExtension("VK_ARM_scheduling_controls", device.extensions)) {
+    device.arm_scheduling_controls.reported = true;
+    device.arm_scheduling_controls.scheduling_controls_properties_arm.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM;
+    device.arm_scheduling_controls.scheduling_controls_properties_arm.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.arm_scheduling_controls.scheduling_controls_properties_arm;
+  }
+
+  if (HasExtension("VK_ARM_shader_core_builtins", device.extensions)) {
+    device.arm_shader_core_builtins.reported = true;
+    device.arm_shader_core_builtins.shader_core_builtins_properties_arm.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM;
+    device.arm_shader_core_builtins.shader_core_builtins_properties_arm.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.arm_shader_core_builtins.shader_core_builtins_properties_arm;
+  }
+
+  if (HasExtension("VK_ARM_shader_core_properties", device.extensions)) {
+    device.arm_shader_core_properties.reported = true;
+    device.arm_shader_core_properties.shader_core_properties_arm.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM;
+    device.arm_shader_core_properties.shader_core_properties_arm.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.arm_shader_core_properties.shader_core_properties_arm;
+  }
+
+  if (HasExtension("VK_EXT_blend_operation_advanced", device.extensions)) {
+    device.ext_blend_operation_advanced.reported = true;
+    device.ext_blend_operation_advanced.blend_operation_advanced_properties_ext
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT;
+    device.ext_blend_operation_advanced.blend_operation_advanced_properties_ext
+        .pNext = properties.pNext;
+    properties.pNext = &device.ext_blend_operation_advanced
+                            .blend_operation_advanced_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_conservative_rasterization", device.extensions)) {
+    device.ext_conservative_rasterization.reported = true;
+    device.ext_conservative_rasterization
+        .conservative_rasterization_properties_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT;
+    device.ext_conservative_rasterization
+        .conservative_rasterization_properties_ext.pNext = properties.pNext;
+    properties.pNext = &device.ext_conservative_rasterization
+                            .conservative_rasterization_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_custom_border_color", device.extensions)) {
+    device.ext_custom_border_color.reported = true;
+    device.ext_custom_border_color.custom_border_color_properties_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT;
+    device.ext_custom_border_color.custom_border_color_properties_ext.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.ext_custom_border_color.custom_border_color_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_descriptor_buffer", device.extensions)) {
+    device.ext_descriptor_buffer.reported = true;
+    device.ext_descriptor_buffer.descriptor_buffer_properties_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT;
+    device.ext_descriptor_buffer.descriptor_buffer_properties_ext.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.ext_descriptor_buffer.descriptor_buffer_properties_ext;
+    device.ext_descriptor_buffer.descriptor_buffer_density_map_properties_ext
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT;
+    device.ext_descriptor_buffer.descriptor_buffer_density_map_properties_ext
+        .pNext = properties.pNext;
+    properties.pNext = &device.ext_descriptor_buffer
+                            .descriptor_buffer_density_map_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_descriptor_indexing", device.extensions)) {
+    device.ext_descriptor_indexing.reported = true;
+    device.ext_descriptor_indexing.descriptor_indexing_properties_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES;
+    device.ext_descriptor_indexing.descriptor_indexing_properties_ext.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.ext_descriptor_indexing.descriptor_indexing_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_discard_rectangles", device.extensions)) {
+    device.ext_discard_rectangles.reported = true;
+    device.ext_discard_rectangles.discard_rectangle_properties_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT;
+    device.ext_discard_rectangles.discard_rectangle_properties_ext.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.ext_discard_rectangles.discard_rectangle_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_extended_dynamic_state3", device.extensions)) {
+    device.ext_extended_dynamic_state3.reported = true;
+    device.ext_extended_dynamic_state3.extended_dynamic_state3_properties_ext
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT;
+    device.ext_extended_dynamic_state3.extended_dynamic_state3_properties_ext
+        .pNext = properties.pNext;
+    properties.pNext = &device.ext_extended_dynamic_state3
+                            .extended_dynamic_state3_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_external_memory_host", device.extensions)) {
+    device.ext_external_memory_host.reported = true;
+    device.ext_external_memory_host.external_memory_host_properties_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT;
+    device.ext_external_memory_host.external_memory_host_properties_ext.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.ext_external_memory_host.external_memory_host_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_fragment_density_map", device.extensions)) {
+    device.ext_fragment_density_map.reported = true;
+    device.ext_fragment_density_map.fragment_density_map_properties_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT;
+    device.ext_fragment_density_map.fragment_density_map_properties_ext.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.ext_fragment_density_map.fragment_density_map_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_fragment_density_map2", device.extensions)) {
+    device.ext_fragment_density_map2.reported = true;
+    device.ext_fragment_density_map2.fragment_density_map2_properties_ext
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT;
+    device.ext_fragment_density_map2.fragment_density_map2_properties_ext
+        .pNext = properties.pNext;
+    properties.pNext =
+        &device.ext_fragment_density_map2.fragment_density_map2_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_graphics_pipeline_library", device.extensions)) {
+    device.ext_graphics_pipeline_library.reported = true;
+    device.ext_graphics_pipeline_library
+        .graphics_pipeline_library_properties_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT;
+    device.ext_graphics_pipeline_library
+        .graphics_pipeline_library_properties_ext.pNext = properties.pNext;
+    properties.pNext = &device.ext_graphics_pipeline_library
+                            .graphics_pipeline_library_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_inline_uniform_block", device.extensions)) {
+    device.ext_inline_uniform_block.reported = true;
+    device.ext_inline_uniform_block.inline_uniform_block_properties_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES;
+    device.ext_inline_uniform_block.inline_uniform_block_properties_ext.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.ext_inline_uniform_block.inline_uniform_block_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_legacy_vertex_attributes", device.extensions)) {
+    device.ext_legacy_vertex_attributes.reported = true;
+    device.ext_legacy_vertex_attributes.legacy_vertex_attributes_properties_ext
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT;
+    device.ext_legacy_vertex_attributes.legacy_vertex_attributes_properties_ext
+        .pNext = properties.pNext;
+    properties.pNext = &device.ext_legacy_vertex_attributes
+                            .legacy_vertex_attributes_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_line_rasterization", device.extensions)) {
+    device.ext_line_rasterization.reported = true;
+    device.ext_line_rasterization.line_rasterization_properties_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES;
+    device.ext_line_rasterization.line_rasterization_properties_ext.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.ext_line_rasterization.line_rasterization_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_map_memory_placed", device.extensions)) {
+    device.ext_map_memory_placed.reported = true;
+    device.ext_map_memory_placed.map_memory_placed_properties_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT;
+    device.ext_map_memory_placed.map_memory_placed_properties_ext.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.ext_map_memory_placed.map_memory_placed_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_mesh_shader", device.extensions)) {
+    device.ext_mesh_shader.reported = true;
+    device.ext_mesh_shader.mesh_shader_properties_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT;
+    device.ext_mesh_shader.mesh_shader_properties_ext.pNext = properties.pNext;
+    properties.pNext = &device.ext_mesh_shader.mesh_shader_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_multi_draw", device.extensions)) {
+    device.ext_multi_draw.reported = true;
+    device.ext_multi_draw.multi_draw_properties_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT;
+    device.ext_multi_draw.multi_draw_properties_ext.pNext = properties.pNext;
+    properties.pNext = &device.ext_multi_draw.multi_draw_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_nested_command_buffer", device.extensions)) {
+    device.ext_nested_command_buffer.reported = true;
+    device.ext_nested_command_buffer.nested_command_buffer_properties_ext
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT;
+    device.ext_nested_command_buffer.nested_command_buffer_properties_ext
+        .pNext = properties.pNext;
+    properties.pNext =
+        &device.ext_nested_command_buffer.nested_command_buffer_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_opacity_micromap", device.extensions)) {
+    device.ext_opacity_micromap.reported = true;
+    device.ext_opacity_micromap.opacity_micromap_properties_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT;
+    device.ext_opacity_micromap.opacity_micromap_properties_ext.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.ext_opacity_micromap.opacity_micromap_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_pci_bus_info", device.extensions)) {
+    device.ext_pci_bus_info.reported = true;
+    device.ext_pci_bus_info.pci_bus_info_properties_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT;
+    device.ext_pci_bus_info.pci_bus_info_properties_ext.pNext =
+        properties.pNext;
+    properties.pNext = &device.ext_pci_bus_info.pci_bus_info_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_physical_device_drm", device.extensions)) {
+    device.ext_physical_device_drm.reported = true;
+    device.ext_physical_device_drm.drm_properties_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT;
+    device.ext_physical_device_drm.drm_properties_ext.pNext = properties.pNext;
+    properties.pNext = &device.ext_physical_device_drm.drm_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_pipeline_robustness", device.extensions)) {
+    device.ext_pipeline_robustness.reported = true;
+    device.ext_pipeline_robustness.pipeline_robustness_properties_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES;
+    device.ext_pipeline_robustness.pipeline_robustness_properties_ext.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.ext_pipeline_robustness.pipeline_robustness_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_provoking_vertex", device.extensions)) {
+    device.ext_provoking_vertex.reported = true;
+    device.ext_provoking_vertex.provoking_vertex_properties_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT;
+    device.ext_provoking_vertex.provoking_vertex_properties_ext.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.ext_provoking_vertex.provoking_vertex_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_robustness2", device.extensions)) {
+    device.ext_robustness2.reported = true;
+    device.ext_robustness2.robustness2_properties_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT;
+    device.ext_robustness2.robustness2_properties_ext.pNext = properties.pNext;
+    properties.pNext = &device.ext_robustness2.robustness2_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_sample_locations", device.extensions)) {
+    device.ext_sample_locations.reported = true;
+    device.ext_sample_locations.sample_locations_properties_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT;
+    device.ext_sample_locations.sample_locations_properties_ext.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.ext_sample_locations.sample_locations_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_sampler_filter_minmax", device.extensions)) {
+    device.ext_sampler_filter_minmax.reported = true;
+    device.ext_sampler_filter_minmax.sampler_filter_minmax_properties_ext
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES;
+    device.ext_sampler_filter_minmax.sampler_filter_minmax_properties_ext
+        .pNext = properties.pNext;
+    properties.pNext =
+        &device.ext_sampler_filter_minmax.sampler_filter_minmax_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_shader_module_identifier", device.extensions)) {
+    device.ext_shader_module_identifier.reported = true;
+    device.ext_shader_module_identifier.shader_module_identifier_properties_ext
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT;
+    device.ext_shader_module_identifier.shader_module_identifier_properties_ext
+        .pNext = properties.pNext;
+    properties.pNext = &device.ext_shader_module_identifier
+                            .shader_module_identifier_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_shader_object", device.extensions)) {
+    device.ext_shader_object.reported = true;
+    device.ext_shader_object.shader_object_properties_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT;
+    device.ext_shader_object.shader_object_properties_ext.pNext =
+        properties.pNext;
+    properties.pNext = &device.ext_shader_object.shader_object_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_shader_tile_image", device.extensions)) {
+    device.ext_shader_tile_image.reported = true;
+    device.ext_shader_tile_image.shader_tile_image_properties_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT;
+    device.ext_shader_tile_image.shader_tile_image_properties_ext.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.ext_shader_tile_image.shader_tile_image_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_subgroup_size_control", device.extensions)) {
+    device.ext_subgroup_size_control.reported = true;
+    device.ext_subgroup_size_control.subgroup_size_control_properties_ext
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES;
+    device.ext_subgroup_size_control.subgroup_size_control_properties_ext
+        .pNext = properties.pNext;
+    properties.pNext =
+        &device.ext_subgroup_size_control.subgroup_size_control_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_texel_buffer_alignment", device.extensions)) {
+    device.ext_texel_buffer_alignment.reported = true;
+    device.ext_texel_buffer_alignment.texel_buffer_alignment_properties_ext
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES;
+    device.ext_texel_buffer_alignment.texel_buffer_alignment_properties_ext
+        .pNext = properties.pNext;
+    properties.pNext = &device.ext_texel_buffer_alignment
+                            .texel_buffer_alignment_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_transform_feedback", device.extensions)) {
+    device.ext_transform_feedback.reported = true;
+    device.ext_transform_feedback.transform_feedback_properties_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT;
+    device.ext_transform_feedback.transform_feedback_properties_ext.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.ext_transform_feedback.transform_feedback_properties_ext;
+  }
+
+  if (HasExtension("VK_EXT_vertex_attribute_divisor", device.extensions)) {
+    device.ext_vertex_attribute_divisor.reported = true;
+    device.ext_vertex_attribute_divisor.vertex_attribute_divisor_properties_ext
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT;
+    device.ext_vertex_attribute_divisor.vertex_attribute_divisor_properties_ext
+        .pNext = properties.pNext;
+    properties.pNext = &device.ext_vertex_attribute_divisor
+                            .vertex_attribute_divisor_properties_ext;
+  }
+
+  if (HasExtension("VK_HUAWEI_cluster_culling_shader", device.extensions)) {
+    device.huawei_cluster_culling_shader.reported = true;
+    device.huawei_cluster_culling_shader
+        .cluster_culling_shader_properties_huawei.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI;
+    device.huawei_cluster_culling_shader
+        .cluster_culling_shader_properties_huawei.pNext = properties.pNext;
+    properties.pNext = &device.huawei_cluster_culling_shader
+                            .cluster_culling_shader_properties_huawei;
+  }
+
+  if (HasExtension("VK_HUAWEI_subpass_shading", device.extensions)) {
+    device.huawei_subpass_shading.reported = true;
+    device.huawei_subpass_shading.subpass_shading_properties_huawei.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI;
+    device.huawei_subpass_shading.subpass_shading_properties_huawei.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.huawei_subpass_shading.subpass_shading_properties_huawei;
+  }
+
+  if (HasExtension("VK_KHR_acceleration_structure", device.extensions)) {
+    device.khr_acceleration_structure.reported = true;
+    device.khr_acceleration_structure.acceleration_structure_properties_khr
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR;
+    device.khr_acceleration_structure.acceleration_structure_properties_khr
+        .pNext = properties.pNext;
+    properties.pNext = &device.khr_acceleration_structure
+                            .acceleration_structure_properties_khr;
+  }
+
+  if (HasExtension("VK_KHR_cooperative_matrix", device.extensions)) {
+    device.khr_cooperative_matrix.reported = true;
+    device.khr_cooperative_matrix.cooperative_matrix_properties_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR;
+    device.khr_cooperative_matrix.cooperative_matrix_properties_khr.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.khr_cooperative_matrix.cooperative_matrix_properties_khr;
+  }
+
+  if (HasExtension("VK_KHR_depth_stencil_resolve", device.extensions)) {
+    device.khr_depth_stencil_resolve.reported = true;
+    device.khr_depth_stencil_resolve.depth_stencil_resolve_properties_khr
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES;
+    device.khr_depth_stencil_resolve.depth_stencil_resolve_properties_khr
+        .pNext = properties.pNext;
+    properties.pNext =
+        &device.khr_depth_stencil_resolve.depth_stencil_resolve_properties_khr;
+  }
+
+  if (HasExtension("VK_KHR_driver_properties", device.extensions)) {
+    device.khr_driver_properties.reported = true;
+    device.khr_driver_properties.driver_properties_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES;
+    device.khr_driver_properties.driver_properties_khr.pNext = properties.pNext;
+    properties.pNext = &device.khr_driver_properties.driver_properties_khr;
+  }
+
+  if (HasExtension("VK_KHR_external_memory_capabilities", device.extensions)) {
+    device.khr_external_memory_capabilities.reported = true;
+    device.khr_external_memory_capabilities.id_properties_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES;
+    device.khr_external_memory_capabilities.id_properties_khr.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.khr_external_memory_capabilities.id_properties_khr;
+  }
+
+  if (HasExtension("VK_KHR_fragment_shader_barycentric", device.extensions)) {
+    device.khr_fragment_shader_barycentric.reported = true;
+    device.khr_fragment_shader_barycentric
+        .fragment_shader_barycentric_properties_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR;
+    device.khr_fragment_shader_barycentric
+        .fragment_shader_barycentric_properties_khr.pNext = properties.pNext;
+    properties.pNext = &device.khr_fragment_shader_barycentric
+                            .fragment_shader_barycentric_properties_khr;
+  }
+
+  if (HasExtension("VK_KHR_fragment_shading_rate", device.extensions)) {
+    device.khr_fragment_shading_rate.reported = true;
+    device.khr_fragment_shading_rate.fragment_shading_rate_properties_khr
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR;
+    device.khr_fragment_shading_rate.fragment_shading_rate_properties_khr
+        .pNext = properties.pNext;
+    properties.pNext =
+        &device.khr_fragment_shading_rate.fragment_shading_rate_properties_khr;
+  }
+
+  if (HasExtension("VK_KHR_line_rasterization", device.extensions)) {
+    device.khr_line_rasterization.reported = true;
+    device.khr_line_rasterization.line_rasterization_properties_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES;
+    device.khr_line_rasterization.line_rasterization_properties_khr.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.khr_line_rasterization.line_rasterization_properties_khr;
+  }
+
+  if (HasExtension("VK_KHR_maintenance2", device.extensions)) {
+    device.khr_maintenance2.reported = true;
+    device.khr_maintenance2.point_clipping_properties_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES;
+    device.khr_maintenance2.point_clipping_properties_khr.pNext =
+        properties.pNext;
+    properties.pNext = &device.khr_maintenance2.point_clipping_properties_khr;
+  }
+
+  if (HasExtension("VK_KHR_maintenance3", device.extensions)) {
+    device.khr_maintenance3.reported = true;
+    device.khr_maintenance3.maintenance3_properties_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES;
+    device.khr_maintenance3.maintenance3_properties_khr.pNext =
+        properties.pNext;
+    properties.pNext = &device.khr_maintenance3.maintenance3_properties_khr;
+  }
+
+  if (HasExtension("VK_KHR_maintenance4", device.extensions)) {
+    device.khr_maintenance4.reported = true;
+    device.khr_maintenance4.maintenance4_properties_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES;
+    device.khr_maintenance4.maintenance4_properties_khr.pNext =
+        properties.pNext;
+    properties.pNext = &device.khr_maintenance4.maintenance4_properties_khr;
+  }
+
+  if (HasExtension("VK_KHR_maintenance5", device.extensions)) {
+    device.khr_maintenance5.reported = true;
+    device.khr_maintenance5.maintenance5_properties_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES;
+    device.khr_maintenance5.maintenance5_properties_khr.pNext =
+        properties.pNext;
+    properties.pNext = &device.khr_maintenance5.maintenance5_properties_khr;
+  }
+
+  if (HasExtension("VK_KHR_maintenance6", device.extensions)) {
+    device.khr_maintenance6.reported = true;
+    device.khr_maintenance6.maintenance6_properties_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES;
+    device.khr_maintenance6.maintenance6_properties_khr.pNext =
+        properties.pNext;
+    properties.pNext = &device.khr_maintenance6.maintenance6_properties_khr;
+  }
+
+  if (HasExtension("VK_KHR_maintenance7", device.extensions)) {
+    device.khr_maintenance7.reported = true;
+    device.khr_maintenance7.maintenance7_properties_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR;
+    device.khr_maintenance7.maintenance7_properties_khr.pNext =
+        properties.pNext;
+    properties.pNext = &device.khr_maintenance7.maintenance7_properties_khr;
+    device.khr_maintenance7.layered_api_properties_list_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR;
+    device.khr_maintenance7.layered_api_properties_list_khr.pNext =
+        properties.pNext;
+    properties.pNext = &device.khr_maintenance7.layered_api_properties_list_khr;
+  }
+
+  if (HasExtension("VK_KHR_multiview", device.extensions)) {
+    device.khr_multiview.reported = true;
+    device.khr_multiview.multiview_properties_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES;
+    device.khr_multiview.multiview_properties_khr.pNext = properties.pNext;
+    properties.pNext = &device.khr_multiview.multiview_properties_khr;
+  }
+
+  if (HasExtension("VK_KHR_performance_query", device.extensions)) {
+    device.khr_performance_query.reported = true;
+    device.khr_performance_query.performance_query_properties_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR;
+    device.khr_performance_query.performance_query_properties_khr.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.khr_performance_query.performance_query_properties_khr;
+  }
+
+  if (HasExtension("VK_KHR_pipeline_binary", device.extensions)) {
+    device.khr_pipeline_binary.reported = true;
+    device.khr_pipeline_binary.pipeline_binary_properties_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR;
+    device.khr_pipeline_binary.pipeline_binary_properties_khr.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.khr_pipeline_binary.pipeline_binary_properties_khr;
+  }
+
+  if (HasExtension("VK_KHR_push_descriptor", device.extensions)) {
+    device.khr_push_descriptor.reported = true;
+    device.khr_push_descriptor.push_descriptor_properties_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES;
+    device.khr_push_descriptor.push_descriptor_properties_khr.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.khr_push_descriptor.push_descriptor_properties_khr;
+  }
+
+  if (HasExtension("VK_KHR_ray_tracing_pipeline", device.extensions)) {
+    device.khr_ray_tracing_pipeline.reported = true;
+    device.khr_ray_tracing_pipeline.ray_tracing_pipeline_properties_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR;
+    device.khr_ray_tracing_pipeline.ray_tracing_pipeline_properties_khr.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.khr_ray_tracing_pipeline.ray_tracing_pipeline_properties_khr;
+  }
+
   if (HasExtension("VK_KHR_shader_float_controls", device.extensions)) {
     device.khr_shader_float_controls.reported = true;
     device.khr_shader_float_controls.float_controls_properties_khr.sType =
@@ -93,37 +713,1540 @@ VkJsonDevice VkJsonGetDevice(VkPhysicalDevice physical_device) {
         &device.khr_shader_float_controls.float_controls_properties_khr;
   }
 
-  if (HasExtension("VK_KHR_driver_properties", device.extensions)) {
-    device.khr_driver_properties.reported = true;
-    device.khr_driver_properties.driver_properties_khr.sType =
-        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES;
-    device.khr_driver_properties.driver_properties_khr.pNext = properties.pNext;
-    properties.pNext = &device.khr_driver_properties.driver_properties_khr;
+  if (HasExtension("VK_KHR_shader_integer_dot_product", device.extensions)) {
+    device.khr_shader_integer_dot_product.reported = true;
+    device.khr_shader_integer_dot_product
+        .shader_integer_dot_product_properties_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES;
+    device.khr_shader_integer_dot_product
+        .shader_integer_dot_product_properties_khr.pNext = properties.pNext;
+    properties.pNext = &device.khr_shader_integer_dot_product
+                            .shader_integer_dot_product_properties_khr;
+  }
+
+  if (HasExtension("VK_KHR_timeline_semaphore", device.extensions)) {
+    device.khr_timeline_semaphore.reported = true;
+    device.khr_timeline_semaphore.timeline_semaphore_properties_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES;
+    device.khr_timeline_semaphore.timeline_semaphore_properties_khr.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.khr_timeline_semaphore.timeline_semaphore_properties_khr;
+  }
+
+  if (HasExtension("VK_KHR_vertex_attribute_divisor", device.extensions)) {
+    device.khr_vertex_attribute_divisor.reported = true;
+    device.khr_vertex_attribute_divisor.vertex_attribute_divisor_properties_khr
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES;
+    device.khr_vertex_attribute_divisor.vertex_attribute_divisor_properties_khr
+        .pNext = properties.pNext;
+    properties.pNext = &device.khr_vertex_attribute_divisor
+                            .vertex_attribute_divisor_properties_khr;
+  }
+
+  if (HasExtension("VK_MESA_image_alignment_control", device.extensions)) {
+    device.mesa_image_alignment_control.reported = true;
+    device.mesa_image_alignment_control.image_alignment_control_properties_mesa
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA;
+    device.mesa_image_alignment_control.image_alignment_control_properties_mesa
+        .pNext = properties.pNext;
+    properties.pNext = &device.mesa_image_alignment_control
+                            .image_alignment_control_properties_mesa;
+  }
+
+  if (HasExtension("VK_MSFT_layered_driver", device.extensions)) {
+    device.msft_layered_driver.reported = true;
+    device.msft_layered_driver.layered_driver_properties_msft.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT;
+    device.msft_layered_driver.layered_driver_properties_msft.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.msft_layered_driver.layered_driver_properties_msft;
+  }
+
+  if (HasExtension("VK_NVX_multiview_per_view_attributes", device.extensions)) {
+    device.nvx_multiview_per_view_attributes.reported = true;
+    device.nvx_multiview_per_view_attributes
+        .multiview_per_view_attributes_properties_nvx.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX;
+    device.nvx_multiview_per_view_attributes
+        .multiview_per_view_attributes_properties_nvx.pNext = properties.pNext;
+    properties.pNext = &device.nvx_multiview_per_view_attributes
+                            .multiview_per_view_attributes_properties_nvx;
+  }
+
+  if (HasExtension("VK_NV_cooperative_matrix", device.extensions)) {
+    device.nv_cooperative_matrix.reported = true;
+    device.nv_cooperative_matrix.cooperative_matrix_properties_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV;
+    device.nv_cooperative_matrix.cooperative_matrix_properties_nv.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.nv_cooperative_matrix.cooperative_matrix_properties_nv;
+  }
+
+  if (HasExtension("VK_NV_copy_memory_indirect", device.extensions)) {
+    device.nv_copy_memory_indirect.reported = true;
+    device.nv_copy_memory_indirect.copy_memory_indirect_properties_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV;
+    device.nv_copy_memory_indirect.copy_memory_indirect_properties_nv.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.nv_copy_memory_indirect.copy_memory_indirect_properties_nv;
+  }
+
+  if (HasExtension("VK_NV_cuda_kernel_launch", device.extensions)) {
+    device.nv_cuda_kernel_launch.reported = true;
+    device.nv_cuda_kernel_launch.cuda_kernel_launch_properties_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV;
+    device.nv_cuda_kernel_launch.cuda_kernel_launch_properties_nv.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.nv_cuda_kernel_launch.cuda_kernel_launch_properties_nv;
+  }
+
+  if (HasExtension("VK_NV_device_generated_commands", device.extensions)) {
+    device.nv_device_generated_commands.reported = true;
+    device.nv_device_generated_commands.device_generated_commands_properties_nv
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV;
+    device.nv_device_generated_commands.device_generated_commands_properties_nv
+        .pNext = properties.pNext;
+    properties.pNext = &device.nv_device_generated_commands
+                            .device_generated_commands_properties_nv;
+  }
+
+  if (HasExtension("VK_NV_extended_sparse_address_space", device.extensions)) {
+    device.nv_extended_sparse_address_space.reported = true;
+    device.nv_extended_sparse_address_space
+        .extended_sparse_address_space_properties_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV;
+    device.nv_extended_sparse_address_space
+        .extended_sparse_address_space_properties_nv.pNext = properties.pNext;
+    properties.pNext = &device.nv_extended_sparse_address_space
+                            .extended_sparse_address_space_properties_nv;
+  }
+
+  if (HasExtension("VK_NV_fragment_shading_rate_enums", device.extensions)) {
+    device.nv_fragment_shading_rate_enums.reported = true;
+    device.nv_fragment_shading_rate_enums
+        .fragment_shading_rate_enums_properties_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV;
+    device.nv_fragment_shading_rate_enums
+        .fragment_shading_rate_enums_properties_nv.pNext = properties.pNext;
+    properties.pNext = &device.nv_fragment_shading_rate_enums
+                            .fragment_shading_rate_enums_properties_nv;
+  }
+
+  if (HasExtension("VK_NV_memory_decompression", device.extensions)) {
+    device.nv_memory_decompression.reported = true;
+    device.nv_memory_decompression.memory_decompression_properties_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV;
+    device.nv_memory_decompression.memory_decompression_properties_nv.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.nv_memory_decompression.memory_decompression_properties_nv;
+  }
+
+  if (HasExtension("VK_NV_mesh_shader", device.extensions)) {
+    device.nv_mesh_shader.reported = true;
+    device.nv_mesh_shader.mesh_shader_properties_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV;
+    device.nv_mesh_shader.mesh_shader_properties_nv.pNext = properties.pNext;
+    properties.pNext = &device.nv_mesh_shader.mesh_shader_properties_nv;
+  }
+
+  if (HasExtension("VK_NV_optical_flow", device.extensions)) {
+    device.nv_optical_flow.reported = true;
+    device.nv_optical_flow.optical_flow_properties_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV;
+    device.nv_optical_flow.optical_flow_properties_nv.pNext = properties.pNext;
+    properties.pNext = &device.nv_optical_flow.optical_flow_properties_nv;
+  }
+
+  if (HasExtension("VK_NV_ray_tracing", device.extensions)) {
+    device.nv_ray_tracing.reported = true;
+    device.nv_ray_tracing.ray_tracing_properties_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV;
+    device.nv_ray_tracing.ray_tracing_properties_nv.pNext = properties.pNext;
+    properties.pNext = &device.nv_ray_tracing.ray_tracing_properties_nv;
+  }
+
+  if (HasExtension("VK_NV_ray_tracing_invocation_reorder", device.extensions)) {
+    device.nv_ray_tracing_invocation_reorder.reported = true;
+    device.nv_ray_tracing_invocation_reorder
+        .ray_tracing_invocation_reorder_properties_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV;
+    device.nv_ray_tracing_invocation_reorder
+        .ray_tracing_invocation_reorder_properties_nv.pNext = properties.pNext;
+    properties.pNext = &device.nv_ray_tracing_invocation_reorder
+                            .ray_tracing_invocation_reorder_properties_nv;
+  }
+
+  if (HasExtension("VK_NV_shader_sm_builtins", device.extensions)) {
+    device.nv_shader_sm_builtins.reported = true;
+    device.nv_shader_sm_builtins.shader_sm_builtins_properties_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV;
+    device.nv_shader_sm_builtins.shader_sm_builtins_properties_nv.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.nv_shader_sm_builtins.shader_sm_builtins_properties_nv;
+  }
+
+  if (HasExtension("VK_NV_shading_rate_image", device.extensions)) {
+    device.nv_shading_rate_image.reported = true;
+    device.nv_shading_rate_image.shading_rate_image_properties_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV;
+    device.nv_shading_rate_image.shading_rate_image_properties_nv.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.nv_shading_rate_image.shading_rate_image_properties_nv;
+  }
+
+  if (HasExtension("VK_QCOM_fragment_density_map_offset", device.extensions)) {
+    device.qcom_fragment_density_map_offset.reported = true;
+    device.qcom_fragment_density_map_offset
+        .fragment_density_map_offset_properties_qcom.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM;
+    device.qcom_fragment_density_map_offset
+        .fragment_density_map_offset_properties_qcom.pNext = properties.pNext;
+    properties.pNext = &device.qcom_fragment_density_map_offset
+                            .fragment_density_map_offset_properties_qcom;
+  }
+
+  if (HasExtension("VK_QCOM_image_processing", device.extensions)) {
+    device.qcom_image_processing.reported = true;
+    device.qcom_image_processing.image_processing_properties_qcom.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM;
+    device.qcom_image_processing.image_processing_properties_qcom.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.qcom_image_processing.image_processing_properties_qcom;
+  }
+
+  if (HasExtension("VK_QCOM_image_processing2", device.extensions)) {
+    device.qcom_image_processing2.reported = true;
+    device.qcom_image_processing2.image_processing2_properties_qcom.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM;
+    device.qcom_image_processing2.image_processing2_properties_qcom.pNext =
+        properties.pNext;
+    properties.pNext =
+        &device.qcom_image_processing2.image_processing2_properties_qcom;
+  }
+
+  vkGetPhysicalDeviceProperties2(physical_device, &properties);
+  device.properties = properties.properties;
+
+  VkPhysicalDeviceFeatures2 features = {
+      VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
+      nullptr,
+      {},
+  };
+
+  if (HasExtension("VK_AMD_anti_lag", device.extensions)) {
+    device.amd_anti_lag.reported = true;
+    device.amd_anti_lag.anti_lag_features_amd.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD;
+    device.amd_anti_lag.anti_lag_features_amd.pNext = features.pNext;
+    features.pNext = &device.amd_anti_lag.anti_lag_features_amd;
+  }
+
+  if (HasExtension("VK_AMD_device_coherent_memory", device.extensions)) {
+    device.amd_device_coherent_memory.reported = true;
+    device.amd_device_coherent_memory.coherent_memory_features_amd.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD;
+    device.amd_device_coherent_memory.coherent_memory_features_amd.pNext =
+        features.pNext;
+    features.pNext =
+        &device.amd_device_coherent_memory.coherent_memory_features_amd;
+  }
+
+  if (HasExtension("VK_AMD_shader_early_and_late_fragment_tests",
+                   device.extensions)) {
+    device.amd_shader_early_and_late_fragment_tests.reported = true;
+    device.amd_shader_early_and_late_fragment_tests
+        .shader_early_and_late_fragment_tests_features_amd.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD;
+    device.amd_shader_early_and_late_fragment_tests
+        .shader_early_and_late_fragment_tests_features_amd.pNext =
+        features.pNext;
+    features.pNext = &device.amd_shader_early_and_late_fragment_tests
+                          .shader_early_and_late_fragment_tests_features_amd;
+  }
+
+  if (HasExtension("VK_ANDROID_external_format_resolve", device.extensions)) {
+    device.android_external_format_resolve.reported = true;
+    device.android_external_format_resolve
+        .external_format_resolve_features_android.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID;
+    device.android_external_format_resolve
+        .external_format_resolve_features_android.pNext = features.pNext;
+    features.pNext = &device.android_external_format_resolve
+                          .external_format_resolve_features_android;
+  }
+
+  if (HasExtension("VK_ARM_rasterization_order_attachment_access",
+                   device.extensions)) {
+    device.arm_rasterization_order_attachment_access.reported = true;
+    device.arm_rasterization_order_attachment_access
+        .rasterization_order_attachment_access_features_arm.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT;
+    device.arm_rasterization_order_attachment_access
+        .rasterization_order_attachment_access_features_arm.pNext =
+        features.pNext;
+    features.pNext = &device.arm_rasterization_order_attachment_access
+                          .rasterization_order_attachment_access_features_arm;
+  }
+
+  if (HasExtension("VK_ARM_render_pass_striped", device.extensions)) {
+    device.arm_render_pass_striped.reported = true;
+    device.arm_render_pass_striped.render_pass_striped_features_arm.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM;
+    device.arm_render_pass_striped.render_pass_striped_features_arm.pNext =
+        features.pNext;
+    features.pNext =
+        &device.arm_render_pass_striped.render_pass_striped_features_arm;
+  }
+
+  if (HasExtension("VK_ARM_scheduling_controls", device.extensions)) {
+    device.arm_scheduling_controls.reported = true;
+    device.arm_scheduling_controls.scheduling_controls_features_arm.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM;
+    device.arm_scheduling_controls.scheduling_controls_features_arm.pNext =
+        features.pNext;
+    features.pNext =
+        &device.arm_scheduling_controls.scheduling_controls_features_arm;
+  }
+
+  if (HasExtension("VK_ARM_shader_core_builtins", device.extensions)) {
+    device.arm_shader_core_builtins.reported = true;
+    device.arm_shader_core_builtins.shader_core_builtins_features_arm.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM;
+    device.arm_shader_core_builtins.shader_core_builtins_features_arm.pNext =
+        features.pNext;
+    features.pNext =
+        &device.arm_shader_core_builtins.shader_core_builtins_features_arm;
+  }
+
+  if (HasExtension("VK_EXT_4444_formats", device.extensions)) {
+    device.ext_formats_4444.reported = true;
+    device.ext_formats_4444.formats_4444_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT;
+    device.ext_formats_4444.formats_4444_features_ext.pNext = features.pNext;
+    features.pNext = &device.ext_formats_4444.formats_4444_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_astc_decode_mode", device.extensions)) {
+    device.ext_astc_decode_mode.reported = true;
+    device.ext_astc_decode_mode.astc_decode_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT;
+    device.ext_astc_decode_mode.astc_decode_features_ext.pNext = features.pNext;
+    features.pNext = &device.ext_astc_decode_mode.astc_decode_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_attachment_feedback_loop_dynamic_state",
+                   device.extensions)) {
+    device.ext_attachment_feedback_loop_dynamic_state.reported = true;
+    device.ext_attachment_feedback_loop_dynamic_state
+        .attachment_feedback_loop_dynamic_state_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT;
+    device.ext_attachment_feedback_loop_dynamic_state
+        .attachment_feedback_loop_dynamic_state_features_ext.pNext =
+        features.pNext;
+    features.pNext = &device.ext_attachment_feedback_loop_dynamic_state
+                          .attachment_feedback_loop_dynamic_state_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_attachment_feedback_loop_layout",
+                   device.extensions)) {
+    device.ext_attachment_feedback_loop_layout.reported = true;
+    device.ext_attachment_feedback_loop_layout
+        .attachment_feedback_loop_layout_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT;
+    device.ext_attachment_feedback_loop_layout
+        .attachment_feedback_loop_layout_features_ext.pNext = features.pNext;
+    features.pNext = &device.ext_attachment_feedback_loop_layout
+                          .attachment_feedback_loop_layout_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_blend_operation_advanced", device.extensions)) {
+    device.ext_blend_operation_advanced.reported = true;
+    device.ext_blend_operation_advanced.blend_operation_advanced_features_ext
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT;
+    device.ext_blend_operation_advanced.blend_operation_advanced_features_ext
+        .pNext = features.pNext;
+    features.pNext = &device.ext_blend_operation_advanced
+                          .blend_operation_advanced_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_border_color_swizzle", device.extensions)) {
+    device.ext_border_color_swizzle.reported = true;
+    device.ext_border_color_swizzle.border_color_swizzle_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT;
+    device.ext_border_color_swizzle.border_color_swizzle_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_border_color_swizzle.border_color_swizzle_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_buffer_device_address", device.extensions)) {
+    device.ext_buffer_device_address.reported = true;
+    device.ext_buffer_device_address.buffer_address_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT;
+    device.ext_buffer_device_address.buffer_address_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_buffer_device_address.buffer_address_features_ext;
+    device.ext_buffer_device_address.buffer_device_address_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT;
+    device.ext_buffer_device_address.buffer_device_address_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_buffer_device_address.buffer_device_address_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_color_write_enable", device.extensions)) {
+    device.ext_color_write_enable.reported = true;
+    device.ext_color_write_enable.color_write_enable_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT;
+    device.ext_color_write_enable.color_write_enable_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_color_write_enable.color_write_enable_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_conditional_rendering", device.extensions)) {
+    device.ext_conditional_rendering.reported = true;
+    device.ext_conditional_rendering.conditional_rendering_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT;
+    device.ext_conditional_rendering.conditional_rendering_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_conditional_rendering.conditional_rendering_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_custom_border_color", device.extensions)) {
+    device.ext_custom_border_color.reported = true;
+    device.ext_custom_border_color.custom_border_color_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT;
+    device.ext_custom_border_color.custom_border_color_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_custom_border_color.custom_border_color_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_depth_bias_control", device.extensions)) {
+    device.ext_depth_bias_control.reported = true;
+    device.ext_depth_bias_control.depth_bias_control_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT;
+    device.ext_depth_bias_control.depth_bias_control_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_depth_bias_control.depth_bias_control_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_depth_clamp_zero_one", device.extensions)) {
+    device.ext_depth_clamp_zero_one.reported = true;
+    device.ext_depth_clamp_zero_one.depth_clamp_zero_one_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT;
+    device.ext_depth_clamp_zero_one.depth_clamp_zero_one_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_depth_clamp_zero_one.depth_clamp_zero_one_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_depth_clip_control", device.extensions)) {
+    device.ext_depth_clip_control.reported = true;
+    device.ext_depth_clip_control.depth_clip_control_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT;
+    device.ext_depth_clip_control.depth_clip_control_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_depth_clip_control.depth_clip_control_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_depth_clip_enable", device.extensions)) {
+    device.ext_depth_clip_enable.reported = true;
+    device.ext_depth_clip_enable.depth_clip_enable_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT;
+    device.ext_depth_clip_enable.depth_clip_enable_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_depth_clip_enable.depth_clip_enable_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_descriptor_buffer", device.extensions)) {
+    device.ext_descriptor_buffer.reported = true;
+    device.ext_descriptor_buffer.descriptor_buffer_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT;
+    device.ext_descriptor_buffer.descriptor_buffer_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_descriptor_buffer.descriptor_buffer_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_descriptor_indexing", device.extensions)) {
+    device.ext_descriptor_indexing.reported = true;
+    device.ext_descriptor_indexing.descriptor_indexing_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES;
+    device.ext_descriptor_indexing.descriptor_indexing_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_descriptor_indexing.descriptor_indexing_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_device_address_binding_report", device.extensions)) {
+    device.ext_device_address_binding_report.reported = true;
+    device.ext_device_address_binding_report.address_binding_report_features_ext
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT;
+    device.ext_device_address_binding_report.address_binding_report_features_ext
+        .pNext = features.pNext;
+    features.pNext = &device.ext_device_address_binding_report
+                          .address_binding_report_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_device_fault", device.extensions)) {
+    device.ext_device_fault.reported = true;
+    device.ext_device_fault.fault_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT;
+    device.ext_device_fault.fault_features_ext.pNext = features.pNext;
+    features.pNext = &device.ext_device_fault.fault_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_device_memory_report", device.extensions)) {
+    device.ext_device_memory_report.reported = true;
+    device.ext_device_memory_report.device_memory_report_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT;
+    device.ext_device_memory_report.device_memory_report_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_device_memory_report.device_memory_report_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_dynamic_rendering_unused_attachments",
+                   device.extensions)) {
+    device.ext_dynamic_rendering_unused_attachments.reported = true;
+    device.ext_dynamic_rendering_unused_attachments
+        .dynamic_rendering_unused_attachments_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT;
+    device.ext_dynamic_rendering_unused_attachments
+        .dynamic_rendering_unused_attachments_features_ext.pNext =
+        features.pNext;
+    features.pNext = &device.ext_dynamic_rendering_unused_attachments
+                          .dynamic_rendering_unused_attachments_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_extended_dynamic_state", device.extensions)) {
+    device.ext_extended_dynamic_state.reported = true;
+    device.ext_extended_dynamic_state.extended_dynamic_state_features_ext
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT;
+    device.ext_extended_dynamic_state.extended_dynamic_state_features_ext
+        .pNext = features.pNext;
+    features.pNext =
+        &device.ext_extended_dynamic_state.extended_dynamic_state_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_extended_dynamic_state2", device.extensions)) {
+    device.ext_extended_dynamic_state2.reported = true;
+    device.ext_extended_dynamic_state2.extended_dynamic_state2_features_ext
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT;
+    device.ext_extended_dynamic_state2.extended_dynamic_state2_features_ext
+        .pNext = features.pNext;
+    features.pNext = &device.ext_extended_dynamic_state2
+                          .extended_dynamic_state2_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_extended_dynamic_state3", device.extensions)) {
+    device.ext_extended_dynamic_state3.reported = true;
+    device.ext_extended_dynamic_state3.extended_dynamic_state3_features_ext
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT;
+    device.ext_extended_dynamic_state3.extended_dynamic_state3_features_ext
+        .pNext = features.pNext;
+    features.pNext = &device.ext_extended_dynamic_state3
+                          .extended_dynamic_state3_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_fragment_density_map", device.extensions)) {
+    device.ext_fragment_density_map.reported = true;
+    device.ext_fragment_density_map.fragment_density_map_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT;
+    device.ext_fragment_density_map.fragment_density_map_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_fragment_density_map.fragment_density_map_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_fragment_density_map2", device.extensions)) {
+    device.ext_fragment_density_map2.reported = true;
+    device.ext_fragment_density_map2.fragment_density_map2_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT;
+    device.ext_fragment_density_map2.fragment_density_map2_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_fragment_density_map2.fragment_density_map2_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_fragment_shader_interlock", device.extensions)) {
+    device.ext_fragment_shader_interlock.reported = true;
+    device.ext_fragment_shader_interlock.fragment_shader_interlock_features_ext
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT;
+    device.ext_fragment_shader_interlock.fragment_shader_interlock_features_ext
+        .pNext = features.pNext;
+    features.pNext = &device.ext_fragment_shader_interlock
+                          .fragment_shader_interlock_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_frame_boundary", device.extensions)) {
+    device.ext_frame_boundary.reported = true;
+    device.ext_frame_boundary.frame_boundary_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT;
+    device.ext_frame_boundary.frame_boundary_features_ext.pNext =
+        features.pNext;
+    features.pNext = &device.ext_frame_boundary.frame_boundary_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_global_priority_query", device.extensions)) {
+    device.ext_global_priority_query.reported = true;
+    device.ext_global_priority_query.global_priority_query_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES;
+    device.ext_global_priority_query.global_priority_query_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_global_priority_query.global_priority_query_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_graphics_pipeline_library", device.extensions)) {
+    device.ext_graphics_pipeline_library.reported = true;
+    device.ext_graphics_pipeline_library.graphics_pipeline_library_features_ext
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT;
+    device.ext_graphics_pipeline_library.graphics_pipeline_library_features_ext
+        .pNext = features.pNext;
+    features.pNext = &device.ext_graphics_pipeline_library
+                          .graphics_pipeline_library_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_host_image_copy", device.extensions)) {
+    device.ext_host_image_copy.reported = true;
+    device.ext_host_image_copy.host_image_copy_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES;
+    device.ext_host_image_copy.host_image_copy_features_ext.pNext =
+        features.pNext;
+    features.pNext = &device.ext_host_image_copy.host_image_copy_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_host_query_reset", device.extensions)) {
+    device.ext_host_query_reset.reported = true;
+    device.ext_host_query_reset.host_query_reset_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES;
+    device.ext_host_query_reset.host_query_reset_features_ext.pNext =
+        features.pNext;
+    features.pNext = &device.ext_host_query_reset.host_query_reset_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_image_2d_view_of_3d", device.extensions)) {
+    device.ext_image_2d_view_of_3d.reported = true;
+    device.ext_image_2d_view_of_3d.image_2d_view_of_3d_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT;
+    device.ext_image_2d_view_of_3d.image_2d_view_of_3d_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_image_2d_view_of_3d.image_2d_view_of_3d_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_image_compression_control", device.extensions)) {
+    device.ext_image_compression_control.reported = true;
+    device.ext_image_compression_control.image_compression_control_features_ext
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT;
+    device.ext_image_compression_control.image_compression_control_features_ext
+        .pNext = features.pNext;
+    features.pNext = &device.ext_image_compression_control
+                          .image_compression_control_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_image_compression_control_swapchain",
+                   device.extensions)) {
+    device.ext_image_compression_control_swapchain.reported = true;
+    device.ext_image_compression_control_swapchain
+        .image_compression_control_swapchain_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT;
+    device.ext_image_compression_control_swapchain
+        .image_compression_control_swapchain_features_ext.pNext =
+        features.pNext;
+    features.pNext = &device.ext_image_compression_control_swapchain
+                          .image_compression_control_swapchain_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_image_robustness", device.extensions)) {
+    device.ext_image_robustness.reported = true;
+    device.ext_image_robustness.image_robustness_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES;
+    device.ext_image_robustness.image_robustness_features_ext.pNext =
+        features.pNext;
+    features.pNext = &device.ext_image_robustness.image_robustness_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_image_sliced_view_of_3d", device.extensions)) {
+    device.ext_image_sliced_view_of_3d.reported = true;
+    device.ext_image_sliced_view_of_3d.image_sliced_view_of_3d_features_ext
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT;
+    device.ext_image_sliced_view_of_3d.image_sliced_view_of_3d_features_ext
+        .pNext = features.pNext;
+    features.pNext = &device.ext_image_sliced_view_of_3d
+                          .image_sliced_view_of_3d_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_image_view_min_lod", device.extensions)) {
+    device.ext_image_view_min_lod.reported = true;
+    device.ext_image_view_min_lod.image_view_min_lod_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT;
+    device.ext_image_view_min_lod.image_view_min_lod_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_image_view_min_lod.image_view_min_lod_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_index_type_uint8", device.extensions)) {
+    device.ext_index_type_uint8.reported = true;
+    device.ext_index_type_uint8.index_type_uint8_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES;
+    device.ext_index_type_uint8.index_type_uint8_features_ext.pNext =
+        features.pNext;
+    features.pNext = &device.ext_index_type_uint8.index_type_uint8_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_inline_uniform_block", device.extensions)) {
+    device.ext_inline_uniform_block.reported = true;
+    device.ext_inline_uniform_block.inline_uniform_block_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES;
+    device.ext_inline_uniform_block.inline_uniform_block_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_inline_uniform_block.inline_uniform_block_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_legacy_dithering", device.extensions)) {
+    device.ext_legacy_dithering.reported = true;
+    device.ext_legacy_dithering.legacy_dithering_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT;
+    device.ext_legacy_dithering.legacy_dithering_features_ext.pNext =
+        features.pNext;
+    features.pNext = &device.ext_legacy_dithering.legacy_dithering_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_legacy_vertex_attributes", device.extensions)) {
+    device.ext_legacy_vertex_attributes.reported = true;
+    device.ext_legacy_vertex_attributes.legacy_vertex_attributes_features_ext
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT;
+    device.ext_legacy_vertex_attributes.legacy_vertex_attributes_features_ext
+        .pNext = features.pNext;
+    features.pNext = &device.ext_legacy_vertex_attributes
+                          .legacy_vertex_attributes_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_line_rasterization", device.extensions)) {
+    device.ext_line_rasterization.reported = true;
+    device.ext_line_rasterization.line_rasterization_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES;
+    device.ext_line_rasterization.line_rasterization_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_line_rasterization.line_rasterization_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_map_memory_placed", device.extensions)) {
+    device.ext_map_memory_placed.reported = true;
+    device.ext_map_memory_placed.map_memory_placed_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT;
+    device.ext_map_memory_placed.map_memory_placed_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_map_memory_placed.map_memory_placed_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_memory_priority", device.extensions)) {
+    device.ext_memory_priority.reported = true;
+    device.ext_memory_priority.memory_priority_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT;
+    device.ext_memory_priority.memory_priority_features_ext.pNext =
+        features.pNext;
+    features.pNext = &device.ext_memory_priority.memory_priority_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_mesh_shader", device.extensions)) {
+    device.ext_mesh_shader.reported = true;
+    device.ext_mesh_shader.mesh_shader_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT;
+    device.ext_mesh_shader.mesh_shader_features_ext.pNext = features.pNext;
+    features.pNext = &device.ext_mesh_shader.mesh_shader_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_multi_draw", device.extensions)) {
+    device.ext_multi_draw.reported = true;
+    device.ext_multi_draw.multi_draw_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT;
+    device.ext_multi_draw.multi_draw_features_ext.pNext = features.pNext;
+    features.pNext = &device.ext_multi_draw.multi_draw_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_multisampled_render_to_single_sampled",
+                   device.extensions)) {
+    device.ext_multisampled_render_to_single_sampled.reported = true;
+    device.ext_multisampled_render_to_single_sampled
+        .multisampled_render_to_single_sampled_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT;
+    device.ext_multisampled_render_to_single_sampled
+        .multisampled_render_to_single_sampled_features_ext.pNext =
+        features.pNext;
+    features.pNext = &device.ext_multisampled_render_to_single_sampled
+                          .multisampled_render_to_single_sampled_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_mutable_descriptor_type", device.extensions)) {
+    device.ext_mutable_descriptor_type.reported = true;
+    device.ext_mutable_descriptor_type.mutable_descriptor_type_features_ext
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT;
+    device.ext_mutable_descriptor_type.mutable_descriptor_type_features_ext
+        .pNext = features.pNext;
+    features.pNext = &device.ext_mutable_descriptor_type
+                          .mutable_descriptor_type_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_nested_command_buffer", device.extensions)) {
+    device.ext_nested_command_buffer.reported = true;
+    device.ext_nested_command_buffer.nested_command_buffer_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT;
+    device.ext_nested_command_buffer.nested_command_buffer_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_nested_command_buffer.nested_command_buffer_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_non_seamless_cube_map", device.extensions)) {
+    device.ext_non_seamless_cube_map.reported = true;
+    device.ext_non_seamless_cube_map.non_seamless_cube_map_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT;
+    device.ext_non_seamless_cube_map.non_seamless_cube_map_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_non_seamless_cube_map.non_seamless_cube_map_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_opacity_micromap", device.extensions)) {
+    device.ext_opacity_micromap.reported = true;
+    device.ext_opacity_micromap.opacity_micromap_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT;
+    device.ext_opacity_micromap.opacity_micromap_features_ext.pNext =
+        features.pNext;
+    features.pNext = &device.ext_opacity_micromap.opacity_micromap_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_pageable_device_local_memory", device.extensions)) {
+    device.ext_pageable_device_local_memory.reported = true;
+    device.ext_pageable_device_local_memory
+        .pageable_device_local_memory_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT;
+    device.ext_pageable_device_local_memory
+        .pageable_device_local_memory_features_ext.pNext = features.pNext;
+    features.pNext = &device.ext_pageable_device_local_memory
+                          .pageable_device_local_memory_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_pipeline_creation_cache_control",
+                   device.extensions)) {
+    device.ext_pipeline_creation_cache_control.reported = true;
+    device.ext_pipeline_creation_cache_control
+        .pipeline_creation_cache_control_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES;
+    device.ext_pipeline_creation_cache_control
+        .pipeline_creation_cache_control_features_ext.pNext = features.pNext;
+    features.pNext = &device.ext_pipeline_creation_cache_control
+                          .pipeline_creation_cache_control_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_pipeline_library_group_handles",
+                   device.extensions)) {
+    device.ext_pipeline_library_group_handles.reported = true;
+    device.ext_pipeline_library_group_handles
+        .pipeline_library_group_handles_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT;
+    device.ext_pipeline_library_group_handles
+        .pipeline_library_group_handles_features_ext.pNext = features.pNext;
+    features.pNext = &device.ext_pipeline_library_group_handles
+                          .pipeline_library_group_handles_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_pipeline_properties", device.extensions)) {
+    device.ext_pipeline_properties.reported = true;
+    device.ext_pipeline_properties.pipeline_properties_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT;
+    device.ext_pipeline_properties.pipeline_properties_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_pipeline_properties.pipeline_properties_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_pipeline_protected_access", device.extensions)) {
+    device.ext_pipeline_protected_access.reported = true;
+    device.ext_pipeline_protected_access.pipeline_protected_access_features_ext
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES;
+    device.ext_pipeline_protected_access.pipeline_protected_access_features_ext
+        .pNext = features.pNext;
+    features.pNext = &device.ext_pipeline_protected_access
+                          .pipeline_protected_access_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_pipeline_robustness", device.extensions)) {
+    device.ext_pipeline_robustness.reported = true;
+    device.ext_pipeline_robustness.pipeline_robustness_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES;
+    device.ext_pipeline_robustness.pipeline_robustness_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_pipeline_robustness.pipeline_robustness_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_primitive_topology_list_restart",
+                   device.extensions)) {
+    device.ext_primitive_topology_list_restart.reported = true;
+    device.ext_primitive_topology_list_restart
+        .primitive_topology_list_restart_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT;
+    device.ext_primitive_topology_list_restart
+        .primitive_topology_list_restart_features_ext.pNext = features.pNext;
+    features.pNext = &device.ext_primitive_topology_list_restart
+                          .primitive_topology_list_restart_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_primitives_generated_query", device.extensions)) {
+    device.ext_primitives_generated_query.reported = true;
+    device.ext_primitives_generated_query
+        .primitives_generated_query_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT;
+    device.ext_primitives_generated_query
+        .primitives_generated_query_features_ext.pNext = features.pNext;
+    features.pNext = &device.ext_primitives_generated_query
+                          .primitives_generated_query_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_private_data", device.extensions)) {
+    device.ext_private_data.reported = true;
+    device.ext_private_data.private_data_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES;
+    device.ext_private_data.private_data_features_ext.pNext = features.pNext;
+    features.pNext = &device.ext_private_data.private_data_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_provoking_vertex", device.extensions)) {
+    device.ext_provoking_vertex.reported = true;
+    device.ext_provoking_vertex.provoking_vertex_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT;
+    device.ext_provoking_vertex.provoking_vertex_features_ext.pNext =
+        features.pNext;
+    features.pNext = &device.ext_provoking_vertex.provoking_vertex_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_rasterization_order_attachment_access",
+                   device.extensions)) {
+    device.ext_rasterization_order_attachment_access.reported = true;
+    device.ext_rasterization_order_attachment_access
+        .rasterization_order_attachment_access_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT;
+    device.ext_rasterization_order_attachment_access
+        .rasterization_order_attachment_access_features_ext.pNext =
+        features.pNext;
+    features.pNext = &device.ext_rasterization_order_attachment_access
+                          .rasterization_order_attachment_access_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_rgba10x6_formats", device.extensions)) {
+    device.ext_rgba10x6_formats.reported = true;
+    device.ext_rgba10x6_formats.rgba10_x6_formats_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT;
+    device.ext_rgba10x6_formats.rgba10_x6_formats_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_rgba10x6_formats.rgba10_x6_formats_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_robustness2", device.extensions)) {
+    device.ext_robustness2.reported = true;
+    device.ext_robustness2.robustness2_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT;
+    device.ext_robustness2.robustness2_features_ext.pNext = features.pNext;
+    features.pNext = &device.ext_robustness2.robustness2_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_scalar_block_layout", device.extensions)) {
+    device.ext_scalar_block_layout.reported = true;
+    device.ext_scalar_block_layout.scalar_block_layout_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES;
+    device.ext_scalar_block_layout.scalar_block_layout_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_scalar_block_layout.scalar_block_layout_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_shader_atomic_float", device.extensions)) {
+    device.ext_shader_atomic_float.reported = true;
+    device.ext_shader_atomic_float.shader_atomic_float_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT;
+    device.ext_shader_atomic_float.shader_atomic_float_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_shader_atomic_float.shader_atomic_float_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_shader_atomic_float2", device.extensions)) {
+    device.ext_shader_atomic_float2.reported = true;
+    device.ext_shader_atomic_float2.shader_atomic_float2_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT;
+    device.ext_shader_atomic_float2.shader_atomic_float2_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_shader_atomic_float2.shader_atomic_float2_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_shader_demote_to_helper_invocation",
+                   device.extensions)) {
+    device.ext_shader_demote_to_helper_invocation.reported = true;
+    device.ext_shader_demote_to_helper_invocation
+        .shader_demote_to_helper_invocation_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES;
+    device.ext_shader_demote_to_helper_invocation
+        .shader_demote_to_helper_invocation_features_ext.pNext = features.pNext;
+    features.pNext = &device.ext_shader_demote_to_helper_invocation
+                          .shader_demote_to_helper_invocation_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_shader_image_atomic_int64", device.extensions)) {
+    device.ext_shader_image_atomic_int64.reported = true;
+    device.ext_shader_image_atomic_int64.shader_image_atomic_int64_features_ext
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT;
+    device.ext_shader_image_atomic_int64.shader_image_atomic_int64_features_ext
+        .pNext = features.pNext;
+    features.pNext = &device.ext_shader_image_atomic_int64
+                          .shader_image_atomic_int64_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_shader_module_identifier", device.extensions)) {
+    device.ext_shader_module_identifier.reported = true;
+    device.ext_shader_module_identifier.shader_module_identifier_features_ext
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT;
+    device.ext_shader_module_identifier.shader_module_identifier_features_ext
+        .pNext = features.pNext;
+    features.pNext = &device.ext_shader_module_identifier
+                          .shader_module_identifier_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_shader_object", device.extensions)) {
+    device.ext_shader_object.reported = true;
+    device.ext_shader_object.shader_object_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT;
+    device.ext_shader_object.shader_object_features_ext.pNext = features.pNext;
+    features.pNext = &device.ext_shader_object.shader_object_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_shader_replicated_composites", device.extensions)) {
+    device.ext_shader_replicated_composites.reported = true;
+    device.ext_shader_replicated_composites
+        .shader_replicated_composites_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT;
+    device.ext_shader_replicated_composites
+        .shader_replicated_composites_features_ext.pNext = features.pNext;
+    features.pNext = &device.ext_shader_replicated_composites
+                          .shader_replicated_composites_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_shader_tile_image", device.extensions)) {
+    device.ext_shader_tile_image.reported = true;
+    device.ext_shader_tile_image.shader_tile_image_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT;
+    device.ext_shader_tile_image.shader_tile_image_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_shader_tile_image.shader_tile_image_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_subgroup_size_control", device.extensions)) {
+    device.ext_subgroup_size_control.reported = true;
+    device.ext_subgroup_size_control.subgroup_size_control_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES;
+    device.ext_subgroup_size_control.subgroup_size_control_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_subgroup_size_control.subgroup_size_control_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_subpass_merge_feedback", device.extensions)) {
+    device.ext_subpass_merge_feedback.reported = true;
+    device.ext_subpass_merge_feedback.subpass_merge_feedback_features_ext
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT;
+    device.ext_subpass_merge_feedback.subpass_merge_feedback_features_ext
+        .pNext = features.pNext;
+    features.pNext =
+        &device.ext_subpass_merge_feedback.subpass_merge_feedback_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_swapchain_maintenance1", device.extensions)) {
+    device.ext_swapchain_maintenance1.reported = true;
+    device.ext_swapchain_maintenance1.swapchain_maintenance1_features_ext
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT;
+    device.ext_swapchain_maintenance1.swapchain_maintenance1_features_ext
+        .pNext = features.pNext;
+    features.pNext =
+        &device.ext_swapchain_maintenance1.swapchain_maintenance1_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_texel_buffer_alignment", device.extensions)) {
+    device.ext_texel_buffer_alignment.reported = true;
+    device.ext_texel_buffer_alignment.texel_buffer_alignment_features_ext
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT;
+    device.ext_texel_buffer_alignment.texel_buffer_alignment_features_ext
+        .pNext = features.pNext;
+    features.pNext =
+        &device.ext_texel_buffer_alignment.texel_buffer_alignment_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_texture_compression_astc_hdr", device.extensions)) {
+    device.ext_texture_compression_astc_hdr.reported = true;
+    device.ext_texture_compression_astc_hdr
+        .texture_compression_astchdr_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES;
+    device.ext_texture_compression_astc_hdr
+        .texture_compression_astchdr_features_ext.pNext = features.pNext;
+    features.pNext = &device.ext_texture_compression_astc_hdr
+                          .texture_compression_astchdr_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_transform_feedback", device.extensions)) {
+    device.ext_transform_feedback.reported = true;
+    device.ext_transform_feedback.transform_feedback_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT;
+    device.ext_transform_feedback.transform_feedback_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_transform_feedback.transform_feedback_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_vertex_attribute_divisor", device.extensions)) {
+    device.ext_vertex_attribute_divisor.reported = true;
+    device.ext_vertex_attribute_divisor.vertex_attribute_divisor_features_ext
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES;
+    device.ext_vertex_attribute_divisor.vertex_attribute_divisor_features_ext
+        .pNext = features.pNext;
+    features.pNext = &device.ext_vertex_attribute_divisor
+                          .vertex_attribute_divisor_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_vertex_input_dynamic_state", device.extensions)) {
+    device.ext_vertex_input_dynamic_state.reported = true;
+    device.ext_vertex_input_dynamic_state
+        .vertex_input_dynamic_state_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT;
+    device.ext_vertex_input_dynamic_state
+        .vertex_input_dynamic_state_features_ext.pNext = features.pNext;
+    features.pNext = &device.ext_vertex_input_dynamic_state
+                          .vertex_input_dynamic_state_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_ycbcr_2plane_444_formats", device.extensions)) {
+    device.ext_ycbcr_2plane_444_formats.reported = true;
+    device.ext_ycbcr_2plane_444_formats.ycbcr_2plane_444_formats_features_ext
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT;
+    device.ext_ycbcr_2plane_444_formats.ycbcr_2plane_444_formats_features_ext
+        .pNext = features.pNext;
+    features.pNext = &device.ext_ycbcr_2plane_444_formats
+                          .ycbcr_2plane_444_formats_features_ext;
+  }
+
+  if (HasExtension("VK_EXT_ycbcr_image_arrays", device.extensions)) {
+    device.ext_ycbcr_image_arrays.reported = true;
+    device.ext_ycbcr_image_arrays.ycbcr_image_arrays_features_ext.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT;
+    device.ext_ycbcr_image_arrays.ycbcr_image_arrays_features_ext.pNext =
+        features.pNext;
+    features.pNext =
+        &device.ext_ycbcr_image_arrays.ycbcr_image_arrays_features_ext;
+  }
+
+  if (HasExtension("VK_HUAWEI_cluster_culling_shader", device.extensions)) {
+    device.huawei_cluster_culling_shader.reported = true;
+    device.huawei_cluster_culling_shader.cluster_culling_shader_features_huawei
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI;
+    device.huawei_cluster_culling_shader.cluster_culling_shader_features_huawei
+        .pNext = features.pNext;
+    features.pNext = &device.huawei_cluster_culling_shader
+                          .cluster_culling_shader_features_huawei;
+  }
+
+  if (HasExtension("VK_HUAWEI_invocation_mask", device.extensions)) {
+    device.huawei_invocation_mask.reported = true;
+    device.huawei_invocation_mask.invocation_mask_features_huawei.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI;
+    device.huawei_invocation_mask.invocation_mask_features_huawei.pNext =
+        features.pNext;
+    features.pNext =
+        &device.huawei_invocation_mask.invocation_mask_features_huawei;
+  }
+
+  if (HasExtension("VK_HUAWEI_subpass_shading", device.extensions)) {
+    device.huawei_subpass_shading.reported = true;
+    device.huawei_subpass_shading.subpass_shading_features_huawei.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI;
+    device.huawei_subpass_shading.subpass_shading_features_huawei.pNext =
+        features.pNext;
+    features.pNext =
+        &device.huawei_subpass_shading.subpass_shading_features_huawei;
+  }
+
+  if (HasExtension("VK_IMG_relaxed_line_rasterization", device.extensions)) {
+    device.img_relaxed_line_rasterization.reported = true;
+    device.img_relaxed_line_rasterization
+        .relaxed_line_rasterization_features_img.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG;
+    device.img_relaxed_line_rasterization
+        .relaxed_line_rasterization_features_img.pNext = features.pNext;
+    features.pNext = &device.img_relaxed_line_rasterization
+                          .relaxed_line_rasterization_features_img;
+  }
+
+  if (HasExtension("VK_INTEL_shader_integer_functions2", device.extensions)) {
+    device.vk_intel_shader_integer_functions2.reported = true;
+    device.vk_intel_shader_integer_functions2
+        .shader_integer_functions2_features_intel.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL;
+    device.vk_intel_shader_integer_functions2
+        .shader_integer_functions2_features_intel.pNext = features.pNext;
+    features.pNext = &device.vk_intel_shader_integer_functions2
+                          .shader_integer_functions2_features_intel;
+  }
+
+  if (HasExtension("VK_KHR_16bit_storage", device.extensions)) {
+    device.khr_16bit_storage.reported = true;
+    device.khr_16bit_storage.bit16_storage_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;
+    device.khr_16bit_storage.bit16_storage_features_khr.pNext = features.pNext;
+    features.pNext = &device.khr_16bit_storage.bit16_storage_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_8bit_storage", device.extensions)) {
+    device.khr_8bit_storage.reported = true;
+    device.khr_8bit_storage.bit8_storage_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES;
+    device.khr_8bit_storage.bit8_storage_features_khr.pNext = features.pNext;
+    features.pNext = &device.khr_8bit_storage.bit8_storage_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_acceleration_structure", device.extensions)) {
+    device.khr_acceleration_structure.reported = true;
+    device.khr_acceleration_structure.acceleration_structure_features_khr
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR;
+    device.khr_acceleration_structure.acceleration_structure_features_khr
+        .pNext = features.pNext;
+    features.pNext =
+        &device.khr_acceleration_structure.acceleration_structure_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_buffer_device_address", device.extensions)) {
+    device.khr_buffer_device_address.reported = true;
+    device.khr_buffer_device_address.buffer_device_address_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES;
+    device.khr_buffer_device_address.buffer_device_address_features_khr.pNext =
+        features.pNext;
+    features.pNext =
+        &device.khr_buffer_device_address.buffer_device_address_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_cooperative_matrix", device.extensions)) {
+    device.khr_cooperative_matrix.reported = true;
+    device.khr_cooperative_matrix.cooperative_matrix_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR;
+    device.khr_cooperative_matrix.cooperative_matrix_features_khr.pNext =
+        features.pNext;
+    features.pNext =
+        &device.khr_cooperative_matrix.cooperative_matrix_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_dynamic_rendering", device.extensions)) {
+    device.khr_dynamic_rendering.reported = true;
+    device.khr_dynamic_rendering.dynamic_rendering_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES;
+    device.khr_dynamic_rendering.dynamic_rendering_features_khr.pNext =
+        features.pNext;
+    features.pNext =
+        &device.khr_dynamic_rendering.dynamic_rendering_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_dynamic_rendering_local_read", device.extensions)) {
+    device.khr_dynamic_rendering_local_read.reported = true;
+    device.khr_dynamic_rendering_local_read
+        .dynamic_rendering_local_read_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES;
+    device.khr_dynamic_rendering_local_read
+        .dynamic_rendering_local_read_features_khr.pNext = features.pNext;
+    features.pNext = &device.khr_dynamic_rendering_local_read
+                          .dynamic_rendering_local_read_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_fragment_shader_barycentric", device.extensions)) {
+    device.khr_fragment_shader_barycentric.reported = true;
+    device.khr_fragment_shader_barycentric
+        .fragment_shader_barycentric_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR;
+    device.khr_fragment_shader_barycentric
+        .fragment_shader_barycentric_features_khr.pNext = features.pNext;
+    features.pNext = &device.khr_fragment_shader_barycentric
+                          .fragment_shader_barycentric_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_fragment_shading_rate", device.extensions)) {
+    device.khr_fragment_shading_rate.reported = true;
+    device.khr_fragment_shading_rate.fragment_shading_rate_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR;
+    device.khr_fragment_shading_rate.fragment_shading_rate_features_khr.pNext =
+        features.pNext;
+    features.pNext =
+        &device.khr_fragment_shading_rate.fragment_shading_rate_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_global_priority", device.extensions)) {
+    device.khr_global_priority.reported = true;
+    device.khr_global_priority.global_priority_query_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES;
+    device.khr_global_priority.global_priority_query_features_khr.pNext =
+        features.pNext;
+    features.pNext =
+        &device.khr_global_priority.global_priority_query_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_imageless_framebuffer", device.extensions)) {
+    device.khr_imageless_framebuffer.reported = true;
+    device.khr_imageless_framebuffer.imageless_framebuffer_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES;
+    device.khr_imageless_framebuffer.imageless_framebuffer_features_khr.pNext =
+        features.pNext;
+    features.pNext =
+        &device.khr_imageless_framebuffer.imageless_framebuffer_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_index_type_uint8", device.extensions)) {
+    device.khr_index_type_uint8.reported = true;
+    device.khr_index_type_uint8.index_type_uint8_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES;
+    device.khr_index_type_uint8.index_type_uint8_features_khr.pNext =
+        features.pNext;
+    features.pNext = &device.khr_index_type_uint8.index_type_uint8_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_line_rasterization", device.extensions)) {
+    device.khr_line_rasterization.reported = true;
+    device.khr_line_rasterization.line_rasterization_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES;
+    device.khr_line_rasterization.line_rasterization_features_khr.pNext =
+        features.pNext;
+    features.pNext =
+        &device.khr_line_rasterization.line_rasterization_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_maintenance4", device.extensions)) {
+    device.khr_maintenance4.reported = true;
+    device.khr_maintenance4.maintenance4_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES;
+    device.khr_maintenance4.maintenance4_features_khr.pNext = features.pNext;
+    features.pNext = &device.khr_maintenance4.maintenance4_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_maintenance5", device.extensions)) {
+    device.khr_maintenance5.reported = true;
+    device.khr_maintenance5.maintenance5_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES;
+    device.khr_maintenance5.maintenance5_features_khr.pNext = features.pNext;
+    features.pNext = &device.khr_maintenance5.maintenance5_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_maintenance6", device.extensions)) {
+    device.khr_maintenance6.reported = true;
+    device.khr_maintenance6.maintenance6_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES;
+    device.khr_maintenance6.maintenance6_features_khr.pNext = features.pNext;
+    features.pNext = &device.khr_maintenance6.maintenance6_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_maintenance7", device.extensions)) {
+    device.khr_maintenance7.reported = true;
+    device.khr_maintenance7.maintenance7_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR;
+    device.khr_maintenance7.maintenance7_features_khr.pNext = features.pNext;
+    features.pNext = &device.khr_maintenance7.maintenance7_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_multiview", device.extensions)) {
+    device.khr_multiview.reported = true;
+    device.khr_multiview.multiview_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
+    device.khr_multiview.multiview_features_khr.pNext = features.pNext;
+    features.pNext = &device.khr_multiview.multiview_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_performance_query", device.extensions)) {
+    device.khr_performance_query.reported = true;
+    device.khr_performance_query.performance_query_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR;
+    device.khr_performance_query.performance_query_features_khr.pNext =
+        features.pNext;
+    features.pNext =
+        &device.khr_performance_query.performance_query_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_pipeline_binary", device.extensions)) {
+    device.khr_pipeline_binary.reported = true;
+    device.khr_pipeline_binary.pipeline_binary_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR;
+    device.khr_pipeline_binary.pipeline_binary_features_khr.pNext =
+        features.pNext;
+    features.pNext = &device.khr_pipeline_binary.pipeline_binary_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_pipeline_executable_properties",
+                   device.extensions)) {
+    device.khr_pipeline_executable_properties.reported = true;
+    device.khr_pipeline_executable_properties
+        .pipeline_executable_properties_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR;
+    device.khr_pipeline_executable_properties
+        .pipeline_executable_properties_features_khr.pNext = features.pNext;
+    features.pNext = &device.khr_pipeline_executable_properties
+                          .pipeline_executable_properties_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_present_id", device.extensions)) {
+    device.khr_present_id.reported = true;
+    device.khr_present_id.present_id_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR;
+    device.khr_present_id.present_id_features_khr.pNext = features.pNext;
+    features.pNext = &device.khr_present_id.present_id_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_present_wait", device.extensions)) {
+    device.khr_present_wait.reported = true;
+    device.khr_present_wait.present_wait_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR;
+    device.khr_present_wait.present_wait_features_khr.pNext = features.pNext;
+    features.pNext = &device.khr_present_wait.present_wait_features_khr;
   }
 
-  vkGetPhysicalDeviceProperties2(physical_device, &properties);
-  device.properties = properties.properties;
+  if (HasExtension("VK_KHR_ray_query", device.extensions)) {
+    device.khr_ray_query.reported = true;
+    device.khr_ray_query.ray_query_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR;
+    device.khr_ray_query.ray_query_features_khr.pNext = features.pNext;
+    features.pNext = &device.khr_ray_query.ray_query_features_khr;
+  }
 
-  VkPhysicalDeviceFeatures2 features = {
-      VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
-      nullptr,
-      {},
-  };
+  if (HasExtension("VK_KHR_ray_tracing_maintenance1", device.extensions)) {
+    device.khr_ray_tracing_maintenance1.reported = true;
+    device.khr_ray_tracing_maintenance1.ray_tracing_maintenance1_features_khr
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR;
+    device.khr_ray_tracing_maintenance1.ray_tracing_maintenance1_features_khr
+        .pNext = features.pNext;
+    features.pNext = &device.khr_ray_tracing_maintenance1
+                          .ray_tracing_maintenance1_features_khr;
+  }
 
-  if (HasExtension("VK_KHR_variable_pointers", device.extensions)) {
-    device.khr_variable_pointers.reported = true;
-    device.khr_variable_pointers.variable_pointer_features_khr.sType =
-        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES;
-    device.khr_variable_pointers.variable_pointer_features_khr.pNext =
+  if (HasExtension("VK_KHR_ray_tracing_pipeline", device.extensions)) {
+    device.khr_ray_tracing_pipeline.reported = true;
+    device.khr_ray_tracing_pipeline.ray_tracing_pipeline_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR;
+    device.khr_ray_tracing_pipeline.ray_tracing_pipeline_features_khr.pNext =
         features.pNext;
     features.pNext =
-        &device.khr_variable_pointers.variable_pointer_features_khr;
-    device.khr_variable_pointers.variable_pointers_features_khr.sType =
-        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES;
-    device.khr_variable_pointers.variable_pointers_features_khr.pNext =
+        &device.khr_ray_tracing_pipeline.ray_tracing_pipeline_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_ray_tracing_position_fetch", device.extensions)) {
+    device.khr_ray_tracing_position_fetch.reported = true;
+    device.khr_ray_tracing_position_fetch
+        .ray_tracing_position_fetch_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR;
+    device.khr_ray_tracing_position_fetch
+        .ray_tracing_position_fetch_features_khr.pNext = features.pNext;
+    features.pNext = &device.khr_ray_tracing_position_fetch
+                          .ray_tracing_position_fetch_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_sampler_ycbcr_conversion", device.extensions)) {
+    device.khr_sampler_ycbcr_conversion.reported = true;
+    device.khr_sampler_ycbcr_conversion.sampler_ycbcr_conversion_features_khr
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;
+    device.khr_sampler_ycbcr_conversion.sampler_ycbcr_conversion_features_khr
+        .pNext = features.pNext;
+    features.pNext = &device.khr_sampler_ycbcr_conversion
+                          .sampler_ycbcr_conversion_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_separate_depth_stencil_layouts",
+                   device.extensions)) {
+    device.khr_separate_depth_stencil_layouts.reported = true;
+    device.khr_separate_depth_stencil_layouts
+        .separate_depth_stencil_layouts_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES;
+    device.khr_separate_depth_stencil_layouts
+        .separate_depth_stencil_layouts_features_khr.pNext = features.pNext;
+    features.pNext = &device.khr_separate_depth_stencil_layouts
+                          .separate_depth_stencil_layouts_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_shader_atomic_int64", device.extensions)) {
+    device.khr_shader_atomic_int64.reported = true;
+    device.khr_shader_atomic_int64.shader_atomic_int64_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES;
+    device.khr_shader_atomic_int64.shader_atomic_int64_features_khr.pNext =
         features.pNext;
     features.pNext =
-        &device.khr_variable_pointers.variable_pointers_features_khr;
+        &device.khr_shader_atomic_int64.shader_atomic_int64_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_shader_clock", device.extensions)) {
+    device.khr_shader_clock.reported = true;
+    device.khr_shader_clock.shader_clock_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR;
+    device.khr_shader_clock.shader_clock_features_khr.pNext = features.pNext;
+    features.pNext = &device.khr_shader_clock.shader_clock_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_shader_expect_assume", device.extensions)) {
+    device.khr_shader_expect_assume.reported = true;
+    device.khr_shader_expect_assume.shader_expect_assume_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES;
+    device.khr_shader_expect_assume.shader_expect_assume_features_khr.pNext =
+        features.pNext;
+    features.pNext =
+        &device.khr_shader_expect_assume.shader_expect_assume_features_khr;
   }
 
   if (HasExtension("VK_KHR_shader_float16_int8", device.extensions)) {
@@ -141,181 +2264,673 @@ VkJsonDevice VkJsonGetDevice(VkPhysicalDevice physical_device) {
     features.pNext = &device.khr_shader_float16_int8.float16_int8_features_khr;
   }
 
-  if (HasExtension("VK_EXT_image_2d_view_of_3d", device.extensions)) {
-    device.ext_image_2d_view_of_3d.reported = true;
-    device.ext_image_2d_view_of_3d.image_2d_view_of_3d_features_ext.sType =
-        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT;
-    device.ext_image_2d_view_of_3d.image_2d_view_of_3d_features_ext.pNext =
+  if (HasExtension("VK_KHR_shader_float_controls2", device.extensions)) {
+    device.khr_shader_float_controls2.reported = true;
+    device.khr_shader_float_controls2.shader_float_controls2_features_khr
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES;
+    device.khr_shader_float_controls2.shader_float_controls2_features_khr
+        .pNext = features.pNext;
+    features.pNext =
+        &device.khr_shader_float_controls2.shader_float_controls2_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_shader_integer_dot_product", device.extensions)) {
+    device.khr_shader_integer_dot_product.reported = true;
+    device.khr_shader_integer_dot_product
+        .shader_integer_dot_product_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES;
+    device.khr_shader_integer_dot_product
+        .shader_integer_dot_product_features_khr.pNext = features.pNext;
+    features.pNext = &device.khr_shader_integer_dot_product
+                          .shader_integer_dot_product_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_shader_maximal_reconvergence", device.extensions)) {
+    device.khr_shader_maximal_reconvergence.reported = true;
+    device.khr_shader_maximal_reconvergence
+        .shader_maximal_reconvergence_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR;
+    device.khr_shader_maximal_reconvergence
+        .shader_maximal_reconvergence_features_khr.pNext = features.pNext;
+    features.pNext = &device.khr_shader_maximal_reconvergence
+                          .shader_maximal_reconvergence_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_shader_quad_control", device.extensions)) {
+    device.khr_shader_quad_control.reported = true;
+    device.khr_shader_quad_control.shader_quad_control_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR;
+    device.khr_shader_quad_control.shader_quad_control_features_khr.pNext =
         features.pNext;
     features.pNext =
-        &device.ext_image_2d_view_of_3d.image_2d_view_of_3d_features_ext;
+        &device.khr_shader_quad_control.shader_quad_control_features_khr;
   }
 
-  if (HasExtension("VK_EXT_custom_border_color", device.extensions)) {
-    device.ext_custom_border_color.reported = true;
-    device.ext_custom_border_color.custom_border_color_features_ext.sType =
-        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT;
-    device.ext_custom_border_color.custom_border_color_features_ext.pNext =
+  if (HasExtension("VK_KHR_shader_relaxed_extended_instruction",
+                   device.extensions)) {
+    device.khr_shader_relaxed_extended_instruction.reported = true;
+    device.khr_shader_relaxed_extended_instruction
+        .shader_relaxed_extended_instruction_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR;
+    device.khr_shader_relaxed_extended_instruction
+        .shader_relaxed_extended_instruction_features_khr.pNext =
         features.pNext;
+    features.pNext = &device.khr_shader_relaxed_extended_instruction
+                          .shader_relaxed_extended_instruction_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_shader_subgroup_extended_types",
+                   device.extensions)) {
+    device.khr_shader_subgroup_extended_types.reported = true;
+    device.khr_shader_subgroup_extended_types
+        .shader_subgroup_extended_types_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES;
+    device.khr_shader_subgroup_extended_types
+        .shader_subgroup_extended_types_features_khr.pNext = features.pNext;
+    features.pNext = &device.khr_shader_subgroup_extended_types
+                          .shader_subgroup_extended_types_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_shader_subgroup_rotate", device.extensions)) {
+    device.khr_shader_subgroup_rotate.reported = true;
+    device.khr_shader_subgroup_rotate.shader_subgroup_rotate_features_khr
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES;
+    device.khr_shader_subgroup_rotate.shader_subgroup_rotate_features_khr
+        .pNext = features.pNext;
     features.pNext =
-        &device.ext_custom_border_color.custom_border_color_features_ext;
+        &device.khr_shader_subgroup_rotate.shader_subgroup_rotate_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_shader_subgroup_uniform_control_flow",
+                   device.extensions)) {
+    device.khr_shader_subgroup_uniform_control_flow.reported = true;
+    device.khr_shader_subgroup_uniform_control_flow
+        .shader_subgroup_uniform_control_flow_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR;
+    device.khr_shader_subgroup_uniform_control_flow
+        .shader_subgroup_uniform_control_flow_features_khr.pNext =
+        features.pNext;
+    features.pNext = &device.khr_shader_subgroup_uniform_control_flow
+                          .shader_subgroup_uniform_control_flow_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_shader_terminate_invocation", device.extensions)) {
+    device.khr_shader_terminate_invocation.reported = true;
+    device.khr_shader_terminate_invocation
+        .shader_terminate_invocation_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES;
+    device.khr_shader_terminate_invocation
+        .shader_terminate_invocation_features_khr.pNext = features.pNext;
+    features.pNext = &device.khr_shader_terminate_invocation
+                          .shader_terminate_invocation_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_synchronization2", device.extensions)) {
+    device.khr_synchronization2.reported = true;
+    device.khr_synchronization2.synchronization2_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES;
+    device.khr_synchronization2.synchronization2_features_khr.pNext =
+        features.pNext;
+    features.pNext = &device.khr_synchronization2.synchronization2_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_timeline_semaphore", device.extensions)) {
+    device.khr_timeline_semaphore.reported = true;
+    device.khr_timeline_semaphore.timeline_semaphore_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES;
+    device.khr_timeline_semaphore.timeline_semaphore_features_khr.pNext =
+        features.pNext;
+    features.pNext =
+        &device.khr_timeline_semaphore.timeline_semaphore_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_uniform_buffer_standard_layout",
+                   device.extensions)) {
+    device.khr_uniform_buffer_standard_layout.reported = true;
+    device.khr_uniform_buffer_standard_layout
+        .uniform_buffer_standard_layout_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES;
+    device.khr_uniform_buffer_standard_layout
+        .uniform_buffer_standard_layout_features_khr.pNext = features.pNext;
+    features.pNext = &device.khr_uniform_buffer_standard_layout
+                          .uniform_buffer_standard_layout_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_variable_pointers", device.extensions)) {
+    device.khr_variable_pointers.reported = true;
+    device.khr_variable_pointers.variable_pointer_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
+    device.khr_variable_pointers.variable_pointer_features_khr.pNext =
+        features.pNext;
+    features.pNext =
+        &device.khr_variable_pointers.variable_pointer_features_khr;
+    device.khr_variable_pointers.variable_pointers_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
+    device.khr_variable_pointers.variable_pointers_features_khr.pNext =
+        features.pNext;
+    features.pNext =
+        &device.khr_variable_pointers.variable_pointers_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_vertex_attribute_divisor", device.extensions)) {
+    device.khr_vertex_attribute_divisor.reported = true;
+    device.khr_vertex_attribute_divisor.vertex_attribute_divisor_features_khr
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES;
+    device.khr_vertex_attribute_divisor.vertex_attribute_divisor_features_khr
+        .pNext = features.pNext;
+    features.pNext = &device.khr_vertex_attribute_divisor
+                          .vertex_attribute_divisor_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_video_maintenance1", device.extensions)) {
+    device.khr_video_maintenance1.reported = true;
+    device.khr_video_maintenance1.video_maintenance1_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR;
+    device.khr_video_maintenance1.video_maintenance1_features_khr.pNext =
+        features.pNext;
+    features.pNext =
+        &device.khr_video_maintenance1.video_maintenance1_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_vulkan_memory_model", device.extensions)) {
+    device.khr_vulkan_memory_model.reported = true;
+    device.khr_vulkan_memory_model.vulkan_memory_model_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES;
+    device.khr_vulkan_memory_model.vulkan_memory_model_features_khr.pNext =
+        features.pNext;
+    features.pNext =
+        &device.khr_vulkan_memory_model.vulkan_memory_model_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_workgroup_memory_explicit_layout",
+                   device.extensions)) {
+    device.khr_workgroup_memory_explicit_layout.reported = true;
+    device.khr_workgroup_memory_explicit_layout
+        .workgroup_memory_explicit_layout_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR;
+    device.khr_workgroup_memory_explicit_layout
+        .workgroup_memory_explicit_layout_features_khr.pNext = features.pNext;
+    features.pNext = &device.khr_workgroup_memory_explicit_layout
+                          .workgroup_memory_explicit_layout_features_khr;
+  }
+
+  if (HasExtension("VK_KHR_zero_initialize_workgroup_memory",
+                   device.extensions)) {
+    device.khr_zero_initialize_workgroup_memory.reported = true;
+    device.khr_zero_initialize_workgroup_memory
+        .zero_initialize_workgroup_memory_features_khr.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES;
+    device.khr_zero_initialize_workgroup_memory
+        .zero_initialize_workgroup_memory_features_khr.pNext = features.pNext;
+    features.pNext = &device.khr_zero_initialize_workgroup_memory
+                          .zero_initialize_workgroup_memory_features_khr;
+  }
+
+  if (HasExtension("VK_MESA_image_alignment_control", device.extensions)) {
+    device.mesa_image_alignment_control.reported = true;
+    device.mesa_image_alignment_control.image_alignment_control_features_mesa
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA;
+    device.mesa_image_alignment_control.image_alignment_control_features_mesa
+        .pNext = features.pNext;
+    features.pNext = &device.mesa_image_alignment_control
+                          .image_alignment_control_features_mesa;
+  }
+
+  if (HasExtension("VK_NV_command_buffer_inheritance", device.extensions)) {
+    device.nv_command_buffer_inheritance.reported = true;
+    device.nv_command_buffer_inheritance.command_buffer_inheritance_features_nv
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV;
+    device.nv_command_buffer_inheritance.command_buffer_inheritance_features_nv
+        .pNext = features.pNext;
+    features.pNext = &device.nv_command_buffer_inheritance
+                          .command_buffer_inheritance_features_nv;
+  }
+
+  if (HasExtension("VK_NV_compute_shader_derivatives", device.extensions)) {
+    device.nv_compute_shader_derivatives.reported = true;
+    device.nv_compute_shader_derivatives.compute_shader_derivatives_features_nv
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV;
+    device.nv_compute_shader_derivatives.compute_shader_derivatives_features_nv
+        .pNext = features.pNext;
+    features.pNext = &device.nv_compute_shader_derivatives
+                          .compute_shader_derivatives_features_nv;
+  }
+
+  if (HasExtension("VK_NV_cooperative_matrix", device.extensions)) {
+    device.nv_cooperative_matrix.reported = true;
+    device.nv_cooperative_matrix.cooperative_matrix_features_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV;
+    device.nv_cooperative_matrix.cooperative_matrix_features_nv.pNext =
+        features.pNext;
+    features.pNext =
+        &device.nv_cooperative_matrix.cooperative_matrix_features_nv;
+  }
+
+  if (HasExtension("VK_NV_copy_memory_indirect", device.extensions)) {
+    device.nv_copy_memory_indirect.reported = true;
+    device.nv_copy_memory_indirect.copy_memory_indirect_features_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV;
+    device.nv_copy_memory_indirect.copy_memory_indirect_features_nv.pNext =
+        features.pNext;
+    features.pNext =
+        &device.nv_copy_memory_indirect.copy_memory_indirect_features_nv;
+  }
+
+  if (HasExtension("VK_NV_corner_sampled_image", device.extensions)) {
+    device.nv_corner_sampled_image.reported = true;
+    device.nv_corner_sampled_image.corner_sampled_image_features_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV;
+    device.nv_corner_sampled_image.corner_sampled_image_features_nv.pNext =
+        features.pNext;
+    features.pNext =
+        &device.nv_corner_sampled_image.corner_sampled_image_features_nv;
+  }
+
+  if (HasExtension("VK_NV_coverage_reduction_mode", device.extensions)) {
+    device.nv_coverage_reduction_mode.reported = true;
+    device.nv_coverage_reduction_mode.coverage_reduction_mode_features_nv
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV;
+    device.nv_coverage_reduction_mode.coverage_reduction_mode_features_nv
+        .pNext = features.pNext;
+    features.pNext =
+        &device.nv_coverage_reduction_mode.coverage_reduction_mode_features_nv;
+  }
+
+  if (HasExtension("VK_NV_cuda_kernel_launch", device.extensions)) {
+    device.nv_cuda_kernel_launch.reported = true;
+    device.nv_cuda_kernel_launch.cuda_kernel_launch_features_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV;
+    device.nv_cuda_kernel_launch.cuda_kernel_launch_features_nv.pNext =
+        features.pNext;
+    features.pNext =
+        &device.nv_cuda_kernel_launch.cuda_kernel_launch_features_nv;
+  }
+
+  if (HasExtension("VK_NV_dedicated_allocation_image_aliasing",
+                   device.extensions)) {
+    device.nv_dedicated_allocation_image_aliasing.reported = true;
+    device.nv_dedicated_allocation_image_aliasing
+        .dedicated_allocation_image_aliasing_features_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV;
+    device.nv_dedicated_allocation_image_aliasing
+        .dedicated_allocation_image_aliasing_features_nv.pNext = features.pNext;
+    features.pNext = &device.nv_dedicated_allocation_image_aliasing
+                          .dedicated_allocation_image_aliasing_features_nv;
+  }
+
+  if (HasExtension("VK_NV_descriptor_pool_overallocation", device.extensions)) {
+    device.nv_descriptor_pool_overallocation.reported = true;
+    device.nv_descriptor_pool_overallocation
+        .descriptor_pool_overallocation_features_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV;
+    device.nv_descriptor_pool_overallocation
+        .descriptor_pool_overallocation_features_nv.pNext = features.pNext;
+    features.pNext = &device.nv_descriptor_pool_overallocation
+                          .descriptor_pool_overallocation_features_nv;
+  }
+
+  if (HasExtension("VK_NV_device_diagnostics_config", device.extensions)) {
+    device.nv_device_diagnostics_config.reported = true;
+    device.nv_device_diagnostics_config.diagnostics_config_features_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV;
+    device.nv_device_diagnostics_config.diagnostics_config_features_nv.pNext =
+        features.pNext;
+    features.pNext =
+        &device.nv_device_diagnostics_config.diagnostics_config_features_nv;
+  }
+
+  if (HasExtension("VK_NV_device_generated_commands", device.extensions)) {
+    device.nv_device_generated_commands.reported = true;
+    device.nv_device_generated_commands.device_generated_commands_features_nv
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV;
+    device.nv_device_generated_commands.device_generated_commands_features_nv
+        .pNext = features.pNext;
+    features.pNext = &device.nv_device_generated_commands
+                          .device_generated_commands_features_nv;
+  }
+
+  if (HasExtension("VK_NV_device_generated_commands_compute",
+                   device.extensions)) {
+    device.nv_device_generated_commands_compute.reported = true;
+    device.nv_device_generated_commands_compute
+        .device_generated_commands_compute_features_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV;
+    device.nv_device_generated_commands_compute
+        .device_generated_commands_compute_features_nv.pNext = features.pNext;
+    features.pNext = &device.nv_device_generated_commands_compute
+                          .device_generated_commands_compute_features_nv;
+  }
+
+  if (HasExtension("VK_NV_extended_sparse_address_space", device.extensions)) {
+    device.nv_extended_sparse_address_space.reported = true;
+    device.nv_extended_sparse_address_space
+        .extended_sparse_address_space_features_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV;
+    device.nv_extended_sparse_address_space
+        .extended_sparse_address_space_features_nv.pNext = features.pNext;
+    features.pNext = &device.nv_extended_sparse_address_space
+                          .extended_sparse_address_space_features_nv;
+  }
+
+  if (HasExtension("VK_NV_external_memory_rdma", device.extensions)) {
+    device.nv_external_memory_rdma.reported = true;
+    device.nv_external_memory_rdma.external_memory_rdma_features_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV;
+    device.nv_external_memory_rdma.external_memory_rdma_features_nv.pNext =
+        features.pNext;
+    features.pNext =
+        &device.nv_external_memory_rdma.external_memory_rdma_features_nv;
+  }
+
+  if (HasExtension("VK_NV_fragment_shading_rate_enums", device.extensions)) {
+    device.nv_fragment_shading_rate_enums.reported = true;
+    device.nv_fragment_shading_rate_enums
+        .fragment_shading_rate_enums_features_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV;
+    device.nv_fragment_shading_rate_enums
+        .fragment_shading_rate_enums_features_nv.pNext = features.pNext;
+    features.pNext = &device.nv_fragment_shading_rate_enums
+                          .fragment_shading_rate_enums_features_nv;
+  }
+
+  if (HasExtension("VK_NV_inherited_viewport_scissor", device.extensions)) {
+    device.nv_inherited_viewport_scissor.reported = true;
+    device.nv_inherited_viewport_scissor.inherited_viewport_scissor_features_nv
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV;
+    device.nv_inherited_viewport_scissor.inherited_viewport_scissor_features_nv
+        .pNext = features.pNext;
+    features.pNext = &device.nv_inherited_viewport_scissor
+                          .inherited_viewport_scissor_features_nv;
+  }
+
+  if (HasExtension("VK_NV_linear_color_attachment", device.extensions)) {
+    device.nv_linear_color_attachment.reported = true;
+    device.nv_linear_color_attachment.linear_color_attachment_features_nv
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV;
+    device.nv_linear_color_attachment.linear_color_attachment_features_nv
+        .pNext = features.pNext;
+    features.pNext =
+        &device.nv_linear_color_attachment.linear_color_attachment_features_nv;
+  }
+
+  if (HasExtension("VK_NV_memory_decompression", device.extensions)) {
+    device.nv_memory_decompression.reported = true;
+    device.nv_memory_decompression.memory_decompression_features_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV;
+    device.nv_memory_decompression.memory_decompression_features_nv.pNext =
+        features.pNext;
+    features.pNext =
+        &device.nv_memory_decompression.memory_decompression_features_nv;
+  }
+
+  if (HasExtension("VK_NV_mesh_shader", device.extensions)) {
+    device.nv_mesh_shader.reported = true;
+    device.nv_mesh_shader.mesh_shader_features_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV;
+    device.nv_mesh_shader.mesh_shader_features_nv.pNext = features.pNext;
+    features.pNext = &device.nv_mesh_shader.mesh_shader_features_nv;
+  }
+
+  if (HasExtension("VK_NV_optical_flow", device.extensions)) {
+    device.nv_optical_flow.reported = true;
+    device.nv_optical_flow.optical_flow_features_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV;
+    device.nv_optical_flow.optical_flow_features_nv.pNext = features.pNext;
+    features.pNext = &device.nv_optical_flow.optical_flow_features_nv;
+  }
+
+  if (HasExtension("VK_NV_per_stage_descriptor_set", device.extensions)) {
+    device.nv_per_stage_descriptor_set.reported = true;
+    device.nv_per_stage_descriptor_set.per_stage_descriptor_set_features_nv
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV;
+    device.nv_per_stage_descriptor_set.per_stage_descriptor_set_features_nv
+        .pNext = features.pNext;
+    features.pNext = &device.nv_per_stage_descriptor_set
+                          .per_stage_descriptor_set_features_nv;
+  }
+
+  if (HasExtension("VK_NV_present_barrier", device.extensions)) {
+    device.nv_present_barrier.reported = true;
+    device.nv_present_barrier.present_barrier_features_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV;
+    device.nv_present_barrier.present_barrier_features_nv.pNext =
+        features.pNext;
+    features.pNext = &device.nv_present_barrier.present_barrier_features_nv;
+  }
+
+  if (HasExtension("VK_NV_raw_access_chains", device.extensions)) {
+    device.nv_raw_access_chains.reported = true;
+    device.nv_raw_access_chains.raw_access_chains_features_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV;
+    device.nv_raw_access_chains.raw_access_chains_features_nv.pNext =
+        features.pNext;
+    features.pNext = &device.nv_raw_access_chains.raw_access_chains_features_nv;
+  }
+
+  if (HasExtension("VK_NV_ray_tracing_invocation_reorder", device.extensions)) {
+    device.nv_ray_tracing_invocation_reorder.reported = true;
+    device.nv_ray_tracing_invocation_reorder
+        .ray_tracing_invocation_reorder_features_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV;
+    device.nv_ray_tracing_invocation_reorder
+        .ray_tracing_invocation_reorder_features_nv.pNext = features.pNext;
+    features.pNext = &device.nv_ray_tracing_invocation_reorder
+                          .ray_tracing_invocation_reorder_features_nv;
+  }
+
+  if (HasExtension("VK_NV_ray_tracing_motion_blur", device.extensions)) {
+    device.nv_ray_tracing_motion_blur.reported = true;
+    device.nv_ray_tracing_motion_blur.ray_tracing_motion_blur_features_nv
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV;
+    device.nv_ray_tracing_motion_blur.ray_tracing_motion_blur_features_nv
+        .pNext = features.pNext;
+    features.pNext =
+        &device.nv_ray_tracing_motion_blur.ray_tracing_motion_blur_features_nv;
+  }
+
+  if (HasExtension("VK_NV_ray_tracing_validation", device.extensions)) {
+    device.nv_ray_tracing_validation.reported = true;
+    device.nv_ray_tracing_validation.ray_tracing_validation_features_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV;
+    device.nv_ray_tracing_validation.ray_tracing_validation_features_nv.pNext =
+        features.pNext;
+    features.pNext =
+        &device.nv_ray_tracing_validation.ray_tracing_validation_features_nv;
+  }
+
+  if (HasExtension("VK_NV_representative_fragment_test", device.extensions)) {
+    device.nv_representative_fragment_test.reported = true;
+    device.nv_representative_fragment_test
+        .representative_fragment_test_features_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV;
+    device.nv_representative_fragment_test
+        .representative_fragment_test_features_nv.pNext = features.pNext;
+    features.pNext = &device.nv_representative_fragment_test
+                          .representative_fragment_test_features_nv;
+  }
+
+  if (HasExtension("VK_NV_scissor_exclusive", device.extensions)) {
+    device.nv_scissor_exclusive.reported = true;
+    device.nv_scissor_exclusive.exclusive_scissor_features_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV;
+    device.nv_scissor_exclusive.exclusive_scissor_features_nv.pNext =
+        features.pNext;
+    features.pNext = &device.nv_scissor_exclusive.exclusive_scissor_features_nv;
   }
 
-  if (HasExtension("VK_EXT_primitive_topology_list_restart",
-                   device.extensions)) {
-    device.ext_primitive_topology_list_restart.reported = true;
-    device.ext_primitive_topology_list_restart
-        .primitive_topology_list_restart_features_ext.sType =
-        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT;
-    device.ext_primitive_topology_list_restart
-        .primitive_topology_list_restart_features_ext.pNext = features.pNext;
-    features.pNext = &device.ext_primitive_topology_list_restart
-                          .primitive_topology_list_restart_features_ext;
+  if (HasExtension("VK_NV_shader_atomic_float16_vector", device.extensions)) {
+    device.nv_shader_atomic_float16_vector.reported = true;
+    device.nv_shader_atomic_float16_vector
+        .shader_atomic_float16_vector_features_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV;
+    device.nv_shader_atomic_float16_vector
+        .shader_atomic_float16_vector_features_nv.pNext = features.pNext;
+    features.pNext = &device.nv_shader_atomic_float16_vector
+                          .shader_atomic_float16_vector_features_nv;
   }
 
-  if (HasExtension("VK_EXT_provoking_vertex", device.extensions)) {
-    device.ext_provoking_vertex.reported = true;
-    device.ext_provoking_vertex.provoking_vertex_features_ext.sType =
-        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT;
-    device.ext_provoking_vertex.provoking_vertex_features_ext.pNext =
+  if (HasExtension("VK_NV_shader_image_footprint", device.extensions)) {
+    device.nv_shader_image_footprint.reported = true;
+    device.nv_shader_image_footprint.shader_image_footprint_features_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV;
+    device.nv_shader_image_footprint.shader_image_footprint_features_nv.pNext =
         features.pNext;
-    features.pNext = &device.ext_provoking_vertex.provoking_vertex_features_ext;
+    features.pNext =
+        &device.nv_shader_image_footprint.shader_image_footprint_features_nv;
   }
 
-  if (HasExtension("VK_KHR_index_type_uint8", device.extensions)) {
-    device.khr_index_type_uint8.reported = true;
-    device.khr_index_type_uint8.index_type_uint8_features_khr.sType =
-        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES;
-    device.khr_index_type_uint8.index_type_uint8_features_khr.pNext =
+  if (HasExtension("VK_NV_shader_sm_builtins", device.extensions)) {
+    device.nv_shader_sm_builtins.reported = true;
+    device.nv_shader_sm_builtins.shader_sm_builtins_features_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV;
+    device.nv_shader_sm_builtins.shader_sm_builtins_features_nv.pNext =
         features.pNext;
-    features.pNext = &device.khr_index_type_uint8.index_type_uint8_features_khr;
+    features.pNext =
+        &device.nv_shader_sm_builtins.shader_sm_builtins_features_nv;
   }
 
-  if (HasExtension("VK_EXT_index_type_uint8", device.extensions)) {
-    device.ext_index_type_uint8.reported = true;
-    device.ext_index_type_uint8.index_type_uint8_features_ext.sType =
-        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES;
-    device.ext_index_type_uint8.index_type_uint8_features_ext.pNext =
+  if (HasExtension("VK_NV_shading_rate_image", device.extensions)) {
+    device.nv_shading_rate_image.reported = true;
+    device.nv_shading_rate_image.shading_rate_image_features_nv.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV;
+    device.nv_shading_rate_image.shading_rate_image_features_nv.pNext =
         features.pNext;
-    features.pNext = &device.ext_index_type_uint8.index_type_uint8_features_ext;
+    features.pNext =
+        &device.nv_shading_rate_image.shading_rate_image_features_nv;
   }
 
-  if (HasExtension("VK_KHR_vertex_attribute_divisor", device.extensions)) {
-    device.khr_vertex_attribute_divisor.reported = true;
-    device.khr_vertex_attribute_divisor.vertex_attribute_divisor_features_khr
-        .sType =
-        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES;
-    device.khr_vertex_attribute_divisor.vertex_attribute_divisor_features_khr
-        .pNext = features.pNext;
-    features.pNext = &device.khr_vertex_attribute_divisor
-                          .vertex_attribute_divisor_features_khr;
+  if (HasExtension("VK_QCOM_filter_cubic_clamp", device.extensions)) {
+    device.qcom_filter_cubic_clamp.reported = true;
+    device.qcom_filter_cubic_clamp.cubic_clamp_features_qcom.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM;
+    device.qcom_filter_cubic_clamp.cubic_clamp_features_qcom.pNext =
+        features.pNext;
+    features.pNext = &device.qcom_filter_cubic_clamp.cubic_clamp_features_qcom;
   }
 
-  if (HasExtension("VK_EXT_vertex_attribute_divisor", device.extensions)) {
-    device.ext_vertex_attribute_divisor.reported = true;
-    device.ext_vertex_attribute_divisor.vertex_attribute_divisor_features_ext
-        .sType =
-        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES;
-    device.ext_vertex_attribute_divisor.vertex_attribute_divisor_features_ext
-        .pNext = features.pNext;
-    features.pNext = &device.ext_vertex_attribute_divisor
-                          .vertex_attribute_divisor_features_ext;
+  if (HasExtension("VK_QCOM_filter_cubic_weights", device.extensions)) {
+    device.qcom_filter_cubic_weights.reported = true;
+    device.qcom_filter_cubic_weights.cubic_weights_features_qcom.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM;
+    device.qcom_filter_cubic_weights.cubic_weights_features_qcom.pNext =
+        features.pNext;
+    features.pNext =
+        &device.qcom_filter_cubic_weights.cubic_weights_features_qcom;
   }
 
-  if (HasExtension("VK_EXT_transform_feedback", device.extensions)) {
-    device.ext_transform_feedback.reported = true;
-    device.ext_transform_feedback.transform_feedback_features_ext.sType =
-        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT;
-    device.ext_transform_feedback.transform_feedback_features_ext.pNext =
+  if (HasExtension("VK_QCOM_fragment_density_map_offset", device.extensions)) {
+    device.qcom_fragment_density_map_offset.reported = true;
+    device.qcom_fragment_density_map_offset
+        .fragment_density_map_offset_features_qcom.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM;
+    device.qcom_fragment_density_map_offset
+        .fragment_density_map_offset_features_qcom.pNext = features.pNext;
+    features.pNext = &device.qcom_fragment_density_map_offset
+                          .fragment_density_map_offset_features_qcom;
+  }
+
+  if (HasExtension("VK_QCOM_image_processing", device.extensions)) {
+    device.qcom_image_processing.reported = true;
+    device.qcom_image_processing.image_processing_features_qcom.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM;
+    device.qcom_image_processing.image_processing_features_qcom.pNext =
         features.pNext;
     features.pNext =
-        &device.ext_transform_feedback.transform_feedback_features_ext;
+        &device.qcom_image_processing.image_processing_features_qcom;
   }
 
-  if (HasExtension("VK_KHR_shader_subgroup_uniform_control_flow",
-                   device.extensions)) {
-    device.khr_shader_subgroup_uniform_control_flow.reported = true;
-    device.khr_shader_subgroup_uniform_control_flow
-        .shader_subgroup_uniform_control_flow_features_khr.sType =
-        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR;
-    device.khr_shader_subgroup_uniform_control_flow
-        .shader_subgroup_uniform_control_flow_features_khr.pNext =
+  if (HasExtension("VK_QCOM_image_processing2", device.extensions)) {
+    device.qcom_image_processing2.reported = true;
+    device.qcom_image_processing2.image_processing2_features_qcom.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM;
+    device.qcom_image_processing2.image_processing2_features_qcom.pNext =
         features.pNext;
-    features.pNext = &device.khr_shader_subgroup_uniform_control_flow
-                          .shader_subgroup_uniform_control_flow_features_khr;
+    features.pNext =
+        &device.qcom_image_processing2.image_processing2_features_qcom;
   }
 
-  if (HasExtension("VK_KHR_shader_subgroup_extended_types",
+  if (HasExtension("VK_QCOM_multiview_per_view_render_areas",
                    device.extensions)) {
-    device.khr_shader_subgroup_extended_types.reported = true;
-    device.khr_shader_subgroup_extended_types
-        .shader_subgroup_extended_types_features_khr.sType =
-        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES;
-    device.khr_shader_subgroup_extended_types
-        .shader_subgroup_extended_types_features_khr.pNext = features.pNext;
-    features.pNext = &device.khr_shader_subgroup_extended_types
-                          .shader_subgroup_extended_types_features_khr;
+    device.qcom_multiview_per_view_render_areas.reported = true;
+    device.qcom_multiview_per_view_render_areas
+        .multiview_per_view_render_areas_features_qcom.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM;
+    device.qcom_multiview_per_view_render_areas
+        .multiview_per_view_render_areas_features_qcom.pNext = features.pNext;
+    features.pNext = &device.qcom_multiview_per_view_render_areas
+                          .multiview_per_view_render_areas_features_qcom;
   }
 
-  if (HasExtension("VK_KHR_8bit_storage", device.extensions)) {
-    device.khr_8bit_storage.reported = true;
-    device.khr_8bit_storage.bit8_storage_features_khr.sType =
-        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES;
-    device.khr_8bit_storage.bit8_storage_features_khr.pNext = features.pNext;
-    features.pNext = &device.khr_8bit_storage.bit8_storage_features_khr;
+  if (HasExtension("VK_QCOM_multiview_per_view_viewports", device.extensions)) {
+    device.qcom_multiview_per_view_viewports.reported = true;
+    device.qcom_multiview_per_view_viewports
+        .multiview_per_view_viewports_features_qcom.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM;
+    device.qcom_multiview_per_view_viewports
+        .multiview_per_view_viewports_features_qcom.pNext = features.pNext;
+    features.pNext = &device.qcom_multiview_per_view_viewports
+                          .multiview_per_view_viewports_features_qcom;
   }
 
-  if (HasExtension("VK_KHR_shader_integer_dot_product", device.extensions)) {
-    device.khr_shader_integer_dot_product.reported = true;
-    device.khr_shader_integer_dot_product
-        .shader_integer_dot_product_features_khr.sType =
-        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES;
-    device.khr_shader_integer_dot_product
-        .shader_integer_dot_product_features_khr.pNext = features.pNext;
-    features.pNext = &device.khr_shader_integer_dot_product
-                          .shader_integer_dot_product_features_khr;
+  if (HasExtension("VK_QCOM_tile_properties", device.extensions)) {
+    device.qcom_tile_properties.reported = true;
+    device.qcom_tile_properties.tile_properties_features_qcom.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM;
+    device.qcom_tile_properties.tile_properties_features_qcom.pNext =
+        features.pNext;
+    features.pNext = &device.qcom_tile_properties.tile_properties_features_qcom;
   }
 
-  if (HasExtension("VK_IMG_relaxed_line_rasterization", device.extensions)) {
-    device.img_relaxed_line_rasterization.reported = true;
-    device.img_relaxed_line_rasterization
-        .relaxed_line_rasterization_features_img.sType =
-        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG;
-    device.img_relaxed_line_rasterization
-        .relaxed_line_rasterization_features_img.pNext = features.pNext;
-    features.pNext = &device.img_relaxed_line_rasterization
-                          .relaxed_line_rasterization_features_img;
+  if (HasExtension("VK_QCOM_ycbcr_degamma", device.extensions)) {
+    device.qcom_ycbcr_degamma.reported = true;
+    device.qcom_ycbcr_degamma.ycbcr_degamma_features_qcom.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM;
+    device.qcom_ycbcr_degamma.ycbcr_degamma_features_qcom.pNext =
+        features.pNext;
+    features.pNext = &device.qcom_ycbcr_degamma.ycbcr_degamma_features_qcom;
   }
 
-  if (HasExtension("VK_KHR_line_rasterization", device.extensions)) {
-    device.khr_line_rasterization.reported = true;
-    device.khr_line_rasterization.line_rasterization_features_khr.sType =
-        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES;
-    device.khr_line_rasterization.line_rasterization_features_khr.pNext =
+  if (HasExtension("VK_SEC_amigo_profiling", device.extensions)) {
+    device.sec_amigo_profiling.reported = true;
+    device.sec_amigo_profiling.amigo_profiling_features_sec.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC;
+    device.sec_amigo_profiling.amigo_profiling_features_sec.pNext =
         features.pNext;
-    features.pNext =
-        &device.khr_line_rasterization.line_rasterization_features_khr;
+    features.pNext = &device.sec_amigo_profiling.amigo_profiling_features_sec;
   }
 
-  if (HasExtension("VK_EXT_line_rasterization", device.extensions)) {
-    device.ext_line_rasterization.reported = true;
-    device.ext_line_rasterization.line_rasterization_features_ext.sType =
-        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES;
-    device.ext_line_rasterization.line_rasterization_features_ext.pNext =
-        features.pNext;
-    features.pNext =
-        &device.ext_line_rasterization.line_rasterization_features_ext;
+  if (HasExtension("VK_VALVE_descriptor_set_host_mapping", device.extensions)) {
+    device.valve_descriptor_set_host_mapping.reported = true;
+    device.valve_descriptor_set_host_mapping
+        .descriptor_set_host_mapping_features_valve.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE;
+    device.valve_descriptor_set_host_mapping
+        .descriptor_set_host_mapping_features_valve.pNext = features.pNext;
+    features.pNext = &device.valve_descriptor_set_host_mapping
+                          .descriptor_set_host_mapping_features_valve;
   }
 
-  if (HasExtension("VK_EXT_primitives_generated_query", device.extensions)) {
-    device.ext_primitives_generated_query.reported = true;
-    device.ext_primitives_generated_query
-        .primitives_generated_query_features_ext.sType =
-        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT;
-    device.ext_primitives_generated_query
-        .primitives_generated_query_features_ext.pNext = features.pNext;
-    features.pNext = &device.ext_primitives_generated_query
-                          .primitives_generated_query_features_ext;
+  if (HasExtension("VK_VALVE_mutable_descriptor_type", device.extensions)) {
+    device.valve_mutable_descriptor_type.reported = true;
+    device.valve_mutable_descriptor_type.mutable_descriptor_type_features_valve
+        .sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT;
+    device.valve_mutable_descriptor_type.mutable_descriptor_type_features_valve
+        .pNext = features.pNext;
+    features.pNext = &device.valve_mutable_descriptor_type
+                          .mutable_descriptor_type_features_valve;
   }
 
   vkGetPhysicalDeviceFeatures2(physical_device, &features);
@@ -334,32 +2949,94 @@ VkJsonDevice VkJsonGetDevice(VkPhysicalDevice physical_device) {
 
   VkFormatProperties format_properties = {};
   for (VkFormat format = VK_FORMAT_R4G4_UNORM_PACK8;
-       // TODO(http://b/171403054): avoid hard-coding last value in the
-       // contiguous range
        format <= VK_FORMAT_ASTC_12x12_SRGB_BLOCK;
        format = static_cast<VkFormat>(format + 1)) {
     vkGetPhysicalDeviceFormatProperties(physical_device, format,
                                         &format_properties);
-    if (format_properties.linearTilingFeatures ||
-        format_properties.optimalTilingFeatures ||
-        format_properties.bufferFeatures) {
+    device.formats.insert(std::make_pair(format, format_properties));
+  }
+
+  if (HasExtension("VK_IMG_format_pvrtc", device.extensions)) {
+    for (VkFormat format = VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG;
+         format <= VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG;
+         format = static_cast<VkFormat>(format + 1)) {
+      vkGetPhysicalDeviceFormatProperties(physical_device, format,
+                                          &format_properties);
+      device.formats.insert(std::make_pair(format, format_properties));
+    }
+  }
+
+  if (HasExtension("VK_EXT_texture_compression_astc_hdr", device.extensions)) {
+    for (VkFormat format = VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT;
+         format <= VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT;
+         format = static_cast<VkFormat>(format + 1)) {
+      vkGetPhysicalDeviceFormatProperties(physical_device, format,
+                                          &format_properties);
+      device.formats.insert(std::make_pair(format, format_properties));
+    }
+  }
+
+  if (HasExtension("VK_KHR_sampler_ycbcr_conversion", device.extensions)) {
+    for (VkFormat format = VK_FORMAT_G8B8G8R8_422_UNORM_KHR;
+         format <= VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR;
+         format = static_cast<VkFormat>(format + 1)) {
+      vkGetPhysicalDeviceFormatProperties(physical_device, format,
+                                          &format_properties);
+      device.formats.insert(std::make_pair(format, format_properties));
+    }
+  }
+
+  if (HasExtension("VK_EXT_ycbcr_2plane_444_formats", device.extensions)) {
+    for (VkFormat format = VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT;
+         format <= VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT;
+         format = static_cast<VkFormat>(format + 1)) {
+      vkGetPhysicalDeviceFormatProperties(physical_device, format,
+                                          &format_properties);
+      device.formats.insert(std::make_pair(format, format_properties));
+    }
+  }
+
+  if (HasExtension("VK_EXT_4444_formats", device.extensions)) {
+    for (VkFormat format = VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT;
+         format <= VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT;
+         format = static_cast<VkFormat>(format + 1)) {
+      vkGetPhysicalDeviceFormatProperties(physical_device, format,
+                                          &format_properties);
+      device.formats.insert(std::make_pair(format, format_properties));
+    }
+  }
+
+  if (HasExtension("VK_NV_optical_flow", device.extensions)) {
+    VkFormat format = VK_FORMAT_R16G16_SFIXED5_NV;
+    vkGetPhysicalDeviceFormatProperties(physical_device, format,
+                                        &format_properties);
+    device.formats.insert(std::make_pair(format, format_properties));
+  }
+
+  if (HasExtension("VK_NV_optical_flow", device.extensions)) {
+    VkFormat format = VK_FORMAT_R16G16_S10_5_NV;
+    vkGetPhysicalDeviceFormatProperties(physical_device, format,
+                                        &format_properties);
+    device.formats.insert(std::make_pair(format, format_properties));
+  }
+
+  if (HasExtension("VK_KHR_maintenance5", device.extensions)) {
+    for (VkFormat format = VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR;
+         format <= VK_FORMAT_A8_UNORM_KHR;
+         format = static_cast<VkFormat>(format + 1)) {
+      vkGetPhysicalDeviceFormatProperties(physical_device, format,
+                                          &format_properties);
       device.formats.insert(std::make_pair(format, format_properties));
     }
   }
 
   if (device.properties.apiVersion >= VK_API_VERSION_1_1) {
     for (VkFormat format = VK_FORMAT_G8B8G8R8_422_UNORM;
-         // TODO(http://b/171403054): avoid hard-coding last value in the
-         // contiguous range
          format <= VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM;
          format = static_cast<VkFormat>(format + 1)) {
       vkGetPhysicalDeviceFormatProperties(physical_device, format,
                                           &format_properties);
-      if (format_properties.linearTilingFeatures ||
-          format_properties.optimalTilingFeatures ||
-          format_properties.bufferFeatures) {
-        device.formats.insert(std::make_pair(format, format_properties));
-      }
+      device.formats.insert(std::make_pair(format, format_properties));
     }
 
     device.subgroup_properties.sType =
@@ -377,6 +3054,11 @@ VkJsonDevice VkJsonGetDevice(VkPhysicalDevice physical_device) {
     device.multiview_properties.pNext = properties.pNext;
     properties.pNext = &device.multiview_properties;
 
+    device.protected_memory_properties.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES;
+    device.protected_memory_properties.pNext = properties.pNext;
+    properties.pNext = &device.protected_memory_properties;
+
     device.id_properties.sType =
         VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES;
     device.id_properties.pNext = properties.pNext;
@@ -389,11 +3071,21 @@ VkJsonDevice VkJsonGetDevice(VkPhysicalDevice physical_device) {
 
     vkGetPhysicalDeviceProperties2(physical_device, &properties);
 
+    device.bit16_storage_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;
+    device.bit16_storage_features.pNext = features.pNext;
+    features.pNext = &device.bit16_storage_features;
+
     device.multiview_features.sType =
         VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
     device.multiview_features.pNext = features.pNext;
     features.pNext = &device.multiview_features;
 
+    device.variable_pointer_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
+    device.variable_pointer_features.pNext = features.pNext;
+    features.pNext = &device.variable_pointer_features;
+
     device.variable_pointers_features.sType =
         VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
     device.variable_pointers_features.pNext = features.pNext;
@@ -414,10 +3106,10 @@ VkJsonDevice VkJsonGetDevice(VkPhysicalDevice physical_device) {
     device.shader_draw_parameter_features.pNext = features.pNext;
     features.pNext = &device.shader_draw_parameter_features;
 
-    device.bit16_storage_features.sType =
-        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;
-    device.bit16_storage_features.pNext = features.pNext;
-    features.pNext = &device.bit16_storage_features;
+    device.shader_draw_parameters_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES;
+    device.shader_draw_parameters_features.pNext = features.pNext;
+    features.pNext = &device.shader_draw_parameters_features;
 
     vkGetPhysicalDeviceFeatures2(physical_device, &features);
 
@@ -476,6 +3168,36 @@ VkJsonDevice VkJsonGetDevice(VkPhysicalDevice physical_device) {
     device.core12.properties.pNext = properties.pNext;
     properties.pNext = &device.core12.properties;
 
+    device.driver_properties.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES;
+    device.driver_properties.pNext = properties.pNext;
+    properties.pNext = &device.driver_properties;
+
+    device.float_controls_properties.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES;
+    device.float_controls_properties.pNext = properties.pNext;
+    properties.pNext = &device.float_controls_properties;
+
+    device.descriptor_indexing_properties.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES;
+    device.descriptor_indexing_properties.pNext = properties.pNext;
+    properties.pNext = &device.descriptor_indexing_properties;
+
+    device.depth_stencil_resolve_properties.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES;
+    device.depth_stencil_resolve_properties.pNext = properties.pNext;
+    properties.pNext = &device.depth_stencil_resolve_properties;
+
+    device.sampler_filter_minmax_properties.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES;
+    device.sampler_filter_minmax_properties.pNext = properties.pNext;
+    properties.pNext = &device.sampler_filter_minmax_properties;
+
+    device.timeline_semaphore_properties.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES;
+    device.timeline_semaphore_properties.pNext = properties.pNext;
+    properties.pNext = &device.timeline_semaphore_properties;
+
     vkGetPhysicalDeviceProperties2(physical_device, &properties);
 
     device.core11.features.sType =
@@ -488,10 +3210,123 @@ VkJsonDevice VkJsonGetDevice(VkPhysicalDevice physical_device) {
     device.core12.features.pNext = features.pNext;
     features.pNext = &device.core12.features;
 
+    device.bit8_storage_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES;
+    device.bit8_storage_features.pNext = features.pNext;
+    features.pNext = &device.bit8_storage_features;
+
+    device.shader_atomic_int64_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES;
+    device.shader_atomic_int64_features.pNext = features.pNext;
+    features.pNext = &device.shader_atomic_int64_features;
+
+    device.shader_float16_int8_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
+    device.shader_float16_int8_features.pNext = features.pNext;
+    features.pNext = &device.shader_float16_int8_features;
+
+    device.descriptor_indexing_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES;
+    device.descriptor_indexing_features.pNext = features.pNext;
+    features.pNext = &device.descriptor_indexing_features;
+
+    device.scalar_block_layout_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES;
+    device.scalar_block_layout_features.pNext = features.pNext;
+    features.pNext = &device.scalar_block_layout_features;
+
+    device.vulkan_memory_model_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES;
+    device.vulkan_memory_model_features.pNext = features.pNext;
+    features.pNext = &device.vulkan_memory_model_features;
+
+    device.imageless_framebuffer_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES;
+    device.imageless_framebuffer_features.pNext = features.pNext;
+    features.pNext = &device.imageless_framebuffer_features;
+
+    device.uniform_buffer_standard_layout_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES;
+    device.uniform_buffer_standard_layout_features.pNext = features.pNext;
+    features.pNext = &device.uniform_buffer_standard_layout_features;
+
+    device.shader_subgroup_extended_types_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES;
+    device.shader_subgroup_extended_types_features.pNext = features.pNext;
+    features.pNext = &device.shader_subgroup_extended_types_features;
+
+    device.separate_depth_stencil_layouts_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES;
+    device.separate_depth_stencil_layouts_features.pNext = features.pNext;
+    features.pNext = &device.separate_depth_stencil_layouts_features;
+
+    device.host_query_reset_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES;
+    device.host_query_reset_features.pNext = features.pNext;
+    features.pNext = &device.host_query_reset_features;
+
+    device.timeline_semaphore_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES;
+    device.timeline_semaphore_features.pNext = features.pNext;
+    features.pNext = &device.timeline_semaphore_features;
+
+    device.buffer_device_address_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES;
+    device.buffer_device_address_features.pNext = features.pNext;
+    features.pNext = &device.buffer_device_address_features;
     vkGetPhysicalDeviceFeatures2(physical_device, &features);
   }
 
   if (device.properties.apiVersion >= VK_API_VERSION_1_3) {
+    for (VkFormat format = VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK;
+         format <= VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK;
+         format = static_cast<VkFormat>(format + 1)) {
+      vkGetPhysicalDeviceFormatProperties(physical_device, format,
+                                          &format_properties);
+      device.formats.insert(std::make_pair(format, format_properties));
+    }
+
+    for (VkFormat format = VK_FORMAT_G8_B8R8_2PLANE_444_UNORM;
+         format <= VK_FORMAT_G16_B16R16_2PLANE_444_UNORM;
+         format = static_cast<VkFormat>(format + 1)) {
+      vkGetPhysicalDeviceFormatProperties(physical_device, format,
+                                          &format_properties);
+      device.formats.insert(std::make_pair(format, format_properties));
+    }
+
+    for (VkFormat format = VK_FORMAT_A4R4G4B4_UNORM_PACK16;
+         format <= VK_FORMAT_A4B4G4R4_UNORM_PACK16;
+         format = static_cast<VkFormat>(format + 1)) {
+      vkGetPhysicalDeviceFormatProperties(physical_device, format,
+                                          &format_properties);
+      device.formats.insert(std::make_pair(format, format_properties));
+    }
+
+    device.subgroup_size_control_properties.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES;
+    device.subgroup_size_control_properties.pNext = properties.pNext;
+    properties.pNext = &device.subgroup_size_control_properties;
+
+    device.inline_uniform_block_properties.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES;
+    device.inline_uniform_block_properties.pNext = properties.pNext;
+    properties.pNext = &device.inline_uniform_block_properties;
+
+    device.shader_integer_dot_product_properties.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES;
+    device.shader_integer_dot_product_properties.pNext = properties.pNext;
+    properties.pNext = &device.shader_integer_dot_product_properties;
+
+    device.texel_buffer_alignment_properties.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES;
+    device.texel_buffer_alignment_properties.pNext = properties.pNext;
+    properties.pNext = &device.texel_buffer_alignment_properties;
+
+    device.maintenance4_properties.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES;
+    device.maintenance4_properties.pNext = properties.pNext;
+    properties.pNext = &device.maintenance4_properties;
+
     device.core13.properties.sType =
         VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES;
     device.core13.properties.pNext = properties.pNext;
@@ -504,10 +3339,113 @@ VkJsonDevice VkJsonGetDevice(VkPhysicalDevice physical_device) {
     device.core13.features.pNext = features.pNext;
     features.pNext = &device.core13.features;
 
+    device.shader_terminate_invocation_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES;
+    device.shader_terminate_invocation_features.pNext = features.pNext;
+    features.pNext = &device.shader_terminate_invocation_features;
+
+    device.shader_demote_to_helper_invocation_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES;
+    device.shader_demote_to_helper_invocation_features.pNext = features.pNext;
+    features.pNext = &device.shader_demote_to_helper_invocation_features;
+
+    device.private_data_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES;
+    device.private_data_features.pNext = features.pNext;
+    features.pNext = &device.private_data_features;
+
+    device.pipeline_creation_cache_control_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES;
+    device.pipeline_creation_cache_control_features.pNext = features.pNext;
+    features.pNext = &device.pipeline_creation_cache_control_features;
+
+    device.synchronization2_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES;
+    device.synchronization2_features.pNext = features.pNext;
+    features.pNext = &device.synchronization2_features;
+
+    device.zero_initialize_workgroup_memory_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES;
+    device.zero_initialize_workgroup_memory_features.pNext = features.pNext;
+    features.pNext = &device.zero_initialize_workgroup_memory_features;
+
+    device.image_robustness_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES;
+    device.image_robustness_features.pNext = features.pNext;
+    features.pNext = &device.image_robustness_features;
+
+    device.subgroup_size_control_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES;
+    device.subgroup_size_control_features.pNext = features.pNext;
+    features.pNext = &device.subgroup_size_control_features;
+
+    device.inline_uniform_block_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES;
+    device.inline_uniform_block_features.pNext = features.pNext;
+    features.pNext = &device.inline_uniform_block_features;
+
+    device.texture_compression_astchdr_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES;
+    device.texture_compression_astchdr_features.pNext = features.pNext;
+    features.pNext = &device.texture_compression_astchdr_features;
+
+    device.dynamic_rendering_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES;
+    device.dynamic_rendering_features.pNext = features.pNext;
+    features.pNext = &device.dynamic_rendering_features;
+
+    device.shader_integer_dot_product_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES;
+    device.shader_integer_dot_product_features.pNext = features.pNext;
+    features.pNext = &device.shader_integer_dot_product_features;
+
+    device.maintenance4_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES;
+    device.maintenance4_features.pNext = features.pNext;
+    features.pNext = &device.maintenance4_features;
+
     vkGetPhysicalDeviceFeatures2(physical_device, &features);
   }
 
   if (device.properties.apiVersion >= VK_API_VERSION_1_4) {
+    for (VkFormat format = VK_FORMAT_A1B5G5R5_UNORM_PACK16;
+         format <= VK_FORMAT_A8_UNORM;
+         format = static_cast<VkFormat>(format + 1)) {
+      vkGetPhysicalDeviceFormatProperties(physical_device, format,
+                                          &format_properties);
+      device.formats.insert(std::make_pair(format, format_properties));
+    }
+
+    device.line_rasterization_properties.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES;
+    device.line_rasterization_properties.pNext = properties.pNext;
+    properties.pNext = &device.line_rasterization_properties;
+
+    device.vertex_attribute_divisor_properties.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES;
+    device.vertex_attribute_divisor_properties.pNext = properties.pNext;
+    properties.pNext = &device.vertex_attribute_divisor_properties;
+
+    device.maintenance5_properties.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES;
+    device.maintenance5_properties.pNext = properties.pNext;
+    properties.pNext = &device.maintenance5_properties;
+
+    device.push_descriptor_properties.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES;
+    device.push_descriptor_properties.pNext = properties.pNext;
+    properties.pNext = &device.push_descriptor_properties;
+
+    device.maintenance6_properties.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES;
+    device.maintenance6_properties.pNext = properties.pNext;
+    properties.pNext = &device.maintenance6_properties;
+
+    device.pipeline_robustness_properties.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES;
+    device.pipeline_robustness_properties.pNext = properties.pNext;
+    properties.pNext = &device.pipeline_robustness_properties;
+
     device.core14.properties.sType =
         VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES;
     device.core14.properties.pNext = properties.pNext;
@@ -537,6 +3475,71 @@ VkJsonDevice VkJsonGetDevice(VkPhysicalDevice physical_device) {
     device.core14.features.pNext = features.pNext;
     features.pNext = &device.core14.features;
 
+    device.global_priority_query_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES;
+    device.global_priority_query_features.pNext = features.pNext;
+    features.pNext = &device.global_priority_query_features;
+
+    device.shader_subgroup_rotate_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES;
+    device.shader_subgroup_rotate_features.pNext = features.pNext;
+    features.pNext = &device.shader_subgroup_rotate_features;
+
+    device.shader_float_controls2_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES;
+    device.shader_float_controls2_features.pNext = features.pNext;
+    features.pNext = &device.shader_float_controls2_features;
+
+    device.shader_expect_assume_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES;
+    device.shader_expect_assume_features.pNext = features.pNext;
+    features.pNext = &device.shader_expect_assume_features;
+
+    device.line_rasterization_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES;
+    device.line_rasterization_features.pNext = features.pNext;
+    features.pNext = &device.line_rasterization_features;
+
+    device.vertex_attribute_divisor_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES;
+    device.vertex_attribute_divisor_features.pNext = features.pNext;
+    features.pNext = &device.vertex_attribute_divisor_features;
+
+    device.index_type_uint8_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES;
+    device.index_type_uint8_features.pNext = features.pNext;
+    features.pNext = &device.index_type_uint8_features;
+
+    device.maintenance5_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES;
+    device.maintenance5_features.pNext = features.pNext;
+    features.pNext = &device.maintenance5_features;
+
+    device.dynamic_rendering_local_read_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES;
+    device.dynamic_rendering_local_read_features.pNext = features.pNext;
+    features.pNext = &device.dynamic_rendering_local_read_features;
+
+    device.maintenance6_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES;
+    device.maintenance6_features.pNext = features.pNext;
+    features.pNext = &device.maintenance6_features;
+
+    device.pipeline_protected_access_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES;
+    device.pipeline_protected_access_features.pNext = features.pNext;
+    features.pNext = &device.pipeline_protected_access_features;
+
+    device.pipeline_robustness_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES;
+    device.pipeline_robustness_features.pNext = features.pNext;
+    features.pNext = &device.pipeline_robustness_features;
+
+    device.host_image_copy_features.sType =
+        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES;
+    device.host_image_copy_features.pNext = features.pNext;
+    features.pNext = &device.host_image_copy_features;
+
     vkGetPhysicalDeviceFeatures2(physical_device, &features);
   }
 
diff --git a/vulkan/vkprofiles/OWNERS b/vulkan/vkprofiles/OWNERS
new file mode 100644
index 0000000000..6289a71bce
--- /dev/null
+++ b/vulkan/vkprofiles/OWNERS
@@ -0,0 +1,2 @@
+include ../OWNERS
+nikigupta@google.com
```

