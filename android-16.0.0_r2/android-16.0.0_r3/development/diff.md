```diff
diff --git a/apps/DumpViewer/app/src/main/Android.bp b/apps/DumpViewer/app/src/main/Android.bp
index cc3f84be9..1f84c1b59 100644
--- a/apps/DumpViewer/app/src/main/Android.bp
+++ b/apps/DumpViewer/app/src/main/Android.bp
@@ -1,6 +1,6 @@
 package {
-    default_team: "trendy_team_framework_backstage_power",
     default_applicable_licenses: ["Android-Apache-2.0"],
+    default_team: "trendy_team_framework_bpm",
 }
 
 android_test {
diff --git a/apps/ShareTest/Android.bp b/apps/ShareTest/Android.bp
index 194fd595e..d0eb24a45 100644
--- a/apps/ShareTest/Android.bp
+++ b/apps/ShareTest/Android.bp
@@ -24,7 +24,7 @@ android_app {
         "aidl/**/I*.aidl",
     ],
     asset_dirs: ["assets"],
-    sdk_version: "35",
+    sdk_version: "current",
     static_libs: [
         "androidx.core_core-ktx",
         "androidx.compose.runtime_runtime",
diff --git a/apps/ShareTest/AndroidManifest.xml b/apps/ShareTest/AndroidManifest.xml
index 678018458..b13ea6ed2 100644
--- a/apps/ShareTest/AndroidManifest.xml
+++ b/apps/ShareTest/AndroidManifest.xml
@@ -35,7 +35,8 @@
             android:name="com.android.sharetest.InteractiveShareTestActivity"
             android:exported="true"
             android:label="Interactive Share Test"
-            android:taskAffinity="com.android.sharetest.InteractiveShareTask">
+            android:taskAffinity="com.android.sharetest.InteractiveShareTask"
+            android:theme="@style/ShareTest">
             <intent-filter>
                 <action android:name="android.intent.action.MAIN"/>
                 <category android:name="android.intent.category.DEFAULT"/>
diff --git a/apps/ShareTest/aidl/com/android/intentresolver/IChooserController.aidl b/apps/ShareTest/aidl/android/service/chooser/IChooserController.aidl
similarity index 87%
rename from apps/ShareTest/aidl/com/android/intentresolver/IChooserController.aidl
rename to apps/ShareTest/aidl/android/service/chooser/IChooserController.aidl
index b2c5a5984..b3d8d81ad 100644
--- a/apps/ShareTest/aidl/com/android/intentresolver/IChooserController.aidl
+++ b/apps/ShareTest/aidl/android/service/chooser/IChooserController.aidl
@@ -1,5 +1,5 @@
 /*
- * Copyright 2024 The Android Open Source Project
+ * Copyright 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,10 +14,11 @@
  * limitations under the License.
  */
 
-package com.android.intentresolver;
+package android.service.chooser;
 
 import android.content.Intent;
 
+/** {@hide} */
 interface IChooserController {
     oneway void updateIntent(in Intent intent);
 }
diff --git a/apps/ShareTest/aidl/com/android/intentresolver/IChooserInteractiveSessionCallback.aidl b/apps/ShareTest/aidl/android/service/chooser/IChooserControllerCallback.aidl
similarity index 68%
rename from apps/ShareTest/aidl/com/android/intentresolver/IChooserInteractiveSessionCallback.aidl
rename to apps/ShareTest/aidl/android/service/chooser/IChooserControllerCallback.aidl
index da003e3b8..bd0c37a8c 100644
--- a/apps/ShareTest/aidl/com/android/intentresolver/IChooserInteractiveSessionCallback.aidl
+++ b/apps/ShareTest/aidl/android/service/chooser/IChooserControllerCallback.aidl
@@ -1,5 +1,5 @@
 /*
- * Copyright 2024 The Android Open Source Project
+ * Copyright 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,11 +14,14 @@
  * limitations under the License.
  */
 
-package com.android.intentresolver;
+package android.service.chooser;
 
-import com.android.intentresolver.IChooserController;
+import android.graphics.Rect;
+import android.service.chooser.IChooserController;
 
-interface IChooserInteractiveSessionCallback {
+/** {@hide} */
+interface IChooserControllerCallback {
     oneway void registerChooserController(in IChooserController updater);
-    oneway void onDrawerVerticalOffsetChanged(in int offset);
+    oneway void onSizeChanged(in Rect size);
+    oneway void onClosed();
 }
diff --git a/apps/ShareTest/src/android/service/chooser/ChooserSession.java b/apps/ShareTest/src/android/service/chooser/ChooserSession.java
index 990725b5e..3da0b76e1 100644
--- a/apps/ShareTest/src/android/service/chooser/ChooserSession.java
+++ b/apps/ShareTest/src/android/service/chooser/ChooserSession.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2024 The Android Open Source Project
+ * Copyright 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,83 +16,163 @@
 
 package android.service.chooser;
 
+import android.app.ActivityOptions;
+import android.content.Context;
 import android.content.Intent;
-import android.os.Handler;
+import android.graphics.Rect;
+import android.os.Bundle;
 import android.os.IBinder;
-import android.os.IBinder.DeathRecipient;
-import android.os.Looper;
-import android.os.Parcel;
-import android.os.Parcelable;
 import android.os.RemoteException;
 import android.util.Log;
 
-import androidx.annotation.MainThread;
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 
-import com.android.intentresolver.IChooserController;
-import com.android.intentresolver.IChooserInteractiveSessionCallback;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.Consumer;
+
+import javax.annotation.concurrent.GuardedBy;
 
 /**
- * <p>An interactive Chooser session API candidate.</p>
  * <p>A class that represents an interactive Chooser session.</p>
- * <p>An instance of the class should be put in an argument to a chooser intent.
- * <p>A {@link ChooserSessionUpdateListener} callback can be used to receive updates about the
+ * <p>An instance of the class can be used as a value for <em>an</em> {@link Intent#ACTION_CHOOSER}
+ * extra to establish a bi-directional communication channel with Chooser.
+ * <p>A {@link UpdateListener} callback can be used to receive updates about the
  * session and communication from Chooser.</p>
  */
-public final class ChooserSession implements Parcelable {
+public final class ChooserSession {
 
-    private static final String TAG = "ChooserSession";
+    /**
+     * A callback interface for Chooser session state updates.
+     */
+    public interface UpdateListener {
 
-    private final IChooserInteractiveSessionCallback mSessionCallbackBinder;
+        /**
+         * Gets invoked when a {@link ChooserController} becomes available.
+         * @param chooserController active chooser controller.
+         */
+        void onChooserConnected(ChooserController chooserController);
 
-    // mChooserSession is expected to be null only on the Chooser side
-    @Nullable
-    private final ChooserSessionImpl mChooserSession;
+        /**
+         * Gets invoked when the session is closed by the Chooser.
+         */
+        void onClosed();
+
+        /**
+         * Gets invoked when drawer size is changed. The rect parameter represents Chooser window
+         * position in pixels.
+         */
+        void onSizeChanged(Rect size);
+    }
 
     /**
-     * An alias for {@code ChooserSession(Looper.getMainLooper())}.
+     * An interface for updating the Chooser.
      */
-    public ChooserSession() {
-        this(new Handler(Looper.getMainLooper()));
+    public interface ChooserController {
+
+        /**
+         * Update chooser intent in a Chooser session.
+         * <p>Updatable Chooser parameters:
+         * <ul>
+         * <li> {@link Intent#EXTRA_INTENT}
+         * <li> {@link Intent#EXTRA_EXCLUDE_COMPONENTS}
+         * <li> {@link Intent#EXTRA_CHOOSER_TARGETS}
+         * <li> {@link Intent#EXTRA_ALTERNATE_INTENTS}
+         * <li> {@link Intent#EXTRA_REPLACEMENT_EXTRAS}
+         * <li> {@link Intent#EXTRA_INITIAL_INTENTS}
+         * <li> {@link Intent#EXTRA_CHOOSER_RESULT_INTENT_SENDER}
+         * <li> {@link Intent#EXTRA_CHOOSER_REFINEMENT_INTENT_SENDER}
+         * <li> {@link Intent#EXTRA_CONTENT_ANNOTATIONS}
+         * </ul>
+         * </p>
+         */
+        void updateIntent(Intent intent) throws RemoteException;
+
+        /**
+         * Collapses Chooser to temporary yield more screen space for the app.
+         * Chooser will stay collapsed until its first user interaction.
+         */
+        void collapse() throws RemoteException;
+
+        /**
+         * Sets whether Chooser targets should be enabled.
+         * <p>
+         * This method is primarily intended to allow for managing a transient state,
+         * particularly useful during long-running operations. By disabling targets,
+         * launching application can prevent unintended interactions.
+         */
+        void setTargetsEnabled(boolean isEnabled) throws RemoteException;
     }
 
     /**
-     * @param handler a thread {@link ChooserSessionUpdateListener} callbacks will be delivered on.
+     * @hide
      */
-    public ChooserSession(Handler handler) {
-        this(new ChooserSessionImpl(handler));
-    }
+    public static final String EXTRA_CHOOSER_SESSION =
+            "com.android.extra.EXTRA_CHOOSER_INTERACTIVE_CALLBACK";
 
-    private ChooserSession(IChooserInteractiveSessionCallback sessionBinder) {
-        mSessionCallbackBinder = sessionBinder;
-        mChooserSession = (sessionBinder instanceof ChooserSessionImpl)
-                ? (ChooserSessionImpl) sessionBinder
-                : null;
-    }
+    private static final String TAG = "ChooserSession";
+
+    private final ChooserSessionImpl mChooserSession = new ChooserSessionImpl();
 
     /**
-     * @return true if the session is active: i.e. is not being cancelled by the client
-     * (see {@link #cancel()}) or closed by the Chooser.
+     * Start a new interactive Chooser session. The method is idempotent and will start Chooser only
+     * once.
+     * @param chooserIntent a {@link Intent#ACTION_CHOOSER} intent that will be used as a base
+     * for the new Chooser session.
+     * <p>An interactive Chooser session also supports the following chooser parameters:
+     * <ul>
+     * <li>{@link Intent#EXTRA_ALTERNATE_INTENTS}</li>
+     * <li>{@link Intent#EXTRA_INITIAL_INTENTS}</li>
+     * <li>{@link Intent#EXTRA_EXCLUDE_COMPONENTS}</li>
+     * <li>{@link Intent#EXTRA_REPLACEMENT_EXTRAS}</li>
+     * <li>{@link Intent#EXTRA_CHOOSER_TARGETS}</li>
+     * <li>{@link Intent#EXTRA_CHOOSER_REFINEMENT_INTENT_SENDER}</li>
+     * <li>{@link Intent#EXTRA_CHOOSER_RESULT}</li>
+     * <li>{@link Intent#EXTRA_CHOOSER_RESULT_INTENT_SENDER}</li>
+     * <li>{@link Intent#EXTRA_CHOSEN_COMPONENT_INTENT_SENDER}</li>
+     * <li>{@link Intent#EXTRA_CONTENT_ANNOTATIONS}</li>
+     * <li>{@link Intent#EXTRA_AUTO_LAUNCH_SINGLE_CHOICE}</li>
+     * </ul>
+     * </p>
+     * <p>See also {@link Intent#createChooser(Intent, CharSequence) }.</p>
      */
-    public boolean isActive() {
-        return mChooserSession != null && mChooserSession.isActive();
+    public void start(@NonNull Context context, @NonNull Intent chooserIntent) {
+        if (context == null) {
+            throw new IllegalArgumentException("context should not be null");
+        }
+        if (chooserIntent == null) {
+            throw new IllegalArgumentException("chooserIntent should not be null");
+        }
+        if (!Intent.ACTION_CHOOSER.equals(chooserIntent.getAction())) {
+            throw new IllegalArgumentException("A chooser intent is expected");
+        }
+        chooserIntent = new Intent(chooserIntent);
+        Bundle binderExtras = new Bundle();
+        binderExtras.putBinder(EXTRA_CHOOSER_SESSION, mChooserSession);
+        chooserIntent.putExtras(binderExtras);
+        ActivityOptions options = ActivityOptions.makeBasic();
+        options.setAllowPassThroughOnTouchOutside(true);
+        context.startActivity(chooserIntent, options.toBundle());
     }
 
     /**
-     * Cancel the session and close the Chooser.
+     * @return true if the session is active: i.e. is not being cancelled by the client
+     * (see {@link #close()}) or closed by the Chooser.
      */
-    public void cancel() {
-        if (mChooserSession != null) {
-            mChooserSession.cancel();
-        }
+    public boolean isActive() {
+        return mChooserSession.isActive();
     }
 
     /**
-     * Should be a @Hidden API for Chooser to get access to the binder.
+     * Cancel the session and close the Chooser.
      */
-    IChooserInteractiveSessionCallback getSessionCallbackBinder() {
-        return mSessionCallbackBinder;
+    public void close() {
+        mChooserSession.close();
     }
 
     /**
@@ -106,89 +186,32 @@ public final class ChooserSession implements Parcelable {
      */
     @Nullable
     public ChooserController getChooserController() {
-        return mChooserSession == null ? null : mChooserSession.getChooserController();
+        return mChooserSession.getChooserController();
     }
 
     /**
      * @param listener make sure that the callback is cleared at the end of a component's lifecycle
      * (e.g. Activity) or provide a properly maintained WeakReference wrapper to avoid memory leaks.
      */
-    public void setChooserStateListener(@Nullable ChooserSessionUpdateListener listener) {
-        if (mChooserSession != null) {
-            mChooserSession.setChooserStateListener(
-                    listener == null
-                            ? null
-                            : new ChooserSessionUpdateListenerWrapper(this, listener));
+    public void addUpdateListener(
+            @NonNull Executor executor, @NonNull UpdateListener listener) {
+        if (executor == null) {
+            throw new IllegalArgumentException("executor should not be null");
         }
-    }
-
-    @Override
-    public int describeContents() {
-        return 0;
-    }
-
-    @Override
-    public void writeToParcel(@NonNull Parcel dest, int flags) {
-        if (mChooserSession != null) {
-            synchronized (mChooserSession) {
-                dest.writeStrongBinder(mChooserSession);
-            }
+        if (listener == null) {
+            throw new IllegalArgumentException("listener should not be null");
         }
+        mChooserSession.addUpdateListener(executor, listener);
     }
 
-    public static final Parcelable.Creator<ChooserSession> CREATOR = new Creator<>() {
-                @Override
-                public ChooserSession createFromParcel(Parcel source) {
-                    IChooserInteractiveSessionCallback binder =
-                            IChooserInteractiveSessionCallback.Stub.asInterface(
-                                    source.readStrongBinder());
-                    return binder == null ? null : new ChooserSession(binder);
-                }
-
-                @Override
-                public ChooserSession[] newArray(int size) {
-                    return new ChooserSession[size];
-                }
-            };
-
     /**
-     * A callback interface for Chooser session state updates.
+     * Removes a previously added UpdateListener callback.
      */
-    public interface ChooserSessionUpdateListener {
-
-        /**
-         * Gets invoked when a {@link ChooserController} becomes available.
-         * @param session a reference this callback is registered to.
-         * @param chooserController active chooser controller.
-         */
-        void onChooserConnected(ChooserSession session, ChooserController chooserController);
-
-        /**
-         * Gets invoked when a {@link ChooserController} becomes unavailable.
-         */
-        void onChooserDisconnected(ChooserSession session);
-
-        /**
-         * Gets invoked when the session is closed by the Chooser.
-         */
-        void onSessionClosed(ChooserSession session);
-
-        /**
-         * A temporary support method; expected to be replaced by some other WindowManager API.
-         */
-        void onDrawerVerticalOffsetChanged(ChooserSession session, int offset);
-    }
-
-    /**
-     * An interface for updating the Chooser.
-     */
-    public interface ChooserController {
-
-        /**
-         * Update chooser intent in a Chooser session.
-         */
-        // TODO: list all the updatable parameters in the javadoc.
-        void updateIntent(Intent intent) throws RemoteException;
+    public void removeUpdateListener(@NonNull UpdateListener listener) {
+        if (listener == null) {
+            throw new IllegalArgumentException("listener should not be null");
+        }
+        mChooserSession.removeUpdateListener(listener);
     }
 
     // Just to hide Chooser binder object from the client.
@@ -203,205 +226,196 @@ public final class ChooserSession implements Parcelable {
         public void updateIntent(Intent intent) throws RemoteException {
             controller.updateIntent(intent);
         }
-    }
-
-    private static class ChooserSessionUpdateListenerWrapper {
-        private final ChooserSession mSession;
-        private final ChooserSessionUpdateListener mListener;
-
-        ChooserSessionUpdateListenerWrapper(
-                ChooserSession mSession, ChooserSessionUpdateListener mListener) {
-            this.mSession = mSession;
-            this.mListener = mListener;
-        }
 
-        public void onChooserConnected(ChooserController chooserController) {
-            mListener.onChooserConnected(mSession, chooserController);
+        @Override
+        public void collapse() throws RemoteException {
+            // TODO: implement
         }
 
-        public void onChooserDisconnected() {
-            mListener.onChooserDisconnected(mSession);
+        @Override
+        public void setTargetsEnabled(boolean isEnabled) throws RemoteException {
+            // TODO: implement
         }
+    }
 
-        public void onSessionClosed() {
-            mListener.onSessionClosed(mSession);
-        }
+    private static class ChooserSessionImpl extends IChooserControllerCallback.Stub {
+        private final Object mListenerLock = new Object();
+        @GuardedBy("mListenerLock")
+        private Map<UpdateListener, UpdateListenerWrapper> mListenerMap = new HashMap<>();
+        private final AtomicBoolean mIsActive = new AtomicBoolean(true);
 
-        public void onDrawerVerticalOffsetChanged(int offset) {
-            mListener.onDrawerVerticalOffsetChanged(mSession, offset);
-        }
-    }
+        private final Object mControllerLock = new Object();
 
-    private static class ChooserSessionImpl extends IChooserInteractiveSessionCallback.Stub {
-        private final Handler mHandler;
-        private volatile ChooserSessionUpdateListenerWrapper mListener;
-        private volatile boolean mIsActive = true;
+        @GuardedBy("mControllerLock")
         @Nullable
         private volatile ChooserControllerWrapper mChooserController;
-        @Nullable
-        private IBinder.DeathRecipient mChooserControllerLinkToDeath;
 
-        ChooserSessionImpl(Handler handler) {
-            mHandler = handler;
-        }
+        @GuardedBy("mControllerLock")
+        @Nullable
+        private volatile IBinder.DeathRecipient mChooserControllerLinkToDeath;
 
         @Override
         public void registerChooserController(
                 @Nullable final IChooserController chooserController) {
-            mHandler.post(() -> setChooserController(chooserController));
+            if (chooserController == null) {
+                // Interaction session did not start.
+                onClosed();
+                return;
+            }
+            Log.d(
+                    TAG,
+                    "setIntentUpdater; isOpen: " + mIsActive
+                            + ", chooserController: " + chooserController);
+            if (!mIsActive.get()) {
+                // close Chooser
+                safeUpdateChooserIntent(chooserController, null);
+                return;
+            }
+            ChooserControllerWrapper controllerWrapper;
+            synchronized (mControllerLock) {
+                if (areEqual(mChooserController, chooserController)) {
+                    return;
+                }
+                disconnectCurrentController();
+                controllerWrapper = connectController(chooserController);
+            }
+            if (controllerWrapper == null) {
+                // we've got a binder that had died, notify session closed
+                onClosed();
+            } else {
+                notifyListeners((listener -> {
+                    if (mIsActive.get()) {
+                        listener.onChooserConnected(controllerWrapper);
+                    }
+                }));
+            }
+        }
+
+        @Override
+        public void onSizeChanged(Rect size) {
+            if (mIsActive.get()) {
+                notifyListeners((listener) -> {
+                    if (mIsActive.get()) {
+                        listener.onSizeChanged(size);
+                    }
+                });
+            }
         }
 
         @Override
-        public void onDrawerVerticalOffsetChanged(int offset) {
-            mHandler.post(() -> notifyDrawerVerticalOffsetChanged(offset));
+        public void onClosed() {
+            doClose(true);
         }
 
         public boolean isActive() {
-            return mIsActive;
+            return mIsActive.get();
         }
 
-        public void cancel() {
-            mIsActive = false;
-            mListener = null;
-            if (mHandler.getLooper().isCurrentThread()) {
-                doClose();
-            } else {
-                mHandler.post(this::doClose);
-            }
+        public void close() {
+            doClose(false);
         }
 
         @Nullable
         public ChooserController getChooserController() {
-            return mChooserController;
-        }
-
-        public void setChooserStateListener(
-                @Nullable ChooserSessionUpdateListenerWrapper listener) {
-            mListener = listener;
-            publishState();
+            synchronized (mControllerLock) {
+                return mChooserController;
+            }
         }
 
-        private void publishState() {
-            if (mHandler.getLooper().isCurrentThread()) {
-                if (!mIsActive) {
-                    notifySessionClosed();
-                } else if (mChooserController == null) {
-                    notifyChooserDisconnected();
-                } else {
-                    notifyChooserConnected(mChooserController);
+        public void addUpdateListener(Executor executor, UpdateListener listener) {
+            synchronized (mListenerLock) {
+                if (!mListenerMap.containsKey(listener)) {
+                    mListenerMap = new HashMap<>(mListenerMap);
+                    mListenerMap.put(listener, new UpdateListenerWrapper(listener, executor));
                 }
-            } else {
-                mHandler.post(this::publishState);
             }
         }
 
-        private void doClose() {
-            ChooserControllerWrapper controllerWrapper = mChooserController;
-            if (controllerWrapper != null) {
-                if (mChooserControllerLinkToDeath != null) {
-                    safeUnlinkToDeath(
-                            controllerWrapper.controller.asBinder(), mChooserControllerLinkToDeath);
+        public void removeUpdateListener(UpdateListener listener) {
+            synchronized (mListenerLock) {
+                if (mListenerMap.containsKey(listener)) {
+                    mListenerMap = new HashMap<>(mListenerMap);
+                    UpdateListenerWrapper lw = mListenerMap.remove(listener);
+                    lw.isSubscribed.set(false);
                 }
-                safeUpdateChooserIntent(controllerWrapper.controller, null);
             }
-            mChooserController = null;
-            mChooserControllerLinkToDeath = null;
         }
 
-        private void setChooserController(IChooserController chooserController) {
-            Log.d(
-                    TAG,
-                    "setIntentUpdater; isOpen: " + mIsActive
-                            + ", chooserController: " + chooserController);
-            if (!mIsActive && chooserController != null) {
-                // close Chooser
-                safeUpdateChooserIntent(chooserController, null);
-                return;
+        private void notifyListeners(Consumer<UpdateListener> block) {
+            Collection<UpdateListenerWrapper> listeners;
+            synchronized (mListenerLock) {
+                listeners = mListenerMap.values();
             }
-            ChooserControllerWrapper controllerWrapper = mChooserController;
-            if (controllerWrapper != null
-                    && areEqual(controllerWrapper.controller, chooserController)) {
-                return;
+            for (UpdateListenerWrapper lw: listeners) {
+                lw.executor.execute(() -> {
+                    if (lw.isSubscribed.get()) {
+                        block.accept(lw.listener);
+                    }
+                });
             }
+        }
 
-            disconnectCurrentIntentUpdater();
-
-            if (chooserController != null) {
-                controllerWrapper = new ChooserControllerWrapper(chooserController);
-                this.mChooserController = controllerWrapper;
-                mChooserControllerLinkToDeath = createDeathRecipient(chooserController);
-                try {
-                    chooserController.asBinder().linkToDeath(mChooserControllerLinkToDeath, 0);
-                    notifyChooserConnected(controllerWrapper);
-                } catch (RemoteException e) {
-                    // binder has already died
-                    this.mChooserController = null;
-                    mChooserControllerLinkToDeath = null;
+        private void doClose(boolean isClosedByChooser) {
+            boolean wasActive = mIsActive.compareAndSet(true, false);
+            synchronized (mControllerLock) {
+                if (!isClosedByChooser && mChooserController != null) {
+                    safeUpdateChooserIntent(mChooserController.controller, null);
                 }
-            } else {
-                mIsActive = false;
-                notifySessionClosed();
+                disconnectCurrentController();
+            }
+            if (wasActive && isClosedByChooser) {
+                notifyListeners((UpdateListener::onClosed));
+            }
+            synchronized (mListenerLock) {
+                mListenerMap = Collections.emptyMap();
             }
         }
 
-        @MainThread
-        private void disconnectCurrentIntentUpdater() {
-            ChooserControllerWrapper controllerWrapper = mChooserController;
-            if (controllerWrapper != null) {
-                if (mChooserControllerLinkToDeath != null) {
-                    safeUnlinkToDeath(
-                            controllerWrapper.controller.asBinder(), mChooserControllerLinkToDeath);
-                }
+        @GuardedBy("mControllerLock")
+        private void disconnectCurrentController() {
+            if (mChooserController != null && mChooserControllerLinkToDeath != null) {
+                safeUnlinkToDeath(
+                        mChooserController.controller.asBinder(), mChooserControllerLinkToDeath);
+            }
+            mChooserController = null;
+            mChooserControllerLinkToDeath = null;
+        }
+
+        @GuardedBy("mControllerLock")
+        private ChooserControllerWrapper connectController(IChooserController chooserController) {
+            ChooserControllerWrapper controllerWrapper =
+                    new ChooserControllerWrapper(chooserController);
+            this.mChooserController = controllerWrapper;
+            mChooserControllerLinkToDeath = createDeathRecipient(chooserController);
+            try {
+                chooserController.asBinder().linkToDeath(mChooserControllerLinkToDeath, 0);
+            } catch (RemoteException e) {
+                // binder has already died
                 mChooserController = null;
                 mChooserControllerLinkToDeath = null;
-                notifyChooserDisconnected();
+                controllerWrapper = null;
             }
+            return controllerWrapper;
         }
 
-        private DeathRecipient createDeathRecipient(IChooserController chooserController) {
+        private IBinder.DeathRecipient createDeathRecipient(IChooserController chooserController) {
             return () -> {
                 Log.d(TAG, "chooser died");
-                mHandler.post(() -> {
-                    ChooserControllerWrapper controllerWrapper = this.mChooserController;
-                    if (areEqual(
-                            controllerWrapper == null ? null : controllerWrapper.controller,
-                            chooserController)) {
-                        this.mChooserController = null;
+                boolean shouldClose = false;
+                synchronized (mControllerLock) {
+                    if (areEqual(mChooserController, chooserController)) {
+                        // is it ever true?
+                        mChooserController = null;
                         mChooserControllerLinkToDeath = null;
-                        mListener.onChooserDisconnected();
+                        shouldClose = true;
                     }
-                });
+                }
+                if (shouldClose) {
+                    doClose(true);
+                }
             };
         }
 
-        private void notifyDrawerVerticalOffsetChanged(int offset) {
-            ChooserSessionUpdateListenerWrapper listener = mListener;
-            if (listener != null) {
-                listener.onDrawerVerticalOffsetChanged(offset);
-            }
-        }
-
-        private void notifyChooserConnected(ChooserController chooserController) {
-            ChooserSessionUpdateListenerWrapper listener = mListener;
-            if (listener != null) {
-                listener.onChooserConnected(chooserController);
-            }
-        }
-
-        private void notifySessionClosed() {
-            ChooserSessionUpdateListenerWrapper listener = mListener;
-            if (listener != null) {
-                listener.onSessionClosed();
-            }
-        }
-
-        private void notifyChooserDisconnected() {
-            ChooserSessionUpdateListenerWrapper listener = mListener;
-            if (listener != null) {
-                listener.onChooserDisconnected();
-            }
-        }
-
         private static void safeUpdateChooserIntent(
                 IChooserController chooserController, @Nullable Intent chooserIntent) {
             try {
@@ -418,7 +432,8 @@ public final class ChooserSession implements Parcelable {
         }
 
         private static boolean areEqual(
-                @Nullable IChooserController left, @Nullable IChooserController right) {
+                @Nullable ChooserControllerWrapper wrapper, @Nullable IChooserController right) {
+            IChooserController left = wrapper == null ? null : wrapper.controller;
             if (left == null && right == null) {
                 return true;
             }
@@ -428,4 +443,15 @@ public final class ChooserSession implements Parcelable {
             return left.asBinder().equals(right.asBinder());
         }
     }
+
+    private static class UpdateListenerWrapper {
+        public final ChooserSession.UpdateListener listener;
+        public final Executor executor;
+        public final AtomicBoolean isSubscribed = new AtomicBoolean(true);
+
+        UpdateListenerWrapper(ChooserSession.UpdateListener listener, Executor executor) {
+            this.listener = listener;
+            this.executor = executor;
+        }
+    }
 }
diff --git a/apps/ShareTest/src/com/android/sharetest/InteractiveShareTestActivity.kt b/apps/ShareTest/src/com/android/sharetest/InteractiveShareTestActivity.kt
index 88b0ad55c..51bcffaf7 100644
--- a/apps/ShareTest/src/com/android/sharetest/InteractiveShareTestActivity.kt
+++ b/apps/ShareTest/src/com/android/sharetest/InteractiveShareTestActivity.kt
@@ -25,12 +25,14 @@ import android.content.Intent
 import android.content.Intent.EXTRA_CHOOSER_RESULT_INTENT_SENDER
 import android.content.IntentFilter
 import android.content.res.Configuration
+import android.graphics.Rect
 import android.os.Bundle
 import android.provider.MediaStore
 import android.service.chooser.ChooserSession
 import android.service.chooser.ChooserSession.ChooserController
 import android.util.Log
 import androidx.activity.compose.setContent
+import androidx.activity.viewModels
 import androidx.compose.foundation.clickable
 import androidx.compose.foundation.layout.Arrangement
 import androidx.compose.foundation.layout.Column
@@ -58,13 +60,13 @@ import androidx.compose.ui.graphics.Color
 import androidx.compose.ui.graphics.SolidColor
 import androidx.compose.ui.layout.onGloballyPositioned
 import androidx.compose.ui.unit.dp
-import androidx.core.os.bundleOf
 import androidx.fragment.app.DialogFragment
 import androidx.fragment.app.FragmentActivity
 import androidx.lifecycle.Lifecycle
 import androidx.lifecycle.compose.collectAsStateWithLifecycle
 import androidx.lifecycle.lifecycleScope
 import androidx.lifecycle.repeatOnLifecycle
+import com.android.sharetest.ui.ColorSchemeSelector
 import com.android.sharetest.ui.theme.ActivityTheme
 import dagger.hilt.android.AndroidEntryPoint
 import kotlinx.coroutines.ExperimentalCoroutinesApi
@@ -74,16 +76,15 @@ import kotlinx.coroutines.flow.scan
 import kotlinx.coroutines.flow.update
 import kotlinx.coroutines.launch
 
-private const val KEY_SESSION = "chooser-session"
-private const val EXTRA_CHOOSER_INTERACTIVE_CALLBACK =
-    "com.android.extra.EXTRA_CHOOSER_INTERACTIVE_CALLBACK"
-
 @AndroidEntryPoint(value = FragmentActivity::class)
 class InteractiveShareTestActivity : Hilt_InteractiveShareTestActivity() {
     private val TAG = "ShareTest/$hashId"
     private var chooserWindowTopOffset = MutableStateFlow(-1)
     private val isInMultiWindowMode = MutableStateFlow<Boolean>(false)
-    private val chooserSession = MutableStateFlow<ChooserSession?>(null)
+    private val viewModel: InteractiveShareTestViewModel by viewModels()
+    private val chooserSession: MutableStateFlow<ChooserSession?>
+        get() = viewModel.chooserSession
+
     private val useRefinementFlow = MutableStateFlow<Boolean>(false)
     private val refinementReceiver =
         object : BroadcastReceiver() {
@@ -98,25 +99,19 @@ class InteractiveShareTestActivity : Hilt_InteractiveShareTestActivity() {
         }
 
     private val sessionStateListener =
-        object : ChooserSession.ChooserSessionUpdateListener {
-            override fun onChooserConnected(
-                session: ChooserSession?,
-                chooserController: ChooserController?,
-            ) {
+        object : ChooserSession.UpdateListener {
+            override fun onChooserConnected(chooserController: ChooserController) {
                 Log.d(TAG, "onChooserConnected")
             }
 
-            override fun onChooserDisconnected(session: ChooserSession?) {
-                Log.d(TAG, "onChooserDisconnected")
-            }
-
-            override fun onSessionClosed(session: ChooserSession?) {
+            override fun onClosed() {
                 Log.d(TAG, "onSessionClosed")
-                chooserSession.update { oldValue -> if (oldValue === session) null else oldValue }
+                chooserSession.value = null
             }
 
-            override fun onDrawerVerticalOffsetChanged(session: ChooserSession, offset: Int) {
-                chooserWindowTopOffset.value = offset
+            override fun onSizeChanged(size: Rect) {
+                Log.d(TAG, "onSizeChanged")
+                chooserWindowTopOffset.value = size.top
             }
         }
 
@@ -125,18 +120,13 @@ class InteractiveShareTestActivity : Hilt_InteractiveShareTestActivity() {
         super.onCreate(savedInstanceState)
 
         isInMultiWindowMode.value = isInMultiWindowMode()
-        chooserSession.value =
-            savedInstanceState?.getParcelable(KEY_SESSION, ChooserSession::class.java)?.apply {
-                setChooserStateListener(sessionStateListener)
-            }
 
         lifecycleScope.launch {
             lifecycle.repeatOnLifecycle(Lifecycle.State.STARTED) {
                 chooserSession
                     .scan<ChooserSession?, ChooserSession?>(null) { prevSession, newSession ->
-                        prevSession?.setChooserStateListener(null)
-                        prevSession?.cancel()
-                        newSession?.setChooserStateListener(sessionStateListener)
+                        prevSession?.close()
+                        newSession?.addUpdateListener(mainExecutor, sessionStateListener)
                         newSession
                     }
                     .collect {}
@@ -151,25 +141,28 @@ class InteractiveShareTestActivity : Hilt_InteractiveShareTestActivity() {
         }
 
         setContent {
+            val spacing = 5.dp
+            val padding = 15.dp
             var sharedText by remember { mutableStateOf("A text to share") }
             val previewWindowBottom by chooserWindowTopOffset.collectAsStateWithLifecycle(-1)
             val showLaunchInSplitScreen by
                 isInMultiWindowMode.map { !it }.collectAsStateWithLifecycle(true)
-            val spacing = 5.dp
             val brush = SolidColor(Color.Red)
-            // val isChooserRunning by chooserSessionManager.activeSession.map { it != null }
-            //     .collectAsStateWithLifecycle(false)
             val isChooserRunning by
                 chooserSession.map { it?.isActive == true }.collectAsStateWithLifecycle(false)
             val userRefinement by useRefinementFlow.collectAsStateWithLifecycle(false)
+            val colorSchemes = mapOf(0 to "System Default", 1 to "Light", 2 to "Dark")
+            var selectedColorSchemeIdx by remember { mutableStateOf(0) }
             ActivityTheme {
                 Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding ->
                     Column(
-                        modifier = Modifier.padding(innerPadding),
+                        modifier = Modifier.padding(innerPadding).padding(horizontal = padding),
                         verticalArrangement = Arrangement.spacedBy(spacing),
                     ) {
                         Row(horizontalArrangement = Arrangement.spacedBy(spacing)) {
-                            Button(onClick = { startCameraApp() }) { Text("Pick Camera App") }
+                            Button(onClick = { startCameraApp(selectedColorSchemeIdx) }) {
+                                Text("Pick Camera App")
+                            }
                             Button(onClick = { launchActivity() }) { Text("Launch Activity") }
                         }
                         Row(horizontalArrangement = Arrangement.spacedBy(spacing)) {
@@ -189,15 +182,23 @@ class InteractiveShareTestActivity : Hilt_InteractiveShareTestActivity() {
                                 modifier = Modifier.weight(1f),
                                 onValueChange = { sharedText = it },
                             )
-                            Button(onClick = { shareText(sharedText) }) { Text("Share Text") }
+                            Button(onClick = { shareText(sharedText, selectedColorSchemeIdx) }) {
+                                Text("Share Text")
+                            }
                         }
                         Row(horizontalArrangement = Arrangement.spacedBy(spacing)) {
                             if (previews.isNotEmpty()) {
-                                Button(onClick = { shareImages(previews, 1) }) {
+                                Button(
+                                    onClick = { shareImages(previews, 1, selectedColorSchemeIdx) }
+                                ) {
                                     Text("Share One Image")
                                 }
                                 if (previews.size > 1) {
-                                    Button(onClick = { shareImages(previews, 2) }) {
+                                    Button(
+                                        onClick = {
+                                            shareImages(previews, 2, selectedColorSchemeIdx)
+                                        }
+                                    ) {
                                         Text("Share Two Images")
                                     }
                                 }
@@ -217,6 +218,13 @@ class InteractiveShareTestActivity : Hilt_InteractiveShareTestActivity() {
                                 modifier = Modifier.align(Alignment.CenterVertically),
                             )
                         }
+                        Text(text = "Chooser Color Scheme")
+                        ColorSchemeSelector(
+                            values = colorSchemes,
+                            selected = selectedColorSchemeIdx,
+                            spacing = spacing,
+                            onValueSelected = { selectedColorSchemeIdx = it },
+                        )
                         if (isChooserRunning) {
                             Button(onClick = { closeChooser() }) { Text("Close Chooser") }
                         }
@@ -271,15 +279,10 @@ class InteractiveShareTestActivity : Hilt_InteractiveShareTestActivity() {
         if (useRefinementFlow.value) {
             unregisterReceiver(refinementReceiver)
         }
+        chooserSession.value?.removeUpdateListener(sessionStateListener)
         super.onDestroy()
     }
 
-    override fun onSaveInstanceState(outState: Bundle) {
-        Log.d(TAG, "onSaveInstanceState")
-        super.onSaveInstanceState(outState)
-        chooserSession.value?.let { outState.putParcelable(KEY_SESSION, it) }
-    }
-
     override fun onConfigurationChanged(newConfig: Configuration) {
         Log.d(TAG, "onConfigurationChanged")
         super.onConfigurationChanged(newConfig)
@@ -300,9 +303,11 @@ class InteractiveShareTestActivity : Hilt_InteractiveShareTestActivity() {
         }
     }
 
-    private fun startCameraApp() {
+    private fun startCameraApp(colorScheme: Int) {
         val targetIntent = Intent(MediaStore.ACTION_IMAGE_CAPTURE)
-        startOrUpdate(Intent.createChooser(targetIntent, null))
+        startOrUpdate(
+            Intent.createChooser(targetIntent, null).apply { setColorScheme(colorScheme) }
+        )
     }
 
     private fun launchActivity() {
@@ -322,17 +327,18 @@ class InteractiveShareTestActivity : Hilt_InteractiveShareTestActivity() {
         )
     }
 
-    private fun shareText(text: String) {
+    private fun shareText(text: String, colorScheme: Int) {
         val targetIntent =
             Intent(Intent.ACTION_SEND).apply {
                 putExtra(Intent.EXTRA_TEXT, text)
                 setType("text/plain")
             }
-        val chooserIntent = Intent.createChooser(targetIntent, null)
+        val chooserIntent =
+            Intent.createChooser(targetIntent, null).apply { setColorScheme(colorScheme) }
         startOrUpdate(chooserIntent)
     }
 
-    private fun shareImages(previews: List<Preview>, count: Int) {
+    private fun shareImages(previews: List<Preview>, count: Int, colorScheme: Int) {
         require(count > 0) { "Unexpected count argument value: $count" }
         val targetIntent =
             Intent(if (count == 1) Intent.ACTION_SEND else Intent.ACTION_SEND_MULTIPLE).apply {
@@ -355,12 +361,13 @@ class InteractiveShareTestActivity : Hilt_InteractiveShareTestActivity() {
                 addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
                 setType("image/*")
             }
-        val chooserIntent = Intent.createChooser(targetIntent, null)
+        val chooserIntent =
+            Intent.createChooser(targetIntent, null).apply { setColorScheme(colorScheme) }
         startOrUpdate(chooserIntent)
     }
 
     private fun closeChooser() {
-        chooserSession.value?.cancel()
+        chooserSession.value?.close()
         chooserSession.value = null
         chooserWindowTopOffset.value = -1
     }
@@ -375,19 +382,17 @@ class InteractiveShareTestActivity : Hilt_InteractiveShareTestActivity() {
         }
         chooserIntent.putExtra(EXTRA_CHOOSER_RESULT_INTENT_SENDER, createResultIntentSender(this))
         if (chooserController == null) {
-            val session = ChooserSession()
-            chooserSession.value = session
-            startActivity(
-                Intent(chooserIntent).apply {
-                    putExtras(bundleOf(EXTRA_CHOOSER_INTERACTIVE_CALLBACK to session))
-                }
-            )
+            ChooserSession().also { chooserSession.value = it }.start(this, chooserIntent)
         } else {
             chooserController.updateIntent(chooserIntent)
         }
     }
 }
 
+private fun Intent.setColorScheme(colorScheme: Int) {
+    putExtra("com.android.extra.CHOOSER_COLOR_SCHEME", colorScheme)
+}
+
 class TestDialog : DialogFragment() {
     override fun onCreateDialog(savedInstanceState: Bundle?): Dialog {
         return AlertDialog.Builder(requireContext())
diff --git a/apps/ShareTest/src/com/android/sharetest/InteractiveShareTestViewModel.kt b/apps/ShareTest/src/com/android/sharetest/InteractiveShareTestViewModel.kt
new file mode 100644
index 000000000..fbb060caa
--- /dev/null
+++ b/apps/ShareTest/src/com/android/sharetest/InteractiveShareTestViewModel.kt
@@ -0,0 +1,25 @@
+/*
+ * Copyright 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.sharetest
+
+import android.service.chooser.ChooserSession
+import androidx.lifecycle.ViewModel
+import kotlinx.coroutines.flow.MutableStateFlow
+
+class InteractiveShareTestViewModel : ViewModel() {
+    val chooserSession = MutableStateFlow<ChooserSession?>(null)
+}
diff --git a/apps/ShareTest/src/com/android/sharetest/ui/ColorSchemeSelector.kt b/apps/ShareTest/src/com/android/sharetest/ui/ColorSchemeSelector.kt
new file mode 100644
index 000000000..ec0161be9
--- /dev/null
+++ b/apps/ShareTest/src/com/android/sharetest/ui/ColorSchemeSelector.kt
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.sharetest.ui
+
+import androidx.compose.foundation.layout.Arrangement
+import androidx.compose.foundation.layout.Row
+import androidx.compose.foundation.selection.selectable
+import androidx.compose.foundation.selection.selectableGroup
+import androidx.compose.material3.RadioButton
+import androidx.compose.material3.Text
+import androidx.compose.runtime.Composable
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.semantics.Role
+import androidx.compose.ui.unit.Dp
+
+@Composable
+fun ColorSchemeSelector(
+    values: Map<Int, String>,
+    spacing: Dp,
+    selected: Int,
+    onValueSelected: (Int) -> Unit,
+) {
+    Row(
+        modifier = Modifier.selectableGroup(),
+        horizontalArrangement = Arrangement.spacedBy(spacing),
+    ) {
+        values.entries.forEach { (value, label) ->
+            Row(
+                horizontalArrangement = Arrangement.spacedBy(spacing),
+                modifier =
+                    Modifier.selectable(
+                        selected = (value == selected),
+                        onClick = { onValueSelected(value) },
+                        role = Role.RadioButton,
+                    ),
+            ) {
+                RadioButton(selected = (value == selected), onClick = null)
+                Text(label, modifier = Modifier.align(Alignment.CenterVertically))
+            }
+        }
+    }
+}
diff --git a/build/tools/mk_sdk_repo_xml.sh b/build/tools/mk_sdk_repo_xml.sh
index b0f480ce8..3b43e171c 100755
--- a/build/tools/mk_sdk_repo_xml.sh
+++ b/build/tools/mk_sdk_repo_xml.sh
@@ -460,6 +460,3 @@ done
 
 # Generate XML footer
 echo "</sdk:$ROOT>" >> "$OUT"
-
-#echo "## Validate XML against schema"
-$XMLLINT --noout --schema $SCHEMA "$OUT"
diff --git a/build/tools/sdk-preprocess-files.mk b/build/tools/sdk-preprocess-files.mk
index 5af3ef3ad..c46f8b5f5 100644
--- a/build/tools/sdk-preprocess-files.mk
+++ b/build/tools/sdk-preprocess-files.mk
@@ -20,7 +20,7 @@ ALL_SDK_FILES += $(sdk_props) $(sample_props) $(sys_img_props)
 # This needs to vary based on the CPU ABI for the system-image files.
 # Rewritten variables:
 # - ${PLATFORM_VERSION}               e.g. "1.0"
-# - ${PLATFORM_SDK_VERSION}           e.g. "3", aka the API level
+# - ${PLATFORM_SDK_VERSION}           e.g. "3.1", aka the API major.minor version
 # - ${PLATFORM_EXTENSION_SDK_VERSION} e.g. "7" -- the extension sdk level
 # - ${PLATFORM_IS_BASE_SDK}           bool. -- whether the current extension sdk is the base extension for this api level
 # - ${PLATFORM_VERSION_CODENAME}      e.g. "REL" (transformed into "") or "Cupcake"
@@ -31,13 +31,15 @@ define process_prop_template
 $(hide) mkdir -p $(dir $@)
 $(hide) sed \
 	-e 's/$${PLATFORM_VERSION}/$(PLATFORM_VERSION)/' \
-	-e 's/$${PLATFORM_SDK_VERSION}/$(PLATFORM_SDK_VERSION)/' \
+	-e 's/$${PLATFORM_SDK_VERSION}/$(subst ",,$(PLATFORM_SDK_VERSION_FULL))/' \
 	-e 's/$${PLATFORM_SDK_EXTENSION_VERSION}/$(PLATFORM_SDK_EXTENSION_VERSION)/' \
 	-e 's/$${PLATFORM_IS_BASE_SDK}/$(if $(filter $(PLATFORM_SDK_EXTENSION_VERSION),$(PLATFORM_BASE_SDK_EXTENSION_VERSION)),true,false)/' \
 	-e 's/$${PLATFORM_VERSION_CODENAME}/$(subst REL,,$(PLATFORM_VERSION_CODENAME))/' \
 	-e 's/$${TARGET_ARCH}/$(TARGET_ARCH)/' \
 	-e 's/$${TARGET_CPU_ABI}/$(TARGET_CPU_ABI)/' \
 	-e 's/$${EMULATOR_MINIMAL_VERSION}/$(EMULATOR_MINIMAL_VERSION)/' \
+	-e 's/$${SYSTEM_IMAGE_TAG_ID}/${SYSTEM_IMAGE_TAG_ID}/' \
+	-e 's/$${SYSTEM_IMAGE_TAG_DISPLAY}/${SYSTEM_IMAGE_TAG_DISPLAY}/' \
 	$< > $@ && sed -i -e '/^AndroidVersion.CodeName=\s*$$/d' $@
 endef
 
diff --git a/build/tools/sdk_clean.sh b/build/tools/sdk_clean.sh
index 97e5a4d47..17991e586 100755
--- a/build/tools/sdk_clean.sh
+++ b/build/tools/sdk_clean.sh
@@ -19,20 +19,9 @@ find $DIR -name "*.java" -o -name "*.xml" | xargs -n 1 \
         -e "s/.*END_INCLUDE(.*//" \
         -i
 
-#
-# Fix up the line endings of all text files. This also removes executable permissions.
-#
-if [ $HOST_OS = windows ] ; then
-    ENDING_TYPE=dos
-else
-    ENDING_TYPE=unix
-fi
-
 # Using -n 500 for xargs to limit the max number of arguments per call to line_endings
 # to 500. This avoids line_endings failing with "arguments too long".
 find $DIR -name "*.aidl" -o -name "*.css" -o -name "*.html" -o -name "*.java" \
                      -o -name "*.js" -o -name "*.prop" -o -name "*.template" \
                      -o -name "*.txt" -o -name "*.windows" -o -name "*.xml" \
-        | xargs -n 500 $HOST_OUT_EXECUTABLES/line_endings $ENDING_TYPE
-
-
+        | xargs -n 500 dos2unix
diff --git a/samples/AconfigDemo/AndroidManifest.xml b/samples/AconfigDemo/AndroidManifest.xml
index 302149189..ff955c109 100644
--- a/samples/AconfigDemo/AndroidManifest.xml
+++ b/samples/AconfigDemo/AndroidManifest.xml
@@ -21,10 +21,9 @@
      to come from a domain that you own or have control over. -->
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="com.example.android.aconfig.demo">
-    <uses-permission android:name="android.permission.READ_DEVICE_CONFIG" />
     <application
         android:name="AconfigDemoApplication"
-        android:label="Hello!">
+        android:label="Aconfig Demo App">
         <activity android:name="AconfigDemoActivity"
                 android:exported="true">
             <intent-filter>
@@ -32,5 +31,8 @@
                 <category android:name="android.intent.category.LAUNCHER"/>
             </intent-filter>
         </activity>
+        <activity android:name=".AconfigJavaCodelabActivity" />
+        <activity android:name=".AconfigNativeCodelabActivity" />
+        <activity android:name=".AconfigSimpleDemoActivity" />
     </application>
 </manifest>
diff --git a/samples/AconfigDemo/OWNERS b/samples/AconfigDemo/OWNERS
index 5be78b049..f34ba8a3b 100644
--- a/samples/AconfigDemo/OWNERS
+++ b/samples/AconfigDemo/OWNERS
@@ -1,6 +1,6 @@
 amhk@google.com
 dzshen@google.com
 jham@google.com
-joeo@google.com
 opg@google.com
 zhidou@google.com
+marybethfair@google.com
diff --git a/samples/AconfigDemo/aconfig_demo_flags.aconfig b/samples/AconfigDemo/aconfig_demo_flags.aconfig
index 803dfa4cc..d4281e868 100644
--- a/samples/AconfigDemo/aconfig_demo_flags.aconfig
+++ b/samples/AconfigDemo/aconfig_demo_flags.aconfig
@@ -29,6 +29,13 @@ flag {
   bug: "287644619"
 }
 
+flag {
+  name: "awesome_demo_flag"
+  namespace: "test"
+  description: "Yet ANOTHER awesome flag for testing purposes."
+  bug: "411155129"
+}
+
 flag {
     name: "fifth_flag"
     namespace: "configuration"
@@ -201,4 +208,18 @@ flag {
     description: "A test flag to verify one stage rollback"
     bug: "303703498"
     is_fixed_read_only: false
-}
\ No newline at end of file
+}
+flag {
+    name: "test_new_trunk_stable_flag_event_rpc_server_side"
+    namespace: "core_experiments_team_internal"
+    description: "A test flag to verify new halyard to gantry rpc"
+    bug: "413977839"
+    is_fixed_read_only: false
+}
+flag {
+    name: "test_new_trunk_stable_flag_event_rpc_fixed_read_only"
+    namespace: "core_experiments_team_internal"
+    description: "A test flag to verify new halyard to gantry rpc"
+    bug: "413977839"
+    is_fixed_read_only: true
+}
diff --git a/samples/AconfigDemo/res/layout/java_codelab.xml b/samples/AconfigDemo/res/layout/java_codelab.xml
new file mode 100644
index 000000000..4829dfe0c
--- /dev/null
+++ b/samples/AconfigDemo/res/layout/java_codelab.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2025 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical"
+    android:gravity="center"
+    android:layout_marginTop="100dip">
+
+    <TextView
+        android:id="@+id/mainTextView"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:scrollbars="vertical"
+        android:textSize="24sp"
+        android:padding="12dip"
+        android:textColor="#444444"/>
+</LinearLayout>
diff --git a/samples/AconfigDemo/res/layout/main.xml b/samples/AconfigDemo/res/layout/main.xml
index a490c48f8..2a99e6ccd 100644
--- a/samples/AconfigDemo/res/layout/main.xml
+++ b/samples/AconfigDemo/res/layout/main.xml
@@ -19,15 +19,21 @@
     android:padding="4dip"
     android:gravity="center_horizontal"
     android:layout_width="fill_parent"
-    android:layout_height="fill_parent">
-    <TextView
-        android:id="@+id/simpleTextView"
-        android:layout_width="match_parent"
+    android:layout_height="fill_parent"
+    android:layout_marginTop="100dip">
+    <Button
+        android:id="@+id/button1"
+        android:layout_width="wrap_content"
         android:layout_height="wrap_content"
-        android:textColor="#444444"
-        android:textSize="25sp"
-        android:autoText="true"
-        android:capitalize="sentences"
-        android:scrollbars="vertical"
-        android:textStyle="bold|italic"/>
+        android:layout_margin="16dp"/>
+    <Button
+        android:id="@+id/button2"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_margin="16dp"/>
+    <Button
+        android:id="@+id/button3"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_margin="16dp"/>
 </LinearLayout>
diff --git a/samples/AconfigDemo/res/layout/native_codelab.xml b/samples/AconfigDemo/res/layout/native_codelab.xml
new file mode 100644
index 000000000..4829dfe0c
--- /dev/null
+++ b/samples/AconfigDemo/res/layout/native_codelab.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2025 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical"
+    android:gravity="center"
+    android:layout_marginTop="100dip">
+
+    <TextView
+        android:id="@+id/mainTextView"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:scrollbars="vertical"
+        android:textSize="24sp"
+        android:padding="12dip"
+        android:textColor="#444444"/>
+</LinearLayout>
diff --git a/samples/AconfigDemo/res/layout/simple_demo.xml b/samples/AconfigDemo/res/layout/simple_demo.xml
new file mode 100644
index 000000000..547e7d375
--- /dev/null
+++ b/samples/AconfigDemo/res/layout/simple_demo.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2025 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:orientation="vertical"
+    android:gravity="center">
+
+    <TextView
+        android:id="@+id/flaggedTextView"
+        android:layout_width="match_parent"
+        android:layout_height="match_parent"
+        android:scrollbars="vertical"
+        android:textSize="44sp"
+        android:padding="12dip"
+        android:gravity="center"/>
+
+</LinearLayout>
diff --git a/samples/AconfigDemo/src/com/example/android/aconfig/demo/AconfigDemoActivity.java b/samples/AconfigDemo/src/com/example/android/aconfig/demo/AconfigDemoActivity.java
index 9e0ac1bd0..c00772339 100644
--- a/samples/AconfigDemo/src/com/example/android/aconfig/demo/AconfigDemoActivity.java
+++ b/samples/AconfigDemo/src/com/example/android/aconfig/demo/AconfigDemoActivity.java
@@ -17,62 +17,57 @@
 package com.example.android.aconfig.demo;
 
 import android.app.Activity;
+import android.content.Intent;
 import android.os.Bundle;
-import android.util.Log;
 import android.view.View;
-import android.view.WindowManager;
-import android.widget.TextView;
-import android.text.method.ScrollingMovementMethod;
+import android.widget.Button;
 
-import com.example.android.aconfig.demo.flags.Flags;
-
-import javax.inject.Inject;
-
-
-/**
- * A minimal "Hello, World!" application.
- */
+/** Main landing page of Aconfig Demo app. */
 public class AconfigDemoActivity extends Activity {
-    @Inject InjectedContent injectedContent;
-    /**
-     * Called with the activity is first created.
-     */
+
     @Override
-    public void onCreate(Bundle savedInstanceState) {
-        ((AconfigDemoApplication)getApplicationContext()).appComponent.inject(this);
+    protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-
         setContentView(R.layout.main);
-        TextView simpleTextView = (TextView) findViewById(R.id.simpleTextView);
-        simpleTextView.setMovementMethod(new ScrollingMovementMethod());
-
-        simpleTextView.setText("Show Java Flags: \n\n");
-
-        StaticContent cp = new StaticContent();
-        simpleTextView.append(cp.getContent());
-
-        simpleTextView.append(injectedContent.getContent());
-
-        simpleTextView.append("Show C/C++ Flags: \n\n");
-        simpleTextView.append(printCFlag());
-
-        if (Flags.awesomeFlag1()) {
-            Log.v("AconfigDemoActivity", Flags.FLAG_AWESOME_FLAG_1 + " is on!");
-        }
-
-        if (Flags.awesomeFlag2()) {
-            Log.v("AconfigDemoActivity", Flags.FLAG_AWESOME_FLAG_2 + " is on!");
-        }
-
-        simpleTextView.append("\n\nShow Rust Flags: \n\n");
-        simpleTextView.append(printRustFlag());
-    }
-
-    public native String printCFlag();
-    public native String printRustFlag();
 
-    static {
-        System.loadLibrary("example_cpp_lib");
-        System.loadLibrary("example_rust_jni");
+        Button button1 = findViewById(R.id.button1);
+        button1.setText("Launch Java Codelab");
+        button1.setOnClickListener(
+                new View.OnClickListener() {
+                    @Override
+                    public void onClick(View v) {
+                        Intent intent =
+                                new Intent(
+                                        AconfigDemoActivity.this, AconfigJavaCodelabActivity.class);
+                        startActivity(intent);
+                    }
+                });
+
+        Button button2 = findViewById(R.id.button2);
+        button2.setText("Launch Native Codelab");
+        button2.setOnClickListener(
+                new View.OnClickListener() {
+                    @Override
+                    public void onClick(View v) {
+                        Intent intent =
+                                new Intent(
+                                        AconfigDemoActivity.this,
+                                        AconfigNativeCodelabActivity.class);
+                        startActivity(intent);
+                    }
+                });
+
+        Button button3 = findViewById(R.id.button3);
+        button3.setText("Launch Simple Demo");
+        button3.setOnClickListener(
+                new View.OnClickListener() {
+                    @Override
+                    public void onClick(View v) {
+                        Intent intent =
+                                new Intent(
+                                        AconfigDemoActivity.this, AconfigSimpleDemoActivity.class);
+                        startActivity(intent);
+                    }
+                });
     }
 }
diff --git a/samples/AconfigDemo/src/com/example/android/aconfig/demo/AconfigDemoApplication.java b/samples/AconfigDemo/src/com/example/android/aconfig/demo/AconfigDemoApplication.java
index e4b89d7cb..6b3a299cb 100644
--- a/samples/AconfigDemo/src/com/example/android/aconfig/demo/AconfigDemoApplication.java
+++ b/samples/AconfigDemo/src/com/example/android/aconfig/demo/AconfigDemoApplication.java
@@ -17,8 +17,10 @@
 package com.example.android.aconfig.demo;
 
 import android.app.Application;
+
 import com.example.android.aconfig.demo.dagger.ApplicationComponent;
 import com.example.android.aconfig.demo.dagger.DaggerApplicationComponent;
+
 /**
  * A minimal "Hello, World!" application.
  */
diff --git a/samples/AconfigDemo/src/com/example/android/aconfig/demo/AconfigJavaCodelabActivity.java b/samples/AconfigDemo/src/com/example/android/aconfig/demo/AconfigJavaCodelabActivity.java
new file mode 100644
index 000000000..ecbf24d52
--- /dev/null
+++ b/samples/AconfigDemo/src/com/example/android/aconfig/demo/AconfigJavaCodelabActivity.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.example.android.aconfig.demo;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.text.method.ScrollingMovementMethod;
+import android.util.Log;
+import android.widget.TextView;
+
+import com.example.android.aconfig.demo.flags.Flags;
+
+import javax.inject.Inject;
+
+/** Display for the Aconfig Java codelab. */
+public class AconfigJavaCodelabActivity extends Activity {
+    private static final String TAG = "AconfigJavaCodelabActivity";
+
+    @Inject InjectedContent mInjectedContent;
+
+    /** Called with the activity is first created. */
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        ((AconfigDemoApplication) getApplicationContext()).appComponent.inject(this);
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.java_codelab);
+
+        TextView mainTextView = (TextView) findViewById(R.id.mainTextView);
+        mainTextView.setMovementMethod(new ScrollingMovementMethod());
+        mainTextView.setText("Show Java Flags: \n\n");
+
+        StaticContent cp = new StaticContent();
+        mainTextView.append(cp.getContent());
+
+        mainTextView.append(mInjectedContent.getContent());
+
+        if (Flags.awesomeFlag1()) {
+            Log.v(TAG, Flags.FLAG_AWESOME_FLAG_1 + " is on!");
+        }
+
+        if (Flags.awesomeFlag2()) {
+            Log.v(TAG, Flags.FLAG_AWESOME_FLAG_2 + " is on!");
+        }
+    }
+}
diff --git a/samples/AconfigDemo/src/com/example/android/aconfig/demo/AconfigNativeCodelabActivity.java b/samples/AconfigDemo/src/com/example/android/aconfig/demo/AconfigNativeCodelabActivity.java
new file mode 100644
index 000000000..d86c5603f
--- /dev/null
+++ b/samples/AconfigDemo/src/com/example/android/aconfig/demo/AconfigNativeCodelabActivity.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.example.android.aconfig.demo;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.text.method.ScrollingMovementMethod;
+import android.util.Log;
+import android.widget.TextView;
+
+/** Display for the Aconfig C++ / Rust codelab. */
+public class AconfigNativeCodelabActivity extends Activity {
+    private static final String TAG = "AconfigNativeCodelabActivity";
+    private static boolean sLoadedCppLib = false;
+    private static boolean sLoadedRustLib = false;
+
+    /** Called with the activity is first created. */
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.native_codelab);
+
+        TextView mainTextView = (TextView) findViewById(R.id.mainTextView);
+        mainTextView.setMovementMethod(new ScrollingMovementMethod());
+
+        if (sLoadedCppLib) {
+            mainTextView.append("C/C++ Flags: \n\n");
+            mainTextView.append(printCFlag());
+        } else {
+            mainTextView.append("Can't show C/C++ flags; error loading native lib.\n");
+        }
+
+        if (sLoadedRustLib) {
+            mainTextView.append("\n\nRust Flags: \n\n");
+            mainTextView.append(printRustFlag());
+        } else {
+            mainTextView.append("Can't show Rust flags; error loading native lib.\n");
+        }
+    }
+
+    /** Prints the C++ flag. */
+    public native String printCFlag();
+
+    /** Prints the Rust flag. */
+    public native String printRustFlag();
+
+    static {
+        try {
+            System.loadLibrary("example_cpp_lib");
+            sLoadedCppLib = true;
+        } catch (UnsatisfiedLinkError e) {
+            Log.e(TAG, "Error loading c++ library:", e);
+        }
+
+        try {
+            System.loadLibrary("example_rust_jni");
+            sLoadedRustLib = true;
+        } catch (UnsatisfiedLinkError e) {
+            Log.e(TAG, "Error loading rust library:", e);
+        }
+    }
+}
diff --git a/samples/AconfigDemo/src/com/example/android/aconfig/demo/AconfigSimpleDemoActivity.java b/samples/AconfigDemo/src/com/example/android/aconfig/demo/AconfigSimpleDemoActivity.java
new file mode 100644
index 000000000..55ab5bb01
--- /dev/null
+++ b/samples/AconfigDemo/src/com/example/android/aconfig/demo/AconfigSimpleDemoActivity.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.example.android.aconfig.demo;
+
+import android.app.Activity;
+import android.graphics.Color;
+import android.os.Bundle;
+import android.widget.TextView;
+
+import com.example.android.aconfig.demo.flags.Flags;
+
+/** Display for the simple demo. */
+public class AconfigSimpleDemoActivity extends Activity {
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.simple_demo);
+
+        TextView flaggedTextView = (TextView) findViewById(R.id.flaggedTextView);
+        // flaggedTextView.setText("The flag doesn't exist yet.");
+        // flaggedTextView.setBackgroundColor(Color.parseColor("#FFFFFF"));
+        // flaggedTextView.setTextColor(Color.parseColor("#000000"));
+
+        if (Flags.awesomeDemoFlag()) {
+            flaggedTextView.setText("Flag is ON.");
+            flaggedTextView.setBackgroundColor(Color.parseColor("#1e8e3e"));
+            flaggedTextView.setTextColor(Color.parseColor("#ffffff"));
+        } else {
+            flaggedTextView.setText("Flag is OFF.");
+            flaggedTextView.setBackgroundColor(Color.parseColor("#d93025"));
+            flaggedTextView.setTextColor(Color.parseColor("#ffffff"));
+        }
+    }
+}
diff --git a/samples/AconfigDemo/src/com/example/android/aconfig/demo/dagger/ApplicationComponent.java b/samples/AconfigDemo/src/com/example/android/aconfig/demo/dagger/ApplicationComponent.java
index 70d54af3f..d46d93979 100644
--- a/samples/AconfigDemo/src/com/example/android/aconfig/demo/dagger/ApplicationComponent.java
+++ b/samples/AconfigDemo/src/com/example/android/aconfig/demo/dagger/ApplicationComponent.java
@@ -16,10 +16,13 @@
 
 package com.example.android.aconfig.demo.dagger;
 
-import com.example.android.aconfig.demo.AconfigDemoActivity;
+import com.example.android.aconfig.demo.AconfigJavaCodelabActivity;
+
 import dagger.Component;
 
+/** Component to show injected Java flags. */
 @Component(modules = {AconfigDemoFlagModule.class})
 public interface ApplicationComponent {
-    void inject(AconfigDemoActivity aconfigDemoActivity);
+    /** Activity for Java codelab. */
+    void inject(AconfigJavaCodelabActivity aconfigJavaCodelabActivity);
 }
diff --git a/samples/AconfigDemo/src/example_cpp_lib.cc b/samples/AconfigDemo/src/example_cpp_lib.cc
index 878610f5b..fbf86c03f 100644
--- a/samples/AconfigDemo/src/example_cpp_lib.cc
+++ b/samples/AconfigDemo/src/example_cpp_lib.cc
@@ -17,9 +17,9 @@ static std::string get_flag_via_injection_interface(
       ((provider->append_injected_content()) ? "true" : "false");
 }
 
-jstring Java_com_example_android_aconfig_demo_AconfigDemoActivity_printCFlag(
-    JNIEnv* env,
-    jobject thiz) {
+jstring
+Java_com_example_android_aconfig_demo_AconfigNativeCodelabActivity_printCFlag(
+    JNIEnv *env, jobject thiz) {
   auto result = std::string("flag name : append_static_content\n");
   result += "use pattern : static method\n";
   result += get_flag_via_static_interface();
diff --git a/samples/AconfigDemo/src/include/example_cpp_lib.h b/samples/AconfigDemo/src/include/example_cpp_lib.h
index ed95fbace..8d102efbe 100644
--- a/samples/AconfigDemo/src/include/example_cpp_lib.h
+++ b/samples/AconfigDemo/src/include/example_cpp_lib.h
@@ -2,6 +2,6 @@
 
 #include <jni.h>
 
-extern "C" jstring Java_com_example_android_aconfig_demo_AconfigDemoActivity_printCFlag(
-    JNIEnv* env,
-    jobject thiz);
+extern "C" jstring
+Java_com_example_android_aconfig_demo_AconfigNativeCodelabActivity_printCFlag(
+    JNIEnv *env, jobject thiz);
diff --git a/samples/AconfigDemo/src/lib.rs b/samples/AconfigDemo/src/lib.rs
index 876baf403..287e48565 100644
--- a/samples/AconfigDemo/src/lib.rs
+++ b/samples/AconfigDemo/src/lib.rs
@@ -22,7 +22,7 @@ pub fn get_flag_via_injection_interface(
 /// printRustFlag function
 #[no_mangle]
 #[allow(unused)]
-pub extern "system" fn Java_com_example_android_aconfig_demo_AconfigDemoActivity_printRustFlag<
+pub extern "system" fn Java_com_example_android_aconfig_demo_AconfigNativeCodelabActivity_printRustFlag<
     'local,
 >(
     mut env: JNIEnv<'local>,
diff --git a/samples/AconfigDemo/tests/src/com/example/android/aconfig/demo/InjectedContentTests.java b/samples/AconfigDemo/tests/src/com/example/android/aconfig/demo/InjectedContentTests.java
index 465601398..c825838fe 100644
--- a/samples/AconfigDemo/tests/src/com/example/android/aconfig/demo/InjectedContentTests.java
+++ b/samples/AconfigDemo/tests/src/com/example/android/aconfig/demo/InjectedContentTests.java
@@ -17,9 +17,8 @@
 package com.example.android.aconfig.demo;
 
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.mockito.Mockito.when;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
 
 import com.example.android.aconfig.demo.flags.FeatureFlags;
 
@@ -37,7 +36,9 @@ public final class InjectedContentTests {
         InjectedContent injectedContent = new InjectedContent(fakeFeatureFlag);
         StringBuilder expected = new StringBuilder();
         expected.append("The flag: appendInjectedContent is ON!!\n\n");
-        assertEquals("Get appendInjectedContent", expected.toString(), injectedContent.getContent());
+        expected.append("The flag: read only flag injected is OFF!!\n\n");
+        assertEquals(
+                "Get appendInjectedContent", expected.toString(), injectedContent.getContent());
     }
 }
 
diff --git a/samples/ApiDemos/res/layout/picture_in_picture.xml b/samples/ApiDemos/res/layout/picture_in_picture.xml
index a55ad551a..b953e536c 100644
--- a/samples/ApiDemos/res/layout/picture_in_picture.xml
+++ b/samples/ApiDemos/res/layout/picture_in_picture.xml
@@ -83,6 +83,13 @@
                 android:padding="8dp"
                 android:text="@string/activity_picture_in_picture_enter_pip_on_back_toggle" />
 
+            <Switch
+                android:id="@+id/show_when_locked"
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content"
+                android:padding="8dp"
+                android:text="@string/activity_picture_in_picture_show_when_locked_toggle" />
+
             <RadioGroup
                 android:id="@+id/current_position"
                 android:layout_width="match_parent"
diff --git a/samples/ApiDemos/res/values/strings.xml b/samples/ApiDemos/res/values/strings.xml
index 60fb44c78..5783a9729 100644
--- a/samples/ApiDemos/res/values/strings.xml
+++ b/samples/ApiDemos/res/values/strings.xml
@@ -67,6 +67,7 @@
     <string name="activity_picture_in_picture_source_rect_hint_toggle">Enable source rect hint</string>
     <string name="activity_picture_in_picture_seamless_resize_toggle">Enable seamless resize</string>
     <string name="activity_picture_in_picture_enter_pip_on_back_toggle">Enter PiP on back</string>
+    <string name="activity_picture_in_picture_show_when_locked_toggle">Show when locked</string>
     <string name="activity_picture_in_picture_placeholder_text">
             This string should be invisible during the enter-pip animation
     </string>
diff --git a/samples/ApiDemos/src/com/example/android/apis/app/PictureInPicture.java b/samples/ApiDemos/src/com/example/android/apis/app/PictureInPicture.java
index c1568e791..ddb0652e5 100644
--- a/samples/ApiDemos/src/com/example/android/apis/app/PictureInPicture.java
+++ b/samples/ApiDemos/src/com/example/android/apis/app/PictureInPicture.java
@@ -61,7 +61,7 @@ public class PictureInPicture extends Activity {
     private static final String EXTRA_ENABLE_SEAMLESS_RESIZE = "seamless_resize";
     private static final String EXTRA_ENTER_PIP_ON_BACK = "enter_pip_on_back";
     private static final String EXTRA_CURRENT_POSITION = "current_position";
-    private static final String EXTRA_ASPECT_RATIO = "aspect_ratio";
+    private static final String EXTRA_SHOW_WHEN_LOCKED = "show_when_locked";
 
     private static final int TABLET_BREAK_POINT_DP = 700;
 
@@ -110,6 +110,7 @@ public class PictureInPicture extends Activity {
     private Switch mSourceRectHintToggle;
     private Switch mSeamlessResizeToggle;
     private Switch mEnterPipOnBackToggle;
+    private Switch mShowWhenLockedToggle;
     private RadioGroup mCurrentPositionGroup;
     private Spinner mAspectRatioSpinner;
     private List<RemoteAction> mPipActions;
@@ -129,6 +130,7 @@ public class PictureInPicture extends Activity {
         mSourceRectHintToggle = findViewById(R.id.source_rect_hint_toggle);
         mSeamlessResizeToggle = findViewById(R.id.seamless_resize_toggle);
         mEnterPipOnBackToggle = findViewById(R.id.enter_pip_on_back);
+        mShowWhenLockedToggle = findViewById(R.id.show_when_locked);
         mCurrentPositionGroup = findViewById(R.id.current_position);
         mAspectRatioSpinner = findViewById(R.id.aspect_ratio);
 
@@ -144,6 +146,8 @@ public class PictureInPicture extends Activity {
         mSourceRectHintToggle.setOnCheckedChangeListener(mOnToggleChangedListener);
         mSeamlessResizeToggle.setOnCheckedChangeListener(mOnToggleChangedListener);
         mEnterPipOnBackToggle.setOnCheckedChangeListener(mOnToggleChangedListener);
+        mShowWhenLockedToggle.setOnCheckedChangeListener(
+                (v, isChecked) -> setShowWhenLocked(isChecked));
         getOnBackInvokedDispatcher().registerOnBackInvokedCallback(
                 OnBackInvokedDispatcher.PRIORITY_DEFAULT, () -> {
                     if (mEnterPipOnBackToggle.isChecked()) {
@@ -181,6 +185,8 @@ public class PictureInPicture extends Activity {
                 intent.getBooleanExtra(EXTRA_ENABLE_SEAMLESS_RESIZE, false));
         mEnterPipOnBackToggle.setChecked(
                 intent.getBooleanExtra(EXTRA_ENTER_PIP_ON_BACK, false));
+        mShowWhenLockedToggle.setChecked(
+                intent.getBooleanExtra(EXTRA_SHOW_WHEN_LOCKED, false));
         final int positionId = "end".equalsIgnoreCase(
                 intent.getStringExtra(EXTRA_CURRENT_POSITION))
                 ? R.id.radio_current_end
diff --git a/samples/DataWiper/Android.bp b/samples/DataWiper/Android.bp
index 08f2ac1a4..e8955fedd 100644
--- a/samples/DataWiper/Android.bp
+++ b/samples/DataWiper/Android.bp
@@ -17,8 +17,8 @@
 // We build two apps from the same source
 
 package {
-    default_team: "trendy_team_framework_backstage_power",
     default_applicable_licenses: ["Android-Apache-2.0"],
+    default_team: "trendy_team_framework_bpm",
 }
 
 android_test {
diff --git a/samples/DeviceAdminWhitelistedAccount/Android.bp b/samples/DeviceAdminWhitelistedAccount/Android.bp
index 146ab05c3..3b89ca735 100644
--- a/samples/DeviceAdminWhitelistedAccount/Android.bp
+++ b/samples/DeviceAdminWhitelistedAccount/Android.bp
@@ -17,8 +17,8 @@
 // We build two apps from the same source
 
 package {
-    default_team: "trendy_team_framework_backstage_power",
     default_applicable_licenses: ["Android-Apache-2.0"],
+    default_team: "trendy_team_framework_bpm",
 }
 
 android_test {
diff --git a/samples/HoneycombGallery/src/com/example/android/hcgallery/ContentFragment.java b/samples/HoneycombGallery/src/com/example/android/hcgallery/ContentFragment.java
index b6754f9f5..764c0d8d7 100644
--- a/samples/HoneycombGallery/src/com/example/android/hcgallery/ContentFragment.java
+++ b/samples/HoneycombGallery/src/com/example/android/hcgallery/ContentFragment.java
@@ -45,6 +45,7 @@ import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import java.util.Objects;
 import java.util.StringTokenizer;
 
 /** Fragment that shows the content selected from the TitlesFragment.
@@ -347,7 +348,7 @@ public class ContentFragment extends Fragment {
              */
             @Override
             protected void onPostExecute(Boolean result) {
-                if (result != Boolean.TRUE) {
+                if (!Objects.equals(result, Boolean.TRUE)) {
                     return;
                 }
 
diff --git a/samples/MotionMechanics/Android.bp b/samples/MotionMechanics/Android.bp
index 7e948f78d..4dda1965d 100644
--- a/samples/MotionMechanics/Android.bp
+++ b/samples/MotionMechanics/Android.bp
@@ -37,6 +37,8 @@ android_library {
         "androidx.compose.runtime_runtime",
         "androidx.navigation_navigation-compose",
         "androidx.window_window",
+        "androidx-constraintlayout_constraintlayout",
+        "androidx.appcompat_appcompat",
     ],
 
     kotlincflags: ["-Xjvm-default=all"],
diff --git a/samples/MotionMechanics/app/AndroidManifest.xml b/samples/MotionMechanics/app/AndroidManifest.xml
index 70b27a152..e6b48a385 100644
--- a/samples/MotionMechanics/app/AndroidManifest.xml
+++ b/samples/MotionMechanics/app/AndroidManifest.xml
@@ -32,5 +32,17 @@
                 <category android:name="android.intent.category.LAUNCHER" />
             </intent-filter>
         </activity>
+
+        <activity
+            android:name="com.android.mechanics.demo.ViewDemoActivity"
+            android:theme="@style/Theme.AppCompat.NoActionBar"
+            android:windowSoftInputMode="adjustResize"
+            android:exported="true">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.LAUNCHER" />
+            </intent-filter>
+        </activity>
+
     </application>
 </manifest>
diff --git a/samples/MotionMechanics/res/layout/view_demo.xml b/samples/MotionMechanics/res/layout/view_demo.xml
new file mode 100644
index 000000000..3dfee6dc0
--- /dev/null
+++ b/samples/MotionMechanics/res/layout/view_demo.xml
@@ -0,0 +1,59 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+  ~ Copyright (C) 2025 The Android Open Source Project
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~      http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+
+<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:app="http://schemas.android.com/apk/res-auto"
+    xmlns:tools="http://schemas.android.com/tools"
+    android:id="@+id/rootLayout"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:paddingTop="80dp"
+    android:paddingLeft="16dp"
+    android:paddingRight="16dp"
+    tools:context=".MainActivity">
+
+    <Spinner
+        android:id="@+id/dropdown"
+        android:layout_width="0dp"
+        android:layout_height="wrap_content"
+        app:layout_constraintTop_toTopOf="parent"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintEnd_toEndOf="parent"
+        />
+
+    <View
+        android:id="@+id/box"
+        android:layout_width="20dp"
+        android:layout_height="20dp"
+        android:background="#FF0000"
+        app:layout_constraintTop_toBottomOf="@id/dropdown"
+        app:layout_constraintStart_toStartOf="parent"
+
+        android:layout_marginTop="40dp"
+        />
+
+    <SeekBar
+        android:id="@+id/slider"
+        android:layout_width="0dp"
+        android:layout_height="wrap_content"
+        android:layout_marginTop="50dp"
+        app:layout_constraintTop_toBottomOf="@id/box"
+        app:layout_constraintStart_toStartOf="parent"
+        app:layout_constraintEnd_toEndOf="parent"
+        />
+
+</androidx.constraintlayout.widget.ConstraintLayout>
\ No newline at end of file
diff --git a/samples/MotionMechanics/src/com/android/mechanics/demo/MechanicsDemo.kt b/samples/MotionMechanics/src/com/android/mechanics/demo/MechanicsDemo.kt
index 61c3ade0a..780facf29 100644
--- a/samples/MotionMechanics/src/com/android/mechanics/demo/MechanicsDemo.kt
+++ b/samples/MotionMechanics/src/com/android/mechanics/demo/MechanicsDemo.kt
@@ -23,48 +23,27 @@ import androidx.compose.runtime.Composable
 import androidx.compose.ui.Modifier
 import androidx.navigation.compose.NavHost
 import androidx.navigation.compose.rememberNavController
-import com.android.mechanics.demo.demos.MagneticOverviewDismiss
-import com.android.mechanics.demo.demos.MaterialFadeThrough
 import com.android.mechanics.demo.presentation.DirectionChangeDemo
 import com.android.mechanics.demo.presentation.DirectionSpecDemo
 import com.android.mechanics.demo.presentation.GuaranteeBoxDemo
 import com.android.mechanics.demo.presentation.GuaranteeFadeDemo
-import com.android.mechanics.demo.presentation.PracticalDemoDetach
+import com.android.mechanics.demo.presentation.MagneticDetachDemo
+import com.android.mechanics.demo.presentation.MagneticDetachWithOverdragDemo
 import com.android.mechanics.demo.presentation.SpecDemo
 
 object DemoScreens {
 
-    private val MotionMechanicsPresentation =
-        ParentScreen(
-            "mm_preso_jan_21",
-            mapOf(
-                "S06 - Expandable Drag Container" to DemoScreen(MaterialFadeThrough),
-                //                "S08 - Predefined Motion" to DemoScreen(MaterialFadeThrough),
-                //                "S09 - Dynamic Motion" to DemoScreen(MaterialFadeThrough),
-                //                "S10 - Continuous Motion" to DemoScreen(MaterialFadeThrough),
-                "S17 - Motion Spec" to DemoScreen(SpecDemo),
-                "S22 - Directionality Hysteresis" to DemoScreen(DirectionChangeDemo),
-                "S23 - Directionality Effects" to DemoScreen(DirectionSpecDemo),
-                "S24 - Guaranteed Fade" to DemoScreen(GuaranteeFadeDemo),
-                "S25 - Guaranteed Size" to DemoScreen(GuaranteeBoxDemo),
-                //                "Extra - Appear" to DemoScreen(PracticalDemoAppear),
-                "Extra - Magnetic Detach" to DemoScreen(PracticalDemoDetach),
-                //                "S25 - Magnetic Detach" to DemoScreen(MaterialFadeThrough),
-                //                "Motion Mechanics Presentation" to MotionMechanicsPresentation,
-                "Extra - Magnetic Card Dismiss" to DemoScreen(MagneticOverviewDismiss),
-                //                "Material Fade Through" to DemoScreen(MaterialFadeThrough),
-                //                "Extra - Tactile Surface Reveal" to
-                // DemoScreen(TactileSurfaceReveal),
-            ),
-        )
-
     val Home =
         ParentScreen(
             "home",
             mapOf(
-                "MM Presentation" to MotionMechanicsPresentation,
-                "Magnetic Card Dismiss" to DemoScreen(MagneticOverviewDismiss),
-                "Material Fade Through" to DemoScreen(MaterialFadeThrough),
+                "Simple Motion Spec examples" to DemoScreen(SpecDemo),
+                "Directionality Hysteresis" to DemoScreen(DirectionChangeDemo),
+                "Directionality Effects" to DemoScreen(DirectionSpecDemo),
+                "Guaranteed Fade" to DemoScreen(GuaranteeFadeDemo),
+                "Guaranteed Size" to DemoScreen(GuaranteeBoxDemo),
+                "Magnetic detach" to DemoScreen(MagneticDetachDemo),
+                "Magnetic detach with Overdrag" to DemoScreen(MagneticDetachWithOverdragDemo),
             ),
         )
 }
diff --git a/samples/MotionMechanics/src/com/android/mechanics/demo/ViewDemoActivity.kt b/samples/MotionMechanics/src/com/android/mechanics/demo/ViewDemoActivity.kt
new file mode 100644
index 000000000..e46bee146
--- /dev/null
+++ b/samples/MotionMechanics/src/com/android/mechanics/demo/ViewDemoActivity.kt
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.mechanics.demo
+
+import android.os.Bundle
+import android.view.View
+import android.widget.AdapterView
+import android.widget.ArrayAdapter
+import android.widget.SeekBar
+import android.widget.Spinner
+import androidx.appcompat.app.AppCompatActivity
+import androidx.constraintlayout.widget.ConstraintLayout
+import com.android.mechanics.spec.Mapping
+import com.android.mechanics.spec.MotionSpec
+import com.android.mechanics.spec.builder.directionalMotionSpec
+import com.android.mechanics.spring.SpringParameters
+import com.android.mechanics.view.DistanceGestureContext
+import com.android.mechanics.view.ViewMotionValue
+
+class ViewDemoActivity : AppCompatActivity() {
+
+    private lateinit var slider: SeekBar
+    private lateinit var box: View
+    private lateinit var rootLayout: ConstraintLayout
+    private lateinit var dropdown: Spinner
+    private var specs = createMotionSpecs(100f)
+
+    private val gestureContext by lazy { DistanceGestureContext.create(this) }
+    private val motionValue by lazy { ViewMotionValue(0f, gestureContext, MotionSpec.Empty) }
+
+    override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+        setContentView(R.layout.view_demo)
+
+        slider = findViewById(R.id.slider)
+        box = findViewById(R.id.box)
+        rootLayout = findViewById(R.id.rootLayout)
+        dropdown = findViewById(R.id.dropdown)
+        dropdown.onItemSelectedListener =
+            object : AdapterView.OnItemSelectedListener {
+                override fun onItemSelected(
+                    parent: AdapterView<*>?,
+                    view: View?,
+                    position: Int,
+                    id: Long,
+                ) {
+                    val key = checkNotNull(parent?.adapter?.getItem(position) as String)
+
+                    motionValue.spec = checkNotNull(specs[key])
+                }
+
+                override fun onNothingSelected(parent: AdapterView<*>?) {}
+            }
+
+        var maxRange = -1f
+
+        slider.viewTreeObserver.addOnGlobalLayoutListener {
+            val newWidth = slider.width.toFloat() - slider.thumb.bounds.width()
+            if (maxRange != newWidth) {
+                val percentage = slider.progress.toFloat() / slider.max.toFloat()
+                maxRange = newWidth
+
+                slider.max = maxRange.toInt()
+                slider.progress = (maxRange * percentage).toInt()
+
+                specs = createMotionSpecs(maxRange)
+
+                dropdown.adapter =
+                    ArrayAdapter(this, android.R.layout.simple_spinner_item, specs.keys.toList())
+                        .apply {
+                            setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
+                        }
+            }
+        }
+
+        slider.setOnSeekBarChangeListener(
+            object : SeekBar.OnSeekBarChangeListener {
+                override fun onProgressChanged(
+                    seekBar: SeekBar?,
+                    progress: Int,
+                    fromUser: Boolean,
+                ) {
+                    if (fromUser) {
+                        gestureContext.dragOffset = progress.toFloat()
+                        motionValue.input = progress.toFloat()
+                    }
+                }
+
+                override fun onStartTrackingTouch(seekBar: SeekBar?) {}
+
+                override fun onStopTrackingTouch(seekBar: SeekBar?) {}
+            }
+        )
+
+        motionValue.addUpdateCallback {
+            val layoutParams = box.layoutParams as ConstraintLayout.LayoutParams
+            layoutParams.leftMargin = motionValue.output.toInt()
+            box.layoutParams = layoutParams
+        }
+    }
+
+    override fun onDestroy() {
+        super.onDestroy()
+        motionValue.dispose()
+    }
+
+    fun createMotionSpecs(maxRange: Float): Map<String, MotionSpec> {
+        return mapOf(
+            "empty" to MotionSpec.Empty,
+            "toggle" to
+                MotionSpec(
+                    directionalMotionSpec(DefaultSpring, Mapping.Zero) {
+                        fixedValue(breakpoint = maxRange / 2f, value = maxRange)
+                    }
+                ),
+        )
+    }
+
+    companion object {
+        val DefaultSpring = SpringParameters(700f, 0.8f)
+    }
+}
diff --git a/samples/MotionMechanics/src/com/android/mechanics/demo/demos/MagneticOverviewDismiss.kt b/samples/MotionMechanics/src/com/android/mechanics/demo/demos/MagneticOverviewDismiss.kt
deleted file mode 100644
index fdfdf10df..000000000
--- a/samples/MotionMechanics/src/com/android/mechanics/demo/demos/MagneticOverviewDismiss.kt
+++ /dev/null
@@ -1,261 +0,0 @@
-/*
- * Copyright (C) 2025 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.mechanics.demo.demos
-
-import androidx.compose.animation.core.Animatable
-import androidx.compose.foundation.gestures.Orientation
-import androidx.compose.foundation.gestures.draggable
-import androidx.compose.foundation.gestures.rememberDraggableState
-import androidx.compose.foundation.layout.Box
-import androidx.compose.foundation.layout.Column
-import androidx.compose.foundation.layout.ColumnScope
-import androidx.compose.foundation.layout.fillMaxSize
-import androidx.compose.foundation.layout.fillMaxWidth
-import androidx.compose.foundation.layout.offset
-import androidx.compose.foundation.layout.padding
-import androidx.compose.foundation.layout.size
-import androidx.compose.material3.Card
-import androidx.compose.material3.CardDefaults.outlinedCardColors
-import androidx.compose.material3.ExperimentalMaterial3ExpressiveApi
-import androidx.compose.material3.MaterialTheme
-import androidx.compose.material3.MotionScheme
-import androidx.compose.runtime.Composable
-import androidx.compose.runtime.getValue
-import androidx.compose.runtime.mutableStateOf
-import androidx.compose.runtime.remember
-import androidx.compose.runtime.setValue
-import androidx.compose.ui.Alignment
-import androidx.compose.ui.Modifier
-import androidx.compose.ui.platform.LocalDensity
-import androidx.compose.ui.unit.Density
-import androidx.compose.ui.unit.Dp
-import androidx.compose.ui.unit.IntOffset
-import androidx.compose.ui.unit.dp
-import com.android.mechanics.debug.debugMotionValue
-import com.android.mechanics.demo.staging.asMechanics
-import com.android.mechanics.demo.staging.defaultSpatialSpring
-import com.android.mechanics.demo.staging.rememberDistanceGestureContext
-import com.android.mechanics.demo.staging.rememberMotionValue
-import com.android.mechanics.demo.tuneable.Demo
-import com.android.mechanics.demo.tuneable.Section
-import com.android.mechanics.demo.tuneable.SliderWithPreview
-import com.android.mechanics.demo.tuneable.SpringParameterSection
-import com.android.mechanics.spec.BreakpointKey
-import com.android.mechanics.spec.DirectionalMotionSpec
-import com.android.mechanics.spec.InputDirection
-import com.android.mechanics.spec.Mapping
-import com.android.mechanics.spec.MotionSpec
-import com.android.mechanics.spec.OnChangeSegmentHandler
-import com.android.mechanics.spec.SegmentData
-import com.android.mechanics.spec.SegmentKey
-import com.android.mechanics.spec.builder
-import com.android.mechanics.spec.reverseBuilder
-import com.android.mechanics.spring.SpringParameters
-import kotlin.math.abs
-import kotlin.math.roundToInt
-
-object MagneticOverviewDismiss : Demo<MagneticOverviewDismiss.Config> {
-    object Keys {
-        val Start = BreakpointKey("Start")
-        val Detach = BreakpointKey("Detach")
-        val Dismiss = BreakpointKey("Dismiss")
-    }
-
-    data class Config(
-        val defaultSpring: SpringParameters,
-        val snapSpring: SpringParameters,
-        val dismissPosition: Dp = 400.dp,
-        val detachPosition: Dp = 200.dp,
-        val attachPosition: Dp = 50.dp,
-        val startPosition: Dp = 0.dp,
-        val velocityThreshold: Dp = 125.dp,
-        val overdragDistance: Dp = 24.dp,
-    )
-
-    @Composable
-    override fun DemoUi(config: Config, modifier: Modifier) {
-
-        val density = LocalDensity.current
-        val spec = remember(config) { with(density) { mutableStateOf(createDetachSpec(config)) } }
-        val gestureContext = rememberDistanceGestureContext()
-        val yOffset = rememberMotionValue(gestureContext::dragOffset, spec::value, gestureContext)
-
-        Column(modifier = modifier.fillMaxSize().padding(64.dp).debugMotionValue(yOffset)) {
-            Box(modifier = Modifier.weight(1f).fillMaxWidth()) {
-                Card(
-                    colors = outlinedCardColors(MaterialTheme.colorScheme.primary),
-                    modifier =
-                        modifier
-                            .align(Alignment.Center)
-                            .padding(64.dp)
-                            .size(width = 150.dp, height = 300.dp)
-                            .offset { IntOffset(0, -yOffset.output.toInt()) }
-                            .draggable(
-                                orientation = Orientation.Vertical,
-                                state =
-                                    rememberDraggableState { delta ->
-                                        gestureContext.dragOffset -= delta
-                                    },
-                                onDragStopped = { velocity ->
-                                    with(yOffset.spec.maxDirection) {
-                                        val currentValue = gestureContext.dragOffset
-                                        val detachPosition =
-                                            breakpoints[findBreakpointIndex(Keys.Detach)].position
-                                        val isDismiss =
-                                            if (
-                                                abs(velocity) >
-                                                    with(density) {
-                                                        config.velocityThreshold.toPx()
-                                                    }
-                                            ) {
-                                                velocity < 0
-                                            } else {
-                                                currentValue > detachPosition
-                                            }
-
-                                        val snapTarget =
-                                            breakpoints[
-                                                    findBreakpointIndex(
-                                                        if (isDismiss) Keys.Dismiss else Keys.Start
-                                                    )]
-                                                .position
-                                        Animatable(gestureContext.dragOffset).animateTo(
-                                            snapTarget
-                                        ) {
-                                            gestureContext.dragOffset = value
-                                        }
-                                    }
-                                },
-                            ),
-                ) {}
-            }
-        }
-    }
-
-    override var visualizationInputRange by mutableStateOf(0f..1000f)
-
-    // Stuff below is only demo helpers - configuration, stuff that should go to libraries etc.
-
-    @Composable
-    override fun ColumnScope.ConfigUi(config: Config, onConfigChanged: (Config) -> Unit) {
-
-        SpringParameterSection(
-            label = "Snap Spring",
-            value = config.snapSpring,
-            onValueChanged = { onConfigChanged(config.copy(snapSpring = it)) },
-            sectionKey = "snap_spring",
-        )
-
-        Section(
-            label = "Detach Position",
-            summary = { "$it" },
-            value = config.detachPosition,
-            onValueChanged = { onConfigChanged(config.copy(detachPosition = it)) },
-            sectionKey = "detach_position",
-        ) { value, onValueChanged ->
-            SliderWithPreview(
-                value = value.value,
-                valueRange = config.attachPosition.value..config.dismissPosition.value,
-                onValueChange = { onValueChanged(it.dp) },
-                render = { "$it" },
-                normalize = { it.roundToInt().toFloat() },
-                modifier = Modifier.fillMaxWidth(),
-            )
-        }
-
-        Section(
-            label = "Attach Position",
-            summary = { "$it" },
-            value = config.attachPosition,
-            onValueChanged = { onConfigChanged(config.copy(attachPosition = it)) },
-            sectionKey = "attach_position",
-        ) { value, onValueChanged ->
-            SliderWithPreview(
-                value = value.value,
-                valueRange = config.startPosition.value..config.detachPosition.value,
-                onValueChange = { onValueChanged(it.dp) },
-                render = { "$it" },
-                normalize = { it.roundToInt().toFloat() },
-                modifier = Modifier.fillMaxWidth(),
-            )
-        }
-    }
-
-    @Composable
-    @OptIn(ExperimentalMaterial3ExpressiveApi::class)
-    override fun rememberDefaultConfig(): Config {
-        val defaultSpring = defaultSpatialSpring()
-        val snapSpring = MotionScheme.expressive().fastSpatialSpec<Float>().asMechanics()
-        return remember(defaultSpring, snapSpring) { Config(defaultSpring, snapSpring) }
-    }
-
-    fun Density.createDetachSpec(config: Config): MotionSpec {
-        val overdragDistancePx = config.overdragDistance.toPx()
-        val startPosPx = config.startPosition.toPx()
-        val detachPosPx = config.detachPosition.toPx()
-        val attachPosPx = config.attachPosition.toPx()
-        val dismissPosPx = config.dismissPosition.toPx()
-
-        val dismissedMapping = Mapping.Fixed(dismissPosPx)
-        val dismissSpec =
-            DirectionalMotionSpec.builder(
-                    config.defaultSpring,
-                    initialMapping = Mapping.Tanh(overdragDistancePx, 3f),
-                )
-                .toBreakpoint(startPosPx, Keys.Start)
-                .continueWith(Mapping.Linear(.3f))
-                .toBreakpoint(detachPosPx, Keys.Detach)
-                .continueWith(Mapping.Identity, config.snapSpring)
-                .toBreakpoint(dismissPosPx, Keys.Dismiss)
-                .completeWith(dismissedMapping)
-
-        val abortSpec =
-            DirectionalMotionSpec.reverseBuilder(
-                    config.defaultSpring,
-                    initialMapping = dismissedMapping,
-                )
-                .toBreakpoint(dismissPosPx, Keys.Dismiss)
-                .continueWith(Mapping.Identity)
-                .toBreakpoint(attachPosPx, Keys.Detach)
-                .continueWith(mapping = Mapping.Zero, spring = config.snapSpring)
-                .toBreakpoint(startPosPx, Keys.Start)
-                .completeWith(Mapping.Tanh(overdragDistancePx, 3f))
-
-        val segmentHandlers =
-            mapOf<SegmentKey, OnChangeSegmentHandler>(
-                SegmentKey(Keys.Detach, Keys.Dismiss, InputDirection.Min) to
-                    { currentSegment, _, newDirection ->
-                        if (newDirection != currentSegment.direction) currentSegment else null
-                    },
-                SegmentKey(Keys.Start, Keys.Detach, InputDirection.Max) to
-                    { currentSegment: SegmentData, newInput: Float, newDirection: InputDirection ->
-                        if (newDirection != currentSegment.direction && newInput >= 0)
-                            currentSegment
-                        else null
-                    },
-            )
-
-        return MotionSpec(
-            maxDirection = dismissSpec,
-            minDirection = abortSpec,
-            resetSpring = config.defaultSpring,
-            segmentHandlers = segmentHandlers,
-        )
-    }
-
-    override val identifier: String = "magnetic_dismiss"
-}
diff --git a/samples/MotionMechanics/src/com/android/mechanics/demo/demos/MaterialFadeThrough.kt b/samples/MotionMechanics/src/com/android/mechanics/demo/demos/MaterialFadeThrough.kt
deleted file mode 100644
index c76a456d9..000000000
--- a/samples/MotionMechanics/src/com/android/mechanics/demo/demos/MaterialFadeThrough.kt
+++ /dev/null
@@ -1,190 +0,0 @@
-/*
- * Copyright (C) 2025 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-@file:OptIn(ExperimentalAnimatableApi::class)
-
-package com.android.mechanics.demo.demos
-
-import androidx.compose.animation.core.ExperimentalAnimatableApi
-import androidx.compose.foundation.background
-import androidx.compose.foundation.layout.Arrangement
-import androidx.compose.foundation.layout.Column
-import androidx.compose.foundation.layout.ColumnScope
-import androidx.compose.foundation.layout.Row
-import androidx.compose.foundation.layout.Spacer
-import androidx.compose.foundation.layout.fillMaxWidth
-import androidx.compose.foundation.layout.height
-import androidx.compose.foundation.layout.padding
-import androidx.compose.foundation.rememberScrollState
-import androidx.compose.foundation.verticalScroll
-import androidx.compose.material.icons.Icons
-import androidx.compose.material.icons.filled.AllInclusive
-import androidx.compose.material3.ExperimentalMaterial3ExpressiveApi
-import androidx.compose.material3.Icon
-import androidx.compose.material3.LocalContentColor
-import androidx.compose.material3.MaterialTheme
-import androidx.compose.material3.MaterialTheme.typography
-import androidx.compose.material3.Text
-import androidx.compose.runtime.Composable
-import androidx.compose.runtime.CompositionLocalProvider
-import androidx.compose.runtime.getValue
-import androidx.compose.runtime.mutableStateOf
-import androidx.compose.runtime.remember
-import androidx.compose.runtime.setValue
-import androidx.compose.ui.Modifier
-import androidx.compose.ui.unit.Dp
-import androidx.compose.ui.unit.dp
-import com.android.compose.animation.scene.ElementKey
-import com.android.compose.modifiers.thenIf
-import com.android.mechanics.demo.staging.behavior.reveal.FadeContentRevealSpec
-import com.android.mechanics.demo.staging.behavior.reveal.fadeReveal
-import com.android.mechanics.demo.staging.behavior.reveal.rememberFadeContentRevealSpec
-import com.android.mechanics.demo.staging.behavior.reveal.revealContainer
-import com.android.mechanics.demo.tuneable.Demo
-import com.android.mechanics.demo.tuneable.DpSlider
-import com.android.mechanics.demo.tuneable.GuaranteeSection
-import com.android.mechanics.demo.tuneable.LabelledCheckbox
-import com.android.mechanics.demo.tuneable.Section
-import com.android.mechanics.demo.tuneable.SpringParameterSection
-import com.android.mechanics.demo.util.ExpandableCard
-
-object MaterialFadeThrough : Demo<MaterialFadeThrough.Config> {
-    object Elements {
-        val ExpandableContent = ElementKey("ExpandableContent")
-    }
-
-    data class Config(val fadeSpec: FadeContentRevealSpec, val showItemBackground: Boolean)
-
-    @Composable
-    override fun DemoUi(config: Config, modifier: Modifier) {
-        val colors = MaterialTheme.colorScheme
-        ExpandableCard(
-            modifier = modifier.fillMaxWidth(),
-            header = { Text(text = "Contents", style = typography.titleMedium) },
-        ) { isExpanded ->
-            Column(
-                verticalArrangement = Arrangement.spacedBy(8.dp),
-                modifier =
-                    Modifier.fillMaxWidth()
-                        .element(Elements.ExpandableContent)
-                        .revealContainer(this@ExpandableCard)
-                        .verticalScroll(rememberScrollState())
-                        .padding(start = 16.dp, end = 16.dp, bottom = 16.dp),
-            ) {
-                if (isExpanded) {
-                    Spacer(modifier = Modifier.height(24.dp))
-                    repeat(10) {
-                        Row(
-                            horizontalArrangement = Arrangement.spacedBy(8.dp),
-                            modifier =
-                                Modifier.noResizeDuringTransitions()
-                                    .fadeReveal(spec = config.fadeSpec, debug = true)
-                                    .fillMaxWidth()
-                                    .thenIf(config.showItemBackground) {
-                                        Modifier.background(colors.primary)
-                                    },
-                        ) {
-                            CompositionLocalProvider(
-                                LocalContentColor provides
-                                    if (config.showItemBackground) colors.onPrimary
-                                    else colors.onSurface
-                            ) {
-                                Icon(Icons.Default.AllInclusive, null)
-                                Text(text = "Item ${it + 1}", modifier = Modifier.height(20.dp))
-                            }
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    @OptIn(ExperimentalMaterial3ExpressiveApi::class)
-    @Composable
-    override fun rememberDefaultConfig(): Config {
-        val fadeRevealSpec = rememberFadeContentRevealSpec(showDelta = 8.dp, hideDelta = 16.dp)
-        return remember(fadeRevealSpec) { Config(fadeRevealSpec, showItemBackground = false) }
-    }
-
-    override var visualizationInputRange by mutableStateOf(0f..1000f)
-    override val collapsedGraphHeight: Dp = 20.dp
-
-    @Composable
-    override fun ColumnScope.ConfigUi(config: Config, onConfigChanged: (Config) -> Unit) {
-        LabelledCheckbox(
-            "Show item background",
-            config.showItemBackground,
-            onCheckedChange = { onConfigChanged(config.copy(showItemBackground = it)) },
-            modifier = Modifier.fillMaxWidth(),
-        )
-
-        Section(
-            "Show",
-            summary = { "" },
-            value = config.fadeSpec,
-            onValueChanged = { onConfigChanged(config.copy(fadeSpec = it)) },
-            sectionKey = "show spec",
-            modifier = Modifier.fillMaxWidth(),
-        ) { spec, onSpecChanged ->
-            SpringParameterSection(
-                " Spring",
-                spec.showSpring,
-                onValueChanged = { onSpecChanged(spec.copy(showSpring = it)) },
-                "showspring",
-                modifier = Modifier.fillMaxWidth(),
-            )
-            GuaranteeSection(
-                " Guarantee",
-                spec.showGuarantee,
-                { onSpecChanged(spec.copy(showGuarantee = it)) },
-                "showguarantee",
-                modifier = Modifier.fillMaxWidth(),
-            )
-
-            Text(text = "Delta", modifier = Modifier.padding(start = 8.dp))
-            DpSlider(spec.showDelta, { onSpecChanged(spec.copy(showDelta = it)) }, 0.dp..24.dp)
-        }
-
-        Section(
-            "Hide",
-            summary = { "" },
-            value = config.fadeSpec,
-            onValueChanged = { onConfigChanged(config.copy(fadeSpec = it)) },
-            sectionKey = "show spec",
-            modifier = Modifier.fillMaxWidth(),
-        ) { spec, onSpecChanged ->
-            SpringParameterSection(
-                "Spring",
-                spec.hideSpring,
-                onValueChanged = { onSpecChanged(spec.copy(hideSpring = it)) },
-                "hidespring",
-                modifier = Modifier.fillMaxWidth(),
-            )
-            GuaranteeSection(
-                "Guarantee",
-                spec.hideGuarantee,
-                { onSpecChanged(spec.copy(hideGuarantee = it)) },
-                "hideguarantee",
-                modifier = Modifier.fillMaxWidth(),
-            )
-
-            Text(text = "Delta", modifier = Modifier.padding(start = 8.dp))
-            DpSlider(spec.hideDelta, { onSpecChanged(spec.copy(hideDelta = it)) }, 0.dp..24.dp)
-        }
-    }
-
-    override val identifier: String = "material_fade_through"
-}
diff --git a/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/DirectionChangeDemo.kt b/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/DirectionChangeDemo.kt
index d78896b88..baf01783b 100644
--- a/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/DirectionChangeDemo.kt
+++ b/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/DirectionChangeDemo.kt
@@ -35,7 +35,6 @@ import androidx.compose.material3.Slider
 import androidx.compose.material3.Text
 import androidx.compose.runtime.Composable
 import androidx.compose.runtime.getValue
-import androidx.compose.runtime.mutableFloatStateOf
 import androidx.compose.runtime.mutableStateOf
 import androidx.compose.runtime.remember
 import androidx.compose.runtime.setValue
@@ -47,36 +46,30 @@ import androidx.compose.ui.geometry.Offset
 import androidx.compose.ui.graphics.PathEffect
 import androidx.compose.ui.layout.onPlaced
 import androidx.compose.ui.platform.LocalDensity
-import androidx.compose.ui.platform.LocalViewConfiguration
 import androidx.compose.ui.unit.IntOffset
 import androidx.compose.ui.unit.dp
 import com.android.mechanics.debug.DebugMotionValueVisualization
 import com.android.mechanics.debug.debugMotionValue
-import com.android.mechanics.demo.staging.defaultSpatialSpring
 import com.android.mechanics.demo.staging.rememberDistanceGestureContext
 import com.android.mechanics.demo.staging.rememberMotionValue
 import com.android.mechanics.demo.tuneable.Demo
+import com.android.mechanics.effects.FixedValue
 import com.android.mechanics.spec.Mapping
 import com.android.mechanics.spec.MotionSpec
-import com.android.mechanics.spec.builder
-import com.android.mechanics.spring.SpringParameters
+import com.android.mechanics.spec.builder.rememberMotionBuilderContext
+import com.android.mechanics.spec.builder.spatialMotionSpec
 
-object DirectionChangeDemo : Demo<DirectionChangeDemo.Config> {
-
-    data class Config(val defaultSpring: SpringParameters)
+object DirectionChangeDemo : Demo<Unit> {
 
     var inputRange by mutableStateOf(0f..0f)
 
     @Composable
-    override fun DemoUi(config: Config, modifier: Modifier) {
+    override fun DemoUi(config: Unit, modifier: Modifier) {
         val colors = MaterialTheme.colorScheme
 
-        val initialTouchSlop = LocalViewConfiguration.current.touchSlop
-        val touchSlop by remember { mutableFloatStateOf(initialTouchSlop) }
-
         // Also using GestureContext.dragOffset as input.
         val gestureContext = rememberDistanceGestureContext()
-        val spec = rememberSpec(inputOutputRange = inputRange, config)
+        val spec = rememberSpec(inputOutputRange = inputRange)
         val motionValue = rememberMotionValue(gestureContext::dragOffset, { spec }, gestureContext)
 
         Column(
@@ -144,32 +137,27 @@ object DirectionChangeDemo : Demo<DirectionChangeDemo.Config> {
     }
 
     @Composable
-    fun rememberSpec(
-        inputOutputRange: ClosedFloatingPointRange<Float>,
-        config: Config,
-    ): MotionSpec {
-
-        return remember(inputOutputRange, config) {
-            MotionSpec.builder(
-                    config.defaultSpring,
-                    initialMapping = Mapping.Fixed(inputOutputRange.start),
-                )
-                .toBreakpoint((inputOutputRange.start + inputOutputRange.endInclusive) / 2f)
-                .completeWith(Mapping.Fixed(inputOutputRange.endInclusive))
+    fun rememberSpec(inputOutputRange: ClosedFloatingPointRange<Float>): MotionSpec {
+
+        val builderContext = rememberMotionBuilderContext()
+        return remember(inputOutputRange, builderContext) {
+            with(builderContext) {
+                spatialMotionSpec(baseMapping = Mapping.Fixed(inputOutputRange.start)) {
+                    after(
+                        (inputOutputRange.start + inputOutputRange.endInclusive) / 2f,
+                        FixedValue(inputOutputRange.endInclusive),
+                    )
+                }
+            }
         }
     }
 
-    @Composable
-    override fun rememberDefaultConfig(): Config {
-        val defaultSpring = defaultSpatialSpring()
-        return remember(defaultSpring) { Config(defaultSpring) }
-    }
+    @Composable override fun rememberDefaultConfig() {}
 
     override val visualizationInputRange: ClosedFloatingPointRange<Float>
         get() = inputRange
 
-    @Composable
-    override fun ColumnScope.ConfigUi(config: Config, onConfigChanged: (Config) -> Unit) {}
+    @Composable override fun ColumnScope.ConfigUi(config: Unit, onConfigChanged: (Unit) -> Unit) {}
 
     override val identifier: String = "DirectionChangeDemo"
 }
diff --git a/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/DirectionSpecDemo.kt b/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/DirectionSpecDemo.kt
index 1557fa68d..8f4566e85 100644
--- a/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/DirectionSpecDemo.kt
+++ b/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/DirectionSpecDemo.kt
@@ -32,7 +32,6 @@ import androidx.compose.foundation.layout.size
 import androidx.compose.foundation.shape.RoundedCornerShape
 import androidx.compose.material3.ExperimentalMaterial3ExpressiveApi
 import androidx.compose.material3.MaterialTheme
-import androidx.compose.material3.MotionScheme
 import androidx.compose.material3.Slider
 import androidx.compose.material3.Text
 import androidx.compose.runtime.Composable
@@ -52,42 +51,36 @@ import androidx.compose.ui.unit.IntOffset
 import androidx.compose.ui.unit.dp
 import com.android.mechanics.debug.DebugMotionValueVisualization
 import com.android.mechanics.debug.debugMotionValue
-import com.android.mechanics.demo.staging.asMechanics
-import com.android.mechanics.demo.staging.defaultSpatialSpring
 import com.android.mechanics.demo.staging.rememberDistanceGestureContext
 import com.android.mechanics.demo.staging.rememberMotionValue
 import com.android.mechanics.demo.tuneable.Demo
 import com.android.mechanics.spec.Breakpoint
 import com.android.mechanics.spec.BreakpointKey
-import com.android.mechanics.spec.DirectionalMotionSpec
 import com.android.mechanics.spec.InputDirection
 import com.android.mechanics.spec.Mapping
 import com.android.mechanics.spec.MotionSpec
 import com.android.mechanics.spec.OnChangeSegmentHandler
 import com.android.mechanics.spec.SegmentData
 import com.android.mechanics.spec.SegmentKey
-import com.android.mechanics.spec.builder
-import com.android.mechanics.spec.reverseBuilder
-import com.android.mechanics.spring.SpringParameters
+import com.android.mechanics.spec.builder.rememberMotionBuilderContext
+import com.android.mechanics.spec.builder.spatialDirectionalMotionSpec
 
-object DirectionSpecDemo : Demo<DirectionSpecDemo.Config> {
+object DirectionSpecDemo : Demo<Unit> {
     object Keys {
         val Start = BreakpointKey("Start")
         val Detach = BreakpointKey("Detach")
         val End = Breakpoint.maxLimit.key
     }
 
-    data class Config(val defaultSpring: SpringParameters)
-
     var inputRange by mutableStateOf(0f..0f)
 
     @Composable
-    override fun DemoUi(config: Config, modifier: Modifier) {
+    override fun DemoUi(config: Unit, modifier: Modifier) {
         val colors = MaterialTheme.colorScheme
 
         // Also using GestureContext.dragOffset as input.
         val gestureContext = rememberDistanceGestureContext()
-        val spec = rememberSpec(inputOutputRange = inputRange, config)
+        val spec = rememberSpec(inputOutputRange = inputRange)
         val motionValue = rememberMotionValue(gestureContext::dragOffset, { spec }, gestureContext)
 
         Column(
@@ -155,67 +148,62 @@ object DirectionSpecDemo : Demo<DirectionSpecDemo.Config> {
     }
 
     @Composable
-    fun rememberSpec(
-        inputOutputRange: ClosedFloatingPointRange<Float>,
-        config: Config,
-    ): MotionSpec {
+    fun rememberSpec(inputOutputRange: ClosedFloatingPointRange<Float>): MotionSpec {
         val delta = inputOutputRange.endInclusive - inputOutputRange.start
 
         val startPosPx = inputOutputRange.start
         val detachPosPx = delta * .4f
         val attachPosPx = delta * .1f
 
-        val fastSpring = MotionScheme.expressive().fastSpatialSpec<Float>().asMechanics()
-        val slowSpring = MotionScheme.expressive().slowSpatialSpec<Float>().asMechanics()
-
-        return remember(inputOutputRange, config) {
-            val detachSpec =
-                DirectionalMotionSpec.builder(config.defaultSpring, initialMapping = Mapping.Zero)
-                    .toBreakpoint(startPosPx, Keys.Start)
-                    .continueWith(Mapping.Linear(.3f))
-                    .toBreakpoint(detachPosPx, Keys.Detach)
-                    .completeWith(Mapping.Identity, slowSpring)
-
-            val attachSpec =
-                DirectionalMotionSpec.reverseBuilder(config.defaultSpring)
-                    .toBreakpoint(attachPosPx, Keys.Detach)
-                    .completeWith(mapping = Mapping.Zero, fastSpring)
-
-            val segmentHandlers =
-                mapOf<SegmentKey, OnChangeSegmentHandler>(
-                    SegmentKey(Keys.Detach, Keys.End, InputDirection.Min) to
-                        { currentSegment, _, newDirection ->
-                            if (newDirection != currentSegment.direction) currentSegment else null
-                        },
-                    SegmentKey(Keys.Start, Keys.Detach, InputDirection.Max) to
-                        { currentSegment: SegmentData, newInput: Float, newDirection: InputDirection
-                            ->
-                            if (newDirection != currentSegment.direction && newInput >= 0)
-                                currentSegment
-                            else null
-                        },
+        val builderContext = rememberMotionBuilderContext()
+
+        return remember(inputOutputRange, builderContext) {
+            with(builderContext) {
+                val detachSpec =
+                    spatialDirectionalMotionSpec(initialMapping = Mapping.Zero) {
+                        fractionalInputFromCurrent(startPosPx, fraction = .3f, key = Keys.Start)
+                        identity(detachPosPx, key = Keys.Detach, spring = spatial.slow)
+                    }
+
+                val attachSpec =
+                    spatialDirectionalMotionSpec(initialMapping = Mapping.Zero) {
+                        identity(attachPosPx, key = Keys.Detach, spring = spatial.fast)
+                    }
+
+                val segmentHandlers =
+                    mapOf<SegmentKey, OnChangeSegmentHandler>(
+                        SegmentKey(Keys.Detach, Keys.End, InputDirection.Min) to
+                            { currentSegment, _, newDirection ->
+                                if (newDirection != currentSegment.direction) currentSegment
+                                else null
+                            },
+                        SegmentKey(Keys.Start, Keys.Detach, InputDirection.Max) to
+                            {
+                                currentSegment: SegmentData,
+                                newInput: Float,
+                                newDirection: InputDirection ->
+                                if (newDirection != currentSegment.direction && newInput >= 0)
+                                    currentSegment
+                                else null
+                            },
+                    )
+
+                MotionSpec(
+                    maxDirection = detachSpec,
+                    minDirection = attachSpec,
+                    resetSpring = spatial.default,
+                    segmentHandlers = segmentHandlers,
                 )
-
-            MotionSpec(
-                maxDirection = detachSpec,
-                minDirection = attachSpec,
-                resetSpring = config.defaultSpring,
-                segmentHandlers = segmentHandlers,
-            )
+            }
         }
     }
 
-    @Composable
-    override fun rememberDefaultConfig(): Config {
-        val defaultSpring = defaultSpatialSpring()
-        return remember(defaultSpring) { Config(defaultSpring) }
-    }
+    @Composable override fun rememberDefaultConfig() {}
 
     override val visualizationInputRange: ClosedFloatingPointRange<Float>
         get() = inputRange
 
-    @Composable
-    override fun ColumnScope.ConfigUi(config: Config, onConfigChanged: (Config) -> Unit) {}
+    @Composable override fun ColumnScope.ConfigUi(config: Unit, onConfigChanged: (Unit) -> Unit) {}
 
     override val identifier: String = "DirectionSpecDemo"
 }
diff --git a/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/GuaranteeBoxDemo.kt b/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/GuaranteeBoxDemo.kt
index ffbdb93b4..44a0d6ce0 100644
--- a/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/GuaranteeBoxDemo.kt
+++ b/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/GuaranteeBoxDemo.kt
@@ -55,7 +55,6 @@ import androidx.compose.ui.unit.dp
 import com.android.compose.modifiers.height
 import com.android.compose.modifiers.width
 import com.android.mechanics.debug.DebugMotionValueVisualization
-import com.android.mechanics.demo.staging.defaultSpatialSpring
 import com.android.mechanics.demo.staging.rememberDistanceGestureContext
 import com.android.mechanics.demo.staging.rememberMotionValue
 import com.android.mechanics.demo.tuneable.Demo
@@ -65,7 +64,8 @@ import com.android.mechanics.demo.tuneable.SpringParameterSection
 import com.android.mechanics.spec.Guarantee
 import com.android.mechanics.spec.Mapping
 import com.android.mechanics.spec.MotionSpec
-import com.android.mechanics.spec.builder
+import com.android.mechanics.spec.builder.rememberMotionBuilderContext
+import com.android.mechanics.spec.builder.spatialDirectionalMotionSpec
 import com.android.mechanics.spring.SpringParameters
 import kotlin.math.min
 
@@ -213,39 +213,52 @@ object GuaranteeBoxDemo : Demo<GuaranteeBoxDemo.Config> {
         config: Config,
     ): MotionSpec {
 
-        val density = LocalDensity.current
+        val builderContext = rememberMotionBuilderContext()
         val left = x()
         val widthVal = width()
         val right = left + widthVal
 
-        return remember(scenario, inputOutputRange, config, left, widthVal, density) {
-            with(density) {
+        return remember(scenario, inputOutputRange, config, left, widthVal, builderContext) {
+            with(builderContext) {
                 val guarantee = Guarantee.InputDelta(config.guaranteeDistance.toPx())
                 val minSize = config.minVisibleWidth.toPx()
                 when (scenario) {
                     Scenario.Mapped ->
-                        MotionSpec.builder(config.defaultSpring, initialMapping = Mapping.Zero)
-                            .toBreakpoint(left)
-                            .jumpTo(0f)
-                            .continueWithTargetValue(widthVal)
-                            .toBreakpoint(right)
-                            .completeWith(Mapping.Fixed(widthVal))
+                        MotionSpec(
+                            spatialDirectionalMotionSpec(initialMapping = Mapping.Zero) {
+                                target(breakpoint = left, from = 0f, to = widthVal)
+                                fixedValue(breakpoint = right, value = widthVal)
+                            }
+                        )
 
                     Scenario.Triggered ->
-                        MotionSpec.builder(config.defaultSpring, initialMapping = Mapping.Zero)
-                            .toBreakpoint(min(left + minSize, right))
-                            .jumpTo(minSize)
-                            .continueWithTargetValue(widthVal - minSize)
-                            .toBreakpoint(right)
-                            .completeWith(Mapping.Fixed(widthVal))
+                        MotionSpec(
+                            spatialDirectionalMotionSpec(initialMapping = Mapping.Zero) {
+                                target(
+                                    breakpoint = min(left + minSize, right),
+                                    from = minSize,
+                                    to = widthVal - minSize,
+                                )
+                                fixedValue(breakpoint = right, value = widthVal)
+                            }
+                        )
 
                     Scenario.Guaranteed ->
-                        MotionSpec.builder(config.defaultSpring, initialMapping = Mapping.Zero)
-                            .toBreakpoint(min(left + minSize, right))
-                            .jumpTo(minSize, guarantee = guarantee)
-                            .continueWithTargetValue(widthVal - minSize)
-                            .toBreakpoint(right)
-                            .completeWith(Mapping.Fixed(widthVal), guarantee = guarantee)
+                        MotionSpec(
+                            spatialDirectionalMotionSpec(initialMapping = Mapping.Zero) {
+                                target(
+                                    breakpoint = min(left + minSize, right),
+                                    from = minSize,
+                                    to = widthVal - minSize,
+                                    guarantee = guarantee,
+                                )
+                                fixedValue(
+                                    breakpoint = right,
+                                    value = widthVal,
+                                    guarantee = guarantee,
+                                )
+                            }
+                        )
                 }
             }
         }
@@ -253,7 +266,7 @@ object GuaranteeBoxDemo : Demo<GuaranteeBoxDemo.Config> {
 
     @Composable
     override fun rememberDefaultConfig(): Config {
-        val defaultSpring = defaultSpatialSpring()
+        val defaultSpring = rememberMotionBuilderContext().spatial.default
         return remember(defaultSpring) {
             Config(
                 defaultSpring,
diff --git a/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/GuaranteeFadeDemo.kt b/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/GuaranteeFadeDemo.kt
index 4e0423a9d..b5658535e 100644
--- a/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/GuaranteeFadeDemo.kt
+++ b/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/GuaranteeFadeDemo.kt
@@ -45,31 +45,20 @@ import androidx.compose.ui.platform.LocalDensity
 import androidx.compose.ui.unit.dp
 import com.android.mechanics.debug.DebugMotionValueVisualization
 import com.android.mechanics.debug.debugMotionValueGraph
-import com.android.mechanics.demo.staging.defaultSpatialSpring
 import com.android.mechanics.demo.staging.rememberDistanceGestureContext
 import com.android.mechanics.demo.staging.rememberMotionValue
 import com.android.mechanics.demo.tuneable.Demo
-import com.android.mechanics.spec.Breakpoint
-import com.android.mechanics.spec.BreakpointKey
 import com.android.mechanics.spec.Guarantee
-import com.android.mechanics.spec.Mapping
 import com.android.mechanics.spec.MotionSpec
-import com.android.mechanics.spec.builder
-import com.android.mechanics.spring.SpringParameters
-
-object GuaranteeFadeDemo : Demo<GuaranteeFadeDemo.Config> {
-    object Keys {
-        val Start = BreakpointKey("Start")
-        val Detach = BreakpointKey("Detach")
-        val End = Breakpoint.maxLimit.key
-    }
+import com.android.mechanics.spec.builder.effectsDirectionalMotionSpec
+import com.android.mechanics.spec.builder.rememberMotionBuilderContext
 
-    data class Config(val defaultSpring: SpringParameters)
+object GuaranteeFadeDemo : Demo<Unit> {
 
     var inputRange by mutableStateOf(0f..200f)
 
     @Composable
-    override fun DemoUi(config: Config, modifier: Modifier) {
+    override fun DemoUi(config: Unit, modifier: Modifier) {
         val colors = MaterialTheme.colorScheme
 
         val density = LocalDensity.current
@@ -78,9 +67,9 @@ object GuaranteeFadeDemo : Demo<GuaranteeFadeDemo.Config> {
 
         // Also using GestureContext.dragOffset as input.
         val gestureContext = rememberDistanceGestureContext()
-        val spec = rememberSpec(inputOutputRange = inputRange, config, { 0f })
+        val spec = rememberSpec(inputOutputRange = inputRange, { 0f })
         val guaranteeSpec =
-            rememberSpec(inputOutputRange = inputRange, config, guaranteeDistance::floatValue)
+            rememberSpec(inputOutputRange = inputRange, guaranteeDistance::floatValue)
 
         val withoutGuarantee =
             rememberMotionValue(gestureContext::dragOffset, { spec }, gestureContext)
@@ -150,30 +139,34 @@ object GuaranteeFadeDemo : Demo<GuaranteeFadeDemo.Config> {
     @Composable
     fun rememberSpec(
         inputOutputRange: ClosedFloatingPointRange<Float>,
-        config: Config,
         guaranteeDistance: () -> Float,
     ): MotionSpec {
         val distance = guaranteeDistance()
         val guarantee = if (distance > 0) Guarantee.InputDelta(distance) else Guarantee.None
-
-        return remember(guarantee, config, inputOutputRange) {
-            MotionSpec.builder(config.defaultSpring, initialMapping = Mapping.Zero)
-                .toBreakpoint((inputOutputRange.start + inputOutputRange.endInclusive) / 2f)
-                .completeWith(Mapping.One, guarantee = guarantee)
+        val builderContext = rememberMotionBuilderContext()
+
+        return remember(guarantee, inputOutputRange, builderContext) {
+            with(builderContext) {
+                MotionSpec(
+                    effectsDirectionalMotionSpec {
+                        fixedValue(
+                            breakpoint =
+                                (inputOutputRange.start + inputOutputRange.endInclusive) / 2f,
+                            value = 1f,
+                            guarantee = guarantee,
+                        )
+                    }
+                )
+            }
         }
     }
 
-    @Composable
-    override fun rememberDefaultConfig(): Config {
-        val defaultSpring = defaultSpatialSpring()
-        return remember(defaultSpring) { Config(defaultSpring) }
-    }
+    @Composable override fun rememberDefaultConfig() {}
 
     override val visualizationInputRange: ClosedFloatingPointRange<Float>
         get() = inputRange
 
-    @Composable
-    override fun ColumnScope.ConfigUi(config: Config, onConfigChanged: (Config) -> Unit) {}
+    @Composable override fun ColumnScope.ConfigUi(config: Unit, onConfigChanged: (Unit) -> Unit) {}
 
     override val identifier: String = "GuaranteeFadeDemo"
 }
diff --git a/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/MagneticDetachDemo.kt b/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/MagneticDetachDemo.kt
new file mode 100644
index 000000000..8d3f5e37a
--- /dev/null
+++ b/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/MagneticDetachDemo.kt
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+@file:OptIn(ExperimentalAnimatableApi::class)
+
+package com.android.mechanics.demo.presentation
+
+import androidx.compose.animation.core.ExperimentalAnimatableApi
+import androidx.compose.foundation.background
+import androidx.compose.foundation.gestures.DraggableState
+import androidx.compose.foundation.gestures.Orientation
+import androidx.compose.foundation.gestures.draggable
+import androidx.compose.foundation.layout.Arrangement
+import androidx.compose.foundation.layout.Box
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.ColumnScope
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.height
+import androidx.compose.foundation.layout.offset
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.layout.size
+import androidx.compose.foundation.shape.RoundedCornerShape
+import androidx.compose.material3.MaterialTheme
+import androidx.compose.material3.Slider
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.getValue
+import androidx.compose.runtime.mutableStateOf
+import androidx.compose.runtime.remember
+import androidx.compose.runtime.setValue
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.draw.clip
+import androidx.compose.ui.draw.drawBehind
+import androidx.compose.ui.geometry.Offset
+import androidx.compose.ui.graphics.PathEffect
+import androidx.compose.ui.layout.onPlaced
+import androidx.compose.ui.unit.IntOffset
+import androidx.compose.ui.unit.dp
+import com.android.mechanics.debug.DebugMotionValueVisualization
+import com.android.mechanics.debug.debugMotionValue
+import com.android.mechanics.demo.staging.rememberDistanceGestureContext
+import com.android.mechanics.demo.staging.rememberMotionValue
+import com.android.mechanics.demo.tuneable.Demo
+import com.android.mechanics.effects.MagneticDetach
+import com.android.mechanics.spec.builder.rememberMotionBuilderContext
+import com.android.mechanics.spec.builder.spatialMotionSpec
+
+object MagneticDetachDemo : Demo<Unit> {
+    var inputRange by mutableStateOf(0f..0f)
+
+    @Composable
+    override fun DemoUi(config: Unit, modifier: Modifier) {
+        val colors = MaterialTheme.colorScheme
+
+        val gestureContext = rememberDistanceGestureContext()
+        val motionBuilderContext = rememberMotionBuilderContext()
+        val spec =
+            remember(motionBuilderContext) {
+                motionBuilderContext.spatialMotionSpec { after(50.dp.toPx(), MagneticDetach()) }
+            }
+        val motionValue = rememberMotionValue(gestureContext::dragOffset, { spec }, gestureContext)
+
+        Column(
+            verticalArrangement = Arrangement.spacedBy(24.dp),
+            modifier = modifier.fillMaxWidth().padding(vertical = 24.dp, horizontal = 96.dp),
+        ) {
+
+            // Output visualization
+            val lineColor = colors.primary
+            Box(
+                contentAlignment = Alignment.CenterStart,
+                modifier =
+                    Modifier.fillMaxWidth()
+                        .onPlaced { inputRange = 0f..it.size.width.toFloat() }
+                        .drawBehind {
+                            drawLine(
+                                lineColor,
+                                start = Offset(x = 0f, y = center.y),
+                                end = Offset(x = size.width, y = center.y),
+                                pathEffect =
+                                    PathEffect.dashPathEffect(
+                                        floatArrayOf(4.dp.toPx(), 4.dp.toPx())
+                                    ),
+                            )
+                        },
+            ) {
+                Box(
+                    modifier =
+                        Modifier.size(48.dp)
+                            .offset {
+                                val halfSize = 48.dp.toPx() / 2f
+                                val xOffset = (-halfSize + motionValue.output).toInt()
+                                IntOffset(x = xOffset, y = 0)
+                            }
+                            .draggable(
+                                remember { DraggableState { gestureContext.dragOffset += it } },
+                                Orientation.Horizontal,
+                            )
+                            .debugMotionValue(motionValue)
+                            .clip(remember { RoundedCornerShape(16.dp) })
+                            .background(colors.primary)
+                )
+            }
+
+            // MotionValue visualization
+            DebugMotionValueVisualization(
+                motionValue,
+                inputRange,
+                modifier = Modifier.fillMaxWidth().height(64.dp),
+            )
+
+            // Input visualization
+            Slider(
+                value = gestureContext.dragOffset,
+                valueRange = inputRange,
+                onValueChange = { gestureContext.dragOffset = it },
+                modifier = Modifier.fillMaxWidth(),
+            )
+        }
+    }
+
+    @Composable override fun rememberDefaultConfig() {}
+
+    override val visualizationInputRange: ClosedFloatingPointRange<Float>
+        get() = inputRange
+
+    @Composable override fun ColumnScope.ConfigUi(config: Unit, onConfigChanged: (Unit) -> Unit) {}
+
+    override val identifier: String = "MagneticDetach"
+}
diff --git a/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/MagneticDetachWithOverdragDemo.kt b/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/MagneticDetachWithOverdragDemo.kt
new file mode 100644
index 000000000..53f5dca95
--- /dev/null
+++ b/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/MagneticDetachWithOverdragDemo.kt
@@ -0,0 +1,148 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+@file:OptIn(ExperimentalAnimatableApi::class)
+
+package com.android.mechanics.demo.presentation
+
+import androidx.compose.animation.core.ExperimentalAnimatableApi
+import androidx.compose.foundation.background
+import androidx.compose.foundation.gestures.Orientation
+import androidx.compose.foundation.gestures.draggable
+import androidx.compose.foundation.gestures.rememberDraggableState
+import androidx.compose.foundation.layout.Arrangement
+import androidx.compose.foundation.layout.Box
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.ColumnScope
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.offset
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.layout.size
+import androidx.compose.foundation.shape.RoundedCornerShape
+import androidx.compose.material3.MaterialTheme
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.getValue
+import androidx.compose.runtime.mutableStateOf
+import androidx.compose.runtime.remember
+import androidx.compose.runtime.setValue
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.draw.clip
+import androidx.compose.ui.draw.drawBehind
+import androidx.compose.ui.geometry.Offset
+import androidx.compose.ui.graphics.PathEffect
+import androidx.compose.ui.layout.onPlaced
+import androidx.compose.ui.unit.IntOffset
+import androidx.compose.ui.unit.dp
+import com.android.mechanics.debug.debugMotionValue
+import com.android.mechanics.demo.presentation.MagneticDetachWithOverdragDemo.TargetValue
+import com.android.mechanics.demo.presentation.MagneticDetachWithOverdragDemo.inputRange
+import com.android.mechanics.demo.staging.rememberDistanceGestureContext
+import com.android.mechanics.demo.staging.rememberMotionValue
+import com.android.mechanics.demo.tuneable.Demo
+import com.android.mechanics.effects.MagneticDetach
+import com.android.mechanics.effects.Overdrag
+import com.android.mechanics.spec.InputDirection
+import com.android.mechanics.spec.SemanticKey
+import com.android.mechanics.spec.builder.MotionBuilderContext
+import com.android.mechanics.spec.builder.fixedSpatialValueSpec
+import com.android.mechanics.spec.builder.rememberMotionBuilderContext
+import com.android.mechanics.spec.builder.spatialMotionSpec
+
+object MagneticDetachWithOverdragDemo : Demo<Unit> {
+
+    var inputRange by mutableStateOf(0f..0f)
+
+    @Composable
+    override fun DemoUi(config: Unit, modifier: Modifier) {
+        val colors = MaterialTheme.colorScheme
+        val gestureContext = rememberDistanceGestureContext()
+        val motionBuilderContext = rememberMotionBuilderContext()
+        var spec by remember() { mutableStateOf(motionBuilderContext.fixedSpatialValueSpec(0f)) }
+
+        val motionValue = rememberMotionValue(gestureContext::dragOffset, { spec }, gestureContext)
+
+        Column(
+            verticalArrangement = Arrangement.spacedBy(24.dp),
+            modifier = modifier.fillMaxWidth().padding(vertical = 24.dp, horizontal = 48.dp),
+        ) {
+
+            // Output visualization
+            val lineColor = colors.primary
+            Box(
+                contentAlignment = Alignment.CenterStart,
+                modifier =
+                    Modifier.fillMaxWidth()
+                        .onPlaced { inputRange = 0f..it.size.width.toFloat() }
+                        .drawBehind {
+                            drawLine(
+                                lineColor,
+                                start = Offset(x = 0f, y = center.y),
+                                end = Offset(x = size.width, y = center.y),
+                                pathEffect =
+                                    PathEffect.dashPathEffect(
+                                        floatArrayOf(4.dp.toPx(), 4.dp.toPx())
+                                    ),
+                            )
+                        },
+            ) {
+                Box(
+                    modifier =
+                        Modifier.size(48.dp)
+                            .offset {
+                                val halfSize = 48.dp.toPx() / 2f
+                                val xOffset = (-halfSize + motionValue.output).toInt()
+                                IntOffset(x = xOffset, y = 0)
+                            }
+                            .draggable(
+                                rememberDraggableState { gestureContext.dragOffset += it },
+                                Orientation.Horizontal,
+                                onDragStarted = {
+                                    gestureContext.reset(motionValue.output, InputDirection.Max)
+                                    spec = motionBuilderContext.createDragSpec()
+                                },
+                                onDragStopped = {
+                                    val targetValue = motionValue[TargetValue] ?: motionValue.output
+                                    spec = motionBuilderContext.fixedSpatialValueSpec(targetValue)
+                                },
+                            )
+                            .debugMotionValue(motionValue)
+                            .clip(remember { RoundedCornerShape(16.dp) })
+                            .background(colors.primary)
+                )
+            }
+        }
+    }
+
+    @Composable override fun rememberDefaultConfig() {}
+
+    override val visualizationInputRange: ClosedFloatingPointRange<Float>
+        get() = inputRange
+
+    @Composable override fun ColumnScope.ConfigUi(config: Unit, onConfigChanged: (Unit) -> Unit) {}
+
+    override val identifier: String = "MagneticDetachOverdrag"
+
+    val TargetValue = SemanticKey<Float?>()
+}
+
+private fun MotionBuilderContext.createDragSpec() = spatialMotionSpec {
+    before(inputRange.start, Overdrag(overdragLimit = TargetValue))
+    after(inputRange.start, MagneticDetach(semanticAttachedValue = TargetValue))
+
+    before(inputRange.endInclusive, MagneticDetach(semanticAttachedValue = TargetValue))
+    after(inputRange.endInclusive, Overdrag(overdragLimit = TargetValue))
+}
diff --git a/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/PracticalDemoAppear.kt b/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/PracticalDemoAppear.kt
deleted file mode 100644
index 57de1e4aa..000000000
--- a/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/PracticalDemoAppear.kt
+++ /dev/null
@@ -1,190 +0,0 @@
-/*
- * Copyright (C) 2025 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-@file:OptIn(ExperimentalAnimatableApi::class)
-
-package com.android.mechanics.demo.presentation
-
-import androidx.compose.animation.core.ExperimentalAnimatableApi
-import androidx.compose.foundation.background
-import androidx.compose.foundation.layout.Arrangement
-import androidx.compose.foundation.layout.Column
-import androidx.compose.foundation.layout.ColumnScope
-import androidx.compose.foundation.layout.Row
-import androidx.compose.foundation.layout.Spacer
-import androidx.compose.foundation.layout.fillMaxWidth
-import androidx.compose.foundation.layout.height
-import androidx.compose.foundation.layout.padding
-import androidx.compose.foundation.rememberScrollState
-import androidx.compose.foundation.verticalScroll
-import androidx.compose.material.icons.Icons
-import androidx.compose.material.icons.filled.AllInclusive
-import androidx.compose.material3.ExperimentalMaterial3ExpressiveApi
-import androidx.compose.material3.Icon
-import androidx.compose.material3.LocalContentColor
-import androidx.compose.material3.MaterialTheme
-import androidx.compose.material3.MaterialTheme.typography
-import androidx.compose.material3.Text
-import androidx.compose.runtime.Composable
-import androidx.compose.runtime.CompositionLocalProvider
-import androidx.compose.runtime.getValue
-import androidx.compose.runtime.mutableStateOf
-import androidx.compose.runtime.remember
-import androidx.compose.runtime.setValue
-import androidx.compose.ui.Modifier
-import androidx.compose.ui.unit.Dp
-import androidx.compose.ui.unit.dp
-import com.android.compose.animation.scene.ElementKey
-import com.android.compose.modifiers.thenIf
-import com.android.mechanics.demo.staging.behavior.reveal.FadeContentRevealSpec
-import com.android.mechanics.demo.staging.behavior.reveal.fadeReveal
-import com.android.mechanics.demo.staging.behavior.reveal.rememberFadeContentRevealSpec
-import com.android.mechanics.demo.staging.behavior.reveal.revealContainer
-import com.android.mechanics.demo.tuneable.Demo
-import com.android.mechanics.demo.tuneable.DpSlider
-import com.android.mechanics.demo.tuneable.GuaranteeSection
-import com.android.mechanics.demo.tuneable.LabelledCheckbox
-import com.android.mechanics.demo.tuneable.Section
-import com.android.mechanics.demo.tuneable.SpringParameterSection
-import com.android.mechanics.demo.util.ExpandableCard
-
-object PracticalDemoAppear : Demo<PracticalDemoAppear.Config> {
-    object Elements {
-        val ExpandableContent = ElementKey("ExpandableContent")
-    }
-
-    data class Config(val fadeSpec: FadeContentRevealSpec, val showItemBackground: Boolean)
-
-    @Composable
-    override fun DemoUi(config: Config, modifier: Modifier) {
-        val colors = MaterialTheme.colorScheme
-        ExpandableCard(
-            modifier = modifier.fillMaxWidth(),
-            header = { Text(text = "Contents", style = typography.titleMedium) },
-        ) { isExpanded ->
-            Column(
-                verticalArrangement = Arrangement.spacedBy(8.dp),
-                modifier =
-                    Modifier.fillMaxWidth()
-                        .element(Elements.ExpandableContent)
-                        .revealContainer(this@ExpandableCard)
-                        .verticalScroll(rememberScrollState())
-                        .padding(start = 16.dp, end = 16.dp, bottom = 16.dp),
-            ) {
-                if (isExpanded) {
-                    Spacer(modifier = Modifier.height(24.dp))
-                    repeat(10) {
-                        Row(
-                            horizontalArrangement = Arrangement.spacedBy(8.dp),
-                            modifier =
-                                Modifier.noResizeDuringTransitions()
-                                    .fadeReveal(spec = config.fadeSpec, debug = true)
-                                    .fillMaxWidth()
-                                    .thenIf(config.showItemBackground) {
-                                        Modifier.background(colors.primary)
-                                    },
-                        ) {
-                            CompositionLocalProvider(
-                                LocalContentColor provides
-                                    if (config.showItemBackground) colors.onPrimary
-                                    else colors.onSurface
-                            ) {
-                                Icon(Icons.Default.AllInclusive, null)
-                                Text(text = "Item ${it + 1}", modifier = Modifier.height(20.dp))
-                            }
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    @OptIn(ExperimentalMaterial3ExpressiveApi::class)
-    @Composable
-    override fun rememberDefaultConfig(): Config {
-        val fadeRevealSpec = rememberFadeContentRevealSpec(showDelta = 8.dp, hideDelta = 16.dp)
-        return remember(fadeRevealSpec) { Config(fadeRevealSpec, showItemBackground = false) }
-    }
-
-    override var visualizationInputRange by mutableStateOf(0f..1000f)
-    override val collapsedGraphHeight: Dp = 20.dp
-
-    @Composable
-    override fun ColumnScope.ConfigUi(config: Config, onConfigChanged: (Config) -> Unit) {
-        LabelledCheckbox(
-            "Show item background",
-            config.showItemBackground,
-            onCheckedChange = { onConfigChanged(config.copy(showItemBackground = it)) },
-            modifier = Modifier.fillMaxWidth(),
-        )
-
-        Section(
-            "Show",
-            summary = { "" },
-            value = config.fadeSpec,
-            onValueChanged = { onConfigChanged(config.copy(fadeSpec = it)) },
-            sectionKey = "show spec",
-            modifier = Modifier.fillMaxWidth(),
-        ) { spec, onSpecChanged ->
-            SpringParameterSection(
-                " Spring",
-                spec.showSpring,
-                onValueChanged = { onSpecChanged(spec.copy(showSpring = it)) },
-                "showspring",
-                modifier = Modifier.fillMaxWidth(),
-            )
-            GuaranteeSection(
-                " Guarantee",
-                spec.showGuarantee,
-                { onSpecChanged(spec.copy(showGuarantee = it)) },
-                "showguarantee",
-                modifier = Modifier.fillMaxWidth(),
-            )
-
-            Text(text = "Delta", modifier = Modifier.padding(start = 8.dp))
-            DpSlider(spec.showDelta, { onSpecChanged(spec.copy(showDelta = it)) }, 0.dp..24.dp)
-        }
-
-        Section(
-            "Hide",
-            summary = { "" },
-            value = config.fadeSpec,
-            onValueChanged = { onConfigChanged(config.copy(fadeSpec = it)) },
-            sectionKey = "show spec",
-            modifier = Modifier.fillMaxWidth(),
-        ) { spec, onSpecChanged ->
-            SpringParameterSection(
-                "Spring",
-                spec.hideSpring,
-                onValueChanged = { onSpecChanged(spec.copy(hideSpring = it)) },
-                "hidespring",
-                modifier = Modifier.fillMaxWidth(),
-            )
-            GuaranteeSection(
-                "Guarantee",
-                spec.hideGuarantee,
-                { onSpecChanged(spec.copy(hideGuarantee = it)) },
-                "hideguarantee",
-                modifier = Modifier.fillMaxWidth(),
-            )
-
-            Text(text = "Delta", modifier = Modifier.padding(start = 8.dp))
-            DpSlider(spec.hideDelta, { onSpecChanged(spec.copy(hideDelta = it)) }, 0.dp..24.dp)
-        }
-    }
-
-    override val identifier: String = "PracticalDemoAppear"
-}
diff --git a/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/PracticalDemoDetach.kt b/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/PracticalDemoDetach.kt
deleted file mode 100644
index d110f7618..000000000
--- a/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/PracticalDemoDetach.kt
+++ /dev/null
@@ -1,204 +0,0 @@
-/*
- * Copyright (C) 2025 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-@file:OptIn(ExperimentalAnimatableApi::class)
-
-package com.android.mechanics.demo.presentation
-
-import androidx.compose.animation.core.ExperimentalAnimatableApi
-import androidx.compose.animation.core.tween
-import androidx.compose.foundation.background
-import androidx.compose.foundation.layout.Arrangement
-import androidx.compose.foundation.layout.Column
-import androidx.compose.foundation.layout.ColumnScope
-import androidx.compose.foundation.layout.Row
-import androidx.compose.foundation.layout.Spacer
-import androidx.compose.foundation.layout.fillMaxWidth
-import androidx.compose.foundation.layout.height
-import androidx.compose.foundation.layout.padding
-import androidx.compose.foundation.rememberScrollState
-import androidx.compose.foundation.verticalScroll
-import androidx.compose.material.icons.Icons
-import androidx.compose.material.icons.filled.AllInclusive
-import androidx.compose.material3.ExperimentalMaterial3ExpressiveApi
-import androidx.compose.material3.Icon
-import androidx.compose.material3.LocalContentColor
-import androidx.compose.material3.MaterialTheme
-import androidx.compose.material3.MaterialTheme.typography
-import androidx.compose.material3.Text
-import androidx.compose.runtime.Composable
-import androidx.compose.runtime.CompositionLocalProvider
-import androidx.compose.runtime.getValue
-import androidx.compose.runtime.mutableStateOf
-import androidx.compose.runtime.remember
-import androidx.compose.runtime.setValue
-import androidx.compose.ui.Modifier
-import androidx.compose.ui.unit.Dp
-import androidx.compose.ui.unit.dp
-import com.android.compose.animation.scene.ElementKey
-import com.android.compose.animation.scene.transitions
-import com.android.compose.modifiers.thenIf
-import com.android.mechanics.demo.staging.behavior.magneticDetach
-import com.android.mechanics.demo.staging.behavior.reveal.FadeContentRevealSpec
-import com.android.mechanics.demo.staging.behavior.reveal.fadeReveal
-import com.android.mechanics.demo.staging.behavior.reveal.rememberFadeContentRevealSpec
-import com.android.mechanics.demo.staging.behavior.reveal.revealContainer
-import com.android.mechanics.demo.tuneable.Demo
-import com.android.mechanics.demo.tuneable.DpSlider
-import com.android.mechanics.demo.tuneable.GuaranteeSection
-import com.android.mechanics.demo.tuneable.LabelledCheckbox
-import com.android.mechanics.demo.tuneable.Section
-import com.android.mechanics.demo.tuneable.SpringParameterSection
-import com.android.mechanics.demo.util.ExpandableCard
-import com.android.mechanics.demo.util.Scenes
-import com.android.mechanics.demo.util.Transitions.ExpandedCollapsedDistance
-
-object PracticalDemoDetach : Demo<PracticalDemoDetach.Config> {
-    object Elements {
-        val ExpandableContent = ElementKey("ExpandableContent")
-    }
-
-    data class Config(val fadeSpec: FadeContentRevealSpec, val showItemBackground: Boolean)
-
-    @Composable
-    override fun DemoUi(config: Config, modifier: Modifier) {
-        val colors = MaterialTheme.colorScheme
-        ExpandableCard(
-            transitions =
-                transitions {
-                    from(Scenes.Expanded, Scenes.Collapsed) {
-                        spec = tween(500)
-                        distance = ExpandedCollapsedDistance
-
-                        magneticDetach(Elements.ExpandableContent)
-                    }
-                },
-            modifier = modifier.fillMaxWidth(),
-            header = { Text(text = "Contents", style = typography.titleMedium) },
-        ) { isExpanded ->
-            Column(
-                verticalArrangement = Arrangement.spacedBy(8.dp),
-                modifier =
-                    Modifier.fillMaxWidth()
-                        .element(Elements.ExpandableContent)
-                        .revealContainer(this@ExpandableCard)
-                        .verticalScroll(rememberScrollState())
-                        .padding(start = 16.dp, end = 16.dp, bottom = 16.dp),
-            ) {
-                if (isExpanded) {
-                    Spacer(modifier = Modifier.height(24.dp))
-                    repeat(10) {
-                        Row(
-                            horizontalArrangement = Arrangement.spacedBy(8.dp),
-                            modifier =
-                                Modifier.noResizeDuringTransitions()
-                                    .fadeReveal(spec = config.fadeSpec, debug = true)
-                                    .fillMaxWidth()
-                                    .thenIf(config.showItemBackground) {
-                                        Modifier.background(colors.primary)
-                                    },
-                        ) {
-                            CompositionLocalProvider(
-                                LocalContentColor provides
-                                    if (config.showItemBackground) colors.onPrimary
-                                    else colors.onSurface
-                            ) {
-                                Icon(Icons.Default.AllInclusive, null)
-                                Text(text = "Item ${it + 1}", modifier = Modifier.height(20.dp))
-                            }
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    @OptIn(ExperimentalMaterial3ExpressiveApi::class)
-    @Composable
-    override fun rememberDefaultConfig(): Config {
-        val fadeRevealSpec = rememberFadeContentRevealSpec(showDelta = 8.dp, hideDelta = 16.dp)
-        return remember(fadeRevealSpec) { Config(fadeRevealSpec, showItemBackground = false) }
-    }
-
-    override var visualizationInputRange by mutableStateOf(0f..1000f)
-    override val collapsedGraphHeight: Dp = 20.dp
-
-    @Composable
-    override fun ColumnScope.ConfigUi(config: Config, onConfigChanged: (Config) -> Unit) {
-        LabelledCheckbox(
-            "Show item background",
-            config.showItemBackground,
-            onCheckedChange = { onConfigChanged(config.copy(showItemBackground = it)) },
-            modifier = Modifier.fillMaxWidth(),
-        )
-
-        Section(
-            "Show",
-            summary = { "" },
-            value = config.fadeSpec,
-            onValueChanged = { onConfigChanged(config.copy(fadeSpec = it)) },
-            sectionKey = "show spec",
-            modifier = Modifier.fillMaxWidth(),
-        ) { spec, onSpecChanged ->
-            SpringParameterSection(
-                " Spring",
-                spec.showSpring,
-                onValueChanged = { onSpecChanged(spec.copy(showSpring = it)) },
-                "showspring",
-                modifier = Modifier.fillMaxWidth(),
-            )
-            GuaranteeSection(
-                " Guarantee",
-                spec.showGuarantee,
-                { onSpecChanged(spec.copy(showGuarantee = it)) },
-                "showguarantee",
-                modifier = Modifier.fillMaxWidth(),
-            )
-
-            Text(text = "Delta", modifier = Modifier.padding(start = 8.dp))
-            DpSlider(spec.showDelta, { onSpecChanged(spec.copy(showDelta = it)) }, 0.dp..24.dp)
-        }
-
-        Section(
-            "Hide",
-            summary = { "" },
-            value = config.fadeSpec,
-            onValueChanged = { onConfigChanged(config.copy(fadeSpec = it)) },
-            sectionKey = "show spec",
-            modifier = Modifier.fillMaxWidth(),
-        ) { spec, onSpecChanged ->
-            SpringParameterSection(
-                "Spring",
-                spec.hideSpring,
-                onValueChanged = { onSpecChanged(spec.copy(hideSpring = it)) },
-                "hidespring",
-                modifier = Modifier.fillMaxWidth(),
-            )
-            GuaranteeSection(
-                "Guarantee",
-                spec.hideGuarantee,
-                { onSpecChanged(spec.copy(hideGuarantee = it)) },
-                "hideguarantee",
-                modifier = Modifier.fillMaxWidth(),
-            )
-
-            Text(text = "Delta", modifier = Modifier.padding(start = 8.dp))
-            DpSlider(spec.hideDelta, { onSpecChanged(spec.copy(hideDelta = it)) }, 0.dp..24.dp)
-        }
-    }
-
-    override val identifier: String = "PracticalDemoDetach"
-}
diff --git a/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/PredefinedMotionDemo.kt b/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/PredefinedMotionDemo.kt
deleted file mode 100644
index 665e1aa3d..000000000
--- a/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/PredefinedMotionDemo.kt
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * Copyright (C) 2025 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-@file:OptIn(ExperimentalAnimatableApi::class)
-
-package com.android.mechanics.demo.presentation
-
-import androidx.compose.animation.core.ExperimentalAnimatableApi
-import androidx.compose.foundation.background
-import androidx.compose.foundation.layout.Arrangement
-import androidx.compose.foundation.layout.Column
-import androidx.compose.foundation.layout.ColumnScope
-import androidx.compose.foundation.layout.Row
-import androidx.compose.foundation.layout.Spacer
-import androidx.compose.foundation.layout.fillMaxWidth
-import androidx.compose.foundation.layout.height
-import androidx.compose.foundation.layout.padding
-import androidx.compose.foundation.rememberScrollState
-import androidx.compose.foundation.verticalScroll
-import androidx.compose.material.icons.Icons
-import androidx.compose.material.icons.filled.AllInclusive
-import androidx.compose.material3.ExperimentalMaterial3ExpressiveApi
-import androidx.compose.material3.Icon
-import androidx.compose.material3.LocalContentColor
-import androidx.compose.material3.MaterialTheme
-import androidx.compose.material3.MaterialTheme.typography
-import androidx.compose.material3.Text
-import androidx.compose.runtime.Composable
-import androidx.compose.runtime.CompositionLocalProvider
-import androidx.compose.runtime.getValue
-import androidx.compose.runtime.mutableStateOf
-import androidx.compose.runtime.remember
-import androidx.compose.runtime.setValue
-import androidx.compose.ui.Modifier
-import androidx.compose.ui.unit.Dp
-import androidx.compose.ui.unit.dp
-import com.android.compose.animation.scene.ElementKey
-import com.android.compose.modifiers.thenIf
-import com.android.mechanics.demo.staging.behavior.reveal.fadeReveal
-import com.android.mechanics.demo.staging.behavior.reveal.revealContainer
-import com.android.mechanics.demo.tuneable.Demo
-import com.android.mechanics.demo.tuneable.LabelledCheckbox
-import com.android.mechanics.demo.util.ExpandableCard
-
-object PredefinedMotionDemo : Demo<PredefinedMotionDemo.Config> {
-    object Elements {
-        val ExpandableContent = ElementKey("ExpandableContent")
-    }
-
-    data class Config(val showItemBackground: Boolean)
-
-    @Composable
-    override fun DemoUi(config: Config, modifier: Modifier) {
-        val colors = MaterialTheme.colorScheme
-        ExpandableCard(
-            modifier = modifier.fillMaxWidth(),
-            header = { Text(text = "Contents", style = typography.titleMedium) },
-        ) { isExpanded ->
-            Column(
-                verticalArrangement = Arrangement.spacedBy(8.dp),
-                modifier =
-                    Modifier.fillMaxWidth()
-                        .element(Elements.ExpandableContent)
-                        .revealContainer(this@ExpandableCard)
-                        .verticalScroll(rememberScrollState())
-                        .padding(start = 16.dp, end = 16.dp, bottom = 16.dp),
-            ) {
-                if (isExpanded) {
-                    Spacer(modifier = Modifier.height(24.dp))
-                    repeat(10) {
-                        Row(
-                            horizontalArrangement = Arrangement.spacedBy(8.dp),
-                            modifier =
-                                Modifier.noResizeDuringTransitions()
-                                    .fadeReveal(debug = true)
-                                    .fillMaxWidth()
-                                    .thenIf(config.showItemBackground) {
-                                        Modifier.background(colors.primary)
-                                    },
-                        ) {
-                            CompositionLocalProvider(
-                                LocalContentColor provides
-                                    if (config.showItemBackground) colors.onPrimary
-                                    else colors.onSurface
-                            ) {
-                                Icon(Icons.Default.AllInclusive, null)
-                                Text(text = "Item ${it + 1}", modifier = Modifier.height(20.dp))
-                            }
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    @OptIn(ExperimentalMaterial3ExpressiveApi::class)
-    @Composable
-    override fun rememberDefaultConfig(): Config {
-        return remember { Config(showItemBackground = false) }
-    }
-
-    override var visualizationInputRange by mutableStateOf(0f..1000f)
-    override val collapsedGraphHeight: Dp = 20.dp
-
-    @Composable
-    override fun ColumnScope.ConfigUi(config: Config, onConfigChanged: (Config) -> Unit) {
-        LabelledCheckbox(
-            "Show item background",
-            config.showItemBackground,
-            onCheckedChange = { onConfigChanged(config.copy(showItemBackground = it)) },
-            modifier = Modifier.fillMaxWidth(),
-        )
-    }
-
-    override val identifier: String = "predefined_motion"
-}
diff --git a/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/SpecDemo.kt b/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/SpecDemo.kt
index 2a429a0dc..4aa06ae1b 100644
--- a/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/SpecDemo.kt
+++ b/samples/MotionMechanics/src/com/android/mechanics/demo/presentation/SpecDemo.kt
@@ -18,8 +18,6 @@
 
 package com.android.mechanics.demo.presentation
 
-import android.util.Log
-import androidx.compose.animation.core.Easing
 import androidx.compose.animation.core.ExperimentalAnimatableApi
 import androidx.compose.foundation.background
 import androidx.compose.foundation.layout.Arrangement
@@ -50,18 +48,19 @@ import androidx.compose.ui.graphics.PathEffect
 import androidx.compose.ui.layout.onPlaced
 import androidx.compose.ui.unit.IntOffset
 import androidx.compose.ui.unit.dp
-import com.android.compose.animation.Easings
 import com.android.mechanics.debug.DebugMotionValueVisualization
 import com.android.mechanics.debug.debugMotionValue
-import com.android.mechanics.demo.staging.defaultSpatialSpring
 import com.android.mechanics.demo.staging.rememberDistanceGestureContext
 import com.android.mechanics.demo.staging.rememberMotionValue
 import com.android.mechanics.demo.tuneable.Demo
 import com.android.mechanics.demo.tuneable.Dropdown
+import com.android.mechanics.demo.tuneable.LabelledCheckbox
+import com.android.mechanics.spec.DirectionalMotionSpec
+import com.android.mechanics.spec.Guarantee
 import com.android.mechanics.spec.Mapping
 import com.android.mechanics.spec.MotionSpec
-import com.android.mechanics.spec.builder
-import com.android.mechanics.spring.SpringParameters
+import com.android.mechanics.spec.builder.rememberMotionBuilderContext
+import com.android.mechanics.spec.builder.spatialDirectionalMotionSpec
 
 object SpecDemo : Demo<SpecDemo.Config> {
     enum class Scenario(val label: String) {
@@ -69,10 +68,9 @@ object SpecDemo : Demo<SpecDemo.Config> {
         Toggle("Toggle"),
         Steps("Discrete Steps"),
         TrackNSnap("Track and Snap"),
-        EasingComparison("Easing Comparison"),
     }
 
-    data class Config(val defaultSpring: SpringParameters)
+    data class Config(val stepGuarantee: Boolean)
 
     var inputRange by mutableStateOf(0f..0f)
 
@@ -83,7 +81,7 @@ object SpecDemo : Demo<SpecDemo.Config> {
 
         // Also using GestureContext.dragOffset as input.
         val gestureContext = rememberDistanceGestureContext()
-        val spec = rememberSpec(activeScenario, inputOutputRange = inputRange, config)
+        val spec = rememberSpec(activeScenario, config, inputOutputRange = inputRange)
         val motionValue = rememberMotionValue(gestureContext::dragOffset, { spec }, gestureContext)
 
         Column(
@@ -157,116 +155,91 @@ object SpecDemo : Demo<SpecDemo.Config> {
     @Composable
     fun rememberSpec(
         scenario: Scenario,
-        inputOutputRange: ClosedFloatingPointRange<Float>,
         config: Config,
+        inputOutputRange: ClosedFloatingPointRange<Float>,
     ): MotionSpec {
 
-        return remember(scenario, inputOutputRange, config) {
-            when (scenario) {
-                Scenario.Empty -> MotionSpec.Empty
-                Scenario.Toggle -> {
-                    MotionSpec.builder(
-                            config.defaultSpring,
-                            initialMapping = Mapping.Fixed(inputOutputRange.start),
-                        )
-                        .toBreakpoint((inputOutputRange.start + inputOutputRange.endInclusive) / 2f)
-                        .completeWith(Mapping.Fixed(inputOutputRange.endInclusive))
-                }
-
-                Scenario.Steps -> {
-                    val steps = 8
-                    val stepSize = (inputOutputRange.start + inputOutputRange.endInclusive) / steps
-
-                    var underConstruction =
-                        MotionSpec.builder(
-                            config.defaultSpring,
-                            initialMapping = Mapping.Fixed(inputOutputRange.start),
-                        )
-                    repeat(steps - 1) { step ->
-                        underConstruction =
-                            underConstruction
-                                .toBreakpoint((step + 1) * stepSize)
-                                .continueWith(Mapping.Fixed((step + 1) * stepSize))
-                    }
-                    underConstruction.complete()
-                }
-
-                Scenario.TrackNSnap -> {
-                    val third = (inputOutputRange.start + inputOutputRange.endInclusive) / 3
-
-                    MotionSpec.builder(
-                            config.defaultSpring,
-                            initialMapping = Mapping.Fixed(inputOutputRange.start),
-                        )
-                        .toBreakpoint(third)
-                        .jumpTo(third)
-                        .continueWithTargetValue(2 * third)
-                        .toBreakpoint(2 * third)
-                        .completeWith(Mapping.Fixed(inputOutputRange.endInclusive))
-                }
-
-                Scenario.EasingComparison -> {
-                    val dOut = inputOutputRange.start + inputOutputRange.endInclusive
-
-                    val segmentSizes = buildList {
-                        val fourth = (dOut) / 4
-                        val sixth = (dOut) / 6
-                        repeat(2) {
-                            add(
-                                (inputOutputRange.start + (it * fourth))..(inputOutputRange.start +
-                                        (it + 1) * fourth)
+        val builderContext = rememberMotionBuilderContext()
+
+        return remember(scenario, inputOutputRange, config, builderContext) {
+            MotionSpec(
+                when (scenario) {
+                    Scenario.Empty -> DirectionalMotionSpec.Empty
+                    Scenario.Toggle ->
+                        builderContext.spatialDirectionalMotionSpec(
+                            Mapping.Fixed(inputOutputRange.start)
+                        ) {
+                            fixedValue(
+                                breakpoint =
+                                    (inputOutputRange.start + inputOutputRange.endInclusive) / 2f,
+                                value = inputOutputRange.endInclusive,
                             )
                         }
 
-                        repeat(3) {
-                            add(
-                                (inputOutputRange.start +
-                                    (it * sixth) +
-                                    dOut / 2)..(inputOutputRange.start +
-                                        (it + 1) * sixth +
-                                        dOut / 2)
+                    Scenario.Steps ->
+                        builderContext.spatialDirectionalMotionSpec(
+                            Mapping.Fixed(inputOutputRange.start)
+                        ) {
+                            val steps = 8
+                            val stepSize =
+                                (inputOutputRange.start + inputOutputRange.endInclusive) / steps
+
+                            val guarantee =
+                                if (config.stepGuarantee) Guarantee.InputDelta(stepSize)
+                                else Guarantee.None
+
+                            val outDiff =
+                                (inputOutputRange.start + inputOutputRange.endInclusive) /
+                                    (steps - 1)
+                            repeat(steps - 2) { step ->
+                                fixedValue(
+                                    breakpoint = (step + 1) * stepSize,
+                                    value = (step + 1) * outDiff,
+                                    guarantee = guarantee,
+                                )
+                            }
+
+                            fixedValue(
+                                breakpoint = inputOutputRange.endInclusive - stepSize,
+                                value = inputOutputRange.endInclusive,
+                                guarantee = guarantee,
                             )
                         }
-                    }
 
-                    Log.d("MIKES", "rememberSpec() called $segmentSizes")
+                    Scenario.TrackNSnap ->
+                        builderContext.spatialDirectionalMotionSpec(
+                            Mapping.Fixed(inputOutputRange.start)
+                        ) {
+                            val third = (inputOutputRange.start + inputOutputRange.endInclusive) / 3
 
-                    fun easingMapping(easing: Easing, range: ClosedFloatingPointRange<Float>) =
-                        Mapping {
-                            val d = range.endInclusive - range.start
-                            easing.transform((it - range.start) / d) * (dOut) +
-                                inputOutputRange.start
+                            target(third, from = third, to = 2 * third)
+                            fixedValue(
+                                breakpoint = 2 * third,
+                                value = inputOutputRange.endInclusive,
+                            )
                         }
-
-                    MotionSpec.builder(config.defaultSpring, initialMapping = Mapping.Zero)
-                        .toBreakpoint(segmentSizes[0].start)
-                        .continueWith(easingMapping(Easings.Emphasized, segmentSizes[0]))
-                        .toBreakpoint(segmentSizes[1].start)
-                        .continueWith(
-                            easingMapping({ Easings.Emphasized.transform(1 - it) }, segmentSizes[1])
-                        )
-                        .toBreakpoint(segmentSizes[2].start)
-                        .continueWith(Mapping.Fixed(inputOutputRange.start))
-                        .toBreakpoint(segmentSizes[3].start)
-                        .continueWith(Mapping.Fixed(inputOutputRange.endInclusive))
-                        .toBreakpoint(segmentSizes[4].start)
-                        .completeWith(Mapping.Fixed(inputOutputRange.start))
                 }
-            }
+            )
         }
     }
 
     @Composable
     override fun rememberDefaultConfig(): Config {
-        val defaultSpring = defaultSpatialSpring()
-        return remember(defaultSpring) { Config(defaultSpring) }
+        return remember { Config(stepGuarantee = false) }
     }
 
     override val visualizationInputRange: ClosedFloatingPointRange<Float>
         get() = inputRange
 
     @Composable
-    override fun ColumnScope.ConfigUi(config: Config, onConfigChanged: (Config) -> Unit) {}
+    override fun ColumnScope.ConfigUi(config: Config, onConfigChanged: (Config) -> Unit) {
+        Text("Steps")
+        LabelledCheckbox(
+            "Use Guarantee",
+            config.stepGuarantee,
+            { onConfigChanged(config.copy(stepGuarantee = it)) },
+        )
+    }
 
     override val identifier: String = "SpecDemo"
 }
diff --git a/samples/MotionMechanics/src/com/android/mechanics/demo/staging/MaterialSprings.kt b/samples/MotionMechanics/src/com/android/mechanics/demo/staging/MaterialSprings.kt
deleted file mode 100644
index 0289101af..000000000
--- a/samples/MotionMechanics/src/com/android/mechanics/demo/staging/MaterialSprings.kt
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2025 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-@file:OptIn(ExperimentalMaterial3ExpressiveApi::class)
-
-package com.android.mechanics.demo.staging
-
-import androidx.compose.animation.core.FiniteAnimationSpec
-import androidx.compose.animation.core.SpringSpec
-import androidx.compose.material3.ExperimentalMaterial3ExpressiveApi
-import androidx.compose.material3.MaterialTheme
-import androidx.compose.runtime.Composable
-import com.android.mechanics.spring.SpringParameters
-
-// The [MaterialTheme.motionScheme] contains the material motion tokes, but they are not accessible
-// yet for MM Springs.
-
-/** Converts a [SpringSpec] into its [SpringParameters] equivalent. */
-fun SpringSpec<*>.asMechanics() = SpringParameters(stiffness, dampingRatio)
-
-/** Converts a [SpringSpec] into its [SpringParameters] equivalent. */
-fun FiniteAnimationSpec<*>.asMechanics() =
-    with(this as SpringSpec<*>) { SpringParameters(stiffness, dampingRatio) }
-
-private fun MechanicsSpringSpec(factory: () -> FiniteAnimationSpec<Any>) =
-    (factory() as SpringSpec<Any>).asMechanics()
-
-@Composable
-fun defaultSpatialSpring(): SpringParameters {
-    return (MaterialTheme.motionScheme.defaultSpatialSpec<Any>() as SpringSpec<Any>).asMechanics()
-}
-
-@Composable
-fun defaultEffectSpring(): SpringParameters {
-    return (MaterialTheme.motionScheme.defaultSpatialSpec<Any>() as SpringSpec<Any>).asMechanics()
-}
diff --git a/samples/MotionMechanics/src/com/android/mechanics/demo/staging/behavior/MagneticDetach.kt b/samples/MotionMechanics/src/com/android/mechanics/demo/staging/behavior/MagneticDetach.kt
deleted file mode 100644
index 852b92ce4..000000000
--- a/samples/MotionMechanics/src/com/android/mechanics/demo/staging/behavior/MagneticDetach.kt
+++ /dev/null
@@ -1,143 +0,0 @@
-/*
- * Copyright (C) 2025 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.mechanics.demo.staging.behavior
-
-import android.util.Log
-import androidx.compose.animation.core.ExperimentalAnimatableApi
-import androidx.compose.runtime.mutableFloatStateOf
-import androidx.compose.ui.unit.IntSize
-import androidx.compose.ui.unit.dp
-import androidx.compose.ui.unit.toSize
-import com.android.compose.animation.scene.ContentKey
-import com.android.compose.animation.scene.ElementKey
-import com.android.compose.animation.scene.TransitionBuilder
-import com.android.compose.animation.scene.UserActionDistance
-import com.android.compose.animation.scene.content.state.TransitionState
-import com.android.compose.animation.scene.transformation.CustomPropertyTransformation
-import com.android.compose.animation.scene.transformation.PropertyTransformation
-import com.android.compose.animation.scene.transformation.PropertyTransformationScope
-import com.android.mechanics.MotionValue
-import com.android.mechanics.ProvidedGestureContext
-import com.android.mechanics.spec.InputDirection
-import com.android.mechanics.spec.Mapping
-import com.android.mechanics.spec.MotionSpec
-import com.android.mechanics.spec.builder
-import com.android.mechanics.spring.SpringParameters
-import kotlinx.coroutines.CoroutineScope
-import kotlinx.coroutines.Job
-import kotlinx.coroutines.launch
-
-/** Animate the reveal of [container] by animating its size. */
-fun TransitionBuilder.magneticDetach(container: ElementKey) {
-    // Make the swipe distance be exactly the target height of the container.
-    // TODO(b/376438969): Make sure that this works correctly when the target size of the element
-    // is changing during the transition (e.g. a notification was added). At the moment, the user
-    // action distance is only called until it returns a value > 0f, which is then cached.
-    distance = UserActionDistance { fromContent, toContent, _ ->
-        val targetSizeInFromContent = container.targetSize(fromContent)
-        val targetSizeInToContent = container.targetSize(toContent)
-        if (targetSizeInFromContent != null && targetSizeInToContent != null) {
-            error(
-                "verticalContainerReveal should not be used with shared elements, but " +
-                    "${container.debugName} is in both ${fromContent.debugName} and " +
-                    toContent.debugName
-            )
-        }
-
-        (targetSizeInToContent?.height ?: targetSizeInFromContent?.height)?.toFloat() ?: 0f
-    }
-
-    Log.d("MIKES", "magneticDetach() called with: container = $container")
-
-    transformation(container) {
-        Log.d("MIKES", "magneticDetach() Created")
-        MagneticDetachTransformation()
-    }
-}
-
-@OptIn(ExperimentalAnimatableApi::class)
-private class MagneticDetachTransformation() : CustomPropertyTransformation<IntSize> {
-    override val property = PropertyTransformation.Property.Size
-
-    val input = mutableFloatStateOf(0f)
-
-    var heightValue: MotionValue? = null
-    var heightValueJob: Job? = null
-
-    override fun PropertyTransformationScope.transform(
-        content: ContentKey,
-        element: ElementKey,
-        transition: TransitionState.Transition,
-        transitionScope: CoroutineScope,
-    ): IntSize {
-        Log.d(
-            "MIKES",
-            "transform() called with: content = $content, element = $element, transition = $transition, transitionScope = $transitionScope",
-        )
-        val idleSize = checkNotNull(element.targetSize(content))
-
-        if (
-            heightValue?.isStable == true &&
-                transition.progress == 1f &&
-                !transition.isUserInputOngoing
-        ) {
-            Log.d("MIKES", "transform() KILL")
-            heightValue = null
-            heightValueJob?.cancel()
-            heightValueJob = null
-            return idleSize
-        }
-
-        val fromSize = checkNotNull(element.targetSize(transition.fromContent)).toSize()
-        val toSize = checkNotNull(element.targetSize(transition.toContent)).toSize()
-        val collapsedSize = if (fromSize.height < toSize.height) fromSize else toSize
-        val expandedHeight = if (fromSize.height >= toSize.height) fromSize else toSize
-
-        input.floatValue = (expandedHeight.height - collapsedSize.height) * transition.progress
-        Log.d("MIKES", "transform()UPD")
-
-        if (heightValue == null) {
-            Log.d("MIKES", "transform()START")
-            val springParameters = SpringParameters(stiffness = 380f, dampingRatio = 0.9f)
-
-            val detachDistance = 48.dp.toPx()
-
-            val spec =
-                MotionSpec.builder(
-                        springParameters,
-                        initialMapping = Mapping.Fixed(collapsedSize.height),
-                    )
-                    .toBreakpoint(0f)
-                    .jumpBy(0f)
-                    .continueWithFractionalInput(.2f)
-                    .toBreakpoint(detachDistance)
-                    .jumpTo(collapsedSize.height + detachDistance)
-                    .continueWithFractionalInput(1f)
-                    .complete()
-
-            heightValue =
-                MotionValue(
-                    input::floatValue,
-                    transition.gestureContext ?: ProvidedGestureContext(0f, InputDirection.Max),
-                    spec,
-                )
-            heightValueJob = transitionScope.launch { heightValue?.keepRunning() }
-        }
-
-        return IntSize(idleSize.width, height = heightValue!!.output.toInt())
-    }
-}
diff --git a/samples/MotionMechanics/src/com/android/mechanics/demo/staging/behavior/reveal/FadeReveal.kt b/samples/MotionMechanics/src/com/android/mechanics/demo/staging/behavior/reveal/FadeReveal.kt
deleted file mode 100644
index b4ddc7261..000000000
--- a/samples/MotionMechanics/src/com/android/mechanics/demo/staging/behavior/reveal/FadeReveal.kt
+++ /dev/null
@@ -1,245 +0,0 @@
-/*
- * Copyright (C) 2025 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.mechanics.demo.staging.behavior.reveal
-
-import android.util.Log
-import androidx.compose.runtime.Composable
-import androidx.compose.runtime.remember
-import androidx.compose.ui.Modifier
-import androidx.compose.ui.geometry.Rect
-import androidx.compose.ui.graphics.CompositingStrategy
-import androidx.compose.ui.layout.ApproachLayoutModifierNode
-import androidx.compose.ui.layout.ApproachMeasureScope
-import androidx.compose.ui.layout.LayoutCoordinates
-import androidx.compose.ui.layout.Measurable
-import androidx.compose.ui.layout.MeasureResult
-import androidx.compose.ui.layout.MeasureScope
-import androidx.compose.ui.layout.Placeable
-import androidx.compose.ui.node.ModifierNodeElement
-import androidx.compose.ui.node.findNearestAncestor
-import androidx.compose.ui.node.requireDensity
-import androidx.compose.ui.node.requireLayoutCoordinates
-import androidx.compose.ui.unit.Constraints
-import androidx.compose.ui.unit.Dp
-import androidx.compose.ui.unit.IntOffset
-import androidx.compose.ui.unit.IntSize
-import androidx.compose.ui.unit.dp
-import androidx.compose.ui.unit.toSize
-import com.android.mechanics.MotionValue
-import com.android.mechanics.debug.findMotionValueDebugger
-import com.android.mechanics.demo.staging.behavior.reveal.RevealContainerNode.Companion.TRAVERSAL_NODE_KEY
-import com.android.mechanics.demo.staging.defaultEffectSpring
-import com.android.mechanics.spec.DirectionalMotionSpec
-import com.android.mechanics.spec.Guarantee
-import com.android.mechanics.spec.Mapping
-import com.android.mechanics.spec.MotionSpec
-import com.android.mechanics.spec.builder
-import com.android.mechanics.spec.reverseBuilder
-import com.android.mechanics.spring.SpringParameters
-import kotlinx.coroutines.DisposableHandle
-import kotlinx.coroutines.launch
-
-@Composable
-fun rememberFadeContentRevealSpec(
-    showSpring: SpringParameters = defaultEffectSpring(),
-    hideSpring: SpringParameters = defaultEffectSpring(),
-    showDelta: Dp = 0.dp,
-    hideDelta: Dp = 0.dp,
-    showGuarantee: Guarantee = Guarantee.None,
-    hideGuarantee: Guarantee = Guarantee.None,
-): FadeContentRevealSpec {
-    return remember(showSpring, hideSpring, showGuarantee, hideGuarantee) {
-        FadeContentRevealSpec(
-            showSpring,
-            hideSpring,
-            showDelta,
-            hideDelta,
-            showGuarantee,
-            hideGuarantee,
-        )
-    }
-}
-
-@Composable
-fun Modifier.fadeReveal(
-    spec: FadeContentRevealSpec = rememberFadeContentRevealSpec(),
-    debug: Boolean = false,
-    label: String? = null,
-): Modifier = this.then(FadeContentRevealElement(spec, debug, label))
-
-data class FadeContentRevealSpec(
-    val showSpring: SpringParameters,
-    val hideSpring: SpringParameters,
-    val showDelta: Dp,
-    val hideDelta: Dp,
-    val showGuarantee: Guarantee,
-    val hideGuarantee: Guarantee,
-)
-
-internal class FadeContentRevealNode(
-    private var spec: FadeContentRevealSpec,
-    private val debug: Boolean,
-    private val label: String?,
-) : Modifier.Node(), ApproachLayoutModifierNode {
-
-    private class AttachedState(
-        val revealContainerNode: RevealContainerNode,
-        val alphaValue: MotionValue,
-        val debugDisposer: DisposableHandle?,
-    )
-
-    private var attachedState: AttachedState? = null
-
-    fun updateSpec(spec: FadeContentRevealSpec) {
-        this.spec = spec
-        attachedState?.updateSpec(lookaheadTargetBounds)
-    }
-
-    private var lookaheadTargetBounds = Rect.Zero
-
-    private fun AttachedState.updateSpec(lookaheadBounds: Rect) {
-        with(requireDensity()) {
-            val showSpec =
-                DirectionalMotionSpec.builder(
-                        initialMapping = Mapping.Zero,
-                        defaultSpring = spec.showSpring,
-                    )
-                    .toBreakpoint(atPosition = lookaheadBounds.bottom + spec.showDelta.toPx())
-                    .continueWith(Mapping.One, guarantee = spec.showGuarantee)
-                    .complete()
-
-            val hideSpec =
-                DirectionalMotionSpec.reverseBuilder(
-                        initialMapping = Mapping.One,
-                        defaultSpring = spec.hideSpring,
-                    )
-                    .toBreakpoint(atPosition = lookaheadBounds.bottom + spec.hideDelta.toPx())
-                    .continueWith(Mapping.Zero, guarantee = spec.hideGuarantee)
-                    .complete()
-
-            alphaValue.spec = MotionSpec(maxDirection = showSpec, minDirection = hideSpec)
-        }
-    }
-
-    override fun onAttach() {
-        val revealContainerNode =
-            checkNotNull(findNearestAncestor(TRAVERSAL_NODE_KEY)) as RevealContainerNode
-
-        val alphaValue =
-            MotionValue(
-                currentInput = revealContainerNode::containerHeight,
-                gestureContext = revealContainerNode,
-                label = "FadeReveal($label)::alpha",
-            )
-
-        var debugDisposer: DisposableHandle? = null
-        if (debug) {
-            val motionValueDebugger = findMotionValueDebugger()
-            if (motionValueDebugger != null) {
-                debugDisposer = motionValueDebugger.register(alphaValue)
-            } else {
-                Log.w(TAG, "Debugging requested, but debugger not found.")
-            }
-        }
-
-        attachedState = AttachedState(revealContainerNode, alphaValue, debugDisposer)
-        coroutineScope.launch { alphaValue.keepRunning() }
-    }
-
-    override fun onDetach() {
-        attachedState?.debugDisposer?.dispose()
-        attachedState = null
-    }
-
-    override fun isMeasurementApproachInProgress(lookaheadSize: IntSize): Boolean {
-        with(checkNotNull(attachedState)) {
-            return revealContainerNode.contentScope.layoutState.currentTransition != null ||
-                !alphaValue.isStable
-        }
-    }
-
-    override fun Placeable.PlacementScope.isPlacementApproachInProgress(
-        lookaheadCoordinates: LayoutCoordinates
-    ): Boolean {
-        with(checkNotNull(attachedState)) {
-            return revealContainerNode.contentScope.layoutState.currentTransition != null ||
-                !alphaValue.isStable
-        }
-    }
-
-    override fun MeasureScope.measure(
-        measurable: Measurable,
-        constraints: Constraints,
-    ): MeasureResult {
-        val placeable = measurable.measure(constraints)
-        return layout(placeable.width, placeable.height) {
-            if (isLookingAhead && coordinates != null) {
-
-                with(checkNotNull(attachedState)) {
-                    lookaheadTargetBounds =
-                        Rect(
-                            with(revealContainerNode.contentScope.lookaheadScope) {
-                                revealContainerNode
-                                    .requireLayoutCoordinates()
-                                    .localLookaheadPositionOf(coordinates!!)
-                            },
-                            coordinates!!.size.toSize(),
-                        )
-                    updateSpec(lookaheadTargetBounds)
-                }
-            }
-
-            placeable.place(0, 0)
-        }
-    }
-
-    override fun ApproachMeasureScope.approachMeasure(
-        measurable: Measurable,
-        constraints: Constraints,
-    ): MeasureResult {
-        return measurable.measure(constraints).run {
-            layout(width, height) {
-                val revealAlpha = checkNotNull(attachedState).alphaValue.output
-
-                if (revealAlpha < 1) {
-                    placeWithLayer(IntOffset.Zero) {
-                        alpha = revealAlpha.coerceAtLeast(0f)
-                        compositingStrategy = CompositingStrategy.ModulateAlpha
-                    }
-                } else {
-                    place(IntOffset.Zero)
-                }
-            }
-        }
-    }
-
-    companion object {
-        const val TAG = "FadeReveal"
-    }
-}
-
-internal data class FadeContentRevealElement(
-    val spec: FadeContentRevealSpec,
-    val debug: Boolean,
-    val label: String?,
-) : ModifierNodeElement<FadeContentRevealNode>() {
-    override fun create(): FadeContentRevealNode = FadeContentRevealNode(spec, debug, label)
-
-    override fun update(node: FadeContentRevealNode) {
-        node.updateSpec(spec)
-    }
-}
diff --git a/samples/MotionMechanics/src/com/android/mechanics/demo/staging/behavior/reveal/RevealContainer.kt b/samples/MotionMechanics/src/com/android/mechanics/demo/staging/behavior/reveal/RevealContainer.kt
deleted file mode 100644
index 363b05b62..000000000
--- a/samples/MotionMechanics/src/com/android/mechanics/demo/staging/behavior/reveal/RevealContainer.kt
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Copyright (C) 2025 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.mechanics.demo.staging.behavior.reveal
-
-import androidx.compose.runtime.getValue
-import androidx.compose.runtime.mutableFloatStateOf
-import androidx.compose.runtime.mutableStateOf
-import androidx.compose.runtime.setValue
-import androidx.compose.ui.Modifier
-import androidx.compose.ui.layout.ApproachLayoutModifierNode
-import androidx.compose.ui.layout.ApproachMeasureScope
-import androidx.compose.ui.layout.Measurable
-import androidx.compose.ui.layout.MeasureResult
-import androidx.compose.ui.node.ModifierNodeElement
-import androidx.compose.ui.node.ObserverModifierNode
-import androidx.compose.ui.node.TraversableNode
-import androidx.compose.ui.node.observeReads
-import androidx.compose.ui.unit.Constraints
-import androidx.compose.ui.unit.IntSize
-import com.android.compose.animation.scene.ContentScope
-import com.android.mechanics.GestureContext
-import com.android.mechanics.ProvidedGestureContext
-import com.android.mechanics.spec.InputDirection
-
-fun Modifier.revealContainer(contentScope: ContentScope): Modifier =
-    this.then(RevealContainerElement(contentScope))
-
-internal class RevealContainerNode(var contentScope: ContentScope) :
-    Modifier.Node(),
-    TraversableNode,
-    ApproachLayoutModifierNode,
-    ObserverModifierNode,
-    GestureContext {
-
-    var containerHeight by mutableFloatStateOf(0f)
-        private set
-
-    override val traverseKey = TRAVERSAL_NODE_KEY
-
-    override fun isMeasurementApproachInProgress(lookaheadSize: IntSize): Boolean {
-        return contentScope.layoutState.currentTransition != null
-    }
-
-    private var lastGestureContext by
-        mutableStateOf<GestureContext>(ProvidedGestureContext(dragOffset = 0f, InputDirection.Max))
-
-    override fun onAttach() {
-        updateGestureContext()
-    }
-
-    override fun ApproachMeasureScope.approachMeasure(
-        measurable: Measurable,
-        constraints: Constraints,
-    ): MeasureResult {
-        val animatedContainerHeight = constraints.maxHeight
-
-        containerHeight = animatedContainerHeight.toFloat()
-
-        val placeable = measurable.measure(constraints.copy(minHeight = animatedContainerHeight))
-        return layout(placeable.width, placeable.height) { placeable.place(0, 0) }
-    }
-
-    companion object {
-        const val TRAVERSAL_NODE_KEY = "com.android.mechanics.demo.util.REVEAL_CONTAINER_NODE_KEY"
-    }
-
-    override fun onObservedReadsChanged() {
-        updateGestureContext()
-    }
-
-    private fun updateGestureContext() {
-        observeReads {
-            val gestureContext = contentScope.layoutState.currentTransition?.gestureContext
-            if (gestureContext != null) {
-                this.lastGestureContext = gestureContext
-            }
-        }
-    }
-
-    override val direction: InputDirection
-        get() = lastGestureContext.direction
-
-    override val dragOffset: Float
-        get() = lastGestureContext.dragOffset
-}
-
-private data class RevealContainerElement(val contentScope: ContentScope) :
-    ModifierNodeElement<RevealContainerNode>() {
-    override fun create(): RevealContainerNode = RevealContainerNode(contentScope)
-
-    override fun update(node: RevealContainerNode) {
-        check(node.contentScope === contentScope)
-    }
-}
diff --git a/samples/SceneTransitionLayoutDemo/src/com/android/compose/animation/scene/demo/Shade.kt b/samples/SceneTransitionLayoutDemo/src/com/android/compose/animation/scene/demo/Shade.kt
index 80c9fa090..ff3cc6987 100644
--- a/samples/SceneTransitionLayoutDemo/src/com/android/compose/animation/scene/demo/Shade.kt
+++ b/samples/SceneTransitionLayoutDemo/src/com/android/compose/animation/scene/demo/Shade.kt
@@ -78,7 +78,6 @@ import com.android.compose.animation.scene.UserActionResult
 import com.android.compose.animation.scene.ValueKey
 import com.android.compose.animation.scene.animateElementFloatAsState
 import com.android.compose.animation.scene.animateSceneFloatAsState
-import com.android.compose.gesture.NestedScrollableBound
 import com.android.compose.modifiers.thenIf
 import com.android.compose.nestedscroll.LargeTopAppBarNestedScrollConnection
 import com.android.compose.nestedscroll.PriorityNestedScrollConnection
@@ -214,7 +213,7 @@ private fun ContentScope.ShadeLayout(
                 {
                     val flingBehavior = ScrollableDefaults.flingBehavior()
                     Box(
-                        Modifier.disableSwipesWhenScrolling(NestedScrollableBound.BottomRight)
+                        Modifier.disableSwipesWhenScrolling()
                             .nestedScroll(
                                 remember(
                                     scrimOffset,
diff --git a/samples/SceneTransitionLayoutDemo/src/com/android/compose/animation/scene/demo/notification/NotificationList.kt b/samples/SceneTransitionLayoutDemo/src/com/android/compose/animation/scene/demo/notification/NotificationList.kt
index c06db6d35..541d76b1b 100644
--- a/samples/SceneTransitionLayoutDemo/src/com/android/compose/animation/scene/demo/notification/NotificationList.kt
+++ b/samples/SceneTransitionLayoutDemo/src/com/android/compose/animation/scene/demo/notification/NotificationList.kt
@@ -76,7 +76,7 @@ fun ContentScope.NotificationList(
     Column(
         modifier
             .thenIf(scrollState != null) {
-                Modifier.disableSwipesWhenScrolling(NestedScrollableBound.BottomRight)
+                Modifier.disableSwipesWhenScrolling(NestedScrollableBound.BottomOrRight)
                     .verticalScroll(scrollState!!, overscrollEffect?.withoutVisualEffect())
             }
             .fillMaxWidth()
diff --git a/samples/VirtualDeviceManager/README.md b/samples/VirtualDeviceManager/README.md
index a955e51b7..d736ed42f 100644
--- a/samples/VirtualDeviceManager/README.md
+++ b/samples/VirtualDeviceManager/README.md
@@ -123,6 +123,7 @@ available devices, build the APKs and install them.
 1.  Start both the Client and the Host apps on each respective device.
 
 1.  They should find each other and connect automatically. On the first launch
+
     the Host app will ask to create a CDM association: allow it.
 
     WARNING: If there are other devices in the vicinity with one of these apps
@@ -161,6 +162,10 @@ show a launcher-like list of installed apps on the host device.
     a new virtual display, mirror the default host display there and start
     streaming the display contents to the client.
 
+-   [WIP] The Host app has a **CREATE DESKTOP DISPLAY** button, clicking it will
+    create a new virtual display in desktop mode and start streaming the display
+    contents to the client.
+
 ### Settings
 
 #### Input
@@ -214,23 +219,11 @@ Each input screen has a "Back", "Home" and "Forward" buttons.
     adb shell aflags enable android.companion.virtual.flags.activity_control_api && adb reboot
     ```
 
-#### Client capabilities
-
 -   **Enable client Sensors**: Enables sensor injection from the client device
     into the host device. Any context that is associated with the virtual device
     will access the virtual sensors by default. \
     *Changing this will recreate the virtual device.*
 
--   **Enable client Camera**: Enables front & back camera injection from the
-    client device into the host device. (WIP: Any context that is associated
-    with the virtual device will the virtual cameras by default). \
-    *Changing this will recreate the virtual device.*
-
--   **Enable client Audio**: Enables audio output on the client device. Any
-    context that is associated with the virtual device will play audio on the
-    client by default. \
-    *This can be changed dynamically.*
-
 #### Displays
 
 -   **Display rotation**: Whether orientation change requests from streamed apps
@@ -290,8 +283,46 @@ Each input screen has a "Back", "Home" and "Forward" buttons.
     adb shell aflags enable android.companion.virtual.flags.device_aware_display_power && adb reboot
     ```
 
+#### Camera
+
+-   **Camera policy**: Choose the cameras to be used on the virtual device:
+    -   *No cameras* - No cameras are exposed on the virtual device.
+    -   *Default device cameras* - The front and back cameras of the host device
+        are exposed as such on the virtual device. Any external camera from the
+        client device is exposed globally on the host device.
+    -   *Client cameras* - All the cameras from the client are exposed only in
+        the virtual device.
+
+    *Changing this will recreate the virtual device.*
+
+    Note: External cameras already present on the client are mapped as virtual
+    external cameras on the host virtual device when the policy is different
+    than *No cameras*. Test cameras can be created on the client device with
+    Android 15 or newer (SDK level 35) with:
+
+    ```shell
+    adb shell start virtual_camera
+    adb shell cmd virtual_camera enable_test_camera
+    ```
+
+    The front and back cameras of the client can be also mapped as virtual
+    external cameras on the virtual device for testing.
+
+-   **Duplicate front camera**: Creates an additional external camera
+    (if external virtual cameras are supported) that duplicates the **front** camera
+    stream of the remote device (if exists).
+
+-   **Duplicate back camera**: Creates an additional external camera
+    (if external virtual cameras are supported) that duplicates the **back** camera
+    stream of the remote device (if exists).
+
 #### Audio
 
+-   **Enable client Audio**: Enables audio output on the client device. Any
+    context that is associated with the virtual device will play audio on the
+    client by default. \
+    *This can be changed dynamically.*
+
 -   **Use AudioPolicy.updateMixingRules**: Updates the dynamic AudiPolicy mixing rules
     instead of unregistering and re-registering the AudioPolicy.
 
@@ -316,7 +347,7 @@ you likely need to enable this in the host Settings. On a Pixel device: System
     The contents of the virtual displays are rendered locally in a separate
     activity.
 
-- **Record encoder output**: Enables recording the output of the encoder on
+-   **Record encoder output**: Enables recording the output of the encoder on
     the host device to a local file on the device. This can be helpful with
     debugging Encoding related issues. To download and play the file locally:
 
@@ -397,6 +428,9 @@ adb shell aflags enable android.companion.virtual.flags.device_aware_display_pow
     accelerometer events, which allows for selecting which device's sensor to
     use. By default, will use the sensors of the device it's shown on.
 
+-   **Picture in Picture**: A simple activity with PiP support showing the
+    behavior of pinned windowing mode on the virtual display.
+
 -   **Display Power**: A simple activity showcasing the behavior of proximity
     locks, screen brightness override and requesting the screen to be kept on
     or turned on.
@@ -443,6 +477,8 @@ which showcases implicit intent handling.
 
 -   Added support for virtual sensor additional info.
 
+-   Added support for virtual external cameras.
+
 ### Android 16 / Baklava / SDK level 36
 
 -   Added `COMPANION_DEVICE_VIRTUAL_DEVICE` device profile.
diff --git a/samples/VirtualDeviceManager/client/src/com/example/android/vdmdemo/client/VirtualCameraController.java b/samples/VirtualDeviceManager/client/src/com/example/android/vdmdemo/client/VirtualCameraController.java
index 955375b2a..3b55526fd 100644
--- a/samples/VirtualDeviceManager/client/src/com/example/android/vdmdemo/client/VirtualCameraController.java
+++ b/samples/VirtualDeviceManager/client/src/com/example/android/vdmdemo/client/VirtualCameraController.java
@@ -84,6 +84,7 @@ final class VirtualCameraController implements AutoCloseable {
         try {
             getFrontCamera().ifPresent(mExposedCameras::add);
             getBackCamera().ifPresent(mExposedCameras::add);
+            mExposedCameras.addAll(getCamerasWithExternalLensFacing());
         } catch (CameraAccessException exception) {
             Log.e(TAG, NO_CAMERA_PERMISSION_LOG_MSG, exception);
         }
@@ -124,19 +125,31 @@ final class VirtualCameraController implements AutoCloseable {
         return Optional.empty();
     }
 
+    List<String> getCamerasWithExternalLensFacing() throws CameraAccessException {
+        final List<String> externalCameraIds = new ArrayList<>();
+        for (String cameraId : mCameraManager.getCameraIdList()) {
+            CameraCharacteristics characteristics = mCameraManager.getCameraCharacteristics(
+                    cameraId);
+
+            if (Objects.equals(characteristics.get(CameraCharacteristics.LENS_FACING),
+                    CameraCharacteristics.LENS_FACING_EXTERNAL)) {
+                externalCameraIds.add(cameraId);
+            }
+        }
+        return externalCameraIds;
+    }
+
     RemoteEventProto.CameraCapabilities getCapabilitiesForCamera(String cameraId)
             throws CameraAccessException {
         CameraCharacteristics characteristics = mCameraManager.getCameraCharacteristics(cameraId);
 
-
         return RemoteEventProto.CameraCapabilities.newBuilder()
                 .setCameraId(cameraId)
                 .setWidth(CAMERA_WIDTH)
                 .setHeight(CAMERA_HEIGHT)
                 .setFps(FPS)
                 .setLensFacing(Objects.requireNonNull(
-                        characteristics.get(
-                                CameraCharacteristics.LENS_FACING)))
+                        characteristics.get(CameraCharacteristics.LENS_FACING)))
                 .setSensorOrientation(Objects.requireNonNull(
                         characteristics.get(CameraCharacteristics.SENSOR_ORIENTATION)))
                 .build();
diff --git a/samples/VirtualDeviceManager/demos/AndroidManifest.xml b/samples/VirtualDeviceManager/demos/AndroidManifest.xml
index 9a0ff2d0c..f528b5cfa 100644
--- a/samples/VirtualDeviceManager/demos/AndroidManifest.xml
+++ b/samples/VirtualDeviceManager/demos/AndroidManifest.xml
@@ -98,6 +98,12 @@
             android:exported="true"
             android:label="@string/secure_window_demo" />
 
+        <activity
+            android:name=".PipDemoActivity"
+            android:exported="false"
+            android:supportsPictureInPicture="true"
+            android:label="@string/pip_demo" />
+
         <activity
             android:name=".LatencyDemoActivity"
             android:exported="true"
diff --git a/samples/VirtualDeviceManager/demos/res/layout/main_activity.xml b/samples/VirtualDeviceManager/demos/res/layout/main_activity.xml
index 942fadce0..2b1bb1dc2 100644
--- a/samples/VirtualDeviceManager/demos/res/layout/main_activity.xml
+++ b/samples/VirtualDeviceManager/demos/res/layout/main_activity.xml
@@ -1,79 +1,92 @@
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="wrap_content"
+<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
     android:layout_height="match_parent"
-    android:layout_gravity="center"
-    android:gravity="center"
-    android:orientation="vertical"
-    android:padding="10dp">
+    android:fillViewport="true">
 
-    <Button
-        android:id="@+id/activity_policy_demo"
+    <LinearLayout
         android:layout_width="match_parent"
         android:layout_height="wrap_content"
-        android:onClick="onDemoSelected"
-        android:text="@string/activity_policy_demo" />
+        android:gravity="center"
+        android:orientation="vertical"
+        android:padding="10dp">
 
-    <Button
-        android:id="@+id/sensor_demo"
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:onClick="onDemoSelected"
-        android:text="@string/sensor_demo" />
+        <Button
+            android:id="@+id/activity_policy_demo"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:onClick="onDemoSelected"
+            android:text="@string/activity_policy_demo" />
 
-    <Button
-        android:id="@+id/display_power_demo"
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:onClick="onDemoSelected"
-        android:text="@string/display_power_demo" />
+        <Button
+            android:id="@+id/sensor_demo"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:onClick="onDemoSelected"
+            android:text="@string/sensor_demo" />
 
-    <Button
-        android:id="@+id/vibration_demo"
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:onClick="onDemoSelected"
-        android:text="@string/vibration_demo" />
+        <Button
+            android:id="@+id/pip_demo"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:onClick="onDemoSelected"
+            android:text="@string/pip_demo" />
 
-    <Button
-        android:id="@+id/rotation_demo"
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:onClick="onDemoSelected"
-        android:text="@string/rotation_demo" />
+        <Button
+            android:id="@+id/display_power_demo"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:onClick="onDemoSelected"
+            android:text="@string/display_power_demo" />
 
-    <Button
-        android:id="@+id/home_demo"
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:onClick="onDemoSelected"
-        android:text="@string/home_demo" />
+        <Button
+            android:id="@+id/vibration_demo"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:onClick="onDemoSelected"
+            android:text="@string/vibration_demo" />
 
-    <Button
-        android:id="@+id/permissions_demo"
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:onClick="onDemoSelected"
-        android:text="@string/permissions_demo" />
+        <Button
+            android:id="@+id/rotation_demo"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:onClick="onDemoSelected"
+            android:text="@string/rotation_demo" />
 
-    <Button
-        android:id="@+id/latency_demo"
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:onClick="onDemoSelected"
-        android:text="@string/latency_demo" />
+        <Button
+            android:id="@+id/home_demo"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:onClick="onDemoSelected"
+            android:text="@string/home_demo" />
 
-    <Button
-        android:id="@+id/stylus_demo"
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:onClick="onDemoSelected"
-        android:text="@string/stylus_demo" />
+        <Button
+            android:id="@+id/permissions_demo"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:onClick="onDemoSelected"
+            android:text="@string/permissions_demo" />
 
-    <Button
-        android:id="@+id/recorder_demo"
-        android:layout_width="match_parent"
-        android:layout_height="wrap_content"
-        android:onClick="onDemoSelected"
-        android:text="@string/recorder_demo" />
+        <Button
+            android:id="@+id/latency_demo"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:onClick="onDemoSelected"
+            android:text="@string/latency_demo" />
+
+        <Button
+            android:id="@+id/stylus_demo"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:onClick="onDemoSelected"
+            android:text="@string/stylus_demo" />
+
+        <Button
+            android:id="@+id/recorder_demo"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:onClick="onDemoSelected"
+            android:text="@string/recorder_demo" />
+
+    </LinearLayout>
 
-</LinearLayout>
\ No newline at end of file
+</ScrollView>
\ No newline at end of file
diff --git a/samples/VirtualDeviceManager/demos/res/layout/pip_demo_activity.xml b/samples/VirtualDeviceManager/demos/res/layout/pip_demo_activity.xml
new file mode 100644
index 000000000..ad37b5652
--- /dev/null
+++ b/samples/VirtualDeviceManager/demos/res/layout/pip_demo_activity.xml
@@ -0,0 +1,16 @@
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="wrap_content"
+    android:layout_height="match_parent"
+    android:layout_gravity="center"
+    android:gravity="center"
+    android:orientation="vertical"
+    android:padding="10dp">
+
+    <Button
+        android:id="@+id/enter_pip"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:onClick="onPipRequested"
+        android:text="@string/enter_pip" />
+
+</LinearLayout>
\ No newline at end of file
diff --git a/samples/VirtualDeviceManager/demos/res/values/strings.xml b/samples/VirtualDeviceManager/demos/res/values/strings.xml
index a895518c8..fefd84e2c 100644
--- a/samples/VirtualDeviceManager/demos/res/values/strings.xml
+++ b/samples/VirtualDeviceManager/demos/res/values/strings.xml
@@ -2,6 +2,7 @@
     <string name="app_name" translatable="false">VDM Demos</string>
     <string name="activity_policy_demo" translatable="false">VDM Activity Policy Demo</string>
     <string name="sensor_demo" translatable="false">VDM Sensor Demo</string>
+    <string name="pip_demo" translatable="false">VDM Picture in Picture Demo</string>
     <string name="display_power_demo" translatable="false">VDM Display Power Demo</string>
     <string name="vibration_demo" translatable="false">VDM Vibration Demo</string>
     <string name="rotation_demo" translatable="false">VDM Rotation Demo</string>
@@ -29,6 +30,8 @@
     <string name="portrait" translatable="false">Portrait</string>
     <string name="landscape" translatable="false">Landscape</string>
 
+    <string name="enter_pip" translatable="false">Enter Picture in Picture</string>
+
     <string name="send_home" translatable="false">Send HOME intent</string>
     <string name="send_secondary_home" translatable="false">Send SECONDARY_HOME intent</string>
     <string name="move_task_to_back" translatable="false">Move task to back</string>
diff --git a/samples/VirtualDeviceManager/demos/src/com/example/android/vdmdemo/demos/MainActivity.java b/samples/VirtualDeviceManager/demos/src/com/example/android/vdmdemo/demos/MainActivity.java
index 4b73050ec..b1da97087 100644
--- a/samples/VirtualDeviceManager/demos/src/com/example/android/vdmdemo/demos/MainActivity.java
+++ b/samples/VirtualDeviceManager/demos/src/com/example/android/vdmdemo/demos/MainActivity.java
@@ -38,6 +38,7 @@ public class MainActivity extends AppCompatActivity {
                     new Intent(this, ActivityPolicyDemoActivity.class));
             case R.id.home_demo -> startActivity(new Intent(this, HomeDemoActivity.class));
             case R.id.sensor_demo -> startActivity(new Intent(this, SensorDemoActivity.class));
+            case R.id.pip_demo -> startActivity(new Intent(this, PipDemoActivity.class));
             case R.id.display_power_demo -> startActivity(
                     new Intent(this, DisplayPowerDemoActivity.class));
             case R.id.rotation_demo -> startActivity(new Intent(this, RotationDemoActivity.class));
diff --git a/samples/VirtualDeviceManager/demos/src/com/example/android/vdmdemo/demos/PipDemoActivity.java b/samples/VirtualDeviceManager/demos/src/com/example/android/vdmdemo/demos/PipDemoActivity.java
new file mode 100644
index 000000000..86975d839
--- /dev/null
+++ b/samples/VirtualDeviceManager/demos/src/com/example/android/vdmdemo/demos/PipDemoActivity.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.example.android.vdmdemo.demos;
+
+import android.app.PictureInPictureParams;
+import android.os.Bundle;
+import android.view.View;
+import android.widget.TextView;
+
+import androidx.appcompat.app.AppCompatActivity;
+
+/** Activity that can enter picture in picture mode. */
+public final class PipDemoActivity extends AppCompatActivity {
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        if (isInPictureInPictureMode()) {
+            setContentView(R.layout.text_demo_activity);
+            ((TextView) requireViewById(R.id.text)).setText(R.string.pip_demo);
+        } else {
+            setContentView(R.layout.pip_demo_activity);
+        }
+    }
+
+    /** Handles PiP request. */
+    public void onPipRequested(View view) {
+        enterPictureInPictureMode(new PictureInPictureParams.Builder().build());
+    }
+
+    @Override
+    public void onUserLeaveHint() {
+        super.onUserLeaveHint();
+        enterPictureInPictureMode(new PictureInPictureParams.Builder().build());
+    }
+}
diff --git a/samples/VirtualDeviceManager/host/res/layout/activity_main.xml b/samples/VirtualDeviceManager/host/res/layout/activity_main.xml
index 56e578856..c772b146d 100644
--- a/samples/VirtualDeviceManager/host/res/layout/activity_main.xml
+++ b/samples/VirtualDeviceManager/host/res/layout/activity_main.xml
@@ -48,6 +48,21 @@
                 android:text="@string/create_mirror_display" />
         </LinearLayout>
 
+        <LinearLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:gravity="center_horizontal"
+            android:orientation="horizontal">
+
+            <Button
+                android:id="@+id/create_desktop_display"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="center"
+                android:onClick="onCreateDesktopDisplay"
+                android:text="@string/create_desktop_display" />
+        </LinearLayout>
+
         <include layout="@layout/custom_launcher" />
 
     </LinearLayout>
diff --git a/samples/VirtualDeviceManager/host/res/values/arrays.xml b/samples/VirtualDeviceManager/host/res/values/arrays.xml
index 12ca105cc..95127ede4 100644
--- a/samples/VirtualDeviceManager/host/res/values/arrays.xml
+++ b/samples/VirtualDeviceManager/host/res/values/arrays.xml
@@ -33,4 +33,11 @@
         <item>5000</item>
         <item>123000</item>
     </string-array>
+
+    <string-array translatable="false" name="camera_policy_options">
+        <item>@string/no_cameras</item>
+        <item>@string/default_cameras</item>
+        <item>@string/client_cameras</item>
+    </string-array>
+
 </resources>
diff --git a/samples/VirtualDeviceManager/host/res/values/strings.xml b/samples/VirtualDeviceManager/host/res/values/strings.xml
index 3667dbd45..7837d143c 100644
--- a/samples/VirtualDeviceManager/host/res/values/strings.xml
+++ b/samples/VirtualDeviceManager/host/res/values/strings.xml
@@ -3,6 +3,7 @@
     <string name="launcher_name" translatable="false">VDM Launcher</string>
     <string name="create_home_display" translatable="false">Create Home Display</string>
     <string name="create_mirror_display" translatable="false">Create Mirror Display</string>
+    <string name="create_desktop_display" translatable="false">Create Desktop Display</string>
     <string name="app_icon_description" translatable="false">Application Icon</string>
     <string name="settings" translatable="false">Settings</string>
     <string name="input" translatable="false">Input</string>
@@ -47,7 +48,7 @@
     <string name="pref_hide_from_recents" translatable="false">hide_from_recents</string>
     <string name="pref_enable_cross_device_clipboard" translatable="false">enable_cross_device_clipboard</string>
     <string name="pref_enable_custom_activity_policy" translatable="false">enable_custom_activity_policy</string>
-    <string name="pref_enable_client_camera" translatable="false">enable_client_camera</string>
+    <string name="pref_camera_policy" translatable="false">camera_policy</string>
     <string name="pref_enable_client_sensors" translatable="false">enable_client_sensors</string>
     <string name="pref_enable_client_audio" translatable="false">enable_client_audio</string>
     <string name="pref_enable_display_rotation" translatable="false">enable_display_rotation</string>
@@ -62,11 +63,14 @@
     <string name="pref_enable_client_native_ime" translatable="false">enable_client_native_ime</string>
     <string name="pref_standalone_host_demo" translatable="false">standalone_host_demo</string>
     <string name="pref_record_encoder_output" translatable="false">record_encoder_output</string>
+    <string name="pref_duplicate_front_camera" translatable="false">duplicate_front_camera</string>
+    <string name="pref_duplicate_back_camera" translatable="false">duplicate_back_camera</string>
     <string name="pref_network_channel" translatable="false">network_channel</string>
     <string name="pref_enable_update_audio_policy_mixes" translatable="false">enable_update_mixing_rules</string>
 
     <string name="internal_pref_home_displays_supported" translatable="false">home_displays_supported</string>
     <string name="internal_pref_mirror_displays_supported" translatable="false">mirror_displays_supported</string>
+    <string name="internal_pref_desktop_displays_supported" translatable="false">desktop_displays_supported</string>
     <string name="internal_pref_virtual_stylus_supported" translatable="false">virtual_stylus_supported</string>
     <string name="internal_pref_virtual_rotary_supported" translatable="false">virtual_rotary_supported</string>
     <string name="internal_pref_display_rotation_supported" translatable="false">display_rotation_supported</string>
@@ -74,4 +78,8 @@
     <string name="app_streaming" translatable="false">android.app.role.COMPANION_DEVICE_APP_STREAMING</string>
     <string name="nearby_device_streaming" translatable="false">android.app.role.COMPANION_DEVICE_NEARBY_DEVICE_STREAMING</string>
     <string name="virtual_device" translatable="false">android.app.role.COMPANION_DEVICE_VIRTUAL_DEVICE</string>
+
+    <string name="no_cameras" translatable="false">No cameras</string>
+    <string name="default_cameras" translatable="false">Default device cameras</string>
+    <string name="client_cameras" translatable="false">Client cameras</string>
 </resources>
\ No newline at end of file
diff --git a/samples/VirtualDeviceManager/host/res/xml/preferences.xml b/samples/VirtualDeviceManager/host/res/xml/preferences.xml
index 8dff612fb..73ccfb34a 100644
--- a/samples/VirtualDeviceManager/host/res/xml/preferences.xml
+++ b/samples/VirtualDeviceManager/host/res/xml/preferences.xml
@@ -31,27 +31,11 @@
             android:summary="Show a custom notification when an activity could not be launched and try to send it to the default display"
             android:defaultValue="false"
             app:iconSpaceReserved="false"/>
-    </PreferenceCategory>
-
-    <PreferenceCategory
-        android:key="client_capabilities"
-        android:title="Client capabilities"
-        app:iconSpaceReserved="false">
-         <SwitchPreferenceCompat
+        <SwitchPreferenceCompat
             android:key="@string/pref_enable_client_sensors"
             android:title="Enable client sensors"
             android:defaultValue="true"
             app:iconSpaceReserved="false" />
-        <SwitchPreferenceCompat
-            android:key="@string/pref_enable_client_camera"
-            android:title="Enable client camera"
-            android:defaultValue="true"
-            app:iconSpaceReserved="false" />
-        <SwitchPreferenceCompat
-            android:key="@string/pref_enable_client_audio"
-            android:title="Enable client audio"
-            android:defaultValue="true"
-            app:iconSpaceReserved="false" />
     </PreferenceCategory>
 
     <PreferenceCategory
@@ -110,12 +94,44 @@
             app:iconSpaceReserved="false" />
     </PreferenceCategory>
 
+    <PreferenceCategory
+        android:key="camera"
+        android:title="Camera"
+        app:iconSpaceReserved="false">
+        <ListPreference
+            android:key="@string/pref_camera_policy"
+            android:title="Camera policy"
+            android:entries="@array/camera_policy_options"
+            android:entryValues="@array/camera_policy_options"
+            android:defaultValue="@string/no_cameras"
+            app:useSimpleSummaryProvider="true"
+            app:iconSpaceReserved="false" />
+        <SwitchPreferenceCompat
+            android:key="@string/pref_duplicate_front_camera"
+            android:title="Duplicate front camera"
+            android:summary="Create an external camera duplicated from the client's front camera."
+            android:defaultValue="false"
+            app:iconSpaceReserved="false" />
+        <SwitchPreferenceCompat
+            android:key="@string/pref_duplicate_back_camera"
+            android:title="Duplicate back camera"
+            android:summary="Create an external camera duplicated from the client's back camera."
+            android:defaultValue="false"
+            app:iconSpaceReserved="false" />
+    </PreferenceCategory>
+
     <PreferenceCategory
         android:key="audio"
         android:title="Audio"
         app:iconSpaceReserved="false">
+    <SwitchPreferenceCompat
+        android:key="@string/pref_enable_client_audio"
+        android:title="Enable client audio"
+        android:defaultValue="true"
+        app:iconSpaceReserved="false" />
     <SwitchPreferenceCompat
         android:key="@string/pref_enable_update_audio_policy_mixes"
+        android:dependency="@string/pref_enable_client_audio"
         android:title="Use AudioPolicy.updateMixingRules"
         android:summary="Updates the dynamic AudiPolicy mixing rules instead of unregistering and registering the AudioPolicy."
         android:defaultValue="true"
diff --git a/samples/VirtualDeviceManager/host/src/com/example/android/vdmdemo/host/MainActivity.java b/samples/VirtualDeviceManager/host/src/com/example/android/vdmdemo/host/MainActivity.java
index 236a513a8..eaa161ea7 100644
--- a/samples/VirtualDeviceManager/host/src/com/example/android/vdmdemo/host/MainActivity.java
+++ b/samples/VirtualDeviceManager/host/src/com/example/android/vdmdemo/host/MainActivity.java
@@ -17,6 +17,7 @@
 package com.example.android.vdmdemo.host;
 
 import android.Manifest;
+import android.app.ActivityOptions;
 import android.app.AlertDialog;
 import android.content.ComponentName;
 import android.content.Context;
@@ -26,6 +27,7 @@ import android.content.pm.PackageManager;
 import android.os.Bundle;
 import android.os.IBinder;
 import android.util.Log;
+import android.view.Display;
 import android.view.Menu;
 import android.view.MenuInflater;
 import android.view.MenuItem;
@@ -58,6 +60,7 @@ public class MainActivity extends Hilt_MainActivity {
     private GridView mLauncher = null;
     private Button mHomeDisplayButton = null;
     private Button mMirrorDisplayButton = null;
+    private Button mDesktopDisplayButton = null;
     private LauncherAdapter mLauncherAdapter = null;
     private final Consumer<Boolean> mVirtualDeviceListener = this::updateLauncherVisibility;
 
@@ -108,6 +111,8 @@ public class MainActivity extends Hilt_MainActivity {
         mHomeDisplayButton.setVisibility(View.GONE);
         mMirrorDisplayButton = requireViewById(R.id.create_mirror_display);
         mMirrorDisplayButton.setVisibility(View.GONE);
+        mDesktopDisplayButton = requireViewById(R.id.create_desktop_display);
+        mDesktopDisplayButton.setVisibility(View.GONE);
 
         mLauncherAdapter = new LauncherAdapter(this, mPreferenceController);
         mLauncher = requireViewById(R.id.app_grid);
@@ -128,28 +133,28 @@ public class MainActivity extends Hilt_MainActivity {
                         return true;
                     }
                     int[] remoteDisplayIds = mVdmService.getRemoteDisplayIds();
-                    if (remoteDisplayIds.length == 0) {
-                        mVdmService.startStreaming(intent);
-                    } else {
-                        String[] displays = new String[remoteDisplayIds.length + 1];
-                        for (int i = 0; i < remoteDisplayIds.length; ++i) {
-                            displays[i] = "Display " + remoteDisplayIds[i];
-                        }
-                        displays[remoteDisplayIds.length] = "New display";
-                        AlertDialog.Builder alertDialogBuilder =
-                                new AlertDialog.Builder(MainActivity.this);
-                        alertDialogBuilder.setTitle("Choose display");
-                        alertDialogBuilder.setItems(
-                                displays,
-                                (dialog, which) -> {
-                                    if (which == remoteDisplayIds.length) {
-                                        mVdmService.startStreaming(intent);
-                                    } else {
-                                        mVdmService.startIntentOnDisplayIndex(intent, which);
-                                    }
-                                });
-                        alertDialogBuilder.show();
+                    String[] displays = new String[remoteDisplayIds.length + 2];
+                    for (int i = 0; i < remoteDisplayIds.length; ++i) {
+                        displays[i] = "Display " + remoteDisplayIds[i];
                     }
+                    displays[remoteDisplayIds.length] = "New display";
+                    displays[remoteDisplayIds.length + 1] = "Default display";
+                    AlertDialog.Builder alertDialogBuilder =
+                            new AlertDialog.Builder(MainActivity.this);
+                    alertDialogBuilder.setTitle("Choose display");
+                    alertDialogBuilder.setItems(displays, (dialog, which) -> {
+                        if (which > remoteDisplayIds.length) {
+                            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+                            startActivity(intent, ActivityOptions.makeBasic()
+                                    .setLaunchDisplayId(Display.DEFAULT_DISPLAY)
+                                    .toBundle());
+                        } else if (which == remoteDisplayIds.length) {
+                            mVdmService.startStreaming(intent);
+                        } else {
+                            mVdmService.startIntentOnDisplayIndex(intent, which);
+                        }
+                    });
+                    alertDialogBuilder.show();
                     return true;
                 });
     }
@@ -222,6 +227,12 @@ public class MainActivity extends Hilt_MainActivity {
                                 VdmCompat.isMirrorDisplaySupported(this, mPreferenceController));
                         mMirrorDisplayButton.setVisibility(visibility);
                     }
+                    if (mDesktopDisplayButton != null) {
+                        mDesktopDisplayButton.setEnabled(
+                                mPreferenceController.getBoolean(
+                                        R.string.internal_pref_desktop_displays_supported));
+                        mDesktopDisplayButton.setVisibility(visibility);
+                    }
                 });
     }
 
@@ -235,6 +246,11 @@ public class MainActivity extends Hilt_MainActivity {
         mVdmService.startMirroring();
     }
 
+    /** Process a desktop display request. */
+    public void onCreateDesktopDisplay(View view) {
+        mVdmService.startDesktop();
+    }
+
     @Override
     public boolean onCreateOptionsMenu(Menu menu) {
         MenuInflater inflater = getMenuInflater();
diff --git a/samples/VirtualDeviceManager/host/src/com/example/android/vdmdemo/host/PreferenceController.java b/samples/VirtualDeviceManager/host/src/com/example/android/vdmdemo/host/PreferenceController.java
index c5fbced1f..d2f91eefa 100644
--- a/samples/VirtualDeviceManager/host/src/com/example/android/vdmdemo/host/PreferenceController.java
+++ b/samples/VirtualDeviceManager/host/src/com/example/android/vdmdemo/host/PreferenceController.java
@@ -76,7 +76,7 @@ final class PreferenceController {
             new BoolRule(R.string.pref_enable_custom_activity_policy, BAKLAVA,
                     Flags::activityControlApi),
 
-            new BoolRule(R.string.pref_enable_client_camera, VANILLA_ICE_CREAM),
+            new StringRule(R.string.pref_camera_policy, VANILLA_ICE_CREAM),
 
             new BoolRule(R.string.pref_enable_client_sensors, UPSIDE_DOWN_CAKE),
 
@@ -123,6 +123,12 @@ final class PreferenceController {
             new BoolRule(R.string.pref_enable_update_audio_policy_mixes, VANILLA_ICE_CREAM)
                     .withDefaultValue(true),
 
+            new BoolRule(R.string.pref_duplicate_front_camera, BAKLAVA,
+                    Flags::externalVirtualCameras),
+
+            new BoolRule(R.string.pref_duplicate_back_camera, BAKLAVA,
+                    Flags::externalVirtualCameras),
+
             // Internal-only switches not exposed in the settings page.
             // All of these are booleans acting as switches, while the above ones may be any type.
 
@@ -132,6 +138,9 @@ final class PreferenceController {
             new InternalBoolRule(R.string.internal_pref_mirror_displays_supported,
                     VANILLA_ICE_CREAM),
 
+            new InternalBoolRule(R.string.internal_pref_desktop_displays_supported,  BAKLAVA)
+                    .withRequiredPermissions(ADD_TRUSTED_DISPLAY),
+
             new InternalBoolRule(R.string.internal_pref_virtual_stylus_supported,
                     VANILLA_ICE_CREAM),
 
@@ -201,6 +210,10 @@ final class PreferenceController {
         return mSharedPreferences.getBoolean(mContext.getString(resId), false);
     }
 
+    boolean setBoolean(@StringRes int resId, boolean b) {
+        return mSharedPreferences.edit().putBoolean(mContext.getString(resId), b).commit();
+    }
+
     String getString(@StringRes int resId) {
         return Objects.requireNonNull(
                 mSharedPreferences.getString(mContext.getString(resId), null));
diff --git a/samples/VirtualDeviceManager/host/src/com/example/android/vdmdemo/host/RemoteCameraManager.java b/samples/VirtualDeviceManager/host/src/com/example/android/vdmdemo/host/RemoteCameraManager.java
index 1086b861e..c2b1a8761 100644
--- a/samples/VirtualDeviceManager/host/src/com/example/android/vdmdemo/host/RemoteCameraManager.java
+++ b/samples/VirtualDeviceManager/host/src/com/example/android/vdmdemo/host/RemoteCameraManager.java
@@ -21,7 +21,12 @@ import android.companion.virtual.VirtualDeviceManager;
 import android.companion.virtual.camera.VirtualCamera;
 import android.companion.virtual.camera.VirtualCameraCallback;
 import android.companion.virtual.camera.VirtualCameraConfig;
+import android.companion.virtualdevice.flags.Flags;
+import android.content.Context;
 import android.graphics.ImageFormat;
+import android.hardware.camera2.CameraAccessException;
+import android.hardware.camera2.CameraCharacteristics;
+import android.hardware.camera2.CameraManager;
 import android.util.ArrayMap;
 import android.util.Log;
 import android.view.Surface;
@@ -34,6 +39,7 @@ import com.example.android.vdmdemo.common.RemoteIo;
 import com.example.android.vdmdemo.common.VideoManager;
 import com.google.common.util.concurrent.MoreExecutors;
 
+import java.util.Arrays;
 import java.util.List;
 import java.util.Objects;
 
@@ -45,31 +51,90 @@ final class RemoteCameraManager implements AutoCloseable {
     private final VirtualDeviceManager.VirtualDevice mVirtualDevice;
     private final ArrayMap<String, VirtualCamera> mVirtualCameras = new ArrayMap<>();
 
-
     RemoteCameraManager(@NonNull VirtualDeviceManager.VirtualDevice virtualDevice,
             @NonNull RemoteIo remoteIo) {
         mVirtualDevice = Objects.requireNonNull(virtualDevice);
         mRemoteIo = Objects.requireNonNull(remoteIo);
     }
 
-    void createCameras(List<RemoteEventProto.CameraCapabilities> cameraCapabilities) {
+    void createCameras(List<RemoteEventProto.CameraCapabilities> cameraCapabilities,
+            boolean isCustomCameraPolicy, boolean duplicateFrontCamera,
+            boolean duplicateBackCamera) {
+        boolean supportExternal = VdmCompat.isAtLeastB() && Flags.externalVirtualCameras();
         for (RemoteEventProto.CameraCapabilities capabilities : cameraCapabilities) {
-            VirtualCameraConfig config = new VirtualCameraConfig.Builder(
-                    "Remote camera " + capabilities.getCameraId())
-                        .addStreamConfig(capabilities.getWidth(), capabilities.getHeight(),
-                                            ImageFormat.YUV_420_888, capabilities.getFps())
-                        .setVirtualCameraCallback(MoreExecutors.directExecutor(),
-                                            new RemoteCamera(capabilities.getCameraId()))
-                        .setLensFacing(capabilities.getLensFacing())
-                        .setSensorOrientation(capabilities.getSensorOrientation()).build();
-            VirtualCamera camera = mVirtualDevice.createVirtualCamera(config);
-            mVirtualCameras.put(capabilities.getCameraId(), camera);
-
-            Log.d(TAG, "Created virtual camera " + capabilities.getCameraId()
-                        + "(" + camera.getConfig().getName() + ")");
+            // filter out external cameras if not supported
+            int lensFacing = capabilities.getLensFacing();
+            if (lensFacing == CameraCharacteristics.LENS_FACING_EXTERNAL && !supportExternal) {
+                continue;
+            }
+
+            if (supportExternal) {
+                if (duplicateFrontCamera && lensFacing == CameraCharacteristics.LENS_FACING_FRONT) {
+                    createVirtualCamera(capabilities.getCameraId(),
+                            CameraCharacteristics.LENS_FACING_EXTERNAL, capabilities);
+                }
+
+                if (duplicateBackCamera && lensFacing == CameraCharacteristics.LENS_FACING_BACK) {
+                    createVirtualCamera(capabilities.getCameraId(),
+                            CameraCharacteristics.LENS_FACING_EXTERNAL, capabilities);
+                }
+            }
+
+            // don't create non external cameras on default camera policy
+            if (!isCustomCameraPolicy && lensFacing != CameraCharacteristics.LENS_FACING_EXTERNAL) {
+                continue;
+            }
+
+            createVirtualCamera(capabilities.getCameraId(), lensFacing, capabilities);
+        }
+
+        try {
+            final CameraManager cameraManager = mVirtualDevice.createContext()
+                    .getSystemService(CameraManager.class);
+            if (cameraManager != null) {
+                Log.d(TAG, "CameraManager on deviceId: " + mVirtualDevice.getDeviceId()
+                        + " has available camera ids: " + Arrays.toString(
+                        cameraManager.getCameraIdList()));
+            }
+
+            final CameraManager cameraManagerDefault = mVirtualDevice.createContext()
+                    .createDeviceContext(Context.DEVICE_ID_DEFAULT)
+                    .getSystemService(CameraManager.class);
+            if (cameraManagerDefault != null) {
+                Log.d(TAG, "CameraManager on default device has available camera ids: "
+                        + Arrays.toString(cameraManagerDefault.getCameraIdList()));
+            }
+        } catch (CameraAccessException e) {
+            Log.e(TAG, "Exception getting the list of camera ids: " + e);
         }
     }
 
+    private void createVirtualCamera(String cameraId, int lensFacing,
+            RemoteEventProto.CameraCapabilities capabilities) {
+        final String lensFacingText = switch (lensFacing) {
+            case CameraCharacteristics.LENS_FACING_FRONT -> "front";
+            case CameraCharacteristics.LENS_FACING_BACK -> "back";
+            case CameraCharacteristics.LENS_FACING_EXTERNAL -> "external";
+            default -> "unknown";
+        };
+        @SuppressLint("WrongConstant")
+        VirtualCameraConfig config = new VirtualCameraConfig.Builder(
+                "Remote " + lensFacingText + " camera " + cameraId)
+                .addStreamConfig(capabilities.getWidth(), capabilities.getHeight(),
+                        ImageFormat.YUV_420_888, capabilities.getFps())
+                .setVirtualCameraCallback(MoreExecutors.directExecutor(),
+                        new RemoteCamera(cameraId))
+                .setLensFacing(lensFacing)
+                .setSensorOrientation(capabilities.getSensorOrientation())
+                .build();
+        VirtualCamera camera = mVirtualDevice.createVirtualCamera(config);
+        mVirtualCameras.put(cameraId, camera);
+
+        Log.d(TAG, "Created virtual camera from client cameraId: " + cameraId
+                + " with name: " + camera.getConfig().getName()
+                + " and lensFacing: " + lensFacing);
+    }
+
     @Override
     public void close() {
         for (int i = 0; i < mVirtualCameras.size(); ++i) {
diff --git a/samples/VirtualDeviceManager/host/src/com/example/android/vdmdemo/host/RemoteDisplay.java b/samples/VirtualDeviceManager/host/src/com/example/android/vdmdemo/host/RemoteDisplay.java
index f060d5427..8a71cef31 100644
--- a/samples/VirtualDeviceManager/host/src/com/example/android/vdmdemo/host/RemoteDisplay.java
+++ b/samples/VirtualDeviceManager/host/src/com/example/android/vdmdemo/host/RemoteDisplay.java
@@ -86,6 +86,8 @@ class RemoteDisplay implements AutoCloseable {
     private static final String TAG = "VdmHost";
 
     private static final int DISPLAY_FPS = 60;
+    // Froce lower DPI on desktop displays to simulate large screen experience.
+    private static final int MAX_DESKTOP_DPI = 180;
 
     private static final int DEFAULT_VIRTUAL_DISPLAY_FLAGS =
             DisplayManager.VIRTUAL_DISPLAY_FLAG_TRUSTED
@@ -98,7 +100,9 @@ class RemoteDisplay implements AutoCloseable {
     static final int DISPLAY_TYPE_APP = 0;
     static final int DISPLAY_TYPE_HOME = 1;
     static final int DISPLAY_TYPE_MIRROR = 2;
-    @IntDef(value = {DISPLAY_TYPE_APP, DISPLAY_TYPE_HOME, DISPLAY_TYPE_MIRROR})
+    static final int DISPLAY_TYPE_DESKTOP = 3;
+    @IntDef(value = {DISPLAY_TYPE_APP, DISPLAY_TYPE_HOME, DISPLAY_TYPE_MIRROR,
+            DISPLAY_TYPE_DESKTOP})
     @Retention(RetentionPolicy.SOURCE)
     public @interface DisplayType {}
 
@@ -183,6 +187,9 @@ class RemoteDisplay implements AutoCloseable {
         if (mContext.checkCallingOrSelfPermission(ADD_TRUSTED_DISPLAY)
                 == PackageManager.PERMISSION_DENIED) {
             flags &= ~DisplayManager.VIRTUAL_DISPLAY_FLAG_TRUSTED;
+        } else if (mDisplayType == DISPLAY_TYPE_DESKTOP) {
+            // TODO(b/261155110): Use a proper API.
+            flags |= VdmCompat.VIRTUAL_DISPLAY_FLAG_SHOULD_SHOW_SYSTEM_DECORATIONS;
         }
 
         Set<String> displayCategories;
@@ -305,6 +312,9 @@ class RemoteDisplay implements AutoCloseable {
         mWidth = width;
         mHeight = height;
         mDpi = dpi;
+        if (mDisplayType == DISPLAY_TYPE_DESKTOP) {
+            mDpi = Math.min(MAX_DESKTOP_DPI, mDpi);
+        }
 
         if (mRemoteIo != null) {
             // Video encoder needs round dimensions...
diff --git a/samples/VirtualDeviceManager/host/src/com/example/android/vdmdemo/host/VdmCompat.java b/samples/VirtualDeviceManager/host/src/com/example/android/vdmdemo/host/VdmCompat.java
index 1f63e8638..d89c3e5a9 100644
--- a/samples/VirtualDeviceManager/host/src/com/example/android/vdmdemo/host/VdmCompat.java
+++ b/samples/VirtualDeviceManager/host/src/com/example/android/vdmdemo/host/VdmCompat.java
@@ -33,7 +33,7 @@ import androidx.core.os.BuildCompat;
 public class VdmCompat {
 
     // Hidden DisplayManager.VIRTUAL_DISPLAY_FLAG_SHOULD_SHOW_SYSTEM_DECORATIONS.
-    private static final int VIRTUAL_DISPLAY_FLAG_SHOULD_SHOW_SYSTEM_DECORATIONS = 1 << 9;
+    static final int VIRTUAL_DISPLAY_FLAG_SHOULD_SHOW_SYSTEM_DECORATIONS = 1 << 9;
 
     private VdmCompat() {}
 
@@ -72,9 +72,6 @@ public class VdmCompat {
         if (!preferenceController.getBoolean(R.string.internal_pref_mirror_displays_supported)) {
             return false;
         }
-        if (preferenceController.getBoolean(R.string.pref_standalone_host_demo)) {
-            return false;
-        }
         if (isAtLeastB() && Flags.enableLimitedVdmRole()) {
             return context.checkCallingOrSelfPermission(ADD_MIRROR_DISPLAY)
                     == PackageManager.PERMISSION_GRANTED;
diff --git a/samples/VirtualDeviceManager/host/src/com/example/android/vdmdemo/host/VdmService.java b/samples/VirtualDeviceManager/host/src/com/example/android/vdmdemo/host/VdmService.java
index 234a4cd74..9a8d9fea0 100644
--- a/samples/VirtualDeviceManager/host/src/com/example/android/vdmdemo/host/VdmService.java
+++ b/samples/VirtualDeviceManager/host/src/com/example/android/vdmdemo/host/VdmService.java
@@ -330,6 +330,7 @@ public final class VdmService extends Hilt_VdmService {
 
         mKeyguardManager = getSystemService(KeyguardManager.class);
         mDisplayManager = getSystemService(DisplayManager.class);
+
         Objects.requireNonNull(mDisplayManager).registerDisplayListener(mDisplayListener, null);
 
         mPreferenceController.addPreferenceObserver(this, mPreferenceObservers);
@@ -621,7 +622,9 @@ public final class VdmService extends Hilt_VdmService {
             virtualDeviceBuilder.setDevicePolicy(POLICY_TYPE_SENSORS, DEVICE_POLICY_CUSTOM);
         }
 
-        if (mPreferenceController.getBoolean(R.string.pref_enable_client_camera)) {
+        final String cameraPolicy = mPreferenceController.getString(R.string.pref_camera_policy);
+        if (cameraPolicy.equals(getString(R.string.no_cameras)) || cameraPolicy.equals(
+                getString(R.string.client_cameras))) {
             virtualDeviceBuilder.setDevicePolicy(POLICY_TYPE_CAMERA, DEVICE_POLICY_CUSTOM);
         }
 
@@ -646,12 +649,15 @@ public final class VdmService extends Hilt_VdmService {
                 new RunningVdmUidsTracker(getApplicationContext(), mPreferenceController,
                         mAudioStreamer, mAudioInjector));
 
-        if (mPreferenceController.getBoolean(R.string.pref_enable_client_camera)) {
+        if (!cameraPolicy.equals(getString(R.string.no_cameras))) {
             if (mRemoteCameraManager != null) {
                 mRemoteCameraManager.close();
             }
             mRemoteCameraManager = new RemoteCameraManager(mVirtualDevice, mRemoteIo);
-            mRemoteCameraManager.createCameras(mDeviceCapabilities.getCameraCapabilitiesList());
+            mRemoteCameraManager.createCameras(mDeviceCapabilities.getCameraCapabilitiesList(),
+                    cameraPolicy.equals(getString(R.string.client_cameras)),
+                    mPreferenceController.getBoolean(R.string.pref_duplicate_front_camera),
+                    mPreferenceController.getBoolean(R.string.pref_duplicate_back_camera));
         }
 
         handleAudioCapabilities();
@@ -701,6 +707,10 @@ public final class VdmService extends Hilt_VdmService {
         startStreaming(null, RemoteDisplay.DISPLAY_TYPE_MIRROR);
     }
 
+    void startDesktop() {
+        startStreaming(null, RemoteDisplay.DISPLAY_TYPE_DESKTOP);
+    }
+
     void startStreaming(Intent intent) {
         startStreaming(intent, RemoteDisplay.DISPLAY_TYPE_APP);
     }
@@ -722,8 +732,7 @@ public final class VdmService extends Hilt_VdmService {
             return;
         }
 
-        boolean homeEnabled = mPendingDisplayType == RemoteDisplay.DISPLAY_TYPE_HOME
-                || mPendingDisplayType == RemoteDisplay.DISPLAY_TYPE_MIRROR;
+        boolean homeEnabled = mPendingDisplayType != RemoteDisplay.DISPLAY_TYPE_APP;
         mRemoteIo.sendMessage(RemoteEvent.newBuilder()
                 .setStartStreaming(StartStreaming.newBuilder()
                         .setHomeEnabled(homeEnabled)
@@ -809,7 +818,14 @@ public final class VdmService extends Hilt_VdmService {
                                 displayId -> mVirtualDevice.setDisplayImePolicy(displayId, policy));
                     }
                 });
-        observers.put(R.string.pref_enable_client_camera, v -> recreateVirtualDevice());
+        observers.put(R.string.pref_camera_policy, s -> {
+            // reset the state of the camera preferences dependencies
+            if (s.equals(getString(R.string.no_cameras))) {
+                mPreferenceController.setBoolean(R.string.pref_duplicate_front_camera, false);
+                mPreferenceController.setBoolean(R.string.pref_duplicate_back_camera, false);
+            }
+            recreateVirtualDevice();
+        });
         observers.put(R.string.pref_enable_client_sensors, v -> recreateVirtualDevice());
         observers.put(R.string.pref_device_profile, v -> recreateVirtualDevice());
         observers.put(R.string.pref_always_unlocked_device, v -> recreateVirtualDevice());
@@ -817,6 +833,8 @@ public final class VdmService extends Hilt_VdmService {
         observers.put(R.string.pref_enable_custom_home, v -> recreateVirtualDevice());
         observers.put(R.string.pref_display_timeout, v -> recreateVirtualDevice());
         observers.put(R.string.pref_enable_display_category, v -> recreateVirtualDevice());
+        observers.put(R.string.pref_duplicate_front_camera, v -> recreateVirtualDevice());
+        observers.put(R.string.pref_duplicate_back_camera, v -> recreateVirtualDevice());
         observers.put(R.string.pref_network_channel, s -> {
             if (!mPreferenceController.getBoolean(R.string.pref_standalone_host_demo)) {
                 mConnectionManager.disconnect();
diff --git a/sdk/platform_source.prop_template b/sdk/platform_source.prop_template
index fa996c7e3..34766b781 100644
--- a/sdk/platform_source.prop_template
+++ b/sdk/platform_source.prop_template
@@ -2,7 +2,7 @@ Pkg.Desc=Android SDK Platform ${PLATFORM_VERSION}
 Pkg.UserSrc=false
 Platform.Version=${PLATFORM_VERSION}
 Platform.CodeName=
-Pkg.Revision=1
+Pkg.Revision=2
 AndroidVersion.ApiLevel=${PLATFORM_SDK_VERSION}
 AndroidVersion.CodeName=${PLATFORM_VERSION_CODENAME}
 AndroidVersion.ExtensionLevel=${PLATFORM_SDK_EXTENSION_VERSION}
diff --git a/tools/cargo_embargo/regenerate_all.sh b/tools/cargo_embargo/regenerate_all.sh
index 966faee1a..6acd1dc80 100755
--- a/tools/cargo_embargo/regenerate_all.sh
+++ b/tools/cargo_embargo/regenerate_all.sh
@@ -17,7 +17,7 @@
 # Helper script to run cargo_embargo generate on all external Rust crates and generate an HTML
 # report of the results, including any errors, warnings or changes to Android.bp files.
 #
-# Should be run from under external/rust/crates.
+# Should be run from under external/rust/android-crates-io.
 
 set -e
 
@@ -45,7 +45,7 @@ END
 success_count=0
 different_count=0
 total_count=0
-for config in */cargo_embargo.json; do
+for config in $(find . -name cargo_embargo.json | sort); do
   ((total_count+=1))
   crate=$(dirname $config)
   echo "Trying $crate..."
@@ -61,7 +61,7 @@ for config in */cargo_embargo.json; do
       echo '</details></td>' >> $report
     else
       # Compare the checked-in Android.bp to the generated one.
-      (cd $crate && git show HEAD:Android.bp > Android.bp.orig)
+      (cd $crate && git show HEAD:./Android.bp > Android.bp.orig)
       if diff $crate/Android.bp.orig $crate/Android.bp > /dev/null; then
         echo '<td class="success">Success</td>' >> $report
         ((success_count+=1))
@@ -86,7 +86,7 @@ for config in */cargo_embargo.json; do
   fi
 
   rm cargo_embargo.err
-  rm -rf "$crate/cargo.metadata" "$crate/cargo.out" "$crate/target.tmp" "$crate/Cargo.lock" "$crate/Android.bp.orig" "$crate/Android.bp.embargo" "$crate/Android.bp.embargo_nobuild"
+  rm -rf "$crate/cargo.metadata" "$crate/cargo.out" "$crate/target.tmp" "$crate/Android.bp.orig" "$crate/Android.bp.embargo" "$crate/Android.bp.embargo_nobuild"
   (cd $crate && git checkout Android.bp)
 
   echo '<td>' >> $report
diff --git a/tools/cargo_embargo/src/main.rs b/tools/cargo_embargo/src/main.rs
index 679f64526..a212dc1ea 100644
--- a/tools/cargo_embargo/src/main.rs
+++ b/tools/cargo_embargo/src/main.rs
@@ -781,6 +781,7 @@ fn choose_licenses(license: &str) -> Result<Vec<&str>> {
         // Variations on "Zlib OR MIT OR Apache-2.0"
         "Zlib OR Apache-2.0 OR MIT" => vec!["Apache-2.0"],
         "MIT OR Apache-2.0 OR Zlib" => vec!["Apache-2.0"],
+        "MIT OR Zlib OR Apache-2.0" => vec!["Apache-2.0"],
 
         // Variations on "Apache-2.0 OR *"
         "Apache-2.0 OR BSL-1.0" => vec!["Apache-2.0"],
@@ -1082,8 +1083,15 @@ fn crate_to_bp_modules(
         }
         m.props.set("name", module_name.clone());
 
-        if let Some(defaults) = &cfg.global_defaults {
-            m.props.set("defaults", vec![defaults.clone()]);
+        let mut defaults = Vec::<String>::new();
+        if package_cfg.no_std {
+            defaults.push("rust_baremetal_defaults".to_string());
+        }
+        if let Some(global_defaults) = &cfg.global_defaults {
+            defaults.push(global_defaults.clone());
+        }
+        if !defaults.is_empty() {
+            m.props.set("defaults", defaults);
         }
 
         if package_cfg.host_supported
diff --git a/tools/crate-updater/src/main.rs b/tools/crate-updater/src/main.rs
index 0b2afc1a1..cdb7adae4 100644
--- a/tools/crate-updater/src/main.rs
+++ b/tools/crate-updater/src/main.rs
@@ -28,7 +28,7 @@ use serde::Deserialize;
 
 #[derive(Parser)]
 struct Cli {
-    /// Absolute path to a repo checkout of aosp-main.
+    /// Absolute path to a repo checkout of main-without-vendor.
     /// It is strongly recommended that you use a source tree dedicated to
     /// running this updater.
     android_root: PathBuf,
@@ -96,7 +96,7 @@ fn cleanup_and_sync_monorepo(monorepo_path: &Path) -> Result<()> {
         .run_and_stream_output()?;
 
     Command::new("git")
-        .args(["checkout", "aosp/main"])
+        .args(["checkout", "goog/main"])
         .current_dir(monorepo_path)
         .run_and_stream_output()?;
 
@@ -132,7 +132,7 @@ fn sync_to_green(monorepo_path: &Path) -> Result<()> {
     let output = Command::new("/google/data/ro/projects/android/ab")
         .args([
             "lkgb",
-            "--branch=aosp-main",
+            "--branch=git_main-without-vendor",
             "--target=aosp_arm64-trunk_staging-userdebug",
             "--raw",
             "--custom_raw_format={o[buildId]}",
@@ -209,7 +209,7 @@ fn try_update(
         .args([
             "-c",
             format!(
-                "source {}/build/envsetup.sh && lunch aosp_husky-trunk_staging-eng && mm && m rust",
+                "source {}/build/envsetup.sh && lunch aosp_cf_x86_64_phone-trunk_staging-eng && mm && m rust",
                 android_root.display()
             )
             .as_str(),
@@ -283,7 +283,7 @@ fn main() -> Result<()> {
     Command::new("/usr/bin/bash")
         .args([
             "-c",
-            "source build/envsetup.sh && lunch aosp_husky-trunk_staging-eng && m cargo_embargo",
+            "source build/envsetup.sh && lunch aosp_cf_x86_64_phone-trunk_staging-eng && m cargo_embargo",
         ])
         .env_remove("OUT_DIR")
         .current_dir(&args.android_root)
diff --git a/tools/external_crates/Cargo.toml b/tools/external_crates/Cargo.toml
index 88bc2f544..3f0c9b902 100644
--- a/tools/external_crates/Cargo.toml
+++ b/tools/external_crates/Cargo.toml
@@ -1,5 +1,6 @@
 [workspace]
 members = [
+    "bp_util",
     "checksum",
     "crate_config",
     "crate_tool",
@@ -9,6 +10,7 @@ members = [
     "name_and_version",
     "repo_config",
     "rooted_path",
+    "success_or_error",
     "test_mapping",
 ]
 resolver = "2"
diff --git a/tools/external_crates/bp_util/Android.bp b/tools/external_crates/bp_util/Android.bp
new file mode 100644
index 000000000..b7f415a64
--- /dev/null
+++ b/tools/external_crates/bp_util/Android.bp
@@ -0,0 +1,40 @@
+// This file is generated by cargo_embargo.
+// Do not modify this file after the first "rust_*" or "genrule" module
+// because the changes will be overridden on upgrade.
+// Content before the first "rust_*" or "genrule" module is preserved.
+
+package {
+    default_team: "trendy_team_android_rust",
+    default_applicable_licenses: ["Android-Apache-2.0"],
+}
+
+rust_test_host {
+    name: "bp_util_test_src_lib",
+    crate_name: "bp_util",
+    cargo_env_compat: true,
+    cargo_pkg_version: "0.1.0",
+    crate_root: "src/lib.rs",
+    test_suites: ["general-tests"],
+    auto_gen_config: true,
+    test_options: {
+        unit_test: true,
+    },
+    edition: "2021",
+    rustlibs: [
+        "libandroid_bp",
+        "libthiserror",
+    ],
+}
+
+rust_library_host {
+    name: "libbp_util",
+    crate_name: "bp_util",
+    cargo_env_compat: true,
+    cargo_pkg_version: "0.1.0",
+    crate_root: "src/lib.rs",
+    edition: "2021",
+    rustlibs: [
+        "libandroid_bp",
+        "libthiserror",
+    ],
+}
diff --git a/tools/external_crates/bp_util/Cargo.toml b/tools/external_crates/bp_util/Cargo.toml
new file mode 100644
index 000000000..2e2a06a99
--- /dev/null
+++ b/tools/external_crates/bp_util/Cargo.toml
@@ -0,0 +1,8 @@
+[package]
+name = "bp_util"
+version = "0.1.0"
+edition = "2021"
+
+[dependencies]
+android_bp = "0.3"
+thiserror = "1.0"
\ No newline at end of file
diff --git a/tools/external_crates/bp_util/src/lib.rs b/tools/external_crates/bp_util/src/lib.rs
new file mode 100644
index 000000000..0aee78a80
--- /dev/null
+++ b/tools/external_crates/bp_util/src/lib.rs
@@ -0,0 +1,341 @@
+// Copyright (C) 2024 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! Convenience methods for working with Android blueprint files.
+
+use std::{
+    collections::{BTreeSet, HashSet},
+    sync::LazyLock,
+};
+
+use android_bp::{BluePrint, Value};
+
+/// Error types for the 'bp_util' crate.
+#[derive(thiserror::Error, Debug)]
+pub enum Error {
+    /// Blueprint rule has no name
+    #[error("Blueprint rule has no name")]
+    RuleWithoutName(String),
+}
+
+/// Extract rust test rules from a blueprint file.
+pub trait RustTests {
+    /// Returns the names of all rust_test and rust_test_host rules.
+    fn rust_tests(&self) -> Result<BTreeSet<&str>, Error>;
+}
+
+impl RustTests for BluePrint {
+    fn rust_tests(&self) -> Result<BTreeSet<&str>, Error> {
+        let mut tests = BTreeSet::new();
+        for module in &self.modules {
+            if matches!(module.typ.as_str(), "rust_test" | "rust_test_host") {
+                let name = module
+                    .get_string("name")
+                    .ok_or(Error::RuleWithoutName(module.typ.clone()))?
+                    .as_str();
+                if !EXCLUDED_TESTS.contains(name) {
+                    tests.insert(name);
+                }
+            }
+        }
+        Ok(tests)
+    }
+}
+
+/// Finds all the rustlib dependencies mentioned in a blueprint file.
+pub trait RustDeps {
+    /// Finds all the rustlibs mentioned in a blueprint file.
+    /// This does a limited amount of evaluation, by doing concatenation and resolving
+    /// identifiers. So you can have `common_rustlibs = ["foo", "bar"] and do
+    /// rust_library { rustlibs = common_rustlibs + ["baz"] }`
+    fn rust_deps(&self) -> BTreeSet<&str>;
+}
+
+impl RustDeps for BluePrint {
+    fn rust_deps(&self) -> BTreeSet<&str> {
+        let mut rustlibs = BTreeSet::new();
+        for module in &self.modules {
+            if let Some(v) = module.get("rustlibs") {
+                match v {
+                    Value::Array(_) => rustlibs.extend(v.as_strs()),
+                    Value::ConcatExpr(_) => rustlibs.extend(v.eval(self)),
+                    _ => {
+                        println!("Only know how to handle Array and ConcatExpr");
+                    }
+                }
+            }
+        }
+        rustlibs
+    }
+}
+
+/// Convenience accessor for arrays of strings.
+pub trait AsStringVec {
+    /// Interpret a android_bp::Value as an array of strings, and convert it to
+    /// an array of &str's. Any element that isn't a string is skipped.
+    fn as_strs(&self) -> Vec<&str>;
+}
+
+impl AsStringVec for Value {
+    fn as_strs(&self) -> Vec<&str> {
+        if let Value::Array(vec) = self {
+            vec.iter()
+                .filter_map(|v| match v {
+                    Value::String(s) => Some(s.as_str()),
+                    _ => {
+                        println!("Array element is not a string");
+                        None
+                    }
+                })
+                .collect()
+        } else {
+            println!("Value is not an array");
+            vec![]
+        }
+    }
+}
+
+/// Evaluate concatenations and resolve identifiers.
+trait EvalConcat {
+    /// Evaluate a concatenation expression, resolving it into a single vector of strings.
+    /// The elements being concatenated are assumed to be either identifiers or
+    /// arrays of strings. Otherwise, they are skipped.
+    fn eval<'a>(&'a self, bp: &'a BluePrint) -> Vec<&'a str>;
+}
+
+impl EvalConcat for Value {
+    fn eval<'a>(&'a self, bp: &'a BluePrint) -> Vec<&'a str> {
+        let mut strings = Vec::new();
+        if let Value::ConcatExpr(expr) = self {
+            for term in expr {
+                match term {
+                    Value::Array(_) => strings.extend(term.as_strs()),
+                    Value::Ident(ident) => {
+                        if let Some(ident_val) = bp.variables.get(ident) {
+                            strings.extend(ident_val.as_strs());
+                        }
+                    }
+                    _ => {
+                        println!("Concat term is neither ident nor array");
+                    }
+                }
+            }
+        } else {
+            println!("Value is not a ConcatExpr");
+        }
+        strings
+    }
+}
+
+/// Find the names of Rust library targets
+pub trait RustLibs {
+    /// Returns the name of all Rust library targets in the blueprint.
+    fn rust_libs(&self) -> Result<Vec<&str>, Error>;
+}
+
+impl RustLibs for BluePrint {
+    fn rust_libs(&self) -> Result<Vec<&str>, Error> {
+        let mut libs = Vec::new();
+        for module in &self.modules {
+            if matches!(
+                module.typ.as_str(),
+                "rust_library" | "rust_library_rlib" | "rust_library_host" | "rust_proc_macro"
+            ) {
+                libs.push(
+                    module
+                        .get_string("name")
+                        .ok_or(Error::RuleWithoutName(module.typ.clone()))?
+                        .as_str(),
+                );
+            }
+        }
+        Ok(libs)
+    }
+}
+
+/// Trait for determining the features enabled for a Rust crate.
+pub trait CrateFeatures {
+    /// Return the features enabled for all crate variants in the Blueprint.
+    fn crate_features<'a>(
+        &'a self,
+        crate_name: impl AsRef<str> + 'a,
+    ) -> impl Iterator<Item = Option<Vec<&'a str>>>;
+    /// Returns true if a feature is enabled for any build variant of the crate.
+    fn is_enabled(&self, crate_name: impl AsRef<str>, feature: impl AsRef<str>) -> bool {
+        self.crate_features(crate_name).any(|variant_features| {
+            variant_features.is_some_and(|features| features.contains(&feature.as_ref()))
+        })
+    }
+}
+
+impl CrateFeatures for BluePrint {
+    fn crate_features<'a>(
+        &'a self,
+        crate_name: impl AsRef<str> + 'a,
+    ) -> impl Iterator<Item = Option<Vec<&'a str>>> {
+        let crate_name = crate_name.as_ref().to_string();
+        self.modules.iter().filter_map(move |m| {
+            if m.get_string("crate_name").is_some_and(|c| *c == crate_name) {
+                Some(m.get("features").map(|v| v.as_strs()))
+            } else {
+                None
+            }
+        })
+    }
+}
+
+// Taken from update_crate_tests.py
+static EXCLUDED_TESTS: LazyLock<HashSet<&'static str>> = LazyLock::new(|| {
+    HashSet::from([
+        "ash_test_src_lib",
+        "ash_test_tests_constant_size_arrays",
+        "ash_test_tests_display",
+        "shared_library_test_src_lib",
+        "vulkano_test_src_lib",
+        // These are helper binaries for aidl_integration_test
+        // and aren't actually meant to run as individual tests.
+        "aidl_test_rust_client",
+        "aidl_test_rust_service",
+        "aidl_test_rust_service_async",
+        // This is a helper binary for AuthFsHostTest and shouldn't
+        // be run directly.
+        "open_then_run",
+        // TODO: Remove when b/198197213 is closed.
+        "diced_client_test",
+        "CoverageRustSmokeTest",
+        "libtrusty-rs-tests",
+        "terminal-size_test_src_lib",
+    ])
+});
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn rust_tests() -> Result<(), Error> {
+        let bp = BluePrint::parse(
+            r###"
+rust_test { name: "foo" }
+rust_test_host { name: "bar" }
+"###,
+        )
+        .expect("Blueprint parse error");
+        assert_eq!(bp.rust_tests()?, BTreeSet::from(["foo", "bar"]));
+        Ok(())
+    }
+
+    #[test]
+    fn rust_deps() {
+        let bp = BluePrint::parse(
+            r###"
+rust_library { rustlibs: ["foo", "bar"] }
+rust_library { rustlibs: ["bar", "baz"] }
+"###,
+        )
+        .expect("Blueprint parse error");
+        assert_eq!(bp.rust_deps(), BTreeSet::from(["foo", "bar", "baz"]));
+    }
+
+    #[test]
+    fn rust_deps_eval() {
+        let bp = BluePrint::parse(
+            r###"
+foo = ["foo"]
+rust_library { rustlibs: foo + ["bar"] }
+"###,
+        )
+        .expect("Blueprint parse error");
+        assert_eq!(bp.rust_deps(), BTreeSet::from(["foo", "bar"]));
+    }
+
+    #[test]
+    fn rust_libs() -> Result<(), Error> {
+        let bp = BluePrint::parse(
+            r###"
+rust_library { name: "foo" }
+"###,
+        )
+        .expect("Blueprint parse error");
+        assert_eq!(bp.rust_libs()?, vec!["foo"]);
+        Ok(())
+    }
+
+    #[test]
+    fn features() {
+        let bp = BluePrint::parse(
+            r###"
+rust_library { crate_name: "foo" }
+"###,
+        )
+        .expect("Blueprint parse error");
+        assert_eq!(
+            bp.crate_features("foo").collect::<Vec<_>>(),
+            vec![None],
+            "Missing features array returns None"
+        );
+
+        let bp = BluePrint::parse(
+            r###"
+rust_library { crate_name: "foo", features: [] }
+"###,
+        )
+        .expect("Blueprint parse error");
+        assert_eq!(
+            bp.crate_features("foo").collect::<Vec<_>>(),
+            vec![Some(Vec::new())],
+            "Empty features array is preserved"
+        );
+
+        let bp = BluePrint::parse(
+            r###"
+rust_library { crate_name: "foo", features: ["foo"] }
+rust_library { crate_name: "bar", features: ["bar"] }
+"###,
+        )
+        .expect("Blueprint parse error");
+        assert_eq!(
+            bp.crate_features("foo").collect::<Vec<_>>(),
+            vec![Some(vec!["foo"])],
+            "Crate name must match"
+        );
+
+        let bp = BluePrint::parse(
+            r###"
+rust_library { crate_name: "foo", features: ["foo1"] }
+rust_library { crate_name: "foo", features: ["foo2"] }
+"###,
+        )
+        .expect("Blueprint parse error");
+        assert_eq!(
+            bp.crate_features("foo").collect::<Vec<_>>(),
+            vec![Some(vec!["foo1"]), Some(vec!["foo2"])],
+            "Multiple variants of the same crate each return a list of features"
+        );
+    }
+
+    #[test]
+    fn feature_is_enabled() {
+        let bp = BluePrint::parse(
+            r###"
+rust_library { crate_name: "foo", features: ["bar"] }
+rust_library { crate_name: "foo", features: ["baz"] }
+"###,
+        )
+        .expect("Blueprint parse error");
+        assert!(bp.is_enabled("foo", "bar"));
+        assert!(bp.is_enabled("foo", "baz"));
+        assert!(!bp.is_enabled("foo", "qux"));
+    }
+}
diff --git a/tools/external_crates/cargo_embargo.json b/tools/external_crates/cargo_embargo.json
index 350518f6b..b8a88e6b9 100644
--- a/tools/external_crates/cargo_embargo.json
+++ b/tools/external_crates/cargo_embargo.json
@@ -1,11 +1,20 @@
 {
   "package": {
+    "bp_util": {
+      "device_supported": false
+    },
     "checksum": {
       "device_supported": false
     },
     "crate_config": {
       "device_supported": false
     },
+    "crate_tool": {
+      "device_supported": false
+    },
+    "crates_io_util": {
+      "device_supported": false
+    },
     "rooted_path": {
       "device_supported": false
     },
@@ -23,14 +32,13 @@
     "repo_config": {
       "device_supported": false
     },
+    "success_or_error": {
+      "device_supported": false
+    },
     "test_mapping": {
       "device_supported": false
     }
   },
   "tests": true,
-  "workspace": true,
-  "workspace_excludes": [
-    "crate_tool",
-    "crates_io_util"
-  ]
+  "workspace": true
 }
diff --git a/tools/external_crates/crate_tool/Android.bp b/tools/external_crates/crate_tool/Android.bp
new file mode 100644
index 000000000..4c702281b
--- /dev/null
+++ b/tools/external_crates/crate_tool/Android.bp
@@ -0,0 +1,175 @@
+// This file is generated by cargo_embargo.
+// Do not modify this file after the first "rust_*" or "genrule" module
+// because the changes will be overridden on upgrade.
+// Content before the first "rust_*" or "genrule" module is preserved.
+
+package {
+    default_team: "trendy_team_android_rust",
+    default_applicable_licenses: ["Android-Apache-2.0"],
+}
+
+rust_binary_host {
+    name: "crate_tool",
+    crate_name: "crate_tool",
+    cargo_env_compat: true,
+    cargo_pkg_version: "0.1.0",
+    crate_root: "src/main.rs",
+    edition: "2021",
+    rustlibs: [
+        "libanyhow",
+        "libcargo_toml",
+        "libcfg_expr",
+        "libchecksum",
+        "libchrono",
+        "libclap",
+        "libcrate_config",
+        "libcrate_tool",
+        "libcrates_index",
+        "libcrates_io_util",
+        "libenv_logger",
+        "libglob",
+        "libgoogle_metadata",
+        "libitertools",
+        "liblicense_checker",
+        "liblog_rust",
+        "libname_and_version",
+        "libprotobuf",
+        "librepo_config",
+        "librooted_path",
+        "libsemver",
+        "libserde",
+        "libserde_json",
+        "libspdx",
+        "libsuccess_or_error",
+        "libtest_mapping",
+        "libthiserror",
+        "libwalkdir",
+    ],
+}
+
+rust_test_host {
+    name: "crate_tool_test_src_lib",
+    crate_name: "crate_tool",
+    cargo_env_compat: true,
+    cargo_pkg_version: "0.1.0",
+    crate_root: "src/lib.rs",
+    test_suites: ["general-tests"],
+    auto_gen_config: true,
+    test_options: {
+        unit_test: true,
+    },
+    edition: "2021",
+    rustlibs: [
+        "libanyhow",
+        "libcargo_toml",
+        "libcfg_expr",
+        "libchecksum",
+        "libchrono",
+        "libclap",
+        "libcrate_config",
+        "libcrates_index",
+        "libcrates_io_util",
+        "libenv_logger",
+        "libglob",
+        "libgoogle_metadata",
+        "libitertools",
+        "liblicense_checker",
+        "liblog_rust",
+        "libname_and_version",
+        "libprotobuf",
+        "librepo_config",
+        "librooted_path",
+        "libsemver",
+        "libserde",
+        "libserde_json",
+        "libspdx",
+        "libsuccess_or_error",
+        "libtempfile",
+        "libtest_mapping",
+        "libthiserror",
+        "libwalkdir",
+    ],
+}
+
+rust_test_host {
+    name: "crate_tool_test_tests_integration_test",
+    crate_name: "integration_test",
+    cargo_env_compat: true,
+    cargo_pkg_version: "0.1.0",
+    crate_root: "tests/integration_test.rs",
+    test_suites: ["general-tests"],
+    auto_gen_config: true,
+    test_options: {
+        unit_test: true,
+    },
+    edition: "2021",
+    rustlibs: [
+        "libanyhow",
+        "libcargo_toml",
+        "libcfg_expr",
+        "libchecksum",
+        "libchrono",
+        "libclap",
+        "libcrate_config",
+        "libcrate_tool",
+        "libcrates_index",
+        "libcrates_io_util",
+        "libenv_logger",
+        "libglob",
+        "libgoogle_metadata",
+        "libitertools",
+        "liblicense_checker",
+        "liblog_rust",
+        "libname_and_version",
+        "libprotobuf",
+        "librepo_config",
+        "librooted_path",
+        "libsemver",
+        "libserde",
+        "libserde_json",
+        "libspdx",
+        "libsuccess_or_error",
+        "libtempfile",
+        "libtest_mapping",
+        "libthiserror",
+        "libwalkdir",
+    ],
+}
+
+rust_library_host {
+    name: "libcrate_tool",
+    crate_name: "crate_tool",
+    cargo_env_compat: true,
+    cargo_pkg_version: "0.1.0",
+    crate_root: "src/lib.rs",
+    edition: "2021",
+    rustlibs: [
+        "libanyhow",
+        "libcargo_toml",
+        "libcfg_expr",
+        "libchecksum",
+        "libchrono",
+        "libclap",
+        "libcrate_config",
+        "libcrates_index",
+        "libcrates_io_util",
+        "libenv_logger",
+        "libglob",
+        "libgoogle_metadata",
+        "libitertools",
+        "liblicense_checker",
+        "liblog_rust",
+        "libname_and_version",
+        "libprotobuf",
+        "librepo_config",
+        "librooted_path",
+        "libsemver",
+        "libserde",
+        "libserde_json",
+        "libspdx",
+        "libsuccess_or_error",
+        "libtest_mapping",
+        "libthiserror",
+        "libwalkdir",
+    ],
+}
diff --git a/tools/external_crates/crate_tool/Cargo.toml b/tools/external_crates/crate_tool/Cargo.toml
index 60b1bcdf4..36a058fd0 100644
--- a/tools/external_crates/crate_tool/Cargo.toml
+++ b/tools/external_crates/crate_tool/Cargo.toml
@@ -7,20 +7,21 @@ edition = "2021"
 
 [dependencies]
 anyhow = "1"
-cargo_metadata = "0.19"
+cargo_toml = "0.22"
 cfg-expr = "0.17"
 chrono = "0.4"
 clap = { version = "4.4.6", features = ["derive"] }
-crates-index = "3.2.0"
+crates-index = "3.8"
+env_logger = "0.10"
 glob = "0.3"
 itertools = "0.11"
+log = "0.4"
 protobuf = "3"
 semver = "1"
 # TODO: Unpin once https://github.com/serde-rs/serde/issues/2844 is resolved.
 serde = { version = "=1.0.210", features = ["derive"] }
 serde_json = "1"
 spdx = "0.10"
-ureq = "3"
 thiserror = "1"
 walkdir = "2"
 checksum = { path = "../checksum" }
@@ -31,11 +32,11 @@ license_checker = { path = "../license_checker" }
 name_and_version = { path = "../name_and_version" }
 repo_config = { path = "../repo_config" }
 rooted_path = { path = "../rooted_path" }
+success_or_error = { path = "../success_or_error" }
 test_mapping = { path = "../test_mapping" }
 
-[build-dependencies]
-protobuf-codegen = "3"
-protobuf-parse = "3"
-
 [dev-dependencies]
 tempfile = "3"
+
+[lints.rust]
+unexpected_cfgs = { level = "warn", check-cfg = ['cfg(soong)'] }
\ No newline at end of file
diff --git a/tools/external_crates/crate_tool/src/android_bp.rs b/tools/external_crates/crate_tool/src/android_bp.rs
index cf42fa3b4..5c0cd50d8 100644
--- a/tools/external_crates/crate_tool/src/android_bp.rs
+++ b/tools/external_crates/crate_tool/src/android_bp.rs
@@ -22,8 +22,7 @@ use std::{
 
 use anyhow::{Context, Result};
 use rooted_path::RootedPath;
-
-use crate::SuccessOrError;
+use success_or_error::SuccessOrError;
 
 fn add_bpfmt_to_path(repo_root: impl AsRef<Path>) -> Result<OsString> {
     let host_bin = repo_root.as_ref().join("prebuilts/build-tools/linux-x86/bin");
@@ -71,6 +70,7 @@ pub fn cargo_embargo_autoconfig(path: &RootedPath) -> Result<Output> {
         .context(format!("Failed to execute {:?}", cmd.get_program()))
 }
 
+/// Rebuilds cargo_embargo if it hasn't been built recently, or `force_rebuild` is true.
 pub fn maybe_build_cargo_embargo(repo_root: &impl AsRef<Path>, force_rebuild: bool) -> Result<()> {
     let cargo_embargo = repo_root.as_ref().join("out/host/linux-x86/bin/cargo_embargo");
     if force_rebuild
@@ -84,7 +84,7 @@ pub fn maybe_build_cargo_embargo(repo_root: &impl AsRef<Path>, force_rebuild: bo
     Ok(())
 }
 
-pub fn build_cargo_embargo(repo_root: &impl AsRef<Path>) -> Result<()> {
+fn build_cargo_embargo(repo_root: &impl AsRef<Path>) -> Result<()> {
     Command::new("/usr/bin/bash")
         .args(["-c", "source build/envsetup.sh && lunch aosp_cf_x86_64_phone-trunk_staging-eng && m cargo_embargo"])
         .env_remove("OUT_DIR")
diff --git a/tools/external_crates/crate_tool/src/crate_type.rs b/tools/external_crates/crate_tool/src/crate_type.rs
index a1e97e3e5..da5603dbf 100644
--- a/tools/external_crates/crate_tool/src/crate_type.rs
+++ b/tools/external_crates/crate_tool/src/crate_type.rs
@@ -13,7 +13,7 @@
 // limitations under the License.
 
 use anyhow::{bail, Result};
-use cargo_metadata::Package;
+use cargo_toml::Manifest;
 use name_and_version::{NameAndVersionRef, NamedAndVersioned};
 use rooted_path::RootedPath;
 use semver::Version;
@@ -22,16 +22,17 @@ use crate::CrateError;
 
 #[derive(Debug, Clone)]
 pub struct Crate {
-    metadata: Package,
+    manifest: Manifest,
     path: RootedPath,
+    version: Version,
 }
 
 impl NamedAndVersioned for Crate {
     fn name(&self) -> &str {
-        self.metadata.name.as_str()
+        self.manifest.package().name()
     }
     fn version(&self) -> &Version {
-        &self.metadata.version
+        &self.version
     }
     fn key(&self) -> NameAndVersionRef {
         NameAndVersionRef::new(self.name(), self.version())
@@ -39,30 +40,26 @@ impl NamedAndVersioned for Crate {
 }
 
 impl Crate {
-    pub fn new(metadata: Package, path: RootedPath) -> Crate {
-        Crate { metadata, path }
+    pub fn new(manifest: Manifest, path: RootedPath) -> Crate {
+        let version = Version::parse(manifest.package().version()).unwrap();
+        Crate { manifest, path, version }
     }
     pub fn from(manifest_dir: RootedPath) -> Result<Crate> {
-        let manifest_path = manifest_dir.abs().join("Cargo.toml");
-        let metadata = cargo_metadata::MetadataCommand::new()
-            .manifest_path(manifest_path)
-            .no_deps()
-            .other_options(["--frozen".to_string()])
-            .exec()?;
-        if metadata.packages.len() != 1 {
+        let manifest = Manifest::from_path(manifest_dir.abs().join("Cargo.toml"))?;
+        if manifest.package.is_none() {
             bail!(CrateError::VirtualCrate(manifest_dir.as_ref().to_path_buf()));
         }
-        Ok(Crate::new(metadata.packages[0].clone(), manifest_dir))
+        Ok(Crate::new(manifest, manifest_dir))
     }
 
     pub fn description(&self) -> &str {
-        self.metadata.description.as_deref().unwrap_or("")
+        self.manifest.package().description().unwrap_or("")
     }
     pub fn license(&self) -> Option<&str> {
-        self.metadata.license.as_deref()
+        self.manifest.package().license()
     }
     pub fn repository(&self) -> Option<&str> {
-        self.metadata.repository.as_deref()
+        self.manifest.package().repository()
     }
     pub fn path(&self) -> &RootedPath {
         &self.path
@@ -80,11 +77,27 @@ mod tests {
     use anyhow::anyhow;
     use tempfile::tempdir;
 
-    fn write_test_manifest(temp_crate_dir: &Path, name: &str, version: &str) -> Result<RootedPath> {
+    fn write_test_manifest(
+        temp_crate_dir: &Path,
+        name: &str,
+        version: &str,
+        license: &str,
+        description: &str,
+        repository: &str,
+    ) -> Result<RootedPath> {
         let temp_crate_dir = RootedPath::new("/", temp_crate_dir.strip_prefix("/")?)?;
         write(
             temp_crate_dir.join("Cargo.toml")?,
-            format!("[package]\nname = \"{}\"\nversion = \"{}\"\n", name, version),
+            format!(
+                r#"
+[package]
+name = "{name}"
+version = "{version}"
+license = "{license}"
+description = "{description}"
+repository = "{repository}"
+"#
+            ),
         )?;
         let lib_rs = temp_crate_dir.join("src/lib.rs")?;
         create_dir(lib_rs.abs().parent().ok_or(anyhow!("Failed to get parent"))?)?;
@@ -94,18 +107,35 @@ mod tests {
 
     #[test]
     fn test_from_and_properties() -> Result<()> {
+        let name = "foo";
+        let version = "1.2.0";
+        let license = "Apache-2.0";
+        let description = "description";
+        let repository = "repo";
         let temp_crate_dir = tempdir()?;
-        let manifest_dir = write_test_manifest(temp_crate_dir.path(), "foo", "1.2.0")?;
+        let manifest_dir = write_test_manifest(
+            temp_crate_dir.path(),
+            name,
+            version,
+            license,
+            description,
+            repository,
+        )?;
         let krate = Crate::from(manifest_dir)?;
-        assert_eq!(krate.name(), "foo");
-        assert_eq!(krate.version().to_string(), "1.2.0");
+        assert_eq!(krate.name(), name);
+        assert_eq!(krate.version().to_string(), version);
+        assert_eq!(krate.description(), description);
+        assert_eq!(krate.license(), Some(license));
+        assert_eq!(krate.repository(), Some(repository));
+        assert_eq!(krate.path().abs(), temp_crate_dir.path());
         Ok(())
     }
 
     #[test]
     fn test_from_error() -> Result<()> {
         let temp_crate_dir = tempdir()?;
-        let manifest_dir = write_test_manifest(temp_crate_dir.path(), "foo", "1.2.0")?;
+        let manifest_dir =
+            write_test_manifest(temp_crate_dir.path(), "foo", "1.2.0", "blah", "blah", "blah")?;
         assert!(Crate::from(manifest_dir.join("blah")?).is_err());
         Ok(())
     }
diff --git a/tools/external_crates/crate_tool/src/crates_io.rs b/tools/external_crates/crate_tool/src/crates_io.rs
deleted file mode 100644
index 4f26e5419..000000000
--- a/tools/external_crates/crate_tool/src/crates_io.rs
+++ /dev/null
@@ -1,140 +0,0 @@
-// Copyright (C) 2024 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use cfg_expr::{
-    targets::{Arch, Family, Os},
-    Predicate, TargetPredicate,
-};
-use crates_index::{Crate, Dependency, DependencyKind, Version};
-use semver::VersionReq;
-use std::collections::HashMap;
-
-/// Filter versions by those that are "safe", meaning not yanked or pre-release.
-pub trait SafeVersions {
-    // Versions of the crate that aren't yanked or pre-release.
-    fn safe_versions(&self) -> impl DoubleEndedIterator<Item = &Version>;
-    // Versions of the crate greater than 'version'.
-    fn versions_gt(&self, version: &semver::Version) -> impl DoubleEndedIterator<Item = &Version> {
-        self.safe_versions().filter(|v| {
-            semver::Version::parse(v.version()).map_or(false, |parsed| parsed.gt(version))
-        })
-    }
-    // Get a specific version of a crate.
-    fn get_version(&self, version: &semver::Version) -> Option<&Version> {
-        self.safe_versions().find(|v| {
-            semver::Version::parse(v.version()).map_or(false, |parsed| parsed.eq(version))
-        })
-    }
-}
-impl SafeVersions for Crate {
-    fn safe_versions(&self) -> impl DoubleEndedIterator<Item = &Version> {
-        self.versions().iter().filter(|v| {
-            !v.is_yanked()
-                && semver::Version::parse(v.version()).map_or(false, |parsed| parsed.pre.is_empty())
-        })
-    }
-}
-
-/// Filter dependencies for those likely to be relevant to Android.
-pub trait AndroidDependencies {
-    fn android_deps(&self) -> impl DoubleEndedIterator<Item = &Dependency>;
-    fn android_version_reqs_by_name(&self) -> HashMap<&str, &str> {
-        self.android_deps().map(|dep| (dep.crate_name(), dep.requirement())).collect()
-    }
-    fn android_deps_with_version_reqs(
-        &self,
-    ) -> impl DoubleEndedIterator<Item = (&Dependency, VersionReq)> {
-        self.android_deps().filter_map(|dep| {
-            VersionReq::parse(dep.requirement()).map_or(None, |req| Some((dep, req)))
-        })
-    }
-}
-impl AndroidDependencies for Version {
-    fn android_deps(&self) -> impl DoubleEndedIterator<Item = &Dependency> {
-        self.dependencies().iter().filter(|dep| {
-            dep.kind() == DependencyKind::Normal && !dep.is_optional() && dep.is_android()
-        })
-    }
-}
-
-/// Dependencies that are likely to be relevant to Android.
-/// Unconditional dependencies (without a target cfg string) are always relevant.
-/// Conditional dependencies are relevant if they are for Unix, Android, or Linux, and for an architecture we care about (Arm, RISC-V, or X86)
-pub trait IsAndroid {
-    /// Returns true if this dependency is likely to be relevant to Android.
-    fn is_android(&self) -> bool;
-}
-impl IsAndroid for Dependency {
-    fn is_android(&self) -> bool {
-        self.target().map_or(true, is_android)
-    }
-}
-fn is_android(target: &str) -> bool {
-    let expr = cfg_expr::Expression::parse(target);
-    if expr.is_err() {
-        return false;
-    }
-    let expr = expr.unwrap();
-    expr.eval(|pred| match pred {
-        Predicate::Target(target_predicate) => match target_predicate {
-            TargetPredicate::Family(family) => *family == Family::unix,
-            TargetPredicate::Os(os) => *os == Os::android || *os == Os::linux,
-            TargetPredicate::Arch(arch) => {
-                [Arch::arm, Arch::aarch64, Arch::riscv32, Arch::riscv64, Arch::x86, Arch::x86_64]
-                    .contains(arch)
-            }
-            _ => true,
-        },
-        _ => true,
-    })
-}
-
-pub trait DependencyChanges {
-    fn is_new_dep(&self, base_deps: &HashMap<&str, &str>) -> bool;
-    fn is_changed_dep(&self, base_deps: &HashMap<&str, &str>) -> bool;
-}
-
-impl DependencyChanges for Dependency {
-    fn is_new_dep(&self, base_deps: &HashMap<&str, &str>) -> bool {
-        !base_deps.contains_key(self.crate_name())
-    }
-
-    fn is_changed_dep(&self, base_deps: &HashMap<&str, &str>) -> bool {
-        let base_dep = base_deps.get(self.crate_name());
-        base_dep.is_none() || base_dep.is_some_and(|base_req| *base_req != self.requirement())
-    }
-}
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-    #[test]
-    fn test_android_cfgs() {
-        assert!(!is_android("asmjs-unknown-emscripten"), "Parse error");
-        assert!(!is_android("cfg(windows)"));
-        assert!(is_android("cfg(unix)"));
-        assert!(!is_android(r#"cfg(target_os = "redox")"#));
-        assert!(!is_android(r#"cfg(target_arch = "wasm32")"#));
-        assert!(is_android(r#"cfg(any(target_os = "linux", target_os = "android"))"#));
-        assert!(is_android(
-            r#"cfg(any(all(target_arch = "arm", target_pointer_width = "32"), target_arch = "mips", target_arch = "powerpc"))"#
-        ));
-        assert!(!is_android(
-            r#"cfg(all(target_arch = "wasm32", target_vendor = "unknown", target_os = "unknown"))"#
-        ));
-        assert!(is_android("cfg(tracing_unstable)"));
-        assert!(is_android(r#"cfg(any(unix, target_os = "wasi"))"#));
-        assert!(is_android(r#"cfg(not(all(target_arch = "arm", target_os = "none")))"#))
-    }
-}
diff --git a/tools/external_crates/crate_tool/src/lib.rs b/tools/external_crates/crate_tool/src/lib.rs
index ef4537dd2..037b9b004 100644
--- a/tools/external_crates/crate_tool/src/lib.rs
+++ b/tools/external_crates/crate_tool/src/lib.rs
@@ -12,20 +12,21 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+//! A command-line tool for managing repositories of 3rd party crates
+//! such as external/rust/android-crates-io.
+
 use std::env::current_dir;
 use std::fs::{create_dir_all, remove_dir_all};
 use std::path::{Path, PathBuf};
-use std::process::{Command, ExitStatus, Output};
-use std::str::from_utf8;
+use std::process::Command;
 
 use anyhow::{anyhow, Context, Result};
+use success_or_error::RunAndExpectSuccess;
 use thiserror::Error;
 
 mod android_bp;
 mod crate_collection;
 mod crate_type;
-mod crates_io;
-mod license;
 mod managed_crate;
 mod managed_repo;
 mod patch;
@@ -36,12 +37,17 @@ pub use self::android_bp::maybe_build_cargo_embargo;
 pub use self::managed_repo::ManagedRepo;
 pub use self::upgradable::SemverCompatibilityRule;
 
+/// Error types for the 'crate_tool' crate. For the most part,
+/// we use `anyhow`, but sometimes type information is useful.
 #[derive(Error, Debug)]
 pub enum CrateError {
+    /// Virtual crate, usually a workspace.
     #[error("Virtual crate: {0}")]
     VirtualCrate(PathBuf),
 }
 
+/// Returns the absolute path to the root of the current Android source
+/// repo, based on the current working directory.
 pub fn default_repo_root() -> Result<PathBuf> {
     let cwd = current_dir().context("Could not get current working directory")?;
     for cur in cwd.ancestors() {
@@ -54,7 +60,7 @@ pub fn default_repo_root() -> Result<PathBuf> {
     Err(anyhow!(".repo directory not found in any ancestor of {}", cwd.display()))
 }
 
-pub fn ensure_exists_and_empty(dir: impl AsRef<Path>) -> Result<()> {
+fn ensure_exists_and_empty(dir: impl AsRef<Path>) -> Result<()> {
     let dir = dir.as_ref();
     if dir.exists() {
         remove_dir_all(dir).context(format!("Failed to remove {}", dir.display()))?;
@@ -62,62 +68,8 @@ pub fn ensure_exists_and_empty(dir: impl AsRef<Path>) -> Result<()> {
     create_dir_all(dir).context(format!("Failed to create {}", dir.display()))
 }
 
-pub trait RunQuiet {
-    fn run_quiet_and_expect_success(&mut self) -> Result<Output>;
-}
-impl RunQuiet for Command {
-    fn run_quiet_and_expect_success(&mut self) -> Result<Output> {
-        self.output()
-            .context(format!("Failed to run {:?}", self))?
-            .success_or_error()
-            .context(format!("Failed to run {:?}", self))
-    }
-}
-
-pub trait SuccessOrError {
-    fn success_or_error(self) -> Result<Self>
-    where
-        Self: std::marker::Sized;
-}
-impl SuccessOrError for ExitStatus {
-    fn success_or_error(self) -> Result<Self> {
-        if !self.success() {
-            let exit_code =
-                self.code().map(|code| format!("{}", code)).unwrap_or("(unknown)".to_string());
-            Err(anyhow!("Process failed with exit code {}", exit_code))
-        } else {
-            Ok(self)
-        }
-    }
-}
-impl SuccessOrError for Output {
-    fn success_or_error(self) -> Result<Self> {
-        (&self).success_or_error()?;
-        Ok(self)
-    }
-}
-impl SuccessOrError for &Output {
-    fn success_or_error(self) -> Result<Self> {
-        if !self.status.success() {
-            let exit_code = self
-                .status
-                .code()
-                .map(|code| format!("{}", code))
-                .unwrap_or("(unknown)".to_string());
-            Err(anyhow!(
-                "Process failed with exit code {}\nstdout:\n{}\nstderr:\n{}",
-                exit_code,
-                from_utf8(&self.stdout)?,
-                from_utf8(&self.stderr)?
-            ))
-        } else {
-            Ok(self)
-        }
-    }
-}
-
 // The copy_dir crate doesn't handle symlinks.
-pub fn copy_dir(src: impl AsRef<Path>, dst: impl AsRef<Path>) -> Result<()> {
+fn copy_dir(src: impl AsRef<Path>, dst: impl AsRef<Path>) -> Result<()> {
     Command::new("cp")
         .arg("--archive")
         .arg(src.as_ref())
diff --git a/tools/external_crates/crate_tool/src/license.rs b/tools/external_crates/crate_tool/src/license.rs
deleted file mode 100644
index ba18d1739..000000000
--- a/tools/external_crates/crate_tool/src/license.rs
+++ /dev/null
@@ -1,113 +0,0 @@
-// Copyright (C) 2024 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-use std::{
-    collections::BTreeMap,
-    fs::{remove_file, write},
-    path::Path,
-    sync::LazyLock,
-};
-
-use anyhow::{anyhow, Result};
-use glob::glob;
-use google_metadata::metadata::LicenseType;
-use license_checker::LicenseState;
-use spdx::{LicenseReq, Licensee};
-
-/// Update MODULE_LICENSE_* files in a directory based on the applicable licenses.
-/// These files are typically empty, and their name indicates the type of license that
-/// applies to the code, for example MODULE_LICENSE_APACHE2.
-pub fn update_module_license_files(path: &impl AsRef<Path>, licenses: &LicenseState) -> Result<()> {
-    let path = path.as_ref();
-    for old_module_license_file in glob(
-        path.join("MODULE_LICENSE*").to_str().ok_or(anyhow!("Failed to convert path to string"))?,
-    )? {
-        remove_file(old_module_license_file?)?;
-    }
-    for license in licenses.satisfied.keys().chain(&licenses.unsatisfied) {
-        if let Some(mod_lic) = MODULE_LICENSE_FILES.get(license) {
-            write(path.join(mod_lic), "")?; // Write an empty file. Essentially "touch".
-        }
-    }
-    Ok(())
-}
-
-fn discriminant(lt: LicenseType) -> u8 {
-    // Smaller --> more restricted
-    // Larger --> less restricted
-    match lt {
-        LicenseType::UNKNOWN => 0,
-        LicenseType::BY_EXCEPTION_ONLY => 1,
-        LicenseType::RESTRICTED => 2,
-        LicenseType::RESTRICTED_IF_STATICALLY_LINKED => 3,
-        LicenseType::RECIPROCAL => 4,
-        LicenseType::NOTICE => 5,
-        LicenseType::PERMISSIVE => 6,
-        LicenseType::UNENCUMBERED => 7,
-    }
-}
-
-pub fn most_restrictive_type(licenses: &LicenseState) -> LicenseType {
-    licenses
-        .satisfied
-        .keys()
-        .chain(&licenses.unsatisfied)
-        .map(|req| LICENSE_TYPES.get(req).cloned().unwrap_or(LicenseType::UNKNOWN))
-        .min_by(|a, b| discriminant(*a).cmp(&discriminant(*b)))
-        .unwrap_or(LicenseType::UNKNOWN)
-}
-
-static MODULE_LICENSE_FILES: LazyLock<BTreeMap<LicenseReq, &'static str>> = LazyLock::new(|| {
-    vec![
-        ("Apache-2.0", "MODULE_LICENSE_APACHE2"),
-        ("MIT", "MODULE_LICENSE_MIT"),
-        ("MIT-0", "MODULE_LICENSE_MIT_0"),
-        ("BSD-3-Clause", "MODULE_LICENSE_BSD"),
-        ("BSD-2-Clause", "MODULE_LICENSE_BSD"),
-        ("ISC", "MODULE_LICENSE_ISC"),
-        ("MPL-2.0", "MODULE_LICENSE_MPL"),
-        ("0BSD", "MODULE_LICENSE_PERMISSIVE"),
-        ("Unlicense", "MODULE_LICENSE_PERMISSIVE"),
-        ("Zlib", "MODULE_LICENSE_ZLIB"),
-        ("Unicode-3.0", "MODULE_LICENSE_UNICODE_3"),
-        ("Unicode-DFS-2016", "MODULE_LICENSE_UNICODE"),
-        ("NCSA", "MODULE_LICENSE_NCSA"),
-        ("OpenSSL", "MODULE_LICENSE_OPENSSL"),
-    ]
-    .into_iter()
-    .map(|l| (Licensee::parse(l.0).unwrap().into_req(), l.1))
-    .collect()
-});
-static LICENSE_TYPES: LazyLock<BTreeMap<LicenseReq, LicenseType>> = LazyLock::new(|| {
-    vec![
-        ("Apache-2.0", LicenseType::NOTICE),
-        ("MIT", LicenseType::NOTICE),
-        ("MIT-0", LicenseType::PERMISSIVE),
-        ("BSD-3-Clause", LicenseType::NOTICE),
-        ("BSD-2-Clause", LicenseType::NOTICE),
-        ("ISC", LicenseType::NOTICE),
-        ("MPL-2.0", LicenseType::RECIPROCAL),
-        ("0BSD", LicenseType::PERMISSIVE),
-        ("Unlicense", LicenseType::PERMISSIVE),
-        ("Zlib", LicenseType::NOTICE),
-        ("Unicode-3.0", LicenseType::NOTICE),
-        ("Unicode-DFS-2016", LicenseType::NOTICE),
-        ("NCSA", LicenseType::NOTICE),
-        ("OpenSSL", LicenseType::NOTICE),
-        ("CC0-1.0", LicenseType::UNENCUMBERED),
-    ]
-    .into_iter()
-    .map(|l| (Licensee::parse(l.0).unwrap().into_req(), l.1))
-    .collect()
-});
diff --git a/tools/external_crates/crate_tool/src/main.rs b/tools/external_crates/crate_tool/src/main.rs
index db8a5defb..dbefc1e65 100644
--- a/tools/external_crates/crate_tool/src/main.rs
+++ b/tools/external_crates/crate_tool/src/main.rs
@@ -12,6 +12,9 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+//! A command-line tool for managing repositories of 3rd party crates
+//! such as external/rust/android-crates-io.
+
 use std::{collections::BTreeSet, path::PathBuf};
 
 use anyhow::{bail, Result};
@@ -152,6 +155,8 @@ impl CrateList {
 }
 
 fn main() -> Result<()> {
+    env_logger::init();
+
     let args = Cli::parse();
 
     maybe_build_cargo_embargo(&args.android_root, args.rebuild_cargo_embargo)?;
diff --git a/tools/external_crates/crate_tool/src/managed_crate.rs b/tools/external_crates/crate_tool/src/managed_crate.rs
index adf3faea9..a4b5b5338 100644
--- a/tools/external_crates/crate_tool/src/managed_crate.rs
+++ b/tools/external_crates/crate_tool/src/managed_crate.rs
@@ -30,6 +30,7 @@ use license_checker::{find_licenses, LicenseState};
 use name_and_version::NamedAndVersioned;
 use rooted_path::RootedPath;
 use semver::Version;
+use success_or_error::SuccessOrError;
 use test_mapping::TestMapping;
 
 use crate::{
@@ -37,10 +38,8 @@ use crate::{
     copy_dir,
     crate_type::Crate,
     ensure_exists_and_empty,
-    license::{most_restrictive_type, update_module_license_files},
     patch::Patch,
     pseudo_crate::{CargoVendorClean, PseudoCrate},
-    SuccessOrError,
 };
 
 #[derive(Debug)]
@@ -94,7 +93,7 @@ impl<State: ManagedCrateState> ManagedCrate<State> {
     pub fn android_version(&self) -> &Version {
         self.android_crate.version()
     }
-    fn android_crate_path(&self) -> &RootedPath {
+    pub fn android_crate_path(&self) -> &RootedPath {
         self.android_crate.path()
     }
     pub fn config(&self) -> &CrateConfig {
@@ -341,7 +340,7 @@ impl ManagedCrate<Vendored> {
         let licenses = find_licenses(
             self.temporary_build_directory(),
             self.name(),
-            self.android_crate.license(),
+            Crate::from(self.temporary_build_directory())?.license(),
         )?;
         let regenerated = self.into_copied_and_patched(licenses)?;
         regenerated.regenerate(run_cargo_embargo)?;
@@ -450,7 +449,7 @@ impl ManagedCrate<CopiedAndPatched> {
             )?;
         }
 
-        update_module_license_files(&self.temporary_build_directory(), &self.extra.licenses)?;
+        self.extra.licenses.update_module_license_files(&self.temporary_build_directory())?;
         Ok(())
     }
     /// Runs cargo_embargo on the crate in the temporary build directory.
@@ -486,7 +485,7 @@ impl ManagedCrate<CopiedAndPatched> {
             self.name(),
             self.extra.vendored_crate.version().to_string(),
             self.extra.vendored_crate.description(),
-            most_restrictive_type(&self.extra.licenses),
+            self.extra.licenses.most_restrictive_type(),
         );
         metadata.write()?;
 
diff --git a/tools/external_crates/crate_tool/src/managed_repo.rs b/tools/external_crates/crate_tool/src/managed_repo.rs
index 6b8b2d7e0..1f915e682 100644
--- a/tools/external_crates/crate_tool/src/managed_repo.rs
+++ b/tools/external_crates/crate_tool/src/managed_repo.rs
@@ -22,27 +22,29 @@ use std::{
 
 use anyhow::{anyhow, bail, Context, Result};
 use crates_index::DependencyKind;
-use crates_io_util::CratesIoIndex;
+use crates_io_util::{
+    CratesIoIndex, DependencyDiffer, FeatureResolver, GetVersion, ParsedVersion, ParsedVersionReq,
+    SafeVersions,
+};
 use google_metadata::GoogleMetadata;
 use itertools::Itertools;
 use license_checker::find_licenses;
+use log::debug;
 use name_and_version::{NameAndVersion, NameAndVersionRef, NamedAndVersioned};
 use repo_config::RepoConfig;
 use rooted_path::RootedPath;
 use semver::{Version, VersionReq};
 use serde::Serialize;
+use success_or_error::SuccessOrError;
 
 use crate::{
     android_bp::cargo_embargo_autoconfig,
     copy_dir,
     crate_collection::CrateCollection,
     crate_type::Crate,
-    crates_io::{AndroidDependencies, DependencyChanges, SafeVersions},
-    license::{most_restrictive_type, update_module_license_files},
     managed_crate::ManagedCrate,
     pseudo_crate::{CargoVendorDirty, PseudoCrate},
     upgradable::{IsUpgradableTo, MatchesWithCompatibilityRule, SemverCompatibilityRule},
-    SuccessOrError,
 };
 
 #[derive(Serialize, Default, Debug)]
@@ -58,6 +60,7 @@ struct UpdateSuggestion {
     version: String,
 }
 
+/// A struct for interacting with a managed repository of 3rd party crates.
 pub struct ManagedRepo {
     path: RootedPath,
     config: OnceCell<RepoConfig>,
@@ -65,14 +68,20 @@ pub struct ManagedRepo {
 }
 
 impl ManagedRepo {
+    /// Constructs a ManagedRepo at the specified path.
+    /// If `offline` is true, no requests are made to crates.io.
     pub fn new(path: RootedPath, offline: bool) -> Result<ManagedRepo> {
         Ok(ManagedRepo {
             path,
             config: OnceCell::new(),
-            crates_io: if offline { CratesIoIndex::new_offline()? } else { CratesIoIndex::new()? },
+            crates_io: if offline {
+                CratesIoIndex::new_offline()?
+            } else {
+                CratesIoIndex::new_cargo()?
+            },
         })
     }
-    pub fn config(&self) -> &RepoConfig {
+    fn config(&self) -> &RepoConfig {
         self.config.get_or_init(|| {
             RepoConfig::read(self.path.abs()).unwrap_or_else(|e| {
                 panic!(
@@ -125,12 +134,14 @@ impl ManagedRepo {
     fn new_cc(&self) -> CrateCollection {
         CrateCollection::new(self.path.root())
     }
-    fn managed_crate_for(
+    /// Returns the managed crate for the specified crate name.
+    pub fn managed_crate_for(
         &self,
         crate_name: &str,
     ) -> Result<ManagedCrate<crate::managed_crate::New>> {
         Ok(ManagedCrate::new(Crate::from(self.managed_dir_for(crate_name))?))
     }
+    /// Returns the names of all crates in the managed repo.
     pub fn all_crate_names(&self) -> Result<BTreeSet<String>> {
         let mut managed_dirs = BTreeSet::new();
         if self.managed_dir().abs().exists() {
@@ -145,6 +156,7 @@ impl ManagedRepo {
         }
         Ok(managed_dirs)
     }
+    /// Analyzes a new crate we would like to import, and reports on any problems.
     pub fn analyze_import(&self, crate_name: &str) -> Result<()> {
         if self.contains(crate_name) {
             println!("Crate already imported at {}", self.managed_dir_for(crate_name));
@@ -169,8 +181,10 @@ impl ManagedRepo {
 
         for version in cio_crate.safe_versions() {
             println!("Version {}", version.version());
+            let resolver = FeatureResolver::new(version);
             let mut found_problems = false;
-            for (dep, req) in version.android_deps_with_version_reqs() {
+            for dep in resolver.resolve(None as Option<Box<dyn Iterator<Item = &str>>>)? {
+                let req = dep.parsed_version_req()?;
                 let cc = if managed_crates.contains_crate(dep.crate_name()) {
                     &managed_crates
                 } else {
@@ -235,6 +249,7 @@ impl ManagedRepo {
         }
         Ok(())
     }
+    /// Imports a new crate to the managed repo.
     pub fn import(&self, crate_name: &str, version: &str, autoconfig: bool) -> Result<()> {
         if self.contains(crate_name) {
             bail!("Crate already imported at {}", self.managed_dir_for(crate_name));
@@ -265,7 +280,7 @@ impl ManagedRepo {
         println!("  Finding license files");
         let licenses = find_licenses(krate.path().abs(), krate.name(), krate.license())?;
 
-        update_module_license_files(&krate.path().abs(), &licenses)?;
+        licenses.update_module_license_files(&krate.path().abs())?;
 
         println!("  Creating METADATA");
         let metadata = GoogleMetadata::init(
@@ -273,7 +288,7 @@ impl ManagedRepo {
             krate.name(),
             krate.version().to_string(),
             krate.description(),
-            most_restrictive_type(&licenses),
+            licenses.most_restrictive_type(),
         )?;
         metadata.write()?;
 
@@ -328,6 +343,8 @@ We apologize for the inconvenience."#,
 
         Ok(())
     }
+    /// Regenerates the data for a list of crates.
+    /// If `run_cargo_embargo` is false, the Android.bp is not updated, but all other metadata is.
     pub fn regenerate<T: AsRef<str>>(
         &self,
         crates: impl Iterator<Item = T>,
@@ -345,6 +362,7 @@ We apologize for the inconvenience."#,
 
         Ok(())
     }
+    /// Runs a preupload check on a set of changed files and reports problems.
     pub fn preupload_check(&self, files: &[String]) -> Result<()> {
         let pseudo_crate = self.pseudo_crate().vendor()?;
         let deps = pseudo_crate.deps().keys().cloned().collect::<BTreeSet<_>>();
@@ -396,6 +414,7 @@ We apologize for the inconvenience."#,
         }
         Ok(())
     }
+    /// Updates the context of the patch files for a crate to match the current contents.
     pub fn recontextualize_patches<T: AsRef<str>>(
         &self,
         crates: impl Iterator<Item = T>,
@@ -406,14 +425,17 @@ We apologize for the inconvenience."#,
         }
         Ok(())
     }
+    /// Prints a list of crates that have newer versions available on crates.io.
     pub fn updatable_crates(&self) -> Result<()> {
         let mut cc = self.new_cc();
         cc.add_from(self.managed_dir().rel())?;
 
         for krate in cc.values() {
             let cio_crate = self.crates_io.get_crate(krate.name())?;
-            let upgrades =
-                cio_crate.versions_gt(krate.version()).map(|v| v.version()).collect::<Vec<_>>();
+            let upgrades = cio_crate
+                .safe_versions_gt(krate.version())
+                .map(|v| v.version())
+                .collect::<Vec<_>>();
             if !upgrades.is_empty() {
                 println!(
                     "{} v{}:\n  {}",
@@ -430,6 +452,7 @@ We apologize for the inconvenience."#,
         }
         Ok(())
     }
+    /// Analyze a crate to see if it can be updated to a newer version.
     pub fn analyze_updates(&self, crate_name: impl AsRef<str>) -> Result<()> {
         let mut managed_crates = self.new_cc();
         managed_crates.add_from(self.managed_dir().rel())?;
@@ -455,16 +478,17 @@ We apologize for the inconvenience."#,
             krate.name(),
             krate.android_version()
         ))?;
-        let base_deps = base_version.android_version_reqs_by_name();
+        let dep_differ = DependencyDiffer::new(base_version);
 
-        let mut newer_versions = cio_crate.versions_gt(krate.android_version()).peekable();
+        let mut newer_versions = cio_crate.safe_versions_gt(krate.android_version()).peekable();
         if newer_versions.peek().is_none() {
             println!("There are no newer versions of this crate.");
         }
         for version in newer_versions {
             println!("Version {}", version.version());
             let mut found_problems = false;
-            let parsed_version = semver::Version::parse(version.version())?;
+            let parsed_version = version.parsed_version()?;
+            let resolver = FeatureResolver::new(version);
             if !krate
                 .android_version()
                 .is_upgradable_to(&parsed_version, SemverCompatibilityRule::Strict)
@@ -479,12 +503,13 @@ We apologize for the inconvenience."#,
                     println!("  Semver-compatible, but only by relaxed standards since major version is 0");
                 }
             }
+            let diff = dep_differ.diff(version);
             // Check to see if the update has any missing dependencies.
             // We try to be a little clever about this in the following ways:
             // * Only consider deps that are likely to be relevant to Android. For example, ignore Windows-only deps.
             // * If a dep is missing, but the same dep exists for the current version of the crate, it's probably not actually necessary.
             // * Use relaxed version requirements, treating 0.x and 0.y as compatible, even though they aren't according to semver rules.
-            for (dep, req) in version.android_deps_with_version_reqs() {
+            for dep in resolver.resolve(None as Option<Box<dyn Iterator<Item = &str>>>)? {
                 let cc = if managed_crates.contains_crate(dep.crate_name()) {
                     &managed_crates
                 } else {
@@ -497,14 +522,14 @@ We apologize for the inconvenience."#,
                         dep.crate_name(),
                         dep.requirement()
                     );
-                    if !dep.is_new_dep(&base_deps) {
+                    if !diff.is_added(dep) {
                         println!("    But the current version has the same dependency, and it seems to work");
                     } else {
                         continue;
                     }
                 }
                 for (_, dep_crate) in cc.get_versions(dep.crate_name()) {
-                    if !req.matches_with_compatibility_rule(
+                    if !dep.parsed_version_req()?.matches_with_compatibility_rule(
                         dep_crate.version(),
                         SemverCompatibilityRule::Loose,
                     ) {
@@ -516,7 +541,7 @@ We apologize for the inconvenience."#,
                             dep_crate.version(),
                             dep_crate.path()
                         );
-                        if !dep.is_changed_dep(&base_deps) {
+                        if !diff.is_changed(dep) {
                             println!("    But the current version has the same dependency and it seems to work.")
                         }
                     }
@@ -529,6 +554,8 @@ We apologize for the inconvenience."#,
 
         Ok(())
     }
+    /// Checks all crates to see if newer versions are available, and reports
+    /// specific updates that seem likely to succeed.
     pub fn suggest_updates(
         &self,
         consider_patched_crates: bool,
@@ -541,6 +568,7 @@ We apologize for the inconvenience."#,
         let legacy_crates = self.legacy_crates()?;
 
         for krate in managed_crates.values() {
+            debug!("Checking for updates to {}", krate.name());
             let cio_crate = self.crates_io.get_crate(krate.name())?;
 
             let base_version = cio_crate.get_version(krate.version());
@@ -555,7 +583,7 @@ We apologize for the inconvenience."#,
                 continue;
             }
             let base_version = base_version.unwrap();
-            let base_deps = base_version.android_version_reqs_by_name();
+            let dep_differ = DependencyDiffer::new(base_version);
 
             let patch_dir = krate.path().join("patches").unwrap();
             if patch_dir.abs().exists() && !consider_patched_crates {
@@ -569,13 +597,15 @@ We apologize for the inconvenience."#,
                 continue;
             }
 
-            for version in cio_crate.versions_gt(krate.version()).rev() {
+            for version in cio_crate.safe_versions_gt(krate.version()).rev() {
                 let parsed_version = semver::Version::parse(version.version())?;
                 if !krate.version().is_upgradable_to(&parsed_version, semver_compatibility) {
                     continue;
                 }
-                if !version.android_deps_with_version_reqs().any(|(dep, req)| {
-                    if !dep.is_changed_dep(&base_deps) {
+                let resolver = FeatureResolver::new(version);
+                if !resolver.resolve(None as Option<Box<dyn Iterator<Item = &str>>>)?.any(|dep| {
+                    let diff = dep_differ.diff(version);
+                    if !diff.is_changed(dep) {
                         return false;
                     }
                     let cc = if managed_crates.contains_crate(dep.crate_name()) {
@@ -583,6 +613,9 @@ We apologize for the inconvenience."#,
                     } else {
                         &legacy_crates
                     };
+                    let Ok(req) = dep.parsed_version_req() else {
+                        return false;
+                    };
                     for (_, dep_crate) in cc.get_versions(dep.crate_name()) {
                         if req.matches_with_compatibility_rule(
                             dep_crate.version(),
@@ -616,6 +649,7 @@ We apologize for the inconvenience."#,
 
         Ok(())
     }
+    /// Update a crate to a newer version.
     pub fn update(&self, crate_name: impl AsRef<str>, version: impl AsRef<str>) -> Result<()> {
         let crate_name = crate_name.as_ref();
         let version = Version::parse(version.as_ref())?;
@@ -668,6 +702,8 @@ We apologize for the inconvenience."#,
         self.regenerate(crate_updates.iter().map(|nv| nv.name()), true)?;
         Ok(())
     }
+    /// Initialize a new managed repository by creating the necessary directories,
+    /// data files, etc.
     pub fn init(&self) -> Result<()> {
         if self.path.abs().exists() {
             return Err(anyhow!("{} already exists", self.path));
@@ -678,6 +714,7 @@ We apologize for the inconvenience."#,
         self.pseudo_crate().init()?;
         Ok(())
     }
+    /// Verifies the checksum file for a crate.
     pub fn verify_checksums<T: AsRef<str>>(&self, crates: impl Iterator<Item = T>) -> Result<()> {
         for krate in crates {
             println!("Verifying checksums for {}", krate.as_ref());
diff --git a/tools/external_crates/crate_tool/src/patch.rs b/tools/external_crates/crate_tool/src/patch.rs
index 4db754e36..9beb9bc65 100644
--- a/tools/external_crates/crate_tool/src/patch.rs
+++ b/tools/external_crates/crate_tool/src/patch.rs
@@ -12,8 +12,8 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-/// A parser to extract the header and footer for patch files we are going
-/// to recontextualize.
+//! A parser to extract the header and footer for patch files we are going
+//! to recontextualize.
 
 pub struct Patch<'a> {
     // The header of the patch, not including the diff stats and the immediately preceding "---", if present.
diff --git a/tools/external_crates/crate_tool/src/pseudo_crate.rs b/tools/external_crates/crate_tool/src/pseudo_crate.rs
index d06522e43..cc317bba6 100644
--- a/tools/external_crates/crate_tool/src/pseudo_crate.rs
+++ b/tools/external_crates/crate_tool/src/pseudo_crate.rs
@@ -27,8 +27,9 @@ use itertools::Itertools;
 use name_and_version::NamedAndVersioned;
 use rooted_path::RootedPath;
 use semver::Version;
+use success_or_error::RunAndExpectSuccess;
 
-use crate::{crate_collection::CrateCollection, ensure_exists_and_empty, RunQuiet};
+use crate::{crate_collection::CrateCollection, ensure_exists_and_empty};
 
 pub struct PseudoCrate<State: PseudoCrateState> {
     path: RootedPath,
@@ -207,7 +208,7 @@ license = "Apache-2.0"
             self.remove(crate_name).with_context(|| {
                 format!("Failed to remove {} after failing to add it: {}", crate_name, e)
             })?;
-            return Err(e);
+            return Err(e.into());
         }
         Ok(())
     }
diff --git a/tools/external_crates/crate_tool/tests/integration_test.rs b/tools/external_crates/crate_tool/tests/integration_test.rs
new file mode 100644
index 000000000..3f367aa84
--- /dev/null
+++ b/tools/external_crates/crate_tool/tests/integration_test.rs
@@ -0,0 +1,116 @@
+// Copyright (C) 2025 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// To run:
+//
+// ./android_cargo.py test -p crate_tool --test integration_test -- --nocapture
+
+#[cfg(not(soong))]
+mod test {
+    use anyhow::Result;
+    use crate_tool::{default_repo_root, maybe_build_cargo_embargo, ManagedRepo};
+    use rooted_path::RootedPath;
+    use std::{fs::remove_dir_all, path::Path, process::Command};
+    use tempfile::TempDir;
+
+    fn dump(path: impl AsRef<Path>) {
+        Command::new("tree")
+            .arg(path.as_ref().file_name().unwrap())
+            .current_dir(path.as_ref().parent().unwrap())
+            .spawn()
+            .unwrap()
+            .wait()
+            .unwrap();
+    }
+    struct TempMonorepo {
+        path: RootedPath,
+        tempdir: TempDir,
+    }
+
+    impl TempMonorepo {
+        fn new(path: RootedPath) -> Result<Self> {
+            let tempdir = tempfile::tempdir_in(path.abs())?;
+            Ok(TempMonorepo { path, tempdir })
+        }
+        fn path(&self) -> &RootedPath {
+            &self.path
+        }
+        fn monorepo_path(&self) -> RootedPath {
+            self.path
+                .join(Path::new(self.tempdir.path().file_name().unwrap()))
+                .unwrap()
+                .join("test_monorepo")
+                .unwrap()
+        }
+        fn vendored_path(&self) -> RootedPath {
+            self.path
+                .with_same_root("out/rust-vendored-crates")
+                .unwrap()
+                .join(self.monorepo_path().rel().parent().unwrap())
+                .unwrap()
+        }
+    }
+
+    impl Drop for TempMonorepo {
+        fn drop(&mut self) {
+            if self.vendored_path().abs().exists() {
+                remove_dir_all(self.vendored_path().abs())
+                    .expect("Failed to clean up vendored crates");
+            }
+        }
+    }
+
+    #[test]
+    fn integration_test() -> Result<()> {
+        let repo_root = default_repo_root()?;
+        let managed_repo_path =
+            TempMonorepo::new(RootedPath::new(repo_root, "development/tools")?)?;
+
+        maybe_build_cargo_embargo(&managed_repo_path.path().root(), false)?;
+
+        let managed_repo = ManagedRepo::new(managed_repo_path.monorepo_path(), false)?;
+        managed_repo.init()?;
+
+        assert!(
+            managed_repo.analyze_import("nonexistent_crate_blah").is_err(),
+            "Analyze import of non-existent crate"
+        );
+        // base64 has no deps
+        managed_repo.analyze_import("base64")?;
+
+        assert!(
+            managed_repo.import("base64", "0.21.123", false).is_err(),
+            "Import of non-existent version"
+        );
+        managed_repo.import("base64", "0.21.7", false)?;
+        assert!(
+            managed_repo.import("base64", "0.22.0", false).is_err(),
+            "Import a crate that's already imported"
+        );
+
+        managed_repo.analyze_updates("base64")?;
+
+        managed_repo.suggest_updates(true, crate_tool::SemverCompatibilityRule::Ignore, false)?;
+
+        assert!(
+            managed_repo.update("base64", "0.21.123").is_err(),
+            "Update to non-existent version"
+        );
+        managed_repo.update("base64", "0.22.1")?;
+
+        dump(managed_repo_path.monorepo_path());
+
+        Ok(())
+    }
+}
diff --git a/tools/external_crates/crates_io_util/Android.bp b/tools/external_crates/crates_io_util/Android.bp
new file mode 100644
index 000000000..6d5b45c9a
--- /dev/null
+++ b/tools/external_crates/crates_io_util/Android.bp
@@ -0,0 +1,96 @@
+// This file is generated by cargo_embargo.
+// Do not modify this file after the first "rust_*" or "genrule" module
+// because the changes will be overridden on upgrade.
+// Content before the first "rust_*" or "genrule" module is preserved.
+
+package {
+    default_team: "trendy_team_android_rust",
+    default_applicable_licenses: ["Android-Apache-2.0"],
+}
+
+rust_test_host {
+    name: "crates_io_util_test_src_lib",
+    crate_name: "crates_io_util",
+    cargo_env_compat: true,
+    cargo_pkg_version: "0.1.0",
+    crate_root: "src/lib.rs",
+    test_suites: ["general-tests"],
+    auto_gen_config: true,
+    test_options: {
+        unit_test: true,
+    },
+    edition: "2021",
+    rustlibs: [
+        "libandroid_bp",
+        "libanyhow",
+        "libbp_util",
+        "libcargo_toml",
+        "libcfg_expr",
+        "libcrate_tool",
+        "libcrates_index",
+        "libenv_logger",
+        "libitertools",
+        "liblog_rust",
+        "librooted_path",
+        "libsemver",
+        "libserde_json",
+        "libsuccess_or_error",
+        "libtempfile",
+        "libtest_mapping",
+        "libthiserror",
+    ],
+}
+
+rust_test_host {
+    name: "crates_io_util_test_tests_resolver_test",
+    crate_name: "resolver_test",
+    cargo_env_compat: true,
+    cargo_pkg_version: "0.1.0",
+    crate_root: "tests/resolver_test.rs",
+    test_suites: ["general-tests"],
+    auto_gen_config: true,
+    test_options: {
+        unit_test: true,
+    },
+    edition: "2021",
+    rustlibs: [
+        "libandroid_bp",
+        "libanyhow",
+        "libbp_util",
+        "libcargo_toml",
+        "libcfg_expr",
+        "libcrate_tool",
+        "libcrates_index",
+        "libcrates_io_util",
+        "libenv_logger",
+        "libitertools",
+        "liblog_rust",
+        "librooted_path",
+        "libsemver",
+        "libserde_json",
+        "libsuccess_or_error",
+        "libtempfile",
+        "libtest_mapping",
+        "libthiserror",
+    ],
+}
+
+rust_library_host {
+    name: "libcrates_io_util",
+    crate_name: "crates_io_util",
+    cargo_env_compat: true,
+    cargo_pkg_version: "0.1.0",
+    crate_root: "src/lib.rs",
+    edition: "2021",
+    rustlibs: [
+        "libcargo_toml",
+        "libcfg_expr",
+        "libcrates_index",
+        "libitertools",
+        "liblog_rust",
+        "libsemver",
+        "libsuccess_or_error",
+        "libtempfile",
+        "libthiserror",
+    ],
+}
diff --git a/tools/external_crates/crates_io_util/Cargo.toml b/tools/external_crates/crates_io_util/Cargo.toml
index 3bbc4c822..ae20b50c1 100644
--- a/tools/external_crates/crates_io_util/Cargo.toml
+++ b/tools/external_crates/crates_io_util/Cargo.toml
@@ -4,12 +4,23 @@ version = "0.1.0"
 edition = "2021"
 
 [dependencies]
+cargo_toml = { version = "0.22", features = ["features"] }
 cfg-expr = "0.17"
 crates-index = "3.2.0"
-ureq = "3"
+itertools = "0.11"
+log = "0.4"
 semver = "1"
+tempfile = "3"
 thiserror = "1"
+ureq = { version = "3", optional = true }
+success_or_error = { path = "../success_or_error" }
 
 [dev-dependencies]
+android_bp = "0.3"
+env_logger = "0.10"
 serde_json = "1"
-itertools = "0.11"
+anyhow = "1"
+bp_util = { path = "../bp_util" }
+crate_tool = { path = "../crate_tool" }
+rooted_path = { path = "../rooted_path" }
+test_mapping = { path = "../test_mapping" }
\ No newline at end of file
diff --git a/tools/external_crates/crates_io_util/examples/dump_json.rs b/tools/external_crates/crates_io_util/examples/dump_json.rs
index e6b107f1a..a667f8a12 100644
--- a/tools/external_crates/crates_io_util/examples/dump_json.rs
+++ b/tools/external_crates/crates_io_util/examples/dump_json.rs
@@ -13,6 +13,10 @@
 // limitations under the License.
 
 // Use to capture more test cases from crates.io.
+//
+// Usage:
+//
+// cargo run --example dump_json -- getrandom 0.3.3
 
 use std::env;
 
@@ -23,7 +27,7 @@ fn main() -> Result<(), Error> {
     let krate = args[1].as_str();
     let version = args[2].as_str();
 
-    let fetcher = CratesIoIndex::new()?;
+    let fetcher = CratesIoIndex::new_cargo()?;
     let cio_crate = fetcher.get_crate(krate)?;
     let version =
         cio_crate.versions().iter().find(|v| v.version() == version).expect("Version not found");
diff --git a/tools/external_crates/crates_io_util/src/android_target.rs b/tools/external_crates/crates_io_util/src/android_target.rs
index af263fbd9..61c65366f 100644
--- a/tools/external_crates/crates_io_util/src/android_target.rs
+++ b/tools/external_crates/crates_io_util/src/android_target.rs
@@ -12,11 +12,14 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+use std::sync::LazyLock;
+
 use cfg_expr::{
-    targets::{Arch, Family, Os},
-    Predicate, TargetPredicate,
+    targets::{get_builtin_target_by_triple, TargetInfo},
+    Predicate,
 };
-use crates_index::Dependency;
+use crates_index::{Dependency, Version};
+use log::debug;
 
 /// Parse cfg expressions in dependencies and determine if they refer to a target relevant to Android.
 /// Dependencies are relevant if they are for Unix, Android, or Linux, and for an architecture we care about (Arm, RISC-V, or X86)
@@ -27,35 +30,83 @@ pub trait AndroidTarget {
 
 impl AndroidTarget for Dependency {
     fn is_android_target(&self) -> bool {
-        self.target().map_or(true, is_android)
+        self.target().is_none_or(is_android)
     }
 }
 
+static ANDROID_TARGETS: LazyLock<Vec<&'static TargetInfo>> = LazyLock::new(|| {
+    vec![
+        get_builtin_target_by_triple("aarch64-linux-android").unwrap(),
+        get_builtin_target_by_triple("armv7-linux-androideabi").unwrap(),
+        get_builtin_target_by_triple("i686-linux-android").unwrap(),
+        get_builtin_target_by_triple("i686-unknown-linux-gnu").unwrap(),
+        get_builtin_target_by_triple("riscv64-linux-android").unwrap(),
+        get_builtin_target_by_triple("x86_64-linux-android").unwrap(),
+        get_builtin_target_by_triple("x86_64-unknown-linux-gnu").unwrap(),
+    ]
+});
+
 fn is_android(target: &str) -> bool {
-    let expr = cfg_expr::Expression::parse(target);
-    if expr.is_err() {
+    debug!("is_android({target})");
+    let Ok(expr) = cfg_expr::Expression::parse(target) else {
         return false;
-    }
-    let expr = expr.unwrap();
-    expr.eval(|pred| match pred {
-        Predicate::Target(target_predicate) => match target_predicate {
-            TargetPredicate::Family(family) => *family == Family::unix,
-            TargetPredicate::Os(os) => *os == Os::android || *os == Os::linux,
-            TargetPredicate::Arch(arch) => {
-                [Arch::arm, Arch::aarch64, Arch::riscv32, Arch::riscv64, Arch::x86, Arch::x86_64]
-                    .contains(arch)
+    };
+    ANDROID_TARGETS.iter().any(|android_target| {
+        debug!("Checking target {android_target:?}");
+        expr.eval(|pred| match pred {
+            Predicate::Target(target_predicate) => {
+                let matches = target_predicate.matches(*android_target);
+                debug!("Predicate::Target({target_predicate:?}) = {matches}");
+                matches
+            }
+            Predicate::Flag(flag) => {
+                debug!("Predicate::Flag({flag})");
+                *flag == "mls_build_async" || *flag == "rustix_use_libc"
+            }
+            Predicate::KeyValue { key, val } => {
+                let expr_val = *key != "getrandom_backend";
+                debug!("Predicate::KeyValue(key = {key}, val = {val}) = {expr_val}");
+                expr_val
             }
             _ => true,
-        },
-        _ => true,
+        })
     })
 }
 
+/// Get the required Android dependencies of a crate.
+pub trait RequiredAndroidDeps {
+    /// Returns the required Android dependencies of a crate.
+    /// That is, dependencies that are:
+    /// * Non-optional
+    /// * Normal (not Build or Dev)
+    /// * If they have a target cfg expression, it applies to Android.
+    fn required_android_deps(&self) -> impl DoubleEndedIterator<Item = &crates_index::Dependency>;
+}
+
+impl RequiredAndroidDeps for Version {
+    fn required_android_deps(&self) -> impl DoubleEndedIterator<Item = &crates_index::Dependency> {
+        self.dependencies().iter().filter(|dep| {
+            dep.kind() == crates_index::DependencyKind::Normal
+                && !dep.is_optional()
+                && dep.is_android_target()
+        })
+    }
+}
+
 #[cfg(test)]
 mod tests {
+    use itertools::assert_equal;
+
     use super::*;
+
+    fn init_logger() {
+        let _ =
+            env_logger::builder().filter_level(log::LevelFilter::max()).is_test(true).try_init();
+    }
+
     #[test]
     fn test_android_cfgs() {
+        init_logger();
         assert!(!is_android("asmjs-unknown-emscripten"), "Parse error");
         assert!(!is_android("cfg(windows)"));
         assert!(is_android("cfg(unix)"));
@@ -68,8 +119,57 @@ mod tests {
         assert!(!is_android(
             r#"cfg(all(target_arch = "wasm32", target_vendor = "unknown", target_os = "unknown"))"#
         ));
-        assert!(is_android("cfg(tracing_unstable)"));
+        assert!(!is_android("cfg(tracing_unstable)"));
         assert!(is_android(r#"cfg(any(unix, target_os = "wasi"))"#));
-        assert!(is_android(r#"cfg(not(all(target_arch = "arm", target_os = "none")))"#))
+        assert!(is_android(r#"cfg(not(all(target_arch = "arm", target_os = "none")))"#));
+        assert!(is_android(r#"cfg(all(target_os = "linux", not(target_env = "musl")))"#));
+        assert!(is_android("cfg(mls_build_async)"), "cfg that is enabled for mls-rs crates");
+        assert!(
+            is_android(
+                r#"cfg(any(all(target_arch = "arm", target_pointer_width = "32"), target_arch = "mips", target_arch = "powerpc"))"#
+            ),
+            "32-bit arm"
+        );
+        assert!(is_android(
+            "cfg(all(not(windows), any(rustix_use_libc, miri, not(all(target_os = \"linux\", target_endian = \"little\", any(target_arch = \"arm\", all(target_arch = \"aarch64\", target_pointer_width = \"64\"), target_arch = \"riscv64\", all(rustix_use_experimental_asm, target_arch = \"powerpc64\"), all(rustix_use_experimental_asm, target_arch = \"mips\"), all(rustix_use_experimental_asm, target_arch = \"mips32r6\"), all(rustix_use_experimental_asm, target_arch = \"mips64\"), all(rustix_use_experimental_asm, target_arch = \"mips64r6\"), target_arch = \"x86\", all(target_arch = \"x86_64\", target_pointer_width = \"64\")))))))"
+        ), "rustix 0.38.31");
+    }
+
+    #[test]
+    fn test_required_android_deps() {
+        init_logger();
+
+        let aarch64_paging_0_7_1: Version =
+            serde_json::from_str(include_str!("testdata/aarch64-paging-0.7.1"))
+                .expect("Failed to parse JSON testdata");
+        assert_equal(
+            aarch64_paging_0_7_1.required_android_deps(),
+            [aarch64_paging_0_7_1
+                .dependencies()
+                .iter()
+                .find(|dep| dep.crate_name() == "bitflags")
+                .unwrap()],
+        );
+    }
+
+    // getrandom 0.3.3 has a complex cfg expression for the libc dependency.
+    #[test]
+    fn test_getrandom_cfg() {
+        init_logger();
+
+        assert!(
+            is_android(
+                r#"cfg(all(any(target_os = "linux", target_os = "android"), not(any(all(target_os = "linux", target_env = ""), getrandom_backend = "custom", getrandom_backend = "linux_raw", getrandom_backend = "rdrand", getrandom_backend = "rndr"))))"#
+            ),
+            "getrandom 0.3.3"
+        );
+
+        let getrandom_0_3_3: Version =
+            serde_json::from_str(include_str!("testdata/getrandom-0.3.3"))
+                .expect("Failed to parse JSON testdata");
+        assert_equal(
+            getrandom_0_3_3.required_android_deps().map(|dep| dep.crate_name()),
+            ["cfg-if", "libc"],
+        );
     }
 }
diff --git a/tools/external_crates/crates_io_util/src/dependency.rs b/tools/external_crates/crates_io_util/src/dependency.rs
new file mode 100644
index 000000000..d020e0443
--- /dev/null
+++ b/tools/external_crates/crates_io_util/src/dependency.rs
@@ -0,0 +1,42 @@
+// Copyright (C) 2025 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+use crates_index::Dependency;
+use semver::VersionReq;
+
+/// Trait for parsing version requirement strings of dependencies.
+pub trait ParsedVersionReq {
+    /// Parses a version requirement, returning an error if unsuccessful.
+    fn parsed_version_req(&self) -> Result<VersionReq, semver::Error>;
+}
+
+impl ParsedVersionReq for Dependency {
+    fn parsed_version_req(&self) -> Result<VersionReq, semver::Error> {
+        VersionReq::parse(self.requirement())
+    }
+}
+
+/// Trait for determining if dependencies in different versions of
+/// a crate are the same.
+pub trait SameDep {
+    /// Returns true if the two dependencies from different versions are
+    /// (probably) the same. That is, they have the same name and kind.
+    fn same_name_and_kind(&self, other: &Dependency) -> bool;
+}
+
+impl SameDep for Dependency {
+    fn same_name_and_kind(&self, other: &Dependency) -> bool {
+        self.name() == other.name() && self.kind() == other.kind()
+    }
+}
diff --git a/tools/external_crates/crates_io_util/src/dependency_diff.rs b/tools/external_crates/crates_io_util/src/dependency_diff.rs
index 7a138e871..29928124c 100644
--- a/tools/external_crates/crates_io_util/src/dependency_diff.rs
+++ b/tools/external_crates/crates_io_util/src/dependency_diff.rs
@@ -12,72 +12,134 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-use std::collections::BTreeMap;
+use std::collections::{HashMap, HashSet};
 
 use crates_index::{Dependency, Version};
+use itertools::Itertools;
+use log::debug;
 
-use crate::DepSet;
-
-// Diff dependencies between two versions of a crate.
-pub struct DependencyDiffer<'a> {
-    base_deps: DepSet<'a>,
-}
+use crate::dependency::SameDep;
 
+/// Diff dependencies between two versions of a crate.
+/// Holds a reference to the current (base) dependencies of a crate,
+/// against which multiple newer versions can be compared.
 #[derive(Debug)]
-pub struct ChangedDep<'base, 'other> {
-    pub base: &'base Dependency,
-    pub other: &'other Dependency,
-}
-
-type ChangedDeps<'base, 'other> = BTreeMap<&'base str, ChangedDep<'base, 'other>>;
-
-#[derive(Debug)]
-pub struct DependencyDiff<'base, 'other> {
-    pub added: DepSet<'other>,
-    pub deleted: DepSet<'base>,
-    pub changed: ChangedDeps<'base, 'other>,
+pub struct DependencyDiffer<'a> {
+    base_version: &'a Version,
 }
 
 impl<'a> DependencyDiffer<'a> {
-    pub fn new(base: &'a Version) -> DependencyDiffer<'a> {
-        let base_deps = BTreeMap::from_iter(base.dependencies().iter().map(|d| (d.name(), d)));
-        DependencyDiffer { base_deps }
+    /// Constructs a DependencyDiffer with the specified base version.
+    pub fn new(base_version: &'a Version) -> DependencyDiffer<'a> {
+        DependencyDiffer { base_version }
     }
+    /// Compares the base version with `other` and returns the differences.
     pub fn diff<'other>(&'a self, other: &'other Version) -> DependencyDiff<'a, 'other> {
-        let other_deps = BTreeMap::from_iter(other.dependencies().iter().map(|d| (d.name(), d)));
-
-        let added = other_deps
+        debug!(
+            "diff base:\n{}",
+            self.base_version
+                .dependencies()
+                .iter()
+                .map(|d| format!("{} {:?}", d.name(), d.kind()))
+                .join("\n")
+        );
+        debug!(
+            "diff other:\n{}",
+            other
+                .dependencies()
+                .iter()
+                .map(|d| format!("{} {:?}", d.name(), d.kind()))
+                .sorted()
+                .join("\n")
+        );
+        let added: HashSet<&Dependency> = other
+            .dependencies()
             .iter()
-            .filter(|(name, _)| !self.base_deps.contains_key(**name))
-            .map(|(name, dep)| (*name, *dep))
+            .filter(|other_dep| {
+                !self
+                    .base_version
+                    .dependencies()
+                    .iter()
+                    .any(|base_dep| base_dep.same_name_and_kind(other_dep))
+            })
             .collect();
-        let deleted = self
-            .base_deps
+        debug!(
+            "diff added:\n{}",
+            added.iter().map(|d| format!("{} {:?}", d.name(), d.kind())).sorted().join("\n")
+        );
+        let deleted: HashSet<&Dependency> = self
+            .base_version
+            .dependencies()
             .iter()
-            .filter(|(name, _)| !other_deps.contains_key(**name))
-            .map(|(name, dep)| (*name, *dep))
+            .filter(|base_dep| {
+                !other.dependencies().iter().any(|other_dep| base_dep.same_name_and_kind(other_dep))
+            })
             .collect();
-        let mut changed = ChangedDeps::new();
-        for (name, base_dep) in &self.base_deps {
-            if let Some(other_dep) = other_deps.get(name) {
+        debug!(
+            "diff deleted:\n{}",
+            deleted.iter().map(|d| format!("{} {:?}", d.name(), d.kind())).join("\n")
+        );
+        let mut changed = HashMap::new();
+        for base_dep in self.base_version.dependencies() {
+            if let Some(other_dep) =
+                other.dependencies().iter().find(|other_dep| base_dep.same_name_and_kind(other_dep))
+            {
                 if base_dep != other_dep {
-                    changed.insert(*name, ChangedDep { base: base_dep, other: other_dep });
+                    changed.insert(other_dep, base_dep);
                 }
             }
         }
+        debug!(
+            "diff changed:\n{}",
+            changed.keys().map(|d| format!("{} {:?}", d.name(), d.kind())).sorted().join("\n")
+        );
 
         DependencyDiff { added, deleted, changed }
     }
 }
 
+/// The difference between the dependencies of two versions of a crate.
+#[derive(Debug)]
+pub struct DependencyDiff<'base, 'other> {
+    /// Newly added dependencies.
+    added: HashSet<&'other Dependency>,
+    /// Dependencies that were deleted.
+    deleted: HashSet<&'base Dependency>,
+    /// Dependencies that differ between the two versions. For example,
+    /// they could have different version requirements.
+    changed: HashMap<&'other Dependency, &'base Dependency>,
+}
+
+impl<'base, 'other> DependencyDiff<'base, 'other> {
+    /// Returns true if the dependency is added in the new version.
+    pub fn is_added(&self, other: &'other Dependency) -> bool {
+        self.added.contains(other)
+    }
+    /// Returns true if the dependency is deleted in the new version.
+    pub fn is_deleted(&self, base: &'base Dependency) -> bool {
+        self.deleted.contains(base)
+    }
+    /// Returns true if the dependency is changed.
+    pub fn is_changed(&self, other: &'other Dependency) -> bool {
+        self.changed.contains_key(other)
+    }
+}
+
 #[cfg(test)]
 mod tests {
     use super::*;
 
-    use itertools::assert_equal;
+    use crates_index::DependencyKind;
+    use itertools::{assert_equal, Itertools};
+
+    fn init_logger() {
+        let _ =
+            env_logger::builder().filter_level(log::LevelFilter::max()).is_test(true).try_init();
+    }
 
     #[test]
     fn trivial() {
+        init_logger();
         let hashbrown_0_12_3: Version =
             serde_json::from_str(include_str!("testdata/hashbrown-0.12.3"))
                 .expect("Failed to parse JSON testdata");
@@ -90,6 +152,7 @@ mod tests {
 
     #[test]
     fn hashbrown() {
+        init_logger();
         let hashbrown_0_12_3: Version =
             serde_json::from_str(include_str!("testdata/hashbrown-0.12.3"))
                 .expect("Failed to parse JSON testdata");
@@ -98,21 +161,49 @@ mod tests {
                 .expect("Failed to parse JSON testdata");
         let differ = DependencyDiffer::new(&hashbrown_0_12_3);
         let diff = differ.diff(&hashbrown_0_14_5);
-        assert_equal(diff.added.keys(), ["allocator-api2", "equivalent", "rkyv"].iter());
-        assert!(diff.deleted.is_empty());
-        assert_equal(diff.changed.keys(), ["ahash", "bumpalo"].iter());
+        assert_equal(
+            diff.added
+                .iter()
+                .filter_map(
+                    |d| if d.kind() == DependencyKind::Normal { Some(d.name()) } else { None },
+                )
+                .sorted(),
+            ["allocator-api2", "equivalent", "rkyv"],
+        );
+        assert_equal(
+            diff.deleted
+                .iter()
+                .filter_map(
+                    |d| if d.kind() == DependencyKind::Normal { Some(d.name()) } else { None },
+                )
+                .sorted(),
+            ["bumpalo"],
+        );
+        assert_equal(
+            diff.changed
+                .keys()
+                .filter_map(
+                    |d| if d.kind() == DependencyKind::Normal { Some(d.name()) } else { None },
+                )
+                .sorted(),
+            ["ahash"],
+        );
     }
 
     #[test]
     fn winnow() {
+        init_logger();
         let winnow_0_5_37: Version = serde_json::from_str(include_str!("testdata/winnow-0.5.37"))
             .expect("Failed to parse JSON testdata");
         let winnow_0_6_20: Version = serde_json::from_str(include_str!("testdata/winnow-0.6.20"))
             .expect("Failed to parse JSON testdata");
         let differ = DependencyDiffer::new(&winnow_0_5_37);
         let diff = differ.diff(&winnow_0_6_20);
-        assert_equal(diff.added.keys(), ["annotate-snippets", "anyhow", "automod"].iter());
-        assert_equal(diff.deleted.keys(), ["escargot"].iter());
-        assert_equal(diff.changed.keys(), ["snapbox", "terminal_size"].iter());
+        assert_equal(
+            diff.added.iter().map(|d| d.name()).sorted(),
+            ["annotate-snippets", "anyhow", "automod"],
+        );
+        assert_equal(diff.deleted.iter().map(|d| d.name()).sorted(), ["escargot"]);
+        assert_equal(diff.changed.keys().map(|d| d.name()).sorted(), ["snapbox", "terminal_size"]);
     }
 }
diff --git a/tools/external_crates/crates_io_util/src/feature.rs b/tools/external_crates/crates_io_util/src/feature.rs
index b5e2e98da..f1bd2134c 100644
--- a/tools/external_crates/crates_io_util/src/feature.rs
+++ b/tools/external_crates/crates_io_util/src/feature.rs
@@ -16,14 +16,17 @@ use std::{borrow::Borrow, collections::BTreeSet};
 
 use crates_index::{Dependency, Version};
 
-// A reference to feature. Either an explicit feature or an optional dependency.
+/// A reference to feature. Either an explicit feature or an optional dependency.
 #[derive(Debug, Clone, PartialEq, Eq)]
 pub enum FeatureRef<'a> {
+    /// An explicit feature
     Feature(&'a str),
+    /// An optional dependency
     OptionalDep(&'a Dependency),
 }
 
-impl<'a> FeatureRef<'a> {
+impl FeatureRef<'_> {
+    /// The name of the feature.
     pub fn name(&self) -> &str {
         match self {
             FeatureRef::Feature(name) => name,
@@ -33,19 +36,19 @@ impl<'a> FeatureRef<'a> {
 }
 
 // Traits that let us use FeatureRef as an element of a set.
-impl<'a> PartialOrd for FeatureRef<'a> {
+impl PartialOrd for FeatureRef<'_> {
     fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
         Some(self.cmp(other))
     }
 }
-impl<'a> Ord for FeatureRef<'a> {
+impl Ord for FeatureRef<'_> {
     fn cmp(&self, other: &Self) -> std::cmp::Ordering {
         self.name().cmp(other.name())
     }
 }
 
 // Lets us retrieve a set element by name.
-impl<'a> Borrow<str> for FeatureRef<'a> {
+impl Borrow<str> for FeatureRef<'_> {
     fn borrow(&self) -> &str {
         self.name()
     }
@@ -53,7 +56,9 @@ impl<'a> Borrow<str> for FeatureRef<'a> {
 
 pub type TypedFeatures<'a> = BTreeSet<FeatureRef<'a>>;
 
+/// A trait for merging explicit features and optional dependencies into a single set.
 pub trait FeaturesAndOptionalDeps {
+    /// Returns a unified list of the features and optional dependencies of a crate version.
     fn features_and_optional_deps(&self) -> TypedFeatures;
 }
 
diff --git a/tools/external_crates/crates_io_util/src/feature_diff.rs b/tools/external_crates/crates_io_util/src/feature_diff.rs
index c55c286c1..b183f2452 100644
--- a/tools/external_crates/crates_io_util/src/feature_diff.rs
+++ b/tools/external_crates/crates_io_util/src/feature_diff.rs
@@ -16,22 +16,30 @@ use crates_index::Version;
 
 use crate::feature::{FeaturesAndOptionalDeps, TypedFeatures};
 
-// Diff features between two versions of a crate.
+/// Diff features between two versions of a crate.
+/// Holds a reference to the current (base) features of a crate,
+/// against which multiple newer versions can be compared.
+#[derive(Debug)]
 pub struct FeatureDiffer<'a> {
     base_features: TypedFeatures<'a>,
 }
 
+/// A pair of features that differ between two versions of a crate.
 #[derive(Debug)]
 pub struct FeatureDiff<'base, 'other> {
+    /// Newly added features.
     pub added: TypedFeatures<'other>,
+    /// Features that were deleted.
     pub deleted: TypedFeatures<'base>,
 }
 
 impl<'a> FeatureDiffer<'a> {
+    /// Constructs a FeatureDiffer with the specified base version.
     pub fn new(base: &'a Version) -> FeatureDiffer<'a> {
         let base_features = base.features_and_optional_deps();
         FeatureDiffer { base_features }
     }
+    /// Compares the base version with `other` and returns the differences.
     pub fn diff<'other>(&'a self, other: &'other Version) -> FeatureDiff<'a, 'other> {
         let other_features = other.features_and_optional_deps();
         let deleted = self
diff --git a/tools/external_crates/crates_io_util/src/feature_resolver.rs b/tools/external_crates/crates_io_util/src/feature_resolver.rs
index 8742dce78..b79fab8c3 100644
--- a/tools/external_crates/crates_io_util/src/feature_resolver.rs
+++ b/tools/external_crates/crates_io_util/src/feature_resolver.rs
@@ -12,79 +12,146 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-use std::collections::{BTreeMap, BTreeSet};
+use std::collections::{BTreeMap, BTreeSet, HashSet};
 
-use crates_index::Version;
+use cargo_toml::DependencyDetail;
+use crates_index::{Dependency, Version};
+use itertools::Itertools;
+use log::debug;
 
-use crate::{
-    feature::{FeaturesAndOptionalDeps, TypedFeatures},
-    DepSet, Error,
-};
+use crate::{AndroidTarget, Error, RequiredAndroidDeps};
 
-// Resolve a list of enabled features to a set of optional dependencies that these features switch on.
+/// Resolves a list of enabled features to a set of optional dependencies that these features switch on.
 pub struct FeatureResolver<'a> {
     version: &'a Version,
-    features: TypedFeatures<'a>,
-    deps: DepSet<'a>,
 }
 
 impl<'a> FeatureResolver<'a> {
+    /// Constructs a FeatureResolver for the specified version of a crate.
     pub fn new(version: &'a Version) -> FeatureResolver<'a> {
-        let features = version.features_and_optional_deps();
-        let deps = BTreeMap::from_iter(version.dependencies().iter().map(|d| (d.name(), d)));
-        FeatureResolver { version, features, deps }
+        FeatureResolver { version }
     }
+    /// Resolves a list of enabled features into a set of required and optional dependencies.
     pub fn resolve(
+        &'a self,
+        features: Option<impl Iterator<Item = impl AsRef<str>>>,
+    ) -> Result<impl Iterator<Item = &'a crates_index::Dependency>, Error> {
+        Ok(self.version.required_android_deps().chain(self.resolve_optional(features)?))
+    }
+    /// Resolves a list of enabled features into a set of optional dependencies.
+    pub fn resolve_optional(
         &self,
         features: Option<impl Iterator<Item = impl AsRef<str>>>,
-    ) -> Result<DepSet<'a>, Error> {
+    ) -> Result<HashSet<&Dependency>, Error> {
+        debug!("Resolving {}", self.version.name());
+        let resolver = cargo_toml::features::Resolver::new();
+
+        let normal_dependencies_by_name = self
+            .version
+            .dependencies()
+            .iter()
+            .filter_map(|dep| match dep.kind() {
+                crates_index::DependencyKind::Normal => Some((dep.name(), dep)),
+                _ => None,
+            })
+            .collect::<BTreeMap<_, _>>();
+
+        let mut dep_details = Vec::new();
+        for dep in self.version.dependencies() {
+            dep_details.push(
+                if !dep.is_optional() && dep.has_default_features() && dep.package().is_none() {
+                    cargo_toml::Dependency::Simple(dep.requirement().into())
+                } else {
+                    cargo_toml::Dependency::Detailed(Box::new(DependencyDetail {
+                        version: Some(dep.requirement().to_string()),
+                        package: dep.package().map(String::from),
+                        registry: None,
+                        registry_index: None,
+                        path: None,
+                        inherited: false,
+                        git: None,
+                        branch: None,
+                        tag: None,
+                        rev: None,
+                        features: dep.features().to_vec(),
+                        optional: dep.is_optional(),
+                        default_features: dep.has_default_features(),
+                        unstable: BTreeMap::new(),
+                    }))
+                },
+            );
+        }
+
+        let mut parse_deps = Vec::new();
+        for (dep, dep_detail) in self.version.dependencies().iter().zip(&dep_details) {
+            let parse_dep = cargo_toml::features::ParseDependency {
+                key: dep.name(),
+                kind: match dep.kind() {
+                    crates_index::DependencyKind::Normal => cargo_toml::features::Kind::Normal,
+                    crates_index::DependencyKind::Dev => cargo_toml::features::Kind::Dev,
+                    crates_index::DependencyKind::Build => cargo_toml::features::Kind::Build,
+                },
+                target: dep.target(),
+                dep: dep_detail,
+            };
+            parse_deps.push(parse_dep);
+        }
+        let parsed_features =
+            resolver.parse_custom(self.version.features(), parse_deps.into_iter());
+
+        let mut resolved = HashSet::new();
+        let mut resolved_features = BTreeSet::new();
         let mut frontier = BTreeSet::new();
         if let Some(features) = features {
             for feature in features {
-                let feature = feature.as_ref().to_string();
-                if !self.features.contains(feature.as_str()) {
-                    return Err(Error::FeatureNotFound(feature, self.version.name().to_string()));
-                }
-                frontier.insert(feature);
+                frontier.insert(feature.as_ref().to_string());
             }
-        } else if self.features.contains("default") {
+        } else if self.version.features().contains_key("default") {
             frontier.insert("default".to_string());
         }
-        let mut resolved = DepSet::new();
-        while !frontier.is_empty() {
-            let f = frontier.pop_first().unwrap();
-            let f = f.as_str();
-            if let Some(dep) = self.features.get(f) {
-                match dep {
-                    crate::FeatureRef::Feature(_) => {
-                        for child in self.version.features().get(f).unwrap() {
-                            let child = child.split_once('/').unwrap_or((child, "")).0;
-                            if child.contains('?') {
-                                continue;
-                            }
-                            if let Some(c) = child.strip_prefix("dep:") {
-                                let dep = self.deps.get(c).ok_or(Error::DepNotFound(
-                                    c.to_string(),
-                                    self.version.name().to_string(),
-                                ))?;
-                                resolved.insert(dep.name(), dep);
-                            } else {
-                                frontier.insert(child.to_string());
-                            }
+        debug!("  features = {}", frontier.iter().join(", "));
+        while let Some(f) = frontier.pop_first() {
+            debug!("  popped {f}");
+            if resolved_features.contains(&f) {
+                debug!("    skipping because we already resolved it");
+                continue;
+            }
+            resolved_features.insert(f.clone());
+            if let Some(feature) = parsed_features.features.get(f.as_str()) {
+                if f.as_str() == "default" && !self.version.features().contains_key("default") {
+                    return Err(Error::FeatureNotFound {
+                        crate_name: self.version.name().to_string(),
+                        feature_name: "default".to_string(),
+                    });
+                }
+                for (dep_name, dep_action) in &feature.enables_deps {
+                    debug!("      enables dep {dep_name}");
+                    if let Some(dep) = normal_dependencies_by_name.get(dep_name) {
+                        if !dep_action.is_conditional
+                            && dep.is_optional()
+                            && dep.is_android_target()
+                        {
+                            resolved.insert(*dep);
+                        } else {
+                            debug!("        skipping. is_conditional = {}, optional = {}, android_target = {}", dep_action.is_conditional, dep.is_optional(), dep.is_android_target());
                         }
+                    } else {
+                        debug!("        dep is not a normal dependency");
                     }
-                    crate::FeatureRef::OptionalDep(d) => {
-                        resolved.insert(d.name(), d);
-                    }
                 }
-            } else {
-                let dep = self
-                    .deps
-                    .get(f)
-                    .ok_or(Error::DepNotFound(f.to_string(), self.version.name().to_string()))?;
-                resolved.insert(dep.name(), dep);
+                for feature_name in &feature.enables_features {
+                    debug!("      enables feature {feature_name}");
+                    frontier.insert(feature_name.to_string());
+                }
+            } else if !parsed_features.hidden_features.contains_key(f.as_str()) {
+                debug!("Feature {f} not found, not even as a hidden feature");
+                return Err(Error::FeatureNotFound {
+                    crate_name: self.version.name().to_string(),
+                    feature_name: f,
+                });
             }
         }
+
         Ok(resolved)
     }
 }
@@ -101,15 +168,24 @@ mod tests {
             serde_json::from_str(include_str!("testdata/hashbrown-0.12.3"))
                 .expect("Failed to parse JSON testdata");
         let resolver = FeatureResolver::new(&hashbrown_0_12_3);
-        assert_equal(resolver.resolve(Some(["bumpalo"].iter()))?.keys(), ["bumpalo"].iter());
-        assert_equal(resolver.resolve(Some(["default"].iter()))?.keys(), ["ahash"].iter());
+        assert_equal(
+            resolver.resolve_optional(Some(["bumpalo"].iter()))?.into_iter().map(|d| d.name()),
+            ["bumpalo"],
+        );
+        assert_equal(
+            resolver.resolve_optional(Some(["default"].iter()))?.into_iter().map(|d| d.name()),
+            ["ahash"],
+        );
         // ahash-compile-time-rng depends on ahash/compile-time-rng
         assert_equal(
-            resolver.resolve(Some(["ahash-compile-time-rng"].iter()))?.keys(),
-            ["ahash"].iter(),
+            resolver
+                .resolve_optional(Some(["ahash-compile-time-rng"].iter()))?
+                .into_iter()
+                .map(|d| d.name()),
+            ["ahash"],
         );
         assert!(
-            resolver.resolve(Some(["inline-more"].iter()))?.is_empty(),
+            resolver.resolve_optional(Some(["inline-more"].iter()))?.is_empty(),
             "inline-more has no deps associated with it"
         );
 
@@ -118,12 +194,16 @@ mod tests {
                 .expect("Failed to parse JSON testdata");
         let resolver = FeatureResolver::new(&hashbrown_0_14_5);
         assert!(
-            resolver.resolve(Some(["bumpalo"].iter())).is_err(),
+            resolver.resolve_optional(Some(["bumpalo"].iter())).is_err(),
             "bumpalo is no longer an optional dep in hashbrown-0.14.5"
         );
         assert_equal(
-            resolver.resolve(Some(["default"].iter()))?.keys(),
-            ["ahash", "allocator-api2"].iter(),
+            resolver
+                .resolve_optional(Some(["default"].iter()))?
+                .into_iter()
+                .map(|d| d.name())
+                .sorted(),
+            ["ahash", "allocator-api2"],
         );
         Ok(())
     }
@@ -135,8 +215,11 @@ mod tests {
                 .expect("Failed to parse JSON testdata");
         let resolver = FeatureResolver::new(&hashbrown_0_12_3);
         assert_equal(
-            resolver.resolve(Some(["ahash", "default", "inline-more", "raw"].iter()))?.keys(),
-            ["ahash"].iter(),
+            resolver
+                .resolve_optional(Some(["ahash", "default", "inline-more", "raw"].iter()))?
+                .into_iter()
+                .map(|d| d.name()),
+            ["ahash"],
         );
         Ok(())
     }
@@ -148,28 +231,40 @@ mod tests {
                 .expect("Failed to parse JSON testdata");
         let resolver = FeatureResolver::new(&hashbrown_0_12_3);
         let empty: Option<Box<dyn Iterator<Item = &str>>> = None;
-        assert_equal(resolver.resolve(empty), resolver.resolve(Some(["default"].iter())));
+        assert_equal(
+            resolver.resolve_optional(empty),
+            resolver.resolve_optional(Some(["default"].iter())),
+        );
 
         let hashbrown_0_14_5: Version =
             serde_json::from_str(include_str!("testdata/hashbrown-0.14.5"))
                 .expect("Failed to parse JSON testdata");
         let resolver = FeatureResolver::new(&hashbrown_0_14_5);
         let empty: Option<Box<dyn Iterator<Item = &str>>> = None;
-        assert_equal(resolver.resolve(empty), resolver.resolve(Some(["default"].iter())));
+        assert_equal(
+            resolver.resolve_optional(empty),
+            resolver.resolve_optional(Some(["default"].iter())),
+        );
 
         let winnow_0_5_37: Version = serde_json::from_str(include_str!("testdata/winnow-0.5.37"))
             .expect("Failed to parse JSON testdata");
         let resolver = FeatureResolver::new(&winnow_0_5_37);
         let empty: Option<Box<dyn Iterator<Item = &str>>> = None;
-        assert_equal(resolver.resolve(empty), resolver.resolve(Some(["default"].iter())));
+        assert_equal(
+            resolver.resolve_optional(empty),
+            resolver.resolve_optional(Some(["default"].iter())),
+        );
 
         let cfg_if_1_0_0: Version = serde_json::from_str(include_str!("testdata/cfg-if-1.0.0"))
             .expect("Failed to parse JSON testdata");
         let resolver = FeatureResolver::new(&cfg_if_1_0_0);
         let empty: Option<Box<dyn Iterator<Item = &str>>> = None;
-        assert!(resolver.resolve(empty)?.is_empty(), "cfg-if has no explicit 'default' feature");
         assert!(
-            resolver.resolve(Some(["default"].iter())).is_err(),
+            resolver.resolve_optional(empty)?.is_empty(),
+            "cfg-if has no explicit 'default' feature"
+        );
+        assert!(
+            resolver.resolve_optional(Some(["default"].iter())).is_err(),
             "cfg-if has no explicit 'default' feature"
         );
 
@@ -182,9 +277,12 @@ mod tests {
             .expect("Failed to parse JSON testdata");
         let resolver = FeatureResolver::new(&winnow_0_5_37);
         // "simd" depends on "dep:memchr"
-        assert_equal(resolver.resolve(Some(["simd"].iter()))?.keys(), ["memchr"].iter());
+        assert_equal(
+            resolver.resolve_optional(Some(["simd"].iter()))?.into_iter().map(|d| d.name()),
+            ["memchr"],
+        );
         assert!(
-            resolver.resolve(Some(["std"].iter()))?.is_empty(),
+            resolver.resolve_optional(Some(["std"].iter()))?.is_empty(),
             "'std' depends on 'memchr?/std', which should be omitted since it's optional."
         );
 
@@ -198,8 +296,39 @@ mod tests {
                 .expect("Failed to parse JSON testdata");
         let resolver = FeatureResolver::new(&aarch64_paging_0_7_1);
         let empty: Option<Box<dyn Iterator<Item = &str>>> = None;
-        assert_equal(resolver.resolve(empty)?.keys(), ["zerocopy"].iter());
+        assert_equal(resolver.resolve_optional(empty)?.into_iter().map(|d| d.name()), ["zerocopy"]);
+
+        Ok(())
+    }
+
+    #[test]
+    fn recursion_bug_2() -> Result<(), Error> {
+        let axum_0_7_0: Version = serde_json::from_str(include_str!("testdata/axum-0.7.0"))
+            .expect("Failed to parse JSON testdata");
+        let resolver = FeatureResolver::new(&axum_0_7_0);
+        let empty: Option<Box<dyn Iterator<Item = &str>>> = None;
+        assert_equal(
+            resolver.resolve_optional(empty)?.into_iter().map(|d| d.name()).sorted(),
+            [
+                "hyper",
+                "hyper-util",
+                "serde_json",
+                "serde_path_to_error",
+                "serde_urlencoded",
+                "tokio",
+            ],
+        );
 
         Ok(())
     }
+
+    #[test]
+    fn android_dep() -> Result<(), Error> {
+        let chrono_0_4_39: Version = serde_json::from_str(include_str!("testdata/chrono-0.4.39"))
+            .expect("Failed to parse JSON testdata");
+        let resolver = FeatureResolver::new(&chrono_0_4_39);
+        let empty: Option<Box<dyn Iterator<Item = &str>>> = None;
+        assert!(resolver.resolve_optional(empty)?.iter().any(|d| d.name() == "android-tzdata"));
+        Ok(())
+    }
 }
diff --git a/tools/external_crates/crates_io_util/src/index.rs b/tools/external_crates/crates_io_util/src/index.rs
index a98fff83d..8f032c0ca 100644
--- a/tools/external_crates/crates_io_util/src/index.rs
+++ b/tools/external_crates/crates_io_util/src/index.rs
@@ -12,25 +12,34 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-use crates_index::{http, Crate, SparseIndex};
-use std::{cell::RefCell, collections::HashSet};
+use crates_index::{Crate, SparseIndex};
+use std::{cell::RefCell, collections::HashSet, process::Command};
+use success_or_error::RunAndExpectSuccess;
 
 use crate::Error;
 
+/// A local index of crates.io data, with a way of updating the index
+/// by fetching data from crates.io.
 pub struct CratesIoIndex {
     fetcher: Box<dyn CratesIoFetcher>,
 }
 
 impl CratesIoIndex {
-    pub fn new() -> Result<CratesIoIndex, Error> {
+    /// Constructs a CratesIoIndex that uses the `ureq` crate
+    /// to fetch data from crates.io via https.
+    #[cfg(feature = "ureq")]
+    pub fn new_ureq() -> Result<CratesIoIndex, Error> {
         Ok(CratesIoIndex {
-            fetcher: Box::new(OnlineFetcher {
+            fetcher: Box::new(UreqFetcher {
                 index: crates_index::SparseIndex::new_cargo_default()?,
                 agent: ureq::Agent::new_with_defaults(),
                 fetched: RefCell::new(HashSet::new()),
             }),
         })
     }
+    /// Constructs a CratesIoIndex in offline mode. No new data is
+    /// fetched from crates.io, but data already in the local cache
+    /// is returned.
     pub fn new_offline() -> Result<CratesIoIndex, Error> {
         Ok(CratesIoIndex {
             fetcher: Box::new(OfflineFetcher {
@@ -38,6 +47,18 @@ impl CratesIoIndex {
             }),
         })
     }
+    /// Constructs a CratesIoIndex that uses cargo commands to fetch data
+    /// from crates.io. Less efficient than making direct https requests,
+    /// but avoids complicated dependencies on cryptographic crates.
+    pub fn new_cargo() -> Result<CratesIoIndex, Error> {
+        Ok(CratesIoIndex {
+            fetcher: Box::new(CargoFetcher {
+                index: crates_index::SparseIndex::new_cargo_default()?,
+                fetched: RefCell::new(HashSet::new()),
+            }),
+        })
+    }
+    /// Fetches and returns the crates.io data on a crate.
     pub fn get_crate(&self, crate_name: impl AsRef<str>) -> Result<Crate, Error> {
         self.fetcher.fetch(crate_name.as_ref())
     }
@@ -47,18 +68,16 @@ pub trait CratesIoFetcher {
     fn fetch(&self, crate_name: &str) -> Result<Crate, Error>;
 }
 
-struct OnlineFetcher {
+#[cfg(feature = "ureq")]
+struct UreqFetcher {
     index: SparseIndex,
     agent: ureq::Agent,
     // Keep track of crates we have fetched, to avoid fetching them multiple times.
     fetched: RefCell<HashSet<String>>,
 }
 
-struct OfflineFetcher {
-    index: SparseIndex,
-}
-
-impl CratesIoFetcher for OnlineFetcher {
+#[cfg(feature = "ureq")]
+impl CratesIoFetcher for UreqFetcher {
     fn fetch(&self, crate_name: &str) -> Result<Crate, Error> {
         let mut fetched = self.fetched.borrow_mut();
         if fetched.contains(crate_name) {
@@ -73,7 +92,7 @@ impl CratesIoFetcher for OnlineFetcher {
 
         let response = self.agent.run(request)?;
         let (parts, mut body) = response.into_parts();
-        let response = http::Response::from_parts(parts, body.read_to_vec()?);
+        let response = crates_index::http::Response::from_parts(parts, body.read_to_vec()?);
         let response = self
             .index
             .parse_cache_response(crate_name, response, true)?
@@ -84,8 +103,45 @@ impl CratesIoFetcher for OnlineFetcher {
     }
 }
 
+struct OfflineFetcher {
+    index: SparseIndex,
+}
+
 impl CratesIoFetcher for OfflineFetcher {
     fn fetch(&self, crate_name: &str) -> Result<Crate, Error> {
         Ok(self.index.crate_from_cache(crate_name.as_ref())?)
     }
 }
+
+// A fetcher that uses cargo commands to update the index. This
+// lets us avoid complicated dependencies on crates that implement
+// https.
+struct CargoFetcher {
+    index: SparseIndex,
+    // Keep track of crates we have fetched, to avoid fetching them multiple times.
+    fetched: RefCell<HashSet<String>>,
+}
+
+impl CratesIoFetcher for CargoFetcher {
+    fn fetch(&self, crate_name: &str) -> Result<Crate, Error> {
+        let mut fetched = self.fetched.borrow_mut();
+        if !fetched.contains(crate_name) {
+            let tempdir = tempfile::tempdir()?;
+            Command::new("cargo")
+                .args(["init", "--lib", "--name", "fake-crate"])
+                .current_dir(&tempdir)
+                .run_quiet_and_expect_success()?;
+            Command::new("cargo")
+                .args(["add", crate_name])
+                .current_dir(&tempdir)
+                .run_quiet_and_expect_success()?;
+            Command::new("cargo")
+                .args(["update", crate_name])
+                .current_dir(&tempdir)
+                .run_quiet_and_expect_success()?;
+            fetched.insert(crate_name.to_string());
+        }
+
+        Ok(self.index.crate_from_cache(crate_name.as_ref())?)
+    }
+}
diff --git a/tools/external_crates/crates_io_util/src/lib.rs b/tools/external_crates/crates_io_util/src/lib.rs
index dcf3ef9de..a439490eb 100644
--- a/tools/external_crates/crates_io_util/src/lib.rs
+++ b/tools/external_crates/crates_io_util/src/lib.rs
@@ -12,13 +12,15 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-use std::collections::BTreeMap;
-
-use crates_index::Dependency;
-use semver::VersionReq;
+//! Crate for fetching and interacting with crates.io data. Built on top
+//! of crates_index, with Android-specific helpers for dealing with features,
+//! dependencies, etc.
 
 mod android_target;
-pub use android_target::AndroidTarget;
+pub use android_target::{AndroidTarget, RequiredAndroidDeps};
+
+mod dependency;
+pub use dependency::{ParsedVersionReq, SameDep};
 
 mod dependency_diff;
 pub use dependency_diff::DependencyDiffer;
@@ -35,17 +37,8 @@ pub use feature_resolver::FeatureResolver;
 mod index;
 pub use index::CratesIoIndex;
 
-type DepSet<'a> = BTreeMap<&'a str, &'a Dependency>;
-
-pub trait ParsedVersionReq {
-    fn parsed_version_req(&self) -> Result<VersionReq, semver::Error>;
-}
-
-impl ParsedVersionReq for Dependency {
-    fn parsed_version_req(&self) -> Result<VersionReq, semver::Error> {
-        VersionReq::parse(self.requirement())
-    }
-}
+mod versions;
+pub use versions::{GetVersion, IsSafe, ParsedVersion, SafeVersions};
 
 /// Error types for the 'crates_io_util' crate.
 #[derive(thiserror::Error, Debug)]
@@ -54,15 +47,26 @@ pub enum Error {
     #[error("Crate {0} not found in crates.io")]
     CrateNotFound(String),
     /// Feature not found for crate
-    #[error("Feature {0} not found for crate {1}")]
-    FeatureNotFound(String, String),
+    #[error("Feature {feature_name} not found for crate {crate_name}")]
+    FeatureNotFound {
+        /// The name of the crate.
+        crate_name: String,
+        /// The name of the feature.
+        feature_name: String,
+    },
     /// Dependency not found for crate
-    #[error("Dependency {0} not found for crate {1}")]
-    DepNotFound(String, String),
+    #[error("Dependency {dep_name} not found for crate {crate_name}")]
+    DepNotFound {
+        /// The name of the crate.
+        crate_name: String,
+        /// The name of the dependency.
+        dep_name: String,
+    },
     /// Failed to get HTTP headers
     #[error("Failed to get HTTP headers")]
     HttpHeader,
     /// Error fetching HTTP data
+    #[cfg(feature = "ureq")]
     #[error(transparent)]
     HttpFetch(#[from] ureq::Error),
     /// Propagated crates_index::Error
@@ -71,4 +75,10 @@ pub enum Error {
     /// Propagated crates_index::http::Error
     #[error(transparent)]
     CratesIndexHttp(#[from] crates_index::http::Error),
+    /// Propagated io::Error
+    #[error(transparent)]
+    IoError(#[from] std::io::Error),
+    /// Error running cargo
+    #[error(transparent)]
+    CargoError(#[from] success_or_error::Error),
 }
diff --git a/tools/external_crates/crates_io_util/src/testdata/ahash-0.8.3 b/tools/external_crates/crates_io_util/src/testdata/ahash-0.8.3
new file mode 100644
index 000000000..d8e4028be
--- /dev/null
+++ b/tools/external_crates/crates_io_util/src/testdata/ahash-0.8.3
@@ -0,0 +1,161 @@
+{
+  "name": "ahash",
+  "vers": "0.8.3",
+  "deps": [
+    {
+      "name": "atomic-polyfill",
+      "req": "^1.0.1",
+      "features": [],
+      "kind": "normal",
+      "optional": true,
+      "default_features": true
+    },
+    {
+      "name": "cfg-if",
+      "req": "^1.0",
+      "features": [],
+      "kind": "normal",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "const-random",
+      "req": "^0.1.12",
+      "features": [],
+      "kind": "normal",
+      "optional": true,
+      "default_features": true
+    },
+    {
+      "name": "criterion",
+      "req": "^0.3.2",
+      "features": [
+        "html_reports"
+      ],
+      "kind": "dev",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "fnv",
+      "req": "^1.0.5",
+      "features": [],
+      "kind": "dev",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "fxhash",
+      "req": "^0.2.1",
+      "features": [],
+      "kind": "dev",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "getrandom",
+      "req": "^0.2.7",
+      "features": [],
+      "kind": "normal",
+      "optional": true,
+      "default_features": true
+    },
+    {
+      "name": "hashbrown",
+      "req": "^0.12.3",
+      "features": [],
+      "kind": "dev",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "hex",
+      "req": "^0.4.2",
+      "features": [],
+      "kind": "dev",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "no-panic",
+      "req": "^0.1.10",
+      "features": [],
+      "kind": "dev",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "once_cell",
+      "req": "^1.13.1",
+      "features": [
+        "unstable",
+        "alloc"
+      ],
+      "kind": "normal",
+      "target": "cfg(not(all(target_arch = \"arm\", target_os = \"none\")))",
+      "optional": false,
+      "default_features": false
+    },
+    {
+      "name": "rand",
+      "req": "^0.8.5",
+      "features": [],
+      "kind": "dev",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "seahash",
+      "req": "^4.0",
+      "features": [],
+      "kind": "dev",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "serde",
+      "req": "^1.0.117",
+      "features": [],
+      "kind": "normal",
+      "optional": true,
+      "default_features": true
+    },
+    {
+      "name": "serde_json",
+      "req": "^1.0.59",
+      "features": [],
+      "kind": "dev",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "version_check",
+      "req": "^0.9.4",
+      "features": [],
+      "kind": "build",
+      "optional": false,
+      "default_features": true
+    }
+  ],
+  "features": {
+    "default": [
+      "std",
+      "runtime-rng"
+    ],
+    "no-rng": [],
+    "runtime-rng": [
+      "getrandom"
+    ],
+    "atomic-polyfill": [
+      "dep:atomic-polyfill",
+      "once_cell/atomic-polyfill"
+    ],
+    "std": [],
+    "compile-time-rng": [
+      "const-random"
+    ]
+  },
+  "rust_version": null,
+  "cksum": "2c99f64d1e06488f620f932677e24bc6e2897582980441ae90a671415bd7ec2f",
+  "yanked": true
+}
diff --git a/tools/external_crates/crates_io_util/src/testdata/axum-0.7.0 b/tools/external_crates/crates_io_util/src/testdata/axum-0.7.0
new file mode 100644
index 000000000..6391ba161
--- /dev/null
+++ b/tools/external_crates/crates_io_util/src/testdata/axum-0.7.0
@@ -0,0 +1,555 @@
+{
+  "name": "axum",
+  "vers": "0.7.0",
+  "deps": [
+    {
+      "name": "anyhow",
+      "req": "^1.0",
+      "features": [],
+      "kind": "dev",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "async-trait",
+      "req": "^0.1.67",
+      "features": [],
+      "kind": "normal",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "axum-core",
+      "req": "^0.4.0",
+      "features": [],
+      "kind": "normal",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "axum-macros",
+      "req": "^0.4.0",
+      "features": [],
+      "kind": "normal",
+      "optional": true,
+      "default_features": true
+    },
+    {
+      "name": "axum-macros",
+      "req": "^0.4.0",
+      "features": [
+        "__private"
+      ],
+      "kind": "dev",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "base64",
+      "req": "^0.21.0",
+      "features": [],
+      "kind": "normal",
+      "optional": true,
+      "default_features": true
+    },
+    {
+      "name": "bytes",
+      "req": "^1.0",
+      "features": [],
+      "kind": "normal",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "futures-util",
+      "req": "^0.3",
+      "features": [
+        "alloc"
+      ],
+      "kind": "normal",
+      "optional": false,
+      "default_features": false
+    },
+    {
+      "name": "http",
+      "req": "^1.0.0",
+      "features": [],
+      "kind": "normal",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "http-body",
+      "req": "^1.0.0",
+      "features": [],
+      "kind": "normal",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "http-body-util",
+      "req": "^0.1.0",
+      "features": [],
+      "kind": "normal",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "hyper",
+      "req": "^1.0.0",
+      "features": [],
+      "kind": "normal",
+      "optional": true,
+      "default_features": true
+    },
+    {
+      "name": "hyper-util",
+      "req": "^0.1.1",
+      "features": [
+        "tokio",
+        "server",
+        "server-auto"
+      ],
+      "kind": "normal",
+      "optional": true,
+      "default_features": true
+    },
+    {
+      "name": "itoa",
+      "req": "^1.0.5",
+      "features": [],
+      "kind": "normal",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "matchit",
+      "req": "^0.7",
+      "features": [],
+      "kind": "normal",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "memchr",
+      "req": "^2.4.1",
+      "features": [],
+      "kind": "normal",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "mime",
+      "req": "^0.3.16",
+      "features": [],
+      "kind": "normal",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "multer",
+      "req": "^2.0.0",
+      "features": [],
+      "kind": "normal",
+      "optional": true,
+      "default_features": true
+    },
+    {
+      "name": "percent-encoding",
+      "req": "^2.1",
+      "features": [],
+      "kind": "normal",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "pin-project-lite",
+      "req": "^0.2.7",
+      "features": [],
+      "kind": "normal",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "quickcheck",
+      "req": "^1.0",
+      "features": [],
+      "kind": "dev",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "quickcheck_macros",
+      "req": "^1.0",
+      "features": [],
+      "kind": "dev",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "reqwest",
+      "req": "^0.11.14",
+      "features": [
+        "json",
+        "stream",
+        "multipart"
+      ],
+      "kind": "dev",
+      "optional": false,
+      "default_features": false
+    },
+    {
+      "name": "rustversion",
+      "req": "^1.0.9",
+      "features": [],
+      "kind": "build",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "rustversion",
+      "req": "^1.0.9",
+      "features": [],
+      "kind": "dev",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "serde",
+      "req": "^1.0",
+      "features": [],
+      "kind": "normal",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "serde",
+      "req": "^1.0",
+      "features": [
+        "derive"
+      ],
+      "kind": "dev",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "serde_json",
+      "req": "^1.0",
+      "features": [
+        "raw_value"
+      ],
+      "kind": "normal",
+      "optional": true,
+      "default_features": true
+    },
+    {
+      "name": "serde_json",
+      "req": "^1.0",
+      "features": [],
+      "kind": "dev",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "serde_path_to_error",
+      "req": "^0.1.8",
+      "features": [],
+      "kind": "normal",
+      "optional": true,
+      "default_features": true
+    },
+    {
+      "name": "serde_urlencoded",
+      "req": "^0.7",
+      "features": [],
+      "kind": "normal",
+      "optional": true,
+      "default_features": true
+    },
+    {
+      "name": "sha1",
+      "req": "^0.10",
+      "features": [],
+      "kind": "normal",
+      "optional": true,
+      "default_features": true
+    },
+    {
+      "name": "sync_wrapper",
+      "req": "^0.1.1",
+      "features": [],
+      "kind": "normal",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "time",
+      "req": "^0.3",
+      "features": [
+        "serde-human-readable"
+      ],
+      "kind": "dev",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "tokio",
+      "req": "^1.25.0",
+      "features": [
+        "time"
+      ],
+      "package": "tokio",
+      "kind": "normal",
+      "optional": true,
+      "default_features": true
+    },
+    {
+      "name": "tokio",
+      "req": "^1.25.0",
+      "features": [
+        "macros",
+        "rt",
+        "rt-multi-thread",
+        "net",
+        "test-util"
+      ],
+      "package": "tokio",
+      "kind": "dev",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "tokio-stream",
+      "req": "^0.1",
+      "features": [],
+      "kind": "dev",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "tokio-tungstenite",
+      "req": "^0.20",
+      "features": [],
+      "kind": "normal",
+      "optional": true,
+      "default_features": true
+    },
+    {
+      "name": "tower",
+      "req": "^0.4.13",
+      "features": [
+        "util"
+      ],
+      "kind": "normal",
+      "optional": false,
+      "default_features": false
+    },
+    {
+      "name": "tower",
+      "req": "^0.4.10",
+      "features": [
+        "util",
+        "timeout",
+        "limit",
+        "load-shed",
+        "steer",
+        "filter"
+      ],
+      "package": "tower",
+      "kind": "dev",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "tower-http",
+      "req": "^0.5.0",
+      "features": [
+        "add-extension",
+        "auth",
+        "catch-panic",
+        "compression-br",
+        "compression-deflate",
+        "compression-gzip",
+        "cors",
+        "decompression-br",
+        "decompression-deflate",
+        "decompression-gzip",
+        "follow-redirect",
+        "fs",
+        "limit",
+        "map-request-body",
+        "map-response-body",
+        "metrics",
+        "normalize-path",
+        "propagate-header",
+        "redirect",
+        "request-id",
+        "sensitive-headers",
+        "set-header",
+        "set-status",
+        "timeout",
+        "trace",
+        "util",
+        "validate-request"
+      ],
+      "kind": "normal",
+      "optional": true,
+      "default_features": true
+    },
+    {
+      "name": "tower-http",
+      "req": "^0.5.0",
+      "features": [
+        "add-extension",
+        "auth",
+        "catch-panic",
+        "compression-br",
+        "compression-deflate",
+        "compression-gzip",
+        "cors",
+        "decompression-br",
+        "decompression-deflate",
+        "decompression-gzip",
+        "follow-redirect",
+        "fs",
+        "limit",
+        "map-request-body",
+        "map-response-body",
+        "metrics",
+        "normalize-path",
+        "propagate-header",
+        "redirect",
+        "request-id",
+        "sensitive-headers",
+        "set-header",
+        "set-status",
+        "timeout",
+        "trace",
+        "util",
+        "validate-request"
+      ],
+      "kind": "dev",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "tower-layer",
+      "req": "^0.3.2",
+      "features": [],
+      "kind": "normal",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "tower-service",
+      "req": "^0.3",
+      "features": [],
+      "kind": "normal",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "tracing",
+      "req": "^0.1",
+      "features": [],
+      "kind": "normal",
+      "optional": true,
+      "default_features": false
+    },
+    {
+      "name": "tracing",
+      "req": "^0.1",
+      "features": [],
+      "kind": "dev",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "tracing-subscriber",
+      "req": "^0.3",
+      "features": [
+        "json"
+      ],
+      "kind": "dev",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "uuid",
+      "req": "^1.0",
+      "features": [
+        "serde",
+        "v4"
+      ],
+      "kind": "dev",
+      "optional": false,
+      "default_features": true
+    }
+  ],
+  "features": {
+    "default": [
+      "form",
+      "http1",
+      "json",
+      "matched-path",
+      "original-uri",
+      "query",
+      "tokio",
+      "tower-log"
+    ],
+    "__private_docs": [
+      "tower/full",
+      "dep:tower-http"
+    ],
+    "ws": [
+      "dep:hyper",
+      "tokio",
+      "dep:tokio-tungstenite",
+      "dep:sha1",
+      "dep:base64"
+    ],
+    "form": [
+      "dep:serde_urlencoded"
+    ],
+    "tracing": [
+      "dep:tracing",
+      "axum-core/tracing"
+    ],
+    "tokio": [
+      "dep:hyper-util",
+      "dep:tokio",
+      "tokio/net",
+      "tokio/rt",
+      "tower/make"
+    ],
+    "multipart": [
+      "dep:multer"
+    ],
+    "tower-log": [
+      "tower/log"
+    ],
+    "http1": [
+      "dep:hyper",
+      "hyper?/http1"
+    ],
+    "macros": [
+      "dep:axum-macros"
+    ],
+    "json": [
+      "dep:serde_json",
+      "dep:serde_path_to_error"
+    ],
+    "original-uri": [],
+    "http2": [
+      "dep:hyper",
+      "hyper?/http2"
+    ],
+    "query": [
+      "dep:serde_urlencoded"
+    ],
+    "matched-path": []
+  },
+  "rust_version": "1.66",
+  "cksum": "f3df9e51a6be3dff35208dc9a8e617d562a5232e7b7c69ef86eba088be62f084",
+  "yanked": false
+}
diff --git a/tools/external_crates/crates_io_util/src/testdata/chrono-0.4.39 b/tools/external_crates/crates_io_util/src/testdata/chrono-0.4.39
new file mode 100644
index 000000000..561da6ec8
--- /dev/null
+++ b/tools/external_crates/crates_io_util/src/testdata/chrono-0.4.39
@@ -0,0 +1,193 @@
+{
+  "name": "chrono",
+  "vers": "0.4.39",
+  "deps": [
+    {
+      "name": "android-tzdata",
+      "req": "^0.1.1",
+      "features": [],
+      "kind": "normal",
+      "target": "cfg(target_os = \"android\")",
+      "optional": true,
+      "default_features": true
+    },
+    {
+      "name": "arbitrary",
+      "req": "^1.0.0",
+      "features": [
+        "derive"
+      ],
+      "kind": "normal",
+      "optional": true,
+      "default_features": true
+    },
+    {
+      "name": "bincode",
+      "req": "^1.3.0",
+      "features": [],
+      "kind": "dev",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "iana-time-zone",
+      "req": "^0.1.45",
+      "features": [
+        "fallback"
+      ],
+      "kind": "normal",
+      "target": "cfg(unix)",
+      "optional": true,
+      "default_features": true
+    },
+    {
+      "name": "js-sys",
+      "req": "^0.3",
+      "features": [],
+      "kind": "normal",
+      "target": "cfg(all(target_arch = \"wasm32\", not(any(target_os = \"emscripten\", target_os = \"wasi\"))))",
+      "optional": true,
+      "default_features": true
+    },
+    {
+      "name": "num-traits",
+      "req": "^0.2",
+      "features": [],
+      "kind": "normal",
+      "optional": false,
+      "default_features": false
+    },
+    {
+      "name": "pure-rust-locales",
+      "req": "^0.8",
+      "features": [],
+      "kind": "normal",
+      "optional": true,
+      "default_features": true
+    },
+    {
+      "name": "rkyv",
+      "req": "^0.7.43",
+      "features": [],
+      "kind": "normal",
+      "optional": true,
+      "default_features": false
+    },
+    {
+      "name": "serde",
+      "req": "^1.0.99",
+      "features": [],
+      "kind": "normal",
+      "optional": true,
+      "default_features": false
+    },
+    {
+      "name": "serde_derive",
+      "req": "^1",
+      "features": [],
+      "kind": "dev",
+      "optional": false,
+      "default_features": false
+    },
+    {
+      "name": "serde_json",
+      "req": "^1",
+      "features": [],
+      "kind": "dev",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "wasm-bindgen",
+      "req": "^0.2",
+      "features": [],
+      "kind": "normal",
+      "target": "cfg(all(target_arch = \"wasm32\", not(any(target_os = \"emscripten\", target_os = \"wasi\"))))",
+      "optional": true,
+      "default_features": true
+    },
+    {
+      "name": "wasm-bindgen-test",
+      "req": "^0.3",
+      "features": [],
+      "kind": "dev",
+      "target": "cfg(all(target_arch = \"wasm32\", not(any(target_os = \"emscripten\", target_os = \"wasi\"))))",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "windows-bindgen",
+      "req": "^0.58",
+      "features": [],
+      "kind": "dev",
+      "target": "cfg(windows)",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "windows-targets",
+      "req": "^0.52",
+      "features": [],
+      "kind": "normal",
+      "target": "cfg(windows)",
+      "optional": true,
+      "default_features": true
+    }
+  ],
+  "features": {
+    "std": [
+      "alloc"
+    ],
+    "rkyv-16": [
+      "dep:rkyv",
+      "rkyv?/size_16"
+    ],
+    "default": [
+      "clock",
+      "std",
+      "oldtime",
+      "wasmbind"
+    ],
+    "unstable-locales": [
+      "pure-rust-locales"
+    ],
+    "wasmbind": [
+      "wasm-bindgen",
+      "js-sys"
+    ],
+    "rkyv-64": [
+      "dep:rkyv",
+      "rkyv?/size_64"
+    ],
+    "rkyv-validation": [
+      "rkyv?/validation"
+    ],
+    "__internal_bench": [],
+    "alloc": [],
+    "now": [
+      "std"
+    ],
+    "rkyv": [
+      "dep:rkyv",
+      "rkyv/size_32"
+    ],
+    "clock": [
+      "winapi",
+      "iana-time-zone",
+      "android-tzdata",
+      "now"
+    ],
+    "oldtime": [],
+    "winapi": [
+      "windows-targets"
+    ],
+    "libc": [],
+    "rkyv-32": [
+      "dep:rkyv",
+      "rkyv?/size_32"
+    ]
+  },
+  "rust_version": "1.61.0",
+  "cksum": "7e36cc9d416881d2e24f9a963be5fb1cd90966419ac844274161d10488b3e825",
+  "yanked": false
+}
diff --git a/tools/external_crates/crates_io_util/src/testdata/getrandom-0.3.3 b/tools/external_crates/crates_io_util/src/testdata/getrandom-0.3.3
new file mode 100644
index 000000000..b6689b61f
--- /dev/null
+++ b/tools/external_crates/crates_io_util/src/testdata/getrandom-0.3.3
@@ -0,0 +1,162 @@
+{
+  "name": "getrandom",
+  "vers": "0.3.3",
+  "deps": [
+    {
+      "name": "cfg-if",
+      "req": "^1",
+      "features": [],
+      "kind": "normal",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "compiler_builtins",
+      "req": "^0.1",
+      "features": [],
+      "kind": "normal",
+      "optional": true,
+      "default_features": true
+    },
+    {
+      "name": "core",
+      "req": "^1.0",
+      "features": [],
+      "package": "rustc-std-workspace-core",
+      "kind": "normal",
+      "optional": true,
+      "default_features": true
+    },
+    {
+      "name": "js-sys",
+      "req": "^0.3.77",
+      "features": [],
+      "kind": "normal",
+      "target": "cfg(all(target_arch = \"wasm32\", any(target_os = \"unknown\", target_os = \"none\"), target_feature = \"atomics\"))",
+      "optional": true,
+      "default_features": false
+    },
+    {
+      "name": "libc",
+      "req": "^0.2.154",
+      "features": [],
+      "kind": "normal",
+      "target": "cfg(all(any(target_os = \"linux\", target_os = \"android\"), not(any(all(target_os = \"linux\", target_env = \"\"), getrandom_backend = \"custom\", getrandom_backend = \"linux_raw\", getrandom_backend = \"rdrand\", getrandom_backend = \"rndr\"))))",
+      "optional": false,
+      "default_features": false
+    },
+    {
+      "name": "libc",
+      "req": "^0.2.154",
+      "features": [],
+      "kind": "normal",
+      "target": "cfg(any(target_os = \"dragonfly\", target_os = \"freebsd\", target_os = \"hurd\", target_os = \"illumos\", target_os = \"cygwin\", all(target_os = \"horizon\", target_arch = \"arm\")))",
+      "optional": false,
+      "default_features": false
+    },
+    {
+      "name": "libc",
+      "req": "^0.2.154",
+      "features": [],
+      "kind": "normal",
+      "target": "cfg(any(target_os = \"haiku\", target_os = \"redox\", target_os = \"nto\", target_os = \"aix\"))",
+      "optional": false,
+      "default_features": false
+    },
+    {
+      "name": "libc",
+      "req": "^0.2.154",
+      "features": [],
+      "kind": "normal",
+      "target": "cfg(any(target_os = \"ios\", target_os = \"visionos\", target_os = \"watchos\", target_os = \"tvos\"))",
+      "optional": false,
+      "default_features": false
+    },
+    {
+      "name": "libc",
+      "req": "^0.2.154",
+      "features": [],
+      "kind": "normal",
+      "target": "cfg(any(target_os = \"macos\", target_os = \"openbsd\", target_os = \"vita\", target_os = \"emscripten\"))",
+      "optional": false,
+      "default_features": false
+    },
+    {
+      "name": "libc",
+      "req": "^0.2.154",
+      "features": [],
+      "kind": "normal",
+      "target": "cfg(target_os = \"netbsd\")",
+      "optional": false,
+      "default_features": false
+    },
+    {
+      "name": "libc",
+      "req": "^0.2.154",
+      "features": [],
+      "kind": "normal",
+      "target": "cfg(target_os = \"solaris\")",
+      "optional": false,
+      "default_features": false
+    },
+    {
+      "name": "libc",
+      "req": "^0.2.154",
+      "features": [],
+      "kind": "normal",
+      "target": "cfg(target_os = \"vxworks\")",
+      "optional": false,
+      "default_features": false
+    },
+    {
+      "name": "r-efi",
+      "req": "^5.1",
+      "features": [],
+      "kind": "normal",
+      "target": "cfg(all(target_os = \"uefi\", getrandom_backend = \"efi_rng\"))",
+      "optional": false,
+      "default_features": false
+    },
+    {
+      "name": "wasi",
+      "req": "^0.14",
+      "features": [],
+      "kind": "normal",
+      "target": "cfg(all(target_arch = \"wasm32\", target_os = \"wasi\", target_env = \"p2\"))",
+      "optional": false,
+      "default_features": false
+    },
+    {
+      "name": "wasm-bindgen",
+      "req": "^0.2.98",
+      "features": [],
+      "kind": "normal",
+      "target": "cfg(all(target_arch = \"wasm32\", any(target_os = \"unknown\", target_os = \"none\")))",
+      "optional": true,
+      "default_features": false
+    },
+    {
+      "name": "wasm-bindgen-test",
+      "req": "^0.3",
+      "features": [],
+      "kind": "dev",
+      "target": "cfg(all(target_arch = \"wasm32\", any(target_os = \"unknown\", target_os = \"none\")))",
+      "optional": false,
+      "default_features": true
+    }
+  ],
+  "features": {
+    "std": [],
+    "wasm_js": [
+      "dep:wasm-bindgen",
+      "dep:js-sys"
+    ],
+    "rustc-dep-of-std": [
+      "dep:compiler_builtins",
+      "dep:core"
+    ]
+  },
+  "rust_version": "1.63",
+  "cksum": "26145e563e54f2cadc477553f1ec5ee650b00862f0a58bcd12cbdc5f0ea2d2f4",
+  "yanked": false
+}
diff --git a/tools/external_crates/crates_io_util/src/testdata/ring b/tools/external_crates/crates_io_util/src/testdata/ring
new file mode 100644
index 000000000..01dea0a3b
--- /dev/null
+++ b/tools/external_crates/crates_io_util/src/testdata/ring
@@ -0,0 +1,444 @@
+{
+  "versions": [
+    {
+      "name": "ring",
+      "vers": "0.17.0",
+      "deps": [
+        {
+          "name": "cc",
+          "req": "^1.0.69",
+          "features": [],
+          "kind": "build",
+          "optional": false,
+          "default_features": false
+        },
+        {
+          "name": "criterion",
+          "req": "^0.4",
+          "features": [],
+          "kind": "dev",
+          "optional": false,
+          "default_features": false
+        },
+        {
+          "name": "getrandom",
+          "req": "^0.2.8",
+          "features": [],
+          "kind": "normal",
+          "optional": false,
+          "default_features": true
+        },
+        {
+          "name": "libc",
+          "req": "^0.2.100",
+          "features": [],
+          "kind": "normal",
+          "target": "cfg(any(target_os = \"android\", target_os = \"linux\"))",
+          "optional": false,
+          "default_features": false
+        },
+        {
+          "name": "libc",
+          "req": "^0.2.100",
+          "features": [],
+          "kind": "dev",
+          "target": "cfg(any(unix, windows))",
+          "optional": false,
+          "default_features": false
+        },
+        {
+          "name": "spin",
+          "req": "^0.9.2",
+          "features": [
+            "once"
+          ],
+          "kind": "normal",
+          "target": "cfg(any(target_arch = \"x86\", target_arch = \"x86_64\", all(any(target_arch = \"aarch64\", target_arch = \"arm\"), any(target_os = \"android\", target_os = \"fuchsia\", target_os = \"linux\", target_os = \"windows\"))))",
+          "optional": false,
+          "default_features": false
+        },
+        {
+          "name": "untrusted",
+          "req": "^0.9",
+          "features": [],
+          "kind": "normal",
+          "optional": false,
+          "default_features": true
+        },
+        {
+          "name": "wasm-bindgen-test",
+          "req": "^0.3.26",
+          "features": [],
+          "kind": "dev",
+          "target": "cfg(target_arch = \"wasm32\")",
+          "optional": false,
+          "default_features": false
+        },
+        {
+          "name": "windows-sys",
+          "req": "^0.48",
+          "features": [
+            "Win32_Foundation",
+            "Win32_System_Threading"
+          ],
+          "kind": "normal",
+          "target": "cfg(all(target_arch = \"aarch64\", target_os = \"windows\"))",
+          "optional": false,
+          "default_features": true
+        }
+      ],
+      "features": {
+        "unstable-testing-arm-no-hw": [],
+        "default": [
+          "alloc",
+          "dev_urandom_fallback"
+        ],
+        "unstable-testing-arm-no-neon": [],
+        "test_logging": [],
+        "wasm32_unknown_unknown_js": [
+          "getrandom/js"
+        ],
+        "dev_urandom_fallback": [],
+        "alloc": [],
+        "slow_tests": [],
+        "std": [
+          "alloc"
+        ]
+      },
+      "links": "ring_core_0_17_0",
+      "rust_version": "1.61.0",
+      "cksum": "fb9d44f9bf6b635117787f72416783eb7e4227aaf255e5ce739563d817176a7e",
+      "yanked": false
+    },
+    {
+      "name": "ring",
+      "vers": "0.17.1-alpha.1",
+      "deps": [
+        {
+          "name": "cc",
+          "req": "^1.0.69",
+          "features": [],
+          "kind": "build",
+          "optional": false,
+          "default_features": false
+        },
+        {
+          "name": "criterion",
+          "req": "^0.4",
+          "features": [],
+          "kind": "dev",
+          "optional": false,
+          "default_features": false
+        },
+        {
+          "name": "getrandom",
+          "req": "^0.2.8",
+          "features": [],
+          "kind": "normal",
+          "optional": false,
+          "default_features": true
+        },
+        {
+          "name": "libc",
+          "req": "^0.2.100",
+          "features": [],
+          "kind": "normal",
+          "target": "cfg(any(target_os = \"android\", target_os = \"linux\"))",
+          "optional": false,
+          "default_features": false
+        },
+        {
+          "name": "libc",
+          "req": "^0.2.100",
+          "features": [],
+          "kind": "dev",
+          "target": "cfg(any(unix, windows))",
+          "optional": false,
+          "default_features": false
+        },
+        {
+          "name": "spin",
+          "req": "^0.9.2",
+          "features": [
+            "once"
+          ],
+          "kind": "normal",
+          "target": "cfg(any(target_arch = \"x86\",target_arch = \"x86_64\", all(any(target_arch = \"aarch64\", target_arch = \"arm\"), any(target_os = \"android\", target_os = \"fuchsia\", target_os = \"linux\", target_os = \"windows\"))))",
+          "optional": false,
+          "default_features": false
+        },
+        {
+          "name": "untrusted",
+          "req": "^0.9",
+          "features": [],
+          "kind": "normal",
+          "optional": false,
+          "default_features": true
+        },
+        {
+          "name": "wasm-bindgen-test",
+          "req": "^0.3.26",
+          "features": [],
+          "kind": "dev",
+          "target": "cfg(target_arch = \"wasm32\")",
+          "optional": false,
+          "default_features": false
+        },
+        {
+          "name": "windows-sys",
+          "req": "^0.48",
+          "features": [
+            "Win32_Foundation",
+            "Win32_System_Threading"
+          ],
+          "kind": "normal",
+          "target": "cfg(all(target_arch = \"aarch64\", target_os = \"windows\"))",
+          "optional": false,
+          "default_features": true
+        }
+      ],
+      "features": {
+        "unstable-testing-arm-no-hw": [],
+        "default": [
+          "alloc",
+          "dev_urandom_fallback"
+        ],
+        "unstable-testing-arm-no-neon": [],
+        "test_logging": [],
+        "wasm32_unknown_unknown_js": [
+          "getrandom/js"
+        ],
+        "dev_urandom_fallback": [],
+        "alloc": [],
+        "slow_tests": [],
+        "std": [
+          "alloc"
+        ]
+      },
+      "links": "ring_core_0_17_1_alpha_1",
+      "rust_version": "1.61.0",
+      "cksum": "dc0c03eb6093f1ec162a7d1dabb176d9156593b7902b266df23c77674e5c6de7",
+      "yanked": false
+    },
+    {
+      "name": "ring",
+      "vers": "0.17.1",
+      "deps": [
+        {
+          "name": "cc",
+          "req": "^1.0.69",
+          "features": [],
+          "kind": "build",
+          "optional": false,
+          "default_features": false
+        },
+        {
+          "name": "criterion",
+          "req": "^0.4",
+          "features": [],
+          "kind": "dev",
+          "optional": false,
+          "default_features": false
+        },
+        {
+          "name": "getrandom",
+          "req": "^0.2.8",
+          "features": [],
+          "kind": "normal",
+          "optional": false,
+          "default_features": true
+        },
+        {
+          "name": "libc",
+          "req": "^0.2.100",
+          "features": [],
+          "kind": "normal",
+          "target": "cfg(any(target_os = \"android\", target_os = \"linux\"))",
+          "optional": false,
+          "default_features": false
+        },
+        {
+          "name": "libc",
+          "req": "^0.2.100",
+          "features": [],
+          "kind": "dev",
+          "target": "cfg(any(unix, windows))",
+          "optional": false,
+          "default_features": false
+        },
+        {
+          "name": "spin",
+          "req": "^0.9.2",
+          "features": [
+            "once"
+          ],
+          "kind": "normal",
+          "target": "cfg(any(target_arch = \"x86\",target_arch = \"x86_64\", all(any(target_arch = \"aarch64\", target_arch = \"arm\"), any(target_os = \"android\", target_os = \"fuchsia\", target_os = \"linux\", target_os = \"windows\"))))",
+          "optional": false,
+          "default_features": false
+        },
+        {
+          "name": "untrusted",
+          "req": "^0.9",
+          "features": [],
+          "kind": "normal",
+          "optional": false,
+          "default_features": true
+        },
+        {
+          "name": "wasm-bindgen-test",
+          "req": "^0.3.26",
+          "features": [],
+          "kind": "dev",
+          "target": "cfg(target_arch = \"wasm32\")",
+          "optional": false,
+          "default_features": false
+        },
+        {
+          "name": "windows-sys",
+          "req": "^0.48",
+          "features": [
+            "Win32_Foundation",
+            "Win32_System_Threading"
+          ],
+          "kind": "normal",
+          "target": "cfg(all(target_arch = \"aarch64\", target_os = \"windows\"))",
+          "optional": false,
+          "default_features": true
+        }
+      ],
+      "features": {
+        "unstable-testing-arm-no-hw": [],
+        "default": [
+          "alloc",
+          "dev_urandom_fallback"
+        ],
+        "unstable-testing-arm-no-neon": [],
+        "test_logging": [],
+        "wasm32_unknown_unknown_js": [
+          "getrandom/js"
+        ],
+        "dev_urandom_fallback": [],
+        "alloc": [],
+        "slow_tests": [],
+        "std": [
+          "alloc"
+        ]
+      },
+      "links": "ring_core_0_17_1",
+      "rust_version": "1.61.0",
+      "cksum": "21af477b4a43496ef7290b74716f235442a30491e352364e33661cf683857a31",
+      "yanked": true
+    },
+    {
+      "name": "ring",
+      "vers": "0.17.2",
+      "deps": [
+        {
+          "name": "cc",
+          "req": "^1.0.69",
+          "features": [],
+          "kind": "build",
+          "optional": false,
+          "default_features": false
+        },
+        {
+          "name": "criterion",
+          "req": "^0.4",
+          "features": [],
+          "kind": "dev",
+          "optional": false,
+          "default_features": false
+        },
+        {
+          "name": "getrandom",
+          "req": "^0.2.8",
+          "features": [],
+          "kind": "normal",
+          "optional": false,
+          "default_features": true
+        },
+        {
+          "name": "libc",
+          "req": "^0.2.100",
+          "features": [],
+          "kind": "normal",
+          "target": "cfg(any(target_os = \"android\", target_os = \"linux\"))",
+          "optional": false,
+          "default_features": false
+        },
+        {
+          "name": "libc",
+          "req": "^0.2.100",
+          "features": [],
+          "kind": "dev",
+          "target": "cfg(any(unix, windows))",
+          "optional": false,
+          "default_features": false
+        },
+        {
+          "name": "spin",
+          "req": "^0.9.2",
+          "features": [
+            "once"
+          ],
+          "kind": "normal",
+          "target": "cfg(any(target_arch = \"x86\",target_arch = \"x86_64\", all(any(target_arch = \"aarch64\", target_arch = \"arm\"), any(target_os = \"android\", target_os = \"fuchsia\", target_os = \"linux\", target_os = \"windows\"))))",
+          "optional": false,
+          "default_features": false
+        },
+        {
+          "name": "untrusted",
+          "req": "^0.9",
+          "features": [],
+          "kind": "normal",
+          "optional": false,
+          "default_features": true
+        },
+        {
+          "name": "wasm-bindgen-test",
+          "req": "^0.3.26",
+          "features": [],
+          "kind": "dev",
+          "target": "cfg(target_arch = \"wasm32\")",
+          "optional": false,
+          "default_features": false
+        },
+        {
+          "name": "windows-sys",
+          "req": "^0.48",
+          "features": [
+            "Win32_Foundation",
+            "Win32_System_Threading"
+          ],
+          "kind": "normal",
+          "target": "cfg(all(target_arch = \"aarch64\", target_os = \"windows\"))",
+          "optional": false,
+          "default_features": true
+        }
+      ],
+      "features": {
+        "unstable-testing-arm-no-hw": [],
+        "default": [
+          "alloc",
+          "dev_urandom_fallback"
+        ],
+        "unstable-testing-arm-no-neon": [],
+        "test_logging": [],
+        "wasm32_unknown_unknown_js": [
+          "getrandom/js"
+        ],
+        "dev_urandom_fallback": [],
+        "alloc": [],
+        "slow_tests": [],
+        "std": [
+          "alloc"
+        ]
+      },
+      "links": "ring_core_0_17_2",
+      "rust_version": "1.61.0",
+      "cksum": "911b295d2d302948838c8ac142da1ee09fa7863163b44e6715bc9357905878b8",
+      "yanked": false
+    }
+  ]
+}
diff --git a/tools/external_crates/crates_io_util/src/testdata/ring-0.17.11-alpha1 b/tools/external_crates/crates_io_util/src/testdata/ring-0.17.11-alpha1
new file mode 100644
index 000000000..7de914d8e
--- /dev/null
+++ b/tools/external_crates/crates_io_util/src/testdata/ring-0.17.11-alpha1
@@ -0,0 +1,112 @@
+{
+  "name": "ring",
+  "vers": "0.17.11-alpha1",
+  "deps": [
+    {
+      "name": "cc",
+      "req": "^1.2.8",
+      "features": [],
+      "kind": "build",
+      "optional": false,
+      "default_features": false
+    },
+    {
+      "name": "cfg-if",
+      "req": "^1.0.0",
+      "features": [],
+      "kind": "normal",
+      "optional": false,
+      "default_features": false
+    },
+    {
+      "name": "getrandom",
+      "req": "^0.2.10",
+      "features": [],
+      "kind": "normal",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "libc",
+      "req": "^0.2.148",
+      "features": [],
+      "kind": "normal",
+      "target": "cfg(all(any(all(target_arch = \"aarch64\", target_endian = \"little\"), all(target_arch = \"arm\", target_endian = \"little\")), any(target_os = \"android\", target_os = \"linux\")))",
+      "optional": false,
+      "default_features": false
+    },
+    {
+      "name": "libc",
+      "req": "^0.2.155",
+      "features": [],
+      "kind": "normal",
+      "target": "cfg(all(all(target_arch = \"aarch64\", target_endian = \"little\"), target_vendor = \"apple\", any(target_os = \"ios\", target_os = \"macos\", target_os = \"tvos\", target_os = \"visionos\", target_os = \"watchos\")))",
+      "optional": false,
+      "default_features": false
+    },
+    {
+      "name": "libc",
+      "req": "^0.2.148",
+      "features": [],
+      "kind": "dev",
+      "target": "cfg(any(unix, windows, target_os = \"wasi\"))",
+      "optional": false,
+      "default_features": false
+    },
+    {
+      "name": "untrusted",
+      "req": "^0.9",
+      "features": [],
+      "kind": "normal",
+      "optional": false,
+      "default_features": true
+    },
+    {
+      "name": "wasm-bindgen-test",
+      "req": "^0.3.37",
+      "features": [
+        "std"
+      ],
+      "kind": "dev",
+      "target": "cfg(all(target_arch = \"wasm32\", target_os = \"unknown\"))",
+      "optional": false,
+      "default_features": false
+    },
+    {
+      "name": "windows-sys",
+      "req": "^0.52",
+      "features": [
+        "Win32_Foundation",
+        "Win32_System_Threading"
+      ],
+      "kind": "normal",
+      "target": "cfg(all(all(target_arch = \"aarch64\", target_endian = \"little\"), target_os = \"windows\"))",
+      "optional": false,
+      "default_features": true
+    }
+  ],
+  "features": {
+    "std": [
+      "alloc"
+    ],
+    "unstable-testing-arm-no-hw": [],
+    "less-safe-getrandom-espidf": [],
+    "unstable-testing-arm-no-neon": [],
+    "less-safe-getrandom-custom-or-rdrand": [],
+    "dev_urandom_fallback": [],
+    "test_logging": [],
+    "wasm32_unknown_unknown_js": [
+      "getrandom/js"
+    ],
+    "alloc": [],
+    "default": [
+      "alloc",
+      "dev_urandom_fallback"
+    ],
+    "slow_tests": []
+  },
+  "links": "ring_core_0_17_11_alpha1",
+  "rust_version": "1.63.0",
+  "cksum": "2725377aaa505d81dae6e10aa08820945eb66e190bc913c843f104589bc7ea0e",
+  "yanked": false
+}
diff --git a/tools/external_crates/crates_io_util/src/versions.rs b/tools/external_crates/crates_io_util/src/versions.rs
new file mode 100644
index 000000000..0ec26829f
--- /dev/null
+++ b/tools/external_crates/crates_io_util/src/versions.rs
@@ -0,0 +1,162 @@
+// Copyright (C) 2025 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+/// Trait for parsing and comparing crate versions. crates_index stores them as
+/// strings, but it's nicer if they are parsed into semver::Version.
+pub trait ParsedVersion {
+    /// Get the parsed representation of a crate version.
+    fn parsed_version(&self) -> Result<semver::Version, semver::Error>;
+    /// Return true if the version is equal to `other`.
+    /// Unparseable versions are never equal to anything.
+    fn version_eq(&self, other: &semver::Version) -> bool {
+        self.parsed_version().is_ok_and(|parsed| parsed.eq(other))
+    }
+    /// Return true if the version is greater than to `other`.
+    /// Returns false if the version is unparseable.
+    fn version_gt(&self, other: &semver::Version) -> bool {
+        self.parsed_version().is_ok_and(|parsed| parsed.gt(other))
+    }
+}
+
+impl ParsedVersion for crates_index::Version {
+    fn parsed_version(&self) -> Result<semver::Version, semver::Error> {
+        semver::Version::parse(self.version())
+    }
+}
+
+/// Trait for checking if a crate version is "safe", meaning not yanked or pre-release.
+pub trait IsSafe {
+    /// Return true if the version is "safe", meaning not yanked or pre-release.
+    fn is_safe(&self) -> bool;
+}
+
+impl IsSafe for crates_index::Version {
+    fn is_safe(&self) -> bool {
+        !self.is_yanked() && self.parsed_version().is_ok_and(|parsed| parsed.pre.is_empty())
+    }
+}
+
+/// Filter crate versions by those that are "safe", meaning not yanked or pre-release.
+pub trait SafeVersions {
+    /// Versions of the crate that aren't yanked or pre-release.
+    fn safe_versions(&self) -> impl DoubleEndedIterator<Item = &crates_index::Version>;
+    /// Safe versions of the crate grater than the specified version.
+    /// That is, potential upgrades, more or less.
+    fn safe_versions_gt(
+        &self,
+        version: &semver::Version,
+    ) -> impl DoubleEndedIterator<Item = &crates_index::Version> {
+        self.safe_versions().filter(|v| v.version_gt(version))
+    }
+}
+
+impl SafeVersions for crates_index::Crate {
+    fn safe_versions(&self) -> impl DoubleEndedIterator<Item = &crates_index::Version> {
+        self.versions().iter().filter(|v| v.is_safe())
+    }
+}
+
+/// Get a specific version of a crate.
+pub trait GetVersion {
+    /// Get a specific version of a crate. O(N)
+    fn get_version(&self, version: &semver::Version) -> Option<&crates_index::Version>;
+    /// Get a particular version from the list of safe versions, or None if no
+    /// safe version exists.
+    fn get_safe_version(&self, version: &semver::Version) -> Option<&crates_index::Version>;
+}
+
+impl GetVersion for crates_index::Crate {
+    fn get_version(&self, version: &semver::Version) -> Option<&crates_index::Version> {
+        self.versions().iter().find(|v| v.version_eq(version))
+    }
+    fn get_safe_version(&self, version: &semver::Version) -> Option<&crates_index::Version> {
+        self.safe_versions().find(|v| v.version_eq(version))
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    use itertools::assert_equal;
+
+    #[test]
+    fn test_parsed_version() {
+        let hashbrown_0_12_3: crates_index::Version =
+            serde_json::from_str(include_str!("testdata/hashbrown-0.12.3"))
+                .expect("Failed to parse JSON testdata");
+        assert_eq!(
+            hashbrown_0_12_3.parsed_version().expect("Failed to parse version"),
+            semver::Version::new(0, 12, 3)
+        );
+        assert!(hashbrown_0_12_3.version_eq(&semver::Version::new(0, 12, 3)));
+        assert!(!hashbrown_0_12_3.version_eq(&semver::Version::new(0, 12, 4)));
+        assert!(hashbrown_0_12_3.version_gt(&semver::Version::new(0, 12, 2)));
+        assert!(!hashbrown_0_12_3.version_gt(&semver::Version::new(0, 12, 3)));
+        assert!(!hashbrown_0_12_3.version_gt(&semver::Version::new(0, 12, 4)));
+    }
+
+    #[test]
+    fn test_is_safe() {
+        let hashbrown_0_12_3: crates_index::Version =
+            serde_json::from_str(include_str!("testdata/hashbrown-0.12.3"))
+                .expect("Failed to parse JSON testdata");
+        assert!(hashbrown_0_12_3.is_safe());
+        let ahash_0_8_3: crates_index::Version =
+            serde_json::from_str(include_str!("testdata/ahash-0.8.3"))
+                .expect("Failed to parse JSON testdata");
+        assert!(!ahash_0_8_3.is_safe(), "ahash 0.8.3 is yanked");
+        let ring_0_17_11_alpha1: crates_index::Version =
+            serde_json::from_str(include_str!("testdata/ring-0.17.11-alpha1"))
+                .expect("Failed to parse JSON testdata");
+        assert!(!ring_0_17_11_alpha1.is_safe(), "ring 0.17.11-alpha1 is pre-release");
+    }
+
+    #[test]
+    fn test_safe_versions() {
+        let ring: crates_index::Crate = serde_json::from_str(include_str!("testdata/ring"))
+            .expect("Failed to parse JSON testdata");
+        assert_equal(ring.safe_versions().map(|v| v.version()), ["0.17.0", "0.17.2"]);
+        assert_equal(
+            ring.safe_versions_gt(&semver::Version::new(0, 17, 0)).map(|v| v.version()),
+            ["0.17.2"],
+        );
+    }
+
+    #[test]
+    fn test_get_version() {
+        let ring: crates_index::Crate = serde_json::from_str(include_str!("testdata/ring"))
+            .expect("Failed to parse JSON testdata");
+        assert!(ring.get_version(&semver::Version::new(0, 16, 0)).is_none());
+        assert!(ring
+            .get_version(&semver::Version::new(0, 17, 0))
+            .is_some_and(|v| v.version() == "0.17.0"));
+        assert!(ring
+            .get_version(&semver::Version::new(0, 17, 1))
+            .is_some_and(|v| v.version() == "0.17.1"));
+        assert!(ring
+            .get_version(&semver::Version::parse("0.17.1-alpha.1").unwrap())
+            .is_some_and(|v| v.version() == "0.17.1-alpha.1"));
+
+        assert!(ring.get_safe_version(&semver::Version::new(0, 16, 0)).is_none());
+        assert!(ring
+            .get_safe_version(&semver::Version::new(0, 17, 0))
+            .is_some_and(|v| v.version() == "0.17.0"));
+        assert!(ring.get_safe_version(&semver::Version::new(0, 17, 1)).is_none(), "yanked version");
+        assert!(
+            ring.get_safe_version(&semver::Version::parse("0.17.1-alpha.1").unwrap()).is_none(),
+            "pre-release version"
+        );
+    }
+}
diff --git a/tools/external_crates/crates_io_util/tests/resolver_test.rs b/tools/external_crates/crates_io_util/tests/resolver_test.rs
new file mode 100644
index 000000000..433b701ac
--- /dev/null
+++ b/tools/external_crates/crates_io_util/tests/resolver_test.rs
@@ -0,0 +1,298 @@
+// Copyright (C) 2025 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// This regression test compares the dependency resolver with the result of
+// running `cargo tree` on all the crates in external/rust/android-crates-io.
+//
+// It takes several minutes to run, and can't run as a presubmit test because
+// it requires network access. It is therefore marked [ignore].
+//
+// To run this test manually:
+//
+// ./android_cargo.py test -p crates_io_util --test resolver_test  -- --nocapture --ignored
+//
+// For additional information about what the resolver is doing, prepend "RUST_LOG=debug" to
+// the command.
+//
+// To specify which crates to test, prepend "CRATES_TO_TEST=crate1,crate2" to the command.
+
+use std::{collections::BTreeSet, env, path::PathBuf, process::Command};
+
+use android_bp::BluePrint;
+use anyhow::{anyhow, Result};
+use bp_util::CrateFeatures;
+use crate_tool::{default_repo_root, ManagedRepo};
+use crates_io_util::{AndroidTarget, CratesIoIndex, FeatureResolver, GetVersion};
+use itertools::Itertools;
+use rooted_path::RootedPath;
+use success_or_error::RunAndExpectSuccess;
+use tempfile::TempDir;
+
+#[derive(Debug)]
+struct CrateDownloader {
+    tempdir: TempDir,
+}
+
+impl CrateDownloader {
+    fn new() -> Result<Self> {
+        let tempdir = tempfile::tempdir()?;
+        Command::new("cargo")
+            .args(["init", "--lib", "--name", "fake-crate"])
+            .current_dir(&tempdir)
+            .run_quiet_and_expect_success()?;
+        Ok(CrateDownloader { tempdir })
+    }
+    fn download(&self, crate_name: &str, version: &semver::Version) -> Result<PathBuf> {
+        // This will fail for yanked crates.
+        Command::new("cargo")
+            .arg("add")
+            .arg(format!("{crate_name}@={version}"))
+            .current_dir(&self.tempdir)
+            .run_quiet_and_expect_success()?;
+        Command::new("cargo")
+            .arg("vendor")
+            .current_dir(&self.tempdir)
+            .run_quiet_and_expect_success()?;
+        Command::new("cargo")
+            .args(["remove", crate_name])
+            .current_dir(&self.tempdir)
+            .run_quiet_and_expect_success()?;
+        Ok(self.tempdir.path().join("vendor").join(crate_name))
+    }
+}
+
+#[derive(Debug, PartialEq, Eq)]
+struct Deps {
+    required: BTreeSet<String>,
+    optional: BTreeSet<String>,
+}
+
+struct CargoTreeResolver {
+    downloader: CrateDownloader,
+}
+
+impl CargoTreeResolver {
+    fn new() -> Result<Self> {
+        Ok(CargoTreeResolver { downloader: CrateDownloader::new()? })
+    }
+    fn resolve(
+        &self,
+        crate_name: &str,
+        version: &semver::Version,
+        features: &Option<Vec<&str>>,
+    ) -> Result<Deps> {
+        static COMMON_ARGS: &[&str] = &[
+            "tree",
+            "--depth=1",
+            "--prefix=depth",
+            "--edges=normal",
+            "--target=aarch64-linux-android",
+            "--target=x86_64-unknown-linux-gnu",
+            "--target=armv7-linux-androideabi",
+            "--config",
+            r#"build.rustflags=["--cfg", "mls_build_async"]"#,
+        ];
+        let features_flag = if let Some(f) = features {
+            if f.is_empty() {
+                vec!["--no-default-features".to_string()]
+            } else {
+                vec!["--no-default-features".to_string(), "--features".to_string(), f.join(",")]
+            }
+        } else {
+            Vec::new()
+        };
+        let crate_path = self.downloader.download(crate_name, version)?;
+        let required = CargoTreeResolver::parse_cargo_tree_output(
+            &Command::new("cargo")
+                .args(COMMON_ARGS)
+                .arg("--no-default-features")
+                .current_dir(&crate_path)
+                .run_quiet_and_expect_success()?
+                .stdout,
+        )?;
+        let optional = CargoTreeResolver::parse_cargo_tree_output(
+            &Command::new("cargo")
+                .args(COMMON_ARGS)
+                .args(features_flag)
+                .current_dir(&crate_path)
+                .run_quiet_and_expect_success()?
+                .stdout,
+        )?
+        .into_iter()
+        .filter(|dep| !required.contains(dep))
+        .collect::<BTreeSet<_>>();
+        Ok(Deps { required, optional })
+    }
+    fn parse_cargo_tree_output(stdout: &[u8]) -> Result<BTreeSet<String>> {
+        Ok(String::from_utf8_lossy(stdout)
+            .lines()
+            .filter_map(|line| match line.split_at_checked(1) {
+                Some(("1", rest)) => rest.split_whitespace().next().map(String::from),
+                _ => None,
+            })
+            .collect::<BTreeSet<_>>())
+    }
+}
+
+struct CratesIoResolver {
+    index: CratesIoIndex,
+}
+
+impl CratesIoResolver {
+    fn new() -> Result<Self> {
+        Ok(CratesIoResolver { index: CratesIoIndex::new_cargo()? })
+    }
+    fn resolve(
+        &self,
+        crate_name: &str,
+        version: &semver::Version,
+        features: &Option<Vec<&str>>,
+    ) -> Result<Deps> {
+        let cio_crate = self.index.get_crate(crate_name)?;
+        let version = cio_crate
+            .get_version(version)
+            .ok_or(anyhow!("{crate_name} version {version} not found"))?;
+        let required = version
+            .dependencies()
+            .iter()
+            .filter_map(|dep| {
+                if dep.kind() == crates_index::DependencyKind::Normal
+                    && !dep.is_optional()
+                    && dep.is_android_target()
+                {
+                    Some(dep.crate_name().to_string())
+                } else {
+                    None
+                }
+            })
+            .collect::<BTreeSet<String>>();
+        let resolver = FeatureResolver::new(version);
+        let optional = resolver
+            .resolve_optional(features.as_ref().map(|f| f.iter()))?
+            .into_iter()
+            .map(|d| d.crate_name().to_string())
+            .collect::<BTreeSet<String>>();
+        Ok(Deps { required, optional })
+    }
+}
+
+trait CrateFeaturesWithDefault {
+    fn crate_features_with_default<'a>(
+        &'a self,
+        crate_name: &'a str,
+    ) -> impl Iterator<Item = Option<Vec<&'a str>>>;
+}
+
+impl CrateFeaturesWithDefault for BluePrint {
+    fn crate_features_with_default<'a>(
+        &'a self,
+        crate_name: &'a str,
+    ) -> impl Iterator<Item = Option<Vec<&'a str>>> {
+        self.crate_features(crate_name)
+            .filter_map(move |features_or_none| {
+                match features_or_none {
+                    // ahash has a "specialize" feature that is added by the build script and passed to
+                    // rustc, but not present in Cargo.toml.
+                    Some(features) => {
+                        if crate_name == "ahash" {
+                            Some(Some(
+                                features
+                                    .into_iter()
+                                    .filter(|feature| *feature != "specialize")
+                                    .collect(),
+                            ))
+                        } else {
+                            Some(Some(features))
+                        }
+                    }
+                    // We always add the default feature set below with .chain([None]), so
+                    // filter it out to avoid testing it twice.
+                    None => None,
+                }
+            })
+            .chain([None])
+    }
+}
+
+#[test]
+#[ignore]
+fn compare_with_cargo_tree() -> Result<()> {
+    env_logger::init();
+
+    let managed_repo = ManagedRepo::new(
+        RootedPath::new(default_repo_root()?, "external/rust/android-crates-io")?,
+        false,
+    )?;
+    let cargo_tree_resolver = CargoTreeResolver::new()?;
+    let crates_io_resolver = CratesIoResolver::new()?;
+
+    let crate_names = env::var("CRATES_TO_TEST")
+        .map(|s| s.split(",").map(String::from).collect::<BTreeSet<_>>())
+        .unwrap_or_else(|_| managed_repo.all_crate_names().unwrap());
+    let mut all_match = true;
+    for crate_name in &crate_names {
+        let managed_crate = managed_repo.managed_crate_for(crate_name)?;
+        let version = managed_crate.android_version();
+        println!("Checking {crate_name} {version}");
+
+        if crates_io_resolver
+            .index
+            .get_crate(crate_name)?
+            .get_version(managed_crate.android_version())
+            .ok_or(anyhow!("{crate_name} version {version} not found"))?
+            .is_yanked()
+        {
+            println!("  Yanked. Skipping.");
+            continue;
+        }
+
+        let bp = BluePrint::from_file(managed_crate.android_crate_path().abs().join("Android.bp"))
+            .map_err(|e: String| anyhow!(e))?;
+        for features in bp.crate_features_with_default(crate_name) {
+            let cargo_tree_deps = match cargo_tree_resolver.resolve(crate_name, version, &features)
+            {
+                Ok(d) => d,
+                Err(e) => {
+                    println!("  Failed to resolve with 'cargo tree': {e}");
+                    all_match = false;
+                    continue;
+                }
+            };
+            let crates_io_deps = match crates_io_resolver.resolve(crate_name, version, &features) {
+                Ok(d) => d,
+                Err(e) => {
+                    println!("  Failed to resolve: {e}");
+                    all_match = false;
+                    continue;
+                }
+            };
+
+            if cargo_tree_deps != crates_io_deps {
+                all_match = false;
+                if cargo_tree_deps.required != crates_io_deps.required {
+                    println!("  Required deps different for {:?}", features);
+                    println!("    cargo tree: {}", cargo_tree_deps.required.iter().join(", "));
+                    println!("    crates.io:  {}", crates_io_deps.required.iter().join(", "));
+                }
+                if cargo_tree_deps.optional != crates_io_deps.optional {
+                    println!("  Optional deps different for {:?}", features);
+                    println!("    cargo tree: {}", cargo_tree_deps.optional.iter().join(", "));
+                    println!("    crates.io:  {}", crates_io_deps.optional.iter().join(", "));
+                }
+            }
+        }
+    }
+    assert!(all_match);
+    Ok(())
+}
diff --git a/tools/external_crates/license_checker/Android.bp b/tools/external_crates/license_checker/Android.bp
index abe5df813..f7b10de7a 100644
--- a/tools/external_crates/license_checker/Android.bp
+++ b/tools/external_crates/license_checker/Android.bp
@@ -17,6 +17,7 @@ rust_library_host {
     edition: "2021",
     rustlibs: [
         "libglob",
+        "libgoogle_metadata",
         "libitertools",
         "libspdx",
         "libtextdistance",
@@ -38,6 +39,7 @@ rust_test_host {
     edition: "2021",
     rustlibs: [
         "libglob",
+        "libgoogle_metadata",
         "libitertools",
         "libspdx",
         "libtextdistance",
diff --git a/tools/external_crates/license_checker/Cargo.toml b/tools/external_crates/license_checker/Cargo.toml
index aa9b7fd35..b951f2c22 100644
--- a/tools/external_crates/license_checker/Cargo.toml
+++ b/tools/external_crates/license_checker/Cargo.toml
@@ -8,4 +8,5 @@ glob = "0.3"
 itertools = "0.14"
 spdx = "0.10"
 textdistance = "1.1.1"
-thiserror = "1.0"
\ No newline at end of file
+thiserror = "1.0"
+google_metadata = { path = "../google_metadata"}
\ No newline at end of file
diff --git a/tools/external_crates/license_checker/src/file_classifier.rs b/tools/external_crates/license_checker/src/file_classifier.rs
index 10e3be2aa..e4f5d7cb1 100644
--- a/tools/external_crates/license_checker/src/file_classifier.rs
+++ b/tools/external_crates/license_checker/src/file_classifier.rs
@@ -12,7 +12,6 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-use spdx::Licensee;
 use std::{
     collections::BTreeSet,
     fs::read_to_string,
@@ -26,8 +25,8 @@ use crate::{Error, LICENSE_DATA};
 pub(crate) struct Classifier {
     file_path: PathBuf,
     contents: String,
-    by_content: OnceLock<BTreeSet<Licensee>>,
-    by_content_fuzzy: OnceLock<Option<Licensee>>,
+    by_content: OnceLock<BTreeSet<spdx::LicenseReq>>,
+    by_content_fuzzy: OnceLock<Option<spdx::LicenseReq>>,
 }
 
 impl Classifier {
@@ -56,13 +55,13 @@ impl Classifier {
     pub fn file_path(&self) -> &Path {
         self.file_path.as_path()
     }
-    pub fn by_name(&self) -> Option<&Licensee> {
+    pub fn by_name(&self) -> Option<&spdx::LicenseReq> {
         LICENSE_DATA.classify_file_name(self.file_path())
     }
-    pub fn by_content(&self) -> &BTreeSet<Licensee> {
+    pub fn by_content(&self) -> &BTreeSet<spdx::LicenseReq> {
         self.by_content.get_or_init(|| LICENSE_DATA.classify_file_contents(&self.contents))
     }
-    pub fn by_content_fuzzy(&self) -> Option<&Licensee> {
+    pub fn by_content_fuzzy(&self) -> Option<&spdx::LicenseReq> {
         self.by_content_fuzzy
             .get_or_init(|| LICENSE_DATA.classify_file_contents_fuzzy(&self.contents))
             .as_ref()
diff --git a/tools/external_crates/license_checker/src/lib.rs b/tools/external_crates/license_checker/src/lib.rs
index dc4f9e4eb..6b7f3fe93 100644
--- a/tools/external_crates/license_checker/src/lib.rs
+++ b/tools/external_crates/license_checker/src/lib.rs
@@ -16,10 +16,13 @@
 
 use std::{
     collections::{BTreeMap, BTreeSet},
+    fs::{remove_file, write},
     path::{Path, PathBuf},
 };
 
 use file_classifier::Classifier;
+use glob::glob;
+use google_metadata::LicenseType;
 use license_data::{CrateLicenseSpecialCase, License};
 use license_terms::LicenseTerms;
 use licenses::LICENSE_DATA;
@@ -113,14 +116,23 @@ pub enum Error {
     /// The list of license preferences contains an unknown license
     #[error("The license preference list contains unknown license {0}")]
     LicensePreferenceForUnknownLicense(String),
+    /// Invalid MODULE_LICENSE_* file name.
+    #[error("The MODULE_LICENSE_* file name '{0}' does not begin with 'MODULE_LICENSE_'")]
+    InvalidModuleLicenseFileName(String),
+    /// License type is too restrictive.
+    #[error("The license type {0:?} is too restrictive")]
+    LicenseTypeTooRestrictive(LicenseType),
+    /// I/O error.
+    #[error(transparent)]
+    IoError(#[from] std::io::Error),
 }
 
 /// The result of license file verification, containing a set of acceptable licenses, and the
 /// corresponding license files, if present.
 #[derive(Debug)]
 pub struct LicenseState {
-    /// Unsatisfied licenses. These are licenses that are required by evaluation of SPDX license in
-    /// Cargo.toml, but for which no matching license file was found.
+    /// Unsatisfied licenses. These are licenses that are required by evaluation of the SPDX
+    /// license in Cargo.toml, but for which no matching license file was found.
     pub unsatisfied: BTreeSet<LicenseReq>,
     /// Licenses for which a license file file was found, and the path to that file.
     pub satisfied: BTreeMap<LicenseReq, PathBuf>,
@@ -143,12 +155,11 @@ impl LicenseState {
         let not_required = terms.not_required;
 
         for classifier in file_classifiers {
-            if let Some(licensee) = classifier.by_name() {
-                let req = licensee.clone().into_req();
-                if state.unsatisfied.remove(&req) {
+            if let Some(req) = classifier.by_name() {
+                if state.unsatisfied.remove(req) {
                     state.satisfied.insert(req.clone(), classifier.file_path().to_owned());
-                } else if !state.satisfied.contains_key(&req) {
-                    if not_required.contains(&req) {
+                } else if !state.satisfied.contains_key(req) {
+                    if not_required.contains(req) {
                         state.unneeded.insert(req.clone(), classifier.file_path().to_owned());
                     } else {
                         state.unexpected.insert(req.clone(), classifier.file_path().to_owned());
@@ -159,17 +170,16 @@ impl LicenseState {
 
         if !state.unsatisfied.is_empty() {
             for classifier in file_classifiers {
-                for licensee in classifier.by_content() {
-                    let req = licensee.clone().into_req();
-                    if state.unsatisfied.remove(&req) {
+                for req in classifier.by_content() {
+                    if state.unsatisfied.remove(req) {
                         state.satisfied.insert(req.clone(), classifier.file_path().to_owned());
-                    } else if !state.satisfied.contains_key(&req) && !not_required.contains(&req) {
+                    } else if !state.satisfied.contains_key(req) && !not_required.contains(req) {
                         state.unexpected.insert(req.clone(), classifier.file_path().to_owned());
                     }
                 }
                 if classifier.by_content().len() == 1 {
-                    let req = classifier.by_content().first().unwrap().clone().into_req();
-                    if !state.satisfied.contains_key(&req) && not_required.contains(&req) {
+                    let req = classifier.by_content().first().unwrap();
+                    if !state.satisfied.contains_key(req) && not_required.contains(req) {
                         state.unneeded.insert(req.clone(), classifier.file_path().to_owned());
                     }
                 }
@@ -181,9 +191,8 @@ impl LicenseState {
                 if classifier.by_name().is_some() || !classifier.by_content().is_empty() {
                     continue;
                 }
-                if let Some(licensee) = classifier.by_content_fuzzy() {
-                    let req = licensee.clone().into_req();
-                    if state.unsatisfied.remove(&req) {
+                if let Some(req) = classifier.by_content_fuzzy() {
+                    if state.unsatisfied.remove(req) {
                         state.satisfied.insert(req.clone(), classifier.file_path().to_owned());
                         if state.unsatisfied.is_empty() {
                             break;
@@ -195,6 +204,30 @@ impl LicenseState {
 
         state
     }
+
+    /// Update MODULE_LICENSE_* files in a directory based on the applicable licenses.
+    /// These files are typically empty, and their name indicates the type of license that
+    /// applies to the code, for example MODULE_LICENSE_APACHE2.
+    pub fn update_module_license_files(&self, path: &impl AsRef<Path>) -> Result<(), Error> {
+        let path = path.as_ref();
+        for old_module_license_file in glob(&path.join("MODULE_LICENSE*").to_string_lossy())? {
+            remove_file(old_module_license_file?)?;
+        }
+        for file in self.required_terms().map(|req| LICENSE_DATA.module_license_file(req).unwrap())
+        {
+            write(path.join(file), "")?; // Write an empty file. Essentially "touch".
+        }
+        Ok(())
+    }
+
+    /// Find the most restrictive type of license, for reporting in the METADATA file.
+    pub fn most_restrictive_type(&self) -> LicenseType {
+        LICENSE_DATA.most_restrictive_type(self.required_terms())
+    }
+
+    fn required_terms(&self) -> impl Iterator<Item = &LicenseReq> {
+        self.satisfied.keys().chain(&self.unsatisfied)
+    }
 }
 
 /// Evaluates the license expression for a crate at a given path and returns a minimal set of
diff --git a/tools/external_crates/license_checker/src/license_data.rs b/tools/external_crates/license_checker/src/license_data.rs
index 3330a8f16..7399614d1 100644
--- a/tools/external_crates/license_checker/src/license_data.rs
+++ b/tools/external_crates/license_checker/src/license_data.rs
@@ -12,6 +12,8 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+use google_metadata::LicenseType;
+
 /// A license and the means for recognizing it.
 /// We must be able to recognize it either by content, by the `text` field,
 /// or by file name, by the `file_names` field, or both.
@@ -23,13 +25,23 @@ pub(crate) struct License {
     pub text: Option<&'static str>,
     /// A set of file names, any of which unambiguously identify the license.
     pub file_names: &'static [&'static str],
+    /// The name of the MODULE_LICENSE_* file for this license.
+    pub module_license_file_name: &'static str,
+    /// The license type, per http://go/thirdpartylicenses#types
+    pub license_type: LicenseType,
 }
 
 /// A list of all the licenses we recognize and accept.
 /// Only acceptable licenses should go in this list. Please see go/thirdpartylicenses
 /// for information on what this means.
 pub(crate) static LICENSES: &[License] = &[
-    License { name: "0BSD", text: None, file_names: &["LICENSE-0BSD"] },
+    License {
+        name: "0BSD",
+        text: None,
+        file_names: &["LICENSE-0BSD"],
+        module_license_file_name: "MODULE_LICENSE_PERMISSIVE",
+        license_type: LicenseType::PERMISSIVE,
+    },
     License {
         name: "Apache-2.0",
         text: Some(include_str!("licenses/Apache-2.0.txt")),
@@ -39,58 +51,118 @@ pub(crate) static LICENSES: &[License] = &[
             "LICENSES/Apache-2.0",
             "docs/LICENSE-APACHE",
         ],
+        module_license_file_name: "MODULE_LICENSE_APACHE2",
+        license_type: LicenseType::NOTICE,
     },
     License {
         name: "Apache-2.0 WITH LLVM-exception",
         text: None,
         file_names: &["LICENSE-Apache-2.0_WITH_LLVM-exception"],
+        module_license_file_name: "MODULE_LICENSE_APACHE2",
+        license_type: LicenseType::NOTICE,
     },
     License {
         name: "BSD-2-Clause",
         text: Some(include_str!("licenses/BSD-2-Clause.txt")),
         // Note: LICENSE-BSD is not unambiguous. Could be 2-clause or 3-clause
         file_names: &["LICENSE-BSD-2-Clause", "LICENSE.BSD-2-Clause"],
+        module_license_file_name: "MODULE_LICENSE_BSD",
+        license_type: LicenseType::NOTICE,
     },
     License {
         name: "BSD-3-Clause",
         text: Some(include_str!("licenses/BSD-3-Clause.txt")),
         // Note: LICENSE-BSD is not unambiguous. Could be 2-clause or 3-clause
         file_names: &["LICENSE-BSD-3-Clause"],
+        module_license_file_name: "MODULE_LICENSE_BSD",
+        license_type: LicenseType::NOTICE,
+    },
+    License {
+        name: "ISC",
+        text: Some(include_str!("licenses/ISC.txt")),
+        file_names: &[],
+        module_license_file_name: "MODULE_LICENSE_ISC",
+        license_type: LicenseType::NOTICE,
     },
-    License { name: "ISC", text: Some(include_str!("licenses/ISC.txt")), file_names: &[] },
     License {
         name: "MIT",
         text: Some(include_str!("licenses/MIT.txt")),
         file_names: &["LICENSE-MIT", "LICENSES/MIT", "docs/LICENSE-MIT"],
+        module_license_file_name: "MODULE_LICENSE_MIT",
+        license_type: LicenseType::NOTICE,
+    },
+    License {
+        name: "MIT-0",
+        text: Some(include_str!("licenses/MIT-0.txt")),
+        file_names: &[],
+        module_license_file_name: "MODULE_LICENSE_MIT_0",
+        license_type: LicenseType::PERMISSIVE,
+    },
+    License {
+        name: "MPL-2.0",
+        text: Some(include_str!("licenses/MPL-2.0.txt")),
+        file_names: &[],
+        module_license_file_name: "MODULE_LICENSE_MPL",
+        license_type: LicenseType::RECIPROCAL,
+    },
+    License {
+        name: "NCSA",
+        text: Some(include_str!("licenses/NCSA.txt")),
+        file_names: &[],
+        module_license_file_name: "MODULE_LICENSE_NCSA",
+        license_type: LicenseType::NOTICE,
+    },
+    License {
+        name: "OpenSSL",
+        text: Some(include_str!("licenses/OpenSSL.txt")),
+        file_names: &[],
+        module_license_file_name: "MODULE_LICENSE_OPENSSL",
+        license_type: LicenseType::NOTICE,
     },
-    License { name: "MIT-0", text: Some(include_str!("licenses/MIT-0.txt")), file_names: &[] },
-    License { name: "MPL-2.0", text: Some(include_str!("licenses/MPL-2.0.txt")), file_names: &[] },
-    License { name: "NCSA", text: Some(include_str!("licenses/NCSA.txt")), file_names: &[] },
-    License { name: "OpenSSL", text: Some(include_str!("licenses/OpenSSL.txt")), file_names: &[] },
     License {
         name: "Unicode-3.0",
         text: Some(include_str!("licenses/Unicode-3.0.txt")),
         // Note: LICENSE-UNICODE is not unambiguous
         file_names: &[],
+        module_license_file_name: "MODULE_LICENSE_UNICODE_3",
+        license_type: LicenseType::NOTICE,
     },
     License {
         name: "Unicode-DFS-2016",
         text: Some(include_str!("licenses/Unicode-DFS-2016.txt")),
         // Note: LICENSE-UNICODE is not unambiguous
         file_names: &[],
+        module_license_file_name: "MODULE_LICENSE_UNICODE",
+        license_type: LicenseType::NOTICE,
     },
     License {
         name: "Unlicense",
         text: Some(include_str!("licenses/Unlicense.txt")),
         file_names: &["UNLICENSE"],
+        module_license_file_name: "MODULE_LICENSE_PERMISSIVE",
+        license_type: LicenseType::PERMISSIVE,
     },
     License {
         name: "Zlib",
         text: Some(include_str!("licenses/Zlib.txt")),
         file_names: &["LICENSE-ZLIB"],
+        module_license_file_name: "MODULE_LICENSE_ZLIB",
+        license_type: LicenseType::NOTICE,
+    },
+    License {
+        name: "BSL-1.0",
+        text: None,
+        file_names: &["LICENSE-BOOST"],
+        module_license_file_name: "MODULE_LICENSE_BOOST",
+        license_type: LicenseType::NOTICE,
+    },
+    License {
+        name: "CC0-1.0",
+        text: None,
+        file_names: &["LICENSES/CC0-1.0"],
+        module_license_file_name: "MODULE_LICENSE_CC0",
+        license_type: LicenseType::UNENCUMBERED,
     },
-    License { name: "BSL-1.0", text: None, file_names: &["LICENSE-BOOST"] },
-    License { name: "CC0-1.0", text: None, file_names: &["LICENSES/CC0-1.0"] },
 ];
 
 /// Specifies the order of preference for choosing a license.
diff --git a/tools/external_crates/license_checker/src/license_data_tests.rs b/tools/external_crates/license_checker/src/license_data_tests.rs
index 68a631219..5ab65d921 100644
--- a/tools/external_crates/license_checker/src/license_data_tests.rs
+++ b/tools/external_crates/license_checker/src/license_data_tests.rs
@@ -26,32 +26,32 @@ mod name_classification {
         );
         assert_eq!(
             LICENSE_DATA.classify_file_name(Path::new("UNLICENSE")),
-            Some(&Licensee::parse("Unlicense").unwrap()),
+            Some(&Licensee::parse("Unlicense").unwrap().into_req()),
             "Unlicense"
         );
         assert_eq!(
             LICENSE_DATA.classify_file_name(Path::new("LICENSE-MIT")),
-            Some(&Licensee::parse("MIT").unwrap()),
+            Some(&Licensee::parse("MIT").unwrap().into_req()),
             "Standard name"
         );
         assert_eq!(
             LICENSE_DATA.classify_file_name(Path::new("LICENSE-APACHE")),
-            Some(&Licensee::parse("Apache-2.0").unwrap()),
+            Some(&Licensee::parse("Apache-2.0").unwrap().into_req()),
             "Standard name"
         );
         assert_eq!(
             LICENSE_DATA.classify_file_name(Path::new("LICENSE-apache")),
-            Some(&Licensee::parse("Apache-2.0").unwrap()),
+            Some(&Licensee::parse("Apache-2.0").unwrap().into_req()),
             "Case-insensitive"
         );
         assert_eq!(
             LICENSE_DATA.classify_file_name(Path::new("LICENSE-APACHE.md")),
-            Some(&Licensee::parse("Apache-2.0").unwrap()),
+            Some(&Licensee::parse("Apache-2.0").unwrap().into_req()),
             ".md extension ignored"
         );
         assert_eq!(
             LICENSE_DATA.classify_file_name(Path::new("LICENSE-0BSD.txt")),
-            Some(&Licensee::parse("0BSD").unwrap()),
+            Some(&Licensee::parse("0BSD").unwrap().into_req()),
             ".txt extension ignored"
         );
         assert!(
@@ -60,12 +60,12 @@ mod name_classification {
         );
         assert_eq!(
             LICENSE_DATA.classify_file_name(Path::new("LICENSES/MIT")),
-            Some(&Licensee::parse("MIT").unwrap()),
+            Some(&Licensee::parse("MIT").unwrap().into_req()),
             "Subdirectory"
         );
         assert_eq!(
             LICENSE_DATA.classify_file_name(Path::new("LICENSES/Apache-2.0")),
-            Some(&Licensee::parse("Apache-2.0").unwrap()),
+            Some(&Licensee::parse("Apache-2.0").unwrap().into_req()),
             "Subdirectory"
         );
     }
@@ -85,7 +85,7 @@ mod content_classification {
         assert_eq!(
             LICENSE_DATA
                 .classify_file_contents(include_str!("testdata/LICENSE-MIT-aarch64-paging.txt")),
-            BTreeSet::from([Licensee::parse("MIT").unwrap()])
+            BTreeSet::from([Licensee::parse("MIT").unwrap().into_req()])
         );
     }
 
@@ -97,7 +97,7 @@ mod content_classification {
         assert_eq!(
             LICENSE_DATA
                 .classify_file_contents_fuzzy(include_str!("testdata/BSD-3-Clause-bindgen.txt")),
-            Some(Licensee::parse("BSD-3-Clause").unwrap())
+            Some(Licensee::parse("BSD-3-Clause").unwrap().into_req())
         );
     }
 
@@ -113,8 +113,8 @@ mod content_classification {
                 .as_str()
             ),
             BTreeSet::from([
-                Licensee::parse("MIT").unwrap(),
-                Licensee::parse("Apache-2.0").unwrap()
+                Licensee::parse("MIT").unwrap().into_req(),
+                Licensee::parse("Apache-2.0").unwrap().into_req()
             ])
         );
     }
diff --git a/tools/external_crates/license_checker/src/licenses.rs b/tools/external_crates/license_checker/src/licenses.rs
index 8f88de640..1e1af73d6 100644
--- a/tools/external_crates/license_checker/src/licenses.rs
+++ b/tools/external_crates/license_checker/src/licenses.rs
@@ -19,8 +19,9 @@ use std::{
     sync::LazyLock,
 };
 
+use google_metadata::LicenseType;
 use itertools::Itertools;
-use spdx::Licensee;
+use spdx::{LicenseReq, Licensee};
 use textdistance::str::ratcliff_obershelp;
 
 use crate::{
@@ -31,10 +32,10 @@ use crate::{
 
 #[derive(Debug)]
 pub(crate) struct Licenses {
-    licenses: BTreeMap<Licensee, ParsedLicense>,
+    licenses: BTreeMap<LicenseReq, ParsedLicense>,
     license_preference: Vec<Licensee>,
     crate_license_special_cases: CrateLicenseSpecialCases,
-    license_file_names: BTreeMap<OsString, Licensee>,
+    license_file_names: BTreeMap<OsString, LicenseReq>,
 }
 
 impl Licenses {
@@ -51,33 +52,38 @@ impl Licenses {
         let mut license_file_names = BTreeMap::new();
         for license in raw_licenses {
             let parsed = ParsedLicense::try_from(license)?;
-            let licensee = parsed.licensee().clone();
+            let req = parsed.license_req();
             for file_name in parsed.file_names() {
-                if let Some(other) = license_file_names.insert(file_name.clone(), licensee.clone())
-                {
+                if let Some(other) = license_file_names.insert(file_name.clone(), req.clone()) {
                     return Err(Error::DuplicateLicenseFileName {
                         file_name: file_name.to_string_lossy().into_owned(),
-                        license: parsed.licensee().to_string(),
+                        license: parsed.license_req().to_string(),
                         other_license: other.to_string(),
                     });
                 }
             }
-            if licenses.insert(licensee.clone(), parsed).is_some() {
-                return Err(Error::DuplicateLicense(licensee.to_string()));
+            if licenses.insert(req.clone(), parsed).is_some() {
+                return Err(Error::DuplicateLicense(req.to_string()));
             }
         }
 
         let mut ranked_licenses = Vec::new();
         for pref in license_preference {
             let licensee = Licensee::parse(pref)?;
-            if !licenses.contains_key(&licensee) {
+            if !licenses.contains_key(&licensee.clone().into_req()) {
                 return Err(Error::LicensePreferenceForUnknownLicense(pref.to_string()));
             }
-            ranked_licenses.push(licensee);
+            ranked_licenses.push(licensee.clone());
         }
         let unranked_licenses = licenses
-            .keys()
-            .filter_map(|l| if !ranked_licenses.contains(l) { Some(l.clone()) } else { None })
+            .values()
+            .filter_map(|l| {
+                if !ranked_licenses.contains(l.licensee()) {
+                    Some(l.licensee().clone())
+                } else {
+                    None
+                }
+            })
             .collect::<Vec<_>>();
         let license_preference = ranked_licenses.into_iter().chain(unranked_licenses).collect();
 
@@ -127,24 +133,24 @@ impl Licenses {
         )
     }
 
-    pub fn classify_file_name(&self, file: impl AsRef<Path>) -> Option<&Licensee> {
+    pub fn classify_file_name(&self, file: impl AsRef<Path>) -> Option<&LicenseReq> {
         self.license_file_names.get(&normalize_filename(file))
     }
 
     /// Classify file contents by exact substring match on the license text.
-    pub fn classify_file_contents(&self, contents: &str) -> BTreeSet<Licensee> {
+    pub fn classify_file_contents(&self, contents: &str) -> BTreeSet<LicenseReq> {
         let contents = strip_punctuation(contents);
 
         let mut matches = BTreeSet::new();
         for license in self.licenses.values() {
             if license.is_substring_of(contents.as_str()) {
-                matches.insert(license.licensee().clone());
+                matches.insert(license.license_req());
             }
         }
         matches
     }
 
-    pub fn classify_file_contents_fuzzy(&self, contents: &str) -> Option<Licensee> {
+    pub fn classify_file_contents_fuzzy(&self, contents: &str) -> Option<LicenseReq> {
         let contents = strip_punctuation(contents);
 
         // Fuzzy match. This is expensive, so start with licenses that are closest in length to the file,
@@ -165,13 +171,43 @@ impl Licenses {
             if let Some(processed_text) = license.processed_text() {
                 let similarity = ratcliff_obershelp(contents.as_str(), processed_text);
                 if similarity > 0.95 {
-                    return Some(license.licensee().clone());
+                    return Some(license.license_req());
                 }
             }
         }
 
         None
     }
+
+    pub fn module_license_file(&self, req: &LicenseReq) -> Option<&'static str> {
+        self.licenses.get(req).map(|l| l.module_license_file_name())
+    }
+
+    pub fn most_restrictive_type<'a>(
+        &self,
+        terms: impl Iterator<Item = &'a LicenseReq>,
+    ) -> LicenseType {
+        let discriminant = |lt: LicenseType| -> u8 {
+            // Smaller --> more restricted
+            // Larger --> less restricted
+            match lt {
+                LicenseType::UNKNOWN => 0,
+                LicenseType::BY_EXCEPTION_ONLY => 1,
+                LicenseType::RESTRICTED => 2,
+                LicenseType::RESTRICTED_IF_STATICALLY_LINKED => 3,
+                LicenseType::RECIPROCAL => 4,
+                LicenseType::NOTICE => 5,
+                LicenseType::PERMISSIVE => 6,
+                LicenseType::UNENCUMBERED => 7,
+            }
+        };
+        terms
+            .map(|req| {
+                self.licenses.get(req).map(|l| l.license_type()).unwrap_or(LicenseType::UNKNOWN)
+            })
+            .min_by(|a, b| discriminant(*a).cmp(&discriminant(*b)))
+            .unwrap_or(LicenseType::UNKNOWN)
+    }
 }
 
 pub(crate) static LICENSE_DATA: LazyLock<Licenses> = LazyLock::new(|| {
@@ -194,9 +230,27 @@ mod tests {
     fn basic() {
         assert!(Licenses::new(
             &[
-                License { name: "Apache-2.0", text: None, file_names: &["LICENSE-APACHE"] },
-                License { name: "MIT", text: None, file_names: &["LICENSE-MIT"] },
-                License { name: "BSD-3-Clause", text: None, file_names: &["LICENSE-BSD-3-Clause"] },
+                License {
+                    name: "Apache-2.0",
+                    text: None,
+                    file_names: &["LICENSE-APACHE"],
+                    module_license_file_name: "MODULE_LICENSE_APACHE2",
+                    license_type: google_metadata::LicenseType::NOTICE,
+                },
+                License {
+                    name: "MIT",
+                    text: None,
+                    file_names: &["LICENSE-MIT"],
+                    module_license_file_name: "MODULE_LICENSE_MIT",
+                    license_type: google_metadata::LicenseType::NOTICE,
+                },
+                License {
+                    name: "BSD-3-Clause",
+                    text: None,
+                    file_names: &["LICENSE-BSD-3-Clause"],
+                    module_license_file_name: "MODULE_LICENSE_BSD",
+                    license_type: google_metadata::LicenseType::NOTICE,
+                },
             ],
             &["Apache-2.0", "MIT"],
             &[],
@@ -214,8 +268,20 @@ mod tests {
         assert!(matches!(
             Licenses::new(
                 &[
-                    License { name: "MIT", text: None, file_names: &["LICENSE-foo"] },
-                    License { name: "MIT", text: None, file_names: &["LICENSE-bar"] }
+                    License {
+                        name: "MIT",
+                        text: None,
+                        file_names: &["LICENSE-foo"],
+                        module_license_file_name: "MODULE_LICENSE_MIT",
+                        license_type: google_metadata::LicenseType::NOTICE,
+                    },
+                    License {
+                        name: "MIT",
+                        text: None,
+                        file_names: &["LICENSE-bar"],
+                        module_license_file_name: "MODULE_LICENSE_MIT",
+                        license_type: google_metadata::LicenseType::NOTICE,
+                    }
                 ],
                 &[],
                 &[],
@@ -229,8 +295,20 @@ mod tests {
         assert!(matches!(
             Licenses::new(
                 &[
-                    License { name: "Apache-2.0", text: Some("foo"), file_names: &[] },
-                    License { name: "MIT", text: Some("foobar"), file_names: &[] }
+                    License {
+                        name: "Apache-2.0",
+                        text: Some("foo"),
+                        file_names: &[],
+                        module_license_file_name: "MODULE_LICENSE_APACHE2",
+                        license_type: google_metadata::LicenseType::NOTICE,
+                    },
+                    License {
+                        name: "MIT",
+                        text: Some("foobar"),
+                        file_names: &[],
+                        module_license_file_name: "MODULE_LICENSE_MIT",
+                        license_type: google_metadata::LicenseType::NOTICE,
+                    }
                 ],
                 &[],
                 &[],
@@ -244,8 +322,20 @@ mod tests {
         assert!(matches!(
             Licenses::new(
                 &[
-                    License { name: "Apache-2.0", text: None, file_names: &["LICENSE"] },
-                    License { name: "MIT", text: None, file_names: &["LICENSE"] }
+                    License {
+                        name: "Apache-2.0",
+                        text: None,
+                        file_names: &["LICENSE"],
+                        module_license_file_name: "MODULE_LICENSE_APACHE2",
+                        license_type: google_metadata::LicenseType::NOTICE,
+                    },
+                    License {
+                        name: "MIT",
+                        text: None,
+                        file_names: &["LICENSE"],
+                        module_license_file_name: "MODULE_LICENSE_MIT",
+                        license_type: google_metadata::LicenseType::NOTICE,
+                    }
                 ],
                 &[],
                 &[],
@@ -257,7 +347,17 @@ mod tests {
     #[test]
     fn unfindable_license_file() {
         assert!(matches!(
-            Licenses::new(&[License { name: "MIT", text: None, file_names: &["foo"] },], &[], &[],),
+            Licenses::new(
+                &[License {
+                    name: "MIT",
+                    text: None,
+                    file_names: &["foo"],
+                    module_license_file_name: "MODULE_LICENSE_MIT",
+                    license_type: google_metadata::LicenseType::NOTICE,
+                },],
+                &[],
+                &[],
+            ),
             Err(Error::LicenseFileNotFindable(_, _))
         ));
     }
@@ -266,7 +366,13 @@ mod tests {
     fn preference_for_unknown_license() {
         assert!(matches!(
             Licenses::new(
-                &[License { name: "MIT", text: None, file_names: &["LICENSE-MIT"] }],
+                &[License {
+                    name: "MIT",
+                    text: None,
+                    file_names: &["LICENSE-MIT"],
+                    module_license_file_name: "MODULE_LICENSE_MIT",
+                    license_type: google_metadata::LicenseType::NOTICE,
+                }],
                 &["foo"],
                 &[],
             ),
@@ -274,7 +380,13 @@ mod tests {
         ));
         assert!(matches!(
             Licenses::new(
-                &[License { name: "MIT", text: None, file_names: &["LICENSE-MIT"] }],
+                &[License {
+                    name: "MIT",
+                    text: None,
+                    file_names: &["LICENSE-MIT"],
+                    module_license_file_name: "MODULE_LICENSE_MIT",
+                    license_type: google_metadata::LicenseType::NOTICE,
+                }],
                 &["Apache-2.0"],
                 &[],
             ),
@@ -286,8 +398,20 @@ mod tests {
     fn evaluate_crate_license() {
         let licenses = Licenses::new(
             &[
-                License { name: "Apache-2.0", text: None, file_names: &["LICENSE-APACHE"] },
-                License { name: "MIT", text: None, file_names: &["LICENSE-MIT"] },
+                License {
+                    name: "Apache-2.0",
+                    text: None,
+                    file_names: &["LICENSE-APACHE"],
+                    module_license_file_name: "MODULE_LICENSE_APACHE2",
+                    license_type: google_metadata::LicenseType::NOTICE,
+                },
+                License {
+                    name: "MIT",
+                    text: None,
+                    file_names: &["LICENSE-MIT"],
+                    module_license_file_name: "MODULE_LICENSE_MIT",
+                    license_type: google_metadata::LicenseType::NOTICE,
+                },
             ],
             &["Apache-2.0", "MIT"],
             &[],
diff --git a/tools/external_crates/license_checker/src/parsed_license_data.rs b/tools/external_crates/license_checker/src/parsed_license_data.rs
index f16c39b1b..9ebcea977 100644
--- a/tools/external_crates/license_checker/src/parsed_license_data.rs
+++ b/tools/external_crates/license_checker/src/parsed_license_data.rs
@@ -17,6 +17,8 @@ use std::{
     ffi::{OsStr, OsString},
 };
 
+use google_metadata::LicenseType;
+
 use crate::{
     license_file_finder::is_findable, util::strip_punctuation, CrateLicenseSpecialCase, Error,
     License,
@@ -30,18 +32,31 @@ pub(crate) struct ParsedLicense {
     processed_text: Option<String>,
     // A set of file names, any of which unambiguously identify the license.
     file_names: BTreeSet<OsString>,
+    /// The name of the MODULE_LICENSE_* file for this license.
+    module_license_file_name: &'static str,
+    /// The license type, per http://go/thirdpartylicenses#types
+    license_type: LicenseType,
 }
 
 impl ParsedLicense {
     pub fn licensee(&self) -> &spdx::Licensee {
         &self.licensee
     }
+    pub fn license_req(&self) -> spdx::LicenseReq {
+        self.licensee.clone().into_req()
+    }
     pub fn processed_text(&self) -> Option<&str> {
         self.processed_text.as_deref()
     }
     pub fn file_names(&self) -> &BTreeSet<OsString> {
         &self.file_names
     }
+    pub fn module_license_file_name(&self) -> &'static str {
+        self.module_license_file_name
+    }
+    pub fn license_type(&self) -> LicenseType {
+        self.license_type
+    }
     pub fn is_substring_of(&self, other: &str) -> bool {
         self.processed_text.as_ref().is_some_and(|text| other.contains(text.as_str()))
     }
@@ -71,10 +86,28 @@ impl TryFrom<&License> for ParsedLicense {
             file_names.insert(OsString::from(license_file.to_uppercase()));
         }
 
+        if !value.module_license_file_name.starts_with("MODULE_LICENSE_") {
+            return Err(Error::InvalidModuleLicenseFileName(
+                value.module_license_file_name.to_string(),
+            ));
+        }
+
+        if matches!(
+            value.license_type,
+            LicenseType::UNKNOWN
+                | LicenseType::BY_EXCEPTION_ONLY
+                | LicenseType::RESTRICTED_IF_STATICALLY_LINKED
+                | LicenseType::RESTRICTED
+        ) {
+            return Err(Error::LicenseTypeTooRestrictive(value.license_type));
+        }
+
         Ok(ParsedLicense {
             licensee: spdx::Licensee::parse(value.name)?,
             processed_text: value.text.map(strip_punctuation),
             file_names,
+            module_license_file_name: value.module_license_file_name,
+            license_type: value.license_type,
         })
     }
 }
@@ -162,7 +195,13 @@ mod parsed_license_tests {
     #[test]
     fn invalid_license_name() {
         assert!(matches!(
-            ParsedLicense::try_from(&License { name: "foo", text: None, file_names: &["LICENSE"] }),
+            ParsedLicense::try_from(&License {
+                name: "foo",
+                text: None,
+                file_names: &["LICENSE"],
+                module_license_file_name: "MODULE_LICENSE_FOO",
+                license_type: LicenseType::NOTICE,
+            }),
             Err(Error::LicenseParseError(_))
         ));
     }
@@ -170,7 +209,13 @@ mod parsed_license_tests {
     #[test]
     fn missing_both_text_and_file_name() {
         assert!(matches!(
-            ParsedLicense::try_from(&License { name: "MIT", text: None, file_names: &[] }),
+            ParsedLicense::try_from(&License {
+                name: "MIT",
+                text: None,
+                file_names: &[],
+                module_license_file_name: "MODULE_LICENSE_MIT",
+                license_type: LicenseType::NOTICE,
+            }),
             Err(Error::LicenseWithoutTextOrFileNames(_))
         ));
     }
@@ -181,18 +226,57 @@ mod parsed_license_tests {
             ParsedLicense::try_from(&License {
                 name: "MIT",
                 text: Some(" "),
-                file_names: &["LICENSE-MIT"]
+                file_names: &["LICENSE-MIT"],
+                module_license_file_name: "MODULE_LICENSE_MIT",
+                license_type: LicenseType::NOTICE,
             }),
             Err(Error::EmptyLicenseText(_))
         ));
     }
 
+    #[test]
+    fn invalid_module_license_file() {
+        assert!(matches!(
+            ParsedLicense::try_from(&License {
+                name: "MIT",
+                text: None,
+                file_names: &["LICENSE-MIT"],
+                module_license_file_name: "blah",
+                license_type: LicenseType::NOTICE,
+            }),
+            Err(Error::InvalidModuleLicenseFileName(_))
+        ));
+    }
+
+    #[test]
+    fn restrictive_licenses_rejected() {
+        for license_type in [
+            LicenseType::UNKNOWN,
+            LicenseType::BY_EXCEPTION_ONLY,
+            LicenseType::RESTRICTED,
+            LicenseType::RESTRICTED_IF_STATICALLY_LINKED,
+        ] {
+            assert!(matches!(
+                ParsedLicense::try_from(&License {
+                    name: "MIT",
+                    text: None,
+                    file_names: &["LICENSE-MIT"],
+                    module_license_file_name: "MODULE_LICENSE_MIT",
+                    license_type,
+                }),
+                Err(Error::LicenseTypeTooRestrictive(_))
+            ));
+        }
+    }
+
     #[test]
     fn is_substring_of() {
         let license: ParsedLicense = ParsedLicense::try_from(&License {
             name: "MIT",
             text: Some("foo"),
             file_names: &["LICENSE-MIT"],
+            module_license_file_name: "MODULE_LICENSE_MIT",
+            license_type: LicenseType::NOTICE,
         })
         .unwrap();
         assert!(license.is_substring_of("foobar"));
@@ -201,6 +285,8 @@ mod parsed_license_tests {
             name: "MIT",
             text: None,
             file_names: &["LICENSE-MIT"],
+            module_license_file_name: "MODULE_LICENSE_MIT",
+            license_type: LicenseType::NOTICE,
         })
         .unwrap();
         assert!(
diff --git a/tools/external_crates/success_or_error/.gitignore b/tools/external_crates/success_or_error/.gitignore
new file mode 100644
index 000000000..ea8c4bf7f
--- /dev/null
+++ b/tools/external_crates/success_or_error/.gitignore
@@ -0,0 +1 @@
+/target
diff --git a/tools/external_crates/success_or_error/Android.bp b/tools/external_crates/success_or_error/Android.bp
new file mode 100644
index 000000000..ed252bf6a
--- /dev/null
+++ b/tools/external_crates/success_or_error/Android.bp
@@ -0,0 +1,19 @@
+// This file is generated by cargo_embargo.
+// Do not modify this file after the first "rust_*" or "genrule" module
+// because the changes will be overridden on upgrade.
+// Content before the first "rust_*" or "genrule" module is preserved.
+
+package {
+    default_team: "trendy_team_android_rust",
+    default_applicable_licenses: ["Android-Apache-2.0"],
+}
+
+rust_library_host {
+    name: "libsuccess_or_error",
+    crate_name: "success_or_error",
+    cargo_env_compat: true,
+    cargo_pkg_version: "0.1.0",
+    crate_root: "src/lib.rs",
+    edition: "2021",
+    rustlibs: ["libthiserror"],
+}
diff --git a/tools/external_crates/success_or_error/Cargo.toml b/tools/external_crates/success_or_error/Cargo.toml
new file mode 100644
index 000000000..042dcaee3
--- /dev/null
+++ b/tools/external_crates/success_or_error/Cargo.toml
@@ -0,0 +1,7 @@
+[package]
+name = "success_or_error"
+version = "0.1.0"
+edition = "2021"
+
+[dependencies]
+thiserror = "1"
\ No newline at end of file
diff --git a/tools/external_crates/success_or_error/src/lib.rs b/tools/external_crates/success_or_error/src/lib.rs
new file mode 100644
index 000000000..9457a28cc
--- /dev/null
+++ b/tools/external_crates/success_or_error/src/lib.rs
@@ -0,0 +1,110 @@
+// Copyright (C) 2025 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+//! Traits to reduce boilerplate when running commands.
+//! Typically, an unsuccessful exit status indicates a problem,
+//! and these traits make it easy to turn that into an error.
+
+use std::{
+    fmt::Display,
+    process::{Command, ExitStatus, Output},
+};
+
+/// Error types for the 'success_or_error' crate.
+#[derive(thiserror::Error, Debug)]
+pub enum Error {
+    /// Process failed
+    #[error("Command failed with exit code {maybe_status}", maybe_status = MaybeExitCode::from(.0))]
+    CommandFailed(Option<i32>),
+    /// Process failed, with output.
+    #[error("Command failed with exit code {}\nstdout:\n{stdout}\nstderr:\n{stderr}", MaybeExitCode::from(.code), )]
+    CommandFailedwithOutput {
+        /// The exit code.
+        code: Option<i32>,
+        /// The contents of STDOUT, lossily converted to UTF-8.
+        stdout: String,
+        /// The contents of STDERR, lossily converted to UTF-8.
+        stderr: String,
+    },
+    /// Failed to run command
+    #[error("Failed to run command: {0}")]
+    FailedToRunCommand(#[from] std::io::Error),
+}
+
+/// Trait for converting unsuccessful process exit codes into Rust errors.
+pub trait SuccessOrError {
+    /// Returns an error if the process did not exit successfully.
+    /// Otherwise, returns `self`.
+    fn success_or_error(self) -> Result<Self, Error>
+    where
+        Self: std::marker::Sized;
+}
+impl SuccessOrError for ExitStatus {
+    fn success_or_error(self) -> Result<Self, Error> {
+        if !self.success() {
+            Err(Error::CommandFailed(self.code()))
+        } else {
+            Ok(self)
+        }
+    }
+}
+impl SuccessOrError for Output {
+    fn success_or_error(self) -> Result<Self, Error> {
+        (&self).success_or_error()?;
+        Ok(self)
+    }
+}
+impl SuccessOrError for &Output {
+    fn success_or_error(self) -> Result<Self, Error> {
+        if !self.status.success() {
+            Err(Error::from(self))
+        } else {
+            Ok(self)
+        }
+    }
+}
+
+/// Trait to run a command, capturing its output and checking that it exited successfully.
+pub trait RunAndExpectSuccess {
+    /// Run a command and return its output, or an error if the process did not
+    /// exit successfully.
+    fn run_quiet_and_expect_success(&mut self) -> Result<Output, Error>;
+}
+impl RunAndExpectSuccess for Command {
+    fn run_quiet_and_expect_success(&mut self) -> Result<Output, Error> {
+        self.output()?.success_or_error()
+    }
+}
+
+// For pretty-printing optional exit codes.
+struct MaybeExitCode<'a>(&'a Option<i32>);
+impl Display for MaybeExitCode<'_> {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        self.0.map(|code| write!(f, "{}", code)).unwrap_or(f.write_str("(unknown)"))
+    }
+}
+impl<'a> From<&'a Option<i32>> for MaybeExitCode<'a> {
+    fn from(value: &'a Option<i32>) -> Self {
+        MaybeExitCode(value)
+    }
+}
+impl From<&Output> for Error {
+    fn from(value: &Output) -> Self {
+        Error::CommandFailedwithOutput {
+            code: value.status.code(),
+            stdout: String::from_utf8_lossy(&value.stdout).to_string(),
+            stderr: String::from_utf8_lossy(&value.stderr).to_string(),
+        }
+    }
+}
diff --git a/tools/external_crates/test_mapping/Android.bp b/tools/external_crates/test_mapping/Android.bp
index 2043b0a94..4487b43e4 100644
--- a/tools/external_crates/test_mapping/Android.bp
+++ b/tools/external_crates/test_mapping/Android.bp
@@ -17,6 +17,7 @@ rust_library_host {
     edition: "2021",
     rustlibs: [
         "libandroid_bp",
+        "libbp_util",
         "libjson_strip_comments",
         "librooted_path",
         "libserde",
@@ -39,6 +40,7 @@ rust_test_host {
     edition: "2021",
     rustlibs: [
         "libandroid_bp",
+        "libbp_util",
         "libjson_strip_comments",
         "librooted_path",
         "libserde",
diff --git a/tools/external_crates/test_mapping/Cargo.toml b/tools/external_crates/test_mapping/Cargo.toml
index 07fc88445..b5e64929c 100644
--- a/tools/external_crates/test_mapping/Cargo.toml
+++ b/tools/external_crates/test_mapping/Cargo.toml
@@ -9,4 +9,5 @@ json-strip-comments = "1"
 serde = { version = "=1.0.210", features = ["derive"] }
 serde_json = "1"
 thiserror = "1.0"
+bp_util = { path = "../bp_util" }
 rooted_path = { path = "../rooted_path" }
\ No newline at end of file
diff --git a/tools/external_crates/test_mapping/src/blueprint.rs b/tools/external_crates/test_mapping/src/blueprint.rs
deleted file mode 100644
index 28581e2ad..000000000
--- a/tools/external_crates/test_mapping/src/blueprint.rs
+++ /dev/null
@@ -1,202 +0,0 @@
-// Copyright (C) 2024 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-//! Convenience methods for working with Android blueprint files.
-
-use std::{
-    collections::{BTreeSet, HashSet},
-    sync::LazyLock,
-};
-
-use android_bp::{BluePrint, Value};
-
-use crate::Error;
-
-/// Extract rust test rules from a blueprint file.
-pub(crate) trait RustTests {
-    /// Returns the names of all rust_test and rust_test_host rules.
-    fn rust_tests(&self) -> Result<BTreeSet<String>, Error>;
-}
-
-impl RustTests for BluePrint {
-    fn rust_tests(&self) -> Result<BTreeSet<String>, Error> {
-        let mut tests = BTreeSet::new();
-        for module in &self.modules {
-            if matches!(module.typ.as_str(), "rust_test" | "rust_test_host") {
-                let name = module
-                    .get_string("name")
-                    .ok_or(Error::RuleWithoutName(module.typ.clone()))?
-                    .clone();
-                if !EXCLUDED_TESTS.contains(name.as_str()) {
-                    tests.insert(name);
-                }
-            }
-        }
-        Ok(tests)
-    }
-}
-
-/// Finds all the rustlib dependencies mentioned in a blueprint file.
-pub(crate) trait RustDeps {
-    // Finds all the rustlibs mentioned in a blueprint file.
-    // This does a limited amount of evaluation, by doing concatenation and resolving
-    // identifiers. So you can have `common_rustlibs = ["foo", "bar"] and do
-    // rust_library { rustlibs = common_rustlibs + ["baz"] }`
-    fn rust_deps(&self) -> BTreeSet<String>;
-}
-
-impl RustDeps for BluePrint {
-    fn rust_deps(&self) -> BTreeSet<String> {
-        let mut rustlibs = BTreeSet::new();
-        for module in &self.modules {
-            if let Some(v) = module.get("rustlibs") {
-                match v {
-                    Value::Array(_) => rustlibs.extend(v.as_string_vec()),
-                    Value::ConcatExpr(_) => rustlibs.extend(v.eval(self)),
-                    _ => {
-                        println!("Only know how to handle Array and ConcatExpr");
-                    }
-                }
-            }
-        }
-        rustlibs
-    }
-}
-
-// Convenience accessor for arrays of strings.
-trait AsStringVec {
-    // Interpret a android_bp::Value as an array of strings, and convert it to
-    // an array of owned strings. Any element that isn't a string is skipped.
-    fn as_string_vec(&self) -> Vec<String>;
-}
-
-impl AsStringVec for Value {
-    fn as_string_vec(&self) -> Vec<String> {
-        if let Value::Array(vec) = self {
-            vec.iter()
-                .filter_map(|v| match v {
-                    Value::String(s) => Some(s.to_string()),
-                    _ => {
-                        println!("Array element is not a string");
-                        None
-                    }
-                })
-                .collect()
-        } else {
-            println!("Value is not an array");
-            vec![]
-        }
-    }
-}
-
-// Evaluate concatenations and resolve identifiers.
-trait EvalConcat {
-    // Evaluate a concatenation expression, resolving it into a single vector of strings.
-    // The elements being concatenated are assumed to be either identifiers or
-    // arrays of strings. Otherwise, they are skipped.
-    fn eval(&self, bp: &BluePrint) -> Vec<String>;
-}
-
-impl EvalConcat for Value {
-    fn eval(&self, bp: &BluePrint) -> Vec<String> {
-        let mut strings = Vec::new();
-        if let Value::ConcatExpr(expr) = self {
-            for term in expr {
-                match term {
-                    Value::Array(_) => strings.extend(term.as_string_vec()),
-                    Value::Ident(ident) => {
-                        if let Some(ident_val) = bp.variables.get(ident) {
-                            strings.extend(ident_val.as_string_vec());
-                        }
-                    }
-                    _ => {
-                        println!("Concat term is neither ident nor array");
-                    }
-                }
-            }
-        } else {
-            println!("Value is not a ConcatExpr");
-        }
-        strings
-    }
-}
-
-// Taken from update_crate_tests.py
-static EXCLUDED_TESTS: LazyLock<HashSet<&'static str>> = LazyLock::new(|| {
-    HashSet::from([
-        "ash_test_src_lib",
-        "ash_test_tests_constant_size_arrays",
-        "ash_test_tests_display",
-        "shared_library_test_src_lib",
-        "vulkano_test_src_lib",
-        // These are helper binaries for aidl_integration_test
-        // and aren't actually meant to run as individual tests.
-        "aidl_test_rust_client",
-        "aidl_test_rust_service",
-        "aidl_test_rust_service_async",
-        // This is a helper binary for AuthFsHostTest and shouldn't
-        // be run directly.
-        "open_then_run",
-        // TODO: Remove when b/198197213 is closed.
-        "diced_client_test",
-        "CoverageRustSmokeTest",
-        "libtrusty-rs-tests",
-        "terminal-size_test_src_lib",
-    ])
-});
-
-#[cfg(test)]
-mod tests {
-    use super::*;
-
-    #[test]
-    fn rust_tests() -> Result<(), Error> {
-        let bp = BluePrint::parse(
-            r###"
-rust_test { name: "foo" }
-rust_test_host { name: "bar" }
-"###,
-        )
-        .expect("Blueprint parse error");
-        assert_eq!(bp.rust_tests()?, BTreeSet::from(["foo".to_string(), "bar".to_string()]));
-        Ok(())
-    }
-
-    #[test]
-    fn rust_deps() {
-        let bp = BluePrint::parse(
-            r###"
-rust_library { rustlibs: ["foo", "bar"] }
-rust_library { rustlibs: ["bar", "baz"] }
-"###,
-        )
-        .expect("Blueprint parse error");
-        assert_eq!(
-            bp.rust_deps(),
-            BTreeSet::from(["foo".to_string(), "bar".to_string(), "baz".to_string()])
-        );
-    }
-
-    #[test]
-    fn rust_deps_eval() {
-        let bp = BluePrint::parse(
-            r###"
-foo = ["foo"]
-rust_library { rustlibs: foo + ["bar"] }
-"###,
-        )
-        .expect("Blueprint parse error");
-        assert_eq!(bp.rust_deps(), BTreeSet::from(["foo".to_string(), "bar".to_string()]));
-    }
-}
diff --git a/tools/external_crates/test_mapping/src/json.rs b/tools/external_crates/test_mapping/src/json.rs
index 63eb05248..90a52f785 100644
--- a/tools/external_crates/test_mapping/src/json.rs
+++ b/tools/external_crates/test_mapping/src/json.rs
@@ -56,23 +56,23 @@ impl TestMappingJson {
             && self.presubmit_rust.is_empty()
             && self.postsubmit.is_empty()
     }
-    pub fn remove_unknown_tests(&mut self, tests: &BTreeSet<String>) -> bool {
+    pub fn remove_unknown_tests(&mut self, tests: &BTreeSet<&str>) -> bool {
         let mut changed = false;
-        if self.presubmit.iter().any(|t| !tests.contains(&t.name)) {
-            self.presubmit.retain(|t| tests.contains(&t.name));
+        if self.presubmit.iter().any(|t| !tests.contains(t.name.as_str())) {
+            self.presubmit.retain(|t| tests.contains(t.name.as_str()));
             changed = true;
         }
-        if self.presubmit_rust.iter().any(|t| !tests.contains(&t.name)) {
-            self.presubmit_rust.retain(|t| tests.contains(&t.name));
+        if self.presubmit_rust.iter().any(|t| !tests.contains(t.name.as_str())) {
+            self.presubmit_rust.retain(|t| tests.contains(t.name.as_str()));
             changed = true;
         }
-        if self.postsubmit.iter().any(|t| !tests.contains(&t.name)) {
-            self.postsubmit.retain(|t| tests.contains(&t.name));
+        if self.postsubmit.iter().any(|t| !tests.contains(t.name.as_str())) {
+            self.postsubmit.retain(|t| tests.contains(t.name.as_str()));
             changed = true;
         }
         changed
     }
-    pub fn set_presubmits(&mut self, tests: &BTreeSet<String>) {
+    pub fn set_presubmits(&mut self, tests: &BTreeSet<&str>) {
         self.presubmit = tests.iter().map(|t| TestMappingName { name: t.to_string() }).collect();
         self.presubmit_rust = self.presubmit.clone();
     }
@@ -86,12 +86,15 @@ impl TestMappingJson {
         self.presubmit_rust.dedup();
         changed
     }
-    pub fn add_new_tests_to_postsubmit(&mut self, tests: &BTreeSet<String>) -> bool {
+    pub fn add_new_tests_to_postsubmit(&mut self, tests: &BTreeSet<&str>) -> bool {
         let mut changed = false;
-        self.postsubmit.extend(tests.difference(&self.all_test_names()).map(|test_name| {
-            changed = true;
-            TestMappingName { name: test_name.to_string() }
-        }));
+        let all_test_names = self.all_test_names();
+        for test in tests {
+            if !all_test_names.contains(*test) {
+                changed = true;
+                self.postsubmit.push(TestMappingName { name: test.to_string() });
+            }
+        }
         self.postsubmit.sort();
         self.postsubmit.dedup();
         changed
@@ -155,7 +158,7 @@ mod tests {
     #[test]
     fn set_presubmits() -> Result<(), Error> {
         let mut json = TestMappingJson::parse(TEST_JSON.to_string())?;
-        json.set_presubmits(&BTreeSet::from(["asdf".to_string()]));
+        json.set_presubmits(&BTreeSet::from(["asdf"]));
         assert_eq!(json.presubmit, vec![TestMappingName { name: "asdf".to_string() }]);
         assert_eq!(json.presubmit, json.presubmit_rust);
         Ok(())
@@ -164,9 +167,8 @@ mod tests {
     #[test]
     fn add_new_tests_to_postsubmit() -> Result<(), Error> {
         let mut json = TestMappingJson::parse(TEST_JSON.to_string())?;
-        assert!(!json.add_new_tests_to_postsubmit(&BTreeSet::from(["bar".to_string()])));
-        assert!(json
-            .add_new_tests_to_postsubmit(&BTreeSet::from(["bar".to_string(), "asdf".to_string()])));
+        assert!(!json.add_new_tests_to_postsubmit(&BTreeSet::from(["bar"])));
+        assert!(json.add_new_tests_to_postsubmit(&BTreeSet::from(["bar", "asdf"])));
         assert_eq!(
             json.postsubmit,
             vec![
diff --git a/tools/external_crates/test_mapping/src/lib.rs b/tools/external_crates/test_mapping/src/lib.rs
index 6d6b07fa2..c122a4c39 100644
--- a/tools/external_crates/test_mapping/src/lib.rs
+++ b/tools/external_crates/test_mapping/src/lib.rs
@@ -14,7 +14,6 @@
 
 //! Read, update, and write TEST_MAPPING files.
 
-mod blueprint;
 mod json;
 mod rdeps;
 
@@ -27,7 +26,7 @@ use std::{
 };
 
 use android_bp::BluePrint;
-use blueprint::RustTests;
+use bp_util::{RustLibs, RustTests};
 use json::{TestMappingJson, TestMappingPath};
 use rdeps::ReverseDeps;
 use rooted_path::RootedPath;
@@ -43,7 +42,7 @@ pub enum Error {
     BlueprintParseError(String),
     /// Blueprint rule has no name
     #[error("Blueprint rule has no name")]
-    RuleWithoutName(String),
+    RuleWithoutName(#[from] bp_util::Error),
 
     /// Error stripping JSON comments
     #[error("Error stripping JSON comments: {0}")]
@@ -149,8 +148,8 @@ impl TestMapping {
     pub fn update_imports(&mut self) -> Result<(), Error> {
         let all_rdeps = ReverseDeps::for_repo(self.path.root());
         let mut rdeps = BTreeSet::new();
-        for lib in self.libs()? {
-            if let Some(paths) = all_rdeps.get(lib.as_str()) {
+        for lib in self.bp.rust_libs()? {
+            if let Some(paths) = all_rdeps.get(lib) {
                 rdeps.append(&mut paths.clone());
             }
         }
@@ -165,21 +164,4 @@ impl TestMapping {
     fn test_mapping(&self) -> RootedPath {
         self.path.join("TEST_MAPPING").unwrap()
     }
-    fn libs(&self) -> Result<Vec<String>, Error> {
-        let mut libs = Vec::new();
-        for module in &self.bp.modules {
-            if matches!(
-                module.typ.as_str(),
-                "rust_library" | "rust_library_rlib" | "rust_library_host" | "rust_proc_macro"
-            ) {
-                libs.push(
-                    module
-                        .get_string("name")
-                        .ok_or(Error::RuleWithoutName(module.typ.clone()))?
-                        .clone(),
-                );
-            }
-        }
-        Ok(libs)
-    }
 }
diff --git a/tools/external_crates/test_mapping/src/rdeps.rs b/tools/external_crates/test_mapping/src/rdeps.rs
index 48620cf26..1d58e6d7a 100644
--- a/tools/external_crates/test_mapping/src/rdeps.rs
+++ b/tools/external_crates/test_mapping/src/rdeps.rs
@@ -24,8 +24,9 @@ use std::{
 };
 
 use android_bp::BluePrint;
+use bp_util::RustDeps;
 
-use crate::{blueprint::RustDeps, Error};
+use crate::Error;
 
 #[derive(Clone)]
 pub(crate) struct ReverseDeps {
@@ -78,7 +79,10 @@ impl ReverseDeps {
             let (dir, _) = line.rsplit_once('/').ok_or(Error::GrepParseError(line.to_string()))?;
             if let Ok(bp) = BluePrint::from_file(repo_root.join(line)) {
                 for rustlib in bp.rust_deps() {
-                    rdeps.entry(rustlib).or_insert(BTreeSet::new()).insert(dir.to_string());
+                    rdeps
+                        .entry(rustlib.to_string())
+                        .or_insert(BTreeSet::new())
+                        .insert(dir.to_string());
                 }
             }
         }
diff --git a/tools/line_endings/Android.bp b/tools/line_endings/Android.bp
deleted file mode 100644
index 6f04f1a3e..000000000
--- a/tools/line_endings/Android.bp
+++ /dev/null
@@ -1,15 +0,0 @@
-// Copyright 2007 The Android Open Source Project
-//
-// Copies files into the directory structure described by a manifest
-
-package {
-    // See: http://go/android-license-faq
-    default_applicable_licenses: ["Android-Apache-2.0"],
-}
-
-cc_binary_host {
-    name: "line_endings",
-    srcs: ["line_endings.c"],
-    cflags: ["-Wall", "-Werror"],
-    stl: "none",
-}
diff --git a/tools/line_endings/line_endings.c b/tools/line_endings/line_endings.c
deleted file mode 100644
index 5d3f8d263..000000000
--- a/tools/line_endings/line_endings.c
+++ /dev/null
@@ -1,158 +0,0 @@
-#include <unistd.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-#include <sys/stat.h>
-
-#define BUFSIZE (1024*8)
-static void to_unix(char* buf);
-static void unix_to_dos(char* buf2, const char* buf);
-
-int usage()
-{
-    fprintf(stderr, "usage: line_endings unix|dos FILES\n"
-            "\n"
-            "Convert FILES to either unix or dos line endings.\n");
-    return 1;
-}
-
-typedef struct Node {
-    struct Node *next;
-    char buf[BUFSIZE*2+3];
-} Node;
-
-int
-main(int argc, char** argv)
-{
-    enum { UNIX, DOS } ending;
-    int i;
-
-    if (argc < 2) {
-        return usage();
-    }
-
-    if (0 == strcmp("unix", argv[1])) {
-        ending = UNIX;
-    }
-    else if (0 == strcmp("dos", argv[1])) {
-        ending = DOS;
-    }
-    else {
-        return usage();
-    }
-
-    for (i=2; i<argc; i++) {
-        int fd;
-        int len;
-
-        // force implied
-        chmod(argv[i], S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP);
-
-        fd = open(argv[i], O_RDWR);
-        if (fd < 0) {
-            fprintf(stderr, "unable to open file for read/write: %s\n", argv[i]);
-            return 1;
-        }
-
-        len = lseek(fd, 0, SEEK_END);
-        lseek(fd, 0, SEEK_SET);
-
-        if (len > 0) {
-            Node* root = malloc(sizeof(Node));
-            Node* node = root;
-            node->buf[0] = 0;
-
-            while (len > 0) {
-                node->next = malloc(sizeof(Node));
-                node = node->next;
-                node->next = NULL;
-
-                char buf[BUFSIZE+2];
-                ssize_t amt;
-                ssize_t amt2 = len < BUFSIZE ? len : BUFSIZE;
-                amt = read(fd, buf, amt2);
-                if (amt != amt2) {
-                    fprintf(stderr, "unable to read file: %s\n", argv[i]);
-                    return 1;
-                }
-                buf[amt2] = '\0';
-                to_unix(buf);
-                if (ending == UNIX) {
-                    strcpy(node->buf, buf);
-                } else {
-                    char buf2[(BUFSIZE*2)+3];
-                    unix_to_dos(buf2, buf);
-                    strcpy(node->buf, buf2);
-                }
-                len -= amt2;
-            }
-
-            (void)ftruncate(fd, 0);
-            lseek(fd, 0, SEEK_SET);
-            while (root) {
-                ssize_t amt2 = strlen(root->buf);
-                if (amt2 > 0) {
-                    ssize_t amt = write(fd, root->buf, amt2);
-                    if (amt != amt2) {
-                        fprintf(stderr, "unable to write file: %s\n", argv[i]);
-                        return 1;
-                    }
-                }
-                node = root;
-                root = root->next;
-                free(node);
-            }
-        }
-        close(fd);
-    }
-    return 0;
-}
-
-void
-to_unix(char* buf)
-{
-    char* p = buf;
-    char* q = buf;
-    while (*p) {
-        if (p[0] == '\r' && p[1] == '\n') {
-            // dos
-            *q = '\n';
-            p += 2;
-            q += 1;
-        }
-        else if (p[0] == '\r') {
-            // old mac
-            *q = '\n';
-            p += 1;
-            q += 1;
-        }
-        else {
-            *q = *p;
-            p += 1;
-            q += 1;
-        }
-    }
-    *q = '\0';
-}
-
-void
-unix_to_dos(char* buf2, const char* buf)
-{
-    const char* p = buf;
-    char* q = buf2;
-    while (*p) {
-        if (*p == '\n') {
-            q[0] = '\r';
-            q[1] = '\n';
-            q += 2;
-            p += 1;
-        } else {
-            *q = *p;
-            p += 1;
-            q += 1;
-        }
-    }
-    *q = '\0';
-}
-
diff --git a/tools/motion/OWNERS b/tools/motion/OWNERS
index 545b822d0..02fe8e15c 100644
--- a/tools/motion/OWNERS
+++ b/tools/motion/OWNERS
@@ -1,3 +1,4 @@
 cinek@google.com
 gallmann@google.com
 michschn@google.com
+sandeepsuman@google.com
\ No newline at end of file
diff --git a/tools/motion/motion_test_watcher_app/src/app/app.component.html b/tools/motion/motion_test_watcher_app/src/app/app.component.html
index b4a8c7e37..5f536191c 100644
--- a/tools/motion/motion_test_watcher_app/src/app/app.component.html
+++ b/tools/motion/motion_test_watcher_app/src/app/app.component.html
@@ -1,14 +1,28 @@
 <mat-toolbar class="bg-blue-500 text-white">
   <span class="font-medium text-lg">Motion Test Watcher</span>
+    <span class="flex-auto"></span>
+
+  <div class = "font-medium text-lg justify-end">
+      <button mat-button color="primary" (click)="openDialog()">
+        Get Presubmit Artifacts
+      </button>
+    </div>
 </mat-toolbar>
 
 <div class="flex h-screen p-4 bg-gray-100">
-  <div class="w-1/4 bg-white rounded-md shadow-md overflow-y-auto mr-4">
-    <app-test-list
-      [goldens]="goldens"
-      (refreshRequest)="refreshGoldens($event)"
-      (selectedGoldenChange)="setSelectedGolden($event)"
-    ></app-test-list>
+  <div class="nav-bar flex items-start justify-center w-10 bg-slate-200 overflow-y-auto">
+    <button (click)="toggleTestListVisibility()" class="pt-4">
+    <span class="google-symbols">menu</span>
+    </button>
+  </div>
+  <div *ngIf="showTestList" [@sidebarMenuAnimation] class="w-1/4 bg-white rounded-r-md  overflow-y-auto mr-4">
+      <app-test-list
+        [goldens]="goldens"
+        (refreshRequest)="refreshGoldens($event)"
+        (selectedGoldenChange)="setSelectedGolden($event)"
+        [testNames]="testNames"
+        (selectedTestNameChange)="setSelectedTest($event)"
+      ></app-test-list>
   </div>
 
   <div class="flex flex-col flex-grow space-y-4">
@@ -21,6 +35,11 @@
   </div>
 </div>
 
+<div *ngIf="showLoader"
+class="fixed top-0 left-0 w-screen h-screen bg-black/60 flex flex-col justify-center items-center z-50 text-white">
+  <mat-spinner diameter="50"></mat-spinner> <p>Loading data...</p>
+</div>
+
 <div
   *ngIf="showProgress"
   class="fixed top-0 left-0 w-full h-1 bg-blue-500 transition-all duration-300 ease-in-out"
diff --git a/tools/motion/motion_test_watcher_app/src/app/app.component.ts b/tools/motion/motion_test_watcher_app/src/app/app.component.ts
index 3a80c0bc6..df60cbfb4 100644
--- a/tools/motion/motion_test_watcher_app/src/app/app.component.ts
+++ b/tools/motion/motion_test_watcher_app/src/app/app.component.ts
@@ -8,7 +8,18 @@ import { TimelineComponent } from '../timeline/timeline.component';
 import { MotionGolden } from '../model/golden';
 import { finalize } from 'rxjs';
 import { NgIf } from '@angular/common';
+import {
+  trigger,
+  state,
+  style,
+  animate,
+  transition
+} from '@angular/animations';
 
+import { DialogContentComponent } from '../dialog/dialog.component';
+import { MatButton } from '@angular/material/button';
+import { MatDialog } from '@angular/material/dialog';
+import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
 @Component({
   selector: 'app-root',
   imports: [
@@ -17,19 +28,119 @@ import { NgIf } from '@angular/common';
     PreviewComponent,
     TimelineComponent,
     NgIf,
-  ],
+    MatButton,
+    MatProgressSpinnerModule
+],
   templateUrl: './app.component.html',
   styleUrl: './app.component.css',
+  animations: [
+    trigger('sidebarMenuAnimation', [
+      state('void', style({
+        width: '0',
+        'min-width': '0',
+        marginRight: '0',
+        opacity: 0,
+        paddingLeft: '0',
+        paddingRight: '0',
+        overflow: 'hidden'
+      })),
+      transition(':leave', [
+        style({
+          width: '*',
+          'min-width': '25%',
+          marginRight: '*',
+          opacity: 1,
+          paddingLeft: '*',
+          paddingRight: '*'
+        }),
+        animate('300ms ease-in')
+      ]),
+      transition(':enter', [
+        style({
+          width: '0',
+          'min-width': '0',
+          marginRight: '0',
+          opacity: 0,
+          paddingLeft: '0',
+          paddingRight: '0'
+        }),
+        animate('300ms ease-out', style({
+          width: '*',
+          'min-width': '25%',
+          marginRight: '*',
+          opacity: 1,
+          paddingLeft: '*',
+          paddingRight: '*'
+        }))
+      ])
+    ])
+  ]
 })
 export class AppComponent implements DoCheck, OnInit {
   constructor(
     private goldenService: GoldensService,
-    private progressTracker: ProgressTracker
-  ) {}
+    private progressTracker: ProgressTracker,
+    public dialog: MatDialog
+    ) {}
+
+  isNullOrEmpty(obj : any) : Boolean {
+    return (obj == null || obj.length == 0)
+  }
+
+  openDialog(): void {
+    const dialogRef = this.dialog.open(DialogContentComponent);
+
+    dialogRef.afterClosed().subscribe(invocationID => {
+      if (invocationID) {
+        this.showLoaderBar()
+        this.goldenService.refreshGoldens(true)
+        this.goldenService.getTestArtifacts(invocationID)
+        .pipe(finalize(() => this.hideLoaderBar()))
+        .subscribe({
+          next : (fetchedTestNames) => {
+            if (this.isNullOrEmpty(fetchedTestNames)) {
+              fetchedTestNames = []
+              console.log("No artifacts found")
+              alert("No artifacts found")
+            }
+            this.goldens = []
+            this.selectedGolden = null
+            this.testNames = fetchedTestNames
+          },
+          error : (err) => {
+            this.testNames = []
+            this.goldens = []
+            this.selectedGolden = null
+            this.showErrorAlert(err)
+          }
+        })
+      }
+    });
+  }
 
   showProgress = false;
+  showLoader = false;
   goldens: MotionGolden[] = [];
+  testNames: String[] = [];
+  selectedTest: String | null = null;
   selectedGolden: MotionGolden | null = null;
+  showTestList: boolean = true;
+
+  toggleTestListVisibility() {
+    this.showTestList = !this.showTestList;
+  }
+
+  showErrorAlert(err: Error) {
+    alert(`Some error occurred ${err.message}`)
+  }
+  showLoaderBar() : void {
+    this.showLoader = true;
+  }
+
+  hideLoaderBar() : void {
+    this.showLoader = false;
+  }
+
 
   ngDoCheck(): void {
     this.showProgress = this.progressTracker.isActive;
@@ -58,4 +169,19 @@ export class AppComponent implements DoCheck, OnInit {
   setSelectedGolden(golden: MotionGolden): void {
     this.selectedGolden = golden;
   }
+
+   setSelectedTest(testName: String): void {
+    this.selectedTest = testName;
+    this.showLoaderBar();
+    this.goldenService.getTestArtifactsForTestName(testName).pipe(finalize(() => this.hideLoaderBar())).subscribe({
+      next: (fetchedGolden) => {
+        this.selectedGolden = fetchedGolden
+      },
+      error: (err) => {
+        this.goldens = [];
+        this.selectedGolden = null;
+        this.showErrorAlert(err)
+      }
+    })
+  }
 }
diff --git a/tools/motion/motion_test_watcher_app/src/app/app.config.ts b/tools/motion/motion_test_watcher_app/src/app/app.config.ts
index 3712b1887..a9217ad8e 100644
--- a/tools/motion/motion_test_watcher_app/src/app/app.config.ts
+++ b/tools/motion/motion_test_watcher_app/src/app/app.config.ts
@@ -1,6 +1,7 @@
 import { provideHttpClient } from '@angular/common/http';
 import { ApplicationConfig } from '@angular/core';
 import { provideRouter } from '@angular/router';
+import { provideAnimations } from '@angular/platform-browser/animations';
 import { provideAnimationsAsync } from '@angular/platform-browser/animations/async';
 
 import { routes } from './app.routes';
@@ -53,6 +54,7 @@ export const appConfig: ApplicationConfig = {
   providers: [
     provideRouter(routes),
     provideHttpClient(),
+    provideAnimations(),
     provideAnimationsAsync(),
     ProgressTracker,
     Preferences,
diff --git a/tools/winscope/src/test/fixtures/traces/empty.pb b/tools/motion/motion_test_watcher_app/src/dialog/dialog.component.css
similarity index 100%
rename from tools/winscope/src/test/fixtures/traces/empty.pb
rename to tools/motion/motion_test_watcher_app/src/dialog/dialog.component.css
diff --git a/tools/motion/motion_test_watcher_app/src/dialog/dialog.component.html b/tools/motion/motion_test_watcher_app/src/dialog/dialog.component.html
new file mode 100644
index 000000000..757b8e0ca
--- /dev/null
+++ b/tools/motion/motion_test_watcher_app/src/dialog/dialog.component.html
@@ -0,0 +1,11 @@
+<h2 mat-dialog-title>Get Presubmit artifacts</h2>
+<mat-dialog-content>
+    <mat-form-field>
+    <mat-label>Presubmit Invocation ID/URL</mat-label>
+    <input matInput type="text" [(ngModel)]="inputText" />
+    </mat-form-field>
+</mat-dialog-content>
+<mat-dialog-actions align="end">
+    <button mat-button color="primary" (click)="onCancel()">Cancel</button>
+    <button mat-button color="primary" (click)="getArtifacts()">Get Artifacts</button>
+</mat-dialog-actions>
diff --git a/tools/motion/motion_test_watcher_app/src/dialog/dialog.component.ts b/tools/motion/motion_test_watcher_app/src/dialog/dialog.component.ts
new file mode 100644
index 000000000..f9b208f30
--- /dev/null
+++ b/tools/motion/motion_test_watcher_app/src/dialog/dialog.component.ts
@@ -0,0 +1,58 @@
+import { Component } from '@angular/core';
+import { MatDialogRef, MatDialogContent, MatDialogTitle, MatDialogActions } from '@angular/material/dialog';
+import { MatInput } from '@angular/material/input';
+import { MatFormField, MatLabel } from '@angular/material/form-field';
+import { FormsModule } from '@angular/forms';
+import { MatButton } from '@angular/material/button';
+
+@Component({
+  selector: 'app-dialog-content',
+  templateUrl: './dialog.component.html',
+  standalone: true,
+  imports: [
+     MatInput,
+     MatFormField,
+     FormsModule,
+     MatButton,
+     MatDialogContent,
+     MatDialogTitle,
+     MatDialogActions,
+     MatLabel
+  ]
+})
+export class DialogContentComponent {
+  inputText: string = '';
+
+  constructor(public dialogRef: MatDialogRef<DialogContentComponent>) {}
+
+  onCancel(): void {
+    this.dialogRef.close();
+  }
+
+  getArtifacts(): void {
+    this.dialogRef.close(this.getInvocationId(this.inputText));
+  }
+
+  // invocationIdentifier could either be the invocation url or just the invocation id
+  getInvocationId(invocationIdentifier : String) : String {
+    if (invocationIdentifier.startsWith("http")) {
+    const parts: string[] = invocationIdentifier.split('/')
+    const keyword = "invocation";
+    const invocationIndex: number = parts.indexOf(keyword);
+
+    if (invocationIndex !== -1 && invocationIndex + 1 < parts.length) {
+      const invocationId: string = parts[invocationIndex + 1];
+      return invocationId;
+    } else {
+      if (invocationIndex === -1) {
+        console.error(`The keyword '${keyword}' was not found in the URL path segments.`);
+      } else {
+        console.error(`The URL structure is unexpected; no segment found after '${keyword}'.`);
+      }
+      return "";
+    }
+  }else{
+    return invocationIdentifier
+  }
+}
+}
diff --git a/tools/motion/motion_test_watcher_app/src/index.html b/tools/motion/motion_test_watcher_app/src/index.html
index b48ff7575..53c52f0b0 100644
--- a/tools/motion/motion_test_watcher_app/src/index.html
+++ b/tools/motion/motion_test_watcher_app/src/index.html
@@ -10,6 +10,7 @@
       href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap"
       rel="stylesheet"
     />
+    <link href="https://fonts.googleapis.com/css2?family=Google+Symbols:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" rel="stylesheet" />
     <link
       href="https://fonts.googleapis.com/icon?family=Material+Icons"
       rel="stylesheet"
diff --git a/tools/motion/motion_test_watcher_app/src/model/golden.ts b/tools/motion/motion_test_watcher_app/src/model/golden.ts
index 325b662c9..ef68f1305 100644
--- a/tools/motion/motion_test_watcher_app/src/model/golden.ts
+++ b/tools/motion/motion_test_watcher_app/src/model/golden.ts
@@ -26,6 +26,7 @@ export interface MotionGolden {
   testTime: string;
   updated: boolean;
   videoUrl: string | undefined;
+  goldenName: string | undefined;
 }
 
 export interface MotionGoldenData {
diff --git a/tools/motion/motion_test_watcher_app/src/service/goldens.service.ts b/tools/motion/motion_test_watcher_app/src/service/goldens.service.ts
index be45143a9..b83238421 100644
--- a/tools/motion/motion_test_watcher_app/src/service/goldens.service.ts
+++ b/tools/motion/motion_test_watcher_app/src/service/goldens.service.ts
@@ -69,6 +69,42 @@ export class GoldensService {
     );
   }
 
+  getTestArtifacts(invocation_id: String) : Observable<String[]> {
+    return this.http
+    .post<String[]>(
+      `${this.serverRoot}/service/presubmit_artifact/list`,
+      { invocation_id },
+      {
+        headers: {
+          ...this.defaultHeaders,
+          'Content-Type': 'application/json',
+        },
+      }
+    )
+    .pipe(
+      tap((artifacts) => console.log(`fetched ${artifacts.length} for invocationID : ${invocation_id}`)),
+      catchError(this.handleError<String[]>('e'))
+    );
+  }
+
+  getTestArtifactsForTestName(resource_id: String) : Observable<MotionGolden> {
+    return this.http
+    .post<MotionGolden>(
+      `${this.serverRoot}/service/fetch_artifact`,
+      { resource_id },
+      {
+        headers: {
+          ...this.defaultHeaders,
+          'Content-Type': 'application/json',
+        },
+      }
+    )
+    .pipe(
+      tap((artifact) => console.log(`fetched ${artifact} for testName : ${resource_id}`)),
+      catchError(this.handleError<MotionGolden>('e'))
+    );
+  }
+
   getActualGoldenData(golden: MotionGolden): Observable<MotionGoldenData> {
     return this.http
       .get<MotionGoldenData>(`${golden.actualUrl}`, {
diff --git a/tools/motion/motion_test_watcher_app/src/test-list/test-list.component.html b/tools/motion/motion_test_watcher_app/src/test-list/test-list.component.html
index 822871114..9552f0207 100644
--- a/tools/motion/motion_test_watcher_app/src/test-list/test-list.component.html
+++ b/tools/motion/motion_test_watcher_app/src/test-list/test-list.component.html
@@ -1,5 +1,5 @@
 <div
-  *ngIf="totalTestCount === 0; else testListContent"
+  *ngIf="totalTestCount === 0 && testNames.length == 0"
   class="flex flex-col items-center justify-center h-full p-8 bg-white rounded-md"
 >
   <p class="text-gray-500 text-center">
@@ -13,7 +13,7 @@
   </button>
 </div>
 
-<ng-template #testListContent>
+<div *ngIf="totalTestCount > 0">
   <div class="p-4 bg-white rounded-md">
     <div class="flex justify-between items-center pb-2 mb-2">
       <select
@@ -69,4 +69,23 @@
       </mat-expansion-panel>
     </mat-accordion>
   </div>
-</ng-template>
+</div>
+
+<div *ngIf="testNames.length > 0">
+  <div class="p-4 bg-white rounded-md">
+    <mat-accordion class="mt-4" displayMode="flat">
+      <mat-expansion-panel hideToggle=""
+        *ngFor="let golden of testNames"
+        (opened)="testOpened(golden)"
+      >
+      <mat-expansion-panel-header class="flex items-center">
+          <mat-panel-title class="flex-1 min-w-0">
+            <div class="flex items-center">
+              <span >{{extractLastPart(golden) }}</span>
+            </div>
+          </mat-panel-title>
+      </mat-expansion-panel-header>
+      </mat-expansion-panel>
+    </mat-accordion>
+  </div>
+</div>
diff --git a/tools/motion/motion_test_watcher_app/src/test-list/test-list.component.ts b/tools/motion/motion_test_watcher_app/src/test-list/test-list.component.ts
index 59e34db13..f1c9d55a6 100644
--- a/tools/motion/motion_test_watcher_app/src/test-list/test-list.component.ts
+++ b/tools/motion/motion_test_watcher_app/src/test-list/test-list.component.ts
@@ -25,11 +25,15 @@ import { FormsModule } from '@angular/forms';
   templateUrl: './test-list.component.html',
   styleUrl: './test-list.component.css',
 })
-export class TestListComponent implements OnChanges {
+export class TestListComponent implements OnChanges{
   @Input() goldens: MotionGolden[] = [];
+  @Input() testNames: String[] = [];
+  @Output() selectedTestNameChange = new EventEmitter<String>();
   @Output() refreshRequest = new EventEmitter<boolean>();
   @Output() selectedGoldenChange = new EventEmitter<MotionGolden>();
   selectedGolden: MotionGolden | null = null;
+  selectedTest: String | null = null;
+
 
   filterStatus: 'all' | 'pass' | 'fail' = 'all';
 
@@ -56,6 +60,16 @@ export class TestListComponent implements OnChanges {
     this.selectedGoldenChange.emit(golden);
   }
 
+  extractLastPart(path: String): String {
+  return path.split('/').pop() || '';
+}
+
+  testOpened(testName: String): void {
+    console.log(`testName clicked : ${testName}`)
+    this.selectedTest = testName;
+    this.selectedTestNameChange.emit(testName);
+  }
+
   get filteredGoldens(): MotionGolden[] {
     if (this.filterStatus === 'all') {
       return this.goldens;
@@ -79,3 +93,4 @@ export class TestListComponent implements OnChanges {
     }
   }
 }
+
diff --git a/tools/motion/motion_test_watcher_app/src/timeline/graph/graph.component.ts b/tools/motion/motion_test_watcher_app/src/timeline/graph/graph.component.ts
index 3334c94ad..482d7ff84 100644
--- a/tools/motion/motion_test_watcher_app/src/timeline/graph/graph.component.ts
+++ b/tools/motion/motion_test_watcher_app/src/timeline/graph/graph.component.ts
@@ -123,31 +123,34 @@ export class GraphComponent implements AfterViewInit, OnChanges {
     const name = actualFeature?.name;
     const type = actualFeature?.type;
 
-    if (
-      actualFeature &&
-      ['float', 'int', 'dp', 'dpOffset', 'dpSize', 'offset'].includes(
-        type || ''
-      )
-    ) {
-      const numericValues =
-        actualFeature.data_points?.filter(
-          (it): it is number => typeof it === 'number'
-        ) || [];
-      const minValue = Math.min(...numericValues) ?? 0;
-      let maxValue = Math.max(...numericValues) ?? 1;
-
-      if (minValue === maxValue) {
-        maxValue += 1;
-      }
-
-      return new LineGraphVisualization(
-        minValue,
-        maxValue,
-        this.graphId,
-        this.previewService
-      );
+    let numericValues: number[] = [];
+    if (actualFeature?.data_points) {
+      numericValues = numericValues.concat(actualFeature.data_points.filter(
+        (it): it is number => typeof it === 'number'
+      ))
+    };
+    if (expectedFeature?.data_points) {
+      numericValues = numericValues.concat(expectedFeature.data_points.filter(
+        (it): it is number => typeof it === 'number'
+      ))
+    };
+
+    let minValue = Math.min(...numericValues) ?? 0;
+    let maxValue = Math.max(...numericValues) ?? 1;
+
+    if (minValue === maxValue) {
+      maxValue += 1;
     }
-    return new LineGraphVisualization(0, 1, this.graphId, this.previewService);
+    if(minValue!==0) {
+      minValue-=(maxValue-minValue)/10;
+    }
+
+    return new LineGraphVisualization(
+      minValue,
+      maxValue,
+      this.graphId,
+      this.previewService
+    );
   }
 
   private createChart(): void {
diff --git a/tools/motion/motion_test_watcher_app/src/timeline/graph/line-graph-visualization.ts b/tools/motion/motion_test_watcher_app/src/timeline/graph/line-graph-visualization.ts
index 786237b04..88dd01b67 100644
--- a/tools/motion/motion_test_watcher_app/src/timeline/graph/line-graph-visualization.ts
+++ b/tools/motion/motion_test_watcher_app/src/timeline/graph/line-graph-visualization.ts
@@ -1,4 +1,4 @@
-import { Visualization, DataPoint } from './visualization';
+import { Visualization, DataPoint, COLORS } from './visualization';
 import * as d3 from 'd3';
 import { PreviewService } from '../../service/preview.service';
 
@@ -70,13 +70,24 @@ export class LineGraphVisualization implements Visualization {
 
   private drawAxes(g: d3.Selection<SVGGElement, unknown, null, undefined>) {
     const xAxis = d3.axisBottom(this.xScale);
-    const yAxis = d3.axisLeft(this.yScale);
-    g.append('g')
+    const currentYAxisTicks = this.yScale.ticks().length;
+    const newYAxisTicks = Math.max(1, Math.floor(currentYAxisTicks / 2));
+    const yAxis = d3.axisLeft(this.yScale)
+                    .ticks(newYAxisTicks);
+    const xAxisGroup= g.append('g')
       .attr('class', 'x axis')
       .attr('transform', `translate(0, ${this.chartHeight})`)
       .call(xAxis);
-
-    g.append('g').attr('class', 'y axis').call(yAxis);
+      xAxisGroup.selectAll('path').attr('stroke', COLORS.gray); // Main axis line
+      xAxisGroup.selectAll('line').attr('stroke', COLORS.gray); // Tick marks
+      xAxisGroup.selectAll('text').attr('fill', COLORS.gray); // Labels
+
+    const yAxisGroup= g.append('g')
+      .attr('class', 'y axis')
+      .call(yAxis);
+      yAxisGroup.selectAll('path').attr('stroke', COLORS.gray); // Main axis line
+      yAxisGroup.selectAll('line').attr('stroke', COLORS.gray); // Tick marks
+      yAxisGroup.selectAll('text').attr('fill', COLORS.gray); // Labels
   }
 
   private drawExpected(
@@ -91,8 +102,9 @@ export class LineGraphVisualization implements Visualization {
     g.append('path')
       .datum(data)
       .attr('fill', 'none')
-      .attr('stroke', 'red')
-      .attr('stroke-width', 1.5)
+      .attr('stroke',COLORS.green)
+      .attr('stroke-width', 2.4)
+      .attr('stroke-dasharray', '10, 5')
       .attr('d', expectedLine);
 
     g.selectAll('.dot-expected')
@@ -103,7 +115,7 @@ export class LineGraphVisualization implements Visualization {
       .attr('cx', (d) => this.xScale(d.x))
       .attr('cy', (d) => this.yScale(d.expectedValue || 0))
       .attr('r', 3)
-      .attr('fill', 'red');
+      .attr('fill', COLORS.green);
   }
 
   private drawActual(
@@ -118,8 +130,8 @@ export class LineGraphVisualization implements Visualization {
     g.append('path')
       .datum(data)
       .attr('fill', 'none')
-      .attr('stroke', 'blue')
-      .attr('stroke-width', 1.5)
+      .attr('stroke',COLORS.blue)
+      .attr('stroke-width', 2.5)
       .attr('d', actualLine);
 
     g.selectAll('.dot-actual')
@@ -129,8 +141,8 @@ export class LineGraphVisualization implements Visualization {
       .attr('class', 'dot-actual')
       .attr('cx', (d) => this.xScale(d.x))
       .attr('cy', (d) => this.yScale(d.actualValue || 0))
-      .attr('r', 2)
-      .attr('fill', 'blue');
+      .attr('r', 3)
+      .attr('fill',COLORS.blue);
   }
 
   private drawLegend(g: d3.Selection<SVGGElement, unknown, null, undefined>) {
@@ -148,8 +160,8 @@ export class LineGraphVisualization implements Visualization {
       .attr('y1', 0)
       .attr('x2', 20)
       .attr('y2', 0)
-      .attr('stroke', 'blue')
-      .attr('stroke-width', 1.5);
+      .attr('stroke', COLORS.blue)
+      .attr('stroke-width', 2.5);
 
     legend
       .append('text')
@@ -164,8 +176,9 @@ export class LineGraphVisualization implements Visualization {
       .attr('y1', 20)
       .attr('x2', 20)
       .attr('y2', 20)
-      .attr('stroke', 'red')
-      .attr('stroke-width', 1.5);
+      .attr('stroke', COLORS.green)
+      .attr('stroke-dasharray', '8, 3')
+      .attr('stroke-width', 2.5);
 
     legend
       .append('text')
@@ -179,15 +192,24 @@ export class LineGraphVisualization implements Visualization {
     g: d3.Selection<SVGGElement, unknown, null, undefined>,
     data: DataPoint[]
   ) {
-    const markerLine = g
+    const YmarkerLine = g
       .append('line')
-      .attr('class', 'marker-line')
+      .attr('class', 'marker-line vertical')
       .attr('y1', 0)
       .attr('y2', this.chartHeight)
       .attr('stroke', 'lightblue')
       .attr('stroke-width', 1)
       .style('opacity', 0);
 
+    const XmarkerLine = g
+      .append('line')
+      .attr('class', 'marker-line horizontal')
+      .attr('x1', 0)
+      .attr('x2', this.chartWidth)
+      .attr('stroke', 'lightblue')
+      .attr('stroke-width', 1)
+      .style('opacity', 0);
+
     const tooltip = g
       .append('g')
       .attr('class', 'tooltip')
@@ -208,19 +230,23 @@ export class LineGraphVisualization implements Visualization {
       .attr('fill', 'none')
       .attr('pointer-events', 'all')
       .on('mouseover', () => {
-        markerLine.style('opacity', 1);
+        YmarkerLine.style('opacity', 1);
+        XmarkerLine.style('opacity', 1);
         tooltip.style('opacity', 1);
       })
       .on('mouseout', () => {
-        markerLine.style('opacity', 0);
+        YmarkerLine.style('opacity', 0);
+        XmarkerLine.style('opacity', 0);
         tooltip.style('opacity', 0);
       })
       .on('mousemove', (event: MouseEvent) => {
         const xPos = d3.pointer(event, g.node())[0];
+        const yPos = d3.pointer(event, g.node())[1];
+        XmarkerLine.attr('y1', yPos).attr('y2', yPos);
         const dataPoint = this.getDataPointAtX(xPos, data);
         if (dataPoint) {
           const snappedXPos = this.xScale(dataPoint.x);
-          markerLine.attr('x1', snappedXPos).attr('x2', snappedXPos);
+          YmarkerLine.attr('x1', snappedXPos).attr('x2', snappedXPos);
 
           tooltipText
             .text(`Actual: ${dataPoint.actualValue}`)
@@ -278,7 +304,7 @@ export class LineGraphVisualization implements Visualization {
       .attr('y1', -400)
       .attr('x2', xPos)
       .attr('y2', this.chartHeight)
-      .attr('stroke', 'red')
+      .attr('stroke', COLORS.red)
       .attr('stroke-width', 1)
       .attr('stroke-linecap', 'butt')
       .attr('transform', `translate(${this.margin.left},${this.margin.top})`);
diff --git a/tools/motion/motion_test_watcher_app/src/timeline/graph/visualization.ts b/tools/motion/motion_test_watcher_app/src/timeline/graph/visualization.ts
index c6df09378..5cd68fb99 100644
--- a/tools/motion/motion_test_watcher_app/src/timeline/graph/visualization.ts
+++ b/tools/motion/motion_test_watcher_app/src/timeline/graph/visualization.ts
@@ -12,3 +12,10 @@ export interface DataPoint {
   actualValue?: number;
   expectedValue?: number;
 }
+
+export const COLORS = {
+  gray: 'rgb(99, 99, 99)',
+  green: 'rgb(76, 199, 45)',
+  blue: 'rgb(98, 32, 221)',
+  red: 'rgb(240, 88, 88)'
+};
diff --git a/tools/repo_pull/README.md b/tools/repo_pull/README.md
index da3085e2c..bb1091dee 100644
--- a/tools/repo_pull/README.md
+++ b/tools/repo_pull/README.md
@@ -85,6 +85,12 @@ These are common queries:
 * `-m` or `--merge` specifies the method to pick the merge commits.  (default:
   `merge-ff-only`)
 
+* `--merge-args` specifies additional arguments to be passed to the git command
+  specified by `--merge`.
+
+  * For example, `--merge merge --merge-args="-X theirs -q"` maps to
+    `git merge --no-edit -X theirs -q`
+
 * `-p` or `--pick` specifies the method to pick the non-merge commits.
   (default: `pick`)
 
@@ -95,6 +101,12 @@ These are common queries:
   * `reset` maps to `git reset --hard`
   * `checkout` maps to `git checkout`
 
+* `--pick-args` specifies additional arguments to be passed to the git command
+  specified by `--pick`.
+
+  * For example, `--pick pick --pick-args="--empty=drop"` maps to `git
+    cherry-pick --allow-empty --empty=drop`
+
 
 ## Examples
 
diff --git a/tools/repo_pull/repo_pull.py b/tools/repo_pull/repo_pull.py
index d5f1110d9..145e5774f 100755
--- a/tools/repo_pull/repo_pull.py
+++ b/tools/repo_pull/repo_pull.py
@@ -28,6 +28,7 @@ import multiprocessing
 import os
 import os.path
 import re
+import shlex
 import sys
 import xml.dom.minidom
 
@@ -251,7 +252,9 @@ _PICK_COMMANDS = {
 }
 
 
-def build_pull_commands(change, branch_name, merge_opt, pick_opt):
+def build_pull_commands(
+    change, branch_name, merge_opt, merge_args, pick_opt, pick_args
+):
     """Build command lines for each change.  The command lines will be passed
     to subprocess.run()."""
 
@@ -260,9 +263,11 @@ def build_pull_commands(change, branch_name, merge_opt, pick_opt):
         cmds.append(['repo', 'start', branch_name])
     cmds.append(['git', 'fetch', change.fetch_url, change.fetch_ref])
     if change.is_merge():
-        cmds.append(_MERGE_COMMANDS[merge_opt] + ['FETCH_HEAD'])
+        merge_args = shlex.split(merge_args)
+        cmds.append(_MERGE_COMMANDS[merge_opt] + merge_args + ['FETCH_HEAD'])
     else:
-        cmds.append(_PICK_COMMANDS[pick_opt] + ['FETCH_HEAD'])
+        pick_args = shlex.split(pick_args)
+        cmds.append(_PICK_COMMANDS[pick_opt] + pick_args + ['FETCH_HEAD'])
     return cmds
 
 
@@ -295,7 +300,8 @@ def _main_bash(args):
             cmds = []
             cmds.append(['pushd', project_dir])
             cmds.extend(build_pull_commands(
-                change, branch_name, args.merge, args.pick))
+                change, branch_name, args.merge, args.merge_args, args.pick,
+                args.pick_args))
             cmds.append(['popd'])
             print(_sh_quote_commands(cmds))
     print(_sh_quote_command(['popd']))
@@ -307,7 +313,9 @@ def _do_pull_change_lists_for_project(task, ignore_unknown_changes):
 
     branch_name = task_opts['branch_name']
     merge_opt = task_opts['merge_opt']
+    merge_args = task_opts['merge_args']
     pick_opt = task_opts['pick_opt']
+    pick_args = task_opts['pick_args']
     project_dirs = task_opts['project_dirs']
     repo_top = task_opts['repo_top']
 
@@ -323,7 +331,8 @@ def _do_pull_change_lists_for_project(task, ignore_unknown_changes):
             return (change, changes[i + 1:], [], err_msg)
 
         print(change.commit_sha1[0:10], i + 1, cwd)
-        cmds = build_pull_commands(change, branch_name, merge_opt, pick_opt)
+        cmds = build_pull_commands(change, branch_name, merge_opt, merge_args,
+                                   pick_opt, pick_args)
         for cmd in cmds:
             proc = run(cmd, cwd=os.path.join(repo_top, cwd), stderr=PIPE)
             if proc.returncode != 0:
@@ -364,7 +373,9 @@ def _main_pull(args):
     task_opts = {
         'branch_name': branch_name,
         'merge_opt': args.merge,
+        'merge_args': args.merge_args,
         'pick_opt': args.pick,
+        'pick_args': args.pick_args,
         'project_dirs': project_dirs,
         'repo_top': repo_top,
     }
@@ -403,11 +414,17 @@ def _parse_args():
                         default='merge-ff-only',
                         help='Method to pull merge commits')
 
+    parser.add_argument('--merge-args', default='', type=str,
+                        help='Additional arguments for merge')
+
     parser.add_argument('-p', '--pick',
                         choices=sorted(_PICK_COMMANDS.keys()),
                         default='pick',
                         help='Method to pull merge commits')
 
+    parser.add_argument('--pick-args', default='', type=str,
+                        help='Additional arguments for pick')
+
     parser.add_argument('-b', '--branch',
                         help='Local branch name for `repo start`')
 
diff --git a/tools/winscope/karma.config.common.js b/tools/winscope/karma.config.common.js
index ab04cff8c..135cc3042 100644
--- a/tools/winscope/karma.config.common.js
+++ b/tools/winscope/karma.config.common.js
@@ -40,6 +40,12 @@ module.exports = (config) => {
         included: false,
         served: true,
       },
+      {
+        pattern:
+          'deps_build/trace_processor/to_be_served/trace_processor_memory64.wasm',
+        included: false,
+        served: true,
+      },
     ],
     reporters: ['progress'],
     preprocessors: {
diff --git a/tools/winscope/package-lock.json b/tools/winscope/package-lock.json
index fc619b6da..2c8c0f918 100644
--- a/tools/winscope/package-lock.json
+++ b/tools/winscope/package-lock.json
@@ -981,12 +981,13 @@
       }
     },
     "node_modules/@babel/code-frame": {
-      "version": "7.24.2",
-      "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.24.2.tgz",
-      "integrity": "sha512-y5+tLQyV8pg3fsiln67BVLD1P13Eg4lh5RW9mF0zUuvLrv9uIQ4MCL+CRT+FTsBlBjcIan6PGsLcBN0m3ClUyQ==",
+      "version": "7.26.2",
+      "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.26.2.tgz",
+      "integrity": "sha512-RJlIHRueQgwWitWgF8OdFYGZX328Ax5BCemNGlqHfplnRT9ESi8JkFlvaVYbS+UubVY6dpv87Fs2u5M29iNFVQ==",
       "dev": true,
       "dependencies": {
-        "@babel/highlight": "^7.24.2",
+        "@babel/helper-validator-identifier": "^7.25.9",
+        "js-tokens": "^4.0.0",
         "picocolors": "^1.0.0"
       },
       "engines": {
@@ -1400,18 +1401,18 @@
       }
     },
     "node_modules/@babel/helper-string-parser": {
-      "version": "7.24.1",
-      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.24.1.tgz",
-      "integrity": "sha512-2ofRCjnnA9y+wk8b9IAREroeUP02KHp431N2mhKniy2yKIDKpbrHv9eXwm8cBeWQYcJmzv5qKCu65P47eCF7CQ==",
+      "version": "7.25.9",
+      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.25.9.tgz",
+      "integrity": "sha512-4A/SCr/2KLd5jrtOMFzaKjVtAei3+2r/NChoBNoZ3EyP/+GlhoaEGoWOZUmFmoITP7zOJyHIMm+DYRd8o3PvHA==",
       "dev": true,
       "engines": {
         "node": ">=6.9.0"
       }
     },
     "node_modules/@babel/helper-validator-identifier": {
-      "version": "7.24.5",
-      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.24.5.tgz",
-      "integrity": "sha512-3q93SSKX2TWCG30M2G2kwaKeTYgEUp5Snjuj8qm729SObL6nbtUldAi37qbxkD5gg3xnBio+f9nqpSepGZMvxA==",
+      "version": "7.25.9",
+      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.25.9.tgz",
+      "integrity": "sha512-Ed61U6XJc3CVRfkERJWDz4dJwKe7iLmmJsbOGu9wSloNSFttHV0I8g6UAgb7qnK5ly5bGLPd4oXZlxCdANBOWQ==",
       "dev": true,
       "engines": {
         "node": ">=6.9.0"
@@ -1442,53 +1443,40 @@
       }
     },
     "node_modules/@babel/helpers": {
-      "version": "7.20.7",
-      "resolved": "https://registry.npmjs.org/@babel/helpers/-/helpers-7.20.7.tgz",
-      "integrity": "sha512-PBPjs5BppzsGaxHQCDKnZ6Gd9s6xl8bBCluz3vEInLGRJmnZan4F6BYCeqtyXqkk4W5IlPmjK4JlOuZkpJ3xZA==",
+      "version": "7.27.0",
+      "resolved": "https://registry.npmjs.org/@babel/helpers/-/helpers-7.27.0.tgz",
+      "integrity": "sha512-U5eyP/CTFPuNE3qk+WZMxFkp/4zUzdceQlfzf7DdGdhp+Fezd7HD+i8Y24ZuTMKX3wQBld449jijbGq6OdGNQg==",
       "dev": true,
       "dependencies": {
-        "@babel/template": "^7.20.7",
-        "@babel/traverse": "^7.20.7",
-        "@babel/types": "^7.20.7"
+        "@babel/template": "^7.27.0",
+        "@babel/types": "^7.27.0"
       },
       "engines": {
         "node": ">=6.9.0"
       }
     },
     "node_modules/@babel/helpers/node_modules/@babel/template": {
-      "version": "7.20.7",
-      "resolved": "https://registry.npmjs.org/@babel/template/-/template-7.20.7.tgz",
-      "integrity": "sha512-8SegXApWe6VoNw0r9JHpSteLKTpTiLZ4rMlGIm9JQ18KiCtyQiAMEazujAHrUS5flrcqYZa75ukev3P6QmUwUw==",
+      "version": "7.27.0",
+      "resolved": "https://registry.npmjs.org/@babel/template/-/template-7.27.0.tgz",
+      "integrity": "sha512-2ncevenBqXI6qRMukPlXwHKHchC7RyMuu4xv5JBXRfOGVcTy1mXCD12qrp7Jsoxll1EV3+9sE4GugBVRjT2jFA==",
       "dev": true,
       "dependencies": {
-        "@babel/code-frame": "^7.18.6",
-        "@babel/parser": "^7.20.7",
-        "@babel/types": "^7.20.7"
+        "@babel/code-frame": "^7.26.2",
+        "@babel/parser": "^7.27.0",
+        "@babel/types": "^7.27.0"
       },
       "engines": {
         "node": ">=6.9.0"
       }
     },
-    "node_modules/@babel/highlight": {
-      "version": "7.24.5",
-      "resolved": "https://registry.npmjs.org/@babel/highlight/-/highlight-7.24.5.tgz",
-      "integrity": "sha512-8lLmua6AVh/8SLJRRVD6V8p73Hir9w5mJrhE+IPpILG31KKlI9iz5zmBYKcWPS59qSfgP9RaSBQSHHE81WKuEw==",
+    "node_modules/@babel/parser": {
+      "version": "7.27.0",
+      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.27.0.tgz",
+      "integrity": "sha512-iaepho73/2Pz7w2eMS0Q5f83+0RKI7i4xmiYeBmDzfRVbQtTOG7Ts0S4HzJVsTMGI9keU8rNfuZr8DKfSt7Yyg==",
       "dev": true,
       "dependencies": {
-        "@babel/helper-validator-identifier": "^7.24.5",
-        "chalk": "^2.4.2",
-        "js-tokens": "^4.0.0",
-        "picocolors": "^1.0.0"
+        "@babel/types": "^7.27.0"
       },
-      "engines": {
-        "node": ">=6.9.0"
-      }
-    },
-    "node_modules/@babel/parser": {
-      "version": "7.24.5",
-      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.24.5.tgz",
-      "integrity": "sha512-EOv5IK8arwh3LI47dz1b0tKUb/1uhHAnHJOrjgtQMIpu1uXd9mlFrJg9IUgGUgZ41Ch0K8REPTYpO7B76b4vJg==",
-      "dev": true,
       "bin": {
         "parser": "bin/babel-parser.js"
       },
@@ -2710,14 +2698,13 @@
       }
     },
     "node_modules/@babel/types": {
-      "version": "7.24.5",
-      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.24.5.tgz",
-      "integrity": "sha512-6mQNsaLeXTw0nxYUYu+NSa4Hx4BlF1x1x8/PMFbiR+GBSr+2DkECc69b8hgy2frEodNcvPffeH8YfWd3LI6jhQ==",
+      "version": "7.27.0",
+      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.27.0.tgz",
+      "integrity": "sha512-H45s8fVLYjbhFH62dIJ3WtmJ6RSPt/3DRO0ZcT2SUiYiQyz3BLVb9ADEnLl91m74aQPS3AzzeajZHYOalWe3bg==",
       "dev": true,
       "dependencies": {
-        "@babel/helper-string-parser": "^7.24.1",
-        "@babel/helper-validator-identifier": "^7.24.5",
-        "to-fast-properties": "^2.0.0"
+        "@babel/helper-string-parser": "^7.25.9",
+        "@babel/helper-validator-identifier": "^7.25.9"
       },
       "engines": {
         "node": ">=6.9.0"
@@ -3811,16 +3798,10 @@
         "@types/node": "*"
       }
     },
-    "node_modules/@types/cookie": {
-      "version": "0.4.1",
-      "resolved": "https://registry.npmjs.org/@types/cookie/-/cookie-0.4.1.tgz",
-      "integrity": "sha512-XW/Aa8APYr6jSVVA1y/DEIZX0/GMKLEVekNG727R8cs56ahETkRAy/3DR7+fJyh7oUgGwNQaRfXCun0+KbWY7Q==",
-      "dev": true
-    },
     "node_modules/@types/cors": {
-      "version": "2.8.13",
-      "resolved": "https://registry.npmjs.org/@types/cors/-/cors-2.8.13.tgz",
-      "integrity": "sha512-RG8AStHlUiV5ysZQKq97copd2UmVYw3/pRMLefISZ3S1hK104Cwm7iLQ3fTKx+lsUH2CE8FlLaYeEA2LSeqYUA==",
+      "version": "2.8.17",
+      "resolved": "https://registry.npmjs.org/@types/cors/-/cors-2.8.17.tgz",
+      "integrity": "sha512-8CGDvrBj1zgo2qE+oS3pOCyYNqCPryMWY2bGfwA0dcfopWGgxs+78df0Rs3rc9THP4JkOhLsAa+15VdpAqkcUA==",
       "dev": true,
       "dependencies": {
         "@types/node": "*"
@@ -3842,9 +3823,9 @@
       }
     },
     "node_modules/@types/eslint-scope": {
-      "version": "3.7.4",
-      "resolved": "https://registry.npmjs.org/@types/eslint-scope/-/eslint-scope-3.7.4.tgz",
-      "integrity": "sha512-9K4zoImiZc3HlIp6AVUDE4CWYx22a+lhSZMYNpbjW04+YF0KWj4pJXnEMjdnFTiQibFFmElcsasJXDbdI/EPhA==",
+      "version": "3.7.7",
+      "resolved": "https://registry.npmjs.org/@types/eslint-scope/-/eslint-scope-3.7.7.tgz",
+      "integrity": "sha512-MzMFlSLBqNF2gcHWO0G1vP/YQyfvrxZ0bF+u7mzUdZ1/xK4A4sru+nraZz5i3iEIk1l1uyicaDVTB4QbbEkAYg==",
       "dependencies": {
         "@types/eslint": "*",
         "@types/estree": "*"
@@ -4521,9 +4502,9 @@
       }
     },
     "node_modules/acorn": {
-      "version": "8.10.0",
-      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.10.0.tgz",
-      "integrity": "sha512-F0SAmZ8iUtS//m8DmCTA0jlh6TDKkHQyK6xc6V4KDTyZKA9dnvX9/3sRTVQrWm79glUAZbnmmNcdYwUIHWVybw==",
+      "version": "8.14.1",
+      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.14.1.tgz",
+      "integrity": "sha512-OvQ/2pUDKmgfCg++xsTX1wGxfTaszcHVcTctW4UJB4hibJx2HXxxO5UmVgyjMa+ZDsiaf5wWLXYpRWMmBI0QHg==",
       "bin": {
         "acorn": "bin/acorn"
       },
@@ -4535,6 +4516,7 @@
       "version": "1.9.0",
       "resolved": "https://registry.npmjs.org/acorn-import-assertions/-/acorn-import-assertions-1.9.0.tgz",
       "integrity": "sha512-cmMwop9x+8KFhxvKrKfPYmN6/pKTYYHBqLa0DfvVZcKMJWNyWLnaqND7dx/qn66R7ewM1UX5XMaDVP5wlVTaVA==",
+      "dev": true,
       "peerDependencies": {
         "acorn": "^8"
       }
@@ -4622,7 +4604,6 @@
       "version": "8.11.0",
       "resolved": "https://registry.npmjs.org/ajv/-/ajv-8.11.0.tgz",
       "integrity": "sha512-wGgprdCvMalC0BztXvitD2hC04YffAvtsUn93JbGXYLAtCUO4xd17mCCZQxUOItiBwZvJScWo8NIvQMQ71rdpg==",
-      "dev": true,
       "dependencies": {
         "fast-deep-equal": "^3.1.1",
         "json-schema-traverse": "^1.0.0",
@@ -4638,7 +4619,6 @@
       "version": "2.1.1",
       "resolved": "https://registry.npmjs.org/ajv-formats/-/ajv-formats-2.1.1.tgz",
       "integrity": "sha512-Wx0Kx52hxE7C18hkMEggYlEifqWZtYaRgouJor+WMdPnQyEK13vgEWyVNup7SoeeoLMsr4kf5h6dOW11I15MUA==",
-      "dev": true,
       "dependencies": {
         "ajv": "^8.0.0"
       },
@@ -4655,7 +4635,6 @@
       "version": "5.1.0",
       "resolved": "https://registry.npmjs.org/ajv-keywords/-/ajv-keywords-5.1.0.tgz",
       "integrity": "sha512-YCS/JNFAUyr5vAuhk1DWm1CBxRHW9LbJ2ozWeemrIqpbsqKjHVxYPyi5GC0rjZIT5JxJ3virVTS8wk4i/Z+krw==",
-      "dev": true,
       "dependencies": {
         "fast-deep-equal": "^3.1.3"
       },
@@ -4959,9 +4938,9 @@
       "dev": true
     },
     "node_modules/axios": {
-      "version": "1.6.8",
-      "resolved": "https://registry.npmjs.org/axios/-/axios-1.6.8.tgz",
-      "integrity": "sha512-v/ZHtJDU39mDpyBoFVkETcd/uNdxrWRrg3bKpOKzXFA6Bvqopts6ALSMU3y6ijYxbw2B+wPrIv46egTzJXCLGQ==",
+      "version": "1.8.4",
+      "resolved": "https://registry.npmjs.org/axios/-/axios-1.8.4.tgz",
+      "integrity": "sha512-eBSYY4Y68NNlHbHBMdeDmKNtDgXWhQsJcGqzO3iLUM0GraQFSS9cVgPX5I9b3lbdFKyYoAEGAZF1DwhTaljNAw==",
       "dependencies": {
         "follow-redirects": "^1.15.6",
         "form-data": "^4.0.0",
@@ -5173,9 +5152,9 @@
       "dev": true
     },
     "node_modules/body-parser": {
-      "version": "1.20.2",
-      "resolved": "https://registry.npmjs.org/body-parser/-/body-parser-1.20.2.tgz",
-      "integrity": "sha512-ml9pReCu3M61kGlqoTm2umSXTlRTuGTx0bfYj+uIUKKYycG5NtSbeetV3faSU6R7ajOPw0g/J1PvK4qNy7s5bA==",
+      "version": "1.20.3",
+      "resolved": "https://registry.npmjs.org/body-parser/-/body-parser-1.20.3.tgz",
+      "integrity": "sha512-7rAxByjUMqQ3/bHJy7D6OGXvx/MMc4IqBn/X0fcM1QUcAItpZrBEYhWGem+tzXH90c+G01ypMcYJBO9Y30203g==",
       "dev": true,
       "dependencies": {
         "bytes": "3.1.2",
@@ -5186,7 +5165,7 @@
         "http-errors": "2.0.0",
         "iconv-lite": "0.4.24",
         "on-finished": "2.4.1",
-        "qs": "6.11.0",
+        "qs": "6.13.0",
         "raw-body": "2.5.2",
         "type-is": "~1.6.18",
         "unpipe": "1.0.0"
@@ -5239,11 +5218,11 @@
       }
     },
     "node_modules/braces": {
-      "version": "3.0.2",
-      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.2.tgz",
-      "integrity": "sha512-b8um+L1RzM3WDSzvhm6gIz1yfTbBt6YTlcEKAvsmqCZZFw46z626lVj9j1yEPW33H5H+lBQpZMP1k8l+78Ha0A==",
+      "version": "3.0.3",
+      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.3.tgz",
+      "integrity": "sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==",
       "dependencies": {
-        "fill-range": "^7.0.1"
+        "fill-range": "^7.1.1"
       },
       "engines": {
         "node": ">=8"
@@ -5259,9 +5238,9 @@
       }
     },
     "node_modules/browserslist": {
-      "version": "4.23.0",
-      "resolved": "https://registry.npmjs.org/browserslist/-/browserslist-4.23.0.tgz",
-      "integrity": "sha512-QW8HiM1shhT2GuzkvklfjcKDiWFXHOeFCIA/huJPwHsslwcydgk7X+z2zXpEijP98UCY7HbubZt5J2Zgvf0CaQ==",
+      "version": "4.24.4",
+      "resolved": "https://registry.npmjs.org/browserslist/-/browserslist-4.24.4.tgz",
+      "integrity": "sha512-KDi1Ny1gSePi1vm0q4oxSF8b4DR44GF4BbmS2YdhPLOEqd8pDviZOGH/GsmRwoWJ2+5Lr085X7naowMwKHDG1A==",
       "funding": [
         {
           "type": "opencollective",
@@ -5277,10 +5256,10 @@
         }
       ],
       "dependencies": {
-        "caniuse-lite": "^1.0.30001587",
-        "electron-to-chromium": "^1.4.668",
-        "node-releases": "^2.0.14",
-        "update-browserslist-db": "^1.0.13"
+        "caniuse-lite": "^1.0.30001688",
+        "electron-to-chromium": "^1.5.73",
+        "node-releases": "^2.0.19",
+        "update-browserslist-db": "^1.1.1"
       },
       "bin": {
         "browserslist": "cli.js"
@@ -5431,13 +5410,28 @@
         "node": ">=12"
       }
     },
-    "node_modules/call-bind": {
+    "node_modules/call-bind-apply-helpers": {
       "version": "1.0.2",
-      "resolved": "https://registry.npmjs.org/call-bind/-/call-bind-1.0.2.tgz",
-      "integrity": "sha512-7O+FbCihrB5WGbFYesctwmTKae6rOiIzmz1icreWJ+0aA7LJfuqhEso2T9ncpcFtzMQtzXf2QGGueWJGTYsqrA==",
+      "resolved": "https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz",
+      "integrity": "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==",
+      "dependencies": {
+        "es-errors": "^1.3.0",
+        "function-bind": "^1.1.2"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      }
+    },
+    "node_modules/call-bound": {
+      "version": "1.0.4",
+      "resolved": "https://registry.npmjs.org/call-bound/-/call-bound-1.0.4.tgz",
+      "integrity": "sha512-+ys997U96po4Kx/ABpBCqhA9EuxJaQWDQg7295H4hBphv3IZg0boBKuwYpt4YXp6MZ5AmZQnU/tyMTlRpaSejg==",
       "dependencies": {
-        "function-bind": "^1.1.1",
-        "get-intrinsic": "^1.0.2"
+        "call-bind-apply-helpers": "^1.0.2",
+        "get-intrinsic": "^1.3.0"
+      },
+      "engines": {
+        "node": ">= 0.4"
       },
       "funding": {
         "url": "https://github.com/sponsors/ljharb"
@@ -5471,9 +5465,9 @@
       }
     },
     "node_modules/caniuse-lite": {
-      "version": "1.0.30001618",
-      "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001618.tgz",
-      "integrity": "sha512-p407+D1tIkDvsEAPS22lJxLQQaG8OTBEqo0KhzfABGk0TU4juBNDSfH0hyAp/HRyx+M8L17z/ltyhxh27FTfQg==",
+      "version": "1.0.30001715",
+      "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001715.tgz",
+      "integrity": "sha512-7ptkFGMm2OAOgvZpwgA4yjQ5SQbrNVGdRjzH0pBdy1Fasvcr+KAeECmbCAECzTuDuoX0FCY8KzUxjf9+9kfZEw==",
       "funding": [
         {
           "type": "opencollective",
@@ -5934,9 +5928,9 @@
       "dev": true
     },
     "node_modules/cookie": {
-      "version": "0.4.2",
-      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.4.2.tgz",
-      "integrity": "sha512-aSWTXFzaKWkvHO1Ny/s+ePFpvKsPnjc551iI41v3ny/ow6tBG5Vd+FuqGNhh1LxOmVzOlGUriIlOaokOvhaStA==",
+      "version": "0.7.2",
+      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.7.2.tgz",
+      "integrity": "sha512-yki5XnKuf750l50uGTllt6kKILY4nQ1eNIQatoXEByZ5dWgnKqbnqmTrBE5B4N7lrMJKQ2ytWMiTO2o0v6Ew/w==",
       "dev": true,
       "engines": {
         "node": ">= 0.6"
@@ -6200,9 +6194,9 @@
       }
     },
     "node_modules/cross-spawn": {
-      "version": "7.0.3",
-      "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.3.tgz",
-      "integrity": "sha512-iRDPJKUPVEND7dHPO8rkbOnPpyDygcDFtWjpeWNCgy8WP2rXcxXL8TskReQl6OrB2G7+UJrags1q15Fudc7G6w==",
+      "version": "7.0.6",
+      "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.6.tgz",
+      "integrity": "sha512-uV2QOWP2nWzsy2aMp8aRibhi9dlzF5Hgh5SHaB9OiTGEyDTiJJyx0uy51QXdyWbtAHNua4XJzUKca3OzKUd3vA==",
       "dependencies": {
         "path-key": "^3.1.0",
         "shebang-command": "^2.0.0",
@@ -6995,6 +6989,19 @@
         "tslib": "^2.0.3"
       }
     },
+    "node_modules/dunder-proto": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz",
+      "integrity": "sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==",
+      "dependencies": {
+        "call-bind-apply-helpers": "^1.0.1",
+        "es-errors": "^1.3.0",
+        "gopd": "^1.2.0"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      }
+    },
     "node_modules/ecc-jsbn": {
       "version": "0.1.2",
       "resolved": "https://registry.npmjs.org/ecc-jsbn/-/ecc-jsbn-0.1.2.tgz",
@@ -7026,9 +7033,9 @@
       "dev": true
     },
     "node_modules/electron-to-chromium": {
-      "version": "1.4.767",
-      "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.4.767.tgz",
-      "integrity": "sha512-nzzHfmQqBss7CE3apQHkHjXW77+8w3ubGCIoEijKCJebPufREaFETgGXWTkh32t259F3Kcq+R8MZdFdOJROgYw=="
+      "version": "1.5.141",
+      "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.5.141.tgz",
+      "integrity": "sha512-qS+qH9oqVYc1ooubTiB9l904WVyM6qNYxtOEEGReoZXw3xlqeYdFr5GclNzbkAufWgwWLEPoDi3d9MoRwwIjGw=="
     },
     "node_modules/emoji-regex": {
       "version": "8.0.0",
@@ -7078,39 +7085,38 @@
       }
     },
     "node_modules/engine.io": {
-      "version": "6.5.1",
-      "resolved": "https://registry.npmjs.org/engine.io/-/engine.io-6.5.1.tgz",
-      "integrity": "sha512-mGqhI+D7YxS9KJMppR6Iuo37Ed3abhU8NdfgSvJSDUafQutrN+sPTncJYTyM9+tkhSmWodKtVYGPPHyXJEwEQA==",
+      "version": "6.6.4",
+      "resolved": "https://registry.npmjs.org/engine.io/-/engine.io-6.6.4.tgz",
+      "integrity": "sha512-ZCkIjSYNDyGn0R6ewHDtXgns/Zre/NT6Agvq1/WobF7JXgFff4SeDroKiCO3fNJreU9YG429Sc81o4w5ok/W5g==",
       "dev": true,
       "dependencies": {
-        "@types/cookie": "^0.4.1",
         "@types/cors": "^2.8.12",
         "@types/node": ">=10.0.0",
         "accepts": "~1.3.4",
         "base64id": "2.0.0",
-        "cookie": "~0.4.1",
+        "cookie": "~0.7.2",
         "cors": "~2.8.5",
         "debug": "~4.3.1",
-        "engine.io-parser": "~5.1.0",
-        "ws": "~8.11.0"
+        "engine.io-parser": "~5.2.1",
+        "ws": "~8.17.1"
       },
       "engines": {
-        "node": ">=10.0.0"
+        "node": ">=10.2.0"
       }
     },
     "node_modules/engine.io-parser": {
-      "version": "5.1.0",
-      "resolved": "https://registry.npmjs.org/engine.io-parser/-/engine.io-parser-5.1.0.tgz",
-      "integrity": "sha512-enySgNiK5tyZFynt3z7iqBR+Bto9EVVVvDFuTT0ioHCGbzirZVGDGiQjZzEp8hWl6hd5FSVytJGuScX1C1C35w==",
+      "version": "5.2.3",
+      "resolved": "https://registry.npmjs.org/engine.io-parser/-/engine.io-parser-5.2.3.tgz",
+      "integrity": "sha512-HqD3yTBfnBxIrbnM1DoD6Pcq8NECnh8d4As1Qgh0z5Gg3jRRIqijury0CL3ghu/edArpUYiYqQiDUQBIs4np3Q==",
       "dev": true,
       "engines": {
         "node": ">=10.0.0"
       }
     },
     "node_modules/enhanced-resolve": {
-      "version": "5.16.1",
-      "resolved": "https://registry.npmjs.org/enhanced-resolve/-/enhanced-resolve-5.16.1.tgz",
-      "integrity": "sha512-4U5pNsuDl0EhuZpq46M5xPslstkviJuhrdobaRDBk2Jy2KO37FDAJl4lb2KlNabxT0m4MTK2UHNrsAcphE8nyw==",
+      "version": "5.18.1",
+      "resolved": "https://registry.npmjs.org/enhanced-resolve/-/enhanced-resolve-5.18.1.tgz",
+      "integrity": "sha512-ZSW3ma5GkcQBIpwZTSRAI8N71Uuwgs93IezB7mf7R60tC8ZbJideoDNKjHn2O9KIlx6rkGTTEk1xUCK2E1Y2Yg==",
       "dependencies": {
         "graceful-fs": "^4.2.4",
         "tapable": "^2.2.0"
@@ -7187,12 +7193,39 @@
       "resolved": "https://registry.npmjs.org/es-cookie/-/es-cookie-1.3.2.tgz",
       "integrity": "sha512-UTlYYhXGLOy05P/vKVT2Ui7WtC7NiRzGtJyAKKn32g5Gvcjn7KAClLPWlipCtxIus934dFg9o9jXiBL0nP+t9Q=="
     },
+    "node_modules/es-define-property": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.1.tgz",
+      "integrity": "sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==",
+      "engines": {
+        "node": ">= 0.4"
+      }
+    },
+    "node_modules/es-errors": {
+      "version": "1.3.0",
+      "resolved": "https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz",
+      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==",
+      "engines": {
+        "node": ">= 0.4"
+      }
+    },
     "node_modules/es-module-lexer": {
       "version": "0.9.3",
       "resolved": "https://registry.npmjs.org/es-module-lexer/-/es-module-lexer-0.9.3.tgz",
       "integrity": "sha512-1HQ2M2sPtxwnvOvT1ZClHyQDiggdNjURWpY2we6aMKCQiUVxTmVs2UYPLIrD84sS+kMdUwfBSylbJPwNnBrnHQ==",
       "dev": true
     },
+    "node_modules/es-object-atoms": {
+      "version": "1.1.1",
+      "resolved": "https://registry.npmjs.org/es-object-atoms/-/es-object-atoms-1.1.1.tgz",
+      "integrity": "sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==",
+      "dependencies": {
+        "es-errors": "^1.3.0"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      }
+    },
     "node_modules/es6-promise": {
       "version": "4.2.8",
       "resolved": "https://registry.npmjs.org/es6-promise/-/es6-promise-4.2.8.tgz",
@@ -7578,9 +7611,9 @@
       }
     },
     "node_modules/escalade": {
-      "version": "3.1.2",
-      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.1.2.tgz",
-      "integrity": "sha512-ErCHMCae19vR8vQGe50xIsVomy19rg6gFu3+r3jkEO46suLMWBksvVyoGgQV+jOfl84ZSOSlmv6Gxa89PmTGmA==",
+      "version": "3.2.0",
+      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.2.0.tgz",
+      "integrity": "sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA==",
       "engines": {
         "node": ">=6"
       }
@@ -8244,37 +8277,37 @@
       }
     },
     "node_modules/express": {
-      "version": "4.19.2",
-      "resolved": "https://registry.npmjs.org/express/-/express-4.19.2.tgz",
-      "integrity": "sha512-5T6nhjsT+EOMzuck8JjBHARTHfMht0POzlA60WV2pMD3gyXw2LZnZ+ueGdNxG+0calOJcWKbpFcuzLZ91YWq9Q==",
+      "version": "4.21.2",
+      "resolved": "https://registry.npmjs.org/express/-/express-4.21.2.tgz",
+      "integrity": "sha512-28HqgMZAmih1Czt9ny7qr6ek2qddF4FclbMzwhCREB6OFfH+rXAnuNCwo1/wFvrtbgsQDb4kSbX9de9lFbrXnA==",
       "dev": true,
       "dependencies": {
         "accepts": "~1.3.8",
         "array-flatten": "1.1.1",
-        "body-parser": "1.20.2",
+        "body-parser": "1.20.3",
         "content-disposition": "0.5.4",
         "content-type": "~1.0.4",
-        "cookie": "0.6.0",
+        "cookie": "0.7.1",
         "cookie-signature": "1.0.6",
         "debug": "2.6.9",
         "depd": "2.0.0",
-        "encodeurl": "~1.0.2",
+        "encodeurl": "~2.0.0",
         "escape-html": "~1.0.3",
         "etag": "~1.8.1",
-        "finalhandler": "1.2.0",
+        "finalhandler": "1.3.1",
         "fresh": "0.5.2",
         "http-errors": "2.0.0",
-        "merge-descriptors": "1.0.1",
+        "merge-descriptors": "1.0.3",
         "methods": "~1.1.2",
         "on-finished": "2.4.1",
         "parseurl": "~1.3.3",
-        "path-to-regexp": "0.1.7",
+        "path-to-regexp": "0.1.12",
         "proxy-addr": "~2.0.7",
-        "qs": "6.11.0",
+        "qs": "6.13.0",
         "range-parser": "~1.2.1",
         "safe-buffer": "5.2.1",
-        "send": "0.18.0",
-        "serve-static": "1.15.0",
+        "send": "0.19.0",
+        "serve-static": "1.16.2",
         "setprototypeof": "1.2.0",
         "statuses": "2.0.1",
         "type-is": "~1.6.18",
@@ -8283,6 +8316,10 @@
       },
       "engines": {
         "node": ">= 0.10.0"
+      },
+      "funding": {
+        "type": "opencollective",
+        "url": "https://opencollective.com/express"
       }
     },
     "node_modules/express/node_modules/array-flatten": {
@@ -8292,9 +8329,9 @@
       "dev": true
     },
     "node_modules/express/node_modules/cookie": {
-      "version": "0.6.0",
-      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.6.0.tgz",
-      "integrity": "sha512-U71cyTamuh1CRNCfpGY6to28lxvNwPG4Guz/EVjgf3Jmzv0vlDp1atT9eS5dDjMYHucpHbWns6Lwf3BKz6svdw==",
+      "version": "0.7.1",
+      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.7.1.tgz",
+      "integrity": "sha512-6DnInpx7SJ2AK3+CTUE/ZM0vWTUboZCegxhC2xiIydHR9jNuTAASBrfEpHhiGOZw/nX51bHt6YQl8jsGo4y/0w==",
       "dev": true,
       "engines": {
         "node": ">= 0.6"
@@ -8309,14 +8346,23 @@
         "ms": "2.0.0"
       }
     },
+    "node_modules/express/node_modules/encodeurl": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz",
+      "integrity": "sha512-Q0n9HRi4m6JuGIV1eFlmvJB7ZEVxu93IrMyiMsGC0lrMJMWzRgx6WGquyfQgZVb31vhGgXnfmPNNXmxnOkRBrg==",
+      "dev": true,
+      "engines": {
+        "node": ">= 0.8"
+      }
+    },
     "node_modules/express/node_modules/finalhandler": {
-      "version": "1.2.0",
-      "resolved": "https://registry.npmjs.org/finalhandler/-/finalhandler-1.2.0.tgz",
-      "integrity": "sha512-5uXcUVftlQMFnWC9qu/svkWv3GTd2PfUhK/3PLkYNAe7FbqJMt3515HaxE6eRL74GdsriiwujiawdaB1BpEISg==",
+      "version": "1.3.1",
+      "resolved": "https://registry.npmjs.org/finalhandler/-/finalhandler-1.3.1.tgz",
+      "integrity": "sha512-6BN9trH7bp3qvnrRyzsBz+g3lZxTNZTbVO2EV1CS0WIcDbawYVdYvGflME/9QP0h0pYlCDBCTjYa9nZzMDpyxQ==",
       "dev": true,
       "dependencies": {
         "debug": "2.6.9",
-        "encodeurl": "~1.0.2",
+        "encodeurl": "~2.0.0",
         "escape-html": "~1.0.3",
         "on-finished": "2.4.1",
         "parseurl": "~1.3.3",
@@ -8401,7 +8447,8 @@
     "node_modules/fast-json-stable-stringify": {
       "version": "2.1.0",
       "resolved": "https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz",
-      "integrity": "sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw=="
+      "integrity": "sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==",
+      "dev": true
     },
     "node_modules/fast-levenshtein": {
       "version": "2.0.6",
@@ -8522,9 +8569,9 @@
       }
     },
     "node_modules/fill-range": {
-      "version": "7.0.1",
-      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.0.1.tgz",
-      "integrity": "sha512-qOo9F+dMUmC2Lcb4BbVvnKJxTPjCm+RRpe4gDuGrzkL7mEVl/djYSu2OdQ2Pa302N4oqkSg9ir6jaLWJ2USVpQ==",
+      "version": "7.1.1",
+      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.1.1.tgz",
+      "integrity": "sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==",
       "dependencies": {
         "to-regex-range": "^5.0.1"
       },
@@ -8766,9 +8813,12 @@
       }
     },
     "node_modules/function-bind": {
-      "version": "1.1.1",
-      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.1.tgz",
-      "integrity": "sha512-yIovAzMX49sF8Yl58fSCWJ5svSLuaibPxXQJFLmBObTuCr0Mf1KiPopGM9NiFjiYBCbfaa2Fh6breQ6ANVTI0A=="
+      "version": "1.1.2",
+      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
+      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
     },
     "node_modules/gauge": {
       "version": "4.0.4",
@@ -8821,13 +8871,23 @@
       }
     },
     "node_modules/get-intrinsic": {
-      "version": "1.1.3",
-      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.1.3.tgz",
-      "integrity": "sha512-QJVz1Tj7MS099PevUG5jvnt9tSkXN8K14dxQlikJuPt4uD9hHAHjLyLBiLR5zELelBdD9QNRAXZzsJx0WaDL9A==",
+      "version": "1.3.0",
+      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.3.0.tgz",
+      "integrity": "sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==",
       "dependencies": {
-        "function-bind": "^1.1.1",
-        "has": "^1.0.3",
-        "has-symbols": "^1.0.3"
+        "call-bind-apply-helpers": "^1.0.2",
+        "es-define-property": "^1.0.1",
+        "es-errors": "^1.3.0",
+        "es-object-atoms": "^1.1.1",
+        "function-bind": "^1.1.2",
+        "get-proto": "^1.0.1",
+        "gopd": "^1.2.0",
+        "has-symbols": "^1.1.0",
+        "hasown": "^2.0.2",
+        "math-intrinsics": "^1.1.0"
+      },
+      "engines": {
+        "node": ">= 0.4"
       },
       "funding": {
         "url": "https://github.com/sponsors/ljharb"
@@ -8848,6 +8908,18 @@
         "node": ">=8.0.0"
       }
     },
+    "node_modules/get-proto": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/get-proto/-/get-proto-1.0.1.tgz",
+      "integrity": "sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==",
+      "dependencies": {
+        "dunder-proto": "^1.0.1",
+        "es-object-atoms": "^1.0.0"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      }
+    },
     "node_modules/get-stream": {
       "version": "6.0.1",
       "resolved": "https://registry.npmjs.org/get-stream/-/get-stream-6.0.1.tgz",
@@ -8954,6 +9026,17 @@
         "node": ">=0.6.0"
       }
     },
+    "node_modules/gopd": {
+      "version": "1.2.0",
+      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.2.0.tgz",
+      "integrity": "sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==",
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
     "node_modules/graceful-fs": {
       "version": "4.2.11",
       "resolved": "https://registry.npmjs.org/graceful-fs/-/graceful-fs-4.2.11.tgz",
@@ -9070,9 +9153,9 @@
       }
     },
     "node_modules/has-symbols": {
-      "version": "1.0.3",
-      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.0.3.tgz",
-      "integrity": "sha512-l3LCuF6MgDNwTDKkdYGEihYjt5pRPbEg46rtlmnSPlUbgmB8LOIrKJbYYFBSbnPaJexMKtiPO8hmeRjRz2Td+A==",
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.1.0.tgz",
+      "integrity": "sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==",
       "engines": {
         "node": ">= 0.4"
       },
@@ -9086,6 +9169,17 @@
       "integrity": "sha512-8Rf9Y83NBReMnx0gFzA8JImQACstCYWUplepDa9xprwwtmgEZUF0h/i5xSA625zB/I37EtrswSST6OXxwaaIJQ==",
       "dev": true
     },
+    "node_modules/hasown": {
+      "version": "2.0.2",
+      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
+      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
+      "dependencies": {
+        "function-bind": "^1.1.2"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      }
+    },
     "node_modules/hdr-histogram-js": {
       "version": "2.0.3",
       "resolved": "https://registry.npmjs.org/hdr-histogram-js/-/hdr-histogram-js-2.0.3.tgz",
@@ -9376,9 +9470,9 @@
       }
     },
     "node_modules/http-proxy-middleware": {
-      "version": "2.0.6",
-      "resolved": "https://registry.npmjs.org/http-proxy-middleware/-/http-proxy-middleware-2.0.6.tgz",
-      "integrity": "sha512-ya/UeJ6HVBYxrgYotAZo1KvPWlgB48kUJLDePFeneHsVujFaW5WNj2NgWCAE//B1Dl02BIfYlpNgBy8Kf8Rjmw==",
+      "version": "2.0.9",
+      "resolved": "https://registry.npmjs.org/http-proxy-middleware/-/http-proxy-middleware-2.0.9.tgz",
+      "integrity": "sha512-c1IyJYLYppU574+YI7R4QyX2ystMtVXZwIdzazUIPIJsHuWNd+mho2j+bKoHftndicGj9yh+xjd+l0yj7VeT1Q==",
       "dev": true,
       "dependencies": {
         "@types/http-proxy": "^1.17.8",
@@ -9736,10 +9830,23 @@
         "node": ">= 0.10"
       }
     },
-    "node_modules/ip": {
-      "version": "2.0.1",
-      "resolved": "https://registry.npmjs.org/ip/-/ip-2.0.1.tgz",
-      "integrity": "sha512-lJUL9imLTNi1ZfXT+DU6rBBdbiKGBuay9B6xGSPVjUeQwaH1RIGqef8RZkUtHioLmSNpPR5M4HVKJGm1j8FWVQ==",
+    "node_modules/ip-address": {
+      "version": "9.0.5",
+      "resolved": "https://registry.npmjs.org/ip-address/-/ip-address-9.0.5.tgz",
+      "integrity": "sha512-zHtQzGojZXTwZTHQqra+ETKd4Sn3vgi7uBmlPoXVWZqYvuKmtI0l/VZTjqGmJY9x88GGOaZ9+G9ES8hC4T4X8g==",
+      "dev": true,
+      "dependencies": {
+        "jsbn": "1.1.0",
+        "sprintf-js": "^1.1.3"
+      },
+      "engines": {
+        "node": ">= 12"
+      }
+    },
+    "node_modules/ip-address/node_modules/sprintf-js": {
+      "version": "1.1.3",
+      "resolved": "https://registry.npmjs.org/sprintf-js/-/sprintf-js-1.1.3.tgz",
+      "integrity": "sha512-Oo+0REFV59/rz3gfJNKQiBlwfHaSESl1pcGyABQsnnIfWOFt6JNj5gCog2U6MLZ//IGYD+nA8nI+mTShREReaA==",
       "dev": true
     },
     "node_modules/ipaddr.js": {
@@ -10401,8 +10508,7 @@
     "node_modules/json-schema-traverse": {
       "version": "1.0.0",
       "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-1.0.0.tgz",
-      "integrity": "sha512-NM8/P9n3XjXhIZn1lLhkFaACTOURQXjWhV4BA/RnOv8xvgqtqpAX9IO4mRQxSx1Rlo4tqzeqb0sOlruaOy3dug==",
-      "dev": true
+      "integrity": "sha512-NM8/P9n3XjXhIZn1lLhkFaACTOURQXjWhV4BA/RnOv8xvgqtqpAX9IO4mRQxSx1Rlo4tqzeqb0sOlruaOy3dug=="
     },
     "node_modules/json-stable-stringify-without-jsonify": {
       "version": "1.0.1",
@@ -11767,6 +11873,14 @@
         "node": ">= 12"
       }
     },
+    "node_modules/math-intrinsics": {
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
+      "integrity": "sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==",
+      "engines": {
+        "node": ">= 0.4"
+      }
+    },
     "node_modules/mdurl": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/mdurl/-/mdurl-1.0.1.tgz",
@@ -11795,10 +11909,13 @@
       }
     },
     "node_modules/merge-descriptors": {
-      "version": "1.0.1",
-      "resolved": "https://registry.npmjs.org/merge-descriptors/-/merge-descriptors-1.0.1.tgz",
-      "integrity": "sha512-cCi6g3/Zr1iqQi6ySbseM1Xvooa98N0w31jzUYrXPX2xqObmFGHJ0tQ5u74H3mVh7wLouTseZyYIq39g8cNp1w==",
-      "dev": true
+      "version": "1.0.3",
+      "resolved": "https://registry.npmjs.org/merge-descriptors/-/merge-descriptors-1.0.3.tgz",
+      "integrity": "sha512-gaNvAS7TZ897/rVaZ0nMtAyxNyi/pdbjbAwUpFQpN70GqnVfOiXpeUUMKRBmzXaSQ8DdTX4/0ms62r2K+hE6mQ==",
+      "dev": true,
+      "funding": {
+        "url": "https://github.com/sponsors/sindresorhus"
+      }
     },
     "node_modules/merge-stream": {
       "version": "2.0.0",
@@ -11823,11 +11940,11 @@
       }
     },
     "node_modules/micromatch": {
-      "version": "4.0.5",
-      "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-4.0.5.tgz",
-      "integrity": "sha512-DMy+ERcEW2q8Z2Po+WNXuw3c5YaUSFjAO5GsJqfEl7UjvtIuFKO6ZrKvcItdy98dwFI2N1tg3zNIdKaQT+aNdA==",
+      "version": "4.0.8",
+      "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-4.0.8.tgz",
+      "integrity": "sha512-PXwfBhYu0hBCPw8Dn0E+WDYb7af3dSLVWKi3HGv84IdF4TyFoC0ysxFd0Goxw7nSv4T/PzEJQxsYsEiFCKo2BA==",
       "dependencies": {
-        "braces": "^3.0.2",
+        "braces": "^3.0.3",
         "picomatch": "^2.3.1"
       },
       "engines": {
@@ -12176,10 +12293,16 @@
       "dev": true
     },
     "node_modules/nanoid": {
-      "version": "3.3.4",
-      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.4.tgz",
-      "integrity": "sha512-MqBkQh/OHTS2egovRtLk45wEyNXwF+cokD+1YPf9u5VfJiRdAiRwB2froX5Co9Rh20xs4siNPm8naNotSD6RBw==",
+      "version": "3.3.11",
+      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.11.tgz",
+      "integrity": "sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==",
       "dev": true,
+      "funding": [
+        {
+          "type": "github",
+          "url": "https://github.com/sponsors/ai"
+        }
+      ],
       "bin": {
         "nanoid": "bin/nanoid.cjs"
       },
@@ -12373,9 +12496,9 @@
       }
     },
     "node_modules/node-releases": {
-      "version": "2.0.14",
-      "resolved": "https://registry.npmjs.org/node-releases/-/node-releases-2.0.14.tgz",
-      "integrity": "sha512-y10wOWt8yZpqXmOgRo77WaHEmhYQYGNA6y421PKsKYWEK8aW+cqAphborZDhqfyKrbZEN92CN1X2KbafY2s7Yw=="
+      "version": "2.0.19",
+      "resolved": "https://registry.npmjs.org/node-releases/-/node-releases-2.0.19.tgz",
+      "integrity": "sha512-xxOWJsBKtzAq7DY0J+DTzuz58K8e7sJbdgwkbMWQe8UYB6ekmsQ45q0M/tJDsGaZmbC+l7n57UV8Hl5tHxO9uw=="
     },
     "node_modules/node-source-walk": {
       "version": "4.3.0",
@@ -12698,9 +12821,12 @@
       }
     },
     "node_modules/object-inspect": {
-      "version": "1.12.2",
-      "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.12.2.tgz",
-      "integrity": "sha512-z+cPxW0QGUp0mcqcsgQyLVRDoXFQbXOwBaqyF7VIgI4TWNQsDHrBpUQslRmIfAoYWdYzs6UlKJtB2XJpTaNSpQ==",
+      "version": "1.13.4",
+      "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.13.4.tgz",
+      "integrity": "sha512-W67iLl4J2EXEGTbfeHCffrjDfitvLANg0UlX3wFUUSTx92KXRFegMHUVgSqE+wvhAbi4WqjGg9czysTV2Epbew==",
+      "engines": {
+        "node": ">= 0.4"
+      },
       "funding": {
         "url": "https://github.com/sponsors/ljharb"
       }
@@ -13166,9 +13292,9 @@
       "integrity": "sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw=="
     },
     "node_modules/path-to-regexp": {
-      "version": "0.1.7",
-      "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-0.1.7.tgz",
-      "integrity": "sha512-5DFkuoqlv1uYQKxy8omFBeJPQcdoE07Kv2sferDCrAq1ohOU+MSDswDIbnx3YAM60qIOnYa53wBhXW0EbMonrQ==",
+      "version": "0.1.12",
+      "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-0.1.12.tgz",
+      "integrity": "sha512-RA1GjUVMnvYFxuqovrEqZoxxW5NUZqbwKtYz/Tt7nXerk0LbLblQmrsgdeOxV5SFHf0UDggjS/bSeOZwt1pmEQ==",
       "dev": true
     },
     "node_modules/path-type": {
@@ -13187,9 +13313,9 @@
       "dev": true
     },
     "node_modules/picocolors": {
-      "version": "1.0.1",
-      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.0.1.tgz",
-      "integrity": "sha512-anP1Z8qwhkbmu7MFP5iTt+wQKXgwzf7zTyGlcdzabySa9vd0Xt392U0rVmz9poOaBj0uHJKyyo9/upk0HrEQew=="
+      "version": "1.1.1",
+      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz",
+      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA=="
     },
     "node_modules/picomatch": {
       "version": "2.3.1",
@@ -14779,11 +14905,11 @@
       }
     },
     "node_modules/qs": {
-      "version": "6.11.0",
-      "resolved": "https://registry.npmjs.org/qs/-/qs-6.11.0.tgz",
-      "integrity": "sha512-MvjoMCJwEarSbUYk5O+nmoSzSutSsTwF85zcHPQ9OrlFoZOYIjaqBAJIqIXjptyD5vThxGq52Xu/MaJzRkIk4Q==",
+      "version": "6.13.0",
+      "resolved": "https://registry.npmjs.org/qs/-/qs-6.13.0.tgz",
+      "integrity": "sha512-+38qI9SOr8tfZ4QmJNplMUxqjbe7LKvvZgWdExBOmd+egZTtjLB67Gu0HRX3u/XOq7UU2Nx6nsjvS16Z9uwfpg==",
       "dependencies": {
-        "side-channel": "^1.0.4"
+        "side-channel": "^1.0.6"
       },
       "engines": {
         "node": ">=0.6"
@@ -15162,7 +15288,6 @@
       "version": "2.0.2",
       "resolved": "https://registry.npmjs.org/require-from-string/-/require-from-string-2.0.2.tgz",
       "integrity": "sha512-Xf0nWe6RseziFMu+Ap9biiUbmplq6S9/p+7w7YXP/JBHhrUDDUhwa+vANyubuqfZWTveU//DYVGsDG7RKL/vEw==",
-      "dev": true,
       "engines": {
         "node": ">=0.10.0"
       }
@@ -15174,9 +15299,9 @@
       "dev": true
     },
     "node_modules/requirejs": {
-      "version": "2.3.6",
-      "resolved": "https://registry.npmjs.org/requirejs/-/requirejs-2.3.6.tgz",
-      "integrity": "sha512-ipEzlWQe6RK3jkzikgCupiTbTvm4S0/CAU5GlgptkN5SO6F3u0UD0K18wy6ErDqiCyP4J4YYe1HuAShvsxePLg==",
+      "version": "2.3.7",
+      "resolved": "https://registry.npmjs.org/requirejs/-/requirejs-2.3.7.tgz",
+      "integrity": "sha512-DouTG8T1WanGok6Qjg2SXuCMzszOo0eHeH9hDZ5Y4x8Je+9JB38HdTLT4/VA8OaUhBa0JPVHJ0pyBkM1z+pDsw==",
       "dev": true,
       "bin": {
         "r_js": "bin/r.js",
@@ -15768,9 +15893,9 @@
       "integrity": "sha512-3wdGidZyq5PB084XLES5TpOSRA3wjXAlIWMhum2kRcv/41Sn2emQ0dycQW4uZXLejwKvg6EsvbdlVL+FYEct7A=="
     },
     "node_modules/send": {
-      "version": "0.18.0",
-      "resolved": "https://registry.npmjs.org/send/-/send-0.18.0.tgz",
-      "integrity": "sha512-qqWzuOjSFOuqPjFe4NOsMLafToQQwBSOEpS+FwEt3A2V3vKubTquT3vmLTQpFgMXp8AlFWFuP1qKaJZOtPpVXg==",
+      "version": "0.19.0",
+      "resolved": "https://registry.npmjs.org/send/-/send-0.19.0.tgz",
+      "integrity": "sha512-dW41u5VfLXu8SJh5bwRmyYUbAoSB3c9uQh6L8h/KtsFREPWpbX1lrljJo186Jc4nmci/sGUZ9a0a0J2zgfq2hw==",
       "dev": true,
       "dependencies": {
         "debug": "2.6.9",
@@ -15847,9 +15972,9 @@
       "integrity": "sha512-2Fgx1Ycm599x+WGpIYwJOvsjmXFzTSc34IwDWALRA/8AopUKAVPwfJ+h5+f85BCp0PWmmJcWzEpxOpoXycMpdA=="
     },
     "node_modules/serialize-javascript": {
-      "version": "6.0.1",
-      "resolved": "https://registry.npmjs.org/serialize-javascript/-/serialize-javascript-6.0.1.tgz",
-      "integrity": "sha512-owoXEFjWRllis8/M1Q+Cw5k8ZH40e3zhp/ovX+Xr/vi1qj6QesbyXXViFbpNvWvPNAD62SutwEXavefrLJWj7w==",
+      "version": "6.0.2",
+      "resolved": "https://registry.npmjs.org/serialize-javascript/-/serialize-javascript-6.0.2.tgz",
+      "integrity": "sha512-Saa1xPByTTq2gdeFZYLLo+RFE35NHZkAbqZeWNd3BpzppeVisAqpDjcp8dyf6uIvEqJRd46jemmyA4iFIeVk8g==",
       "dependencies": {
         "randombytes": "^2.1.0"
       }
@@ -15924,20 +16049,29 @@
       "dev": true
     },
     "node_modules/serve-static": {
-      "version": "1.15.0",
-      "resolved": "https://registry.npmjs.org/serve-static/-/serve-static-1.15.0.tgz",
-      "integrity": "sha512-XGuRDNjXUijsUL0vl6nSD7cwURuzEgglbOaFuZM9g3kwDXOWVTck0jLzjPzGD+TazWbboZYu52/9/XPdUgne9g==",
+      "version": "1.16.2",
+      "resolved": "https://registry.npmjs.org/serve-static/-/serve-static-1.16.2.tgz",
+      "integrity": "sha512-VqpjJZKadQB/PEbEwvFdO43Ax5dFBZ2UECszz8bQ7pi7wt//PWe1P6MN7eCnjsatYtBT6EuiClbjSWP2WrIoTw==",
       "dev": true,
       "dependencies": {
-        "encodeurl": "~1.0.2",
+        "encodeurl": "~2.0.0",
         "escape-html": "~1.0.3",
         "parseurl": "~1.3.3",
-        "send": "0.18.0"
+        "send": "0.19.0"
       },
       "engines": {
         "node": ">= 0.8.0"
       }
     },
+    "node_modules/serve-static/node_modules/encodeurl": {
+      "version": "2.0.0",
+      "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz",
+      "integrity": "sha512-Q0n9HRi4m6JuGIV1eFlmvJB7ZEVxu93IrMyiMsGC0lrMJMWzRgx6WGquyfQgZVb31vhGgXnfmPNNXmxnOkRBrg==",
+      "dev": true,
+      "engines": {
+        "node": ">= 0.8"
+      }
+    },
     "node_modules/set-blocking": {
       "version": "2.0.0",
       "resolved": "https://registry.npmjs.org/set-blocking/-/set-blocking-2.0.0.tgz",
@@ -15987,13 +16121,68 @@
       }
     },
     "node_modules/side-channel": {
-      "version": "1.0.4",
-      "resolved": "https://registry.npmjs.org/side-channel/-/side-channel-1.0.4.tgz",
-      "integrity": "sha512-q5XPytqFEIKHkGdiMIrY10mvLRvnQh42/+GoBlFW3b2LXLE2xxJpZFdm94we0BaoV3RwJyGqg5wS7epxTv0Zvw==",
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/side-channel/-/side-channel-1.1.0.tgz",
+      "integrity": "sha512-ZX99e6tRweoUXqR+VBrslhda51Nh5MTQwou5tnUDgbtyM0dBgmhEDtWGP/xbKn6hqfPRHujUNwz5fy/wbbhnpw==",
+      "dependencies": {
+        "es-errors": "^1.3.0",
+        "object-inspect": "^1.13.3",
+        "side-channel-list": "^1.0.0",
+        "side-channel-map": "^1.0.1",
+        "side-channel-weakmap": "^1.0.2"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/side-channel-list": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/side-channel-list/-/side-channel-list-1.0.0.tgz",
+      "integrity": "sha512-FCLHtRD/gnpCiCHEiJLOwdmFP+wzCmDEkc9y7NsYxeF4u7Btsn1ZuwgwJGxImImHicJArLP4R0yX4c2KCrMrTA==",
       "dependencies": {
-        "call-bind": "^1.0.0",
-        "get-intrinsic": "^1.0.2",
-        "object-inspect": "^1.9.0"
+        "es-errors": "^1.3.0",
+        "object-inspect": "^1.13.3"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/side-channel-map": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/side-channel-map/-/side-channel-map-1.0.1.tgz",
+      "integrity": "sha512-VCjCNfgMsby3tTdo02nbjtM/ewra6jPHmpThenkTYh8pG9ucZ/1P8So4u4FGBek/BjpOVsDCMoLA/iuBKIFXRA==",
+      "dependencies": {
+        "call-bound": "^1.0.2",
+        "es-errors": "^1.3.0",
+        "get-intrinsic": "^1.2.5",
+        "object-inspect": "^1.13.3"
+      },
+      "engines": {
+        "node": ">= 0.4"
+      },
+      "funding": {
+        "url": "https://github.com/sponsors/ljharb"
+      }
+    },
+    "node_modules/side-channel-weakmap": {
+      "version": "1.0.2",
+      "resolved": "https://registry.npmjs.org/side-channel-weakmap/-/side-channel-weakmap-1.0.2.tgz",
+      "integrity": "sha512-WPS/HvHQTYnHisLo9McqBHOJk2FkHO/tlpvldyrnem4aeQp4hai3gythswg6p01oSoTl58rcpiFAjF2br2Ak2A==",
+      "dependencies": {
+        "call-bound": "^1.0.2",
+        "es-errors": "^1.3.0",
+        "get-intrinsic": "^1.2.5",
+        "object-inspect": "^1.13.3",
+        "side-channel-map": "^1.0.1"
+      },
+      "engines": {
+        "node": ">= 0.4"
       },
       "funding": {
         "url": "https://github.com/sponsors/ljharb"
@@ -16033,30 +16222,31 @@
       }
     },
     "node_modules/socket.io": {
-      "version": "4.7.1",
-      "resolved": "https://registry.npmjs.org/socket.io/-/socket.io-4.7.1.tgz",
-      "integrity": "sha512-W+utHys2w//dhFjy7iQQu9sGd3eokCjGbl2r59tyLqNiJJBdIebn3GAKEXBr3osqHTObJi2die/25bCx2zsaaw==",
+      "version": "4.8.1",
+      "resolved": "https://registry.npmjs.org/socket.io/-/socket.io-4.8.1.tgz",
+      "integrity": "sha512-oZ7iUCxph8WYRHHcjBEc9unw3adt5CmSNlppj/5Q4k2RIrhl8Z5yY2Xr4j9zj0+wzVZ0bxmYoGSzKJnRl6A4yg==",
       "dev": true,
       "dependencies": {
         "accepts": "~1.3.4",
         "base64id": "~2.0.0",
         "cors": "~2.8.5",
         "debug": "~4.3.2",
-        "engine.io": "~6.5.0",
+        "engine.io": "~6.6.0",
         "socket.io-adapter": "~2.5.2",
         "socket.io-parser": "~4.2.4"
       },
       "engines": {
-        "node": ">=10.0.0"
+        "node": ">=10.2.0"
       }
     },
     "node_modules/socket.io-adapter": {
-      "version": "2.5.2",
-      "resolved": "https://registry.npmjs.org/socket.io-adapter/-/socket.io-adapter-2.5.2.tgz",
-      "integrity": "sha512-87C3LO/NOMc+eMcpcxUBebGjkpMDkNBS9tf7KJqcDsmL936EChtVva71Dw2q4tQcuVC+hAUy4an2NO/sYXmwRA==",
+      "version": "2.5.5",
+      "resolved": "https://registry.npmjs.org/socket.io-adapter/-/socket.io-adapter-2.5.5.tgz",
+      "integrity": "sha512-eLDQas5dzPgOWCk9GuuJC2lBqItuhKI4uxGgo9aIV7MYbk2h9Q6uULEh8WBzThoI7l+qU9Ast9fVUmkqPP9wYg==",
       "dev": true,
       "dependencies": {
-        "ws": "~8.11.0"
+        "debug": "~4.3.4",
+        "ws": "~8.17.1"
       }
     },
     "node_modules/socket.io-parser": {
@@ -16084,16 +16274,16 @@
       }
     },
     "node_modules/socks": {
-      "version": "2.7.1",
-      "resolved": "https://registry.npmjs.org/socks/-/socks-2.7.1.tgz",
-      "integrity": "sha512-7maUZy1N7uo6+WVEX6psASxtNlKaNVMlGQKkG/63nEDdLOWNbiUMoLK7X4uYoLhQstau72mLgfEWcXcwsaHbYQ==",
+      "version": "2.8.4",
+      "resolved": "https://registry.npmjs.org/socks/-/socks-2.8.4.tgz",
+      "integrity": "sha512-D3YaD0aRxR3mEcqnidIs7ReYJFVzWdd6fXJYUM8ixcQcJRGTka/b3saV0KflYhyVJXKhb947GndU35SxYNResQ==",
       "dev": true,
       "dependencies": {
-        "ip": "^2.0.0",
+        "ip-address": "^9.0.5",
         "smart-buffer": "^4.2.0"
       },
       "engines": {
-        "node": ">= 10.13.0",
+        "node": ">= 10.0.0",
         "npm": ">= 3.0.0"
       }
     },
@@ -16663,15 +16853,15 @@
       }
     },
     "node_modules/terser-webpack-plugin": {
-      "version": "5.3.10",
-      "resolved": "https://registry.npmjs.org/terser-webpack-plugin/-/terser-webpack-plugin-5.3.10.tgz",
-      "integrity": "sha512-BKFPWlPDndPs+NGGCr1U59t0XScL5317Y0UReNrHaw9/FwhPENlq6bfgs+4yPfyP51vqC1bQ4rp1EfXW5ZSH9w==",
+      "version": "5.3.14",
+      "resolved": "https://registry.npmjs.org/terser-webpack-plugin/-/terser-webpack-plugin-5.3.14.tgz",
+      "integrity": "sha512-vkZjpUjb6OMS7dhV+tILUW6BhpDR7P2L/aQSAv+Uwk+m8KATX9EccViHTJR2qDtACKPIYndLGCyl3FMo+r2LMw==",
       "dependencies": {
-        "@jridgewell/trace-mapping": "^0.3.20",
+        "@jridgewell/trace-mapping": "^0.3.25",
         "jest-worker": "^27.4.5",
-        "schema-utils": "^3.1.1",
-        "serialize-javascript": "^6.0.1",
-        "terser": "^5.26.0"
+        "schema-utils": "^4.3.0",
+        "serialize-javascript": "^6.0.2",
+        "terser": "^5.31.1"
       },
       "engines": {
         "node": ">= 10.13.0"
@@ -16695,47 +16885,20 @@
         }
       }
     },
-    "node_modules/terser-webpack-plugin/node_modules/ajv": {
-      "version": "6.12.6",
-      "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz",
-      "integrity": "sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==",
-      "dependencies": {
-        "fast-deep-equal": "^3.1.1",
-        "fast-json-stable-stringify": "^2.0.0",
-        "json-schema-traverse": "^0.4.1",
-        "uri-js": "^4.2.2"
-      },
-      "funding": {
-        "type": "github",
-        "url": "https://github.com/sponsors/epoberezkin"
-      }
-    },
-    "node_modules/terser-webpack-plugin/node_modules/ajv-keywords": {
-      "version": "3.5.2",
-      "resolved": "https://registry.npmjs.org/ajv-keywords/-/ajv-keywords-3.5.2.tgz",
-      "integrity": "sha512-5p6WTN0DdTGVQk6VjcEju19IgaHudalcfabD7yhDGeA6bcQnmL+CpveLJq/3hvfwd1aof6L386Ougkx6RfyMIQ==",
-      "peerDependencies": {
-        "ajv": "^6.9.1"
-      }
-    },
     "node_modules/terser-webpack-plugin/node_modules/commander": {
       "version": "2.20.3",
       "resolved": "https://registry.npmjs.org/commander/-/commander-2.20.3.tgz",
       "integrity": "sha512-GpVkmM8vF2vQUkj2LvZmD35JxeJOLCwJ9cUkugyk2nuhbv3+mJvpLYYt+0+USMxE+oj+ey/lJEnhZw75x/OMcQ=="
     },
-    "node_modules/terser-webpack-plugin/node_modules/json-schema-traverse": {
-      "version": "0.4.1",
-      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
-      "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg=="
-    },
     "node_modules/terser-webpack-plugin/node_modules/schema-utils": {
-      "version": "3.1.1",
-      "resolved": "https://registry.npmjs.org/schema-utils/-/schema-utils-3.1.1.tgz",
-      "integrity": "sha512-Y5PQxS4ITlC+EahLuXaY86TXfR7Dc5lw294alXOq86JAHCihAIZfqv8nNCWvaEJvaC51uN9hbLGeV0cFBdH+Fw==",
+      "version": "4.3.2",
+      "resolved": "https://registry.npmjs.org/schema-utils/-/schema-utils-4.3.2.tgz",
+      "integrity": "sha512-Gn/JaSk/Mt9gYubxTtSn/QCV4em9mpAPiR1rqy/Ocu19u/G9J5WWdNoUT4SiV6mFC3y6cxyFcFwdzPM3FgxGAQ==",
       "dependencies": {
-        "@types/json-schema": "^7.0.8",
-        "ajv": "^6.12.5",
-        "ajv-keywords": "^3.5.2"
+        "@types/json-schema": "^7.0.9",
+        "ajv": "^8.9.0",
+        "ajv-formats": "^2.1.1",
+        "ajv-keywords": "^5.1.0"
       },
       "engines": {
         "node": ">= 10.13.0"
@@ -16746,9 +16909,9 @@
       }
     },
     "node_modules/terser-webpack-plugin/node_modules/terser": {
-      "version": "5.31.0",
-      "resolved": "https://registry.npmjs.org/terser/-/terser-5.31.0.tgz",
-      "integrity": "sha512-Q1JFAoUKE5IMfI4Z/lkE/E6+SwgzO+x4tq4v1AyBLRj8VSYvRO6A/rQrPg1yud4g0En9EKI1TvFRF2tQFcoUkg==",
+      "version": "5.39.0",
+      "resolved": "https://registry.npmjs.org/terser/-/terser-5.39.0.tgz",
+      "integrity": "sha512-LBAhFyLho16harJoWMg/nZsQYgTrg5jXOn2nCYjRUcZZEdE3qa2zb8QEDRUGVZBW4rlazf2fxkg8tztybTaqWw==",
       "dependencies": {
         "@jridgewell/source-map": "^0.3.3",
         "acorn": "^8.8.2",
@@ -16875,15 +17038,6 @@
         "node": ">=0.6.0"
       }
     },
-    "node_modules/to-fast-properties": {
-      "version": "2.0.0",
-      "resolved": "https://registry.npmjs.org/to-fast-properties/-/to-fast-properties-2.0.0.tgz",
-      "integrity": "sha512-/OaKK0xYrs3DmxRYqL/yDc+FxFUVYhDlXMhRmv3z915w2HF1tnN1omB354j8VUGO/hbRzyD6Y3sA7v7GS/ceog==",
-      "dev": true,
-      "engines": {
-        "node": ">=4"
-      }
-    },
     "node_modules/to-regex-range": {
       "version": "5.0.1",
       "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
@@ -17380,9 +17534,9 @@
       }
     },
     "node_modules/update-browserslist-db": {
-      "version": "1.0.16",
-      "resolved": "https://registry.npmjs.org/update-browserslist-db/-/update-browserslist-db-1.0.16.tgz",
-      "integrity": "sha512-KVbTxlBYlckhF5wgfyZXTWnMn7MMZjMu9XG8bPlliUOP9ThaF4QnhP8qrjrH7DRzHfSk0oQv1wToW+iA5GajEQ==",
+      "version": "1.1.3",
+      "resolved": "https://registry.npmjs.org/update-browserslist-db/-/update-browserslist-db-1.1.3.tgz",
+      "integrity": "sha512-UxhIZQ+QInVdunkDAaiazvvT/+fXL5Osr0JZlJulepYu6Jd7qJtDZjlur0emRlT71EN3ScPoE7gvsuIKKNavKw==",
       "funding": [
         {
           "type": "opencollective",
@@ -17398,8 +17552,8 @@
         }
       ],
       "dependencies": {
-        "escalade": "^3.1.2",
-        "picocolors": "^1.0.1"
+        "escalade": "^3.2.0",
+        "picocolors": "^1.1.1"
       },
       "bin": {
         "update-browserslist-db": "cli.js"
@@ -17732,20 +17886,19 @@
       "integrity": "sha512-cmO2aPd6gR6bK/ttdk8ZIypJfZMOcTvsvXv/LxXZjAFu5TC6vXqFrZYudlPuKxVsA34Pc8Fysq2rCnflu+wuuA=="
     },
     "node_modules/webpack": {
-      "version": "5.91.0",
-      "resolved": "https://registry.npmjs.org/webpack/-/webpack-5.91.0.tgz",
-      "integrity": "sha512-rzVwlLeBWHJbmgTC/8TvAcu5vpJNII+MelQpylD4jNERPwpBJOE2lEcko1zJX3QJeLjTTAnQxn/OJ8bjDzVQaw==",
-      "dependencies": {
-        "@types/eslint-scope": "^3.7.3",
-        "@types/estree": "^1.0.5",
-        "@webassemblyjs/ast": "^1.12.1",
-        "@webassemblyjs/wasm-edit": "^1.12.1",
-        "@webassemblyjs/wasm-parser": "^1.12.1",
-        "acorn": "^8.7.1",
-        "acorn-import-assertions": "^1.9.0",
-        "browserslist": "^4.21.10",
+      "version": "5.99.6",
+      "resolved": "https://registry.npmjs.org/webpack/-/webpack-5.99.6.tgz",
+      "integrity": "sha512-TJOLrJ6oeccsGWPl7ujCYuc0pIq2cNsuD6GZDma8i5o5Npvcco/z+NKvZSFsP0/x6SShVb0+X2JK/JHUjKY9dQ==",
+      "dependencies": {
+        "@types/eslint-scope": "^3.7.7",
+        "@types/estree": "^1.0.6",
+        "@webassemblyjs/ast": "^1.14.1",
+        "@webassemblyjs/wasm-edit": "^1.14.1",
+        "@webassemblyjs/wasm-parser": "^1.14.1",
+        "acorn": "^8.14.0",
+        "browserslist": "^4.24.0",
         "chrome-trace-event": "^1.0.2",
-        "enhanced-resolve": "^5.16.0",
+        "enhanced-resolve": "^5.17.1",
         "es-module-lexer": "^1.2.1",
         "eslint-scope": "5.1.1",
         "events": "^3.2.0",
@@ -17755,9 +17908,9 @@
         "loader-runner": "^4.2.0",
         "mime-types": "^2.1.27",
         "neo-async": "^2.6.2",
-        "schema-utils": "^3.2.0",
+        "schema-utils": "^4.3.0",
         "tapable": "^2.1.1",
-        "terser-webpack-plugin": "^5.3.10",
+        "terser-webpack-plugin": "^5.3.11",
         "watchpack": "^2.4.1",
         "webpack-sources": "^3.2.3"
       },
@@ -17989,182 +18142,155 @@
       }
     },
     "node_modules/webpack/node_modules/@types/estree": {
-      "version": "1.0.5",
-      "resolved": "https://registry.npmjs.org/@types/estree/-/estree-1.0.5.tgz",
-      "integrity": "sha512-/kYRxGDLWzHOB7q+wtSUQlFrtcdUccpfy+X+9iMBpHK8QLLhx2wIPYuS5DYtR9Wa/YlZAbIovy7qVdB1Aq6Lyw=="
+      "version": "1.0.7",
+      "resolved": "https://registry.npmjs.org/@types/estree/-/estree-1.0.7.tgz",
+      "integrity": "sha512-w28IoSUCJpidD/TGviZwwMJckNESJZXFu7NBZ5YJ4mEUnNraUn9Pm8HSZm/jDF1pDWYKspWE7oVphigUPRakIQ=="
     },
     "node_modules/webpack/node_modules/@webassemblyjs/ast": {
-      "version": "1.12.1",
-      "resolved": "https://registry.npmjs.org/@webassemblyjs/ast/-/ast-1.12.1.tgz",
-      "integrity": "sha512-EKfMUOPRRUTy5UII4qJDGPpqfwjOmZ5jeGFwid9mnoqIFK+e0vqoi1qH56JpmZSzEL53jKnNzScdmftJyG5xWg==",
+      "version": "1.14.1",
+      "resolved": "https://registry.npmjs.org/@webassemblyjs/ast/-/ast-1.14.1.tgz",
+      "integrity": "sha512-nuBEDgQfm1ccRp/8bCQrx1frohyufl4JlbMMZ4P1wpeOfDhF6FQkxZJ1b/e+PLwr6X1Nhw6OLme5usuBWYBvuQ==",
       "dependencies": {
-        "@webassemblyjs/helper-numbers": "1.11.6",
-        "@webassemblyjs/helper-wasm-bytecode": "1.11.6"
+        "@webassemblyjs/helper-numbers": "1.13.2",
+        "@webassemblyjs/helper-wasm-bytecode": "1.13.2"
       }
     },
     "node_modules/webpack/node_modules/@webassemblyjs/floating-point-hex-parser": {
-      "version": "1.11.6",
-      "resolved": "https://registry.npmjs.org/@webassemblyjs/floating-point-hex-parser/-/floating-point-hex-parser-1.11.6.tgz",
-      "integrity": "sha512-ejAj9hfRJ2XMsNHk/v6Fu2dGS+i4UaXBXGemOfQ/JfQ6mdQg/WXtwleQRLLS4OvfDhv8rYnVwH27YJLMyYsxhw=="
+      "version": "1.13.2",
+      "resolved": "https://registry.npmjs.org/@webassemblyjs/floating-point-hex-parser/-/floating-point-hex-parser-1.13.2.tgz",
+      "integrity": "sha512-6oXyTOzbKxGH4steLbLNOu71Oj+C8Lg34n6CqRvqfS2O71BxY6ByfMDRhBytzknj9yGUPVJ1qIKhRlAwO1AovA=="
     },
     "node_modules/webpack/node_modules/@webassemblyjs/helper-api-error": {
-      "version": "1.11.6",
-      "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-api-error/-/helper-api-error-1.11.6.tgz",
-      "integrity": "sha512-o0YkoP4pVu4rN8aTJgAyj9hC2Sv5UlkzCHhxqWj8butaLvnpdc2jOwh4ewE6CX0txSfLn/UYaV/pheS2Txg//Q=="
+      "version": "1.13.2",
+      "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-api-error/-/helper-api-error-1.13.2.tgz",
+      "integrity": "sha512-U56GMYxy4ZQCbDZd6JuvvNV/WFildOjsaWD3Tzzvmw/mas3cXzRJPMjP83JqEsgSbyrmaGjBfDtV7KDXV9UzFQ=="
     },
     "node_modules/webpack/node_modules/@webassemblyjs/helper-buffer": {
-      "version": "1.12.1",
-      "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-buffer/-/helper-buffer-1.12.1.tgz",
-      "integrity": "sha512-nzJwQw99DNDKr9BVCOZcLuJJUlqkJh+kVzVl6Fmq/tI5ZtEyWT1KZMyOXltXLZJmDtvLCDgwsyrkohEtopTXCw=="
+      "version": "1.14.1",
+      "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-buffer/-/helper-buffer-1.14.1.tgz",
+      "integrity": "sha512-jyH7wtcHiKssDtFPRB+iQdxlDf96m0E39yb0k5uJVhFGleZFoNw1c4aeIcVUPPbXUVJ94wwnMOAqUHyzoEPVMA=="
     },
     "node_modules/webpack/node_modules/@webassemblyjs/helper-numbers": {
-      "version": "1.11.6",
-      "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-numbers/-/helper-numbers-1.11.6.tgz",
-      "integrity": "sha512-vUIhZ8LZoIWHBohiEObxVm6hwP034jwmc9kuq5GdHZH0wiLVLIPcMCdpJzG4C11cHoQ25TFIQj9kaVADVX7N3g==",
+      "version": "1.13.2",
+      "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-numbers/-/helper-numbers-1.13.2.tgz",
+      "integrity": "sha512-FE8aCmS5Q6eQYcV3gI35O4J789wlQA+7JrqTTpJqn5emA4U2hvwJmvFRC0HODS+3Ye6WioDklgd6scJ3+PLnEA==",
       "dependencies": {
-        "@webassemblyjs/floating-point-hex-parser": "1.11.6",
-        "@webassemblyjs/helper-api-error": "1.11.6",
+        "@webassemblyjs/floating-point-hex-parser": "1.13.2",
+        "@webassemblyjs/helper-api-error": "1.13.2",
         "@xtuc/long": "4.2.2"
       }
     },
     "node_modules/webpack/node_modules/@webassemblyjs/helper-wasm-bytecode": {
-      "version": "1.11.6",
-      "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-wasm-bytecode/-/helper-wasm-bytecode-1.11.6.tgz",
-      "integrity": "sha512-sFFHKwcmBprO9e7Icf0+gddyWYDViL8bpPjJJl0WHxCdETktXdmtWLGVzoHbqUcY4Be1LkNfwTmXOJUFZYSJdA=="
+      "version": "1.13.2",
+      "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-wasm-bytecode/-/helper-wasm-bytecode-1.13.2.tgz",
+      "integrity": "sha512-3QbLKy93F0EAIXLh0ogEVR6rOubA9AoZ+WRYhNbFyuB70j3dRdwH9g+qXhLAO0kiYGlg3TxDV+I4rQTr/YNXkA=="
     },
     "node_modules/webpack/node_modules/@webassemblyjs/helper-wasm-section": {
-      "version": "1.12.1",
-      "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-wasm-section/-/helper-wasm-section-1.12.1.tgz",
-      "integrity": "sha512-Jif4vfB6FJlUlSbgEMHUyk1j234GTNG9dBJ4XJdOySoj518Xj0oGsNi59cUQF4RRMS9ouBUxDDdyBVfPTypa5g==",
+      "version": "1.14.1",
+      "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-wasm-section/-/helper-wasm-section-1.14.1.tgz",
+      "integrity": "sha512-ds5mXEqTJ6oxRoqjhWDU83OgzAYjwsCV8Lo/N+oRsNDmx/ZDpqalmrtgOMkHwxsG0iI//3BwWAErYRHtgn0dZw==",
       "dependencies": {
-        "@webassemblyjs/ast": "1.12.1",
-        "@webassemblyjs/helper-buffer": "1.12.1",
-        "@webassemblyjs/helper-wasm-bytecode": "1.11.6",
-        "@webassemblyjs/wasm-gen": "1.12.1"
+        "@webassemblyjs/ast": "1.14.1",
+        "@webassemblyjs/helper-buffer": "1.14.1",
+        "@webassemblyjs/helper-wasm-bytecode": "1.13.2",
+        "@webassemblyjs/wasm-gen": "1.14.1"
       }
     },
     "node_modules/webpack/node_modules/@webassemblyjs/ieee754": {
-      "version": "1.11.6",
-      "resolved": "https://registry.npmjs.org/@webassemblyjs/ieee754/-/ieee754-1.11.6.tgz",
-      "integrity": "sha512-LM4p2csPNvbij6U1f19v6WR56QZ8JcHg3QIJTlSwzFcmx6WSORicYj6I63f9yU1kEUtrpG+kjkiIAkevHpDXrg==",
+      "version": "1.13.2",
+      "resolved": "https://registry.npmjs.org/@webassemblyjs/ieee754/-/ieee754-1.13.2.tgz",
+      "integrity": "sha512-4LtOzh58S/5lX4ITKxnAK2USuNEvpdVV9AlgGQb8rJDHaLeHciwG4zlGr0j/SNWlr7x3vO1lDEsuePvtcDNCkw==",
       "dependencies": {
         "@xtuc/ieee754": "^1.2.0"
       }
     },
     "node_modules/webpack/node_modules/@webassemblyjs/leb128": {
-      "version": "1.11.6",
-      "resolved": "https://registry.npmjs.org/@webassemblyjs/leb128/-/leb128-1.11.6.tgz",
-      "integrity": "sha512-m7a0FhE67DQXgouf1tbN5XQcdWoNgaAuoULHIfGFIEVKA6tu/edls6XnIlkmS6FrXAquJRPni3ZZKjw6FSPjPQ==",
+      "version": "1.13.2",
+      "resolved": "https://registry.npmjs.org/@webassemblyjs/leb128/-/leb128-1.13.2.tgz",
+      "integrity": "sha512-Lde1oNoIdzVzdkNEAWZ1dZ5orIbff80YPdHx20mrHwHrVNNTjNr8E3xz9BdpcGqRQbAEa+fkrCb+fRFTl/6sQw==",
       "dependencies": {
         "@xtuc/long": "4.2.2"
       }
     },
     "node_modules/webpack/node_modules/@webassemblyjs/utf8": {
-      "version": "1.11.6",
-      "resolved": "https://registry.npmjs.org/@webassemblyjs/utf8/-/utf8-1.11.6.tgz",
-      "integrity": "sha512-vtXf2wTQ3+up9Zsg8sa2yWiQpzSsMyXj0qViVP6xKGCUT8p8YJ6HqI7l5eCnWx1T/FYdsv07HQs2wTFbbof/RA=="
+      "version": "1.13.2",
+      "resolved": "https://registry.npmjs.org/@webassemblyjs/utf8/-/utf8-1.13.2.tgz",
+      "integrity": "sha512-3NQWGjKTASY1xV5m7Hr0iPeXD9+RDobLll3T9d2AO+g3my8xy5peVyjSag4I50mR1bBSN/Ct12lo+R9tJk0NZQ=="
     },
     "node_modules/webpack/node_modules/@webassemblyjs/wasm-edit": {
-      "version": "1.12.1",
-      "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-edit/-/wasm-edit-1.12.1.tgz",
-      "integrity": "sha512-1DuwbVvADvS5mGnXbE+c9NfA8QRcZ6iKquqjjmR10k6o+zzsRVesil54DKexiowcFCPdr/Q0qaMgB01+SQ1u6g==",
+      "version": "1.14.1",
+      "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-edit/-/wasm-edit-1.14.1.tgz",
+      "integrity": "sha512-RNJUIQH/J8iA/1NzlE4N7KtyZNHi3w7at7hDjvRNm5rcUXa00z1vRz3glZoULfJ5mpvYhLybmVcwcjGrC1pRrQ==",
       "dependencies": {
-        "@webassemblyjs/ast": "1.12.1",
-        "@webassemblyjs/helper-buffer": "1.12.1",
-        "@webassemblyjs/helper-wasm-bytecode": "1.11.6",
-        "@webassemblyjs/helper-wasm-section": "1.12.1",
-        "@webassemblyjs/wasm-gen": "1.12.1",
-        "@webassemblyjs/wasm-opt": "1.12.1",
-        "@webassemblyjs/wasm-parser": "1.12.1",
-        "@webassemblyjs/wast-printer": "1.12.1"
+        "@webassemblyjs/ast": "1.14.1",
+        "@webassemblyjs/helper-buffer": "1.14.1",
+        "@webassemblyjs/helper-wasm-bytecode": "1.13.2",
+        "@webassemblyjs/helper-wasm-section": "1.14.1",
+        "@webassemblyjs/wasm-gen": "1.14.1",
+        "@webassemblyjs/wasm-opt": "1.14.1",
+        "@webassemblyjs/wasm-parser": "1.14.1",
+        "@webassemblyjs/wast-printer": "1.14.1"
       }
     },
     "node_modules/webpack/node_modules/@webassemblyjs/wasm-gen": {
-      "version": "1.12.1",
-      "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-gen/-/wasm-gen-1.12.1.tgz",
-      "integrity": "sha512-TDq4Ojh9fcohAw6OIMXqiIcTq5KUXTGRkVxbSo1hQnSy6lAM5GSdfwWeSxpAo0YzgsgF182E/U0mDNhuA0tW7w==",
+      "version": "1.14.1",
+      "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-gen/-/wasm-gen-1.14.1.tgz",
+      "integrity": "sha512-AmomSIjP8ZbfGQhumkNvgC33AY7qtMCXnN6bL2u2Js4gVCg8fp735aEiMSBbDR7UQIj90n4wKAFUSEd0QN2Ukg==",
       "dependencies": {
-        "@webassemblyjs/ast": "1.12.1",
-        "@webassemblyjs/helper-wasm-bytecode": "1.11.6",
-        "@webassemblyjs/ieee754": "1.11.6",
-        "@webassemblyjs/leb128": "1.11.6",
-        "@webassemblyjs/utf8": "1.11.6"
+        "@webassemblyjs/ast": "1.14.1",
+        "@webassemblyjs/helper-wasm-bytecode": "1.13.2",
+        "@webassemblyjs/ieee754": "1.13.2",
+        "@webassemblyjs/leb128": "1.13.2",
+        "@webassemblyjs/utf8": "1.13.2"
       }
     },
     "node_modules/webpack/node_modules/@webassemblyjs/wasm-opt": {
-      "version": "1.12.1",
-      "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-opt/-/wasm-opt-1.12.1.tgz",
-      "integrity": "sha512-Jg99j/2gG2iaz3hijw857AVYekZe2SAskcqlWIZXjji5WStnOpVoat3gQfT/Q5tb2djnCjBtMocY/Su1GfxPBg==",
+      "version": "1.14.1",
+      "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-opt/-/wasm-opt-1.14.1.tgz",
+      "integrity": "sha512-PTcKLUNvBqnY2U6E5bdOQcSM+oVP/PmrDY9NzowJjislEjwP/C4an2303MCVS2Mg9d3AJpIGdUFIQQWbPds0Sw==",
       "dependencies": {
-        "@webassemblyjs/ast": "1.12.1",
-        "@webassemblyjs/helper-buffer": "1.12.1",
-        "@webassemblyjs/wasm-gen": "1.12.1",
-        "@webassemblyjs/wasm-parser": "1.12.1"
+        "@webassemblyjs/ast": "1.14.1",
+        "@webassemblyjs/helper-buffer": "1.14.1",
+        "@webassemblyjs/wasm-gen": "1.14.1",
+        "@webassemblyjs/wasm-parser": "1.14.1"
       }
     },
     "node_modules/webpack/node_modules/@webassemblyjs/wasm-parser": {
-      "version": "1.12.1",
-      "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-parser/-/wasm-parser-1.12.1.tgz",
-      "integrity": "sha512-xikIi7c2FHXysxXe3COrVUPSheuBtpcfhbpFj4gmu7KRLYOzANztwUU0IbsqvMqzuNK2+glRGWCEqZo1WCLyAQ==",
+      "version": "1.14.1",
+      "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-parser/-/wasm-parser-1.14.1.tgz",
+      "integrity": "sha512-JLBl+KZ0R5qB7mCnud/yyX08jWFw5MsoalJ1pQ4EdFlgj9VdXKGuENGsiCIjegI1W7p91rUlcB/LB5yRJKNTcQ==",
       "dependencies": {
-        "@webassemblyjs/ast": "1.12.1",
-        "@webassemblyjs/helper-api-error": "1.11.6",
-        "@webassemblyjs/helper-wasm-bytecode": "1.11.6",
-        "@webassemblyjs/ieee754": "1.11.6",
-        "@webassemblyjs/leb128": "1.11.6",
-        "@webassemblyjs/utf8": "1.11.6"
+        "@webassemblyjs/ast": "1.14.1",
+        "@webassemblyjs/helper-api-error": "1.13.2",
+        "@webassemblyjs/helper-wasm-bytecode": "1.13.2",
+        "@webassemblyjs/ieee754": "1.13.2",
+        "@webassemblyjs/leb128": "1.13.2",
+        "@webassemblyjs/utf8": "1.13.2"
       }
     },
     "node_modules/webpack/node_modules/@webassemblyjs/wast-printer": {
-      "version": "1.12.1",
-      "resolved": "https://registry.npmjs.org/@webassemblyjs/wast-printer/-/wast-printer-1.12.1.tgz",
-      "integrity": "sha512-+X4WAlOisVWQMikjbcvY2e0rwPsKQ9F688lksZhBcPycBBuii3O7m8FACbDMWDojpAqvjIncrG8J0XHKyQfVeA==",
+      "version": "1.14.1",
+      "resolved": "https://registry.npmjs.org/@webassemblyjs/wast-printer/-/wast-printer-1.14.1.tgz",
+      "integrity": "sha512-kPSSXE6De1XOR820C90RIo2ogvZG+c3KiHzqUoO/F34Y2shGzesfqv7o57xrxovZJH/MetF5UjroJ/R/3isoiw==",
       "dependencies": {
-        "@webassemblyjs/ast": "1.12.1",
+        "@webassemblyjs/ast": "1.14.1",
         "@xtuc/long": "4.2.2"
       }
     },
-    "node_modules/webpack/node_modules/ajv": {
-      "version": "6.12.6",
-      "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz",
-      "integrity": "sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==",
-      "dependencies": {
-        "fast-deep-equal": "^3.1.1",
-        "fast-json-stable-stringify": "^2.0.0",
-        "json-schema-traverse": "^0.4.1",
-        "uri-js": "^4.2.2"
-      },
-      "funding": {
-        "type": "github",
-        "url": "https://github.com/sponsors/epoberezkin"
-      }
-    },
-    "node_modules/webpack/node_modules/ajv-keywords": {
-      "version": "3.5.2",
-      "resolved": "https://registry.npmjs.org/ajv-keywords/-/ajv-keywords-3.5.2.tgz",
-      "integrity": "sha512-5p6WTN0DdTGVQk6VjcEju19IgaHudalcfabD7yhDGeA6bcQnmL+CpveLJq/3hvfwd1aof6L386Ougkx6RfyMIQ==",
-      "peerDependencies": {
-        "ajv": "^6.9.1"
-      }
-    },
     "node_modules/webpack/node_modules/es-module-lexer": {
       "version": "1.3.0",
       "resolved": "https://registry.npmjs.org/es-module-lexer/-/es-module-lexer-1.3.0.tgz",
       "integrity": "sha512-vZK7T0N2CBmBOixhmjdqx2gWVbFZ4DXZ/NyRMZVlJXPa7CyFS+/a4QQsDGDQy9ZfEzxFuNEsMLeQJnKP2p5/JA=="
     },
-    "node_modules/webpack/node_modules/json-schema-traverse": {
-      "version": "0.4.1",
-      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
-      "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg=="
-    },
     "node_modules/webpack/node_modules/schema-utils": {
-      "version": "3.3.0",
-      "resolved": "https://registry.npmjs.org/schema-utils/-/schema-utils-3.3.0.tgz",
-      "integrity": "sha512-pN/yOAvcC+5rQ5nERGuwrjLlYvLTbCibnZ1I7B1LaiAz9BRBlE9GMgE/eqV30P7aJQUf7Ddimy/RsbYO/GrVGg==",
+      "version": "4.3.2",
+      "resolved": "https://registry.npmjs.org/schema-utils/-/schema-utils-4.3.2.tgz",
+      "integrity": "sha512-Gn/JaSk/Mt9gYubxTtSn/QCV4em9mpAPiR1rqy/Ocu19u/G9J5WWdNoUT4SiV6mFC3y6cxyFcFwdzPM3FgxGAQ==",
       "dependencies": {
-        "@types/json-schema": "^7.0.8",
-        "ajv": "^6.12.5",
-        "ajv-keywords": "^3.5.2"
+        "@types/json-schema": "^7.0.9",
+        "ajv": "^8.9.0",
+        "ajv-formats": "^2.1.1",
+        "ajv-keywords": "^5.1.0"
       },
       "engines": {
         "node": ">= 10.13.0"
@@ -18297,16 +18423,16 @@
       "dev": true
     },
     "node_modules/ws": {
-      "version": "8.11.0",
-      "resolved": "https://registry.npmjs.org/ws/-/ws-8.11.0.tgz",
-      "integrity": "sha512-HPG3wQd9sNQoT9xHyNCXoDUa+Xw/VevmY9FoHyQ+g+rrMn4j6FB4np7Z0OhdTgjx6MgQLK7jwSy1YecU1+4Asg==",
+      "version": "8.17.1",
+      "resolved": "https://registry.npmjs.org/ws/-/ws-8.17.1.tgz",
+      "integrity": "sha512-6XQFvXTkbfUOZOKKILFG1PDK2NDQs4azKQl26T0YS5CxqWLgXajbPZ+h4gZekJyRqFU8pvnbAbbs/3TgRPy+GQ==",
       "dev": true,
       "engines": {
         "node": ">=10.0.0"
       },
       "peerDependencies": {
         "bufferutil": "^4.0.1",
-        "utf-8-validate": "^5.0.2"
+        "utf-8-validate": ">=5.0.2"
       },
       "peerDependenciesMeta": {
         "bufferutil": {
@@ -19000,12 +19126,13 @@
       }
     },
     "@babel/code-frame": {
-      "version": "7.24.2",
-      "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.24.2.tgz",
-      "integrity": "sha512-y5+tLQyV8pg3fsiln67BVLD1P13Eg4lh5RW9mF0zUuvLrv9uIQ4MCL+CRT+FTsBlBjcIan6PGsLcBN0m3ClUyQ==",
+      "version": "7.26.2",
+      "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.26.2.tgz",
+      "integrity": "sha512-RJlIHRueQgwWitWgF8OdFYGZX328Ax5BCemNGlqHfplnRT9ESi8JkFlvaVYbS+UubVY6dpv87Fs2u5M29iNFVQ==",
       "dev": true,
       "requires": {
-        "@babel/highlight": "^7.24.2",
+        "@babel/helper-validator-identifier": "^7.25.9",
+        "js-tokens": "^4.0.0",
         "picocolors": "^1.0.0"
       }
     },
@@ -19325,15 +19452,15 @@
       }
     },
     "@babel/helper-string-parser": {
-      "version": "7.24.1",
-      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.24.1.tgz",
-      "integrity": "sha512-2ofRCjnnA9y+wk8b9IAREroeUP02KHp431N2mhKniy2yKIDKpbrHv9eXwm8cBeWQYcJmzv5qKCu65P47eCF7CQ==",
+      "version": "7.25.9",
+      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.25.9.tgz",
+      "integrity": "sha512-4A/SCr/2KLd5jrtOMFzaKjVtAei3+2r/NChoBNoZ3EyP/+GlhoaEGoWOZUmFmoITP7zOJyHIMm+DYRd8o3PvHA==",
       "dev": true
     },
     "@babel/helper-validator-identifier": {
-      "version": "7.24.5",
-      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.24.5.tgz",
-      "integrity": "sha512-3q93SSKX2TWCG30M2G2kwaKeTYgEUp5Snjuj8qm729SObL6nbtUldAi37qbxkD5gg3xnBio+f9nqpSepGZMvxA==",
+      "version": "7.25.9",
+      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.25.9.tgz",
+      "integrity": "sha512-Ed61U6XJc3CVRfkERJWDz4dJwKe7iLmmJsbOGu9wSloNSFttHV0I8g6UAgb7qnK5ly5bGLPd4oXZlxCdANBOWQ==",
       "dev": true
     },
     "@babel/helper-validator-option": {
@@ -19355,47 +19482,37 @@
       }
     },
     "@babel/helpers": {
-      "version": "7.20.7",
-      "resolved": "https://registry.npmjs.org/@babel/helpers/-/helpers-7.20.7.tgz",
-      "integrity": "sha512-PBPjs5BppzsGaxHQCDKnZ6Gd9s6xl8bBCluz3vEInLGRJmnZan4F6BYCeqtyXqkk4W5IlPmjK4JlOuZkpJ3xZA==",
+      "version": "7.27.0",
+      "resolved": "https://registry.npmjs.org/@babel/helpers/-/helpers-7.27.0.tgz",
+      "integrity": "sha512-U5eyP/CTFPuNE3qk+WZMxFkp/4zUzdceQlfzf7DdGdhp+Fezd7HD+i8Y24ZuTMKX3wQBld449jijbGq6OdGNQg==",
       "dev": true,
       "requires": {
-        "@babel/template": "^7.20.7",
-        "@babel/traverse": "^7.20.7",
-        "@babel/types": "^7.20.7"
+        "@babel/template": "^7.27.0",
+        "@babel/types": "^7.27.0"
       },
       "dependencies": {
         "@babel/template": {
-          "version": "7.20.7",
-          "resolved": "https://registry.npmjs.org/@babel/template/-/template-7.20.7.tgz",
-          "integrity": "sha512-8SegXApWe6VoNw0r9JHpSteLKTpTiLZ4rMlGIm9JQ18KiCtyQiAMEazujAHrUS5flrcqYZa75ukev3P6QmUwUw==",
+          "version": "7.27.0",
+          "resolved": "https://registry.npmjs.org/@babel/template/-/template-7.27.0.tgz",
+          "integrity": "sha512-2ncevenBqXI6qRMukPlXwHKHchC7RyMuu4xv5JBXRfOGVcTy1mXCD12qrp7Jsoxll1EV3+9sE4GugBVRjT2jFA==",
           "dev": true,
           "requires": {
-            "@babel/code-frame": "^7.18.6",
-            "@babel/parser": "^7.20.7",
-            "@babel/types": "^7.20.7"
+            "@babel/code-frame": "^7.26.2",
+            "@babel/parser": "^7.27.0",
+            "@babel/types": "^7.27.0"
           }
         }
       }
     },
-    "@babel/highlight": {
-      "version": "7.24.5",
-      "resolved": "https://registry.npmjs.org/@babel/highlight/-/highlight-7.24.5.tgz",
-      "integrity": "sha512-8lLmua6AVh/8SLJRRVD6V8p73Hir9w5mJrhE+IPpILG31KKlI9iz5zmBYKcWPS59qSfgP9RaSBQSHHE81WKuEw==",
+    "@babel/parser": {
+      "version": "7.27.0",
+      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.27.0.tgz",
+      "integrity": "sha512-iaepho73/2Pz7w2eMS0Q5f83+0RKI7i4xmiYeBmDzfRVbQtTOG7Ts0S4HzJVsTMGI9keU8rNfuZr8DKfSt7Yyg==",
       "dev": true,
       "requires": {
-        "@babel/helper-validator-identifier": "^7.24.5",
-        "chalk": "^2.4.2",
-        "js-tokens": "^4.0.0",
-        "picocolors": "^1.0.0"
+        "@babel/types": "^7.27.0"
       }
     },
-    "@babel/parser": {
-      "version": "7.24.5",
-      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.24.5.tgz",
-      "integrity": "sha512-EOv5IK8arwh3LI47dz1b0tKUb/1uhHAnHJOrjgtQMIpu1uXd9mlFrJg9IUgGUgZ41Ch0K8REPTYpO7B76b4vJg==",
-      "dev": true
-    },
     "@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression": {
       "version": "7.18.6",
       "resolved": "https://registry.npmjs.org/@babel/plugin-bugfix-safari-id-destructuring-collision-in-function-expression/-/plugin-bugfix-safari-id-destructuring-collision-in-function-expression-7.18.6.tgz",
@@ -20228,14 +20345,13 @@
       }
     },
     "@babel/types": {
-      "version": "7.24.5",
-      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.24.5.tgz",
-      "integrity": "sha512-6mQNsaLeXTw0nxYUYu+NSa4Hx4BlF1x1x8/PMFbiR+GBSr+2DkECc69b8hgy2frEodNcvPffeH8YfWd3LI6jhQ==",
+      "version": "7.27.0",
+      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.27.0.tgz",
+      "integrity": "sha512-H45s8fVLYjbhFH62dIJ3WtmJ6RSPt/3DRO0ZcT2SUiYiQyz3BLVb9ADEnLl91m74aQPS3AzzeajZHYOalWe3bg==",
       "dev": true,
       "requires": {
-        "@babel/helper-string-parser": "^7.24.1",
-        "@babel/helper-validator-identifier": "^7.24.5",
-        "to-fast-properties": "^2.0.0"
+        "@babel/helper-string-parser": "^7.25.9",
+        "@babel/helper-validator-identifier": "^7.25.9"
       }
     },
     "@colors/colors": {
@@ -21012,16 +21128,10 @@
         "@types/node": "*"
       }
     },
-    "@types/cookie": {
-      "version": "0.4.1",
-      "resolved": "https://registry.npmjs.org/@types/cookie/-/cookie-0.4.1.tgz",
-      "integrity": "sha512-XW/Aa8APYr6jSVVA1y/DEIZX0/GMKLEVekNG727R8cs56ahETkRAy/3DR7+fJyh7oUgGwNQaRfXCun0+KbWY7Q==",
-      "dev": true
-    },
     "@types/cors": {
-      "version": "2.8.13",
-      "resolved": "https://registry.npmjs.org/@types/cors/-/cors-2.8.13.tgz",
-      "integrity": "sha512-RG8AStHlUiV5ysZQKq97copd2UmVYw3/pRMLefISZ3S1hK104Cwm7iLQ3fTKx+lsUH2CE8FlLaYeEA2LSeqYUA==",
+      "version": "2.8.17",
+      "resolved": "https://registry.npmjs.org/@types/cors/-/cors-2.8.17.tgz",
+      "integrity": "sha512-8CGDvrBj1zgo2qE+oS3pOCyYNqCPryMWY2bGfwA0dcfopWGgxs+78df0Rs3rc9THP4JkOhLsAa+15VdpAqkcUA==",
       "dev": true,
       "requires": {
         "@types/node": "*"
@@ -21043,9 +21153,9 @@
       }
     },
     "@types/eslint-scope": {
-      "version": "3.7.4",
-      "resolved": "https://registry.npmjs.org/@types/eslint-scope/-/eslint-scope-3.7.4.tgz",
-      "integrity": "sha512-9K4zoImiZc3HlIp6AVUDE4CWYx22a+lhSZMYNpbjW04+YF0KWj4pJXnEMjdnFTiQibFFmElcsasJXDbdI/EPhA==",
+      "version": "3.7.7",
+      "resolved": "https://registry.npmjs.org/@types/eslint-scope/-/eslint-scope-3.7.7.tgz",
+      "integrity": "sha512-MzMFlSLBqNF2gcHWO0G1vP/YQyfvrxZ0bF+u7mzUdZ1/xK4A4sru+nraZz5i3iEIk1l1uyicaDVTB4QbbEkAYg==",
       "requires": {
         "@types/eslint": "*",
         "@types/estree": "*"
@@ -21619,14 +21729,15 @@
       }
     },
     "acorn": {
-      "version": "8.10.0",
-      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.10.0.tgz",
-      "integrity": "sha512-F0SAmZ8iUtS//m8DmCTA0jlh6TDKkHQyK6xc6V4KDTyZKA9dnvX9/3sRTVQrWm79glUAZbnmmNcdYwUIHWVybw=="
+      "version": "8.14.1",
+      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.14.1.tgz",
+      "integrity": "sha512-OvQ/2pUDKmgfCg++xsTX1wGxfTaszcHVcTctW4UJB4hibJx2HXxxO5UmVgyjMa+ZDsiaf5wWLXYpRWMmBI0QHg=="
     },
     "acorn-import-assertions": {
       "version": "1.9.0",
       "resolved": "https://registry.npmjs.org/acorn-import-assertions/-/acorn-import-assertions-1.9.0.tgz",
       "integrity": "sha512-cmMwop9x+8KFhxvKrKfPYmN6/pKTYYHBqLa0DfvVZcKMJWNyWLnaqND7dx/qn66R7ewM1UX5XMaDVP5wlVTaVA==",
+      "dev": true,
       "requires": {}
     },
     "acorn-jsx": {
@@ -21694,7 +21805,6 @@
       "version": "8.11.0",
       "resolved": "https://registry.npmjs.org/ajv/-/ajv-8.11.0.tgz",
       "integrity": "sha512-wGgprdCvMalC0BztXvitD2hC04YffAvtsUn93JbGXYLAtCUO4xd17mCCZQxUOItiBwZvJScWo8NIvQMQ71rdpg==",
-      "dev": true,
       "requires": {
         "fast-deep-equal": "^3.1.1",
         "json-schema-traverse": "^1.0.0",
@@ -21706,7 +21816,6 @@
       "version": "2.1.1",
       "resolved": "https://registry.npmjs.org/ajv-formats/-/ajv-formats-2.1.1.tgz",
       "integrity": "sha512-Wx0Kx52hxE7C18hkMEggYlEifqWZtYaRgouJor+WMdPnQyEK13vgEWyVNup7SoeeoLMsr4kf5h6dOW11I15MUA==",
-      "dev": true,
       "requires": {
         "ajv": "^8.0.0"
       }
@@ -21715,7 +21824,6 @@
       "version": "5.1.0",
       "resolved": "https://registry.npmjs.org/ajv-keywords/-/ajv-keywords-5.1.0.tgz",
       "integrity": "sha512-YCS/JNFAUyr5vAuhk1DWm1CBxRHW9LbJ2ozWeemrIqpbsqKjHVxYPyi5GC0rjZIT5JxJ3virVTS8wk4i/Z+krw==",
-      "dev": true,
       "requires": {
         "fast-deep-equal": "^3.1.3"
       }
@@ -21937,9 +22045,9 @@
       "dev": true
     },
     "axios": {
-      "version": "1.6.8",
-      "resolved": "https://registry.npmjs.org/axios/-/axios-1.6.8.tgz",
-      "integrity": "sha512-v/ZHtJDU39mDpyBoFVkETcd/uNdxrWRrg3bKpOKzXFA6Bvqopts6ALSMU3y6ijYxbw2B+wPrIv46egTzJXCLGQ==",
+      "version": "1.8.4",
+      "resolved": "https://registry.npmjs.org/axios/-/axios-1.8.4.tgz",
+      "integrity": "sha512-eBSYY4Y68NNlHbHBMdeDmKNtDgXWhQsJcGqzO3iLUM0GraQFSS9cVgPX5I9b3lbdFKyYoAEGAZF1DwhTaljNAw==",
       "requires": {
         "follow-redirects": "^1.15.6",
         "form-data": "^4.0.0",
@@ -22098,9 +22206,9 @@
       "dev": true
     },
     "body-parser": {
-      "version": "1.20.2",
-      "resolved": "https://registry.npmjs.org/body-parser/-/body-parser-1.20.2.tgz",
-      "integrity": "sha512-ml9pReCu3M61kGlqoTm2umSXTlRTuGTx0bfYj+uIUKKYycG5NtSbeetV3faSU6R7ajOPw0g/J1PvK4qNy7s5bA==",
+      "version": "1.20.3",
+      "resolved": "https://registry.npmjs.org/body-parser/-/body-parser-1.20.3.tgz",
+      "integrity": "sha512-7rAxByjUMqQ3/bHJy7D6OGXvx/MMc4IqBn/X0fcM1QUcAItpZrBEYhWGem+tzXH90c+G01ypMcYJBO9Y30203g==",
       "dev": true,
       "requires": {
         "bytes": "3.1.2",
@@ -22111,7 +22219,7 @@
         "http-errors": "2.0.0",
         "iconv-lite": "0.4.24",
         "on-finished": "2.4.1",
-        "qs": "6.11.0",
+        "qs": "6.13.0",
         "raw-body": "2.5.2",
         "type-is": "~1.6.18",
         "unpipe": "1.0.0"
@@ -22162,11 +22270,11 @@
       }
     },
     "braces": {
-      "version": "3.0.2",
-      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.2.tgz",
-      "integrity": "sha512-b8um+L1RzM3WDSzvhm6gIz1yfTbBt6YTlcEKAvsmqCZZFw46z626lVj9j1yEPW33H5H+lBQpZMP1k8l+78Ha0A==",
+      "version": "3.0.3",
+      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.3.tgz",
+      "integrity": "sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==",
       "requires": {
-        "fill-range": "^7.0.1"
+        "fill-range": "^7.1.1"
       }
     },
     "browser-tabs-lock": {
@@ -22178,14 +22286,14 @@
       }
     },
     "browserslist": {
-      "version": "4.23.0",
-      "resolved": "https://registry.npmjs.org/browserslist/-/browserslist-4.23.0.tgz",
-      "integrity": "sha512-QW8HiM1shhT2GuzkvklfjcKDiWFXHOeFCIA/huJPwHsslwcydgk7X+z2zXpEijP98UCY7HbubZt5J2Zgvf0CaQ==",
+      "version": "4.24.4",
+      "resolved": "https://registry.npmjs.org/browserslist/-/browserslist-4.24.4.tgz",
+      "integrity": "sha512-KDi1Ny1gSePi1vm0q4oxSF8b4DR44GF4BbmS2YdhPLOEqd8pDviZOGH/GsmRwoWJ2+5Lr085X7naowMwKHDG1A==",
       "requires": {
-        "caniuse-lite": "^1.0.30001587",
-        "electron-to-chromium": "^1.4.668",
-        "node-releases": "^2.0.14",
-        "update-browserslist-db": "^1.0.13"
+        "caniuse-lite": "^1.0.30001688",
+        "electron-to-chromium": "^1.5.73",
+        "node-releases": "^2.0.19",
+        "update-browserslist-db": "^1.1.1"
       }
     },
     "browserstack": {
@@ -22302,13 +22410,22 @@
         }
       }
     },
-    "call-bind": {
+    "call-bind-apply-helpers": {
       "version": "1.0.2",
-      "resolved": "https://registry.npmjs.org/call-bind/-/call-bind-1.0.2.tgz",
-      "integrity": "sha512-7O+FbCihrB5WGbFYesctwmTKae6rOiIzmz1icreWJ+0aA7LJfuqhEso2T9ncpcFtzMQtzXf2QGGueWJGTYsqrA==",
+      "resolved": "https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz",
+      "integrity": "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==",
+      "requires": {
+        "es-errors": "^1.3.0",
+        "function-bind": "^1.1.2"
+      }
+    },
+    "call-bound": {
+      "version": "1.0.4",
+      "resolved": "https://registry.npmjs.org/call-bound/-/call-bound-1.0.4.tgz",
+      "integrity": "sha512-+ys997U96po4Kx/ABpBCqhA9EuxJaQWDQg7295H4hBphv3IZg0boBKuwYpt4YXp6MZ5AmZQnU/tyMTlRpaSejg==",
       "requires": {
-        "function-bind": "^1.1.1",
-        "get-intrinsic": "^1.0.2"
+        "call-bind-apply-helpers": "^1.0.2",
+        "get-intrinsic": "^1.3.0"
       }
     },
     "callsites": {
@@ -22333,9 +22450,9 @@
       "dev": true
     },
     "caniuse-lite": {
-      "version": "1.0.30001618",
-      "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001618.tgz",
-      "integrity": "sha512-p407+D1tIkDvsEAPS22lJxLQQaG8OTBEqo0KhzfABGk0TU4juBNDSfH0hyAp/HRyx+M8L17z/ltyhxh27FTfQg=="
+      "version": "1.0.30001715",
+      "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001715.tgz",
+      "integrity": "sha512-7ptkFGMm2OAOgvZpwgA4yjQ5SQbrNVGdRjzH0pBdy1Fasvcr+KAeECmbCAECzTuDuoX0FCY8KzUxjf9+9kfZEw=="
     },
     "caseless": {
       "version": "0.12.0",
@@ -22710,9 +22827,9 @@
       "dev": true
     },
     "cookie": {
-      "version": "0.4.2",
-      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.4.2.tgz",
-      "integrity": "sha512-aSWTXFzaKWkvHO1Ny/s+ePFpvKsPnjc551iI41v3ny/ow6tBG5Vd+FuqGNhh1LxOmVzOlGUriIlOaokOvhaStA==",
+      "version": "0.7.2",
+      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.7.2.tgz",
+      "integrity": "sha512-yki5XnKuf750l50uGTllt6kKILY4nQ1eNIQatoXEByZ5dWgnKqbnqmTrBE5B4N7lrMJKQ2ytWMiTO2o0v6Ew/w==",
       "dev": true
     },
     "cookie-signature": {
@@ -22906,9 +23023,9 @@
       }
     },
     "cross-spawn": {
-      "version": "7.0.3",
-      "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.3.tgz",
-      "integrity": "sha512-iRDPJKUPVEND7dHPO8rkbOnPpyDygcDFtWjpeWNCgy8WP2rXcxXL8TskReQl6OrB2G7+UJrags1q15Fudc7G6w==",
+      "version": "7.0.6",
+      "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.6.tgz",
+      "integrity": "sha512-uV2QOWP2nWzsy2aMp8aRibhi9dlzF5Hgh5SHaB9OiTGEyDTiJJyx0uy51QXdyWbtAHNua4XJzUKca3OzKUd3vA==",
       "requires": {
         "path-key": "^3.1.0",
         "shebang-command": "^2.0.0",
@@ -23474,6 +23591,16 @@
         "tslib": "^2.0.3"
       }
     },
+    "dunder-proto": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz",
+      "integrity": "sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==",
+      "requires": {
+        "call-bind-apply-helpers": "^1.0.1",
+        "es-errors": "^1.3.0",
+        "gopd": "^1.2.0"
+      }
+    },
     "ecc-jsbn": {
       "version": "0.1.2",
       "resolved": "https://registry.npmjs.org/ecc-jsbn/-/ecc-jsbn-0.1.2.tgz",
@@ -23507,9 +23634,9 @@
       "dev": true
     },
     "electron-to-chromium": {
-      "version": "1.4.767",
-      "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.4.767.tgz",
-      "integrity": "sha512-nzzHfmQqBss7CE3apQHkHjXW77+8w3ubGCIoEijKCJebPufREaFETgGXWTkh32t259F3Kcq+R8MZdFdOJROgYw=="
+      "version": "1.5.141",
+      "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.5.141.tgz",
+      "integrity": "sha512-qS+qH9oqVYc1ooubTiB9l904WVyM6qNYxtOEEGReoZXw3xlqeYdFr5GclNzbkAufWgwWLEPoDi3d9MoRwwIjGw=="
     },
     "emoji-regex": {
       "version": "8.0.0",
@@ -23552,33 +23679,32 @@
       }
     },
     "engine.io": {
-      "version": "6.5.1",
-      "resolved": "https://registry.npmjs.org/engine.io/-/engine.io-6.5.1.tgz",
-      "integrity": "sha512-mGqhI+D7YxS9KJMppR6Iuo37Ed3abhU8NdfgSvJSDUafQutrN+sPTncJYTyM9+tkhSmWodKtVYGPPHyXJEwEQA==",
+      "version": "6.6.4",
+      "resolved": "https://registry.npmjs.org/engine.io/-/engine.io-6.6.4.tgz",
+      "integrity": "sha512-ZCkIjSYNDyGn0R6ewHDtXgns/Zre/NT6Agvq1/WobF7JXgFff4SeDroKiCO3fNJreU9YG429Sc81o4w5ok/W5g==",
       "dev": true,
       "requires": {
-        "@types/cookie": "^0.4.1",
         "@types/cors": "^2.8.12",
         "@types/node": ">=10.0.0",
         "accepts": "~1.3.4",
         "base64id": "2.0.0",
-        "cookie": "~0.4.1",
+        "cookie": "~0.7.2",
         "cors": "~2.8.5",
         "debug": "~4.3.1",
-        "engine.io-parser": "~5.1.0",
-        "ws": "~8.11.0"
+        "engine.io-parser": "~5.2.1",
+        "ws": "~8.17.1"
       }
     },
     "engine.io-parser": {
-      "version": "5.1.0",
-      "resolved": "https://registry.npmjs.org/engine.io-parser/-/engine.io-parser-5.1.0.tgz",
-      "integrity": "sha512-enySgNiK5tyZFynt3z7iqBR+Bto9EVVVvDFuTT0ioHCGbzirZVGDGiQjZzEp8hWl6hd5FSVytJGuScX1C1C35w==",
+      "version": "5.2.3",
+      "resolved": "https://registry.npmjs.org/engine.io-parser/-/engine.io-parser-5.2.3.tgz",
+      "integrity": "sha512-HqD3yTBfnBxIrbnM1DoD6Pcq8NECnh8d4As1Qgh0z5Gg3jRRIqijury0CL3ghu/edArpUYiYqQiDUQBIs4np3Q==",
       "dev": true
     },
     "enhanced-resolve": {
-      "version": "5.16.1",
-      "resolved": "https://registry.npmjs.org/enhanced-resolve/-/enhanced-resolve-5.16.1.tgz",
-      "integrity": "sha512-4U5pNsuDl0EhuZpq46M5xPslstkviJuhrdobaRDBk2Jy2KO37FDAJl4lb2KlNabxT0m4MTK2UHNrsAcphE8nyw==",
+      "version": "5.18.1",
+      "resolved": "https://registry.npmjs.org/enhanced-resolve/-/enhanced-resolve-5.18.1.tgz",
+      "integrity": "sha512-ZSW3ma5GkcQBIpwZTSRAI8N71Uuwgs93IezB7mf7R60tC8ZbJideoDNKjHn2O9KIlx6rkGTTEk1xUCK2E1Y2Yg==",
       "requires": {
         "graceful-fs": "^4.2.4",
         "tapable": "^2.2.0"
@@ -23637,12 +23763,30 @@
       "resolved": "https://registry.npmjs.org/es-cookie/-/es-cookie-1.3.2.tgz",
       "integrity": "sha512-UTlYYhXGLOy05P/vKVT2Ui7WtC7NiRzGtJyAKKn32g5Gvcjn7KAClLPWlipCtxIus934dFg9o9jXiBL0nP+t9Q=="
     },
+    "es-define-property": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.1.tgz",
+      "integrity": "sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g=="
+    },
+    "es-errors": {
+      "version": "1.3.0",
+      "resolved": "https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz",
+      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw=="
+    },
     "es-module-lexer": {
       "version": "0.9.3",
       "resolved": "https://registry.npmjs.org/es-module-lexer/-/es-module-lexer-0.9.3.tgz",
       "integrity": "sha512-1HQ2M2sPtxwnvOvT1ZClHyQDiggdNjURWpY2we6aMKCQiUVxTmVs2UYPLIrD84sS+kMdUwfBSylbJPwNnBrnHQ==",
       "dev": true
     },
+    "es-object-atoms": {
+      "version": "1.1.1",
+      "resolved": "https://registry.npmjs.org/es-object-atoms/-/es-object-atoms-1.1.1.tgz",
+      "integrity": "sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==",
+      "requires": {
+        "es-errors": "^1.3.0"
+      }
+    },
     "es6-promise": {
       "version": "4.2.8",
       "resolved": "https://registry.npmjs.org/es6-promise/-/es6-promise-4.2.8.tgz",
@@ -23835,9 +23979,9 @@
       "optional": true
     },
     "escalade": {
-      "version": "3.1.2",
-      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.1.2.tgz",
-      "integrity": "sha512-ErCHMCae19vR8vQGe50xIsVomy19rg6gFu3+r3jkEO46suLMWBksvVyoGgQV+jOfl84ZSOSlmv6Gxa89PmTGmA=="
+      "version": "3.2.0",
+      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.2.0.tgz",
+      "integrity": "sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA=="
     },
     "escape-html": {
       "version": "1.0.3",
@@ -24306,37 +24450,37 @@
       "dev": true
     },
     "express": {
-      "version": "4.19.2",
-      "resolved": "https://registry.npmjs.org/express/-/express-4.19.2.tgz",
-      "integrity": "sha512-5T6nhjsT+EOMzuck8JjBHARTHfMht0POzlA60WV2pMD3gyXw2LZnZ+ueGdNxG+0calOJcWKbpFcuzLZ91YWq9Q==",
+      "version": "4.21.2",
+      "resolved": "https://registry.npmjs.org/express/-/express-4.21.2.tgz",
+      "integrity": "sha512-28HqgMZAmih1Czt9ny7qr6ek2qddF4FclbMzwhCREB6OFfH+rXAnuNCwo1/wFvrtbgsQDb4kSbX9de9lFbrXnA==",
       "dev": true,
       "requires": {
         "accepts": "~1.3.8",
         "array-flatten": "1.1.1",
-        "body-parser": "1.20.2",
+        "body-parser": "1.20.3",
         "content-disposition": "0.5.4",
         "content-type": "~1.0.4",
-        "cookie": "0.6.0",
+        "cookie": "0.7.1",
         "cookie-signature": "1.0.6",
         "debug": "2.6.9",
         "depd": "2.0.0",
-        "encodeurl": "~1.0.2",
+        "encodeurl": "~2.0.0",
         "escape-html": "~1.0.3",
         "etag": "~1.8.1",
-        "finalhandler": "1.2.0",
+        "finalhandler": "1.3.1",
         "fresh": "0.5.2",
         "http-errors": "2.0.0",
-        "merge-descriptors": "1.0.1",
+        "merge-descriptors": "1.0.3",
         "methods": "~1.1.2",
         "on-finished": "2.4.1",
         "parseurl": "~1.3.3",
-        "path-to-regexp": "0.1.7",
+        "path-to-regexp": "0.1.12",
         "proxy-addr": "~2.0.7",
-        "qs": "6.11.0",
+        "qs": "6.13.0",
         "range-parser": "~1.2.1",
         "safe-buffer": "5.2.1",
-        "send": "0.18.0",
-        "serve-static": "1.15.0",
+        "send": "0.19.0",
+        "serve-static": "1.16.2",
         "setprototypeof": "1.2.0",
         "statuses": "2.0.1",
         "type-is": "~1.6.18",
@@ -24351,9 +24495,9 @@
           "dev": true
         },
         "cookie": {
-          "version": "0.6.0",
-          "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.6.0.tgz",
-          "integrity": "sha512-U71cyTamuh1CRNCfpGY6to28lxvNwPG4Guz/EVjgf3Jmzv0vlDp1atT9eS5dDjMYHucpHbWns6Lwf3BKz6svdw==",
+          "version": "0.7.1",
+          "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.7.1.tgz",
+          "integrity": "sha512-6DnInpx7SJ2AK3+CTUE/ZM0vWTUboZCegxhC2xiIydHR9jNuTAASBrfEpHhiGOZw/nX51bHt6YQl8jsGo4y/0w==",
           "dev": true
         },
         "debug": {
@@ -24365,14 +24509,20 @@
             "ms": "2.0.0"
           }
         },
+        "encodeurl": {
+          "version": "2.0.0",
+          "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz",
+          "integrity": "sha512-Q0n9HRi4m6JuGIV1eFlmvJB7ZEVxu93IrMyiMsGC0lrMJMWzRgx6WGquyfQgZVb31vhGgXnfmPNNXmxnOkRBrg==",
+          "dev": true
+        },
         "finalhandler": {
-          "version": "1.2.0",
-          "resolved": "https://registry.npmjs.org/finalhandler/-/finalhandler-1.2.0.tgz",
-          "integrity": "sha512-5uXcUVftlQMFnWC9qu/svkWv3GTd2PfUhK/3PLkYNAe7FbqJMt3515HaxE6eRL74GdsriiwujiawdaB1BpEISg==",
+          "version": "1.3.1",
+          "resolved": "https://registry.npmjs.org/finalhandler/-/finalhandler-1.3.1.tgz",
+          "integrity": "sha512-6BN9trH7bp3qvnrRyzsBz+g3lZxTNZTbVO2EV1CS0WIcDbawYVdYvGflME/9QP0h0pYlCDBCTjYa9nZzMDpyxQ==",
           "dev": true,
           "requires": {
             "debug": "2.6.9",
-            "encodeurl": "~1.0.2",
+            "encodeurl": "~2.0.0",
             "escape-html": "~1.0.3",
             "on-finished": "2.4.1",
             "parseurl": "~1.3.3",
@@ -24444,7 +24594,8 @@
     "fast-json-stable-stringify": {
       "version": "2.1.0",
       "resolved": "https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz",
-      "integrity": "sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw=="
+      "integrity": "sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==",
+      "dev": true
     },
     "fast-levenshtein": {
       "version": "2.0.6",
@@ -24539,9 +24690,9 @@
       }
     },
     "fill-range": {
-      "version": "7.0.1",
-      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.0.1.tgz",
-      "integrity": "sha512-qOo9F+dMUmC2Lcb4BbVvnKJxTPjCm+RRpe4gDuGrzkL7mEVl/djYSu2OdQ2Pa302N4oqkSg9ir6jaLWJ2USVpQ==",
+      "version": "7.1.1",
+      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.1.1.tgz",
+      "integrity": "sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==",
       "requires": {
         "to-regex-range": "^5.0.1"
       }
@@ -24713,9 +24864,9 @@
       "optional": true
     },
     "function-bind": {
-      "version": "1.1.1",
-      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.1.tgz",
-      "integrity": "sha512-yIovAzMX49sF8Yl58fSCWJ5svSLuaibPxXQJFLmBObTuCr0Mf1KiPopGM9NiFjiYBCbfaa2Fh6breQ6ANVTI0A=="
+      "version": "1.1.2",
+      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
+      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA=="
     },
     "gauge": {
       "version": "4.0.4",
@@ -24756,13 +24907,20 @@
       "dev": true
     },
     "get-intrinsic": {
-      "version": "1.1.3",
-      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.1.3.tgz",
-      "integrity": "sha512-QJVz1Tj7MS099PevUG5jvnt9tSkXN8K14dxQlikJuPt4uD9hHAHjLyLBiLR5zELelBdD9QNRAXZzsJx0WaDL9A==",
+      "version": "1.3.0",
+      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.3.0.tgz",
+      "integrity": "sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==",
       "requires": {
-        "function-bind": "^1.1.1",
-        "has": "^1.0.3",
-        "has-symbols": "^1.0.3"
+        "call-bind-apply-helpers": "^1.0.2",
+        "es-define-property": "^1.0.1",
+        "es-errors": "^1.3.0",
+        "es-object-atoms": "^1.1.1",
+        "function-bind": "^1.1.2",
+        "get-proto": "^1.0.1",
+        "gopd": "^1.2.0",
+        "has-symbols": "^1.1.0",
+        "hasown": "^2.0.2",
+        "math-intrinsics": "^1.1.0"
       }
     },
     "get-own-enumerable-property-symbols": {
@@ -24777,6 +24935,15 @@
       "integrity": "sha512-pjzuKtY64GYfWizNAJ0fr9VqttZkNiK2iS430LtIHzjBEr6bX8Am2zm4sW4Ro5wjWW5cAlRL1qAMTcXbjNAO2Q==",
       "dev": true
     },
+    "get-proto": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/get-proto/-/get-proto-1.0.1.tgz",
+      "integrity": "sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==",
+      "requires": {
+        "dunder-proto": "^1.0.1",
+        "es-object-atoms": "^1.0.0"
+      }
+    },
     "get-stream": {
       "version": "6.0.1",
       "resolved": "https://registry.npmjs.org/get-stream/-/get-stream-6.0.1.tgz",
@@ -24853,6 +25020,11 @@
         "minimist": "^1.2.5"
       }
     },
+    "gopd": {
+      "version": "1.2.0",
+      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.2.0.tgz",
+      "integrity": "sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg=="
+    },
     "graceful-fs": {
       "version": "4.2.11",
       "resolved": "https://registry.npmjs.org/graceful-fs/-/graceful-fs-4.2.11.tgz",
@@ -24947,9 +25119,9 @@
       "dev": true
     },
     "has-symbols": {
-      "version": "1.0.3",
-      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.0.3.tgz",
-      "integrity": "sha512-l3LCuF6MgDNwTDKkdYGEihYjt5pRPbEg46rtlmnSPlUbgmB8LOIrKJbYYFBSbnPaJexMKtiPO8hmeRjRz2Td+A=="
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.1.0.tgz",
+      "integrity": "sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ=="
     },
     "has-unicode": {
       "version": "2.0.1",
@@ -24957,6 +25129,14 @@
       "integrity": "sha512-8Rf9Y83NBReMnx0gFzA8JImQACstCYWUplepDa9xprwwtmgEZUF0h/i5xSA625zB/I37EtrswSST6OXxwaaIJQ==",
       "dev": true
     },
+    "hasown": {
+      "version": "2.0.2",
+      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
+      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
+      "requires": {
+        "function-bind": "^1.1.2"
+      }
+    },
     "hdr-histogram-js": {
       "version": "2.0.3",
       "resolved": "https://registry.npmjs.org/hdr-histogram-js/-/hdr-histogram-js-2.0.3.tgz",
@@ -25197,9 +25377,9 @@
       }
     },
     "http-proxy-middleware": {
-      "version": "2.0.6",
-      "resolved": "https://registry.npmjs.org/http-proxy-middleware/-/http-proxy-middleware-2.0.6.tgz",
-      "integrity": "sha512-ya/UeJ6HVBYxrgYotAZo1KvPWlgB48kUJLDePFeneHsVujFaW5WNj2NgWCAE//B1Dl02BIfYlpNgBy8Kf8Rjmw==",
+      "version": "2.0.9",
+      "resolved": "https://registry.npmjs.org/http-proxy-middleware/-/http-proxy-middleware-2.0.9.tgz",
+      "integrity": "sha512-c1IyJYLYppU574+YI7R4QyX2ystMtVXZwIdzazUIPIJsHuWNd+mho2j+bKoHftndicGj9yh+xjd+l0yj7VeT1Q==",
       "dev": true,
       "requires": {
         "@types/http-proxy": "^1.17.8",
@@ -25452,11 +25632,23 @@
       "resolved": "https://registry.npmjs.org/interpret/-/interpret-2.2.0.tgz",
       "integrity": "sha512-Ju0Bz/cEia55xDwUWEa8+olFpCiQoypjnQySseKtmjNrnps3P+xfpUmGr90T7yjlVJmOtybRvPXhKMbHr+fWnw=="
     },
-    "ip": {
-      "version": "2.0.1",
-      "resolved": "https://registry.npmjs.org/ip/-/ip-2.0.1.tgz",
-      "integrity": "sha512-lJUL9imLTNi1ZfXT+DU6rBBdbiKGBuay9B6xGSPVjUeQwaH1RIGqef8RZkUtHioLmSNpPR5M4HVKJGm1j8FWVQ==",
-      "dev": true
+    "ip-address": {
+      "version": "9.0.5",
+      "resolved": "https://registry.npmjs.org/ip-address/-/ip-address-9.0.5.tgz",
+      "integrity": "sha512-zHtQzGojZXTwZTHQqra+ETKd4Sn3vgi7uBmlPoXVWZqYvuKmtI0l/VZTjqGmJY9x88GGOaZ9+G9ES8hC4T4X8g==",
+      "dev": true,
+      "requires": {
+        "jsbn": "1.1.0",
+        "sprintf-js": "^1.1.3"
+      },
+      "dependencies": {
+        "sprintf-js": {
+          "version": "1.1.3",
+          "resolved": "https://registry.npmjs.org/sprintf-js/-/sprintf-js-1.1.3.tgz",
+          "integrity": "sha512-Oo+0REFV59/rz3gfJNKQiBlwfHaSESl1pcGyABQsnnIfWOFt6JNj5gCog2U6MLZ//IGYD+nA8nI+mTShREReaA==",
+          "dev": true
+        }
+      }
     },
     "ipaddr.js": {
       "version": "2.0.1",
@@ -25956,8 +26148,7 @@
     "json-schema-traverse": {
       "version": "1.0.0",
       "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-1.0.0.tgz",
-      "integrity": "sha512-NM8/P9n3XjXhIZn1lLhkFaACTOURQXjWhV4BA/RnOv8xvgqtqpAX9IO4mRQxSx1Rlo4tqzeqb0sOlruaOy3dug==",
-      "dev": true
+      "integrity": "sha512-NM8/P9n3XjXhIZn1lLhkFaACTOURQXjWhV4BA/RnOv8xvgqtqpAX9IO4mRQxSx1Rlo4tqzeqb0sOlruaOy3dug=="
     },
     "json-stable-stringify-without-jsonify": {
       "version": "1.0.1",
@@ -27051,6 +27242,11 @@
       "integrity": "sha512-PRsaiG84bK+AMvxziE/lCFss8juXjNaWzVbN5tXAm4XjeaS9NAHhop+PjQxz2A9h8Q4M/xGmzP8vqNwy6JeK0A==",
       "dev": true
     },
+    "math-intrinsics": {
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
+      "integrity": "sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g=="
+    },
     "mdurl": {
       "version": "1.0.1",
       "resolved": "https://registry.npmjs.org/mdurl/-/mdurl-1.0.1.tgz",
@@ -27073,9 +27269,9 @@
       }
     },
     "merge-descriptors": {
-      "version": "1.0.1",
-      "resolved": "https://registry.npmjs.org/merge-descriptors/-/merge-descriptors-1.0.1.tgz",
-      "integrity": "sha512-cCi6g3/Zr1iqQi6ySbseM1Xvooa98N0w31jzUYrXPX2xqObmFGHJ0tQ5u74H3mVh7wLouTseZyYIq39g8cNp1w==",
+      "version": "1.0.3",
+      "resolved": "https://registry.npmjs.org/merge-descriptors/-/merge-descriptors-1.0.3.tgz",
+      "integrity": "sha512-gaNvAS7TZ897/rVaZ0nMtAyxNyi/pdbjbAwUpFQpN70GqnVfOiXpeUUMKRBmzXaSQ8DdTX4/0ms62r2K+hE6mQ==",
       "dev": true
     },
     "merge-stream": {
@@ -27095,11 +27291,11 @@
       "integrity": "sha512-iclAHeNqNm68zFtnZ0e+1L2yUIdvzNoauKU4WBA3VvH/vPFieF7qfRlwUZU+DA9P9bPXIS90ulxoUoCH23sV2w=="
     },
     "micromatch": {
-      "version": "4.0.5",
-      "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-4.0.5.tgz",
-      "integrity": "sha512-DMy+ERcEW2q8Z2Po+WNXuw3c5YaUSFjAO5GsJqfEl7UjvtIuFKO6ZrKvcItdy98dwFI2N1tg3zNIdKaQT+aNdA==",
+      "version": "4.0.8",
+      "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-4.0.8.tgz",
+      "integrity": "sha512-PXwfBhYu0hBCPw8Dn0E+WDYb7af3dSLVWKi3HGv84IdF4TyFoC0ysxFd0Goxw7nSv4T/PzEJQxsYsEiFCKo2BA==",
       "requires": {
-        "braces": "^3.0.2",
+        "braces": "^3.0.3",
         "picomatch": "^2.3.1"
       }
     },
@@ -27362,9 +27558,9 @@
       "dev": true
     },
     "nanoid": {
-      "version": "3.3.4",
-      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.4.tgz",
-      "integrity": "sha512-MqBkQh/OHTS2egovRtLk45wEyNXwF+cokD+1YPf9u5VfJiRdAiRwB2froX5Co9Rh20xs4siNPm8naNotSD6RBw==",
+      "version": "3.3.11",
+      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.11.tgz",
+      "integrity": "sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==",
       "dev": true
     },
     "natural-compare": {
@@ -27518,9 +27714,9 @@
       "optional": true
     },
     "node-releases": {
-      "version": "2.0.14",
-      "resolved": "https://registry.npmjs.org/node-releases/-/node-releases-2.0.14.tgz",
-      "integrity": "sha512-y10wOWt8yZpqXmOgRo77WaHEmhYQYGNA6y421PKsKYWEK8aW+cqAphborZDhqfyKrbZEN92CN1X2KbafY2s7Yw=="
+      "version": "2.0.19",
+      "resolved": "https://registry.npmjs.org/node-releases/-/node-releases-2.0.19.tgz",
+      "integrity": "sha512-xxOWJsBKtzAq7DY0J+DTzuz58K8e7sJbdgwkbMWQe8UYB6ekmsQ45q0M/tJDsGaZmbC+l7n57UV8Hl5tHxO9uw=="
     },
     "node-source-walk": {
       "version": "4.3.0",
@@ -27770,9 +27966,9 @@
       "dev": true
     },
     "object-inspect": {
-      "version": "1.12.2",
-      "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.12.2.tgz",
-      "integrity": "sha512-z+cPxW0QGUp0mcqcsgQyLVRDoXFQbXOwBaqyF7VIgI4TWNQsDHrBpUQslRmIfAoYWdYzs6UlKJtB2XJpTaNSpQ=="
+      "version": "1.13.4",
+      "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.13.4.tgz",
+      "integrity": "sha512-W67iLl4J2EXEGTbfeHCffrjDfitvLANg0UlX3wFUUSTx92KXRFegMHUVgSqE+wvhAbi4WqjGg9czysTV2Epbew=="
     },
     "obuf": {
       "version": "1.1.2",
@@ -28138,9 +28334,9 @@
       "integrity": "sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw=="
     },
     "path-to-regexp": {
-      "version": "0.1.7",
-      "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-0.1.7.tgz",
-      "integrity": "sha512-5DFkuoqlv1uYQKxy8omFBeJPQcdoE07Kv2sferDCrAq1ohOU+MSDswDIbnx3YAM60qIOnYa53wBhXW0EbMonrQ==",
+      "version": "0.1.12",
+      "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-0.1.12.tgz",
+      "integrity": "sha512-RA1GjUVMnvYFxuqovrEqZoxxW5NUZqbwKtYz/Tt7nXerk0LbLblQmrsgdeOxV5SFHf0UDggjS/bSeOZwt1pmEQ==",
       "dev": true
     },
     "path-type": {
@@ -28156,9 +28352,9 @@
       "dev": true
     },
     "picocolors": {
-      "version": "1.0.1",
-      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.0.1.tgz",
-      "integrity": "sha512-anP1Z8qwhkbmu7MFP5iTt+wQKXgwzf7zTyGlcdzabySa9vd0Xt392U0rVmz9poOaBj0uHJKyyo9/upk0HrEQew=="
+      "version": "1.1.1",
+      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz",
+      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA=="
     },
     "picomatch": {
       "version": "2.3.1",
@@ -29232,11 +29428,11 @@
       "dev": true
     },
     "qs": {
-      "version": "6.11.0",
-      "resolved": "https://registry.npmjs.org/qs/-/qs-6.11.0.tgz",
-      "integrity": "sha512-MvjoMCJwEarSbUYk5O+nmoSzSutSsTwF85zcHPQ9OrlFoZOYIjaqBAJIqIXjptyD5vThxGq52Xu/MaJzRkIk4Q==",
+      "version": "6.13.0",
+      "resolved": "https://registry.npmjs.org/qs/-/qs-6.13.0.tgz",
+      "integrity": "sha512-+38qI9SOr8tfZ4QmJNplMUxqjbe7LKvvZgWdExBOmd+egZTtjLB67Gu0HRX3u/XOq7UU2Nx6nsjvS16Z9uwfpg==",
       "requires": {
-        "side-channel": "^1.0.4"
+        "side-channel": "^1.0.6"
       }
     },
     "queue-microtask": {
@@ -29534,8 +29730,7 @@
     "require-from-string": {
       "version": "2.0.2",
       "resolved": "https://registry.npmjs.org/require-from-string/-/require-from-string-2.0.2.tgz",
-      "integrity": "sha512-Xf0nWe6RseziFMu+Ap9biiUbmplq6S9/p+7w7YXP/JBHhrUDDUhwa+vANyubuqfZWTveU//DYVGsDG7RKL/vEw==",
-      "dev": true
+      "integrity": "sha512-Xf0nWe6RseziFMu+Ap9biiUbmplq6S9/p+7w7YXP/JBHhrUDDUhwa+vANyubuqfZWTveU//DYVGsDG7RKL/vEw=="
     },
     "require-main-filename": {
       "version": "2.0.0",
@@ -29544,9 +29739,9 @@
       "dev": true
     },
     "requirejs": {
-      "version": "2.3.6",
-      "resolved": "https://registry.npmjs.org/requirejs/-/requirejs-2.3.6.tgz",
-      "integrity": "sha512-ipEzlWQe6RK3jkzikgCupiTbTvm4S0/CAU5GlgptkN5SO6F3u0UD0K18wy6ErDqiCyP4J4YYe1HuAShvsxePLg==",
+      "version": "2.3.7",
+      "resolved": "https://registry.npmjs.org/requirejs/-/requirejs-2.3.7.tgz",
+      "integrity": "sha512-DouTG8T1WanGok6Qjg2SXuCMzszOo0eHeH9hDZ5Y4x8Je+9JB38HdTLT4/VA8OaUhBa0JPVHJ0pyBkM1z+pDsw==",
       "dev": true
     },
     "requirejs-config-file": {
@@ -29965,9 +30160,9 @@
       }
     },
     "send": {
-      "version": "0.18.0",
-      "resolved": "https://registry.npmjs.org/send/-/send-0.18.0.tgz",
-      "integrity": "sha512-qqWzuOjSFOuqPjFe4NOsMLafToQQwBSOEpS+FwEt3A2V3vKubTquT3vmLTQpFgMXp8AlFWFuP1qKaJZOtPpVXg==",
+      "version": "0.19.0",
+      "resolved": "https://registry.npmjs.org/send/-/send-0.19.0.tgz",
+      "integrity": "sha512-dW41u5VfLXu8SJh5bwRmyYUbAoSB3c9uQh6L8h/KtsFREPWpbX1lrljJo186Jc4nmci/sGUZ9a0a0J2zgfq2hw==",
       "dev": true,
       "requires": {
         "debug": "2.6.9",
@@ -30038,9 +30233,9 @@
       }
     },
     "serialize-javascript": {
-      "version": "6.0.1",
-      "resolved": "https://registry.npmjs.org/serialize-javascript/-/serialize-javascript-6.0.1.tgz",
-      "integrity": "sha512-owoXEFjWRllis8/M1Q+Cw5k8ZH40e3zhp/ovX+Xr/vi1qj6QesbyXXViFbpNvWvPNAD62SutwEXavefrLJWj7w==",
+      "version": "6.0.2",
+      "resolved": "https://registry.npmjs.org/serialize-javascript/-/serialize-javascript-6.0.2.tgz",
+      "integrity": "sha512-Saa1xPByTTq2gdeFZYLLo+RFE35NHZkAbqZeWNd3BpzppeVisAqpDjcp8dyf6uIvEqJRd46jemmyA4iFIeVk8g==",
       "requires": {
         "randombytes": "^2.1.0"
       }
@@ -30108,15 +30303,23 @@
       }
     },
     "serve-static": {
-      "version": "1.15.0",
-      "resolved": "https://registry.npmjs.org/serve-static/-/serve-static-1.15.0.tgz",
-      "integrity": "sha512-XGuRDNjXUijsUL0vl6nSD7cwURuzEgglbOaFuZM9g3kwDXOWVTck0jLzjPzGD+TazWbboZYu52/9/XPdUgne9g==",
+      "version": "1.16.2",
+      "resolved": "https://registry.npmjs.org/serve-static/-/serve-static-1.16.2.tgz",
+      "integrity": "sha512-VqpjJZKadQB/PEbEwvFdO43Ax5dFBZ2UECszz8bQ7pi7wt//PWe1P6MN7eCnjsatYtBT6EuiClbjSWP2WrIoTw==",
       "dev": true,
       "requires": {
-        "encodeurl": "~1.0.2",
+        "encodeurl": "~2.0.0",
         "escape-html": "~1.0.3",
         "parseurl": "~1.3.3",
-        "send": "0.18.0"
+        "send": "0.19.0"
+      },
+      "dependencies": {
+        "encodeurl": {
+          "version": "2.0.0",
+          "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz",
+          "integrity": "sha512-Q0n9HRi4m6JuGIV1eFlmvJB7ZEVxu93IrMyiMsGC0lrMJMWzRgx6WGquyfQgZVb31vhGgXnfmPNNXmxnOkRBrg==",
+          "dev": true
+        }
       }
     },
     "set-blocking": {
@@ -30159,13 +30362,47 @@
       "integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A=="
     },
     "side-channel": {
-      "version": "1.0.4",
-      "resolved": "https://registry.npmjs.org/side-channel/-/side-channel-1.0.4.tgz",
-      "integrity": "sha512-q5XPytqFEIKHkGdiMIrY10mvLRvnQh42/+GoBlFW3b2LXLE2xxJpZFdm94we0BaoV3RwJyGqg5wS7epxTv0Zvw==",
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/side-channel/-/side-channel-1.1.0.tgz",
+      "integrity": "sha512-ZX99e6tRweoUXqR+VBrslhda51Nh5MTQwou5tnUDgbtyM0dBgmhEDtWGP/xbKn6hqfPRHujUNwz5fy/wbbhnpw==",
+      "requires": {
+        "es-errors": "^1.3.0",
+        "object-inspect": "^1.13.3",
+        "side-channel-list": "^1.0.0",
+        "side-channel-map": "^1.0.1",
+        "side-channel-weakmap": "^1.0.2"
+      }
+    },
+    "side-channel-list": {
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/side-channel-list/-/side-channel-list-1.0.0.tgz",
+      "integrity": "sha512-FCLHtRD/gnpCiCHEiJLOwdmFP+wzCmDEkc9y7NsYxeF4u7Btsn1ZuwgwJGxImImHicJArLP4R0yX4c2KCrMrTA==",
+      "requires": {
+        "es-errors": "^1.3.0",
+        "object-inspect": "^1.13.3"
+      }
+    },
+    "side-channel-map": {
+      "version": "1.0.1",
+      "resolved": "https://registry.npmjs.org/side-channel-map/-/side-channel-map-1.0.1.tgz",
+      "integrity": "sha512-VCjCNfgMsby3tTdo02nbjtM/ewra6jPHmpThenkTYh8pG9ucZ/1P8So4u4FGBek/BjpOVsDCMoLA/iuBKIFXRA==",
       "requires": {
-        "call-bind": "^1.0.0",
-        "get-intrinsic": "^1.0.2",
-        "object-inspect": "^1.9.0"
+        "call-bound": "^1.0.2",
+        "es-errors": "^1.3.0",
+        "get-intrinsic": "^1.2.5",
+        "object-inspect": "^1.13.3"
+      }
+    },
+    "side-channel-weakmap": {
+      "version": "1.0.2",
+      "resolved": "https://registry.npmjs.org/side-channel-weakmap/-/side-channel-weakmap-1.0.2.tgz",
+      "integrity": "sha512-WPS/HvHQTYnHisLo9McqBHOJk2FkHO/tlpvldyrnem4aeQp4hai3gythswg6p01oSoTl58rcpiFAjF2br2Ak2A==",
+      "requires": {
+        "call-bound": "^1.0.2",
+        "es-errors": "^1.3.0",
+        "get-intrinsic": "^1.2.5",
+        "object-inspect": "^1.13.3",
+        "side-channel-map": "^1.0.1"
       }
     },
     "signal-exit": {
@@ -30195,27 +30432,28 @@
       }
     },
     "socket.io": {
-      "version": "4.7.1",
-      "resolved": "https://registry.npmjs.org/socket.io/-/socket.io-4.7.1.tgz",
-      "integrity": "sha512-W+utHys2w//dhFjy7iQQu9sGd3eokCjGbl2r59tyLqNiJJBdIebn3GAKEXBr3osqHTObJi2die/25bCx2zsaaw==",
+      "version": "4.8.1",
+      "resolved": "https://registry.npmjs.org/socket.io/-/socket.io-4.8.1.tgz",
+      "integrity": "sha512-oZ7iUCxph8WYRHHcjBEc9unw3adt5CmSNlppj/5Q4k2RIrhl8Z5yY2Xr4j9zj0+wzVZ0bxmYoGSzKJnRl6A4yg==",
       "dev": true,
       "requires": {
         "accepts": "~1.3.4",
         "base64id": "~2.0.0",
         "cors": "~2.8.5",
         "debug": "~4.3.2",
-        "engine.io": "~6.5.0",
+        "engine.io": "~6.6.0",
         "socket.io-adapter": "~2.5.2",
         "socket.io-parser": "~4.2.4"
       }
     },
     "socket.io-adapter": {
-      "version": "2.5.2",
-      "resolved": "https://registry.npmjs.org/socket.io-adapter/-/socket.io-adapter-2.5.2.tgz",
-      "integrity": "sha512-87C3LO/NOMc+eMcpcxUBebGjkpMDkNBS9tf7KJqcDsmL936EChtVva71Dw2q4tQcuVC+hAUy4an2NO/sYXmwRA==",
+      "version": "2.5.5",
+      "resolved": "https://registry.npmjs.org/socket.io-adapter/-/socket.io-adapter-2.5.5.tgz",
+      "integrity": "sha512-eLDQas5dzPgOWCk9GuuJC2lBqItuhKI4uxGgo9aIV7MYbk2h9Q6uULEh8WBzThoI7l+qU9Ast9fVUmkqPP9wYg==",
       "dev": true,
       "requires": {
-        "ws": "~8.11.0"
+        "debug": "~4.3.4",
+        "ws": "~8.17.1"
       }
     },
     "socket.io-parser": {
@@ -30240,12 +30478,12 @@
       }
     },
     "socks": {
-      "version": "2.7.1",
-      "resolved": "https://registry.npmjs.org/socks/-/socks-2.7.1.tgz",
-      "integrity": "sha512-7maUZy1N7uo6+WVEX6psASxtNlKaNVMlGQKkG/63nEDdLOWNbiUMoLK7X4uYoLhQstau72mLgfEWcXcwsaHbYQ==",
+      "version": "2.8.4",
+      "resolved": "https://registry.npmjs.org/socks/-/socks-2.8.4.tgz",
+      "integrity": "sha512-D3YaD0aRxR3mEcqnidIs7ReYJFVzWdd6fXJYUM8ixcQcJRGTka/b3saV0KflYhyVJXKhb947GndU35SxYNResQ==",
       "dev": true,
       "requires": {
-        "ip": "^2.0.0",
+        "ip-address": "^9.0.5",
         "smart-buffer": "^4.2.0"
       }
     },
@@ -30690,58 +30928,37 @@
       }
     },
     "terser-webpack-plugin": {
-      "version": "5.3.10",
-      "resolved": "https://registry.npmjs.org/terser-webpack-plugin/-/terser-webpack-plugin-5.3.10.tgz",
-      "integrity": "sha512-BKFPWlPDndPs+NGGCr1U59t0XScL5317Y0UReNrHaw9/FwhPENlq6bfgs+4yPfyP51vqC1bQ4rp1EfXW5ZSH9w==",
+      "version": "5.3.14",
+      "resolved": "https://registry.npmjs.org/terser-webpack-plugin/-/terser-webpack-plugin-5.3.14.tgz",
+      "integrity": "sha512-vkZjpUjb6OMS7dhV+tILUW6BhpDR7P2L/aQSAv+Uwk+m8KATX9EccViHTJR2qDtACKPIYndLGCyl3FMo+r2LMw==",
       "requires": {
-        "@jridgewell/trace-mapping": "^0.3.20",
+        "@jridgewell/trace-mapping": "^0.3.25",
         "jest-worker": "^27.4.5",
-        "schema-utils": "^3.1.1",
-        "serialize-javascript": "^6.0.1",
-        "terser": "^5.26.0"
+        "schema-utils": "^4.3.0",
+        "serialize-javascript": "^6.0.2",
+        "terser": "^5.31.1"
       },
       "dependencies": {
-        "ajv": {
-          "version": "6.12.6",
-          "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz",
-          "integrity": "sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==",
-          "requires": {
-            "fast-deep-equal": "^3.1.1",
-            "fast-json-stable-stringify": "^2.0.0",
-            "json-schema-traverse": "^0.4.1",
-            "uri-js": "^4.2.2"
-          }
-        },
-        "ajv-keywords": {
-          "version": "3.5.2",
-          "resolved": "https://registry.npmjs.org/ajv-keywords/-/ajv-keywords-3.5.2.tgz",
-          "integrity": "sha512-5p6WTN0DdTGVQk6VjcEju19IgaHudalcfabD7yhDGeA6bcQnmL+CpveLJq/3hvfwd1aof6L386Ougkx6RfyMIQ==",
-          "requires": {}
-        },
         "commander": {
           "version": "2.20.3",
           "resolved": "https://registry.npmjs.org/commander/-/commander-2.20.3.tgz",
           "integrity": "sha512-GpVkmM8vF2vQUkj2LvZmD35JxeJOLCwJ9cUkugyk2nuhbv3+mJvpLYYt+0+USMxE+oj+ey/lJEnhZw75x/OMcQ=="
         },
-        "json-schema-traverse": {
-          "version": "0.4.1",
-          "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
-          "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg=="
-        },
         "schema-utils": {
-          "version": "3.1.1",
-          "resolved": "https://registry.npmjs.org/schema-utils/-/schema-utils-3.1.1.tgz",
-          "integrity": "sha512-Y5PQxS4ITlC+EahLuXaY86TXfR7Dc5lw294alXOq86JAHCihAIZfqv8nNCWvaEJvaC51uN9hbLGeV0cFBdH+Fw==",
+          "version": "4.3.2",
+          "resolved": "https://registry.npmjs.org/schema-utils/-/schema-utils-4.3.2.tgz",
+          "integrity": "sha512-Gn/JaSk/Mt9gYubxTtSn/QCV4em9mpAPiR1rqy/Ocu19u/G9J5WWdNoUT4SiV6mFC3y6cxyFcFwdzPM3FgxGAQ==",
           "requires": {
-            "@types/json-schema": "^7.0.8",
-            "ajv": "^6.12.5",
-            "ajv-keywords": "^3.5.2"
+            "@types/json-schema": "^7.0.9",
+            "ajv": "^8.9.0",
+            "ajv-formats": "^2.1.1",
+            "ajv-keywords": "^5.1.0"
           }
         },
         "terser": {
-          "version": "5.31.0",
-          "resolved": "https://registry.npmjs.org/terser/-/terser-5.31.0.tgz",
-          "integrity": "sha512-Q1JFAoUKE5IMfI4Z/lkE/E6+SwgzO+x4tq4v1AyBLRj8VSYvRO6A/rQrPg1yud4g0En9EKI1TvFRF2tQFcoUkg==",
+          "version": "5.39.0",
+          "resolved": "https://registry.npmjs.org/terser/-/terser-5.39.0.tgz",
+          "integrity": "sha512-LBAhFyLho16harJoWMg/nZsQYgTrg5jXOn2nCYjRUcZZEdE3qa2zb8QEDRUGVZBW4rlazf2fxkg8tztybTaqWw==",
           "requires": {
             "@jridgewell/source-map": "^0.3.3",
             "acorn": "^8.8.2",
@@ -30846,12 +31063,6 @@
         "os-tmpdir": "~1.0.2"
       }
     },
-    "to-fast-properties": {
-      "version": "2.0.0",
-      "resolved": "https://registry.npmjs.org/to-fast-properties/-/to-fast-properties-2.0.0.tgz",
-      "integrity": "sha512-/OaKK0xYrs3DmxRYqL/yDc+FxFUVYhDlXMhRmv3z915w2HF1tnN1omB354j8VUGO/hbRzyD6Y3sA7v7GS/ceog==",
-      "dev": true
-    },
     "to-regex-range": {
       "version": "5.0.1",
       "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
@@ -31220,12 +31431,12 @@
       "dev": true
     },
     "update-browserslist-db": {
-      "version": "1.0.16",
-      "resolved": "https://registry.npmjs.org/update-browserslist-db/-/update-browserslist-db-1.0.16.tgz",
-      "integrity": "sha512-KVbTxlBYlckhF5wgfyZXTWnMn7MMZjMu9XG8bPlliUOP9ThaF4QnhP8qrjrH7DRzHfSk0oQv1wToW+iA5GajEQ==",
+      "version": "1.1.3",
+      "resolved": "https://registry.npmjs.org/update-browserslist-db/-/update-browserslist-db-1.1.3.tgz",
+      "integrity": "sha512-UxhIZQ+QInVdunkDAaiazvvT/+fXL5Osr0JZlJulepYu6Jd7qJtDZjlur0emRlT71EN3ScPoE7gvsuIKKNavKw==",
       "requires": {
-        "escalade": "^3.1.2",
-        "picocolors": "^1.0.1"
+        "escalade": "^3.2.0",
+        "picocolors": "^1.1.1"
       }
     },
     "upper-case": {
@@ -31491,20 +31702,19 @@
       "integrity": "sha512-cmO2aPd6gR6bK/ttdk8ZIypJfZMOcTvsvXv/LxXZjAFu5TC6vXqFrZYudlPuKxVsA34Pc8Fysq2rCnflu+wuuA=="
     },
     "webpack": {
-      "version": "5.91.0",
-      "resolved": "https://registry.npmjs.org/webpack/-/webpack-5.91.0.tgz",
-      "integrity": "sha512-rzVwlLeBWHJbmgTC/8TvAcu5vpJNII+MelQpylD4jNERPwpBJOE2lEcko1zJX3QJeLjTTAnQxn/OJ8bjDzVQaw==",
-      "requires": {
-        "@types/eslint-scope": "^3.7.3",
-        "@types/estree": "^1.0.5",
-        "@webassemblyjs/ast": "^1.12.1",
-        "@webassemblyjs/wasm-edit": "^1.12.1",
-        "@webassemblyjs/wasm-parser": "^1.12.1",
-        "acorn": "^8.7.1",
-        "acorn-import-assertions": "^1.9.0",
-        "browserslist": "^4.21.10",
+      "version": "5.99.6",
+      "resolved": "https://registry.npmjs.org/webpack/-/webpack-5.99.6.tgz",
+      "integrity": "sha512-TJOLrJ6oeccsGWPl7ujCYuc0pIq2cNsuD6GZDma8i5o5Npvcco/z+NKvZSFsP0/x6SShVb0+X2JK/JHUjKY9dQ==",
+      "requires": {
+        "@types/eslint-scope": "^3.7.7",
+        "@types/estree": "^1.0.6",
+        "@webassemblyjs/ast": "^1.14.1",
+        "@webassemblyjs/wasm-edit": "^1.14.1",
+        "@webassemblyjs/wasm-parser": "^1.14.1",
+        "acorn": "^8.14.0",
+        "browserslist": "^4.24.0",
         "chrome-trace-event": "^1.0.2",
-        "enhanced-resolve": "^5.16.0",
+        "enhanced-resolve": "^5.17.1",
         "es-module-lexer": "^1.2.1",
         "eslint-scope": "5.1.1",
         "events": "^3.2.0",
@@ -31514,184 +31724,163 @@
         "loader-runner": "^4.2.0",
         "mime-types": "^2.1.27",
         "neo-async": "^2.6.2",
-        "schema-utils": "^3.2.0",
+        "schema-utils": "^4.3.0",
         "tapable": "^2.1.1",
-        "terser-webpack-plugin": "^5.3.10",
+        "terser-webpack-plugin": "^5.3.11",
         "watchpack": "^2.4.1",
         "webpack-sources": "^3.2.3"
       },
       "dependencies": {
         "@types/estree": {
-          "version": "1.0.5",
-          "resolved": "https://registry.npmjs.org/@types/estree/-/estree-1.0.5.tgz",
-          "integrity": "sha512-/kYRxGDLWzHOB7q+wtSUQlFrtcdUccpfy+X+9iMBpHK8QLLhx2wIPYuS5DYtR9Wa/YlZAbIovy7qVdB1Aq6Lyw=="
+          "version": "1.0.7",
+          "resolved": "https://registry.npmjs.org/@types/estree/-/estree-1.0.7.tgz",
+          "integrity": "sha512-w28IoSUCJpidD/TGviZwwMJckNESJZXFu7NBZ5YJ4mEUnNraUn9Pm8HSZm/jDF1pDWYKspWE7oVphigUPRakIQ=="
         },
         "@webassemblyjs/ast": {
-          "version": "1.12.1",
-          "resolved": "https://registry.npmjs.org/@webassemblyjs/ast/-/ast-1.12.1.tgz",
-          "integrity": "sha512-EKfMUOPRRUTy5UII4qJDGPpqfwjOmZ5jeGFwid9mnoqIFK+e0vqoi1qH56JpmZSzEL53jKnNzScdmftJyG5xWg==",
+          "version": "1.14.1",
+          "resolved": "https://registry.npmjs.org/@webassemblyjs/ast/-/ast-1.14.1.tgz",
+          "integrity": "sha512-nuBEDgQfm1ccRp/8bCQrx1frohyufl4JlbMMZ4P1wpeOfDhF6FQkxZJ1b/e+PLwr6X1Nhw6OLme5usuBWYBvuQ==",
           "requires": {
-            "@webassemblyjs/helper-numbers": "1.11.6",
-            "@webassemblyjs/helper-wasm-bytecode": "1.11.6"
+            "@webassemblyjs/helper-numbers": "1.13.2",
+            "@webassemblyjs/helper-wasm-bytecode": "1.13.2"
           }
         },
         "@webassemblyjs/floating-point-hex-parser": {
-          "version": "1.11.6",
-          "resolved": "https://registry.npmjs.org/@webassemblyjs/floating-point-hex-parser/-/floating-point-hex-parser-1.11.6.tgz",
-          "integrity": "sha512-ejAj9hfRJ2XMsNHk/v6Fu2dGS+i4UaXBXGemOfQ/JfQ6mdQg/WXtwleQRLLS4OvfDhv8rYnVwH27YJLMyYsxhw=="
+          "version": "1.13.2",
+          "resolved": "https://registry.npmjs.org/@webassemblyjs/floating-point-hex-parser/-/floating-point-hex-parser-1.13.2.tgz",
+          "integrity": "sha512-6oXyTOzbKxGH4steLbLNOu71Oj+C8Lg34n6CqRvqfS2O71BxY6ByfMDRhBytzknj9yGUPVJ1qIKhRlAwO1AovA=="
         },
         "@webassemblyjs/helper-api-error": {
-          "version": "1.11.6",
-          "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-api-error/-/helper-api-error-1.11.6.tgz",
-          "integrity": "sha512-o0YkoP4pVu4rN8aTJgAyj9hC2Sv5UlkzCHhxqWj8butaLvnpdc2jOwh4ewE6CX0txSfLn/UYaV/pheS2Txg//Q=="
+          "version": "1.13.2",
+          "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-api-error/-/helper-api-error-1.13.2.tgz",
+          "integrity": "sha512-U56GMYxy4ZQCbDZd6JuvvNV/WFildOjsaWD3Tzzvmw/mas3cXzRJPMjP83JqEsgSbyrmaGjBfDtV7KDXV9UzFQ=="
         },
         "@webassemblyjs/helper-buffer": {
-          "version": "1.12.1",
-          "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-buffer/-/helper-buffer-1.12.1.tgz",
-          "integrity": "sha512-nzJwQw99DNDKr9BVCOZcLuJJUlqkJh+kVzVl6Fmq/tI5ZtEyWT1KZMyOXltXLZJmDtvLCDgwsyrkohEtopTXCw=="
+          "version": "1.14.1",
+          "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-buffer/-/helper-buffer-1.14.1.tgz",
+          "integrity": "sha512-jyH7wtcHiKssDtFPRB+iQdxlDf96m0E39yb0k5uJVhFGleZFoNw1c4aeIcVUPPbXUVJ94wwnMOAqUHyzoEPVMA=="
         },
         "@webassemblyjs/helper-numbers": {
-          "version": "1.11.6",
-          "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-numbers/-/helper-numbers-1.11.6.tgz",
-          "integrity": "sha512-vUIhZ8LZoIWHBohiEObxVm6hwP034jwmc9kuq5GdHZH0wiLVLIPcMCdpJzG4C11cHoQ25TFIQj9kaVADVX7N3g==",
+          "version": "1.13.2",
+          "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-numbers/-/helper-numbers-1.13.2.tgz",
+          "integrity": "sha512-FE8aCmS5Q6eQYcV3gI35O4J789wlQA+7JrqTTpJqn5emA4U2hvwJmvFRC0HODS+3Ye6WioDklgd6scJ3+PLnEA==",
           "requires": {
-            "@webassemblyjs/floating-point-hex-parser": "1.11.6",
-            "@webassemblyjs/helper-api-error": "1.11.6",
+            "@webassemblyjs/floating-point-hex-parser": "1.13.2",
+            "@webassemblyjs/helper-api-error": "1.13.2",
             "@xtuc/long": "4.2.2"
           }
         },
         "@webassemblyjs/helper-wasm-bytecode": {
-          "version": "1.11.6",
-          "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-wasm-bytecode/-/helper-wasm-bytecode-1.11.6.tgz",
-          "integrity": "sha512-sFFHKwcmBprO9e7Icf0+gddyWYDViL8bpPjJJl0WHxCdETktXdmtWLGVzoHbqUcY4Be1LkNfwTmXOJUFZYSJdA=="
+          "version": "1.13.2",
+          "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-wasm-bytecode/-/helper-wasm-bytecode-1.13.2.tgz",
+          "integrity": "sha512-3QbLKy93F0EAIXLh0ogEVR6rOubA9AoZ+WRYhNbFyuB70j3dRdwH9g+qXhLAO0kiYGlg3TxDV+I4rQTr/YNXkA=="
         },
         "@webassemblyjs/helper-wasm-section": {
-          "version": "1.12.1",
-          "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-wasm-section/-/helper-wasm-section-1.12.1.tgz",
-          "integrity": "sha512-Jif4vfB6FJlUlSbgEMHUyk1j234GTNG9dBJ4XJdOySoj518Xj0oGsNi59cUQF4RRMS9ouBUxDDdyBVfPTypa5g==",
+          "version": "1.14.1",
+          "resolved": "https://registry.npmjs.org/@webassemblyjs/helper-wasm-section/-/helper-wasm-section-1.14.1.tgz",
+          "integrity": "sha512-ds5mXEqTJ6oxRoqjhWDU83OgzAYjwsCV8Lo/N+oRsNDmx/ZDpqalmrtgOMkHwxsG0iI//3BwWAErYRHtgn0dZw==",
           "requires": {
-            "@webassemblyjs/ast": "1.12.1",
-            "@webassemblyjs/helper-buffer": "1.12.1",
-            "@webassemblyjs/helper-wasm-bytecode": "1.11.6",
-            "@webassemblyjs/wasm-gen": "1.12.1"
+            "@webassemblyjs/ast": "1.14.1",
+            "@webassemblyjs/helper-buffer": "1.14.1",
+            "@webassemblyjs/helper-wasm-bytecode": "1.13.2",
+            "@webassemblyjs/wasm-gen": "1.14.1"
           }
         },
         "@webassemblyjs/ieee754": {
-          "version": "1.11.6",
-          "resolved": "https://registry.npmjs.org/@webassemblyjs/ieee754/-/ieee754-1.11.6.tgz",
-          "integrity": "sha512-LM4p2csPNvbij6U1f19v6WR56QZ8JcHg3QIJTlSwzFcmx6WSORicYj6I63f9yU1kEUtrpG+kjkiIAkevHpDXrg==",
+          "version": "1.13.2",
+          "resolved": "https://registry.npmjs.org/@webassemblyjs/ieee754/-/ieee754-1.13.2.tgz",
+          "integrity": "sha512-4LtOzh58S/5lX4ITKxnAK2USuNEvpdVV9AlgGQb8rJDHaLeHciwG4zlGr0j/SNWlr7x3vO1lDEsuePvtcDNCkw==",
           "requires": {
             "@xtuc/ieee754": "^1.2.0"
           }
         },
         "@webassemblyjs/leb128": {
-          "version": "1.11.6",
-          "resolved": "https://registry.npmjs.org/@webassemblyjs/leb128/-/leb128-1.11.6.tgz",
-          "integrity": "sha512-m7a0FhE67DQXgouf1tbN5XQcdWoNgaAuoULHIfGFIEVKA6tu/edls6XnIlkmS6FrXAquJRPni3ZZKjw6FSPjPQ==",
+          "version": "1.13.2",
+          "resolved": "https://registry.npmjs.org/@webassemblyjs/leb128/-/leb128-1.13.2.tgz",
+          "integrity": "sha512-Lde1oNoIdzVzdkNEAWZ1dZ5orIbff80YPdHx20mrHwHrVNNTjNr8E3xz9BdpcGqRQbAEa+fkrCb+fRFTl/6sQw==",
           "requires": {
             "@xtuc/long": "4.2.2"
           }
         },
         "@webassemblyjs/utf8": {
-          "version": "1.11.6",
-          "resolved": "https://registry.npmjs.org/@webassemblyjs/utf8/-/utf8-1.11.6.tgz",
-          "integrity": "sha512-vtXf2wTQ3+up9Zsg8sa2yWiQpzSsMyXj0qViVP6xKGCUT8p8YJ6HqI7l5eCnWx1T/FYdsv07HQs2wTFbbof/RA=="
+          "version": "1.13.2",
+          "resolved": "https://registry.npmjs.org/@webassemblyjs/utf8/-/utf8-1.13.2.tgz",
+          "integrity": "sha512-3NQWGjKTASY1xV5m7Hr0iPeXD9+RDobLll3T9d2AO+g3my8xy5peVyjSag4I50mR1bBSN/Ct12lo+R9tJk0NZQ=="
         },
         "@webassemblyjs/wasm-edit": {
-          "version": "1.12.1",
-          "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-edit/-/wasm-edit-1.12.1.tgz",
-          "integrity": "sha512-1DuwbVvADvS5mGnXbE+c9NfA8QRcZ6iKquqjjmR10k6o+zzsRVesil54DKexiowcFCPdr/Q0qaMgB01+SQ1u6g==",
+          "version": "1.14.1",
+          "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-edit/-/wasm-edit-1.14.1.tgz",
+          "integrity": "sha512-RNJUIQH/J8iA/1NzlE4N7KtyZNHi3w7at7hDjvRNm5rcUXa00z1vRz3glZoULfJ5mpvYhLybmVcwcjGrC1pRrQ==",
           "requires": {
-            "@webassemblyjs/ast": "1.12.1",
-            "@webassemblyjs/helper-buffer": "1.12.1",
-            "@webassemblyjs/helper-wasm-bytecode": "1.11.6",
-            "@webassemblyjs/helper-wasm-section": "1.12.1",
-            "@webassemblyjs/wasm-gen": "1.12.1",
-            "@webassemblyjs/wasm-opt": "1.12.1",
-            "@webassemblyjs/wasm-parser": "1.12.1",
-            "@webassemblyjs/wast-printer": "1.12.1"
+            "@webassemblyjs/ast": "1.14.1",
+            "@webassemblyjs/helper-buffer": "1.14.1",
+            "@webassemblyjs/helper-wasm-bytecode": "1.13.2",
+            "@webassemblyjs/helper-wasm-section": "1.14.1",
+            "@webassemblyjs/wasm-gen": "1.14.1",
+            "@webassemblyjs/wasm-opt": "1.14.1",
+            "@webassemblyjs/wasm-parser": "1.14.1",
+            "@webassemblyjs/wast-printer": "1.14.1"
           }
         },
         "@webassemblyjs/wasm-gen": {
-          "version": "1.12.1",
-          "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-gen/-/wasm-gen-1.12.1.tgz",
-          "integrity": "sha512-TDq4Ojh9fcohAw6OIMXqiIcTq5KUXTGRkVxbSo1hQnSy6lAM5GSdfwWeSxpAo0YzgsgF182E/U0mDNhuA0tW7w==",
+          "version": "1.14.1",
+          "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-gen/-/wasm-gen-1.14.1.tgz",
+          "integrity": "sha512-AmomSIjP8ZbfGQhumkNvgC33AY7qtMCXnN6bL2u2Js4gVCg8fp735aEiMSBbDR7UQIj90n4wKAFUSEd0QN2Ukg==",
           "requires": {
-            "@webassemblyjs/ast": "1.12.1",
-            "@webassemblyjs/helper-wasm-bytecode": "1.11.6",
-            "@webassemblyjs/ieee754": "1.11.6",
-            "@webassemblyjs/leb128": "1.11.6",
-            "@webassemblyjs/utf8": "1.11.6"
+            "@webassemblyjs/ast": "1.14.1",
+            "@webassemblyjs/helper-wasm-bytecode": "1.13.2",
+            "@webassemblyjs/ieee754": "1.13.2",
+            "@webassemblyjs/leb128": "1.13.2",
+            "@webassemblyjs/utf8": "1.13.2"
           }
         },
         "@webassemblyjs/wasm-opt": {
-          "version": "1.12.1",
-          "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-opt/-/wasm-opt-1.12.1.tgz",
-          "integrity": "sha512-Jg99j/2gG2iaz3hijw857AVYekZe2SAskcqlWIZXjji5WStnOpVoat3gQfT/Q5tb2djnCjBtMocY/Su1GfxPBg==",
+          "version": "1.14.1",
+          "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-opt/-/wasm-opt-1.14.1.tgz",
+          "integrity": "sha512-PTcKLUNvBqnY2U6E5bdOQcSM+oVP/PmrDY9NzowJjislEjwP/C4an2303MCVS2Mg9d3AJpIGdUFIQQWbPds0Sw==",
           "requires": {
-            "@webassemblyjs/ast": "1.12.1",
-            "@webassemblyjs/helper-buffer": "1.12.1",
-            "@webassemblyjs/wasm-gen": "1.12.1",
-            "@webassemblyjs/wasm-parser": "1.12.1"
+            "@webassemblyjs/ast": "1.14.1",
+            "@webassemblyjs/helper-buffer": "1.14.1",
+            "@webassemblyjs/wasm-gen": "1.14.1",
+            "@webassemblyjs/wasm-parser": "1.14.1"
           }
         },
         "@webassemblyjs/wasm-parser": {
-          "version": "1.12.1",
-          "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-parser/-/wasm-parser-1.12.1.tgz",
-          "integrity": "sha512-xikIi7c2FHXysxXe3COrVUPSheuBtpcfhbpFj4gmu7KRLYOzANztwUU0IbsqvMqzuNK2+glRGWCEqZo1WCLyAQ==",
+          "version": "1.14.1",
+          "resolved": "https://registry.npmjs.org/@webassemblyjs/wasm-parser/-/wasm-parser-1.14.1.tgz",
+          "integrity": "sha512-JLBl+KZ0R5qB7mCnud/yyX08jWFw5MsoalJ1pQ4EdFlgj9VdXKGuENGsiCIjegI1W7p91rUlcB/LB5yRJKNTcQ==",
           "requires": {
-            "@webassemblyjs/ast": "1.12.1",
-            "@webassemblyjs/helper-api-error": "1.11.6",
-            "@webassemblyjs/helper-wasm-bytecode": "1.11.6",
-            "@webassemblyjs/ieee754": "1.11.6",
-            "@webassemblyjs/leb128": "1.11.6",
-            "@webassemblyjs/utf8": "1.11.6"
+            "@webassemblyjs/ast": "1.14.1",
+            "@webassemblyjs/helper-api-error": "1.13.2",
+            "@webassemblyjs/helper-wasm-bytecode": "1.13.2",
+            "@webassemblyjs/ieee754": "1.13.2",
+            "@webassemblyjs/leb128": "1.13.2",
+            "@webassemblyjs/utf8": "1.13.2"
           }
         },
         "@webassemblyjs/wast-printer": {
-          "version": "1.12.1",
-          "resolved": "https://registry.npmjs.org/@webassemblyjs/wast-printer/-/wast-printer-1.12.1.tgz",
-          "integrity": "sha512-+X4WAlOisVWQMikjbcvY2e0rwPsKQ9F688lksZhBcPycBBuii3O7m8FACbDMWDojpAqvjIncrG8J0XHKyQfVeA==",
+          "version": "1.14.1",
+          "resolved": "https://registry.npmjs.org/@webassemblyjs/wast-printer/-/wast-printer-1.14.1.tgz",
+          "integrity": "sha512-kPSSXE6De1XOR820C90RIo2ogvZG+c3KiHzqUoO/F34Y2shGzesfqv7o57xrxovZJH/MetF5UjroJ/R/3isoiw==",
           "requires": {
-            "@webassemblyjs/ast": "1.12.1",
+            "@webassemblyjs/ast": "1.14.1",
             "@xtuc/long": "4.2.2"
           }
         },
-        "ajv": {
-          "version": "6.12.6",
-          "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz",
-          "integrity": "sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==",
-          "requires": {
-            "fast-deep-equal": "^3.1.1",
-            "fast-json-stable-stringify": "^2.0.0",
-            "json-schema-traverse": "^0.4.1",
-            "uri-js": "^4.2.2"
-          }
-        },
-        "ajv-keywords": {
-          "version": "3.5.2",
-          "resolved": "https://registry.npmjs.org/ajv-keywords/-/ajv-keywords-3.5.2.tgz",
-          "integrity": "sha512-5p6WTN0DdTGVQk6VjcEju19IgaHudalcfabD7yhDGeA6bcQnmL+CpveLJq/3hvfwd1aof6L386Ougkx6RfyMIQ==",
-          "requires": {}
-        },
         "es-module-lexer": {
           "version": "1.3.0",
           "resolved": "https://registry.npmjs.org/es-module-lexer/-/es-module-lexer-1.3.0.tgz",
           "integrity": "sha512-vZK7T0N2CBmBOixhmjdqx2gWVbFZ4DXZ/NyRMZVlJXPa7CyFS+/a4QQsDGDQy9ZfEzxFuNEsMLeQJnKP2p5/JA=="
         },
-        "json-schema-traverse": {
-          "version": "0.4.1",
-          "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
-          "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg=="
-        },
         "schema-utils": {
-          "version": "3.3.0",
-          "resolved": "https://registry.npmjs.org/schema-utils/-/schema-utils-3.3.0.tgz",
-          "integrity": "sha512-pN/yOAvcC+5rQ5nERGuwrjLlYvLTbCibnZ1I7B1LaiAz9BRBlE9GMgE/eqV30P7aJQUf7Ddimy/RsbYO/GrVGg==",
+          "version": "4.3.2",
+          "resolved": "https://registry.npmjs.org/schema-utils/-/schema-utils-4.3.2.tgz",
+          "integrity": "sha512-Gn/JaSk/Mt9gYubxTtSn/QCV4em9mpAPiR1rqy/Ocu19u/G9J5WWdNoUT4SiV6mFC3y6cxyFcFwdzPM3FgxGAQ==",
           "requires": {
-            "@types/json-schema": "^7.0.8",
-            "ajv": "^6.12.5",
-            "ajv-keywords": "^3.5.2"
+            "@types/json-schema": "^7.0.9",
+            "ajv": "^8.9.0",
+            "ajv-formats": "^2.1.1",
+            "ajv-keywords": "^5.1.0"
           }
         }
       }
@@ -31918,9 +32107,9 @@
       "dev": true
     },
     "ws": {
-      "version": "8.11.0",
-      "resolved": "https://registry.npmjs.org/ws/-/ws-8.11.0.tgz",
-      "integrity": "sha512-HPG3wQd9sNQoT9xHyNCXoDUa+Xw/VevmY9FoHyQ+g+rrMn4j6FB4np7Z0OhdTgjx6MgQLK7jwSy1YecU1+4Asg==",
+      "version": "8.17.1",
+      "resolved": "https://registry.npmjs.org/ws/-/ws-8.17.1.tgz",
+      "integrity": "sha512-6XQFvXTkbfUOZOKKILFG1PDK2NDQs4azKQl26T0YS5CxqWLgXajbPZ+h4gZekJyRqFU8pvnbAbbs/3TgRPy+GQ==",
       "dev": true,
       "requires": {}
     },
diff --git a/tools/winscope/package.json b/tools/winscope/package.json
index f07c58fa3..d8f26dab3 100644
--- a/tools/winscope/package.json
+++ b/tools/winscope/package.json
@@ -11,7 +11,7 @@
     "deps_graph:check_cycles": "npx madge --extensions ts,js src/ --circular",
     "start": "webpack serve --config webpack.config.dev.js --open --hot --port 8080",
     "start:remote_tool_mock": "webpack serve --config src/test/remote_tool_mock/webpack.config.js --open --hot --port 8081",
-    "build:trace_processor": "PERFETTO_TOP=../../../external/perfetto; (cd $PERFETTO_TOP && tools/install-build-deps --ui && ui/node ui/build.js --out trace_processor_build) && rm -rf deps_build/trace_processor && mkdir -p deps_build/trace_processor && rsync -ar $PERFETTO_TOP/trace_processor_build/ deps_build/trace_processor && mkdir deps_build/trace_processor/to_be_served && cp deps_build/trace_processor/ui/dist_version/engine_bundle.js deps_build/trace_processor/to_be_served/ && cp deps_build/trace_processor/wasm/trace_processor.wasm deps_build/trace_processor/to_be_served/",
+    "build:trace_processor": "PERFETTO_TOP=../../../external/perfetto; (cd $PERFETTO_TOP && tools/install-build-deps --ui && ui/node ui/build.js --out trace_processor_build) && rm -rf deps_build/trace_processor && mkdir -p deps_build/trace_processor && rsync -ar $PERFETTO_TOP/trace_processor_build/ deps_build/trace_processor && mkdir deps_build/trace_processor/to_be_served && cp deps_build/trace_processor/ui/dist_version/engine_bundle.js deps_build/trace_processor/to_be_served/ && cp deps_build/trace_processor/wasm_memory64/trace_processor_memory64.wasm deps_build/trace_processor/to_be_served/ && cp deps_build/trace_processor/wasm/trace_processor.wasm deps_build/trace_processor/to_be_served/",
     "build:prod": "npm run build:trace_processor && npm run build:protos && npm run build:app",
     "build:protos": "node protos/build.js",
     "build:app": "rm -rf dist/prod/ && webpack --config webpack.config.prod.js --progress && cp deps_build/trace_processor/to_be_served/* src/adb/winscope_proxy.py src/logo_light_mode.svg src/logo_dark_mode.svg src/viewers/components/rects/cube_full_shade.svg src/viewers/components/rects/cube_partial_shade.svg src/app/components/trackpad_right_click.svg src/app/components/trackpad_vertical_scroll.svg src/app/components/trackpad_horizontal_scroll.svg dist/prod/",
diff --git a/tools/winscope/protos/build.js b/tools/winscope/protos/build.js
index 8f869de14..35258c02c 100644
--- a/tools/winscope/protos/build.js
+++ b/tools/winscope/protos/build.js
@@ -26,68 +26,41 @@ async function build() {
     await runCommand(`rm -rf ${OUT_TOP}`);
 
     const promises = [
-        // IME
+        // IME udc
         buildProtos([
             '../../../../frameworks/base/core/proto/android/view/inputmethod/inputmethodeditortrace.proto'
         ], 'ime/udc'),
-        buildProtos([
-            'ime/latest/wrapper.proto',
-        ], 'ime/latest'),
 
-        // ProtoLog
+        // ProtoLog udc
         buildProtos([
             'protolog/udc/protolog.proto'
         ], 'protolog/udc'),
-        buildProtos([
-            '../../../../external/perfetto/protos/perfetto/trace/android/protolog.proto'
-        ], 'protolog/latest'),
 
-        // SurfaceFlinger
+        // SurfaceFlinger udc
         buildProtos([
             'surfaceflinger/udc/layerstrace.proto',
         ], 'surfaceflinger/udc'),
-        buildProtos([
-            '../../../../external/perfetto/protos/perfetto/trace/android/surfaceflinger_layers.proto',
-        ], 'surfaceflinger/latest'),
 
-        // Transactions
+        // Transactions udc
         buildProtos([
             'surfaceflinger/udc/transactions.proto',
         ], 'transactions/udc'),
-        buildProtos([
-            '../../../../external/perfetto/protos/perfetto/trace/android/surfaceflinger_transactions.proto',
-        ], 'transactions/latest'),
 
-        // Transitions
+        // Transitions udc
         buildProtos([
             'transitions/udc/windowmanagertransitiontrace.proto',
             'transitions/udc/wm_shell_transition_trace.proto'
         ], 'transitions/udc'),
-        buildProtos([
-            '../../../../external/perfetto/protos/perfetto/trace/android/shell_transition.proto',
-        ], 'transitions/latest'),
 
-        // ViewCapture
+        // ViewCapture udc
         buildProtos([
             '../../../../frameworks/libs/systemui/viewcapturelib/src/com/android/app/viewcapture/proto/view_capture.proto'
         ], 'viewcapture/udc'),
-        buildProtos([
-            'viewcapture/latest/wrapper.proto',
-        ], 'viewcapture/latest'),
 
-        // WindowManager
+        // WindowManager udc
         buildProtos([
             '../../../../frameworks/base/core/proto/android/server/windowmanagertrace.proto',
         ], 'windowmanager/udc'),
-        buildProtos([
-            'windowmanager/latest/wrapper.proto',
-        ], 'windowmanager/latest'),
-
-        // Input
-        buildProtos([
-            '../../../../external/perfetto/protos/perfetto/trace/android/android_input_event.proto',
-            'input/latest/input_event_wrapper.proto',
-        ], 'input/latest'),
 
         // Test proto fields
         buildProtos([
@@ -98,6 +71,12 @@ async function build() {
         buildProtos([
             'test/intdef_translation_test.proto',
         ], 'test/intdef_translation'),
+
+        // Perfetto trace
+        buildProtos([
+            '../../../../external/perfetto/protos/perfetto/trace/trace.proto',
+            '../../../../external/perfetto/protos/perfetto/trace/android/winscope_extensions_impl.proto'
+        ], 'perfetto/trace'),
     ];
 
     await Promise.all(promises);
diff --git a/tools/winscope/src/adb/winscope_proxy.py b/tools/winscope/src/adb/winscope_proxy.py
index 81465e08c..e8b0c6b57 100644
--- a/tools/winscope/src/adb/winscope_proxy.py
+++ b/tools/winscope/src/adb/winscope_proxy.py
@@ -240,7 +240,7 @@ class FetchEndpoint(DeviceRequestEndpoint):
                 log.debug(
                     f"Fetching file {filepath} from device to {tmp.name}")
                 try:
-                    self.call_adb_outfile('exec-out su root cat ' +
+                    self.call_adb_outfile('exec-out cat ' +
                                         filepath, tmp, device_id)
                 except AdbError as ex:
                     log.warning(f"Unable to fetch file {filepath} - {repr(ex)}")
@@ -334,7 +334,7 @@ class TraceThread(threading.Thread):
         log.info("Trace {} ended on {}, waiting for cleanup".format(self.target_id, self._device_id))
         time.sleep(0.2)
         for i in range(int(COMMAND_TIMEOUT_S / retry_interval)):
-            if call_adb(f"shell su root cat {self.status_filename}", device=self._device_id) == 'TRACE_OK\n':
+            if call_adb(f"shell cat {self.status_filename}", device=self._device_id) == 'TRACE_OK\n':
                 log.info("Trace {} finished on {}".format(
                     self.target_id,
                     self._device_id))
@@ -430,7 +430,7 @@ class EndTraceEndpoint(DeviceRequestEndpoint):
         if thread.is_alive():
             thread.end_trace()
         success = thread.success()
-        signal_handler_log = call_adb(f"shell su root cat {SIGNAL_HANDLER_LOG}", device=device_id).encode('utf-8')
+        signal_handler_log = call_adb(f"shell cat {SIGNAL_HANDLER_LOG}", device=device_id).encode('utf-8')
 
         if (thread.timed_out()):
             timeout_message = "Trace {} timed out during cleanup".format(target_id)
@@ -450,7 +450,7 @@ class EndTraceEndpoint(DeviceRequestEndpoint):
             b"\n"
         log.debug("### Output ###\n".format(target_id) + out.decode("utf-8"))
 
-        call_adb(f"shell su root rm {thread.status_filename}", device=device_id)
+        call_adb(f"shell rm {thread.status_filename}", device=device_id)
 
         threads.pop(target_id)
 
diff --git a/tools/winscope/src/app/app_module.ts b/tools/winscope/src/app/app_module.ts
index 0d40b479b..8323a6ecb 100644
--- a/tools/winscope/src/app/app_module.ts
+++ b/tools/winscope/src/app/app_module.ts
@@ -48,6 +48,7 @@ import {MatToolbarModule} from '@angular/material/toolbar';
 import {MatTooltipModule} from '@angular/material/tooltip';
 import {BrowserModule, Title} from '@angular/platform-browser';
 import {BrowserAnimationsModule} from '@angular/platform-browser/animations';
+import {VariableHeightScrollDirective} from 'viewers/common/variable_height_scroll_directive';
 import {CollapsedSectionsComponent} from 'viewers/components/collapsed_sections_component';
 import {CollapsibleSectionTitleComponent} from 'viewers/components/collapsible_section_title_component';
 import {CoordinatesTableComponent} from 'viewers/components/coordinates_table_component';
@@ -71,15 +72,12 @@ import {ViewCapturePropertyGroupsComponent} from 'viewers/components/view_captur
 import {ViewerInputComponent} from 'viewers/viewer_input/viewer_input_component';
 import {ViewerJankCujsComponent} from 'viewers/viewer_jank_cujs/viewer_jank_cujs_component';
 import {ViewerMediaBasedComponent} from 'viewers/viewer_media_based/viewer_media_based_component';
-import {ProtologScrollDirective} from 'viewers/viewer_protolog/scroll_strategy/protolog_scroll_directive';
 import {ViewerProtologComponent} from 'viewers/viewer_protolog/viewer_protolog_component';
 import {ActiveSearchComponent} from 'viewers/viewer_search/active_search_component';
 import {SearchListComponent} from 'viewers/viewer_search/search_list_component';
 import {ViewerSearchComponent} from 'viewers/viewer_search/viewer_search_component';
 import {ViewerSurfaceFlingerComponent} from 'viewers/viewer_surface_flinger/viewer_surface_flinger_component';
-import {TransactionsScrollDirective} from 'viewers/viewer_transactions/scroll_strategy/transactions_scroll_directive';
 import {ViewerTransactionsComponent} from 'viewers/viewer_transactions/viewer_transactions_component';
-import {TransitionsScrollDirective} from 'viewers/viewer_transitions/scroll_strategy/transitions_scroll_directive';
 import {ViewerTransitionsComponent} from 'viewers/viewer_transitions/viewer_transitions_component';
 import {ViewerViewCaptureComponent} from 'viewers/viewer_view_capture/viewer_view_capture_component';
 import {ViewerWindowManagerComponent} from 'viewers/viewer_window_manager/viewer_window_manager_component';
@@ -150,9 +148,7 @@ import {GlobalErrorHandler} from './global_error_handler';
     MatDrawerContainer,
     LoadProgressComponent,
     SliderComponent,
-    ProtologScrollDirective,
-    TransactionsScrollDirective,
-    TransitionsScrollDirective,
+    VariableHeightScrollDirective,
     ViewCapturePropertyGroupsComponent,
     SelectWithFilterComponent,
     ShortcutsComponent,
diff --git a/tools/winscope/src/app/components/app_component.ts b/tools/winscope/src/app/components/app_component.ts
index 4edeec37c..3f31444fc 100644
--- a/tools/winscope/src/app/components/app_component.ts
+++ b/tools/winscope/src/app/components/app_component.ts
@@ -50,6 +50,7 @@ import {
   AppRefreshDumpsRequest,
   AppResetRequest,
   AppTraceViewRequest,
+  BugreportFileSelected,
   DarkModeToggled,
   WinscopeEvent,
   WinscopeEventType,
@@ -75,19 +76,26 @@ import {SnackBarOpener} from './snack_bar_opener';
 import {TimelineComponent} from './timeline/timeline_component';
 import {TraceViewComponent} from './trace_view_component';
 import {UploadTracesComponent} from './upload_traces_component';
+import {
+  WarningDialogComponent,
+  WarningDialogData,
+  WarningDialogResult,
+} from './warning_dialog_component';
 
 @Component({
   selector: 'app-root',
   encapsulation: ViewEncapsulation.None,
   template: `
     <mat-toolbar class="toolbar">
-      <div class="horizontal-align vertical-align">
-        <img class="app-title fixed" [src]="getLogoUrl()"/>
+      <div class="horizontal-align vertical-align fixed">
+        <img class="app-title" [src]="getLogoUrl()"/>
       </div>
 
       <div class="horizontal-align vertical-align">
         <div *ngIf="showDataLoadedElements" class="download-files-section">
-          <div class="file-descriptor vertical-align">
+          <div
+            class="file-descriptor vertical-align"
+            [class.file-warning]="packetLossWarning() !== undefined">
             <button
               mat-icon-button
               *ngIf="showCrossToolSyncButton()"
@@ -97,6 +105,10 @@ import {UploadTracesComponent} from './upload_traces_component';
               [color]="getCrossToolSyncButtonColor()">
               <mat-icon class="material-symbols-outlined">cloud_sync</mat-icon>
             </button>
+            <mat-icon
+              *ngIf="packetLossWarning()"
+              [matTooltip]="packetLossWarning()"
+              class="warning-icon fixed">warning</mat-icon>
             <span *ngIf="!isEditingFilename" class="download-file-info mat-body-2">
               {{ filenameFormControl.value }}
             </span>
@@ -205,7 +217,7 @@ import {UploadTracesComponent} from './upload_traces_component';
     <mat-drawer-container autosize disableClose autoFocus>
       <mat-drawer-content>
         <ng-container *ngIf="dataLoaded; else noLoadedTracesBlock">
-          <trace-view class="viewers" [viewers]="viewers" [store]="store"></trace-view>
+          <trace-view class="viewers" [viewers]="viewers" [store]="persistentStore"></trace-view>
 
           <mat-divider></mat-divider>
         </ng-container>
@@ -216,7 +228,7 @@ import {UploadTracesComponent} from './upload_traces_component';
           *ngIf="dataLoaded"
           [allTraces]="tracePipeline.getTraces()"
           [timelineData]="timelineData"
-          [store]="store"
+          [store]="persistentStore"
           (collapsedTimelineSizeChanged)="onCollapsedTimelineSizeChanged($event)"></timeline>
       </mat-drawer>
     </mat-drawer-container>
@@ -231,15 +243,16 @@ import {UploadTracesComponent} from './upload_traces_component';
           <div class="card-grid landing-grid">
             <collect-traces
               class="collect-traces-card homepage-card"
-              [storage]="traceCollectionStorage"
+              [storage]="appStorage"
               (filesCollected)="onFilesCollected($event)"></collect-traces>
 
             <upload-traces
               #uploadTraces
               class="upload-traces-card homepage-card"
               [tracePipeline]="tracePipeline"
+              [storage]="appStorage"
               (filesUploaded)="onFilesUploaded($event)"
-              (viewTracesButtonClick)="onViewTracesButtonClick()"
+              (viewTracesButtonClick)="onViewTracesButtonClick($event)"
               (downloadTracesClick)="onDownloadTracesButtonClick(uploadTraces)"></upload-traces>
           </div>
         </div>
@@ -285,7 +298,14 @@ import {UploadTracesComponent} from './upload_traces_component';
       .file-descriptor {
         font-size: 14px;
         padding-left: 10px;
-        max-width: 700px;
+        max-width: 750px;
+      }
+      .file-warning  {
+        border: solid 2px var(--warning-color);
+        background: var(--warning-background-color);
+      }
+      .file-descriptor .warning-icon {
+        padding-inline-end: 4px;
       }
       .download-file-info {
         text-overflow: ellipsis;
@@ -345,7 +365,7 @@ export class AppComponent implements WinscopeEventListener {
   showDataLoadedElements = false;
   collapsedTimelineHeight = 0;
   isEditingFilename = false;
-  store = new PersistentStore();
+  persistentStore = new PersistentStore();
   viewers: Viewer[] = [];
 
   isDarkModeOn = false;
@@ -361,7 +381,7 @@ export class AppComponent implements WinscopeEventListener {
     ]),
   );
 
-  traceCollectionStorage: Store;
+  appStorage: Store;
   downloadProgress: number | undefined;
 
   @ViewChild(UploadTracesComponent)
@@ -394,7 +414,7 @@ export class AppComponent implements WinscopeEventListener {
       new PersistentStore(),
     );
 
-    const storeDarkMode = this.store.get('dark-mode');
+    const storeDarkMode = this.persistentStore.get('dark-mode');
     const prefersDarkQuery = window.matchMedia?.(
       '(prefers-color-scheme: dark)',
     );
@@ -469,7 +489,7 @@ export class AppComponent implements WinscopeEventListener {
       );
     }
 
-    this.traceCollectionStorage =
+    this.appStorage =
       globalConfig.MODE === 'PROD'
         ? new PersistentStore()
         : new InMemoryStorage();
@@ -504,7 +524,7 @@ export class AppComponent implements WinscopeEventListener {
 
   async setDarkMode(enabled: boolean) {
     document.body.classList.toggle('dark-mode', enabled);
-    this.store.add('dark-mode', `${enabled}`);
+    this.persistentStore.add('dark-mode', `${enabled}`);
     this.isDarkModeOn = enabled;
     await this.mediator.onWinscopeEvent(new DarkModeToggled(enabled));
   }
@@ -555,11 +575,13 @@ export class AppComponent implements WinscopeEventListener {
 
   async onUploadNewButtonClick() {
     await this.mediator.onWinscopeEvent(new AppResetRequest());
-    this.store.clear('treeView');
+    this.persistentStore.clear('treeView');
   }
 
-  async onViewTracesButtonClick() {
-    await this.mediator.onWinscopeEvent(new AppTraceViewRequest());
+  async onViewTracesButtonClick(discardLegacyTraces: boolean) {
+    await this.mediator.onWinscopeEvent(
+      new AppTraceViewRequest(discardLegacyTraces),
+    );
   }
 
   onProgressUpdate(message: string, progressPercentage: number | undefined) {
@@ -600,6 +622,13 @@ export class AppComponent implements WinscopeEventListener {
       this.pageTitle.setTitle('Winscope');
       this.changeDetectorRef.detectChanges();
     });
+
+    await event.visit(
+      WinscopeEventType.BUGREPORT_FILE_SELECTION_REQUEST,
+      async (event) => {
+        await this.showFileSelectionDialog(event.filenames);
+      },
+    );
   }
 
   openShortcutsPanel() {
@@ -628,15 +657,15 @@ export class AppComponent implements WinscopeEventListener {
     this.setDarkMode(!this.isDarkModeOn);
   }
 
-  dumpsUploaded() {
+  dumpsUploaded(): boolean {
     return !this.timelineData.hasMoreThanOneDistinctTimestamp();
   }
 
-  showCrossToolSyncButton() {
+  showCrossToolSyncButton(): boolean {
     return this.crossToolProtocol.isConnected();
   }
 
-  getCrossToolSyncTooltip() {
+  getCrossToolSyncTooltip(): string {
     const currStatus = this.crossToolProtocol.getAllowTimestampSync();
 
     return `Cross Tool Sync ${this.translateStatus(
@@ -653,12 +682,48 @@ export class AppComponent implements WinscopeEventListener {
     );
   }
 
-  getCrossToolSyncButtonColor() {
+  getCrossToolSyncButtonColor(): string {
     return this.crossToolProtocol.getAllowTimestampSync()
       ? 'primary'
       : 'accent';
   }
 
+  packetLossWarning(): string | undefined {
+    const lostPackets = this.tracePipeline.lostPackets();
+    if (lostPackets === 0) {
+      return undefined;
+    }
+    return `${lostPackets} Perfetto packet${
+      lostPackets > 1 ? 's' : ''
+    } lost during tracing - data may be incomplete`;
+  }
+
+  async showFileSelectionDialog(filenames: string[]) {
+    await new Promise<void>((resolve) => {
+      this.ngZone.run(() => {
+        const data: WarningDialogData = {
+          message: `Multiple Perfetto traces found. Select one to process:`,
+          actions: [],
+          options: filenames,
+          closeText: 'Process selected trace',
+          singleSelection: true,
+        };
+        const dialogRef = this.dialog.open(WarningDialogComponent, {
+          data,
+          disableClose: true,
+        });
+        dialogRef
+          .beforeClosed()
+          .subscribe(async (result: WarningDialogResult | undefined) => {
+            await this.mediator.onWinscopeEvent(
+              new BugreportFileSelected(result?.selectedOptions[0]),
+            );
+            resolve();
+          });
+      });
+    });
+  }
+
   private goToLink(url: string) {
     window.open(url, '_blank');
   }
diff --git a/tools/winscope/src/app/components/app_component_test.ts b/tools/winscope/src/app/components/app_component_test.ts
index 166caf307..bde4766dd 100644
--- a/tools/winscope/src/app/components/app_component_test.ts
+++ b/tools/winscope/src/app/components/app_component_test.ts
@@ -18,11 +18,7 @@ import {OverlayModule} from '@angular/cdk/overlay';
 import {CommonModule} from '@angular/common';
 import {HttpClientModule} from '@angular/common/http';
 import {ChangeDetectionStrategy} from '@angular/core';
-import {
-  ComponentFixture,
-  ComponentFixtureAutoDetect,
-  TestBed,
-} from '@angular/core/testing';
+import {ComponentFixtureAutoDetect, TestBed} from '@angular/core/testing';
 import {
   FormControl,
   FormsModule,
@@ -31,6 +27,7 @@ import {
 } from '@angular/forms';
 import {MatButtonModule} from '@angular/material/button';
 import {MatCardModule} from '@angular/material/card';
+import {MatCheckboxModule} from '@angular/material/checkbox';
 import {MatDialogModule} from '@angular/material/dialog';
 import {MatDividerModule} from '@angular/material/divider';
 import {MatFormFieldModule} from '@angular/material/form-field';
@@ -57,11 +54,14 @@ import {
 } from 'messaging/user_warnings';
 import {
   AppRefreshDumpsRequest,
+  BugreportFileSelected,
+  BugreportFileSelectionRequest,
   ViewersLoaded,
   ViewersUnloaded,
 } from 'messaging/winscope_event';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
+import {waitToBeCalled} from 'test/unit/spy_utils';
 import {TracesBuilder} from 'test/unit/traces_builder';
-import {waitToBeCalled} from 'test/utils';
 import {ViewerSurfaceFlingerComponent} from 'viewers/viewer_surface_flinger/viewer_surface_flinger_component';
 import {AppComponent} from './app_component';
 import {
@@ -77,14 +77,14 @@ import {TimelineComponent} from './timeline/timeline_component';
 import {TraceConfigComponent} from './trace_config_component';
 import {TraceViewComponent} from './trace_view_component';
 import {UploadTracesComponent} from './upload_traces_component';
+import {WarningDialogComponent} from './warning_dialog_component';
 import {WdpSetupComponent} from './wdp_setup_component';
 import {WinscopeProxySetupComponent} from './winscope_proxy_setup_component';
 
 describe('AppComponent', () => {
-  let fixture: ComponentFixture<AppComponent>;
   let component: AppComponent;
-  let htmlElement: HTMLElement;
   let downloadTracesSpy: jasmine.Spy;
+  let dom: DOMTestHelper<AppComponent>;
 
   beforeEach(async () => {
     await TestBed.configureTestingModule({
@@ -112,6 +112,7 @@ describe('AppComponent', () => {
         MatProgressBarModule,
         OverlayModule,
         MatTabsModule,
+        MatCheckboxModule,
       ],
       declarations: [
         WinscopeProxySetupComponent,
@@ -129,15 +130,16 @@ describe('AppComponent', () => {
         ViewerSurfaceFlingerComponent,
         ShortcutsComponent,
         SnackBarComponent,
+        WarningDialogComponent,
       ],
     })
       .overrideComponent(AppComponent, {
         set: {changeDetection: ChangeDetectionStrategy.Default},
       })
       .compileComponents();
-    fixture = TestBed.createComponent(AppComponent);
+    const fixture = TestBed.createComponent(AppComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
     component.filenameFormControl = new FormControl(
       'winscope',
       Validators.compose([
@@ -146,7 +148,7 @@ describe('AppComponent', () => {
       ]),
     );
     downloadTracesSpy = spyOn(Download, 'fromUrl');
-    fixture.detectChanges();
+    dom.detectChanges();
   });
 
   it('can be created', () => {
@@ -164,7 +166,7 @@ describe('AppComponent', () => {
   it('displays correct elements when no data loaded', () => {
     component.dataLoaded = false;
     component.showDataLoadedElements = false;
-    fixture.detectChanges();
+    dom.detectChanges();
     checkHomepage();
   });
 
@@ -173,21 +175,15 @@ describe('AppComponent', () => {
     checkTraceViewPage();
 
     spyOn(component, 'dumpsUploaded').and.returnValue(true);
-    fixture.detectChanges();
-    expect(htmlElement.querySelector('.refresh-dumps')).toBeTruthy();
+    dom.detectChanges();
+    expect(dom.find('.refresh-dumps')).toBeTruthy();
   });
 
   it('returns to homepage on upload new button click', async () => {
     goToTraceView();
     checkTraceViewPage();
-
-    assertDefined(
-      htmlElement.querySelector<HTMLButtonElement>('.upload-new'),
-    ).click();
-    fixture.detectChanges();
-    await fixture.whenStable();
-    fixture.detectChanges();
-    await fixture.whenStable();
+    await dom.clickAndWaitStable('.upload-new');
+    await dom.detectChangesAndWaitStable();
     checkHomepage();
   });
 
@@ -200,50 +196,41 @@ describe('AppComponent', () => {
       component.mediator,
       'onWinscopeEvent',
     ).and.callThrough();
-    assertDefined(
-      htmlElement.querySelector<HTMLButtonElement>('.refresh-dumps'),
-    ).click();
-    fixture.detectChanges();
-    await fixture.whenStable();
-    fixture.detectChanges();
-    await fixture.whenStable();
+    await dom.clickAndWaitStable('.refresh-dumps');
+    await dom.detectChangesAndWaitStable();
     checkHomepage();
     expect(winscopeEventSpy).toHaveBeenCalledWith(new AppRefreshDumpsRequest());
   });
 
   it('shows download progress bar', () => {
     component.showDataLoadedElements = true;
-    fixture.detectChanges();
+    dom.detectChanges();
     expect(
-      htmlElement.querySelector('.download-files-section mat-progress-bar'),
-    ).toBeNull();
+      dom.find('.download-files-section mat-progress-bar'),
+    ).toBeUndefined();
 
     component.onProgressUpdate('Progress update', 10);
-    fixture.detectChanges();
-    expect(
-      htmlElement.querySelector('.download-files-section mat-progress-bar'),
-    ).toBeTruthy();
+    dom.detectChanges();
+    expect(dom.find('.download-files-section mat-progress-bar')).toBeTruthy();
 
     component.onOperationFinished(true);
-    fixture.detectChanges();
+    dom.detectChanges();
     expect(
-      htmlElement.querySelector('.download-files-section mat-progress-bar'),
-    ).toBeNull();
+      dom.find('.download-files-section mat-progress-bar'),
+    ).toBeUndefined();
   });
 
   it('downloads traces on download button click and shows download progress bar', async () => {
     component.showDataLoadedElements = true;
-    fixture.detectChanges();
+    dom.detectChanges();
     clickDownloadTracesButton();
-    expect(
-      htmlElement.querySelector('.download-files-section mat-progress-bar'),
-    ).toBeTruthy();
+    expect(dom.find('.download-files-section mat-progress-bar')).toBeTruthy();
     await waitToBeCalled(downloadTracesSpy);
   });
 
   it('downloads traces after valid file name change', async () => {
     component.showDataLoadedElements = true;
-    fixture.detectChanges();
+    dom.detectChanges();
 
     clickEditFilenameButton();
     updateFilenameInputAndDownloadTraces('Winscope2', true);
@@ -280,13 +267,13 @@ describe('AppComponent', () => {
       .createSpy()
       .and.returnValue('test_archive');
     await component.onWinscopeEvent(new ViewersLoaded([]));
-    fixture.detectChanges();
+    dom.detectChanges();
     expect(pageTitle.getTitle()).toBe('Winscope | test_archive');
   });
 
   it('does not download traces if invalid file name chosen', () => {
     component.showDataLoadedElements = true;
-    fixture.detectChanges();
+    dom.detectChanges();
 
     clickEditFilenameButton();
     updateFilenameInputAndDownloadTraces('w?n$cope', false);
@@ -295,7 +282,7 @@ describe('AppComponent', () => {
 
   it('behaves as expected when entering valid then invalid then valid file names', async () => {
     component.showDataLoadedElements = true;
-    fixture.detectChanges();
+    dom.detectChanges();
 
     clickEditFilenameButton();
     updateFilenameInputAndDownloadTraces('Winscope2', true);
@@ -322,93 +309,152 @@ describe('AppComponent', () => {
     const spy = spyOn(component, 'trySubmitFilename');
 
     component.showDataLoadedElements = true;
-    fixture.detectChanges();
+    dom.detectChanges();
     clickEditFilenameButton();
-    const inputField = assertDefined(
-      htmlElement.querySelector('.file-name-input-field'),
-    );
-    const inputEl = assertDefined(
-      htmlElement.querySelector<HTMLInputElement>(
-        '.file-name-input-field input',
-      ),
-    );
-    inputEl.value = 'valid_file_name';
+    const inputField = dom.get('.file-name-input-field');
+    inputField.get('input').updateValue('valid_file_name');
 
-    inputField.dispatchEvent(new KeyboardEvent('keydown', {key: 'Enter'}));
-    fixture.detectChanges();
+    inputField.keydownEnter();
     expect(spy).toHaveBeenCalledTimes(1);
 
-    inputField.dispatchEvent(new KeyboardEvent('keydown', {key: 'Escape'}));
-    fixture.detectChanges();
+    inputField.keydownEsc();
     expect(spy).toHaveBeenCalledTimes(2);
 
-    inputField.dispatchEvent(new FocusEvent('focusout'));
-    fixture.detectChanges();
+    inputField.focusOut();
     expect(spy).toHaveBeenCalledTimes(3);
   });
 
   it('downloads traces from upload traces section', () => {
     const traces = assertDefined(component.tracePipeline.getTraces());
     spyOn(traces, 'getSize').and.returnValue(1);
-    fixture.detectChanges();
+    dom.detectChanges();
     const downloadButtonClickSpy = spyOn(
       component,
       'onDownloadTracesButtonClick',
     );
-
-    const downloadButton = assertDefined(
-      htmlElement.querySelector<HTMLElement>('upload-traces .download-btn'),
-    );
-    downloadButton.click();
-    fixture.detectChanges();
+    dom.findAndClick('upload-traces .download-btn');
     expect(downloadButtonClickSpy).toHaveBeenCalledOnceWith(
       component.uploadTracesComponent,
     );
   });
 
-  it('opens shortcuts dialog', () => {
-    expect(document.querySelector('shortcuts-panel')).toBeFalsy();
-    const shortcutsButton = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.shortcuts'),
+  it('shows cross tool sync button', async () => {
+    component.showDataLoadedElements = true;
+    dom.detectChanges();
+    const fileDescriptor = dom.get('.file-descriptor');
+    expect(fileDescriptor.find('.cross-tool-sync-button')).toBeUndefined();
+
+    spyOn(component.crossToolProtocol, 'isConnected').and.returnValue(true);
+    dom.detectChanges();
+    const syncButton = fileDescriptor.get('.cross-tool-sync-button');
+    await syncButton.checkTooltip('Cross Tool Sync ON (Click to turn OFF)');
+    syncButton.checkClassName('mat-primary', true);
+    syncButton.checkClassName('mat-accent', false);
+
+    syncButton.click();
+    await syncButton.checkTooltip('Cross Tool Sync OFF (Click to turn ON)');
+    syncButton.checkClassName('mat-accent', true);
+    syncButton.checkClassName('mat-primary', false);
+
+    syncButton.click();
+    await syncButton.checkTooltip('Cross Tool Sync ON (Click to turn OFF)');
+    syncButton.checkClassName('mat-primary', true);
+    syncButton.checkClassName('mat-accent', false);
+  });
+
+  it('shows warning icon for packet loss', async () => {
+    component.showDataLoadedElements = true;
+    dom.detectChanges();
+    const fileDescriptor = dom.get('.file-descriptor');
+    fileDescriptor.checkClassName('file-warning', false);
+    expect(fileDescriptor.find('.warning-icon')).toBeUndefined();
+
+    const spy = spyOn(component.tracePipeline, 'lostPackets').and.returnValue(
+      1,
+    );
+    dom.detectChanges();
+    fileDescriptor.checkClassName('file-warning', true);
+    const warningIcon = fileDescriptor.get('.warning-icon');
+    await warningIcon.checkTooltip(
+      '1 Perfetto packet lost during tracing - data may be incomplete',
+    );
+
+    spy.and.returnValue(4);
+    dom.detectChanges();
+    await warningIcon.checkTooltip(
+      '4 Perfetto packets lost during tracing - data may be incomplete',
     );
-    shortcutsButton.click();
-    fixture.detectChanges();
-    expect(document.querySelector('shortcuts-panel')).toBeTruthy();
+  });
+
+  it('opens shortcuts dialog', () => {
+    expect(dom.findInDocument('shortcuts-panel')).toBeUndefined();
+    dom.findAndClick('.shortcuts');
+    expect(dom.findInDocument('shortcuts-panel')).toBeTruthy();
   });
 
   it('sets snackbar opener to global user notifier', () => {
-    expect(document.querySelector('snack-bar')).toBeFalsy();
+    expect(dom.findInDocument('snack-bar')).toBeUndefined();
     UserNotifier.add(new NoValidFiles());
     UserNotifier.notify();
-    expect(document.querySelector('snack-bar')).toBeTruthy();
+    expect(dom.findInDocument('snack-bar')).toBeTruthy();
   });
 
   it('does not open new snackbar until existing snackbar has been dismissed', async () => {
-    expect(document.querySelector('snack-bar')).toBeFalsy();
+    expect(dom.findInDocument('snack-bar')).toBeUndefined();
     const firstMessage = new NoValidFiles();
     UserNotifier.add(firstMessage);
     UserNotifier.notify();
-    fixture.detectChanges();
-    await fixture.whenRenderingDone();
-    let snackbar = assertDefined(document.querySelector('snack-bar'));
-    expect(snackbar.textContent).toContain(firstMessage.getMessage());
+    await dom.detectChangesAndRenderingDone();
+    let snackbar = dom.getSnackBar();
+    snackbar.checkText(firstMessage.getMessage());
 
     const secondMessage = new FailedToInitializeTimelineData();
     UserNotifier.add(secondMessage);
     UserNotifier.notify();
-    fixture.detectChanges();
-    await fixture.whenRenderingDone();
-    snackbar = assertDefined(document.querySelector('snack-bar'));
-    expect(snackbar.textContent).toContain(firstMessage.getMessage());
+    await dom.detectChangesAndRenderingDone();
+    snackbar = dom.getSnackBar();
+    snackbar.checkText(firstMessage.getMessage());
+
+    snackbar.findAndClick('.snack-bar-actions .close-button');
+    await dom.whenRenderingDone();
+    snackbar = dom.getSnackBar();
+    snackbar.checkText(secondMessage.getMessage());
+  });
 
-    const closeButton = assertDefined(
-      snackbar.querySelector<HTMLElement>('.snack-bar-action'),
+  it('shows bugreport selection dialog', async () => {
+    expect(dom.findInDocument('warning-dialog')).toBeUndefined();
+    let eventHandled = false;
+    component
+      .onWinscopeEvent(new BugreportFileSelectionRequest(['f1', 'f2']))
+      .then(() => {
+        eventHandled = true;
+      });
+    await dom.whenStable();
+    const dialog = dom.getInDocument('warning-dialog');
+    expect(eventHandled).toBeFalse();
+
+    dialog
+      .get('.warning-message')
+      .checkTextExact('Multiple Perfetto traces found. Select one to process:');
+    const [option1, option2] = dialog.findAll(
+      '.warning-action-boxes .mat-checkbox',
     );
-    closeButton.click();
-    fixture.detectChanges();
-    await fixture.whenRenderingDone();
-    snackbar = assertDefined(document.querySelector('snack-bar'));
-    expect(snackbar.textContent).toContain(secondMessage.getMessage());
+    option1.checkTextExact('f1');
+    option2.checkTextExact('f2');
+    option2.dispatchEvent(new Event('change'));
+    await dom.whenStable();
+    expect(eventHandled).toBeFalse();
+
+    const mediatorSpy = spyOn(component.mediator, 'onWinscopeEvent');
+    const actions = dialog.findAll('.warning-action-buttons button');
+    expect(actions.length).toEqual(1);
+    actions[0].click();
+    await dom.whenStable();
+    expect(eventHandled).toBeTrue();
+    expect(mediatorSpy).toHaveBeenCalledOnceWith(
+      new BugreportFileSelected('f2'),
+    );
+    expect(dom.findInDocument('warning-dialog')).toBeUndefined();
   });
 
   function goToTraceView() {
@@ -419,79 +465,58 @@ describe('AppComponent', () => {
       undefined,
       TimestampConverterUtils.TIMESTAMP_CONVERTER,
     );
-    fixture.detectChanges();
+    dom.detectChanges();
   }
 
   function updateFilenameInputAndDownloadTraces(name: string, valid: boolean) {
-    const inputEl = assertDefined(
-      htmlElement.querySelector<HTMLInputElement>(
-        '.file-name-input-field input',
-      ),
-    );
-    const checkButton = assertDefined(
-      htmlElement.querySelector('.check-button'),
-    );
-    inputEl.value = name;
-    inputEl.dispatchEvent(new Event('input'));
-    fixture.detectChanges();
-    checkButton.dispatchEvent(new Event('click'));
-    fixture.detectChanges();
-
-    const saveButton = assertDefined(
-      htmlElement.querySelector<HTMLButtonElement>('.save-button'),
-    );
+    dom.findAndDispatchInput('.file-name-input-field', name);
+    dom.findAndClick('.check-button');
+
+    const saveButton = dom.get('.save-button');
     if (valid) {
-      assertDefined(htmlElement.querySelector('.download-file-info'));
-      expect(saveButton.disabled).toBeFalse();
+      expect(dom.find('.download-file-info')).toBeTruthy();
+      saveButton.checkDisabled(false);
       clickDownloadTracesButton();
     } else {
-      expect(htmlElement.querySelector('.download-file-info')).toBeFalsy();
-      expect(saveButton.disabled).toBeTrue();
+      expect(dom.find('.download-file-info')).toBeUndefined();
+      saveButton.checkDisabled(true);
     }
   }
 
   function clickDownloadTracesButton() {
-    const downloadButton = assertDefined(
-      htmlElement.querySelector('.save-button'),
-    );
-    downloadButton.dispatchEvent(new Event('click'));
-    fixture.detectChanges();
+    dom.findAndClick('.save-button');
   }
 
   function clickEditFilenameButton() {
-    const pencilButton = assertDefined(
-      htmlElement.querySelector('.edit-button'),
-    );
-    pencilButton.dispatchEvent(new Event('click'));
-    fixture.detectChanges();
+    dom.findAndClick('.edit-button');
   }
 
   function checkHomepage() {
-    expect(htmlElement.querySelector('.welcome-info')).toBeTruthy();
-    expect(htmlElement.querySelector('.collect-traces-card')).toBeTruthy();
-    expect(htmlElement.querySelector('.upload-traces-card')).toBeTruthy();
-    expect(htmlElement.querySelector('.viewers')).toBeFalsy();
-    expect(htmlElement.querySelector('.upload-new')).toBeFalsy();
-    expect(htmlElement.querySelector('timeline')).toBeFalsy();
+    expect(dom.find('.welcome-info')).toBeTruthy();
+    expect(dom.find('.collect-traces-card')).toBeTruthy();
+    expect(dom.find('.upload-traces-card')).toBeTruthy();
+    expect(dom.find('.viewers')).toBeUndefined();
+    expect(dom.find('.upload-new')).toBeUndefined();
+    expect(dom.find('timeline')).toBeUndefined();
     checkPermanentHeaderItems();
   }
 
   function checkTraceViewPage() {
-    expect(htmlElement.querySelector('.welcome-info')).toBeFalsy();
-    expect(htmlElement.querySelector('.save-button')).toBeTruthy();
-    expect(htmlElement.querySelector('.collect-traces-card')).toBeFalsy();
-    expect(htmlElement.querySelector('.upload-traces-card')).toBeFalsy();
-    expect(htmlElement.querySelector('.viewers')).toBeTruthy();
-    expect(htmlElement.querySelector('.upload-new')).toBeTruthy();
-    expect(htmlElement.querySelector('timeline')).toBeTruthy();
+    expect(dom.find('.welcome-info')).toBeUndefined();
+    expect(dom.find('.save-button')).toBeTruthy();
+    expect(dom.find('.collect-traces-card')).toBeUndefined();
+    expect(dom.find('.upload-traces-card')).toBeUndefined();
+    expect(dom.find('.viewers')).toBeTruthy();
+    expect(dom.find('.upload-new')).toBeTruthy();
+    expect(dom.find('timeline')).toBeTruthy();
     checkPermanentHeaderItems();
   }
 
   function checkPermanentHeaderItems() {
-    expect(htmlElement.querySelector('.app-title')).toBeTruthy();
-    expect(htmlElement.querySelector('.shortcuts')).toBeTruthy();
-    expect(htmlElement.querySelector('.documentation')).toBeTruthy();
-    expect(htmlElement.querySelector('.report-bug')).toBeTruthy();
-    expect(htmlElement.querySelector('.dark-mode')).toBeTruthy();
+    expect(dom.find('.app-title')).toBeTruthy();
+    expect(dom.find('.shortcuts')).toBeTruthy();
+    expect(dom.find('.documentation')).toBeTruthy();
+    expect(dom.find('.report-bug')).toBeTruthy();
+    expect(dom.find('.dark-mode')).toBeTruthy();
   }
 });
diff --git a/tools/winscope/src/app/components/collect_traces_component.ts b/tools/winscope/src/app/components/collect_traces_component.ts
index 506b36d4d..bf20a4d64 100644
--- a/tools/winscope/src/app/components/collect_traces_component.ts
+++ b/tools/winscope/src/app/components/collect_traces_component.ts
@@ -668,7 +668,10 @@ export class CollectTracesComponent
         types: this.dumpConfig[req].types,
       };
     });
-    Analytics.Tracing.logCollectDumps(requestedTraceTypes.map((t) => t.name));
+    Analytics.Tracing.logCollectDumps(
+      requestedTraceTypes.map((t) => t.name),
+      this.getConnectionType(),
+    );
 
     const requestedDumpsWithConfig: UserRequest[] = requestedDumps.map(
       (target) => {
@@ -866,6 +869,7 @@ export class CollectTracesComponent
     });
     Analytics.Tracing.logCollectTraces(
       this.requestedTraceTypes.map((t) => t.name),
+      this.getConnectionType(),
     );
 
     if (requestedTraces.length === 0) {
diff --git a/tools/winscope/src/app/components/collect_traces_component_test.ts b/tools/winscope/src/app/components/collect_traces_component_test.ts
index 490bcd3b1..21b7735a4 100644
--- a/tools/winscope/src/app/components/collect_traces_component_test.ts
+++ b/tools/winscope/src/app/components/collect_traces_component_test.ts
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+import {ClipboardModule} from '@angular/cdk/clipboard';
 import {CommonModule} from '@angular/common';
 import {
   Component,
@@ -20,7 +21,7 @@ import {
   QueryList,
   ViewChildren,
 } from '@angular/core';
-import {ComponentFixture, TestBed} from '@angular/core/testing';
+import {TestBed} from '@angular/core/testing';
 import {FormsModule} from '@angular/forms';
 import {MatButtonModule} from '@angular/material/button';
 import {MatCardModule} from '@angular/material/card';
@@ -44,8 +45,9 @@ import {
   NoTraceTargetsSelected,
   WinscopeEvent,
 } from 'messaging/winscope_event';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
+import {waitToBeCalled} from 'test/unit/spy_utils';
 import {UserNotifierChecker} from 'test/unit/user_notifier_checker';
-import {waitToBeCalled} from 'test/utils';
 import {TraceType} from 'trace/trace_type';
 import {
   AdbDeviceConnection,
@@ -56,6 +58,7 @@ import {ConnectionState} from 'trace_collection/connection_state';
 import {MockAdbDeviceConnection} from 'trace_collection/mock/mock_adb_device_connection';
 import {UiTraceTarget} from 'trace_collection/ui/ui_trace_target';
 import {WdpDeviceConnection} from 'trace_collection/wdp/wdp_device_connection';
+import {WdpHostConnection} from 'trace_collection/wdp/wdp_host_connection';
 import {WinscopeProxyDeviceConnection} from 'trace_collection/winscope_proxy/winscope_proxy_device_connection';
 import {CollectTracesComponent} from './collect_traces_component';
 import {LoadProgressComponent} from './load_progress_component';
@@ -65,16 +68,15 @@ import {WdpSetupComponent} from './wdp_setup_component';
 import {WinscopeProxySetupComponent} from './winscope_proxy_setup_component';
 
 describe('CollectTracesComponent', () => {
-  let fixture: ComponentFixture<TestHostComponent>;
   let hostComponent: TestHostComponent;
   let component: CollectTracesComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<TestHostComponent>;
   let mockDevice: MockAdbDeviceConnection;
   let mockDeviceWatch: MockAdbDeviceConnection;
   const testFile = new File([], 'test_file');
 
   beforeAll(() => {
-    spyOn(window, 'open');
+    spyOn(WdpHostConnection.prototype, 'requestDevices');
   });
 
   beforeEach(async () => {
@@ -96,6 +98,7 @@ describe('CollectTracesComponent', () => {
         MatSelectModule,
         MatFormFieldModule,
         MatInputModule,
+        ClipboardModule,
       ],
       providers: [MatSnackBar],
       declarations: [
@@ -109,10 +112,10 @@ describe('CollectTracesComponent', () => {
       ],
       schemas: [NO_ERRORS_SCHEMA],
     }).compileComponents();
-    fixture = TestBed.createComponent(TestHostComponent);
+    const fixture = TestBed.createComponent(TestHostComponent);
     hostComponent = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
-    fixture.detectChanges();
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
+    dom.detectChanges();
     component = assertDefined(hostComponent.components?.get(0));
     mockDevice = new MockAdbDeviceConnection(
       '35562',
@@ -133,8 +136,8 @@ describe('CollectTracesComponent', () => {
   });
 
   it('renders the expected card title', () => {
-    const title = assertDefined(htmlElement.querySelector('.title'));
-    expect(title.textContent).toContain('Collect Traces');
+    const title = dom.get('.title');
+    title.checkText('Collect Traces');
   });
 
   it('defaults to overriding host', () => {
@@ -146,23 +149,21 @@ describe('CollectTracesComponent', () => {
   it('refreshes connection', () => {
     const controller = assertDefined(component.controller);
     const spy = spyOn(controller, 'restartConnection');
-    assertDefined(
-      htmlElement.querySelector<HTMLElement>('.refresh-connection'),
-    ).click();
+    dom.findAndClick('.refresh-connection');
     expect(spy).toHaveBeenCalled();
   });
 
   it('displays no connected devices', () => {
     setSpyWithDevices([]);
-    const el = assertDefined(htmlElement.querySelector('.devices-connecting'));
-    expect(el.textContent).toContain('No devices detected');
+    const el = dom.get('.devices-connecting');
+    el.checkText('No devices detected');
   });
 
   it('displays connected authorized devices', () => {
     setSpyWithDevices([mockDevice]);
-    const el = assertDefined(htmlElement.querySelector('.devices-connecting'));
-    expect(el.textContent).toContain('Pixel 6');
-    expect(el.textContent).toContain('smartphone');
+    const el = dom.get('.devices-connecting');
+    el.checkText('Pixel 6');
+    el.checkText('smartphone');
   });
 
   it('displays connected unauthorized devices', () => {
@@ -174,22 +175,19 @@ describe('CollectTracesComponent', () => {
         component,
       ),
     ]);
-    const el = assertDefined(htmlElement.querySelector('.devices-connecting'));
-    expect(el.textContent).toContain('unauthorized');
-    expect(el.textContent).toContain('screen_lock_portrait');
+    const el = dom.get('.devices-connecting');
+    el.checkText('unauthorized');
+    el.checkText('screen_lock_portrait');
   });
 
   it('detects changes in devices', async () => {
     const spy = setSpyWithDevices([]);
-    const el = assertDefined(htmlElement.querySelector('.devices-connecting'));
-    expect(el.textContent).toContain('No devices detected');
+    const el = dom.get('.devices-connecting');
+    el.checkText('No devices detected');
 
     spy.and.returnValue([mockDevice]);
-    fixture.detectChanges();
-    await fixture.whenStable();
-    expect(el.textContent?.trim()).toContain(
-      'Select a device: smartphone  Pixel 6 (35562)',
-    );
+    await dom.detectChangesAndWaitStable();
+    el.checkText('Select a device: smartphone  Pixel 6 (35562)');
   });
 
   it('displays connected devices again if selected device no longer present', () => {
@@ -197,74 +195,51 @@ describe('CollectTracesComponent', () => {
     clickAvailableDevice();
 
     spy.and.returnValue([mockDeviceWatch]);
-    fixture.detectChanges();
-    const el = assertDefined(htmlElement.querySelector('.devices-connecting'));
-    expect(el.textContent).toContain(
-      'Select a device: smartphone  Pixel Watch (75432)',
-    );
+    dom.detectChanges();
+    const el = dom.get('.devices-connecting');
+    el.checkText('Select a device: smartphone  Pixel Watch (75432)');
   });
 
   it('auto selects last device', () => {
     const spy = setSpyWithDevices([mockDevice]);
     clickAvailableDevice();
-    let configSection = assertDefined(
-      htmlElement.querySelector('.trace-collection-config'),
-    );
-    expect(configSection.textContent).toContain('Pixel 6');
+    let configSection = dom.get('.trace-collection-config');
+    configSection.checkText('Pixel 6');
 
     spy.and.returnValue([mockDeviceWatch]);
-    fixture.detectChanges();
+    dom.detectChanges();
 
-    const el = assertDefined(htmlElement.querySelector('.devices-connecting'));
-    expect(el.textContent).toContain(
-      'Select a device: smartphone  Pixel Watch (75432)',
-    );
-    expect(htmlElement.querySelector('.trace-collection-config')).toBeNull();
+    const el = dom.get('.devices-connecting');
+    el.checkText('Select a device: smartphone  Pixel Watch (75432)');
+    expect(dom.find('.trace-collection-config')).toBeUndefined();
 
     spy.and.returnValue([mockDevice]);
-    fixture.detectChanges();
-    configSection = assertDefined(
-      htmlElement.querySelector('.trace-collection-config'),
-    );
-    expect(configSection.textContent).toContain('Pixel 6');
+    dom.detectChanges();
+    configSection = dom.get('.trace-collection-config');
+    configSection.checkText('Pixel 6');
   });
 
   it('displays trace collection config elements', async () => {
     goToConfigSection();
 
-    const el = assertDefined(
-      htmlElement.querySelector('.trace-collection-config'),
-    );
-    expect(el.textContent).toContain('smartphone');
-    expect(el.textContent).toContain('Pixel 6');
-    expect(el.textContent).toContain('35562');
+    const el = dom.get('.trace-collection-config');
+    el.checkText('smartphone');
+    el.checkText('Pixel 6');
+    el.checkText('35562');
 
-    const traceSection = assertDefined(
-      htmlElement.querySelector('.trace-section'),
-    );
-    expect(traceSection.querySelector('trace-config')?.textContent).toContain(
-      'Trace targets',
-    );
-    expect(traceSection.querySelector('.start-btn')?.textContent).toContain(
-      'Start trace',
-    );
+    const traceSection = dom.get('.trace-section');
+    traceSection.get('trace-config').checkText('Trace targets');
+    traceSection.get('.start-btn').checkText('Start trace');
 
     await changeTab(1);
-    const dumpSection = assertDefined(
-      htmlElement.querySelector('.dump-section'),
-    );
-    expect(dumpSection.querySelector('trace-config')?.textContent).toContain(
-      'Dump targets',
-    );
-    expect(dumpSection.querySelector('.dump-btn')?.textContent).toContain(
-      'Dump state',
-    );
+    const dumpSection = dom.get('.dump-section');
+    dumpSection.get('trace-config').checkText('Dump targets');
+    dumpSection.get('.dump-btn').checkText('Dump state');
   });
 
   it('updates config on change in trace config component', async () => {
     goToConfigSection();
-    await fixture.whenStable();
-    fixture.detectChanges();
+    await dom.detectChangesAndWaitStable();
     clickCheckboxAndCheckTraceConfig(UiTraceTarget.WINDOW_MANAGER_TRACE, false);
     await changeTab(1);
     clickCheckboxAndCheckTraceConfig(UiTraceTarget.WINDOW_MANAGER_DUMP, true);
@@ -353,9 +328,7 @@ describe('CollectTracesComponent', () => {
 
     const controller = assertDefined(component.controller);
     const spy = spyOn(controller, 'restartConnection');
-    assertDefined(
-      htmlElement.querySelector<HTMLElement>('.change-btn'),
-    ).click();
+    dom.findAndClick('.change-btn');
     expect(spy).toHaveBeenCalled();
   });
 
@@ -368,10 +341,7 @@ describe('CollectTracesComponent', () => {
     const restartSpy = spyOn(controller, 'restartConnection');
     goToConfigSection();
 
-    assertDefined(htmlElement.querySelector<HTMLElement>('.fetch-btn')).click();
-    fixture.detectChanges();
-    await fixture.whenStable();
-
+    await dom.clickAndWaitStable('.fetch-btn');
     expect(emitSpy).toHaveBeenCalledOnceWith({
       requested: [],
       collected: [],
@@ -388,10 +358,7 @@ describe('CollectTracesComponent', () => {
     const restartSpy = spyOn(controller, 'restartConnection');
     goToConfigSection();
 
-    assertDefined(htmlElement.querySelector<HTMLElement>('.fetch-btn')).click();
-    fixture.detectChanges();
-    await fixture.whenStable();
-
+    await dom.clickAndWaitStable('.fetch-btn');
     expect(emitSpy).toHaveBeenCalledWith({
       requested: [],
       collected: [testFile],
@@ -401,33 +368,33 @@ describe('CollectTracesComponent', () => {
 
   it('displays unknown error message', () => {
     component.state = ConnectionState.ERROR;
-    fixture.detectChanges();
+    dom.detectChanges();
 
     const testErrorMessage = 'bad things are happening';
     component.errorText = testErrorMessage;
-    fixture.detectChanges();
+    dom.detectChanges();
 
-    const el = assertDefined(htmlElement.querySelector('.unknown-error'));
-    expect(el.textContent).toContain('Error:');
-    expect(el.textContent).toContain(testErrorMessage);
+    const el = dom.get('.unknown-error');
+    el.checkText('Error:');
+    el.checkText(testErrorMessage);
 
     const controller = assertDefined(component.controller);
     const spy = spyOn(controller, 'restartConnection');
-    assertDefined(htmlElement.querySelector<HTMLElement>('.retry-btn')).click();
+    dom.findAndClick('.retry-btn');
     expect(spy).toHaveBeenCalled();
   });
 
   it('displays starting trace elements', () => {
     goToConfigSection();
     component.onConnectionStateChange(ConnectionState.STARTING_TRACE);
-    fixture.detectChanges();
+    dom.detectChanges();
     checkTracingProgress('Starting trace...', true);
   });
 
   it('displays tracing elements and ends trace correctly', async () => {
     goToConfigSection();
     component.onConnectionStateChange(ConnectionState.TRACING);
-    fixture.detectChanges();
+    dom.detectChanges();
     checkTracingProgress('Tracing...', false);
 
     const controller = assertDefined(component.controller);
@@ -437,11 +404,7 @@ describe('CollectTracesComponent', () => {
     const fetchSpy = spyOn(controller, 'fetchLastSessionData').and.returnValue(
       Promise.resolve([]),
     );
-    assertDefined(
-      htmlElement.querySelector<HTMLElement>('.end-btn button'),
-    ).click();
-    fixture.detectChanges();
-    await fixture.whenStable();
+    await dom.clickAndWaitStable('.end-btn button');
     expect(endSpy).toHaveBeenCalled();
     expect(fetchSpy).toHaveBeenCalled();
   });
@@ -449,7 +412,7 @@ describe('CollectTracesComponent', () => {
   it('displays ending trace elements', () => {
     goToConfigSection();
     component.onConnectionStateChange(ConnectionState.ENDING_TRACE);
-    fixture.detectChanges();
+    dom.detectChanges();
     checkTracingProgress('Ending trace...', true);
   });
 
@@ -457,15 +420,15 @@ describe('CollectTracesComponent', () => {
     goToConfigSection();
     await changeTab(1);
     component.onConnectionStateChange(ConnectionState.DUMPING_STATE);
-    fixture.detectChanges();
-    const progress = assertDefined(htmlElement.querySelector('.dumping-state'));
-    expect(progress.querySelector('.end-btn button')).toBeNull();
+    dom.detectChanges();
+    const progress = dom.get('.dumping-state');
+    expect(progress.find('.end-btn button')).toBeUndefined();
   });
 
   it('displays loading data elements', async () => {
     goToConfigSection();
     await component.onConnectionStateChange(ConnectionState.LOADING_DATA);
-    fixture.detectChanges();
+    dom.detectChanges();
     checkTracingProgress('Fetching...');
   });
 
@@ -474,13 +437,7 @@ describe('CollectTracesComponent', () => {
     const spy = spyOn(controller, 'startTrace');
     goToConfigSection();
     const dialog = await openAndReturnDialog();
-
-    const buttons = dialog.querySelectorAll<HTMLElement>(
-      '.warning-action-buttons button',
-    );
-    buttons.item(buttons.length - 1).click();
-    fixture.detectChanges();
-    await fixture.whenStable();
+    await dialog.clickLastAndWaitStable('.warning-action-buttons button');
     expect(spy).toHaveBeenCalled();
   });
 
@@ -489,13 +446,9 @@ describe('CollectTracesComponent', () => {
     const spy = spyOn(controller, 'startTrace');
     goToConfigSection();
     const dialog = await openAndReturnDialog();
-    assertDefined(
-      dialog.querySelector<HTMLElement>('.warning-action-buttons button'),
-    ).click();
-    fixture.detectChanges();
-    await fixture.whenStable();
+    await dialog.clickAndWaitStable('.warning-action-buttons button');
     expect(spy).not.toHaveBeenCalled();
-    expect(htmlElement.querySelector('trace-config')).toBeTruthy();
+    expect(dom.find('trace-config')).toBeDefined();
   });
 
   it('does not show IME warning dialog again in same controller if user selects "Do not show again"', async () => {
@@ -504,26 +457,17 @@ describe('CollectTracesComponent', () => {
     goToConfigSection();
     const dialog = await openAndReturnDialog();
 
-    const option = assertDefined(
-      dialog.querySelector<HTMLInputElement>(
-        '.warning-action-boxes mat-checkbox input',
-      ),
-    );
-    option.checked = true;
+    const option = dialog.get('.warning-action-boxes mat-checkbox input');
+    option.getHTMLElement<HTMLInputElement>().checked = true;
     option.click();
-    fixture.detectChanges();
 
-    assertDefined(
-      dialog.querySelector<HTMLElement>('.warning-action-buttons button'),
-    ).click();
-    fixture.detectChanges();
-    await fixture.whenStable();
+    await dialog.clickAndWaitStable('.warning-action-buttons button');
     expect(spy).not.toHaveBeenCalled();
-    expect(htmlElement.querySelector('trace-config')).toBeTruthy();
+    expect(dom.find('trace-config')).toBeDefined();
 
     await clickStartTraceButton();
     expect(spy).toHaveBeenCalled();
-    expect(document.querySelector('warning-dialog')).toBeNull();
+    expect(dom.findInDocument('warning-dialog')).toBeUndefined();
   });
 
   it('handles successful external operations', () => {
@@ -531,8 +475,8 @@ describe('CollectTracesComponent', () => {
     component.onProgressUpdate('test operation', 0);
     checkTracingProgress('test operation');
     component.onOperationFinished(true);
-    expect(htmlElement.querySelector('.tracing-progress')).toBeNull();
-    expect(htmlElement.querySelector('.trace-collection-config')).toBeTruthy();
+    expect(dom.find('.tracing-progress')).toBeUndefined();
+    expect(dom.find('.trace-collection-config')).toBeDefined();
   });
 
   it('restarts host on unsuccessful external operation', () => {
@@ -550,8 +494,7 @@ describe('CollectTracesComponent', () => {
     const spy = spyOn(controller, 'dumpState');
     component.refreshDumps = true;
     await component.onConnectionStateChange(ConnectionState.CONNECTING);
-    fixture.detectChanges();
-    await fixture.whenStable();
+    await dom.detectChangesAndWaitStable();
     expect(spy).toHaveBeenCalledOnceWith(mockDevice, [
       {target: UiTraceTarget.WINDOW_MANAGER_DUMP, config: []},
       {target: UiTraceTarget.SURFACE_FLINGER_DUMP, config: []},
@@ -567,32 +510,28 @@ describe('CollectTracesComponent', () => {
     const spy = spyOn(controller, 'dumpState');
     component.refreshDumps = true;
     await component.onConnectionStateChange(ConnectionState.CONNECTING);
-    fixture.detectChanges();
-    await fixture.whenStable();
+    await dom.detectChangesAndWaitStable();
     expect(spy).not.toHaveBeenCalled();
   });
 
   it('refreshes dumps using stored dump config', async () => {
     goToConfigSection();
-    await fixture.whenStable();
-    fixture.detectChanges();
+    await dom.detectChangesAndWaitStable();
     await changeTab(1);
     clickCheckboxAndCheckTraceConfig(UiTraceTarget.WINDOW_MANAGER_DUMP, true);
 
     hostComponent.showFirstComponent = false;
-    fixture.detectChanges();
+    dom.detectChanges();
     hostComponent.showSecondComponent = true;
-    fixture.detectChanges();
-    await fixture.whenStable();
+    await dom.detectChangesAndWaitStable();
     const newComponent = assertDefined(hostComponent.components?.get(0));
     const controller = assertDefined(newComponent.controller);
     const spy = spyOn(controller, 'dumpState');
     await newComponent.onWinscopeEvent(new AppRefreshDumpsRequest());
-    fixture.detectChanges();
+    dom.detectChanges();
 
     await newComponent.onConnectionStateChange(ConnectionState.CONNECTING);
-    fixture.detectChanges();
-    await fixture.whenStable();
+    await dom.detectChangesAndWaitStable();
     const newDevice = new MockAdbDeviceConnection(
       '35562',
       'Pixel 6',
@@ -612,10 +551,10 @@ describe('CollectTracesComponent', () => {
     const config = component.traceConfig;
     expect(config[UiTraceTarget.WAYLAND]?.available).toBeFalse();
     component.onAvailableTracesChange([UiTraceTarget.WAYLAND], []);
-    fixture.detectChanges();
+    dom.detectChanges();
     expect(config[UiTraceTarget.WAYLAND]?.available).toBeTrue();
     component.onAvailableTracesChange([], [UiTraceTarget.WAYLAND]);
-    fixture.detectChanges();
+    dom.detectChanges();
     expect(config[UiTraceTarget.WAYLAND]?.available).toBeFalse();
   });
 
@@ -631,7 +570,7 @@ describe('CollectTracesComponent', () => {
     const userNotifierChecker = new UserNotifierChecker();
     const spy = spyOn(component, 'endTrace').and.callThrough();
     await component.onConnectionStateChange(ConnectionState.TRACE_TIMEOUT);
-    await fixture.whenStable();
+    await dom.whenStable();
     expect(spy).toHaveBeenCalledTimes(1);
     userNotifierChecker.expectAdded([new ProxyTraceTimeout()]);
   });
@@ -658,10 +597,9 @@ describe('CollectTracesComponent', () => {
   it('changes host type by default if in store', async () => {
     await changeConnection(1);
     hostComponent.showFirstComponent = false;
-    fixture.detectChanges();
+    dom.detectChanges();
     hostComponent.showSecondComponent = true;
-    fixture.detectChanges();
-    await fixture.whenStable();
+    await dom.detectChangesAndWaitStable();
     const component = assertDefined(hostComponent.components?.get(0));
     expect(component.controller?.getConnectionType()).toEqual(
       AdbConnectionType.WDP,
@@ -696,11 +634,10 @@ describe('CollectTracesComponent', () => {
       hostComponent.showFirstComponent = false;
       hostComponent.storage = new InMemoryStorage();
       hostComponent.showSecondComponent = true;
-      fixture.detectChanges();
-      await fixture.whenStable();
+      await dom.detectChangesAndWaitStable();
       component = assertDefined(hostComponent.components?.get(0));
       component.state = ConnectionState.UNAUTH;
-      fixture.detectChanges();
+      dom.detectChanges();
     });
 
     it('defaults to winscope proxy host', () => {
@@ -710,27 +647,15 @@ describe('CollectTracesComponent', () => {
     });
 
     it('displays proxy element if not adb success', () => {
-      expect(htmlElement.querySelector('winscope-proxy-setup')).toBeTruthy();
+      expect(dom.find('winscope-proxy-setup')).toBeTruthy();
     });
 
     it('adds security token and restarts host', async () => {
       const controller = assertDefined(component.controller);
       const securityTokenSpy = spyOn(controller, 'setSecurityToken');
       const restartSpy = spyOn(controller, 'restartConnection');
-
-      const proxyTokenInput = assertDefined(
-        htmlElement.querySelector<HTMLInputElement>(
-          '.proxy-token-input-field input',
-        ),
-      );
-      proxyTokenInput.value = '12345';
-      proxyTokenInput.dispatchEvent(new Event('input'));
-      fixture.detectChanges();
-
-      assertDefined(htmlElement.querySelector<HTMLElement>('.retry')).click();
-      fixture.detectChanges();
-      await fixture.whenStable();
-
+      dom.findAndDispatchInput('.proxy-token-input-field', '12345');
+      await dom.clickAndWaitStable('.retry');
       expect(securityTokenSpy).toHaveBeenCalledOnceWith('12345');
       expect(restartSpy).toHaveBeenCalledTimes(1);
     });
@@ -740,16 +665,16 @@ describe('CollectTracesComponent', () => {
       const stateSpy = spyOn(device, 'getState');
       setSpyWithDevices([device]);
       stateSpy.and.returnValue(AdbDeviceState.OFFLINE);
-      fixture.detectChanges();
-      expect(htmlElement.querySelector('.authorize-btn')).toBeNull();
+      dom.detectChanges();
+      expect(dom.find('.authorize-btn')).toBeUndefined();
 
       stateSpy.and.returnValue(AdbDeviceState.AVAILABLE);
-      fixture.detectChanges();
-      expect(htmlElement.querySelector('.authorize-btn')).toBeNull();
+      dom.detectChanges();
+      expect(dom.find('.authorize-btn')).toBeUndefined();
 
       stateSpy.and.returnValue(AdbDeviceState.UNAUTHORIZED);
-      fixture.detectChanges();
-      expect(htmlElement.querySelector('.authorize-btn')).toBeNull();
+      dom.detectChanges();
+      expect(dom.find('.authorize-btn')).toBeUndefined();
     });
   });
 
@@ -757,16 +682,15 @@ describe('CollectTracesComponent', () => {
     beforeEach(async () => {
       hostComponent.showSecondComponent = true;
       hostComponent.showFirstComponent = false;
-      fixture.detectChanges();
-      await fixture.whenStable();
+      await dom.detectChangesAndWaitStable();
       component = assertDefined(hostComponent.components?.get(0));
       await changeConnection(1);
       component.state = ConnectionState.UNAUTH;
-      fixture.detectChanges();
+      dom.detectChanges();
     });
 
     it('displays proxy element if not adb success', () => {
-      expect(htmlElement.querySelector('wdp-setup')).toBeTruthy();
+      expect(dom.find('wdp-setup')).toBeTruthy();
     });
 
     it('restarts host', async () => {
@@ -774,11 +698,7 @@ describe('CollectTracesComponent', () => {
       const securityTokenSpy = spyOn(controller, 'setSecurityToken');
       const restartSpy = spyOn(controller, 'restartConnection');
 
-      assertDefined(
-        htmlElement.querySelector<HTMLElement>('wdp-setup .retry'),
-      ).click();
-      fixture.detectChanges();
-      await fixture.whenStable();
+      await dom.clickAndWaitStable('wdp-setup .retry');
       expect(securityTokenSpy).not.toHaveBeenCalled();
       expect(restartSpy).toHaveBeenCalledTimes(1);
     });
@@ -789,19 +709,16 @@ describe('CollectTracesComponent', () => {
       const stateSpy = spyOn(device, 'getState');
       setSpyWithDevices([device]);
       stateSpy.and.returnValue(AdbDeviceState.OFFLINE);
-      fixture.detectChanges();
-      expect(htmlElement.querySelector('.authorize-btn')).toBeNull();
+      dom.detectChanges();
+      expect(dom.find('.authorize-btn')).toBeUndefined();
 
       stateSpy.and.returnValue(AdbDeviceState.AVAILABLE);
-      fixture.detectChanges();
-      expect(htmlElement.querySelector('.authorize-btn')).toBeNull();
+      dom.detectChanges();
+      expect(dom.find('.authorize-btn')).toBeUndefined();
 
       stateSpy.and.returnValue(AdbDeviceState.UNAUTHORIZED);
-      fixture.detectChanges();
-      assertDefined(
-        htmlElement.querySelector<HTMLElement>('.authorize-btn'),
-      ).click();
-      fixture.detectChanges();
+      dom.detectChanges();
+      dom.findAndClick('.authorize-btn');
       expect(authorizeSpy).toHaveBeenCalledTimes(1);
     });
   });
@@ -813,7 +730,7 @@ describe('CollectTracesComponent', () => {
     const controller = assertDefined(c.controller);
     c.state = ConnectionState.IDLE;
     const spy = spyOn(controller, 'getDevices').and.returnValue(devices);
-    fixture.detectChanges();
+    dom.detectChanges();
     return spy;
   }
 
@@ -823,10 +740,7 @@ describe('CollectTracesComponent', () => {
   }
 
   function clickAvailableDevice() {
-    assertDefined(
-      htmlElement.querySelector<HTMLElement>('.available-device'),
-    ).click();
-    fixture.detectChanges();
+    dom.findAndClick('.available-device');
   }
 
   function clickCheckboxAndCheckTraceConfig(
@@ -839,24 +753,18 @@ describe('CollectTracesComponent', () => {
         : component.traceConfig[key].config.enabled,
     ).toBeTrue();
 
-    const checkboxSection = assertDefined(
-      htmlElement.querySelector(isDump ? '.dump-section' : '.trace-section'),
-    );
-    const traceBoxes = Array.from(
-      checkboxSection.querySelectorAll<HTMLElement>('.trace-checkbox'),
+    const checkboxSection = dom.get(
+      isDump ? '.dump-section' : '.trace-section',
     );
+    const boxes = Array.from(checkboxSection.findAll('.trace-checkbox'));
 
     const expectedName = isDump
       ? component.dumpConfig[key].name
       : component.traceConfig[key].name;
     const traceBox = assertDefined(
-      traceBoxes.find((box) => box.textContent?.includes(expectedName)),
+      boxes.find((box) => box.getText()?.includes(expectedName)),
     );
-    const traceCheckboxInput = assertDefined(
-      traceBox.querySelector<HTMLInputElement>('input'),
-    );
-    traceCheckboxInput.click();
-    fixture.detectChanges();
+    traceBox.findAndClick('input');
     expect(
       isDump
         ? component.dumpConfig[key].config.enabled
@@ -871,44 +779,33 @@ describe('CollectTracesComponent', () => {
   }
 
   async function clickStartTraceButton() {
-    const start = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.start-btn button'),
-    );
-    start.click();
-    fixture.detectChanges();
-    await fixture.whenStable();
+    await dom.clickAndWaitStable('.start-btn button');
   }
 
   function checkTracingProgress(message: string, endButtonDisabled?: boolean) {
-    const el = assertDefined(htmlElement.querySelector('.tracing-progress'));
-    const progress = assertDefined(el.querySelector('load-progress'));
-    expect(progress.textContent).toContain(message);
-    const endButton = el.querySelector<HTMLButtonElement>('.end-btn button');
+    const el = dom.get('.tracing-progress');
+    const progress = el.get('load-progress');
+    progress.checkText(message);
+    const endButton = el.find('.end-btn button');
     if (endButtonDisabled === undefined) {
-      expect(endButton).toBeNull();
+      expect(endButton).toBeUndefined();
     } else {
-      expect(progress.innerHTML).toContain('cable');
-      expect(endButton?.disabled).toEqual(endButtonDisabled);
+      progress.checkInnerHTML('cable');
+      assertDefined(endButton).checkDisabled(endButtonDisabled);
     }
   }
 
   async function clickDumpStateButton() {
-    assertDefined(
-      htmlElement.querySelector<HTMLElement>('.dump-btn button'),
-    ).click();
-    fixture.detectChanges();
-    await fixture.whenStable();
+    await dom.clickAndWaitStable('.dump-btn button');
   }
 
-  async function openAndReturnDialog(): Promise<HTMLElement> {
+  async function openAndReturnDialog(): Promise<
+    DOMTestHelper<TestHostComponent>
+  > {
     updateTraceConfigToInvalidIMEFrameMapping();
     await clickStartTraceButton();
-    const dialog = assertDefined(
-      document.querySelector<HTMLElement>('warning-dialog'),
-    );
-    expect(dialog.textContent).toContain(
-      'Cannot build frame mapping for IME with selected traces',
-    );
+    const dialog = dom.getInDocument('warning-dialog');
+    dialog.checkText('Cannot build frame mapping for IME with selected traces');
     return dialog;
   }
 
@@ -925,7 +822,7 @@ describe('CollectTracesComponent', () => {
     );
     // does not update if no selected device
     component.onDevicesChange([device1]);
-    fixture.detectChanges();
+    dom.detectChanges();
     checkMediaBasedConfig([], false);
 
     goToConfigSection();
@@ -940,11 +837,11 @@ describe('CollectTracesComponent', () => {
       multiDisplayScreenRecording,
     );
     component.onDevicesChange([device2]);
-    fixture.detectChanges();
+    dom.detectChanges();
     checkMediaBasedConfig([], false);
 
     component.onDevicesChange([device1]);
-    fixture.detectChanges();
+    dom.detectChanges();
     checkMediaBasedConfig(['12345 Extra Info'], multiDisplayScreenRecording);
 
     if (multiDisplayScreenRecording) {
@@ -957,7 +854,7 @@ describe('CollectTracesComponent', () => {
         false,
       );
       component.onDevicesChange([device3]);
-      fixture.detectChanges();
+      dom.detectChanges();
       checkMediaBasedConfig(['12345 Extra Info'], false);
     }
   }
@@ -980,23 +877,15 @@ describe('CollectTracesComponent', () => {
   }
 
   async function changeConnection(index: number) {
-    assertDefined(
-      htmlElement.querySelector<HTMLElement>('.mat-select-trigger'),
-    ).click();
-    fixture.detectChanges();
-    await fixture.whenStable();
-    const options = document.querySelectorAll<HTMLElement>('.mat-option');
-    options.item(index).click();
-    fixture.detectChanges();
+    await dom.openMatSelect();
+    await dom.whenRenderingDone();
+    const panel = dom.getMatSelectPanel();
+    panel.findAndClickByIndex('.mat-option', index);
   }
 
   async function changeTab(index: number) {
-    const labels = htmlElement.querySelectorAll<HTMLElement>(
-      '.target-tabs .mat-tab-label',
-    );
-    labels[index].click();
-    fixture.detectChanges();
-    await fixture.whenStable();
+    const selector = '.target-tabs .mat-tab-label';
+    await dom.clickByIndexAndWaitStable(selector, index);
   }
 
   @Component({
diff --git a/tools/winscope/src/app/components/shortcuts_component_test.ts b/tools/winscope/src/app/components/shortcuts_component_test.ts
index 7d583c5aa..f1bb4ad28 100644
--- a/tools/winscope/src/app/components/shortcuts_component_test.ts
+++ b/tools/winscope/src/app/components/shortcuts_component_test.ts
@@ -14,25 +14,25 @@
  * limitations under the License.
  */
 import {HttpClientModule} from '@angular/common/http';
-import {ComponentFixture, TestBed} from '@angular/core/testing';
+import {TestBed} from '@angular/core/testing';
 import {MatDialogModule} from '@angular/material/dialog';
 import {MatIconModule} from '@angular/material/icon';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
 import {ShortcutsComponent} from './shortcuts_component';
 
 describe('ShortcutsComponent', () => {
-  let fixture: ComponentFixture<ShortcutsComponent>;
   let component: ShortcutsComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<ShortcutsComponent>;
 
   beforeEach(async () => {
     await TestBed.configureTestingModule({
       imports: [MatIconModule, HttpClientModule, MatDialogModule],
       declarations: [ShortcutsComponent],
     }).compileComponents();
-    fixture = TestBed.createComponent(ShortcutsComponent);
+    const fixture = TestBed.createComponent(ShortcutsComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
-    fixture.detectChanges();
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
+    dom.detectChanges();
   });
 
   it('can be created', () => {
@@ -41,21 +41,21 @@ describe('ShortcutsComponent', () => {
 
   it('renders key shortcuts', () => {
     checkShortcuts('.key-shortcut', [
-      ['zoom in'],
-      ['zoom out'],
-      ['slider left'],
-      ['slider right'],
-      ['previous'],
-      ['next'],
+      ['Zoom in'],
+      ['Zoom out'],
+      ['Move slider left'],
+      ['Move slider right'],
+      ['Previous state'],
+      ['Next state'],
     ]);
   });
 
   it('renders pointer shortcuts', () => {
     checkShortcuts('.pointer-shortcut', [
-      ['right click', 'bookmarks'],
-      ['vertical scroll', 'zoom'],
-      ['horizontal scroll', 'move slider'],
-      ['vertical scroll', 'zoom'],
+      ['Right click', 'bookmarks'],
+      ['Vertical Scroll', 'Zoom'],
+      ['Horizontal Scroll', 'Move slider'],
+      ['Vertical Scroll', 'Zoom'],
     ]);
   });
 
@@ -63,12 +63,12 @@ describe('ShortcutsComponent', () => {
     shortcutsSelector: string,
     expectedContent: string[][],
   ) {
-    const shortcuts = htmlElement.querySelectorAll(shortcutsSelector);
+    const shortcuts = dom.findAll(shortcutsSelector);
     expect(shortcuts.length).toEqual(expectedContent.length);
 
     for (let i = 0; i < expectedContent.length; i++) {
       expectedContent[i].forEach((s) => {
-        expect(shortcuts.item(i).textContent?.toLowerCase()).toContain(s);
+        shortcuts[i].checkText(s);
       });
     }
   }
diff --git a/tools/winscope/src/app/components/snack_bar_component.ts b/tools/winscope/src/app/components/snack_bar_component.ts
index 6ff36a84d..f6ee9a527 100644
--- a/tools/winscope/src/app/components/snack_bar_component.ts
+++ b/tools/winscope/src/app/components/snack_bar_component.ts
@@ -14,19 +14,30 @@
  * limitations under the License.
  */
 
-import {Component, Inject} from '@angular/core';
+import {Component, ElementRef, Inject} from '@angular/core';
 import {MatSnackBarRef, MAT_SNACK_BAR_DATA} from '@angular/material/snack-bar';
 
 @Component({
   selector: 'snack-bar',
   template: `
     <div class="snack-bar-container">
-      <p *ngFor="let message of messages" class="mat-body-1">
-        {{ message }}
-      </p>
-      <button color="primary" mat-button class="snack-bar-action" (click)="snackBarRef.dismiss()">
-        Close
-      </button>
+      <div class="message-container">
+        <p *ngFor="let message of messages" class="message mat-body-1">
+          {{ message }}
+        </p>
+      </div>
+      <div class="snack-bar-actions">
+        <button
+          color="primary"
+          mat-button
+          class="copy-button"
+          [cdkCopyToClipboard]="formatMessages()">Copy</button>
+        <button
+          color="primary"
+          mat-button
+          class="close-button"
+          (click)="snackBarRef.dismiss()">Close</button>
+      </div>
     </div>
   `,
   styles: [
@@ -34,9 +45,21 @@ import {MatSnackBarRef, MAT_SNACK_BAR_DATA} from '@angular/material/snack-bar';
       .snack-bar-container {
         display: flex;
         flex-direction: column;
+        white-space: pre-line;
       }
-      .snack-bar-action {
-        margin-left: 12px;
+      .message-container {
+        display: flex;
+        flex-direction: column;
+        white-space: pre-line;
+        max-height: 200px;
+        overflow-y: auto;
+      }
+      .message {
+        padding-block-end: 4px;
+      }
+      .snack-bar-actions {
+        display: flex;
+        justify-content: center;
       }
     `,
   ],
@@ -46,5 +69,10 @@ export class SnackBarComponent {
     @Inject(MatSnackBarRef)
     public snackBarRef: MatSnackBarRef<SnackBarComponent>,
     @Inject(MAT_SNACK_BAR_DATA) public messages: string[],
+    @Inject(ElementRef) public elementRef: ElementRef,
   ) {}
+
+  formatMessages(): string {
+    return this.messages.join('\n\n');
+  }
 }
diff --git a/tools/winscope/src/app/components/snack_bar_component_test.ts b/tools/winscope/src/app/components/snack_bar_component_test.ts
new file mode 100644
index 000000000..44a4c68d8
--- /dev/null
+++ b/tools/winscope/src/app/components/snack_bar_component_test.ts
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import {Clipboard, ClipboardModule} from '@angular/cdk/clipboard';
+import {TestBed} from '@angular/core/testing';
+import {MatButtonModule} from '@angular/material/button';
+import {MatSnackBarRef, MAT_SNACK_BAR_DATA} from '@angular/material/snack-bar';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
+import {SnackBarComponent} from './snack_bar_component';
+
+describe('SnackBarComponent', () => {
+  const messages = ['test message 1', 'test message 2'];
+  let component: SnackBarComponent;
+  let dom: DOMTestHelper<SnackBarComponent>;
+  let mockCopyText: jasmine.Spy;
+  let mockSnackbarRef: jasmine.SpyObj<MatSnackBarRef<SnackBarComponent>>;
+
+  beforeEach(async () => {
+    mockCopyText = jasmine.createSpy();
+    mockSnackbarRef = jasmine.createSpyObj('snackBarRef', ['dismiss']);
+    await TestBed.configureTestingModule({
+      providers: [
+        {provide: MatSnackBarRef, useValue: mockSnackbarRef},
+        {provide: MAT_SNACK_BAR_DATA, useValue: messages},
+        {provide: Clipboard, useValue: {copy: mockCopyText}},
+      ],
+      imports: [ClipboardModule, MatButtonModule],
+      declarations: [SnackBarComponent],
+    }).compileComponents();
+    const fixture = TestBed.createComponent(SnackBarComponent);
+    component = fixture.componentInstance;
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
+    dom.detectChanges();
+  });
+
+  it('shows all messages', () => {
+    const messageElements = dom.findAll('.message');
+    expect(messageElements.length).toEqual(2);
+    messageElements[0].checkTextExact(messages[0]);
+    messageElements[1].checkTextExact(messages[1]);
+  });
+
+  it('dismisses snackbar on close button click', () => {
+    dom.findAndClick('.snack-bar-actions .close-button');
+    expect(mockSnackbarRef.dismiss).toHaveBeenCalledTimes(1);
+  });
+
+  it('copies messages on copy button click', () => {
+    dom.findAndClick('.snack-bar-actions .copy-button');
+    expect(mockCopyText).toHaveBeenCalledOnceWith(messages.join('\n\n'));
+  });
+});
diff --git a/tools/winscope/src/app/components/snack_bar_opener_test.ts b/tools/winscope/src/app/components/snack_bar_opener_test.ts
index 2f96dc3c1..6bc0ef6d1 100644
--- a/tools/winscope/src/app/components/snack_bar_opener_test.ts
+++ b/tools/winscope/src/app/components/snack_bar_opener_test.ts
@@ -14,6 +14,7 @@
  * limitations under the License.
  */
 
+import {ClipboardModule} from '@angular/cdk/clipboard';
 import {Overlay} from '@angular/cdk/overlay';
 import {TestBed} from '@angular/core/testing';
 import {MatSnackBar, MatSnackBarRef} from '@angular/material/snack-bar';
@@ -22,7 +23,7 @@ import {
   FailedToInitializeTimelineData,
   NoValidFiles,
 } from 'messaging/user_warnings';
-import {waitToBeCalled} from 'test/utils';
+import {waitToBeCalled} from 'test/unit/spy_utils';
 import {SnackBarComponent} from './snack_bar_component';
 import {SnackBarOpener} from './snack_bar_opener';
 
@@ -39,7 +40,7 @@ describe('SnackBarOpener', () => {
   beforeEach(() => {
     TestBed.configureTestingModule({
       providers: [SnackBarOpener, MatSnackBar, Overlay],
-      imports: [BrowserAnimationsModule],
+      imports: [BrowserAnimationsModule, ClipboardModule],
       declarations: [SnackBarComponent],
     });
     snackBarOpener = TestBed.inject(SnackBarOpener);
diff --git a/tools/winscope/src/app/components/timeline/expanded-timeline/canvas_drawer.ts b/tools/winscope/src/app/components/timeline/expanded-timeline/canvas_drawer.ts
index b1481b285..72258c53c 100644
--- a/tools/winscope/src/app/components/timeline/expanded-timeline/canvas_drawer.ts
+++ b/tools/winscope/src/app/components/timeline/expanded-timeline/canvas_drawer.ts
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-import {TimelineUtils} from 'app/components/timeline/timeline_utils';
+import {convertHexToRgb} from 'app/components/timeline/timeline_utils';
 import {assertDefined} from 'common/assert_utils';
 import {Rect} from 'common/geometry/rect';
 
@@ -42,7 +42,7 @@ export class CanvasDrawer {
       throw new Error('Canvas not set');
     }
 
-    const rgbColor = TimelineUtils.convertHexToRgb(hexColor);
+    const rgbColor = convertHexToRgb(hexColor);
     if (rgbColor === undefined) {
       throw new Error('Failed to parse provided hex color');
     }
diff --git a/tools/winscope/src/app/components/timeline/expanded-timeline/default_timeline_row_component_test.ts b/tools/winscope/src/app/components/timeline/expanded-timeline/default_timeline_row_component_test.ts
index 704874fd0..84ea67fa6 100644
--- a/tools/winscope/src/app/components/timeline/expanded-timeline/default_timeline_row_component_test.ts
+++ b/tools/winscope/src/app/components/timeline/expanded-timeline/default_timeline_row_component_test.ts
@@ -15,7 +15,7 @@
  */
 
 import {DragDropModule} from '@angular/cdk/drag-drop';
-import {ComponentFixture, TestBed} from '@angular/core/testing';
+import {TestBed} from '@angular/core/testing';
 import {FormsModule, ReactiveFormsModule} from '@angular/forms';
 import {MatButtonModule} from '@angular/material/button';
 import {MatFormFieldModule} from '@angular/material/form-field';
@@ -28,15 +28,15 @@ import {assertDefined} from 'common/assert_utils';
 import {Rect} from 'common/geometry/rect';
 import {TimestampConverterUtils} from 'common/time/test_utils';
 import {TimeRange} from 'common/time/time';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
+import {waitToBeCalled} from 'test/unit/spy_utils';
 import {TraceBuilder} from 'test/unit/trace_builder';
-import {waitToBeCalled} from 'test/utils';
 import {TraceType} from 'trace/trace_type';
 import {DefaultTimelineRowComponent} from './default_timeline_row_component';
 
 describe('DefaultTimelineRowComponent', () => {
-  let fixture: ComponentFixture<DefaultTimelineRowComponent>;
   let component: DefaultTimelineRowComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<DefaultTimelineRowComponent>;
 
   beforeEach(async () => {
     await TestBed.configureTestingModule({
@@ -54,9 +54,9 @@ describe('DefaultTimelineRowComponent', () => {
       ],
       declarations: [DefaultTimelineRowComponent],
     }).compileComponents();
-    fixture = TestBed.createComponent(DefaultTimelineRowComponent);
+    const fixture = TestBed.createComponent(DefaultTimelineRowComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
   });
 
   it('can be created', () => {
@@ -65,14 +65,11 @@ describe('DefaultTimelineRowComponent', () => {
 
   it('can draw entries', async () => {
     setTraceAndSelectionRange(10n, 110n);
-
     const drawRectSpy = spyOn(
       component.canvasDrawer,
       'drawRect',
     ).and.callThrough();
-
-    fixture.detectChanges();
-    await fixture.whenRenderingDone();
+    await dom.detectChangesAndRenderingDone();
 
     const rectHeight = component.canvasDrawer.getScaledCanvasHeight();
     const rectWidth = rectHeight;
@@ -106,11 +103,8 @@ describe('DefaultTimelineRowComponent', () => {
 
   it('can draw entries zoomed in', async () => {
     setTraceAndSelectionRange(60n, 85n);
-
     const drawRectSpy = spyOn(component.canvasDrawer, 'drawRect');
-
-    fixture.detectChanges();
-    await fixture.whenRenderingDone();
+    await dom.detectChangesAndRenderingDone();
 
     const rectHeight = component.canvasDrawer.getScaledCanvasHeight();
     const rectWidth = rectHeight;
@@ -129,9 +123,7 @@ describe('DefaultTimelineRowComponent', () => {
 
   it('can draw hovering entry', async () => {
     setTraceAndSelectionRange(10n, 110n);
-
-    fixture.detectChanges();
-    await fixture.whenRenderingDone();
+    await dom.detectChangesAndRenderingDone();
 
     const drawRectSpy = spyOn(
       component.canvasDrawer,
@@ -154,9 +146,7 @@ describe('DefaultTimelineRowComponent', () => {
     );
     component.getCanvas().dispatchEvent(event);
 
-    fixture.detectChanges();
-    await fixture.whenRenderingDone();
-
+    await dom.detectChangesAndRenderingDone();
     await Promise.all(waitPromises);
 
     const rectHeight = component.canvasDrawer.getScaledCanvasHeight();
@@ -178,19 +168,14 @@ describe('DefaultTimelineRowComponent', () => {
 
   it('can draw correct entry on click of first entry', async () => {
     setTraceAndSelectionRange(10n, 110n);
-
-    fixture.detectChanges();
-    await fixture.whenRenderingDone();
-
+    await dom.detectChangesAndRenderingDone();
     // 9 rect draws - 4 entry rects present + 4 for redraw + 1 for selected entry
     await drawCorrectEntryOnClick(0, 10n, 9);
   });
 
   it('can draw correct entry on click of middle entry', async () => {
     setTraceAndSelectionRange(10n, 110n);
-
-    fixture.detectChanges();
-    await fixture.whenRenderingDone();
+    await dom.detectChangesAndRenderingDone();
 
     const canvasWidth = Math.floor(
       component.canvasDrawer.getScaledCanvasWidth() -
@@ -204,9 +189,7 @@ describe('DefaultTimelineRowComponent', () => {
 
   it('can draw correct entry on click when timeline zoomed in near start', async () => {
     setTraceAndSelectionRange(10n, 15n);
-
-    fixture.detectChanges();
-    await fixture.whenRenderingDone();
+    await dom.detectChangesAndRenderingDone();
 
     const canvasWidth = Math.floor(
       component.canvasDrawer.getScaledCanvasWidth() -
@@ -220,9 +203,7 @@ describe('DefaultTimelineRowComponent', () => {
 
   it('can draw correct entry on click when timeline zoomed in near end', async () => {
     setTraceAndSelectionRange(60n, 80n);
-
-    fixture.detectChanges();
-    await fixture.whenRenderingDone();
+    await dom.detectChangesAndRenderingDone();
 
     const canvasWidth = Math.floor(
       component.canvasDrawer.getScaledCanvasWidth() -
@@ -236,20 +217,15 @@ describe('DefaultTimelineRowComponent', () => {
 
   it('emits scroll event', async () => {
     setTraceAndSelectionRange(10n, 110n);
-    fixture.detectChanges();
-    await fixture.whenRenderingDone();
-
+    await dom.detectChangesAndRenderingDone();
     const spy = spyOn(component.onScrollEvent, 'emit');
-    htmlElement.dispatchEvent(new WheelEvent('wheel'));
-    fixture.detectChanges();
+    dom.dispatchEvent(new WheelEvent('wheel'));
     expect(spy).toHaveBeenCalled();
   });
 
   it('tracks mouse position', async () => {
     setTraceAndSelectionRange(10n, 110n);
-
-    fixture.detectChanges();
-    await fixture.whenRenderingDone();
+    await dom.detectChangesAndRenderingDone();
 
     const spy = spyOn(component.onMouseXRatioUpdate, 'emit');
     const canvas = assertDefined(component.canvasRef).nativeElement;
@@ -258,13 +234,13 @@ describe('DefaultTimelineRowComponent', () => {
     Object.defineProperty(mouseMoveEvent, 'target', {value: canvas});
     Object.defineProperty(mouseMoveEvent, 'offsetX', {value: 100});
     canvas.dispatchEvent(mouseMoveEvent);
-    fixture.detectChanges();
+    dom.detectChanges();
 
     expect(spy).toHaveBeenCalledWith(100 / canvas.offsetWidth);
 
     const mouseLeaveEvent = new MouseEvent('mouseleave');
     canvas.dispatchEvent(mouseLeaveEvent);
-    fixture.detectChanges();
+    dom.detectChanges();
     expect(spy).toHaveBeenCalledWith(undefined);
   });
 
@@ -305,9 +281,7 @@ describe('DefaultTimelineRowComponent', () => {
       component.canvasDrawer.getScaledCanvasHeight() / 2,
     );
     component.getCanvas().dispatchEvent(event);
-
-    fixture.detectChanges();
-    await fixture.whenRenderingDone();
+    await dom.detectChangesAndRenderingDone();
 
     await Promise.all(waitPromises);
 
diff --git a/tools/winscope/src/app/components/timeline/expanded-timeline/expanded_timeline_component_test.ts b/tools/winscope/src/app/components/timeline/expanded-timeline/expanded_timeline_component_test.ts
index 8a59898c3..c7bd96ba9 100644
--- a/tools/winscope/src/app/components/timeline/expanded-timeline/expanded_timeline_component_test.ts
+++ b/tools/winscope/src/app/components/timeline/expanded-timeline/expanded_timeline_component_test.ts
@@ -16,7 +16,7 @@
 
 import {DragDropModule} from '@angular/cdk/drag-drop';
 import {ChangeDetectionStrategy} from '@angular/core';
-import {ComponentFixture, TestBed} from '@angular/core/testing';
+import {TestBed} from '@angular/core/testing';
 import {FormsModule, ReactiveFormsModule} from '@angular/forms';
 import {MatButtonModule} from '@angular/material/button';
 import {MatFormFieldModule} from '@angular/material/form-field';
@@ -28,7 +28,8 @@ import {BrowserAnimationsModule} from '@angular/platform-browser/animations';
 import {TimelineData} from 'app/timeline_data';
 import {assertDefined} from 'common/assert_utils';
 import {TimestampConverterUtils} from 'common/time/test_utils';
-import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
+import {HierarchyTreeBuilder} from 'test/unit/hierarchy_tree_builder';
 import {TracesBuilder} from 'test/unit/traces_builder';
 import {TracePosition} from 'trace/trace_position';
 import {TraceType} from 'trace/trace_type';
@@ -37,9 +38,8 @@ import {ExpandedTimelineComponent} from './expanded_timeline_component';
 import {TransitionTimelineComponent} from './transition_timeline_component';
 
 describe('ExpandedTimelineComponent', () => {
-  let fixture: ComponentFixture<ExpandedTimelineComponent>;
   let component: ExpandedTimelineComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<ExpandedTimelineComponent>;
   let timelineData: TimelineData;
   const time10 = TimestampConverterUtils.makeRealTimestamp(10n);
   const time11 = TimestampConverterUtils.makeRealTimestamp(11n);
@@ -72,9 +72,9 @@ describe('ExpandedTimelineComponent', () => {
         set: {changeDetection: ChangeDetectionStrategy.Default},
       })
       .compileComponents();
-    fixture = TestBed.createComponent(ExpandedTimelineComponent);
+    const fixture = TestBed.createComponent(ExpandedTimelineComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
     timelineData = new TimelineData();
     const traces = new TracesBuilder()
       .setEntries(TraceType.SURFACE_FLINGER, [{}])
@@ -84,37 +84,21 @@ describe('ExpandedTimelineComponent', () => {
       .setEntries(TraceType.TRANSACTIONS, [{}])
       .setTimestamps(TraceType.TRANSACTIONS, [time12])
       .setEntries(TraceType.TRANSITION, [
-        new PropertyTreeBuilder()
-          .setIsRoot(true)
-          .setRootId('TransitionsTraceEntry')
+        new HierarchyTreeBuilder()
+          .setId('TransitionsTraceEntry')
           .setName('transition')
-          .setChildren([
-            {
-              name: 'wmData',
-              children: [{name: 'finishTimeNs', value: time30}],
-            },
-            {
-              name: 'shellData',
-              children: [{name: 'dispatchTimeNs', value: time10}],
-            },
-            {name: 'aborted', value: false},
-          ])
+          .setProperties({
+            finishTimeNs: time30,
+            dispatchTimeNs: time10,
+          })
           .build(),
-        new PropertyTreeBuilder()
-          .setIsRoot(true)
-          .setRootId('TransitionsTraceEntry')
+        new HierarchyTreeBuilder()
+          .setId('TransitionsTraceEntry')
           .setName('transition')
-          .setChildren([
-            {
-              name: 'wmData',
-              children: [{name: 'finishTimeNs', value: time110}],
-            },
-            {
-              name: 'shellData',
-              children: [{name: 'dispatchTimeNs', value: time60}],
-            },
-            {name: 'aborted', value: false},
-          ])
+          .setProperties({
+            finishTimeNs: time110,
+            dispatchTimeNs: time60,
+          })
           .build(),
       ])
       .setTimestamps(TraceType.TRANSITION, [time10, time60])
@@ -133,21 +117,17 @@ describe('ExpandedTimelineComponent', () => {
   });
 
   it('renders all timelines', () => {
-    fixture.detectChanges();
+    dom.detectChanges();
 
-    const timelineElements = htmlElement.querySelectorAll(
-      '.timeline.row single-timeline',
-    );
+    const timelineElements = dom.findAll('.timeline.row single-timeline');
     expect(timelineElements.length).toEqual(4);
 
-    const transitionElement = htmlElement.querySelectorAll(
-      '.timeline.row transition-timeline',
-    );
+    const transitionElement = dom.findAll('.timeline.row transition-timeline');
     expect(transitionElement.length).toEqual(1);
   });
 
   it('passes initial selectedEntry of correct type into each timeline', () => {
-    fixture.detectChanges();
+    dom.detectChanges();
 
     const singleTimelines = assertDefined(component.singleTimelines);
     expect(singleTimelines.length).toBe(4);
@@ -173,7 +153,7 @@ describe('ExpandedTimelineComponent', () => {
     assertDefined(component.timelineData).setPosition(
       TracePosition.fromTimestamp(time11),
     );
-    fixture.detectChanges();
+    dom.detectChanges();
 
     const singleTimelines = assertDefined(component.singleTimelines);
     expect(singleTimelines.length).toBe(4);
diff --git a/tools/winscope/src/app/components/timeline/expanded-timeline/transition_timeline_component.ts b/tools/winscope/src/app/components/timeline/expanded-timeline/transition_timeline_component.ts
index 3d8151b83..4763aa3f9 100644
--- a/tools/winscope/src/app/components/timeline/expanded-timeline/transition_timeline_component.ts
+++ b/tools/winscope/src/app/components/timeline/expanded-timeline/transition_timeline_component.ts
@@ -15,14 +15,19 @@
  */
 
 import {Component, Input} from '@angular/core';
-import {TimelineUtils} from 'app/components/timeline/timeline_utils';
+import {
+  getTimeRangeForTransition,
+  isTransitionWithUnknownEnd,
+  isTransitionWithUnknownStart,
+} from 'app/components/timeline/timeline_utils';
 import {assertDefined, assertTrue} from 'common/assert_utils';
 import {Point} from 'common/geometry/point';
 import {Rect} from 'common/geometry/rect';
 import {TimeRange, Timestamp} from 'common/time/time';
 import {AbsoluteEntryIndex, Trace, TraceEntry} from 'trace/trace';
 import {TraceType} from 'trace/trace_type';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
+import {TransitionStatus} from 'trace/transitions/status';
+import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 import {AbstractTimelineRowComponent} from './abstract_timeline_row_component';
 
 @Component({
@@ -53,13 +58,13 @@ import {AbstractTimelineRowComponent} from './abstract_timeline_row_component';
     `,
   ],
 })
-export class TransitionTimelineComponent extends AbstractTimelineRowComponent<PropertyTreeNode> {
-  @Input() selectedEntry: TraceEntry<PropertyTreeNode> | undefined;
-  @Input() trace: Trace<PropertyTreeNode> | undefined;
-  @Input() transitionEntries: Array<PropertyTreeNode | undefined> | undefined;
+export class TransitionTimelineComponent extends AbstractTimelineRowComponent<HierarchyTreeNode> {
+  @Input() selectedEntry: TraceEntry<HierarchyTreeNode> | undefined;
+  @Input() trace: Trace<HierarchyTreeNode> | undefined;
+  @Input() transitionEntries: Array<HierarchyTreeNode | undefined> | undefined;
   @Input() fullRange: TimeRange | undefined;
 
-  hoveringEntry?: TraceEntry<PropertyTreeNode>;
+  hoveringEntry?: TraceEntry<HierarchyTreeNode>;
   rowsToUse = new Map<number, number>();
   maxRowsRequires = 0;
   shouldNotRenderEntries: number[] = [];
@@ -116,7 +121,7 @@ export class TransitionTimelineComponent extends AbstractTimelineRowComponent<Pr
     if (!transition) {
       return undefined;
     }
-    const timeRange = TimelineUtils.getTimeRangeForTransition(
+    const timeRange = getTimeRangeForTransition(
       transition,
       assertDefined(this.selectionRange),
       assertDefined(this.timestampConverter),
@@ -130,7 +135,7 @@ export class TransitionTimelineComponent extends AbstractTimelineRowComponent<Pr
 
   protected override getEntryAt(
     mousePoint: Point,
-  ): TraceEntry<PropertyTreeNode> | undefined {
+  ): TraceEntry<HierarchyTreeNode> | undefined {
     const transitionEntries = assertDefined(this.trace).mapEntry(
       (entry) => entry,
     );
@@ -213,21 +218,18 @@ export class TransitionTimelineComponent extends AbstractTimelineRowComponent<Pr
     );
   }
 
-  private drawSegment(rect: Rect, transition: PropertyTreeNode) {
-    const aborted = assertDefined(
-      transition.getChildByName('aborted'),
-    ).getValue();
+  private drawSegment(rect: Rect, transition: HierarchyTreeNode) {
+    const aborted =
+      transition.getEagerPropertyByName('status')?.formattedValue() ===
+      TransitionStatus.ABORTED;
     const alpha = aborted ? 0.25 : 1.0;
 
-    const hasUnknownStart =
-      TimelineUtils.isTransitionWithUnknownStart(transition);
-    const hasUnknownEnd = TimelineUtils.isTransitionWithUnknownEnd(transition);
     this.canvasDrawer.drawRect(
       rect,
       this.color,
       alpha,
-      hasUnknownStart,
-      hasUnknownEnd,
+      isTransitionWithUnknownStart(transition),
+      isTransitionWithUnknownEnd(transition),
     );
   }
 
@@ -248,7 +250,7 @@ export class TransitionTimelineComponent extends AbstractTimelineRowComponent<Pr
         return;
       }
 
-      const timeRange = TimelineUtils.getTimeRangeForTransition(
+      const timeRange = getTimeRangeForTransition(
         transition,
         assertDefined(this.fullRange),
         assertDefined(this.timestampConverter),
diff --git a/tools/winscope/src/app/components/timeline/expanded-timeline/transition_timeline_component_test.ts b/tools/winscope/src/app/components/timeline/expanded-timeline/transition_timeline_component_test.ts
index a0f880c3f..1fae52134 100644
--- a/tools/winscope/src/app/components/timeline/expanded-timeline/transition_timeline_component_test.ts
+++ b/tools/winscope/src/app/components/timeline/expanded-timeline/transition_timeline_component_test.ts
@@ -16,7 +16,7 @@
 
 import {DragDropModule} from '@angular/cdk/drag-drop';
 import {ChangeDetectionStrategy} from '@angular/core';
-import {ComponentFixture, TestBed} from '@angular/core/testing';
+import {TestBed} from '@angular/core/testing';
 import {FormsModule, ReactiveFormsModule} from '@angular/forms';
 import {MatButtonModule} from '@angular/material/button';
 import {MatFormFieldModule} from '@angular/material/form-field';
@@ -29,17 +29,18 @@ import {assertDefined} from 'common/assert_utils';
 import {Rect} from 'common/geometry/rect';
 import {TimestampConverterUtils} from 'common/time/test_utils';
 import {TimeRange, Timestamp} from 'common/time/time';
-import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
+import {HierarchyTreeBuilder} from 'test/unit/hierarchy_tree_builder';
+import {waitToBeCalled} from 'test/unit/spy_utils';
 import {TraceBuilder} from 'test/unit/trace_builder';
-import {waitToBeCalled} from 'test/utils';
 import {TraceType} from 'trace/trace_type';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
+import {TransitionStatus} from 'trace/transitions/status';
+import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 import {TransitionTimelineComponent} from './transition_timeline_component';
 
 describe('TransitionTimelineComponent', () => {
-  let fixture: ComponentFixture<TransitionTimelineComponent>;
   let component: TransitionTimelineComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<TransitionTimelineComponent>;
 
   const time0 = TimestampConverterUtils.makeRealTimestamp(0n);
   const time5 = TimestampConverterUtils.makeRealTimestamp(5n);
@@ -76,9 +77,9 @@ describe('TransitionTimelineComponent', () => {
         set: {changeDetection: ChangeDetectionStrategy.Default},
       })
       .compileComponents();
-    fixture = TestBed.createComponent(TransitionTimelineComponent);
+    const fixture = TestBed.createComponent(TransitionTimelineComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
     component.timestampConverter = TimestampConverterUtils.TIMESTAMP_CONVERTER;
     component.fullRange = range0to160;
   });
@@ -227,14 +228,12 @@ describe('TransitionTimelineComponent', () => {
 
     const mouseoutEvent = new MouseEvent('mouseout');
     component.getCanvas().dispatchEvent(mouseoutEvent);
-    fixture.detectChanges();
-    await fixture.whenRenderingDone();
+    await dom.detectChangesAndRenderingDone();
     expect(drawRectSpy).not.toHaveBeenCalled();
 
     await dispatchMousemoveEvent();
     component.getCanvas().dispatchEvent(mouseoutEvent);
-    fixture.detectChanges();
-    await fixture.whenRenderingDone();
+    await dom.detectChangesAndRenderingDone();
 
     expect(drawRectSpy).toHaveBeenCalledOnceWith(
       getExpectedBorderedRect(),
@@ -403,7 +402,7 @@ describe('TransitionTimelineComponent', () => {
     const transition0 = makeTransition(time10, time30);
     const transition1 = makeTransition(time60, time110);
 
-    component.trace = new TraceBuilder<PropertyTreeNode>()
+    component.trace = new TraceBuilder<HierarchyTreeNode>()
       .setType(TraceType.TRANSITION)
       .setEntries([transition0, transition1])
       .setTimestamps([time10, time20])
@@ -413,18 +412,14 @@ describe('TransitionTimelineComponent', () => {
 
     const drawRectSpy = spyOn(component.canvasDrawer, 'drawRect');
 
-    fixture.detectChanges();
-    await fixture.whenRenderingDone();
-
+    await dom.detectChangesAndRenderingDone();
     expect(drawRectSpy).toHaveBeenCalledTimes(1);
   });
 
   it('emits scroll event', async () => {
     await setDefaultTraceAndSelectionRange();
-
     const spy = spyOn(component.onScrollEvent, 'emit');
-    htmlElement.dispatchEvent(new WheelEvent('wheel'));
-    fixture.detectChanges();
+    dom.dispatchEvent(new WheelEvent('wheel'));
     expect(spy).toHaveBeenCalled();
   });
 
@@ -438,19 +433,19 @@ describe('TransitionTimelineComponent', () => {
     Object.defineProperty(mouseMoveEvent, 'target', {value: canvas});
     Object.defineProperty(mouseMoveEvent, 'offsetX', {value: 100});
     canvas.dispatchEvent(mouseMoveEvent);
-    fixture.detectChanges();
+    dom.detectChanges();
 
     expect(spy).toHaveBeenCalledWith(100 / canvas.offsetWidth);
 
     const mouseLeaveEvent = new MouseEvent('mouseleave');
     canvas.dispatchEvent(mouseLeaveEvent);
-    fixture.detectChanges();
+    dom.detectChanges();
     expect(spy).toHaveBeenCalledWith(undefined);
   });
 
   async function setDefaultTraceAndSelectionRange(setSelectedEntry = false) {
     const transitions = [makeTransition(time35, time85)];
-    component.trace = new TraceBuilder<PropertyTreeNode>()
+    component.trace = new TraceBuilder<HierarchyTreeNode>()
       .setType(TraceType.TRANSITION)
       .setEntries(transitions)
       .setTimestamps([time35])
@@ -458,64 +453,42 @@ describe('TransitionTimelineComponent', () => {
     component.transitionEntries = transitions;
     component.selectionRange = range10to110;
     if (setSelectedEntry) component.selectedEntry = component.trace.getEntry(0);
-    fixture.detectChanges();
-    await fixture.whenRenderingDone();
+    await dom.detectChangesAndRenderingDone();
   }
 
   function makeTransition(
-    dispatchTime: Timestamp | undefined,
-    finishTime: Timestamp | undefined,
-    abortTime?: Timestamp,
-    createTime?: Timestamp,
-  ): PropertyTreeNode {
-    const shellDataChildren = [];
-    if (dispatchTime !== undefined) {
-      shellDataChildren.push({name: 'dispatchTimeNs', value: dispatchTime});
-    }
-    if (dispatchTime !== undefined) {
-      shellDataChildren.push({name: 'abortTimeNs', value: abortTime});
-    }
-
-    const wmDataChildren = [];
-    if (finishTime !== undefined) {
-      wmDataChildren.push({name: 'finishTimeNs', value: finishTime});
-    }
-    if (createTime !== undefined) {
-      wmDataChildren.push({name: 'createTimeNs', value: createTime});
-    }
-
-    return new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
+    dispatchTimeNs: Timestamp | undefined,
+    finishTimeNs: Timestamp | undefined,
+    shellAbortTimeNs?: Timestamp,
+    createTimeNs?: Timestamp,
+  ): HierarchyTreeNode {
+    return new HierarchyTreeBuilder()
+      .setId('TransitionsTraceEntry')
       .setName('transition')
-      .setChildren([
-        {
-          name: 'wmData',
-          children: wmDataChildren,
-        },
-        {
-          name: 'shellData',
-          children: shellDataChildren,
-        },
-        {name: 'aborted', value: abortTime !== undefined},
-      ])
+      .setProperties({
+        dispatchTimeNs,
+        shellAbortTimeNs,
+        finishTimeNs,
+        createTimeNs,
+        status:
+          shellAbortTimeNs !== undefined ? TransitionStatus.ABORTED : undefined,
+      })
       .build();
   }
 
   async function setTraceAndSelectionRange(
-    transitions: PropertyTreeNode[],
+    transitions: HierarchyTreeNode[],
     timestamps: Timestamp[],
     range = range10to110,
   ) {
-    component.trace = new TraceBuilder<PropertyTreeNode>()
+    component.trace = new TraceBuilder<HierarchyTreeNode>()
       .setType(TraceType.TRANSITION)
       .setEntries(transitions)
       .setTimestamps(timestamps)
       .build();
     component.transitionEntries = transitions;
     component.selectionRange = range;
-    fixture.detectChanges();
-    await fixture.whenRenderingDone();
+    await dom.detectChangesAndRenderingDone();
   }
 
   function getExpectedBorderedRect(): Rect {
@@ -538,7 +511,6 @@ describe('TransitionTimelineComponent', () => {
     );
     spyOnProperty(mousemoveEvent, 'offsetY').and.returnValue(25 / 2);
     component.getCanvas().dispatchEvent(mousemoveEvent);
-    fixture.detectChanges();
-    await fixture.whenRenderingDone();
+    await dom.detectChangesAndRenderingDone();
   }
 });
diff --git a/tools/winscope/src/app/components/timeline/mini-timeline/drawer/mini_timeline_drawer_impl.ts b/tools/winscope/src/app/components/timeline/mini-timeline/drawer/mini_timeline_drawer_impl.ts
index a5f5f04ae..31fa9d11a 100644
--- a/tools/winscope/src/app/components/timeline/mini-timeline/drawer/mini_timeline_drawer_impl.ts
+++ b/tools/winscope/src/app/components/timeline/mini-timeline/drawer/mini_timeline_drawer_impl.ts
@@ -16,7 +16,7 @@
 
 import {Color} from 'app/colors';
 import {Segment} from 'app/components/timeline/segment';
-import {TimelineUtils} from 'app/components/timeline/timeline_utils';
+import {convertHexToRgb} from 'app/components/timeline/timeline_utils';
 import {Point} from 'common/geometry/point';
 import {MouseEventButton} from 'common/mouse_event_button';
 import {Padding} from 'common/padding';
@@ -322,7 +322,7 @@ export class MiniTimelineDrawerImpl implements MiniTimelineDrawer {
       return;
     }
 
-    const rgbColor = TimelineUtils.convertHexToRgb(hexColor);
+    const rgbColor = convertHexToRgb(hexColor);
     if (rgbColor === undefined) {
       throw new Error('Failed to parse provided hex color');
     }
diff --git a/tools/winscope/src/app/components/timeline/mini-timeline/drawer/mini_timeline_drawer_input.ts b/tools/winscope/src/app/components/timeline/mini-timeline/drawer/mini_timeline_drawer_input.ts
index 4e2ad3078..8a2f98086 100644
--- a/tools/winscope/src/app/components/timeline/mini-timeline/drawer/mini_timeline_drawer_input.ts
+++ b/tools/winscope/src/app/components/timeline/mini-timeline/drawer/mini_timeline_drawer_input.ts
@@ -16,13 +16,17 @@
 
 import {Transformer} from 'app/components/timeline/mini-timeline/transformer';
 import {Segment} from 'app/components/timeline/segment';
-import {TimelineUtils} from 'app/components/timeline/timeline_utils';
+import {
+  getTimeRangeForTransition,
+  isTransitionWithUnknownEnd,
+  isTransitionWithUnknownStart,
+} from 'app/components/timeline/timeline_utils';
 import {TimelineData} from 'app/timeline_data';
 import {assertDefined} from 'common/assert_utils';
 import {TimeRange, Timestamp} from 'common/time/time';
 import {Trace, TraceEntry} from 'trace/trace';
 import {TraceType} from 'trace/trace_type';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
+import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 import {
   MiniCanvasDrawerData,
   TimelineTrace,
@@ -77,12 +81,12 @@ export class MiniTimelineDrawerInput {
           activePoint: undefined,
           segments: this.transformTransitionTraceTimestamps(
             transformer,
-            trace as Trace<PropertyTreeNode>,
+            trace as Trace<HierarchyTreeNode>,
           ),
           activeSegment: activeEntry
             ? this.transformTransitionEntry(
                 transformer,
-                activeEntry as TraceEntry<PropertyTreeNode>,
+                activeEntry as TraceEntry<HierarchyTreeNode>,
               )
             : undefined,
         });
@@ -103,7 +107,7 @@ export class MiniTimelineDrawerInput {
 
   private transformTransitionTraceTimestamps(
     transformer: Transformer,
-    trace: Trace<PropertyTreeNode>,
+    trace: Trace<HierarchyTreeNode>,
   ): Segment[] {
     return trace
       .mapEntry((entry) => this.transformTransitionEntry(transformer, entry))
@@ -118,16 +122,16 @@ export class MiniTimelineDrawerInput {
 
   private transformTransitionEntry(
     transformer: Transformer,
-    entry: TraceEntry<PropertyTreeNode>,
+    entry: TraceEntry<HierarchyTreeNode>,
   ): Segment | undefined {
-    const transition: PropertyTreeNode | undefined = this.timelineData
+    const transition: HierarchyTreeNode | undefined = this.timelineData
       .getTransitionEntries()
       .at(entry.getIndex());
     if (!transition) {
       return undefined;
     }
 
-    const timeRange = TimelineUtils.getTimeRangeForTransition(
+    const timeRange = getTimeRangeForTransition(
       transition,
       this.selection,
       assertDefined(this.timelineData.getTimestampConverter()),
@@ -140,8 +144,8 @@ export class MiniTimelineDrawerInput {
     return {
       from: transformer.transform(timeRange.from),
       to: transformer.transform(timeRange.to),
-      unknownStart: TimelineUtils.isTransitionWithUnknownStart(transition),
-      unknownEnd: TimelineUtils.isTransitionWithUnknownEnd(transition),
+      unknownStart: isTransitionWithUnknownStart(transition),
+      unknownEnd: isTransitionWithUnknownEnd(transition),
     };
   }
 
diff --git a/tools/winscope/src/app/components/timeline/mini-timeline/mini_timeline_component.ts b/tools/winscope/src/app/components/timeline/mini-timeline/mini_timeline_component.ts
index f1f4dbcf6..bdcd53ee2 100644
--- a/tools/winscope/src/app/components/timeline/mini-timeline/mini_timeline_component.ts
+++ b/tools/winscope/src/app/components/timeline/mini-timeline/mini_timeline_component.ts
@@ -28,6 +28,7 @@ import {
 } from '@angular/core';
 import {TimelineData} from 'app/timeline_data';
 import {assertDefined} from 'common/assert_utils';
+import {KeyboardEventCode} from 'common/dom_utils';
 import {PersistentStore} from 'common/store/persistent_store';
 import {TimeRange, Timestamp} from 'common/time/time';
 import {TimestampUtils} from 'common/time/timestamp_utils';
@@ -295,19 +296,22 @@ export class MiniTimelineComponent {
     if ((event.target as HTMLElement).tagName === 'INPUT') {
       return;
     }
-    if (event.code === 'KeyA') {
+    if (event.code === KeyboardEventCode.A) {
       this.updateSliderPosition(-MiniTimelineComponent.SLIDER_HORIZONTAL_STEP);
     }
-    if (event.code === 'KeyD') {
+    if (event.code === KeyboardEventCode.D) {
       this.updateSliderPosition(MiniTimelineComponent.SLIDER_HORIZONTAL_STEP);
     }
 
-    if (event.code !== 'KeyW' && event.code !== 'KeyS') {
+    if (
+      event.code !== KeyboardEventCode.W &&
+      event.code !== KeyboardEventCode.S
+    ) {
       return;
     }
 
     const zoomTo = this.hoverTimestamp;
-    const isZoomIn = event.code === 'KeyW';
+    const isZoomIn = event.code === KeyboardEventCode.W;
     Analytics.Navigation.logZoom('key', 'timeline', isZoomIn ? 'in' : 'out');
     isZoomIn ? this.zoomIn(zoomTo) : this.zoomOut(zoomTo);
   }
@@ -344,16 +348,15 @@ export class MiniTimelineComponent {
 
   @HostListener('wheel', ['$event'])
   onScroll(event: WheelEvent) {
-    const moveDirection = this.getMoveDirection(event);
+    if ((event.target as HTMLElement)?.id !== 'mini-timeline-canvas') {
+      return;
+    }
+    event.preventDefault();
 
-    if (
-      (event.target as HTMLElement)?.id === 'mini-timeline-canvas' &&
-      event.deltaY !== 0 &&
-      moveDirection === 'y'
-    ) {
+    const moveDirection = this.getMoveDirection(event);
+    if (event.deltaY !== 0 && moveDirection === 'y') {
       this.updateZoomByScrollEvent(event);
     }
-
     if (event.deltaX !== 0 && moveDirection === 'x') {
       this.updateHorizontalScroll(event);
     }
diff --git a/tools/winscope/src/app/components/timeline/mini-timeline/mini_timeline_component_test.ts b/tools/winscope/src/app/components/timeline/mini-timeline/mini_timeline_component_test.ts
index b50e68922..ab4fd3696 100644
--- a/tools/winscope/src/app/components/timeline/mini-timeline/mini_timeline_component_test.ts
+++ b/tools/winscope/src/app/components/timeline/mini-timeline/mini_timeline_component_test.ts
@@ -17,7 +17,7 @@
 import {DragDropModule} from '@angular/cdk/drag-drop';
 import {CdkMenuModule} from '@angular/cdk/menu';
 import {ChangeDetectionStrategy, Component, ViewChild} from '@angular/core';
-import {ComponentFixture, fakeAsync, TestBed} from '@angular/core/testing';
+import {fakeAsync, TestBed} from '@angular/core/testing';
 import {FormsModule, ReactiveFormsModule} from '@angular/forms';
 import {MatButtonModule} from '@angular/material/button';
 import {MatFormFieldModule} from '@angular/material/form-field';
@@ -28,10 +28,11 @@ import {MatTooltipModule} from '@angular/material/tooltip';
 import {BrowserAnimationsModule} from '@angular/platform-browser/animations';
 import {TimelineData} from 'app/timeline_data';
 import {assertDefined} from 'common/assert_utils';
+import {KeyboardEventCode} from 'common/dom_utils';
 import {TimestampConverterUtils} from 'common/time/test_utils';
 import {TimeRange, Timestamp} from 'common/time/time';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
 import {TracesBuilder} from 'test/unit/traces_builder';
-import {dragElement} from 'test/utils';
 import {Trace} from 'trace/trace';
 import {TracePosition} from 'trace/trace_position';
 import {TraceType} from 'trace/trace_type';
@@ -39,11 +40,15 @@ import {MiniTimelineComponent} from './mini_timeline_component';
 import {SliderComponent} from './slider_component';
 
 describe('MiniTimelineComponent', () => {
-  let fixture: ComponentFixture<TestHostComponent>;
   let component: TestHostComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<TestHostComponent>;
   let timelineData: TimelineData;
 
+  const resetButtonSelector = 'button#reset-zoom-btn';
+  const zoomInSelector = '#zoom-in-btn';
+  const zoomOutSelector = '#zoom-out-btn';
+  const zoomControlSelector = '.zoom-control';
+
   const timestamp10 = TimestampConverterUtils.makeRealTimestamp(10n);
   const timestamp15 = TimestampConverterUtils.makeRealTimestamp(15n);
   const timestamp16 = TimestampConverterUtils.makeRealTimestamp(16n);
@@ -92,9 +97,9 @@ describe('MiniTimelineComponent', () => {
         set: {changeDetection: ChangeDetectionStrategy.Default},
       })
       .compileComponents();
-    fixture = TestBed.createComponent(TestHostComponent);
+    const fixture = TestBed.createComponent(TestHostComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
 
     timelineData = new TimelineData();
     await timelineData.initialize(
@@ -113,7 +118,7 @@ describe('MiniTimelineComponent', () => {
   });
 
   it('redraws on resize', () => {
-    fixture.detectChanges();
+    dom.detectChanges();
     const miniTimelineComponent = assertDefined(
       component.miniTimelineComponent,
     );
@@ -121,7 +126,7 @@ describe('MiniTimelineComponent', () => {
     expect(spy).not.toHaveBeenCalled();
 
     window.dispatchEvent(new Event('resize'));
-    fixture.detectChanges();
+    dom.detectChanges();
 
     expect(spy).toHaveBeenCalled();
   });
@@ -133,61 +138,53 @@ describe('MiniTimelineComponent', () => {
     const zoomRange = timelineData.getZoomRange();
     expect(zoomRange).toEqual(expectedZoomRange);
     expect(zoomRange).not.toEqual(fullRange);
-    fixture.detectChanges();
-
-    getResetButton().click();
-    fixture.detectChanges();
-
+    dom.detectChanges();
+    dom.findAndClick(resetButtonSelector);
     expect(timelineData.getZoomRange()).toEqual(fullRange);
   });
 
   it('resets zoom to initial zoom on reset button click if available', () => {
     const initialZoom = new TimeRange(timestamp15, timestamp16);
     component.initialZoom = initialZoom;
-    fixture.detectChanges();
+    dom.detectChanges();
     expect(timelineData.getZoomRange()).toEqual(initialZoom);
 
     const newZoom = new TimeRange(timestamp10, timestamp16);
     timelineData.setZoom(newZoom);
     expect(timelineData.getZoomRange()).toEqual(newZoom);
-    fixture.detectChanges();
-
-    getResetButton().click();
-    fixture.detectChanges();
+    dom.detectChanges();
 
+    dom.findAndClick(resetButtonSelector);
     expect(timelineData.getZoomRange()).toEqual(initialZoom);
     expect(timelineData.getFullTimeRange()).not.toEqual(initialZoom);
   });
 
   it('show zoom controls when zoomed out', () => {
-    const zoomControlDiv = assertDefined(
-      htmlElement.querySelector('.zoom-control'),
+    const zoomControlDiv = dom.get(zoomControlSelector).getHTMLElement();
+    expect(window.getComputedStyle(zoomControlDiv).visibility).toEqual(
+      'visible',
     );
-    expect(window.getComputedStyle(zoomControlDiv).visibility).toBe('visible');
-
-    const zoomButton = getResetButton();
-    expect(window.getComputedStyle(zoomButton).visibility).toBe('visible');
+    const zoomButton = dom.get(resetButtonSelector).getHTMLElement();
+    expect(window.getComputedStyle(zoomButton).visibility).toEqual('visible');
   });
 
   it('shows zoom controls when zoomed in', () => {
     const zoom = new TimeRange(timestamp15, timestamp16);
     timelineData.setZoom(zoom);
+    dom.detectChanges();
 
-    fixture.detectChanges();
-
-    const zoomControlDiv = assertDefined(
-      htmlElement.querySelector('.zoom-control'),
+    const zoomControlDiv = dom.get(zoomControlSelector).getHTMLElement();
+    expect(window.getComputedStyle(zoomControlDiv).visibility).toEqual(
+      'visible',
     );
-    expect(window.getComputedStyle(zoomControlDiv).visibility).toBe('visible');
-
-    const zoomButton = getResetButton();
-    expect(window.getComputedStyle(zoomButton).visibility).toBe('visible');
+    const zoomButton = dom.get(resetButtonSelector).getHTMLElement();
+    expect(window.getComputedStyle(zoomButton).visibility).toEqual('visible');
   });
 
   it('loads with initial zoom', () => {
     const initialZoom = new TimeRange(timestamp15, timestamp16);
     component.initialZoom = initialZoom;
-    fixture.detectChanges();
+    dom.detectChanges();
     const timelineData = assertDefined(component.timelineData);
     const zoomRange = timelineData.getZoomRange();
     expect(zoomRange.from).toEqual(initialZoom.from);
@@ -195,22 +192,22 @@ describe('MiniTimelineComponent', () => {
   });
 
   it('updates timelineData on zoom changed', () => {
-    fixture.detectChanges();
+    dom.detectChanges();
     const zoom = new TimeRange(timestamp15, timestamp16);
     assertDefined(component.miniTimelineComponent).onZoomChanged(zoom);
-    fixture.detectChanges();
+    dom.detectChanges();
     expect(timelineData.getZoomRange()).toBe(zoom);
   });
 
   it('creates an appropriately sized canvas', () => {
-    fixture.detectChanges();
+    dom.detectChanges();
     const canvas = assertDefined(component.miniTimelineComponent).getCanvas();
     expect(canvas.width).toBeGreaterThan(100);
     expect(canvas.height).toBeGreaterThan(10);
   });
 
   it('getTracesToShow returns traces targeted by selectedTraces', () => {
-    fixture.detectChanges();
+    dom.detectChanges();
     const selectedTraces = assertDefined(component.selectedTraces);
     const selectedTracesTypes = selectedTraces.map((trace) => trace.type);
 
@@ -224,7 +221,7 @@ describe('MiniTimelineComponent', () => {
 
   it('getTracesToShow adds traces in correct order', () => {
     component.selectedTraces = [traceWm, traceSf, traceTransactions];
-    fixture.detectChanges();
+    dom.detectChanges();
     const tracesToShowTypes = assertDefined(component.miniTimelineComponent)
       .getTracesToShow()
       .map((trace) => trace.type);
@@ -236,16 +233,16 @@ describe('MiniTimelineComponent', () => {
   });
 
   it('updates zoom when slider moved', fakeAsync(() => {
-    fixture.detectChanges();
+    dom.detectChanges();
     const initialZoom = new TimeRange(timestamp15, timestamp16);
     assertDefined(component.miniTimelineComponent).onZoomChanged(initialZoom);
-    fixture.detectChanges();
-
-    const slider = assertDefined(htmlElement.querySelector('.slider .handle'));
-    expect(window.getComputedStyle(slider).visibility).toEqual('visible');
+    dom.detectChanges();
 
-    dragElement(fixture, slider, 100, 8);
+    const slider = dom.get('.slider .handle');
+    const sliderEl = slider.getHTMLElement();
+    expect(window.getComputedStyle(sliderEl).visibility).toEqual('visible');
 
+    slider.dragElement(100, 8);
     const finalZoom = timelineData.getZoomRange();
     expect(finalZoom).not.toBe(initialZoom);
   }));
@@ -259,16 +256,13 @@ describe('MiniTimelineComponent', () => {
     );
     miniTimelineComponent.onZoomChanged(initialZoom);
     miniTimelineComponent.currentTracePosition = position800;
+    dom.detectChanges();
 
-    fixture.detectChanges();
-
-    getZoomInButton().click();
-    fixture.detectChanges();
+    dom.findAndClick(zoomInSelector);
     const zoomedIn = timelineData.getZoomRange();
     checkZoomDifference(initialZoom, zoomedIn);
 
-    getZoomOutButton().click();
-    fixture.detectChanges();
+    dom.findAndClick(zoomOutSelector);
     const zoomedOut = timelineData.getZoomRange();
     checkZoomDifference(zoomedOut, zoomedIn);
   });
@@ -280,36 +274,32 @@ describe('MiniTimelineComponent', () => {
     assertDefined(component.miniTimelineComponent).onZoomChanged(initialZoom);
 
     timelineData.setPosition(position800);
-    fixture.detectChanges();
-
-    getZoomOutButton().click();
-    fixture.detectChanges();
+    dom.detectChanges();
 
+    dom.findAndClick(zoomOutSelector);
     let finalZoom = timelineData.getZoomRange();
-    expect(finalZoom.from.getValueNs()).toBe(initialZoom.from.getValueNs());
-    expect(finalZoom.to.getValueNs()).toBe(initialZoom.to.getValueNs());
+    expect(finalZoom.from.getValueNs()).toEqual(initialZoom.from.getValueNs());
+    expect(finalZoom.to.getValueNs()).toEqual(initialZoom.to.getValueNs());
 
+    setCanvasZeroXOffset();
     zoomOutByScrollWheel();
-
     finalZoom = timelineData.getZoomRange();
-    expect(finalZoom.from.getValueNs()).toBe(initialZoom.from.getValueNs());
-    expect(finalZoom.to.getValueNs()).toBe(initialZoom.to.getValueNs());
+    expect(finalZoom.from.getValueNs()).toEqual(initialZoom.from.getValueNs());
+    expect(finalZoom.to.getValueNs()).toEqual(initialZoom.to.getValueNs());
   });
 
   it('zooms in/out with scroll wheel', () => {
     initializeTraces();
-
     let initialZoom = new TimeRange(timestamp10, timestamp1000);
     const miniTimelineComponent = assertDefined(
       component.miniTimelineComponent,
     );
     miniTimelineComponent.onZoomChanged(initialZoom);
-
-    fixture.detectChanges();
+    dom.detectChanges();
+    setCanvasZeroXOffset();
 
     for (let i = 0; i < 10; i++) {
       zoomInByScrollWheel();
-
       const finalZoom = timelineData.getZoomRange();
       checkZoomDifference(initialZoom, finalZoom);
       initialZoom = finalZoom;
@@ -317,7 +307,6 @@ describe('MiniTimelineComponent', () => {
 
     for (let i = 0; i < 9; i++) {
       zoomOutByScrollWheel();
-
       const finalZoom = timelineData.getZoomRange();
       checkZoomDifference(finalZoom, initialZoom);
       initialZoom = finalZoom;
@@ -329,7 +318,7 @@ describe('MiniTimelineComponent', () => {
 
     const initialZoom = new TimeRange(timestamp10, timestamp1000);
     assertDefined(component.miniTimelineComponent).onZoomChanged(initialZoom);
-    fixture.detectChanges();
+    dom.detectChanges();
 
     component.expandedTimelineScrollEvent = {
       deltaY: -200,
@@ -337,41 +326,33 @@ describe('MiniTimelineComponent', () => {
       x: 10, // scrolling on pos
       target: component.miniTimelineComponent?.getCanvas(),
     } as unknown as WheelEvent;
-    fixture.detectChanges();
+    dom.detectChanges();
 
     const finalZoom = timelineData.getZoomRange();
     checkZoomDifference(initialZoom, finalZoom);
   });
 
   it('opens context menu', () => {
-    fixture.detectChanges();
-    expect(document.querySelector('.context-menu')).toBeFalsy();
-
-    assertDefined(component.miniTimelineComponent)
-      .getCanvas()
-      .dispatchEvent(new MouseEvent('contextmenu'));
-    fixture.detectChanges();
+    dom.detectChanges();
+    expect(dom.findInDocument('.context-menu')).toBeUndefined();
 
+    openContextMenu(assertDefined(component.miniTimelineComponent));
     const options = getContextMenuItems();
     expect(options.length).toEqual(2);
   });
 
   it('adds bookmark', () => {
-    fixture.detectChanges();
+    dom.detectChanges();
     const miniTimelineComponent = assertDefined(
       component.miniTimelineComponent,
     );
     const spy = spyOn(miniTimelineComponent.onToggleBookmark, 'emit');
 
-    miniTimelineComponent
-      .getCanvas()
-      .dispatchEvent(new MouseEvent('contextmenu'));
-    fixture.detectChanges();
-
+    openContextMenu(miniTimelineComponent);
     const options = getContextMenuItems();
-    expect(options[0].textContent).toContain('Add bookmark');
-    options[0].click();
+    options[0].checkText('Add bookmark');
 
+    options[0].click();
     expect(spy).toHaveBeenCalledWith({
       range: new TimeRange(timestamp10, timestamp10),
       rangeContainsBookmark: false,
@@ -380,21 +361,16 @@ describe('MiniTimelineComponent', () => {
 
   it('removes bookmark', () => {
     component.bookmarks = [timestamp10];
-    fixture.detectChanges();
+    dom.detectChanges();
     const miniTimelineComponent = assertDefined(
       component.miniTimelineComponent,
     );
     const spy = spyOn(miniTimelineComponent.onToggleBookmark, 'emit');
 
-    miniTimelineComponent
-      .getCanvas()
-      .dispatchEvent(new MouseEvent('contextmenu'));
-    fixture.detectChanges();
-
+    openContextMenu(assertDefined(component.miniTimelineComponent));
     const options = getContextMenuItems();
-    expect(options[0].textContent).toContain('Remove bookmark');
+    options[0].checkText('Remove bookmark');
     options[0].click();
-
     expect(spy).toHaveBeenCalledWith({
       range: new TimeRange(timestamp10, timestamp10),
       rangeContainsBookmark: true,
@@ -403,21 +379,17 @@ describe('MiniTimelineComponent', () => {
 
   it('removes all bookmarks', () => {
     component.bookmarks = [timestamp10, timestamp1000];
-    fixture.detectChanges();
+    dom.detectChanges();
     const miniTimelineComponent = assertDefined(
       component.miniTimelineComponent,
     );
     const spy = spyOn(miniTimelineComponent.onRemoveAllBookmarks, 'emit');
 
-    miniTimelineComponent
-      .getCanvas()
-      .dispatchEvent(new MouseEvent('contextmenu'));
-    fixture.detectChanges();
-
+    openContextMenu(miniTimelineComponent);
     const options = getContextMenuItems();
-    expect(options[1].textContent).toContain('Remove all bookmarks');
-    options[1].click();
+    options[1].checkText('Remove all bookmarks');
 
+    options[1].click();
     expect(spy).toHaveBeenCalled();
   });
 
@@ -426,7 +398,7 @@ describe('MiniTimelineComponent', () => {
 
     const initialZoom = new TimeRange(timestamp1000, timestamp2000);
     component.initialZoom = initialZoom;
-    fixture.detectChanges();
+    dom.detectChanges();
 
     zoomInByKeyW();
     const zoomedIn = timelineData.getZoomRange();
@@ -442,11 +414,12 @@ describe('MiniTimelineComponent', () => {
 
     const initialZoom = new TimeRange(timestamp1000, timestamp2000);
     component.initialZoom = initialZoom;
-    fixture.detectChanges();
+    dom.detectChanges();
 
     while (timelineData.getZoomRange().to !== timestamp4000) {
-      document.dispatchEvent(new KeyboardEvent('keydown', {code: 'KeyD'}));
-      fixture.detectChanges();
+      dom.dispatchEventInDocument(
+        new KeyboardEvent('keydown', {code: KeyboardEventCode.D}),
+      );
       const zoomRange = timelineData.getZoomRange();
       const increase =
         zoomRange.from.getValueNs() - initialZoom.from.getValueNs();
@@ -458,13 +431,15 @@ describe('MiniTimelineComponent', () => {
 
     // cannot move past end of trace
     const finalZoom = timelineData.getZoomRange();
-    document.dispatchEvent(new KeyboardEvent('keydown', {code: 'KeyD'}));
-    fixture.detectChanges();
+    dom.dispatchEventInDocument(
+      new KeyboardEvent('keydown', {code: KeyboardEventCode.D}),
+    );
     expect(timelineData.getZoomRange()).toEqual(finalZoom);
 
     while (timelineData.getZoomRange().from !== timestamp1000) {
-      document.dispatchEvent(new KeyboardEvent('keydown', {code: 'KeyA'}));
-      fixture.detectChanges();
+      dom.dispatchEventInDocument(
+        new KeyboardEvent('keydown', {code: KeyboardEventCode.A}),
+      );
       const zoomRange = timelineData.getZoomRange();
       const decrease =
         finalZoom.from.getValueNs() - zoomRange.from.getValueNs();
@@ -475,8 +450,9 @@ describe('MiniTimelineComponent', () => {
     }
 
     // cannot move before start of trace
-    document.dispatchEvent(new KeyboardEvent('keydown', {code: 'KeyA'}));
-    fixture.detectChanges();
+    dom.dispatchEventInDocument(
+      new KeyboardEvent('keydown', {code: KeyboardEventCode.A}),
+    );
     expect(timelineData.getZoomRange()).toEqual(initialZoom);
   });
 
@@ -485,7 +461,7 @@ describe('MiniTimelineComponent', () => {
     const initialZoom = new TimeRange(timestamp1000, timestamp4000);
     component.initialZoom = initialZoom;
     component.currentTracePosition = TracePosition.fromTimestamp(timestamp2000);
-    fixture.detectChanges();
+    dom.detectChanges();
 
     const miniTimelineComponent = assertDefined(
       component.miniTimelineComponent,
@@ -501,7 +477,7 @@ describe('MiniTimelineComponent', () => {
         (usableRange.to - usableRange.from) * 0.25 + drawer.getPadding().left,
     });
     canvas.dispatchEvent(mouseMoveEvent);
-    fixture.detectChanges();
+    dom.detectChanges();
 
     const fullRangeQuarterTimestamp = timestamp1750;
     checkZoomOnTimestamp(
@@ -511,6 +487,8 @@ describe('MiniTimelineComponent', () => {
       zoomInByKeyW,
       zoomOutByKeyS,
     );
+
+    setCanvasZeroXOffset();
     checkZoomOnTimestamp(
       fullRangeQuarterTimestamp,
       1n,
@@ -525,7 +503,7 @@ describe('MiniTimelineComponent', () => {
     const initialZoom = new TimeRange(timestamp1000, timestamp4000);
     component.initialZoom = initialZoom;
     component.currentTracePosition = TracePosition.fromTimestamp(timestamp1750);
-    fixture.detectChanges();
+    dom.detectChanges();
 
     const fullRangeQuarterTimestamp = timestamp1750;
     checkZoomOnTimestamp(
@@ -535,28 +513,18 @@ describe('MiniTimelineComponent', () => {
       zoomInByKeyW,
       zoomOutByKeyS,
     );
-    checkZoomOnTimestamp(
-      fullRangeQuarterTimestamp,
-      1n,
-      4n,
-      zoomInByScrollWheel,
-      zoomOutByScrollWheel,
-    );
-
-    const zoomInButton = getZoomInButton();
-    const zoomOutButton = getZoomOutButton();
 
+    const zoomInButton = dom.get(zoomInSelector);
+    const zoomOutButton = dom.get(zoomOutSelector);
     checkZoomOnTimestamp(
       fullRangeQuarterTimestamp,
       1n,
       4n,
       () => {
         zoomInButton.click();
-        fixture.detectChanges();
       },
       () => {
         zoomOutButton.click();
-        fixture.detectChanges();
       },
     );
   });
@@ -566,7 +534,7 @@ describe('MiniTimelineComponent', () => {
     const initialZoom = new TimeRange(timestamp1000, timestamp4000);
     component.initialZoom = initialZoom;
     component.currentTracePosition = TracePosition.fromTimestamp(timestamp1750);
-    fixture.detectChanges();
+    dom.detectChanges();
 
     const miniTimelineComponent = assertDefined(
       component.miniTimelineComponent,
@@ -581,9 +549,9 @@ describe('MiniTimelineComponent', () => {
       value: (usableRange.to - usableRange.from) * 0.5,
     });
     canvas.dispatchEvent(mouseMoveEvent);
-    fixture.detectChanges();
+    dom.detectChanges();
     canvas.dispatchEvent(new MouseEvent('mouseleave'));
-    fixture.detectChanges();
+    dom.detectChanges();
 
     const fullRangeQuarterTimestamp = timestamp1750;
     checkZoomOnTimestamp(
@@ -593,28 +561,18 @@ describe('MiniTimelineComponent', () => {
       zoomInByKeyW,
       zoomOutByKeyS,
     );
-    checkZoomOnTimestamp(
-      fullRangeQuarterTimestamp,
-      1n,
-      4n,
-      zoomInByScrollWheel,
-      zoomOutByScrollWheel,
-    );
-
-    const zoomInButton = getZoomInButton();
-    const zoomOutButton = getZoomOutButton();
 
+    const zoomInButton = dom.get(zoomInSelector);
+    const zoomOutButton = dom.get(zoomOutSelector);
     checkZoomOnTimestamp(
       fullRangeQuarterTimestamp,
       1n,
       4n,
       () => {
         zoomInButton.click();
-        fixture.detectChanges();
       },
       () => {
         zoomOutButton.click();
-        fixture.detectChanges();
       },
     );
   });
@@ -624,7 +582,7 @@ describe('MiniTimelineComponent', () => {
     const initialZoom = new TimeRange(timestamp2000, timestamp4000);
     component.initialZoom = initialZoom;
     component.currentTracePosition = TracePosition.fromTimestamp(timestamp1750);
-    fixture.detectChanges();
+    dom.detectChanges();
 
     const fullRangeMiddleTimestamp = timestamp3000;
     checkZoomOnTimestamp(
@@ -634,6 +592,8 @@ describe('MiniTimelineComponent', () => {
       zoomInByKeyW,
       zoomOutByKeyS,
     );
+
+    setCanvasZeroXOffset();
     checkZoomOnTimestamp(
       fullRangeMiddleTimestamp,
       1n,
@@ -642,20 +602,17 @@ describe('MiniTimelineComponent', () => {
       zoomOutByScrollWheel,
     );
 
-    const zoomInButton = getZoomInButton();
-    const zoomOutButton = getZoomOutButton();
-
+    const zoomInButton = dom.get(zoomInSelector);
+    const zoomOutButton = dom.get(zoomOutSelector);
     checkZoomOnTimestamp(
       fullRangeMiddleTimestamp,
       1n,
       2n,
       () => {
         zoomInButton.click();
-        fixture.detectChanges();
       },
       () => {
         zoomOutButton.click();
-        fixture.detectChanges();
       },
     );
   });
@@ -664,10 +621,10 @@ describe('MiniTimelineComponent', () => {
     initializeTracesForWASDZoom();
     const initialZoom = new TimeRange(timestamp1000, timestamp4000);
     component.initialZoom = initialZoom;
-    fixture.detectChanges();
+    dom.detectChanges();
     component.currentTracePosition = TracePosition.fromTimestamp(timestamp2000);
     component.expandedTimelineMouseXRatio = 0.25;
-    fixture.detectChanges();
+    dom.detectChanges();
 
     const fullRangeQuarterTimestamp = timestamp1750;
     checkZoomOnTimestamp(
@@ -677,6 +634,8 @@ describe('MiniTimelineComponent', () => {
       zoomInByKeyW,
       zoomOutByKeyS,
     );
+
+    setCanvasZeroXOffset();
     checkZoomOnTimestamp(
       fullRangeQuarterTimestamp,
       1n,
@@ -698,7 +657,7 @@ describe('MiniTimelineComponent', () => {
       undefined,
       TimestampConverterUtils.TIMESTAMP_CONVERTER,
     );
-    fixture.detectChanges();
+    dom.detectChanges();
   }
 
   function initializeTracesForWASDZoom() {
@@ -731,56 +690,45 @@ describe('MiniTimelineComponent', () => {
   }
 
   function zoomInByKeyW() {
-    document.dispatchEvent(new KeyboardEvent('keydown', {code: 'KeyW'}));
-    fixture.detectChanges();
+    dom.dispatchEventInDocument(
+      new KeyboardEvent('keydown', {code: KeyboardEventCode.W}),
+    );
   }
 
   function zoomOutByKeyS() {
-    document.dispatchEvent(new KeyboardEvent('keydown', {code: 'KeyS'}));
-    fixture.detectChanges();
+    dom.dispatchEventInDocument(
+      new KeyboardEvent('keydown', {code: KeyboardEventCode.S}),
+    );
   }
 
   function zoomInByScrollWheel() {
-    assertDefined(component.miniTimelineComponent).onScroll({
-      deltaY: -200,
-      deltaX: 0,
-      x: 10, // scrolling on pos
-      target: {id: 'mini-timeline-canvas', offsetLeft: 0},
-    } as unknown as WheelEvent);
-    fixture.detectChanges();
+    const wheelEvent = new WheelEvent('wheel');
+    spyOnProperty(wheelEvent, 'x').and.returnValue(10);
+    spyOnProperty(wheelEvent, 'deltaY').and.returnValue(-200);
+    zoomByScroll(wheelEvent);
   }
 
   function zoomOutByScrollWheel() {
-    assertDefined(component.miniTimelineComponent).onScroll({
-      deltaY: 200,
-      deltaX: 0,
-      x: 10, // scrolling on pos
-      target: {id: 'mini-timeline-canvas', offsetLeft: 0},
-    } as unknown as WheelEvent);
-    fixture.detectChanges();
+    const wheelEvent = new WheelEvent('wheel');
+    spyOnProperty(wheelEvent, 'y').and.returnValue(10);
+    spyOnProperty(wheelEvent, 'deltaY').and.returnValue(200);
+    zoomByScroll(wheelEvent);
   }
 
-  function getResetButton(): HTMLElement {
-    return assertDefined(
-      htmlElement.querySelector<HTMLElement>('button#reset-zoom-btn'),
-    );
-  }
+  function zoomByScroll(wheelEvent: WheelEvent) {
+    const spy = spyOn(wheelEvent, 'preventDefault').and.callThrough();
+    spyOnProperty(wheelEvent, 'deltaX').and.returnValue(0);
 
-  function getZoomInButton(): HTMLElement {
-    return assertDefined(
-      htmlElement.querySelector<HTMLElement>('#zoom-in-btn'),
-    );
-  }
+    const canvas = assertDefined(component.miniTimelineComponent?.getCanvas());
+    spyOnProperty(wheelEvent, 'target').and.returnValue(canvas);
 
-  function getZoomOutButton(): HTMLElement {
-    return assertDefined(
-      htmlElement.querySelector<HTMLElement>('#zoom-out-btn'),
-    );
+    dom.get('mini-timeline').dispatchEvent(wheelEvent);
+    dom.detectChanges();
+    expect(spy).toHaveBeenCalledTimes(1);
   }
 
-  function getContextMenuItems(): HTMLElement[] {
-    const menu = assertDefined(document.querySelector('.context-menu'));
-    return Array.from(menu.querySelectorAll<HTMLElement>('.context-menu-item'));
+  function getContextMenuItems(): Array<DOMTestHelper<TestHostComponent>> {
+    return dom.getInDocument('.context-menu')?.findAll('.context-menu-item');
   }
 
   function checkZoomOnTimestamp(
@@ -827,6 +775,18 @@ describe('MiniTimelineComponent', () => {
     }
   }
 
+  function openContextMenu(miniTimelineComponent: MiniTimelineComponent) {
+    miniTimelineComponent
+      .getCanvas()
+      .dispatchEvent(new MouseEvent('contextmenu'));
+    dom.detectChanges();
+  }
+
+  function setCanvasZeroXOffset() {
+    const canvas = assertDefined(component.miniTimelineComponent).getCanvas();
+    spyOnProperty(canvas, 'offsetLeft').and.returnValue(0);
+  }
+
   @Component({
     selector: 'host-component',
     template: `
diff --git a/tools/winscope/src/app/components/timeline/mini-timeline/slider_component_test.ts b/tools/winscope/src/app/components/timeline/mini-timeline/slider_component_test.ts
index fd656fa46..805d0e592 100644
--- a/tools/winscope/src/app/components/timeline/mini-timeline/slider_component_test.ts
+++ b/tools/winscope/src/app/components/timeline/mini-timeline/slider_component_test.ts
@@ -16,7 +16,7 @@
 
 import {DragDropModule} from '@angular/cdk/drag-drop';
 import {ChangeDetectionStrategy} from '@angular/core';
-import {ComponentFixture, fakeAsync, TestBed} from '@angular/core/testing';
+import {fakeAsync, TestBed} from '@angular/core/testing';
 import {FormsModule, ReactiveFormsModule} from '@angular/forms';
 import {MatButtonModule} from '@angular/material/button';
 import {MatFormFieldModule} from '@angular/material/form-field';
@@ -28,14 +28,15 @@ import {BrowserAnimationsModule} from '@angular/platform-browser/animations';
 import {assertDefined} from 'common/assert_utils';
 import {TimestampConverterUtils} from 'common/time/test_utils';
 import {TimeRange} from 'common/time/time';
-import {dragElement} from 'test/utils';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
 import {TracePosition} from 'trace/trace_position';
 import {MIN_SLIDER_WIDTH, SliderComponent} from './slider_component';
 
 describe('SliderComponent', () => {
-  let fixture: ComponentFixture<SliderComponent>;
   let component: SliderComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<SliderComponent>;
+  const leftCropperSelector = '.slider .cropper.left';
+  const rightCropperSelector = '.slider .cropper.right';
   const time100 = TimestampConverterUtils.makeRealTimestamp(100n);
   const time125 = TimestampConverterUtils.makeRealTimestamp(125n);
   const time126 = TimestampConverterUtils.makeRealTimestamp(126n);
@@ -63,16 +64,14 @@ describe('SliderComponent', () => {
         set: {changeDetection: ChangeDetectionStrategy.Default},
       })
       .compileComponents();
-    fixture = TestBed.createComponent(SliderComponent);
+    const fixture = TestBed.createComponent(SliderComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
-
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
     component.fullRange = new TimeRange(time100, time200);
     component.zoomRange = new TimeRange(time125, time175);
     component.currentPosition = TracePosition.fromTimestamp(time150);
     component.timestampConverter = TimestampConverterUtils.TIMESTAMP_CONVERTER;
-
-    fixture.detectChanges();
+    dom.detectChanges();
   });
 
   it('can be created', () => {
@@ -80,7 +79,7 @@ describe('SliderComponent', () => {
   });
 
   it('reposition properly on zoom', () => {
-    fixture.detectChanges();
+    dom.detectChanges();
     component.ngOnChanges({
       zoomRange: {
         firstChange: true,
@@ -89,18 +88,18 @@ describe('SliderComponent', () => {
         currentValue: component.zoomRange,
       },
     });
-    fixture.detectChanges();
+    dom.detectChanges();
 
-    const sliderWitdth = component.sliderBox.nativeElement.offsetWidth;
-    expect(component.sliderWidth).toBe(sliderWitdth / 2);
-    expect(component.dragPosition.x).toBe(sliderWitdth / 4);
+    const sliderWidth = component.sliderBox.nativeElement.offsetWidth;
+    expect(component.sliderWidth).toEqual(sliderWidth / 2);
+    expect(component.dragPosition.x).toEqual(sliderWidth / 4);
   });
 
   it('has min width', () => {
     component.fullRange = new TimeRange(time100, time200);
     component.zoomRange = new TimeRange(time125, time126);
 
-    fixture.detectChanges();
+    dom.detectChanges();
     component.ngOnChanges({
       zoomRange: {
         firstChange: true,
@@ -109,21 +108,19 @@ describe('SliderComponent', () => {
         currentValue: component.zoomRange,
       },
     });
-    fixture.detectChanges();
+    dom.detectChanges();
 
     const sliderWidth = component.sliderBox.nativeElement.offsetWidth;
-    expect(component.sliderWidth).toBe(MIN_SLIDER_WIDTH);
-    expect(component.dragPosition.x).toBe(
+    expect(component.sliderWidth).toEqual(MIN_SLIDER_WIDTH);
+    expect(component.dragPosition.x).toEqual(
       sliderWidth / 4 - MIN_SLIDER_WIDTH / 2,
     );
   });
 
   it('repositions slider on resize', () => {
-    const slider = assertDefined(htmlElement.querySelector('.slider'));
-    const cursor = assertDefined(htmlElement.querySelector('.cursor'));
-
-    fixture.detectChanges();
-
+    const slider = dom.get('.slider').getHTMLElement();
+    const cursor = dom.get('.cursor').getHTMLElement();
+    dom.detectChanges();
     const initialSliderXPos = slider.getBoundingClientRect().left;
     const initialCursorXPos = cursor.getBoundingClientRect().left;
 
@@ -132,18 +129,17 @@ describe('SliderComponent', () => {
       'offsetWidth',
       'get',
     ).and.returnValue(100);
-    expect(component.sliderBox.nativeElement.offsetWidth).toBe(100);
+    expect(component.sliderBox.nativeElement.offsetWidth).toEqual(100);
 
-    htmlElement.style.width = '587px';
+    slider.style.width = '587px';
     window.dispatchEvent(new Event('resize'));
-    fixture.detectChanges();
-
-    expect(initialSliderXPos).not.toBe(slider.getBoundingClientRect().left);
-    expect(initialCursorXPos).not.toBe(cursor.getBoundingClientRect().left);
+    dom.detectChanges();
+    expect(initialSliderXPos).not.toEqual(slider.getBoundingClientRect().left);
+    expect(initialCursorXPos).not.toEqual(cursor.getBoundingClientRect().left);
   });
 
   it('draws current position cursor', () => {
-    fixture.detectChanges();
+    dom.detectChanges();
     component.ngOnChanges({
       currentPosition: {
         firstChange: true,
@@ -152,12 +148,10 @@ describe('SliderComponent', () => {
         currentValue: component.currentPosition,
       },
     });
-    fixture.detectChanges();
+    dom.detectChanges();
 
-    const sliderBox = assertDefined(
-      htmlElement.querySelector('#timeline-slider-box'),
-    );
-    const cursor = assertDefined(htmlElement.querySelector('.cursor'));
+    const sliderBox = dom.get('#timeline-slider-box').getHTMLElement();
+    const cursor = dom.get('.cursor').getHTMLElement();
     const sliderBoxRect = sliderBox.getBoundingClientRect();
     expect(cursor.getBoundingClientRect().left).toBeCloseTo(
       (sliderBoxRect.left + sliderBoxRect.right) / 2,
@@ -166,8 +160,7 @@ describe('SliderComponent', () => {
   });
 
   it('moving slider around updates zoom', fakeAsync(async () => {
-    fixture.detectChanges();
-
+    dom.detectChanges();
     const initialZoom = assertDefined(component.zoomRange);
 
     let lastZoomUpdate: TimeRange | undefined = undefined;
@@ -177,27 +170,21 @@ describe('SliderComponent', () => {
       },
     );
 
-    const slider = htmlElement.querySelector('.slider .handle');
-    expect(slider).toBeTruthy();
-    expect(window.getComputedStyle(assertDefined(slider)).visibility).toBe(
-      'visible',
-    );
-
-    dragElement(fixture, assertDefined(slider), 100, 8);
+    const slider = dom.get('.slider .handle');
+    checkVisible(slider.getHTMLElement());
 
+    slider.dragElement(100, 8);
     expect(zoomChangedSpy).toHaveBeenCalled();
-
     const finalZoom = assertDefined<TimeRange>(lastZoomUpdate);
-    expect(finalZoom.from).not.toBe(initialZoom.from);
-    expect(finalZoom.to).not.toBe(initialZoom.to);
-    expect(finalZoom.to.minus(finalZoom.from.getValueNs()).getValueNs()).toBe(
-      initialZoom.to.minus(initialZoom.from.getValueNs()).getValueNs(),
-    );
+    expect(finalZoom.from).not.toEqual(initialZoom.from);
+    expect(finalZoom.to).not.toEqual(initialZoom.to);
+    expect(
+      finalZoom.to.minus(finalZoom.from.getValueNs()).getValueNs(),
+    ).toEqual(initialZoom.to.minus(initialZoom.from.getValueNs()).getValueNs());
   }));
 
   it('moving slider left pointer around updates zoom', fakeAsync(async () => {
-    fixture.detectChanges();
-
+    dom.detectChanges();
     const initialZoom = assertDefined(component.zoomRange);
 
     let lastZoomUpdate: TimeRange | undefined = undefined;
@@ -207,14 +194,10 @@ describe('SliderComponent', () => {
       },
     );
 
-    const leftCropper = htmlElement.querySelector('.slider .cropper.left');
-    expect(leftCropper).toBeTruthy();
-    expect(window.getComputedStyle(assertDefined(leftCropper)).visibility).toBe(
-      'visible',
-    );
-
-    dragElement(fixture, assertDefined(leftCropper), 5, 0);
+    const leftCropper = dom.get(leftCropperSelector);
+    checkVisible(leftCropper.getHTMLElement());
 
+    leftCropper.dragElement(5, 0);
     expect(zoomChangedSpy).toHaveBeenCalled();
 
     const finalZoom = assertDefined<TimeRange>(lastZoomUpdate);
@@ -223,8 +206,7 @@ describe('SliderComponent', () => {
   }));
 
   it('moving slider right pointer around updates zoom', fakeAsync(async () => {
-    fixture.detectChanges();
-
+    dom.detectChanges();
     const initialZoom = assertDefined(component.zoomRange);
 
     let lastZoomUpdate: TimeRange | undefined = undefined;
@@ -234,14 +216,10 @@ describe('SliderComponent', () => {
       },
     );
 
-    const rightCropper = htmlElement.querySelector('.slider .cropper.right');
-    expect(rightCropper).toBeTruthy();
-    expect(
-      window.getComputedStyle(assertDefined(rightCropper)).visibility,
-    ).toBe('visible');
-
-    dragElement(fixture, assertDefined(rightCropper), 5, 0);
+    const rightCropper = dom.get(rightCropperSelector);
+    checkVisible(rightCropper.getHTMLElement());
 
+    rightCropper.dragElement(5, 0);
     expect(zoomChangedSpy).toHaveBeenCalled();
 
     const finalZoom = assertDefined<TimeRange>(lastZoomUpdate);
@@ -251,8 +229,7 @@ describe('SliderComponent', () => {
 
   it('cannot slide left cropper past edges', fakeAsync(() => {
     component.zoomRange = component.fullRange;
-    fixture.detectChanges();
-
+    dom.detectChanges();
     const initialZoom = assertDefined(component.zoomRange);
 
     let lastZoomUpdate: TimeRange | undefined = undefined;
@@ -262,25 +239,20 @@ describe('SliderComponent', () => {
       },
     );
 
-    const leftCropper = htmlElement.querySelector('.slider .cropper.left');
-    expect(leftCropper).toBeTruthy();
-    expect(window.getComputedStyle(assertDefined(leftCropper)).visibility).toBe(
-      'visible',
-    );
-
-    dragElement(fixture, assertDefined(leftCropper), -5, 0);
+    const leftCropper = dom.get(leftCropperSelector);
+    checkVisible(leftCropper.getHTMLElement());
 
+    leftCropper.dragElement(-5, 0);
     expect(zoomChangedSpy).toHaveBeenCalled();
 
     const finalZoom = assertDefined<TimeRange>(lastZoomUpdate);
-    expect(finalZoom.from.getValueNs()).toBe(initialZoom.from.getValueNs());
-    expect(finalZoom.to.getValueNs()).toBe(initialZoom.to.getValueNs());
+    expect(finalZoom.from.getValueNs()).toEqual(initialZoom.from.getValueNs());
+    expect(finalZoom.to.getValueNs()).toEqual(initialZoom.to.getValueNs());
   }));
 
   it('cannot slide right cropper past edges', fakeAsync(() => {
     component.zoomRange = component.fullRange;
-    fixture.detectChanges();
-
+    dom.detectChanges();
     const initialZoom = assertDefined(component.zoomRange);
 
     let lastZoomUpdate: TimeRange | undefined = undefined;
@@ -290,25 +262,20 @@ describe('SliderComponent', () => {
       },
     );
 
-    const rightCropper = htmlElement.querySelector('.slider .cropper.right');
-    expect(rightCropper).toBeTruthy();
-    expect(
-      window.getComputedStyle(assertDefined(rightCropper)).visibility,
-    ).toBe('visible');
-
-    dragElement(fixture, assertDefined(rightCropper), 5, 0);
+    const rightCropper = dom.get(rightCropperSelector);
+    checkVisible(rightCropper.getHTMLElement());
 
+    rightCropper.dragElement(5, 0);
     expect(zoomChangedSpy).toHaveBeenCalled();
 
     const finalZoom = assertDefined<TimeRange>(lastZoomUpdate);
-    expect(finalZoom.from.getValueNs()).toBe(initialZoom.from.getValueNs());
-    expect(finalZoom.to.getValueNs()).toBe(initialZoom.to.getValueNs());
+    expect(finalZoom.from.getValueNs()).toEqual(initialZoom.from.getValueNs());
+    expect(finalZoom.to.getValueNs()).toEqual(initialZoom.to.getValueNs());
   }));
 
   it('cannot slide left cropper past right cropper', fakeAsync(() => {
     component.zoomRange = new TimeRange(time125, time125);
-    fixture.detectChanges();
-
+    dom.detectChanges();
     const initialZoom = assertDefined(component.zoomRange);
 
     let lastZoomUpdate: TimeRange | undefined = undefined;
@@ -318,25 +285,20 @@ describe('SliderComponent', () => {
       },
     );
 
-    const leftCropper = htmlElement.querySelector('.slider .cropper.left');
-    expect(leftCropper).toBeTruthy();
-    expect(window.getComputedStyle(assertDefined(leftCropper)).visibility).toBe(
-      'visible',
-    );
-
-    dragElement(fixture, assertDefined(leftCropper), 100, 0);
+    const leftCropper = dom.get(leftCropperSelector);
+    checkVisible(leftCropper.getHTMLElement());
 
+    leftCropper.dragElement(100, 0);
     expect(zoomChangedSpy).toHaveBeenCalled();
 
     const finalZoom = assertDefined<TimeRange>(lastZoomUpdate);
-    expect(finalZoom.from.getValueNs()).toBe(initialZoom.from.getValueNs());
-    expect(finalZoom.to.getValueNs()).toBe(initialZoom.to.getValueNs());
+    expect(finalZoom.from.getValueNs()).toEqual(initialZoom.from.getValueNs());
+    expect(finalZoom.to.getValueNs()).toEqual(initialZoom.to.getValueNs());
   }));
 
   it('cannot slide right cropper past left cropper', fakeAsync(() => {
     component.zoomRange = new TimeRange(time125, time125);
-    fixture.detectChanges();
-
+    dom.detectChanges();
     const initialZoom = assertDefined(component.zoomRange);
 
     let lastZoomUpdate: TimeRange | undefined = undefined;
@@ -346,25 +308,20 @@ describe('SliderComponent', () => {
       },
     );
 
-    const rightCropper = htmlElement.querySelector('.slider .cropper.right');
-    expect(rightCropper).toBeTruthy();
-    expect(
-      window.getComputedStyle(assertDefined(rightCropper)).visibility,
-    ).toBe('visible');
-
-    dragElement(fixture, assertDefined(rightCropper), -100, 0);
+    const rightCropper = dom.get(rightCropperSelector);
+    checkVisible(rightCropper.getHTMLElement());
 
+    rightCropper.dragElement(-100, 0);
     expect(zoomChangedSpy).toHaveBeenCalled();
 
     const finalZoom = assertDefined<TimeRange>(lastZoomUpdate);
-    expect(finalZoom.from.getValueNs()).toBe(initialZoom.from.getValueNs());
-    expect(finalZoom.to.getValueNs()).toBe(initialZoom.to.getValueNs());
+    expect(finalZoom.from.getValueNs()).toEqual(initialZoom.from.getValueNs());
+    expect(finalZoom.to.getValueNs()).toEqual(initialZoom.to.getValueNs());
   }));
 
   it('cannot move slider past edges', fakeAsync(() => {
     component.zoomRange = component.fullRange;
-    fixture.detectChanges();
-
+    dom.detectChanges();
     const initialZoom = assertDefined(component.zoomRange);
 
     let lastZoomUpdate: TimeRange | undefined = undefined;
@@ -374,18 +331,18 @@ describe('SliderComponent', () => {
       },
     );
 
-    const slider = htmlElement.querySelector('.slider .handle');
-    expect(slider).toBeTruthy();
-    expect(window.getComputedStyle(assertDefined(slider)).visibility).toBe(
-      'visible',
-    );
-
-    dragElement(fixture, assertDefined(slider), 100, 8);
+    const slider = dom.get('.slider .handle');
+    checkVisible(slider.getHTMLElement());
 
+    slider.dragElement(100, 8);
     expect(zoomChangedSpy).toHaveBeenCalled();
 
     const finalZoom = assertDefined<TimeRange>(lastZoomUpdate);
-    expect(finalZoom.from.getValueNs()).toBe(initialZoom.from.getValueNs());
-    expect(finalZoom.to.getValueNs()).toBe(initialZoom.to.getValueNs());
+    expect(finalZoom.from.getValueNs()).toEqual(initialZoom.from.getValueNs());
+    expect(finalZoom.to.getValueNs()).toEqual(initialZoom.to.getValueNs());
   }));
+
+  function checkVisible(element: HTMLElement) {
+    expect(window.getComputedStyle(element).visibility).toEqual('visible');
+  }
 });
diff --git a/tools/winscope/src/app/components/timeline/timeline_component.ts b/tools/winscope/src/app/components/timeline/timeline_component.ts
index cce7b4e50..ae9f79d8e 100644
--- a/tools/winscope/src/app/components/timeline/timeline_component.ts
+++ b/tools/winscope/src/app/components/timeline/timeline_component.ts
@@ -37,9 +37,10 @@ import {
 import {DomSanitizer, SafeUrl} from '@angular/platform-browser';
 import {TimelineData} from 'app/timeline_data';
 import {assertDefined} from 'common/assert_utils';
+import {KeyboardEventKey} from 'common/dom_utils';
 import {FunctionUtils} from 'common/function_utils';
 import {PersistentStore} from 'common/store/persistent_store';
-import {StringUtils} from 'common/string_utils';
+import {parseBigIntStrippingUnit} from 'common/string_utils';
 import {TimeRange, Timestamp, TimestampFormatType} from 'common/time/time';
 import {TimestampUtils} from 'common/time/timestamp_utils';
 import {Analytics} from 'logging/analytics';
@@ -772,10 +773,10 @@ export class TimelineComponent
     ) {
       return;
     }
-    if (event.key === 'ArrowLeft') {
+    if (event.key === KeyboardEventKey.ARROW_LEFT) {
       event.preventDefault();
       await this.moveToPreviousEntry();
-    } else if (event.key === 'ArrowRight') {
+    } else if (event.key === KeyboardEventKey.ARROW_RIGHT) {
       event.preventDefault();
       await this.moveToNextEntry();
     }
@@ -861,7 +862,7 @@ export class TimelineComponent
 
     const timestamp = assertDefined(
       timelineData.getTimestampConverter(),
-    ).makeTimestampFromNs(StringUtils.parseBigIntStrippingUnit(target.value));
+    ).makeTimestampFromNs(parseBigIntStrippingUnit(target.value));
 
     Analytics.Navigation.logTimeInput('ns');
     await this.updatePosition(
diff --git a/tools/winscope/src/app/components/timeline/timeline_component_test.ts b/tools/winscope/src/app/components/timeline/timeline_component_test.ts
index 7704be0b8..4edff97e0 100644
--- a/tools/winscope/src/app/components/timeline/timeline_component_test.ts
+++ b/tools/winscope/src/app/components/timeline/timeline_component_test.ts
@@ -18,7 +18,7 @@ import {ClipboardModule} from '@angular/cdk/clipboard';
 import {DragDropModule} from '@angular/cdk/drag-drop';
 import {CdkMenuModule} from '@angular/cdk/menu';
 import {ChangeDetectionStrategy, Component, ViewChild} from '@angular/core';
-import {ComponentFixture, TestBed} from '@angular/core/testing';
+import {TestBed} from '@angular/core/testing';
 import {FormsModule, ReactiveFormsModule} from '@angular/forms';
 import {MatButtonModule} from '@angular/material/button';
 import {MatFormFieldModule} from '@angular/material/form-field';
@@ -26,7 +26,6 @@ import {MatIconModule} from '@angular/material/icon';
 import {MatInputModule} from '@angular/material/input';
 import {MatSelectModule} from '@angular/material/select';
 import {MatTooltipModule} from '@angular/material/tooltip';
-import {By} from '@angular/platform-browser';
 import {BrowserAnimationsModule} from '@angular/platform-browser/animations';
 import {
   MatDrawer,
@@ -50,15 +49,17 @@ import {
   TraceSearchRequest,
   WinscopeEvent,
 } from 'messaging/winscope_event';
+import {checkTooltips, DOMTestHelper} from 'test/unit/dom_test_utils';
 import {TracesBuilder} from 'test/unit/traces_builder';
 import {TraceBuilder} from 'test/unit/trace_builder';
-import {UnitTestUtils} from 'test/unit/utils';
+import {makeEmptyTrace} from 'test/unit/trace_utils';
 import {Trace} from 'trace/trace';
 import {Traces} from 'trace/traces';
 import {TRACE_INFO} from 'trace/trace_info';
 import {TracePosition} from 'trace/trace_position';
 import {TraceType} from 'trace/trace_type';
 import {QueryResult} from 'trace_processor/query_result';
+import {makeSearchTraceSpies} from 'trace_processor/test_utils';
 import {CanvasDrawer} from './expanded-timeline/canvas_drawer';
 import {DefaultTimelineRowComponent} from './expanded-timeline/default_timeline_row_component';
 import {ExpandedTimelineComponent} from './expanded-timeline/expanded_timeline_component';
@@ -88,9 +89,11 @@ describe('TimelineComponent', () => {
   const position110 = TracePosition.fromTimestamp(time110);
   const position112 = TracePosition.fromTimestamp(time112);
 
-  let fixture: ComponentFixture<TestHostComponent>;
+  const nextEntrySelector = '#next_entry_button';
+  const prevEntrySelector = '#prev_entry_button';
+
   let component: TestHostComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<TestHostComponent>;
 
   beforeEach(async () => {
     await TestBed.configureTestingModule({
@@ -125,9 +128,9 @@ describe('TimelineComponent', () => {
         set: {changeDetection: ChangeDetectionStrategy.Default},
       })
       .compileComponents();
-    fixture = TestBed.createComponent(TestHostComponent);
+    const fixture = TestBed.createComponent(TestHostComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
   });
 
   it('can be created', () => {
@@ -143,19 +146,15 @@ describe('TimelineComponent', () => {
       undefined,
       TimestampConverterUtils.TIMESTAMP_CONVERTER,
     );
-    fixture.detectChanges();
+    dom.detectChanges();
 
     const timelineComponent = assertDefined(component.timeline);
 
-    const button = assertDefined(
-      htmlElement.querySelector(`.${timelineComponent.TOGGLE_BUTTON_CLASS}`),
-    );
-
     // initially not expanded
-    let expandedTimelineElement = fixture.debugElement.query(
-      By.directive(ExpandedTimelineComponent),
+    let expandedTimelineElement = dom.findByDirective(
+      ExpandedTimelineComponent,
     );
-    expect(expandedTimelineElement).toBeFalsy();
+    expect(expandedTimelineElement).toBeUndefined();
 
     let isExpanded = false;
     timelineComponent.setEmitEvent(async (event: WinscopeEvent) => {
@@ -163,18 +162,16 @@ describe('TimelineComponent', () => {
       isExpanded = (event as ExpandedTimelineToggled).isTimelineExpanded;
     });
 
-    button.dispatchEvent(new Event('click'));
-    expandedTimelineElement = fixture.debugElement.query(
-      By.directive(ExpandedTimelineComponent),
+    const button = dom.findAndClick(
+      `.${timelineComponent.TOGGLE_BUTTON_CLASS}`,
     );
-    expect(expandedTimelineElement).toBeTruthy();
+    expandedTimelineElement = dom.findByDirective(ExpandedTimelineComponent);
+    expect(expandedTimelineElement).toBeDefined();
     expect(isExpanded).toBeTrue();
 
-    button.dispatchEvent(new Event('click'));
-    expandedTimelineElement = fixture.debugElement.query(
-      By.directive(ExpandedTimelineComponent),
-    );
-    expect(expandedTimelineElement).toBeFalsy();
+    button.click();
+    expandedTimelineElement = dom.findByDirective(ExpandedTimelineComponent);
+    expect(expandedTimelineElement).toBeUndefined();
     expect(isExpanded).toBeFalse();
   });
 
@@ -187,18 +184,14 @@ describe('TimelineComponent', () => {
       undefined,
       TimestampConverterUtils.TIMESTAMP_CONVERTER,
     );
-    fixture.detectChanges();
+    dom.detectChanges();
 
-    expect(htmlElement.querySelector('.time-selector')).toBeNull();
-    expect(htmlElement.querySelector('.trace-selector')).toBeNull();
+    expect(dom.find('.time-selector')).toBeUndefined();
+    expect(dom.find('.trace-selector')).toBeUndefined();
 
-    const errorMessageContainer = assertDefined(
-      htmlElement.querySelector('.no-timeline-msg'),
-    );
-    expect(errorMessageContainer.textContent).toContain('No timeline to show!');
-    expect(errorMessageContainer.textContent).toContain(
-      'All loaded traces contain no timestamps.',
-    );
+    const errorMessageContainer = dom.get('.no-timeline-msg');
+    errorMessageContainer.checkText('No timeline to show!');
+    errorMessageContainer.checkText('All loaded traces contain no timestamps.');
 
     checkNoTimelineNavigation();
   });
@@ -206,18 +199,14 @@ describe('TimelineComponent', () => {
   it('handles some empty traces and some with one timestamp', async () => {
     await loadTracesWithOneTimestamp();
 
-    expect(htmlElement.querySelector('#time-selector')).toBeTruthy();
-    const shownSelection = assertDefined(
-      htmlElement.querySelector('#trace-selector .shown-selection'),
-    );
-    expect(shownSelection.innerHTML).toContain('Window Manager');
-    expect(shownSelection.innerHTML).not.toContain('Surface Flinger');
+    expect(dom.find('#time-selector')).toBeDefined();
+    const shownSelection = dom.get('#trace-selector .shown-selection');
+    shownSelection.checkInnerHTML('Window Manager');
+    shownSelection.checkInnerHTML('Surface Flinger', false);
 
-    const errorMessageContainer = assertDefined(
-      htmlElement.querySelector('.no-timeline-msg'),
-    );
-    expect(errorMessageContainer.textContent).toContain('No timeline to show!');
-    expect(errorMessageContainer.textContent).toContain(
+    const errorMessageContainer = dom.get('.no-timeline-msg');
+    errorMessageContainer.checkText('No timeline to show!');
+    errorMessageContainer.checkText(
       'Only a single timestamp has been recorded.',
     );
 
@@ -226,20 +215,16 @@ describe('TimelineComponent', () => {
 
   it('processes active trace input and updates selected traces', async () => {
     loadAllTraces();
-    fixture.detectChanges();
+    dom.detectChanges();
 
     const timelineComponent = assertDefined(component.timeline);
-    const nextEntryButton = assertDefined(
-      htmlElement.querySelector<HTMLElement>('#next_entry_button'),
-    );
-    const prevEntryButton = assertDefined(
-      htmlElement.querySelector<HTMLElement>('#prev_entry_button'),
-    );
+    const nextEntryButton = dom.get(nextEntrySelector);
+    const prevEntryButton = dom.get(prevEntrySelector);
 
     timelineComponent.selectedTraces = [
       getLoadedTrace(TraceType.SURFACE_FLINGER),
     ];
-    fixture.detectChanges();
+    dom.detectChanges();
     checkActiveTraceSurfaceFlinger(nextEntryButton, prevEntryButton);
 
     // setting same trace as active does not affect selected traces
@@ -296,40 +281,32 @@ describe('TimelineComponent', () => {
       TimestampConverterUtils.TIMESTAMP_CONVERTER,
     );
     timelineData.setPosition(position100);
-    fixture.detectChanges();
-    const nextEntryButton = assertDefined(
-      htmlElement.querySelector<HTMLElement>('#next_entry_button'),
-    );
-    const prevEntryButton = assertDefined(
-      htmlElement.querySelector<HTMLElement>('#prev_entry_button'),
-    );
+    dom.detectChanges();
+    const nextEntryButton = dom.get(nextEntrySelector);
+    const prevEntryButton = dom.get(prevEntrySelector);
     expect(timelineData.getActiveTrace()).toBeUndefined();
     expect(timelineData.getCurrentPosition()?.timestamp.getValueNs()).toEqual(
       100n,
     );
 
-    expect(prevEntryButton.getAttribute('disabled')).toEqual('true');
-    expect(nextEntryButton.getAttribute('disabled')).toEqual('true');
+    prevEntryButton.checkDisabled(true);
+    nextEntryButton.checkDisabled(true);
   });
 
   it('handles ActiveTraceChanged event', async () => {
     loadSfWmTraces();
-    fixture.detectChanges();
+    dom.detectChanges();
 
     const timelineComponent = assertDefined(component.timeline);
-    const nextEntryButton = assertDefined(
-      htmlElement.querySelector<HTMLElement>('#next_entry_button'),
-    );
-    const prevEntryButton = assertDefined(
-      htmlElement.querySelector<HTMLElement>('#prev_entry_button'),
-    );
+    const nextEntryButton = dom.get(nextEntrySelector);
+    const prevEntryButton = dom.get(prevEntrySelector);
     const spy = spyOn(
       assertDefined(timelineComponent.miniTimeline?.drawer),
       'draw',
     );
 
     await updateActiveTrace(TraceType.SURFACE_FLINGER);
-    fixture.detectChanges();
+    dom.detectChanges();
     checkActiveTraceSurfaceFlinger(nextEntryButton, prevEntryButton);
     expect(spy).toHaveBeenCalled();
   });
@@ -344,8 +321,7 @@ describe('TimelineComponent', () => {
       TraceType.VIEW_CAPTURE,
     ];
     loadAllTraces();
-    const [spyQueryResult, spyIter] =
-      UnitTestUtils.makeSearchTraceSpies(time100);
+    const [spyQueryResult, spyIter] = makeSearchTraceSpies(time100);
     const searchTrace = new TraceBuilder<QueryResult>()
       .setEntries([spyQueryResult])
       .setTimestamps([time100])
@@ -355,32 +331,26 @@ describe('TimelineComponent', () => {
     await component.timeline?.onWinscopeEvent(new TraceAddRequest(searchTrace));
     expectSelectedTraceTypes(allTraceTypes);
 
-    await openSelectPanel();
+    await dom.openMatSelect();
 
-    const matOptions =
-      document.documentElement.querySelectorAll<HTMLInputElement>('mat-option');
-    await UnitTestUtils.checkTooltips(
-      Array.from(matOptions),
-      [
-        'test query, 0',
-        'mock_screen_recording',
-        'file descriptor',
-        'file descriptor',
-        'file descriptor',
-        'Test Window, mock_view_capture',
-      ],
-      fixture,
-    );
-    expect(matOptions.item(0).textContent).toContain('Search test query');
-    const sfOption = matOptions.item(2);
-    expect(sfOption.textContent).toContain('Surface Flinger');
-    expect(sfOption.ariaDisabled).toEqual('true');
+    const matOptions = dom.getMatSelectPanel().findAll('mat-option');
+    await checkTooltips(Array.from(matOptions), [
+      'test query, 0',
+      'mock_screen_recording',
+      'file descriptor',
+      'file descriptor',
+      'file descriptor',
+      'Test Window, mock_view_capture',
+    ]);
+    matOptions[0].checkText('Search test query');
+    const sfOption = matOptions[2];
+    sfOption.checkText('Surface Flinger');
+    expect(sfOption.getHTMLElement().ariaDisabled).toEqual('true');
     for (const i of [1, 3, 4]) {
-      expect(matOptions.item(i).ariaDisabled).toEqual('false');
+      expect(matOptions[1].getHTMLElement().ariaDisabled).toEqual('false');
     }
 
-    matOptions.item(3).click();
-    fixture.detectChanges();
+    matOptions[3].click();
     const expectedTypes = [
       TraceType.SEARCH,
       TraceType.SCREEN_RECORDING,
@@ -389,58 +359,45 @@ describe('TimelineComponent', () => {
       TraceType.VIEW_CAPTURE,
     ];
     expectSelectedTraceTypes(expectedTypes);
-    const traceIcons = Array.from(
-      htmlElement.querySelectorAll<HTMLElement>(
-        '#trace-selector .shown-selection .mat-icon',
-      ),
-    ).slice(1);
+    const traceIcons = dom
+      .findAll('#trace-selector .shown-selection .mat-icon')
+      .slice(1);
     traceIcons.forEach((el, index) => {
-      const text = el.textContent?.trim();
       const expectedType = expectedTypes[index];
-      expect(text).toEqual(TRACE_INFO[expectedType].icon);
+      el.checkTextExact(TRACE_INFO[expectedType].icon);
     });
-    await UnitTestUtils.checkTooltips(
-      traceIcons,
-      [
-        'Search test query',
-        'Screen Recording mock_screen_recording',
-        TRACE_INFO[TraceType.SURFACE_FLINGER].name,
-        TRACE_INFO[TraceType.PROTO_LOG].name,
-        'View Capture Test Window',
-      ],
-      fixture,
-    );
+    await checkTooltips(traceIcons, [
+      'Search test query',
+      'Screen Recording mock_screen_recording',
+      TRACE_INFO[TraceType.SURFACE_FLINGER].name,
+      TRACE_INFO[TraceType.PROTO_LOG].name,
+      'View Capture Test Window',
+    ]);
 
-    matOptions.item(3).click();
-    fixture.detectChanges();
+    matOptions[3].click();
     expectSelectedTraceTypes(allTraceTypes);
-    const newIcons = htmlElement.querySelectorAll(
-      '#trace-selector .shown-selection .mat-icon',
-    );
+    const newIcons = dom.findAll('#trace-selector .shown-selection .mat-icon');
     expect(
       Array.from(newIcons)
-        .map((icon) => icon.textContent?.trim())
+        .map((icon) => icon.getText())
         .slice(1),
     ).toEqual(allTraceTypes.map((type) => TRACE_INFO[type].icon));
   });
 
   it('update name and disables option for dumps', async () => {
-    loadAllTraces(component, fixture, false);
-    await openSelectPanel();
+    loadAllTraces(component, dom, false);
+    await dom.openMatSelect();
 
-    const matOptions =
-      document.documentElement.querySelectorAll<HTMLInputElement>('mat-option'); // [WM, SF, SR, ProtoLog, VC]
+    const matOptions = dom.getMatSelectPanel().findAll('mat-option'); // [WM, SF, SR, ProtoLog, VC]
 
     for (const i of [0, 2, 4]) {
-      expect(matOptions.item(i).ariaDisabled).toEqual('false');
+      expect(matOptions[i].getHTMLElement().ariaDisabled).toEqual('false');
     }
     for (const i of [1, 3]) {
-      expect(matOptions.item(i).ariaDisabled).toEqual('true');
+      expect(matOptions[i].getHTMLElement().ariaDisabled).toEqual('true');
     }
-    expect(matOptions.item(3).textContent).toContain('ProtoLog Dump');
-    expect(matOptions.item(4).textContent).toContain(
-      'View Capture Test Window',
-    );
+    matOptions[3].checkText('ProtoLog Dump');
+    matOptions[4].checkText('View Capture Test Window');
   });
 
   it('next button disabled if no next entry', () => {
@@ -451,22 +408,20 @@ describe('TimelineComponent', () => {
       100n,
     );
 
-    const nextEntryButton = assertDefined(
-      htmlElement.querySelector('#next_entry_button'),
-    );
-    expect(nextEntryButton.getAttribute('disabled')).toBeFalsy();
+    const nextEntryButton = dom.get(nextEntrySelector);
+    nextEntryButton.checkDisabled(false);
 
     timelineData.setPosition(position90);
-    fixture.detectChanges();
-    expect(nextEntryButton.getAttribute('disabled')).toBeFalsy();
+    dom.detectChanges();
+    nextEntryButton.checkDisabled(false);
 
     timelineData.setPosition(position110);
-    fixture.detectChanges();
-    expect(nextEntryButton.getAttribute('disabled')).toBeTruthy();
+    dom.detectChanges();
+    nextEntryButton.checkDisabled(true);
 
     timelineData.setPosition(position112);
-    fixture.detectChanges();
-    expect(nextEntryButton.getAttribute('disabled')).toBeTruthy();
+    dom.detectChanges();
+    nextEntryButton.checkDisabled(true);
   });
 
   it('prev button disabled if no prev entry', () => {
@@ -476,36 +431,30 @@ describe('TimelineComponent', () => {
     expect(timelineData.getCurrentPosition()?.timestamp.getValueNs()).toEqual(
       100n,
     );
-    const prevEntryButton = assertDefined(
-      htmlElement.querySelector('#prev_entry_button'),
-    );
-    expect(prevEntryButton.getAttribute('disabled')).toBeTruthy();
+    const prevEntryButton = dom.get(prevEntrySelector);
+    prevEntryButton.checkDisabled(true);
 
     timelineData.setPosition(position90);
-    fixture.detectChanges();
-    expect(prevEntryButton.getAttribute('disabled')).toBeTruthy();
+    dom.detectChanges();
+    prevEntryButton.checkDisabled(true);
 
     timelineData.setPosition(position110);
-    fixture.detectChanges();
-    expect(prevEntryButton.getAttribute('disabled')).toBeFalsy();
+    dom.detectChanges();
+    prevEntryButton.checkDisabled(false);
 
     timelineData.setPosition(position112);
-    fixture.detectChanges();
-    expect(prevEntryButton.getAttribute('disabled')).toBeFalsy();
+    dom.detectChanges();
+    prevEntryButton.checkDisabled(false);
   });
 
   it('next button enabled for different active viewers', async () => {
     loadSfWmTraces();
-    const nextEntryButton = assertDefined(
-      htmlElement.querySelector('#next_entry_button'),
-    );
-
-    expect(nextEntryButton.getAttribute('disabled')).toBeNull();
+    const nextEntryButton = dom.get(nextEntrySelector);
+    nextEntryButton.checkDisabled(false);
 
     await updateActiveTrace(TraceType.WINDOW_MANAGER);
-    fixture.detectChanges();
-
-    expect(nextEntryButton.getAttribute('disabled')).toBeNull();
+    dom.detectChanges();
+    nextEntryButton.checkDisabled(false);
   });
 
   it('changes timestamp on next entry button press', () => {
@@ -516,9 +465,7 @@ describe('TimelineComponent', () => {
         .getCurrentPosition()
         ?.timestamp.getValueNs(),
     ).toEqual(100n);
-    const nextEntryButton = assertDefined(
-      htmlElement.querySelector<HTMLElement>('#next_entry_button'),
-    );
+    const nextEntryButton = dom.get(nextEntrySelector);
 
     testCurrentTimestampOnButtonClick(nextEntryButton, position105, 110n);
 
@@ -541,9 +488,7 @@ describe('TimelineComponent', () => {
         .getCurrentPosition()
         ?.timestamp.getValueNs(),
     ).toEqual(100n);
-    const prevEntryButton = assertDefined(
-      htmlElement.querySelector<HTMLElement>('#prev_entry_button'),
-    );
+    const prevEntryButton = dom.get(prevEntrySelector);
 
     // In this state we are already on the first entry at timestamp 100, so
     // there is no entry to move to before and we just don't update the timestamp
@@ -568,27 +513,22 @@ describe('TimelineComponent', () => {
     const spyNextEntry = spyOn(timelineComponent, 'moveToNextEntry');
     const spyPrevEntry = spyOn(timelineComponent, 'moveToPreviousEntry');
 
-    document.dispatchEvent(new KeyboardEvent('keydown', {key: 'ArrowRight'}));
-    fixture.detectChanges();
+    dom.keydownArrowRight(true);
     expect(spyNextEntry).toHaveBeenCalled();
 
-    const formElement = htmlElement.querySelector('.time-input input');
+    const formElement = dom.get('.time-input input').getHTMLElement();
     const focusInEvent = new FocusEvent('focusin');
     Object.defineProperty(focusInEvent, 'target', {value: formElement});
-    document.dispatchEvent(focusInEvent);
-    fixture.detectChanges();
+    dom.dispatchEventInDocument(focusInEvent);
 
-    document.dispatchEvent(new KeyboardEvent('keydown', {key: 'ArrowLeft'}));
-    fixture.detectChanges();
+    dom.keydownArrowLeft(true);
     expect(spyPrevEntry).not.toHaveBeenCalled();
 
     const focusOutEvent = new FocusEvent('focusout');
     Object.defineProperty(focusOutEvent, 'target', {value: formElement});
-    document.dispatchEvent(focusOutEvent);
-    fixture.detectChanges();
+    dom.dispatchEventInDocument(focusOutEvent);
 
-    document.dispatchEvent(new KeyboardEvent('keydown', {key: 'ArrowLeft'}));
-    fixture.detectChanges();
+    dom.keydownArrowLeft(true);
     expect(spyPrevEntry).toHaveBeenCalled();
   });
 
@@ -601,9 +541,7 @@ describe('TimelineComponent', () => {
         ?.timestamp.getValueNs(),
     ).toEqual(100n);
 
-    const timeInputField = assertDefined(
-      document.querySelector<HTMLInputElement>('.time-input.nano'),
-    );
+    const timeInputField = dom.get('.time-input.nano');
 
     testCurrentTimestampOnTimeInput(
       timeInputField,
@@ -647,9 +585,7 @@ describe('TimelineComponent', () => {
         ?.timestamp.getValueNs(),
     ).toEqual(100n);
 
-    const timeInputField = assertDefined(
-      document.querySelector<HTMLInputElement>('.time-input.human'),
-    );
+    const timeInputField = dom.get('.time-input.human');
 
     testCurrentTimestampOnTimeInput(
       timeInputField,
@@ -698,9 +634,7 @@ describe('TimelineComponent', () => {
         ?.timestamp.valueOf(),
     ).toEqual(100n);
 
-    const timeInputField = assertDefined(
-      document.querySelector<HTMLInputElement>('.time-input.human'),
-    );
+    const timeInputField = dom.get('.time-input.human');
 
     testCurrentTimestampOnTimeInput(
       timeInputField,
@@ -719,9 +653,7 @@ describe('TimelineComponent', () => {
         ?.timestamp.valueOf(),
     ).toEqual(100n);
 
-    const timeInputField = assertDefined(
-      document.querySelector<HTMLInputElement>('.time-input.human'),
-    );
+    const timeInputField = dom.get('.time-input.human');
 
     testCurrentTimestampOnTimeInput(
       timeInputField,
@@ -752,7 +684,7 @@ describe('TimelineComponent', () => {
       ],
       firstTimeline,
     );
-    await openSelectPanel();
+    await dom.openMatSelect();
     clickTraceFromSelectPanel(2);
     clickTraceFromSelectPanel(3);
     clickTraceFromSelectPanel(4);
@@ -763,7 +695,10 @@ describe('TimelineComponent', () => {
 
     const secondFixture = TestBed.createComponent(TestHostComponent);
     const secondHost = secondFixture.componentInstance;
-    loadAllTraces(secondHost, secondFixture);
+    loadAllTraces(
+      secondHost,
+      new DOMTestHelper(secondFixture, secondFixture.nativeElement),
+    );
     const secondTimeline = assertDefined(secondHost.timeline);
     expectSelectedTraceTypes(
       [TraceType.SCREEN_RECORDING, TraceType.SURFACE_FLINGER],
@@ -778,7 +713,10 @@ describe('TimelineComponent', () => {
 
     const thirdFixture = TestBed.createComponent(TestHostComponent);
     const thirdHost = thirdFixture.componentInstance;
-    loadAllTraces(thirdHost, thirdFixture);
+    loadAllTraces(
+      thirdHost,
+      new DOMTestHelper(thirdFixture, thirdFixture.nativeElement),
+    );
     const thirdTimeline = assertDefined(thirdHost.timeline);
     expectSelectedTraceTypes(
       [
@@ -804,7 +742,7 @@ describe('TimelineComponent', () => {
       firstTimeline,
     );
     await updateActiveTrace(TraceType.PROTO_LOG);
-    await openSelectPanel();
+    await dom.openMatSelect();
     clickTraceFromSelectPanel(1);
     clickTraceFromSelectPanel(4);
     expectSelectedTraceTypes(
@@ -818,7 +756,10 @@ describe('TimelineComponent', () => {
 
     const secondFixture = TestBed.createComponent(TestHostComponent);
     const secondHost = secondFixture.componentInstance;
-    loadAllTraces(secondHost, secondFixture);
+    loadAllTraces(
+      secondHost,
+      new DOMTestHelper(secondFixture, secondFixture.nativeElement),
+    );
     const secondTimeline = assertDefined(secondHost.timeline);
     expectSelectedTraceTypes(
       [
@@ -834,13 +775,16 @@ describe('TimelineComponent', () => {
   it('does not apply stored trace deselection if only one timestamp available', async () => {
     loadAllTraces();
     await updateActiveTrace(TraceType.PROTO_LOG);
-    await openSelectPanel();
+    await dom.openMatSelect();
     clickTraceFromSelectPanel(2);
 
     const secondFixture = TestBed.createComponent(TestHostComponent);
     const secondHost = secondFixture.componentInstance;
     const secondElement = secondFixture.nativeElement;
-    await loadTracesWithOneTimestamp(secondHost, secondFixture);
+    await loadTracesWithOneTimestamp(
+      secondHost,
+      new DOMTestHelper(secondFixture, secondFixture.nativeElement),
+    );
 
     const shownSelection = assertDefined(
       secondElement.querySelector('#trace-selector .shown-selection'),
@@ -861,7 +805,7 @@ describe('TimelineComponent', () => {
       ],
       component.timeline,
     );
-    await openSelectPanel();
+    await dom.openMatSelect();
     clickTraceFromSelectPanel(3);
     clickTraceFromSelectPanel(4);
     expectSelectedTraceTypes(
@@ -873,7 +817,7 @@ describe('TimelineComponent', () => {
       component.timeline,
     );
     await updateActiveTrace(TraceType.PROTO_LOG);
-    fixture.detectChanges();
+    dom.detectChanges();
     expectSelectedTraceTypes(
       [
         TraceType.SCREEN_RECORDING,
@@ -886,7 +830,10 @@ describe('TimelineComponent', () => {
 
     const secondFixture = TestBed.createComponent(TestHostComponent);
     const secondHost = secondFixture.componentInstance;
-    loadAllTraces(secondHost, secondFixture);
+    loadAllTraces(
+      secondHost,
+      new DOMTestHelper(secondFixture, secondFixture.nativeElement),
+    );
     const secondTimeline = assertDefined(secondHost.timeline);
     expectSelectedTraceTypes(
       [
@@ -910,7 +857,7 @@ describe('TimelineComponent', () => {
       ],
       component.timeline,
     );
-    await openSelectPanel();
+    await dom.openMatSelect();
     clickTraceFromSelectPanel(3);
     clickTraceFromSelectPanel(4);
     expectSelectedTraceTypes(
@@ -924,7 +871,10 @@ describe('TimelineComponent', () => {
 
     const secondFixture = TestBed.createComponent(TestHostComponent);
     const secondHost = secondFixture.componentInstance;
-    loadSfWmTraces(secondHost, secondFixture);
+    loadSfWmTraces(
+      secondHost,
+      new DOMTestHelper(secondFixture, secondFixture.nativeElement),
+    );
     const secondTimeline = assertDefined(secondHost.timeline);
     expectSelectedTraceTypes(
       [TraceType.SURFACE_FLINGER, TraceType.WINDOW_MANAGER],
@@ -933,7 +883,10 @@ describe('TimelineComponent', () => {
 
     const thirdFixture = TestBed.createComponent(TestHostComponent);
     const thirdHost = thirdFixture.componentInstance;
-    loadAllTraces(thirdHost, thirdFixture);
+    loadAllTraces(
+      thirdHost,
+      new DOMTestHelper(thirdFixture, thirdFixture.nativeElement),
+    );
     const thirdTimeline = assertDefined(thirdHost.timeline);
     expectSelectedTraceTypes(
       [
@@ -951,13 +904,16 @@ describe('TimelineComponent', () => {
       [TraceType.SURFACE_FLINGER, TraceType.WINDOW_MANAGER],
       component.timeline,
     );
-    await openSelectPanel();
+    await dom.openMatSelect();
     clickTraceFromSelectPanel(1);
     expectSelectedTraceTypes([TraceType.SURFACE_FLINGER], component.timeline);
 
     const secondFixture = TestBed.createComponent(TestHostComponent);
     const secondHost = secondFixture.componentInstance;
-    loadAllTraces(secondHost, secondFixture);
+    loadAllTraces(
+      secondHost,
+      new DOMTestHelper(secondFixture, secondFixture.nativeElement),
+    );
     const secondTimeline = assertDefined(secondHost.timeline);
     expectSelectedTraceTypes(
       [
@@ -976,17 +932,12 @@ describe('TimelineComponent', () => {
     expect(timelineComponent.bookmarks).toEqual([]);
     expect(timelineComponent.currentPositionBookmarked()).toBeFalse();
 
-    const bookmarkIcon = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.bookmark-icon'),
-    );
-    bookmarkIcon.click();
-    fixture.detectChanges();
+    const bookmarkIcon = dom.findAndClick('.bookmark-icon');
 
     expect(timelineComponent.bookmarks).toEqual([time100]);
     expect(timelineComponent.currentPositionBookmarked()).toBeTrue();
 
     bookmarkIcon.click();
-    fixture.detectChanges();
     expect(timelineComponent.bookmarks).toEqual([]);
     expect(timelineComponent.currentPositionBookmarked()).toBeFalse();
   });
@@ -1029,7 +980,7 @@ describe('TimelineComponent', () => {
     loadSfWmTraces();
     const timelineComponent = assertDefined(component.timeline);
     timelineComponent.bookmarks = [time100, time101, time112];
-    fixture.detectChanges();
+    dom.detectChanges();
 
     openContextMenu();
     clickRemoveAllBookmarksOption();
@@ -1063,10 +1014,8 @@ describe('TimelineComponent', () => {
     ).and.returnValue(Promise.resolve(trace));
     const canvas = miniTimelineComponent.getCanvas();
     canvas.dispatchEvent(new MouseEvent('mousedown'));
-    fixture.detectChanges();
-    await fixture.whenStable();
-    fixture.detectChanges();
-    await fixture.whenStable();
+    await dom.detectChangesAndWaitStable();
+    await dom.detectChangesAndWaitStable();
 
     expect(activeTrace).toEqual(trace);
     expect(position).toBeDefined();
@@ -1080,7 +1029,7 @@ describe('TimelineComponent', () => {
       assertDefined(timelineComponent.miniTimeline?.drawer),
       'draw',
     );
-    const trace = UnitTestUtils.makeEmptyTrace(TraceType.SEARCH);
+    const trace = makeEmptyTrace(TraceType.SEARCH);
 
     await timelineComponent.onWinscopeEvent(new TraceAddRequest(trace));
     expect(spy).toHaveBeenCalledTimes(1);
@@ -1112,11 +1061,10 @@ describe('TimelineComponent', () => {
     loadSfWmTraces();
     const timelineComponent = assertDefined(component.timeline);
     timelineComponent.isDisabled = true;
-    fixture.detectChanges();
+    dom.detectChanges();
 
     const spyNextEntry = spyOn(timelineComponent, 'moveToNextEntry');
-    document.dispatchEvent(new KeyboardEvent('keydown', {key: 'ArrowRight'}));
-    fixture.detectChanges();
+    dom.keydownArrowRight(true);
     expect(spyNextEntry).not.toHaveBeenCalled();
   });
 
@@ -1131,10 +1079,7 @@ describe('TimelineComponent', () => {
     spyOnProperty(wheelEvent, 'deltaY').and.returnValue(-200);
     spyOnProperty(wheelEvent, 'deltaX').and.returnValue(0);
     spyOnProperty(wheelEvent, 'y').and.returnValue(10);
-    assertDefined(htmlElement.querySelector('single-timeline')).dispatchEvent(
-      wheelEvent,
-    );
-    fixture.detectChanges();
+    dom.get('single-timeline').dispatchEvent(wheelEvent);
     expect(expandedDrawSpy).toHaveBeenCalledTimes(5); // 3 entries total + 2 selected
     expect(miniDrawSpy).toHaveBeenCalledTimes(1); // all on one canvas so spy called once
 
@@ -1142,12 +1087,9 @@ describe('TimelineComponent', () => {
     expandedDrawSpy.calls.reset();
     miniDrawSpy.calls.reset();
     spyOnProperty(wheelEvent, 'target').and.returnValue(
-      assertDefined(htmlElement.querySelector('#mini-timeline-canvas')),
+      dom.get('#mini-timeline-canvas').getHTMLElement(),
     );
-    assertDefined(htmlElement.querySelector('mini-timeline')).dispatchEvent(
-      wheelEvent,
-    );
-    fixture.detectChanges();
+    dom.get('mini-timeline').dispatchEvent(wheelEvent);
     expect(expandedDrawSpy).toHaveBeenCalledTimes(4); // 2 entries total + 2 selected
     expect(miniDrawSpy).toHaveBeenCalledTimes(1);
   });
@@ -1161,15 +1103,12 @@ describe('TimelineComponent', () => {
     const clickEvent = new MouseEvent('mousedown');
     spyOnProperty(clickEvent, 'offsetX').and.returnValue(0);
     spyOnProperty(clickEvent, 'offsetY').and.returnValue(0);
-    assertDefined(
-      htmlElement.querySelector<HTMLElement>('single-timeline #canvas'),
-    ).dispatchEvent(clickEvent);
-    fixture.detectChanges();
+    dom.get('single-timeline #canvas').dispatchEvent(clickEvent);
     expect(expandedDrawSpy).toHaveBeenCalledTimes(3); // redraws SF timeline row
     expect(miniDrawSpy).toHaveBeenCalledTimes(1); // all on one canvas so spy called once
   });
 
-  function loadSfWmTraces(hostComponent = component, hostFixture = fixture) {
+  function loadSfWmTraces(hostComponent = component, domHelper = dom) {
     const traces = new TracesBuilder()
       .setTimestamps(TraceType.SURFACE_FLINGER, [time100, time110])
       .setTimestamps(TraceType.WINDOW_MANAGER, [
@@ -1188,12 +1127,12 @@ describe('TimelineComponent', () => {
     );
     timelineData.setPosition(position100);
     hostComponent.allTraces = hostComponent.timelineData.getTraces();
-    hostFixture.detectChanges();
+    domHelper.detectChanges();
   }
 
   function loadAllTraces(
     hostComponent = component,
-    hostFixture = fixture,
+    domHelper = dom,
     loadAllTraces = true,
   ) {
     const traces = new TracesBuilder()
@@ -1235,7 +1174,7 @@ describe('TimelineComponent', () => {
       TimestampConverterUtils.TIMESTAMP_CONVERTER,
     );
     hostComponent.allTraces = traces;
-    hostFixture.detectChanges();
+    domHelper.detectChanges();
   }
 
   function loadTracesWithLargeTimeRange() {
@@ -1262,7 +1201,7 @@ describe('TimelineComponent', () => {
     );
     timelineData.setPosition(position100);
     component.allTraces = timelineData.getTraces();
-    fixture.detectChanges();
+    dom.detectChanges();
   }
 
   function getLoadedTrace(type: TraceType): Trace<object> {
@@ -1275,7 +1214,7 @@ describe('TimelineComponent', () => {
 
   async function loadTracesWithOneTimestamp(
     hostComponent = component,
-    hostFixture = fixture,
+    domHelper = dom,
   ) {
     const traces = new TracesBuilder()
       .setTimestamps(TraceType.SURFACE_FLINGER, [])
@@ -1287,9 +1226,8 @@ describe('TimelineComponent', () => {
       TimestampConverterUtils.TIMESTAMP_CONVERTER,
     );
     hostComponent.allTraces = traces;
-    hostFixture.detectChanges();
-    await hostFixture.whenStable();
-    hostFixture.detectChanges();
+    await domHelper.detectChangesAndWaitStable();
+    domHelper.detectChanges();
   }
 
   async function updateActiveTrace(type: TraceType) {
@@ -1311,121 +1249,101 @@ describe('TimelineComponent', () => {
   }
 
   function testCurrentTimestampOnButtonClick(
-    button: HTMLElement,
+    button: DOMTestHelper<TestHostComponent>,
     pos: TracePosition,
     expectedNs: bigint,
   ) {
     const timelineData = assertDefined(component.timelineData);
     timelineData.setPosition(pos);
-    fixture.detectChanges();
+    dom.detectChanges();
     button.click();
-    fixture.detectChanges();
     expect(timelineData.getCurrentPosition()?.timestamp.getValueNs()).toEqual(
       expectedNs,
     );
   }
 
   function testCurrentTimestampOnTimeInput(
-    inputField: HTMLInputElement,
+    inputField: DOMTestHelper<TestHostComponent>,
     pos: TracePosition,
     textInput: string,
     expectedNs: bigint,
   ) {
     const timelineData = assertDefined(component.timelineData);
     timelineData.setPosition(pos);
-    fixture.detectChanges();
+    dom.detectChanges();
 
-    inputField.value = textInput;
+    inputField.updateValue(textInput);
     inputField.dispatchEvent(new Event('change'));
-    fixture.detectChanges();
 
     expect(timelineData.getCurrentPosition()?.timestamp.getValueNs()).toEqual(
       expectedNs,
     );
   }
 
-  async function openSelectPanel() {
-    const selectTrigger = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.mat-select-trigger'),
-    );
-    selectTrigger.click();
-    fixture.detectChanges();
-    await fixture.whenStable();
-  }
-
   function clickTraceFromSelectPanel(index: number) {
-    const matOptions = assertDefined(
-      document.documentElement.querySelectorAll<HTMLElement>('mat-option'),
-    );
-    matOptions.item(index).click();
-    fixture.detectChanges();
+    dom.getMatSelectPanel().findAndClickByIndex('mat-option', index);
   }
 
   function checkActiveTraceSurfaceFlinger(
-    nextEntryButton: HTMLElement,
-    prevEntryButton: HTMLElement,
+    nextEntryButton: DOMTestHelper<TestHostComponent>,
+    prevEntryButton: DOMTestHelper<TestHostComponent>,
   ) {
     testCurrentTimestampOnButtonClick(prevEntryButton, position110, 100n);
-    expect(prevEntryButton.getAttribute('disabled')).toEqual('true');
-    expect(nextEntryButton.getAttribute('disabled')).toBeNull();
+    prevEntryButton.checkDisabled(true);
+    nextEntryButton.checkDisabled(false);
     testCurrentTimestampOnButtonClick(nextEntryButton, position100, 110n);
-    expect(prevEntryButton.getAttribute('disabled')).toBeNull();
-    expect(nextEntryButton.getAttribute('disabled')).toEqual('true');
+    prevEntryButton.checkDisabled(false);
+    nextEntryButton.checkDisabled(true);
   }
 
   function checkActiveTraceWindowManager(
-    nextEntryButton: HTMLElement,
-    prevEntryButton: HTMLElement,
+    nextEntryButton: DOMTestHelper<TestHostComponent>,
+    prevEntryButton: DOMTestHelper<TestHostComponent>,
   ) {
     testCurrentTimestampOnButtonClick(prevEntryButton, position90, 90n);
-    expect(prevEntryButton.getAttribute('disabled')).toEqual('true');
-    expect(nextEntryButton.getAttribute('disabled')).toBeNull();
+    prevEntryButton.checkDisabled(true);
+    nextEntryButton.checkDisabled(false);
     testCurrentTimestampOnButtonClick(nextEntryButton, position90, 101n);
-    expect(prevEntryButton.getAttribute('disabled')).toBeNull();
-    expect(nextEntryButton.getAttribute('disabled')).toBeNull();
+    prevEntryButton.checkDisabled(false);
+    nextEntryButton.checkDisabled(false);
     testCurrentTimestampOnButtonClick(nextEntryButton, position110, 112n);
-    expect(prevEntryButton.getAttribute('disabled')).toBeNull();
-    expect(nextEntryButton.getAttribute('disabled')).toEqual('true');
+    prevEntryButton.checkDisabled(false);
+    nextEntryButton.checkDisabled(true);
   }
 
   function checkActiveTraceHasOneEntry(
-    nextEntryButton: HTMLElement,
-    prevEntryButton: HTMLElement,
+    nextEntryButton: DOMTestHelper<TestHostComponent>,
+    prevEntryButton: DOMTestHelper<TestHostComponent>,
   ) {
-    expect(prevEntryButton.getAttribute('disabled')).toEqual('true');
-    expect(nextEntryButton.getAttribute('disabled')).toEqual('true');
+    prevEntryButton.checkDisabled(true);
+    nextEntryButton.checkDisabled(true);
   }
 
   function checkNoTimelineNavigation() {
     const timelineComponent = assertDefined(component.timeline);
     // no expand button
     expect(
-      htmlElement.querySelector(`.${timelineComponent.TOGGLE_BUTTON_CLASS}`),
-    ).toBeNull();
+      dom.find(`.${timelineComponent.TOGGLE_BUTTON_CLASS}`),
+    ).toBeUndefined();
 
     // no timelines shown
-    const miniTimelineElement = fixture.debugElement.query(
-      By.directive(MiniTimelineComponent),
-    );
-    expect(miniTimelineElement).toBeFalsy();
+    const miniTimelineElement = dom.findByDirective(MiniTimelineComponent);
+    expect(miniTimelineElement).toBeUndefined();
 
     // arrow key presses don't do anything
     const spyNextEntry = spyOn(timelineComponent, 'moveToNextEntry');
     const spyPrevEntry = spyOn(timelineComponent, 'moveToPreviousEntry');
 
-    document.dispatchEvent(new KeyboardEvent('keydown', {key: 'ArrowRight'}));
-    fixture.detectChanges();
+    dom.keydownArrowRight(true);
     expect(spyNextEntry).not.toHaveBeenCalled();
 
-    document.dispatchEvent(new KeyboardEvent('keydown', {key: 'ArrowLeft'}));
-    fixture.detectChanges();
+    dom.keydownArrowLeft(true);
     expect(spyPrevEntry).not.toHaveBeenCalled();
   }
 
   function openContextMenu(xOffset = 0, clickBelowMarker = false) {
-    const miniTimelineCanvas = assertDefined(
-      htmlElement.querySelector<HTMLElement>('#mini-timeline-canvas'),
-    );
+    const miniTimelineCanvas = dom.get('#mini-timeline-canvas');
+    const canvasEl = miniTimelineCanvas.getHTMLElement();
     const yOffset = clickBelowMarker
       ? assertDefined(component.timeline?.miniTimeline?.drawer?.getHeight()) /
           6 +
@@ -1434,53 +1352,37 @@ describe('TimelineComponent', () => {
 
     const event = new MouseEvent('contextmenu');
     spyOnProperty(event, 'offsetX').and.returnValue(
-      miniTimelineCanvas.offsetLeft +
-        miniTimelineCanvas.offsetWidth / 2 +
-        xOffset,
+      canvasEl.offsetLeft + canvasEl.offsetWidth / 2 + xOffset,
     );
     spyOnProperty(event, 'offsetY').and.returnValue(
-      miniTimelineCanvas.offsetTop + yOffset,
+      canvasEl.offsetTop + yOffset,
     );
     miniTimelineCanvas.dispatchEvent(event);
-    fixture.detectChanges();
   }
 
   function clickToggleBookmarkOption() {
-    const menu = assertDefined(document.querySelector('.context-menu'));
-    const toggleOption = assertDefined(
-      menu.querySelector<HTMLElement>('.context-menu-item'),
-    );
-    toggleOption.click();
-    fixture.detectChanges();
+    const menu = dom.getInDocument('.context-menu');
+    menu.findAndClick('.context-menu-item');
   }
 
   function clickRemoveAllBookmarksOption() {
-    const menu = assertDefined(document.querySelector('.context-menu'));
-    const options = assertDefined(
-      menu.querySelectorAll<HTMLElement>('.context-menu-item'),
-    );
-    options.item(1).click();
-    fixture.detectChanges();
+    const menu = dom.getInDocument('.context-menu');
+    menu.findAndClickByIndex('.context-menu-item', 1);
   }
 
   function checkTimelineEnabled() {
-    expect(htmlElement.querySelector('.disabled-component')).toBeNull();
-    expect(htmlElement.querySelector('.disabled-message')).toBeNull();
+    expect(dom.find('.disabled-component')).toBeUndefined();
+    expect(dom.find('.disabled-message')).toBeUndefined();
   }
 
   function checkTimelineDisabled() {
-    expect(htmlElement.querySelector('.disabled-component')).toBeTruthy();
-    expect(htmlElement.querySelector('.disabled-message')).toBeTruthy();
+    expect(dom.find('.disabled-component')).toBeDefined();
+    expect(dom.find('.disabled-message')).toBeDefined();
   }
 
   function openExpandedTimeline() {
     const timelineComponent = assertDefined(component.timeline);
-    assertDefined(
-      htmlElement.querySelector<HTMLElement>(
-        `.${timelineComponent.TOGGLE_BUTTON_CLASS}`,
-      ),
-    ).click();
-    fixture.detectChanges();
+    dom.findAndClick(`.${timelineComponent.TOGGLE_BUTTON_CLASS}`);
   }
 
   @Component({
diff --git a/tools/winscope/src/app/components/timeline/timeline_utils.ts b/tools/winscope/src/app/components/timeline/timeline_utils.ts
index 7355df9f2..4a9aeb726 100644
--- a/tools/winscope/src/app/components/timeline/timeline_utils.ts
+++ b/tools/winscope/src/app/components/timeline/timeline_utils.ts
@@ -17,122 +17,122 @@
 import {assertDefined} from 'common/assert_utils';
 import {TimeRange, Timestamp} from 'common/time/time';
 import {ComponentTimestampConverter} from 'common/time/timestamp_converter';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
-
-export class TimelineUtils {
-  static isTransitionWithUnknownStart(transition: PropertyTreeNode): boolean {
-    const shellData = transition.getChildByName('shellData');
-    const dispatchTimestamp: Timestamp | undefined = shellData
-      ?.getChildByName('dispatchTimeNs')
-      ?.getValue();
-    return dispatchTimestamp === undefined;
+import {TransitionStatus} from 'trace/transitions/status';
+import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
+
+export function isTransitionWithUnknownStart(
+  transition: HierarchyTreeNode,
+): boolean {
+  const dispatchTimestamp: Timestamp | undefined = transition
+    ?.getEagerPropertyByName('dispatchTimeNs')
+    ?.getValue();
+  return dispatchTimestamp === undefined;
+}
+
+export function isTransitionWithUnknownEnd(
+  transition: HierarchyTreeNode,
+): boolean {
+  const aborted = isAborted(transition);
+  const finishOrAbortTimestamp: Timestamp | undefined = aborted
+    ? transition?.getEagerPropertyByName('shellAbortTimeNs')?.getValue()
+    : transition?.getEagerPropertyByName('finishTimeNs')?.getValue();
+  return finishOrAbortTimestamp === undefined;
+}
+
+function isAborted(transition: HierarchyTreeNode): boolean {
+  return (
+    transition.getEagerPropertyByName('status')?.formattedValue() ===
+    TransitionStatus.ABORTED
+  );
+}
+
+export function getTimeRangeForTransition(
+  transition: HierarchyTreeNode,
+  fullTimeRange: TimeRange,
+  converter: ComponentTimestampConverter,
+): TimeRange | undefined {
+  const aborted = isAborted(transition);
+
+  const dispatchTimestamp: Timestamp | undefined = transition
+    ?.getEagerPropertyByName('dispatchTimeNs')
+    ?.getValue();
+  const createTimestamp: Timestamp | undefined = transition
+    ?.getEagerPropertyByName('createTimeNs')
+    ?.getValue();
+  const finishOrAbortTimestamp: Timestamp | undefined = aborted
+    ? transition?.getEagerPropertyByName('shellAbortTimeNs')?.getValue()
+    : transition?.getEagerPropertyByName('finishTimeNs')?.getValue();
+
+  // currently we only render transitions during 'play' stage, so
+  // do not render if no dispatch time and no finish/shell abort time
+  // or if transition created but never dispatched to shell
+  // TODO (b/324056564): visualise transition lifecycle in timeline
+  if (
+    (!dispatchTimestamp && !finishOrAbortTimestamp) ||
+    (!dispatchTimestamp && createTimestamp)
+  ) {
+    return undefined;
   }
 
-  static isTransitionWithUnknownEnd(transition: PropertyTreeNode): boolean {
-    const shellData = transition.getChildByName('shellData');
-    const wmData = transition.getChildByName('wmData');
-    const aborted: boolean = assertDefined(
-      transition.getChildByName('aborted'),
-    ).getValue();
-    const finishOrAbortTimestamp: Timestamp | undefined = aborted
-      ? shellData?.getChildByName('abortTimeNs')?.getValue()
-      : wmData?.getChildByName('finishTimeNs')?.getValue();
-    return finishOrAbortTimestamp === undefined;
+  const timeRangeMin = fullTimeRange.from.getValueNs();
+  const timeRangeMax = fullTimeRange.to.getValueNs();
+
+  if (
+    finishOrAbortTimestamp &&
+    finishOrAbortTimestamp.getValueNs() < timeRangeMin
+  ) {
+    return undefined;
   }
 
-  static getTimeRangeForTransition(
-    transition: PropertyTreeNode,
-    fullTimeRange: TimeRange,
-    converter: ComponentTimestampConverter,
-  ): TimeRange | undefined {
-    const shellData = transition.getChildByName('shellData');
-    const wmData = transition.getChildByName('wmData');
-
-    const aborted: boolean = assertDefined(
-      transition.getChildByName('aborted'),
-    ).getValue();
-
-    const dispatchTimestamp: Timestamp | undefined = shellData
-      ?.getChildByName('dispatchTimeNs')
-      ?.getValue();
-    const createTimestamp: Timestamp | undefined = wmData
-      ?.getChildByName('createTimeNs')
-      ?.getValue();
-    const finishOrAbortTimestamp: Timestamp | undefined = aborted
-      ? shellData?.getChildByName('abortTimeNs')?.getValue()
-      : wmData?.getChildByName('finishTimeNs')?.getValue();
-
-    // currently we only render transitions during 'play' stage, so
-    // do not render if no dispatch time and no finish/shell abort time
-    // or if transition created but never dispatched to shell
-    // TODO (b/324056564): visualise transition lifecycle in timeline
-    if (
-      (!dispatchTimestamp && !finishOrAbortTimestamp) ||
-      (!dispatchTimestamp && createTimestamp)
-    ) {
-      return undefined;
-    }
-
-    const timeRangeMin = fullTimeRange.from.getValueNs();
-    const timeRangeMax = fullTimeRange.to.getValueNs();
-
-    if (
-      finishOrAbortTimestamp &&
-      finishOrAbortTimestamp.getValueNs() < timeRangeMin
-    ) {
-      return undefined;
-    }
-
-    if (
-      !finishOrAbortTimestamp &&
-      assertDefined(dispatchTimestamp).getValueNs() < timeRangeMin
-    ) {
-      return undefined;
-    }
-
-    if (
-      dispatchTimestamp &&
-      finishOrAbortTimestamp &&
-      dispatchTimestamp.getValueNs() > timeRangeMax
-    ) {
-      return undefined;
-    }
-
-    const dispatchTimeNs = dispatchTimestamp
-      ? dispatchTimestamp.getValueNs()
-      : assertDefined(finishOrAbortTimestamp).getValueNs() - 1n;
-
-    const finishTimeNs = finishOrAbortTimestamp
-      ? finishOrAbortTimestamp.getValueNs()
-      : dispatchTimeNs + 1n;
-
-    const startTime = converter.makeTimestampFromNs(
-      dispatchTimeNs > timeRangeMin ? dispatchTimeNs : timeRangeMin,
-    );
-    const finishTime = converter.makeTimestampFromNs(finishTimeNs);
-
-    return new TimeRange(startTime, finishTime);
+  if (
+    !finishOrAbortTimestamp &&
+    assertDefined(dispatchTimestamp).getValueNs() < timeRangeMin
+  ) {
+    return undefined;
   }
 
-  static convertHexToRgb(
-    hex: string,
-  ): {r: number; g: number; b: number} | undefined {
-    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
-    const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
-    hex = hex.replace(shorthandRegex, (m, r, g, b) => {
-      return r + r + g + g + b + b;
-    });
-
-    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
-    return result
-      ? {
-          // tslint:disable-next-line:ban
-          r: parseInt(result[1], 16),
-          // tslint:disable-next-line:ban
-          g: parseInt(result[2], 16),
-          // tslint:disable-next-line:ban
-          b: parseInt(result[3], 16),
-        }
-      : undefined;
+  if (
+    dispatchTimestamp &&
+    finishOrAbortTimestamp &&
+    dispatchTimestamp.getValueNs() > timeRangeMax
+  ) {
+    return undefined;
   }
+
+  const dispatchTimeNs = dispatchTimestamp
+    ? dispatchTimestamp.getValueNs()
+    : assertDefined(finishOrAbortTimestamp).getValueNs() - 1n;
+
+  const finishTimeNs = finishOrAbortTimestamp
+    ? finishOrAbortTimestamp.getValueNs()
+    : dispatchTimeNs + 1n;
+
+  const startTime = converter.makeTimestampFromNs(
+    dispatchTimeNs > timeRangeMin ? dispatchTimeNs : timeRangeMin,
+  );
+  const finishTime = converter.makeTimestampFromNs(finishTimeNs);
+
+  return new TimeRange(startTime, finishTime);
+}
+
+export function convertHexToRgb(
+  hex: string,
+): {r: number; g: number; b: number} | undefined {
+  // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
+  const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
+  hex = hex.replace(shorthandRegex, (m, r, g, b) => {
+    return r + r + g + g + b + b;
+  });
+
+  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
+  return result
+    ? {
+        // tslint:disable-next-line:ban
+        r: parseInt(result[1], 16),
+        // tslint:disable-next-line:ban
+        g: parseInt(result[2], 16),
+        // tslint:disable-next-line:ban
+        b: parseInt(result[3], 16),
+      }
+    : undefined;
 }
diff --git a/tools/winscope/src/app/components/timeline/timeline_utils_test.ts b/tools/winscope/src/app/components/timeline/timeline_utils_test.ts
new file mode 100644
index 000000000..20bc39052
--- /dev/null
+++ b/tools/winscope/src/app/components/timeline/timeline_utils_test.ts
@@ -0,0 +1,222 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import {TimestampConverterUtils} from 'common/time/test_utils';
+import {TimeRange} from 'common/time/time';
+import {HierarchyTreeBuilder} from 'test/unit/hierarchy_tree_builder';
+import {TransitionStatus} from 'trace/transitions/status';
+import {
+  convertHexToRgb,
+  getTimeRangeForTransition,
+  isTransitionWithUnknownEnd,
+  isTransitionWithUnknownStart,
+} from './timeline_utils';
+
+describe('TimelineUtils', () => {
+  const zeroTs = TimestampConverterUtils.makeZeroTimestamp();
+
+  describe('isTransitionWithUnknownStart', () => {
+    it('returns true if dispatch time missing', () => {
+      const transition = makeTransition({});
+      expect(isTransitionWithUnknownStart(transition)).toBeTrue();
+    });
+
+    it('returns false if dispatch time present, even if zero', () => {
+      const transition = makeTransition({dispatchTimeNs: zeroTs});
+      expect(isTransitionWithUnknownStart(transition)).toBeFalse();
+    });
+  });
+
+  describe('isTransitionWithUnknownEnd', () => {
+    it('returns true if aborted and no shell time present', () => {
+      const transition = makeTransition({status: 'ABORTED'});
+      expect(isTransitionWithUnknownEnd(transition)).toBeTrue();
+    });
+
+    it('returns false if aborted and shell time present', () => {
+      const transition = makeTransition({
+        status: 'ABORTED',
+        shellAbortTimeNs: zeroTs,
+      });
+      expect(isTransitionWithUnknownEnd(transition)).toBeFalse();
+    });
+
+    it('returns true if not aborted and finish time missing', () => {
+      const transition = makeTransition({});
+      expect(isTransitionWithUnknownEnd(transition)).toBeTrue();
+    });
+
+    it('returns false if not aborted and finish time present', () => {
+      const transition = makeTransition({finishTimeNs: zeroTs});
+      expect(isTransitionWithUnknownEnd(transition)).toBeFalse();
+    });
+  });
+
+  describe('getTimeRangeForTransition', () => {
+    const ts8 = TimestampConverterUtils.makeRealTimestamp(8n);
+    const ts9 = TimestampConverterUtils.makeRealTimestamp(9n);
+    const ts10 = TimestampConverterUtils.makeRealTimestamp(10n);
+    const ts12 = TimestampConverterUtils.makeRealTimestamp(12n);
+    const ts16 = TimestampConverterUtils.makeRealTimestamp(16n);
+    const ts17 = TimestampConverterUtils.makeRealTimestamp(17n);
+    const ts20 = TimestampConverterUtils.makeRealTimestamp(20n);
+    const ts21 = TimestampConverterUtils.makeRealTimestamp(21n);
+    const ts22 = TimestampConverterUtils.makeRealTimestamp(22n);
+    const fullTimeRange = new TimeRange(ts10, ts20);
+    const converter = TimestampConverterUtils.TIMESTAMP_CONVERTER;
+
+    it('returns undefined if dispatch, finish and abort times missing', () => {
+      const transition = makeTransition({});
+      expect(
+        getTimeRangeForTransition(transition, fullTimeRange, converter),
+      ).toBeUndefined();
+    });
+
+    it('returns undefined if dispatch time missing but create time present', () => {
+      const transition = makeTransition({
+        createTimeNs: ts12,
+        finishTimeNs: ts17,
+      });
+      expect(
+        getTimeRangeForTransition(transition, fullTimeRange, converter),
+      ).toBeUndefined();
+    });
+
+    it('returns undefined if finish time before full time range', () => {
+      const transition = makeTransition({
+        dispatchTimeNs: ts8,
+        finishTimeNs: ts9,
+      });
+      expect(
+        getTimeRangeForTransition(transition, fullTimeRange, converter),
+      ).toBeUndefined();
+    });
+
+    it('returns undefined if abort time before full time range', () => {
+      const transition = makeTransition({
+        dispatchTimeNs: ts8,
+        status: TransitionStatus.ABORTED,
+        shellAbortTimeNs: ts9,
+      });
+      expect(
+        getTimeRangeForTransition(transition, fullTimeRange, converter),
+      ).toBeUndefined();
+    });
+
+    it('returns undefined if finish and abort times missing and dispatch time before full time range', () => {
+      const transition = makeTransition({dispatchTimeNs: ts8});
+      expect(
+        getTimeRangeForTransition(transition, fullTimeRange, converter),
+      ).toBeUndefined();
+    });
+
+    it('returns undefined if dispatch time after full time range and finish time present', () => {
+      const transition = makeTransition({
+        dispatchTimeNs: ts21,
+        finishTimeNs: ts22,
+      });
+      expect(
+        getTimeRangeForTransition(transition, fullTimeRange, converter),
+      ).toBeUndefined();
+    });
+
+    it('returns undefined if dispatch time after full time range and abort time present', () => {
+      const transition = makeTransition({
+        dispatchTimeNs: ts21,
+        status: TransitionStatus.ABORTED,
+        shellAbortTimeNs: ts22,
+      });
+      expect(
+        getTimeRangeForTransition(transition, fullTimeRange, converter),
+      ).toBeUndefined();
+    });
+
+    it('returns range from dispatch to finish time', () => {
+      const transition = makeTransition({
+        dispatchTimeNs: ts12,
+        finishTimeNs: ts17,
+      });
+      expect(
+        getTimeRangeForTransition(transition, fullTimeRange, converter),
+      ).toEqual(new TimeRange(ts12, ts17));
+    });
+
+    it('returns range from dispatch to abort time', () => {
+      const transition = makeTransition({
+        dispatchTimeNs: ts12,
+        status: TransitionStatus.ABORTED,
+        shellAbortTimeNs: ts17,
+      });
+      expect(
+        getTimeRangeForTransition(transition, fullTimeRange, converter),
+      ).toEqual(new TimeRange(ts12, ts17));
+    });
+
+    it('returns range from unknown start to finish time', () => {
+      const transition = makeTransition({finishTimeNs: ts17});
+      expect(
+        getTimeRangeForTransition(transition, fullTimeRange, converter),
+      ).toEqual(new TimeRange(ts16, ts17));
+    });
+
+    it('returns range from unknown start to abort time', () => {
+      const transition = makeTransition({
+        status: TransitionStatus.ABORTED,
+        shellAbortTimeNs: ts17,
+      });
+      expect(
+        getTimeRangeForTransition(transition, fullTimeRange, converter),
+      ).toEqual(new TimeRange(ts16, ts17));
+    });
+
+    it('returns range from dispatch time to unknown end', () => {
+      const transition = makeTransition({dispatchTimeNs: ts16});
+      expect(
+        getTimeRangeForTransition(transition, fullTimeRange, converter),
+      ).toEqual(new TimeRange(ts16, ts17));
+    });
+  });
+
+  describe('convertHexToRgb', () => {
+    it('handles full regex', () => {
+      expect(convertHexToRgb('0135AF')).toEqual({r: 1, g: 53, b: 175});
+    });
+
+    it('handles full regex with # prefix', () => {
+      expect(convertHexToRgb('#0135AF')).toEqual({r: 1, g: 53, b: 175});
+    });
+
+    it('handles shorthand regex', () => {
+      expect(convertHexToRgb('13F')).toEqual({r: 17, g: 51, b: 255});
+    });
+
+    it('handles shorthand regex with #', () => {
+      expect(convertHexToRgb('#13F')).toEqual({r: 17, g: 51, b: 255});
+    });
+
+    it('robust to invalid hex string', () => {
+      expect(convertHexToRgb('#1')).toEqual(undefined);
+    });
+  });
+
+  function makeTransition(properties: object) {
+    return new HierarchyTreeBuilder()
+      .setId('')
+      .setName('')
+      .setProperties(properties)
+      .build();
+  }
+});
diff --git a/tools/winscope/src/app/components/trace_config_component_test.ts b/tools/winscope/src/app/components/trace_config_component_test.ts
index ceb5048c9..7698cd3dd 100644
--- a/tools/winscope/src/app/components/trace_config_component_test.ts
+++ b/tools/winscope/src/app/components/trace_config_component_test.ts
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 import {CommonModule} from '@angular/common';
-import {ComponentFixture, TestBed} from '@angular/core/testing';
+import {TestBed} from '@angular/core/testing';
 import {FormsModule, ReactiveFormsModule} from '@angular/forms';
 import {MatButtonModule} from '@angular/material/button';
 import {MatCheckboxModule} from '@angular/material/checkbox';
@@ -27,16 +27,15 @@ import {BrowserAnimationsModule} from '@angular/platform-browser/animations';
 import {assertDefined} from 'common/assert_utils';
 import {InMemoryStorage} from 'common/store/in_memory_storage';
 import {Store} from 'common/store/store';
-import {UnitTestUtils} from 'test/unit/utils';
+import {checkTooltips, DOMTestHelper} from 'test/unit/dom_test_utils';
 import {TraceType} from 'trace/trace_type';
 import {ConfigurationOptions} from 'trace_collection/ui/ui_trace_configuration';
 import {TraceConfigComponent} from './trace_config_component';
 
 describe('TraceConfigComponent', () => {
   const storeKey = 'TestConfigSettings';
-  let fixture: ComponentFixture<TraceConfigComponent>;
   let component: TraceConfigComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<TraceConfigComponent>;
   let configChangeSpy: jasmine.Spy;
 
   beforeEach(async () => {
@@ -56,9 +55,9 @@ describe('TraceConfigComponent', () => {
       ],
       declarations: [TraceConfigComponent],
     }).compileComponents();
-    fixture = TestBed.createComponent(TraceConfigComponent);
+    const fixture = TestBed.createComponent(TraceConfigComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
     configChangeSpy = spyOn(component.traceConfigChange, 'emit');
     await setComponentInputs(component);
   });
@@ -68,11 +67,7 @@ describe('TraceConfigComponent', () => {
   });
 
   it('displays config alphabetically by name', () => {
-    expect(
-      Array.from(
-        htmlElement.querySelectorAll<HTMLElement>('.trace-checkbox'),
-      ).map((box) => box.textContent?.trim()),
-    ).toEqual([
+    expect(dom.findAll('.trace-checkbox').map((box) => box.getText())).toEqual([
       'layers_trace',
       'multiple_selection_trace',
       'optional_multiple_selection_trace',
@@ -83,11 +78,7 @@ describe('TraceConfigComponent', () => {
   });
 
   it('displays advanced config alphabetically by name', () => {
-    expect(
-      Array.from(
-        htmlElement.querySelectorAll<HTMLElement>('.config-heading'),
-      ).map((box) => box.textContent?.trim()),
-    ).toEqual([
+    expect(dom.findAll('.config-heading').map((box) => box.getText())).toEqual([
       'layers_trace configuration',
       'multiple_selection_trace configuration',
       'optional_multiple_selection_trace configuration',
@@ -97,10 +88,7 @@ describe('TraceConfigComponent', () => {
   });
 
   it('applies stored config and emits event on init', async () => {
-    assertDefined(
-      htmlElement.querySelector<HTMLInputElement>('.enable-config-opt input'),
-    ).click();
-    fixture.detectChanges();
+    dom.findAndClick('.enable-config-opt input');
     expect(
       assertDefined(component.traceConfig)['layers_trace'].config
         .checkboxConfigs,
@@ -120,8 +108,9 @@ describe('TraceConfigComponent', () => {
 
     const newFixture = TestBed.createComponent(TraceConfigComponent);
     const newComponent = newFixture.componentInstance;
+    const newDom = new DOMTestHelper(newFixture, newFixture.nativeElement);
     const spy = spyOn(newComponent.traceConfigChange, 'emit');
-    await setComponentInputs(newComponent, newFixture, commonStorage);
+    await setComponentInputs(newComponent, newDom, commonStorage);
     expect(spy).toHaveBeenCalledTimes(1);
 
     const newConfig = assertDefined(newComponent.traceConfig);
@@ -138,15 +127,15 @@ describe('TraceConfigComponent', () => {
   it('handles proxy object for initial trace config', async () => {
     const newFixture = TestBed.createComponent(TraceConfigComponent);
     const newComponent = newFixture.componentInstance;
+    const newDom = new DOMTestHelper(newFixture, newFixture.nativeElement);
     const spy = spyOn(newComponent.traceConfigChange, 'emit');
 
     newComponent.title = 'Targets';
     newComponent.traceConfig = component.traceConfig;
     newComponent.traceConfigStoreKey = 'TestConfigSettings';
     newComponent.storage = component.storage;
-    await detectNgModelChanges(newFixture);
-    newFixture.detectChanges();
-
+    await detectNgModelChanges(newDom);
+    newDom.detectChanges();
     expect(spy).toHaveBeenCalledTimes(1);
   });
 
@@ -156,17 +145,15 @@ describe('TraceConfigComponent', () => {
     const config = assertDefined(component.traceConfig);
 
     const box = getTraceBoxForKey('layers_trace');
-    const inputElement = assertDefined(
-      box.querySelector<HTMLInputElement>('input'),
-    );
+    const input = box.get('input');
+    const inputElement = input.getHTMLElement<HTMLInputElement>();
 
-    expect(box.textContent).toContain(traceKey);
+    box.checkText(traceKey);
     expect(inputElement.checked).toBeTrue();
     expect(inputElement.ariaChecked).toEqual('true');
     expect(config[traceKey].config.enabled).toBeTrue();
 
-    inputElement.click();
-    fixture.detectChanges();
+    input.click();
     expect(inputElement.checked).toBeFalse();
     expect(inputElement.ariaChecked).toEqual('false');
     expect(config[traceKey].config.enabled).toBeFalse();
@@ -179,17 +166,15 @@ describe('TraceConfigComponent', () => {
     const config = assertDefined(component.traceConfig);
 
     const box = getTraceBoxForKey(traceKey);
-    const inputElement = assertDefined(
-      box.querySelector<HTMLInputElement>('input'),
-    );
+    const input = box.get('input');
+    const inputElement = input.getHTMLElement<HTMLInputElement>();
 
-    expect(box.textContent).toContain(traceKey);
+    box.checkText(traceKey);
     expect(inputElement.checked).toBeFalse();
     expect(inputElement.ariaChecked).toEqual('false');
     expect(config[traceKey].config.enabled).toBeFalse();
 
-    inputElement.click();
-    fixture.detectChanges();
+    input.click();
     expect(inputElement.checked).toBeTrue();
     expect(inputElement.ariaChecked).toEqual('true');
     expect(config[traceKey].config.enabled).toBeTrue();
@@ -199,31 +184,24 @@ describe('TraceConfigComponent', () => {
   it('disables checkbox for unavailable trace', () => {
     const traceKey = 'unavailable_trace';
     const box = getTraceBoxForKey(traceKey);
-    const inputElement = assertDefined(
-      box.querySelector<HTMLInputElement>('input'),
-    );
-    expect(inputElement.disabled).toBeTrue();
-    expect(box.textContent).toContain(traceKey);
+    box.get('input').checkDisabled(true);
+    box.checkText(traceKey);
   });
 
   it('checkbox and select configs show', () => {
-    const enable_config_opt = assertDefined(
-      htmlElement.querySelector('.enable-config-opt'),
-    );
-    expect(enable_config_opt.innerHTML).toContain('trace buffers');
-    expect(enable_config_opt.innerHTML).not.toContain('tracing level');
+    const enable_config_opt = dom.get('.enable-config-opt');
+    enable_config_opt.checkInnerHTML('trace buffers');
+    enable_config_opt.checkInnerHTML('tracing level', false);
 
-    const selection_config_opt = assertDefined(
-      htmlElement.querySelector('.selection-config-opt'),
-    );
-    expect(selection_config_opt.innerHTML).not.toContain('trace buffers');
-    expect(selection_config_opt.innerHTML).toContain('tracing level');
+    const selection_config_opt = dom.get('.selection-config-opt');
+    selection_config_opt.checkInnerHTML('trace buffers', false);
+    selection_config_opt.checkInnerHTML('tracing level');
   });
 
   it('changing checkbox config model value causes box to change', async () => {
-    const inputElement = assertDefined(
-      htmlElement.querySelector<HTMLInputElement>('.enable-config input'),
-    );
+    const inputElement = dom
+      .get('.enable-config input')
+      .getHTMLElement<HTMLInputElement>();
     assertDefined(
       assertDefined(component.traceConfig)['layers_trace'].config,
     ).checkboxConfigs[0].enabled = false;
@@ -241,46 +219,32 @@ describe('TraceConfigComponent', () => {
 
   it('changing checkbox config by DOM interaction emits event', async () => {
     configChangeSpy.calls.reset();
-    const inputElement = assertDefined(
-      htmlElement.querySelector<HTMLInputElement>('.enable-config input'),
-    );
-    inputElement.click();
-    fixture.detectChanges();
+    dom.findAndClick('.enable-config input');
     expect(configChangeSpy).toHaveBeenCalledTimes(1);
   });
 
   it('changing selected config causes select to change', async () => {
     configChangeSpy.calls.reset();
-    await openSelect(0);
-
-    const panel = assertDefined(
-      document.querySelector<HTMLElement>('.mat-select-panel'),
-    );
-    expect(panel.querySelector('.user-option')).toBeNull();
-
-    clickFirstOption(panel);
+    await dom.openMatSelect();
+    const panel = dom.getMatSelectPanel();
+    dom.clickMatOption();
+    expect(panel.find('.user-option')).toBeUndefined();
     expect(configChangeSpy).toHaveBeenCalledTimes(1);
   });
 
   it('clicking None button clears optional single selection config value', async () => {
     configChangeSpy.calls.reset();
-    await openSelect(getIndexForConfigKey('optional_selection_trace'));
+    await dom.openMatSelect(getIndexForConfigKey('optional_selection_trace'));
 
-    const panel = assertDefined(
-      document.querySelector<HTMLElement>('.mat-select-panel'),
-    );
-    clickFirstOption(panel);
+    dom.clickMatOption();
     expect(configChangeSpy).toHaveBeenCalledTimes(1);
     expect(
       configChangeSpy.calls.mostRecent().args[0]['optional_selection_trace']
         .config.selectionConfigs[0].value,
     ).toEqual('12345');
 
-    const noneButton = assertDefined(
-      panel.querySelectorAll<HTMLElement>('.user-option').item(0),
-    );
-    noneButton.click();
-    fixture.detectChanges();
+    const panel = dom.getMatSelectPanel();
+    panel.findAndClick('.user-option');
     expect(configChangeSpy).toHaveBeenCalledTimes(2);
     expect(
       configChangeSpy.calls.mostRecent().args[0]['optional_selection_trace']
@@ -290,16 +254,10 @@ describe('TraceConfigComponent', () => {
 
   it('clicking All button selects or clears all options for multiple selection config', async () => {
     configChangeSpy.calls.reset();
-    await openSelect(getIndexForConfigKey('multiple_selection_trace'));
+    await dom.openMatSelect(getIndexForConfigKey('multiple_selection_trace'));
 
-    const panel = assertDefined(
-      document.querySelector<HTMLElement>('.mat-select-panel'),
-    );
-    const allButton = assertDefined(
-      panel.querySelector<HTMLElement>('.user-option'),
-    );
-    allButton.click();
-    fixture.detectChanges();
+    const panel = dom.getMatSelectPanel();
+    const allButton = panel.findAndClick('.user-option');
     expect(configChangeSpy).toHaveBeenCalledTimes(1);
     expect(
       configChangeSpy.calls.mostRecent().args[0]['multiple_selection_trace']
@@ -307,7 +265,6 @@ describe('TraceConfigComponent', () => {
     ).toEqual(['12345', '67890']);
 
     allButton.click();
-    fixture.detectChanges();
     expect(configChangeSpy).toHaveBeenCalledTimes(2);
     expect(
       configChangeSpy.calls.mostRecent().args[0]['multiple_selection_trace']
@@ -316,29 +273,24 @@ describe('TraceConfigComponent', () => {
   });
 
   it('stabilizes tooltip position', async () => {
-    await openSelect(getIndexForConfigKey('optional_selection_trace'));
+    await dom.openMatSelect(getIndexForConfigKey('optional_selection_trace'));
 
-    const panel = assertDefined(
-      document.querySelector<HTMLElement>('.mat-select-panel'),
-    );
-    const options = panel.querySelectorAll<HTMLElement>('mat-option');
+    const panel = dom.getMatSelectPanel();
+    const options = panel.findAll('mat-option');
 
-    const shortOption = options.item(0);
-    UnitTestUtils.checkTooltips([shortOption], [undefined], fixture);
+    const shortOption = options[0];
+    checkTooltips([shortOption], [undefined]);
 
-    const longOption = options.item(1);
+    const longOption = options[1];
     longOption.dispatchEvent(new Event('mouseenter'));
-    fixture.detectChanges();
-    const tooltipPanel = assertDefined(
-      document.querySelector<HTMLElement>('.mat-tooltip-panel'),
-    );
+    const tooltipPanel = dom.findMatTooltipPanel()?.getHTMLElement();
     expect(tooltipPanel?.style.top.length).toBeGreaterThan(0);
     expect(tooltipPanel?.style.left.length).toBeGreaterThan(0);
   });
 
   async function setComponentInputs(
     c: TraceConfigComponent,
-    f: ComponentFixture<TraceConfigComponent> = fixture,
+    d: DOMTestHelper<TraceConfigComponent> = dom,
     storage: Store = new InMemoryStorage(),
   ) {
     c.title = 'Targets';
@@ -448,25 +400,24 @@ describe('TraceConfigComponent', () => {
     };
     c.traceConfigStoreKey = storeKey;
     c.storage = storage;
-    await detectNgModelChanges(f);
-    f.detectChanges();
+    await detectNgModelChanges(d);
+    d.detectChanges();
   }
 
   async function detectNgModelChanges(
-    f: ComponentFixture<TraceConfigComponent> = fixture,
+    d: DOMTestHelper<TraceConfigComponent> = dom,
   ) {
-    f.detectChanges();
-    await f.whenStable();
-    f.detectChanges();
+    await d.detectChangesAndWaitStable();
+    d.detectChanges();
   }
 
-  function getTraceBoxForKey(traceKey: string): HTMLElement {
+  function getTraceBoxForKey(
+    traceKey: string,
+  ): DOMTestHelper<TraceConfigComponent> {
     const index = component
       .getSortedTraceKeys()
       .findIndex((key) => key === traceKey);
-    return assertDefined(
-      htmlElement.querySelectorAll<HTMLElement>('.trace-checkbox').item(index),
-    );
+    return dom.findAll('.trace-checkbox')[index];
   }
 
   function getIndexForConfigKey(configKey: string): number {
@@ -474,23 +425,4 @@ describe('TraceConfigComponent', () => {
       .getSortedConfigKeys()
       .findIndex((key) => key === configKey);
   }
-
-  async function openSelect(index: number) {
-    const selectTrigger = assertDefined(
-      htmlElement
-        .querySelectorAll<HTMLElement>('.mat-select-trigger')
-        .item(index),
-    );
-    selectTrigger.click();
-    fixture.detectChanges();
-    await fixture.whenStable();
-  }
-
-  function clickFirstOption(panel: HTMLElement) {
-    const newOption = assertDefined(
-      panel.querySelector<HTMLElement>('mat-option'),
-    );
-    newOption.click();
-    fixture.detectChanges();
-  }
 });
diff --git a/tools/winscope/src/app/components/trace_view_component_test.ts b/tools/winscope/src/app/components/trace_view_component_test.ts
index 18cca6552..3184a38af 100644
--- a/tools/winscope/src/app/components/trace_view_component_test.ts
+++ b/tools/winscope/src/app/components/trace_view_component_test.ts
@@ -17,7 +17,7 @@
 import {OverlayModule} from '@angular/cdk/overlay';
 import {CommonModule} from '@angular/common';
 import {Component, CUSTOM_ELEMENTS_SCHEMA, ViewChild} from '@angular/core';
-import {ComponentFixture, TestBed} from '@angular/core/testing';
+import {TestBed} from '@angular/core/testing';
 import {ReactiveFormsModule} from '@angular/forms';
 import {MatButtonModule} from '@angular/material/button';
 import {MatCardModule} from '@angular/material/card';
@@ -38,27 +38,27 @@ import {
   WinscopeEvent,
   WinscopeEventType,
 } from 'messaging/winscope_event';
+import {checkTooltips, DOMTestHelper} from 'test/unit/dom_test_utils';
 import {TraceBuilder} from 'test/unit/trace_builder';
-import {UnitTestUtils} from 'test/unit/utils';
+import {makeEmptyTrace} from 'test/unit/trace_utils';
 import {TraceType} from 'trace/trace_type';
 import {Viewer, ViewType} from 'viewers/viewer';
 import {ViewerStub} from 'viewers/viewer_stub';
 import {TraceViewComponent} from './trace_view_component';
 
 describe('TraceViewComponent', () => {
-  const traceSf = UnitTestUtils.makeEmptyTrace(TraceType.SURFACE_FLINGER);
+  const traceSf = makeEmptyTrace(TraceType.SURFACE_FLINGER);
   const traceWm = new TraceBuilder<object>()
     .setType(TraceType.WINDOW_MANAGER)
     .setEntries([{}])
     .setTimestamps([TimestampConverterUtils.makeZeroTimestamp()])
     .setDescriptors(['file_1', 'file_1'])
     .build();
-  const traceSr = UnitTestUtils.makeEmptyTrace(TraceType.SCREEN_RECORDING);
-  const traceProtolog = UnitTestUtils.makeEmptyTrace(TraceType.PROTO_LOG);
+  const traceSr = makeEmptyTrace(TraceType.SCREEN_RECORDING);
+  const traceProtolog = makeEmptyTrace(TraceType.PROTO_LOG);
 
-  let fixture: ComponentFixture<TestHostComponent>;
   let component: TestHostComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<TestHostComponent>;
 
   beforeEach(async () => {
     await TestBed.configureTestingModule({
@@ -79,16 +79,16 @@ describe('TraceViewComponent', () => {
       ],
       schemas: [CUSTOM_ELEMENTS_SCHEMA],
     }).compileComponents();
-    fixture = TestBed.createComponent(TestHostComponent);
-    htmlElement = fixture.nativeElement;
+    const fixture = TestBed.createComponent(TestHostComponent);
     component = fixture.componentInstance;
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
     component.viewers = [
       new ViewerStub('Title0', 'Content0', traceSf, ViewType.TRACE_TAB),
       new ViewerStub('Title1', 'Content1', traceWm, ViewType.TRACE_TAB),
       new ViewerStub('Title2', 'Content2', traceSr, ViewType.OVERLAY),
       new ViewerStub('Title3', 'Content3', traceProtolog, ViewType.TRACE_TAB),
     ];
-    fixture.detectChanges();
+    dom.detectChanges();
   });
 
   it('can be created', () => {
@@ -96,17 +96,15 @@ describe('TraceViewComponent', () => {
   });
 
   it('creates viewer tabs', () => {
-    const tabs = htmlElement.querySelectorAll('.tab');
+    const tabs = getTabs();
     expect(tabs.length).toEqual(3);
-    expect(tabs.item(0).textContent).toContain('Title0');
-    expect(tabs.item(1).textContent).toContain('Title1 Dump');
+    tabs[0].checkText('Title0');
+    tabs[1].checkText('Title1 Dump');
   });
 
   it('creates viewer overlay', () => {
-    const overlayContainer = assertDefined(
-      htmlElement.querySelector('.overlay-container'),
-    );
-    expect(overlayContainer.textContent).toContain('Content2');
+    const overlayContainer = dom.get('.overlay-container');
+    overlayContainer.checkText('Content2');
   });
 
   it('throws error if more than one overlay present', () => {
@@ -116,29 +114,28 @@ describe('TraceViewComponent', () => {
         new ViewerStub('Title1', 'Content1', traceWm, ViewType.OVERLAY),
         new ViewerStub('Title2', 'Content2', traceSr, ViewType.OVERLAY),
       ];
-      fixture.detectChanges();
+      dom.detectChanges();
     }).toThrowError();
   });
 
   it('switches view on click', () => {
-    const tabButtons = htmlElement.querySelectorAll<HTMLElement>('.tab');
+    const tabs = getTabs();
 
     // Initially tab 0
-    fixture.detectChanges();
+    dom.detectChanges();
     let visibleTabContents = getVisibleTabContents();
     expect(visibleTabContents.length).toEqual(1);
     expect(visibleTabContents[0].innerHTML).toEqual('Content0');
 
     // Switch to tab 1
-    tabButtons.item(1).click();
-    fixture.detectChanges();
+    tabs[1].click();
     visibleTabContents = getVisibleTabContents();
     expect(visibleTabContents.length).toEqual(1);
     expect(visibleTabContents[0].innerHTML).toEqual('Content1');
 
     // Switch to tab 0
-    tabButtons.item(0).click();
-    fixture.detectChanges();
+    tabs[1].click();
+    tabs[0].click();
     visibleTabContents = getVisibleTabContents();
     expect(visibleTabContents.length).toEqual(1);
     expect(visibleTabContents[0].innerHTML).toEqual('Content0');
@@ -146,14 +143,13 @@ describe('TraceViewComponent', () => {
 
   it("emits 'view switched' events", () => {
     const traceViewComponent = assertDefined(component.traceViewComponent);
-    const tabButtons = htmlElement.querySelectorAll<HTMLElement>('.tab');
+    const tabs = getTabs();
 
     const emitAppEvent = jasmine.createSpy();
     traceViewComponent.setEmitEvent(emitAppEvent);
-
     expect(emitAppEvent).not.toHaveBeenCalled();
 
-    tabButtons.item(1).click();
+    tabs[1].click();
     expect(emitAppEvent).toHaveBeenCalledTimes(1);
     expect(emitAppEvent).toHaveBeenCalledWith(
       jasmine.objectContaining({
@@ -161,7 +157,7 @@ describe('TraceViewComponent', () => {
       } as WinscopeEvent),
     );
 
-    tabButtons.item(0).click();
+    tabs[0].click();
     expect(emitAppEvent).toHaveBeenCalledTimes(2);
     expect(emitAppEvent).toHaveBeenCalledWith(
       jasmine.objectContaining({
@@ -182,7 +178,7 @@ describe('TraceViewComponent', () => {
     await traceViewComponent.onWinscopeEvent(
       new TabbedViewSwitchRequest(traceWm),
     );
-    fixture.detectChanges();
+    dom.detectChanges();
     visibleTabContents = getVisibleTabContents();
     expect(visibleTabContents.length).toEqual(1);
     expect(visibleTabContents[0].innerHTML).toEqual('Content1');
@@ -191,7 +187,7 @@ describe('TraceViewComponent', () => {
     await traceViewComponent.onWinscopeEvent(
       new TabbedViewSwitchRequest(traceSf),
     );
-    fixture.detectChanges();
+    dom.detectChanges();
     visibleTabContents = getVisibleTabContents();
     expect(visibleTabContents.length).toEqual(1);
     expect(visibleTabContents[0].innerHTML).toEqual('Content0');
@@ -205,7 +201,7 @@ describe('TraceViewComponent', () => {
     expect(emitAppEvent).not.toHaveBeenCalled();
 
     component.viewers = [new ViewerStub('Title1', 'Content1', traceWm)];
-    fixture.detectChanges();
+    dom.detectChanges();
 
     expect(emitAppEvent).toHaveBeenCalledTimes(1);
     expect(emitAppEvent).toHaveBeenCalledWith(
@@ -216,15 +212,12 @@ describe('TraceViewComponent', () => {
   });
 
   it('disables filter presets button for viewers without presets', () => {
-    const filterPresets = assertDefined(
-      htmlElement.querySelector<HTMLButtonElement>('.filter-presets'),
-    );
-    expect(filterPresets.textContent).toContain('Filter Presets');
-    expect(filterPresets.disabled).toBeFalse();
-    const tabButtons = htmlElement.querySelectorAll<HTMLElement>('.tab');
-    tabButtons.item(2).click();
-    fixture.detectChanges();
-    expect(filterPresets.disabled).toBeTrue();
+    const filterPresets = dom.get('.filter-presets');
+    filterPresets.checkText('Filter Presets');
+    filterPresets.checkDisabled(false);
+    const tabs = getTabs();
+    tabs[2].click();
+    filterPresets.checkDisabled(true);
   });
 
   it('saves preset by button', () => {
@@ -232,25 +225,15 @@ describe('TraceViewComponent', () => {
     component.traceViewComponent?.setEmitEvent(emitAppEvent);
     openFilterPresets();
 
-    const overlayPanel = assertDefined(
-      document.querySelector('.overlay-panel'),
-    );
-    const existingPresets = assertDefined(
-      overlayPanel.querySelector('.existing-presets-section'),
-    );
-    expect(existingPresets.textContent).toContain('No existing presets found');
+    const overlay = getOverlay();
+    const existingPresets = overlay.get('.existing-presets-section');
+    existingPresets.checkText('No existing presets found');
 
-    const saveButton = assertDefined(
-      overlayPanel.querySelector<HTMLButtonElement>('.save-field button'),
-    );
-    expect(saveButton.disabled).toBeTrue();
+    const saveButton = overlay.get('.save-field button');
+    saveButton.checkDisabled(true);
 
-    const inputEl = assertDefined(
-      overlayPanel.querySelector<HTMLInputElement>('.save-field input'),
-    );
-    updateInputField(inputEl, 'Test Preset');
+    const input = overlay.findAndDispatchInput('.save-field', 'Test Preset');
     saveButton.click();
-    fixture.detectChanges();
 
     expect(emitAppEvent).toHaveBeenCalledWith(
       new FilterPresetSaveRequest(
@@ -258,9 +241,9 @@ describe('TraceViewComponent', () => {
         TraceType.SURFACE_FLINGER,
       ),
     );
-    expect(existingPresets.textContent).toContain('Test Preset');
-    expect(inputEl.value).toEqual('');
-    expect(saveButton.disabled).toBeTrue();
+    existingPresets.checkText('Test Preset');
+    input.checkValue('');
+    saveButton.checkDisabled(true);
   });
 
   it('saves preset by keydown', () => {
@@ -268,20 +251,14 @@ describe('TraceViewComponent', () => {
     component.traceViewComponent?.setEmitEvent(emitAppEvent);
     openFilterPresets();
 
-    const overlayPanel = assertDefined(
-      document.querySelector('.overlay-panel'),
-    );
+    const overlay = getOverlay();
 
-    const inputEl = assertDefined(
-      overlayPanel.querySelector<HTMLInputElement>('.save-field input'),
-    );
-    inputEl.dispatchEvent(new KeyboardEvent('keydown', {key: 'Enter'}));
-    fixture.detectChanges();
+    const inputEl = overlay.get('.save-field input');
+    inputEl.keydownEnter();
     expect(emitAppEvent).not.toHaveBeenCalled();
 
-    updateInputField(inputEl, 'Test Preset');
-    inputEl.dispatchEvent(new KeyboardEvent('keydown', {key: 'Enter'}));
-    fixture.detectChanges();
+    inputEl.dispatchInput('Test Preset');
+    inputEl.keydownEnter();
 
     expect(emitAppEvent).toHaveBeenCalledWith(
       new FilterPresetSaveRequest(
@@ -295,52 +272,38 @@ describe('TraceViewComponent', () => {
     savePresetByButton('Test Preset');
 
     component.showSecondComponent = true;
-    fixture.detectChanges();
+    dom.detectChanges();
 
     openFilterPresets();
-    const existingPresets = assertDefined(
-      document.querySelector('.overlay-panel .existing-presets-section'),
+    const existingPresets = dom.getInDocument(
+      '.overlay-panel .existing-presets-section',
     );
-    expect(existingPresets.textContent).toContain('Test Preset');
+    existingPresets.checkText('Test Preset');
   });
 
   it('deletes preset', () => {
     savePresetByButton('Test Preset');
-    const saveButton = assertDefined(
-      document.querySelector<HTMLButtonElement>('.save-field button'),
-    );
-    updateInputField(
-      assertDefined(
-        document.querySelector<HTMLInputElement>('.save-field input'),
-      ),
-      'Test Preset',
-    );
-    expect(saveButton.disabled).toBeTrue();
-
-    assertDefined(
-      document.querySelector<HTMLElement>('.delete-button'),
-    ).click();
-    fixture.detectChanges();
-    expect(
-      document.querySelector<HTMLElement>('.existing-presets-section')
-        ?.textContent,
-    ).toContain('No existing presets found');
-    expect(saveButton.disabled).toBeFalse();
+    const overlay = getOverlay();
+    const saveButton = overlay.get('.save-field button');
+    overlay.findAndDispatchInput('.save-field', 'Test Preset');
+    saveButton.checkDisabled(true);
+
+    dom.findAndClickInDocument('.delete-button');
+    dom
+      .getInDocument('.existing-presets-section')
+      .checkText('No existing presets found');
+    saveButton.checkDisabled(false);
   });
 
   it('does not show presets for different trace', () => {
     savePresetByButton('Test Preset');
-    closeFilterPresets();
-
-    const tabs = htmlElement.querySelectorAll<HTMLElement>('.tab');
-    tabs.item(1).click();
-    fixture.detectChanges();
+    dom.findAndClickInDocument('.cdk-overlay-backdrop');
+    const tabs = getTabs();
+    tabs[1].click();
 
     openFilterPresets();
-    const existingPresets = assertDefined(
-      document.querySelector('.overlay-panel'),
-    );
-    expect(existingPresets.textContent).toContain('No existing presets found');
+    const overlay = getOverlay();
+    overlay.checkText('No existing presets found');
   });
 
   it('emits apply preset request', () => {
@@ -348,14 +311,7 @@ describe('TraceViewComponent', () => {
     component.traceViewComponent?.setEmitEvent(emitAppEvent);
     savePresetByButton('Test Preset');
 
-    const preset = assertDefined(
-      document.querySelector<HTMLElement>(
-        '.overlay-panel .existing-preset button',
-      ),
-    );
-    preset.click();
-    fixture.detectChanges();
-
+    dom.findAndClickInDocument('.overlay-panel .existing-preset button');
     expect(emitAppEvent).toHaveBeenCalledWith(
       new FilterPresetApplyRequest(
         'Test Preset.Surface Flinger',
@@ -369,66 +325,46 @@ describe('TraceViewComponent', () => {
       new ViewerStub('Title0', 'Content0', undefined, ViewType.GLOBAL_SEARCH),
       new ViewerStub('Title1', 'Content1', traceWm, ViewType.TRACE_TAB),
     ];
-    fixture.detectChanges();
+    dom.detectChanges();
     const visibleTabContents = getVisibleTabContents();
     expect(visibleTabContents.length).toEqual(1);
     expect(visibleTabContents[0].innerHTML).toEqual('Content1');
   });
 
   it('shows tooltips for tabs with trace descriptors', async () => {
-    const tabs = htmlElement.querySelectorAll('.tab');
-    const wmTab = tabs.item(1);
-    await UnitTestUtils.checkTooltips([wmTab], ['file_1'], fixture);
+    const tabs = getTabs();
+    const wmTab = tabs[1];
+    await checkTooltips([wmTab], ['file_1']);
   });
 
   function getVisibleTabContents() {
     const contents: HTMLElement[] = [];
-    htmlElement
-      .querySelectorAll<HTMLElement>('.trace-view-content div')
-      .forEach((content) => {
-        if (content.style.display !== 'none') {
-          contents.push(content);
-        }
-      });
+    dom.findAll('.trace-view-content div').forEach((content) => {
+      const element = content.getHTMLElement();
+      if (element.style.display !== 'none') {
+        contents.push(element);
+      }
+    });
     return contents;
   }
 
-  function savePresetByButton(presetName: string) {
-    openFilterPresets();
-    const overlayPanel = assertDefined(
-      document.querySelector('.overlay-panel'),
-    );
-    const saveButton = assertDefined(
-      overlayPanel.querySelector<HTMLButtonElement>('.save-field button'),
-    );
-
-    const inputEl = assertDefined(
-      overlayPanel.querySelector<HTMLInputElement>('.save-field input'),
-    );
-    updateInputField(inputEl, presetName);
-    saveButton.click();
-    fixture.detectChanges();
+  function getTabs() {
+    return dom.findAll('.tab');
   }
 
-  function openFilterPresets() {
-    const filterPresets = assertDefined(
-      htmlElement.querySelector<HTMLButtonElement>('.filter-presets'),
-    );
-    filterPresets.click();
-    fixture.detectChanges();
+  function getOverlay() {
+    return dom.getInDocument('.overlay-panel');
   }
 
-  function closeFilterPresets() {
-    assertDefined(
-      document.querySelector<HTMLElement>('.cdk-overlay-backdrop'),
-    ).click();
-    fixture.detectChanges();
+  function savePresetByButton(presetName: string) {
+    openFilterPresets();
+    const overlay = getOverlay();
+    overlay.findAndDispatchInput('.save-field', presetName);
+    overlay.findAndClick('.save-field button');
   }
 
-  function updateInputField(inputEl: HTMLInputElement, value: string) {
-    inputEl.value = value;
-    inputEl.dispatchEvent(new Event('input'));
-    fixture.detectChanges();
+  function openFilterPresets() {
+    dom.findAndClick('.filter-presets');
   }
 
   @Component({
diff --git a/tools/winscope/src/app/components/upload_traces_component.ts b/tools/winscope/src/app/components/upload_traces_component.ts
index ef4e7b902..5e054a9fb 100644
--- a/tools/winscope/src/app/components/upload_traces_component.ts
+++ b/tools/winscope/src/app/components/upload_traces_component.ts
@@ -23,8 +23,13 @@ import {
   Output,
 } from '@angular/core';
 import {TracePipeline} from 'app/trace_pipeline';
+import {Store} from 'common/store/store';
 import {ProgressListener} from 'messaging/progress_listener';
-import {WinscopeEvent, WinscopeEventType} from 'messaging/winscope_event';
+import {
+  ShowTraceUploadWarning,
+  WinscopeEvent,
+  WinscopeEventType,
+} from 'messaging/winscope_event';
 import {WinscopeEventListener} from 'messaging/winscope_event_listener';
 import {Trace} from 'trace/trace';
 import {TRACE_INFO} from 'trace/trace_info';
@@ -40,44 +45,66 @@ import {LoadProgressComponent} from './load_progress_component';
         <div
           *ngIf="!isLoadingFiles && tracePipeline.getTraces().getSize() > 0"
           class="trace-actions-container">
-          <button
-            color="primary"
-            mat-raised-button
-            class="load-btn"
-            matTooltip="Upload trace with an associated viewer to visualize"
-            [matTooltipDisabled]="hasLoadedFilesWithViewers()"
-            [disabled]="isViewTracesButtonDisabled()"
-            (click)="onViewTracesButtonClick()">
-            View traces
-          </button>
-
-          <button
-            class="download-btn"
-            color="primary"
-            mat-stroked-button
-            (click)="downloadTracesClick.emit()">Download all</button>
-
-          <button
-            class="upload-btn"
-            color="primary"
-            mat-stroked-button
-            for="fileDropRef"
-            [disabled]="viewersLoading"
-            (click)="fileDropRef.click()">
-            Upload another file
-          </button>
-
-          <button
-            class="clear-all-btn"
-            color="primary"
-            mat-stroked-button
-            [disabled]="viewersLoading"
-            (click)="onClearButtonClick()">
-            Clear all
-          </button>
+          <div class="trace-action-buttons">
+            <button
+              class="clear-all-btn"
+              color="primary"
+              mat-stroked-button
+              [disabled]="viewersLoading"
+              (click)="onClearButtonClick()">
+              Clear all
+            </button>
+
+            <button
+              class="download-btn"
+              color="primary"
+              mat-stroked-button
+              (click)="downloadTracesClick.emit()">Download all</button>
+
+            <button
+              class="upload-btn"
+              color="primary"
+              mat-stroked-button
+              for="fileDropRef"
+              [disabled]="viewersLoading"
+              (click)="fileDropRef.click()">
+              Upload another file
+            </button>
+          </div>
+          <div class="trace-action-buttons">
+            <button
+              color="primary"
+              mat-raised-button
+              class="load-btn"
+              matTooltip="Upload trace with an associated viewer to visualize"
+              [matTooltipDisabled]="hasLoadedFilesWithViewers()"
+              [disabled]="isViewTracesButtonDisabled()"
+              (click)="onViewTracesButtonClick()">
+              View traces
+            </button>
+            <mat-checkbox
+              class="discard-legacy-traces wrapped-checkbox"
+              color="primary"
+              [checked]="!isDiscardLegacyTracesBoxDisabled() && discardLegacyTraces"
+              [disabled]="isDiscardLegacyTracesBoxDisabled()"
+              matTooltip="Discard legacy traces instead of converting to Perfetto to reduce loading time"
+              (change)="updateDiscardLegacyTraces()">
+              Discard legacy traces
+            </mat-checkbox>
+          </div>
         </div>
       </div>
 
+      <div *ngFor="let message of warningMessages; let i = index" class="warning-banner mat-elevation-z2">
+        <div class="warning-content">
+          <mat-icon class="warning-icon">warning</mat-icon>
+          <span class="warn-message">{{ message }}</span>
+        </div>
+         <button mat-icon-button (click)="clearWarning(i)" [attr.aria-label]="'Dismiss warning: ' + message">
+            <mat-icon>close</mat-icon>
+        </button>
+      </div>
+
       <mat-card-content
         class="drop-box"
         ref="drop-box"
@@ -156,17 +183,21 @@ import {LoadProgressComponent} from './load_progress_component';
       }
       .card-header {
         justify-content: space-between;
-        align-items: center;
+        align-items: start;
         display: flex;
         flex-direction: row;
       }
       .title {
         padding-top: 16px;
-        text-align: center;
+        text-align: start;
       }
       .trace-actions-container {
         display: flex;
-        flex-direction: row;
+        flex-direction: column;
+      }
+      .trace-action-buttons {
+        display: flex;
+        flex-direction: row-reverse;
         flex-wrap: wrap;
         gap: 10px;
         padding: 4px 0px;
@@ -226,8 +257,36 @@ import {LoadProgressComponent} from './load_progress_component';
       .trace-error {
         background-color: var(--error-background-color);
       }
-      .warning-icon, .error-icon {
-        flex-shrink: 0;
+      .warning-banner {
+        background-color: var(--warning-background-color);
+        padding: 8px 8px 8px 16px;
+        display: flex;
+        align-items: center;
+        justify-content: space-between;
+        gap: 8px;
+        margin: 10px 0;
+        border-radius: 4px;
+      }
+      .warning-banner .warning-content {
+         display: flex;
+         align-items: center;
+         gap: 8px;
+         flex-grow: 1;
+         text-align: left;
+      }
+      .warning-banner .warning-icon {
+         flex-shrink: 0;
+      }
+      .warning-banner .warn-message {
+        padding: 0;
+        margin: 0;
+        white-space: pre-line;
+      }
+      .discard-legacy-traces {
+        font-size: 14px;
+        display: flex;
+        align-items: center;
+        justify-content: end;
       }
     `,
   ],
@@ -241,19 +300,42 @@ export class UploadTracesComponent
   progressPercentage?: number;
   lastUiProgressUpdateTimeMs?: number;
   viewersLoading = false;
+  warningMessages: string[] = [];
+  discardLegacyTraces = false;
 
   @Input() tracePipeline: TracePipeline | undefined;
+  @Input() storage: Store | undefined;
   @Output() filesUploaded = new EventEmitter<File[]>();
-  @Output() viewTracesButtonClick = new EventEmitter<void>();
+  @Output() viewTracesButtonClick = new EventEmitter<boolean>();
   @Output() downloadTracesClick = new EventEmitter<void>();
 
+  private readonly discardLegacyStoreKey = 'discardLegacyTraces';
+
   constructor(
     @Inject(ChangeDetectorRef) private changeDetectorRef: ChangeDetectorRef,
     @Inject(NgZone) private ngZone: NgZone,
   ) {}
 
   ngOnInit() {
+    if (this.storage) {
+      const storedValue = this.storage.get(this.discardLegacyStoreKey);
+      this.discardLegacyTraces =
+        storedValue === 'true' || storedValue === undefined;
+    }
     this.tracePipeline?.clear();
+    this.clearAllWarnings();
+  }
+
+  updateDiscardLegacyTraces() {
+    this.discardLegacyTraces = !this.discardLegacyTraces;
+    this.storage?.add(
+      this.discardLegacyStoreKey,
+      this.discardLegacyTraces.toString(),
+    );
+  }
+
+  clearAllWarnings() {
+    this.warningMessages = [];
   }
 
   async onWinscopeEvent(event: WinscopeEvent) {
@@ -266,6 +348,15 @@ export class UploadTracesComponent
         this.viewersLoading = false;
       },
     );
+    await event.visit(
+      WinscopeEventType.SHOW_TRACE_UPLOAD_WARNING,
+      async (e: ShowTraceUploadWarning) => {
+        if (e.message && !this.warningMessages.includes(e.message)) {
+          this.warningMessages.push(e.message);
+        }
+        this.changeDetectorRef.detectChanges();
+      },
+    );
   }
 
   onProgressUpdate(
@@ -300,11 +391,12 @@ export class UploadTracesComponent
   }
 
   onViewTracesButtonClick() {
-    this.viewTracesButtonClick.emit();
+    this.viewTracesButtonClick.emit(this.discardLegacyTraces);
   }
 
   onClearButtonClick() {
     this.tracePipeline?.clear();
+    this.clearAllWarnings();
     this.onOperationFinished();
   }
 
@@ -352,6 +444,13 @@ export class UploadTracesComponent
     });
   }
 
+  isDiscardLegacyTracesBoxDisabled(): boolean {
+    if (this.isViewTracesButtonDisabled()) {
+      return true;
+    }
+    return !this.tracePipeline?.hasConvertibleLegacyTraces();
+  }
+
   isViewTracesButtonDisabled(): boolean {
     return this.viewersLoading || !this.hasLoadedFilesWithViewers();
   }
@@ -369,6 +468,11 @@ export class UploadTracesComponent
     return 'Cannot visualize trace. ' + reason;
   }
 
+  clearWarning(index: number) {
+    this.warningMessages.splice(index, 1);
+    this.changeDetectorRef.detectChanges(); // Trigger UI update
+  }
+
   private getInputFiles(event: Event): File[] {
     const files: FileList | null = (event?.target as HTMLInputElement)?.files;
     if (!files || !files[0]) {
diff --git a/tools/winscope/src/app/components/upload_traces_component_test.ts b/tools/winscope/src/app/components/upload_traces_component_test.ts
index 73f2f0296..513547f85 100644
--- a/tools/winscope/src/app/components/upload_traces_component_test.ts
+++ b/tools/winscope/src/app/components/upload_traces_component_test.ts
@@ -13,22 +13,26 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-import {ComponentFixture, TestBed} from '@angular/core/testing';
+import {ClipboardModule} from '@angular/cdk/clipboard';
+import {TestBed} from '@angular/core/testing';
 import {MatCardModule} from '@angular/material/card';
+import {MatCheckboxModule} from '@angular/material/checkbox';
 import {MatIconModule} from '@angular/material/icon';
 import {MatListModule} from '@angular/material/list';
 import {MatProgressBarModule} from '@angular/material/progress-bar';
 import {MatSnackBar, MatSnackBarModule} from '@angular/material/snack-bar';
 import {MatTooltipModule} from '@angular/material/tooltip';
-import {By} from '@angular/platform-browser';
 import {FilesSource} from 'app/files_source';
 import {TracePipeline} from 'app/trace_pipeline';
 import {assertDefined} from 'common/assert_utils';
+import {InMemoryStorage} from 'common/store/in_memory_storage';
 import {TimestampConverterUtils} from 'common/time/test_utils';
 import {
   AppTraceViewRequest,
   AppTraceViewRequestHandled,
+  ShowTraceUploadWarning,
 } from 'messaging/winscope_event';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
 import {getFixtureFile} from 'test/unit/fixture_utils';
 import {TraceBuilder} from 'test/unit/trace_builder';
 import {Traces} from 'trace/traces';
@@ -40,9 +44,13 @@ describe('UploadTracesComponent', () => {
   const clearAllSelector = '.clear-all-btn';
   const viewTracesSelector = '.load-btn';
   const removeTraceSelector = '.uploaded-files button';
-  let fixture: ComponentFixture<UploadTracesComponent>;
+  const warningBannerSelector = '.warning-banner';
+  const warningMessageSelector = '.warn-message';
+  const warningCloseButtonSelector = '.warning-banner button';
+  const discardLegacySelector = '.discard-legacy-traces input';
+
   let component: UploadTracesComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<UploadTracesComponent>;
   let validSfFile: File;
   let validWmFile: File;
 
@@ -55,13 +63,15 @@ describe('UploadTracesComponent', () => {
         MatIconModule,
         MatProgressBarModule,
         MatTooltipModule,
+        MatCheckboxModule,
+        ClipboardModule,
       ],
       providers: [MatSnackBar],
       declarations: [UploadTracesComponent, LoadProgressComponent],
     }).compileComponents();
-    fixture = TestBed.createComponent(UploadTracesComponent);
+    const fixture = TestBed.createComponent(UploadTracesComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
     component.tracePipeline = new TracePipeline();
     validSfFile = await getFixtureFile(
       'traces/elapsed_and_real_timestamp/SurfaceFlinger.pb',
@@ -69,7 +79,8 @@ describe('UploadTracesComponent', () => {
     validWmFile = await getFixtureFile(
       'traces/elapsed_and_real_timestamp/WindowManager.pb',
     );
-    fixture.detectChanges();
+    component.storage = new InMemoryStorage();
+    dom.detectChanges();
   });
 
   it('can be created', () => {
@@ -77,9 +88,7 @@ describe('UploadTracesComponent', () => {
   });
 
   it('renders the expected card title', () => {
-    expect(htmlElement.querySelector('.title')?.innerHTML).toContain(
-      'Upload Traces',
-    );
+    dom.get('.title').checkText('Upload Traces');
   });
 
   it('handles file upload via drag and drop', () => {
@@ -101,100 +110,143 @@ describe('UploadTracesComponent', () => {
 
   it('displays only load progress bar on progress update (no existing files)', () => {
     component.onProgressUpdate(undefined, undefined);
-    fixture.detectChanges();
+    dom.detectChanges();
     checkOnlyProgressBarShowing();
 
     component.onOperationFinished();
-    fixture.detectChanges();
-    expect(htmlElement.querySelector('load-progress')).toBeNull();
-    assertDefined(htmlElement.querySelector('.drop-info'));
+    dom.detectChanges();
+    expect(dom.find('load-progress')).toBeUndefined();
+    expect(dom.find('.drop-info')).toBeDefined();
   });
 
   it('displays only load progress bar on progress update (existing files)', async () => {
     await loadFiles([validSfFile]);
     component.onProgressUpdate(undefined, undefined);
-    fixture.detectChanges();
+    dom.detectChanges();
     checkOnlyProgressBarShowing();
 
     component.onOperationFinished();
-    fixture.detectChanges();
-    expect(htmlElement.querySelector('load-progress')).toBeNull();
-    assertDefined(htmlElement.querySelector('.trace-actions-container'));
-    assertDefined(htmlElement.querySelector('.uploaded-files'));
+    dom.detectChanges();
+    expect(dom.find('load-progress')).toBeUndefined();
+    expect(dom.find('.trace-actions-container')).toBeDefined();
+    expect(dom.find('.uploaded-files')).toBeDefined();
   });
 
   it('shows progress bar with custom message', () => {
     component.onProgressUpdate('Updating', undefined);
-    fixture.detectChanges();
+    dom.detectChanges();
     checkOnlyProgressBarShowing('Updating');
   });
 
   it('updates progress bar percentage only if sufficient time has passed', () => {
     component.onProgressUpdate(undefined, 10);
-    fixture.detectChanges();
-    const progressBar = fixture.debugElement.query(
-      By.directive(LoadProgressComponent),
-    ).componentInstance as LoadProgressComponent;
+    dom.detectChanges();
+    const progressBar = assertDefined(
+      dom.findByDirective(LoadProgressComponent),
+    );
     expect(progressBar.progressPercentage).toEqual(10);
 
     component.onProgressUpdate(undefined, 20);
-    fixture.detectChanges();
+    dom.detectChanges();
     expect(progressBar.progressPercentage).toEqual(10);
 
     const now = Date.now();
     spyOn(Date, 'now').and.returnValue(now + 500);
     component.onProgressUpdate(undefined, 20);
-    fixture.detectChanges();
+    dom.detectChanges();
     expect(progressBar.progressPercentage).toEqual(20);
   });
 
   it('can display uploaded traces', async () => {
     await loadFiles([validSfFile]);
-    assertDefined(htmlElement.querySelector('.uploaded-files'));
-    assertDefined(htmlElement.querySelector('.trace-actions-container'));
+    expect(dom.find('.uploaded-files')).toBeDefined();
+    expect(dom.find('.trace-actions-container')).toBeDefined();
   });
 
   it('can remove one of two uploaded traces', async () => {
     await loadFiles([validSfFile, validWmFile]);
-    expect(component.tracePipeline?.getTraces().getSize()).toBe(2);
+    expect(component.tracePipeline?.getTraces().getSize()).toEqual(2);
 
     const spy = spyOn(component, 'onOperationFinished');
-    removeTrace();
-    assertDefined(htmlElement.querySelector('.uploaded-files'));
+    dom.findAndClick(removeTraceSelector);
+    expect(dom.find('.uploaded-files')).toBeDefined();
     expect(spy).toHaveBeenCalled();
-    expect(component.tracePipeline?.getTraces().getSize()).toBe(1);
+    expect(component.tracePipeline?.getTraces().getSize()).toEqual(1);
   });
 
   it('handles removal of the only uploaded trace', async () => {
     await loadFiles([validSfFile]);
 
     const spy = spyOn(component, 'onOperationFinished');
-    removeTrace();
-    assertDefined(htmlElement.querySelector('.drop-info'));
+    dom.findAndClick(removeTraceSelector);
+    expect(dom.find('.drop-info')).toBeDefined();
     expect(spy).toHaveBeenCalled();
-    expect(component.tracePipeline?.getTraces().getSize()).toBe(0);
+    expect(component.tracePipeline?.getTraces().getSize()).toEqual(0);
   });
 
   it('can remove all uploaded traces', async () => {
     await loadFiles([validSfFile, validWmFile]);
-    expect(component.tracePipeline?.getTraces().getSize()).toBe(2);
+    expect(component.tracePipeline?.getTraces().getSize()).toEqual(2);
 
     const spy = spyOn(component, 'onOperationFinished');
-    const clearAllButton = getButton(clearAllSelector);
-    clearAllButton.click();
-    fixture.detectChanges();
-    assertDefined(htmlElement.querySelector('.drop-info'));
+    dom.findAndClick(clearAllSelector);
+    expect(dom.find('.drop-info')).toBeDefined();
     expect(spy).toHaveBeenCalled();
-    expect(component.tracePipeline?.getTraces().getSize()).toBe(0);
+    expect(component.tracePipeline?.getTraces().getSize()).toEqual(0);
   });
 
   it('can emit view traces event', async () => {
     await loadFiles([validSfFile]);
+    const spy = spyOn(component.viewTracesButtonClick, 'emit');
+    dom.findAndClick(viewTracesSelector);
+    expect(spy).toHaveBeenCalledWith(true);
+  });
 
+  it('can emit view traces event discarding legacy traces', async () => {
+    await loadFiles([validSfFile]);
+    dom.findAndClick(discardLegacySelector);
     const spy = spyOn(component.viewTracesButtonClick, 'emit');
-    getButton(viewTracesSelector).click();
-    fixture.detectChanges();
-    expect(spy).toHaveBeenCalled();
+    dom.findAndClick(viewTracesSelector);
+    expect(spy).toHaveBeenCalledWith(false);
+  });
+
+  it('disables checkbox to discard legacy traces', async () => {
+    await loadFiles([validSfFile]);
+    spyOn(
+      assertDefined(component.tracePipeline),
+      'hasConvertibleLegacyTraces',
+    ).and.returnValue(false);
+    dom.detectChanges();
+    const box = dom.get(discardLegacySelector);
+    box.checkDisabled(true);
+    expect(box.getHTMLElement<HTMLInputElement>().checked).toBeFalse();
+  });
+
+  it('updates discard legacy traces box from storage', async () => {
+    await loadFiles([validSfFile]);
+    dom.findAndClick(discardLegacySelector);
+
+    const fixture = TestBed.createComponent(UploadTracesComponent);
+    const newComponent = fixture.componentInstance;
+    const newDom = new DOMTestHelper(fixture, fixture.nativeElement);
+    newComponent.storage = component.storage;
+    newComponent.tracePipeline = new TracePipeline();
+    newDom.detectChanges();
+
+    await newComponent.tracePipeline.loadFiles(
+      [validSfFile],
+      FilesSource.TEST,
+      undefined,
+    );
+    newDom.detectChanges();
+
+    expect(
+      newDom.get(discardLegacySelector).getHTMLElement<HTMLInputElement>()
+        .checked,
+    ).toBeFalse();
+    const spy = spyOn(newComponent.viewTracesButtonClick, 'emit');
+    newDom.findAndClick(viewTracesSelector);
+    expect(spy).toHaveBeenCalledWith(false);
   });
 
   it('shows warning elements for traces without visualization', async () => {
@@ -202,9 +254,9 @@ describe('UploadTracesComponent', () => {
       'traces/elapsed_and_real_timestamp/shell_transition_trace.pb',
     );
     await loadFiles([shellTransitionFile]);
-
-    expect(htmlElement.querySelector('.warning-icon')).toBeTruthy();
-    expect(getButton(viewTracesSelector).disabled).toBeTrue();
+    expect(dom.find('.warning-icon')).toBeDefined();
+    dom.get(viewTracesSelector).checkDisabled(true);
+    dom.get(discardLegacySelector).checkDisabled(true);
   });
 
   it('shows error elements for corrupted traces', async () => {
@@ -218,50 +270,42 @@ describe('UploadTracesComponent', () => {
     spyOn(assertDefined(component.tracePipeline), 'getTraces').and.returnValue(
       traces,
     );
-    fixture.detectChanges();
-
-    expect(htmlElement.querySelector('.error-icon')).toBeTruthy();
-    expect(getButton(viewTracesSelector).disabled).toBeTrue();
+    dom.detectChanges();
+    expect(dom.find('.error-icon')).toBeDefined();
+    dom.get(viewTracesSelector).checkDisabled(true);
   });
 
   it('emits download traces event', async () => {
     await loadFiles([validSfFile]);
-
     const spy = spyOn(component.downloadTracesClick, 'emit');
-    const downloadTracesButton = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.download-btn'),
-    );
-    downloadTracesButton.click();
-    fixture.detectChanges();
+    dom.findAndClick('.download-btn');
     expect(spy).toHaveBeenCalled();
   });
 
   it('disables edit/view traces functionality on trace view request events', async () => {
     await loadFiles([validSfFile]);
     const buttons = [
-      getButton(viewTracesSelector),
-      getButton(removeTraceSelector),
-      getButton(clearAllSelector),
-      getButton(uploadSelector),
+      dom.get(viewTracesSelector),
+      dom.get(removeTraceSelector),
+      dom.get(clearAllSelector),
+      dom.get(uploadSelector),
     ];
-    const dropBox = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.drop-box'),
-    );
+    const dropBox = dom.get('.drop-box');
     const spy = spyOn(component.filesUploaded, 'emit');
 
     await component.onWinscopeEvent(new AppTraceViewRequest());
-    fixture.detectChanges();
+    dom.detectChanges();
     buttons.forEach((button) => {
-      expect(button.disabled).toBeTrue();
+      button.checkDisabled(true);
     });
     dropFileAndGetTransferredFiles();
     addFileByClickAndGetTransferredFiles(true, dropBox);
     expect(spy).not.toHaveBeenCalled();
 
     await component.onWinscopeEvent(new AppTraceViewRequestHandled());
-    fixture.detectChanges();
+    dom.detectChanges();
     buttons.forEach((button) => {
-      expect(button.disabled).toBeFalse();
+      button.checkDisabled(false);
     });
     const files = dropFileAndGetTransferredFiles();
     expect(spy).toHaveBeenCalledOnceWith(files);
@@ -270,65 +314,173 @@ describe('UploadTracesComponent', () => {
     expect(spy).toHaveBeenCalledOnceWith(files);
   });
 
+  it('displays warning banners when ShowTraceUploadWarning events received', async () => {
+    const warningMessage1 = 'This is the first warning!';
+    const warningMessage2 = 'This is the second warning!';
+    const warningEvent1 = new ShowTraceUploadWarning(warningMessage1);
+    const warningEvent2 = new ShowTraceUploadWarning(warningMessage2);
+
+    // Initially, no banners should be visible
+    expect(component.warningMessages.length).toEqual(0);
+    expect(dom.findAll(warningBannerSelector).length).toEqual(0);
+
+    // Simulate receiving the first event
+    await component.onWinscopeEvent(warningEvent1);
+    dom.detectChanges();
+
+    // Assert first banner visibility and message content
+    expect(component.warningMessages).toEqual([warningMessage1]);
+    let bannerElements = dom.findAll(warningBannerSelector);
+    expect(bannerElements.length).toEqual(1);
+    bannerElements[0]
+      .get(warningMessageSelector)
+      .checkTextExact(warningMessage1);
+
+    // Simulate receiving the second event
+    await component.onWinscopeEvent(warningEvent2);
+    dom.detectChanges();
+
+    // Assert both banners are visible with correct messages
+    expect(component.warningMessages).toEqual([
+      warningMessage1,
+      warningMessage2,
+    ]);
+    bannerElements = dom.findAll(warningBannerSelector);
+    expect(bannerElements.length).toEqual(2);
+    bannerElements[0]
+      .get(warningMessageSelector)
+      .checkTextExact(warningMessage1);
+    bannerElements[1]
+      .get(warningMessageSelector)
+      .checkTextExact(warningMessage2);
+
+    // Simulate receiving the first event again (should not add duplicate)
+    await component.onWinscopeEvent(warningEvent1);
+    dom.detectChanges();
+    expect(component.warningMessages).toEqual([
+      warningMessage1,
+      warningMessage2,
+    ]);
+    expect(dom.findAll(warningBannerSelector).length).toEqual(2);
+  });
+
+  it('clears specific warning banner when its close button is clicked', async () => {
+    const warningMessage1 = 'Warning 1 to dismiss';
+    const warningMessage2 = 'Warning 2 to keep';
+    const warningEvent1 = new ShowTraceUploadWarning(warningMessage1);
+    const warningEvent2 = new ShowTraceUploadWarning(warningMessage2);
+
+    // Show the banners first
+    await component.onWinscopeEvent(warningEvent1);
+    await component.onWinscopeEvent(warningEvent2);
+    dom.detectChanges();
+    let warningBanners = dom.findAll(warningBannerSelector);
+    expect(warningBanners.length).toEqual(2);
+    warningBanners[0]
+      .get(warningMessageSelector)
+      .checkTextExact(warningMessage1);
+    warningBanners[1]
+      .get(warningMessageSelector)
+      .checkTextExact(warningMessage2);
+
+    const firstBannerCloseButton = warningBanners[0].find(
+      warningCloseButtonSelector,
+    );
+    firstBannerCloseButton!!.click();
+    dom.detectChanges();
+
+    // Assert only the first banner is removed
+    warningBanners = dom.findAll(warningBannerSelector);
+    expect(warningBanners.length).toEqual(1);
+    warningBanners[0]
+      .get(warningMessageSelector)
+      .checkTextExact(warningMessage2);
+  });
+
+  it('clears all warning banners when clear all button is clicked', async () => {
+    const warningMessage1 = 'Warning before clear all 1!';
+    const warningMessage2 = 'Warning before clear all 2!';
+    const warningEvent1 = new ShowTraceUploadWarning(warningMessage1);
+    const warningEvent2 = new ShowTraceUploadWarning(warningMessage2);
+    await loadFiles([validSfFile]); // Need a file to enable clear all
+
+    // Show the banners first
+    await component.onWinscopeEvent(warningEvent1);
+    await component.onWinscopeEvent(warningEvent2);
+    dom.detectChanges();
+    expect(component.warningMessages.length).toEqual(2);
+    expect(dom.findAll(warningBannerSelector).length).toEqual(2);
+
+    // Click clear all
+    dom.findAndClick(clearAllSelector);
+
+    // Assert banners are hidden
+    expect(component.warningMessages.length).toEqual(0);
+    expect(dom.findAll(warningBannerSelector).length).toEqual(0);
+  });
+
+  it('warning banners are not cleared when new files are uploaded', async () => {
+    const warningMessage1 = 'Warning before new load 1!';
+    const warningMessage2 = 'Warning before new load 2!';
+    const warningEvent1 = new ShowTraceUploadWarning(warningMessage1);
+    const warningEvent2 = new ShowTraceUploadWarning(warningMessage2);
+
+    // Show the banners first
+    await component.onWinscopeEvent(warningEvent1);
+    await component.onWinscopeEvent(warningEvent2);
+    dom.detectChanges();
+    expect(component.warningMessages.length).toEqual(2);
+    expect(dom.findAll(warningBannerSelector).length).toEqual(2);
+
+    // Start a new progress update
+    component.onProgressUpdate('Loading new files...', 0);
+    dom.detectChanges();
+
+    // Assert banners are hidden
+    expect(component.warningMessages.length).toEqual(2);
+    expect(dom.findAll(warningBannerSelector).length).toEqual(2);
+  });
+
   async function loadFiles(files: File[]) {
     const tracePipeline = assertDefined(component.tracePipeline);
     tracePipeline.clear();
     await tracePipeline.loadFiles(files, FilesSource.TEST, undefined);
-    fixture.detectChanges();
+    dom.detectChanges();
   }
 
   function dropFileAndGetTransferredFiles(withFile = true): File[] {
-    const dropbox = assertDefined(htmlElement.querySelector('.drop-box'));
     let dataTransfer: DataTransfer | undefined;
     if (withFile) {
       dataTransfer = new DataTransfer();
       dataTransfer.items.add(validSfFile);
     }
-    dropbox.dispatchEvent(new DragEvent('drop', {dataTransfer}));
-    fixture.detectChanges();
+    const dropBox = dom.get('.drop-box');
+    dropBox.dispatchEvent(new DragEvent('drop', {dataTransfer}));
     return Array.from(dataTransfer?.files ?? []);
   }
 
   function addFileByClickAndGetTransferredFiles(
     withFile = true,
-    clickEl: HTMLElement = getButton(uploadSelector),
+    clickEl = dom.get(uploadSelector),
   ): File[] {
     const dataTransfer = new DataTransfer();
     if (withFile) dataTransfer.items.add(validSfFile);
     const fileList = dataTransfer.files;
 
-    const fileInput = assertDefined(
-      htmlElement.querySelector<HTMLInputElement>('.drop-box input'),
-    );
+    const fileInput = dom.get('.drop-box input');
+    const fileInputEl = fileInput.getHTMLElement<HTMLInputElement>();
     clickEl.addEventListener('click', () => {
-      fileInput.files = fileList;
+      fileInputEl.files = fileList;
     });
-
     clickEl.click();
-    fixture.detectChanges();
     fileInput.dispatchEvent(new Event('change'));
-    fixture.detectChanges();
     return Array.from(fileList);
   }
 
-  function removeTrace() {
-    getButton(removeTraceSelector).click();
-    fixture.detectChanges();
-  }
-
-  function getButton(selector: string): HTMLButtonElement {
-    return assertDefined(
-      htmlElement.querySelector<HTMLButtonElement>(selector),
-    );
-  }
-
   function checkOnlyProgressBarShowing(expectedMessage = 'Loading...') {
-    const progressBar = assertDefined(
-      htmlElement.querySelector('load-progress'),
-    );
-    expect(progressBar.textContent).toEqual(expectedMessage);
-    expect(htmlElement.querySelector('.trace-actions-container')).toBeNull();
-    expect(htmlElement.querySelector('.uploaded-files')).toBeNull();
-    expect(htmlElement.querySelector('.drop-info')).toBeNull();
+    dom.get('load-progress').checkTextExact(expectedMessage);
+    expect(dom.find('.trace-actions-container')).toBeUndefined();
+    expect(dom.find('.uploaded-files')).toBeUndefined();
+    expect(dom.find('.drop-info')).toBeUndefined();
   }
 });
diff --git a/tools/winscope/src/app/components/warning_dialog_component.ts b/tools/winscope/src/app/components/warning_dialog_component.ts
index daaa66f33..531c000dd 100644
--- a/tools/winscope/src/app/components/warning_dialog_component.ts
+++ b/tools/winscope/src/app/components/warning_dialog_component.ts
@@ -30,13 +30,20 @@ import {MAT_DIALOG_DATA} from '@angular/material/dialog';
           <mat-checkbox
             *ngFor="let option of data.options; let i = index"
             color="primary"
-            (change)="updateSelectedOptions(option)"
-            [class.not-last]="i < data.options.length - 1"
-            >{{ option }}</mat-checkbox>
+            [checked]="selectedOptions.includes(option)"
+            (change)="updateSelectedOptions(option)">{{ option }}</mat-checkbox>
         </div>
         <div class="warning-action-buttons">
-          <button *ngFor="let action of data.actions" [mat-dialog-close]="getDialogResult(action)" class="not-last" color="primary" mat-stroked-button> {{ action }} </button>
-          <button [mat-dialog-close]="getDialogResult(data.closeText)" color="primary" mat-raised-button> {{ data.closeText }} </button>
+          <button
+            *ngFor="let action of data.actions"
+            [mat-dialog-close]="getDialogResult(action)"
+            class="not-last"
+            color="primary"
+            mat-stroked-button> {{ action }} </button>
+          <button
+            [mat-dialog-close]="getDialogResult(data.closeText)"
+            color="primary"
+            mat-raised-button> {{ data.closeText }} </button>
         </div>
       </div>
     </mat-dialog-content>
@@ -61,10 +68,15 @@ import {MAT_DIALOG_DATA} from '@angular/material/dialog';
       }
       .warning-actions {
         display: flex;
+        flex-direction: column;
         justify-content: space-between;
-        align-items: center;
+        align-items: end;
         margin-top: 8px;
       }
+      .warning-action-boxes {
+        display: flex;
+        flex-direction: column;
+      }
       .warning-actions .not-last {
         margin-right: 8px;
       }
@@ -78,9 +90,15 @@ export class WarningDialogComponent {
 
   updateSelectedOptions(clickedOption: string) {
     if (!this.selectedOptions.includes(clickedOption)) {
-      this.selectedOptions.push(clickedOption);
+      if (this.data.singleSelection) {
+        this.selectedOptions = [clickedOption];
+      } else {
+        this.selectedOptions.push(clickedOption);
+      }
     } else {
-      this.selectedOptions.filter((opt) => opt !== clickedOption);
+      this.selectedOptions = this.selectedOptions.filter(
+        (opt) => opt !== clickedOption,
+      );
     }
   }
 
@@ -94,6 +112,7 @@ export interface WarningDialogData {
   actions: string[] | undefined;
   options: string[] | undefined;
   closeText: string;
+  singleSelection?: boolean;
 }
 
 export interface WarningDialogResult {
diff --git a/tools/winscope/src/app/components/warning_dialog_component_test.ts b/tools/winscope/src/app/components/warning_dialog_component_test.ts
index 45c92905b..96eeb8f97 100644
--- a/tools/winscope/src/app/components/warning_dialog_component_test.ts
+++ b/tools/winscope/src/app/components/warning_dialog_component_test.ts
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 import {Component, Inject} from '@angular/core';
-import {ComponentFixture, TestBed} from '@angular/core/testing';
+import {TestBed} from '@angular/core/testing';
 import {MatButtonModule} from '@angular/material/button';
 import {MatCheckboxModule} from '@angular/material/checkbox';
 import {
@@ -24,7 +24,7 @@ import {
 } from '@angular/material/dialog';
 import {MatIconModule} from '@angular/material/icon';
 import {BrowserAnimationsModule} from '@angular/platform-browser/animations';
-import {assertDefined} from 'common/assert_utils';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
 import {
   WarningDialogComponent,
   WarningDialogData,
@@ -32,9 +32,8 @@ import {
 } from './warning_dialog_component';
 
 describe('WarningDialogComponent', () => {
-  let fixture: ComponentFixture<TestHostComponent>;
   let component: TestHostComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<TestHostComponent>;
 
   beforeEach(async () => {
     await TestBed.configureTestingModule({
@@ -47,49 +46,36 @@ describe('WarningDialogComponent', () => {
       ],
       declarations: [TestHostComponent, WarningDialogComponent],
     }).compileComponents();
-    fixture = TestBed.createComponent(TestHostComponent);
+    const fixture = TestBed.createComponent(TestHostComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
-    fixture.detectChanges();
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
+    dom.detectChanges();
   });
 
   it('can be created', () => {
-    expect(document.querySelector('warning-dialog')).toBeNull();
+    expect(dom.findInDocument('warning-dialog')).toBeUndefined();
     openAndReturnDialog();
   });
 
   it('renders warning message, action boxes and buttons', () => {
     const dialog = openAndReturnDialog();
 
-    const content = assertDefined(dialog.querySelector('.warning-content'));
-    expect(content.querySelector('.warning-message')?.textContent).toContain(
-      'test message',
-    );
-
-    const actionBoxContainer = assertDefined(
-      content.querySelector('.warning-action-boxes'),
-    );
-    expect(actionBoxContainer.textContent).toContain('option1');
-    expect(actionBoxContainer.textContent).toContain('option2');
-
-    const actionButtonContainer = assertDefined(
-      content.querySelector('.warning-action-buttons'),
-    );
-    expect(actionButtonContainer.textContent).toContain('action1');
-    expect(actionButtonContainer.textContent).toContain('action2');
-    expect(actionButtonContainer.textContent).toContain('close message');
+    const content = dialog.get('.warning-content');
+    content.get('.warning-message').checkText('test message');
+
+    const actionBoxContainer = content.get('.warning-action-boxes');
+    actionBoxContainer.checkText('option1');
+    actionBoxContainer.checkText('option2');
+
+    const actionButtonContainer = content.get('.warning-action-buttons');
+    actionButtonContainer.checkText('action1');
+    actionButtonContainer.checkText('action2');
+    actionButtonContainer.checkText('close message');
   });
 
   it('provides action text and selected options as dialog result on close', async () => {
     const dialog = openAndReturnDialog();
-
-    const actionButton = assertDefined(
-      dialog.querySelector('.warning-action-buttons button'),
-    ) as HTMLElement;
-    actionButton.click();
-    fixture.detectChanges();
-    await fixture.whenStable();
-
+    await dialog.clickAndWaitStable('.warning-action-buttons button');
     expect(component.dialogResult).toEqual({
       closeActionText: 'action1',
       selectedOptions: [],
@@ -98,49 +84,46 @@ describe('WarningDialogComponent', () => {
 
   it('provides close text and selected options as dialog result on close', async () => {
     const dialog = openAndReturnDialog();
-
-    const buttons = assertDefined(
-      dialog.querySelectorAll('.warning-action-buttons button'),
-    );
-    (buttons.item(buttons.length - 1) as HTMLElement).click();
-    fixture.detectChanges();
-    await fixture.whenStable();
-
+    await dialog.clickLastAndWaitStable('.warning-action-buttons button');
     expect(component.dialogResult).toEqual({
       closeActionText: 'close message',
       selectedOptions: [],
     });
   });
 
-  it('updates selected options and provides selected options in dialog result', async () => {
-    const dialog = openAndReturnDialog();
+  it('deselects options', async () => {
+    await checkSelection([], [0, 0]);
+  });
 
-    const option = assertDefined(
-      dialog.querySelector('.warning-action-boxes mat-checkbox input'),
-    ) as HTMLInputElement;
-    option.checked = true;
-    option.click();
-    fixture.detectChanges();
+  it('updates selected options with multiple selection', async () => {
+    await checkSelection(['option1', 'option2']);
+  });
+
+  it('updates selected options with only single selection', async () => {
+    component.singleSelection = true;
+    await checkSelection(['option2']);
+  });
 
-    const buttons = assertDefined(
-      dialog.querySelectorAll('.warning-action-buttons button'),
-    );
-    (buttons.item(buttons.length - 1) as HTMLElement).click();
-    fixture.detectChanges();
-    await fixture.whenStable();
+  function openAndReturnDialog(): DOMTestHelper<TestHostComponent> {
+    dom.findAndClick('button');
+    return dom.getInDocument('warning-dialog');
+  }
 
+  async function checkSelection(
+    expectedOptions: string[],
+    optionsToSelect = [0, 1],
+  ) {
+    const dialog = openAndReturnDialog();
+    const options = dialog.findAll('.warning-action-boxes mat-checkbox');
+    for (const i of optionsToSelect) {
+      options[i].dispatchEvent(new Event('change'));
+      await dom.whenStable();
+    }
+    await dialog.clickLastAndWaitStable('.warning-action-buttons button');
     expect(component.dialogResult).toEqual({
       closeActionText: 'close message',
-      selectedOptions: ['option1'],
+      selectedOptions: expectedOptions,
     });
-  });
-
-  function openAndReturnDialog(): HTMLElement {
-    htmlElement.querySelector('button')?.click();
-    fixture.detectChanges();
-    return assertDefined(
-      document.querySelector('warning-dialog'),
-    ) as HTMLElement;
   }
 
   @Component({
@@ -152,6 +135,7 @@ describe('WarningDialogComponent', () => {
   class TestHostComponent {
     dialogRef: MatDialogRef<WarningDialogComponent> | undefined;
     dialogResult: WarningDialogResult | undefined;
+    singleSelection: boolean | undefined;
 
     constructor(@Inject(MatDialog) public dialog: MatDialog) {}
 
@@ -161,6 +145,7 @@ describe('WarningDialogComponent', () => {
         actions: ['action1', 'action2'],
         options: ['option1', 'option2'],
         closeText: 'close message',
+        singleSelection: this.singleSelection,
       };
       this.dialogRef = this.dialog.open(WarningDialogComponent, {data});
       this.dialogRef
diff --git a/tools/winscope/src/app/components/wdp_setup_component_test.ts b/tools/winscope/src/app/components/wdp_setup_component_test.ts
index 46bfff76e..11a72399c 100644
--- a/tools/winscope/src/app/components/wdp_setup_component_test.ts
+++ b/tools/winscope/src/app/components/wdp_setup_component_test.ts
@@ -15,18 +15,18 @@
  */
 import {CommonModule} from '@angular/common';
 import {NO_ERRORS_SCHEMA} from '@angular/core';
-import {ComponentFixture, TestBed} from '@angular/core/testing';
+import {TestBed} from '@angular/core/testing';
 import {MatButtonModule} from '@angular/material/button';
 import {MatIconModule} from '@angular/material/icon';
 import {BrowserAnimationsModule} from '@angular/platform-browser/animations';
 import {assertDefined} from 'common/assert_utils';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
 import {ConnectionState} from 'trace_collection/connection_state';
 import {WdpSetupComponent} from './wdp_setup_component';
 
 describe('WdpSetupComponent', () => {
-  let fixture: ComponentFixture<WdpSetupComponent>;
   let component: WdpSetupComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<WdpSetupComponent>;
 
   beforeEach(async () => {
     await TestBed.configureTestingModule({
@@ -39,9 +39,9 @@ describe('WdpSetupComponent', () => {
       declarations: [WdpSetupComponent],
       schemas: [NO_ERRORS_SCHEMA],
     }).compileComponents();
-    fixture = TestBed.createComponent(WdpSetupComponent);
+    const fixture = TestBed.createComponent(WdpSetupComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
     component.state = ConnectionState.CONNECTING;
   });
 
@@ -50,31 +50,24 @@ describe('WdpSetupComponent', () => {
   });
 
   it('correct connecting message', () => {
-    fixture.detectChanges();
-    expect(
-      htmlElement.querySelector('.connecting-message')?.textContent,
-    ).toContain('Connecting...');
-    expect(htmlElement.querySelector('.retry')).toBeNull();
-    expect(htmlElement.querySelector('.install')).toBeNull();
+    dom.detectChanges();
+    dom.get('.connecting-message').checkText('Connecting...');
+    expect(dom.find('.retry')).toBeUndefined();
+    expect(dom.find('.install')).toBeUndefined();
   });
 
   it('correct icon and message displays if no proxy', () => {
     component.state = ConnectionState.NOT_FOUND;
-    fixture.detectChanges();
-    const text = htmlElement.querySelector(
-      '.further-adb-info-text',
-    )?.textContent;
-    expect(text).toContain(
+    dom.detectChanges();
+    const text = dom.get('.further-adb-info-text');
+    text.checkText(
       "Failed to connect. Web Device Proxy doesn't seem to be running.",
     );
-    expect(text).toContain('Please check you have Web Device Proxy installed.');
+    text.checkText('Please check you have Web Device Proxy installed.');
     checkRetryButton();
 
     const windowSpy = spyOn(window, 'open');
-    assertDefined(
-      htmlElement.querySelector<HTMLButtonElement>('.install'),
-    ).click();
-    fixture.detectChanges();
+    dom.findAndClick('.install');
     expect(windowSpy).toHaveBeenCalledOnceWith(
       'https://tools.google.com/dlpage/android_web_device_proxy',
       '_blank',
@@ -83,21 +76,20 @@ describe('WdpSetupComponent', () => {
 
   it('correct icon and message displays if unauthorized proxy', () => {
     component.state = ConnectionState.UNAUTH;
-    fixture.detectChanges();
-    expect(htmlElement.querySelector('.adb-info')?.textContent).toEqual(
-      'Web Device Proxy not yet authorized. Enable popups and try again.',
-    );
-    expect(htmlElement.querySelector('.adb-icon')?.textContent).toEqual('lock');
+    dom.detectChanges();
+    dom
+      .get('.adb-info')
+      .checkTextExact(
+        'Web Device Proxy not yet authorized. Enable popups and try again.',
+      );
+    dom.get('.adb-icon').checkTextExact('lock');
     checkRetryButton();
-    expect(htmlElement.querySelector('.install')).toBeNull();
+    expect(dom.find('.install')).toBeUndefined();
   });
 
   function checkRetryButton() {
     const spy = spyOn(assertDefined(component.retryConnection), 'emit');
-    assertDefined(
-      htmlElement.querySelector<HTMLButtonElement>('.retry'),
-    ).click();
-    fixture.detectChanges();
+    dom.findAndClick('.retry');
     expect(spy).toHaveBeenCalled();
   }
 });
diff --git a/tools/winscope/src/app/components/winscope_proxy_setup_component_test.ts b/tools/winscope/src/app/components/winscope_proxy_setup_component_test.ts
index 7a732e60e..a2932ed55 100644
--- a/tools/winscope/src/app/components/winscope_proxy_setup_component_test.ts
+++ b/tools/winscope/src/app/components/winscope_proxy_setup_component_test.ts
@@ -15,7 +15,7 @@
  */
 import {CommonModule} from '@angular/common';
 import {NO_ERRORS_SCHEMA} from '@angular/core';
-import {ComponentFixture, TestBed} from '@angular/core/testing';
+import {TestBed} from '@angular/core/testing';
 import {FormsModule} from '@angular/forms';
 import {MatButtonModule} from '@angular/material/button';
 import {MatFormFieldModule} from '@angular/material/form-field';
@@ -24,13 +24,13 @@ import {MatInputModule} from '@angular/material/input';
 import {BrowserAnimationsModule} from '@angular/platform-browser/animations';
 import {assertDefined} from 'common/assert_utils';
 import {Download} from 'common/download';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
 import {ConnectionState} from 'trace_collection/connection_state';
 import {WinscopeProxySetupComponent} from './winscope_proxy_setup_component';
 
 describe('WinscopeProxySetupComponent', () => {
-  let fixture: ComponentFixture<WinscopeProxySetupComponent>;
   let component: WinscopeProxySetupComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<WinscopeProxySetupComponent>;
 
   beforeEach(async () => {
     await TestBed.configureTestingModule({
@@ -46,9 +46,9 @@ describe('WinscopeProxySetupComponent', () => {
       declarations: [WinscopeProxySetupComponent],
       schemas: [NO_ERRORS_SCHEMA],
     }).compileComponents();
-    fixture = TestBed.createComponent(WinscopeProxySetupComponent);
+    const fixture = TestBed.createComponent(WinscopeProxySetupComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
     component.state = ConnectionState.CONNECTING;
   });
 
@@ -57,51 +57,41 @@ describe('WinscopeProxySetupComponent', () => {
   });
 
   it('correct connecting message', () => {
-    fixture.detectChanges();
-    expect(
-      htmlElement.querySelector('.connecting-message')?.textContent,
-    ).toContain('Connecting...');
+    dom.detectChanges();
+    dom.get('.connecting-message').checkText('Connecting...');
   });
 
   it('correct icon and message displays if no proxy', () => {
     component.state = ConnectionState.NOT_FOUND;
-    fixture.detectChanges();
-    expect(
-      htmlElement.querySelector('.further-adb-info-text')?.textContent,
-    ).toContain('Launch the Winscope ADB Connect proxy');
+    dom.detectChanges();
+    dom
+      .get('.further-adb-info-text')
+      .checkText('Launch the Winscope ADB Connect proxy');
   });
 
   it('correct icon and message displays if invalid proxy', () => {
     component.state = ConnectionState.INVALID_VERSION;
-    fixture.detectChanges();
-    expect(
-      htmlElement.querySelector('.further-adb-info-text')?.textContent,
-    ).toContain(
-      `Your local proxy version is incompatible with Winscope. Please update the proxy to version ${component.proxyVersion}.`,
-    );
-    expect(htmlElement.querySelector('.adb-icon')?.textContent).toEqual(
-      'update',
-    );
+    dom.detectChanges();
+    dom
+      .get('.further-adb-info-text')
+      .checkText(
+        `Your local proxy version is incompatible with Winscope. Please update the proxy to version ${component.proxyVersion}.`,
+      );
+    dom.get('.adb-icon').checkTextExact('update');
   });
 
   it('correct icon and message displays if unauthorized proxy', () => {
     component.state = ConnectionState.UNAUTH;
-    fixture.detectChanges();
-    expect(htmlElement.querySelector('.adb-info')?.textContent).toEqual(
-      'Proxy authorization required.',
-    );
-    expect(htmlElement.querySelector('.adb-icon')?.textContent).toEqual('lock');
+    dom.detectChanges();
+    dom.get('.adb-info').checkText('Proxy authorization required.');
+    dom.get('.adb-icon').checkTextExact('lock');
   });
 
   it('download proxy button downloads proxy', () => {
     component.state = ConnectionState.NOT_FOUND;
-    fixture.detectChanges();
+    dom.detectChanges();
     const spy = spyOn(Download, 'fromUrl');
-    const button = assertDefined(
-      htmlElement.querySelector<HTMLButtonElement>('.download-proxy-btn'),
-    );
-    button.click();
-    fixture.detectChanges();
+    dom.findAndClick('.download-proxy-btn');
     expect(spy).toHaveBeenCalledWith(
       component.downloadProxyUrl,
       'winscope_proxy.py',
@@ -110,63 +100,37 @@ describe('WinscopeProxySetupComponent', () => {
 
   it('retry button emits event', () => {
     component.state = ConnectionState.NOT_FOUND;
-    fixture.detectChanges();
+    dom.detectChanges();
 
     const spy = spyOn(assertDefined(component.retryConnection), 'emit');
-    const button = assertDefined(
-      htmlElement.querySelector<HTMLButtonElement>('.retry'),
-    );
-    button.click();
-    fixture.detectChanges();
+    dom.findAndClick('.retry');
     expect(spy).toHaveBeenCalledWith('');
   });
 
   it('input proxy token saved as expected', () => {
     const spy = spyOn(assertDefined(component.retryConnection), 'emit');
     component.state = ConnectionState.UNAUTH;
-    fixture.detectChanges();
+    dom.detectChanges();
 
-    const button = assertDefined(
-      htmlElement.querySelector<HTMLButtonElement>('.retry'),
-    );
-    button.click();
-    fixture.detectChanges();
+    dom.findAndClick('.retry');
     expect(spy).not.toHaveBeenCalled();
 
-    const proxyTokenInput = assertDefined(
-      htmlElement.querySelector<HTMLInputElement>(
-        '.proxy-token-input-field input',
-      ),
-    );
-    proxyTokenInput.value = '12345';
-    proxyTokenInput.dispatchEvent(new Event('input'));
-    fixture.detectChanges();
-
-    assertDefined(
-      htmlElement.querySelector<HTMLButtonElement>('.retry'),
-    ).click();
-    fixture.detectChanges();
+    dom.findAndDispatchInput('.proxy-token-input-field', '12345');
+    expect(spy).not.toHaveBeenCalled();
+
+    dom.findAndClick('.retry');
     expect(spy).toHaveBeenCalledWith('12345');
   });
 
   it('emits event on enter key', () => {
     const spy = spyOn(assertDefined(component.retryConnection), 'emit');
     component.state = ConnectionState.UNAUTH;
-    fixture.detectChanges();
+    dom.detectChanges();
 
-    const proxyTokenInputField = assertDefined(
-      htmlElement.querySelector('.proxy-token-input-field'),
-    );
-    const proxyTokenInput = assertDefined(
-      proxyTokenInputField.querySelector<HTMLInputElement>('input'),
-    );
+    dom.findAndDispatchInput('.proxy-token-input-field', '12345');
+    expect(spy).not.toHaveBeenCalled();
 
-    proxyTokenInput.value = '12345';
-    proxyTokenInput.dispatchEvent(new Event('input'));
-    proxyTokenInputField.dispatchEvent(
-      new KeyboardEvent('keydown', {key: 'Enter'}),
-    );
-    fixture.detectChanges();
+    dom.get('.proxy-token-input-field').keydownEnter();
     expect(spy).toHaveBeenCalledWith('12345');
   });
 });
diff --git a/tools/winscope/src/app/files_source.ts b/tools/winscope/src/app/files_source.ts
index a21249364..557df42a3 100644
--- a/tools/winscope/src/app/files_source.ts
+++ b/tools/winscope/src/app/files_source.ts
@@ -19,4 +19,5 @@ export enum FilesSource {
   COLLECTED = 'collected_traces',
   UPLOADED = 'uploaded_traces',
   REMOTE_TOOL = 'remote',
+  APP = 'app',
 }
diff --git a/tools/winscope/src/app/loaded_parsers.ts b/tools/winscope/src/app/loaded_parsers.ts
index 4b2cdc958..1ee40ff66 100644
--- a/tools/winscope/src/app/loaded_parsers.ts
+++ b/tools/winscope/src/app/loaded_parsers.ts
@@ -23,6 +23,10 @@ import {UserNotifier} from 'common/user_notifier';
 import {TraceHasOldData, TraceOverridden} from 'messaging/user_warnings';
 import {FileAndParser} from 'parsers/file_and_parser';
 import {FileAndParsers} from 'parsers/file_and_parsers';
+import {
+  getParserWithLatestRealToBootTimeOffset,
+  getParserWithLatestRealToMonotonicTimeOffset,
+} from 'parsers/parser_time_utils';
 import {Parser} from 'trace/parser';
 import {TraceFile} from 'trace/trace_file';
 import {TRACE_INFO} from 'trace/trace_info';
@@ -73,6 +77,10 @@ export class LoadedParsers {
     return fileAndParsers.map((fileAndParser) => fileAndParser.parser);
   }
 
+  getPerfettoFile(): TraceFile | undefined {
+    return this.perfettoParsers.at(0)?.file;
+  }
+
   remove<T extends TraceType>(
     parser: Parser<TraceEntryTypeMap[T]>,
     keepForDownload = false,
@@ -153,7 +161,7 @@ export class LoadedParsers {
     };
 
     const tryPushOutPerfettoFile = (parsers: FileAndParser[]) => {
-      const file: TraceFile = parsers.values().next().value.file;
+      const file = parsers[0].file;
       let outputFilename = FileUtils.removeDirFromFileName(file.file.name);
       if (FileUtils.getFileExtension(file.file.name) === undefined) {
         outputFilename += '.perfetto-trace';
@@ -211,36 +219,6 @@ export class LoadedParsers {
     );
   }
 
-  getLatestRealToMonotonicOffset(
-    parsers: Array<Parser<object>>,
-  ): bigint | undefined {
-    const p = parsers
-      .filter((offset) => offset.getRealToMonotonicTimeOffsetNs() !== undefined)
-      .sort((a, b) => {
-        return Number(
-          (a.getRealToMonotonicTimeOffsetNs() ?? 0n) -
-            (b.getRealToMonotonicTimeOffsetNs() ?? 0n),
-        );
-      })
-      .at(-1);
-    return p?.getRealToMonotonicTimeOffsetNs();
-  }
-
-  getLatestRealToBootTimeOffset(
-    parsers: Array<Parser<object>>,
-  ): bigint | undefined {
-    const p = parsers
-      .filter((offset) => offset.getRealToBootTimeOffsetNs() !== undefined)
-      .sort((a, b) => {
-        return Number(
-          (a.getRealToBootTimeOffsetNs() ?? 0n) -
-            (b.getRealToBootTimeOffsetNs() ?? 0n),
-        );
-      })
-      .at(-1);
-    return p?.getRealToBootTimeOffsetNs();
-  }
-
   private addLegacyParsers(parsers: FileAndParser[]) {
     const legacyParsersBeingLoaded = new Map<TraceType, Parser<object>>();
 
@@ -265,14 +243,7 @@ export class LoadedParsers {
       // dangling in the disk that get automatically included into bugreports. Hence, Perfetto
       // parsers must always override legacy ones so that dangling legacy files are ignored.
       this.legacyParsers = this.legacyParsers.filter((fileAndParser) => {
-        const isOverriddenByPerfettoParser =
-          fileAndParser.parser.getTraceType() === parser.getTraceType();
-        if (isOverriddenByPerfettoParser) {
-          UserNotifier.add(
-            new TraceOverridden(fileAndParser.parser.getDescriptors().join()),
-          );
-        }
-        return !isOverriddenByPerfettoParser;
+        return fileAndParser.parser.getTraceType() !== parser.getTraceType();
       });
     });
   }
@@ -281,16 +252,10 @@ export class LoadedParsers {
     // While transitioning to the Perfetto format, devices might still have old legacy trace files
     // dangling in the disk that get automatically included into bugreports. Hence, Perfetto parsers
     // must always override legacy ones so that dangling legacy files are ignored.
-    const isOverriddenByPerfettoParser = this.perfettoParsers.some(
+    return !this.perfettoParsers.some(
       (fileAndParser) =>
         fileAndParser.parser.getTraceType() === newParser.getTraceType(),
     );
-    if (isOverriddenByPerfettoParser) {
-      UserNotifier.add(new TraceOverridden(newParser.getDescriptors().join()));
-      return false;
-    }
-
-    return true;
   }
 
   private filterOutLegacyParsersWithOldData(
@@ -302,12 +267,12 @@ export class LoadedParsers {
       ...this.perfettoParsers.values(),
     ];
 
-    const latestMonotonicOffset = this.getLatestRealToMonotonicOffset(
+    const latestMonotonicOffset = getParserWithLatestRealToMonotonicTimeOffset(
       allParsers.map(({parser, file}) => parser),
-    );
-    const latestBootTimeOffset = this.getLatestRealToBootTimeOffset(
+    )?.getRealToMonotonicTimeOffsetNs();
+    const latestBootTimeOffset = getParserWithLatestRealToBootTimeOffset(
       allParsers.map(({parser, file}) => parser),
-    );
+    )?.getRealToBootTimeOffsetNs();
 
     newLegacyParsers = newLegacyParsers.filter(({parser, file}) => {
       const monotonicOffset = parser.getRealToMonotonicTimeOffsetNs();
diff --git a/tools/winscope/src/app/loaded_parsers_test.ts b/tools/winscope/src/app/loaded_parsers_test.ts
index c64a66805..8f596da8a 100644
--- a/tools/winscope/src/app/loaded_parsers_test.ts
+++ b/tools/winscope/src/app/loaded_parsers_test.ts
@@ -54,53 +54,51 @@ describe('LoadedParsers', () => {
     TimestampConverterUtils.makeRealTimestamp(5n * 60n * 1000000000n + 12n), // 5m12ns
   ];
 
-  const filename = 'filename';
-
   const parserSf0 = new ParserBuilder<object>()
     .setType(TraceType.SURFACE_FLINGER)
     .setTimestamps(timestamps)
-    .setDescriptors([filename])
+    .setDescriptors(['sf0'])
     .build();
   const parserSf1 = new ParserBuilder<object>()
     .setType(TraceType.SURFACE_FLINGER)
     .setTimestamps(timestamps)
-    .setDescriptors([filename])
+    .setDescriptors(['sf1'])
     .build();
   const parserSf_longButOldData = new ParserBuilder<object>()
     .setType(TraceType.SURFACE_FLINGER)
     .setTimestamps(oldTimestamps)
-    .setDescriptors([filename])
+    .setDescriptors(['sf old'])
     .build();
   const parserSf_empty = new ParserBuilder<object>()
     .setType(TraceType.SURFACE_FLINGER)
     .setTimestamps([])
-    .setDescriptors([filename])
+    .setDescriptors(['sf empty'])
     .build();
   const parserSf_elapsed = new ParserBuilder<object>()
     .setType(TraceType.SURFACE_FLINGER)
     .setTimestamps(elapsedTimestamps)
-    .setDescriptors([filename])
+    .setDescriptors(['sf elapsed'])
     .setNoOffsets(true)
     .build();
   const parserWm0 = new ParserBuilder<object>()
     .setType(TraceType.WINDOW_MANAGER)
     .setTimestamps(timestamps)
-    .setDescriptors([filename])
+    .setDescriptors(['wm0'])
     .build();
   const parserWm1 = new ParserBuilder<object>()
     .setType(TraceType.WINDOW_MANAGER)
     .setTimestamps(timestamps)
-    .setDescriptors([filename])
+    .setDescriptors(['wm1'])
     .build();
   const parserWm_dump = new ParserBuilder<object>()
     .setType(TraceType.WINDOW_MANAGER)
     .setTimestamps([realZeroTimestamp])
-    .setDescriptors([filename])
+    .setDescriptors(['wm dump'])
     .build();
   const parserWm_elapsed = new ParserBuilder<object>()
     .setType(TraceType.WINDOW_MANAGER)
     .setTimestamps(elapsedTimestamps)
-    .setDescriptors([filename])
+    .setDescriptors(['wm elapsed'])
     .setNoOffsets(true)
     .build();
   const parserWmTransitions = new ParserBuilder<object>()
@@ -110,29 +108,30 @@ describe('LoadedParsers', () => {
       elapsedZeroTimestamp,
       elapsedZeroTimestamp,
     ])
-    .setDescriptors([filename])
+    .setDescriptors(['wm transitions'])
     .build();
   const parserEventlog = new ParserBuilder<object>()
     .setType(TraceType.EVENT_LOG)
     .setTimestamps(timestamps)
-    .setDescriptors([filename])
+    .setDescriptors(['eventlog'])
     .setNoOffsets(true)
     .build();
   const parserScreenRecording = new ParserBuilder<object>()
     .setType(TraceType.SCREEN_RECORDING)
     .setTimestamps(timestamps)
-    .setDescriptors([filename])
+    .setDescriptors(['screen recording'])
     .build();
   const parserViewCapture0 = new ParserBuilder<object>()
     .setType(TraceType.VIEW_CAPTURE)
     .setEntries([])
-    .setDescriptors([filename])
+    .setDescriptors(['vc0'])
     .build();
   const parserViewCapture1 = new ParserBuilder<object>()
     .setType(TraceType.VIEW_CAPTURE)
     .setEntries([])
-    .setDescriptors([filename])
+    .setDescriptors(['vc1'])
     .build();
+  const perfettoFilename = 'perfetto trace';
 
   let loadedParsers: LoadedParsers;
   let userNotifierChecker: UserNotifierChecker;
@@ -180,7 +179,7 @@ describe('LoadedParsers', () => {
 
   it('drops elapsed-only parsers if parsers with real timestamps present', () => {
     loadParsers([parserSf_elapsed, parserSf0], []);
-    expectLoadResult([parserSf0], [new TraceHasOldData(filename)]);
+    expectLoadResult([parserSf0], [new TraceHasOldData('sf elapsed')]);
   });
 
   it('doesnt drop elapsed-only parsers if no parsers with real timestamps present', () => {
@@ -202,12 +201,12 @@ describe('LoadedParsers', () => {
 
     it('taking into account other legacy parsers', () => {
       loadParsers([parserSf_longButOldData, parserWm0], []);
-      expectLoadResult([parserWm0], [new TraceHasOldData(filename, timeGap)]);
+      expectLoadResult([parserWm0], [new TraceHasOldData('sf old', timeGap)]);
     });
 
     it('taking into account perfetto parsers', () => {
       loadParsers([parserSf_longButOldData], [parserWm0]);
-      expectLoadResult([parserWm0], [new TraceHasOldData(filename, timeGap)]);
+      expectLoadResult([parserWm0], [new TraceHasOldData('sf old', timeGap)]);
     });
 
     it('taking into account already-loaded parsers', () => {
@@ -216,7 +215,7 @@ describe('LoadedParsers', () => {
       // Drop parser with old data, even if it provides
       // a longer trace than the already-loaded parser
       loadParsers([parserSf_longButOldData], []);
-      expectLoadResult([parserWm0], [new TraceHasOldData(filename, timeGap)]);
+      expectLoadResult([parserWm0], [new TraceHasOldData('sf old', timeGap)]);
     });
 
     it('doesnt drop legacy parser with dump (zero timestamp)', () => {
@@ -234,6 +233,7 @@ describe('LoadedParsers', () => {
     it('is robust to traces with time range overlap', () => {
       const parser = parserSf0;
       const timestamps = assertDefined(parserSf0.getTimestamps());
+      const filename = 'overlapping';
 
       const timestampsOverlappingFront = [
         timestamps[0].add(-1n),
@@ -316,11 +316,11 @@ describe('LoadedParsers', () => {
 
     it('when a perfetto parser is already loaded', () => {
       loadParsers([parserSf0], [parserSf1]);
-      expectLoadResult([parserSf1], [new TraceOverridden(filename)]);
+      expectLoadResult([parserSf1], []);
       userNotifierChecker.reset();
 
       loadParsers([parserSf0], []);
-      expectLoadResult([parserSf1], [new TraceOverridden(filename)]);
+      expectLoadResult([parserSf1], []);
     });
 
     it('when a perfetto parser is loaded afterwards', () => {
@@ -328,7 +328,7 @@ describe('LoadedParsers', () => {
       expectLoadResult([parserSf0], []);
 
       loadParsers([], [parserSf1]);
-      expectLoadResult([parserSf1], [new TraceOverridden(filename)]);
+      expectLoadResult([parserSf1], []);
     });
   });
 
@@ -340,10 +340,7 @@ describe('LoadedParsers', () => {
 
     it('legacy + perfetto parsers', () => {
       loadParsers([parserSf0, parserSf0], [parserSf1]);
-      expectLoadResult(
-        [parserSf1],
-        [new TraceOverridden(filename), new TraceOverridden(filename)],
-      );
+      expectLoadResult([parserSf1], []);
     });
   });
 
@@ -438,10 +435,7 @@ describe('LoadedParsers', () => {
     loadedParsers.remove(parserWm0, true);
     expectLoadResult([parserSf0], []);
 
-    await expectDownloadResult([
-      'sf/filename.winscope',
-      'wm/filename.winscope',
-    ]);
+    await expectDownloadResult(['sf/sf0.winscope', 'wm/wm0.winscope']);
   });
 
   it('can be cleared', async () => {
@@ -454,13 +448,11 @@ describe('LoadedParsers', () => {
 
     loadParsers([parserSf0, parserWm0], []);
     expectLoadResult([parserSf0, parserWm0], []);
-    await expectDownloadResult([
-      'sf/filename.winscope',
-      'wm/filename.winscope',
-    ]);
+    await expectDownloadResult(['sf/sf0.winscope', 'wm/wm0.winscope']);
   });
 
   it('can make zip archive of traces with appropriate directories and extensions', async () => {
+    const filename = 'filename';
     const fileDuplicated = new File([], filename);
 
     const legacyFiles = [
@@ -508,7 +500,7 @@ describe('LoadedParsers', () => {
 
     await expectDownloadResult([
       'filename.mp4',
-      'filename.perfetto-trace',
+      'perfetto trace.perfetto-trace',
       'vc/filename.winscope',
       'wm/filename (1).pb',
       'wm/filename.pb',
@@ -536,11 +528,13 @@ describe('LoadedParsers', () => {
     legacyFiles?: File[],
   ) {
     const legacyFileAndParsers = legacy.map((parser, i) => {
-      const legacyFile = legacyFiles ? legacyFiles[i] : new File([], filename);
+      const legacyFile = legacyFiles
+        ? legacyFiles[i]
+        : new File([], parser.getDescriptors()[0]);
       return new FileAndParser(new TraceFile(legacyFile), parser);
     });
 
-    const perfettoTraceFile = new TraceFile(new File([], filename));
+    const perfettoTraceFile = new TraceFile(new File([], perfettoFilename));
     const perfettoFileAndParsers =
       perfetto.length > 0
         ? new FileAndParsers(perfettoTraceFile, perfetto)
diff --git a/tools/winscope/src/app/mediator.ts b/tools/winscope/src/app/mediator.ts
index b88ab4dfe..4d6801d8c 100644
--- a/tools/winscope/src/app/mediator.ts
+++ b/tools/winscope/src/app/mediator.ts
@@ -35,6 +35,7 @@ import {
   AppTraceViewRequest,
   AppTraceViewRequestHandled,
   ExpandedTimelineToggled,
+  ShowTraceUploadWarning,
   TraceAddRequest,
   TracePositionUpdate,
   TraceSearchCompleted,
@@ -95,6 +96,10 @@ export class Mediator {
     this.appComponent = appComponent;
     this.storage = storage;
 
+    this.tracePipeline.setEmitEvent(async (event) => {
+      await this.onWinscopeEvent(event);
+    });
+
     this.crossToolProtocol.setEmitEvent(async (event) => {
       await this.onWinscopeEvent(event);
     });
@@ -147,6 +152,7 @@ export class Mediator {
     await event.visit(WinscopeEventType.APP_FILES_UPLOADED, async (event) => {
       this.currentProgressListener = this.uploadTracesComponent;
       await this.loadFiles(event.files, FilesSource.UPLOADED);
+
       UserNotifier.notify();
     });
 
@@ -170,7 +176,7 @@ export class Mediator {
           await this.uploadTracesComponent?.onWinscopeEvent(
             new AppTraceViewRequest(),
           );
-          await this.loadViewers(FilesSource.COLLECTED);
+          await this.loadViewers(FilesSource.COLLECTED, false);
           await this.uploadTracesComponent?.onWinscopeEvent(
             new AppTraceViewRequestHandled(),
           );
@@ -196,10 +202,13 @@ export class Mediator {
       },
     );
 
-    await event.visit(WinscopeEventType.APP_TRACE_VIEW_REQUEST, async () => {
-      await this.loadViewers(FilesSource.UPLOADED);
-      UserNotifier.notify();
-    });
+    await event.visit(
+      WinscopeEventType.APP_TRACE_VIEW_REQUEST,
+      async (event) => {
+        await this.loadViewers(FilesSource.UPLOADED, event.discardLegacyTraces);
+        UserNotifier.notify();
+      },
+    );
 
     await event.visit(
       WinscopeEventType.REMOTE_TOOL_DOWNLOAD_START,
@@ -360,16 +369,36 @@ export class Mediator {
         await this.timelineComponent?.onWinscopeEvent(initializedEvent);
       },
     );
+
+    await event.visit(
+      WinscopeEventType.BUGREPORT_FILE_SELECTED,
+      async (event) => {
+        await this.tracePipeline.onWinscopeEvent(event);
+      },
+    );
+
+    await event.visit(
+      WinscopeEventType.BUGREPORT_FILE_SELECTION_REQUEST,
+      async (event) => {
+        await this.appComponent.onWinscopeEvent(event);
+      },
+    );
   }
 
   private async loadFiles(files: File[], source: FilesSource) {
     const startTimeMs = Date.now();
-    await this.tracePipeline.loadFiles(
+    const warnings = await this.tracePipeline.loadFiles(
       files,
       source,
       this.currentProgressListener,
     );
     Analytics.Loading.logLoadFilesTime(Date.now() - startTimeMs, source);
+
+    for (const warning of warnings) {
+      await this.uploadTracesComponent?.onWinscopeEvent(
+        new ShowTraceUploadWarning(warning.getMessage()),
+      );
+    }
   }
 
   private async propagateTracePosition(
@@ -490,16 +519,27 @@ export class Mediator {
     UserNotifier.notify();
   }
 
-  private async loadViewers(source: FilesSource) {
+  private async loadViewers(source: FilesSource, discardLegacyTraces: boolean) {
     const e2eStartTimeMs = Date.now();
+
+    if (discardLegacyTraces) {
+      this.tracePipeline.discardLegacyTraces();
+    } else {
+      this.currentProgressListener?.onProgressUpdate(
+        'Converting legacy traces to perfetto...',
+        undefined,
+      );
+      await TimeUtils.sleepMs(10); // allow the UI to update before making the main thread very busy
+      await this.tracePipeline.convertLegacyTracesToPerfetto();
+      this.currentProgressListener?.onOperationFinished(true);
+    }
+
     this.currentProgressListener?.onProgressUpdate(
       'Computing frame mapping...',
       undefined,
     );
 
-    // TODO: move this into the ProgressListener
-    // allow the UI to update before making the main thread very busy
-    await TimeUtils.sleepMs(10);
+    await TimeUtils.sleepMs(10); // allow the UI to update before making the main thread very busy
 
     this.tracePipeline.filterTracesWithoutVisualization();
     if (this.tracePipeline.getTraces().getSize() === 0) {
diff --git a/tools/winscope/src/app/mediator_test.ts b/tools/winscope/src/app/mediator_test.ts
index 759e64f37..43f4a0130 100644
--- a/tools/winscope/src/app/mediator_test.ts
+++ b/tools/winscope/src/app/mediator_test.ts
@@ -28,9 +28,9 @@ import {
   FailedToCreateTracesParser,
   IncompleteFrameMapping,
   InvalidLegacyTrace,
+  InvalidPerfettoTrace,
   NoTraceTargetsSelected,
   NoValidFiles,
-  UnsupportedFileFormat,
 } from 'messaging/user_warnings';
 import {
   ActiveTraceChanged,
@@ -41,6 +41,8 @@ import {
   AppResetRequest,
   AppTraceViewRequest,
   AppTraceViewRequestHandled,
+  BugreportFileSelected,
+  BugreportFileSelectionRequest,
   DarkModeToggled,
   ExpandedTimelineToggled,
   FilterPresetApplyRequest,
@@ -107,6 +109,7 @@ describe('Mediator', () => {
   let inputFiles: File[];
   let eventLogFile: File;
   let perfettoFile: File;
+  let wmDumpFile: File;
   let tracePipeline: TracePipeline;
   let timelineData: TimelineData;
   let abtChromeExtensionProtocol: WinscopeEventEmitter & WinscopeEventListener;
@@ -150,7 +153,12 @@ describe('Mediator', () => {
     perfettoFile = await getFixtureFile(
       'traces/perfetto/layers_trace.perfetto-trace',
     );
-    eventLogFile = await getFixtureFile('traces/eventlog_no_cujs.winscope');
+    eventLogFile = await getFixtureFile(
+      'traces/elapsed_and_real_timestamp/eventlog_no_cujs.winscope',
+    );
+    wmDumpFile = await getFixtureFile(
+      'traces/elapsed_timestamp/dump_WindowManager.pb',
+    );
     userNotifierChecker = new UserNotifierChecker();
   });
 
@@ -219,6 +227,9 @@ describe('Mediator', () => {
       spyOn(crossToolProtocol, 'onWinscopeEvent'),
       spyOn(timelineComponent, 'onWinscopeEvent'),
       spyOn(timelineData, 'initialize').and.callThrough(),
+      spyOn(tracePipeline, 'onWinscopeEvent'),
+      spyOn(tracePipeline, 'convertLegacyTracesToPerfetto'),
+      spyOn(tracePipeline, 'discardLegacyTraces'),
       spyOn(traceViewComponent, 'onWinscopeEvent'),
       spyOn(uploadTracesComponent, 'onWinscopeEvent'),
       spyOn(uploadTracesComponent, 'onProgressUpdate'),
@@ -254,6 +265,14 @@ describe('Mediator', () => {
     userNotifierChecker.expectNotified([]);
   });
 
+  it('handles uploaded traces discarding legacy traces with conversion option', async () => {
+    await mediator.onWinscopeEvent(new AppFilesUploaded(inputFiles));
+    resetSpyCalls();
+    await mediator.onWinscopeEvent(new AppTraceViewRequest(true));
+    checkLoadTraceViewEvents(uploadTracesComponent, undefined, undefined, true);
+    userNotifierChecker.expectNotified([]);
+  });
+
   it('handles collected traces from Winscope', async () => {
     await mediator.onWinscopeEvent(
       new AppFilesCollected({
@@ -270,12 +289,14 @@ describe('Mediator', () => {
     await mediator.onWinscopeEvent(
       new AppFilesCollected({
         requested: [],
-        collected: [await getFixtureFile('traces/empty.pb')],
+        collected: [await getFixtureFile('invalid_files/empty.pb')],
       }),
     );
     expect(
       userNotifierChecker.expectNotified([
-        new UnsupportedFileFormat('empty.pb'),
+        new InvalidPerfettoTrace('empty.pb', [
+          'Perfetto trace has no Winscope trace entries',
+        ]),
       ]),
     );
     expect(appComponent.onWinscopeEvent).not.toHaveBeenCalled();
@@ -286,7 +307,9 @@ describe('Mediator', () => {
       new AppFilesCollected({
         requested: [],
         collected: [
-          await getFixtureFile('traces/no_entries_InputMethodClients.pb'),
+          await getFixtureFile(
+            'invalid_files/no_entries_InputMethodClients.pb',
+          ),
         ],
       }),
     );
@@ -374,7 +397,7 @@ describe('Mediator', () => {
       await getFixtureFile(
         'traces/elapsed_and_real_timestamp/dump_SurfaceFlinger.pb',
       ),
-      await getFixtureFile('traces/dump_WindowManager.pb'),
+      wmDumpFile,
     ];
     await loadFiles(dumpFiles);
     await mediator.onWinscopeEvent(new AppTraceViewRequest());
@@ -484,8 +507,7 @@ describe('Mediator', () => {
   });
 
   it("initializes viewers' trace position also when loaded traces have no valid timestamps", async () => {
-    const dumpFile = await getFixtureFile('traces/dump_WindowManager.pb');
-    await mediator.onWinscopeEvent(new AppFilesUploaded([dumpFile]));
+    await mediator.onWinscopeEvent(new AppFilesUploaded([wmDumpFile]));
 
     resetSpyCalls();
     await mediator.onWinscopeEvent(new AppTraceViewRequest());
@@ -507,8 +529,7 @@ describe('Mediator', () => {
   it('warns user if frame mapping fails', async () => {
     const errorMsg = 'frame mapping failed';
     spyOn(tracePipeline, 'buildTraces').and.throwError(errorMsg);
-    const dumpFile = await getFixtureFile('traces/dump_WindowManager.pb');
-    await mediator.onWinscopeEvent(new AppFilesUploaded([dumpFile]));
+    await mediator.onWinscopeEvent(new AppFilesUploaded([wmDumpFile]));
 
     resetSpyCalls();
     await mediator.onWinscopeEvent(new AppTraceViewRequest());
@@ -806,17 +827,35 @@ describe('Mediator', () => {
     removeSearchTraceAndCheckPropagation(false);
   });
 
-  async function loadFiles(
-    files = inputFiles,
-    viewersToReassignTraces = [viewerStub0, viewerStub1],
-  ) {
+  it('handles BR file selection requests', async () => {
+    const request = new BugreportFileSelectionRequest(['f1']);
+    await mediator.onWinscopeEvent(request);
+    expect(appComponent.onWinscopeEvent).toHaveBeenCalledOnceWith(request);
+
+    const selection = new BugreportFileSelected('f1');
+    await mediator.onWinscopeEvent(selection);
+    expect(tracePipeline.onWinscopeEvent).toHaveBeenCalledOnceWith(selection);
+  });
+
+  it('sends warning banner event on file upload warning', async () => {
+    const bugreport = await getFixtureFile('bugreports/bugreport_no_trace.zip');
+    await mediator.onWinscopeEvent(new AppFilesUploaded([bugreport]));
+
+    expect(uploadTracesComponent.onWinscopeEvent).toHaveBeenCalledWith(
+      jasmine.objectContaining({
+        type: WinscopeEventType.SHOW_TRACE_UPLOAD_WARNING,
+        message: jasmine.stringMatching(
+          /^No Winscope Perfetto trace found in bug report/,
+        ),
+      }),
+    );
+  });
+
+  async function loadFiles(files = inputFiles) {
     for (const file of files) {
       await mediator.onWinscopeEvent(new AppFilesUploaded([file]));
     }
     userNotifierChecker.expectNone();
-    viewersToReassignTraces.forEach((viewer) =>
-      reassignViewerStubTrace(viewer),
-    );
   }
 
   function reassignViewerStubTrace(viewerStub: ViewerStub) {
@@ -826,12 +865,18 @@ describe('Mediator', () => {
       .getTrace(viewerStubTraces[0].type) as Trace<object>;
   }
 
-  async function loadTraceView(expectedViewers = viewers) {
+  async function loadTraceView(
+    expectedViewers = viewers,
+    viewersToReassignTraces = [viewerStub0, viewerStub1],
+  ) {
     // Simulate "View traces" button click
     resetSpyCalls();
     await mediator.onWinscopeEvent(new AppTraceViewRequest());
 
     checkLoadTraceViewEvents(uploadTracesComponent, expectedViewers);
+    viewersToReassignTraces.forEach((viewer) =>
+      reassignViewerStubTrace(viewer),
+    );
 
     // Simulate notification of TraceViewComponent about initially selected/focused tab
     resetSpyCalls();
@@ -850,9 +895,16 @@ describe('Mediator', () => {
     progressListener: ProgressListener,
     expectedViewers = viewers,
     notifications: UserWarning[] = [],
+    discardLegacyTraces = false,
   ) {
     expect(progressListener.onProgressUpdate).toHaveBeenCalled();
     expect(progressListener.onOperationFinished).toHaveBeenCalled();
+    expect(tracePipeline.discardLegacyTraces).toHaveBeenCalledTimes(
+      discardLegacyTraces ? 1 : 0,
+    );
+    expect(tracePipeline.convertLegacyTracesToPerfetto).toHaveBeenCalledTimes(
+      discardLegacyTraces ? 0 : 1,
+    );
     expect(timelineData.initialize).toHaveBeenCalledTimes(1);
     expect(appComponent.onWinscopeEvent).toHaveBeenCalledOnceWith(
       new ViewersLoaded(expectedViewers),
@@ -907,7 +959,7 @@ describe('Mediator', () => {
   }
 
   async function loadPerfettoFilesAndReturnSearchViewer(): Promise<ViewerStub> {
-    await loadFiles([perfettoFile], [viewerStub0]);
+    await loadFiles([perfettoFile]);
     const searchViewer = new ViewerStub(
       'search',
       undefined,
@@ -917,7 +969,7 @@ describe('Mediator', () => {
     spyOn(searchViewer, 'onWinscopeEvent');
     const expectedViewers = [viewerStub0, searchViewer];
     createViewersSpy.and.returnValue(expectedViewers);
-    await loadTraceView(expectedViewers);
+    await loadTraceView(expectedViewers, [viewerStub0]);
     resetSpyCalls();
     return searchViewer;
   }
diff --git a/tools/winscope/src/app/timeline_data.ts b/tools/winscope/src/app/timeline_data.ts
index 09710abd2..16dcf33bc 100644
--- a/tools/winscope/src/app/timeline_data.ts
+++ b/tools/winscope/src/app/timeline_data.ts
@@ -24,7 +24,7 @@ import {Traces} from 'trace/traces';
 import {TraceEntryFinder} from 'trace/trace_entry_finder';
 import {TracePosition} from 'trace/trace_position';
 import {TraceType, TraceTypeUtils} from 'trace/trace_type';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
+import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 
 export class TimelineData {
   private traces = new Traces();
@@ -41,7 +41,8 @@ export class TimelineData {
     TraceEntry<object> | undefined
   >();
   private activeTrace: Trace<object> | undefined;
-  private transitionEntries: Array<PropertyTreeNode | undefined> = []; // cached trace entries to avoid TP and object creation latencies each time transition timeline is redrawn
+  // cached trace entries to avoid TP and object creation latencies each time transition timeline is redrawn
+  private transitionEntries: Array<HierarchyTreeNode | undefined> = [];
   private timestampConverter: ComponentTimestampConverter | undefined;
 
   async initialize(
@@ -68,7 +69,7 @@ export class TimelineData {
       let someCorrupted = false;
       await Promise.all(
         transitionTrace.mapEntry(async (entry) => {
-          let transition: PropertyTreeNode | undefined;
+          let transition: HierarchyTreeNode | undefined;
           try {
             transition = await entry.getValue();
           } catch (e) {
@@ -100,7 +101,7 @@ export class TimelineData {
     }
   }
 
-  getTransitionEntries(): Array<PropertyTreeNode | undefined> {
+  getTransitionEntries(): Array<HierarchyTreeNode | undefined> {
     return this.transitionEntries;
   }
 
diff --git a/tools/winscope/src/app/timeline_data_test.ts b/tools/winscope/src/app/timeline_data_test.ts
index cd65292fc..23d6c7a99 100644
--- a/tools/winscope/src/app/timeline_data_test.ts
+++ b/tools/winscope/src/app/timeline_data_test.ts
@@ -22,8 +22,8 @@ import {ParserBuilder} from 'test/unit/parser_builder';
 import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
 import {TracesBuilder} from 'test/unit/traces_builder';
 import {TraceBuilder} from 'test/unit/trace_builder';
+import {makeEmptyTrace} from 'test/unit/trace_utils';
 import {UserNotifierChecker} from 'test/unit/user_notifier_checker';
-import {UnitTestUtils} from 'test/unit/utils';
 import {Traces} from 'trace/traces';
 import {TracePosition} from 'trace/trace_position';
 import {TraceType} from 'trace/trace_type';
@@ -225,7 +225,7 @@ describe('TimelineData', () => {
     expect(success).toBeFalse();
 
     success = timelineData.trySetActiveTrace(
-      UnitTestUtils.makeEmptyTrace(TraceType.SURFACE_FLINGER),
+      makeEmptyTrace(TraceType.SURFACE_FLINGER),
     );
     expect(timelineData.getActiveTrace()).toEqual(traceWm);
     expect(success).toBeFalse();
diff --git a/tools/winscope/src/app/trace_file_filter.ts b/tools/winscope/src/app/trace_file_filter.ts
index 82e69a161..9e3b990fb 100644
--- a/tools/winscope/src/app/trace_file_filter.ts
+++ b/tools/winscope/src/app/trace_file_filter.ts
@@ -15,24 +15,55 @@
  */
 
 import {assertDefined} from 'common/assert_utils';
-import {byteArrayToString} from 'common/buffer_utils';
 import {FileUtils} from 'common/file_utils';
+import {FunctionUtils} from 'common/function_utils';
+import {utf8Decode} from 'common/string_utils';
 import {TimezoneInfo} from 'common/time/time';
 import {UserNotifier} from 'common/user_notifier';
-import {TraceOverridden} from 'messaging/user_warnings';
+import {UserWarning} from 'messaging/user_warning';
+import {MissingPersistentTrace, TraceOverridden} from 'messaging/user_warnings';
+import {
+  BugreportFileSelectionRequest,
+  WinscopeEvent,
+  WinscopeEventType,
+} from 'messaging/winscope_event';
+import {
+  EmitEvent,
+  WinscopeEventEmitter,
+} from 'messaging/winscope_event_emitter';
+import {WinscopeEventListener} from 'messaging/winscope_event_listener';
 import {TraceFile} from 'trace/trace_file';
 import {TraceMetadata} from 'trace/trace_metadata';
 
+export enum BuildType {
+  USER = 'user',
+  USERDEBUG = 'userdebug',
+  ENG = 'eng',
+}
+
+export interface BugreportData {
+  timezoneInfo?: TimezoneInfo;
+  buildType?: BuildType;
+  isPersistentTracingEnabled: boolean;
+}
+
 export interface FilterResult {
   legacy: TraceFile[];
   metadata: TraceMetadata;
   perfetto?: TraceFile;
   timezoneInfo?: TimezoneInfo;
+  criticalWarnings?: UserWarning[];
 }
 
-export class TraceFileFilter {
-  private static readonly BUGREPORT_SYSTRACE_PATH =
-    'FS/data/misc/perfetto-traces/bugreport/systrace.pftrace';
+export class TraceFileFilter
+  implements WinscopeEventListener, WinscopeEventEmitter
+{
+  private static readonly BUGREPORT_PERFETTO_TRACE_DIR =
+    'FS/data/misc/perfetto-traces/bugreport';
+  private static readonly BUGREPORT_PERFETTO_TRACE_ORDER = [
+    TraceFileFilter.BUGREPORT_PERFETTO_TRACE_DIR + '/systrace.pftrace',
+    TraceFileFilter.BUGREPORT_PERFETTO_TRACE_DIR + '/sysui.pftrace',
+  ];
   private static readonly BUGREPORT_LEGACY_FILES_ALLOWLIST = [
     'FS/data/misc/wmtrace/',
     'FS/data/misc/perfetto-traces/',
@@ -46,6 +77,22 @@ export class TraceFileFilter {
     '.perfetto',
   ];
 
+  private emitEvent: EmitEvent = FunctionUtils.DO_NOTHING_ASYNC;
+  private selectedFile: string | undefined;
+
+  setEmitEvent(callback: EmitEvent) {
+    this.emitEvent = callback;
+  }
+
+  async onWinscopeEvent(event: WinscopeEvent) {
+    await event.visit(
+      WinscopeEventType.BUGREPORT_FILE_SELECTED,
+      async (event) => {
+        this.selectedFile = event.filename;
+      },
+    );
+  }
+
   async filter(files: TraceFile[]): Promise<FilterResult> {
     const bugreportMainEntry = files.find((file) =>
       file.file.name.endsWith('main_entry.txt'),
@@ -57,7 +104,12 @@ export class TraceFileFilter {
       (file) => !this.isPerfettoFile(file) && !mFiles.includes(file),
     );
 
-    if (!(await this.isBugreport(bugreportMainEntry, files))) {
+    const isBugReportArchive = await this.isBugreport(
+      bugreportMainEntry,
+      files,
+    );
+
+    if (!isBugReportArchive) {
       const perfettoFile = this.pickLargestFile(perfettoFiles);
       return {
         perfetto: perfettoFile,
@@ -66,7 +118,7 @@ export class TraceFileFilter {
       };
     }
 
-    const timezoneInfo = await this.processRawBugReport(
+    const bugreportData = await this.getBugreportData(
       assertDefined(bugreportMainEntry),
       files,
     );
@@ -76,33 +128,73 @@ export class TraceFileFilter {
       perfettoFiles,
       legacyFiles,
       metadata,
-      timezoneInfo,
+      bugreportData,
     );
   }
 
-  private async processRawBugReport(
+  private async getBugreportData(
     bugreportMainEntry: TraceFile,
     files: TraceFile[],
-  ): Promise<TimezoneInfo | undefined> {
+  ): Promise<BugreportData | undefined> {
     const bugreportName = (await bugreportMainEntry.file.text()).trim();
-    const rawBugReport = files.find((file) => file.file.name === bugreportName);
-    if (!rawBugReport) {
+    const mainBugreportFile = files.find(
+      (file) => file.file.name === bugreportName,
+    );
+    if (!mainBugreportFile) {
       return undefined;
     }
 
-    const traceBuffer = new Uint8Array(await rawBugReport.file.arrayBuffer());
-    const fileData = byteArrayToString(traceBuffer);
+    const traceBuffer = new Uint8Array(
+      await mainBugreportFile.file.arrayBuffer(),
+    );
+    const fileData = utf8Decode(traceBuffer);
 
-    const timezoneStartIndex = fileData.indexOf('[persist.sys.timezone]');
-    if (timezoneStartIndex === -1) {
-      return undefined;
-    }
-    const timezone = this.extractValueFromRawBugReport(
+    const timezone = this.extractBugreportProperty(
+      fileData,
+      'persist.sys.timezone',
+    );
+    const timezoneInfo = timezone ? {timezone, locale: 'en-US'} : undefined;
+    const buildTypeString = this.extractBugreportProperty(
+      fileData,
+      'ro.build.type',
+    );
+    const persistentTracingFlag = this.extractBugreportProperty(
       fileData,
-      timezoneStartIndex,
+      'persist.debug.perfetto.persistent_sysui_tracing_for_bugreport',
     );
+    const isPersistentTracingEnabled = persistentTracingFlag === '1';
+
+    return {
+      timezoneInfo,
+      buildType: this.parseBuildType(buildTypeString),
+      isPersistentTracingEnabled,
+    };
+  }
 
-    return {timezone, locale: 'en-US'};
+  private parseBuildType(
+    buildTypeString: string | undefined,
+  ): BuildType | undefined {
+    if (!buildTypeString) {
+      return undefined;
+    }
+    const lowerCaseBuildType = buildTypeString.toLowerCase();
+    if (Object.values(BuildType).includes(lowerCaseBuildType as BuildType)) {
+      return lowerCaseBuildType as BuildType;
+    }
+    console.warn(`Unknown build type found in bugreport: ${buildTypeString}`);
+    return undefined;
+  }
+
+  private extractBugreportProperty(
+    fileData: string,
+    propertyKey: string,
+  ): string | undefined {
+    const keyWithBrackets = `[${propertyKey}]`;
+    const startIndex = fileData.indexOf(keyWithBrackets);
+    if (startIndex === -1) {
+      return undefined;
+    }
+    return this.extractValueFromRawBugReport(fileData, startIndex);
   }
 
   private extractValueFromRawBugReport(
@@ -126,14 +218,12 @@ export class TraceFileFilter {
       return false;
     }
     const bugreportName = (await bugreportMainEntry.file.text()).trim();
-    return (
-      files.find((file) => {
-        return (
-          file.parentArchive === bugreportMainEntry.parentArchive &&
-          file.file.name === bugreportName
-        );
-      }) !== undefined
-    );
+    return files.some((file) => {
+      return (
+        file.parentArchive === bugreportMainEntry.parentArchive &&
+        file.file.name === bugreportName
+      );
+    });
   }
 
   private async filterBugreport(
@@ -141,7 +231,7 @@ export class TraceFileFilter {
     perfettoFiles: TraceFile[],
     legacyFiles: TraceFile[],
     metadata: TraceMetadata,
-    timezoneInfo?: TimezoneInfo,
+    bugreportData?: BugreportData,
   ): Promise<FilterResult> {
     const isFileAllowlisted = (file: TraceFile) => {
       for (const traceDir of TraceFileFilter.BUGREPORT_LEGACY_FILES_ALLOWLIST) {
@@ -176,14 +266,59 @@ export class TraceFileFilter {
         unzippedLegacyFiles.push(file);
       }
     }
-    const perfettoFile = perfettoFiles.find(
-      (file) => file.file.name === TraceFileFilter.BUGREPORT_SYSTRACE_PATH,
+    const brPerfettoFiles = perfettoFiles.filter(
+      (file) =>
+        FileUtils.getFileDirectory(file.file.name) ===
+        TraceFileFilter.BUGREPORT_PERFETTO_TRACE_DIR,
     );
+
+    const getIndex = (fileName: string) => {
+      return TraceFileFilter.BUGREPORT_PERFETTO_TRACE_ORDER.findIndex(
+        (name) => name === fileName,
+      );
+    };
+    let perfettoFile = brPerfettoFiles
+      .filter((file) =>
+        TraceFileFilter.BUGREPORT_PERFETTO_TRACE_ORDER.includes(file.file.name),
+      )
+      .sort((f1, f2) => getIndex(f1.file.name) - getIndex(f2.file.name))
+      .at(0);
+
+    if (!perfettoFile && brPerfettoFiles.length === 1) {
+      perfettoFile = brPerfettoFiles[0];
+    }
+
+    if (!perfettoFile && brPerfettoFiles.length > 1) {
+      // emitEvent must be set to propagate event to mediator, which routes file selection
+      // request to AppComponent. User is prompted by dialog to select which file to
+      // process. Once dialog is closed, selected file is sent back to TraceFileFilter
+      // via BugreportFileSelected event and handled above in onWinscopeEvent, where
+      // it is stored in selectedFile. Promise below only resolves after BugreportFileSelected
+      // event has been handled.
+      await this.emitEvent(
+        new BugreportFileSelectionRequest(
+          brPerfettoFiles.map((file) => file.file.name),
+        ),
+      );
+      if (this.selectedFile) {
+        perfettoFile = brPerfettoFiles.find(
+          (file) => file.file.name === this.selectedFile,
+        );
+        this.selectedFile = undefined;
+      }
+    }
+
+    const criticalWarnings: UserWarning[] = [];
+    if (!perfettoFile && bugreportData) {
+      criticalWarnings.push(new MissingPersistentTrace(bugreportData));
+    }
+
     return {
       perfetto: perfettoFile,
       legacy: unzippedLegacyFiles,
       metadata,
-      timezoneInfo,
+      timezoneInfo: bugreportData?.timezoneInfo,
+      criticalWarnings,
     };
   }
 
@@ -203,7 +338,7 @@ export class TraceFileFilter {
     const metadata: TraceMetadata = {};
     for (const file of files) {
       const buffer = new Uint8Array(await file.file.arrayBuffer());
-      const text = byteArrayToString(buffer);
+      const text = utf8Decode(buffer);
       try {
         const data = JSON.parse(text);
         if (
diff --git a/tools/winscope/src/app/trace_file_filter_test.ts b/tools/winscope/src/app/trace_file_filter_test.ts
index 5f85fa2b4..19bbf5a4e 100644
--- a/tools/winscope/src/app/trace_file_filter_test.ts
+++ b/tools/winscope/src/app/trace_file_filter_test.ts
@@ -14,11 +14,16 @@
  * limitations under the License.
  */
 
-import {TraceOverridden} from 'messaging/user_warnings';
+import {assertDefined} from 'common/assert_utils';
+import {MissingPersistentTrace, TraceOverridden} from 'messaging/user_warnings';
+import {
+  BugreportFileSelected,
+  WinscopeEventType,
+} from 'messaging/winscope_event';
 import {getFixtureFile} from 'test/unit/fixture_utils';
 import {UserNotifierChecker} from 'test/unit/user_notifier_checker';
 import {TraceFile} from 'trace/trace_file';
-import {TraceFileFilter} from './trace_file_filter';
+import {BuildType, TraceFileFilter} from './trace_file_filter';
 
 describe('TraceFileFilter', () => {
   const filter = new TraceFileFilter();
@@ -84,15 +89,12 @@ describe('TraceFileFilter', () => {
       userNotifierChecker.expectNone();
     });
 
-    it('picks perfetto systrace.pftrace', async () => {
-      const perfettoSystemTrace = makeTraceFile(
-        'FS/data/misc/perfetto-traces/bugreport/systrace.pftrace',
+    it('picks perfetto sysui.pftrace (persistent session)', async () => {
+      const perfettoSysUi = makeTraceFile(
+        'FS/data/misc/perfetto-traces/bugreport/sysui.pftrace',
         bugreportArchive,
       );
-      const bugreportFiles = [
-        await makeBugreportMainEntryTraceFile(),
-        await makeBugreportCodenameTraceFile(),
-        perfettoSystemTrace,
+      const otherFiles = [
         makeTraceFile(
           'FS/data/misc/perfetto-traces/other.perfetto-trace',
           bugreportArchive,
@@ -101,14 +103,63 @@ describe('TraceFileFilter', () => {
           'FS/data/misc/perfetto-traces/other.pftrace',
           bugreportArchive,
         ),
+        makeTraceFile(
+          'FS/data/misc/perfetto-traces/bugreport/other.pftrace',
+          bugreportArchive,
+          10,
+        ),
       ];
-      const result = await filter.filter(bugreportFiles);
-      expect(result.perfetto).toEqual(perfettoSystemTrace);
-      expect(result.legacy).toEqual([]);
-      userNotifierChecker.expectNone();
+      await checkPerfettoPicked(perfettoSysUi, otherFiles);
+    });
+
+    it('picks perfetto systrace.pftrace (traceur or aot session) over sysui.pftrace', async () => {
+      const perfettoSysTrace = makeTraceFile(
+        'FS/data/misc/perfetto-traces/bugreport/systrace.pftrace',
+        bugreportArchive,
+      );
+      await checkPerfettoPicked(perfettoSysTrace, [
+        makeTraceFile(
+          'FS/data/misc/perfetto-traces/bugreport/sysui.pftrace',
+          bugreportArchive,
+          10,
+        ),
+      ]);
+    });
+
+    it('picks single file in perfetto directory', async () => {
+      const perfettoTest = makeTraceFile(
+        'FS/data/misc/perfetto-traces/bugreport/test.pftrace',
+        bugreportArchive,
+      );
+      await checkPerfettoPicked(perfettoTest, []);
     });
 
-    it('ignores perfetto traces other than systrace.pftrace', async () => {
+    it('sends request for file selection if multiple files in perfetto directory', async () => {
+      let requested: string[] | undefined;
+      filter.setEmitEvent(async (event) => {
+        await event.visit(
+          WinscopeEventType.BUGREPORT_FILE_SELECTION_REQUEST,
+          async (event) => {
+            requested = event.filenames;
+            await filter.onWinscopeEvent(
+              new BugreportFileSelected(event.filenames[1]),
+            );
+          },
+        );
+      });
+
+      const perfettoTest = makeTraceFile(
+        'FS/data/misc/perfetto-traces/bugreport/test.pftrace',
+        bugreportArchive,
+      );
+      const perfettoOther = makeTraceFile(
+        'FS/data/misc/perfetto-traces/bugreport/other.pftrace',
+        bugreportArchive,
+      );
+      await checkPerfettoPicked(perfettoOther, [perfettoTest]);
+    });
+
+    it('ignores perfetto traces not in bugreport directory', async () => {
       const bugreportFiles = [
         await makeBugreportMainEntryTraceFile(),
         await makeBugreportCodenameTraceFile(),
@@ -164,6 +215,82 @@ describe('TraceFileFilter', () => {
       ]);
       userNotifierChecker.expectNone();
     });
+
+    it('warns about missing trace on user build', async () => {
+      await checkMissingPerfettoTraceWarning(BuildType.USER, undefined, [
+        "'user' builds",
+        'expected',
+      ]);
+    });
+
+    it('warns about missing trace on userdebug build with persistent flag disabled', async () => {
+      await checkMissingPerfettoTraceWarning(BuildType.USERDEBUG, '0', [
+        'seems to be disabled',
+        'adb shell setprop',
+      ]);
+    });
+
+    it('warns about missing trace on userdebug build with persistent flag enabled', async () => {
+      await checkMissingPerfettoTraceWarning(BuildType.USERDEBUG, '1', [
+        'No Winscope Perfetto trace found in bug report. Ensure the bugreport comes from a device where persistent tracing is enabled',
+      ]);
+    });
+
+    it('warns about missing trace on userdebug build with persistent flag unknown', async () => {
+      await checkMissingPerfettoTraceWarning(BuildType.USERDEBUG, undefined, [
+        'No Winscope Perfetto trace found in bug report.',
+        "The persistent tracing property ('persist.debug.perfetto.persistent') seems to be disabled",
+      ]);
+    });
+
+    it('warns about missing trace on eng build with persistent flag disabled', async () => {
+      await checkMissingPerfettoTraceWarning(BuildType.ENG, '0', [
+        'No Winscope Perfetto trace found in bug report.',
+        "The persistent tracing property ('persist.debug.perfetto.persistent') seems to be disabled",
+      ]);
+    });
+
+    it('warns about missing trace on eng build with persistent flag enabled', async () => {
+      await checkMissingPerfettoTraceWarning(BuildType.ENG, '1', [
+        'No Winscope Perfetto trace found in bug report. Ensure the bugreport comes from a device where persistent tracing is enabled',
+      ]);
+    });
+
+    it('does not warn if a valid perfetto trace is found', async () => {
+      const perfettoSysTrace = makeTraceFile(
+        'FS/data/misc/perfetto-traces/bugreport/systrace.pftrace',
+        bugreportArchive,
+      );
+      const mainBugreportFilename = 'bugreport-user-build.txt';
+      const bugreportFiles = [
+        await makeCustomBugreportMainEntryTraceFile(mainBugreportFilename),
+        makeMainBugreportFile(mainBugreportFilename, {
+          'persist.sys.timezone': 'America/Los_Angeles',
+        }),
+        perfettoSysTrace, // Include the trace file
+      ];
+
+      const result = await filter.filter(bugreportFiles);
+      expect(result.perfetto).toEqual(perfettoSysTrace);
+      expect(result.criticalWarnings?.length).toEqual(0); // No warnings expected
+      userNotifierChecker.expectNone();
+    });
+
+    async function checkPerfettoPicked(
+      perfetto: TraceFile,
+      other: TraceFile[],
+    ) {
+      const bugreportFiles = [
+        await makeBugreportMainEntryTraceFile(),
+        await makeBugreportCodenameTraceFile(),
+        ...other,
+        perfetto,
+      ];
+      const result = await filter.filter(bugreportFiles);
+      expect(result.perfetto).toEqual(perfetto);
+      expect(result.legacy).toEqual([]);
+      userNotifierChecker.expectNone();
+    }
   });
 
   describe('plain input (no bugreport)', () => {
@@ -232,6 +359,47 @@ describe('TraceFileFilter', () => {
     }
   });
 
+  async function checkMissingPerfettoTraceWarning(
+    buildType: BuildType,
+    persistentFlag: string | undefined,
+    expectedMessageSubstrings: string[],
+  ) {
+    const mainBugreportFilename = `bugreport-${buildType}-build${
+      persistentFlag ? '-flag' + persistentFlag : ''
+    }.txt`;
+    const properties: {[key: string]: string} = {
+      'ro.build.type': buildType,
+      'persist.sys.timezone': 'America/Los_Angeles', // Example timezone
+    };
+    if (persistentFlag !== undefined) {
+      properties[
+        'persist.debug.perfetto.persistent_sysui_tracing_for_bugreport'
+      ] = persistentFlag;
+    }
+
+    const bugreportFiles = [
+      await makeCustomBugreportMainEntryTraceFile(mainBugreportFilename),
+      makeMainBugreportFile(mainBugreportFilename, properties),
+    ];
+
+    const result = await filter.filter(bugreportFiles);
+
+    expect(result.perfetto).toBeUndefined();
+    expect(result.criticalWarnings).toBeDefined();
+    expect(result.criticalWarnings?.length).toEqual(1);
+    const warning = assertDefined(
+      result.criticalWarnings,
+    )[0] as MissingPersistentTrace;
+    expect(warning).toBeInstanceOf(MissingPersistentTrace);
+
+    const actualMessage = warning.getMessage();
+    expectedMessageSubstrings.forEach((substring) => {
+      expect(actualMessage).toContain(substring);
+    });
+
+    userNotifierChecker.expectNone();
+  }
+
   function makeTraceFile(
     filename: string,
     parentArchive?: File,
@@ -242,6 +410,30 @@ describe('TraceFileFilter', () => {
     return new TraceFile(file as unknown as File, parentArchive);
   }
 
+  function makeMainBugreportFile(
+    filename: string, // Should match the content of main_entry.txt
+    properties: {[key: string]: string},
+    parentArchive?: File,
+  ): TraceFile {
+    let content = 'some initial bugreport content...\n';
+    for (const [key, value] of Object.entries(properties)) {
+      // Add other properties if needed for testing timezone etc.
+      content += `[${key}]: [${value}]\n`;
+    }
+    content += '...some trailing bugreport content\n';
+
+    const file = new File([content], filename);
+    return new TraceFile(file, parentArchive ?? bugreportArchive);
+  }
+
+  async function makeCustomBugreportMainEntryTraceFile(
+    mainBugreportFilename = 'bugreport-codename_beta-UPB2.230407.019-2023-05-30-14-33-48.txt',
+  ): Promise<TraceFile> {
+    // Ensure the content matches the filename used in makeMainBugreportFile
+    const file = new File([mainBugreportFilename], 'main_entry.txt');
+    return new TraceFile(file, bugreportArchive);
+  }
+
   async function makeBugreportMainEntryTraceFile(): Promise<TraceFile> {
     const file = await getFixtureFile(
       'bugreports/main_entry.txt',
@@ -260,7 +452,7 @@ describe('TraceFileFilter', () => {
 
   async function makeZippedTraceFile(): Promise<TraceFile> {
     const file = await getFixtureFile(
-      'traces/winscope.zip',
+      'archives/winscope.zip',
       'FS/data/misc/wmtrace/winscope.zip',
     );
     return new TraceFile(file, bugreportArchive);
diff --git a/tools/winscope/src/app/trace_pipeline.ts b/tools/winscope/src/app/trace_pipeline.ts
index a51fe94ef..529bba65f 100644
--- a/tools/winscope/src/app/trace_pipeline.ts
+++ b/tools/winscope/src/app/trace_pipeline.ts
@@ -23,97 +23,141 @@ import {
 import {UserNotifier} from 'common/user_notifier';
 import {Analytics} from 'logging/analytics';
 import {ProgressListener} from 'messaging/progress_listener';
-import {CorruptedArchive, NoValidFiles} from 'messaging/user_warnings';
+import {UserWarning} from 'messaging/user_warning';
+import {
+  CorruptedArchive,
+  InvalidPerfettoTrace,
+  NoValidFiles,
+  UnsupportedFileFormat,
+} from 'messaging/user_warnings';
+import {WinscopeEvent} from 'messaging/winscope_event';
+import {
+  EmitEvent,
+  WinscopeEventEmitter,
+} from 'messaging/winscope_event_emitter';
+import {WinscopeEventListener} from 'messaging/winscope_event_listener';
+import {FileAndParser} from 'parsers/file_and_parser';
 import {FileAndParsers} from 'parsers/file_and_parsers';
 import {ParserFactory as LegacyParserFactory} from 'parsers/legacy/parser_factory';
+import {LegacyToPerfettoConverter} from 'parsers/legacy_to_perfetto_converter';
+import {
+  getParserWithLatestRealToBootTimeOffset,
+  getParserWithLatestRealToMonotonicTimeOffset,
+} from 'parsers/parser_time_utils';
 import {ParserFactory as PerfettoParserFactory} from 'parsers/perfetto/parser_factory';
 import {ParserSearch} from 'parsers/search/parser_search';
 import {TracesParserFactory} from 'parsers/traces/traces_parser_factory';
 import {FrameMapper} from 'trace/frame_mapper';
+import {Parser} from 'trace/parser';
 import {Trace} from 'trace/trace';
 import {Traces} from 'trace/traces';
 import {TraceFile} from 'trace/trace_file';
 import {TraceEntryTypeMap, TraceType, TraceTypeUtils} from 'trace/trace_type';
-import {QueryResult} from 'trace_processor/query_result';
+import {QueryResult, Row} from 'trace_processor/query_result';
+import {TraceProcessorFactory} from 'trace_processor/trace_processor_factory';
 import {FilesSource} from './files_source';
 import {LoadedParsers} from './loaded_parsers';
-import {TraceFileFilter} from './trace_file_filter';
+import {FilterResult, TraceFileFilter} from './trace_file_filter';
 
 type UnzippedArchive = TraceFile[];
 
-export class TracePipeline {
+export class TracePipeline
+  implements WinscopeEventListener, WinscopeEventEmitter
+{
   private loadedParsers = new LoadedParsers();
   private traceFileFilter = new TraceFileFilter();
-  private tracesParserFactory = new TracesParserFactory();
   private traces = new Traces();
   private downloadArchiveFilename?: string;
+  private lostPerfettoPackets = 0;
   private timestampConverter = new TimestampConverter(UTC_TIMEZONE_INFO);
 
+  setEmitEvent(callback: EmitEvent) {
+    this.traceFileFilter.setEmitEvent(callback);
+  }
+
+  async onWinscopeEvent(event: WinscopeEvent) {
+    await this.traceFileFilter.onWinscopeEvent(event);
+  }
+
   async loadFiles(
     files: File[],
     source: FilesSource,
     progressListener: ProgressListener | undefined,
-  ) {
+  ): Promise<UserWarning[]> {
     this.downloadArchiveFilename = this.makeDownloadArchiveFilename(
       files,
       source,
     );
 
+    const warnings: UserWarning[] = [];
+
     try {
       const unzippedArchives = await this.unzipFiles(files, progressListener);
 
       if (unzippedArchives.length === 0) {
         UserNotifier.add(new NoValidFiles());
-        return;
+        return warnings;
       }
 
       for (const unzippedArchive of unzippedArchives) {
-        await this.loadUnzippedArchive(
+        const newWarnings = await this.loadUnzippedArchive(
           unzippedArchive,
           source,
           progressListener,
         );
+        warnings.push(...newWarnings);
       }
 
-      this.traces = new Traces();
-
-      this.loadedParsers.getParsers().forEach((parser) => {
-        const trace = Trace.fromParser(parser);
-        this.traces.addTrace(trace);
-        Analytics.Tracing.logTraceLoaded(parser);
-      });
+      await this.convertLoadedParsersToTraces();
+      return warnings;
+    } finally {
+      progressListener?.onOperationFinished(true);
+    }
+  }
 
-      const tracesParsers = await this.tracesParserFactory.createParsers(
-        this.traces,
-        this.timestampConverter,
-      );
+  async convertLegacyTracesToPerfetto() {
+    if (!this.hasConvertibleLegacyTraces()) {
+      return;
+    }
+    const singlePerfettoTrace = await this.convertLegacyParsersToPerfettoFile();
+    if (!singlePerfettoTrace) {
+      return;
+    }
+    const perfettoParsers = await this.processPerfettoFile(
+      singlePerfettoTrace,
+      FilesSource.APP,
+      undefined,
+      new InvalidPerfettoTrace(singlePerfettoTrace.getDescriptor(), [
+        'failed to convert legacy parsers into perfetto trace',
+      ]),
+    );
+    if (!perfettoParsers || perfettoParsers.parsers.length === 0) {
+      return;
+    }
 
-      tracesParsers.forEach((tracesParser) => {
-        const trace = Trace.fromParser(tracesParser);
-        this.traces.addTrace(trace);
-      });
+    this.timestampConverter.clear();
+    this.updateTimestamps([], perfettoParsers);
+    this.loadedParsers.addParsers([], perfettoParsers);
+    await this.convertLoadedParsersToTraces();
+  }
 
-      const hasTransitionTrace =
-        this.traces.getTrace(TraceType.TRANSITION) !== undefined;
-      if (hasTransitionTrace) {
-        this.removeTracesAndParsersByType(TraceType.WM_TRANSITION);
-        this.removeTracesAndParsersByType(TraceType.SHELL_TRANSITION);
-      }
+  hasConvertibleLegacyTraces(): boolean {
+    return this.getLegacyTracesWithPerfettoConversion().length > 0;
+  }
 
-      const hasCujTrace = this.traces.getTrace(TraceType.CUJS) !== undefined;
-      if (hasCujTrace) {
-        this.removeTracesAndParsersByType(TraceType.EVENT_LOG);
-      }
+  discardLegacyTraces() {
+    const tracesToRemove = this.getLegacyTracesWithPerfettoConversion();
+    tracesToRemove.forEach((trace) => this.removeTrace(trace));
+  }
 
-      const hasMergedInputTrace =
-        this.traces.getTrace(TraceType.INPUT_EVENT_MERGED) !== undefined;
-      if (hasMergedInputTrace) {
-        this.removeTracesAndParsersByType(TraceType.INPUT_KEY_EVENT);
-        this.removeTracesAndParsersByType(TraceType.INPUT_MOTION_EVENT);
+  private getLegacyTracesWithPerfettoConversion() {
+    const traces: Array<Trace<object>> = [];
+    this.traces.forEachTrace((trace) => {
+      if (trace.getParser()?.canConvertToPerfetto()) {
+        traces.push(trace);
       }
-    } finally {
-      progressListener?.onOperationFinished(true);
-    }
+    });
+    return traces;
   }
 
   removeTrace<T extends TraceType>(
@@ -169,6 +213,10 @@ export class TracePipeline {
     return this.timestampConverter;
   }
 
+  lostPackets(): number {
+    return this.lostPerfettoPackets;
+  }
+
   async getScreenRecordingVideo(): Promise<undefined | Blob> {
     const traces = this.getTraces();
     const screenRecording =
@@ -199,15 +247,19 @@ export class TracePipeline {
     this.traces = new Traces();
     this.timestampConverter.clear();
     this.downloadArchiveFilename = undefined;
+    this.lostPerfettoPackets = 0;
   }
 
   private async loadUnzippedArchive(
     unzippedArchive: UnzippedArchive,
     source: FilesSource,
     progressListener: ProgressListener | undefined,
-  ) {
+  ): Promise<UserWarning[]> {
+    const warnings: UserWarning[] = [];
+
     let startTimeMs = Date.now();
     const filterResult = await this.traceFileFilter.filter(unzippedArchive);
+    warnings.push(...(filterResult.criticalWarnings ?? []));
     const size =
       filterResult.legacy.reduce(
         (totalSize, f) => (totalSize += f.file.size),
@@ -227,11 +279,54 @@ export class TracePipeline {
 
     if (!filterResult.perfetto && filterResult.legacy.length === 0) {
       UserNotifier.add(new NoValidFiles());
-      return;
+      return warnings;
     }
 
     startTimeMs = Date.now();
-    const legacyParsers = await new LegacyParserFactory().createParsers(
+
+    const {parsers: legacyParsers, unsupportedFiles} =
+      await this.processLegacyFiles(filterResult, source, progressListener);
+
+    let perfettoParsers: FileAndParsers | undefined;
+    if (filterResult.perfetto) {
+      perfettoParsers = await this.processPerfettoFile(
+        filterResult.perfetto,
+        source,
+        progressListener,
+        new UnsupportedFileFormat(filterResult.perfetto.getDescriptor()),
+      );
+    } else {
+      for (const file of unsupportedFiles) {
+        if (perfettoParsers) {
+          UserNotifier.add(new UnsupportedFileFormat(file.getDescriptor()));
+          continue;
+        }
+        perfettoParsers = await this.processPerfettoFile(
+          file,
+          source,
+          progressListener,
+          new UnsupportedFileFormat(file.getDescriptor()),
+        );
+      }
+    }
+
+    if (perfettoParsers) {
+      await this.checkForLostPerfettoPackets();
+    }
+
+    this.updateTimestamps(legacyParsers, perfettoParsers);
+    this.loadedParsers.addParsers(legacyParsers, perfettoParsers);
+
+    return warnings;
+  }
+
+  private async processLegacyFiles(
+    filterResult: FilterResult,
+    source: FilesSource,
+    progressListener: ProgressListener | undefined,
+  ) {
+    const startTimeMs = Date.now();
+    const processedLegacyFiles = await new LegacyParserFactory().processFiles(
       filterResult.legacy,
       this.timestampConverter,
       filterResult.metadata,
@@ -244,37 +339,69 @@ export class TracePipeline {
     );
     Analytics.Memory.logUsage('legacy_files_parsed');
 
-    let perfettoParsers: FileAndParsers | undefined;
+    return processedLegacyFiles;
+  }
 
-    if (filterResult.perfetto) {
-      startTimeMs = Date.now();
-      const parsers = await new PerfettoParserFactory().createParsers(
-        filterResult.perfetto,
+  private async processPerfettoFile(
+    file: TraceFile,
+    source: FilesSource,
+    progressListener: ProgressListener | undefined,
+    onFailureWarning: UserWarning,
+  ): Promise<FileAndParsers | undefined> {
+    const startTimeMs = Date.now();
+    const {parsers, isPerfettoTrace} =
+      await new PerfettoParserFactory().processFile(
+        file,
         this.timestampConverter,
         progressListener,
       );
-      Analytics.Loading.logFileParsingTime(
-        'perfetto',
-        source,
-        Date.now() - startTimeMs,
-      );
-      Analytics.Memory.logUsage('perfetto_files_parsed');
-      perfettoParsers = new FileAndParsers(filterResult.perfetto, parsers);
+    Analytics.Loading.logFileParsingTime(
+      'perfetto',
+      source,
+      Date.now() - startTimeMs,
+    );
+    Analytics.Memory.logUsage('perfetto_files_parsed');
+    if (parsers.length > 0) {
+      return new FileAndParsers(file, parsers);
+    }
+    if (!isPerfettoTrace) {
+      UserNotifier.add(onFailureWarning);
+    }
+    return undefined;
+  }
+
+  private async checkForLostPerfettoPackets() {
+    const tp = TraceProcessorFactory.getSingleInstance();
+    const packetLossQuery =
+      'SELECT name, value FROM stats ' +
+      "WHERE name = 'traced_buf_trace_writer_packet_loss'";
+    const res = await tp.query(packetLossQuery);
+    const value =
+      res.numRows() > 0 ? res.firstRow<Row>({})['value'] : undefined;
+    if (typeof value === 'bigint' && value > 0n) {
+      this.lostPerfettoPackets = Number(value);
+    } else {
+      this.lostPerfettoPackets = 0;
     }
+  }
+
+  private updateTimestamps(
+    nonPerfettoParsers: FileAndParser[],
+    perfettoParsers?: FileAndParsers,
+  ) {
+    const allParsers = nonPerfettoParsers
+      .map((fileAndParser) => fileAndParser.parser)
+      .concat(perfettoParsers?.parsers ?? []);
 
     const monotonicTimeOffset =
-      this.loadedParsers.getLatestRealToMonotonicOffset(
-        legacyParsers
-          .map((fileAndParser) => fileAndParser.parser)
-          .concat(perfettoParsers?.parsers ?? []),
-      );
+      getParserWithLatestRealToMonotonicTimeOffset(
+        allParsers,
+      )?.getRealToMonotonicTimeOffsetNs();
 
     const realToBootTimeOffset =
-      this.loadedParsers.getLatestRealToBootTimeOffset(
-        legacyParsers
-          .map((fileAndParser) => fileAndParser.parser)
-          .concat(perfettoParsers?.parsers ?? []),
-      );
+      getParserWithLatestRealToBootTimeOffset(
+        allParsers,
+      )?.getRealToBootTimeOffsetNs();
 
     if (monotonicTimeOffset !== undefined) {
       this.timestampConverter.setRealToMonotonicTimeOffsetNs(
@@ -286,11 +413,72 @@ export class TracePipeline {
     }
 
     perfettoParsers?.parsers.forEach((p) => p.createTimestamps());
-    legacyParsers.forEach((fileAndParser) =>
+    nonPerfettoParsers.forEach((fileAndParser) =>
       fileAndParser.parser.createTimestamps(),
     );
+  }
 
-    this.loadedParsers.addParsers(legacyParsers, perfettoParsers);
+  private async convertLoadedParsersToTraces() {
+    this.traces = new Traces();
+
+    this.loadedParsers.getParsers().forEach((parser) => {
+      const trace = Trace.fromParser(parser);
+      this.traces.addTrace(trace);
+      Analytics.Tracing.logTraceLoaded(parser);
+    });
+
+    const tracesParsers = await new TracesParserFactory().createParsers(
+      this.traces,
+      this.timestampConverter,
+    );
+
+    tracesParsers.forEach((tracesParser) => {
+      const trace = Trace.fromParser(tracesParser);
+      this.traces.addTrace(trace);
+    });
+
+    const hasTransitionTrace =
+      this.traces.getTrace(TraceType.TRANSITION) !== undefined;
+    if (hasTransitionTrace) {
+      this.removeTracesAndParsersByType(TraceType.WM_TRANSITION);
+      this.removeTracesAndParsersByType(TraceType.SHELL_TRANSITION);
+    }
+
+    const hasCujTrace = this.traces.getTrace(TraceType.CUJS) !== undefined;
+    if (hasCujTrace) {
+      this.removeTracesAndParsersByType(TraceType.EVENT_LOG);
+    }
+
+    const hasMergedInputTrace =
+      this.traces.getTrace(TraceType.INPUT_EVENT_MERGED) !== undefined;
+    if (hasMergedInputTrace) {
+      this.removeTracesAndParsersByType(TraceType.INPUT_KEY_EVENT);
+      this.removeTracesAndParsersByType(TraceType.INPUT_MOTION_EVENT);
+    }
+  }
+
+  private async convertLegacyParsersToPerfettoFile(): Promise<
+    TraceFile | undefined
+  > {
+    const legacyParsers = this.traces
+      .mapTrace((trace) => {
+        return trace.isPerfetto() ? undefined : trace.getParser();
+      })
+      .filter((parser) => parser !== undefined) as Array<Parser<object>>;
+
+    if (legacyParsers.length === 0) {
+      return undefined;
+    }
+
+    const allParsers = this.traces.mapTrace((trace) => {
+      return trace.getParser();
+    });
+
+    return await LegacyToPerfettoConverter.convertToSinglePerfettoFile(
+      legacyParsers,
+      allParsers,
+      this.loadedParsers.getPerfettoFile(),
+    );
   }
 
   private makeDownloadArchiveFilename(
@@ -317,7 +505,8 @@ export class TracePipeline {
       return archiveFilenameNoIllegalChars;
     } else {
       console.error(
-        "Cannot convert uploaded archive filename to acceptable format for download. Defaulting download filename to 'winscope.zip'.",
+        'Cannot convert uploaded archive filename to acceptable format for download. ' +
+          "Defaulting download filename to 'winscope.zip'.",
       );
       return 'winscope';
     }
diff --git a/tools/winscope/src/app/trace_pipeline_test.ts b/tools/winscope/src/app/trace_pipeline_test.ts
index b7fbc49ea..b4624c0d3 100644
--- a/tools/winscope/src/app/trace_pipeline_test.ts
+++ b/tools/winscope/src/app/trace_pipeline_test.ts
@@ -26,17 +26,21 @@ import {
   CorruptedArchive,
   InvalidPerfettoTrace,
   NoValidFiles,
-  PerfettoPacketLoss,
   TraceOverridden,
   UnsupportedFileFormat,
 } from 'messaging/user_warnings';
+import {BugreportFileSelected} from 'messaging/winscope_event';
+import {LegacyToPerfettoConverter} from 'parsers/legacy_to_perfetto_converter';
 import {getFixtureFile} from 'test/unit/fixture_utils';
-import {TracesUtils} from 'test/unit/traces_utils';
+import {extractEntries} from 'test/unit/traces_utils';
 import {UserNotifierChecker} from 'test/unit/user_notifier_checker';
+import {Parser} from 'trace/parser';
+import {TraceFile} from 'trace/trace_file';
 import {TraceType} from 'trace/trace_type';
 import {QueryResult} from 'trace_processor/query_result';
 import {TraceProcessor} from 'trace_processor/trace_processor';
 import {FilesSource} from './files_source';
+import {TraceFileFilter} from './trace_file_filter';
 import {TracePipeline} from './trace_pipeline';
 
 describe('TracePipeline', () => {
@@ -50,6 +54,8 @@ describe('TracePipeline', () => {
   let brCodenameFile: File;
   let brSfFile: File;
   let jpgFile: File;
+  let perfettoFile: File;
+  let elapsedFile: File;
 
   let progressListener: ProgressListenerStub;
   let tracePipeline: TracePipeline;
@@ -69,7 +75,7 @@ describe('TracePipeline', () => {
     validWmFile = await getFixtureFile(
       'traces/elapsed_and_real_timestamp/WindowManager.pb',
     );
-    screenshotFile = await getFixtureFile('traces/screenshot.png');
+    screenshotFile = await getFixtureFile('traces/screenshot/screenshot.png');
     screenRecordingFile = await getFixtureFile(
       'traces/elapsed_and_real_timestamp/screen_recording_metadata_v2.mp4',
     );
@@ -85,7 +91,14 @@ describe('TracePipeline', () => {
       'traces/elapsed_and_real_timestamp/SurfaceFlinger.pb',
       'FS/data/misc/wmtrace/surface_flinger.bp',
     );
-    jpgFile = await getFixtureFile('winscope_homepage.jpg');
+    jpgFile = await getFixtureFile('invalid_files/winscope_homepage.jpg');
+    perfettoFile = await getFixtureFile(
+      'traces/perfetto/protolog.perfetto-trace',
+      'traces/perfetto/protolog',
+    );
+    elapsedFile = await getFixtureFile(
+      'traces/elapsed_timestamp/SurfaceFlinger.pb',
+    );
   });
 
   beforeEach(async () => {
@@ -94,11 +107,15 @@ describe('TracePipeline', () => {
     progressListener = new ProgressListenerStub();
     spyOn(progressListener, 'onProgressUpdate');
     spyOn(progressListener, 'onOperationFinished');
-    userNotifierChecker.reset();
 
     tracePipeline = new TracePipeline();
   });
 
+  afterEach(() => {
+    userNotifierChecker.expectNone();
+    userNotifierChecker.reset();
+  });
+
   it('can load valid trace files', async () => {
     expect(tracePipeline.getTraces().getSize()).toEqual(0);
 
@@ -110,22 +127,22 @@ describe('TracePipeline', () => {
     );
     expect(tracePipeline.getTraces().getSize()).toEqual(2);
 
-    const traceEntries = await TracesUtils.extractEntries(
-      tracePipeline.getTraces(),
-    );
-    expect(traceEntries.get(TraceType.WINDOW_MANAGER)?.length).toBeGreaterThan(
-      0,
-    );
-    expect(traceEntries.get(TraceType.SURFACE_FLINGER)?.length).toBeGreaterThan(
-      0,
-    );
+    const traces = tracePipeline.getTraces();
+    expect(
+      traces.getTrace(TraceType.WINDOW_MANAGER)?.lengthEntries,
+    ).toBeGreaterThan(0);
+    expect(
+      traces.getTrace(TraceType.SURFACE_FLINGER)?.lengthEntries,
+    ).toBeGreaterThan(0);
   });
 
   it('can load valid gzipped file and archive', async () => {
     expect(tracePipeline.getTraces().getSize()).toEqual(0);
 
-    const gzippedFile = await getFixtureFile('traces/WindowManager.pb.gz');
-    const gzippedArchive = await getFixtureFile('traces/WindowManager.zip.gz');
+    const gzippedFile = await getFixtureFile('archives/WindowManager.pb.gz');
+    const gzippedArchive = await getFixtureFile(
+      'archives/WindowManager.zip.gz',
+    );
 
     await loadFiles([gzippedFile, gzippedArchive], FilesSource.TEST);
     await expectLoadResult(2, []);
@@ -134,7 +151,7 @@ describe('TracePipeline', () => {
     expect(traces.getSize()).toEqual(2);
     expect(traces.getTraces(TraceType.WINDOW_MANAGER).length).toEqual(2);
 
-    const traceEntries = await TracesUtils.extractEntries(traces);
+    const traceEntries = await extractEntries(traces);
     expect(traceEntries.get(TraceType.WINDOW_MANAGER)?.length).toBeGreaterThan(
       0,
     );
@@ -158,7 +175,7 @@ describe('TracePipeline', () => {
 
   it('can convert illegal uploaded archive filename to legal name for download archive', async () => {
     const fileWithIllegalName = await getFixtureFile(
-      'traces/SFtrace(with_illegal_characters).pb',
+      'traces/elapsed_and_real_timestamp/SFtrace(with_illegal_characters).pb',
     );
     await loadFiles([fileWithIllegalName]);
     await expectLoadResult(1, []);
@@ -174,8 +191,8 @@ describe('TracePipeline', () => {
       brCodenameFile,
       brSfFile,
       await getFixtureFile(
-        'traces/elapsed_and_real_timestamp/wm_transition_trace.pb',
-        'FS/data/misc/ignored-dir/window_manager.bp',
+        'traces/elapsed_and_real_timestamp/WindowManager.pb',
+        'FS/data/misc/ignored-dir/window_manager.pb',
       ),
     ];
 
@@ -227,11 +244,23 @@ describe('TracePipeline', () => {
     ).toEqual(expectedTimestamp);
   });
 
-  it('is robust to corrupted archive', async () => {
-    const corruptedArchive = await getFixtureFile('corrupted_archive.zip');
+  it('forwards winscope events to file filter', async () => {
+    const setEmitEventSpy = spyOn(TraceFileFilter.prototype, 'setEmitEvent');
+    const emitEventSpy = jasmine.createSpy();
+    tracePipeline.setEmitEvent(emitEventSpy);
+    expect(setEmitEventSpy).toHaveBeenCalledOnceWith(emitEventSpy);
 
-    await loadFiles([corruptedArchive]);
+    const onEventSpy = spyOn(TraceFileFilter.prototype, 'onWinscopeEvent');
+    const testEvent = new BugreportFileSelected('f1');
+    tracePipeline.onWinscopeEvent(testEvent);
+    expect(onEventSpy).toHaveBeenCalledOnceWith(testEvent);
+  });
 
+  it('is robust to corrupted archive', async () => {
+    const corruptedArchive = await getFixtureFile(
+      'invalid_files/corrupted_archive.zip',
+    );
+    await loadFiles([corruptedArchive]);
     await expectLoadResult(0, [
       new CorruptedArchive(corruptedArchive),
       new NoValidFiles(),
@@ -241,19 +270,32 @@ describe('TracePipeline', () => {
   it('is robust to invalid trace files', async () => {
     const invalidFiles = [jpgFile];
     await loadFiles(invalidFiles);
-
     await expectLoadResult(0, [
       new UnsupportedFileFormat('winscope_homepage.jpg'),
     ]);
   });
 
+  it('notifies for unsupported file uploaded before valid file', async () => {
+    const invalidFiles = [jpgFile, perfettoFile];
+    await loadFiles(invalidFiles);
+    await expectLoadResult(1, [
+      new UnsupportedFileFormat('winscope_homepage.jpg'),
+    ]);
+  });
+
+  it('notifies for unsupported file uploaded after valid file', async () => {
+    const invalidFiles = [perfettoFile, jpgFile];
+    await loadFiles(invalidFiles);
+    await expectLoadResult(1, [
+      new UnsupportedFileFormat('winscope_homepage.jpg'),
+    ]);
+  });
+
   it('is robust to invalid perfetto trace files', async () => {
     const invalidFiles = [
-      await getFixtureFile('traces/perfetto/invalid_protolog.perfetto-trace'),
+      await getFixtureFile('invalid_files/invalid_protolog.perfetto-trace'),
     ];
-
     await loadFiles(invalidFiles);
-
     await expectLoadResult(0, [
       new InvalidPerfettoTrace('invalid_protolog.perfetto-trace', [
         'Perfetto trace has no Winscope trace entries',
@@ -261,41 +303,41 @@ describe('TracePipeline', () => {
     ]);
   });
 
-  it('shows warning for packet loss', async () => {
-    const file = [
-      await getFixtureFile('traces/perfetto/layers_trace.perfetto-trace'),
-    ];
+  it('surfaces information about packet loss', async () => {
+    await loadFiles([perfettoFile]);
+    expect(tracePipeline.lostPackets()).toEqual(0);
+
     const queryResultObj = jasmine.createSpyObj<QueryResult>('result', [
       'numRows',
       'firstRow',
-      'waitAllRows',
     ]);
     queryResultObj.numRows.and.returnValue(1);
     queryResultObj.firstRow.and.returnValue({value: 2n});
-    queryResultObj.waitAllRows.and.returnValue(Promise.resolve(queryResultObj));
 
-    const spy = spyOn(
-      TraceProcessor.prototype,
-      'queryAllRows',
-    ).and.callThrough();
+    const spy = spyOn(TraceProcessor.prototype, 'query').and.callThrough();
     spy
       .withArgs(
-        "select name, value from stats where name = 'traced_buf_trace_writer_packet_loss'",
+        'SELECT name, value FROM stats ' +
+          "WHERE name = 'traced_buf_trace_writer_packet_loss'",
       )
       .and.returnValue(Promise.resolve(queryResultObj));
+    await loadFiles([perfettoFile]);
+    expect(tracePipeline.lostPackets()).toEqual(2);
 
-    await loadFiles(file);
-    await expectLoadResult(1, [
-      new PerfettoPacketLoss('layers_trace.perfetto-trace', 2),
-    ]);
+    queryResultObj.numRows.and.returnValue(0);
+    await loadFiles([perfettoFile]); // clears lost packets from previous load on overwrite
+    expect(tracePipeline.lostPackets()).toEqual(0);
+
+    queryResultObj.numRows.and.returnValue(1);
+    await loadFiles([perfettoFile]);
+    expect(tracePipeline.lostPackets()).toEqual(2);
+    tracePipeline.clear(); // resets lost packets on explicit clear call
+    expect(tracePipeline.lostPackets()).toEqual(0);
   });
 
   it('is robust to mixed valid and invalid trace files', async () => {
     expect(tracePipeline.getTraces().getSize()).toEqual(0);
-    const files = [
-      jpgFile,
-      await getFixtureFile('traces/dump_WindowManager.pb'),
-    ];
+    const files = [jpgFile, elapsedFile];
 
     await loadFiles(files);
 
@@ -346,7 +388,11 @@ describe('TracePipeline', () => {
   });
 
   it('removes constituent traces of CUJs trace but keeps for download', async () => {
-    const files = [await getFixtureFile('traces/eventlog.winscope')];
+    const files = [
+      await getFixtureFile(
+        'traces/elapsed_and_real_timestamp/eventlog.winscope',
+      ),
+    ];
     await loadFiles(files);
     await expectLoadResult(1, []);
 
@@ -468,13 +514,11 @@ describe('TracePipeline', () => {
   });
 
   it('tries to create search trace', async () => {
-    const perfettoFile = await getFixtureFile(
-      'traces/perfetto/layers_trace.perfetto-trace',
-    );
     await loadFiles([perfettoFile]);
-    const validQuery = 'select ts from surfaceflinger_layers_snapshot';
+    const validQuery = 'select ts from protolog';
     expect(await tracePipeline.tryCreateSearchTrace(validQuery)).toBeDefined();
     expect(await tracePipeline.tryCreateSearchTrace('fail')).toBeUndefined();
+    userNotifierChecker.reset();
   });
 
   it('creates screen recording using metadata', async () => {
@@ -488,6 +532,109 @@ describe('TracePipeline', () => {
     await expectLoadResult(1, []);
   });
 
+  it('discards legacy traces without conversion', async () => {
+    await loadFiles([validSfFile, screenshotFile]);
+    expectLoadResult(2, []);
+    tracePipeline.discardLegacyTraces();
+    const traces = tracePipeline.getTraces();
+    expect(traces.getSize()).toEqual(1);
+    expect(traces.getTrace(TraceType.SCREENSHOT)).toBeDefined();
+  });
+
+  describe('legacy to perfetto conversion', () => {
+    let parserSf: Parser<object>;
+    let converterSpy: jasmine.Spy;
+
+    beforeEach(async () => {
+      converterSpy = spyOn(
+        LegacyToPerfettoConverter,
+        'convertToSinglePerfettoFile',
+      ).and.callThrough();
+      await loadFiles([validSfFile]);
+      parserSf = assertDefined(
+        tracePipeline
+          .getTraces()
+          .getTrace(TraceType.SURFACE_FLINGER)
+          ?.getParser(),
+      );
+    });
+
+    it('robust to no available legacy-to-perfetto conversions', async () => {
+      tracePipeline.clear();
+      await loadFiles([screenshotFile]);
+      await tracePipeline.convertLegacyTracesToPerfetto();
+      expect(converterSpy).not.toHaveBeenCalled();
+    });
+
+    it('robust to failed legacy-to-perfetto conversion', async () => {
+      converterSpy.and.returnValue(Promise.resolve(undefined));
+      await expectAsync(
+        tracePipeline.convertLegacyTracesToPerfetto(),
+      ).not.toBeRejected();
+      expect(converterSpy).toHaveBeenCalledTimes(1);
+    });
+
+    it('robust to no perfetto data in converted file', async () => {
+      converterSpy.and.returnValue(Promise.resolve(new TraceFile(validSfFile)));
+      await tracePipeline.convertLegacyTracesToPerfetto();
+      userNotifierChecker.expectAdded([
+        new InvalidPerfettoTrace('SurfaceFlinger.pb', [
+          'failed to convert legacy parsers into perfetto trace',
+        ]),
+      ]);
+      userNotifierChecker.reset();
+    });
+
+    it('with single legacy trace', async () => {
+      await tracePipeline.convertLegacyTracesToPerfetto();
+      expect(converterSpy).toHaveBeenCalledOnceWith(
+        [parserSf],
+        [parserSf],
+        undefined,
+      );
+      expect(tracePipeline.getTraces().getSize()).toEqual(1);
+      checkSfTraceIsPerfetto();
+    });
+
+    it('with perfetto parser loaded', async () => {
+      await loadFiles([perfettoFile]);
+      const parserPerfetto = getParser(TraceType.PROTO_LOG);
+      await tracePipeline.convertLegacyTracesToPerfetto();
+      expect(converterSpy).toHaveBeenCalledOnceWith(
+        [parserSf],
+        [parserSf, parserPerfetto],
+        new TraceFile(perfettoFile),
+      );
+      expect(tracePipeline.getTraces().getSize()).toEqual(2);
+      checkSfTraceIsPerfetto();
+    });
+
+    it('with multiple legacy traces', async () => {
+      await loadFiles([validWmFile]);
+      const parserWm = getParser(TraceType.WINDOW_MANAGER);
+      await tracePipeline.convertLegacyTracesToPerfetto();
+      expect(converterSpy).toHaveBeenCalledOnceWith(
+        [parserSf, parserWm],
+        [parserSf, parserWm],
+        undefined,
+      );
+      expect(tracePipeline.getTraces().getSize()).toEqual(2);
+      checkSfTraceIsPerfetto();
+    });
+
+    function checkSfTraceIsPerfetto() {
+      const traces = tracePipeline.getTraces();
+      const trace = traces.getTrace(TraceType.SURFACE_FLINGER);
+      expect(trace?.isPerfetto()).toBeTrue();
+    }
+
+    function getParser(type: TraceType): Parser<{}> {
+      return assertDefined(
+        tracePipeline.getTraces().getTrace(type)?.getParser(),
+      );
+    }
+  });
+
   async function loadFiles(
     files: File[],
     source: FilesSource = FilesSource.TEST,
@@ -502,6 +649,7 @@ describe('TracePipeline', () => {
     expectedWarnings: UserWarning[],
   ) {
     userNotifierChecker.expectAdded(expectedWarnings);
+    userNotifierChecker.reset();
     expect(tracePipeline.getTraces().getSize()).toEqual(numberOfTraces);
   }
 
diff --git a/tools/winscope/src/app/trace_search/search_view_factory_transitions.ts b/tools/winscope/src/app/trace_search/search_view_factory_transitions.ts
index 331f45c10..122805781 100644
--- a/tools/winscope/src/app/trace_search/search_view_factory_transitions.ts
+++ b/tools/winscope/src/app/trace_search/search_view_factory_transitions.ts
@@ -74,7 +74,7 @@ ORDER BY PROPS.transition_id, PROPS.property`,
           PROTOS.transition_id,
           PROTOS.base64_proto_id
         FROM __intrinsic_window_manager_shell_transition_protos PROTOS
-        LEFT JOIN transitions_with_updated_ts TRANS
+        LEFT JOIN window_manager_shell_transitions TRANS
           ON TRANS.transition_id = PROTOS.transition_id;
     `;
     await this.traceProcessor.query(sqlCreateTableWithTimestamps);
diff --git a/tools/winscope/src/app/trace_search/trace_search_initializer.ts b/tools/winscope/src/app/trace_search/trace_search_initializer.ts
index 6b93f7856..a51ce03dc 100644
--- a/tools/winscope/src/app/trace_search/trace_search_initializer.ts
+++ b/tools/winscope/src/app/trace_search/trace_search_initializer.ts
@@ -34,7 +34,7 @@ export class TraceSearchInitializer {
   ];
 
   static async createSearchViews(traces: Traces): Promise<string[]> {
-    const traceProcessor = await TraceProcessorFactory.getSingleInstance();
+    const traceProcessor = TraceProcessorFactory.getSingleInstance();
 
     const searchViews: string[] = [];
     for (const FactoryType of TraceSearchInitializer.FACTORIES) {
diff --git a/tools/winscope/src/app/trace_search/trace_search_initializer_test.ts b/tools/winscope/src/app/trace_search/trace_search_initializer_test.ts
index 12b098dd1..c58ce3eb0 100644
--- a/tools/winscope/src/app/trace_search/trace_search_initializer_test.ts
+++ b/tools/winscope/src/app/trace_search/trace_search_initializer_test.ts
@@ -15,11 +15,12 @@
  */
 
 import {assertDefined} from 'common/assert_utils';
-import {UnitTestUtils} from 'test/unit/utils';
+import {getPerfettoParser} from 'test/unit/fixture_utils';
 import {Parser} from 'trace/parser';
 import {Trace} from 'trace/trace';
 import {Traces} from 'trace/traces';
 import {TraceType} from 'trace/trace_type';
+import {runQueryAndGetResult} from 'trace_processor/test_utils';
 import {SEARCH_VIEWS, TraceSearchInitializer} from './trace_search_initializer';
 
 describe('TraceSearchInitializer', () => {
@@ -29,7 +30,7 @@ describe('TraceSearchInitializer', () => {
   });
 
   it('initializes surface flinger', async () => {
-    const parser = await UnitTestUtils.getPerfettoParser(
+    const parser = await getPerfettoParser(
       TraceType.SURFACE_FLINGER,
       'traces/perfetto/layers_trace.perfetto-trace',
     );
@@ -37,7 +38,7 @@ describe('TraceSearchInitializer', () => {
       'sf_layer_search',
       'sf_hierarchy_root_search',
     ]);
-    const queryResult = await UnitTestUtils.runQueryAndGetResult(`
+    const queryResult = await runQueryAndGetResult(`
       SELECT * FROM sf_layer_search
         WHERE layer_name LIKE 'Task%'
         AND property='flags'
@@ -45,7 +46,7 @@ describe('TraceSearchInitializer', () => {
     `);
     expect(queryResult.numRows()).toEqual(2);
 
-    const queryResultEntry = await UnitTestUtils.runQueryAndGetResult(`
+    const queryResultEntry = await runQueryAndGetResult(`
       SELECT * FROM sf_hierarchy_root_search
         WHERE property LIKE 'displays[1]%'
         AND (
@@ -57,19 +58,19 @@ describe('TraceSearchInitializer', () => {
   });
 
   it('initializes transactions', async () => {
-    const parser = await UnitTestUtils.getPerfettoParser(
+    const parser = await getPerfettoParser(
       TraceType.TRANSACTIONS,
       'traces/perfetto/transactions_trace.perfetto-trace',
     );
     await createViewsAndTestExamples(parser, ['transactions_search']);
-    const queryResultTransaction = await UnitTestUtils.runQueryAndGetResult(`
+    const queryResultTransaction = await runQueryAndGetResult(`
       SELECT * FROM transactions_search
         WHERE flat_property='transactions.layer_changes.x'
         AND value!='0.0'
     `);
     expect(queryResultTransaction.numRows()).toEqual(3);
 
-    const queryResultAddedLayer = await UnitTestUtils.runQueryAndGetResult(`
+    const queryResultAddedLayer = await runQueryAndGetResult(`
       SELECT * FROM transactions_search
         WHERE flat_property='added_layers.name'
         AND value='ImeContainer'
@@ -78,24 +79,24 @@ describe('TraceSearchInitializer', () => {
   });
 
   it('initializes protolog', async () => {
-    const parser = await UnitTestUtils.getPerfettoParser(
+    const parser = await getPerfettoParser(
       TraceType.PROTO_LOG,
       'traces/perfetto/protolog.perfetto-trace',
     );
     await createViewsAndTestExamples(parser, ['protolog']);
-    const queryResult = await UnitTestUtils.runQueryAndGetResult(`
+    const queryResult = await runQueryAndGetResult(`
       SELECT * FROM protolog WHERE message LIKE '%string%'
     `);
     expect(queryResult.numRows()).toEqual(2);
   });
 
   it('initializes transitions', async () => {
-    const parser = await UnitTestUtils.getPerfettoParser(
+    const parser = await getPerfettoParser(
       TraceType.TRANSITION,
       'traces/perfetto/shell_transitions_trace.perfetto-trace',
     );
     await createViewsAndTestExamples(parser, ['transitions_search']);
-    const queryResult = await UnitTestUtils.runQueryAndGetResult(`
+    const queryResult = await runQueryAndGetResult(`
       SELECT * FROM transitions_search
         WHERE flat_property='handler'
         AND value LIKE '%DefaultMixedHandler'
@@ -104,12 +105,12 @@ describe('TraceSearchInitializer', () => {
   });
 
   it('initializes view capture', async () => {
-    const parser = await UnitTestUtils.getPerfettoParser(
+    const parser = await getPerfettoParser(
       TraceType.VIEW_CAPTURE,
       'traces/perfetto/viewcapture.perfetto-trace',
     );
     await createViewsAndTestExamples(parser, ['viewcapture_search']);
-    const queryResult = await UnitTestUtils.runQueryAndGetResult(`
+    const queryResult = await runQueryAndGetResult(`
       SELECT * FROM viewcapture_search
         WHERE class_name LIKE '%SearchContainerView'
         AND flat_property='translation_y'
@@ -133,7 +134,7 @@ describe('TraceSearchInitializer', () => {
       );
       for (const example of view.examples) {
         await expectAsync(
-          UnitTestUtils.runQueryAndGetResult(example.query),
+          runQueryAndGetResult(example.query),
         ).not.toBeRejected();
       }
     }
diff --git a/tools/winscope/src/common/array_utils.ts b/tools/winscope/src/common/array_utils.ts
index 00b56d12f..cb98538aa 100644
--- a/tools/winscope/src/common/array_utils.ts
+++ b/tools/winscope/src/common/array_utils.ts
@@ -27,185 +27,183 @@ type TypedArray =
 /**
  * Utility functions for working with arrays.
  */
-export class ArrayUtils {
-  /**
-   * Checks if two arrays are equal.
-   *
-   * @param a The first array.
-   * @param b The second array.
-   * @param predicate A function that takes two elements and returns true if they are equal. Defaults to strict equality.
-   *  True if the arrays are equal, false otherwise.
-   */
-  static equal<T>(
-    a: T[] | TypedArray,
-    b: T[] | TypedArray,
-    predicate: (a: T | number, b: T | number) => boolean = (a, b) => a === b,
-  ): boolean {
-    if (a.length !== b.length) {
+/**
+ * Checks if two arrays are equal.
+ *
+ * @param a The first array.
+ * @param b The second array.
+ * @param predicate A function that takes two elements and returns true if they are equal. Defaults to strict equality.
+ *  True if the arrays are equal, false otherwise.
+ */
+export function equal<T>(
+  a: T[] | TypedArray,
+  b: T[] | TypedArray,
+  predicate: (a: T | number, b: T | number) => boolean = (a, b) => a === b,
+): boolean {
+  if (a.length !== b.length) {
+    return false;
+  }
+
+  for (let i = 0; i < a.length; i++) {
+    if (!predicate(a[i], b[i])) {
       return false;
     }
+  }
 
-    for (let i = 0; i < a.length; i++) {
-      if (!predicate(a[i], b[i])) {
-        return false;
+  return true;
+}
+
+/**
+ * Searches for a subarray within an array.
+ *
+ * @param array The array to search in.
+ * @param subarray The subarray to search for.
+ * @return The index of the first occurrence of the subarray, or undefined if it is not found.
+ */
+export function searchSubarray<T>(
+  array: T[] | TypedArray,
+  subarray: T[] | TypedArray,
+): number | undefined {
+  for (let i = 0; i + subarray.length <= array.length; ++i) {
+    let match = true;
+
+    for (let j = 0; j < subarray.length; ++j) {
+      if (array[i + j] !== subarray[j]) {
+        match = false;
+        break;
       }
     }
 
-    return true;
+    if (match) {
+      return i;
+    }
   }
 
-  /**
-   * Searches for a subarray within an array.
-   *
-   * @param array The array to search in.
-   * @param subarray The subarray to search for.
-   * @return The index of the first occurrence of the subarray, or undefined if it is not found.
-   */
-  static searchSubarray<T>(
-    array: T[] | TypedArray,
-    subarray: T[] | TypedArray,
-  ): number | undefined {
-    for (let i = 0; i + subarray.length <= array.length; ++i) {
-      let match = true;
-
-      for (let j = 0; j < subarray.length; ++j) {
-        if (array[i + j] !== subarray[j]) {
-          match = false;
-          break;
-        }
-      }
-
-      if (match) {
-        return i;
-      }
-    }
+  return undefined;
+}
 
+/**
+ * Performs a binary search to find the first element in the array that is greater than or equal to the target value.
+ *
+ * @param values The array to search in.
+ * @param target The value to search for.
+ * @return The index of the first element that is greater than or equal to the target value, or undefined if no such element exists.
+ */
+export function binarySearchFirstGreaterOrEqual<T>(
+  values: T[] | TypedArray,
+  target: T,
+): number | undefined {
+  if (values.length === 0) {
     return undefined;
   }
 
-  /**
-   * Performs a binary search to find the first element in the array that is greater than or equal to the target value.
-   *
-   * @param values The array to search in.
-   * @param target The value to search for.
-   * @return The index of the first element that is greater than or equal to the target value, or undefined if no such element exists.
-   */
-  static binarySearchFirstGreaterOrEqual<T>(
-    values: T[] | TypedArray,
-    target: T,
-  ): number | undefined {
-    if (values.length === 0) {
-      return undefined;
-    }
-
-    let low = 0;
-    let high = values.length - 1;
+  let low = 0;
+  let high = values.length - 1;
 
-    let result: number | undefined = undefined;
+  let result: number | undefined = undefined;
 
-    while (low <= high) {
-      const mid = (low + high) >> 1;
+  while (low <= high) {
+    const mid = (low + high) >> 1;
 
-      if (values[mid] < target) {
-        low = mid + 1;
-      } else if (values[mid] > target) {
-        if (result === undefined || result > mid) {
-          result = mid;
-        }
-        high = mid - 1;
-      } else {
+    if (values[mid] < target) {
+      low = mid + 1;
+    } else if (values[mid] > target) {
+      if (result === undefined || result > mid) {
         result = mid;
-        high = mid - 1;
       }
+      high = mid - 1;
+    } else {
+      result = mid;
+      high = mid - 1;
     }
-
-    return result;
   }
 
-  /**
-   * Performs a binary search to find the first element in the array that is greater than the target value.
-   *
-   * @param values The array to search in.
-   * @param target The value to search for.
-   * @return The index of the first element that is greater than the target value, or undefined if no such element exists.
-   */
-  static binarySearchFirstGreater<T>(
-    values: T[] | TypedArray,
-    target: T,
-  ): number | undefined {
-    if (values.length === 0) {
-      return undefined;
-    }
+  return result;
+}
+
+/**
+ * Performs a binary search to find the first element in the array that is greater than the target value.
+ *
+ * @param values The array to search in.
+ * @param target The value to search for.
+ * @return The index of the first element that is greater than the target value, or undefined if no such element exists.
+ */
+export function binarySearchFirstGreater<T>(
+  values: T[] | TypedArray,
+  target: T,
+): number | undefined {
+  if (values.length === 0) {
+    return undefined;
+  }
 
-    let low = 0;
-    let high = values.length - 1;
+  let low = 0;
+  let high = values.length - 1;
 
-    let result: number | undefined = undefined;
+  let result: number | undefined = undefined;
 
-    while (low <= high) {
-      const mid = (low + high) >> 1;
+  while (low <= high) {
+    const mid = (low + high) >> 1;
 
-      if (values[mid] < target) {
-        low = mid + 1;
-      } else if (values[mid] > target) {
-        if (result === undefined || result > mid) {
-          result = mid;
-        }
-        high = mid - 1;
-      } else {
-        low = mid + 1;
+    if (values[mid] < target) {
+      low = mid + 1;
+    } else if (values[mid] > target) {
+      if (result === undefined || result > mid) {
+        result = mid;
       }
+      high = mid - 1;
+    } else {
+      low = mid + 1;
     }
-
-    return result;
   }
 
-  /**
-   * Converts an array of bytes to a bigint in little-endian order.
-   *
-   * @param buffer The array of bytes to convert.
-   * @param start The starting index of the bytes to convert.
-   * @param end The ending index of the bytes to convert.
-   * @return The bigint representation of the bytes in little-endian order.
-   */
-  static toUintLittleEndian(
-    buffer: Uint8Array,
-    start: number,
-    end: number,
-  ): bigint {
-    let result = 0n;
-    for (let i = end - 1; i >= start; --i) {
-      result *= 256n;
-      result += BigInt(buffer[i]);
-    }
-    return result;
-  }
+  return result;
+}
 
-  /**
-   * Converts an array of bytes to a bigint in little-endian order, treating the bytes as a signed integer.
-   *
-   * @param buffer The array of bytes to convert.
-   * @param start The starting index of the bytes to convert.
-   * @param end The ending index of the bytes to convert.
-   * @return The bigint representation of the bytes in little-endian order, treating the bytes as a signed integer.
-   */
-  static toIntLittleEndian(
-    buffer: Uint8Array,
-    start: number,
-    end: number,
-  ): bigint {
-    const numOfBits = BigInt(Math.max(0, 8 * (end - start)));
-    if (numOfBits <= 0n) {
-      return 0n;
-    }
+/**
+ * Converts an array of bytes to a bigint in little-endian order.
+ *
+ * @param buffer The array of bytes to convert.
+ * @param start The starting index of the bytes to convert.
+ * @param end The ending index of the bytes to convert.
+ * @return The bigint representation of the bytes in little-endian order.
+ */
+export function toUintLittleEndian(
+  buffer: Uint8Array,
+  start: number,
+  end: number,
+): bigint {
+  let result = 0n;
+  for (let i = end - 1; i >= start; --i) {
+    result *= 256n;
+    result += BigInt(buffer[i]);
+  }
+  return result;
+}
 
-    let result = ArrayUtils.toUintLittleEndian(buffer, start, end);
-    const maxSignedValue = 2n ** (numOfBits - 1n) - 1n;
-    if (result > maxSignedValue) {
-      const valuesRange = 2n ** numOfBits;
-      result -= valuesRange;
-    }
+/**
+ * Converts an array of bytes to a bigint in little-endian order, treating the bytes as a signed integer.
+ *
+ * @param buffer The array of bytes to convert.
+ * @param start The starting index of the bytes to convert.
+ * @param end The ending index of the bytes to convert.
+ * @return The bigint representation of the bytes in little-endian order, treating the bytes as a signed integer.
+ */
+export function toIntLittleEndian(
+  buffer: Uint8Array,
+  start: number,
+  end: number,
+): bigint {
+  const numOfBits = BigInt(Math.max(0, 8 * (end - start)));
+  if (numOfBits <= 0n) {
+    return 0n;
+  }
 
-    return result;
+  let result = toUintLittleEndian(buffer, start, end);
+  const maxSignedValue = 2n ** (numOfBits - 1n) - 1n;
+  if (result > maxSignedValue) {
+    const valuesRange = 2n ** numOfBits;
+    result -= valuesRange;
   }
+
+  return result;
 }
diff --git a/tools/winscope/src/common/array_utils_test.ts b/tools/winscope/src/common/array_utils_test.ts
index 8451db3e9..d3bc5e937 100644
--- a/tools/winscope/src/common/array_utils_test.ts
+++ b/tools/winscope/src/common/array_utils_test.ts
@@ -14,68 +14,63 @@
  * limitations under the License.
  */
 
-import {ArrayUtils} from './array_utils';
+import {
+  binarySearchFirstGreater,
+  binarySearchFirstGreaterOrEqual,
+  equal,
+  searchSubarray,
+  toIntLittleEndian,
+  toUintLittleEndian,
+} from './array_utils';
 
 describe('ArrayUtils', () => {
   it('equal', () => {
-    expect(ArrayUtils.equal([], [1])).toBeFalse();
-    expect(ArrayUtils.equal([1], [])).toBeFalse();
+    expect(equal([], [1])).toBeFalse();
+    expect(equal([1], [])).toBeFalse();
 
-    expect(ArrayUtils.equal([], [])).toBeTrue();
-    expect(ArrayUtils.equal([undefined], [undefined])).toBeTrue();
-    expect(ArrayUtils.equal([1, 2, 3], [1, 2, 3])).toBeTrue();
+    expect(equal([], [])).toBeTrue();
+    expect(equal([undefined], [undefined])).toBeTrue();
+    expect(equal([1, 2, 3], [1, 2, 3])).toBeTrue();
 
-    expect(ArrayUtils.equal([], new Uint8Array(1))).toBeFalse();
-    expect(ArrayUtils.equal([1], new Uint8Array(1))).toBeFalse();
+    expect(equal([], new Uint8Array(1))).toBeFalse();
+    expect(equal([1], new Uint8Array(1))).toBeFalse();
 
-    expect(ArrayUtils.equal([], new Uint8Array(0))).toBeTrue();
-    expect(ArrayUtils.equal([1, 2, 3], new Uint8Array([1, 2, 3]))).toBeTrue();
+    expect(equal([], new Uint8Array(0))).toBeTrue();
+    expect(equal([1, 2, 3], new Uint8Array([1, 2, 3]))).toBeTrue();
 
-    expect(
-      ArrayUtils.equal(new Uint8Array([]), new Uint8Array([1])),
-    ).toBeFalse();
-    expect(
-      ArrayUtils.equal(new Uint8Array([1]), new Uint8Array([])),
-    ).toBeFalse();
+    expect(equal(new Uint8Array([]), new Uint8Array([1]))).toBeFalse();
+    expect(equal(new Uint8Array([1]), new Uint8Array([]))).toBeFalse();
 
-    expect(ArrayUtils.equal(new Uint8Array([]), new Uint8Array([]))).toBeTrue();
+    expect(equal(new Uint8Array([]), new Uint8Array([]))).toBeTrue();
     expect(
-      ArrayUtils.equal(new Uint8Array([1, 2, 3]), new Uint8Array([1, 2, 3])),
+      equal(new Uint8Array([1, 2, 3]), new Uint8Array([1, 2, 3])),
     ).toBeTrue();
   });
 
   it('equal with predicate', () => {
     const predicate = (a: number, b: number) => a !== b;
-    expect(ArrayUtils.equal([], [1], predicate)).toBeFalse();
-    expect(ArrayUtils.equal([1], [], predicate)).toBeFalse();
+    expect(equal([], [1], predicate)).toBeFalse();
+    expect(equal([1], [], predicate)).toBeFalse();
 
-    expect(ArrayUtils.equal([], [], predicate)).toBeTrue();
-    expect(ArrayUtils.equal([1, 2, 3], [1, 2, 3], predicate)).toBeFalse();
+    expect(equal([], [], predicate)).toBeTrue();
+    expect(equal([1, 2, 3], [1, 2, 3], predicate)).toBeFalse();
 
-    expect(ArrayUtils.equal([], new Uint8Array(1), predicate)).toBeFalse();
-    expect(ArrayUtils.equal([1], new Uint8Array(1), predicate)).toBeTrue();
+    expect(equal([], new Uint8Array(1), predicate)).toBeFalse();
+    expect(equal([1], new Uint8Array(1), predicate)).toBeTrue();
 
-    expect(ArrayUtils.equal([], new Uint8Array(0), predicate)).toBeTrue();
-    expect(
-      ArrayUtils.equal([1, 2, 3], new Uint8Array([1, 2, 3]), predicate),
-    ).toBeFalse();
+    expect(equal([], new Uint8Array(0), predicate)).toBeTrue();
+    expect(equal([1, 2, 3], new Uint8Array([1, 2, 3]), predicate)).toBeFalse();
 
     expect(
-      ArrayUtils.equal(new Uint8Array([]), new Uint8Array([1]), predicate),
+      equal(new Uint8Array([]), new Uint8Array([1]), predicate),
     ).toBeFalse();
     expect(
-      ArrayUtils.equal(new Uint8Array([1]), new Uint8Array([]), predicate),
+      equal(new Uint8Array([1]), new Uint8Array([]), predicate),
     ).toBeFalse();
 
+    expect(equal(new Uint8Array([]), new Uint8Array([]), predicate)).toBeTrue();
     expect(
-      ArrayUtils.equal(new Uint8Array([]), new Uint8Array([]), predicate),
-    ).toBeTrue();
-    expect(
-      ArrayUtils.equal(
-        new Uint8Array([1, 2, 3]),
-        new Uint8Array([1, 2, 3]),
-        predicate,
-      ),
+      equal(new Uint8Array([1, 2, 3]), new Uint8Array([1, 2, 3]), predicate),
     ).toBeFalse();
 
     const predicateWithNonNumberType = (
@@ -83,158 +78,122 @@ describe('ArrayUtils', () => {
       b: number | undefined,
     ) => a !== b;
     expect(
-      ArrayUtils.equal([undefined], [undefined], predicateWithNonNumberType),
+      equal([undefined], [undefined], predicateWithNonNumberType),
     ).toBeFalse();
   });
 
   it('searchSubarray', () => {
-    expect(ArrayUtils.searchSubarray([], [0])).toEqual(undefined);
-    expect(ArrayUtils.searchSubarray([], [])).toEqual(0);
-    expect(ArrayUtils.searchSubarray([0], [])).toEqual(0);
-
-    expect(ArrayUtils.searchSubarray([0, 1, 2], [-1])).toEqual(undefined);
-    expect(ArrayUtils.searchSubarray([0, 1, 2], [])).toEqual(0);
-    expect(ArrayUtils.searchSubarray([0, 1, 2], [0])).toEqual(0);
-    expect(ArrayUtils.searchSubarray([0, 1, 2], [1])).toEqual(1);
-    expect(ArrayUtils.searchSubarray([0, 1, 2], [2])).toEqual(2);
-
-    expect(ArrayUtils.searchSubarray([0, 1, 2], [0, 1])).toEqual(0);
-    expect(ArrayUtils.searchSubarray([0, 1, 2], [1, 2])).toEqual(1);
-    expect(ArrayUtils.searchSubarray([0, 1, 2], [2])).toEqual(2);
-    expect(ArrayUtils.searchSubarray([0, 1, 2], [2, 3])).toEqual(undefined);
+    expect(searchSubarray([], [0])).toEqual(undefined);
+    expect(searchSubarray([], [])).toEqual(0);
+    expect(searchSubarray([0], [])).toEqual(0);
+
+    expect(searchSubarray([0, 1, 2], [-1])).toEqual(undefined);
+    expect(searchSubarray([0, 1, 2], [])).toEqual(0);
+    expect(searchSubarray([0, 1, 2], [0])).toEqual(0);
+    expect(searchSubarray([0, 1, 2], [1])).toEqual(1);
+    expect(searchSubarray([0, 1, 2], [2])).toEqual(2);
+
+    expect(searchSubarray([0, 1, 2], [0, 1])).toEqual(0);
+    expect(searchSubarray([0, 1, 2], [1, 2])).toEqual(1);
+    expect(searchSubarray([0, 1, 2], [2])).toEqual(2);
+    expect(searchSubarray([0, 1, 2], [2, 3])).toEqual(undefined);
   });
 
   it('binarySearchFirstGreaterOrEqual', () => {
     // no match
-    expect(ArrayUtils.binarySearchFirstGreaterOrEqual([], 9)).toBeUndefined();
-    expect(ArrayUtils.binarySearchFirstGreaterOrEqual([8], 9)).toBeUndefined();
-    expect(
-      ArrayUtils.binarySearchFirstGreaterOrEqual([7, 8], 9),
-    ).toBeUndefined();
-    expect(
-      ArrayUtils.binarySearchFirstGreaterOrEqual([6, 7, 8], 9),
-    ).toBeUndefined();
+    expect(binarySearchFirstGreaterOrEqual([], 9)).toBeUndefined();
+    expect(binarySearchFirstGreaterOrEqual([8], 9)).toBeUndefined();
+    expect(binarySearchFirstGreaterOrEqual([7, 8], 9)).toBeUndefined();
+    expect(binarySearchFirstGreaterOrEqual([6, 7, 8], 9)).toBeUndefined();
 
     // match (greater)
-    expect(ArrayUtils.binarySearchFirstGreaterOrEqual([6], 5)).toEqual(0);
-    expect(ArrayUtils.binarySearchFirstGreaterOrEqual([6, 7], 5)).toEqual(0);
-    expect(ArrayUtils.binarySearchFirstGreaterOrEqual([4, 6], 5)).toEqual(1);
-    expect(ArrayUtils.binarySearchFirstGreaterOrEqual([4, 6, 7, 8], 5)).toEqual(
-      1,
-    );
-    expect(
-      ArrayUtils.binarySearchFirstGreaterOrEqual([3, 4, 6, 7, 8], 5),
-    ).toEqual(2);
+    expect(binarySearchFirstGreaterOrEqual([6], 5)).toEqual(0);
+    expect(binarySearchFirstGreaterOrEqual([6, 7], 5)).toEqual(0);
+    expect(binarySearchFirstGreaterOrEqual([4, 6], 5)).toEqual(1);
+    expect(binarySearchFirstGreaterOrEqual([4, 6, 7, 8], 5)).toEqual(1);
+    expect(binarySearchFirstGreaterOrEqual([3, 4, 6, 7, 8], 5)).toEqual(2);
 
     // match (equal)
-    expect(ArrayUtils.binarySearchFirstGreaterOrEqual([5], 5)).toEqual(0);
-    expect(ArrayUtils.binarySearchFirstGreaterOrEqual([5, 6], 5)).toEqual(0);
-    expect(ArrayUtils.binarySearchFirstGreaterOrEqual([4, 5], 5)).toEqual(1);
-    expect(ArrayUtils.binarySearchFirstGreaterOrEqual([3, 4, 5], 5)).toEqual(2);
-    expect(ArrayUtils.binarySearchFirstGreaterOrEqual([3, 4, 5, 6], 5)).toEqual(
-      2,
-    );
-    expect(
-      ArrayUtils.binarySearchFirstGreaterOrEqual([3, 4, 5, 6, 7], 5),
-    ).toEqual(2);
+    expect(binarySearchFirstGreaterOrEqual([5], 5)).toEqual(0);
+    expect(binarySearchFirstGreaterOrEqual([5, 6], 5)).toEqual(0);
+    expect(binarySearchFirstGreaterOrEqual([4, 5], 5)).toEqual(1);
+    expect(binarySearchFirstGreaterOrEqual([3, 4, 5], 5)).toEqual(2);
+    expect(binarySearchFirstGreaterOrEqual([3, 4, 5, 6], 5)).toEqual(2);
+    expect(binarySearchFirstGreaterOrEqual([3, 4, 5, 6, 7], 5)).toEqual(2);
 
     // match (equal with repeated values)
-    expect(ArrayUtils.binarySearchFirstGreaterOrEqual([5, 5], 5)).toEqual(0);
-    expect(ArrayUtils.binarySearchFirstGreaterOrEqual([5, 5, 5], 5)).toEqual(0);
-    expect(ArrayUtils.binarySearchFirstGreaterOrEqual([5, 5, 5, 5], 5)).toEqual(
-      0,
-    );
-    expect(ArrayUtils.binarySearchFirstGreaterOrEqual([4, 5, 5, 6], 5)).toEqual(
-      1,
-    );
-    expect(
-      ArrayUtils.binarySearchFirstGreaterOrEqual([4, 4, 5, 5, 5, 6], 5),
-    ).toEqual(2);
+    expect(binarySearchFirstGreaterOrEqual([5, 5], 5)).toEqual(0);
+    expect(binarySearchFirstGreaterOrEqual([5, 5, 5], 5)).toEqual(0);
+    expect(binarySearchFirstGreaterOrEqual([5, 5, 5, 5], 5)).toEqual(0);
+    expect(binarySearchFirstGreaterOrEqual([4, 5, 5, 6], 5)).toEqual(1);
+    expect(binarySearchFirstGreaterOrEqual([4, 4, 5, 5, 5, 6], 5)).toEqual(2);
     expect(
-      ArrayUtils.binarySearchFirstGreaterOrEqual([4, 4, 4, 5, 5, 5, 5, 6], 5),
+      binarySearchFirstGreaterOrEqual([4, 4, 4, 5, 5, 5, 5, 6], 5),
     ).toEqual(3);
   });
 
   it('binarySearchFirstGreater', () => {
     // no match
-    expect(ArrayUtils.binarySearchFirstGreater([], 9)).toBeUndefined();
-    expect(ArrayUtils.binarySearchFirstGreater([8], 9)).toBeUndefined();
-    expect(ArrayUtils.binarySearchFirstGreater([7, 8], 9)).toBeUndefined();
-    expect(ArrayUtils.binarySearchFirstGreater([6, 7, 8], 9)).toBeUndefined();
+    expect(binarySearchFirstGreater([], 9)).toBeUndefined();
+    expect(binarySearchFirstGreater([8], 9)).toBeUndefined();
+    expect(binarySearchFirstGreater([7, 8], 9)).toBeUndefined();
+    expect(binarySearchFirstGreater([6, 7, 8], 9)).toBeUndefined();
 
     // match
-    expect(ArrayUtils.binarySearchFirstGreater([6], 5)).toEqual(0);
-    expect(ArrayUtils.binarySearchFirstGreater([6, 7], 5)).toEqual(0);
-    expect(ArrayUtils.binarySearchFirstGreater([4, 6], 5)).toEqual(1);
-    expect(ArrayUtils.binarySearchFirstGreater([4, 6, 7, 8], 5)).toEqual(1);
-    expect(ArrayUtils.binarySearchFirstGreater([3, 4, 6, 7, 8], 5)).toEqual(2);
+    expect(binarySearchFirstGreater([6], 5)).toEqual(0);
+    expect(binarySearchFirstGreater([6, 7], 5)).toEqual(0);
+    expect(binarySearchFirstGreater([4, 6], 5)).toEqual(1);
+    expect(binarySearchFirstGreater([4, 6, 7, 8], 5)).toEqual(1);
+    expect(binarySearchFirstGreater([3, 4, 6, 7, 8], 5)).toEqual(2);
 
     // match (ignore equal)
-    expect(ArrayUtils.binarySearchFirstGreater([5], 5)).toEqual(undefined);
-    expect(ArrayUtils.binarySearchFirstGreater([5, 6], 5)).toEqual(1);
-    expect(ArrayUtils.binarySearchFirstGreater([4, 5, 6], 5)).toEqual(2);
-    expect(ArrayUtils.binarySearchFirstGreater([3, 4, 5, 6], 5)).toEqual(3);
-    expect(ArrayUtils.binarySearchFirstGreater([3, 4, 5, 6, 7], 5)).toEqual(3);
+    expect(binarySearchFirstGreater([5], 5)).toEqual(undefined);
+    expect(binarySearchFirstGreater([5, 6], 5)).toEqual(1);
+    expect(binarySearchFirstGreater([4, 5, 6], 5)).toEqual(2);
+    expect(binarySearchFirstGreater([3, 4, 5, 6], 5)).toEqual(3);
+    expect(binarySearchFirstGreater([3, 4, 5, 6, 7], 5)).toEqual(3);
 
     // match (with repeated values)
-    expect(ArrayUtils.binarySearchFirstGreater([6, 6], 5)).toEqual(0);
-    expect(ArrayUtils.binarySearchFirstGreater([6, 6, 6], 5)).toEqual(0);
-    expect(ArrayUtils.binarySearchFirstGreater([6, 6, 6, 6], 5)).toEqual(0);
-    expect(ArrayUtils.binarySearchFirstGreater([5, 6, 6, 7], 5)).toEqual(1);
-    expect(ArrayUtils.binarySearchFirstGreater([5, 5, 6, 6, 6, 7], 5)).toEqual(
-      2,
-    );
-    expect(
-      ArrayUtils.binarySearchFirstGreater([5, 5, 5, 6, 6, 6, 6, 7], 5),
-    ).toEqual(3);
+    expect(binarySearchFirstGreater([6, 6], 5)).toEqual(0);
+    expect(binarySearchFirstGreater([6, 6, 6], 5)).toEqual(0);
+    expect(binarySearchFirstGreater([6, 6, 6, 6], 5)).toEqual(0);
+    expect(binarySearchFirstGreater([5, 6, 6, 7], 5)).toEqual(1);
+    expect(binarySearchFirstGreater([5, 5, 6, 6, 6, 7], 5)).toEqual(2);
+    expect(binarySearchFirstGreater([5, 5, 5, 6, 6, 6, 6, 7], 5)).toEqual(3);
   });
 
   it('toUintLittleEndian', () => {
     const buffer = new Uint8Array([0, 0, 1, 1]);
 
-    expect(
-      ArrayUtils.toUintLittleEndian(new Uint8Array([0xff, 0xff]), 0, -1),
-    ).toEqual(0n);
-    expect(
-      ArrayUtils.toUintLittleEndian(new Uint8Array([0xff, 0xff]), 0, 0),
-    ).toEqual(0n);
-    expect(
-      ArrayUtils.toUintLittleEndian(new Uint8Array([0xff, 0xff]), 1, 1),
-    ).toEqual(0n);
+    expect(toUintLittleEndian(new Uint8Array([0xff, 0xff]), 0, -1)).toEqual(0n);
+    expect(toUintLittleEndian(new Uint8Array([0xff, 0xff]), 0, 0)).toEqual(0n);
+    expect(toUintLittleEndian(new Uint8Array([0xff, 0xff]), 1, 1)).toEqual(0n);
 
     expect(
-      ArrayUtils.toUintLittleEndian(new Uint8Array([0x00, 0x01, 0xff]), 0, 1),
+      toUintLittleEndian(new Uint8Array([0x00, 0x01, 0xff]), 0, 1),
     ).toEqual(0n);
     expect(
-      ArrayUtils.toUintLittleEndian(new Uint8Array([0x00, 0x01, 0xff]), 1, 2),
+      toUintLittleEndian(new Uint8Array([0x00, 0x01, 0xff]), 1, 2),
     ).toEqual(1n);
     expect(
-      ArrayUtils.toUintLittleEndian(new Uint8Array([0x00, 0x01, 0xff]), 2, 3),
+      toUintLittleEndian(new Uint8Array([0x00, 0x01, 0xff]), 2, 3),
     ).toEqual(255n);
 
-    expect(
-      ArrayUtils.toUintLittleEndian(new Uint8Array([0x00, 0x00]), 0, 2),
-    ).toEqual(0n);
-    expect(
-      ArrayUtils.toUintLittleEndian(new Uint8Array([0x01, 0x00]), 0, 2),
-    ).toEqual(1n);
-    expect(
-      ArrayUtils.toUintLittleEndian(new Uint8Array([0x00, 0x01]), 0, 2),
-    ).toEqual(256n);
-    expect(
-      ArrayUtils.toUintLittleEndian(new Uint8Array([0xff, 0xff]), 0, 2),
-    ).toEqual(0xffffn);
+    expect(toUintLittleEndian(new Uint8Array([0x00, 0x00]), 0, 2)).toEqual(0n);
+    expect(toUintLittleEndian(new Uint8Array([0x01, 0x00]), 0, 2)).toEqual(1n);
+    expect(toUintLittleEndian(new Uint8Array([0x00, 0x01]), 0, 2)).toEqual(
+      256n,
+    );
+    expect(toUintLittleEndian(new Uint8Array([0xff, 0xff]), 0, 2)).toEqual(
+      0xffffn,
+    );
 
     expect(
-      ArrayUtils.toUintLittleEndian(
-        new Uint8Array([0xff, 0xff, 0xff, 0xff]),
-        0,
-        4,
-      ),
+      toUintLittleEndian(new Uint8Array([0xff, 0xff, 0xff, 0xff]), 0, 4),
     ).toEqual(0xffffffffn);
 
     expect(
-      ArrayUtils.toUintLittleEndian(
+      toUintLittleEndian(
         new Uint8Array([0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]),
         0,
         8,
@@ -242,7 +201,7 @@ describe('ArrayUtils', () => {
     ).toEqual(0xffffffffffffffffn);
 
     expect(
-      ArrayUtils.toUintLittleEndian(
+      toUintLittleEndian(
         new Uint8Array([0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]),
         0,
         9,
@@ -251,94 +210,62 @@ describe('ArrayUtils', () => {
   });
 
   it('toIntLittleEndian', () => {
-    expect(ArrayUtils.toIntLittleEndian(new Uint8Array([0xff]), 0, -1)).toEqual(
-      0n,
-    );
-    expect(ArrayUtils.toIntLittleEndian(new Uint8Array([0xff]), 0, 0)).toEqual(
-      0n,
-    );
+    expect(toIntLittleEndian(new Uint8Array([0xff]), 0, -1)).toEqual(0n);
+    expect(toIntLittleEndian(new Uint8Array([0xff]), 0, 0)).toEqual(0n);
 
-    expect(ArrayUtils.toIntLittleEndian(new Uint8Array([0x00]), 0, 1)).toEqual(
-      0n,
-    );
-    expect(ArrayUtils.toIntLittleEndian(new Uint8Array([0x01]), 0, 1)).toEqual(
-      1n,
-    );
-    expect(ArrayUtils.toIntLittleEndian(new Uint8Array([0x7f]), 0, 1)).toEqual(
-      127n,
+    expect(toIntLittleEndian(new Uint8Array([0x00]), 0, 1)).toEqual(0n);
+    expect(toIntLittleEndian(new Uint8Array([0x01]), 0, 1)).toEqual(1n);
+    expect(toIntLittleEndian(new Uint8Array([0x7f]), 0, 1)).toEqual(127n);
+    expect(toIntLittleEndian(new Uint8Array([0x80]), 0, 1)).toEqual(-128n);
+    expect(toIntLittleEndian(new Uint8Array([0xff]), 0, 1)).toEqual(-1n);
+
+    expect(toIntLittleEndian(new Uint8Array([0xff, 0x7f]), 0, 2)).toEqual(
+      32767n,
     );
-    expect(ArrayUtils.toIntLittleEndian(new Uint8Array([0x80]), 0, 1)).toEqual(
-      -128n,
+    expect(toIntLittleEndian(new Uint8Array([0x00, 0x80]), 0, 2)).toEqual(
+      -32768n,
     );
-    expect(ArrayUtils.toIntLittleEndian(new Uint8Array([0xff]), 0, 1)).toEqual(
-      -1n,
+    expect(toIntLittleEndian(new Uint8Array([0x01, 0x80]), 0, 2)).toEqual(
+      -32767n,
     );
+    expect(toIntLittleEndian(new Uint8Array([0xff, 0xff]), 0, 2)).toEqual(-1n);
 
     expect(
-      ArrayUtils.toIntLittleEndian(new Uint8Array([0xff, 0x7f]), 0, 2),
-    ).toEqual(32767n);
-    expect(
-      ArrayUtils.toIntLittleEndian(new Uint8Array([0x00, 0x80]), 0, 2),
-    ).toEqual(-32768n);
-    expect(
-      ArrayUtils.toIntLittleEndian(new Uint8Array([0x01, 0x80]), 0, 2),
-    ).toEqual(-32767n);
-    expect(
-      ArrayUtils.toIntLittleEndian(new Uint8Array([0xff, 0xff]), 0, 2),
-    ).toEqual(-1n);
-
-    expect(
-      ArrayUtils.toIntLittleEndian(
-        new Uint8Array([0xff, 0xff, 0xff, 0x7f]),
-        0,
-        4,
-      ),
+      toIntLittleEndian(new Uint8Array([0xff, 0xff, 0xff, 0x7f]), 0, 4),
     ).toEqual(0x7fffffffn);
     expect(
-      ArrayUtils.toIntLittleEndian(
-        new Uint8Array([0x00, 0x00, 0x00, 0x80]),
-        0,
-        4,
-      ),
+      toIntLittleEndian(new Uint8Array([0x00, 0x00, 0x00, 0x80]), 0, 4),
     ).toEqual(-0x80000000n);
     expect(
-      ArrayUtils.toIntLittleEndian(
-        new Uint8Array([0x01, 0x00, 0x00, 0x80]),
-        0,
-        4,
-      ),
+      toIntLittleEndian(new Uint8Array([0x01, 0x00, 0x00, 0x80]), 0, 4),
     ).toEqual(-0x7fffffffn);
     expect(
-      ArrayUtils.toIntLittleEndian(
-        new Uint8Array([0xff, 0xff, 0xff, 0xff]),
-        0,
-        4,
-      ),
+      toIntLittleEndian(new Uint8Array([0xff, 0xff, 0xff, 0xff]), 0, 4),
     ).toEqual(-1n);
 
     expect(
-      ArrayUtils.toIntLittleEndian(
+      toIntLittleEndian(
         new Uint8Array([0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f]),
         0,
         8,
       ),
     ).toEqual(0x7fffffffffffffffn);
     expect(
-      ArrayUtils.toIntLittleEndian(
+      toIntLittleEndian(
         new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80]),
         0,
         8,
       ),
     ).toEqual(-0x8000000000000000n);
     expect(
-      ArrayUtils.toIntLittleEndian(
+      toIntLittleEndian(
         new Uint8Array([0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80]),
         0,
         8,
       ),
     ).toEqual(-0x7fffffffffffffffn);
     expect(
-      ArrayUtils.toIntLittleEndian(
+      toIntLittleEndian(
         new Uint8Array([0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]),
         0,
         8,
@@ -346,28 +273,28 @@ describe('ArrayUtils', () => {
     ).toEqual(-1n);
 
     expect(
-      ArrayUtils.toIntLittleEndian(
+      toIntLittleEndian(
         new Uint8Array([0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f]),
         0,
         9,
       ),
     ).toEqual(0x7fffffffffffffffffn);
     expect(
-      ArrayUtils.toIntLittleEndian(
+      toIntLittleEndian(
         new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80]),
         0,
         9,
       ),
     ).toEqual(-0x800000000000000000n);
     expect(
-      ArrayUtils.toIntLittleEndian(
+      toIntLittleEndian(
         new Uint8Array([0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80]),
         0,
         9,
       ),
     ).toEqual(-0x7fffffffffffffffffn);
     expect(
-      ArrayUtils.toIntLittleEndian(
+      toIntLittleEndian(
         new Uint8Array([0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]),
         0,
         9,
diff --git a/tools/winscope/src/common/assert_utils.ts b/tools/winscope/src/common/assert_utils.ts
index 4b25a9f0c..977270344 100644
--- a/tools/winscope/src/common/assert_utils.ts
+++ b/tools/winscope/src/common/assert_utils.ts
@@ -62,3 +62,99 @@ export function assertTrue(value: boolean, lazyErrorMessage?: () => string) {
 export function assertUnreachable(x: never): never {
   throw new Error('This line should never execute');
 }
+
+/**
+ * Asserts that the given value is a string.
+ *
+ * @param value The value to assert.
+ * @param lazyErrorMessage A function that returns a message to be included in the error if the assertion fails.
+ * @throws {Error} If the value is not a string.
+ * @return The value, asserted to be a string.
+ */
+export function assertString<A>(
+  value: A | null | undefined,
+  lazyErrorMessage?: () => string,
+): string {
+  if (typeof value !== 'string') {
+    throw new Error(
+      lazyErrorMessage
+        ? lazyErrorMessage()
+        : `Expected string, but found ${value}`,
+    );
+  }
+  return value;
+}
+
+export function assertStringOrUndefined<A>(
+  value: A | null | undefined,
+  lazyErrorMessage?: () => string,
+): string | undefined {
+  if (value === null || value === undefined) {
+    return undefined;
+  }
+  return assertString(value, lazyErrorMessage);
+}
+
+/**
+ * Asserts that the given value is a number.
+ *
+ * @param value The value to assert.
+ * @param lazyErrorMessage A function that returns a message to be included in the error if the assertion fails.
+ * @throws {Error} If the value is not a number.
+ * @return The value, asserted to be a number.
+ */
+export function assertNumber<A>(
+  value: A | null | undefined,
+  lazyErrorMessage?: () => string,
+): number {
+  if (typeof value !== 'number') {
+    throw new Error(
+      lazyErrorMessage
+        ? lazyErrorMessage()
+        : `Expected number, but found ${value}`,
+    );
+  }
+  return value;
+}
+
+export function assertNumberOrUndefined<A>(
+  value: A | null | undefined,
+  lazyErrorMessage?: () => string,
+): number | undefined {
+  if (value === null || value === undefined) {
+    return undefined;
+  }
+  return assertNumber(value, lazyErrorMessage);
+}
+
+/**
+ * Asserts that the given value is a bigint.
+ *
+ * @param value The value to assert.
+ * @param lazyErrorMessage A function that returns a message to be included in the error if the assertion fails.
+ * @throws {Error} If the value is not a bigint.
+ * @return The value, asserted to be a bigint.
+ */
+export function assertBigInt<A>(
+  value: A | null | undefined,
+  lazyErrorMessage?: () => string,
+): bigint {
+  if (typeof value !== 'bigint') {
+    throw new Error(
+      lazyErrorMessage
+        ? lazyErrorMessage()
+        : `Expected bigint, but found ${value}`,
+    );
+  }
+  return value;
+}
+
+export function assertBigIntOrUndefined<A>(
+  value: A | null | undefined,
+  lazyErrorMessage?: () => string,
+): bigint | undefined {
+  if (value === null || value === undefined) {
+    return undefined;
+  }
+  return assertBigInt(value, lazyErrorMessage);
+}
diff --git a/tools/winscope/src/common/bigint_math.ts b/tools/winscope/src/common/bigint_math.ts
index fb61b31c4..441be7b2a 100644
--- a/tools/winscope/src/common/bigint_math.ts
+++ b/tools/winscope/src/common/bigint_math.ts
@@ -14,22 +14,20 @@
  * limitations under the License.
  */
 
-/**
- * BigintMath provides mathematical operations for bigints.
- */
-export class BigintMath {
-  /**
-   * Divides two bigints and rounds the result to the nearest integer.
-   *
-   * @param ns The dividend.
-   * @param div The divisor.
-   * @return The rounded quotient.
-   */
-  static divideAndRound(ns: bigint, div: bigint): bigint {
-    let quot = ns / div;
-    if (ns % div >= div / 2n) {
-      quot += 1n;
+export function divideAndRound(ns: bigint, div: bigint): bigint {
+  let quot = ns / div;
+  if (ns % div >= div / 2n) {
+    quot += 1n;
+  }
+  return quot;
+}
+
+export function getMax(values: Array<bigint>): bigint | undefined {
+  let max: bigint | undefined;
+  for (const value of values) {
+    if (max === undefined || value > max) {
+      max = value;
     }
-    return quot;
   }
+  return max;
 }
diff --git a/tools/winscope/src/common/bigint_math_test.ts b/tools/winscope/src/common/bigint_math_test.ts
index 55174edb9..175061d96 100644
--- a/tools/winscope/src/common/bigint_math_test.ts
+++ b/tools/winscope/src/common/bigint_math_test.ts
@@ -14,17 +14,24 @@
  * limitations under the License.
  */
 
-import {BigintMath} from './bigint_math';
+import {divideAndRound, getMax} from './bigint_math';
 
 describe('BigintMath', () => {
-  it('divideAndRound()', () => {
-    expect(BigintMath.divideAndRound(0n, 10n)).toEqual(0n);
-    expect(BigintMath.divideAndRound(10n, 10n)).toEqual(1n);
-    expect(BigintMath.divideAndRound(10n, 6n)).toEqual(2n);
-    expect(BigintMath.divideAndRound(10n, 5n)).toEqual(2n);
-    expect(BigintMath.divideAndRound(10n, 4n)).toEqual(3n);
-    expect(() => BigintMath.divideAndRound(1n, 0n)).toThrowError();
-    expect(BigintMath.divideAndRound(10000n + 4999n, 10000n)).toEqual(1n);
-    expect(BigintMath.divideAndRound(10000n + 5000n, 10000n)).toEqual(2n);
+  it('divideAndRound', () => {
+    expect(divideAndRound(0n, 10n)).toEqual(0n);
+    expect(divideAndRound(10n, 10n)).toEqual(1n);
+    expect(divideAndRound(10n, 6n)).toEqual(2n);
+    expect(divideAndRound(10n, 5n)).toEqual(2n);
+    expect(divideAndRound(10n, 4n)).toEqual(3n);
+    expect(() => divideAndRound(1n, 0n)).toThrowError();
+    expect(divideAndRound(10000n + 4999n, 10000n)).toEqual(1n);
+    expect(divideAndRound(10000n + 5000n, 10000n)).toEqual(2n);
+  });
+
+  it('getMax', () => {
+    expect(getMax([])).toBeUndefined();
+    expect(getMax([1n])).toEqual(1n);
+    expect(getMax([1n, 2n])).toEqual(2n);
+    expect(getMax([-1n, 1n])).toEqual(1n);
   });
 });
diff --git a/tools/winscope/src/common/buffer_utils.ts b/tools/winscope/src/common/buffer_utils.ts
index 290140c87..5cbd30d82 100644
--- a/tools/winscope/src/common/buffer_utils.ts
+++ b/tools/winscope/src/common/buffer_utils.ts
@@ -14,6 +14,8 @@
  * limitations under the License.
  */
 
+import {binaryEncode} from './string_utils';
+
 export class ResizableBuffer {
   private buffer: Uint8Array;
   private capacityUsed = 0;
@@ -99,19 +101,7 @@ export class ArrayBufferBuilder {
   }
 
   private setAscii(buffer: Uint8Array, byteOffset: number, token: string) {
-    const byteArray = stringToByteArray(token);
+    const byteArray = binaryEncode(token);
     buffer.set(byteArray, byteOffset);
   }
 }
-
-export function stringToByteArray(str: string): Uint8Array {
-  const data = new Uint8Array(str.length);
-  for (let i = 0; i < str.length; ++i) {
-    data[i] = str.charCodeAt(i);
-  }
-  return data;
-}
-
-export function byteArrayToString(data: Uint8Array): string {
-  return new TextDecoder('utf-8').decode(data);
-}
diff --git a/tools/winscope/src/common/dom_utils.ts b/tools/winscope/src/common/dom_utils.ts
index 061fa70a8..240c6900f 100644
--- a/tools/winscope/src/common/dom_utils.ts
+++ b/tools/winscope/src/common/dom_utils.ts
@@ -17,15 +17,38 @@
 /**
  * Utility functions for DOM manipulation.
  */
-export class DOMUtils {
-  /**
-   * Checks if an element is visible on the screen.
-   *
-   * @param element The element to check.
-   * @return True if the element is visible, false otherwise.
-   */
-  static isElementVisible(element: HTMLElement) {
-    const rect = element.getBoundingClientRect();
-    return rect.height > 0 && rect.width > 0;
-  }
+
+/**
+ * Checks if an element is visible on the screen.
+ *
+ * @param element The element to check.
+ * @return True if the element is visible, false otherwise.
+ */
+export function isElementVisible(element: HTMLElement) {
+  const rect = element.getBoundingClientRect();
+  return rect.height > 0 && rect.width > 0;
+}
+
+export function isElementOverflowing(element: HTMLElement) {
+  return element.scrollWidth > element.clientWidth;
+}
+
+export enum KeyboardEventCode {
+  A = 'KeyA',
+  D = 'KeyD',
+  S = 'KeyS',
+  W = 'KeyW',
+}
+
+export enum KeyboardEventKey {
+  ARROW_DOWN = 'ArrowDown',
+  ARROW_LEFT = 'ArrowLeft',
+  ARROW_RIGHT = 'ArrowRight',
+  ARROW_UP = 'ArrowUp',
+  ENTER = 'Enter',
+  ESCAPE = 'Escape',
+}
+
+export enum KeyboardEventKeyCode {
+  SPACE = 32,
 }
diff --git a/tools/winscope/src/parsers/view_capture/legacy/tampered_protos.ts b/tools/winscope/src/common/errors.ts
similarity index 52%
rename from tools/winscope/src/parsers/view_capture/legacy/tampered_protos.ts
rename to tools/winscope/src/common/errors.ts
index 82f21bbe8..672dc6048 100644
--- a/tools/winscope/src/parsers/view_capture/legacy/tampered_protos.ts
+++ b/tools/winscope/src/common/errors.ts
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2024 The Android Open Source Project
+ * Copyright (C) 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,15 +14,4 @@
  * limitations under the License.
  */
 
-import {assertDefined} from 'common/assert_utils';
-import {TamperedMessageType} from 'parsers/tampered_message_type';
-import root from 'protos/viewcapture/udc/json';
-
-export const ExportedData = TamperedMessageType.tamper(
-  root.lookupType('com.android.app.viewcapture.data.ExportedData'),
-);
-
-export const NodeField = assertDefined(
-  ExportedData.fields['windowData'].tamperedMessageType?.fields['frameData']
-    .tamperedMessageType,
-).fields['node'];
+export const NOT_IMPLEMENTED_ERROR = new Error('Not implemented');
diff --git a/tools/winscope/src/common/file_utils.ts b/tools/winscope/src/common/file_utils.ts
index ea231b899..b74a427e6 100644
--- a/tools/winscope/src/common/file_utils.ts
+++ b/tools/winscope/src/common/file_utils.ts
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 import JSZip from 'jszip';
-import {ArrayUtils} from './array_utils';
+import {equal} from './array_utils';
 import {FunctionUtils, OnProgressUpdateType} from './function_utils';
 
 /**
@@ -47,6 +47,20 @@ export class FileUtils {
     return filename.slice(lastDot + 1);
   }
 
+  /**
+   * Extracts the file directory from a filename.
+   *
+   * @param filename The filename to extract the directory from.
+   * @return The file directory, or undefined if there is no directory.
+   */
+  static getFileDirectory(filename: string): string | undefined {
+    const lastIndex = filename.lastIndexOf('/');
+    if (lastIndex === -1) {
+      return undefined;
+    }
+    return filename.slice(0, lastIndex);
+  }
+
   /**
    * Removes the directory from a filename.
    *
@@ -191,7 +205,7 @@ export class FileUtils {
     magicNumber: number[],
   ): Promise<boolean> {
     const bufferStart = new Uint8Array((await file.arrayBuffer()).slice(0, 2));
-    return ArrayUtils.equal(bufferStart, magicNumber);
+    return equal(bufferStart, magicNumber);
   }
 
   private static readonly GZIP_MAGIC_NUMBER = [0x1f, 0x8b];
diff --git a/tools/winscope/src/common/file_utils_test.ts b/tools/winscope/src/common/file_utils_test.ts
index c40f64aff..05f7e014b 100644
--- a/tools/winscope/src/common/file_utils_test.ts
+++ b/tools/winscope/src/common/file_utils_test.ts
@@ -23,6 +23,14 @@ describe('FileUtils', () => {
     expect(FileUtils.getFileExtension('winscopezip')).toEqual(undefined);
   });
 
+  it('extracts file directories', () => {
+    expect(FileUtils.getFileDirectory('test/winscope.zip')).toEqual('test');
+    expect(FileUtils.getFileDirectory('test/test/winscope.zip')).toEqual(
+      'test/test',
+    );
+    expect(FileUtils.getFileDirectory('winscope.zip')).toEqual(undefined);
+  });
+
   it('removes directory from filename', () => {
     expect(FileUtils.removeDirFromFileName('test/winscope.zip')).toEqual(
       'winscope.zip',
@@ -71,7 +79,7 @@ describe('FileUtils', () => {
   });
 
   it('unzips archive', async () => {
-    const validZipFile = await getFixtureFile('traces/winscope.zip');
+    const validZipFile = await getFixtureFile('archives/winscope.zip');
     const unzippedFiles = await FileUtils.unzipFile(validZipFile);
     expect(unzippedFiles.map((f) => f.name)).toEqual([
       'Surface Flinger/SurfaceFlinger.pb',
@@ -80,7 +88,9 @@ describe('FileUtils', () => {
   });
 
   it('recursively unzips archive', async () => {
-    const validZipFile = await getFixtureFile('traces/recursive_winscope.zip');
+    const validZipFile = await getFixtureFile(
+      'archives/recursive_winscope.zip',
+    );
     const unzippedFiles = await FileUtils.unzipFile(validZipFile);
     expect(unzippedFiles.map((f) => f.name)).toEqual([
       'Surface Flinger/SurfaceFlinger.pb',
@@ -89,26 +99,26 @@ describe('FileUtils', () => {
   });
 
   it('decompresses gzipped file', async () => {
-    const gzippedFile = await getFixtureFile('traces/WindowManager.pb.gz');
+    const gzippedFile = await getFixtureFile('archives/WindowManager.pb.gz');
     const unzippedFile = await FileUtils.decompressGZipFile(gzippedFile);
-    expect(unzippedFile.name).toEqual('traces/WindowManager.pb');
+    expect(unzippedFile.name).toEqual('archives/WindowManager.pb');
     expect(unzippedFile.size).toEqual(377137);
   });
 
   it('decompresses gzipped file without gz ext', async () => {
     const gzippedFile = await getFixtureFile(
-      'traces/WindowManager.pb.gz',
-      'traces/WindowManager.pb',
+      'archives/WindowManager.pb.gz',
+      'archives/WindowManager.pb',
     );
     const unzippedFile = await FileUtils.decompressGZipFile(gzippedFile);
-    expect(unzippedFile.name).toEqual('traces/WindowManager.pb');
+    expect(unzippedFile.name).toEqual('archives/WindowManager.pb');
     expect(unzippedFile.size).toEqual(377137);
   });
 
   it('decompresses gzipped archive', async () => {
-    const gzippedFile = await getFixtureFile('traces/WindowManager.zip.gz');
+    const gzippedFile = await getFixtureFile('archives/WindowManager.zip.gz');
     const unzippedFile = await FileUtils.decompressGZipFile(gzippedFile);
-    expect(unzippedFile.name).toEqual('traces/WindowManager.zip');
+    expect(unzippedFile.name).toEqual('archives/WindowManager.zip');
     expect(unzippedFile.size).toEqual(10158);
   });
 
diff --git a/tools/winscope/src/common/intDefMapping.json b/tools/winscope/src/common/intDefMapping.json
index 1404ecdb6..83e309c33 100644
--- a/tools/winscope/src/common/intDefMapping.json
+++ b/tools/winscope/src/common/intDefMapping.json
@@ -381,7 +381,8 @@
       "21": "OOM_ADJ_REASON_RESTRICTION_CHANGE",
       "22": "OOM_ADJ_REASON_COMPONENT_DISABLED",
       "23": "OOM_ADJ_REASON_FOLLOW_UP",
-      "24": "OOM_ADJ_REASON_RECONFIGURATION"
+      "24": "OOM_ADJ_REASON_RECONFIGURATION",
+      "25": "OOM_ADJ_REASON_SERVICE_BINDER_CALL"
     }
   },
   "android.app.ActivityOptions.BackgroundActivityStartMode": {
@@ -401,7 +402,11 @@
       "1": "TYPE_LAUNCHER",
       "2": "TYPE_NOTIFICATION",
       "3": "TYPE_LOCKSCREEN",
-      "5": "TYPE_DESKTOP_ANIMATION"
+      "4": "TYPE_RECENTS_ANIMATION",
+      "5": "TYPE_DESKTOP_ANIMATION",
+      "6": "TYPE_QSS",
+      "7": "TYPE_TILE",
+      "8": "TYPE_COMPLICATION"
     }
   },
   "android.app.AlarmManager.AlarmType": {
@@ -426,7 +431,10 @@
       "64": "FLAG_ELIGIBLE_FOR_USER_ASPECT_RATIO_BUTTON",
       "128": "FLAG_FULLSCREEN_OVERRIDE_SYSTEM",
       "256": "FLAG_FULLSCREEN_OVERRIDE_USER",
-      "512": "FLAG_HAS_MIN_ASPECT_RATIO_OVERRIDE"
+      "512": "FLAG_HAS_MIN_ASPECT_RATIO_OVERRIDE",
+      "1024": "FLAG_ENABLE_RESTART_MENU_FOR_DISPLAY_MOVE",
+      "2048": "FLAG_OPT_OUT_EDGE_TO_EDGE",
+      "4096": "FLAG_SAFE_REGION_LETTERBOXED"
     }
   },
   "android.app.AppOpsManager.AttributionFlags": {
@@ -771,7 +779,8 @@
     "values": {
       "0": "RESULT_APPROVED",
       "1": "RESULT_FAILED_NOT_IN_FULLSCREEN_WITH_HISTORY",
-      "2": "RESULT_FAILED_NOT_TOP_FOCUSED"
+      "2": "RESULT_FAILED_NOT_TOP_FOCUSED",
+      "3": "RESULT_FAILED_ALREADY_FULLY_EXPANDED"
     }
   },
   "android.app.GameManager.GameMode": {
@@ -1117,6 +1126,14 @@
       "1": "NAV_BAR_MODE_KIDS"
     }
   },
+  "android.app.StatusBarManager.NavbarFlags": {
+    "flag": true,
+    "values": {
+      "1": "NAVBAR_BACK_DISMISS_IME",
+      "2": "NAVBAR_IME_VISIBLE",
+      "4": "NAVBAR_IME_SWITCHER_BUTTON_VISIBLE"
+    }
+  },
   "android.app.StatusBarManager.RequestResult": {
     "flag": false,
     "values": {
@@ -1153,6 +1170,15 @@
       "2": "WINDOW_STATE_HIDDEN"
     }
   },
+  "android.app.TaskInfo.SelfMovable": {
+    "flag": false,
+    "values": {
+      "-1": "SELF_MOVABLE_UNSET",
+      "0": "SELF_MOVABLE_DEFAULT",
+      "1": "SELF_MOVABLE_ALLOWED",
+      "2": "SELF_MOVABLE_DENIED"
+    }
+  },
   "android.app.UiAutomation.ConnectionState": {
     "flag": false,
     "values": {
@@ -1200,6 +1226,14 @@
       "2": "ENABLE_CAR_MODE_ALLOW_SLEEP"
     }
   },
+  "android.app.UiModeManager.ForceInvertType": {
+    "flag": false,
+    "values": {
+      "0": "FORCE_INVERT_TYPE_OFF",
+      "1": "FORCE_INVERT_TYPE_DARK",
+      "2": "FORCE_INVERT_TYPE_LIGHT"
+    }
+  },
   "android.app.UiModeManager.NightMode": {
     "flag": false,
     "values": {
@@ -1470,7 +1504,8 @@
       "8": "LOCK_TASK_FEATURE_OVERVIEW",
       "16": "LOCK_TASK_FEATURE_GLOBAL_ACTIONS",
       "32": "LOCK_TASK_FEATURE_KEYGUARD",
-      "64": "LOCK_TASK_FEATURE_BLOCK_ACTIVITY_START_IN_TASK"
+      "64": "LOCK_TASK_FEATURE_BLOCK_ACTIVITY_START_IN_TASK",
+      "128": "LOCK_TASK_FEATURE_QUICK_SETTINGS"
     }
   },
   "android.app.admin.DevicePolicyManager.MtePolicy": {
@@ -2156,6 +2191,13 @@
       "7": "EVENT_UI_SURFACE_HIDDEN"
     }
   },
+  "android.app.supervision.SupervisionRecoveryInfo.State": {
+    "flag": false,
+    "values": {
+      "0": "STATE_PENDING",
+      "1": "STATE_VERIFIED"
+    }
+  },
   "android.app.time.Capabilities.CapabilityState": {
     "flag": false,
     "values": {
@@ -2387,6 +2429,12 @@
       "3": "RESULT_INTERNAL_ERROR"
     }
   },
+  "android.companion.CompanionDeviceManager.TransportFlags": {
+    "flag": true,
+    "values": {
+      "1": "TRANSPORT_FLAG_EXTEND_PATCH_DIFF"
+    }
+  },
   "android.companion.DeviceFilter.MediumType": {
     "flag": false,
     "values": {
@@ -2480,6 +2528,16 @@
       "270": "SENSOR_ORIENTATION_270"
     }
   },
+  "android.companion.virtual.sensor.VirtualSensorAdditionalInfo.Type": {
+    "flag": false,
+    "values": {
+      "65536": "TYPE_UNTRACKED_DELAY",
+      "65537": "TYPE_INTERNAL_TEMPERATURE",
+      "65538": "TYPE_VEC3_CALIBRATION",
+      "65539": "TYPE_SENSOR_PLACEMENT",
+      "65540": "TYPE_SAMPLING"
+    }
+  },
   "android.companion.virtual.sensor.VirtualSensorConfig.ReportingMode": {
     "flag": false,
     "values": {
@@ -2838,6 +2896,13 @@
       "3": "TYPE_STRING"
     }
   },
+  "android.content.om.OverlayConstraint.ConstraintType": {
+    "flag": false,
+    "values": {
+      "0": "TYPE_DISPLAY_ID",
+      "1": "TYPE_DEVICE_ID"
+    }
+  },
   "android.content.om.OverlayInfo.State": {
     "flag": false,
     "values": {
@@ -2855,7 +2920,9 @@
     "flag": false,
     "values": {
       "0": "TYPE_SET_ENABLED",
-      "1": "TYPE_SET_DISABLED"
+      "1": "TYPE_SET_DISABLED",
+      "2": "TYPE_REGISTER_FABRICATED",
+      "3": "TYPE_UNREGISTER_FABRICATED"
     }
   },
   "android.content.pm.ActivityInfo.ColorMode": {
@@ -2887,6 +2954,8 @@
       "16384": "CONFIG_COLOR_MODE",
       "1073741824": "CONFIG_FONT_SCALE",
       "32768": "CONFIG_GRAMMATICAL_GENDER",
+      "268435456": "CONFIG_FONT_WEIGHT_ADJUSTMENT",
+      "536870912": "CONFIG_WINDOW_CONFIGURATION",
       "-2147483648": "CONFIG_ASSETS_PATHS",
       "134217728": "CONFIG_RESOURCES_UNUSED"
     }
@@ -3931,6 +4000,21 @@
       "3": "STATUS_FAILURE_INSTALL"
     }
   },
+  "android.content.theming.ThemeStyle.Type": {
+    "flag": false,
+    "values": {
+      "0": "SPRITZ",
+      "1": "TONAL_SPOT",
+      "2": "VIBRANT",
+      "3": "EXPRESSIVE",
+      "4": "RAINBOW",
+      "5": "FRUIT_SALAD",
+      "6": "CONTENT",
+      "7": "MONOCHROMATIC",
+      "8": "CLOCK",
+      "9": "CLOCK_VIBRANT"
+    }
+  },
   "android.credentials.CredentialManager.ProviderFilter": {
     "flag": true,
     "values": {
@@ -4267,7 +4351,16 @@
       "0": "RECTANGLE",
       "1": "OVAL",
       "2": "LINE",
-      "3": "RING"
+      "3": "RING",
+      "4": "ARC"
+    }
+  },
+  "android.graphics.drawable.GradientDrawable.StrokeCap": {
+    "flag": false,
+    "values": {
+      "0": "BUTT",
+      "1": "ROUND",
+      "2": "SQUARE"
     }
   },
   "android.graphics.drawable.Icon.IconType": {
@@ -4506,7 +4599,13 @@
       "56": "R_8",
       "57": "R_16",
       "58": "RG_1616",
-      "59": "RGBA_10101010"
+      "59": "RGBA_10101010",
+      "61": "R_12",
+      "62": "R_14",
+      "63": "RG_1212",
+      "64": "RG_1414",
+      "65": "RGBA_12121212",
+      "66": "RGBA_14141414"
     }
   },
   "android.hardware.LutProperties.Dimension": {
@@ -4646,6 +4745,7 @@
       "15": "BIOMETRIC_ERROR_SECURITY_UPDATE_REQUIRED",
       "20": "BIOMETRIC_ERROR_IDENTITY_CHECK_NOT_ACTIVE",
       "21": "BIOMETRIC_ERROR_NOT_ENABLED_FOR_APPS",
+      "22": "BIOMETRIC_ERROR_CONTENT_VIEW_MORE_OPTIONS_BUTTON",
       "100": "BIOMETRIC_PAUSED_REJECTED"
     }
   },
@@ -4777,6 +4877,23 @@
       "20": "BIOMETRIC_ERROR_IDENTITY_CHECK_NOT_ACTIVE"
     }
   },
+  "android.hardware.biometrics.BiometricManager.BiometricModality": {
+    "flag": true,
+    "values": {
+      "2": "TYPE_FINGERPRINT",
+      "8": "TYPE_FACE"
+    }
+  },
+  "android.hardware.biometrics.BiometricManager.IconType.Types": {
+    "flag": false,
+    "values": {
+      "0": "PASSWORD",
+      "1": "QR_CODE",
+      "2": "ACCOUNT",
+      "3": "GENERIC",
+      "4": "SETTING"
+    }
+  },
   "android.hardware.biometrics.BiometricPrompt.AuthenticationResultType": {
     "flag": false,
     "values": {
@@ -4795,7 +4912,9 @@
       "6": "DISMISSED_REASON_SERVER_REQUESTED",
       "7": "DISMISSED_REASON_CREDENTIAL_CONFIRMED",
       "8": "DISMISSED_REASON_CONTENT_VIEW_MORE_OPTIONS",
-      "9": "DISMISSED_REASON_ERROR_NO_WM"
+      "9": "DISMISSED_REASON_ERROR_NO_WM",
+      "20": "DISMISSED_REASON_FALLBACK_OPTION_BASE",
+      "24": "DISMISSED_REASON_FALLBACK_OPTION_MAX"
     }
   },
   "android.hardware.biometrics.BiometricRequestConstants.RequestReason": {
@@ -5021,6 +5140,10 @@
       "15": "PROPERTY_EXTENDED_DEVICE_STATE_EXTERNAL_DISPLAY",
       "16": "PROPERTY_FEATURE_REAR_DISPLAY",
       "17": "PROPERTY_FEATURE_DUAL_DISPLAY_INTERNAL_DEFAULT",
+      "101": "PROPERTY_LAPTOP_HARDWARE_CONFIGURATION_LID_CLOSED",
+      "102": "PROPERTY_LAPTOP_HARDWARE_CONFIGURATION_LID_OPEN",
+      "103": "PROPERTY_LAPTOP_HARDWARE_CONFIGURATION_SLATE",
+      "104": "PROPERTY_LAPTOP_HARDWARE_CONFIGURATION_DOCKED",
       "1001": "PROPERTY_FEATURE_REAR_DISPLAY_OUTER_DEFAULT"
     }
   },
@@ -5029,7 +5152,11 @@
     "values": {
       "1": "PROPERTY_FOLDABLE_HARDWARE_CONFIGURATION_FOLD_IN_CLOSED",
       "2": "PROPERTY_FOLDABLE_HARDWARE_CONFIGURATION_FOLD_IN_HALF_OPEN",
-      "3": "PROPERTY_FOLDABLE_HARDWARE_CONFIGURATION_FOLD_IN_OPEN"
+      "3": "PROPERTY_FOLDABLE_HARDWARE_CONFIGURATION_FOLD_IN_OPEN",
+      "101": "PROPERTY_LAPTOP_HARDWARE_CONFIGURATION_LID_CLOSED",
+      "102": "PROPERTY_LAPTOP_HARDWARE_CONFIGURATION_LID_OPEN",
+      "103": "PROPERTY_LAPTOP_HARDWARE_CONFIGURATION_SLATE",
+      "104": "PROPERTY_LAPTOP_HARDWARE_CONFIGURATION_DOCKED"
     }
   },
   "android.hardware.devicestate.DeviceState.SystemDeviceStateProperties": {
@@ -5167,7 +5294,8 @@
       "6": "EVENT_DISPLAY_CONNECTED",
       "7": "EVENT_DISPLAY_DISCONNECTED",
       "8": "EVENT_DISPLAY_REFRESH_RATE_CHANGED",
-      "9": "EVENT_DISPLAY_STATE_CHANGED"
+      "9": "EVENT_DISPLAY_STATE_CHANGED",
+      "10": "EVENT_DISPLAY_COMMITTED_STATE_CHANGED"
     }
   },
   "android.hardware.display.DisplayManagerInternal.RefreshRateLimitType": {
@@ -5489,7 +5617,6 @@
       "21": "KEY_GESTURE_TYPE_ALL_APPS",
       "22": "KEY_GESTURE_TYPE_LAUNCH_SEARCH",
       "23": "KEY_GESTURE_TYPE_LANGUAGE_SWITCH",
-      "24": "KEY_GESTURE_TYPE_ACCESSIBILITY_ALL_APPS",
       "25": "KEY_GESTURE_TYPE_TOGGLE_CAPS_LOCK",
       "26": "KEY_GESTURE_TYPE_SYSTEM_MUTE",
       "27": "KEY_GESTURE_TYPE_SPLIT_SCREEN_NAVIGATION_LEFT",
@@ -5523,12 +5650,11 @@
       "55": "KEY_GESTURE_TYPE_ACCESSIBILITY_SHORTCUT_CHORD",
       "56": "KEY_GESTURE_TYPE_RINGER_TOGGLE_CHORD",
       "57": "KEY_GESTURE_TYPE_GLOBAL_ACTIONS",
-      "58": "KEY_GESTURE_TYPE_TV_ACCESSIBILITY_SHORTCUT_CHORD",
       "59": "KEY_GESTURE_TYPE_TV_TRIGGER_BUG_REPORT",
       "60": "KEY_GESTURE_TYPE_ACCESSIBILITY_SHORTCUT",
       "61": "KEY_GESTURE_TYPE_CLOSE_ALL_DIALOGS",
       "62": "KEY_GESTURE_TYPE_MOVE_TO_NEXT_DISPLAY",
-      "63": "KEY_GESTURE_TYPE_TOGGLE_TALKBACK",
+      "63": "KEY_GESTURE_TYPE_TOGGLE_SCREEN_READER",
       "64": "KEY_GESTURE_TYPE_TOGGLE_STICKY_KEYS",
       "65": "KEY_GESTURE_TYPE_TOGGLE_BOUNCE_KEYS",
       "66": "KEY_GESTURE_TYPE_TOGGLE_SLOW_KEYS",
@@ -5541,7 +5667,9 @@
       "73": "KEY_GESTURE_TYPE_ACTIVATE_SELECT_TO_SPEAK",
       "74": "KEY_GESTURE_TYPE_MAXIMIZE_FREEFORM_WINDOW",
       "75": "KEY_GESTURE_TYPE_TOGGLE_DO_NOT_DISTURB",
-      "76": "KEY_GESTURE_TYPE_TOGGLE_VOICE_ACCESS"
+      "76": "KEY_GESTURE_TYPE_TOGGLE_VOICE_ACCESS",
+      "77": "KEY_GESTURE_TYPE_SWITCH_TO_PREVIOUS_DESK",
+      "78": "KEY_GESTURE_TYPE_SWITCH_TO_NEXT_DESK"
     }
   },
   "android.hardware.input.KeyboardLayoutSelectionResult.LayoutSelectionCriteria": {
@@ -6241,8 +6369,7 @@
     "flag": true,
     "values": {
       "1": "IME_ACTIVE",
-      "2": "IME_VISIBLE",
-      "4": "IME_VISIBLE_IMPERCEPTIBLE"
+      "2": "IME_VISIBLE"
     }
   },
   "android.inputmethodservice.InputMethodService.SettingsObserver.ShowImeWithHardKeyboardType": {
@@ -6512,6 +6639,36 @@
       "134217728": "CHANNEL_OUT_FRONT_WIDE_RIGHT"
     }
   },
+  "android.media.AudioDeviceVolumeManager.AbsoluteDeviceVolumeBehavior": {
+    "flag": false,
+    "values": {
+      "3": "DEVICE_VOLUME_BEHAVIOR_ABSOLUTE",
+      "5": "DEVICE_VOLUME_BEHAVIOR_ABSOLUTE_ADJUST_ONLY"
+    }
+  },
+  "android.media.AudioDeviceVolumeManager.DeviceVolumeBehavior": {
+    "flag": false,
+    "values": {
+      "0": "DEVICE_VOLUME_BEHAVIOR_VARIABLE",
+      "1": "DEVICE_VOLUME_BEHAVIOR_FULL",
+      "2": "DEVICE_VOLUME_BEHAVIOR_FIXED",
+      "3": "DEVICE_VOLUME_BEHAVIOR_ABSOLUTE",
+      "4": "DEVICE_VOLUME_BEHAVIOR_ABSOLUTE_MULTI_MODE",
+      "5": "DEVICE_VOLUME_BEHAVIOR_ABSOLUTE_ADJUST_ONLY"
+    }
+  },
+  "android.media.AudioDeviceVolumeManager.DeviceVolumeBehaviorState": {
+    "flag": false,
+    "values": {
+      "-1": "DEVICE_VOLUME_BEHAVIOR_UNSET",
+      "0": "DEVICE_VOLUME_BEHAVIOR_VARIABLE",
+      "1": "DEVICE_VOLUME_BEHAVIOR_FULL",
+      "2": "DEVICE_VOLUME_BEHAVIOR_FIXED",
+      "3": "DEVICE_VOLUME_BEHAVIOR_ABSOLUTE",
+      "4": "DEVICE_VOLUME_BEHAVIOR_ABSOLUTE_MULTI_MODE",
+      "5": "DEVICE_VOLUME_BEHAVIOR_ABSOLUTE_ADJUST_ONLY"
+    }
+  },
   "android.media.AudioDeviceVolumeManager.VolumeAdjustmentMode": {
     "flag": false,
     "values": {
@@ -6682,13 +6839,6 @@
       "1": "AUDIO_HAL_TYPE_AIDL"
     }
   },
-  "android.media.AudioManager.AbsoluteDeviceVolumeBehavior": {
-    "flag": false,
-    "values": {
-      "3": "DEVICE_VOLUME_BEHAVIOR_ABSOLUTE",
-      "5": "DEVICE_VOLUME_BEHAVIOR_ABSOLUTE_ADJUST_ONLY"
-    }
-  },
   "android.media.AudioManager.AudioDeviceCategory": {
     "flag": false,
     "values": {
@@ -6773,18 +6923,6 @@
       "5": "DEVICE_VOLUME_BEHAVIOR_ABSOLUTE_ADJUST_ONLY"
     }
   },
-  "android.media.AudioManager.DeviceVolumeBehaviorState": {
-    "flag": false,
-    "values": {
-      "-1": "DEVICE_VOLUME_BEHAVIOR_UNSET",
-      "0": "DEVICE_VOLUME_BEHAVIOR_VARIABLE",
-      "1": "DEVICE_VOLUME_BEHAVIOR_FULL",
-      "2": "DEVICE_VOLUME_BEHAVIOR_FIXED",
-      "3": "DEVICE_VOLUME_BEHAVIOR_ABSOLUTE",
-      "4": "DEVICE_VOLUME_BEHAVIOR_ABSOLUTE_MULTI_MODE",
-      "5": "DEVICE_VOLUME_BEHAVIOR_ABSOLUTE_ADJUST_ONLY"
-    }
-  },
   "android.media.AudioManager.EncodedSurroundOutputMode": {
     "flag": false,
     "values": {
@@ -6853,6 +6991,14 @@
       "16": "FLAG_VIBRATE"
     }
   },
+  "android.media.AudioManager.QueryVolCommand": {
+    "flag": false,
+    "values": {
+      "1": "QUERY_VOL_MIN",
+      "2": "QUERY_VOL_MAX",
+      "3": "QUERY_VOL"
+    }
+  },
   "android.media.AudioManager.SystemSoundEffect": {
     "flag": false,
     "values": {
@@ -7003,13 +7149,16 @@
       "553648128": "AUDIO_FORMAT_APTX_HD",
       "587202560": "AUDIO_FORMAT_LDAC",
       "721420288": "AUDIO_FORMAT_LC3",
-      "134217728": "AUDIO_FORMAT_OPUS"
+      "134217728": "AUDIO_FORMAT_OPUS",
+      "134217729": "AUDIO_FORMAT_OPUS_HI_RES"
     }
   },
   "android.media.AudioSystem.AudioFormatNativeEnumForBtLeAudioCodec": {
     "flag": false,
     "values": {
-      "721420288": "AUDIO_FORMAT_LC3"
+      "721420288": "AUDIO_FORMAT_LC3",
+      "134217728": "AUDIO_FORMAT_OPUS",
+      "134217729": "AUDIO_FORMAT_OPUS_HI_RES"
     }
   },
   "android.media.AudioSystem.AudioSystemError": {
@@ -7830,6 +7979,14 @@
       "10000": "SUBTEXT_CUSTOM"
     }
   },
+  "android.media.RoutingSessionInfo.ReleaseType": {
+    "flag": false,
+    "values": {
+      "0": "RELEASE_UNSUPPORTED",
+      "1": "RELEASE_TYPE_CASTING",
+      "2": "RELEASE_TYPE_SHARING"
+    }
+  },
   "android.media.RoutingSessionInfo.TransferReason": {
     "flag": false,
     "values": {
@@ -8206,6 +8363,21 @@
       "1": "CAPTURE_REGION_FIXED_DISPLAY"
     }
   },
+  "android.media.projection.MediaProjectionConfig.MediaProjectionSource": {
+    "flag": true,
+    "values": {
+      "2": "PROJECTION_SOURCE_DISPLAY",
+      "4": "PROJECTION_SOURCE_DISPLAY_REGION",
+      "8": "PROJECTION_SOURCE_APP",
+      "16": "PROJECTION_SOURCE_APP_CONTENT"
+    }
+  },
+  "android.media.projection.MediaProjectionEvent.EventType": {
+    "flag": false,
+    "values": {
+      "0": "PROJECTION_STARTED_DURING_CALL_AND_ACTIVE_POST_CALL"
+    }
+  },
   "android.media.quality.AmbientBacklightEvent.Type": {
     "flag": false,
     "values": {
@@ -9835,7 +10007,9 @@
       "1": "TYPE_VPN_SERVICE",
       "2": "TYPE_VPN_PLATFORM",
       "3": "TYPE_VPN_LEGACY",
-      "4": "TYPE_VPN_OEM"
+      "4": "TYPE_VPN_OEM",
+      "5": "TYPE_VPN_OEM_SERVICE",
+      "6": "TYPE_VPN_OEM_LEGACY"
     }
   },
   "android.net.VpnProfileState.State": {
@@ -10380,47 +10554,6 @@
       "3": "BACKPORTED_FIX_STATUS_NOT_FIXED"
     }
   },
-  "android.os.Build.SdkIntFull": {
-    "flag": false,
-    "values": {
-      "100000": "BASE",
-      "200000": "BASE_1_1",
-      "300000": "CUPCAKE",
-      "400000": "DONUT",
-      "500000": "ECLAIR",
-      "600000": "ECLAIR_0_1",
-      "700000": "ECLAIR_MR1",
-      "800000": "FROYO",
-      "900000": "GINGERBREAD",
-      "1000000": "GINGERBREAD_MR1",
-      "1100000": "HONEYCOMB",
-      "1200000": "HONEYCOMB_MR1",
-      "1300000": "HONEYCOMB_MR2",
-      "1400000": "ICE_CREAM_SANDWICH",
-      "1500000": "ICE_CREAM_SANDWICH_MR1",
-      "1600000": "JELLY_BEAN",
-      "1700000": "JELLY_BEAN_MR1",
-      "1800000": "JELLY_BEAN_MR2",
-      "1900000": "KITKAT",
-      "2000000": "KITKAT_WATCH",
-      "2100000": "LOLLIPOP",
-      "2200000": "LOLLIPOP_MR1",
-      "2300000": "M",
-      "2400000": "N",
-      "2500000": "N_MR1",
-      "2600000": "O",
-      "2700000": "O_MR1",
-      "2800000": "P",
-      "2900000": "Q",
-      "3000000": "R",
-      "3100000": "S",
-      "3200000": "S_V2",
-      "3300000": "TIRAMISU",
-      "3400000": "UPSIDE_DOWN_CAKE",
-      "3500000": "VANILLA_ICE_CREAM",
-      "3600000": "BAKLAVA"
-    }
-  },
   "android.os.Bundle.HasBinderStatus": {
     "flag": true,
     "values": {
@@ -10443,7 +10576,9 @@
       "30": "STRATEGY_BOOLEAN_AND",
       "40": "STRATEGY_BOOLEAN_OR",
       "50": "STRATEGY_ARRAY_APPEND",
-      "60": "STRATEGY_ARRAY_LIST_APPEND"
+      "55": "STRATEGY_ARRAY_UNION",
+      "60": "STRATEGY_ARRAY_LIST_APPEND",
+      "70": "STRATEGY_STRING_APPEND"
     }
   },
   "android.os.CoolingDevice.Type": {
@@ -10731,6 +10866,15 @@
       "3": "BRIGHTNESS_CONSTRAINT_TYPE_DIM"
     }
   },
+  "android.os.PowerManager.FlagAmbientSuppression": {
+    "flag": true,
+    "values": {
+      "0": "FLAG_AMBIENT_SUPPRESSION_NONE",
+      "1": "FLAG_AMBIENT_SUPPRESSION_DREAM",
+      "2": "FLAG_AMBIENT_SUPPRESSION_AOD",
+      "3": "FLAG_AMBIENT_SUPPRESSION_ALL"
+    }
+  },
   "android.os.PowerManager.GoToSleepReason": {
     "flag": false,
     "values": {
@@ -10875,7 +11019,8 @@
       "14": "WAKE_REASON_TILT",
       "15": "WAKE_REASON_TAP",
       "16": "WAKE_REASON_LIFT",
-      "17": "WAKE_REASON_BIOMETRIC"
+      "17": "WAKE_REASON_BIOMETRIC",
+      "18": "WAKE_REASON_DOCK"
     }
   },
   "android.os.PowerMonitor.PowerMonitorType": {
@@ -11016,6 +11161,7 @@
       "256": "DETECT_VM_UNTAGGED_SOCKET",
       "512": "DETECT_VM_NON_SDK_API_USAGE",
       "1024": "DETECT_VM_IMPLICIT_DIRECT_BOOT",
+      "2048": "DETECT_VM_CREDENTIAL_PROTECTED_WHILE_LOCKED",
       "4096": "DETECT_VM_INCORRECT_CONTEXT_USE",
       "8192": "DETECT_VM_UNSAFE_INTENT_LAUNCH",
       "16384": "DETECT_VM_BACKGROUND_ACTIVITY_LAUNCH_ABORTED",
@@ -11136,6 +11282,15 @@
       "-1": "REMOVE_RESULT_ERROR_UNKNOWN"
     }
   },
+  "android.os.UserManager.UserLogoutability": {
+    "flag": false,
+    "values": {
+      "0": "LOGOUTABILITY_STATUS_OK",
+      "1": "LOGOUTABILITY_STATUS_CANNOT_LOGOUT_SYSTEM_USER",
+      "2": "LOGOUTABILITY_STATUS_CANNOT_SWITCH",
+      "3": "LOGOUTABILITY_STATUS_DEVICE_NOT_SUPPORTED"
+    }
+  },
   "android.os.UserManager.UserOperationResult": {
     "flag": false,
     "values": {
@@ -11148,7 +11303,7 @@
       "6": "USER_OPERATION_ERROR_MAX_USERS",
       "7": "USER_OPERATION_ERROR_USER_ACCOUNT_ALREADY_EXISTS",
       "8": "USER_OPERATION_ERROR_DISABLED_USER",
-      "9": "USER_OPERATION_ERROR_PRIVATE_PROFILE",
+      "9": "USER_OPERATION_ERROR_FEATURE_UNSUPPORTED",
       "10": "USER_OPERATION_ERROR_USER_RESTRICTED"
     }
   },
@@ -11192,7 +11347,8 @@
       "34": "USAGE_PHYSICAL_EMULATION",
       "33": "USAGE_RINGTONE",
       "18": "USAGE_TOUCH",
-      "82": "USAGE_IME_FEEDBACK"
+      "82": "USAGE_IME_FEEDBACK",
+      "98": "USAGE_GESTURE_INPUT"
     }
   },
   "android.os.VibrationAttributes.UsageClass": {
@@ -11529,6 +11685,14 @@
       "4": "RESET_MODE_TRUSTED_DEFAULTS"
     }
   },
+  "android.provider.Settings.Secure.AccessibilityMagnificationCursorFollowingMode": {
+    "flag": false,
+    "values": {
+      "0": "ACCESSIBILITY_MAGNIFICATION_CURSOR_FOLLOWING_MODE_CONTINUOUS",
+      "1": "ACCESSIBILITY_MAGNIFICATION_CURSOR_FOLLOWING_MODE_CENTER",
+      "2": "ACCESSIBILITY_MAGNIFICATION_CURSOR_FOLLOWING_MODE_EDGE"
+    }
+  },
   "android.provider.Settings.Secure.DeviceStateRotationLockKey": {
     "flag": false,
     "values": {
@@ -11567,6 +11731,15 @@
       "10": "HUB_MODE_TUTORIAL_COMPLETED"
     }
   },
+  "android.provider.Settings.Secure.LowLightDisplayBehavior": {
+    "flag": false,
+    "values": {
+      "0": "LOW_LIGHT_DISPLAY_BEHAVIOR_NONE",
+      "1": "LOW_LIGHT_DISPLAY_BEHAVIOR_SCREEN_OFF",
+      "2": "LOW_LIGHT_DISPLAY_BEHAVIOR_LOW_LIGHT_CLOCK_DREAM",
+      "3": "LOW_LIGHT_DISPLAY_BEHAVIOR_NO_DREAM"
+    }
+  },
   "android.provider.Settings.Secure.PrivateSpaceAutoLockOption": {
     "flag": false,
     "values": {
@@ -11592,6 +11765,15 @@
       "10": "USER_SETUP_PERSONALIZATION_COMPLETE"
     }
   },
+  "android.provider.Settings.Secure.WhenToStartGlanceableHub": {
+    "flag": false,
+    "values": {
+      "0": "GLANCEABLE_HUB_START_NEVER",
+      "1": "GLANCEABLE_HUB_START_CHARGING",
+      "2": "GLANCEABLE_HUB_START_CHARGING_UPRIGHT",
+      "3": "GLANCEABLE_HUB_START_DOCKED"
+    }
+  },
   "android.provider.Settings.SetAllResult": {
     "flag": false,
     "values": {
@@ -11737,8 +11919,8 @@
   "android.security.authenticationpolicy.AuthenticationPolicyManager.DisableSecureLockDeviceRequestStatus": {
     "flag": false,
     "values": {
-      "0": "ERROR_UNKNOWN",
-      "1": "SUCCESS",
+      "0": "SUCCESS",
+      "1": "ERROR_UNKNOWN",
       "2": "ERROR_UNSUPPORTED",
       "3": "ERROR_INVALID_PARAMS"
     }
@@ -11746,8 +11928,8 @@
   "android.security.authenticationpolicy.AuthenticationPolicyManager.EnableSecureLockDeviceRequestStatus": {
     "flag": false,
     "values": {
-      "0": "ERROR_UNKNOWN",
-      "1": "SUCCESS",
+      "0": "SUCCESS",
+      "1": "ERROR_UNKNOWN",
       "2": "ERROR_UNSUPPORTED",
       "3": "ERROR_INVALID_PARAMS",
       "4": "ERROR_NO_BIOMETRICS_ENROLLED",
@@ -13927,31 +14109,6 @@
       "5": "NET_ENTERPRISE_ID_5"
     }
   },
-  "android.telephony.Annotation.ImsAudioCodec": {
-    "flag": false,
-    "values": {
-      "0": "AUDIO_CODEC_NONE",
-      "1": "AUDIO_CODEC_AMR",
-      "2": "AUDIO_CODEC_AMR_WB",
-      "3": "AUDIO_CODEC_QCELP13K",
-      "4": "AUDIO_CODEC_EVRC",
-      "5": "AUDIO_CODEC_EVRC_B",
-      "6": "AUDIO_CODEC_EVRC_WB",
-      "7": "AUDIO_CODEC_EVRC_NW",
-      "8": "AUDIO_CODEC_GSM_EFR",
-      "9": "AUDIO_CODEC_GSM_FR",
-      "11": "AUDIO_CODEC_G711U",
-      "12": "AUDIO_CODEC_G723",
-      "13": "AUDIO_CODEC_G711A",
-      "14": "AUDIO_CODEC_G722",
-      "15": "AUDIO_CODEC_G711AB",
-      "16": "AUDIO_CODEC_G729",
-      "17": "AUDIO_CODEC_EVS_NB",
-      "18": "AUDIO_CODEC_EVS_WB",
-      "19": "AUDIO_CODEC_EVS_SWB",
-      "20": "AUDIO_CODEC_EVS_FB"
-    }
-  },
   "android.telephony.Annotation.ImsCallServiceType": {
     "flag": false,
     "values": {
@@ -15148,7 +15305,8 @@
       "134": "RESULT_RIL_NO_SUBSCRIPTION",
       "135": "RESULT_RIL_NO_NETWORK_FOUND",
       "136": "RESULT_RIL_DEVICE_IN_USE",
-      "137": "RESULT_RIL_ABORTED"
+      "137": "RESULT_RIL_ABORTED",
+      "138": "RESULT_SMS_SEND_FAIL_AFTER_MAX_RETRY"
     }
   },
   "android.telephony.SmsManager.SMS_RP_CAUSE": {
@@ -17249,6 +17407,15 @@
       "2": "SATELLITE_COMMUNICATION_RESTRICTION_REASON_ENTITLEMENT"
     }
   },
+  "android.telephony.satellite.SatelliteManager.SatelliteDataSupportMode": {
+    "flag": false,
+    "values": {
+      "-1": "SATELLITE_DATA_SUPPORT_UNKNOWN",
+      "0": "SATELLITE_DATA_SUPPORT_RESTRICTED",
+      "1": "SATELLITE_DATA_SUPPORT_CONSTRAINED",
+      "2": "SATELLITE_DATA_SUPPORT_UNCONSTRAINED"
+    }
+  },
   "android.telephony.satellite.SatelliteManager.SatelliteDatagramTransferState": {
     "flag": false,
     "values": {
@@ -17553,7 +17720,8 @@
     "flag": false,
     "values": {
       "0": "RECORD_CONTENT_DISPLAY",
-      "1": "RECORD_CONTENT_TASK"
+      "1": "RECORD_CONTENT_TASK",
+      "2": "RECORD_CONTENT_BELOW_OVERLAY"
     }
   },
   "android.view.ContentRecordingSession.TargetUid": {
@@ -17631,16 +17799,16 @@
       "7": "PERFORM_TRAVERSALS_START",
       "8": "DRAW_START",
       "9": "FRAME_DEADLINE",
-      "12": "SYNC_QUEUED",
-      "13": "SYNC_START",
-      "14": "ISSUE_DRAW_COMMANDS_START",
-      "15": "SWAP_BUFFERS",
-      "16": "FRAME_COMPLETED",
-      "17": "DEQUEUE_BUFFER_DURATION",
-      "18": "QUEUE_BUFFER_DURATION",
-      "19": "GPU_COMPLETED",
-      "20": "SWAP_BUFFERS_COMPLETED",
-      "21": "DISPLAY_PRESENT_TIME"
+      "13": "SYNC_QUEUED",
+      "14": "SYNC_START",
+      "15": "ISSUE_DRAW_COMMANDS_START",
+      "16": "SWAP_BUFFERS",
+      "17": "FRAME_COMPLETED",
+      "18": "DEQUEUE_BUFFER_DURATION",
+      "19": "QUEUE_BUFFER_DURATION",
+      "20": "GPU_COMPLETED",
+      "21": "SWAP_BUFFERS_COMPLETED",
+      "22": "DISPLAY_PRESENT_TIME"
     }
   },
   "android.view.FrameMetrics.Metric": {
@@ -17746,7 +17914,8 @@
       "16384": "SPY",
       "32768": "INTERCEPTS_STYLUS",
       "65536": "CLONE",
-      "262144": "SENSITIVE_FOR_PRIVACY"
+      "262144": "SENSITIVE_FOR_PRIVACY",
+      "524288": "DISPLAY_TOPOLOGY_AWARE"
     }
   },
   "android.view.InsetsController.AnimationType": {
@@ -17773,7 +17942,8 @@
       "2": "FLAG_INSETS_ROUNDED_CORNER",
       "4": "FLAG_FORCE_CONSUMING",
       "8": "FLAG_ANIMATE_RESIZING",
-      "16": "FLAG_FORCE_CONSUMING_OPAQUE_CAPTION_BAR"
+      "16": "FLAG_FORCE_CONSUMING_OPAQUE_CAPTION_BAR",
+      "32": "FLAG_INVALID"
     }
   },
   "android.view.InsetsSource.InternalInsetsSide": {
@@ -18300,7 +18470,9 @@
       "64": "FLAG_NO_FOCUS_CHANGE",
       "2048": "FLAG_IS_ACCESSIBILITY_EVENT",
       "-2147483648": "FLAG_TAINTED",
-      "1073741824": "FLAG_TARGET_ACCESSIBILITY_FOCUS"
+      "1073741824": "FLAG_TARGET_ACCESSIBILITY_FOCUS",
+      "128": "FLAG_SUPPORTS_ORIENTATION",
+      "256": "FLAG_SUPPORTS_DIRECTIONAL_ORIENTATION"
     }
   },
   "android.view.MotionEvent.ToolType": {
@@ -18442,7 +18614,9 @@
       "2": "BUFFER_TRANSFORM_MIRROR_VERTICAL",
       "4": "BUFFER_TRANSFORM_ROTATE_90",
       "3": "BUFFER_TRANSFORM_ROTATE_180",
-      "7": "BUFFER_TRANSFORM_ROTATE_270"
+      "7": "BUFFER_TRANSFORM_ROTATE_270",
+      "5": "BUFFER_TRANSFORM_MIRROR_HORIZONTAL_ROTATE_90",
+      "6": "BUFFER_TRANSFORM_MIRROR_VERTICAL_ROTATE_90"
     }
   },
   "android.view.SurfaceControl.CachingHint": {
@@ -18652,6 +18826,15 @@
       "-2147483648": "AT_MOST"
     }
   },
+  "android.view.View.RectangleOnScreenRequestSource": {
+    "flag": false,
+    "values": {
+      "0": "RECTANGLE_ON_SCREEN_REQUEST_SOURCE_UNDEFINED",
+      "1": "RECTANGLE_ON_SCREEN_REQUEST_SOURCE_SCROLL_ONLY",
+      "2": "RECTANGLE_ON_SCREEN_REQUEST_SOURCE_TEXT_CURSOR",
+      "3": "RECTANGLE_ON_SCREEN_REQUEST_SOURCE_INPUT_FOCUS"
+    }
+  },
   "android.view.View.ResolvedLayoutDir": {
     "flag": false,
     "values": {
@@ -18859,7 +19042,7 @@
       "2": "INPUT_FEATURE_DISABLE_USER_ACTIVITY",
       "4": "INPUT_FEATURE_SPY",
       "8": "INPUT_FEATURE_SENSITIVE_FOR_PRIVACY",
-      "16": "INPUT_FEATURE_RECEIVE_POWER_KEY_DOUBLE_PRESS"
+      "16": "INPUT_FEATURE_DISPLAY_TOPOLOGY_AWARE"
     }
   },
   "android.view.WindowManager.LayoutParams.LayoutInDisplayCutoutMode": {
@@ -19003,7 +19186,8 @@
       "2038": "TYPE_APPLICATION_OVERLAY",
       "2039": "TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY",
       "2040": "TYPE_NOTIFICATION_SHADE",
-      "2041": "TYPE_STATUS_BAR_ADDITIONAL"
+      "2041": "TYPE_STATUS_BAR_ADDITIONAL",
+      "-1": "INVALID_WINDOW_TYPE"
     }
   },
   "android.view.WindowManager.RemoveContentMode": {
@@ -19064,7 +19248,10 @@
       "2048": "TRANSIT_FLAG_KEYGUARD_APPEARING",
       "4096": "TRANSIT_FLAG_KEYGUARD_OCCLUDING",
       "8192": "TRANSIT_FLAG_KEYGUARD_UNOCCLUDING",
-      "16384": "TRANSIT_FLAG_PHYSICAL_DISPLAY_SWITCH"
+      "16384": "TRANSIT_FLAG_PHYSICAL_DISPLAY_SWITCH",
+      "32768": "TRANSIT_FLAG_AOD_APPEARING",
+      "65536": "TRANSIT_FLAG_AVOID_MOVE_TO_FRONT",
+      "131072": "TRANSIT_FLAG_DISPLAY_LEVEL_TRANSITION"
     }
   },
   "android.view.WindowManager.TransitionOldType": {
@@ -19434,7 +19621,8 @@
     "values": {
       "5": "ORIGIN_CLIENT",
       "6": "ORIGIN_SERVER",
-      "7": "ORIGIN_IME"
+      "7": "ORIGIN_IME",
+      "8": "ORIGIN_WM_SHELL"
     }
   },
   "android.view.inputmethod.ImeTracker.Phase": {
@@ -19507,7 +19695,17 @@
       "66": "PHASE_CLIENT_VIEW_HANDLER_AVAILABLE",
       "67": "PHASE_SERVER_UPDATE_CLIENT_VISIBILITY",
       "68": "PHASE_WM_DISPLAY_IME_CONTROLLER_SET_IME_REQUESTED_VISIBLE",
-      "69": "PHASE_WM_UPDATE_DISPLAY_WINDOW_REQUESTED_VISIBLE_TYPES"
+      "69": "PHASE_WM_UPDATE_DISPLAY_WINDOW_REQUESTED_VISIBLE_TYPES",
+      "70": "PHASE_WM_REQUESTED_VISIBLE_TYPES_NOT_CHANGED",
+      "71": "PHASE_CLIENT_UPDATE_ANIMATING_TYPES",
+      "72": "PHASE_WM_UPDATE_ANIMATING_TYPES",
+      "73": "PHASE_WM_WINDOW_ANIMATING_TYPES_CHANGED",
+      "74": "PHASE_WM_NOTIFY_HIDE_ANIMATION_FINISHED",
+      "75": "PHASE_WM_UPDATE_DISPLAY_WINDOW_ANIMATING_TYPES",
+      "76": "PHASE_CLIENT_ON_CONTROLS_CHANGED",
+      "77": "PHASE_SERVER_IME_INVOKER",
+      "78": "PHASE_SERVER_CLIENT_INVOKER",
+      "79": "PHASE_SERVER_ALREADY_VISIBLE"
     }
   },
   "android.view.inputmethod.ImeTracker.Status": {
@@ -20215,7 +20413,9 @@
       "30000": "TASK_CHILD_LAYER_WINDOW_DECORATIONS",
       "40000": "TASK_CHILD_LAYER_RECENTS_ANIMATION_PIP_OVERLAY",
       "50000": "TASK_CHILD_LAYER_TASK_OVERLAY",
-      "60000": "TASK_CHILD_LAYER_RESIZE_VEIL"
+      "60000": "TASK_CHILD_LAYER_RESIZE_VEIL",
+      "-10000": "TASK_CHILD_SHELL_LAYER_LETTERBOX_BACKGROUND",
+      "1000": "TASK_CHILD_SHELL_LAYER_LETTERBOX_SPY"
     }
   },
   "android.window.TaskFragmentOperation.OperationType": {
@@ -20234,15 +20434,15 @@
       "9": "OP_TYPE_SET_RELATIVE_BOUNDS",
       "10": "OP_TYPE_REORDER_TO_FRONT",
       "11": "OP_TYPE_SET_ISOLATED_NAVIGATION",
-      "12": "OP_TYPE_REORDER_TO_BOTTOM_OF_TASK",
-      "13": "OP_TYPE_REORDER_TO_TOP_OF_TASK",
-      "14": "OP_TYPE_CREATE_OR_MOVE_TASK_FRAGMENT_DECOR_SURFACE",
-      "15": "OP_TYPE_REMOVE_TASK_FRAGMENT_DECOR_SURFACE",
-      "16": "OP_TYPE_SET_DIM_ON_TASK",
-      "17": "OP_TYPE_SET_MOVE_TO_BOTTOM_IF_CLEAR_WHEN_LAUNCH",
-      "18": "OP_TYPE_SET_DECOR_SURFACE_BOOSTED",
-      "19": "OP_TYPE_SET_PINNED",
-      "20": "OP_TYPE_SET_CAN_AFFECT_SYSTEM_UI_FLAGS"
+      "12": "OP_TYPE_CREATE_OR_MOVE_TASK_FRAGMENT_DECOR_SURFACE",
+      "13": "OP_TYPE_REMOVE_TASK_FRAGMENT_DECOR_SURFACE",
+      "14": "OP_TYPE_SET_DIM_ON_TASK",
+      "15": "OP_TYPE_SET_DECOR_SURFACE_BOOSTED",
+      "16": "OP_TYPE_SET_PINNED",
+      "1001": "OP_TYPE_PRIVILEGED_REORDER_TO_BOTTOM_OF_TASK",
+      "1002": "OP_TYPE_PRIVILEGED_REORDER_TO_TOP_OF_TASK",
+      "1003": "OP_TYPE_PRIVILEGED_SET_MOVE_TO_BOTTOM_IF_CLEAR_WHEN_LAUNCH",
+      "1004": "OP_TYPE_PRIVILEGED_SET_CAN_AFFECT_SYSTEM_UI_FLAGS"
     }
   },
   "android.window.TaskFragmentOrganizer.TaskFragmentTransitionType": {
@@ -20277,6 +20477,14 @@
       "16": "REFERENCE_WRITE_TO_PARCEL"
     }
   },
+  "android.window.TaskSnapshotManager.Resolution": {
+    "flag": false,
+    "values": {
+      "1": "RESOLUTION_HIGH",
+      "2": "RESOLUTION_LOW",
+      "3": "RESOLUTION_ANY"
+    }
+  },
   "android.window.TransitionFilter.ContainerOrder": {
     "flag": false,
     "values": {
@@ -20285,7 +20493,7 @@
     }
   },
   "android.window.TransitionInfo.ChangeFlags": {
-    "flag": false,
+    "flag": true,
     "values": {
       "0": "FLAG_NONE",
       "1": "FLAG_SHOW_WALLPAPER",
@@ -20332,12 +20540,16 @@
       "2": "CHANGE_BOUNDS_TRANSACTION",
       "4": "CHANGE_PIP_CALLBACK",
       "8": "CHANGE_HIDDEN",
-      "16": "CHANGE_BOUNDS_TRANSACTION_RECT",
-      "32": "CHANGE_IGNORE_ORIENTATION_REQUEST",
-      "64": "CHANGE_FORCE_NO_PIP",
-      "128": "CHANGE_FORCE_TRANSLUCENT",
-      "256": "CHANGE_DRAG_RESIZING",
-      "512": "CHANGE_RELATIVE_BOUNDS"
+      "16": "CHANGE_IGNORE_ORIENTATION_REQUEST",
+      "32": "CHANGE_FORCE_NO_PIP",
+      "64": "CHANGE_FORCE_TRANSLUCENT",
+      "128": "CHANGE_DRAG_RESIZING",
+      "256": "CHANGE_RELATIVE_BOUNDS",
+      "512": "CHANGE_FORCE_EXCLUDED_FROM_RECENTS",
+      "1024": "CHANGE_LAUNCH_NEXT_TO_BUBBLE",
+      "2048": "CHANGE_DISABLE_PIP",
+      "4096": "CHANGE_DISABLE_LAUNCH_ADJACENT",
+      "8192": "CHANGE_IS_TASK_MOVE_ALLOWED"
     }
   },
   "android.window.WindowContainerTransaction.HierarchyOp.HierarchyOpType": {
@@ -20366,8 +20578,10 @@
       "20": "HIERARCHY_OP_TYPE_RESTORE_BACK_NAVIGATION",
       "21": "HIERARCHY_OP_TYPE_SET_EXCLUDE_INSETS_TYPES",
       "22": "HIERARCHY_OP_TYPE_SET_KEYGUARD_STATE",
-      "23": "HIERARCHY_OP_TYPE_SET_DISABLE_LAUNCH_ADJACENT",
-      "24": "HIERARCHY_OP_TYPE_REMOVE_ROOT_TASK"
+      "23": "HIERARCHY_OP_TYPE_REMOVE_ROOT_TASK",
+      "24": "HIERARCHY_OP_TYPE_APP_COMPAT_REACHABILITY",
+      "25": "HIERARCHY_OP_TYPE_SET_SAFE_REGION_BOUNDS",
+      "26": "HIERARCHY_OP_TYPE_SET_SYSTEM_BAR_VISIBILITY_OVERRIDE"
     }
   },
   "android.window.WindowContextController.AttachStatus": {
@@ -20602,7 +20816,9 @@
       "55": "CONTROL_WINDOW_INSETS_ANIMATION",
       "56": "SHOW_INPUT_TARGET_CHANGED",
       "57": "HIDE_INPUT_TARGET_CHANGED",
-      "58": "HIDE_WINDOW_LOST_FOCUS"
+      "58": "HIDE_WINDOW_LOST_FOCUS",
+      "59": "IME_REQUESTED_CHANGED_LISTENER",
+      "60": "HIDE_FOR_BUBBLES_WHEN_LOCKED"
     }
   },
   "com.android.internal.inputmethod.StartInputFlags": {
@@ -20760,7 +20976,19 @@
       "122": "CUJ_DESKTOP_MODE_CLOSE_TASK",
       "123": "CUJ_DESKTOP_MODE_APP_LAUNCH_FROM_INTENT",
       "124": "CUJ_DESKTOP_MODE_APP_LAUNCH_FROM_ICON",
-      "125": "CUJ_DESKTOP_MODE_KEYBOARD_QUICK_SWITCH_APP_LAUNCH"
+      "125": "CUJ_DESKTOP_MODE_KEYBOARD_QUICK_SWITCH_APP_LAUNCH",
+      "126": "CUJ_LAUNCHER_WORK_UTILITY_VIEW_EXPAND",
+      "127": "CUJ_LAUNCHER_WORK_UTILITY_VIEW_SHRINK",
+      "128": "CUJ_DEFAULT_TASK_TO_TASK_ANIMATION",
+      "129": "CUJ_DESKTOP_MODE_MOVE_WINDOW_TO_DISPLAY",
+      "130": "CUJ_STATUS_BAR_APP_RETURN_TO_CALL_CHIP",
+      "131": "CUJ_NOTIFICATIONS_ANIMATED_ACTION",
+      "132": "CUJ_LPP_ASSIST_INVOCATION_EFFECT",
+      "133": "CUJ_WEAR_CAROUSEL_SCROLL_JANK",
+      "134": "CUJ_WEAR_CAROUSEL_FLING_JANK",
+      "135": "CUJ_WEAR_CAROUSEL_SWIPE_JANK",
+      "136": "CUJ_WEAR_QSS_TRAY_OPEN",
+      "137": "CUJ_WEAR_NOTIFICATION_TRAY_OPEN"
     }
   },
   "com.android.internal.jank.DisplayRefreshRate.RefreshRate": {
@@ -20857,22 +21085,6 @@
       "8": "CTRL_BOTTOM"
     }
   },
-  "com.android.internal.power.EnergyConsumerStats.StandardPowerBucket": {
-    "flag": false,
-    "values": {
-      "-1": "POWER_BUCKET_UNKNOWN",
-      "0": "POWER_BUCKET_SCREEN_ON",
-      "1": "POWER_BUCKET_SCREEN_DOZE",
-      "2": "POWER_BUCKET_SCREEN_OTHER",
-      "3": "POWER_BUCKET_CPU",
-      "4": "POWER_BUCKET_WIFI",
-      "5": "POWER_BUCKET_BLUETOOTH",
-      "6": "POWER_BUCKET_GNSS",
-      "7": "POWER_BUCKET_MOBILE_RADIO",
-      "8": "POWER_BUCKET_CAMERA",
-      "9": "POWER_BUCKET_PHONE"
-    }
-  },
   "com.android.internal.power.ModemPowerProfile.ModemDrainType": {
     "flag": false,
     "values": {
@@ -20942,7 +21154,11 @@
       "26": "ACTION_NOTIFICATIONS_HIDDEN_FOR_MEASURE",
       "27": "ACTION_NOTIFICATIONS_HIDDEN_FOR_MEASURE_WITH_SHADE_OPEN",
       "28": "ACTION_KEYGUARD_FACE_UNLOCK_TO_HOME",
-      "29": "ACTION_SHADE_WINDOW_DISPLAY_CHANGE"
+      "29": "ACTION_SHADE_WINDOW_DISPLAY_CHANGE",
+      "30": "ACTION_DESKTOP_MODE_ENTER_APP_HANDLE_DRAG",
+      "31": "ACTION_DESKTOP_MODE_ENTER_APP_HANDLE_MENU",
+      "32": "ACTION_DESKTOP_MODE_EXIT_MODE",
+      "33": "ACTION_DESKTOP_MODE_EXIT_MODE_ON_LAST_WINDOW_CLOSE"
     }
   },
   "com.android.internal.util.ObservableServiceConnection.DisconnectReason": {
@@ -20989,7 +21205,8 @@
       "32": "STRONG_AUTH_REQUIRED_AFTER_USER_LOCKDOWN",
       "128": "STRONG_AUTH_REQUIRED_AFTER_NON_STRONG_BIOMETRICS_TIMEOUT",
       "256": "SOME_AUTH_REQUIRED_AFTER_TRUSTAGENT_EXPIRED",
-      "512": "SOME_AUTH_REQUIRED_AFTER_ADAPTIVE_AUTH_REQUEST"
+      "512": "SOME_AUTH_REQUIRED_AFTER_ADAPTIVE_AUTH_REQUEST",
+      "1024": "SOME_AUTH_REQUIRED_AFTER_WATCH_DISCONNECTED"
     }
   },
   "com.android.internal.widget.LockPatternUtils.VerifyFlag": {
@@ -20999,19 +21216,6 @@
       "2": "VERIFY_FLAG_WRITE_REPAIR_MODE_PW"
     }
   },
-  "com.android.internal.widget.LockSettingsInternal.ArmRebootEscrowErrorCode": {
-    "flag": false,
-    "values": {
-      "0": "ARM_REBOOT_ERROR_NONE",
-      "1": "ARM_REBOOT_ERROR_UNSPECIFIED",
-      "2": "ARM_REBOOT_ERROR_ESCROW_NOT_READY",
-      "3": "ARM_REBOOT_ERROR_NO_PROVIDER",
-      "4": "ARM_REBOOT_ERROR_PROVIDER_MISMATCH",
-      "5": "ARM_REBOOT_ERROR_NO_ESCROW_KEY",
-      "6": "ARM_REBOOT_ERROR_KEYSTORE_FAILURE",
-      "7": "ARM_REBOOT_ERROR_STORE_ESCROW_KEY"
-    }
-  },
   "com.android.internal.widget.MessagingGroup.ImageDisplayLocation": {
     "flag": false,
     "values": {
@@ -21046,6 +21250,14 @@
       "1": "RESPONSE_RETRY"
     }
   },
+  "com.android.internal.widget.floatingtoolbar.RemoteFloatingToolbarPopup.ToolbarState": {
+    "flag": false,
+    "values": {
+      "1": "TOOLBAR_STATE_SHOWN",
+      "2": "TOOLBAR_STATE_HIDDEN",
+      "3": "TOOLBAR_STATE_DISMISSED"
+    }
+  },
   "com.android.net.module.util.DnsPacket.RecordType": {
     "flag": false,
     "values": {
diff --git a/tools/winscope/src/common/string_utils.ts b/tools/winscope/src/common/string_utils.ts
index 5baa0206b..05bd8ff2b 100644
--- a/tools/winscope/src/common/string_utils.ts
+++ b/tools/winscope/src/common/string_utils.ts
@@ -13,96 +13,142 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+import {
+  decode as protobufBase64Decode,
+  encode as protobufBase64Encode,
+  length as protobufBase64Length,
+} from '@protobufjs/base64';
 import {assertTrue} from './assert_utils';
 
 /**
  * String utility functions.
  */
-export class StringUtils {
-  static parseBigIntStrippingUnit(s: string): bigint {
-    const match = s.match(/^\s*(-?\d+)\D*.*$/);
-    if (!match) {
-      throw new Error(`Cannot parse '${s}' as bigint`);
-    }
-    return BigInt(match[1]);
+export function parseBigIntStrippingUnit(s: string): bigint {
+  const match = s.match(/^\s*(-?\d+)\D*.*$/);
+  if (!match) {
+    throw new Error(`Cannot parse '${s}' as bigint`);
   }
+  return BigInt(match[1]);
+}
 
-  static convertCamelToSnakeCase(s: string): string {
-    const result: string[] = [];
-
-    let prevChar: string | undefined;
-    for (const currChar of s) {
-      const prevCharCouldBeWordEnd =
-        prevChar &&
-        (StringUtils.isDigit(prevChar) || StringUtils.isLowerCase(prevChar));
-      const currCharCouldBeWordStart = StringUtils.isUpperCase(currChar);
-      if (prevCharCouldBeWordEnd && currCharCouldBeWordStart) {
-        result.push('_');
-        result.push(currChar.toLowerCase());
-      } else {
-        result.push(currChar);
-      }
-      prevChar = currChar;
-    }
+export function convertCamelToSnakeCase(s: string): string {
+  const result: string[] = [];
 
-    return result.join('');
+  let prevChar: string | undefined;
+  for (const currChar of s) {
+    const prevCharCouldBeWordEnd =
+      prevChar && (isDigit(prevChar) || isLowerCase(prevChar));
+    const currCharCouldBeWordStart = isUpperCase(currChar);
+    if (prevCharCouldBeWordEnd && currCharCouldBeWordStart) {
+      result.push('_');
+      result.push(currChar.toLowerCase());
+    } else {
+      result.push(currChar);
+    }
+    prevChar = currChar;
   }
 
-  static convertSnakeToCamelCase(s: string): string {
-    const tokens = s.split('_').filter((token) => token.length > 0);
-    const tokensCapitalized = tokens.map((token) => {
-      return StringUtils.capitalizeFirstCharIfAlpha(token);
-    });
-
-    const inputStartsWithUnderscore = s[0] === '_';
-    let result = inputStartsWithUnderscore ? '_' : '';
-    result += tokens[0];
-    for (const token of tokensCapitalized.slice(1)) {
-      if (!StringUtils.isAlpha(token[0])) {
-        result += '_';
-      }
-      result += token;
-    }
+  return result.join('');
+}
 
-    return result;
-  }
+export function convertSnakeToCamelCase(s: string): string {
+  const tokens = s.split('_').filter((token) => token.length > 0);
+  const tokensCapitalized = tokens.map((token) => {
+    return capitalizeFirstCharIfAlpha(token);
+  });
 
-  static isAlpha(char: string): boolean {
-    assertTrue(char.length === 1, () => 'Input must be a single character');
-    return char[0].toLowerCase() !== char[0].toUpperCase();
+  const inputStartsWithUnderscore = s[0] === '_';
+  let result = inputStartsWithUnderscore ? '_' : '';
+  result += tokens[0];
+  for (const token of tokensCapitalized.slice(1)) {
+    if (!isAlpha(token[0])) {
+      result += '_';
+    }
+    result += token;
   }
 
-  static isDigit(char: string): boolean {
-    assertTrue(char.length === 1, () => 'Input must be a single character');
-    return char >= '0' && char <= '9';
-  }
+  return result;
+}
 
-  static isLowerCase(char: string): boolean {
-    assertTrue(char.length === 1, () => 'Input must be a single character');
-    return StringUtils.isAlpha(char) && char === char.toLowerCase();
-  }
+export function isAlpha(char: string): boolean {
+  assertTrue(char.length === 1, () => 'Input must be a single character');
+  return char[0].toLowerCase() !== char[0].toUpperCase();
+}
 
-  static isUpperCase(char: string): boolean {
-    assertTrue(char.length === 1, () => 'Input must be a single character');
-    return StringUtils.isAlpha(char) && char === char.toUpperCase();
-  }
+export function isDigit(char: string): boolean {
+  assertTrue(char.length === 1, () => 'Input must be a single character');
+  return char >= '0' && char <= '9';
+}
 
-  static isBlank(str: string): boolean {
-    return str.replace(/\s/g, '').length === 0;
+export function isLowerCase(char: string): boolean {
+  assertTrue(char.length === 1, () => 'Input must be a single character');
+  return isAlpha(char) && char === char.toLowerCase();
+}
+
+export function isUpperCase(char: string): boolean {
+  assertTrue(char.length === 1, () => 'Input must be a single character');
+  return isAlpha(char) && char === char.toUpperCase();
+}
+
+export function isBlank(str: string): boolean {
+  return str.replace(/\s/g, '').length === 0;
+}
+
+export function isNumeric(str: string): boolean {
+  return Number(str).toString() === str;
+}
+
+export function binaryEncode(str: string): Uint8Array {
+  const data = new Uint8Array(str.length);
+  for (let i = 0; i < str.length; ++i) {
+    data[i] = str.charCodeAt(i);
   }
+  return data;
+}
 
-  static isNumeric(str: string): boolean {
-    return Number(str).toString() === str;
+export function binaryDecode(buf: Uint8Array): string {
+  let str = '';
+  for (let i = 0; i < buf.length; i++) {
+    str += String.fromCharCode(buf[i]);
   }
+  return str;
+}
 
-  private static capitalizeFirstCharIfAlpha(word: string): string {
-    if (word.length === 0) {
-      return word;
-    }
+export function utf8Encode(data: string): Uint8Array {
+  return new TextEncoder().encode(data);
+}
 
-    if (!StringUtils.isAlpha(word[0])) {
-      return word;
-    }
-    return word[0].toUpperCase() + word.slice(1);
+export function utf8Decode(data: Uint8Array): string {
+  return new TextDecoder('utf-8').decode(data);
+}
+
+export function hexEncode(bytes: Uint8Array): string {
+  return bytes.reduce(
+    (prev, curr) => prev + ('0' + curr.toString(16)).slice(-2),
+    '',
+  );
+}
+
+export function base64Decode(str: string): Uint8Array {
+  // if the string is in base64url format, convert to base64
+  const b64 = str.replace('-', '+').replace('_', '/');
+  const arr = new Uint8Array(protobufBase64Length(b64));
+  const written = protobufBase64Decode(b64, arr, 0);
+  assertTrue(written === arr.length);
+  return arr;
+}
+
+export function base64Encode(buffer: Uint8Array): string {
+  return protobufBase64Encode(buffer, 0, buffer.length);
+}
+
+function capitalizeFirstCharIfAlpha(word: string): string {
+  if (word.length === 0) {
+    return word;
+  }
+
+  if (!isAlpha(word[0])) {
+    return word;
   }
+  return word[0].toUpperCase() + word.slice(1);
 }
diff --git a/tools/winscope/src/common/string_utils_test.ts b/tools/winscope/src/common/string_utils_test.ts
index ec79b4686..d95eb3b52 100644
--- a/tools/winscope/src/common/string_utils_test.ts
+++ b/tools/winscope/src/common/string_utils_test.ts
@@ -14,187 +14,161 @@
  * limitations under the License.
  */
 
-import {StringUtils} from './string_utils';
+import {
+  convertCamelToSnakeCase,
+  convertSnakeToCamelCase,
+  isAlpha,
+  isBlank,
+  isDigit,
+  isLowerCase,
+  isNumeric,
+  isUpperCase,
+  parseBigIntStrippingUnit,
+} from './string_utils';
 
 describe('StringUtils', () => {
   it('parses bigint', () => {
-    expect(StringUtils.parseBigIntStrippingUnit('-10')).toEqual(-10n);
-    expect(StringUtils.parseBigIntStrippingUnit('-10 unit')).toEqual(-10n);
-    expect(StringUtils.parseBigIntStrippingUnit('-10unit')).toEqual(-10n);
-    expect(StringUtils.parseBigIntStrippingUnit(' -10 unit ')).toEqual(-10n);
-
-    expect(StringUtils.parseBigIntStrippingUnit('0')).toEqual(0n);
-    expect(StringUtils.parseBigIntStrippingUnit('0 unit')).toEqual(0n);
-    expect(StringUtils.parseBigIntStrippingUnit('0unit')).toEqual(0n);
-    expect(StringUtils.parseBigIntStrippingUnit(' 0 unit ')).toEqual(0n);
-
-    expect(StringUtils.parseBigIntStrippingUnit('10')).toEqual(10n);
-    expect(StringUtils.parseBigIntStrippingUnit('10 unit')).toEqual(10n);
-    expect(StringUtils.parseBigIntStrippingUnit('10unit')).toEqual(10n);
-    expect(StringUtils.parseBigIntStrippingUnit(' 10 unit ')).toEqual(10n);
-
-    expect(() => StringUtils.parseBigIntStrippingUnit('invalid')).toThrow();
-    expect(() =>
-      StringUtils.parseBigIntStrippingUnit('invalid 10 unit'),
-    ).toThrow();
+    expect(parseBigIntStrippingUnit('-10')).toEqual(-10n);
+    expect(parseBigIntStrippingUnit('-10 unit')).toEqual(-10n);
+    expect(parseBigIntStrippingUnit('-10unit')).toEqual(-10n);
+    expect(parseBigIntStrippingUnit(' -10 unit ')).toEqual(-10n);
+
+    expect(parseBigIntStrippingUnit('0')).toEqual(0n);
+    expect(parseBigIntStrippingUnit('0 unit')).toEqual(0n);
+    expect(parseBigIntStrippingUnit('0unit')).toEqual(0n);
+    expect(parseBigIntStrippingUnit(' 0 unit ')).toEqual(0n);
+
+    expect(parseBigIntStrippingUnit('10')).toEqual(10n);
+    expect(parseBigIntStrippingUnit('10 unit')).toEqual(10n);
+    expect(parseBigIntStrippingUnit('10unit')).toEqual(10n);
+    expect(parseBigIntStrippingUnit(' 10 unit ')).toEqual(10n);
+
+    expect(() => parseBigIntStrippingUnit('invalid')).toThrow();
+    expect(() => parseBigIntStrippingUnit('invalid 10 unit')).toThrow();
   });
 
   it('convertCamelToSnakeCase()', () => {
-    expect(StringUtils.convertCamelToSnakeCase('aaa')).toEqual('aaa');
-    expect(StringUtils.convertCamelToSnakeCase('Aaa')).toEqual('Aaa');
-    expect(StringUtils.convertCamelToSnakeCase('_aaa')).toEqual('_aaa');
-    expect(StringUtils.convertCamelToSnakeCase('_Aaa')).toEqual('_Aaa');
-
-    expect(StringUtils.convertCamelToSnakeCase('aaaBbb')).toEqual('aaa_bbb');
-    expect(StringUtils.convertCamelToSnakeCase('AaaBbb')).toEqual('Aaa_bbb');
-    expect(StringUtils.convertCamelToSnakeCase('aaa_bbb')).toEqual('aaa_bbb');
-    expect(StringUtils.convertCamelToSnakeCase('aaa_Bbb')).toEqual('aaa_Bbb');
-
-    expect(StringUtils.convertCamelToSnakeCase('aaaBbbCcc')).toEqual(
-      'aaa_bbb_ccc',
-    );
-    expect(StringUtils.convertCamelToSnakeCase('aaaBbb_ccc')).toEqual(
-      'aaa_bbb_ccc',
-    );
-    expect(StringUtils.convertCamelToSnakeCase('aaaBbb_Ccc')).toEqual(
-      'aaa_bbb_Ccc',
-    );
-
-    expect(StringUtils.convertCamelToSnakeCase('aaaBBBccc')).toEqual(
-      'aaa_bBBccc',
-    );
-    expect(StringUtils.convertCamelToSnakeCase('aaaBBBcccDDD')).toEqual(
-      'aaa_bBBccc_dDD',
-    );
-    expect(StringUtils.convertCamelToSnakeCase('aaaBBB_ccc')).toEqual(
-      'aaa_bBB_ccc',
-    );
-    expect(StringUtils.convertCamelToSnakeCase('aaaBbb_CCC')).toEqual(
-      'aaa_bbb_CCC',
-    );
-
-    expect(StringUtils.convertCamelToSnakeCase('_field_32')).toEqual(
-      '_field_32',
-    );
-    expect(StringUtils.convertCamelToSnakeCase('field_32')).toEqual('field_32');
-    expect(StringUtils.convertCamelToSnakeCase('field_32Bits')).toEqual(
-      'field_32_bits',
-    );
-    expect(StringUtils.convertCamelToSnakeCase('field_32BitsLsb')).toEqual(
+    expect(convertCamelToSnakeCase('aaa')).toEqual('aaa');
+    expect(convertCamelToSnakeCase('Aaa')).toEqual('Aaa');
+    expect(convertCamelToSnakeCase('_aaa')).toEqual('_aaa');
+    expect(convertCamelToSnakeCase('_Aaa')).toEqual('_Aaa');
+
+    expect(convertCamelToSnakeCase('aaaBbb')).toEqual('aaa_bbb');
+    expect(convertCamelToSnakeCase('AaaBbb')).toEqual('Aaa_bbb');
+    expect(convertCamelToSnakeCase('aaa_bbb')).toEqual('aaa_bbb');
+    expect(convertCamelToSnakeCase('aaa_Bbb')).toEqual('aaa_Bbb');
+
+    expect(convertCamelToSnakeCase('aaaBbbCcc')).toEqual('aaa_bbb_ccc');
+    expect(convertCamelToSnakeCase('aaaBbb_ccc')).toEqual('aaa_bbb_ccc');
+    expect(convertCamelToSnakeCase('aaaBbb_Ccc')).toEqual('aaa_bbb_Ccc');
+
+    expect(convertCamelToSnakeCase('aaaBBBccc')).toEqual('aaa_bBBccc');
+    expect(convertCamelToSnakeCase('aaaBBBcccDDD')).toEqual('aaa_bBBccc_dDD');
+    expect(convertCamelToSnakeCase('aaaBBB_ccc')).toEqual('aaa_bBB_ccc');
+    expect(convertCamelToSnakeCase('aaaBbb_CCC')).toEqual('aaa_bbb_CCC');
+
+    expect(convertCamelToSnakeCase('_field_32')).toEqual('_field_32');
+    expect(convertCamelToSnakeCase('field_32')).toEqual('field_32');
+    expect(convertCamelToSnakeCase('field_32Bits')).toEqual('field_32_bits');
+    expect(convertCamelToSnakeCase('field_32BitsLsb')).toEqual(
       'field_32_bits_lsb',
     );
-    expect(StringUtils.convertCamelToSnakeCase('field_32bits')).toEqual(
-      'field_32bits',
-    );
-    expect(StringUtils.convertCamelToSnakeCase('field_32bitsLsb')).toEqual(
+    expect(convertCamelToSnakeCase('field_32bits')).toEqual('field_32bits');
+    expect(convertCamelToSnakeCase('field_32bitsLsb')).toEqual(
       'field_32bits_lsb',
     );
 
-    expect(StringUtils.convertCamelToSnakeCase('_aaaAaa.bbbBbb')).toEqual(
+    expect(convertCamelToSnakeCase('_aaaAaa.bbbBbb')).toEqual(
       '_aaa_aaa.bbb_bbb',
     );
-    expect(StringUtils.convertCamelToSnakeCase('aaaAaa.bbbBbb')).toEqual(
-      'aaa_aaa.bbb_bbb',
+    expect(convertCamelToSnakeCase('aaaAaa.bbbBbb')).toEqual('aaa_aaa.bbb_bbb');
+    expect(convertCamelToSnakeCase('aaaAaa.field_32bitsLsb.bbbBbb')).toEqual(
+      'aaa_aaa.field_32bits_lsb.bbb_bbb',
     );
-    expect(
-      StringUtils.convertCamelToSnakeCase('aaaAaa.field_32bitsLsb.bbbBbb'),
-    ).toEqual('aaa_aaa.field_32bits_lsb.bbb_bbb');
   });
 
   it('convertSnakeToCamelCase()', () => {
-    expect(StringUtils.convertSnakeToCamelCase('_aaa')).toEqual('_aaa');
-    expect(StringUtils.convertSnakeToCamelCase('aaa')).toEqual('aaa');
+    expect(convertSnakeToCamelCase('_aaa')).toEqual('_aaa');
+    expect(convertSnakeToCamelCase('aaa')).toEqual('aaa');
 
-    expect(StringUtils.convertSnakeToCamelCase('aaa_bbb')).toEqual('aaaBbb');
-    expect(StringUtils.convertSnakeToCamelCase('_aaa_bbb')).toEqual('_aaaBbb');
+    expect(convertSnakeToCamelCase('aaa_bbb')).toEqual('aaaBbb');
+    expect(convertSnakeToCamelCase('_aaa_bbb')).toEqual('_aaaBbb');
 
-    expect(StringUtils.convertSnakeToCamelCase('aaa_bbb_ccc')).toEqual(
-      'aaaBbbCcc',
-    );
-    expect(StringUtils.convertSnakeToCamelCase('_aaa_bbb_ccc')).toEqual(
-      '_aaaBbbCcc',
-    );
+    expect(convertSnakeToCamelCase('aaa_bbb_ccc')).toEqual('aaaBbbCcc');
+    expect(convertSnakeToCamelCase('_aaa_bbb_ccc')).toEqual('_aaaBbbCcc');
 
-    expect(StringUtils.convertSnakeToCamelCase('_field_32')).toEqual(
-      '_field_32',
-    );
-    expect(StringUtils.convertSnakeToCamelCase('field_32')).toEqual('field_32');
-    expect(StringUtils.convertSnakeToCamelCase('field_32_bits')).toEqual(
-      'field_32Bits',
-    );
-    expect(StringUtils.convertSnakeToCamelCase('field_32_bits_lsb')).toEqual(
+    expect(convertSnakeToCamelCase('_field_32')).toEqual('_field_32');
+    expect(convertSnakeToCamelCase('field_32')).toEqual('field_32');
+    expect(convertSnakeToCamelCase('field_32_bits')).toEqual('field_32Bits');
+    expect(convertSnakeToCamelCase('field_32_bits_lsb')).toEqual(
       'field_32BitsLsb',
     );
-    expect(StringUtils.convertSnakeToCamelCase('field_32bits')).toEqual(
-      'field_32bits',
-    );
-    expect(StringUtils.convertSnakeToCamelCase('field_32bits_lsb')).toEqual(
+    expect(convertSnakeToCamelCase('field_32bits')).toEqual('field_32bits');
+    expect(convertSnakeToCamelCase('field_32bits_lsb')).toEqual(
       'field_32bitsLsb',
     );
 
-    expect(StringUtils.convertSnakeToCamelCase('_aaa_aaa.bbb_bbb')).toEqual(
+    expect(convertSnakeToCamelCase('_aaa_aaa.bbb_bbb')).toEqual(
       '_aaaAaa.bbbBbb',
     );
-    expect(StringUtils.convertSnakeToCamelCase('aaa_aaa.bbb_bbb')).toEqual(
-      'aaaAaa.bbbBbb',
+    expect(convertSnakeToCamelCase('aaa_aaa.bbb_bbb')).toEqual('aaaAaa.bbbBbb');
+    expect(convertSnakeToCamelCase('aaa_aaa.field_32bits_lsb.bbb_bbb')).toEqual(
+      'aaaAaa.field_32bitsLsb.bbbBbb',
     );
-    expect(
-      StringUtils.convertSnakeToCamelCase('aaa_aaa.field_32bits_lsb.bbb_bbb'),
-    ).toEqual('aaaAaa.field_32bitsLsb.bbbBbb');
   });
 
   it('isAlpha()', () => {
-    expect(StringUtils.isAlpha('a')).toBeTrue();
-    expect(StringUtils.isAlpha('A')).toBeTrue();
-    expect(StringUtils.isAlpha('_')).toBeFalse();
-    expect(StringUtils.isAlpha('0')).toBeFalse();
-    expect(StringUtils.isAlpha('9')).toBeFalse();
+    expect(isAlpha('a')).toBeTrue();
+    expect(isAlpha('A')).toBeTrue();
+    expect(isAlpha('_')).toBeFalse();
+    expect(isAlpha('0')).toBeFalse();
+    expect(isAlpha('9')).toBeFalse();
   });
 
   it('isDigit()', () => {
-    expect(StringUtils.isDigit('a')).toBeFalse();
-    expect(StringUtils.isDigit('A')).toBeFalse();
-    expect(StringUtils.isDigit('_')).toBeFalse();
-    expect(StringUtils.isDigit('0')).toBeTrue();
-    expect(StringUtils.isDigit('9')).toBeTrue();
+    expect(isDigit('a')).toBeFalse();
+    expect(isDigit('A')).toBeFalse();
+    expect(isDigit('_')).toBeFalse();
+    expect(isDigit('0')).toBeTrue();
+    expect(isDigit('9')).toBeTrue();
   });
 
   it('isLowerCase()', () => {
-    expect(StringUtils.isLowerCase('a')).toBeTrue();
-    expect(StringUtils.isLowerCase('z')).toBeTrue();
-    expect(StringUtils.isLowerCase('A')).toBeFalse();
-    expect(StringUtils.isLowerCase('Z')).toBeFalse();
-    expect(StringUtils.isLowerCase('_')).toBeFalse();
-    expect(StringUtils.isLowerCase('0')).toBeFalse();
-    expect(StringUtils.isLowerCase('9')).toBeFalse();
+    expect(isLowerCase('a')).toBeTrue();
+    expect(isLowerCase('z')).toBeTrue();
+    expect(isLowerCase('A')).toBeFalse();
+    expect(isLowerCase('Z')).toBeFalse();
+    expect(isLowerCase('_')).toBeFalse();
+    expect(isLowerCase('0')).toBeFalse();
+    expect(isLowerCase('9')).toBeFalse();
   });
 
   it('isUpperCase()', () => {
-    expect(StringUtils.isUpperCase('A')).toBeTrue();
-    expect(StringUtils.isUpperCase('Z')).toBeTrue();
-    expect(StringUtils.isUpperCase('a')).toBeFalse();
-    expect(StringUtils.isUpperCase('z')).toBeFalse();
-    expect(StringUtils.isUpperCase('_')).toBeFalse();
-    expect(StringUtils.isUpperCase('0')).toBeFalse();
-    expect(StringUtils.isUpperCase('9')).toBeFalse();
+    expect(isUpperCase('A')).toBeTrue();
+    expect(isUpperCase('Z')).toBeTrue();
+    expect(isUpperCase('a')).toBeFalse();
+    expect(isUpperCase('z')).toBeFalse();
+    expect(isUpperCase('_')).toBeFalse();
+    expect(isUpperCase('0')).toBeFalse();
+    expect(isUpperCase('9')).toBeFalse();
   });
 
   it('isBlank()', () => {
-    expect(StringUtils.isBlank('')).toBeTrue();
-    expect(StringUtils.isBlank(' ')).toBeTrue();
-    expect(StringUtils.isBlank('  ')).toBeTrue();
-    expect(StringUtils.isBlank(' a')).toBeFalse();
-    expect(StringUtils.isBlank('a ')).toBeFalse();
-    expect(StringUtils.isBlank(' a ')).toBeFalse();
-    expect(StringUtils.isBlank('a  a')).toBeFalse();
+    expect(isBlank('')).toBeTrue();
+    expect(isBlank(' ')).toBeTrue();
+    expect(isBlank('  ')).toBeTrue();
+    expect(isBlank(' a')).toBeFalse();
+    expect(isBlank('a ')).toBeFalse();
+    expect(isBlank(' a ')).toBeFalse();
+    expect(isBlank('a  a')).toBeFalse();
   });
 
   it('isNumeric()', () => {
-    expect(StringUtils.isNumeric('0')).toBeTrue();
-    expect(StringUtils.isNumeric('1')).toBeTrue();
-    expect(StringUtils.isNumeric('0.1')).toBeTrue();
-    expect(StringUtils.isNumeric('')).toBeFalse();
-    expect(StringUtils.isNumeric('a')).toBeFalse();
-    expect(StringUtils.isNumeric('4n')).toBeFalse();
+    expect(isNumeric('0')).toBeTrue();
+    expect(isNumeric('1')).toBeTrue();
+    expect(isNumeric('0.1')).toBeTrue();
+    expect(isNumeric('')).toBeFalse();
+    expect(isNumeric('a')).toBeFalse();
+    expect(isNumeric('4n')).toBeFalse();
   });
 });
diff --git a/tools/winscope/src/common/time/test_utils.ts b/tools/winscope/src/common/time/test_utils.ts
index 1190ee45f..0b6c3e744 100644
--- a/tools/winscope/src/common/time/test_utils.ts
+++ b/tools/winscope/src/common/time/test_utils.ts
@@ -93,3 +93,11 @@ export function timestampEqualityTester(
 }
 
 export const TimestampConverterUtils = new TimestampConverterTestUtils();
+
+export function getTimestampConverter(
+  withUTCOffset = false,
+): TimestampConverter {
+  return withUTCOffset
+    ? new TimestampConverter(TimestampConverterUtils.ASIA_TIMEZONE_INFO)
+    : new TimestampConverter(TimestampConverterUtils.UTC_TIMEZONE_INFO);
+}
diff --git a/tools/winscope/src/common/time/time_duration.ts b/tools/winscope/src/common/time/time_duration.ts
index 87355b349..0cace90b7 100644
--- a/tools/winscope/src/common/time/time_duration.ts
+++ b/tools/winscope/src/common/time/time_duration.ts
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-import {BigintMath} from 'common/bigint_math';
+import {divideAndRound} from 'common/bigint_math';
 import {TIME_UNIT_TO_NANO} from 'common/time/time_units';
 
 export class TimeDuration {
@@ -24,7 +24,7 @@ export class TimeDuration {
   }
 
   format(): string {
-    const msString = BigintMath.divideAndRound(
+    const msString = divideAndRound(
       this.timeDiffNs,
       BigInt(TIME_UNIT_TO_NANO.ms),
     );
diff --git a/tools/winscope/src/common/time/timestamp_converter.ts b/tools/winscope/src/common/time/timestamp_converter.ts
index 64d9f3214..a8858817e 100644
--- a/tools/winscope/src/common/time/timestamp_converter.ts
+++ b/tools/winscope/src/common/time/timestamp_converter.ts
@@ -15,7 +15,7 @@
  */
 
 import {assertDefined, assertTrue} from 'common/assert_utils';
-import {BigintMath} from 'common/bigint_math';
+import {divideAndRound} from 'common/bigint_math';
 import {
   INVALID_TIME_NS,
   Timestamp,
@@ -45,10 +45,7 @@ class RealTimestampFormatter implements TimestampFormatter {
   format(timestamp: Timestamp, type: TimestampFormatType): string {
     const timestampNanos =
       timestamp.getValueNs() + (this.utcOffset.getValueNs() ?? 0n);
-    const ms = BigintMath.divideAndRound(
-      timestampNanos,
-      BigInt(TIME_UNIT_TO_NANO.ms),
-    );
+    const ms = divideAndRound(timestampNanos, BigInt(TIME_UNIT_TO_NANO.ms));
     const formattedTimestamp = new Date(Number(ms))
       .toISOString()
       .replace('Z', '')
diff --git a/tools/winscope/src/logging/analytics.ts b/tools/winscope/src/logging/analytics.ts
index 38807d25e..26bb212b5 100644
--- a/tools/winscope/src/logging/analytics.ts
+++ b/tools/winscope/src/logging/analytics.ts
@@ -295,10 +295,8 @@ export class Analytics {
   };
 
   static TraceProcessor = class {
-    static logQueryExecutionTime(ms: number, waitAllRows: boolean) {
-      Analytics.logTimeMs(Analytics.TP_GENERAL_QUERY_TIME, ms, {
-        waitAllRows,
-      });
+    static logQueryExecutionTime(ms: number) {
+      Analytics.logTimeMs(Analytics.TP_GENERAL_QUERY_TIME, ms);
     }
   };
 
@@ -332,18 +330,23 @@ export class Analytics {
       } as Gtag.CustomParams);
     }
 
-    static logCollectDumps(requestedDumps: string[]) {
+    static logCollectDumps(requestedDumps: string[], connectionType?: string) {
       requestedDumps.forEach((dumpType) => {
         Analytics.doLogEvent(Analytics.TRACING_COLLECT_DUMP, {
           type: dumpType,
+          connectionType,
         } as Gtag.CustomParams);
       });
     }
 
-    static logCollectTraces(requestedTraces: string[]) {
+    static logCollectTraces(
+      requestedTraces: string[],
+      connectionType?: string,
+    ) {
       requestedTraces.forEach((traceType) => {
         Analytics.doLogEvent(Analytics.TRACING_COLLECT_TRACE, {
           type: traceType,
+          connectionType,
         } as Gtag.CustomParams);
       });
     }
diff --git a/tools/winscope/src/messaging/user_warnings.ts b/tools/winscope/src/messaging/user_warnings.ts
index e0327179b..8065b8d76 100644
--- a/tools/winscope/src/messaging/user_warnings.ts
+++ b/tools/winscope/src/messaging/user_warnings.ts
@@ -14,6 +14,7 @@
  * limitations under the License.
  */
 
+import {BugreportData, BuildType} from 'app/trace_file_filter';
 import {TimeRange} from 'common/time/time';
 import {TimeDuration} from 'common/time/time_duration';
 import {TRACE_INFO} from 'trace/trace_info';
@@ -50,6 +51,31 @@ export class NoValidFiles extends UserWarning {
   }
 }
 
+export class MissingPersistentTrace extends UserWarning {
+  constructor(private bugreportData: BugreportData) {
+    super();
+  }
+
+  override getDescriptor(): string {
+    return 'missing persistent trace';
+  }
+
+  override getMessage(): string {
+    const baseMessage = 'No Winscope Perfetto trace found in bug report.';
+
+    if (this.bugreportData.buildType === BuildType.USER) {
+      return `${baseMessage} This is expected on 'user' builds. Persistent tracing usually requires a 'userdebug' or 'eng' build, or root access.`;
+    }
+
+    if (!this.bugreportData.isPersistentTracingEnabled) {
+      return `${baseMessage} The persistent tracing property ('persist.debug.perfetto.persistent') seems to be disabled. You can try enabling it via:\n'adb shell setprop persist.debug.perfetto.persistent 1 && adb reboot'\nThen, reproduce the issue and capture a new bug report.`;
+    }
+
+    // Unknown issue
+    return `${baseMessage} Ensure the bugreport comes from a device where persistent tracing is enabled (e.g., dogfood devices or using 'adb shell setprop persist.debug.perfetto.persistent 1').`;
+  }
+}
+
 export class TraceHasOldData extends UserWarning {
   constructor(
     private readonly descriptor: string,
@@ -325,18 +351,16 @@ export class TraceSearchQueryFailed extends UserWarning {
   }
 }
 
-export class PerfettoPacketLoss extends UserWarning {
-  constructor(private descriptor: string, private totalPacketLoss: number) {
+export class FailedToConvertLegacyTraces extends UserWarning {
+  constructor(private readonly errorMessage: string) {
     super();
   }
 
   getDescriptor(): string {
-    return 'perfetto packet loss';
+    return 'failed to convert legacy trace';
   }
 
   getMessage(): string {
-    return `${this.descriptor}: ${this.totalPacketLoss} packet${
-      this.totalPacketLoss > 1 ? 's' : ''
-    } lost during tracing - data may be incomplete`;
+    return `Legacy to perfetto conversion failed: ${this.errorMessage}\nDiscarding legacy traces.`;
   }
 }
diff --git a/tools/winscope/src/messaging/winscope_event.ts b/tools/winscope/src/messaging/winscope_event.ts
index 0fd4b1f31..58b87eeb7 100644
--- a/tools/winscope/src/messaging/winscope_event.ts
+++ b/tools/winscope/src/messaging/winscope_event.ts
@@ -30,6 +30,8 @@ export enum WinscopeEventType {
   APP_TRACE_VIEW_REQUEST,
   APP_TRACE_VIEW_REQUEST_HANDLED,
   APP_REFRESH_DUMPS_REQUEST,
+  BUGREPORT_FILE_SELECTED,
+  BUGREPORT_FILE_SELECTION_REQUEST,
   REMOTE_TOOL_DOWNLOAD_START,
   REMOTE_TOOL_FILES_RECEIVED,
   REMOTE_TOOL_TIMESTAMP_RECEIVED,
@@ -51,6 +53,7 @@ export enum WinscopeEventType {
   TRACE_REMOVE_REQUEST,
   INITIALIZE_TRACE_SEARCH_REQUEST,
   TRACE_SEARCH_INITIALIZED,
+  SHOW_TRACE_UPLOAD_WARNING,
 }
 
 interface TypeMap {
@@ -61,6 +64,8 @@ interface TypeMap {
   [WinscopeEventType.APP_TRACE_VIEW_REQUEST]: AppTraceViewRequest;
   [WinscopeEventType.APP_TRACE_VIEW_REQUEST_HANDLED]: AppTraceViewRequestHandled;
   [WinscopeEventType.APP_REFRESH_DUMPS_REQUEST]: AppRefreshDumpsRequest;
+  [WinscopeEventType.BUGREPORT_FILE_SELECTED]: BugreportFileSelected;
+  [WinscopeEventType.BUGREPORT_FILE_SELECTION_REQUEST]: BugreportFileSelectionRequest;
   [WinscopeEventType.REMOTE_TOOL_DOWNLOAD_START]: RemoteToolDownloadStart;
   [WinscopeEventType.REMOTE_TOOL_FILES_RECEIVED]: RemoteToolFilesReceived;
   [WinscopeEventType.REMOTE_TOOL_TIMESTAMP_RECEIVED]: RemoteToolTimestampReceived;
@@ -82,6 +87,7 @@ interface TypeMap {
   [WinscopeEventType.INITIALIZE_TRACE_SEARCH_REQUEST]: InitializeTraceSearchRequest;
   [WinscopeEventType.TRACE_SEARCH_INITIALIZED]: TraceSearchInitialized;
   [WinscopeEventType.TRACE_SEARCH_COMPLETED]: TraceSearchCompleted;
+  [WinscopeEventType.SHOW_TRACE_UPLOAD_WARNING]: ShowTraceUploadWarning;
 }
 
 export abstract class WinscopeEvent {
@@ -124,6 +130,9 @@ export class AppResetRequest extends WinscopeEvent {
 
 export class AppTraceViewRequest extends WinscopeEvent {
   override readonly type = WinscopeEventType.APP_TRACE_VIEW_REQUEST;
+  constructor(readonly discardLegacyTraces = false) {
+    super();
+  }
 }
 
 export class AppTraceViewRequestHandled extends WinscopeEvent {
@@ -300,3 +309,27 @@ export class TraceSearchInitialized extends WinscopeEvent {
 export class TraceSearchCompleted extends WinscopeEvent {
   override readonly type = WinscopeEventType.TRACE_SEARCH_COMPLETED;
 }
+
+export class BugreportFileSelected extends WinscopeEvent {
+  override readonly type = WinscopeEventType.BUGREPORT_FILE_SELECTED;
+
+  constructor(readonly filename: string | undefined) {
+    super();
+  }
+}
+
+export class BugreportFileSelectionRequest extends WinscopeEvent {
+  override readonly type = WinscopeEventType.BUGREPORT_FILE_SELECTION_REQUEST;
+
+  constructor(readonly filenames: string[]) {
+    super();
+  }
+}
+
+export class ShowTraceUploadWarning extends WinscopeEvent {
+  override readonly type = WinscopeEventType.SHOW_TRACE_UPLOAD_WARNING;
+
+  constructor(readonly message: string) {
+    super();
+  }
+}
diff --git a/tools/winscope/src/trace/tree_node/property_tree_builder_from_proto.ts b/tools/winscope/src/parsers/abstract_property_tree_builder.ts
similarity index 62%
rename from tools/winscope/src/trace/tree_node/property_tree_builder_from_proto.ts
rename to tools/winscope/src/parsers/abstract_property_tree_builder.ts
index 5e91b9027..c1d39df25 100644
--- a/tools/winscope/src/trace/tree_node/property_tree_builder_from_proto.ts
+++ b/tools/winscope/src/parsers/abstract_property_tree_builder.ts
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2024 The Android Open Source Project
+ * Copyright (C) 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,18 +15,15 @@
  */
 
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
-import {PropertyTreeNodeFactory} from './property_tree_node_factory';
 
-export class PropertyTreeBuilderFromProto {
-  private denylistProperties: string[] = [];
-  private duplicateCount = 0;
-  private proto: object | undefined;
+export abstract class AbstractPropertyTreeBuilder<T> {
+  protected data: T | undefined;
   private rootId: string | number = 'UnknownRootId';
-  private rootName: string | undefined = 'UnknownRootName';
-  private visitProtoType = true;
+  protected rootName: string | undefined = 'UnknownRootName';
+  private duplicateCount = 0;
 
-  setData(value: object | undefined): this {
-    this.proto = value;
+  setData(value: T | undefined): this {
+    this.data = value;
     return this;
   }
 
@@ -40,24 +37,14 @@ export class PropertyTreeBuilderFromProto {
     return this;
   }
 
-  setDenyList(value: string[]): this {
-    this.denylistProperties = value;
-    return this;
-  }
-
   setDuplicateCount(value: number): this {
     this.duplicateCount = value;
     return this;
   }
 
-  setVisitPrototype(value: boolean): this {
-    this.visitProtoType = value;
-    return this;
-  }
-
   build(): PropertyTreeNode {
-    if (this.proto === undefined) {
-      throw new Error('proto not set');
+    if (this.data === undefined) {
+      throw new Error('data not set');
     }
     if (this.rootId === undefined) {
       throw new Error('rootId not set');
@@ -65,12 +52,8 @@ export class PropertyTreeBuilderFromProto {
     if (this.rootName === undefined) {
       throw new Error('rootName not set');
     }
-    const factory = new PropertyTreeNodeFactory(
-      this.denylistProperties,
-      this.visitProtoType,
-    );
-
-    return factory.makeProtoProperty(this.makeNodeId(), '', this.proto);
+    const rootId = this.makeNodeId();
+    return this.buildPropertiesTree(rootId);
   }
 
   private makeNodeId(): string {
@@ -80,4 +63,6 @@ export class PropertyTreeBuilderFromProto {
     }
     return nodeId;
   }
+
+  protected abstract buildPropertiesTree(rootNodeId: string): PropertyTreeNode;
 }
diff --git a/tools/winscope/src/parsers/events/operations/add_cuj_properties.ts b/tools/winscope/src/parsers/events/operations/add_cuj_properties.ts
index 439cd00d5..6fdb458c9 100644
--- a/tools/winscope/src/parsers/events/operations/add_cuj_properties.ts
+++ b/tools/winscope/src/parsers/events/operations/add_cuj_properties.ts
@@ -15,9 +15,9 @@
  */
 
 import {assertDefined} from 'common/assert_utils';
-import {StringUtils} from 'common/string_utils';
+import {isNumeric} from 'common/string_utils';
 import {EventTag} from 'parsers/events/event_tag';
-import {CujType} from 'trace/cuj_type';
+import {CujType} from 'trace/cujs/cuj_type';
 import {AddOperation} from 'trace/tree_node/operations/add_operation';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 import {DEFAULT_PROPERTY_TREE_NODE_FACTORY} from 'trace/tree_node/property_tree_node_factory';
@@ -73,10 +73,10 @@ export class AddCujProperties extends AddOperation<PropertyTreeNode> {
     }
 
     if (
-      !StringUtils.isNumeric(cujType) ||
-      !StringUtils.isNumeric(unixNs) ||
-      !StringUtils.isNumeric(elapsedNs) ||
-      !StringUtils.isNumeric(uptimeNs)
+      !isNumeric(cujType) ||
+      !isNumeric(unixNs) ||
+      !isNumeric(elapsedNs) ||
+      !isNumeric(uptimeNs)
     ) {
       throw new Error(`CUJ Data ${data} didn't match expected format`);
     }
diff --git a/tools/winscope/src/parsers/events/parser_eventlog.ts b/tools/winscope/src/parsers/events/parser_eventlog.ts
index ba7079894..c952aae2b 100644
--- a/tools/winscope/src/parsers/events/parser_eventlog.ts
+++ b/tools/winscope/src/parsers/events/parser_eventlog.ts
@@ -14,18 +14,17 @@
  * limitations under the License.
  */
 
-import {byteArrayToString} from 'common/buffer_utils';
-import {StringUtils} from 'common/string_utils';
+import {isBlank, utf8Decode, utf8Encode} from 'common/string_utils';
 import {Timestamp} from 'common/time/time';
 import {AbstractParser} from 'parsers/legacy/abstract_parser';
+import {PropertyTreeBuilderFromProto} from 'parsers/property_tree_builder_from_proto';
 import {TraceType} from 'trace/trace_type';
-import {PropertyTreeBuilderFromProto} from 'trace/tree_node/property_tree_builder_from_proto';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 
 class ParserEventLog extends AbstractParser<PropertyTreeNode, Event> {
   private static readonly MAGIC_NUMBER_STRING = 'EventLog';
   private static readonly MAGIC_NUMBER: number[] = Array.from(
-    new TextEncoder().encode(ParserEventLog.MAGIC_NUMBER_STRING),
+    utf8Encode(ParserEventLog.MAGIC_NUMBER_STRING),
   );
 
   override getTraceType(): TraceType {
@@ -67,21 +66,19 @@ class ParserEventLog extends AbstractParser<PropertyTreeNode, Event> {
   }
 
   private decodeByteArray(bytes: Uint8Array): string[] {
-    const allLogsString = byteArrayToString(bytes);
+    const allLogsString = utf8Decode(bytes);
     const splitLogs = allLogsString.split('\n');
 
     const firstIndexOfEventLogTrace = splitLogs.findIndex((substring) => {
       return (
         !substring.includes(ParserEventLog.MAGIC_NUMBER_STRING) &&
         !substring.includes('beginning of events') &&
-        !StringUtils.isBlank(substring)
+        !isBlank(substring)
       );
     });
 
     const lastIndexOfEventLogTrace = splitLogs.findIndex((substring, index) => {
-      return (
-        index > firstIndexOfEventLogTrace && StringUtils.isBlank(substring)
-      );
+      return index > firstIndexOfEventLogTrace && isBlank(substring);
     });
 
     if (lastIndexOfEventLogTrace === -1) {
diff --git a/tools/winscope/src/parsers/events/parser_eventlog_test.ts b/tools/winscope/src/parsers/events/parser_eventlog_test.ts
index 094254749..5ac201b14 100644
--- a/tools/winscope/src/parsers/events/parser_eventlog_test.ts
+++ b/tools/winscope/src/parsers/events/parser_eventlog_test.ts
@@ -19,8 +19,8 @@ import {
   TimestampConverterUtils,
   timestampEqualityTester,
 } from 'common/time/test_utils';
+import {LegacyParserProvider} from 'test/unit/fixture_utils';
 import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
-import {UnitTestUtils} from 'test/unit/utils';
 import {CoarseVersion} from 'trace/coarse_version';
 import {Parser} from 'trace/parser';
 import {TraceType} from 'trace/trace_type';
@@ -33,9 +33,9 @@ describe('ParserEventLog', () => {
 
     beforeAll(async () => {
       jasmine.addCustomEqualityTester(timestampEqualityTester);
-      parser = assertDefined(
-        await UnitTestUtils.getParser('traces/eventlog.winscope'),
-      ) as Parser<PropertyTreeNode>;
+      parser = await new LegacyParserProvider()
+        .addFilename('traces/elapsed_and_real_timestamp/eventlog.winscope')
+        .getParser<PropertyTreeNode>();
     });
 
     it('has expected trace type', () => {
@@ -88,11 +88,11 @@ describe('ParserEventLog', () => {
 
     beforeAll(async () => {
       jasmine.addCustomEqualityTester(timestampEqualityTester);
-      parser = assertDefined(
-        await UnitTestUtils.getParser(
-          'traces/eventlog_timestamps_not_monotonically_increasing.winscope',
-        ),
-      ) as Parser<PropertyTreeNode>;
+      parser = await new LegacyParserProvider()
+        .addFilename(
+          'traces/elapsed_and_real_timestamp/eventlog_timestamps_not_monotonically_increasing.winscope',
+        )
+        .getParser<PropertyTreeNode>();
     });
 
     it('sorts entries to make timestamps monotonically increasing', () => {
diff --git a/tools/winscope/src/parsers/events/traces_parser_cujs.ts b/tools/winscope/src/parsers/events/traces_parser_cujs.ts
index a79f1812d..521387348 100644
--- a/tools/winscope/src/parsers/events/traces_parser_cujs.ts
+++ b/tools/winscope/src/parsers/events/traces_parser_cujs.ts
@@ -18,13 +18,13 @@ import {assertDefined} from 'common/assert_utils';
 import {Timestamp} from 'common/time/time';
 import {ParserTimestampConverter} from 'common/time/timestamp_converter';
 import {SetFormatters} from 'parsers/operations/set_formatters';
+import {PropertyTreeBuilderFromProto} from 'parsers/property_tree_builder_from_proto';
 import {AbstractTracesParser} from 'parsers/traces/abstract_traces_parser';
 import {CoarseVersion} from 'trace/coarse_version';
 import {Trace} from 'trace/trace';
 import {Traces} from 'trace/traces';
 import {TraceType} from 'trace/trace_type';
 import {CUJ_TYPE_FORMATTER} from 'trace/tree_node/formatters';
-import {PropertyTreeBuilderFromProto} from 'trace/tree_node/property_tree_builder_from_proto';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 import {EventTag} from './event_tag';
 import {AddCujProperties} from './operations/add_cuj_properties';
diff --git a/tools/winscope/src/parsers/events/traces_parser_cujs_test.ts b/tools/winscope/src/parsers/events/traces_parser_cujs_test.ts
index 10b01880c..9af1384e5 100644
--- a/tools/winscope/src/parsers/events/traces_parser_cujs_test.ts
+++ b/tools/winscope/src/parsers/events/traces_parser_cujs_test.ts
@@ -19,14 +19,15 @@ import {
   TimestampConverterUtils,
   timestampEqualityTester,
 } from 'common/time/test_utils';
+import {getTracesParser} from 'test/unit/fixture_utils';
 import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
-import {UnitTestUtils} from 'test/unit/utils';
 import {CoarseVersion} from 'trace/coarse_version';
 import {Parser} from 'trace/parser';
 import {TraceType} from 'trace/trace_type';
 import {
   CUJ_TYPE_FORMATTER,
   DEFAULT_PROPERTY_FORMATTER,
+  TIMESTAMP_NODE_FORMATTER,
 } from 'trace/tree_node/formatters';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 
@@ -35,9 +36,11 @@ describe('TracesParserCujs', () => {
 
   beforeAll(async () => {
     jasmine.addCustomEqualityTester(timestampEqualityTester);
-    parser = (await UnitTestUtils.getTracesParser([
-      'traces/eventlog.winscope',
-    ])) as Parser<PropertyTreeNode>;
+    parser = (
+      await getTracesParser([
+        'traces/elapsed_and_real_timestamp/eventlog.winscope',
+      ])
+    ).tracesParser as Parser<PropertyTreeNode>;
   });
 
   it('has expected trace type', () => {
@@ -83,7 +86,7 @@ describe('TracesParserCujs', () => {
             TimestampConverterUtils.TIMESTAMP_CONVERTER.makeTimestampFromNs(
               1681207048025580000n,
             ),
-          formatter: DEFAULT_PROPERTY_FORMATTER,
+          formatter: TIMESTAMP_NODE_FORMATTER,
         },
         {
           name: 'endTimestamp',
@@ -91,7 +94,7 @@ describe('TracesParserCujs', () => {
             TimestampConverterUtils.TIMESTAMP_CONVERTER.makeTimestampFromNs(
               1681207048643085000n,
             ),
-          formatter: DEFAULT_PROPERTY_FORMATTER,
+          formatter: TIMESTAMP_NODE_FORMATTER,
         },
         {name: 'canceled', value: true, formatter: DEFAULT_PROPERTY_FORMATTER},
       ])
diff --git a/tools/winscope/src/parsers/hierarchy_tree_builder_log.ts b/tools/winscope/src/parsers/hierarchy_tree_builder_log.ts
new file mode 100644
index 000000000..c9f849d0c
--- /dev/null
+++ b/tools/winscope/src/parsers/hierarchy_tree_builder_log.ts
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import {HierarchyTreeBuilder} from 'parsers/hierarchy_tree_builder';
+import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
+import {PropertiesProvider} from 'trace/tree_node/properties_provider';
+
+export class HierarchyTreeBuilderLog extends HierarchyTreeBuilder {
+  protected override buildIdentifierToChildrenMap(
+    traceLogEntries: PropertiesProvider[],
+  ): Map<number, readonly HierarchyTreeNode[]> {
+    const nodes = traceLogEntries.map((entry) => {
+      const properties = entry.getEagerProperties();
+      return this.makeNode(properties.id, properties.name, entry);
+    });
+    return new Map([[0, nodes]]);
+  }
+
+  protected override assignParentChildRelationships(
+    root: HierarchyTreeNode,
+    identifierToChildren: Map<number, HierarchyTreeNode[]>,
+  ): void {
+    for (const nodes of identifierToChildren.values()) {
+      nodes.forEach((node) => {
+        this.setParentChildRelationship(root, node);
+      });
+    }
+  }
+}
diff --git a/tools/winscope/src/parsers/hierarchy_tree_builder_log_test.ts b/tools/winscope/src/parsers/hierarchy_tree_builder_log_test.ts
new file mode 100644
index 000000000..5efe5dbe4
--- /dev/null
+++ b/tools/winscope/src/parsers/hierarchy_tree_builder_log_test.ts
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
+import {TreeNodeUtils} from 'test/unit/tree_node_utils';
+import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
+import {OperationChain} from 'trace/tree_node/operations/operation_chain';
+import {PropertiesProvider} from 'trace/tree_node/properties_provider';
+import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
+import {HierarchyTreeBuilderLog} from './hierarchy_tree_builder_log';
+
+describe('HierarchyTreeBuilderLog', () => {
+  let builder: HierarchyTreeBuilderLog;
+  let root: PropertiesProvider;
+  let rootPropertiesTree: PropertyTreeNode;
+
+  beforeEach(() => {
+    jasmine.addCustomEqualityTester(TreeNodeUtils.treeNodeEqualityTester);
+    builder = new HierarchyTreeBuilderLog();
+    rootPropertiesTree = new PropertyTreeBuilder()
+      .setIsRoot(true)
+      .setRootId('LogTrace')
+      .setName('root')
+      .build();
+    root = makePropertiesProvider(rootPropertiesTree);
+  });
+
+  it('throws error if root not set', () => {
+    const noEntryError = new Error('root not set');
+    expect(() => builder.setChildren([]).build()).toThrow(noEntryError);
+  });
+
+  it('throws error if containers not set', () => {
+    const noChildrenError = new Error('children not set');
+    expect(() => builder.setRoot(root).build()).toThrow(noChildrenError);
+  });
+
+  it('builds root with no children correctly', () => {
+    const rootNode = builder.setRoot(root).setChildren([]).build();
+    const expectedRoot = new HierarchyTreeNode(
+      'LogTrace root',
+      'root',
+      makePropertiesProvider(rootPropertiesTree),
+    );
+    expect(rootNode).toEqual(expectedRoot);
+  });
+
+  it('builds root with children correctly', () => {
+    const container1Props = new PropertyTreeBuilder()
+      .setRootId('LogEntry1')
+      .setName('log')
+      .setIsRoot(true)
+      .build();
+
+    const container1Provider = makePropertiesProvider(container1Props);
+
+    const container2Props = new PropertyTreeBuilder()
+      .setRootId('LogEntry2')
+      .setName('log')
+      .setIsRoot(true)
+      .build();
+
+    const container2Provider = makePropertiesProvider(container2Props);
+
+    const rootNode = builder
+      .setRoot(root)
+      .setChildren([container1Provider, container2Provider])
+      .build();
+
+    const expectedRoot = new HierarchyTreeNode(
+      'LogTrace root',
+      'root',
+      makePropertiesProvider(rootPropertiesTree),
+    );
+    expectedRoot.addOrReplaceChild(
+      new HierarchyTreeNode('LogEntry1 log', 'log', container1Provider),
+    );
+    expectedRoot.addOrReplaceChild(
+      new HierarchyTreeNode('LogEntry2 log', 'log', container2Provider),
+    );
+
+    expect(rootNode).toEqual(expectedRoot);
+  });
+
+  function makePropertiesProvider(properties: PropertyTreeNode) {
+    return new PropertiesProvider(
+      properties,
+      async () => properties,
+      OperationChain.emptyChain<PropertyTreeNode>(),
+      OperationChain.emptyChain<PropertyTreeNode>(),
+      OperationChain.emptyChain<PropertyTreeNode>(),
+    );
+  }
+});
diff --git a/tools/winscope/src/parsers/input/perfetto/abstract_input_event_parser.ts b/tools/winscope/src/parsers/input/perfetto/abstract_input_event_parser.ts
index 3508263e5..3aa7bd565 100644
--- a/tools/winscope/src/parsers/input/perfetto/abstract_input_event_parser.ts
+++ b/tools/winscope/src/parsers/input/perfetto/abstract_input_event_parser.ts
@@ -14,17 +14,21 @@
  * limitations under the License.
  */
 
-import {assertDefined} from 'common/assert_utils';
+import {
+  assertBigIntOrUndefined,
+  assertDefined,
+  assertNumberOrUndefined,
+  assertString,
+  assertStringOrUndefined,
+} from 'common/assert_utils';
 import {ParserTimestampConverter} from 'common/time/timestamp_converter';
 import {SetFormatters} from 'parsers/operations/set_formatters';
 import {TranslateIntDef} from 'parsers/operations/translate_intdef';
 import {AbstractParser} from 'parsers/perfetto/abstract_parser';
 import {FakeProtoBuilder} from 'parsers/perfetto/fake_proto_builder';
-import {FakeProtoTransformer} from 'parsers/perfetto/fake_proto_transformer';
-import {Utils} from 'parsers/perfetto/utils';
-import {TamperedMessageType} from 'parsers/tampered_message_type';
-import root from 'protos/input/latest/json';
-import {perfetto} from 'protos/input/latest/static';
+import {queryVsyncId} from 'parsers/perfetto/utils';
+import {TAMPERED_WINSCOPE_EXTENSIONS} from 'parsers/tampered_message_type';
+import {perfetto} from 'protos/perfetto/trace/static';
 import {
   CustomQueryParserResultTypeMap,
   CustomQueryType,
@@ -36,12 +40,16 @@ import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 import {TraceProcessor} from 'trace_processor/trace_processor';
 
 export abstract class AbstractInputEventParser extends AbstractParser<PropertyTreeNode> {
-  protected static readonly WrapperProto = TamperedMessageType.tamper(
-    root.lookupType('perfetto.protos.InputEventWrapper'),
+  protected static readonly WrapperProto = assertDefined(
+    TAMPERED_WINSCOPE_EXTENSIONS.fields[
+      '.perfetto.protos.WinscopeExtensionsImpl.androidInputEvent'
+    ].tamperedMessageType,
   );
 
   private static readonly DispatchEventsField =
-    AbstractInputEventParser.WrapperProto.fields['windowDispatchEvents'];
+    AbstractInputEventParser.WrapperProto.fields[
+      'dispatcherWindowDispatchEvent'
+    ];
 
   private static readonly DISPATCH_EVENT_OPS = [
     new SetFormatters(AbstractInputEventParser.DispatchEventsField),
@@ -50,20 +58,12 @@ export abstract class AbstractInputEventParser extends AbstractParser<PropertyTr
 
   private static readonly DispatchTableName = 'android_input_event_dispatch';
 
-  private dispatchEventTransformer: FakeProtoTransformer;
-
   protected constructor(
     traceFile: TraceFile,
     traceProcessor: TraceProcessor,
     timestampConverter: ParserTimestampConverter,
   ) {
     super(traceFile, traceProcessor, timestampConverter);
-
-    this.dispatchEventTransformer = new FakeProtoTransformer(
-      assertDefined(
-        AbstractInputEventParser.DispatchEventsField.tamperedMessageType,
-      ),
-    );
   }
 
   protected async getDispatchEvents(
@@ -81,7 +81,7 @@ export abstract class AbstractInputEventParser extends AbstractParser<PropertyTr
         WHERE d.event_id = ${eventId}
         ORDER BY d.id;
     `;
-    const result = await this.traceProcessor.queryAllRows(sql);
+    const result = await this.traceProcessor.query(sql);
 
     const dispatchEvents: perfetto.protos.AndroidWindowInputDispatchEvent[] =
       [];
@@ -90,11 +90,11 @@ export abstract class AbstractInputEventParser extends AbstractParser<PropertyTr
       const prevId = it.get('id');
       while (it.valid() && it.get('id') === prevId) {
         builder.addArg(
-          it.get('key') as string,
-          it.get('value_type') as string,
-          it.get('int_value') as bigint | undefined,
-          it.get('real_value') as number | undefined,
-          it.get('string_value') as string | undefined,
+          assertString(it.get('key')),
+          assertString(it.get('value_type')),
+          assertBigIntOrUndefined(it.get('int_value')),
+          assertNumberOrUndefined(it.get('real_value')),
+          assertStringOrUndefined(it.get('string_value')),
         );
         it.next();
       }
@@ -119,7 +119,7 @@ export abstract class AbstractInputEventParser extends AbstractParser<PropertyTr
   ): Promise<CustomQueryParserResultTypeMap[Q]> {
     return new VisitableParserCustomQuery(type)
       .visit(CustomQueryType.VSYNCID, async () => {
-        return Utils.queryVsyncId(
+        return queryVsyncId(
           this.traceProcessor,
           this.getTableName(),
           this.entryIndexToRowIdMap,
diff --git a/tools/winscope/src/parsers/input/perfetto/parser_key_event.ts b/tools/winscope/src/parsers/input/perfetto/parser_key_event.ts
index 3338113b2..f33b15987 100644
--- a/tools/winscope/src/parsers/input/perfetto/parser_key_event.ts
+++ b/tools/winscope/src/parsers/input/perfetto/parser_key_event.ts
@@ -20,17 +20,17 @@ import {AbstractInputEventParser} from 'parsers/input/perfetto/abstract_input_ev
 import {SetFormatters} from 'parsers/operations/set_formatters';
 import {TranslateIntDef} from 'parsers/operations/translate_intdef';
 import {FakeProtoTransformer} from 'parsers/perfetto/fake_proto_transformer';
-import {Utils} from 'parsers/perfetto/utils';
-import {perfetto} from 'protos/input/latest/static';
+import {queryEntry} from 'parsers/perfetto/utils';
+import {PropertyTreeBuilderFromProto} from 'parsers/property_tree_builder_from_proto';
+import {perfetto} from 'protos/perfetto/trace/static';
 import {TraceFile} from 'trace/trace_file';
 import {TraceType} from 'trace/trace_type';
-import {PropertyTreeBuilderFromProto} from 'trace/tree_node/property_tree_builder_from_proto';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 import {TraceProcessor} from 'trace_processor/trace_processor';
 
 export class ParserKeyEvent extends AbstractInputEventParser {
   private static readonly KeyEventField =
-    AbstractInputEventParser.WrapperProto.fields['keyEvent'];
+    AbstractInputEventParser.WrapperProto.fields['dispatcherKeyEvent'];
 
   private static readonly KEY_EVENT_OPS = [
     new SetFormatters(ParserKeyEvent.KeyEventField),
@@ -57,17 +57,14 @@ export class ParserKeyEvent extends AbstractInputEventParser {
 
   override async getEntry(index: number): Promise<PropertyTreeNode> {
     const keyEvent = await this.getKeyEventProto(index);
-    const events = perfetto.protos.InputEventWrapper.create({
-      keyEvent,
-      windowDispatchEvents: await this.getDispatchEvents(keyEvent.eventId),
-    });
-    return this.makeKeyPropertiesTree(events);
+    const windowDispatchEvents = await this.getDispatchEvents(keyEvent.eventId);
+    return this.makeKeyPropertiesTree(keyEvent, windowDispatchEvents);
   }
 
   private async getKeyEventProto(
     index: number,
   ): Promise<perfetto.protos.AndroidKeyEvent> {
-    let keyEventProto = await Utils.queryEntry(
+    let keyEventProto = await queryEntry(
       this.traceProcessor,
       this.getTableName(),
       this.entryIndexToRowIdMap,
@@ -87,10 +84,12 @@ export class ParserKeyEvent extends AbstractInputEventParser {
   }
 
   private makeKeyPropertiesTree(
-    entryProto: perfetto.protos.InputEventWrapper,
+    keyEvent: perfetto.protos.AndroidKeyEvent,
+    windowDispatchEvents: perfetto.protos.AndroidWindowInputDispatchEvent[],
   ): PropertyTreeNode {
+    const entry = {keyEvent, windowDispatchEvents};
     const tree = new PropertyTreeBuilderFromProto()
-      .setData(entryProto)
+      .setData(entry)
       .setRootId('AndroidKeyEvent')
       .setRootName('entry')
       .build();
diff --git a/tools/winscope/src/parsers/input/perfetto/parser_key_event_test.ts b/tools/winscope/src/parsers/input/perfetto/parser_key_event_test.ts
index 27e4b9715..71cf62086 100644
--- a/tools/winscope/src/parsers/input/perfetto/parser_key_event_test.ts
+++ b/tools/winscope/src/parsers/input/perfetto/parser_key_event_test.ts
@@ -18,20 +18,20 @@ import {
   TimestampConverterUtils,
   timestampEqualityTester,
 } from 'common/time/test_utils';
+import {getPerfettoParser} from 'test/unit/fixture_utils';
 import {TraceBuilder} from 'test/unit/trace_builder';
-import {UnitTestUtils} from 'test/unit/utils';
 import {CoarseVersion} from 'trace/coarse_version';
 import {CustomQueryType} from 'trace/custom_query';
 import {Parser} from 'trace/parser';
 import {TraceType} from 'trace/trace_type';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 
-describe('Perfetto ParserKeyEvent', () => {
+describe('PerfettoParserKeyEvent', () => {
   let parser: Parser<PropertyTreeNode>;
 
   beforeAll(async () => {
     jasmine.addCustomEqualityTester(timestampEqualityTester);
-    parser = await UnitTestUtils.getPerfettoParser(
+    parser = await getPerfettoParser(
       TraceType.INPUT_KEY_EVENT,
       'traces/perfetto/input-events.perfetto-trace',
     );
diff --git a/tools/winscope/src/parsers/input/perfetto/parser_motion_event.ts b/tools/winscope/src/parsers/input/perfetto/parser_motion_event.ts
index 9d3aef9ab..8dee052b1 100644
--- a/tools/winscope/src/parsers/input/perfetto/parser_motion_event.ts
+++ b/tools/winscope/src/parsers/input/perfetto/parser_motion_event.ts
@@ -20,17 +20,17 @@ import {AbstractInputEventParser} from 'parsers/input/perfetto/abstract_input_ev
 import {SetFormatters} from 'parsers/operations/set_formatters';
 import {TranslateIntDef} from 'parsers/operations/translate_intdef';
 import {FakeProtoTransformer} from 'parsers/perfetto/fake_proto_transformer';
-import {Utils} from 'parsers/perfetto/utils';
-import {perfetto} from 'protos/input/latest/static';
+import {queryEntry} from 'parsers/perfetto/utils';
+import {PropertyTreeBuilderFromProto} from 'parsers/property_tree_builder_from_proto';
+import {perfetto} from 'protos/perfetto/trace/static';
 import {TraceFile} from 'trace/trace_file';
 import {TraceType} from 'trace/trace_type';
-import {PropertyTreeBuilderFromProto} from 'trace/tree_node/property_tree_builder_from_proto';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 import {TraceProcessor} from 'trace_processor/trace_processor';
 
 export class ParserMotionEvent extends AbstractInputEventParser {
   private static readonly MotionEventField =
-    AbstractInputEventParser.WrapperProto.fields['motionEvent'];
+    AbstractInputEventParser.WrapperProto.fields['dispatcherMotionEvent'];
 
   private static readonly MOTION_EVENT_OPS = [
     new SetFormatters(ParserMotionEvent.MotionEventField),
@@ -57,17 +57,16 @@ export class ParserMotionEvent extends AbstractInputEventParser {
 
   override async getEntry(index: number): Promise<PropertyTreeNode> {
     const motionEvent = await this.getMotionEventProto(index);
-    const events = perfetto.protos.InputEventWrapper.create({
-      motionEvent,
-      windowDispatchEvents: await this.getDispatchEvents(motionEvent.eventId),
-    });
-    return this.makeMotionPropertiesTree(events);
+    const windowDispatchEvents = await this.getDispatchEvents(
+      motionEvent.eventId,
+    );
+    return this.makeMotionPropertiesTree(motionEvent, windowDispatchEvents);
   }
 
   private async getMotionEventProto(
     index: number,
   ): Promise<perfetto.protos.AndroidMotionEvent> {
-    let motionEventProto = await Utils.queryEntry(
+    let motionEventProto = await queryEntry(
       this.traceProcessor,
       this.getTableName(),
       this.entryIndexToRowIdMap,
@@ -87,10 +86,12 @@ export class ParserMotionEvent extends AbstractInputEventParser {
   }
 
   private makeMotionPropertiesTree(
-    entryProto: perfetto.protos.InputEventWrapper,
+    motionEvent: perfetto.protos.AndroidMotionEvent,
+    windowDispatchEvents: perfetto.protos.AndroidWindowInputDispatchEvent[],
   ): PropertyTreeNode {
+    const entry = {motionEvent, windowDispatchEvents};
     const tree = new PropertyTreeBuilderFromProto()
-      .setData(entryProto)
+      .setData(entry)
       .setRootId('AndroidMotionEvent')
       .setRootName('entry')
       .build();
diff --git a/tools/winscope/src/parsers/input/perfetto/parser_motion_event_test.ts b/tools/winscope/src/parsers/input/perfetto/parser_motion_event_test.ts
index c1059cb25..1e963a6d8 100644
--- a/tools/winscope/src/parsers/input/perfetto/parser_motion_event_test.ts
+++ b/tools/winscope/src/parsers/input/perfetto/parser_motion_event_test.ts
@@ -18,20 +18,20 @@ import {
   TimestampConverterUtils,
   timestampEqualityTester,
 } from 'common/time/test_utils';
+import {getPerfettoParser} from 'test/unit/fixture_utils';
 import {TraceBuilder} from 'test/unit/trace_builder';
-import {UnitTestUtils} from 'test/unit/utils';
 import {CoarseVersion} from 'trace/coarse_version';
 import {CustomQueryType} from 'trace/custom_query';
 import {Parser} from 'trace/parser';
 import {TraceType} from 'trace/trace_type';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 
-describe('Perfetto ParserMotionEvent', () => {
+describe('PerfettoParserMotionEvent', () => {
   let parser: Parser<PropertyTreeNode>;
 
   beforeAll(async () => {
     jasmine.addCustomEqualityTester(timestampEqualityTester);
-    parser = await UnitTestUtils.getPerfettoParser(
+    parser = await getPerfettoParser(
       TraceType.INPUT_MOTION_EVENT,
       'traces/perfetto/input-events.perfetto-trace',
     );
@@ -80,19 +80,15 @@ describe('Perfetto ParserMotionEvent', () => {
       'SOURCE_TOUCHSCREEN',
     );
     expect(motionEvent?.getChildByName('flags')?.formattedValue()).toEqual(
-      'UNKNOWN (0x80)',
+      'FLAG_SUPPORTS_ORIENTATION',
     );
     expect(motionEvent?.getChildByName('deviceId')?.getValue()).toEqual(4);
     expect(motionEvent?.getChildByName('displayId')?.getValue()).toEqual(0);
     expect(
       motionEvent?.getChildByName('classification')?.formattedValue(),
     ).toEqual('CLASSIFICATION_NONE');
-    expect(motionEvent?.getChildByName('cursorPositionX')?.getValue()).toEqual(
-      null,
-    );
-    expect(motionEvent?.getChildByName('cursorPositionY')?.getValue()).toEqual(
-      null,
-    );
+    expect(motionEvent?.getChildByName('cursorPositionX')).toEqual(undefined);
+    expect(motionEvent?.getChildByName('cursorPositionY')).toEqual(undefined);
     expect(motionEvent?.getChildByName('metaState')?.formattedValue()).toEqual(
       '0x0',
     );
diff --git a/tools/winscope/src/parsers/input/perfetto/traces_parser_input_test.ts b/tools/winscope/src/parsers/input/perfetto/traces_parser_input_test.ts
index 7dde29bcf..ca80c1ffa 100644
--- a/tools/winscope/src/parsers/input/perfetto/traces_parser_input_test.ts
+++ b/tools/winscope/src/parsers/input/perfetto/traces_parser_input_test.ts
@@ -19,9 +19,9 @@ import {
   TimestampConverterUtils,
   timestampEqualityTester,
 } from 'common/time/test_utils';
+import {getTracesParser} from 'test/unit/fixture_utils';
 import {TraceBuilder} from 'test/unit/trace_builder';
 import {UserNotifierChecker} from 'test/unit/user_notifier_checker';
-import {UnitTestUtils} from 'test/unit/utils';
 import {CoarseVersion} from 'trace/coarse_version';
 import {CustomQueryType} from 'trace/custom_query';
 import {Parser} from 'trace/parser';
@@ -38,9 +38,9 @@ describe('TracesParserInput', () => {
 
   beforeEach(async () => {
     jasmine.addCustomEqualityTester(timestampEqualityTester);
-    parser = (await UnitTestUtils.getTracesParser([
-      'traces/perfetto/input-events.perfetto-trace',
-    ])) as Parser<PropertyTreeNode>;
+    parser = (
+      await getTracesParser(['traces/perfetto/input-events.perfetto-trace'])
+    ).tracesParser as Parser<PropertyTreeNode>;
     userNotifierChecker.reset();
   });
 
@@ -99,9 +99,11 @@ describe('TracesParserInput', () => {
   });
 
   it('supports VSYNCID custom query with missing vsync_ids', async () => {
-    const missingVsyncIdsParser = (await UnitTestUtils.getTracesParser([
-      'traces/perfetto/input-missing-vsync-ids.perfetto-trace',
-    ])) as Parser<PropertyTreeNode>;
+    const missingVsyncIdsParser = (
+      await getTracesParser([
+        'traces/perfetto/input-missing-vsync-ids.perfetto-trace',
+      ])
+    ).tracesParser as Parser<PropertyTreeNode>;
     const trace = new TraceBuilder()
       .setType(TraceType.INPUT_EVENT_MERGED)
       .setParser(missingVsyncIdsParser)
diff --git a/tools/winscope/src/parsers/input_method/hierarchy_tree_clients_factory.ts b/tools/winscope/src/parsers/input_method/hierarchy_tree_clients_factory.ts
index b1f2fa64a..0374f373c 100644
--- a/tools/winscope/src/parsers/input_method/hierarchy_tree_clients_factory.ts
+++ b/tools/winscope/src/parsers/input_method/hierarchy_tree_clients_factory.ts
@@ -18,13 +18,12 @@ import {HierarchyTreeBuilderInputMethod} from 'parsers/input_method/hierarchy_tr
 import {AddDefaults} from 'parsers/operations/add_defaults';
 import {SetFormatters} from 'parsers/operations/set_formatters';
 import {TranslateIntDef} from 'parsers/operations/translate_intdef';
+import {PropertyTreeBuilderFromProto} from 'parsers/property_tree_builder_from_proto';
 import {TamperedProtoField} from 'parsers/tampered_message_type';
-import {perfetto} from 'protos/ime/latest/static';
-import {android} from 'protos/ime/udc/static';
+import {perfetto} from 'protos/perfetto/trace/static';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 import {LazyPropertiesStrategyType} from 'trace/tree_node/properties_provider';
 import {PropertiesProviderBuilder} from 'trace/tree_node/properties_provider_builder';
-import {PropertyTreeBuilderFromProto} from 'trace/tree_node/property_tree_builder_from_proto';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 
 export class HierarchyTreeClientsFactory {
@@ -71,9 +70,7 @@ export class HierarchyTreeClientsFactory {
   }
 
   makeHierarchyTree(
-    entryProto:
-      | android.view.inputmethod.IInputMethodClientsTraceProto
-      | perfetto.protos.IInputMethodClientsTraceProto,
+    entryProto: perfetto.protos.IInputMethodClientsTraceProto,
   ): HierarchyTreeNode {
     const entry = new PropertiesProviderBuilder()
       .setEagerProperties(this.makeEntryEagerPropertiesTree(entryProto))
@@ -107,9 +104,7 @@ export class HierarchyTreeClientsFactory {
   }
 
   private makeEntryEagerPropertiesTree(
-    entryProto:
-      | android.view.inputmethod.IInputMethodClientsTraceProto
-      | perfetto.protos.IInputMethodClientsTraceProto,
+    entryProto: perfetto.protos.IInputMethodClientsTraceProto,
   ): PropertyTreeNode {
     const denyList: string[] = [];
     Object.getOwnPropertyNames(entryProto).forEach((it) => {
@@ -127,9 +122,7 @@ export class HierarchyTreeClientsFactory {
   }
 
   private makeEntryLazyPropertiesStrategy(
-    entryProto:
-      | android.view.inputmethod.IInputMethodClientsTraceProto
-      | perfetto.protos.IInputMethodClientsTraceProto,
+    entryProto: perfetto.protos.IInputMethodClientsTraceProto,
   ): LazyPropertiesStrategyType {
     return async () => {
       return new PropertyTreeBuilderFromProto()
@@ -147,7 +140,6 @@ export class HierarchyTreeClientsFactory {
 
   private makeClientEagerPropertiesTree(
     clientProto:
-      | android.view.inputmethod.InputMethodClientsTraceProto.IClientSideProto
       | perfetto.protos.InputMethodClientsTraceProto.IClientSideProto
       | null
       | undefined,
@@ -169,13 +161,11 @@ export class HierarchyTreeClientsFactory {
       .setRootId('InputMethodClients')
       .setRootName('client')
       .setDenyList(denyList)
-      .setVisitPrototype(false)
       .build();
   }
 
   private makeClientLazyPropertiesStrategy(
     clientProto:
-      | android.view.inputmethod.InputMethodClientsTraceProto.IClientSideProto
       | perfetto.protos.InputMethodClientsTraceProto.IClientSideProto
       | null
       | undefined,
@@ -186,7 +176,6 @@ export class HierarchyTreeClientsFactory {
         .setRootId('InputMethodClients')
         .setRootName('client')
         .setDenyList(HierarchyTreeClientsFactory.CLIENT_EAGER_PROPERTIES)
-        .setVisitPrototype(false)
         .build();
     };
   }
diff --git a/tools/winscope/src/parsers/input_method/hierarchy_tree_manager_service_factory.ts b/tools/winscope/src/parsers/input_method/hierarchy_tree_manager_service_factory.ts
index c408d7e57..143ccc392 100644
--- a/tools/winscope/src/parsers/input_method/hierarchy_tree_manager_service_factory.ts
+++ b/tools/winscope/src/parsers/input_method/hierarchy_tree_manager_service_factory.ts
@@ -18,13 +18,12 @@ import {HierarchyTreeBuilderInputMethod} from 'parsers/input_method/hierarchy_tr
 import {AddDefaults} from 'parsers/operations/add_defaults';
 import {SetFormatters} from 'parsers/operations/set_formatters';
 import {TranslateIntDef} from 'parsers/operations/translate_intdef';
+import {PropertyTreeBuilderFromProto} from 'parsers/property_tree_builder_from_proto';
 import {TamperedProtoField} from 'parsers/tampered_message_type';
-import {perfetto} from 'protos/ime/latest/static';
-import {android} from 'protos/ime/udc/static';
+import {perfetto} from 'protos/perfetto/trace/static';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 import {LazyPropertiesStrategyType} from 'trace/tree_node/properties_provider';
 import {PropertiesProviderBuilder} from 'trace/tree_node/properties_provider_builder';
-import {PropertyTreeBuilderFromProto} from 'trace/tree_node/property_tree_builder_from_proto';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 
 export class HierarchyTreeManagerServiceFactory {
@@ -77,9 +76,7 @@ export class HierarchyTreeManagerServiceFactory {
   }
 
   makeHierarchyTree(
-    entryProto:
-      | android.view.inputmethod.IInputMethodManagerServiceTraceProto
-      | perfetto.protos.IInputMethodManagerServiceTraceProto,
+    entryProto: perfetto.protos.IInputMethodManagerServiceTraceProto,
   ): HierarchyTreeNode {
     const entry = new PropertiesProviderBuilder()
       .setEagerProperties(this.makeEntryEagerPropertiesTree(entryProto))
@@ -119,9 +116,7 @@ export class HierarchyTreeManagerServiceFactory {
   }
 
   private makeEntryEagerPropertiesTree(
-    entryProto:
-      | android.view.inputmethod.IInputMethodManagerServiceTraceProto
-      | perfetto.protos.IInputMethodManagerServiceTraceProto,
+    entryProto: perfetto.protos.IInputMethodManagerServiceTraceProto,
   ): PropertyTreeNode {
     const denyList: string[] = [];
     Object.getOwnPropertyNames(entryProto).forEach((it) => {
@@ -158,7 +153,7 @@ export class HierarchyTreeManagerServiceFactory {
   }
 
   private makeServiceEagerPropertiesTree(
-    serviceProto: android.server.inputmethod.IInputMethodManagerServiceProto,
+    serviceProto: perfetto.protos.IInputMethodManagerServiceProto,
   ): PropertyTreeNode {
     const denyList: string[] = [];
     let data: object = serviceProto;
@@ -181,12 +176,11 @@ export class HierarchyTreeManagerServiceFactory {
       .setRootId('InputMethodManagerService')
       .setRootName('inputMethodManagerService')
       .setDenyList(denyList)
-      .setVisitPrototype(false)
       .build();
   }
 
   private makeServiceLazyPropertiesStrategy(
-    serviceProto: android.server.inputmethod.IInputMethodManagerServiceProto,
+    serviceProto: perfetto.protos.IInputMethodManagerServiceProto,
   ): LazyPropertiesStrategyType {
     return async () => {
       return new PropertyTreeBuilderFromProto()
@@ -196,7 +190,6 @@ export class HierarchyTreeManagerServiceFactory {
         .setDenyList(
           HierarchyTreeManagerServiceFactory.SERVICE_EAGER_PROPERTIES,
         )
-        .setVisitPrototype(false)
         .build();
     };
   }
diff --git a/tools/winscope/src/parsers/input_method/hierarchy_tree_service_factory.ts b/tools/winscope/src/parsers/input_method/hierarchy_tree_service_factory.ts
index 64c729e76..769fb883f 100644
--- a/tools/winscope/src/parsers/input_method/hierarchy_tree_service_factory.ts
+++ b/tools/winscope/src/parsers/input_method/hierarchy_tree_service_factory.ts
@@ -18,13 +18,12 @@ import {HierarchyTreeBuilderInputMethod} from 'parsers/input_method/hierarchy_tr
 import {AddDefaults} from 'parsers/operations/add_defaults';
 import {SetFormatters} from 'parsers/operations/set_formatters';
 import {TranslateIntDef} from 'parsers/operations/translate_intdef';
+import {PropertyTreeBuilderFromProto} from 'parsers/property_tree_builder_from_proto';
 import {TamperedProtoField} from 'parsers/tampered_message_type';
-import {perfetto} from 'protos/ime/latest/static';
-import {android} from 'protos/ime/udc/static';
+import {perfetto} from 'protos/perfetto/trace/static';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 import {LazyPropertiesStrategyType} from 'trace/tree_node/properties_provider';
 import {PropertiesProviderBuilder} from 'trace/tree_node/properties_provider_builder';
-import {PropertyTreeBuilderFromProto} from 'trace/tree_node/property_tree_builder_from_proto';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 
 export class HierarchyTreeServiceFactory {
@@ -74,9 +73,7 @@ export class HierarchyTreeServiceFactory {
   }
 
   makeHierarchyTree(
-    entryProto:
-      | android.view.inputmethod.IInputMethodServiceTraceProto
-      | perfetto.protos.IInputMethodServiceTraceProto,
+    entryProto: perfetto.protos.IInputMethodServiceTraceProto,
   ): HierarchyTreeNode {
     const entry = new PropertiesProviderBuilder()
       .setEagerProperties(this.makeEntryEagerPropertiesTree(entryProto))
@@ -114,9 +111,7 @@ export class HierarchyTreeServiceFactory {
   }
 
   private makeEntryEagerPropertiesTree(
-    entryProto:
-      | android.view.inputmethod.IInputMethodServiceTraceProto
-      | perfetto.protos.IInputMethodServiceTraceProto,
+    entryProto: perfetto.protos.IInputMethodServiceTraceProto,
   ): PropertyTreeNode {
     const denyList: string[] = [];
     Object.getOwnPropertyNames(entryProto).forEach((it) => {
@@ -134,9 +129,7 @@ export class HierarchyTreeServiceFactory {
   }
 
   private makeEntryLazyPropertiesStrategy(
-    entryProto:
-      | android.view.inputmethod.IInputMethodServiceTraceProto
-      | perfetto.protos.IInputMethodServiceTraceProto,
+    entryProto: perfetto.protos.IInputMethodServiceTraceProto,
   ): LazyPropertiesStrategyType {
     return async () => {
       return new PropertyTreeBuilderFromProto()
@@ -153,9 +146,7 @@ export class HierarchyTreeServiceFactory {
   }
 
   private makeServiceEagerPropertiesTree(
-    serviceProto:
-      | android.inputmethodservice.IInputMethodServiceProto
-      | perfetto.protos.IInputMethodServiceProto,
+    serviceProto: perfetto.protos.IInputMethodServiceProto,
   ): PropertyTreeNode {
     const denyList: string[] = [];
     let data: object = serviceProto;
@@ -175,14 +166,11 @@ export class HierarchyTreeServiceFactory {
       .setRootId('InputMethodService')
       .setRootName('inputMethodService')
       .setDenyList(denyList)
-      .setVisitPrototype(false)
       .build();
   }
 
   private makeServiceLazyPropertiesStrategy(
-    serviceProto:
-      | android.inputmethodservice.IInputMethodServiceProto
-      | perfetto.protos.IInputMethodServiceProto,
+    serviceProto: perfetto.protos.IInputMethodServiceProto,
   ): LazyPropertiesStrategyType {
     return async () => {
       return new PropertyTreeBuilderFromProto()
@@ -190,7 +178,6 @@ export class HierarchyTreeServiceFactory {
         .setRootId('InputMethodService')
         .setRootName('inputMethodService')
         .setDenyList(HierarchyTreeServiceFactory.SERVICE_EAGER_PROPERTIES)
-        .setVisitPrototype(false)
         .build();
     };
   }
diff --git a/tools/winscope/src/parsers/input_method/legacy/parser_input_method_clients.ts b/tools/winscope/src/parsers/input_method/legacy/parser_input_method_clients.ts
index b363ffc02..4213584b4 100644
--- a/tools/winscope/src/parsers/input_method/legacy/parser_input_method_clients.ts
+++ b/tools/winscope/src/parsers/input_method/legacy/parser_input_method_clients.ts
@@ -16,11 +16,10 @@
 
 import {assertDefined} from 'common/assert_utils';
 import {Timestamp} from 'common/time/time';
-import {HierarchyTreeClientsFactory} from 'parsers/input_method/hierarchy_tree_clients_factory';
 import {AbstractParser} from 'parsers/legacy/abstract_parser';
-import {TamperedMessageType} from 'parsers/tampered_message_type';
 import root from 'protos/ime/udc/json';
 import {android} from 'protos/ime/udc/static';
+import {perfetto} from 'protos/perfetto/trace/static';
 import {TraceType} from 'trace/trace_type';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 
@@ -34,22 +33,9 @@ class ParserInputMethodClients extends AbstractParser<
     0x09, 0x49, 0x4d, 0x43, 0x54, 0x52, 0x41, 0x43, 0x45,
   ]; // .IMCTRACE
 
-  private static readonly InputMethodClientsTraceFileProto =
-    TamperedMessageType.tamper(
-      root.lookupType(
-        'android.view.inputmethod.InputMethodClientsTraceFileProto',
-      ),
-    );
-  private static readonly ENTRY_FIELD =
-    ParserInputMethodClients.InputMethodClientsTraceFileProto.fields['entry'];
-  private static readonly CLIENT_FIELD = assertDefined(
-    ParserInputMethodClients.ENTRY_FIELD.tamperedMessageType,
-  ).fields['client'];
-  private static readonly HIERARCHY_TREE_FACTORY =
-    new HierarchyTreeClientsFactory(
-      ParserInputMethodClients.ENTRY_FIELD,
-      ParserInputMethodClients.CLIENT_FIELD,
-    );
+  private static readonly InputMethodClientsTraceFileProto = root.lookupType(
+    'android.view.inputmethod.InputMethodClientsTraceFileProto',
+  );
 
   private realToBootTimeOffsetNs: bigint | undefined;
 
@@ -81,25 +67,33 @@ class ParserInputMethodClients extends AbstractParser<
     return decoded.entry ?? [];
   }
 
-  protected override getTimestamp(entry: ImeProto): Timestamp {
-    return this.timestampConverter.makeTimestampFromBootTimeNs(
-      BigInt(assertDefined(entry.elapsedRealtimeNanos).toString()),
-    );
+  override canConvertToPerfetto(): boolean {
+    return true;
   }
 
-  override processDecodedEntry(
-    index: number,
-    entry: ImeProto,
-  ): HierarchyTreeNode {
-    if (
-      entry.elapsedRealtimeNanos === undefined ||
-      entry.elapsedRealtimeNanos === null
-    ) {
-      throw new Error('Missing elapsedRealtimeNanos on IME Clients entry');
+  override convertToPerfettoPackets(
+    sequenceId: number,
+  ): perfetto.protos.TracePacket[] {
+    const packets = [];
+
+    for (const entry of this.decodedEntries) {
+      const packet = perfetto.protos.TracePacket.create();
+      packet.timestamp = assertDefined(entry.elapsedRealtimeNanos);
+      packet.timestampClockId =
+        perfetto.protos.ClockSnapshot.Clock.BuiltinClocks.BOOTTIME;
+      packet.trustedPacketSequenceId = sequenceId;
+      packet.winscopeExtensions = {
+        '.perfetto.protos.WinscopeExtensionsImpl.inputmethodClients':
+          perfetto.protos.InputMethodClientsTraceProto.fromObject(entry),
+      };
+      packets.push(packet);
     }
+    return packets;
+  }
 
-    return ParserInputMethodClients.HIERARCHY_TREE_FACTORY.makeHierarchyTree(
-      entry,
+  protected override getTimestamp(entry: ImeProto): Timestamp {
+    return this.timestampConverter.makeTimestampFromBootTimeNs(
+      BigInt(assertDefined(entry.elapsedRealtimeNanos).toString()),
     );
   }
 }
diff --git a/tools/winscope/src/parsers/input_method/legacy/parser_input_method_clients_test.ts b/tools/winscope/src/parsers/input_method/legacy/parser_input_method_clients_test.ts
index 491171e28..6590a50ae 100644
--- a/tools/winscope/src/parsers/input_method/legacy/parser_input_method_clients_test.ts
+++ b/tools/winscope/src/parsers/input_method/legacy/parser_input_method_clients_test.ts
@@ -19,7 +19,8 @@ import {
   TimestampConverterUtils,
   timestampEqualityTester,
 } from 'common/time/test_utils';
-import {UnitTestUtils} from 'test/unit/utils';
+import Long from 'long';
+import {LegacyParserProvider} from 'test/unit/fixture_utils';
 import {CoarseVersion} from 'trace/coarse_version';
 import {Parser} from 'trace/parser';
 import {TraceType} from 'trace/trace_type';
@@ -31,9 +32,9 @@ describe('ParserInputMethodClients', () => {
 
     beforeAll(async () => {
       jasmine.addCustomEqualityTester(timestampEqualityTester);
-      parser = (await UnitTestUtils.getParser(
-        'traces/elapsed_and_real_timestamp/InputMethodClients.pb',
-      )) as Parser<HierarchyTreeNode>;
+      parser = await new LegacyParserProvider()
+        .addFilename('traces/elapsed_and_real_timestamp/InputMethodClients.pb')
+        .getParser<HierarchyTreeNode>();
     });
 
     it('has expected trace type', () => {
@@ -50,15 +51,52 @@ describe('ParserInputMethodClients', () => {
         TimestampConverterUtils.makeRealTimestamp(1659107090249283325n),
         TimestampConverterUtils.makeRealTimestamp(1659107090279417928n),
       ];
-      expect(assertDefined(parser.getTimestamps()).slice(0, 3)).toEqual(
-        expected,
-      );
+      expect(parser.getTimestamps()?.slice(0, 3)).toEqual(expected);
+    });
+
+    it('does not provide entry', () => {
+      expect(parser.getEntry).toThrow();
+    });
+
+    it('converts to valid perfetto packets', async () => {
+      const packets = parser.convertToPerfettoPackets!(10);
+      expect(packets.length).toEqual(13);
+      expect(packets[0].trustedPacketSequenceId).toEqual(10);
+      const data =
+        packets[0].winscopeExtensions?.[
+          '.perfetto.protos.WinscopeExtensionsImpl.inputmethodClients'
+        ];
+      expect(data?.client).toBeDefined();
+      expect(data?.where).toEqual('InsetsSourceConsumer#setControl');
+      const ts = Long.fromString(BigInt(15613638434).toString());
+      ts.unsigned = true;
+      expect(packets[0].timestamp).toEqual(ts);
     });
 
-    it('retrieves trace entry', async () => {
-      const entry = await parser.getEntry(1);
+    it('converts to valid perfetto trace', async () => {
+      const perfettoParser = await new LegacyParserProvider()
+        .addFilename('traces/elapsed_and_real_timestamp/InputMethodClients.pb')
+        .setConvertToPerfetto(true)
+        .getParser<HierarchyTreeNode>();
+
+      expect(perfettoParser.getTimestamps()?.slice(0, 3)).toEqual([
+        TimestampConverterUtils.makeRealTimestamp(1659107090215405395n),
+        TimestampConverterUtils.makeRealTimestamp(1659107090249283325n),
+        TimestampConverterUtils.makeRealTimestamp(1659107090279417928n),
+      ]);
+
+      const entry = await perfettoParser.getEntry(10);
       expect(entry).toBeInstanceOf(HierarchyTreeNode);
-      expect(entry.id).toEqual('InputMethodClients entry');
+      expect(entry.getEagerPropertyByName('where')?.getValue()).toEqual(
+        'InsetsSourceConsumer#setControl',
+      );
+      const client = assertDefined(entry.getChildByName('client'));
+      const properties = await client.getAllProperties();
+      const intdefProperty = properties
+        ?.getChildByName('viewRootImpl')
+        ?.getChildByName('windowAttributes')
+        ?.getChildByName('type');
+      expect(intdefProperty?.formattedValue()).toEqual('TYPE_BASE_APPLICATION');
     });
   });
 
@@ -67,9 +105,9 @@ describe('ParserInputMethodClients', () => {
 
     beforeAll(async () => {
       jasmine.addCustomEqualityTester(timestampEqualityTester);
-      parser = (await UnitTestUtils.getParser(
-        'traces/elapsed_timestamp/InputMethodClients.pb',
-      )) as Parser<HierarchyTreeNode>;
+      parser = await new LegacyParserProvider()
+        .addFilename('traces/elapsed_timestamp/InputMethodClients.pb')
+        .getParser<HierarchyTreeNode>();
     });
 
     it('has expected trace type', () => {
@@ -82,23 +120,23 @@ describe('ParserInputMethodClients', () => {
       );
     });
 
-    it('retrieves trace entry from timestamp', async () => {
-      const entry = await parser.getEntry(0);
-      expect(entry).toBeInstanceOf(HierarchyTreeNode);
-      expect(entry.id).toEqual('InputMethodClients entry');
+    it('does not provide entry', () => {
+      expect(parser.getEntry).toThrow();
     });
 
-    it('translates intdefs', async () => {
-      const entry = await parser.getEntry(8);
-      const client = assertDefined(entry.getChildByName('client'));
-      const properties = await client.getAllProperties();
-      const intdefProperty = assertDefined(
-        properties
-          ?.getChildByName('viewRootImpl')
-          ?.getChildByName('windowAttributes')
-          ?.getChildByName('type'),
-      );
-      expect(intdefProperty.formattedValue()).toEqual('TYPE_BASE_APPLICATION');
+    it('converts to valid perfetto packets', async () => {
+      const packets = parser.convertToPerfettoPackets!(10);
+      expect(packets.length).toEqual(33);
+      expect(packets[0].trustedPacketSequenceId).toEqual(10);
+      const data =
+        packets[0].winscopeExtensions?.[
+          '.perfetto.protos.WinscopeExtensionsImpl.inputmethodClients'
+        ];
+      expect(data?.client).toBeDefined();
+      expect(data?.where).toEqual('InsetsSourceConsumer#setControl');
+      const ts = Long.fromString(BigInt(1149083651642).toString());
+      ts.unsigned = true;
+      expect(packets[0].timestamp).toEqual(ts);
     });
   });
 });
diff --git a/tools/winscope/src/parsers/input_method/legacy/parser_input_method_manager_service.ts b/tools/winscope/src/parsers/input_method/legacy/parser_input_method_manager_service.ts
index 570fb60b6..dae72e5d9 100644
--- a/tools/winscope/src/parsers/input_method/legacy/parser_input_method_manager_service.ts
+++ b/tools/winscope/src/parsers/input_method/legacy/parser_input_method_manager_service.ts
@@ -16,17 +16,16 @@
 
 import {assertDefined} from 'common/assert_utils';
 import {Timestamp} from 'common/time/time';
-import {HierarchyTreeManagerServiceFactory} from 'parsers/input_method/hierarchy_tree_manager_service_factory';
 import {AbstractParser} from 'parsers/legacy/abstract_parser';
-import {TamperedMessageType} from 'parsers/tampered_message_type';
 import root from 'protos/ime/udc/json';
 import {android} from 'protos/ime/udc/static';
+import {perfetto} from 'protos/perfetto/trace/static';
 import {TraceType} from 'trace/trace_type';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 
 type ImeProto = android.view.inputmethod.IInputMethodManagerServiceTraceProto;
 
-class ParserInputMethodManagerService extends AbstractParser<
+export class ParserInputMethodManagerService extends AbstractParser<
   HierarchyTreeNode,
   ImeProto
 > {
@@ -35,21 +34,8 @@ class ParserInputMethodManagerService extends AbstractParser<
   ]; // .IMMTRACE
 
   private static readonly InputMethodManagerServiceTraceFileProto =
-    TamperedMessageType.tamper(
-      root.lookupType(
-        'android.view.inputmethod.InputMethodManagerServiceTraceFileProto',
-      ),
-    );
-  private static readonly ENTRY_FIELD =
-    ParserInputMethodManagerService.InputMethodManagerServiceTraceFileProto
-      .fields['entry'];
-  private static readonly MANAGER_SERVICE_FIELD = assertDefined(
-    ParserInputMethodManagerService.ENTRY_FIELD.tamperedMessageType,
-  ).fields['inputMethodManagerService'];
-  private static readonly HIERARCHY_TREE_FACTORY =
-    new HierarchyTreeManagerServiceFactory(
-      ParserInputMethodManagerService.ENTRY_FIELD,
-      ParserInputMethodManagerService.MANAGER_SERVICE_FIELD,
+    root.lookupType(
+      'android.view.inputmethod.InputMethodManagerServiceTraceFileProto',
     );
 
   private realToBootTimeOffsetNs: bigint | undefined;
@@ -82,28 +68,33 @@ class ParserInputMethodManagerService extends AbstractParser<
     return decoded.entry ?? [];
   }
 
-  protected override getTimestamp(entry: ImeProto): Timestamp {
-    return this.timestampConverter.makeTimestampFromBootTimeNs(
-      BigInt(assertDefined(entry.elapsedRealtimeNanos).toString()),
-    );
+  override canConvertToPerfetto(): boolean {
+    return true;
   }
 
-  protected override processDecodedEntry(
-    index: number,
-    entry: ImeProto,
-  ): HierarchyTreeNode {
-    if (
-      entry.elapsedRealtimeNanos === undefined ||
-      entry.elapsedRealtimeNanos === null
-    ) {
-      throw new Error(
-        'Missing elapsedRealtimeNanos on IME Manager Service entry',
-      );
+  override convertToPerfettoPackets(
+    sequenceId: number,
+  ): perfetto.protos.TracePacket[] {
+    const packets = [];
+
+    for (const entry of this.decodedEntries) {
+      const packet = perfetto.protos.TracePacket.create();
+      packet.timestamp = assertDefined(entry.elapsedRealtimeNanos);
+      packet.timestampClockId =
+        perfetto.protos.ClockSnapshot.Clock.BuiltinClocks.BOOTTIME;
+      packet.trustedPacketSequenceId = sequenceId;
+      packet.winscopeExtensions = {
+        '.perfetto.protos.WinscopeExtensionsImpl.inputmethodManagerService':
+          perfetto.protos.InputMethodManagerServiceTraceProto.fromObject(entry),
+      };
+      packets.push(packet);
     }
-    return ParserInputMethodManagerService.HIERARCHY_TREE_FACTORY.makeHierarchyTree(
-      entry,
+    return packets;
+  }
+
+  protected override getTimestamp(entry: ImeProto): Timestamp {
+    return this.timestampConverter.makeTimestampFromBootTimeNs(
+      BigInt(assertDefined(entry.elapsedRealtimeNanos).toString()),
     );
   }
 }
-
-export {ParserInputMethodManagerService};
diff --git a/tools/winscope/src/parsers/input_method/legacy/parser_input_method_manager_service_test.ts b/tools/winscope/src/parsers/input_method/legacy/parser_input_method_manager_service_test.ts
index d9255c67b..3423f9b9f 100644
--- a/tools/winscope/src/parsers/input_method/legacy/parser_input_method_manager_service_test.ts
+++ b/tools/winscope/src/parsers/input_method/legacy/parser_input_method_manager_service_test.ts
@@ -18,7 +18,8 @@ import {
   TimestampConverterUtils,
   timestampEqualityTester,
 } from 'common/time/test_utils';
-import {UnitTestUtils} from 'test/unit/utils';
+import Long from 'long';
+import {LegacyParserProvider} from 'test/unit/fixture_utils';
 import {CoarseVersion} from 'trace/coarse_version';
 import {Parser} from 'trace/parser';
 import {TraceType} from 'trace/trace_type';
@@ -30,9 +31,11 @@ describe('ParserInputMethodManagerService', () => {
 
     beforeAll(async () => {
       jasmine.addCustomEqualityTester(timestampEqualityTester);
-      parser = (await UnitTestUtils.getParser(
-        'traces/elapsed_and_real_timestamp/InputMethodManagerService.pb',
-      )) as Parser<HierarchyTreeNode>;
+      parser = await new LegacyParserProvider()
+        .addFilename(
+          'traces/elapsed_and_real_timestamp/InputMethodManagerService.pb',
+        )
+        .getParser<HierarchyTreeNode>();
     });
 
     it('has expected trace type', () => {
@@ -50,10 +53,44 @@ describe('ParserInputMethodManagerService', () => {
       ]);
     });
 
-    it('retrieves trace entry', async () => {
-      const entry = await parser.getEntry(0);
+    it('does not provide entry', () => {
+      expect(parser.getEntry).toThrow();
+    });
+
+    it('converts to valid perfetto packets', async () => {
+      const packets = parser.convertToPerfettoPackets!(10);
+      expect(packets.length).toEqual(1);
+      expect(packets[0].trustedPacketSequenceId).toEqual(10);
+      const data =
+        packets[0].winscopeExtensions?.[
+          '.perfetto.protos.WinscopeExtensionsImpl.inputmethodManagerService'
+        ];
+      expect(data?.inputMethodManagerService).toBeDefined();
+      expect(data?.where).toEqual(
+        'InputMethodManagerService#startInputOrWindowGainedFocus',
+      );
+      const ts = Long.fromString(BigInt(15963782518).toString());
+      ts.unsigned = true;
+      expect(packets[0].timestamp).toEqual(ts);
+    });
+
+    it('converts to valid perfetto trace', async () => {
+      const perfettoParser = await new LegacyParserProvider()
+        .addFilename(
+          'traces/elapsed_and_real_timestamp/InputMethodManagerService.pb',
+        )
+        .setConvertToPerfetto(true)
+        .getParser<HierarchyTreeNode>();
+
+      expect(perfettoParser.getTimestamps()).toEqual([
+        TimestampConverterUtils.makeRealTimestamp(1659107090565549479n),
+      ]);
+
+      const entry = await perfettoParser.getEntry(0);
       expect(entry).toBeInstanceOf(HierarchyTreeNode);
-      expect(entry.id).toEqual('InputMethodManagerService entry');
+      expect(entry.getEagerPropertyByName('where')?.getValue()).toEqual(
+        'InputMethodManagerService#startInputOrWindowGainedFocus',
+      );
     });
   });
 
@@ -61,9 +98,9 @@ describe('ParserInputMethodManagerService', () => {
     let parser: Parser<HierarchyTreeNode>;
 
     beforeAll(async () => {
-      parser = (await UnitTestUtils.getParser(
-        'traces/elapsed_timestamp/InputMethodManagerService.pb',
-      )) as Parser<HierarchyTreeNode>;
+      parser = await new LegacyParserProvider()
+        .addFilename('traces/elapsed_timestamp/InputMethodManagerService.pb')
+        .getParser<HierarchyTreeNode>();
     });
 
     it('has expected trace type', () => {
@@ -78,10 +115,25 @@ describe('ParserInputMethodManagerService', () => {
       );
     });
 
-    it('retrieves trace entry from timestamp', async () => {
-      const entry = await parser.getEntry(0);
-      expect(entry).toBeInstanceOf(HierarchyTreeNode);
-      expect(entry.id).toEqual('InputMethodManagerService entry');
+    it('does not provide entry', () => {
+      expect(parser.getEntry).toThrow();
+    });
+
+    it('converts to valid perfetto packets', async () => {
+      const packets = parser.convertToPerfettoPackets!(10);
+      expect(packets.length).toEqual(3);
+      expect(packets[0].trustedPacketSequenceId).toEqual(10);
+      const data =
+        packets[0].winscopeExtensions?.[
+          '.perfetto.protos.WinscopeExtensionsImpl.inputmethodManagerService'
+        ];
+      expect(data?.inputMethodManagerService).toBeDefined();
+      expect(data?.where).toEqual(
+        'InputMethodManagerService#startInputOrWindowGainedFocus',
+      );
+      const ts = Long.fromString(BigInt(1149226290110).toString());
+      ts.unsigned = true;
+      expect(packets[0].timestamp).toEqual(ts);
     });
   });
 });
diff --git a/tools/winscope/src/parsers/input_method/legacy/parser_input_method_service.ts b/tools/winscope/src/parsers/input_method/legacy/parser_input_method_service.ts
index b5ddc0b39..9d37c691f 100644
--- a/tools/winscope/src/parsers/input_method/legacy/parser_input_method_service.ts
+++ b/tools/winscope/src/parsers/input_method/legacy/parser_input_method_service.ts
@@ -16,41 +16,25 @@
 
 import {assertDefined} from 'common/assert_utils';
 import {Timestamp} from 'common/time/time';
-import {HierarchyTreeServiceFactory} from 'parsers/input_method/hierarchy_tree_service_factory';
 import {AbstractParser} from 'parsers/legacy/abstract_parser';
-import {TamperedMessageType} from 'parsers/tampered_message_type';
 import root from 'protos/ime/udc/json';
 import {android} from 'protos/ime/udc/static';
+import {perfetto} from 'protos/perfetto/trace/static';
 import {TraceType} from 'trace/trace_type';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 
 type ImeProto = android.view.inputmethod.IInputMethodServiceTraceProto;
 
-class ParserInputMethodService extends AbstractParser<
+export class ParserInputMethodService extends AbstractParser<
   HierarchyTreeNode,
   ImeProto
 > {
   private static readonly MAGIC_NUMBER = [
     0x09, 0x49, 0x4d, 0x53, 0x54, 0x52, 0x41, 0x43, 0x45,
   ]; // .IMSTRACE
-
-  private static readonly InputMethodServiceTraceFileProto =
-    TamperedMessageType.tamper(
-      root.lookupType(
-        'android.view.inputmethod.InputMethodServiceTraceFileProto',
-      ),
-    );
-  private static readonly ENTRY_FIELD =
-    ParserInputMethodService.InputMethodServiceTraceFileProto.fields['entry'];
-  private static readonly SERVICE_FIELD = assertDefined(
-    ParserInputMethodService.ENTRY_FIELD.tamperedMessageType,
-  ).fields['inputMethodService'];
-
-  private static readonly HIERARCHY_TREE_FACTORY =
-    new HierarchyTreeServiceFactory(
-      ParserInputMethodService.ENTRY_FIELD,
-      ParserInputMethodService.SERVICE_FIELD,
-    );
+  private static readonly InputMethodServiceTraceFileProto = root.lookupType(
+    'android.view.inputmethod.InputMethodServiceTraceFileProto',
+  );
 
   private realToBootTimeOffsetNs: bigint | undefined;
 
@@ -82,26 +66,33 @@ class ParserInputMethodService extends AbstractParser<
     return decoded.entry ?? [];
   }
 
-  protected override getTimestamp(entry: ImeProto): Timestamp {
-    return this.timestampConverter.makeTimestampFromBootTimeNs(
-      BigInt(assertDefined(entry.elapsedRealtimeNanos).toString()),
-    );
+  override canConvertToPerfetto(): boolean {
+    return true;
   }
 
-  override processDecodedEntry(
-    index: number,
-    entry: ImeProto,
-  ): HierarchyTreeNode {
-    if (
-      entry.elapsedRealtimeNanos === undefined ||
-      entry.elapsedRealtimeNanos === null
-    ) {
-      throw new Error('Missing elapsedRealtimeNanos on IME Service entry');
+  override convertToPerfettoPackets(
+    sequenceId: number,
+  ): perfetto.protos.TracePacket[] {
+    const packets = [];
+
+    for (const entry of this.decodedEntries) {
+      const packet = perfetto.protos.TracePacket.create();
+      packet.timestamp = assertDefined(entry.elapsedRealtimeNanos);
+      packet.timestampClockId =
+        perfetto.protos.ClockSnapshot.Clock.BuiltinClocks.BOOTTIME;
+      packet.trustedPacketSequenceId = sequenceId;
+      packet.winscopeExtensions = {
+        '.perfetto.protos.WinscopeExtensionsImpl.inputmethodService':
+          perfetto.protos.InputMethodServiceTraceProto.fromObject(entry),
+      };
+      packets.push(packet);
     }
-    return ParserInputMethodService.HIERARCHY_TREE_FACTORY.makeHierarchyTree(
-      entry,
+    return packets;
+  }
+
+  protected override getTimestamp(entry: ImeProto): Timestamp {
+    return this.timestampConverter.makeTimestampFromBootTimeNs(
+      BigInt(assertDefined(entry.elapsedRealtimeNanos).toString()),
     );
   }
 }
-
-export {ParserInputMethodService};
diff --git a/tools/winscope/src/parsers/input_method/legacy/parser_input_method_service_test.ts b/tools/winscope/src/parsers/input_method/legacy/parser_input_method_service_test.ts
index 59e3d413e..30e909e67 100644
--- a/tools/winscope/src/parsers/input_method/legacy/parser_input_method_service_test.ts
+++ b/tools/winscope/src/parsers/input_method/legacy/parser_input_method_service_test.ts
@@ -18,7 +18,8 @@ import {
   TimestampConverterUtils,
   timestampEqualityTester,
 } from 'common/time/test_utils';
-import {UnitTestUtils} from 'test/unit/utils';
+import Long from 'long';
+import {LegacyParserProvider} from 'test/unit/fixture_utils';
 import {CoarseVersion} from 'trace/coarse_version';
 import {Parser} from 'trace/parser';
 import {TraceType} from 'trace/trace_type';
@@ -30,9 +31,9 @@ describe('ParserInputMethodService', () => {
 
     beforeAll(async () => {
       jasmine.addCustomEqualityTester(timestampEqualityTester);
-      parser = (await UnitTestUtils.getParser(
-        'traces/elapsed_and_real_timestamp/InputMethodService.pb',
-      )) as Parser<HierarchyTreeNode>;
+      parser = await new LegacyParserProvider()
+        .addFilename('traces/elapsed_and_real_timestamp/InputMethodService.pb')
+        .getParser<HierarchyTreeNode>();
     });
 
     it('has expected trace type', () => {
@@ -50,10 +51,40 @@ describe('ParserInputMethodService', () => {
       expect(parser.getTimestamps()).toEqual(expected);
     });
 
-    it('retrieves trace entry', async () => {
-      const entry = await parser.getEntry(0);
+    it('does not provide entry', () => {
+      expect(parser.getEntry).toThrow();
+    });
+
+    it('converts to valid perfetto packets', async () => {
+      const packets = parser.convertToPerfettoPackets!(10);
+      expect(packets.length).toEqual(1);
+      expect(packets[0].trustedPacketSequenceId).toEqual(10);
+      const data =
+        packets[0].winscopeExtensions?.[
+          '.perfetto.protos.WinscopeExtensionsImpl.inputmethodService'
+        ];
+      expect(data?.inputMethodService).toBeDefined();
+      expect(data?.where).toEqual('InputMethodService#doStartInput');
+      const ts = Long.fromString(BigInt(16578752896).toString());
+      ts.unsigned = true;
+      expect(packets[0].timestamp).toEqual(ts);
+    });
+
+    it('converts to valid perfetto trace', async () => {
+      const perfettoParser = await new LegacyParserProvider()
+        .addFilename('traces/elapsed_and_real_timestamp/InputMethodService.pb')
+        .setConvertToPerfetto(true)
+        .getParser<HierarchyTreeNode>();
+
+      expect(perfettoParser.getTimestamps()).toEqual([
+        TimestampConverterUtils.makeRealTimestamp(1659107091180519857n),
+      ]);
+
+      const entry = await perfettoParser.getEntry(0);
       expect(entry).toBeInstanceOf(HierarchyTreeNode);
-      expect(entry.id).toEqual('InputMethodService entry');
+      expect(entry.getEagerPropertyByName('where')?.getValue()).toEqual(
+        'InputMethodService#doStartInput',
+      );
     });
   });
 
@@ -61,9 +92,9 @@ describe('ParserInputMethodService', () => {
     let parser: Parser<HierarchyTreeNode>;
 
     beforeAll(async () => {
-      parser = (await UnitTestUtils.getParser(
-        'traces/elapsed_timestamp/InputMethodService.pb',
-      )) as Parser<HierarchyTreeNode>;
+      parser = await new LegacyParserProvider()
+        .addFilename('traces/elapsed_timestamp/InputMethodService.pb')
+        .getParser<HierarchyTreeNode>();
     });
 
     it('has expected trace type', () => {
@@ -76,10 +107,25 @@ describe('ParserInputMethodService', () => {
       );
     });
 
-    it('retrieves trace entry', async () => {
-      const entry = await parser.getEntry(0);
-      expect(entry).toBeInstanceOf(HierarchyTreeNode);
-      expect(entry.id).toEqual('InputMethodService entry');
+    it('does not provide entry', () => {
+      expect(parser.getEntry).toThrow();
+    });
+
+    it('converts to valid perfetto packets', async () => {
+      const packets = parser.convertToPerfettoPackets!(10);
+      expect(packets.length).toEqual(7);
+      expect(packets[0].trustedPacketSequenceId).toEqual(10);
+
+      const data = assertDefined(
+        packets[0].winscopeExtensions?.[
+          '.perfetto.protos.WinscopeExtensionsImpl.inputmethodService'
+        ],
+      );
+      expect(data.where).toEqual('InputMethodService#doFinishInput');
+      expect(data?.inputMethodService).toBeDefined();
+      const ts = Long.fromString(BigInt(1149230019887).toString());
+      ts.unsigned = true;
+      expect(packets[0].timestamp).toEqual(ts);
     });
   });
 });
diff --git a/tools/winscope/src/parsers/input_method/perfetto/parser_input_method_clients.ts b/tools/winscope/src/parsers/input_method/perfetto/parser_input_method_clients.ts
index 78b394ed0..307e6071f 100644
--- a/tools/winscope/src/parsers/input_method/perfetto/parser_input_method_clients.ts
+++ b/tools/winscope/src/parsers/input_method/perfetto/parser_input_method_clients.ts
@@ -19,20 +19,19 @@ import {ParserTimestampConverter} from 'common/time/timestamp_converter';
 import {HierarchyTreeClientsFactory} from 'parsers/input_method/hierarchy_tree_clients_factory';
 import {AbstractParser} from 'parsers/perfetto/abstract_parser';
 import {FakeProtoTransformer} from 'parsers/perfetto/fake_proto_transformer';
-import {Utils} from 'parsers/perfetto/utils';
-import {TamperedMessageType} from 'parsers/tampered_message_type';
-import root from 'protos/ime/latest/json';
+import {queryEntry} from 'parsers/perfetto/utils';
+import {TAMPERED_WINSCOPE_EXTENSIONS} from 'parsers/tampered_message_type';
 import {TraceFile} from 'trace/trace_file';
 import {TraceType} from 'trace/trace_type';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 import {TraceProcessor} from 'trace_processor/trace_processor';
 
 export class ParserInputMethodClients extends AbstractParser<HierarchyTreeNode> {
-  private static readonly Wrapper = TamperedMessageType.tamper(
-    root.lookupType('perfetto.protos.Wrapper'),
+  private static readonly ENTRY_FIELD = assertDefined(
+    TAMPERED_WINSCOPE_EXTENSIONS.fields[
+      '.perfetto.protos.WinscopeExtensionsImpl.inputmethodClients'
+    ],
   );
-  private static readonly ENTRY_FIELD =
-    ParserInputMethodClients.Wrapper.fields['inputmethodClients'];
   private static readonly CLIENT_FIELD = assertDefined(
     ParserInputMethodClients.ENTRY_FIELD.tamperedMessageType,
   ).fields['client'];
@@ -61,7 +60,7 @@ export class ParserInputMethodClients extends AbstractParser<HierarchyTreeNode>
   }
 
   override async getEntry(index: number): Promise<HierarchyTreeNode> {
-    let entryProto = await Utils.queryEntry(
+    let entryProto = await queryEntry(
       this.traceProcessor,
       this.getTableName(),
       this.entryIndexToRowIdMap,
diff --git a/tools/winscope/src/parsers/input_method/perfetto/parser_input_method_clients_test.ts b/tools/winscope/src/parsers/input_method/perfetto/parser_input_method_clients_test.ts
index 58857b83f..ea588dd60 100644
--- a/tools/winscope/src/parsers/input_method/perfetto/parser_input_method_clients_test.ts
+++ b/tools/winscope/src/parsers/input_method/perfetto/parser_input_method_clients_test.ts
@@ -18,18 +18,18 @@ import {
   TimestampConverterUtils,
   timestampEqualityTester,
 } from 'common/time/test_utils';
-import {UnitTestUtils} from 'test/unit/utils';
+import {getPerfettoParser} from 'test/unit/fixture_utils';
 import {CoarseVersion} from 'trace/coarse_version';
 import {Parser} from 'trace/parser';
 import {TraceType} from 'trace/trace_type';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 
-describe('Perfetto ParserInputMethodClients', () => {
+describe('PerfettoParserInputMethodClients', () => {
   let parser: Parser<HierarchyTreeNode>;
 
   beforeAll(async () => {
     jasmine.addCustomEqualityTester(timestampEqualityTester);
-    parser = (await UnitTestUtils.getPerfettoParser(
+    parser = (await getPerfettoParser(
       TraceType.INPUT_METHOD_CLIENTS,
       'traces/perfetto/ime.perfetto-trace',
     )) as Parser<HierarchyTreeNode>;
diff --git a/tools/winscope/src/parsers/input_method/perfetto/parser_input_method_manager_service.ts b/tools/winscope/src/parsers/input_method/perfetto/parser_input_method_manager_service.ts
index ff1b2f7e1..fde133687 100644
--- a/tools/winscope/src/parsers/input_method/perfetto/parser_input_method_manager_service.ts
+++ b/tools/winscope/src/parsers/input_method/perfetto/parser_input_method_manager_service.ts
@@ -19,20 +19,19 @@ import {ParserTimestampConverter} from 'common/time/timestamp_converter';
 import {HierarchyTreeManagerServiceFactory} from 'parsers/input_method/hierarchy_tree_manager_service_factory';
 import {AbstractParser} from 'parsers/perfetto/abstract_parser';
 import {FakeProtoTransformer} from 'parsers/perfetto/fake_proto_transformer';
-import {Utils} from 'parsers/perfetto/utils';
-import {TamperedMessageType} from 'parsers/tampered_message_type';
-import root from 'protos/ime/latest/json';
+import {queryEntry} from 'parsers/perfetto/utils';
+import {TAMPERED_WINSCOPE_EXTENSIONS} from 'parsers/tampered_message_type';
 import {TraceFile} from 'trace/trace_file';
 import {TraceType} from 'trace/trace_type';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 import {TraceProcessor} from 'trace_processor/trace_processor';
 
 export class ParserInputMethodManagerService extends AbstractParser<HierarchyTreeNode> {
-  private static readonly Wrapper = TamperedMessageType.tamper(
-    root.lookupType('perfetto.protos.Wrapper'),
+  private static readonly ENTRY_FIELD = assertDefined(
+    TAMPERED_WINSCOPE_EXTENSIONS.fields[
+      '.perfetto.protos.WinscopeExtensionsImpl.inputmethodManagerService'
+    ],
   );
-  private static readonly ENTRY_FIELD =
-    ParserInputMethodManagerService.Wrapper.fields['inputmethodManagerService'];
   private static readonly MANAGER_SERVICE_FIELD = assertDefined(
     ParserInputMethodManagerService.ENTRY_FIELD.tamperedMessageType,
   ).fields['inputMethodManagerService'];
@@ -63,7 +62,7 @@ export class ParserInputMethodManagerService extends AbstractParser<HierarchyTre
   }
 
   override async getEntry(index: number): Promise<HierarchyTreeNode> {
-    let entryProto = await Utils.queryEntry(
+    let entryProto = await queryEntry(
       this.traceProcessor,
       this.getTableName(),
       this.entryIndexToRowIdMap,
diff --git a/tools/winscope/src/parsers/input_method/perfetto/parser_input_method_manager_service_test.ts b/tools/winscope/src/parsers/input_method/perfetto/parser_input_method_manager_service_test.ts
index 8efd2071f..bc556cdb4 100644
--- a/tools/winscope/src/parsers/input_method/perfetto/parser_input_method_manager_service_test.ts
+++ b/tools/winscope/src/parsers/input_method/perfetto/parser_input_method_manager_service_test.ts
@@ -18,18 +18,18 @@ import {
   TimestampConverterUtils,
   timestampEqualityTester,
 } from 'common/time/test_utils';
-import {UnitTestUtils} from 'test/unit/utils';
+import {getPerfettoParser} from 'test/unit/fixture_utils';
 import {CoarseVersion} from 'trace/coarse_version';
 import {Parser} from 'trace/parser';
 import {TraceType} from 'trace/trace_type';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 
-describe('Perfetto ParserInputMethodManagerService', () => {
+describe('PerfettoParserInputMethodManagerService', () => {
   let parser: Parser<HierarchyTreeNode>;
 
   beforeAll(async () => {
     jasmine.addCustomEqualityTester(timestampEqualityTester);
-    parser = (await UnitTestUtils.getPerfettoParser(
+    parser = (await getPerfettoParser(
       TraceType.INPUT_METHOD_MANAGER_SERVICE,
       'traces/perfetto/ime.perfetto-trace',
     )) as Parser<HierarchyTreeNode>;
@@ -61,6 +61,4 @@ describe('Perfetto ParserInputMethodManagerService', () => {
     expect(entry).toBeInstanceOf(HierarchyTreeNode);
     expect(entry.id).toEqual('InputMethodManagerService entry');
   });
-
-  //TODO: check decoded intdefs
 });
diff --git a/tools/winscope/src/parsers/input_method/perfetto/parser_input_method_service.ts b/tools/winscope/src/parsers/input_method/perfetto/parser_input_method_service.ts
index a922510f8..81df3a130 100644
--- a/tools/winscope/src/parsers/input_method/perfetto/parser_input_method_service.ts
+++ b/tools/winscope/src/parsers/input_method/perfetto/parser_input_method_service.ts
@@ -19,20 +19,19 @@ import {ParserTimestampConverter} from 'common/time/timestamp_converter';
 import {HierarchyTreeServiceFactory} from 'parsers/input_method/hierarchy_tree_service_factory';
 import {AbstractParser} from 'parsers/perfetto/abstract_parser';
 import {FakeProtoTransformer} from 'parsers/perfetto/fake_proto_transformer';
-import {Utils} from 'parsers/perfetto/utils';
-import {TamperedMessageType} from 'parsers/tampered_message_type';
-import root from 'protos/ime/latest/json';
+import {queryEntry} from 'parsers/perfetto/utils';
+import {TAMPERED_WINSCOPE_EXTENSIONS} from 'parsers/tampered_message_type';
 import {TraceFile} from 'trace/trace_file';
 import {TraceType} from 'trace/trace_type';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 import {TraceProcessor} from 'trace_processor/trace_processor';
 
 export class ParserInputMethodService extends AbstractParser<HierarchyTreeNode> {
-  private static readonly Wrapper = TamperedMessageType.tamper(
-    root.lookupType('perfetto.protos.Wrapper'),
+  private static readonly ENTRY_FIELD = assertDefined(
+    TAMPERED_WINSCOPE_EXTENSIONS.fields[
+      '.perfetto.protos.WinscopeExtensionsImpl.inputmethodService'
+    ],
   );
-  private static readonly ENTRY_FIELD =
-    ParserInputMethodService.Wrapper.fields['inputmethodService'];
   private static readonly SERVICE_FIELD = assertDefined(
     ParserInputMethodService.ENTRY_FIELD.tamperedMessageType,
   ).fields['inputMethodService'];
@@ -61,7 +60,7 @@ export class ParserInputMethodService extends AbstractParser<HierarchyTreeNode>
   }
 
   override async getEntry(index: number): Promise<HierarchyTreeNode> {
-    let entryProto = await Utils.queryEntry(
+    let entryProto = await queryEntry(
       this.traceProcessor,
       this.getTableName(),
       this.entryIndexToRowIdMap,
diff --git a/tools/winscope/src/parsers/input_method/perfetto/parser_input_method_service_test.ts b/tools/winscope/src/parsers/input_method/perfetto/parser_input_method_service_test.ts
index 1c2013946..29f32751c 100644
--- a/tools/winscope/src/parsers/input_method/perfetto/parser_input_method_service_test.ts
+++ b/tools/winscope/src/parsers/input_method/perfetto/parser_input_method_service_test.ts
@@ -18,18 +18,18 @@ import {
   TimestampConverterUtils,
   timestampEqualityTester,
 } from 'common/time/test_utils';
-import {UnitTestUtils} from 'test/unit/utils';
+import {getPerfettoParser} from 'test/unit/fixture_utils';
 import {CoarseVersion} from 'trace/coarse_version';
 import {Parser} from 'trace/parser';
 import {TraceType} from 'trace/trace_type';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 
-describe('Perfetto ParserInputMethodService', () => {
+describe('PerfettoParserInputMethodService', () => {
   let parser: Parser<HierarchyTreeNode>;
 
   beforeAll(async () => {
     jasmine.addCustomEqualityTester(timestampEqualityTester);
-    parser = (await UnitTestUtils.getPerfettoParser(
+    parser = (await getPerfettoParser(
       TraceType.INPUT_METHOD_SERVICE,
       'traces/perfetto/ime.perfetto-trace',
     )) as Parser<HierarchyTreeNode>;
diff --git a/tools/winscope/src/parsers/legacy/abstract_parser.ts b/tools/winscope/src/parsers/legacy/abstract_parser.ts
index 2fd339655..4312b8f65 100644
--- a/tools/winscope/src/parsers/legacy/abstract_parser.ts
+++ b/tools/winscope/src/parsers/legacy/abstract_parser.ts
@@ -14,8 +14,10 @@
  * limitations under the License.
  */
 
+import {NOT_IMPLEMENTED_ERROR} from 'common/errors';
 import {Timestamp} from 'common/time/time';
 import {ParserTimestampConverter} from 'common/time/timestamp_converter';
+import {perfetto} from 'protos/perfetto/trace/static';
 import {CoarseVersion} from 'trace/coarse_version';
 import {
   CustomQueryParamTypeMap,
@@ -43,7 +45,6 @@ export abstract class AbstractParser<
   protected abstract getMagicNumber(): undefined | number[];
   protected abstract decodeTrace(trace: Uint8Array): U[] | Promise<U[]>;
   protected abstract getTimestamp(decodedEntry: U): Timestamp;
-  protected abstract processDecodedEntry(index: number, decodedEntry: U): T;
 
   constructor(
     trace: TraceFile,
@@ -94,7 +95,26 @@ export abstract class AbstractParser<
     entriesRange: EntriesRange,
     param?: CustomQueryParamTypeMap[Q],
   ): Promise<CustomQueryParserResultTypeMap[Q]> {
-    throw new Error('Not implemented');
+    throw NOT_IMPLEMENTED_ERROR;
+  }
+
+  canConvertToPerfetto(): boolean {
+    return false;
+  }
+
+  convertToPerfettoPackets(
+    sequenceId: number,
+    trustedPid: number,
+    trustedUid: number,
+  ): perfetto.protos.TracePacket[] {
+    throw NOT_IMPLEMENTED_ERROR;
+  }
+
+  protected processDecodedEntry(index: number, decodedEntry: U): T {
+    // Legacy parsers that implement convertToPerfettoPackets should not
+    // parser and provide individual trace entries, as they should be
+    // converted to perfetto using LegacyToPerfettoConverter
+    throw NOT_IMPLEMENTED_ERROR;
   }
 
   private decodeTimestamps(): Timestamp[] {
diff --git a/tools/winscope/src/parsers/legacy/parser_common_test.ts b/tools/winscope/src/parsers/legacy/parser_common_test.ts
index 73cda44b6..3e80bcc39 100644
--- a/tools/winscope/src/parsers/legacy/parser_common_test.ts
+++ b/tools/winscope/src/parsers/legacy/parser_common_test.ts
@@ -18,8 +18,7 @@ import {
   TimestampConverterUtils,
   timestampEqualityTester,
 } from 'common/time/test_utils';
-import {getFixtureFile} from 'test/unit/fixture_utils';
-import {UnitTestUtils} from 'test/unit/utils';
+import {getFixtureFile, LegacyParserProvider} from 'test/unit/fixture_utils';
 import {Parser} from 'trace/parser';
 import {TraceFile} from 'trace/trace_file';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
@@ -30,52 +29,38 @@ describe('Parser', () => {
     jasmine.addCustomEqualityTester(timestampEqualityTester);
   });
 
-  it('is robust to empty trace file', async () => {
-    const trace = new TraceFile(
-      await getFixtureFile('traces/empty.pb'),
-      undefined,
-    );
-    const parsers = await new ParserFactory().createParsers(
-      [trace],
-      TimestampConverterUtils.TIMESTAMP_CONVERTER,
-      {},
-    );
-    expect(parsers.length).toEqual(0);
-  });
+  describe('is robust to', () => {
+    it('empty trace file', async () => {
+      await checkRobustToFile('invalid_files/empty.pb', true);
+    });
 
-  it('is robust to trace with no entries', async () => {
-    const trace = new TraceFile(
-      await getFixtureFile('traces/no_entries_InputMethodClients.pb'),
-      undefined,
-    );
-    const parsers = await new ParserFactory().createParsers(
-      [trace],
-      TimestampConverterUtils.TIMESTAMP_CONVERTER,
-      {},
-    );
-    expect(parsers.length).toEqual(0);
-  });
+    it('trace with no entries', async () => {
+      await checkRobustToFile('invalid_files/no_entries_InputMethodClients.pb');
+    });
 
-  it('is robust to view capture trace with no entries', async () => {
-    const trace = new TraceFile(
-      await getFixtureFile('traces/no_entries_view_capture.vc'),
-      undefined,
-    );
-    const parsers = await new ParserFactory().createParsers(
-      [trace],
-      TimestampConverterUtils.TIMESTAMP_CONVERTER,
-      {},
-    );
-    expect(parsers.length).toEqual(0);
+    it('view capture trace with no entries', async () => {
+      await checkRobustToFile('invalid_files/no_entries_view_capture.vc');
+    });
+
+    async function checkRobustToFile(file: string, unsupported = false) {
+      const trace = new TraceFile(await getFixtureFile(file), undefined);
+      const processed = await new ParserFactory().processFiles(
+        [trace],
+        TimestampConverterUtils.TIMESTAMP_CONVERTER,
+        {},
+      );
+      expect(processed.parsers.length).toEqual(0);
+      expect(processed.unsupportedFiles).toEqual(unsupported ? [trace] : []);
+    }
   });
 
   describe('real timestamp', () => {
     let parser: Parser<HierarchyTreeNode>;
 
     beforeAll(async () => {
-      parser = (await UnitTestUtils.getParser(
-        'traces/elapsed_and_real_timestamp/WindowManager.pb',
-      )) as Parser<HierarchyTreeNode>;
+      parser = await new LegacyParserProvider()
+        .addFilename('traces/elapsed_and_real_timestamp/WindowManager.pb')
+        .getParser<HierarchyTreeNode>();
     });
 
     it('has expected descriptors', () => {
@@ -110,9 +95,9 @@ describe('Parser', () => {
     let parser: Parser<HierarchyTreeNode>;
 
     beforeAll(async () => {
-      parser = (await UnitTestUtils.getParser(
-        'traces/elapsed_timestamp/WindowManager.pb',
-      )) as Parser<HierarchyTreeNode>;
+      parser = await new LegacyParserProvider()
+        .addFilename('traces/elapsed_timestamp/WindowManager.pb')
+        .getParser<HierarchyTreeNode>();
     });
 
     it('provides timestamps', () => {
diff --git a/tools/winscope/src/parsers/legacy/parser_factory.ts b/tools/winscope/src/parsers/legacy/parser_factory.ts
index 4c28c2d77..81fbd9376 100644
--- a/tools/winscope/src/parsers/legacy/parser_factory.ts
+++ b/tools/winscope/src/parsers/legacy/parser_factory.ts
@@ -17,10 +17,7 @@ import {assertTrue} from 'common/assert_utils';
 import {ParserTimestampConverter} from 'common/time/timestamp_converter';
 import {UserNotifier} from 'common/user_notifier';
 import {ProgressListener} from 'messaging/progress_listener';
-import {
-  InvalidLegacyTrace,
-  UnsupportedFileFormat,
-} from 'messaging/user_warnings';
+import {InvalidLegacyTrace} from 'messaging/user_warnings';
 import {ParserEventLog} from 'parsers/events/parser_eventlog';
 import {FileAndParser} from 'parsers/file_and_parser';
 import {ParserInputMethodClients} from 'parsers/input_method/legacy/parser_input_method_clients';
@@ -41,6 +38,11 @@ import {Parser} from 'trace/parser';
 import {TraceFile} from 'trace/trace_file';
 import {TraceMetadata} from 'trace/trace_metadata';
 
+interface ProcessedFiles {
+  parsers: FileAndParser[];
+  unsupportedFiles: TraceFile[];
+}
+
 export class ParserFactory {
   static readonly PARSERS = [
     ParserInputMethodClients,
@@ -60,13 +62,14 @@ export class ParserFactory {
     ParserScreenshot,
   ];
 
-  async createParsers(
+  async processFiles(
     traceFiles: TraceFile[],
     timestampConverter: ParserTimestampConverter,
     metadata: TraceMetadata,
     progressListener?: ProgressListener,
-  ): Promise<FileAndParser[]> {
+  ): Promise<ProcessedFiles> {
     const parsers = new Array<{file: TraceFile; parser: Parser<object>}>();
+    const unsupportedFiles: TraceFile[] = [];
 
     for (const [index, traceFile] of traceFiles.entries()) {
       progressListener?.onProgressUpdate(
@@ -110,9 +113,9 @@ export class ParserFactory {
       }
 
       if (!hasFoundParser) {
-        UserNotifier.add(new UnsupportedFileFormat(traceFile.getDescriptor()));
+        unsupportedFiles.push(traceFile);
       }
     }
-    return parsers;
+    return {parsers, unsupportedFiles};
   }
 }
diff --git a/tools/winscope/src/parsers/legacy/parsing_utils.ts b/tools/winscope/src/parsers/legacy/parsing_utils.ts
index ddd394dd8..02b5af4e3 100644
--- a/tools/winscope/src/parsers/legacy/parsing_utils.ts
+++ b/tools/winscope/src/parsers/legacy/parsing_utils.ts
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-import {ArrayUtils} from 'common/array_utils';
+import {equal} from 'common/array_utils';
 
 export class ParsingUtils {
   static throwIfMagicNumberDoesNotMatch(
@@ -22,7 +22,7 @@ export class ParsingUtils {
     magicNumber: number[] | undefined,
   ) {
     if (magicNumber !== undefined) {
-      const bufferContainsMagicNumber = ArrayUtils.equal(
+      const bufferContainsMagicNumber = equal(
         magicNumber,
         traceBuffer.slice(0, magicNumber.length),
       );
diff --git a/tools/winscope/src/parsers/legacy_to_perfetto_converter.ts b/tools/winscope/src/parsers/legacy_to_perfetto_converter.ts
new file mode 100644
index 000000000..49a06ecf7
--- /dev/null
+++ b/tools/winscope/src/parsers/legacy_to_perfetto_converter.ts
@@ -0,0 +1,278 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import {assertDefined} from 'common/assert_utils';
+import {NOT_IMPLEMENTED_ERROR} from 'common/errors';
+import {UserNotifier} from 'common/user_notifier';
+import Long from 'long';
+import {FailedToConvertLegacyTraces} from 'messaging/user_warnings';
+import {perfetto} from 'protos/perfetto/trace/static';
+import {Parser} from 'trace/parser';
+import {TraceFile} from 'trace/trace_file';
+import {
+  getParserWithLatestRealToBootTimeOffset,
+  getParserWithLatestRealToMonotonicTimeOffset,
+} from './parser_time_utils';
+
+export interface ClockSnapshot {
+  realtime: bigint;
+  boottime: bigint | undefined;
+  monotonic: bigint | undefined;
+}
+
+export class LegacyToPerfettoConverter {
+  static async convertToSinglePerfettoFile(
+    legacyParsers: Array<Parser<object>>,
+    allParsers: Array<Parser<object>>,
+    perfettoFile?: TraceFile,
+  ): Promise<TraceFile | undefined> {
+    let trace: perfetto.protos.Trace;
+    try {
+      trace = await LegacyToPerfettoConverter.makePerfettoTrace(
+        allParsers,
+        perfettoFile,
+      );
+    } catch (e) {
+      console.error(e);
+      UserNotifier.add(
+        new FailedToConvertLegacyTraces((e as Error).message),
+      ).notify();
+      return perfettoFile;
+    }
+    const legacyPackets = LegacyToPerfettoConverter.makeTraceDataPackets(
+      legacyParsers,
+      trace,
+    );
+    if (legacyPackets.length === 0) {
+      return undefined;
+    }
+    trace.packet.push(...legacyPackets);
+
+    const data = perfetto.protos.Trace.encode(trace).finish();
+    return new TraceFile(
+      new File([data], 'combined_winscope_trace.perfetto-trace'),
+    );
+  }
+
+  private static async makePerfettoTrace(
+    allParsers: Array<Parser<object>>,
+    perfettoFile?: TraceFile,
+  ): Promise<perfetto.protos.Trace> {
+    let trace: perfetto.protos.Trace;
+    if (!perfettoFile) {
+      const clockSnapshots =
+        LegacyToPerfettoConverter.makeClockSnapshots(allParsers);
+      trace = perfetto.protos.Trace.create();
+      if (clockSnapshots.length === 0) {
+        throw new Error('no parsers or Perfetto file provided');
+      }
+      clockSnapshots.forEach((snapshot) => {
+        const clockSnapshot =
+          LegacyToPerfettoConverter.makeTracePacketWithClockSnapshot(snapshot);
+        trace.packet.push(clockSnapshot);
+      });
+    } else {
+      const fileBuffer = new Uint8Array(await perfettoFile.file.arrayBuffer());
+      trace = perfetto.protos.Trace.decode(fileBuffer);
+    }
+
+    return trace;
+  }
+
+  private static makeClockSnapshots(
+    parsers: Array<Parser<object>>,
+  ): ClockSnapshot[] {
+    if (parsers.length === 0) {
+      return [];
+    }
+    const clockSnapshots: ClockSnapshot[] = [];
+
+    const boottimeParser = getParserWithLatestRealToBootTimeOffset(parsers);
+    const monotonicParser =
+      getParserWithLatestRealToMonotonicTimeOffset(parsers);
+
+    const boottimeSnapshots: ClockSnapshot[] = [];
+    const monotonicSnapshots: ClockSnapshot[] = [];
+
+    if (boottimeParser === undefined && monotonicParser === undefined) {
+      LegacyToPerfettoConverter.getRealTimestampsForClockSnapshots(
+        parsers[0],
+      ).forEach((realtime) => {
+        clockSnapshots.push({
+          realtime,
+          boottime: realtime,
+          monotonic: realtime,
+        });
+      });
+    }
+
+    if (boottimeParser) {
+      const boottimeOffset = boottimeParser?.getRealToBootTimeOffsetNs();
+      LegacyToPerfettoConverter.getRealTimestampsForClockSnapshots(
+        boottimeParser,
+      ).forEach((realtime) => {
+        const boottime = realtime - assertDefined(boottimeOffset);
+        boottimeSnapshots.push({realtime, boottime, monotonic: undefined});
+      });
+    }
+
+    if (monotonicParser) {
+      const monotonicOffset = monotonicParser?.getRealToMonotonicTimeOffsetNs();
+      LegacyToPerfettoConverter.getRealTimestampsForClockSnapshots(
+        monotonicParser,
+      ).forEach((realtime) => {
+        const monotonic = realtime - assertDefined(monotonicOffset);
+
+        // Monotonic snapshots must contain a boottime timestamp for TP to be able
+        // to convert monotonic timestamps to boottime
+        let boottime: bigint;
+        if (boottimeParser) {
+          const snapshotB = boottimeSnapshots[boottimeSnapshots.length - 1];
+          const realtimeDiff = snapshotB.realtime - realtime;
+          boottime = assertDefined(snapshotB.boottime) - realtimeDiff;
+        } else {
+          boottime = monotonic;
+        }
+
+        monotonicSnapshots.push({realtime, boottime, monotonic});
+      });
+    }
+
+    clockSnapshots.push(...boottimeSnapshots);
+    clockSnapshots.push(...monotonicSnapshots);
+
+    return clockSnapshots;
+  }
+
+  private static getRealTimestampsForClockSnapshots(
+    parser: Parser<object>,
+  ): Array<bigint> {
+    const ts = assertDefined(parser.getTimestamps());
+    const realTs: Array<bigint> = [];
+    if (ts.length > 0) {
+      realTs.push(ts[0].getValueNs());
+    }
+    if (ts.length > 1) {
+      // to adjust against drift in TP, we add clock snapshots at the
+      // start and end of the trace
+      realTs.push(ts[parser.getLengthEntries() - 1].getValueNs());
+    }
+    return realTs;
+  }
+
+  private static makeTracePacketWithClockSnapshot(
+    legacySnapshot: ClockSnapshot,
+  ): perfetto.protos.TracePacket {
+    const packet = perfetto.protos.TracePacket.create();
+    packet.trustedPacketSequenceId = 1;
+
+    const snapshot = perfetto.protos.ClockSnapshot.create();
+
+    const realtime = Long.fromString(legacySnapshot.realtime.toString());
+
+    const clockRealtimeCoarse = perfetto.protos.ClockSnapshot.Clock.create();
+    clockRealtimeCoarse.clockId =
+      perfetto.protos.ClockSnapshot.Clock.BuiltinClocks.REALTIME_COARSE;
+    clockRealtimeCoarse.timestamp = realtime;
+    snapshot.clocks.push(clockRealtimeCoarse);
+
+    const clockRealtime = perfetto.protos.ClockSnapshot.Clock.create();
+    clockRealtime.clockId =
+      perfetto.protos.ClockSnapshot.Clock.BuiltinClocks.REALTIME;
+    clockRealtime.timestamp = realtime;
+    snapshot.clocks.push(clockRealtime);
+
+    if (legacySnapshot.boottime !== undefined) {
+      const boottime = Long.fromString(legacySnapshot.boottime.toString());
+      const clockBoottime = perfetto.protos.ClockSnapshot.Clock.create();
+      clockBoottime.clockId =
+        perfetto.protos.ClockSnapshot.Clock.BuiltinClocks.BOOTTIME;
+      clockBoottime.timestamp = boottime;
+      snapshot.clocks.push(clockBoottime);
+    }
+
+    if (legacySnapshot.monotonic !== undefined) {
+      const monotonic = Long.fromString(legacySnapshot.monotonic.toString());
+      const clockMonotonic = perfetto.protos.ClockSnapshot.Clock.create();
+      clockMonotonic.clockId =
+        perfetto.protos.ClockSnapshot.Clock.BuiltinClocks.MONOTONIC;
+      clockMonotonic.timestamp = monotonic;
+      snapshot.clocks.push(clockMonotonic);
+
+      const clockMonotonicCoarse = perfetto.protos.ClockSnapshot.Clock.create();
+      clockMonotonicCoarse.clockId =
+        perfetto.protos.ClockSnapshot.Clock.BuiltinClocks.MONOTONIC_COARSE;
+      clockMonotonicCoarse.timestamp = monotonic;
+      snapshot.clocks.push(clockMonotonicCoarse);
+
+      const clockMonotonicRaw = perfetto.protos.ClockSnapshot.Clock.create();
+      clockMonotonicRaw.clockId =
+        perfetto.protos.ClockSnapshot.Clock.BuiltinClocks.MONOTONIC_RAW;
+      clockMonotonicRaw.timestamp = monotonic;
+      snapshot.clocks.push(clockMonotonicRaw);
+    }
+
+    packet.clockSnapshot = snapshot;
+
+    return packet;
+  }
+
+  private static makeTraceDataPackets(
+    legacyParsers: Array<Parser<object>>,
+    trace: perfetto.protos.Trace,
+  ): perfetto.protos.TracePacket[] {
+    const [largestUid, largestPid] = trace.packet.reduce(
+      ([uid, pid], packet) => {
+        return [
+          Math.max(packet.trustedUid ?? 0, uid),
+          Math.max(packet.trustedPid ?? 0, pid),
+        ];
+      },
+      [0, 0],
+    );
+    let [trustedUid, trustedPid] = [largestUid + 1, largestPid + 1];
+
+    const packets: perfetto.protos.TracePacket[] = [];
+    let sequenceId =
+      Math.max(
+        ...trace.packet.map((packet) => packet.trustedPacketSequenceId ?? 0),
+      ) + 1;
+    for (const parser of legacyParsers) {
+      if (parser.canConvertToPerfetto()) {
+        try {
+          const legacyPackets = parser.convertToPerfettoPackets!(
+            sequenceId,
+            trustedUid,
+            trustedPid,
+          );
+          if (legacyPackets.length > 0) {
+            legacyPackets[0].firstPacketOnSequence = true;
+            packets.push(...legacyPackets);
+            sequenceId++;
+            trustedUid++;
+            trustedPid++;
+          }
+        } catch (e) {
+          // swallow
+          if (e !== NOT_IMPLEMENTED_ERROR) {
+            console.error(e);
+          }
+        }
+      }
+    }
+    return packets;
+  }
+}
diff --git a/tools/winscope/src/parsers/legacy_to_perfetto_converter_test.ts b/tools/winscope/src/parsers/legacy_to_perfetto_converter_test.ts
new file mode 100644
index 000000000..830ec2a5f
--- /dev/null
+++ b/tools/winscope/src/parsers/legacy_to_perfetto_converter_test.ts
@@ -0,0 +1,388 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import {assertDefined} from 'common/assert_utils';
+import {TimestampConverterUtils} from 'common/time/test_utils';
+import Long from 'long';
+import {FailedToConvertLegacyTraces} from 'messaging/user_warnings';
+import {perfetto} from 'protos/perfetto/trace/static';
+import {ParserBuilder} from 'test/unit/parser_builder';
+import {UserNotifierChecker} from 'test/unit/user_notifier_checker';
+import {Parser} from 'trace/parser';
+import {TraceFile} from 'trace/trace_file';
+import {
+  ClockSnapshot,
+  LegacyToPerfettoConverter,
+} from './legacy_to_perfetto_converter';
+
+type TracePacket = perfetto.protos.TracePacket;
+
+describe('LegacyToPerfettoConverter', () => {
+  const packetB1 = makePacketWithBoottimeTs(10);
+  const packetB2 = makePacketWithBoottimeTs(15);
+  const packetB3 = makePacketWithBoottimeTs(18);
+  const packetM1 = makePacketWithMonotonicTs(14);
+  const packetM2 = makePacketWithMonotonicTs(20);
+  const packetM3 = makePacketWithMonotonicTs(25);
+
+  const perfettoClock = {realtime: 50n, boottime: 30n, monotonic: 40n};
+  const perfettoSnapshot = makeExpectedClockSnapshot(perfettoClock);
+  const emptyPacket = perfetto.protos.TracePacket.create();
+  const existingFile = makeExistingPerfettoFile(perfettoSnapshot, emptyPacket);
+
+  it('converts multiple legacy files to new perfetto file', async () => {
+    const parser1 = makeParser([packetB1]);
+    spyOn(parser1, 'getRealToMonotonicTimeOffsetNs').and.returnValue(undefined);
+    const parser2 = makeParser([packetB2]);
+    spyOn(parser2, 'getRealToMonotonicTimeOffsetNs').and.returnValue(undefined);
+
+    const perfettoFile = await convertToPerfetto([parser1, parser2]);
+    const trace = await checkAndDecodePerfettoFile(assertDefined(perfettoFile));
+    expect(trace.packet).toEqual([
+      makeExpectedClockSnapshot({
+        realtime: 15n,
+        boottime: 15n,
+        monotonic: undefined,
+      }),
+      packetB1,
+      packetB2,
+    ]);
+  });
+
+  it('adds multiple legacy files to existing perfetto file', async () => {
+    const parsers = [makeParser([packetB1]), makeParser([packetM1])];
+    const perfettoFile = await convertToPerfetto(parsers, existingFile);
+    const trace = await checkAndDecodePerfettoFile(assertDefined(perfettoFile));
+    expect(trace.packet).toEqual([
+      perfettoSnapshot,
+      emptyPacket,
+      packetB1,
+      packetM1,
+    ]);
+  });
+
+  it('ignores legacy file that cannot be converted to perfetto format', async () => {
+    const parser1 = makeParser([]);
+    expect(await convertToPerfetto([parser1])).toBeUndefined();
+    expect(await convertToPerfetto([parser1], existingFile)).toBeUndefined();
+
+    const parser2 = makeParser([packetM1]);
+    const parsers = [parser1, parser2];
+    const perfettoFile = await convertToPerfetto(parsers, existingFile);
+    const trace = await checkAndDecodePerfettoFile(assertDefined(perfettoFile));
+    expect(trace.packet).toEqual([perfettoSnapshot, emptyPacket, packetM1]);
+  });
+
+  it('converts elapsed legacy trace to new perfetto trace', async () => {
+    await testElapsedParsers([packetB1]);
+  });
+
+  it('converts elapsed legacy trace with multiple entries', async () => {
+    const packets = [packetB1, packetB2, packetB3];
+    await testElapsedParsers(packets);
+  });
+
+  it('converts legacy trace with real-to-boottime offset', async () => {
+    await testBoottimeParsers([packetB1]);
+  });
+
+  it('converts legacy trace with real-to-boottime offset with multiple entries', async () => {
+    const packets = [packetB1, packetB2, packetB3];
+    await testBoottimeParsers(packets);
+  });
+
+  it('converts legacy trace with real-to-monotonic offset', async () => {
+    await testMonotonicParsers([packetM1]);
+  });
+
+  it('converts legacy trace with real-to-monotonic offset with multiple entries', async () => {
+    const packets = [packetM1, packetM2, packetM3];
+    await testMonotonicParsers(packets);
+  });
+
+  it('with boot-time and monotonically offset parsers loaded', async () => {
+    const parserB = makeParser([packetB1]);
+    spyOn(parserB, 'getRealToBootTimeOffsetNs').and.returnValue(2n);
+    spyOn(parserB, 'getRealToMonotonicTimeOffsetNs').and.returnValue(undefined);
+
+    const parserM = makeParser([packetM1]);
+    spyOn(parserM, 'getRealToBootTimeOffsetNs').and.returnValue(undefined);
+    spyOn(parserM, 'getRealToMonotonicTimeOffsetNs').and.returnValue(3n);
+
+    const perfettoFile =
+      await LegacyToPerfettoConverter.convertToSinglePerfettoFile(
+        [parserM],
+        [parserM, parserB],
+      );
+    const trace = await checkAndDecodePerfettoFile(assertDefined(perfettoFile));
+    expect(trace.packet).toEqual([
+      makeExpectedClockSnapshot({
+        realtime: 10n,
+        boottime: 8n,
+        monotonic: undefined,
+      }),
+      makeExpectedClockSnapshot({
+        realtime: 14n,
+        boottime: 12n,
+        monotonic: 11n,
+      }),
+      packetM1,
+    ]);
+  });
+
+  it('converts legacy trace with zero timestamp', async () => {
+    const packet = makePacketWithBoottimeTs(0);
+    const parser = makeParser([packet]);
+    spyOn(parser, 'getRealToBootTimeOffsetNs').and.returnValue(undefined);
+    spyOn(parser, 'getRealToMonotonicTimeOffsetNs').and.returnValue(undefined);
+    const perfettoFile = await convertToPerfetto([parser]);
+    const trace = await checkAndDecodePerfettoFile(assertDefined(perfettoFile));
+    const clockSnapshot = makeExpectedClockSnapshot({
+      realtime: 0n,
+      boottime: 0n,
+      monotonic: 0n,
+    });
+    expect(trace.packet).toEqual([clockSnapshot, packet]);
+  });
+
+  it('robust to errors in existing trace decoding', async () => {
+    const userNotifierChecker = new UserNotifierChecker();
+    const parser = makeParser([]);
+    spyOn(perfetto.protos.Trace, 'decode').and.throwError('decoding failed');
+    const perfettoFile = await convertToPerfetto([parser], existingFile);
+    expect(perfettoFile).toEqual(existingFile);
+    userNotifierChecker.expectNotified([
+      new FailedToConvertLegacyTraces('decoding failed'),
+    ]);
+  });
+
+  it('robust to errors in packet conversion', async () => {
+    const parser = makeParser([], true);
+    expect(await convertToPerfetto([parser])).toBeUndefined();
+  });
+
+  it('robust to errors if allParsers empty and no Perfetto file provided', async () => {
+    const userNotifierChecker = new UserNotifierChecker();
+    const parser = makeParser([], true);
+    const perfettoFile =
+      await LegacyToPerfettoConverter.convertToSinglePerfettoFile([parser], []);
+    expect(perfettoFile).toBeUndefined();
+    userNotifierChecker.expectNotified([
+      new FailedToConvertLegacyTraces('no parsers or Perfetto file provided'),
+    ]);
+  });
+
+  function makePacketWithMonotonicTs(ts: number) {
+    return perfetto.protos.TracePacket.create({
+      trustedPacketSequenceId: 1,
+      timestamp: Long.fromInt(ts, true),
+      timestampClockId:
+        perfetto.protos.ClockSnapshot.Clock.BuiltinClocks.MONOTONIC,
+    });
+  }
+
+  function makePacketWithBoottimeTs(ts: number) {
+    return perfetto.protos.TracePacket.create({
+      trustedPacketSequenceId: 1,
+      timestamp: Long.fromInt(ts, true),
+      timestampClockId:
+        perfetto.protos.ClockSnapshot.Clock.BuiltinClocks.BOOTTIME,
+    });
+  }
+
+  async function convertToPerfetto(
+    parsers: Array<Parser<{}>>,
+    perfettoFile?: TraceFile,
+  ) {
+    return await LegacyToPerfettoConverter.convertToSinglePerfettoFile(
+      parsers,
+      parsers,
+      perfettoFile,
+    );
+  }
+
+  async function testElapsedParsers(packets: TracePacket[]) {
+    const parser = makeParser(packets);
+    spyOn(parser, 'getRealToBootTimeOffsetNs').and.returnValue(undefined);
+    spyOn(parser, 'getRealToMonotonicTimeOffsetNs').and.returnValue(undefined);
+    const perfettoFile = await convertToPerfetto([parser]);
+    const trace = await checkAndDecodePerfettoFile(assertDefined(perfettoFile));
+    const snapshotPackets = [
+      makeExpectedClockSnapshot({
+        realtime: 10n,
+        boottime: 10n,
+        monotonic: 10n,
+      }),
+    ];
+    if (packets.length > 1) {
+      snapshotPackets.push(
+        makeExpectedClockSnapshot({
+          realtime: 18n,
+          boottime: 18n,
+          monotonic: 18n,
+        }),
+      );
+    }
+    expect(trace.packet).toEqual([...snapshotPackets, ...packets]);
+  }
+
+  async function testBoottimeParsers(packets: TracePacket[]) {
+    const parser = makeParser(packets);
+    spyOn(parser, 'getRealToBootTimeOffsetNs').and.returnValue(3n);
+    spyOn(parser, 'getRealToMonotonicTimeOffsetNs').and.returnValue(undefined);
+    await testConversion(parser, packets, false);
+  }
+
+  async function testMonotonicParsers(packets: TracePacket[]) {
+    const parser = makeParser(packets);
+    spyOn(parser, 'getRealToBootTimeOffsetNs').and.returnValue(undefined);
+    spyOn(parser, 'getRealToMonotonicTimeOffsetNs').and.returnValue(3n);
+    await testConversion(parser, packets, true);
+  }
+
+  async function testConversion(
+    parser: Parser<{}>,
+    packets: TracePacket[],
+    isMonotonic: boolean,
+  ) {
+    const perfettoFile = await convertToPerfetto([parser]);
+    const trace = await checkAndDecodePerfettoFile(assertDefined(perfettoFile));
+    const snapshotPackets = [makeSnapshotFromPacket(packets[0], isMonotonic)];
+    if (packets.length > 1) {
+      snapshotPackets.push(
+        makeSnapshotFromPacket(packets[packets.length - 1], isMonotonic),
+      );
+    }
+    expect(trace.packet).toEqual([...snapshotPackets, ...packets]);
+  }
+
+  function makeSnapshotFromPacket(packet: TracePacket, isMonotonic = false) {
+    const realtime = BigInt(packet.timestamp?.toString() ?? 0n);
+    return makeExpectedClockSnapshot({
+      realtime,
+      boottime: realtime - 3n,
+      monotonic: isMonotonic ? realtime - 3n : undefined,
+    });
+  }
+
+  function makeExistingPerfettoFile(
+    clockSnapshot20: TracePacket,
+    emptyPacket: TracePacket,
+  ) {
+    const existingTrace = perfetto.protos.Trace.fromObject({
+      packet: [clockSnapshot20, emptyPacket],
+    });
+    return new TraceFile(
+      new File(
+        [perfetto.protos.Trace.encode(existingTrace).finish()],
+        'existing_trace',
+      ),
+    );
+  }
+
+  function makeParser(
+    testPackets: TracePacket[],
+    conversionError = false,
+  ): Parser<{}> {
+    const ts =
+      testPackets.length === 0
+        ? [TimestampConverterUtils.makeRealTimestamp(0n)]
+        : testPackets.map((testPacket) => {
+            const ns = BigInt(testPacket?.timestamp.toString() ?? 0n);
+            return TimestampConverterUtils.makeRealTimestamp(ns);
+          });
+    const parser = new ParserBuilder<string>()
+      .setEntries(ts.length === 0 ? [''] : ts.map((t) => ''))
+      .setTimestamps(ts)
+      .build();
+
+    if (testPackets.length > 0) {
+      const parserConvertSpy = jasmine.createSpy();
+      parserConvertSpy.and.returnValue(testPackets);
+      parser.convertToPerfettoPackets = parserConvertSpy;
+    } else if (conversionError) {
+      const parserConvertSpy = jasmine.createSpy();
+      parserConvertSpy.and.throwError(new Error('conversion failed'));
+      parser.convertToPerfettoPackets = parserConvertSpy;
+    }
+
+    return parser;
+  }
+
+  async function checkAndDecodePerfettoFile(
+    perfettoFile: TraceFile,
+  ): Promise<perfetto.protos.Trace> {
+    const expectedPerfettoTraceName = 'combined_winscope_trace.perfetto-trace';
+    expect(perfettoFile.getDescriptor()).toEqual(expectedPerfettoTraceName);
+    const fileBuffer = new Uint8Array(await perfettoFile.file.arrayBuffer());
+    return perfetto.protos.Trace.decode(fileBuffer);
+  }
+
+  function makeExpectedClockSnapshot(
+    clockSnapshot: ClockSnapshot,
+  ): TracePacket {
+    const realtime = Long.fromString(clockSnapshot.realtime.toString());
+    const clocks = [
+      {
+        clockId:
+          perfetto.protos.ClockSnapshot.Clock.BuiltinClocks.REALTIME_COARSE,
+        timestamp: realtime,
+      },
+      {
+        clockId: perfetto.protos.ClockSnapshot.Clock.BuiltinClocks.REALTIME,
+        timestamp: realtime,
+      },
+    ];
+
+    if (clockSnapshot.boottime !== undefined) {
+      clocks.push({
+        clockId: perfetto.protos.ClockSnapshot.Clock.BuiltinClocks.BOOTTIME,
+        timestamp: Long.fromString(clockSnapshot.boottime.toString()),
+      });
+    }
+
+    if (clockSnapshot.monotonic !== undefined) {
+      const monotonic = Long.fromString(clockSnapshot.monotonic.toString());
+      clocks.push(
+        ...[
+          {
+            clockId:
+              perfetto.protos.ClockSnapshot.Clock.BuiltinClocks.MONOTONIC,
+            timestamp: monotonic,
+          },
+          {
+            clockId:
+              perfetto.protos.ClockSnapshot.Clock.BuiltinClocks
+                .MONOTONIC_COARSE,
+            timestamp: monotonic,
+          },
+          {
+            clockId:
+              perfetto.protos.ClockSnapshot.Clock.BuiltinClocks.MONOTONIC_RAW,
+            timestamp: monotonic,
+          },
+        ],
+      );
+    }
+
+    return perfetto.protos.TracePacket.fromObject({
+      trustedPacketSequenceId: 1,
+      clockSnapshot: {
+        clocks,
+      },
+    });
+  }
+});
diff --git a/tools/winscope/src/parsers/operations/set_formatters.ts b/tools/winscope/src/parsers/operations/set_formatters.ts
index 22401252d..5a439262a 100644
--- a/tools/winscope/src/parsers/operations/set_formatters.ts
+++ b/tools/winscope/src/parsers/operations/set_formatters.ts
@@ -14,6 +14,7 @@
  * limitations under the License.
  */
 
+import {Timestamp} from 'common/time/time';
 import {RawDataUtils} from 'parsers/raw_data_utils';
 import {
   TamperedMessageType,
@@ -31,6 +32,7 @@ import {
   RECT_FORMATTER,
   REGION_FORMATTER,
   SIZE_FORMATTER,
+  TIMESTAMP_NODE_FORMATTER,
   TRANSFORM_FORMATTER,
 } from 'trace/tree_node/formatters';
 import {Operation} from 'trace/tree_node/operations/operation';
@@ -79,6 +81,8 @@ export class SetFormatters implements Operation<PropertyTreeNode> {
 
     if (valuesById) return new EnumFormatter(valuesById);
 
+    if (node.getValue() instanceof Timestamp) return TIMESTAMP_NODE_FORMATTER;
+
     if (RawDataUtils.isColor(node)) return COLOR_FORMATTER;
     if (RawDataUtils.isRect(node)) return RECT_FORMATTER;
     if (RawDataUtils.isBuffer(node)) return BUFFER_FORMATTER;
diff --git a/tools/winscope/src/parsers/operations/set_formatters_test.ts b/tools/winscope/src/parsers/operations/set_formatters_test.ts
index 0beeb6c63..d4a53c7a4 100644
--- a/tools/winscope/src/parsers/operations/set_formatters_test.ts
+++ b/tools/winscope/src/parsers/operations/set_formatters_test.ts
@@ -15,7 +15,7 @@
  */
 
 import {assertDefined} from 'common/assert_utils';
-import {TransformTypeFlags} from 'parsers/surface_flinger/transform_utils';
+import {TimestampConverterUtils} from 'common/time/test_utils';
 import {
   TamperedMessageType,
   TamperedProtoField,
@@ -23,6 +23,7 @@ import {
 import root from 'protos/test/fake_proto/json';
 import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
 import {TreeNodeUtils} from 'test/unit/tree_node_utils';
+import {TransformTypeFlags} from 'trace/surface_flinger/transform_utils';
 import {EMPTY_OBJ_STRING, LAYER_ID_FORMATTER} from 'trace/tree_node/formatters';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 import {SetFormatters} from './set_formatters';
@@ -269,4 +270,17 @@ describe('SetFormatters', () => {
       assertDefined(propertyRoot.getChildByName('layerId')).formattedValue(),
     ).toEqual('none');
   });
+
+  it('adds correct formatter for timestamp node', () => {
+    propertyRoot = new PropertyTreeBuilder()
+      .setIsRoot(true)
+      .setRootId('test')
+      .setName('node')
+      .setChildren([
+        {name: 'ts', value: TimestampConverterUtils.makeElapsedTimestamp(10n)},
+      ])
+      .build();
+    operation.apply(propertyRoot);
+    expect(propertyRoot.getChildByName('ts')?.formattedValue()).toEqual('10ns');
+  });
 });
diff --git a/tools/winscope/src/parsers/operations/translate_intdef.ts b/tools/winscope/src/parsers/operations/translate_intdef.ts
index 8e5a4b264..48926cdb7 100644
--- a/tools/winscope/src/parsers/operations/translate_intdef.ts
+++ b/tools/winscope/src/parsers/operations/translate_intdef.ts
@@ -66,7 +66,7 @@ export class TranslateIntDef implements Operation<PropertyTreeNode> {
       if (this.intDefColumn[propertyPath]) {
         return this.getIntFlagsAsStrings(
           value,
-          this.intDefColumn[propertyPath] as string,
+          this.intDefColumn[propertyPath],
         );
       }
     }
@@ -177,6 +177,6 @@ export class TranslateIntDef implements Operation<PropertyTreeNode> {
     'WindowStateProto.requestedVisibleTypes':
       'android.view.WindowInsets.Type.InsetsType',
     'Target.flags': 'android.window.TransitionInfo.ChangeFlags',
-    'Transition.flags': 'android.view.WindowManager.TransitionFlags',
+    'ShellTransition.flags': 'android.view.WindowManager.TransitionFlags',
   };
 }
diff --git a/tools/winscope/src/parsers/operations/translate_intdef_test.ts b/tools/winscope/src/parsers/operations/translate_intdef_test.ts
index 3a1cbb831..fec95cd6e 100644
--- a/tools/winscope/src/parsers/operations/translate_intdef_test.ts
+++ b/tools/winscope/src/parsers/operations/translate_intdef_test.ts
@@ -148,7 +148,9 @@ describe('TranslateIntDef', () => {
       assertDefined(
         propertyRoot.getChildByName('inputConfig'),
       ).formattedValue(),
-    ).toEqual('SENSITIVE_FOR_PRIVACY | UNKNOWN (0xFFF80000)');
+    ).toEqual(
+      'DISPLAY_TOPOLOGY_AWARE | SENSITIVE_FOR_PRIVACY | UNKNOWN (0xFFF00000)',
+    );
   });
 
   it('formats flags if no translation found', () => {
@@ -158,7 +160,7 @@ describe('TranslateIntDef', () => {
       .setName('node')
       .setChildren([
         {name: 'layoutParamsFlags', value: 0},
-        {name: 'inputConfig', value: -524288},
+        {name: 'inputConfig', value: -1048576},
       ])
       .build();
 
@@ -174,6 +176,6 @@ describe('TranslateIntDef', () => {
       assertDefined(
         propertyRoot.getChildByName('inputConfig'),
       ).formattedValue(),
-    ).toEqual('UNKNOWN (0xFFF80000)');
+    ).toEqual('UNKNOWN (0xFFF00000)');
   });
 });
diff --git a/tools/winscope/src/parsers/parser_time_utils.ts b/tools/winscope/src/parsers/parser_time_utils.ts
new file mode 100644
index 000000000..dd0a9886d
--- /dev/null
+++ b/tools/winscope/src/parsers/parser_time_utils.ts
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import {assertDefined} from 'common/assert_utils';
+import {Parser} from 'trace/parser';
+
+export function getParserWithLatestRealToBootTimeOffset(
+  parsers: Array<Parser<object>>,
+): Parser<object> | undefined {
+  return parsers
+    .filter((parser) => parser.getRealToBootTimeOffsetNs() !== undefined)
+    .sort((a, b) => {
+      return Number(
+        assertDefined(a.getRealToBootTimeOffsetNs()) -
+          assertDefined(b.getRealToBootTimeOffsetNs()),
+      );
+    })
+    .at(-1);
+}
+
+export function getParserWithLatestRealToMonotonicTimeOffset(
+  parsers: Array<Parser<object>>,
+): Parser<object> | undefined {
+  return parsers
+    .filter((parser) => parser.getRealToMonotonicTimeOffsetNs() !== undefined)
+    .sort((a, b) => {
+      return Number(
+        assertDefined(a.getRealToMonotonicTimeOffsetNs()) -
+          assertDefined(b.getRealToMonotonicTimeOffsetNs()),
+      );
+    })
+    .at(-1);
+}
diff --git a/tools/winscope/src/parsers/perfetto/abstract_parser.ts b/tools/winscope/src/parsers/perfetto/abstract_parser.ts
index e4e508b5d..684047cb3 100644
--- a/tools/winscope/src/parsers/perfetto/abstract_parser.ts
+++ b/tools/winscope/src/parsers/perfetto/abstract_parser.ts
@@ -14,7 +14,8 @@
  * limitations under the License.
  */
 
-import {assertDefined, assertTrue} from 'common/assert_utils';
+import {assertBigInt, assertDefined, assertTrue} from 'common/assert_utils';
+import {NOT_IMPLEMENTED_ERROR} from 'common/errors';
 import {INVALID_TIME_NS, Timestamp} from 'common/time/time';
 import {ParserTimestampConverter} from 'common/time/timestamp_converter';
 import {CoarseVersion} from 'trace/coarse_version';
@@ -82,7 +83,7 @@ export abstract class AbstractParser<T> implements Parser<T> {
       }
     }
     this.realToBootTimeOffsetNs = await this.queryRealToBootTimeOffset(
-      assertDefined(lastNonZeroTimestamp),
+      assertDefined(lastNonZeroTimestamp ?? INVALID_TIME_NS),
     );
   }
 
@@ -112,7 +113,7 @@ export abstract class AbstractParser<T> implements Parser<T> {
     entriesRange: EntriesRange,
     param?: CustomQueryParamTypeMap[Q],
   ): Promise<CustomQueryParserResultTypeMap[Q]> {
-    throw new Error('Not implemented');
+    throw NOT_IMPLEMENTED_ERROR;
   }
 
   getDescriptors(): string[] {
@@ -127,16 +128,20 @@ export abstract class AbstractParser<T> implements Parser<T> {
     return this.realToBootTimeOffsetNs;
   }
 
+  canConvertToPerfetto(): boolean {
+    return false;
+  }
+
   protected async buildEntryIndexToRowIdMap(): Promise<AbsoluteEntryIndex[]> {
     const sqlRowIdAndTimestamp = `
      SELECT DISTINCT tbl.id AS id, tbl.ts
      FROM ${this.getTableName()} AS tbl
      ORDER BY tbl.ts;
    `;
-    const result = await this.traceProcessor.queryAllRows(sqlRowIdAndTimestamp);
+    const result = await this.traceProcessor.query(sqlRowIdAndTimestamp);
     const entryIndexToRowId: AbsoluteEntryIndex[] = [];
     for (const it = result.iter({}); it.valid(); it.next()) {
-      const rowId = Number(it.get('id') as bigint);
+      const rowId = Number(it.get('id'));
       entryIndexToRowId.push(rowId);
     }
     return entryIndexToRowId;
@@ -144,10 +149,10 @@ export abstract class AbstractParser<T> implements Parser<T> {
 
   private async queryRowBootTimeTimestamps(): Promise<Array<bigint>> {
     const sql = `SELECT ts FROM ${this.getTableName()} ORDER BY id;`;
-    const result = await this.traceProcessor.queryAllRows(sql);
+    const result = await this.traceProcessor.query(sql);
     const timestamps: Array<bigint> = [];
     for (const it = result.iter({}); it.valid(); it.next()) {
-      timestamps.push(it.get('ts') as bigint);
+      timestamps.push(assertBigInt(it.get('ts')));
     }
     return timestamps;
   }
@@ -161,13 +166,13 @@ export abstract class AbstractParser<T> implements Parser<T> {
       SELECT TO_REALTIME(${bootTimeNs}) as realtime;
     `;
 
-    const result = await this.traceProcessor.queryAllRows(sql);
+    const result = await this.traceProcessor.query(sql);
     assertTrue(
       result.numRows() === 1,
       () => 'Failed to query realtime timestamp',
     );
 
-    const real = result.iter({}).get('realtime') as bigint;
+    const real = assertBigInt(result.iter({}).get('realtime'));
     return real - bootTimeNs;
   }
 
diff --git a/tools/winscope/src/parsers/perfetto/abstract_parser_test.ts b/tools/winscope/src/parsers/perfetto/abstract_parser_test.ts
index f922f5701..6eb249ea3 100644
--- a/tools/winscope/src/parsers/perfetto/abstract_parser_test.ts
+++ b/tools/winscope/src/parsers/perfetto/abstract_parser_test.ts
@@ -13,19 +13,28 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-import {UnitTestUtils} from 'test/unit/utils';
+import {getPerfettoParser, getPerfettoParsers} from 'test/unit/fixture_utils';
 import {TraceType} from 'trace/trace_type';
 
-describe('Perfetto AbstractParser', () => {
-  it('fails parsing if there are no trace entries', async () => {
-    const parsers = await UnitTestUtils.getPerfettoParsers(
-      'traces/perfetto/no_winscope_traces.perfetto-trace',
+describe('PerfettoAbstractParser', () => {
+  it('robust to perfetto trace with no trace entries', async () => {
+    const parsers = await getPerfettoParsers(
+      'invalid_files/no_winscope_traces.perfetto-trace',
+    );
+    expect(parsers.length).toEqual(0);
+  });
+
+  it('robust to non-perfetto file', async () => {
+    const parsers = await getPerfettoParsers(
+      'traces/screenshot/screenshot.png',
+      false,
+      false,
     );
     expect(parsers.length).toEqual(0);
   });
 
   it('has expected descriptors', async () => {
-    const parser = await UnitTestUtils.getPerfettoParser(
+    const parser = await getPerfettoParser(
       TraceType.SURFACE_FLINGER,
       'traces/perfetto/layers_trace.perfetto-trace',
     );
diff --git a/tools/winscope/src/parsers/perfetto/fake_proto_builder.ts b/tools/winscope/src/parsers/perfetto/fake_proto_builder.ts
index e9988a0be..23914dbcd 100644
--- a/tools/winscope/src/parsers/perfetto/fake_proto_builder.ts
+++ b/tools/winscope/src/parsers/perfetto/fake_proto_builder.ts
@@ -15,7 +15,7 @@
  */
 
 import {ObjectUtils} from 'common/object_utils';
-import {StringUtils} from 'common/string_utils';
+import {convertSnakeToCamelCase} from 'common/string_utils';
 
 export type FakeProto = any;
 
@@ -32,7 +32,7 @@ export class FakeProtoBuilder {
     const keyCamelCase = key
       .split('.')
       .map((token) => {
-        return StringUtils.convertSnakeToCamelCase(token);
+        return convertSnakeToCamelCase(token);
       })
       .join('.');
     const value = this.makeValue(valueType, intValue, realValue, stringValue);
diff --git a/tools/winscope/src/parsers/perfetto/parser_factory.ts b/tools/winscope/src/parsers/perfetto/parser_factory.ts
index 5c5794cb7..2fe6a01bb 100644
--- a/tools/winscope/src/parsers/perfetto/parser_factory.ts
+++ b/tools/winscope/src/parsers/perfetto/parser_factory.ts
@@ -18,10 +18,7 @@ import {ParserTimestampConverter} from 'common/time/timestamp_converter';
 import {UserNotifier} from 'common/user_notifier';
 import {Analytics} from 'logging/analytics';
 import {ProgressListener} from 'messaging/progress_listener';
-import {
-  InvalidPerfettoTrace,
-  PerfettoPacketLoss,
-} from 'messaging/user_warnings';
+import {InvalidPerfettoTrace} from 'messaging/user_warnings';
 import {ParserKeyEvent} from 'parsers/input/perfetto/parser_key_event';
 import {ParserMotionEvent} from 'parsers/input/perfetto/parser_motion_event';
 import {ParserInputMethodClients} from 'parsers/input_method/perfetto/parser_input_method_clients';
@@ -35,10 +32,14 @@ import {ParserViewCapture} from 'parsers/view_capture/perfetto/parser_view_captu
 import {ParserWindowManager} from 'parsers/window_manager/perfetto/parser_window_manager';
 import {Parser} from 'trace/parser';
 import {TraceFile} from 'trace/trace_file';
-import {Row} from 'trace_processor/query_result';
 import {TraceProcessor} from 'trace_processor/trace_processor';
 import {TraceProcessorFactory} from 'trace_processor/trace_processor_factory';
 
+interface ProcessedFile {
+  parsers: Array<Parser<object>>;
+  isPerfettoTrace: boolean;
+}
+
 export class ParserFactory {
   private static readonly PARSERS = [
     ParserInputMethodClients,
@@ -57,11 +58,11 @@ export class ParserFactory {
   private static readonly NO_ENTRIES_ERROR_REGEX =
     /Perfetto trace has no \w+(\w|\s)* entries/;
 
-  async createParsers(
+  async processFile(
     traceFile: TraceFile,
     timestampConverter: ParserTimestampConverter,
     progressListener?: ProgressListener,
-  ): Promise<Array<Parser<object>>> {
+  ): Promise<ProcessedFile> {
     const traceProcessor = await this.initializeTraceProcessor();
     for (
       let chunkStart = 0;
@@ -80,7 +81,7 @@ export class ParserFactory {
         await traceProcessor.parse(new Uint8Array(data));
       } catch (e) {
         console.error('Trace processor failed to parse data:', e);
-        return [];
+        return {parsers: [], isPerfettoTrace: false};
       }
     }
     await traceProcessor.notifyEof();
@@ -129,28 +130,17 @@ export class ParserFactory {
         new InvalidPerfettoTrace(traceFile.getDescriptor(), errors),
       );
     }
-    const result = await traceProcessor.queryAllRows(
-      "select name, value from stats where name = 'traced_buf_trace_writer_packet_loss'",
-    );
-    if (result.numRows() > 0) {
-      const value = result.firstRow<Row>({})['value'];
-      if (typeof value === 'bigint' && value > 0n) {
-        UserNotifier.add(
-          new PerfettoPacketLoss(traceFile.getDescriptor(), Number(value)),
-        );
-      }
-    }
-
-    return parsers;
+    return {parsers, isPerfettoTrace: true};
   }
 
   private async initializeTraceProcessor(): Promise<TraceProcessor> {
-    const traceProcessor = await TraceProcessorFactory.getSingleInstance();
+    const traceProcessor = TraceProcessorFactory.getSingleInstance();
 
     await traceProcessor.resetTraceProcessor({
       cropTrackEvents: false,
       ingestFtraceInRawTable: false,
       analyzeTraceProtoContent: false,
+      ftraceDropUntilAllCpusValid: false,
     });
     Analytics.Memory.logUsage('tp_initialized');
 
diff --git a/tools/winscope/src/parsers/perfetto/utils.ts b/tools/winscope/src/parsers/perfetto/utils.ts
index a54c80d4f..f5a77e334 100644
--- a/tools/winscope/src/parsers/perfetto/utils.ts
+++ b/tools/winscope/src/parsers/perfetto/utils.ts
@@ -14,22 +14,44 @@
  * limitations under the License.
  */
 
-import {assertDefined, assertTrue} from 'common/assert_utils';
+import {
+  assertBigInt,
+  assertBigIntOrUndefined,
+  assertNumberOrUndefined,
+  assertString,
+  assertStringOrUndefined,
+  assertTrue,
+} from 'common/assert_utils';
 import {UserNotifier} from 'common/user_notifier';
 import {MissingVsyncId} from 'messaging/user_warnings';
 import {AbsoluteEntryIndex, EntriesRange} from 'trace/trace';
 import {TraceProcessor} from 'trace_processor/trace_processor';
 import {FakeProto, FakeProtoBuilder} from './fake_proto_builder';
 
-export class Utils {
-  static async queryEntry(
-    traceProcessor: TraceProcessor,
-    tableName: string,
-    entryIndexToRowIdMap: number[],
-    entryIndex: AbsoluteEntryIndex,
-  ): Promise<FakeProto> {
-    const rowId = entryIndexToRowIdMap[entryIndex];
-    const sql = `
+export async function queryArgs(
+  traceProcessor: TraceProcessor,
+  argSetId: number,
+): Promise<FakeProto> {
+  const sql = `
+      SELECT
+          key,
+          value_type,
+          int_value,
+          string_value,
+          real_value
+      FROM args WHERE args.arg_set_id = ${argSetId};
+    `;
+  return getAndConvertArgsToProto(traceProcessor, sql);
+}
+
+export async function queryEntry(
+  traceProcessor: TraceProcessor,
+  tableName: string,
+  entryIndexToRowIdMap: number[],
+  entryIndex: AbsoluteEntryIndex,
+): Promise<FakeProto> {
+  const rowId = entryIndexToRowIdMap[entryIndex];
+  const sql = `
       SELECT
           tbl.id,
           args.key,
@@ -41,103 +63,109 @@ export class Utils {
       INNER JOIN args ON tbl.arg_set_id = args.arg_set_id
       WHERE tbl.id = ${rowId};
     `;
-    const result = await traceProcessor.queryAllRows(sql);
+  return getAndConvertArgsToProto(traceProcessor, sql);
+}
 
-    const builder = new FakeProtoBuilder();
-    for (const it = result.iter({}); it.valid(); it.next()) {
-      builder.addArg(
-        it.get('key') as string,
-        it.get('value_type') as string,
-        it.get('int_value') as bigint | undefined,
-        it.get('real_value') as number | undefined,
-        it.get('string_value') as string | undefined,
-      );
-    }
-    return builder.build();
+async function getAndConvertArgsToProto(
+  traceProcessor: TraceProcessor,
+  sql: string,
+): Promise<FakeProto> {
+  const result = await traceProcessor.query(sql);
+  const builder = new FakeProtoBuilder();
+  for (const it = result.iter({}); it.valid(); it.next()) {
+    builder.addArg(
+      assertString(it.get('key')),
+      assertString(it.get('value_type')),
+      assertBigIntOrUndefined(it.get('int_value')),
+      assertNumberOrUndefined(it.get('real_value')),
+      assertStringOrUndefined(it.get('string_value')),
+    );
   }
+  return builder.build();
+}
 
-  static async queryVsyncId(
-    traceProcessor: TraceProcessor,
+export async function queryVsyncId(
+  traceProcessor: TraceProcessor,
+  tableName: string,
+  entryIndexToRowIdMap: number[],
+  entriesRange: EntriesRange,
+  createVsyncIdQuery: (
     tableName: string,
-    entryIndexToRowIdMap: number[],
-    entriesRange: EntriesRange,
-    createVsyncIdQuery: (
-      tableName: string,
-      minRowId: number,
-      maxRowId: number,
-    ) => string = Utils.createDefaultVsyncIdQuery,
-  ): Promise<Array<bigint>> {
-    let minRowId = Number.MAX_VALUE;
-    let maxRowId = Number.MIN_VALUE;
-    for (
-      let entryIndex = entriesRange.start;
-      entryIndex < entriesRange.end;
-      ++entryIndex
-    ) {
-      const rowId = entryIndexToRowIdMap[entryIndex];
-      minRowId = Math.min(minRowId, rowId);
-      maxRowId = Math.max(maxRowId, rowId);
-    }
-    const numEntries = maxRowId - minRowId + 1;
+    minRowId: number,
+    maxRowId: number,
+  ) => string = createDefaultVsyncIdQuery,
+): Promise<Array<bigint>> {
+  let minRowId = Number.MAX_VALUE;
+  let maxRowId = Number.MIN_VALUE;
+  for (
+    let entryIndex = entriesRange.start;
+    entryIndex < entriesRange.end;
+    ++entryIndex
+  ) {
+    const rowId = entryIndexToRowIdMap[entryIndex];
+    minRowId = Math.min(minRowId, rowId);
+    maxRowId = Math.max(maxRowId, rowId);
+  }
+  const numEntries = maxRowId - minRowId + 1;
 
-    const sql = createVsyncIdQuery(tableName, minRowId, maxRowId);
-    const result = await traceProcessor.queryAllRows(sql);
+  const sql = createVsyncIdQuery(tableName, minRowId, maxRowId);
+  const result = await traceProcessor.query(sql);
 
-    const vsyncIdOrderedByRow: Array<bigint> = [];
-    let curRowId = BigInt(minRowId);
-    for (const it = result.iter({}); it.valid(); it.next()) {
-      const id = assertDefined(it.get('id') as bigint | undefined);
-      while (curRowId < id) {
-        // Handle missing table rows that don't have a vsync_id
-        vsyncIdOrderedByRow.push(-1n);
-        curRowId++;
-      }
-      assertTrue(
-        curRowId === id,
-        () => 'query for vsyncId contains duplicate rows with the same id',
-      );
-      const value = it.get('int_value') as bigint | undefined;
-      const valueType = it.get('value_type') as string;
-      assertTrue(
-        valueType === 'uint' || valueType === 'int',
-        () => 'expected vsync_id to have integer type',
-      );
-      vsyncIdOrderedByRow.push(value ?? -1n);
-      curRowId++;
-    }
-    while (curRowId <= maxRowId) {
-      // Handle missing table rows at the end of the trace
+  const vsyncIdOrderedByRow: Array<bigint> = [];
+  let curRowId = BigInt(minRowId);
+  for (const it = result.iter({}); it.valid(); it.next()) {
+    const id = assertBigInt(it.get('id'));
+    while (curRowId < id) {
+      // Handle missing table rows that don't have a vsync_id
       vsyncIdOrderedByRow.push(-1n);
       curRowId++;
     }
+    assertTrue(
+      curRowId === id,
+      () => 'query for vsyncId contains duplicate rows with the same id',
+    );
+    const value = assertBigIntOrUndefined(it.get('int_value'));
+    const valueType = assertString(it.get('value_type'));
+    assertTrue(
+      valueType === 'uint' || valueType === 'int',
+      () => 'expected vsync_id to have integer type',
+    );
+    vsyncIdOrderedByRow.push(value ?? -1n);
+    curRowId++;
+  }
+  while (curRowId <= maxRowId) {
+    // Handle missing table rows at the end of the trace
+    vsyncIdOrderedByRow.push(-1n);
+    curRowId++;
+  }
 
-    if (vsyncIdOrderedByRow.length !== numEntries) {
-      UserNotifier.add(new MissingVsyncId(tableName));
-    }
-
-    const vsyncIdOrderedByEntry: Array<bigint> = [];
-    for (
-      let entryIndex = entriesRange.start;
-      entryIndex < entriesRange.end;
-      ++entryIndex
-    ) {
-      const rowId = entryIndexToRowIdMap[entryIndex];
-      const vsyncId = vsyncIdOrderedByRow[rowId - minRowId];
-      vsyncIdOrderedByEntry.push(vsyncId);
-    }
+  if (vsyncIdOrderedByRow.length !== numEntries) {
+    UserNotifier.add(new MissingVsyncId(tableName));
+  }
 
-    return vsyncIdOrderedByEntry;
+  const vsyncIdOrderedByEntry: Array<bigint> = [];
+  for (
+    let entryIndex = entriesRange.start;
+    entryIndex < entriesRange.end;
+    ++entryIndex
+  ) {
+    const rowId = entryIndexToRowIdMap[entryIndex];
+    const vsyncId = vsyncIdOrderedByRow[rowId - minRowId];
+    vsyncIdOrderedByEntry.push(vsyncId);
   }
 
-  // Creates a sql query for the vsync_id of the table rows that have
-  // an id in the range [minRowId, maxRowId]. The query may be created in a way
-  // where rows that don't have a vsync_id can be omitted from the query result.
-  private static createDefaultVsyncIdQuery(
-    tableName: string,
-    minRowId: number,
-    maxRowId: number,
-  ): string {
-    return `
+  return vsyncIdOrderedByEntry;
+}
+
+// Creates a sql query for the vsync_id of the table rows that have
+// an id in the range [minRowId, maxRowId]. The query may be created in a way
+// where rows that don't have a vsync_id can be omitted from the query result.
+function createDefaultVsyncIdQuery(
+  tableName: string,
+  minRowId: number,
+  maxRowId: number,
+): string {
+  return `
       SELECT
         tbl.id AS id,
         args.key,
@@ -150,5 +178,31 @@ export class Utils {
         AND args.key = 'vsync_id'
         ORDER BY tbl.id;
     `;
+}
+
+export async function getDistinctValues(
+  traceProcessor: TraceProcessor,
+  tableName: string,
+  columns: string[],
+): Promise<string[]> {
+  const uniqueValueCol = 'unique_value';
+  const sql =
+    columns
+      .map((col) => {
+        return `SELECT DISTINCT ${col} AS ${uniqueValueCol} FROM ${tableName}`;
+      })
+      .join(' UNION ') + ` ORDER BY ${uniqueValueCol}`;
+
+  const rows = await traceProcessor.query(sql);
+  if (rows.numRows() === 0) {
+    return [];
+  }
+
+  const options: string[] = [];
+  for (const it = rows.iter({}); it.valid(); it.next()) {
+    const val = it.get(uniqueValueCol);
+    const option = val !== null && val !== undefined ? val.toString() : 'N/A';
+    options.push(option);
   }
+  return options;
 }
diff --git a/tools/winscope/src/parsers/property_tree_builder_from_proto.ts b/tools/winscope/src/parsers/property_tree_builder_from_proto.ts
new file mode 100644
index 000000000..54b64a629
--- /dev/null
+++ b/tools/winscope/src/parsers/property_tree_builder_from_proto.ts
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2024 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
+import {PropertyTreeNodeFactory} from 'trace/tree_node/property_tree_node_factory';
+import {AbstractPropertyTreeBuilder} from './abstract_property_tree_builder';
+
+export class PropertyTreeBuilderFromProto extends AbstractPropertyTreeBuilder<object> {
+  private denylistProperties: string[] = [];
+
+  setDenyList(value: string[]): this {
+    this.denylistProperties = value;
+    return this;
+  }
+
+  protected override buildPropertiesTree(rootNodeId: string): PropertyTreeNode {
+    const factory = new PropertyTreeNodeFactory(this.denylistProperties);
+    return factory.makeProtoProperty(rootNodeId, '', this.data);
+  }
+}
diff --git a/tools/winscope/src/trace/tree_node/property_tree_builder_from_proto_test.ts b/tools/winscope/src/parsers/property_tree_builder_from_proto_test.ts
similarity index 100%
rename from tools/winscope/src/trace/tree_node/property_tree_builder_from_proto_test.ts
rename to tools/winscope/src/parsers/property_tree_builder_from_proto_test.ts
diff --git a/tools/winscope/src/parsers/property_tree_builder_from_query_row.ts b/tools/winscope/src/parsers/property_tree_builder_from_query_row.ts
new file mode 100644
index 000000000..6bcfe4a25
--- /dev/null
+++ b/tools/winscope/src/parsers/property_tree_builder_from_query_row.ts
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import {assertDefined} from 'common/assert_utils';
+import {convertSnakeToCamelCase} from 'common/string_utils';
+import {
+  PropertySource,
+  PropertyTreeNode,
+} from 'trace/tree_node/property_tree_node';
+import {PropertyTreeNodeFactory} from 'trace/tree_node/property_tree_node_factory';
+import {RowIteratorBase} from 'trace_processor/query_result';
+import {AbstractPropertyTreeBuilder} from './abstract_property_tree_builder';
+
+export class PropertyTreeBuilderFromQueryRow extends AbstractPropertyTreeBuilder<RowIteratorBase> {
+  private columns: string[] | undefined;
+
+  setColumns(value: string[]): this {
+    this.columns = value;
+    return this;
+  }
+
+  protected override buildPropertiesTree(rootNodeId: string): PropertyTreeNode {
+    if (this.columns === undefined) {
+      throw new Error('columns not set');
+    }
+    const factory = new PropertyTreeNodeFactory();
+
+    const rootNode = factory.makePropertyRoot(
+      rootNodeId,
+      assertDefined(this.rootName),
+      PropertySource.TP,
+      undefined,
+    );
+
+    for (const col of this.columns) {
+      const val = this.data?.get(col) ?? undefined;
+      if (val !== undefined) {
+        const colCamelCase = convertSnakeToCamelCase(col);
+        const node = factory.makeTpProperty(rootNodeId, colCamelCase, val);
+        rootNode.addOrReplaceChild(node);
+      }
+    }
+
+    return rootNode;
+  }
+}
diff --git a/tools/winscope/src/parsers/property_tree_builder_from_query_row_test.ts b/tools/winscope/src/parsers/property_tree_builder_from_query_row_test.ts
new file mode 100644
index 000000000..a345f6a40
--- /dev/null
+++ b/tools/winscope/src/parsers/property_tree_builder_from_query_row_test.ts
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
+import {PropertySource} from 'trace/tree_node/property_tree_node';
+import {RowIteratorBase} from 'trace_processor/query_result';
+import {PropertyTreeBuilderFromQueryRow} from './property_tree_builder_from_query_row';
+
+describe('PropertyTreeBuilderFromQueryRow', () => {
+  const columns = ['test_prop', 'other_prop'];
+  let builder: PropertyTreeBuilderFromQueryRow;
+
+  beforeEach(() => {
+    builder = new PropertyTreeBuilderFromQueryRow()
+      .setRootId(1)
+      .setRootName('rootName');
+  });
+
+  it('throws error if columns not set', () => {
+    expect(builder.setData(getSpyRow()).build).toThrowError();
+  });
+
+  it('converts column name from snake to camel case', () => {
+    const spyRow = getSpyRow();
+    spyRow.get.withArgs(columns[0]).and.returnValue(1);
+    spyRow.get.withArgs(columns[1]).and.returnValue('test_value');
+
+    const expectedRoot = new PropertyTreeBuilder()
+      .setRootId('1')
+      .setName('rootName')
+      .setIsRoot(true)
+      .setSource(PropertySource.TP)
+      .setChildren([
+        {name: 'testProp', value: 1},
+        {name: 'otherProp', value: 'test_value'},
+      ])
+      .build();
+
+    const tree = builder.setColumns(columns).setData(spyRow).build();
+    expect(tree).toEqual(expectedRoot);
+  });
+
+  function getSpyRow() {
+    return jasmine.createSpyObj<RowIteratorBase>('row', ['get']);
+  }
+});
diff --git a/tools/winscope/src/parsers/protolog/legacy/legacy_to_perfetto_configs.ts b/tools/winscope/src/parsers/protolog/legacy/legacy_to_perfetto_configs.ts
new file mode 100644
index 000000000..99f2510b9
--- /dev/null
+++ b/tools/winscope/src/parsers/protolog/legacy/legacy_to_perfetto_configs.ts
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import Long from 'long';
+import {perfetto} from 'protos/perfetto/trace/static';
+import configJson32 from '../../../../configs/services.core.protolog32.json'; // eslint-disable-line no-restricted-imports
+import configJson64 from '../../../../configs/services.core.protolog64.json'; // eslint-disable-line no-restricted-imports
+
+interface LegacyConfig {
+  groups: {[key: string]: {tag: string}};
+  messages: {
+    [key: string]: {
+      message: string;
+      level: string;
+      group: string;
+      at: string;
+    };
+  };
+}
+
+function makeProtologViewerConfig(
+  configJson: LegacyConfig,
+): perfetto.protos.ProtoLogViewerConfig {
+  const groupNameToId = new Map<string, number>();
+
+  const groups: perfetto.protos.ProtoLogViewerConfig.Group[] = Object.entries(
+    configJson.groups,
+  ).map(([name, {tag}], index) => {
+    const group = perfetto.protos.ProtoLogViewerConfig.Group.fromObject({
+      id: index + 1,
+      name,
+      tag,
+    });
+    groupNameToId.set(group.name, group.id);
+    return group;
+  });
+
+  const messages: perfetto.protos.ProtoLogViewerConfig.MessageData[] =
+    Object.entries(configJson.messages).map(
+      ([id, {message, level, group, at}]) => {
+        let protologLevel: perfetto.protos.ProtoLogLevel;
+        switch (level) {
+          case 'DEBUG':
+            protologLevel = perfetto.protos.ProtoLogLevel.PROTOLOG_LEVEL_DEBUG;
+            break;
+          case 'VERBOSE':
+            protologLevel =
+              perfetto.protos.ProtoLogLevel.PROTOLOG_LEVEL_VERBOSE;
+            break;
+          case 'INFO':
+            protologLevel = perfetto.protos.ProtoLogLevel.PROTOLOG_LEVEL_INFO;
+            break;
+          case 'WARN':
+            protologLevel = perfetto.protos.ProtoLogLevel.PROTOLOG_LEVEL_WARN;
+            break;
+          case 'ERROR':
+            protologLevel = perfetto.protos.ProtoLogLevel.PROTOLOG_LEVEL_ERROR;
+            break;
+          case 'WTF':
+            protologLevel = perfetto.protos.ProtoLogLevel.PROTOLOG_LEVEL_WTF;
+            break;
+          default:
+            protologLevel =
+              perfetto.protos.ProtoLogLevel.PROTOLOG_LEVEL_UNDEFINED;
+        }
+        return perfetto.protos.ProtoLogViewerConfig.MessageData.fromObject({
+          messageId: Long.fromString(id),
+          message,
+          level: protologLevel,
+          groupId: groupNameToId.get(group),
+          location: at,
+        });
+      },
+    );
+  return perfetto.protos.ProtoLogViewerConfig.fromObject({
+    messages,
+    groups,
+  });
+}
+
+export const CONFIG_32 = makeProtologViewerConfig(configJson32);
+export const CONFIG_64 = makeProtologViewerConfig(configJson64);
diff --git a/tools/winscope/src/parsers/protolog/legacy/parser_protolog.ts b/tools/winscope/src/parsers/protolog/legacy/parser_protolog.ts
index fe35b6208..4de7f8267 100644
--- a/tools/winscope/src/parsers/protolog/legacy/parser_protolog.ts
+++ b/tools/winscope/src/parsers/protolog/legacy/parser_protolog.ts
@@ -15,20 +15,25 @@
  */
 
 import {assertDefined} from 'common/assert_utils';
+import {utf8Encode} from 'common/string_utils';
 import {Timestamp} from 'common/time/time';
+import Long from 'long';
 import {AbstractParser} from 'parsers/legacy/abstract_parser';
-import {LogMessage} from 'parsers/protolog/log_message';
-import {ParserProtologUtils} from 'parsers/protolog/parser_protolog_utils';
+import {perfetto} from 'protos/perfetto/trace/static';
 import root from 'protos/protolog/udc/json';
 import {com} from 'protos/protolog/udc/static';
 import {TraceType} from 'trace/trace_type';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 import configJson32 from '../../../../configs/services.core.protolog32.json'; // eslint-disable-line no-restricted-imports
 import configJson64 from '../../../../configs/services.core.protolog64.json'; // eslint-disable-line no-restricted-imports
+import {CONFIG_32, CONFIG_64} from './legacy_to_perfetto_configs';
 
 type ProtoLogMessage = com.android.internal.protolog.IProtoLogMessage;
 
-class ParserProtoLog extends AbstractParser<PropertyTreeNode, ProtoLogMessage> {
+export class ParserProtoLog extends AbstractParser<
+  PropertyTreeNode,
+  ProtoLogMessage
+> {
   private static readonly ProtoLogFileProto = root.lookupType(
     'com.android.internal.protolog.ProtoLogFileProto',
   );
@@ -61,15 +66,15 @@ class ParserProtoLog extends AbstractParser<PropertyTreeNode, ProtoLogMessage> {
       buffer,
     ) as com.android.internal.protolog.IProtoLogFileProto;
 
-    if (fileProto.version === ParserProtoLog.PROTOLOG_32_BIT_VERSION) {
+    if (this.is32BitVersion(fileProto.log?.at(0))) {
       if (configJson32.version !== ParserProtoLog.PROTOLOG_32_BIT_VERSION) {
-        const message = `Unsupported ProtoLog JSON config version ${configJson32.version} expected ${ParserProtoLog.PROTOLOG_32_BIT_VERSION}`;
+        const message = `Unsupported ProtoLog JSON config version ${configJson32.version}. Expected ${ParserProtoLog.PROTOLOG_32_BIT_VERSION}`;
         console.log(message);
         throw new TypeError(message);
       }
-    } else if (fileProto.version === ParserProtoLog.PROTOLOG_64_BIT_VERSION) {
+    } else if (this.is64BitVersion(fileProto.log?.at(0))) {
       if (configJson64.version !== ParserProtoLog.PROTOLOG_64_BIT_VERSION) {
-        const message = `Unsupported ProtoLog JSON config version ${configJson64.version} expected ${ParserProtoLog.PROTOLOG_64_BIT_VERSION}`;
+        const message = `Unsupported ProtoLog JSON config version ${configJson64.version}. Expected ${ParserProtoLog.PROTOLOG_64_BIT_VERSION}`;
         console.log(message);
         throw new TypeError(message);
       }
@@ -95,185 +100,130 @@ class ParserProtoLog extends AbstractParser<PropertyTreeNode, ProtoLogMessage> {
     return fileProto.log;
   }
 
-  protected override getTimestamp(entry: ProtoLogMessage): Timestamp {
-    return this.timestampConverter.makeTimestampFromBootTimeNs(
-      BigInt(assertDefined(entry.elapsedRealtimeNanos).toString()),
-    );
+  private is32BitVersion(entry: ProtoLogMessage | undefined): boolean {
+    return (entry?.messageHashLegacy ?? 0) > 0;
   }
 
-  override processDecodedEntry(
-    index: number,
-    entry: ProtoLogMessage,
-  ): PropertyTreeNode {
-    let messageHash = assertDefined(entry.messageHash).toString();
-    let config: ProtologConfig | undefined = undefined;
-    if (messageHash !== null && messageHash !== '0') {
-      config = assertDefined(configJson64) as ProtologConfig;
-    } else {
-      messageHash = assertDefined(entry.messageHashLegacy).toString();
-      config = assertDefined(configJson32) as ProtologConfig;
-    }
-
-    const message: ConfigMessage | undefined = config.messages[messageHash];
-    const tag: string | undefined = message
-      ? config.groups[message.group].tag
-      : undefined;
-
-    const logMessage = this.makeLogMessage(entry, message, tag);
-    return ParserProtologUtils.makeMessagePropertiesTree(
-      logMessage,
-      this.timestampConverter,
-      this.getRealToMonotonicTimeOffsetNs() !== undefined,
+  private is64BitVersion(entry: ProtoLogMessage | undefined): boolean {
+    return (
+      entry?.messageHash instanceof Long &&
+      (entry.messageHash.toString() ?? '0') !== '0'
     );
   }
 
-  private makeLogMessage(
-    entry: ProtoLogMessage,
-    message: ConfigMessage | undefined,
-    tag: string | undefined,
-  ): LogMessage {
-    if (!message || !tag) {
-      return this.makeLogMessageWithoutFormat(entry);
-    }
-    try {
-      return this.makeLogMessageWithFormat(entry, message, tag);
-    } catch (error) {
-      if (error instanceof FormatStringMismatchError) {
-        return this.makeLogMessageWithoutFormat(entry);
-      }
-      throw this.createParsingError((error as Error).message);
-    }
+  override canConvertToPerfetto(): boolean {
+    return true;
   }
 
-  private makeLogMessageWithFormat(
-    entry: ProtoLogMessage,
-    message: ConfigMessage,
-    tag: string,
-  ): LogMessage {
-    let text = '';
-
-    const strParams: string[] = assertDefined(entry.strParams);
-    let strParamsIdx = 0;
-    const sint64Params: Array<bigint> = assertDefined(entry.sint64Params).map(
-      (param) => BigInt(param.toString()),
-    );
-    let sint64ParamsIdx = 0;
-    const doubleParams: number[] = assertDefined(entry.doubleParams);
-    let doubleParamsIdx = 0;
-    const booleanParams: boolean[] = assertDefined(entry.booleanParams);
-    let booleanParamsIdx = 0;
+  override convertToPerfettoPackets(
+    sequenceId: number,
+    trustedUid = 1,
+    trustedPid = 1,
+  ): perfetto.protos.TracePacket[] {
+    const packets = [];
+    const firstPacket = this.createPacket(sequenceId, trustedUid, trustedPid);
+    firstPacket.sequenceFlags =
+      perfetto.protos.TracePacket.SequenceFlags.SEQ_INCREMENTAL_STATE_CLEARED;
+    packets.push(firstPacket);
+    packets.push(this.makeViewerConfigPacket(sequenceId, trustedUid));
+
+    const stringToIid = new Map<string, number>();
+    let stringIid = 1;
+
+    for (const entry of this.decodedEntries) {
+      const packet = this.createPacket(sequenceId, trustedUid, trustedPid);
+      packet.timestamp = assertDefined(entry.elapsedRealtimeNanos);
+      packet.timestampClockId =
+        perfetto.protos.ClockSnapshot.Clock.BuiltinClocks.BOOTTIME;
+
+      let messageId: Long;
+      if (this.is64BitVersion(entry)) {
+        messageId = assertDefined(entry.messageHash);
+      } else {
+        messageId = Long.fromNumber(assertDefined(entry.messageHashLegacy));
+      }
 
-    const messageFormat = message.message;
-    for (let i = 0; i < messageFormat.length; ) {
-      if (messageFormat[i] === '%') {
-        if (i + 1 >= messageFormat.length) {
-          // Should never happen - protologtool checks for that
-          throw this.createParsingError('invalid format string');
-        }
-        switch (messageFormat[i + 1]) {
-          case '%':
-            text += '%';
-            break;
-          case 'd':
-            text += this.getParam(sint64Params, sint64ParamsIdx++).toString(10);
-            break;
-          case 'o':
-            text += this.getParam(sint64Params, sint64ParamsIdx++).toString(8);
-            break;
-          case 'x':
-            text += this.getParam(sint64Params, sint64ParamsIdx++).toString(16);
-            break;
-          case 'f':
-            text += this.getParam(doubleParams, doubleParamsIdx++).toFixed(6);
-            break;
-          case 'e':
-            text += this.getParam(
-              doubleParams,
-              doubleParamsIdx++,
-            ).toExponential();
-            break;
-          case 'g':
-            text += this.getParam(doubleParams, doubleParamsIdx++).toString();
-            break;
-          case 's':
-            text += this.getParam(strParams, strParamsIdx++);
-            break;
-          case 'b':
-            text += this.getParam(booleanParams, booleanParamsIdx++).toString();
-            break;
-          default:
-            // Should never happen - protologtool checks for that
-            throw this.createParsingError(
-              'invalid format string conversion: ' + messageFormat[i + 1],
-            );
+      const strParamIids: number[] = [];
+
+      entry.strParams?.forEach((param) => {
+        const iid = stringToIid.get(param);
+        if (iid !== undefined) {
+          strParamIids.push(iid);
+        } else {
+          stringToIid.set(param, stringIid);
+          const packet = this.createPacket(sequenceId, trustedUid, trustedPid);
+          this.updateInternedDataPacket(packet, param, stringIid);
+          packets.push(packet);
+          strParamIids.push(stringIid);
+          stringIid++;
         }
-        i += 2;
-      } else {
-        text += messageFormat[i];
-        i += 1;
+      });
+
+      if (strParamIids.length > 0) {
+        packet.sequenceFlags =
+          perfetto.protos.TracePacket.SequenceFlags.SEQ_NEEDS_INCREMENTAL_STATE;
       }
+
+      packet.protologMessage = perfetto.protos.ProtoLogMessage.create({
+        messageId,
+        strParamIids,
+        sint64Params: entry.sint64Params,
+        doubleParams: entry.doubleParams,
+        booleanParams: entry.booleanParams?.map((param) => {
+          return param ? 1 : 0;
+        }),
+      });
+      packets.push(packet);
     }
 
-    return {
-      text,
-      tag,
-      level: message.level,
-      at: message.at,
-      timestamp: BigInt(assertDefined(entry.elapsedRealtimeNanos).toString()),
-    };
+    return packets;
   }
 
-  private getParam<T>(arr: T[], idx: number): T {
-    if (arr.length <= idx) {
-      throw this.createParsingError('no param for format string conversion');
-    }
-    return arr[idx];
+  protected override getTimestamp(entry: ProtoLogMessage): Timestamp {
+    return this.timestampConverter.makeTimestampFromBootTimeNs(
+      BigInt(assertDefined(entry.elapsedRealtimeNanos).toString()),
+    );
   }
 
-  private makeLogMessageWithoutFormat(entry: ProtoLogMessage): LogMessage {
-    const text =
-      assertDefined(entry.messageHash).toString() +
-      ' - [' +
-      assertDefined(entry.strParams).toString() +
-      '] [' +
-      assertDefined(entry.sint64Params).toString() +
-      '] [' +
-      assertDefined(entry.doubleParams).toString() +
-      '] [' +
-      assertDefined(entry.booleanParams).toString() +
-      ']';
-
-    return {
-      text,
-      tag: 'INVALID',
-      level: 'invalid',
-      at: '',
-      timestamp: BigInt(assertDefined(entry.elapsedRealtimeNanos).toString()),
-    };
+  private makeViewerConfigPacket(
+    sequenceId: number,
+    trustedUid: number,
+  ): perfetto.protos.TracePacket {
+    const packet = this.createPacket(sequenceId, trustedUid, undefined);
+    if (this.is64BitVersion(this.decodedEntries[0])) {
+      packet.protologViewerConfig = CONFIG_64;
+    } else {
+      packet.protologViewerConfig = CONFIG_32;
+    }
+    return packet;
   }
 
-  private createParsingError(msg: string) {
-    return new Error(`Protolog parsing error: ${msg}`);
+  private updateInternedDataPacket(
+    packet: perfetto.protos.TracePacket,
+    str: string,
+    iid: number,
+  ): perfetto.protos.TracePacket {
+    const internedString = perfetto.protos.InternedString.fromObject({
+      iid: Long.fromNumber(iid),
+      str: utf8Encode(str),
+    });
+    packet.internedData = perfetto.protos.InternedData.fromObject({
+      protologStringArgs: [internedString],
+    });
+    return packet;
   }
-}
 
-class FormatStringMismatchError extends Error {
-  constructor(message: string) {
-    super(message);
+  private createPacket(
+    sequenceId: number,
+    trustedUid: number | undefined,
+    trustedPid: number | undefined,
+  ): perfetto.protos.TracePacket {
+    const packet = perfetto.protos.TracePacket.create();
+    packet.trustedPacketSequenceId = sequenceId;
+    packet.trustedUid = trustedUid;
+    if (trustedPid) {
+      packet.trustedPid = trustedPid;
+    }
+    return packet;
   }
 }
-
-interface ProtologConfig {
-  version: string;
-  messages: {[key: string]: ConfigMessage};
-  groups: {[key: string]: {tag: string}};
-}
-
-interface ConfigMessage {
-  message: string;
-  level: string;
-  group: string;
-  at: string;
-}
-
-export {ParserProtoLog};
diff --git a/tools/winscope/src/parsers/protolog/legacy/parser_protolog_test.ts b/tools/winscope/src/parsers/protolog/legacy/parser_protolog_test.ts
index 92fced40e..52b4bf3d3 100644
--- a/tools/winscope/src/parsers/protolog/legacy/parser_protolog_test.ts
+++ b/tools/winscope/src/parsers/protolog/legacy/parser_protolog_test.ts
@@ -15,159 +15,379 @@
  */
 
 import {assertDefined} from 'common/assert_utils';
+import {utf8Encode} from 'common/string_utils';
 import {
   TimestampConverterUtils,
   timestampEqualityTester,
 } from 'common/time/test_utils';
 import {Timestamp} from 'common/time/time';
-import {UnitTestUtils} from 'test/unit/utils';
+import Long from 'long';
+import {perfetto} from 'protos/perfetto/trace/static';
+import {LegacyParserProvider} from 'test/unit/fixture_utils';
 import {CoarseVersion} from 'trace/coarse_version';
 import {Parser} from 'trace/parser';
 import {TraceType} from 'trace/trace_type';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
+import {CONFIG_32, CONFIG_64} from './legacy_to_perfetto_configs';
+
+interface ExpectedInternedData {
+  packetIndex: number;
+  str: string;
+  iid: number;
+}
+
+interface ExpectedMessagePacket {
+  packetIndex: number;
+  sequenceFlags: perfetto.protos.TracePacket.SequenceFlags;
+  timestamp: Long;
+  messageId: Long;
+  strParamIids: number[];
+  sint64Params: Long[];
+  doubleParams: number[];
+  booleanParams: number[];
+}
 
 interface ExpectedMessage {
-  'message': string;
-  'ts': string;
-  'at': string;
-  'level': string;
-  'tag': string;
+  message: string;
+  ts: string;
+  at: string;
+  level: string;
+  tag: string;
 }
 
-const genProtoLogTest =
-  (
-    traceFile: string,
-    timestampCount: number,
-    first3ExpectedRealTimestamps: Timestamp[],
-    expectedFirstMessage: ExpectedMessage,
-  ) =>
-  () => {
-    let parser: Parser<PropertyTreeNode>;
-
-    beforeAll(async () => {
-      jasmine.addCustomEqualityTester(timestampEqualityTester);
-      parser = (await UnitTestUtils.getParser(
-        traceFile,
-      )) as Parser<PropertyTreeNode>;
-    });
+abstract class ParserProtologTest {
+  abstract readonly traceFile: string;
+  abstract readonly timestampCount: number;
+  abstract readonly first3ExpectedRealTimestamps: Timestamp[];
+  abstract readonly expectedConfig: perfetto.protos.IProtoLogViewerConfig;
+  abstract readonly internedData1: ExpectedInternedData;
+  abstract readonly internedData2: ExpectedInternedData;
+  abstract readonly messagePacketWithInternedStrings: ExpectedMessagePacket;
+  abstract readonly messagePacketNoInternedStrings: ExpectedMessagePacket;
+  abstract readonly expectedFirstMessage: ExpectedMessage;
 
-    it('has expected trace type', () => {
-      expect(parser.getTraceType()).toEqual(TraceType.PROTO_LOG);
-    });
+  execute() {
+    describe('ParserProtologTest', () => {
+      const [sequenceId, trustedUid, trustedPid] = [10, 3, 5];
+      let parser: Parser<PropertyTreeNode>;
 
-    it('has expected coarse version', () => {
-      expect(parser.getCoarseVersion()).toEqual(CoarseVersion.LEGACY);
-    });
+      beforeAll(async () => {
+        jasmine.addCustomEqualityTester(timestampEqualityTester);
+        parser = await new LegacyParserProvider()
+          .addFilename(this.traceFile)
+          .getParser<PropertyTreeNode>();
+      });
 
-    it('has expected length', () => {
-      expect(parser.getLengthEntries()).toEqual(timestampCount);
-    });
+      it('has expected trace type', () => {
+        expect(parser.getTraceType()).toEqual(TraceType.PROTO_LOG);
+      });
 
-    it('provides timestamps', () => {
-      const timestamps = assertDefined(parser.getTimestamps());
-      expect(timestamps.length).toEqual(timestampCount);
+      it('has expected coarse version', () => {
+        expect(parser.getCoarseVersion()).toEqual(CoarseVersion.LEGACY);
+      });
 
-      expect(timestamps.slice(0, 3)).toEqual(first3ExpectedRealTimestamps);
-    });
+      it('has expected length', () => {
+        expect(parser.getLengthEntries()).toEqual(this.timestampCount);
+      });
 
-    it('reconstructs human-readable log message', async () => {
-      const message = await parser.getEntry(0);
-
-      expect(
-        assertDefined(message.getChildByName('text')).formattedValue(),
-      ).toEqual(expectedFirstMessage['message']);
-      expect(
-        assertDefined(message.getChildByName('timestamp')).formattedValue(),
-      ).toEqual(expectedFirstMessage['ts']);
-      expect(
-        assertDefined(message.getChildByName('tag')).formattedValue(),
-      ).toEqual(expectedFirstMessage['tag']);
-      expect(
-        assertDefined(message.getChildByName('level')).formattedValue(),
-      ).toEqual(expectedFirstMessage['level']);
-      expect(
-        assertDefined(message.getChildByName('at')).formattedValue(),
-      ).toEqual(expectedFirstMessage['at']);
-    });
+      it('provides timestamps', () => {
+        const timestamps = assertDefined(parser.getTimestamps());
+        expect(timestamps.length).toEqual(this.timestampCount);
+
+        expect(timestamps.slice(0, 3)).toEqual(
+          this.first3ExpectedRealTimestamps,
+        );
+      });
+
+      it('does not provide entry', () => {
+        expect(parser.getEntry).toThrow();
+      });
 
-    it('reconstructs human-readable log message (REAL time)', async () => {
-      const message = await parser.getEntry(0);
-
-      expect(
-        assertDefined(message.getChildByName('text')).formattedValue(),
-      ).toEqual(expectedFirstMessage['message']);
-      expect(
-        assertDefined(message.getChildByName('timestamp')).formattedValue(),
-      ).toEqual(expectedFirstMessage['ts']);
-      expect(
-        assertDefined(message.getChildByName('tag')).formattedValue(),
-      ).toEqual(expectedFirstMessage['tag']);
-      expect(
-        assertDefined(message.getChildByName('level')).formattedValue(),
-      ).toEqual(expectedFirstMessage['level']);
-      expect(
-        assertDefined(message.getChildByName('at')).formattedValue(),
-      ).toEqual(expectedFirstMessage['at']);
+      it('converts to valid perfetto packets', async () => {
+        const packets = parser.convertToPerfettoPackets!(
+          sequenceId,
+          trustedUid,
+          trustedPid,
+        );
+        expect(
+          packets.filter((packet) => packet.protologMessage).length,
+        ).toEqual(this.timestampCount);
+
+        const firstPacket = packets[0];
+        expect(firstPacket.trustedPacketSequenceId).toEqual(sequenceId);
+        expect(firstPacket.sequenceFlags).toEqual(
+          perfetto.protos.TracePacket.SequenceFlags
+            .SEQ_INCREMENTAL_STATE_CLEARED,
+        );
+        expect(firstPacket.trustedUid).toEqual(trustedUid);
+        expect(firstPacket.trustedPid).toEqual(trustedPid);
+        expect(firstPacket.internedData).toBeNull();
+        expect(firstPacket.protologViewerConfig).toBeNull();
+        expect(firstPacket.protologMessage).toBeNull();
+
+        const viewerConfigPacket = packets[1];
+        expect(viewerConfigPacket.trustedPacketSequenceId).toEqual(sequenceId);
+        expect(viewerConfigPacket.sequenceFlags).toEqual(
+          perfetto.protos.TracePacket.SequenceFlags.SEQ_UNSPECIFIED,
+        );
+        expect(viewerConfigPacket.protologViewerConfig).toEqual(
+          this.expectedConfig,
+        );
+        expect(viewerConfigPacket.trustedUid).toEqual(trustedUid);
+        expect(viewerConfigPacket.trustedPid).toEqual(0);
+        expect(viewerConfigPacket.internedData).toBeNull();
+        expect(viewerConfigPacket.protologMessage).toBeNull();
+
+        checkInternedDataPacket(packets, this.internedData1);
+        checkInternedDataPacket(packets, this.internedData2);
+
+        checkMessagePacket(packets, this.messagePacketNoInternedStrings);
+        checkMessagePacket(packets, this.messagePacketWithInternedStrings);
+      });
+
+      it('converts to valid perfetto trace', async () => {
+        const perfettoParser = await new LegacyParserProvider()
+          .addFilename(this.traceFile)
+          .setConvertToPerfetto(true)
+          .getParser<PropertyTreeNode>();
+
+        expect(perfettoParser.getTimestamps()?.slice(0, 3)).toEqual(
+          this.first3ExpectedRealTimestamps,
+        );
+
+        const message = await perfettoParser.getEntry(0);
+
+        expect(
+          assertDefined(message.getChildByName('text')).formattedValue(),
+        ).toEqual(this.expectedFirstMessage.message);
+        expect(
+          assertDefined(message.getChildByName('timestamp')).formattedValue(),
+        ).toEqual(this.expectedFirstMessage.ts);
+        expect(
+          assertDefined(message.getChildByName('tag')).formattedValue(),
+        ).toEqual(this.expectedFirstMessage.tag);
+        expect(
+          assertDefined(message.getChildByName('level')).formattedValue(),
+        ).toEqual(this.expectedFirstMessage.level);
+        expect(
+          assertDefined(message.getChildByName('at')).formattedValue(),
+        ).toEqual(this.expectedFirstMessage.at);
+      });
+
+      function checkMessagePacket(
+        packets: perfetto.protos.TracePacket[],
+        expectedMsg: ExpectedMessagePacket,
+      ) {
+        const packet = packets[expectedMsg.packetIndex];
+        expect(packet.trustedPacketSequenceId).toEqual(sequenceId);
+        expect(packet.sequenceFlags).toEqual(expectedMsg.sequenceFlags);
+        expect(packet.trustedUid).toEqual(trustedUid);
+        expect(packet.trustedPid).toEqual(trustedPid);
+        const ts1 = expectedMsg.timestamp;
+        ts1.unsigned = true;
+        expect(packet.timestamp).toEqual(ts1);
+        expect(packet.protologMessage?.messageId).toEqual(
+          expectedMsg.messageId,
+        );
+        expect(packet.protologMessage?.strParamIids).toEqual(
+          expectedMsg.strParamIids,
+        );
+        expect(packet.protologMessage?.booleanParams).toEqual(
+          expectedMsg.booleanParams,
+        );
+        expect(packet.protologMessage?.doubleParams).toEqual(
+          expectedMsg.doubleParams,
+        );
+        expect(packet.protologMessage?.sint64Params).toEqual(
+          expectedMsg.sint64Params,
+        );
+        expect(packet.protologViewerConfig).toBeNull();
+        expect(packet.internedData).toBeNull();
+      }
+
+      function checkInternedDataPacket(
+        packets: perfetto.protos.TracePacket[],
+        expectedData: ExpectedInternedData,
+      ) {
+        const packet = packets[expectedData.packetIndex];
+        expect(packet.trustedPacketSequenceId).toEqual(sequenceId);
+        expect(packet.sequenceFlags).toEqual(
+          perfetto.protos.TracePacket.SequenceFlags.SEQ_UNSPECIFIED,
+        );
+        expect(packet.trustedUid).toEqual(trustedUid);
+        expect(packet.trustedPid).toEqual(trustedPid);
+        expect(packet.internedData?.protologStringArgs).toEqual([
+          perfetto.protos.InternedString.fromObject({
+            iid: Long.fromNumber(expectedData.iid),
+            str: utf8Encode(expectedData.str),
+          }),
+        ]);
+        expect(packet.protologViewerConfig).toBeNull();
+        expect(packet.protologMessage).toBeNull();
+      }
     });
+  }
+}
+
+class ParserProtolog32Test extends ParserProtologTest {
+  override readonly traceFile =
+    'traces/elapsed_and_real_timestamp/ProtoLog32.pb';
+  override readonly timestampCount = 50;
+  override readonly first3ExpectedRealTimestamps = [
+    TimestampConverterUtils.makeRealTimestamp(1655727125377266486n),
+    TimestampConverterUtils.makeRealTimestamp(1655727125377336718n),
+    TimestampConverterUtils.makeRealTimestamp(1655727125377350430n),
+  ];
+  override readonly expectedConfig = CONFIG_32;
+  override readonly internedData1: ExpectedInternedData = {
+    packetIndex: 2,
+    iid: 1,
+    str: 'ITYPE_IME',
   };
+  override readonly internedData2: ExpectedInternedData = {
+    packetIndex: 3,
+    iid: 2,
+    str: 'false',
+  };
+  override readonly messagePacketNoInternedStrings: ExpectedMessagePacket = {
+    packetIndex: 50,
+    sequenceFlags: perfetto.protos.TracePacket.SequenceFlags.SEQ_UNSPECIFIED,
+    timestamp: Long.fromNumber(850755642097),
+    messageId: Long.fromNumber(1984782949),
+    strParamIids: [],
+    sint64Params: [],
+    booleanParams: [],
+    doubleParams: [],
+  };
+  override readonly messagePacketWithInternedStrings: ExpectedMessagePacket = {
+    packetIndex: 4,
+    sequenceFlags:
+      perfetto.protos.TracePacket.SequenceFlags.SEQ_NEEDS_INCREMENTAL_STATE,
+    timestamp: Long.fromNumber(850746266486),
+    messageId: Long.fromNumber(2070726247),
+    strParamIids: [1, 2, 2],
+    sint64Params: [],
+    booleanParams: [],
+    doubleParams: [],
+  };
+  override readonly expectedFirstMessage: ExpectedMessage = {
+    message:
+      'InsetsSource updateVisibility for ITYPE_IME, serverVisible: false clientVisible: false',
+    ts: '2022-06-20, 12:12:05.377',
+    tag: 'WindowManager',
+    level: 'DEBUG',
+    at: 'com/android/server/wm/InsetsSourceProvider.java',
+  };
+}
+
+class ParserProtolog64Test extends ParserProtologTest {
+  override readonly traceFile =
+    'traces/elapsed_and_real_timestamp/ProtoLog64.pb';
+  override readonly timestampCount = 4615;
+  override readonly first3ExpectedRealTimestamps = [
+    TimestampConverterUtils.makeRealTimestamp(1709196806399529939n),
+    TimestampConverterUtils.makeRealTimestamp(1709196806399763866n),
+    TimestampConverterUtils.makeRealTimestamp(1709196806400297151n),
+  ];
+  override readonly expectedConfig = CONFIG_64;
+  override readonly internedData1: ExpectedInternedData = {
+    packetIndex: 5,
+    iid: 1,
+    str: 'ActivityRecord{e361a5d u0 com.google.android.gm/.ConversationListActivityGmail',
+  };
+  override readonly internedData2: ExpectedInternedData = {
+    packetIndex: 6,
+    iid: 2,
+    str: 'null',
+  };
+  override readonly messagePacketNoInternedStrings: ExpectedMessagePacket = {
+    packetIndex: 2,
+    sequenceFlags: perfetto.protos.TracePacket.SequenceFlags.SEQ_UNSPECIFIED,
+    timestamp: Long.fromNumber(1315553529939),
+    messageId: Long.fromString('1665699123574159131'),
+    strParamIids: [],
+    sint64Params: [],
+    booleanParams: [0],
+    doubleParams: [],
+  };
+  override readonly messagePacketWithInternedStrings: ExpectedMessagePacket = {
+    packetIndex: 9,
+    sequenceFlags:
+      perfetto.protos.TracePacket.SequenceFlags.SEQ_NEEDS_INCREMENTAL_STATE,
+    timestamp: Long.fromNumber(1315574594310),
+    messageId: Long.fromString('-6873410057142191118'),
+    strParamIids: [1, 2, 3, 4],
+    sint64Params: [],
+    booleanParams: [],
+    doubleParams: [],
+  };
+  override readonly expectedFirstMessage: ExpectedMessage = {
+    message: 'Starting activity when config will change = false',
+    ts: '2024-02-29, 08:53:26.400',
+    tag: 'WindowManager',
+    level: 'VERBOSE',
+    at: 'com/android/server/wm/ActivityStarter.java',
+  };
+}
+
+class ParserProtologMissingConfigTest extends ParserProtologTest {
+  override readonly traceFile =
+    'traces/elapsed_and_real_timestamp/ProtoLogMissingConfigMessage.pb';
+  override readonly timestampCount = 7295;
+  override readonly first3ExpectedRealTimestamps = [
+    TimestampConverterUtils.makeRealTimestamp(1669053909777144978n),
+    TimestampConverterUtils.makeRealTimestamp(1669053909778011697n),
+    TimestampConverterUtils.makeRealTimestamp(1669053909778800707n),
+  ];
+  override readonly expectedConfig = CONFIG_32;
+  override readonly internedData1: ExpectedInternedData = {
+    packetIndex: 2,
+    iid: 1,
+    str: 'NotificationShade',
+  };
+  override readonly internedData2: ExpectedInternedData = {
+    packetIndex: 4,
+    iid: 2,
+    str: 'Window{f199162 u0 NotificationShade}',
+  };
+  override readonly messagePacketNoInternedStrings: ExpectedMessagePacket = {
+    packetIndex: 92,
+    sequenceFlags: perfetto.protos.TracePacket.SequenceFlags.SEQ_UNSPECIFIED,
+    timestamp: Long.fromNumber(24398203599667),
+    messageId: Long.fromString('1381227466'),
+    strParamIids: [],
+    sint64Params: [Long.fromNumber(2), Long.fromNumber(0)],
+    booleanParams: [],
+    doubleParams: [],
+  };
+  override readonly messagePacketWithInternedStrings: ExpectedMessagePacket = {
+    packetIndex: 3,
+    sequenceFlags:
+      perfetto.protos.TracePacket.SequenceFlags.SEQ_NEEDS_INCREMENTAL_STATE,
+    timestamp: Long.fromNumber(24398190144978),
+    messageId: Long.fromNumber(585096182),
+    strParamIids: [1],
+    sint64Params: [],
+    booleanParams: [1],
+    doubleParams: [],
+  };
+  override readonly expectedFirstMessage: ExpectedMessage = {
+    message: 'SURFACE isColorSpaceAgnostic=true: NotificationShade',
+    ts: '2022-11-21, 18:05:09.777',
+    tag: 'WindowManager',
+    level: 'INFO',
+    at: 'com/android/server/wm/WindowSurfaceController.java',
+  };
+}
+
+describe('32', () => {
+  new ParserProtolog32Test().execute();
+});
+
+describe('64', () => {
+  new ParserProtolog64Test().execute();
+});
 
-describe('ParserProtoLog', () => {
-  describe(
-    '32',
-    genProtoLogTest(
-      'traces/elapsed_and_real_timestamp/ProtoLog32.pb',
-      50,
-      [
-        TimestampConverterUtils.makeRealTimestamp(1655727125377266486n),
-        TimestampConverterUtils.makeRealTimestamp(1655727125377336718n),
-        TimestampConverterUtils.makeRealTimestamp(1655727125377350430n),
-      ],
-      {
-        'message':
-          'InsetsSource updateVisibility for ITYPE_IME, serverVisible: false clientVisible: false',
-        'ts': '2022-06-20, 12:12:05.377',
-        'tag': 'WindowManager',
-        'level': 'DEBUG',
-        'at': 'com/android/server/wm/InsetsSourceProvider.java',
-      },
-    ),
-  );
-  describe(
-    '64',
-    genProtoLogTest(
-      'traces/elapsed_and_real_timestamp/ProtoLog64.pb',
-      4615,
-      [
-        TimestampConverterUtils.makeRealTimestamp(1709196806399529939n),
-        TimestampConverterUtils.makeRealTimestamp(1709196806399763866n),
-        TimestampConverterUtils.makeRealTimestamp(1709196806400297151n),
-      ],
-      {
-        'message': 'Starting activity when config will change = false',
-        'ts': '2024-02-29, 08:53:26.400',
-        'tag': 'WindowManager',
-        'level': 'VERBOSE',
-        'at': 'com/android/server/wm/ActivityStarter.java',
-      },
-    ),
-  );
-  describe(
-    'Missing config message',
-    genProtoLogTest(
-      'traces/elapsed_and_real_timestamp/ProtoLogMissingConfigMessage.pb',
-      7295,
-      [
-        TimestampConverterUtils.makeRealTimestamp(1669053909777144978n),
-        TimestampConverterUtils.makeRealTimestamp(1669053909778011697n),
-        TimestampConverterUtils.makeRealTimestamp(1669053909778800707n),
-      ],
-      {
-        'message': 'SURFACE isColorSpaceAgnostic=true: NotificationShade',
-        'ts': '2022-11-21, 18:05:09.777',
-        'tag': 'WindowManager',
-        'level': 'INFO',
-        'at': 'com/android/server/wm/WindowSurfaceController.java',
-      },
-    ),
-  );
+describe('Missing config', () => {
+  new ParserProtologMissingConfigTest().execute();
 });
diff --git a/tools/winscope/src/parsers/protolog/parser_protolog_utils.ts b/tools/winscope/src/parsers/protolog/parser_protolog_utils.ts
deleted file mode 100644
index d16b35f3c..000000000
--- a/tools/winscope/src/parsers/protolog/parser_protolog_utils.ts
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import {MakeTimestampStrategyType} from 'common/time/time';
-import {ParserTimestampConverter} from 'common/time/timestamp_converter';
-import {SetFormatters} from 'parsers/operations/set_formatters';
-import {TransformToTimestamp} from 'parsers/operations/transform_to_timestamp';
-import {TIMESTAMP_NODE_FORMATTER} from 'trace/tree_node/formatters';
-import {PropertyTreeBuilderFromProto} from 'trace/tree_node/property_tree_builder_from_proto';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
-import {LogMessage} from './log_message';
-
-export class ParserProtologUtils {
-  static makeMessagePropertiesTree(
-    logMessage: LogMessage,
-    timestampConverter: ParserTimestampConverter,
-    isMonotonic: boolean,
-  ): PropertyTreeNode {
-    const tree = new PropertyTreeBuilderFromProto()
-      .setData(logMessage)
-      .setRootId('ProtoLogTrace')
-      .setRootName('entry')
-      .setVisitPrototype(false)
-      .build();
-
-    const customFormatters = new Map([['timestamp', TIMESTAMP_NODE_FORMATTER]]);
-
-    const strategy: MakeTimestampStrategyType = (valueNs: bigint) => {
-      if (isMonotonic) {
-        return timestampConverter.makeTimestampFromMonotonicNs(valueNs);
-      }
-      return timestampConverter.makeTimestampFromBootTimeNs(valueNs);
-    };
-
-    new TransformToTimestamp(['timestamp'], strategy).apply(tree);
-    new SetFormatters(undefined, customFormatters).apply(tree);
-    return tree;
-  }
-}
diff --git a/tools/winscope/src/parsers/protolog/perfetto/parser_protolog.ts b/tools/winscope/src/parsers/protolog/perfetto/parser_protolog.ts
index 2d07355cc..0d31e7a2e 100644
--- a/tools/winscope/src/parsers/protolog/perfetto/parser_protolog.ts
+++ b/tools/winscope/src/parsers/protolog/perfetto/parser_protolog.ts
@@ -14,9 +14,16 @@
  * limitations under the License.
  */
 
+import {
+  assertBigIntOrUndefined,
+  assertStringOrUndefined,
+} from 'common/assert_utils';
+import {MakeTimestampStrategyType} from 'common/time/time';
+import {SetFormatters} from 'parsers/operations/set_formatters';
+import {TransformToTimestamp} from 'parsers/operations/transform_to_timestamp';
 import {AbstractParser} from 'parsers/perfetto/abstract_parser';
+import {PropertyTreeBuilderFromProto} from 'parsers/property_tree_builder_from_proto';
 import {LogMessage} from 'parsers/protolog/log_message';
-import {ParserProtologUtils} from 'parsers/protolog/parser_protolog_utils';
 import {TraceType} from 'trace/trace_type';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 
@@ -28,11 +35,11 @@ class PerfettoLogMessageTableRow {
   timestamp: bigint = 0n;
 
   constructor(
-    timestamp: bigint,
-    tag: string,
-    level: string,
-    message: string,
-    location: string,
+    timestamp: bigint | undefined,
+    tag: string | undefined,
+    level: string | undefined,
+    message: string | undefined,
+    location: string | undefined,
   ) {
     this.timestamp = timestamp ?? this.timestamp;
     this.tag = tag ?? this.tag;
@@ -57,11 +64,7 @@ export class ParserProtolog extends AbstractParser<PropertyTreeNode> {
       timestamp: protologEntry.timestamp,
     };
 
-    return ParserProtologUtils.makeMessagePropertiesTree(
-      logMessage,
-      this.timestampConverter,
-      false,
-    );
+    return this.makeMessagePropertiesTree(logMessage);
   }
 
   protected override getTableName(): string {
@@ -76,7 +79,7 @@ export class ParserProtolog extends AbstractParser<PropertyTreeNode> {
         protolog
       WHERE protolog.id = ${this.entryIndexToRowIdMap[index]};
     `;
-    const result = await this.traceProcessor.queryAllRows(sql);
+    const result = await this.traceProcessor.query(sql);
 
     if (result.numRows() !== 1) {
       throw new Error(
@@ -87,11 +90,27 @@ export class ParserProtolog extends AbstractParser<PropertyTreeNode> {
     const entry = result.iter({});
 
     return new PerfettoLogMessageTableRow(
-      entry.get('ts') as bigint,
-      entry.get('tag') as string,
-      entry.get('level') as string,
-      entry.get('message') as string,
-      entry.get('location') as string,
+      assertBigIntOrUndefined(entry.get('ts')),
+      assertStringOrUndefined(entry.get('tag')),
+      assertStringOrUndefined(entry.get('level')),
+      assertStringOrUndefined(entry.get('message')),
+      assertStringOrUndefined(entry.get('location')),
     );
   }
+
+  private makeMessagePropertiesTree(logMessage: LogMessage): PropertyTreeNode {
+    const tree = new PropertyTreeBuilderFromProto()
+      .setData(logMessage)
+      .setRootId('ProtoLogTrace')
+      .setRootName('entry')
+      .build();
+
+    const strategy: MakeTimestampStrategyType = (valueNs: bigint) => {
+      return this.timestampConverter.makeTimestampFromBootTimeNs(valueNs);
+    };
+
+    new TransformToTimestamp(['timestamp'], strategy).apply(tree);
+    new SetFormatters().apply(tree);
+    return tree;
+  }
 }
diff --git a/tools/winscope/src/parsers/protolog/perfetto/parser_protolog_test.ts b/tools/winscope/src/parsers/protolog/perfetto/parser_protolog_test.ts
index 3260b83f5..87c28d23a 100644
--- a/tools/winscope/src/parsers/protolog/perfetto/parser_protolog_test.ts
+++ b/tools/winscope/src/parsers/protolog/perfetto/parser_protolog_test.ts
@@ -18,17 +18,17 @@ import {
   TimestampConverterUtils,
   timestampEqualityTester,
 } from 'common/time/test_utils';
-import {UnitTestUtils} from 'test/unit/utils';
+import {getPerfettoParser} from 'test/unit/fixture_utils';
 import {Parser} from 'trace/parser';
 import {TraceType} from 'trace/trace_type';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 
-describe('Perfetto ParserProtolog', () => {
+describe('PerfettoParserProtolog', () => {
   let parser: Parser<PropertyTreeNode>;
 
   beforeAll(async () => {
     jasmine.addCustomEqualityTester(timestampEqualityTester);
-    parser = await UnitTestUtils.getPerfettoParser(
+    parser = await getPerfettoParser(
       TraceType.PROTO_LOG,
       'traces/perfetto/protolog.perfetto-trace',
     );
diff --git a/tools/winscope/src/parsers/screen_recording/parser_screen_recording.ts b/tools/winscope/src/parsers/screen_recording/parser_screen_recording.ts
index 753bedb30..7bd634f2f 100644
--- a/tools/winscope/src/parsers/screen_recording/parser_screen_recording.ts
+++ b/tools/winscope/src/parsers/screen_recording/parser_screen_recording.ts
@@ -14,7 +14,11 @@
  * limitations under the License.
  */
 
-import {ArrayUtils} from 'common/array_utils';
+import {
+  searchSubarray,
+  toIntLittleEndian,
+  toUintLittleEndian,
+} from 'common/array_utils';
 import {Timestamp} from 'common/time/time';
 import {ParserTimestampConverter} from 'common/time/timestamp_converter';
 import {TIME_UNIT_TO_NANO} from 'common/time/time_units';
@@ -95,7 +99,7 @@ class ParserScreenRecording extends AbstractParser<
   }
 
   private searchMagicString(videoData: Uint8Array): number | undefined {
-    let pos = ArrayUtils.searchSubarray(
+    let pos = searchSubarray(
       videoData,
       ParserScreenRecording.WINSCOPE_META_MAGIC_STRING,
     );
@@ -164,9 +168,7 @@ class ParserScreenRecording extends AbstractParser<
         'Failed to parse metadata version. Video data is too short.',
       );
     }
-    const version = Number(
-      ArrayUtils.toUintLittleEndian(videoData, pos, pos + 4),
-    );
+    const version = Number(toUintLittleEndian(videoData, pos, pos + 4));
     pos += 4;
     return [pos, version];
   }
@@ -180,7 +182,7 @@ class ParserScreenRecording extends AbstractParser<
         'Failed to parse realtime-to-elapsed time offset. Video data is too short.',
       );
     }
-    const offset = ArrayUtils.toIntLittleEndian(videoData, pos, pos + 8);
+    const offset = toIntLittleEndian(videoData, pos, pos + 8);
     pos += 8;
     return [pos, offset];
   }
@@ -194,9 +196,7 @@ class ParserScreenRecording extends AbstractParser<
         'Failed to parse frames count. Video data is too short.',
       );
     }
-    const count = Number(
-      ArrayUtils.toUintLittleEndian(videoData, pos, pos + 4),
-    );
+    const count = Number(toUintLittleEndian(videoData, pos, pos + 4));
     pos += 4;
     return [pos, count];
   }
@@ -213,7 +213,7 @@ class ParserScreenRecording extends AbstractParser<
     }
     const timestamps: Array<bigint> = [];
     for (let i = 0; i < count; ++i) {
-      const timestamp = ArrayUtils.toUintLittleEndian(videoData, pos, pos + 8);
+      const timestamp = toUintLittleEndian(videoData, pos, pos + 8);
       pos += 8;
       timestamps.push(timestamp);
     }
diff --git a/tools/winscope/src/parsers/screen_recording/parser_screen_recording_legacy.ts b/tools/winscope/src/parsers/screen_recording/parser_screen_recording_legacy.ts
index f11ad2098..1cba7deef 100644
--- a/tools/winscope/src/parsers/screen_recording/parser_screen_recording_legacy.ts
+++ b/tools/winscope/src/parsers/screen_recording/parser_screen_recording_legacy.ts
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-import {ArrayUtils} from 'common/array_utils';
+import {searchSubarray, toUintLittleEndian} from 'common/array_utils';
 import {Timestamp} from 'common/time/time';
 import {AbstractParser} from 'parsers/legacy/abstract_parser';
 import {MediaBasedTraceEntry} from 'trace/media_based_trace_entry';
@@ -40,7 +40,6 @@ class ParserScreenRecordingLegacy extends AbstractParser<
   override getRealToBootTimeOffsetNs(): bigint | undefined {
     return undefined;
   }
-
   override decodeTrace(videoData: Uint8Array): Array<bigint> {
     const posCount = this.searchMagicString(videoData);
     const [posTimestamps, count] = this.parseFramesCount(videoData, posCount);
@@ -64,7 +63,7 @@ class ParserScreenRecordingLegacy extends AbstractParser<
   }
 
   private searchMagicString(videoData: Uint8Array): number {
-    let pos = ArrayUtils.searchSubarray(
+    let pos = searchSubarray(
       videoData,
       ParserScreenRecordingLegacy.WINSCOPE_META_MAGIC_STRING,
     );
@@ -84,9 +83,7 @@ class ParserScreenRecordingLegacy extends AbstractParser<
         'Failed to parse frames count. Video data is too short.',
       );
     }
-    const framesCount = Number(
-      ArrayUtils.toUintLittleEndian(videoData, pos, pos + 4),
-    );
+    const framesCount = Number(toUintLittleEndian(videoData, pos, pos + 4));
     pos += 4;
     return [pos, framesCount];
   }
@@ -103,8 +100,7 @@ class ParserScreenRecordingLegacy extends AbstractParser<
     }
     const timestamps: Array<bigint> = [];
     for (let i = 0; i < count; ++i) {
-      const value =
-        ArrayUtils.toUintLittleEndian(videoData, pos, pos + 8) * 1000n;
+      const value = toUintLittleEndian(videoData, pos, pos + 8) * 1000n;
       pos += 8;
       timestamps.push(value);
     }
diff --git a/tools/winscope/src/parsers/screen_recording/parser_screen_recording_legacy_test.ts b/tools/winscope/src/parsers/screen_recording/parser_screen_recording_legacy_test.ts
index ef4a79a9d..5cf41263d 100644
--- a/tools/winscope/src/parsers/screen_recording/parser_screen_recording_legacy_test.ts
+++ b/tools/winscope/src/parsers/screen_recording/parser_screen_recording_legacy_test.ts
@@ -16,7 +16,7 @@
 
 import {assertDefined} from 'common/assert_utils';
 import {TimestampConverterUtils} from 'common/time/test_utils';
-import {UnitTestUtils} from 'test/unit/utils';
+import {LegacyParserProvider} from 'test/unit/fixture_utils';
 import {CoarseVersion} from 'trace/coarse_version';
 import {MediaBasedTraceEntry} from 'trace/media_based_trace_entry';
 import {Parser} from 'trace/parser';
@@ -26,9 +26,9 @@ describe('ParserScreenRecordingLegacy', () => {
   let parser: Parser<MediaBasedTraceEntry>;
 
   beforeAll(async () => {
-    parser = (await UnitTestUtils.getParser(
-      'traces/elapsed_timestamp/screen_recording.mp4',
-    )) as Parser<MediaBasedTraceEntry>;
+    parser = await new LegacyParserProvider()
+      .addFilename('traces/elapsed_timestamp/screen_recording.mp4')
+      .getParser<MediaBasedTraceEntry>();
   });
 
   it('has expected trace type', () => {
diff --git a/tools/winscope/src/parsers/screen_recording/parser_screen_recording_test.ts b/tools/winscope/src/parsers/screen_recording/parser_screen_recording_test.ts
index 2d6ac0aa4..d4b4ebafe 100644
--- a/tools/winscope/src/parsers/screen_recording/parser_screen_recording_test.ts
+++ b/tools/winscope/src/parsers/screen_recording/parser_screen_recording_test.ts
@@ -18,7 +18,7 @@ import {
   TimestampConverterUtils,
   timestampEqualityTester,
 } from 'common/time/test_utils';
-import {UnitTestUtils} from 'test/unit/utils';
+import {LegacyParserProvider} from 'test/unit/fixture_utils';
 import {CoarseVersion} from 'trace/coarse_version';
 import {MediaBasedTraceEntry} from 'trace/media_based_trace_entry';
 import {Parser} from 'trace/parser';
@@ -30,9 +30,11 @@ describe('ParserScreenRecording', () => {
   describe('metadata v2', () => {
     beforeAll(async () => {
       jasmine.addCustomEqualityTester(timestampEqualityTester);
-      parser = (await UnitTestUtils.getParser(
-        'traces/elapsed_and_real_timestamp/screen_recording_metadata_v2.mp4',
-      )) as Parser<MediaBasedTraceEntry>;
+      parser = await new LegacyParserProvider()
+        .addFilename(
+          'traces/elapsed_and_real_timestamp/screen_recording_metadata_v2.mp4',
+        )
+        .getParser<MediaBasedTraceEntry>();
     });
 
     it('has expected trace type', () => {
@@ -73,23 +75,25 @@ describe('ParserScreenRecording', () => {
   describe('separate metadata file', () => {
     beforeAll(async () => {
       jasmine.addCustomEqualityTester(timestampEqualityTester);
-      parser = (await UnitTestUtils.getParser(
-        'traces/elapsed_and_real_timestamp/screen_recording_no_metadata.mp4',
-        undefined,
-        undefined,
-        {
+      parser = await new LegacyParserProvider()
+        .addFilename(
+          'traces/elapsed_and_real_timestamp/screen_recording_no_metadata.mp4',
+        )
+        .setMetadata({
           screenRecordingOffsets: {
             elapsedRealTimeNanos: 5n,
             realToElapsedTimeOffsetNanos: 10n,
           },
-        },
-      )) as Parser<MediaBasedTraceEntry>;
+        })
+        .getParser<MediaBasedTraceEntry>();
     });
 
     it('throws error if metadata not provided', async () => {
-      const parsers = await UnitTestUtils.getParsers(
-        'traces/elapsed_and_real_timestamp/screen_recording_no_metadata.mp4',
-      );
+      const parsers = await new LegacyParserProvider()
+        .addFilename(
+          'traces/elapsed_and_real_timestamp/screen_recording_no_metadata.mp4',
+        )
+        .getParsers();
       expect(parsers.length).toEqual(0);
     });
 
diff --git a/tools/winscope/src/parsers/screenshot/parser_screenshot_test.ts b/tools/winscope/src/parsers/screenshot/parser_screenshot_test.ts
index 4fe53f394..45cd0d7b2 100644
--- a/tools/winscope/src/parsers/screenshot/parser_screenshot_test.ts
+++ b/tools/winscope/src/parsers/screenshot/parser_screenshot_test.ts
@@ -33,7 +33,7 @@ describe('ParserScreenshot', () => {
 
   beforeAll(async () => {
     jasmine.addCustomEqualityTester(timestampEqualityTester);
-    file = await getFixtureFile('traces/screenshot.png');
+    file = await getFixtureFile('traces/screenshot/screenshot.png');
     parser = new ParserScreenshot(
       new TraceFile(file),
       new TimestampConverter(TimestampConverterUtils.UTC_TIMEZONE_INFO, 0n),
diff --git a/tools/winscope/src/parsers/search/parser_search.ts b/tools/winscope/src/parsers/search/parser_search.ts
index f1ddb36ed..ad5e72db8 100644
--- a/tools/winscope/src/parsers/search/parser_search.ts
+++ b/tools/winscope/src/parsers/search/parser_search.ts
@@ -14,7 +14,8 @@
  * limitations under the License.
  */
 
-import {assertDefined} from 'common/assert_utils';
+import {assertBigInt, assertDefined} from 'common/assert_utils';
+import {NOT_IMPLEMENTED_ERROR} from 'common/errors';
 import {INVALID_TIME_NS, Timestamp} from 'common/time/time';
 import {TimestampConverter} from 'common/time/timestamp_converter';
 import {UserNotifier} from 'common/user_notifier';
@@ -69,7 +70,7 @@ export class ParserSearch implements Parser<QueryResult> {
     type: Q,
     entriesRange: EntriesRange,
   ): Promise<CustomQueryParserResultTypeMap[Q]> {
-    throw new Error('not implemented');
+    throw NOT_IMPLEMENTED_ERROR;
   }
 
   getDescriptors(): string[] {
@@ -85,16 +86,20 @@ export class ParserSearch implements Parser<QueryResult> {
   }
 
   createTimestamps(): void {
-    throw new Error('not implemented');
+    throw NOT_IMPLEMENTED_ERROR;
+  }
+
+  canConvertToPerfetto(): boolean {
+    return false;
   }
 
   async parse() {
-    const tp = await TraceProcessorFactory.getSingleInstance();
+    const tp = TraceProcessorFactory.getSingleInstance();
     try {
-      this.queryResult = await tp.queryAllRows(this.query);
+      this.queryResult = await tp.query(this.query);
       if (this.hasTimestamps() && this.queryResult.numRows() > 0) {
         for (const it = this.queryResult.iter({}); it.valid(); it.next()) {
-          const ns = it.get('ts') as bigint;
+          const ns = assertBigInt(it.get('ts'));
           if (ns === INVALID_TIME_NS) {
             this.timestamps.push(this.timestampConverter.makeZeroTimestamp());
           } else {
diff --git a/tools/winscope/src/parsers/search/parser_search_test.ts b/tools/winscope/src/parsers/search/parser_search_test.ts
index 99a2477d4..6b9348149 100644
--- a/tools/winscope/src/parsers/search/parser_search_test.ts
+++ b/tools/winscope/src/parsers/search/parser_search_test.ts
@@ -16,13 +16,14 @@
 
 import {assertDefined} from 'common/assert_utils';
 import {
+  getTimestampConverter,
   TimestampConverterUtils,
   timestampEqualityTester,
 } from 'common/time/test_utils';
 import {TraceSearchQueryFailed} from 'messaging/user_warnings';
 import {ParserSurfaceFlinger} from 'parsers/surface_flinger/perfetto/parser_surface_flinger';
+import {getPerfettoParser} from 'test/unit/fixture_utils';
 import {UserNotifierChecker} from 'test/unit/user_notifier_checker';
-import {UnitTestUtils} from 'test/unit/utils';
 import {CoarseVersion} from 'trace/coarse_version';
 import {TraceType} from 'trace/trace_type';
 import {ParserSearch} from './parser_search';
@@ -146,6 +147,7 @@ describe('ParserSearch', () => {
         'ts',
         'arg_set_id',
         'base64_proto_id',
+        'vsync_id',
       ]);
       expect(entry.numRows()).toEqual(0);
     });
@@ -166,12 +168,12 @@ describe('ParserSearch', () => {
 
   async function createParser(query: string): Promise<ParserSearch> {
     await (
-      (await UnitTestUtils.getPerfettoParser(
+      (await getPerfettoParser(
         TraceType.SURFACE_FLINGER,
         'traces/perfetto/layers_trace.perfetto-trace',
       )) as ParserSurfaceFlinger
     ).parse();
-    parser = new ParserSearch(query, UnitTestUtils.getTimestampConverter());
+    parser = new ParserSearch(query, getTimestampConverter());
     await parser.parse();
     return parser;
   }
diff --git a/tools/winscope/src/parsers/surface_flinger/computations/rects_computation.ts b/tools/winscope/src/parsers/surface_flinger/computations/rects_computation.ts
index dcf124613..38b6ea6ca 100644
--- a/tools/winscope/src/parsers/surface_flinger/computations/rects_computation.ts
+++ b/tools/winscope/src/parsers/surface_flinger/computations/rects_computation.ts
@@ -19,11 +19,8 @@ import {Rect} from 'common/geometry/rect';
 import {Region} from 'common/geometry/region';
 import {Size} from 'common/geometry/size';
 import {TransformMatrix} from 'common/geometry/transform_matrix';
-import {
-  Transform,
-  TransformType,
-} from 'parsers/surface_flinger/transform_utils';
 import {GeometryFactory} from 'trace/geometry_factory';
+import {Transform, TransformType} from 'trace/surface_flinger/transform_utils';
 import {TraceRect} from 'trace/trace_rect';
 import {TraceRectBuilder} from 'trace/trace_rect_builder';
 import {Computation} from 'trace/tree_node/computation';
diff --git a/tools/winscope/src/parsers/surface_flinger/computations/rects_computation_test.ts b/tools/winscope/src/parsers/surface_flinger/computations/rects_computation_test.ts
index b0f8a96f4..03f0d015d 100644
--- a/tools/winscope/src/parsers/surface_flinger/computations/rects_computation_test.ts
+++ b/tools/winscope/src/parsers/surface_flinger/computations/rects_computation_test.ts
@@ -17,12 +17,12 @@
 import {Rect} from 'common/geometry/rect';
 import {Region} from 'common/geometry/region';
 import {IDENTITY_MATRIX} from 'common/geometry/transform_matrix';
+import {android} from 'protos/surfaceflinger/udc/static';
+import {HierarchyTreeBuilder} from 'test/unit/hierarchy_tree_builder';
 import {
   Transform,
   TransformTypeFlags,
-} from 'parsers/surface_flinger/transform_utils';
-import {android} from 'protos/surfaceflinger/udc/static';
-import {HierarchyTreeBuilder} from 'test/unit/hierarchy_tree_builder';
+} from 'trace/surface_flinger/transform_utils';
 import {TraceRect} from 'trace/trace_rect';
 import {TraceRectBuilder} from 'trace/trace_rect_builder';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
diff --git a/tools/winscope/src/parsers/surface_flinger/computations/visibility_properties_computation.ts b/tools/winscope/src/parsers/surface_flinger/computations/visibility_properties_computation.ts
index 693ae8b34..148fffbcb 100644
--- a/tools/winscope/src/parsers/surface_flinger/computations/visibility_properties_computation.ts
+++ b/tools/winscope/src/parsers/surface_flinger/computations/visibility_properties_computation.ts
@@ -17,12 +17,9 @@
 import {assertDefined} from 'common/assert_utils';
 import {Rect} from 'common/geometry/rect';
 import {RawDataUtils} from 'parsers/raw_data_utils';
-import {LayerFlag} from 'parsers/surface_flinger/layer_flag';
-import {
-  Transform,
-  TransformType,
-} from 'parsers/surface_flinger/transform_utils';
 import {GeometryFactory} from 'trace/geometry_factory';
+import {LayerFlag} from 'trace/surface_flinger/layer_flag';
+import {Transform, TransformType} from 'trace/surface_flinger/transform_utils';
 import {Computation} from 'trace/tree_node/computation';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
diff --git a/tools/winscope/src/parsers/surface_flinger/computations/visibility_properties_computation_test.ts b/tools/winscope/src/parsers/surface_flinger/computations/visibility_properties_computation_test.ts
index d0b4a47cc..c073e34da 100644
--- a/tools/winscope/src/parsers/surface_flinger/computations/visibility_properties_computation_test.ts
+++ b/tools/winscope/src/parsers/surface_flinger/computations/visibility_properties_computation_test.ts
@@ -15,12 +15,12 @@
  */
 
 import {assertDefined} from 'common/assert_utils';
-import {LayerFlag} from 'parsers/surface_flinger/layer_flag';
 import {android} from 'protos/surfaceflinger/udc/static';
 import {
   ChildHierarchy,
   HierarchyTreeBuilder,
 } from 'test/unit/hierarchy_tree_builder';
+import {LayerFlag} from 'trace/surface_flinger/layer_flag';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 import {VisibilityPropertiesComputation} from './visibility_properties_computation';
 import {ZOrderPathsComputation} from './z_order_paths_computation';
diff --git a/tools/winscope/src/parsers/surface_flinger/entry_hierarchy_tree_factory.ts b/tools/winscope/src/parsers/surface_flinger/entry_hierarchy_tree_factory.ts
index 1dfbbcc89..a04f46771 100644
--- a/tools/winscope/src/parsers/surface_flinger/entry_hierarchy_tree_factory.ts
+++ b/tools/winscope/src/parsers/surface_flinger/entry_hierarchy_tree_factory.ts
@@ -16,15 +16,14 @@
 
 import {assertDefined} from 'common/assert_utils';
 import {DuplicateLayerIds, MissingLayerIds} from 'messaging/user_warnings';
-import {perfetto} from 'protos/surfaceflinger/latest/static';
-import {android} from 'protos/surfaceflinger/udc/static';
+import {PropertyTreeBuilderFromProto} from 'parsers/property_tree_builder_from_proto';
+import {perfetto} from 'protos/perfetto/trace/static';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 import {
   LazyPropertiesStrategyType,
   PropertiesProvider,
 } from 'trace/tree_node/properties_provider';
 import {PropertiesProviderBuilder} from 'trace/tree_node/properties_provider_builder';
-import {PropertyTreeBuilderFromProto} from 'trace/tree_node/property_tree_builder_from_proto';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 import {COMMON_OPERATIONS} from './common_operations';
 import {RectsComputation} from './computations/rects_computation';
@@ -33,14 +32,12 @@ import {ZOrderPathsComputation} from './computations/z_order_paths_computation';
 import {DENYLIST_PROPERTIES} from './denylist_properties';
 import {EAGER_PROPERTIES} from './eager_properties';
 import {HierarchyTreeBuilderSf} from './hierarchy_tree_builder_sf';
-import {ParserSurfaceFlinger as LegacyParserSurfaceFlinger} from './legacy/parser_surface_flinger';
-import {ParserSurfaceFlinger as PerfettoParserSurfaceFlinger} from './perfetto/parser_surface_flinger';
+import {ParserSurfaceFlinger} from './perfetto/parser_surface_flinger';
 
 export class EntryHierarchyTreeFactory {
   makeEntryHierarchyTree(
-    entryProto: EntryType,
-    layerProtos: LayerType[],
-    ParserSurfaceFlinger: ParserSurfaceFlinger,
+    entryProto: perfetto.protos.ILayersSnapshotProto,
+    layerProtos: perfetto.protos.ILayerProto[],
   ): HierarchyTreeNode {
     const excludesCompositionState =
       entryProto?.excludesCompositionState ?? true;
@@ -52,7 +49,10 @@ export class EntryHierarchyTreeFactory {
     let missingLayerIds = false;
 
     const layers = layerProtos.reduce(
-      (allLayerProps: PropertiesProvider[], layer: LayerType) => {
+      (
+        allLayerProps: PropertiesProvider[],
+        layer: perfetto.protos.ILayerProto,
+      ) => {
         if (layer.id === null || layer.id === undefined) {
           missingLayerIds = true;
           return allLayerProps;
@@ -132,7 +132,7 @@ export class EntryHierarchyTreeFactory {
   }
 
   private makeEagerPropertiesTree(
-    layer: LayerType,
+    layer: perfetto.protos.ILayerProto,
     duplicateCount: number,
   ): PropertyTreeNode {
     const denyList: string[] = [];
@@ -153,7 +153,9 @@ export class EntryHierarchyTreeFactory {
       .build();
   }
 
-  private makeEntryEagerPropertiesTree(entry: EntryType): PropertyTreeNode {
+  private makeEntryEagerPropertiesTree(
+    entry: perfetto.protos.ILayersSnapshotProto,
+  ): PropertyTreeNode {
     const denyList: string[] = [];
     let obj = entry;
     do {
@@ -172,7 +174,7 @@ export class EntryHierarchyTreeFactory {
   }
 
   private makeLayerLazyPropertiesStrategy(
-    layer: LayerType,
+    layer: perfetto.protos.ILayerProto,
     duplicateCount: number,
   ): LazyPropertiesStrategyType {
     return async () => {
@@ -187,7 +189,7 @@ export class EntryHierarchyTreeFactory {
   }
 
   private makeEntryLazyPropertiesStrategy(
-    entry: EntryType,
+    entry: perfetto.protos.ILayersSnapshotProto,
   ): LazyPropertiesStrategyType {
     return async () => {
       return new PropertyTreeBuilderFromProto()
@@ -199,15 +201,3 @@ export class EntryHierarchyTreeFactory {
     };
   }
 }
-
-type EntryType =
-  | android.surfaceflinger.ILayersTraceProto
-  | perfetto.protos.ILayersSnapshotProto;
-
-type LayerType =
-  | android.surfaceflinger.ILayerProto
-  | perfetto.protos.ILayerProto;
-
-type ParserSurfaceFlinger =
-  | typeof PerfettoParserSurfaceFlinger
-  | typeof LegacyParserSurfaceFlinger;
diff --git a/tools/winscope/src/parsers/surface_flinger/entry_hierarchy_tree_factory_test.ts b/tools/winscope/src/parsers/surface_flinger/entry_hierarchy_tree_factory_test.ts
index ec99fa175..d2e76599e 100644
--- a/tools/winscope/src/parsers/surface_flinger/entry_hierarchy_tree_factory_test.ts
+++ b/tools/winscope/src/parsers/surface_flinger/entry_hierarchy_tree_factory_test.ts
@@ -16,7 +16,6 @@
 
 import {DuplicateLayerIds, MissingLayerIds} from 'messaging/user_warnings';
 import {EntryHierarchyTreeFactory} from './entry_hierarchy_tree_factory';
-import {ParserSurfaceFlinger} from './legacy/parser_surface_flinger';
 
 describe('EntryHierarchyTreeFactory', () => {
   const factory = new EntryHierarchyTreeFactory();
@@ -34,11 +33,7 @@ describe('EntryHierarchyTreeFactory', () => {
         name: 'Second test layer',
       },
     ];
-    const tree = factory.makeEntryHierarchyTree(
-      entryProto,
-      layerProtos,
-      ParserSurfaceFlinger,
-    );
+    const tree = factory.makeEntryHierarchyTree(entryProto, layerProtos);
     expect(tree.getAllChildren().length).toEqual(1);
     expect(tree.getChildByName(testLayer.name)).toBeDefined();
     expect(tree.getWarnings()).toEqual([new MissingLayerIds()]);
@@ -47,11 +42,7 @@ describe('EntryHierarchyTreeFactory', () => {
   it('handles duplicate layer ids', () => {
     const entryProto = {};
     const layerProtos = [testLayer, testLayer];
-    const tree = factory.makeEntryHierarchyTree(
-      entryProto,
-      layerProtos,
-      ParserSurfaceFlinger,
-    );
+    const tree = factory.makeEntryHierarchyTree(entryProto, layerProtos);
     expect(tree.getAllChildren().length).toEqual(2);
     expect(tree.getChildByName(testLayer.name)).toBeDefined();
     expect(tree.getChildByName(testLayer.name + ' duplicate(1)')).toBeDefined();
@@ -65,11 +56,7 @@ describe('EntryHierarchyTreeFactory', () => {
   });
 
   function checkExcludesCompositionState(entry: object, expected: boolean) {
-    const tree = factory.makeEntryHierarchyTree(
-      entry,
-      [testLayer],
-      ParserSurfaceFlinger,
-    );
+    const tree = factory.makeEntryHierarchyTree(entry, [testLayer]);
     const excludesCompositionState = tree
       .getChildByName(testLayer.name)
       ?.getEagerPropertyByName('excludesCompositionState')
diff --git a/tools/winscope/src/parsers/surface_flinger/hierarchy_tree_builder_sf_test.ts b/tools/winscope/src/parsers/surface_flinger/hierarchy_tree_builder_sf_test.ts
index e8969974d..8d2b55049 100644
--- a/tools/winscope/src/parsers/surface_flinger/hierarchy_tree_builder_sf_test.ts
+++ b/tools/winscope/src/parsers/surface_flinger/hierarchy_tree_builder_sf_test.ts
@@ -16,6 +16,7 @@
 
 import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
 import {TreeNodeUtils} from 'test/unit/tree_node_utils';
+import {LayerFlag} from 'trace/surface_flinger/layer_flag';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 import {OperationChain} from 'trace/tree_node/operations/operation_chain';
 import {PropertiesProvider} from 'trace/tree_node/properties_provider';
@@ -24,7 +25,6 @@ import {
   PropertyTreeNode,
 } from 'trace/tree_node/property_tree_node';
 import {HierarchyTreeBuilderSf} from './hierarchy_tree_builder_sf';
-import {LayerFlag} from './layer_flag';
 
 describe('HierarchyTreeBuilderSf', () => {
   let builder: HierarchyTreeBuilderSf;
diff --git a/tools/winscope/src/parsers/surface_flinger/legacy/parser_surface_flinger.ts b/tools/winscope/src/parsers/surface_flinger/legacy/parser_surface_flinger.ts
index 94f15402a..e0202ad2a 100644
--- a/tools/winscope/src/parsers/surface_flinger/legacy/parser_surface_flinger.ts
+++ b/tools/winscope/src/parsers/surface_flinger/legacy/parser_surface_flinger.ts
@@ -16,85 +16,28 @@
 
 import {assertDefined} from 'common/assert_utils';
 import {Timestamp} from 'common/time/time';
+import Long from 'long';
 import {AbstractParser} from 'parsers/legacy/abstract_parser';
-import {AddDefaults} from 'parsers/operations/add_defaults';
-import {SetFormatters} from 'parsers/operations/set_formatters';
-import {TranslateIntDef} from 'parsers/operations/translate_intdef';
-import {DENYLIST_PROPERTIES} from 'parsers/surface_flinger/denylist_properties';
-import {EAGER_PROPERTIES} from 'parsers/surface_flinger/eager_properties';
-import {EntryHierarchyTreeFactory} from 'parsers/surface_flinger/entry_hierarchy_tree_factory';
-import {TamperedMessageType} from 'parsers/tampered_message_type';
+import {perfetto} from 'protos/perfetto/trace/static';
 import root from 'protos/surfaceflinger/udc/json';
 import {android} from 'protos/surfaceflinger/udc/static';
-import {
-  CustomQueryParserResultTypeMap,
-  CustomQueryType,
-  VisitableParserCustomQuery,
-} from 'trace/custom_query';
-import {EntriesRange} from 'trace/trace';
 import {TraceType} from 'trace/trace_type';
-import {EnumFormatter, LAYER_ID_FORMATTER} from 'trace/tree_node/formatters';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 
 type LayerTraceProto = android.surfaceflinger.ILayersTraceProto;
 
-class ParserSurfaceFlinger extends AbstractParser<
+export class ParserSurfaceFlinger extends AbstractParser<
   HierarchyTreeNode,
   LayerTraceProto
 > {
   private static readonly MAGIC_NUMBER = [
     0x09, 0x4c, 0x59, 0x52, 0x54, 0x52, 0x41, 0x43, 0x45,
   ]; // .LYRTRACE
-  private static readonly CUSTOM_FORMATTERS = new Map([
-    ['cropLayerId', LAYER_ID_FORMATTER],
-    ['zOrderRelativeOf', LAYER_ID_FORMATTER],
-    [
-      'hwcCompositionType',
-      new EnumFormatter(android.surfaceflinger.HwcCompositionType),
-    ],
-  ]);
 
-  private static readonly LayersTraceFileProto = TamperedMessageType.tamper(
-    root.lookupType('android.surfaceflinger.LayersTraceFileProto'),
+  private static readonly LayersTraceFileProto = root.lookupType(
+    'android.surfaceflinger.LayersTraceFileProto',
   );
-  private static readonly entryField =
-    ParserSurfaceFlinger.LayersTraceFileProto.fields['entry'];
-  private static readonly layerField = assertDefined(
-    ParserSurfaceFlinger.entryField.tamperedMessageType?.fields['layers']
-      .tamperedMessageType,
-  ).fields['layers'];
 
-  static readonly Operations = {
-    SetFormattersLayer: new SetFormatters(
-      ParserSurfaceFlinger.layerField,
-      ParserSurfaceFlinger.CUSTOM_FORMATTERS,
-    ),
-    TranslateIntDefLayer: new TranslateIntDef(ParserSurfaceFlinger.layerField),
-    AddDefaultsLayerEager: new AddDefaults(
-      ParserSurfaceFlinger.layerField,
-      EAGER_PROPERTIES,
-    ),
-    AddDefaultsLayerLazy: new AddDefaults(
-      ParserSurfaceFlinger.layerField,
-      undefined,
-      EAGER_PROPERTIES.concat(DENYLIST_PROPERTIES),
-    ),
-    SetFormattersEntry: new SetFormatters(
-      ParserSurfaceFlinger.entryField,
-      ParserSurfaceFlinger.CUSTOM_FORMATTERS,
-    ),
-    TranslateIntDefEntry: new TranslateIntDef(ParserSurfaceFlinger.entryField),
-    AddDefaultsEntryEager: new AddDefaults(ParserSurfaceFlinger.entryField, [
-      'displays',
-    ]),
-    AddDefaultsEntryLazy: new AddDefaults(
-      ParserSurfaceFlinger.entryField,
-      undefined,
-      DENYLIST_PROPERTIES,
-    ),
-  };
-
-  private readonly factory = new EntryHierarchyTreeFactory();
   private realToMonotonicTimeOffsetNs: bigint | undefined;
   private isDump = false;
 
@@ -118,6 +61,7 @@ class ParserSurfaceFlinger extends AbstractParser<
     const decoded = ParserSurfaceFlinger.LayersTraceFileProto.decode(
       buffer,
     ) as android.surfaceflinger.ILayersTraceFileProto;
+
     const timeOffset = BigInt(
       decoded.realToElapsedTimeOffsetNanos?.toString() ?? '0',
     );
@@ -132,6 +76,29 @@ class ParserSurfaceFlinger extends AbstractParser<
     return decoded.entry ?? [];
   }
 
+  override canConvertToPerfetto(): boolean {
+    return true;
+  }
+
+  override convertToPerfettoPackets(
+    sequenceId: number,
+  ): perfetto.protos.TracePacket[] {
+    const packets = [];
+    for (const entry of this.decodedEntries) {
+      const packet = perfetto.protos.TracePacket.create();
+      packet.timestamp = this.isDump
+        ? Long.fromInt(0)
+        : assertDefined(entry.elapsedRealtimeNanos);
+      packet.timestampClockId =
+        perfetto.protos.ClockSnapshot.Clock.BuiltinClocks.MONOTONIC;
+      packet.trustedPacketSequenceId = sequenceId;
+      packet.surfaceflingerLayersSnapshot =
+        perfetto.protos.LayersSnapshotProto.fromObject(entry);
+      packets.push(packet);
+    }
+    return packets;
+  }
+
   protected override getTimestamp(entry: LayerTraceProto): Timestamp {
     if (this.isDump) {
       return this.timestampConverter.makeZeroTimestamp();
@@ -140,49 +107,4 @@ class ParserSurfaceFlinger extends AbstractParser<
       BigInt(assertDefined(entry.elapsedRealtimeNanos).toString()),
     );
   }
-
-  override processDecodedEntry(
-    index: number,
-    entry: LayerTraceProto,
-  ): HierarchyTreeNode {
-    return this.factory.makeEntryHierarchyTree(
-      entry,
-      assertDefined(entry.layers?.layers),
-      ParserSurfaceFlinger,
-    );
-  }
-
-  override customQuery<Q extends CustomQueryType>(
-    type: Q,
-    entriesRange: EntriesRange,
-  ): Promise<CustomQueryParserResultTypeMap[Q]> {
-    return new VisitableParserCustomQuery(type)
-      .visit(CustomQueryType.VSYNCID, () => {
-        const result = this.decodedEntries
-          .slice(entriesRange.start, entriesRange.end)
-          .map((entry) => {
-            return BigInt(assertDefined(entry.vsyncId?.toString())); // convert Long to bigint
-          });
-        return Promise.resolve(result);
-      })
-      .visit(CustomQueryType.SF_LAYERS_ID_AND_NAME, () => {
-        const result: Array<{id: number; name: string}> = [];
-        this.decodedEntries
-          .slice(entriesRange.start, entriesRange.end)
-          .forEach((entry: LayerTraceProto) => {
-            entry.layers?.layers?.forEach(
-              (layer: android.surfaceflinger.ILayerProto) => {
-                result.push({
-                  id: assertDefined(layer.id),
-                  name: assertDefined(layer.name),
-                });
-              },
-            );
-          });
-        return Promise.resolve(result);
-      })
-      .getResult();
-  }
 }
-
-export {ParserSurfaceFlinger};
diff --git a/tools/winscope/src/parsers/surface_flinger/legacy/parser_surface_flinger_dump_test.ts b/tools/winscope/src/parsers/surface_flinger/legacy/parser_surface_flinger_dump_test.ts
index 69529b038..d5aeabea9 100644
--- a/tools/winscope/src/parsers/surface_flinger/legacy/parser_surface_flinger_dump_test.ts
+++ b/tools/winscope/src/parsers/surface_flinger/legacy/parser_surface_flinger_dump_test.ts
@@ -14,12 +14,16 @@
  * limitations under the License.
  */
 
+import {assertDefined} from 'common/assert_utils';
 import {
+  getTimestampConverter,
   TimestampConverterUtils,
   timestampEqualityTester,
 } from 'common/time/test_utils';
+import Long from 'long';
+import {perfetto} from 'protos/perfetto/trace/static';
+import {LegacyParserProvider} from 'test/unit/fixture_utils';
 import {UserNotifierChecker} from 'test/unit/user_notifier_checker';
-import {UnitTestUtils} from 'test/unit/utils';
 import {CoarseVersion} from 'trace/coarse_version';
 import {Parser} from 'trace/parser';
 import {TraceType} from 'trace/trace_type';
@@ -37,9 +41,9 @@ describe('ParserSurfaceFlingerDump', () => {
     let parser: Parser<HierarchyTreeNode>;
 
     beforeAll(async () => {
-      parser = (await UnitTestUtils.getParser(
-        'traces/elapsed_and_real_timestamp/dump_SurfaceFlinger.pb',
-      )) as Parser<HierarchyTreeNode>;
+      parser = await new LegacyParserProvider()
+        .addFilename('traces/elapsed_and_real_timestamp/dump_SurfaceFlinger.pb')
+        .getParser<HierarchyTreeNode>();
     });
 
     afterEach(() => {
@@ -61,18 +65,37 @@ describe('ParserSurfaceFlingerDump', () => {
     });
 
     it('does not apply timezone info', async () => {
-      const parserWithTimezoneInfo = (await UnitTestUtils.getParser(
-        'traces/elapsed_and_real_timestamp/dump_SurfaceFlinger.pb',
-        UnitTestUtils.getTimestampConverter(true),
-      )) as Parser<HierarchyTreeNode>;
+      const parserWithTimezoneInfo = await new LegacyParserProvider()
+        .addFilename('traces/elapsed_and_real_timestamp/dump_SurfaceFlinger.pb')
+        .setTimestampConverter(getTimestampConverter(true))
+        .getParser<HierarchyTreeNode>();
 
       const expected = [TimestampConverterUtils.makeElapsedTimestamp(0n)];
       expect(parserWithTimezoneInfo.getTimestamps()).toEqual(expected);
     });
 
-    it('retrieves trace entry', async () => {
-      const entry = await parser.getEntry(0);
-      expect(entry).toBeTruthy();
+    it('does not provide entry', () => {
+      expect(parser.getEntry).toThrow();
+    });
+
+    it('converts to valid perfetto packets', async () => {
+      const packets = parser.convertToPerfettoPackets!(10);
+      expect(packets.length).toEqual(1);
+      expect(packets[0].timestamp).toEqual(Long.fromInt(0));
+      expect(packets[0].timestampClockId).toEqual(
+        perfetto.protos.ClockSnapshot.Clock.BuiltinClocks.MONOTONIC,
+      );
+      expect(packets[0].trustedPacketSequenceId).toEqual(10);
+      expect(
+        packets[0].surfaceflingerLayersSnapshot?.layers?.layers?.length,
+      ).toEqual(94);
+    });
+
+    it('converts to valid perfetto trace', async () => {
+      await checkValidPerfettoTraceConversion(
+        'traces/elapsed_and_real_timestamp/dump_SurfaceFlinger.pb',
+        95,
+      );
     });
   });
 
@@ -80,9 +103,9 @@ describe('ParserSurfaceFlingerDump', () => {
     let parser: Parser<HierarchyTreeNode>;
 
     beforeAll(async () => {
-      parser = (await UnitTestUtils.getParser(
-        'traces/elapsed_timestamp/dump_SurfaceFlinger.pb',
-      )) as Parser<HierarchyTreeNode>;
+      parser = await new LegacyParserProvider()
+        .addFilename('traces/elapsed_timestamp/dump_SurfaceFlinger.pb')
+        .getParser<HierarchyTreeNode>();
     });
 
     it('has expected trace type', () => {
@@ -97,5 +120,45 @@ describe('ParserSurfaceFlingerDump', () => {
       const expected = [TimestampConverterUtils.makeElapsedTimestamp(0n)];
       expect(parser.getTimestamps()).toEqual(expected);
     });
+
+    it('converts to valid perfetto packets', async () => {
+      const packets = parser.convertToPerfettoPackets!(10);
+      expect(packets.length).toEqual(1);
+      expect(packets[0].timestamp).toEqual(Long.fromInt(0));
+      expect(packets[0].timestampClockId).toEqual(
+        perfetto.protos.ClockSnapshot.Clock.BuiltinClocks.MONOTONIC,
+      );
+      expect(packets[0].trustedPacketSequenceId).toEqual(10);
+      expect(
+        packets[0].surfaceflingerLayersSnapshot?.layers?.layers?.length,
+      ).toEqual(91);
+    });
+
+    it('does not provide entry', () => {
+      expect(parser.getEntry).toThrow();
+    });
+
+    it('converts to valid perfetto trace', async () => {
+      await checkValidPerfettoTraceConversion(
+        'traces/elapsed_timestamp/dump_SurfaceFlinger.pb',
+        92,
+      );
+    });
   });
+
+  async function checkValidPerfettoTraceConversion(
+    filename: string,
+    nodeCount: number,
+  ) {
+    const perfettoParser = await new LegacyParserProvider()
+      .addFilename(filename)
+      .setConvertToPerfetto(true)
+      .getParser<HierarchyTreeNode>();
+    const expected = [TimestampConverterUtils.makeZeroTimestamp()];
+    expect(assertDefined(perfettoParser.getTimestamps())).toEqual(expected);
+    const entry = await perfettoParser.getEntry(0);
+    let count = 0;
+    entry.forEachNodeDfs(() => count++);
+    expect(count).toEqual(nodeCount);
+  }
 });
diff --git a/tools/winscope/src/parsers/surface_flinger/legacy/parser_surface_flinger_test.ts b/tools/winscope/src/parsers/surface_flinger/legacy/parser_surface_flinger_test.ts
index 9df8d8bfd..e629ca9dd 100644
--- a/tools/winscope/src/parsers/surface_flinger/legacy/parser_surface_flinger_test.ts
+++ b/tools/winscope/src/parsers/surface_flinger/legacy/parser_surface_flinger_test.ts
@@ -18,10 +18,12 @@ import {
   TimestampConverterUtils,
   timestampEqualityTester,
 } from 'common/time/test_utils';
+import Long from 'long';
 import {DuplicateLayerIds} from 'messaging/user_warnings';
+import {perfetto} from 'protos/perfetto/trace/static';
+import {LegacyParserProvider} from 'test/unit/fixture_utils';
 import {TraceBuilder} from 'test/unit/trace_builder';
 import {UserNotifierChecker} from 'test/unit/user_notifier_checker';
-import {UnitTestUtils} from 'test/unit/utils';
 import {CoarseVersion} from 'trace/coarse_version';
 import {CustomQueryType} from 'trace/custom_query';
 import {Parser} from 'trace/parser';
@@ -43,26 +45,21 @@ describe('ParserSurfaceFlinger', () => {
   });
 
   describe('trace with real timestamps', () => {
-    let parser: Parser<HierarchyTreeNode>;
-    let trace: Trace<HierarchyTreeNode>;
+    let realParser: Parser<HierarchyTreeNode>;
 
     beforeAll(async () => {
       jasmine.addCustomEqualityTester(timestampEqualityTester);
-      parser = (await UnitTestUtils.getParser(
-        'traces/elapsed_and_real_timestamp/SurfaceFlinger.pb',
-      )) as Parser<HierarchyTreeNode>;
-      trace = new TraceBuilder<HierarchyTreeNode>()
-        .setType(TraceType.SURFACE_FLINGER)
-        .setParser(parser)
-        .build();
+      realParser = await new LegacyParserProvider()
+        .addFilename('traces/elapsed_and_real_timestamp/SurfaceFlinger.pb')
+        .getParser<HierarchyTreeNode>();
     });
 
     it('has expected trace type', () => {
-      expect(parser.getTraceType()).toEqual(TraceType.SURFACE_FLINGER);
+      expect(realParser.getTraceType()).toEqual(TraceType.SURFACE_FLINGER);
     });
 
     it('has expected coarse version', () => {
-      expect(parser.getCoarseVersion()).toEqual(CoarseVersion.LEGACY);
+      expect(realParser.getCoarseVersion()).toEqual(CoarseVersion.LEGACY);
     });
 
     it('provides timestamps', () => {
@@ -71,150 +68,210 @@ describe('ParserSurfaceFlinger', () => {
         TimestampConverterUtils.makeRealTimestamp(1659107089233029344n),
         TimestampConverterUtils.makeRealTimestamp(1659107090005226366n),
       ];
-      expect(assertDefined(parser.getTimestamps()).slice(0, 3)).toEqual(
+      expect(assertDefined(realParser.getTimestamps()).slice(0, 3)).toEqual(
         expected,
       );
     });
 
-    it('provides correct root entry node', async () => {
-      const entry = await parser.getEntry(1);
-      expect(entry.id).toEqual('LayerTraceEntry root');
-      expect(entry.name).toEqual('root');
+    it('does not provide entry', () => {
+      expect(realParser.getEntry).toThrow();
     });
 
-    it('decodes layer state flags', async () => {
-      const entry = await parser.getEntry(0);
-      {
-        const layer = assertDefined(
-          entry.findDfs(UiTreeUtils.makeIdMatchFilter('27 Leaf:24:25#27')),
-        );
-        expect(layer.name).toEqual('Leaf:24:25#27');
+    it('converts to valid perfetto packets', async () => {
+      const packets = realParser.convertToPerfettoPackets!(10);
+      expect(packets.length).toEqual(21);
+      expect(packets[0].trustedPacketSequenceId).toEqual(10);
+      expect(
+        packets[0].surfaceflingerLayersSnapshot?.layers?.layers?.length,
+      ).toEqual(83);
+      expect(packets[0].timestamp).toEqual(
+        Long.fromString(BigInt(14500282843).toString()),
+      );
+      expect(packets[0].timestampClockId).toEqual(
+        perfetto.protos.ClockSnapshot.Clock.BuiltinClocks.MONOTONIC,
+      );
+    });
 
-        expect(
-          assertDefined(layer.getEagerPropertyByName('flags')).formattedValue(),
-        ).toEqual('0');
-        expect(
-          assertDefined(
-            layer.getEagerPropertyByName('verboseFlags'),
-          ).formattedValue(),
-        ).toEqual('');
-      }
-      {
-        const layer = assertDefined(
-          entry.findDfs(UiTreeUtils.makeIdMatchFilter('48 Task=4#48')),
-        );
-        expect(layer.name).toEqual('Task=4#48');
+    describe('converts to valid perfetto trace', () => {
+      let perfettoParser: Parser<HierarchyTreeNode>;
+      let perfettoTrace: Trace<HierarchyTreeNode>;
 
-        expect(
-          assertDefined(layer.getEagerPropertyByName('flags')).formattedValue(),
-        ).toEqual('1');
-        expect(
-          assertDefined(
-            layer.getEagerPropertyByName('verboseFlags'),
-          ).formattedValue(),
-        ).toEqual('HIDDEN (0x1)');
-      }
-      {
-        const layer = assertDefined(
-          entry.findDfs(
-            UiTreeUtils.makeIdMatchFilter('77 Wallpaper BBQ wrapper#77'),
-          ),
-        );
-        expect(layer.name).toEqual('Wallpaper BBQ wrapper#77');
+      beforeAll(async () => {
+        perfettoParser = await new LegacyParserProvider()
+          .addFilename('traces/elapsed_and_real_timestamp/SurfaceFlinger.pb')
+          .setConvertToPerfetto(true)
+          .getParser<HierarchyTreeNode>();
+        perfettoTrace = new TraceBuilder<HierarchyTreeNode>()
+          .setType(TraceType.SURFACE_FLINGER)
+          .setParser(perfettoParser)
+          .build();
+      });
 
+      it('provides timestamps', () => {
+        const expected = [
+          TimestampConverterUtils.makeRealTimestamp(1659107089102062832n),
+          TimestampConverterUtils.makeRealTimestamp(1659107089233029344n),
+          TimestampConverterUtils.makeRealTimestamp(1659107090005226366n),
+        ];
         expect(
-          assertDefined(layer.getEagerPropertyByName('flags')).formattedValue(),
-        ).toEqual('256');
-        expect(
-          assertDefined(
-            layer.getEagerPropertyByName('verboseFlags'),
-          ).formattedValue(),
-        ).toEqual('ENABLE_BACKPRESSURE (0x100)');
-      }
-    });
+          assertDefined(perfettoParser.getTimestamps()).slice(0, 3),
+        ).toEqual(expected);
+      });
 
-    it('supports VSYNCID custom query', async () => {
-      const entries = await trace
-        .sliceEntries(0, 3)
-        .customQuery(CustomQueryType.VSYNCID);
-      const values = entries.map((entry) => entry.getValue());
-      expect(values).toEqual([4891n, 5235n, 5748n]);
-    });
+      it('decodes layer state flags', async () => {
+        const entry = await perfettoParser.getEntry(0);
+        {
+          const layer = assertDefined(
+            entry.findDfs(UiTreeUtils.makeIdMatchFilter('27 Leaf:24:25#27')),
+          );
+          expect(layer.name).toEqual('Leaf:24:25#27');
+
+          expect(
+            assertDefined(
+              layer.getEagerPropertyByName('flags'),
+            ).formattedValue(),
+          ).toEqual('0');
+          expect(
+            assertDefined(
+              layer.getEagerPropertyByName('verboseFlags'),
+            ).formattedValue(),
+          ).toEqual('');
+        }
+        {
+          const layer = assertDefined(
+            entry.findDfs(UiTreeUtils.makeIdMatchFilter('48 Task=4#48')),
+          );
+          expect(layer.name).toEqual('Task=4#48');
 
-    it('supports SF_LAYERS_ID_AND_NAME custom query', async () => {
-      const idAndNames = await trace
-        .sliceEntries(0, 1)
-        .customQuery(CustomQueryType.SF_LAYERS_ID_AND_NAME);
-      expect(idAndNames).toContain({
-        id: 4,
-        name: 'WindowedMagnification:0:31#4',
+          expect(
+            assertDefined(
+              layer.getEagerPropertyByName('flags'),
+            ).formattedValue(),
+          ).toEqual('1');
+          expect(
+            assertDefined(
+              layer.getEagerPropertyByName('verboseFlags'),
+            ).formattedValue(),
+          ).toEqual('HIDDEN (0x1)');
+        }
+        {
+          const layer = assertDefined(
+            entry.findDfs(
+              UiTreeUtils.makeIdMatchFilter('77 Wallpaper BBQ wrapper#77'),
+            ),
+          );
+          expect(layer.name).toEqual('Wallpaper BBQ wrapper#77');
+
+          expect(
+            assertDefined(
+              layer.getEagerPropertyByName('flags'),
+            ).formattedValue(),
+          ).toEqual('256');
+          expect(
+            assertDefined(
+              layer.getEagerPropertyByName('verboseFlags'),
+            ).formattedValue(),
+          ).toEqual('ENABLE_BACKPRESSURE (0x100)');
+        }
+      });
+
+      it('supports VSYNCID custom query', async () => {
+        const entries = await perfettoTrace
+          .sliceEntries(0, 3)
+          .customQuery(CustomQueryType.VSYNCID);
+        const values = entries.map((entry) => entry.getValue());
+        expect(values).toEqual([4891n, 5235n, 5748n]);
+      });
+
+      it('supports SF_LAYERS_ID_AND_NAME custom query', async () => {
+        const idAndNames = await perfettoTrace
+          .sliceEntries(0, 1)
+          .customQuery(CustomQueryType.SF_LAYERS_ID_AND_NAME);
+        expect(idAndNames).toContain({
+          id: 4,
+          name: 'WindowedMagnification:0:31#4',
+        });
+        expect(idAndNames).toContain({id: 5, name: 'HideDisplayCutout:0:14#5'});
       });
-      expect(idAndNames).toContain({id: 5, name: 'HideDisplayCutout:0:14#5'});
     });
 
-    it('is robust to duplicated layer ids', async () => {
-      const parser = (await UnitTestUtils.getParser(
-        'traces/elapsed_and_real_timestamp/SurfaceFlinger_with_duplicated_ids.pb',
-      )) as Parser<HierarchyTreeNode>;
-      const entry = await parser.getEntry(0);
-      expect(entry.getWarnings()).toEqual([
-        new DuplicateLayerIds([-2147483595]),
-      ]);
-
-      const layer = assertDefined(
-        entry.findDfs(
-          UiTreeUtils.makeIdMatchFilter(
-            '-2147483595 Input Consumer recents_animation_input_consumer#408(Mirror)',
+    describe('handles duplicate ids', () => {
+      it('is robust to duplicated layer ids', async () => {
+        const parser = await new LegacyParserProvider()
+          .addFilename(
+            'traces/elapsed_and_real_timestamp/SurfaceFlinger_with_duplicated_ids.pb',
+          )
+          .setConvertToPerfetto(true)
+          .getParser<HierarchyTreeNode>();
+        const entry = await parser.getEntry(0);
+        expect(entry.getWarnings()).toEqual([
+          new DuplicateLayerIds([-2147483595]),
+        ]);
+
+        const layer = assertDefined(
+          entry.findDfs(
+            UiTreeUtils.makeIdMatchFilter(
+              '-2147483595 Input Consumer recents_animation_input_consumer#408(Mirror)',
+            ),
           ),
-        ),
-      );
-      expect(layer.name).toEqual(
-        'Input Consumer recents_animation_input_consumer#408(Mirror)',
-      );
-      expect(layer.getAllChildren().length).toEqual(0);
+        );
+        expect(layer.name).toEqual(
+          'Input Consumer recents_animation_input_consumer#408(Mirror)',
+        );
+        expect(layer.getAllChildren().length).toEqual(0);
 
-      const dupLayer = assertDefined(
-        entry.findDfs(
-          UiTreeUtils.makeIdMatchFilter(
-            '-2147483595 Input Consumer recents_animation_input_consumer#408(Mirror) duplicate(1)',
+        const dupLayer = assertDefined(
+          entry.findDfs(
+            UiTreeUtils.makeIdMatchFilter(
+              '-2147483595 Input Consumer recents_animation_input_consumer#408(Mirror) duplicate(1)',
+            ),
           ),
-        ),
-      );
+        );
 
-      expect(dupLayer.name).toEqual(
-        'Input Consumer recents_animation_input_consumer#408(Mirror) duplicate(1)',
-      );
-      expect(dupLayer.getAllChildren().length).toEqual(0);
+        expect(dupLayer.name).toEqual(
+          'Input Consumer recents_animation_input_consumer#408(Mirror) duplicate(1)',
+        );
+        expect(dupLayer.getAllChildren().length).toEqual(0);
+      });
     });
   });
 
   describe('trace with only elapsed timestamps', () => {
-    let parser: Parser<HierarchyTreeNode>;
+    let elapsedParser: Parser<HierarchyTreeNode>;
 
     beforeAll(async () => {
-      parser = (await UnitTestUtils.getParser(
-        'traces/elapsed_timestamp/SurfaceFlinger.pb',
-      )) as Parser<HierarchyTreeNode>;
+      elapsedParser = await new LegacyParserProvider()
+        .addFilename('traces/elapsed_timestamp/SurfaceFlinger.pb')
+        .getParser<HierarchyTreeNode>();
     });
 
     it('has expected trace type', () => {
-      expect(parser.getTraceType()).toEqual(TraceType.SURFACE_FLINGER);
+      expect(elapsedParser.getTraceType()).toEqual(TraceType.SURFACE_FLINGER);
     });
 
     it('has expected coarse version', () => {
-      expect(parser.getCoarseVersion()).toEqual(CoarseVersion.LEGACY);
+      expect(elapsedParser.getCoarseVersion()).toEqual(CoarseVersion.LEGACY);
     });
 
     it('provides timestamps', () => {
-      expect(assertDefined(parser.getTimestamps())[0]).toEqual(
+      expect(assertDefined(elapsedParser.getTimestamps())[0]).toEqual(
         TimestampConverterUtils.makeElapsedTimestamp(850335483446n),
       );
     });
 
-    it('provides correct root entry node', async () => {
-      const entry = await parser.getEntry(0);
-      expect(entry.id).toEqual('LayerTraceEntry root');
-      expect(entry.name).toEqual('root');
+    it('converts to valid perfetto packets, without latest offsets', async () => {
+      const packets = elapsedParser.convertToPerfettoPackets!(10);
+      expect(packets.length).toEqual(3);
+      expect(packets[0].trustedPacketSequenceId).toEqual(10);
+      expect(
+        packets[0].surfaceflingerLayersSnapshot?.layers?.layers?.length,
+      ).toEqual(94);
+      expect(packets[0].timestamp).toEqual(
+        Long.fromString(BigInt(850335483446).toString()),
+      );
+      expect(packets[0].timestampClockId).toEqual(
+        perfetto.protos.ClockSnapshot.Clock.BuiltinClocks.MONOTONIC,
+      );
     });
   });
 });
diff --git a/tools/winscope/src/parsers/surface_flinger/operations/add_composition_type.ts b/tools/winscope/src/parsers/surface_flinger/operations/add_composition_type.ts
index 5eca1c18c..02f3f1d24 100644
--- a/tools/winscope/src/parsers/surface_flinger/operations/add_composition_type.ts
+++ b/tools/winscope/src/parsers/surface_flinger/operations/add_composition_type.ts
@@ -14,8 +14,8 @@
  * limitations under the License.
  */
 
-import {perfetto} from 'protos/surfaceflinger/latest/static';
-import {LayerCompositionType} from 'trace/layer_composition_type';
+import {perfetto} from 'protos/perfetto/trace/static';
+import {LayerCompositionType} from 'trace/surface_flinger/layer_composition_type';
 import {AddOperation} from 'trace/tree_node/operations/add_operation';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 import {DEFAULT_PROPERTY_TREE_NODE_FACTORY} from 'trace/tree_node/property_tree_node_factory';
diff --git a/tools/winscope/src/parsers/surface_flinger/operations/add_composition_type_test.ts b/tools/winscope/src/parsers/surface_flinger/operations/add_composition_type_test.ts
index 809c18f43..588cf1dea 100644
--- a/tools/winscope/src/parsers/surface_flinger/operations/add_composition_type_test.ts
+++ b/tools/winscope/src/parsers/surface_flinger/operations/add_composition_type_test.ts
@@ -14,9 +14,9 @@
  * limitations under the License.
  */
 
-import {perfetto} from 'protos/surfaceflinger/latest/static';
+import {perfetto} from 'protos/perfetto/trace/static';
 import {TreeNodeUtils} from 'test/unit/tree_node_utils';
-import {LayerCompositionType} from 'trace/layer_composition_type';
+import {LayerCompositionType} from 'trace/surface_flinger/layer_composition_type';
 import {
   PropertySource,
   PropertyTreeNode,
diff --git a/tools/winscope/src/parsers/surface_flinger/operations/add_display_properties.ts b/tools/winscope/src/parsers/surface_flinger/operations/add_display_properties.ts
index 13779bd47..a5a1bde1d 100644
--- a/tools/winscope/src/parsers/surface_flinger/operations/add_display_properties.ts
+++ b/tools/winscope/src/parsers/surface_flinger/operations/add_display_properties.ts
@@ -15,7 +15,7 @@
  */
 
 import {assertDefined, assertTrue} from 'common/assert_utils';
-import {DisplayLayerStack} from 'trace/display_layer_stack';
+import {DisplayLayerStack} from 'parsers/surface_flinger/operations/display_layer_stack';
 import {Operation} from 'trace/tree_node/operations/operation';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 import {DEFAULT_PROPERTY_TREE_NODE_FACTORY} from 'trace/tree_node/property_tree_node_factory';
diff --git a/tools/winscope/src/parsers/surface_flinger/operations/add_verbose_flags.ts b/tools/winscope/src/parsers/surface_flinger/operations/add_verbose_flags.ts
index 06e58b8c4..20321dc17 100644
--- a/tools/winscope/src/parsers/surface_flinger/operations/add_verbose_flags.ts
+++ b/tools/winscope/src/parsers/surface_flinger/operations/add_verbose_flags.ts
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-import {LayerFlag} from 'parsers/surface_flinger/layer_flag';
+import {LayerFlag} from 'trace/surface_flinger/layer_flag';
 import {formatAsHex} from 'trace/tree_node/formatters';
 import {AddOperation} from 'trace/tree_node/operations/add_operation';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
diff --git a/tools/winscope/src/trace/display_layer_stack.ts b/tools/winscope/src/parsers/surface_flinger/operations/display_layer_stack.ts
similarity index 100%
rename from tools/winscope/src/trace/display_layer_stack.ts
rename to tools/winscope/src/parsers/surface_flinger/operations/display_layer_stack.ts
diff --git a/tools/winscope/src/parsers/surface_flinger/operations/update_transforms.ts b/tools/winscope/src/parsers/surface_flinger/operations/update_transforms.ts
index 0e8cf4e2a..94626f02b 100644
--- a/tools/winscope/src/parsers/surface_flinger/operations/update_transforms.ts
+++ b/tools/winscope/src/parsers/surface_flinger/operations/update_transforms.ts
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-import {Transform} from 'parsers/surface_flinger/transform_utils';
+import {Transform} from 'trace/surface_flinger/transform_utils';
 import {Operation} from 'trace/tree_node/operations/operation';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 import {DEFAULT_PROPERTY_TREE_NODE_FACTORY} from 'trace/tree_node/property_tree_node_factory';
diff --git a/tools/winscope/src/parsers/surface_flinger/operations/update_transforms_test.ts b/tools/winscope/src/parsers/surface_flinger/operations/update_transforms_test.ts
index cf41b3f54..d8dcc0647 100644
--- a/tools/winscope/src/parsers/surface_flinger/operations/update_transforms_test.ts
+++ b/tools/winscope/src/parsers/surface_flinger/operations/update_transforms_test.ts
@@ -15,9 +15,9 @@
  */
 
 import {assertDefined} from 'common/assert_utils';
-import {TransformTypeFlags} from 'parsers/surface_flinger/transform_utils';
 import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
 import {TreeNodeUtils} from 'test/unit/tree_node_utils';
+import {TransformTypeFlags} from 'trace/surface_flinger/transform_utils';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 import {UpdateTransforms} from './update_transforms';
 
diff --git a/tools/winscope/src/parsers/surface_flinger/perfetto/parser_surface_flinger.ts b/tools/winscope/src/parsers/surface_flinger/perfetto/parser_surface_flinger.ts
index b565841c8..bd7d4c232 100644
--- a/tools/winscope/src/parsers/surface_flinger/perfetto/parser_surface_flinger.ts
+++ b/tools/winscope/src/parsers/surface_flinger/perfetto/parser_surface_flinger.ts
@@ -14,7 +14,15 @@
  * limitations under the License.
  */
 
-import {assertDefined, assertTrue} from 'common/assert_utils';
+import {
+  assertBigInt,
+  assertBigIntOrUndefined,
+  assertDefined,
+  assertNumberOrUndefined,
+  assertString,
+  assertStringOrUndefined,
+  assertTrue,
+} from 'common/assert_utils';
 import {ParserTimestampConverter} from 'common/time/timestamp_converter';
 import {AddDefaults} from 'parsers/operations/add_defaults';
 import {SetFormatters} from 'parsers/operations/set_formatters';
@@ -22,13 +30,12 @@ import {TranslateIntDef} from 'parsers/operations/translate_intdef';
 import {AbstractParser} from 'parsers/perfetto/abstract_parser';
 import {FakeProtoBuilder} from 'parsers/perfetto/fake_proto_builder';
 import {FakeProtoTransformer} from 'parsers/perfetto/fake_proto_transformer';
-import {Utils} from 'parsers/perfetto/utils';
+import {queryEntry, queryVsyncId} from 'parsers/perfetto/utils';
 import {DENYLIST_PROPERTIES} from 'parsers/surface_flinger/denylist_properties';
 import {EAGER_PROPERTIES} from 'parsers/surface_flinger/eager_properties';
 import {EntryHierarchyTreeFactory} from 'parsers/surface_flinger/entry_hierarchy_tree_factory';
-import {TamperedMessageType} from 'parsers/tampered_message_type';
-import root from 'protos/surfaceflinger/latest/json';
-import {perfetto} from 'protos/surfaceflinger/latest/static';
+import {TAMPERED_TRACE_PACKET} from 'parsers/tampered_message_type';
+import {perfetto} from 'protos/perfetto/trace/static';
 import {
   CustomQueryParserResultTypeMap,
   CustomQueryType,
@@ -50,12 +57,8 @@ export class ParserSurfaceFlinger extends AbstractParser<HierarchyTreeNode> {
       new EnumFormatter(perfetto.protos.HwcCompositionType),
     ],
   ]);
-
-  private static readonly LayersTraceFileProto = TamperedMessageType.tamper(
-    root.lookupType('perfetto.protos.LayersTraceFileProto'),
-  );
   private static readonly entryField =
-    ParserSurfaceFlinger.LayersTraceFileProto.fields['entry'];
+    TAMPERED_TRACE_PACKET.fields['surfaceflingerLayersSnapshot'];
   private static readonly layerField = assertDefined(
     ParserSurfaceFlinger.entryField.tamperedMessageType?.fields['layers']
       .tamperedMessageType,
@@ -114,7 +117,7 @@ export class ParserSurfaceFlinger extends AbstractParser<HierarchyTreeNode> {
   }
 
   override async getEntry(index: number): Promise<HierarchyTreeNode> {
-    let snapshotProto = await Utils.queryEntry(
+    let snapshotProto = await queryEntry(
       this.traceProcessor,
       this.getTableName(),
       this.entryIndexToRowIdMap,
@@ -127,11 +130,7 @@ export class ParserSurfaceFlinger extends AbstractParser<HierarchyTreeNode> {
       (layerProto) => this.layerProtoTransformer.transform(layerProto),
     );
 
-    return this.factory.makeEntryHierarchyTree(
-      snapshotProto,
-      layerProtos,
-      ParserSurfaceFlinger,
-    );
+    return this.factory.makeEntryHierarchyTree(snapshotProto, layerProtos);
   }
 
   override async customQuery<Q extends CustomQueryType>(
@@ -140,7 +139,7 @@ export class ParserSurfaceFlinger extends AbstractParser<HierarchyTreeNode> {
   ): Promise<CustomQueryParserResultTypeMap[Q]> {
     return new VisitableParserCustomQuery(type)
       .visit(CustomQueryType.VSYNCID, async () => {
-        return Utils.queryVsyncId(
+        return queryVsyncId(
           this.traceProcessor,
           this.getTableName(),
           this.entryIndexToRowIdMap,
@@ -158,11 +157,11 @@ export class ParserSurfaceFlinger extends AbstractParser<HierarchyTreeNode> {
         )
         GROUP BY id;
       `;
-        const queryResult = await this.traceProcessor.queryAllRows(sql);
+        const queryResult = await this.traceProcessor.query(sql);
         const result: CustomQueryParserResultTypeMap[CustomQueryType.SF_LAYERS_ID_AND_NAME] =
           [];
         for (const it = queryResult.iter({}); it.valid(); it.next()) {
-          const idAndName = it.get('id_and_name') as string;
+          const idAndName = assertString(it.get('id_and_name'));
           const indexDelimiter = idAndName.indexOf(',');
           assertTrue(
             indexDelimiter > 0,
@@ -206,16 +205,16 @@ export class ParserSurfaceFlinger extends AbstractParser<HierarchyTreeNode> {
           INNER JOIN args ON sfl.arg_set_id = args.arg_set_id
       WHERE snapshot_id = ${this.entryIndexToRowIdMap[index]};
     `;
-    const result = await this.traceProcessor.queryAllRows(sql);
+    const result = await this.traceProcessor.query(sql);
 
     for (const it = result.iter({}); it.valid(); it.next()) {
-      const builder = getBuilder(it.get('layer_id') as number);
+      const builder = getBuilder(Number(assertBigInt(it.get('layer_id'))));
       builder.addArg(
-        it.get('key') as string,
-        it.get('value_type') as string,
-        it.get('int_value') as bigint | undefined,
-        it.get('real_value') as number | undefined,
-        it.get('string_value') as string | undefined,
+        assertString(it.get('key')),
+        assertString(it.get('value_type')),
+        assertBigIntOrUndefined(it.get('int_value')),
+        assertNumberOrUndefined(it.get('real_value')),
+        assertStringOrUndefined(it.get('string_value')),
       );
     }
 
diff --git a/tools/winscope/src/parsers/surface_flinger/perfetto/parser_surface_flinger_test.ts b/tools/winscope/src/parsers/surface_flinger/perfetto/parser_surface_flinger_test.ts
index 4db6fc17a..e5ad910d1 100644
--- a/tools/winscope/src/parsers/surface_flinger/perfetto/parser_surface_flinger_test.ts
+++ b/tools/winscope/src/parsers/surface_flinger/perfetto/parser_surface_flinger_test.ts
@@ -19,9 +19,9 @@ import {
   timestampEqualityTester,
 } from 'common/time/test_utils';
 import {DuplicateLayerIds} from 'messaging/user_warnings';
+import {getPerfettoParser} from 'test/unit/fixture_utils';
 import {TraceBuilder} from 'test/unit/trace_builder';
 import {UserNotifierChecker} from 'test/unit/user_notifier_checker';
-import {UnitTestUtils} from 'test/unit/utils';
 import {CoarseVersion} from 'trace/coarse_version';
 import {CustomQueryType} from 'trace/custom_query';
 import {Parser} from 'trace/parser';
@@ -30,7 +30,7 @@ import {TraceType} from 'trace/trace_type';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 import {UiTreeUtils} from 'viewers/common/ui_tree_utils';
 
-describe('Perfetto ParserSurfaceFlinger', () => {
+describe('PerfettoParserSurfaceFlinger', () => {
   let userNotifierChecker: UserNotifierChecker;
 
   beforeAll(() => {
@@ -48,7 +48,7 @@ describe('Perfetto ParserSurfaceFlinger', () => {
 
     beforeAll(async () => {
       jasmine.addCustomEqualityTester(timestampEqualityTester);
-      parser = (await UnitTestUtils.getPerfettoParser(
+      parser = (await getPerfettoParser(
         TraceType.SURFACE_FLINGER,
         'traces/perfetto/layers_trace.perfetto-trace',
       )) as Parser<HierarchyTreeNode>;
@@ -155,7 +155,7 @@ describe('Perfetto ParserSurfaceFlinger', () => {
 
   describe('invalid traces', () => {
     it('is robust to duplicated layer ids', async () => {
-      const parser = await UnitTestUtils.getPerfettoParser(
+      const parser = await getPerfettoParser(
         TraceType.SURFACE_FLINGER,
         'traces/perfetto/layers_trace_with_duplicated_ids.perfetto-trace',
       );
diff --git a/tools/winscope/src/parsers/tampered_message_type.ts b/tools/winscope/src/parsers/tampered_message_type.ts
index 75bc0c920..97cafac3c 100644
--- a/tools/winscope/src/parsers/tampered_message_type.ts
+++ b/tools/winscope/src/parsers/tampered_message_type.ts
@@ -16,19 +16,35 @@
 
 import {assertDefined} from 'common/assert_utils';
 import * as protobuf from 'protobufjs';
+import root from 'protos/perfetto/trace/json';
 
 export class TamperedMessageType extends protobuf.Type {
+  override fields: {[k: string]: TamperedProtoField} = {};
+
+  static tamperTracePacket(): TamperedMessageType {
+    const tracePacket = root.lookupType('perfetto.protos.TracePacket');
+    const allowList: string[] = [
+      'surfaceflingerLayersSnapshot',
+      'surfaceflingerTransactions',
+      'shellTransition',
+      'protologMessage',
+      'winscopeExtensions',
+    ];
+    TamperedMessageType.tamperTypeDfs(tracePacket, allowList);
+    return tracePacket as TamperedMessageType;
+  }
+
   static tamper(protoType: protobuf.Type): TamperedMessageType {
     TamperedMessageType.tamperTypeDfs(protoType);
     return protoType as TamperedMessageType;
   }
 
-  override fields: {[k: string]: TamperedProtoField} = {};
-
-  private static tamperTypeDfs(protoType: protobuf.Type) {
+  private static tamperTypeDfs(protoType: protobuf.Type, allowList?: string[]) {
     for (const fieldName of Object.keys(protoType.fields)) {
-      const field = protoType.fields[fieldName];
-      TamperedMessageType.tamperFieldDfs(field);
+      if (!allowList || allowList.includes(fieldName)) {
+        const field = protoType.fields[fieldName];
+        TamperedMessageType.tamperFieldDfs(field);
+      }
     }
   }
 
@@ -70,3 +86,9 @@ export class TamperedProtoField extends protobuf.Field {
   tamperedMessageType: TamperedMessageType | undefined;
   tamperedEnumType: protobuf.Enum | undefined;
 }
+
+export const TAMPERED_TRACE_PACKET = TamperedMessageType.tamperTracePacket();
+
+export const TAMPERED_WINSCOPE_EXTENSIONS = assertDefined(
+  TAMPERED_TRACE_PACKET.fields['winscopeExtensions'].tamperedMessageType,
+);
diff --git a/tools/winscope/src/parsers/traces/abstract_traces_parser.ts b/tools/winscope/src/parsers/traces/abstract_traces_parser.ts
index cba5fbaf1..d2401725f 100644
--- a/tools/winscope/src/parsers/traces/abstract_traces_parser.ts
+++ b/tools/winscope/src/parsers/traces/abstract_traces_parser.ts
@@ -14,6 +14,7 @@
  * limitations under the License.
  */
 
+import {NOT_IMPLEMENTED_ERROR} from 'common/errors';
 import {Timestamp} from 'common/time/time';
 import {ParserTimestampConverter} from 'common/time/timestamp_converter';
 import {CoarseVersion} from 'trace/coarse_version';
@@ -37,13 +38,17 @@ export abstract class AbstractTracesParser<T> implements Parser<T> {
     type: Q,
     entriesRange: EntriesRange,
   ): Promise<CustomQueryParserResultTypeMap[Q]> {
-    throw new Error('Not implemented');
+    throw NOT_IMPLEMENTED_ERROR;
   }
 
   getTimestamps(): Timestamp[] | undefined {
     return this.timestamps;
   }
 
+  canConvertToPerfetto(): boolean {
+    return false;
+  }
+
   abstract getCoarseVersion(): CoarseVersion;
   abstract parse(): Promise<void>;
   abstract createTimestamps(): Promise<void>;
diff --git a/tools/winscope/src/parsers/transactions/legacy/parser_transactions.ts b/tools/winscope/src/parsers/transactions/legacy/parser_transactions.ts
index e80cd6398..26edbeb04 100644
--- a/tools/winscope/src/parsers/transactions/legacy/parser_transactions.ts
+++ b/tools/winscope/src/parsers/transactions/legacy/parser_transactions.ts
@@ -17,25 +17,15 @@
 import {assertDefined} from 'common/assert_utils';
 import {Timestamp} from 'common/time/time';
 import {AbstractParser} from 'parsers/legacy/abstract_parser';
-import {AddDefaults} from 'parsers/operations/add_defaults';
-import {SetFormatters} from 'parsers/operations/set_formatters';
-import {TamperedMessageType} from 'parsers/tampered_message_type';
-import {TranslateChanges} from 'parsers/transactions/operations/translate_changes';
+import {perfetto} from 'protos/perfetto/trace/static';
 import root from 'protos/transactions/udc/json';
 import {android} from 'protos/transactions/udc/static';
-import {
-  CustomQueryParserResultTypeMap,
-  CustomQueryType,
-  VisitableParserCustomQuery,
-} from 'trace/custom_query';
-import {EntriesRange} from 'trace/trace';
 import {TraceType} from 'trace/trace_type';
-import {PropertyTreeBuilderFromProto} from 'trace/tree_node/property_tree_builder_from_proto';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 
 type TraceEntryProto = android.surfaceflinger.proto.ITransactionTraceEntry;
 
-class ParserTransactions extends AbstractParser<
+export class ParserTransactions extends AbstractParser<
   PropertyTreeNode,
   TraceEntryProto
 > {
@@ -43,18 +33,9 @@ class ParserTransactions extends AbstractParser<
     0x09, 0x54, 0x4e, 0x58, 0x54, 0x52, 0x41, 0x43, 0x45,
   ]; // .TNXTRACE
 
-  private static readonly TransactionsTraceFileProto =
-    TamperedMessageType.tamper(
-      root.lookupType('android.surfaceflinger.TransactionTraceFile'),
-    );
-  private static readonly TransactionsTraceEntryField =
-    ParserTransactions.TransactionsTraceFileProto.fields['entry'];
-
-  private static readonly OPERATIONS = [
-    new AddDefaults(ParserTransactions.TransactionsTraceEntryField),
-    new SetFormatters(ParserTransactions.TransactionsTraceEntryField),
-    new TranslateChanges(),
-  ];
+  private static readonly TransactionsTraceFileProto = root.lookupType(
+    'android.surfaceflinger.TransactionTraceFile',
+  );
 
   private realToMonotonicTimeOffsetNs: bigint | undefined;
 
@@ -88,46 +69,30 @@ class ParserTransactions extends AbstractParser<
     return decodedProto.entry ?? [];
   }
 
-  protected override getTimestamp(entryProto: TraceEntryProto): Timestamp {
-    return this.timestampConverter.makeTimestampFromMonotonicNs(
-      BigInt(assertDefined(entryProto.elapsedRealtimeNanos).toString()),
-    );
-  }
-
-  override processDecodedEntry(
-    index: number,
-    entryProto: TraceEntryProto,
-  ): PropertyTreeNode {
-    return this.makePropertiesTree(entryProto);
+  override canConvertToPerfetto(): boolean {
+    return true;
   }
 
-  override customQuery<Q extends CustomQueryType>(
-    type: Q,
-    entriesRange: EntriesRange,
-  ): Promise<CustomQueryParserResultTypeMap[Q]> {
-    return new VisitableParserCustomQuery(type)
-      .visit(CustomQueryType.VSYNCID, async () => {
-        return this.decodedEntries
-          .slice(entriesRange.start, entriesRange.end)
-          .map((entry) => {
-            return BigInt(assertDefined(entry.vsyncId?.toString())); // convert Long to bigint
-          });
-      })
-      .getResult();
+  override convertToPerfettoPackets(
+    sequenceId: number,
+  ): perfetto.protos.TracePacket[] {
+    const packets = [];
+    for (const entry of this.decodedEntries) {
+      const packet = perfetto.protos.TracePacket.create();
+      packet.timestamp = assertDefined(entry.elapsedRealtimeNanos);
+      packet.timestampClockId =
+        perfetto.protos.ClockSnapshot.Clock.BuiltinClocks.MONOTONIC;
+      packet.trustedPacketSequenceId = sequenceId;
+      packet.surfaceflingerTransactions =
+        perfetto.protos.TransactionTraceEntry.fromObject(entry);
+      packets.push(packet);
+    }
+    return packets;
   }
 
-  private makePropertiesTree(entryProto: TraceEntryProto): PropertyTreeNode {
-    const tree = new PropertyTreeBuilderFromProto()
-      .setData(entryProto)
-      .setRootId('TransactionsTraceEntry')
-      .setRootName('entry')
-      .build();
-
-    ParserTransactions.OPERATIONS.forEach((operation) => {
-      operation.apply(tree);
-    });
-    return tree;
+  protected override getTimestamp(entryProto: TraceEntryProto): Timestamp {
+    return this.timestampConverter.makeTimestampFromMonotonicNs(
+      BigInt(assertDefined(entryProto.elapsedRealtimeNanos).toString()),
+    );
   }
 }
-
-export {ParserTransactions};
diff --git a/tools/winscope/src/parsers/transactions/legacy/parser_transactions_test.ts b/tools/winscope/src/parsers/transactions/legacy/parser_transactions_test.ts
index 01f51a4f5..d83f68527 100644
--- a/tools/winscope/src/parsers/transactions/legacy/parser_transactions_test.ts
+++ b/tools/winscope/src/parsers/transactions/legacy/parser_transactions_test.ts
@@ -18,23 +18,25 @@ import {
   TimestampConverterUtils,
   timestampEqualityTester,
 } from 'common/time/test_utils';
+import Long from 'long';
+import {perfetto} from 'protos/perfetto/trace/static';
+import {LegacyParserProvider} from 'test/unit/fixture_utils';
 import {TraceBuilder} from 'test/unit/trace_builder';
-import {UnitTestUtils} from 'test/unit/utils';
 import {CoarseVersion} from 'trace/coarse_version';
 import {CustomQueryType} from 'trace/custom_query';
 import {Parser} from 'trace/parser';
 import {TraceType} from 'trace/trace_type';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
+import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 
 describe('ParserTransactions', () => {
   describe('trace with real timestamps', () => {
-    let parser: Parser<PropertyTreeNode>;
+    let parser: Parser<HierarchyTreeNode>;
 
     beforeAll(async () => {
       jasmine.addCustomEqualityTester(timestampEqualityTester);
-      parser = (await UnitTestUtils.getParser(
-        'traces/elapsed_and_real_timestamp/Transactions.pb',
-      )) as Parser<PropertyTreeNode>;
+      parser = await new LegacyParserProvider()
+        .addFilename('traces/elapsed_and_real_timestamp/Transactions.pb')
+        .getParser<HierarchyTreeNode>();
     });
 
     it('has expected trace type', () => {
@@ -58,75 +60,98 @@ describe('ParserTransactions', () => {
       expect(timestamps.slice(0, 3)).toEqual(expected);
     });
 
-    it('retrieves trace entry from timestamp', async () => {
-      const entry = await parser.getEntry(1);
-      expect(entry.id).toEqual('TransactionsTraceEntry entry');
+    it('does not provide entry', () => {
+      expect(parser.getEntry).toThrow();
     });
 
-    it("decodes 'what' field in proto", async () => {
-      {
-        const entry = await parser.getEntry(0);
-        const transactions = assertDefined(
-          entry.getChildByName('transactions'),
-        );
-
-        expect(
-          transactions
-            .getChildByName('0')
-            ?.getChildByName('layerChanges')
-            ?.getChildByName('0')
-            ?.getChildByName('what')
-            ?.formattedValue(),
-        ).toEqual('eLayerChanged');
-
-        expect(
-          transactions
-            .getChildByName('1')
-            ?.getChildByName('layerChanges')
-            ?.getChildByName('0')
-            ?.getChildByName('what')
-            ?.formattedValue(),
-        ).toEqual('eFlagsChanged | eDestinationFrameChanged');
-      }
-      {
-        const entry = await parser.getEntry(222);
-        const transactions = assertDefined(
-          entry.getChildByName('transactions'),
-        );
-
-        expect(
-          transactions
-            .getChildByName('1')
-            ?.getChildByName('displayChanges')
-            ?.getChildByName('0')
-            ?.getChildByName('what')
-            ?.formattedValue(),
-        ).toEqual(
-          'eLayerStackChanged | eDisplayProjectionChanged | eFlagsChanged',
-        );
-      }
+    it('converts to valid perfetto packets', async () => {
+      const packets = parser.convertToPerfettoPackets!(10);
+      expect(packets.length).toEqual(712);
+      expect(packets[0].trustedPacketSequenceId).toEqual(10);
+      expect(
+        packets[0].surfaceflingerTransactions?.transactions?.length,
+      ).toEqual(2);
+      expect(packets[0].timestamp).toEqual(
+        Long.fromString(BigInt(2450981445).toString()),
+      );
+      expect(packets[0].timestampClockId).toEqual(
+        perfetto.protos.ClockSnapshot.Clock.BuiltinClocks.MONOTONIC,
+      );
     });
 
-    it('supports VSYNCID custom query', async () => {
-      const trace = new TraceBuilder()
-        .setType(TraceType.TRANSACTIONS)
-        .setParser(parser)
-        .build();
-      const entries = await trace
-        .sliceEntries(0, 3)
-        .customQuery(CustomQueryType.VSYNCID);
-      const values = entries.map((entry) => entry.getValue());
-      expect(values).toEqual([1n, 2n, 3n]);
+    describe('converts to valid perfetto trace', () => {
+      let perfettoParser: Parser<HierarchyTreeNode>;
+
+      beforeAll(async () => {
+        perfettoParser = await new LegacyParserProvider()
+          .addFilename('traces/elapsed_and_real_timestamp/Transactions.pb')
+          .setConvertToPerfetto(true)
+          .getParser<HierarchyTreeNode>();
+      });
+
+      it('provides timestamps', () => {
+        const timestamps = assertDefined(perfettoParser.getTimestamps());
+
+        expect(timestamps.length).toEqual(712);
+
+        const expected = [
+          TimestampConverterUtils.makeRealTimestamp(1659507541051480997n),
+          TimestampConverterUtils.makeRealTimestamp(1659507541118452067n),
+          TimestampConverterUtils.makeRealTimestamp(1659507542621651001n),
+        ];
+        expect(timestamps.slice(0, 3)).toEqual(expected);
+      });
+
+      it("decodes 'what' field in proto", async () => {
+        {
+          const entry = await perfettoParser.getEntry(0);
+          const [transaction0, transaction1] = await Promise.all(
+            entry
+              .getAllChildren()
+              .slice(0, 2)
+              .map((child) => child.getAllProperties()),
+          );
+          expect(transaction0.getChildByName('what')?.formattedValue()).toEqual(
+            'eLayerChanged',
+          );
+
+          expect(
+            transaction1?.getChildByName('what')?.formattedValue(),
+          ).toEqual('eFlagsChanged | eDestinationFrameChanged');
+        }
+        {
+          // translates upper and lower bits
+          const entry = await perfettoParser.getEntry(222);
+          const transaction = await entry
+            .getAllChildren()[42]
+            .getAllProperties();
+          expect(transaction.getChildByName('what')?.formattedValue()).toEqual(
+            'eLayerStackChanged | eDisplayProjectionChanged | eFlagsChanged',
+          );
+        }
+      });
+
+      it('supports VSYNCID custom query', async () => {
+        const trace = new TraceBuilder()
+          .setType(TraceType.TRANSACTIONS)
+          .setParser(perfettoParser)
+          .build();
+        const entries = await trace
+          .sliceEntries(0, 3)
+          .customQuery(CustomQueryType.VSYNCID);
+        const values = entries.map((entry) => entry.getValue());
+        expect(values).toEqual([1n, 2n, 3n]);
+      });
     });
   });
 
   describe('trace with only elapsed timestamps', () => {
-    let parser: Parser<PropertyTreeNode>;
+    let parser: Parser<HierarchyTreeNode>;
 
     beforeAll(async () => {
-      parser = (await UnitTestUtils.getParser(
-        'traces/elapsed_timestamp/Transactions.pb',
-      )) as Parser<PropertyTreeNode>;
+      parser = await new LegacyParserProvider()
+        .addFilename('traces/elapsed_timestamp/Transactions.pb')
+        .getParser<HierarchyTreeNode>();
     });
 
     it('has expected trace type', () => {
@@ -145,5 +170,20 @@ describe('ParserTransactions', () => {
       ];
       expect(timestamps.slice(0, 3)).toEqual(expected);
     });
+
+    it('converts to valid perfetto packets', async () => {
+      const packets = parser.convertToPerfettoPackets!(10);
+      expect(packets.length).toEqual(4997);
+      expect(packets[0].trustedPacketSequenceId).toEqual(10);
+      expect(
+        packets[0].surfaceflingerTransactions?.transactions?.length,
+      ).toEqual(1);
+      expect(packets[0].timestamp).toEqual(
+        Long.fromString(BigInt(14862317023).toString()),
+      );
+      expect(packets[0].timestampClockId).toEqual(
+        perfetto.protos.ClockSnapshot.Clock.BuiltinClocks.MONOTONIC,
+      );
+    });
   });
 });
diff --git a/tools/winscope/src/parsers/transactions/operations/translate_changes.ts b/tools/winscope/src/parsers/transactions/operations/translate_changes.ts
deleted file mode 100644
index c7ac758b7..000000000
--- a/tools/winscope/src/parsers/transactions/operations/translate_changes.ts
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import {assertDefined} from 'common/assert_utils';
-import {android} from 'protos/transactions/udc/static';
-import {FixedStringFormatter} from 'trace/tree_node/formatters';
-import {Operation} from 'trace/tree_node/operations/operation';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
-
-export class TranslateChanges implements Operation<PropertyTreeNode> {
-  apply(value: PropertyTreeNode): void {
-    value
-      .getChildByName('transactions')
-      ?.getAllChildren()
-      .forEach((transactionState) => {
-        transactionState
-          .getChildByName('layerChanges')
-          ?.getAllChildren()
-          .forEach((layerState) => {
-            this.translateLayerChanges(layerState);
-          });
-
-        transactionState
-          .getChildByName('displayChanges')
-          ?.getAllChildren()
-          .forEach((displayState) => {
-            this.translateDisplayChanges(displayState);
-          });
-      });
-
-    value
-      .getChildByName('addedDisplays')
-      ?.getAllChildren()
-      .forEach((displayState) => {
-        this.translateDisplayChanges(displayState);
-      });
-  }
-
-  private translateLayerChanges(layerState: PropertyTreeNode) {
-    const what = assertDefined(layerState.getChildByName('what'));
-
-    const originalValue = what.getValue();
-    let translation: string = '';
-
-    if (originalValue.low !== undefined && originalValue.high !== undefined) {
-      translation = this.concatBitsetTokens(
-        this.decodeBitset32(
-          originalValue.low,
-          android.surfaceflinger.proto.LayerState.ChangesLsb,
-        ).concat(
-          this.decodeBitset32(
-            originalValue.high,
-            android.surfaceflinger.proto.LayerState.ChangesMsb,
-          ),
-        ),
-      );
-    } else {
-      const bigintValue = BigInt(originalValue?.toString() ?? 0n);
-      translation = this.concatBitsetTokens(
-        this.decodeBitset32(
-          Number(bigintValue),
-          android.surfaceflinger.proto.LayerState.ChangesLsb,
-        ).concat(
-          this.decodeBitset32(
-            Number(bigintValue >> 32n),
-            android.surfaceflinger.proto.LayerState.ChangesMsb,
-          ),
-        ),
-      );
-    }
-
-    what.setFormatter(new FixedStringFormatter(translation));
-  }
-
-  private translateDisplayChanges(displayState: PropertyTreeNode) {
-    const what = assertDefined(displayState.getChildByName('what'));
-    const originalValue = what.getValue();
-
-    const translation = this.concatBitsetTokens(
-      this.decodeBitset32(
-        Number(originalValue),
-        android.surfaceflinger.proto.DisplayState.Changes,
-      ),
-    );
-
-    what.setFormatter(new FixedStringFormatter(translation));
-  }
-
-  private decodeBitset32(
-    bitset: number,
-    EnumProto: {[key: number]: string},
-  ): string[] {
-    const changes = Object.values(EnumProto)
-      .filter((key) => {
-        if (Number.isNaN(Number(key))) {
-          return false;
-        }
-        return (bitset & Number(key)) !== 0;
-      })
-      .map((key) => EnumProto[Number(key)]);
-    return changes;
-  }
-
-  private concatBitsetTokens(tokens: string[]): string {
-    if (tokens.length === 0) {
-      return '0';
-    }
-    return tokens.join(' | ');
-  }
-}
diff --git a/tools/winscope/src/parsers/transactions/operations/translate_changes_test.ts b/tools/winscope/src/parsers/transactions/operations/translate_changes_test.ts
deleted file mode 100644
index ee2585d97..000000000
--- a/tools/winscope/src/parsers/transactions/operations/translate_changes_test.ts
+++ /dev/null
@@ -1,166 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import {assertDefined} from 'common/assert_utils';
-import {MockLong} from 'test/unit/mock_long';
-import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
-import {TranslateChanges} from './translate_changes';
-
-describe('TranslateChanges', () => {
-  let operation: TranslateChanges;
-
-  beforeEach(() => {
-    operation = new TranslateChanges();
-  });
-
-  it("decodes 'what' field in LayerState from layerChanges", async () => {
-    const propertyRoot = new PropertyTreeBuilder()
-      .setRootId('TransactionsTraceEntry')
-      .setName('entry')
-      .setIsRoot(true)
-      .setChildren([
-        {
-          name: 'transactions',
-          children: [
-            {
-              name: '0',
-              children: [
-                {
-                  name: 'layerChanges',
-                  children: [
-                    {name: '0', children: [{name: 'what', value: 2}]},
-                    {
-                      name: '1',
-                      children: [{name: 'what', value: new MockLong(2, 0)}],
-                    },
-                    {name: '2', children: [{name: 'what', value: 4294967360}]},
-                    {
-                      name: '3',
-                      children: [{name: 'what', value: new MockLong(64, 1)}],
-                    },
-                  ],
-                },
-              ],
-            },
-          ],
-        },
-      ])
-      .build();
-
-    operation.apply(propertyRoot);
-
-    const layerChanges = assertDefined(
-      propertyRoot
-        .getChildByName('transactions')
-        ?.getChildByName('0')
-        ?.getChildByName('layerChanges'),
-    );
-
-    expect(
-      layerChanges
-        ?.getChildByName('0')
-        ?.getChildByName('what')
-        ?.formattedValue(),
-    ).toEqual('eLayerChanged');
-
-    expect(
-      layerChanges
-        ?.getChildByName('1')
-        ?.getChildByName('what')
-        ?.formattedValue(),
-    ).toEqual('eLayerChanged');
-
-    expect(
-      layerChanges
-        ?.getChildByName('2')
-        ?.getChildByName('what')
-        ?.formattedValue(),
-    ).toEqual('eFlagsChanged | eDestinationFrameChanged');
-
-    expect(
-      layerChanges
-        ?.getChildByName('3')
-        ?.getChildByName('what')
-        ?.formattedValue(),
-    ).toEqual('eFlagsChanged | eDestinationFrameChanged');
-  });
-
-  it("decodes 'what' field in DisplayState from displayChanges", async () => {
-    const propertyRoot = new PropertyTreeBuilder()
-      .setRootId('TransactionsTraceEntry')
-      .setName('entry')
-      .setIsRoot(true)
-      .setChildren([
-        {
-          name: 'transactions',
-          children: [
-            {
-              name: '0',
-              children: [
-                {
-                  name: 'displayChanges',
-                  children: [
-                    {name: '0', children: [{name: 'what', value: 22}]},
-                  ],
-                },
-              ],
-            },
-          ],
-        },
-      ])
-      .build();
-
-    operation.apply(propertyRoot);
-
-    const displayChanges = assertDefined(
-      propertyRoot
-        .getChildByName('transactions')
-        ?.getChildByName('0')
-        ?.getChildByName('displayChanges'),
-    );
-
-    expect(
-      displayChanges
-        ?.getChildByName('0')
-        ?.getChildByName('what')
-        ?.formattedValue(),
-    ).toEqual('eLayerStackChanged | eDisplayProjectionChanged | eFlagsChanged');
-  });
-
-  it("decodes 'what' field in DisplayState from addedDisplays", async () => {
-    const propertyRoot = new PropertyTreeBuilder()
-      .setRootId('TransactionsTraceEntry')
-      .setName('entry')
-      .setIsRoot(true)
-      .setChildren([
-        {
-          name: 'addedDisplays',
-          children: [{name: '0', children: [{name: 'what', value: 22}]}],
-        },
-      ])
-      .build();
-
-    operation.apply(propertyRoot);
-
-    expect(
-      propertyRoot
-        .getChildByName('addedDisplays')
-        ?.getChildByName('0')
-        ?.getChildByName('what')
-        ?.formattedValue(),
-    ).toEqual('eLayerStackChanged | eDisplayProjectionChanged | eFlagsChanged');
-  });
-});
diff --git a/tools/winscope/src/parsers/transactions/perfetto/parser_transactions.ts b/tools/winscope/src/parsers/transactions/perfetto/parser_transactions.ts
index eb636f315..87355bb7b 100644
--- a/tools/winscope/src/parsers/transactions/perfetto/parser_transactions.ts
+++ b/tools/winscope/src/parsers/transactions/perfetto/parser_transactions.ts
@@ -14,18 +14,27 @@
  * limitations under the License.
  */
 
-import {assertDefined} from 'common/assert_utils';
+import {assertBigInt, assertDefined, assertString} from 'common/assert_utils';
 import {ParserTimestampConverter} from 'common/time/timestamp_converter';
+import {HierarchyTreeBuilderLog} from 'parsers/hierarchy_tree_builder_log';
 import {AddDefaults} from 'parsers/operations/add_defaults';
 import {SetFormatters} from 'parsers/operations/set_formatters';
 import {AbstractParser} from 'parsers/perfetto/abstract_parser';
 import {FakeProtoTransformer} from 'parsers/perfetto/fake_proto_transformer';
-import {Utils} from 'parsers/perfetto/utils';
-import {TamperedMessageType} from 'parsers/tampered_message_type';
-import {TranslateChanges} from 'parsers/transactions/operations/translate_changes';
-import root from 'protos/transactions/latest/json';
-import {perfetto} from 'protos/transactions/latest/static';
 import {
+  getDistinctValues,
+  queryArgs,
+  queryVsyncId,
+} from 'parsers/perfetto/utils';
+import {PropertyTreeBuilderFromProto} from 'parsers/property_tree_builder_from_proto';
+import {PropertyTreeBuilderFromQueryRow} from 'parsers/property_tree_builder_from_query_row';
+import {
+  TamperedProtoField,
+  TAMPERED_TRACE_PACKET,
+} from 'parsers/tampered_message_type';
+import {perfetto} from 'protos/perfetto/trace/static';
+import {
+  CustomQueryParamTypeMap,
   CustomQueryParserResultTypeMap,
   CustomQueryType,
   VisitableParserCustomQuery,
@@ -33,25 +42,26 @@ import {
 import {EntriesRange} from 'trace/index_types';
 import {TraceFile} from 'trace/trace_file';
 import {TraceType} from 'trace/trace_type';
-import {PropertyTreeBuilderFromProto} from 'trace/tree_node/property_tree_builder_from_proto';
+import {TransactionColumnType} from 'trace/transactions/transaction_column_type';
+import {TransactionType} from 'trace/transactions/transaction_type';
+import {
+  EnumFormatter,
+  FixedStringFormatter,
+  PropertyFormatter,
+} from 'trace/tree_node/formatters';
+import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
+import {Operation} from 'trace/tree_node/operations/operation';
+import {PropertiesProvider} from 'trace/tree_node/properties_provider';
+import {PropertiesProviderBuilder} from 'trace/tree_node/properties_provider_builder';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
+import {QueryResult, Row, RowIteratorBase} from 'trace_processor/query_result';
 import {TraceProcessor} from 'trace_processor/trace_processor';
 
-export class ParserTransactions extends AbstractParser<PropertyTreeNode> {
-  private static readonly TransactionsTraceFileProto =
-    TamperedMessageType.tamper(
-      root.lookupType('perfetto.protos.TransactionTraceFile'),
-    );
+export class ParserTransactions extends AbstractParser<HierarchyTreeNode> {
   private static readonly TransactionsTraceEntryField =
-    ParserTransactions.TransactionsTraceFileProto.fields['entry'];
+    TAMPERED_TRACE_PACKET.fields['surfaceflingerTransactions'];
 
-  private static readonly OPERATIONS = [
-    new AddDefaults(ParserTransactions.TransactionsTraceEntryField),
-    new SetFormatters(ParserTransactions.TransactionsTraceEntryField),
-    new TranslateChanges(),
-  ];
-
-  private protoTransformer: FakeProtoTransformer;
+  private flags: {[key: number]: string} | undefined;
 
   constructor(
     traceFile: TraceFile,
@@ -59,61 +69,338 @@ export class ParserTransactions extends AbstractParser<PropertyTreeNode> {
     timestampConverter: ParserTimestampConverter,
   ) {
     super(traceFile, traceProcessor, timestampConverter);
-
-    this.protoTransformer = new FakeProtoTransformer(
-      assertDefined(
-        ParserTransactions.TransactionsTraceEntryField.tamperedMessageType,
-      ),
-    );
   }
 
   override getTraceType(): TraceType {
     return TraceType.TRANSACTIONS;
   }
 
-  override async getEntry(index: number): Promise<PropertyTreeNode> {
-    let entryProto = await Utils.queryEntry(
-      this.traceProcessor,
-      this.getTableName(),
-      this.entryIndexToRowIdMap,
-      index,
-    );
-    entryProto = this.protoTransformer.transform(entryProto);
-    return this.makePropertiesTree(entryProto);
-  }
+  override async getEntry(index: number): Promise<HierarchyTreeNode> {
+    const sql = `SELECT
+      sft.transaction_id,
+      sft.pid,
+      sft.uid,
+      sft.process_name,
+      sft.layer_id,
+      sft.display_id,
+      sft.flags_id,
+      sft.transaction_type,
+      sft.arg_set_id,
+      sfs.vsync_id
+    FROM __transaction_with_process AS sft
+    INNER JOIN surfaceflinger_transactions AS sfs
+      ON sfs.id = ${this.entryIndexToRowIdMap[index]}
+      AND sfs.id = sft.snapshot_id`;
 
-  protected override getTableName(): string {
-    return 'surfaceflinger_transactions';
+    const queryResult = await this.traceProcessor.query(sql);
+
+    if (this.flags === undefined) {
+      const flags = await this.queryFlags();
+      this.flags = {};
+      flags.forEach(
+        (flags, flagId) => (assertDefined(this.flags)[flagId] = flags),
+      );
+    }
+
+    return this.makeHierarchyTree(queryResult);
   }
 
   override async customQuery<Q extends CustomQueryType>(
     type: Q,
     entriesRange: EntriesRange,
+    param?: CustomQueryParamTypeMap[Q],
   ): Promise<CustomQueryParserResultTypeMap[Q]> {
     return new VisitableParserCustomQuery(type)
       .visit(CustomQueryType.VSYNCID, async () => {
-        return Utils.queryVsyncId(
+        return queryVsyncId(
           this.traceProcessor,
           this.getTableName(),
           this.entryIndexToRowIdMap,
           entriesRange,
+          ParserTransactions.createVsyncIdQuery,
         );
       })
+      .visit(CustomQueryType.LOG_TABLE_FILTER_VALUES, async () => {
+        let tableName = this.getTransactionTableName();
+        let columns: string[];
+        switch (param) {
+          case TransactionColumnType.TRANSACTION_ID:
+            columns = ['transaction_id'];
+            break;
+          case TransactionColumnType.VSYNC_ID:
+            tableName = this.getTableName();
+            columns = ['vsync_id'];
+            break;
+          case TransactionColumnType.PID:
+            columns = ['pid'];
+            break;
+          case TransactionColumnType.UID:
+            columns = ['uid'];
+            break;
+          case TransactionColumnType.PROCESS:
+            columns = ['process_name'];
+            break;
+          case TransactionColumnType.TRANSACTION_TYPE:
+            columns = ['transaction_type'];
+            break;
+          case TransactionColumnType.LAYER_OR_DISPLAY_ID:
+            columns = ['layer_id', 'display_id'];
+            break;
+          case TransactionColumnType.FLAGS:
+            tableName = this.getFlagTableName();
+            columns = ['flag'];
+            break;
+
+          default:
+            throw new Error('unexpected transaction column type requested');
+        }
+        return getDistinctValues(this.traceProcessor, tableName, columns);
+      })
       .getResult();
   }
 
-  private makePropertiesTree(
-    entryProto: perfetto.protos.TransactionTraceEntry,
-  ): PropertyTreeNode {
-    const tree = new PropertyTreeBuilderFromProto()
-      .setData(entryProto)
+  protected override async preProcessTrace(): Promise<void> {
+    const sql = `
+CREATE PERFETTO TABLE ${this.getTransactionTableName()} AS
+  WITH process_matches AS (
+  SELECT
+      sft.id as row_id,
+      processes.name AS process_name,
+      0 AS match_priority
+  FROM __intrinsic_surfaceflinger_transaction AS sft
+  INNER JOIN process AS processes
+      ON sft.pid = processes.pid AND sft.uid = processes.uid
+  WHERE
+      (sft.pid IS NOT NULL AND sft.pid != 0)
+      AND (sft.uid IS NOT NULL AND sft.uid != 0)
+
+  UNION ALL
+
+  SELECT
+      sft.id as row_id,
+      processes.name AS process_name,
+      1 AS match_priority
+  FROM __intrinsic_surfaceflinger_transaction AS sft
+  INNER JOIN process AS processes
+      ON sft.pid = processes.pid
+  WHERE
+      (sft.uid IS NULL OR sft.uid = 0)
+      AND (sft.pid IS NOT NULL AND sft.pid != 0)
+
+  UNION ALL
+
+  SELECT
+      sft.id as row_id,
+      processes.name AS process_name,
+      2 AS match_priority
+  FROM __intrinsic_surfaceflinger_transaction AS sft
+  INNER JOIN process AS processes
+      ON sft.uid = processes.uid
+  WHERE
+      (sft.pid IS NULL OR sft.pid = 0)
+      AND (sft.uid IS NOT NULL AND sft.uid != 0)
+),
+ranked_process_matches AS (
+    SELECT
+        row_id,
+        process_name,
+        match_priority,
+        COUNT(*) OVER (PARTITION BY row_id, match_priority) as num_matches_at_priority,
+        ROW_NUMBER() OVER (PARTITION BY row_id ORDER BY match_priority ASC) as row_number
+    FROM process_matches
+)
+SELECT
+    sft.snapshot_id,
+    sft.transaction_id,
+    sft.pid,
+    sft.uid,
+    CASE
+        WHEN rpm.num_matches_at_priority > 1 THEN NULL
+        ELSE rpm.process_name
+    END AS process_name,
+    sft.layer_id,
+    sft.display_id,
+    sft.flags_id,
+    sft.transaction_type,
+    sft.arg_set_id
+FROM __intrinsic_surfaceflinger_transaction AS sft
+LEFT JOIN ranked_process_matches AS rpm
+    ON sft.id = rpm.row_id AND rpm.row_number = 1;`;
+    await this.traceProcessor.query(sql);
+  }
+
+  protected override getTableName(): string {
+    return 'surfaceflinger_transactions';
+  }
+
+  private getTransactionTableName(): string {
+    return '__transaction_with_process';
+  }
+
+  private getFlagTableName(): string {
+    return '__intrinsic_surfaceflinger_transaction_flag';
+  }
+
+  private makeHierarchyTree(result: QueryResult): HierarchyTreeNode {
+    const vsyncId =
+      result.numRows() > 0 ? result.firstRow<Row>({})['vsync_id'] : undefined;
+    const entryProperties = new PropertyTreeBuilderFromProto()
+      .setData({vsyncId})
       .setRootId('TransactionsTraceEntry')
       .setRootName('entry')
       .build();
+    const entry = new PropertiesProviderBuilder()
+      .setEagerProperties(entryProperties)
+      .build();
+
+    const transactions: PropertiesProvider[] = [];
+    const columns = [
+      'transaction_id',
+      'pid',
+      'uid',
+      'process_name',
+      'layer_id',
+      'display_id',
+      'flags_id',
+      'transaction_type',
+    ];
+
+    for (const it = result.iter({}); it.valid(); it.next()) {
+      transactions.push(
+        this.makeTransactionPropertiesProvider(
+          it,
+          columns,
+          transactions.length,
+        ),
+      );
+    }
+
+    return new HierarchyTreeBuilderLog()
+      .setRoot(entry)
+      .setChildren(transactions)
+      .build();
+  }
+
+  private makeTransactionPropertiesProvider(
+    row: RowIteratorBase,
+    columns: string[],
+    index: number,
+  ): PropertiesProvider {
+    const argSetId = row.get('arg_set_id') ?? undefined;
+
+    let field: TamperedProtoField | undefined;
+    const transactionType = assertString(row.get('transaction_type'));
+    const entryProtoType = assertDefined(
+      ParserTransactions.TransactionsTraceEntryField.tamperedMessageType,
+    );
+    switch (transactionType) {
+      case TransactionType.DISPLAY_ADDED:
+      case TransactionType.DISPLAY_CHANGED:
+        field = entryProtoType.fields['addedDisplays'];
+        break;
+      case TransactionType.LAYER_ADDED:
+        field = entryProtoType.fields['addedLayers'];
+        break;
+      case TransactionType.LAYER_CHANGED:
+        field = assertDefined(
+          entryProtoType.fields['transactions']?.tamperedMessageType?.fields[
+            'layerChanges'
+          ],
+        );
+        break;
+      default:
+        if (argSetId !== undefined) {
+          throw new Error('unexpected transaction type found with arg set id');
+        }
+    }
+
+    const eagerProperties = new PropertyTreeBuilderFromQueryRow()
+      .setData(row)
+      .setColumns(columns)
+      .setRootId(index)
+      .setRootName(field?.type ?? transactionType)
+      .build();
+
+    const flagsIdFormatter = new EnumFormatter(assertDefined(this.flags));
+    const builder = new PropertiesProviderBuilder()
+      .setEagerProperties(eagerProperties)
+      .setEagerOperations([
+        new SetFormatters(
+          undefined,
+          new Map<string, PropertyFormatter>([['flagsId', flagsIdFormatter]]),
+        ),
+      ]);
+
+    if (argSetId !== undefined && field !== undefined) {
+      const customFormatters = new Map<string, PropertyFormatter>([
+        ['flags', new EnumFormatter(perfetto.protos.LayerState.Flags)],
+      ]);
+      const flagsId = eagerProperties.getChildByName('flagsId');
+      if (flagsId !== undefined) {
+        const whatTranslation = flagsIdFormatter.format(flagsId);
+        customFormatters.set('what', new FixedStringFormatter(whatTranslation));
+      }
+      const lazyOperations: Array<Operation<PropertyTreeNode>> = [
+        new AddDefaults(field),
+        new SetFormatters(field, customFormatters),
+      ];
+
+      const lazyPropertiesStrategy = async () => {
+        let data = await queryArgs(this.traceProcessor, Number(argSetId));
+        const transformer = new FakeProtoTransformer(
+          assertDefined(field?.tamperedMessageType),
+        );
+        data = transformer.transform(data);
+
+        return new PropertyTreeBuilderFromProto()
+          .setData(data)
+          .setRootId(index)
+          .setRootName(assertDefined(field).name)
+          .build();
+      };
+
+      builder
+        .setLazyOperations(lazyOperations)
+        .setLazyPropertiesStrategy(lazyPropertiesStrategy);
+    }
+
+    return builder.build();
+  }
+
+  private async queryFlags(): Promise<Map<number, string>> {
+    const sql = `SELECT flags_id, flag FROM ${this.getFlagTableName()};`;
+    const result = await this.traceProcessor.query(sql);
+
+    const flags = new Map<number, string>();
+    for (const it = result.iter({}); it.valid(); it.next()) {
+      const flagId = Number(assertBigInt(it.get('flags_id')));
+      const flag = assertString(it.get('flag'));
+      if (flags.has(flagId)) {
+        flags.set(flagId, flags.get(flagId) + ' | ' + flag);
+      } else {
+        flags.set(flagId, flag);
+      }
+    }
+    return flags;
+  }
 
-    ParserTransactions.OPERATIONS.forEach((operation) => {
-      operation.apply(tree);
-    });
-    return tree;
+  // Use a custom sql query to get the vsync_id of the first dispatch
+  // entry associated with an input event, if any.
+  private static createVsyncIdQuery(
+    tableName: string,
+    minRowId: number,
+    maxRowId: number,
+  ): string {
+    return `
+      SELECT
+        tbl.id AS id,
+        vsync_id as int_value,
+        'uint' as value_type
+      FROM ${tableName} AS tbl
+      WHERE
+        tbl.id BETWEEN ${minRowId} AND ${maxRowId}
+      GROUP BY tbl.id
+      ORDER BY tbl.id;
+    `;
   }
 }
diff --git a/tools/winscope/src/parsers/transactions/perfetto/parser_transactions_test.ts b/tools/winscope/src/parsers/transactions/perfetto/parser_transactions_test.ts
index e12c1b31b..deabd97e3 100644
--- a/tools/winscope/src/parsers/transactions/perfetto/parser_transactions_test.ts
+++ b/tools/winscope/src/parsers/transactions/perfetto/parser_transactions_test.ts
@@ -18,20 +18,21 @@ import {
   TimestampConverterUtils,
   timestampEqualityTester,
 } from 'common/time/test_utils';
+import {getPerfettoParser} from 'test/unit/fixture_utils';
 import {TraceBuilder} from 'test/unit/trace_builder';
-import {UnitTestUtils} from 'test/unit/utils';
 import {CoarseVersion} from 'trace/coarse_version';
 import {CustomQueryType} from 'trace/custom_query';
 import {Parser} from 'trace/parser';
 import {TraceType} from 'trace/trace_type';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
+import {TransactionType} from 'trace/transactions/transaction_type';
+import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 
-describe('Perfetto ParserTransactions', () => {
-  let parser: Parser<PropertyTreeNode>;
+describe('PerfettoParserTransactions', () => {
+  let parser: Parser<HierarchyTreeNode>;
 
   beforeAll(async () => {
     jasmine.addCustomEqualityTester(timestampEqualityTester);
-    parser = await UnitTestUtils.getPerfettoParser(
+    parser = await getPerfettoParser(
       TraceType.TRANSACTIONS,
       'traces/perfetto/transactions_trace.perfetto-trace',
     );
@@ -63,103 +64,208 @@ describe('Perfetto ParserTransactions', () => {
     expect(entry.id).toEqual('TransactionsTraceEntry entry');
   });
 
-  it('transforms fake proto built from trace processor args', async () => {
-    const entry0 = await parser.getEntry(0);
-    const entry2 = await parser.getEntry(2);
+  describe('eager fetching', () => {
+    it('fetches id properties', async () => {
+      const entry0 = await parser.getEntry(0);
+      checkIdProperties(
+        assertDefined(entry0.getChildByName('LayerCreationArgs')),
+        undefined,
+        1n,
+        undefined,
+        TransactionType.LAYER_ADDED,
+      );
+      checkIdProperties(
+        assertDefined(entry0.getChildByName('LayerState')),
+        2211908157441n,
+        1n,
+        undefined,
+        TransactionType.LAYER_CHANGED,
+      );
 
-    // Add empty arrays
-    expect(entry0.getChildByName('addedDisplays')?.getAllChildren()).toEqual(
-      [],
-    );
-    expect(entry0.getChildByName('destroyedLayers')?.getAllChildren()).toEqual(
-      [],
-    );
-    expect(entry0.getChildByName('removedDisplays')?.getAllChildren()).toEqual(
-      [],
-    );
-    expect(
-      entry0.getChildByName('destroyedLayerHandles')?.getAllChildren(),
-    ).toEqual([]);
-    expect(entry0.getChildByName('displays')?.getAllChildren()).toEqual([]);
-
-    // Add default values
-    expect(
-      entry0
-        .getChildByName('transactions')
-        ?.getChildByName('1')
-        ?.getChildByName('pid')
-        ?.getValue(),
-    ).toEqual(0);
-
-    // Convert value types (bigint -> number)
-    expect(
-      entry0
-        .getChildByName('transactions')
-        ?.getChildByName('1')
-        ?.getChildByName('uid')
-        ?.getValue(),
-    ).toEqual(1003);
-
-    // Decode enum IDs
-    expect(
-      entry0
-        .getChildByName('transactions')
-        ?.getChildByName('0')
-        ?.getChildByName('layerChanges')
-        ?.getChildByName('0')
-        ?.getChildByName('dropInputMode')
-        ?.formattedValue(),
-    ).toEqual('NONE');
-
-    expect(
-      entry2
-        .getChildByName('transactions')
-        ?.getChildByName('0')
-        ?.getChildByName('layerChanges')
-        ?.getChildByName('0')
-        ?.getChildByName('bufferData')
-        ?.getChildByName('pixelFormat')
-        ?.formattedValue(),
-    ).toEqual('PIXEL_FORMAT_RGBA_1010102');
+      const entry222 = await parser.getEntry(222);
+      checkIdProperties(
+        assertDefined(entry222.getChildByName('DisplayState')),
+        6841882902621n,
+        undefined,
+        4294967295n,
+        TransactionType.DISPLAY_CHANGED,
+      );
+
+      const entry351 = await parser.getEntry(351);
+      checkIdProperties(
+        assertDefined(entry351.getChildByName(TransactionType.LAYER_DESTROYED)),
+        undefined,
+        62n,
+        undefined,
+        TransactionType.LAYER_DESTROYED,
+      );
+      checkIdProperties(
+        assertDefined(
+          entry351.getChildByName(TransactionType.LAYER_HANDLE_DESTROYED),
+        ),
+        undefined,
+        62n,
+        undefined,
+        TransactionType.LAYER_HANDLE_DESTROYED,
+      );
+      checkIdProperties(
+        assertDefined(entry351.getChildByName(TransactionType.NO_OP)),
+        6841882902741n,
+        undefined,
+        undefined,
+        TransactionType.NO_OP,
+      );
+    });
+
+    it('fetches and translates flags', async () => {
+      const entry0 = await parser.getEntry(0);
+      const n0 = assertDefined(entry0.getChildByName('LayerState'));
+      checkEagerProperty(n0, 'flagsId', 0n, 'eLayerChanged');
+
+      const n1 = entry0.getAllChildren()[1];
+      checkEagerProperty(
+        n1,
+        'flagsId',
+        1n,
+        'eFlagsChanged | eDestinationFrameChanged',
+      );
+
+      const entry222 = await parser.getEntry(222);
+      const n2 = assertDefined(entry222.getChildByName('DisplayState'));
+      const expectedFlags =
+        'eLayerStackChanged | eDisplayProjectionChanged | eFlagsChanged';
+      checkEagerProperty(n2, 'flagsId', 9n, expectedFlags);
+    });
+
+    it('fetches process properties', async () => {
+      const transactions0 = (await parser.getEntry(0)).getAllChildren();
+      const transactions1 = (await parser.getEntry(679)).getAllChildren();
+
+      // translated due to uid/pid dual match though multiple uid=1003 in trace
+      checkProcessProperties(transactions0[0], 515n, 1003n, 'process515');
+
+      // not translated due to multiple uid=1003 processes in trace
+      checkProcessProperties(transactions0[1], 0n, 1003n, undefined);
+
+      // not translated due to missing process in trace
+      checkProcessProperties(transactions1[0], 0n, 10239n, undefined);
+
+      // translated due to uid/pid dual match
+      checkProcessProperties(transactions1[3], 1593n, 1000n, 'process1593');
+
+      // not translated due to zero uid/pid
+      checkProcessProperties(transactions1[7], 0n, 0n, undefined);
+
+      // translated due to single pid match
+      checkProcessProperties(transactions1[8], 0n, 10169n, 'process3300');
+
+      // translated due to single uid match
+      checkProcessProperties(transactions1[9], 3300n, 0n, 'process3300');
+
+      // not translated due to missing pid and uid
+      checkProcessProperties(
+        transactions1[11],
+        undefined,
+        undefined,
+        undefined,
+      );
+    });
+
+    function checkIdProperties(
+      t: HierarchyTreeNode,
+      txid: bigint | undefined,
+      layerId: bigint | undefined,
+      displayId: bigint | undefined,
+      transactionType: TransactionType,
+    ) {
+      checkEagerProperty(t, 'transactionId', txid);
+      checkEagerProperty(t, 'layerId', layerId);
+      checkEagerProperty(t, 'displayId', displayId);
+      checkEagerProperty(t, 'transactionType', transactionType);
+    }
+
+    function checkProcessProperties(
+      t: HierarchyTreeNode,
+      pid: bigint | undefined,
+      uid: bigint | undefined,
+      name: string | undefined,
+    ) {
+      checkEagerProperty(t, 'pid', pid);
+      checkEagerProperty(t, 'uid', uid);
+      checkEagerProperty(t, 'processName', name);
+    }
+
+    function checkEagerProperty(
+      t: HierarchyTreeNode,
+      name: string,
+      val: any,
+      formattedValue?: string,
+    ) {
+      const node = t.getEagerPropertyByName(name);
+      expect(node?.getValue()).toEqual(val);
+      if (formattedValue) {
+        expect(node?.formattedValue()).toEqual(formattedValue);
+      }
+    }
   });
 
-  it("decodes 'what' field in proto", async () => {
-    {
-      const entry = await parser.getEntry(0);
-      const transactions = assertDefined(entry.getChildByName('transactions'));
-      expect(
-        transactions
-          .getChildByName('0')
-          ?.getChildByName('layerChanges')
-          ?.getChildByName('0')
-          ?.getChildByName('what')
-          ?.formattedValue(),
-      ).toEqual('eLayerChanged');
+  describe('lazy property fetching', () => {
+    it('transforms fake proto built from trace processor args', async () => {
+      const entry0 = await parser.getEntry(0);
+
+      expect(entry0.getChildByName('DisplayState')).toBeUndefined();
+
+      const layerChange1 = await entry0.getAllChildren()[1].getAllProperties();
+
+      // Add default values
+      expect(layerChange1?.getChildByName('alpha')?.getValue()).toEqual(0);
+
+      // Convert value types (bigint -> number)
+      expect(layerChange1?.getChildByName('flags')?.getValue()).toEqual(256);
 
+      // Decode enum IDs
       expect(
-        transactions
-          .getChildByName('1')
-          ?.getChildByName('layerChanges')
-          ?.getChildByName('0')
-          ?.getChildByName('what')
-          ?.formattedValue(),
-      ).toEqual('eFlagsChanged | eDestinationFrameChanged');
-    }
-    {
-      const entry = await parser.getEntry(222);
-      const transactions = assertDefined(entry.getChildByName('transactions'));
+        layerChange1?.getChildByName('dropInputMode')?.formattedValue(),
+      ).toEqual('NONE');
 
+      const entry2 = await parser.getEntry(2);
+      const layerChange2 = await entry2.getAllChildren()[0].getAllProperties();
       expect(
-        transactions
-          .getChildByName('1')
-          ?.getChildByName('displayChanges')
-          ?.getChildByName('0')
-          ?.getChildByName('what')
+        layerChange2
+          ?.getChildByName('bufferData')
+          ?.getChildByName('pixelFormat')
           ?.formattedValue(),
-      ).toEqual(
-        'eLayerStackChanged | eDisplayProjectionChanged | eFlagsChanged',
-      );
-    }
+      ).toEqual('PIXEL_FORMAT_RGBA_1010102');
+    });
+
+    it("decodes 'what' field", async () => {
+      {
+        const entry = await parser.getEntry(0);
+        const layerChanges0 = await entry
+          .getChildByName('LayerState')
+          ?.getAllProperties();
+        expect(layerChanges0?.getChildByName('what')?.formattedValue()).toEqual(
+          'eLayerChanged',
+        );
+        const layerChanges1 = await entry
+          .getAllChildren()[1]
+          .getAllProperties();
+        expect(layerChanges1?.getChildByName('what')?.formattedValue()).toEqual(
+          'eFlagsChanged | eDestinationFrameChanged',
+        );
+      }
+      {
+        const entry = await parser.getEntry(222);
+        const displayChanges = await entry
+          .getChildByName('DisplayState')
+          ?.getAllProperties();
+        expect(
+          displayChanges?.getChildByName('what')?.formattedValue(),
+        ).toEqual(
+          'eLayerStackChanged | eDisplayProjectionChanged | eFlagsChanged',
+        );
+      }
+    });
   });
 
   it('supports VSYNCID custom query', async () => {
diff --git a/tools/winscope/src/parsers/transitions/entry_properties_tree_factory.ts b/tools/winscope/src/parsers/transitions/entry_properties_tree_factory.ts
deleted file mode 100644
index 6024f9492..000000000
--- a/tools/winscope/src/parsers/transitions/entry_properties_tree_factory.ts
+++ /dev/null
@@ -1,231 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import {assertDefined} from 'common/assert_utils';
-import {MakeTimestampStrategyType, Timestamp} from 'common/time/time';
-import {ParserTimestampConverter} from 'common/time/timestamp_converter';
-import {AddDefaults} from 'parsers/operations/add_defaults';
-import {SetFormatters} from 'parsers/operations/set_formatters';
-import {TransformToTimestamp} from 'parsers/operations/transform_to_timestamp';
-import {TranslateIntDef} from 'parsers/operations/translate_intdef';
-import {TamperedMessageType} from 'parsers/tampered_message_type';
-import {perfetto} from 'protos/transitions/latest/static';
-import root from 'protos/transitions/udc/json';
-import {com} from 'protos/transitions/udc/static';
-import {
-  EnumFormatter,
-  PropertyFormatter,
-  TIMESTAMP_NODE_FORMATTER,
-} from 'trace/tree_node/formatters';
-import {PropertyTreeBuilderFromProto} from 'trace/tree_node/property_tree_builder_from_proto';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
-import {AddDuration} from './operations/add_duration';
-import {AddRealToBootTimeOffsetTimestamp} from './operations/add_real_to_elapsed_time_offset_timestamp';
-import {AddRootProperties} from './operations/add_root_properties';
-import {AddStatus} from './operations/add_status';
-import {UpdateAbortTimeNodes} from './operations/update_abort_time_nodes';
-import {TransitionType} from './transition_type';
-
-interface TransitionInfo {
-  entry:
-    | com.android.server.wm.shell.ITransition
-    | com.android.wm.shell.ITransition
-    | perfetto.protos.IShellTransition;
-  realToBootTimeOffsetNs: bigint | undefined;
-  timestampConverter: ParserTimestampConverter;
-  handlerMapping?: {[key: number]: string};
-}
-
-export class EntryPropertiesTreeFactory {
-  static readonly TRANSITION_OPERATIONS = [
-    new AddDuration(),
-    new AddStatus(),
-    new AddRootProperties(),
-  ];
-
-  private static readonly TransitionTraceProto = TamperedMessageType.tamper(
-    root.lookupType('com.android.server.wm.shell.TransitionTraceProto'),
-  );
-  private static readonly TransitionField =
-    EntryPropertiesTreeFactory.TransitionTraceProto.fields['transitions'];
-  private static readonly WM_ADD_DEFAULTS_OPERATION = new AddDefaults(
-    EntryPropertiesTreeFactory.TransitionField,
-    ['type', 'targets'],
-  );
-  private static WM_INTDEF_OPERATION = new TranslateIntDef(
-    EntryPropertiesTreeFactory.TransitionField,
-  );
-  private static readonly SET_FORMATTERS_OPERATION = new SetFormatters();
-  private static readonly PERFETTO_TRANSITION_OPERATIONS = [
-    new UpdateAbortTimeNodes(),
-  ];
-  private static readonly TRANSITION_TYPE_FORMATTER = new EnumFormatter(
-    TransitionType,
-  );
-
-  static makeTransitionPropertiesTree(
-    shellEntryTree: PropertyTreeNode,
-    wmEntryTree: PropertyTreeNode,
-  ): PropertyTreeNode {
-    const transitionTree = new PropertyTreeNode(
-      wmEntryTree.id,
-      wmEntryTree.name,
-      wmEntryTree.source,
-      undefined,
-    );
-
-    transitionTree.addOrReplaceChild(
-      assertDefined(shellEntryTree.getChildByName('shellData')),
-    );
-    transitionTree.addOrReplaceChild(
-      assertDefined(wmEntryTree.getChildByName('wmData')),
-    );
-    EntryPropertiesTreeFactory.TRANSITION_OPERATIONS.forEach((operation) =>
-      operation.apply(transitionTree),
-    );
-    return transitionTree;
-  }
-
-  static makeWmPropertiesTree(
-    info?: TransitionInfo,
-    denylistProperties: string[] = [],
-  ): PropertyTreeNode {
-    const tree = new PropertyTreeBuilderFromProto()
-      .setData({wmData: info?.entry ?? null})
-      .setRootId('TransitionTraceEntry')
-      .setRootName('Selected Transition')
-      .setDenyList(denylistProperties)
-      .setVisitPrototype(false)
-      .build();
-
-    if (!info) {
-      EntryPropertiesTreeFactory.SET_FORMATTERS_OPERATION.apply(tree);
-      return tree;
-    }
-
-    if (denylistProperties.length > 0) {
-      EntryPropertiesTreeFactory.PERFETTO_TRANSITION_OPERATIONS.forEach(
-        (operation) => operation.apply(tree),
-      );
-    }
-
-    let realToBootTimeOffsetTimestamp: Timestamp | undefined;
-
-    if (info.realToBootTimeOffsetNs !== undefined) {
-      realToBootTimeOffsetTimestamp =
-        info.timestampConverter.makeTimestampFromRealNs(
-          info.realToBootTimeOffsetNs,
-        );
-    }
-
-    const wmDataNode = assertDefined(tree.getChildByName('wmData'));
-    new AddRealToBootTimeOffsetTimestamp(realToBootTimeOffsetTimestamp).apply(
-      wmDataNode,
-    );
-    EntryPropertiesTreeFactory.WM_ADD_DEFAULTS_OPERATION.apply(wmDataNode);
-    new TransformToTimestamp(
-      [
-        'abortTimeNs',
-        'createTimeNs',
-        'sendTimeNs',
-        'finishTimeNs',
-        'startingWindowRemoveTimeNs',
-      ],
-      EntryPropertiesTreeFactory.makeTimestampStrategy(info.timestampConverter),
-    ).apply(wmDataNode);
-
-    const customFormatters = new Map<string, PropertyFormatter>([
-      ['type', EntryPropertiesTreeFactory.TRANSITION_TYPE_FORMATTER],
-      ['mode', EntryPropertiesTreeFactory.TRANSITION_TYPE_FORMATTER],
-      ['abortTimeNs', TIMESTAMP_NODE_FORMATTER],
-      ['createTimeNs', TIMESTAMP_NODE_FORMATTER],
-      ['sendTimeNs', TIMESTAMP_NODE_FORMATTER],
-      ['finishTimeNs', TIMESTAMP_NODE_FORMATTER],
-      ['startingWindowRemoveTimeNs', TIMESTAMP_NODE_FORMATTER],
-    ]);
-
-    new SetFormatters(undefined, customFormatters).apply(tree);
-
-    EntryPropertiesTreeFactory.WM_INTDEF_OPERATION.apply(tree);
-    return tree;
-  }
-
-  static makeShellPropertiesTree(
-    info?: TransitionInfo,
-    denylistProperties: string[] = [],
-  ): PropertyTreeNode {
-    const tree = new PropertyTreeBuilderFromProto()
-      .setData({shellData: info?.entry ?? null})
-      .setRootId('TransitionTraceEntry')
-      .setRootName('Selected Transition')
-      .setDenyList(denylistProperties)
-      .setVisitPrototype(false)
-      .build();
-
-    if (!info) {
-      EntryPropertiesTreeFactory.SET_FORMATTERS_OPERATION.apply(tree);
-      return tree;
-    }
-
-    if (denylistProperties.length > 0) {
-      EntryPropertiesTreeFactory.PERFETTO_TRANSITION_OPERATIONS.forEach(
-        (operation) => operation.apply(tree),
-      );
-    }
-
-    let realToBootTimeOffsetTimestamp: Timestamp | undefined;
-    if (info.realToBootTimeOffsetNs !== undefined) {
-      realToBootTimeOffsetTimestamp =
-        info.timestampConverter.makeTimestampFromRealNs(
-          info.realToBootTimeOffsetNs,
-        );
-    }
-
-    const shellDataNode = assertDefined(tree.getChildByName('shellData'));
-    new AddRealToBootTimeOffsetTimestamp(realToBootTimeOffsetTimestamp).apply(
-      shellDataNode,
-    );
-    new TransformToTimestamp(
-      ['dispatchTimeNs', 'mergeRequestTimeNs', 'mergeTimeNs', 'abortTimeNs'],
-      EntryPropertiesTreeFactory.makeTimestampStrategy(info.timestampConverter),
-    ).apply(shellDataNode);
-
-    const customFormatters = new Map<string, PropertyFormatter>([
-      ['type', EntryPropertiesTreeFactory.TRANSITION_TYPE_FORMATTER],
-      ['mode', EntryPropertiesTreeFactory.TRANSITION_TYPE_FORMATTER],
-      ['dispatchTimeNs', TIMESTAMP_NODE_FORMATTER],
-      ['mergeRequestTimeNs', TIMESTAMP_NODE_FORMATTER],
-      ['mergeTimeNs', TIMESTAMP_NODE_FORMATTER],
-      ['abortTimeNs', TIMESTAMP_NODE_FORMATTER],
-    ]);
-
-    if (info.handlerMapping) {
-      customFormatters.set('handler', new EnumFormatter(info.handlerMapping));
-    }
-
-    new SetFormatters(undefined, customFormatters).apply(tree);
-
-    return tree;
-  }
-
-  private static makeTimestampStrategy(
-    timestampConverter: ParserTimestampConverter,
-  ): MakeTimestampStrategyType {
-    return (valueNs: bigint) => {
-      return timestampConverter.makeTimestampFromBootTimeNs(valueNs);
-    };
-  }
-}
diff --git a/tools/winscope/src/parsers/transitions/legacy/parser_transitions_shell.ts b/tools/winscope/src/parsers/transitions/legacy/parser_transitions_shell.ts
index 51a6f4534..85981c8c8 100644
--- a/tools/winscope/src/parsers/transitions/legacy/parser_transitions_shell.ts
+++ b/tools/winscope/src/parsers/transitions/legacy/parser_transitions_shell.ts
@@ -14,18 +14,18 @@
  * limitations under the License.
  */
 
+import {assertDefined} from 'common/assert_utils';
 import {Timestamp} from 'common/time/time';
 import {AbstractParser} from 'parsers/legacy/abstract_parser';
-import {EntryPropertiesTreeFactory} from 'parsers/transitions/entry_properties_tree_factory';
 import root from 'protos/transitions/udc/json';
 import {com} from 'protos/transitions/udc/static';
 import {TraceType} from 'trace/trace_type';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 
 type TransitionProto = com.android.wm.shell.ITransition;
+type HandlerProto = com.android.wm.shell.IHandlerMapping;
 
 export class ParserTransitionsShell extends AbstractParser<
-  PropertyTreeNode,
+  TransitionProto,
   TransitionProto
 > {
   private static readonly WmShellTransitionsTraceProto = root.lookupType(
@@ -33,7 +33,7 @@ export class ParserTransitionsShell extends AbstractParser<
   );
 
   private realToBootTimeOffsetNs: bigint | undefined;
-  private handlerMapping: undefined | {[key: number]: string};
+  private handlerMapping: undefined | HandlerProto[];
 
   override getTraceType(): TraceType {
     return TraceType.SHELL_TRANSITION;
@@ -52,25 +52,23 @@ export class ParserTransitionsShell extends AbstractParser<
       ParserTransitionsShell.WmShellTransitionsTraceProto.decode(
         traceBuffer,
       ) as unknown as com.android.wm.shell.IWmShellTransitionTraceProto;
-
     const timeOffset = BigInt(
       decodedProto.realToElapsedTimeOffsetNanos?.toString() ?? '0',
     );
     this.realToBootTimeOffsetNs = timeOffset !== 0n ? timeOffset : undefined;
-
-    this.handlerMapping = {};
-    for (const mapping of decodedProto.handlerMappings ?? []) {
-      this.handlerMapping[mapping.id] = mapping.name;
-    }
-
+    this.handlerMapping = decodedProto.handlerMappings ?? [];
     return decodedProto.transitions ?? [];
   }
 
+  getShellHandlerMapping(): HandlerProto[] {
+    return assertDefined(this.handlerMapping);
+  }
+
   override processDecodedEntry(
     index: number,
     entryProto: TransitionProto,
-  ): PropertyTreeNode {
-    return this.makePropertiesTree(entryProto);
+  ): TransitionProto {
+    return entryProto;
   }
 
   protected override getTimestamp(entry: TransitionProto): Timestamp {
@@ -84,43 +82,4 @@ export class ParserTransitionsShell extends AbstractParser<
   protected getMagicNumber(): number[] | undefined {
     return [0x09, 0x57, 0x4d, 0x53, 0x54, 0x52, 0x41, 0x43, 0x45]; // .WMSTRACE
   }
-
-  private validateShellTransitionEntry(entry: TransitionProto) {
-    if (entry.id === 0) {
-      throw new Error('Shell Transitions entry needs non-null id');
-    }
-    if (
-      !entry.dispatchTimeNs &&
-      !entry.mergeRequestTimeNs &&
-      !entry.mergeTimeNs &&
-      !entry.abortTimeNs
-    ) {
-      throw new Error(
-        'Shell Transitions entry requires at least one non-null timestamp',
-      );
-    }
-    if (this.realToBootTimeOffsetNs === undefined) {
-      throw new Error('Shell Transitions trace missing realToBootTimeOffsetNs');
-    }
-    if (this.handlerMapping === undefined) {
-      throw new Error('Shell Transitions trace missing handler mapping');
-    }
-  }
-
-  private makePropertiesTree(entryProto: TransitionProto): PropertyTreeNode {
-    this.validateShellTransitionEntry(entryProto);
-
-    const shellEntryTree = EntryPropertiesTreeFactory.makeShellPropertiesTree({
-      entry: entryProto,
-      realToBootTimeOffsetNs: this.realToBootTimeOffsetNs,
-      handlerMapping: this.handlerMapping,
-      timestampConverter: this.timestampConverter,
-    });
-    const wmEntryTree = EntryPropertiesTreeFactory.makeWmPropertiesTree();
-
-    return EntryPropertiesTreeFactory.makeTransitionPropertiesTree(
-      shellEntryTree,
-      wmEntryTree,
-    );
-  }
 }
diff --git a/tools/winscope/src/parsers/transitions/legacy/parser_transitions_shell_test.ts b/tools/winscope/src/parsers/transitions/legacy/parser_transitions_shell_test.ts
index a215eb6ee..61c29eebf 100644
--- a/tools/winscope/src/parsers/transitions/legacy/parser_transitions_shell_test.ts
+++ b/tools/winscope/src/parsers/transitions/legacy/parser_transitions_shell_test.ts
@@ -19,20 +19,23 @@ import {
   TimestampConverterUtils,
   timestampEqualityTester,
 } from 'common/time/test_utils';
-import {UnitTestUtils} from 'test/unit/utils';
+import {com} from 'protos/transitions/udc/static';
+import {LegacyParserProvider} from 'test/unit/fixture_utils';
 import {CoarseVersion} from 'trace/coarse_version';
 import {Parser} from 'trace/parser';
 import {TraceType} from 'trace/trace_type';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
+import {ParserTransitionsShell} from './parser_transitions_shell';
 
 describe('ParserTransitionsShell', () => {
-  let parser: Parser<PropertyTreeNode>;
+  let parser: Parser<com.android.wm.shell.Transition>;
 
   beforeAll(async () => {
     jasmine.addCustomEqualityTester(timestampEqualityTester);
-    parser = (await UnitTestUtils.getParser(
-      'traces/elapsed_and_real_timestamp/shell_transition_trace.pb',
-    )) as Parser<PropertyTreeNode>;
+    parser = await new LegacyParserProvider()
+      .addFilename(
+        'traces/elapsed_and_real_timestamp/shell_transition_trace.pb',
+      )
+      .getParser<com.android.wm.shell.Transition>();
   });
 
   it('has expected trace type', () => {
@@ -55,4 +58,27 @@ describe('ParserTransitionsShell', () => {
     ];
     expect(timestamps).toEqual(expected);
   });
+
+  it('provides decoded proto', async () => {
+    const entry = await parser.getEntry(0);
+    expect(entry.id).toEqual(6);
+    expect(entry.dispatchTimeNs.toString()).toEqual('57649649922341');
+    expect(entry.handler).toEqual(2);
+  });
+
+  it('provides shell mapping', async () => {
+    expect(parser).toBeInstanceOf(ParserTransitionsShell);
+    const mapping = (
+      parser as unknown as ParserTransitionsShell
+    ).getShellHandlerMapping();
+    expect(mapping.length).toEqual(2);
+    expect(mapping[0].id).toEqual(2);
+    expect(mapping[0].name).toEqual(
+      'com.android.wm.shell.transition.DefaultMixedHandler',
+    );
+    expect(mapping[1].id).toEqual(3);
+    expect(mapping[1].name).toEqual(
+      'com.android.wm.shell.recents.RecentsTransitionHandler',
+    );
+  });
 });
diff --git a/tools/winscope/src/parsers/transitions/legacy/parser_transitions_wm.ts b/tools/winscope/src/parsers/transitions/legacy/parser_transitions_wm.ts
index 2f7724477..8d01537dc 100644
--- a/tools/winscope/src/parsers/transitions/legacy/parser_transitions_wm.ts
+++ b/tools/winscope/src/parsers/transitions/legacy/parser_transitions_wm.ts
@@ -16,16 +16,14 @@
 
 import {Timestamp} from 'common/time/time';
 import {AbstractParser} from 'parsers/legacy/abstract_parser';
-import {EntryPropertiesTreeFactory} from 'parsers/transitions/entry_properties_tree_factory';
 import root from 'protos/transitions/udc/json';
 import {com} from 'protos/transitions/udc/static';
 import {TraceType} from 'trace/trace_type';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 
 type TransitionProto = com.android.server.wm.shell.ITransition;
 
 export class ParserTransitionsWm extends AbstractParser<
-  PropertyTreeNode,
+  TransitionProto,
   TransitionProto
 > {
   private static readonly TransitionTraceProto = root.lookupType(
@@ -49,8 +47,8 @@ export class ParserTransitionsWm extends AbstractParser<
   override processDecodedEntry(
     index: number,
     entryProto: TransitionProto,
-  ): PropertyTreeNode {
-    return this.makePropertiesTree(entryProto);
+  ): TransitionProto {
+    return entryProto;
   }
 
   override decodeTrace(buffer: Uint8Array): TransitionProto[] {
@@ -75,39 +73,4 @@ export class ParserTransitionsWm extends AbstractParser<
     // shell dispatch time else INVALID_TIME_NS
     return this.timestampConverter.makeZeroTimestamp();
   }
-
-  private validateWmTransitionEntry(entry: TransitionProto) {
-    if (entry.id === 0) {
-      throw new Error('WM Transition entry needs non-null id');
-    }
-    if (
-      !entry.createTimeNs &&
-      !entry.sendTimeNs &&
-      !entry.abortTimeNs &&
-      !entry.finishTimeNs
-    ) {
-      throw new Error(
-        'WM Transition entry requires at least one non-null timestamp',
-      );
-    }
-    if (this.realToBootTimeOffsetNs === undefined) {
-      throw new Error('WM Transition trace missing realToBootTimeOffsetNs');
-    }
-  }
-
-  private makePropertiesTree(entryProto: TransitionProto): PropertyTreeNode {
-    this.validateWmTransitionEntry(entryProto);
-
-    const shellEntryTree = EntryPropertiesTreeFactory.makeShellPropertiesTree();
-    const wmEntryTree = EntryPropertiesTreeFactory.makeWmPropertiesTree({
-      entry: entryProto,
-      realToBootTimeOffsetNs: this.realToBootTimeOffsetNs,
-      timestampConverter: this.timestampConverter,
-    });
-
-    return EntryPropertiesTreeFactory.makeTransitionPropertiesTree(
-      shellEntryTree,
-      wmEntryTree,
-    );
-  }
 }
diff --git a/tools/winscope/src/parsers/transitions/legacy/parser_transitions_wm_test.ts b/tools/winscope/src/parsers/transitions/legacy/parser_transitions_wm_test.ts
index 37faf570e..89581fbbe 100644
--- a/tools/winscope/src/parsers/transitions/legacy/parser_transitions_wm_test.ts
+++ b/tools/winscope/src/parsers/transitions/legacy/parser_transitions_wm_test.ts
@@ -19,20 +19,20 @@ import {
   TimestampConverterUtils,
   timestampEqualityTester,
 } from 'common/time/test_utils';
-import {UnitTestUtils} from 'test/unit/utils';
+import {com} from 'protos/transitions/udc/static';
+import {LegacyParserProvider} from 'test/unit/fixture_utils';
 import {CoarseVersion} from 'trace/coarse_version';
 import {Parser} from 'trace/parser';
 import {TraceType} from 'trace/trace_type';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 
 describe('ParserTransitionsWm', () => {
-  let parser: Parser<PropertyTreeNode>;
+  let parser: Parser<com.android.server.wm.shell.ITransition>;
 
   beforeAll(async () => {
     jasmine.addCustomEqualityTester(timestampEqualityTester);
-    parser = (await UnitTestUtils.getParser(
-      'traces/elapsed_and_real_timestamp/wm_transition_trace.pb',
-    )) as Parser<PropertyTreeNode>;
+    parser = await new LegacyParserProvider()
+      .addFilename('traces/elapsed_and_real_timestamp/wm_transition_trace.pb')
+      .getParser<com.android.server.wm.shell.ITransition>();
   });
 
   it('has expected trace type', () => {
@@ -50,18 +50,10 @@ describe('ParserTransitionsWm', () => {
     timestamps.forEach((timestamp) => expect(timestamp).toEqual(expected));
   });
 
-  it('translates flags', async () => {
-    const entry = await parser.getEntry(4);
-    expect(
-      entry.getChildByName('wmData')?.getChildByName('flags')?.formattedValue(),
-    ).toEqual('TRANSIT_FLAG_IS_RECENTS');
-
-    const targets = entry.getChildByName('wmData')?.getChildByName('targets');
-    expect(
-      targets?.getChildByName('0')?.getChildByName('flags')?.formattedValue(),
-    ).toEqual('FLAG_MOVED_TO_TOP | FLAG_SHOW_WALLPAPER');
-    expect(
-      targets?.getChildByName('1')?.getChildByName('flags')?.formattedValue(),
-    ).toEqual('FLAG_NONE');
+  it('provides decoded proto', async () => {
+    const entry = await parser.getEntry(0);
+    expect(entry.id).toEqual(6);
+    expect(entry.startTransactionId?.toString()).toEqual('13086765351818');
+    expect(entry.sendTimeNs?.toString()).toEqual('57649646973488');
   });
 });
diff --git a/tools/winscope/src/parsers/transitions/legacy/traces_parser_transitions.ts b/tools/winscope/src/parsers/transitions/legacy/traces_parser_transitions.ts
index 54e83b78e..d3e73d076 100644
--- a/tools/winscope/src/parsers/transitions/legacy/traces_parser_transitions.ts
+++ b/tools/winscope/src/parsers/transitions/legacy/traces_parser_transitions.ts
@@ -14,22 +14,30 @@
  * limitations under the License.
  */
 
-import {assertDefined} from 'common/assert_utils';
-import {Timestamp} from 'common/time/time';
+import {assertDefined, assertTrue} from 'common/assert_utils';
+import {getMax} from 'common/bigint_math';
+import {NOT_IMPLEMENTED_ERROR} from 'common/errors';
 import {ParserTimestampConverter} from 'common/time/timestamp_converter';
+import Long from 'long';
 import {AbstractTracesParser} from 'parsers/traces/abstract_traces_parser';
-import {EntryPropertiesTreeFactory} from 'parsers/transitions/entry_properties_tree_factory';
+import {perfetto} from 'protos/perfetto/trace/static';
+import {com} from 'protos/transitions/udc/static';
 import {CoarseVersion} from 'trace/coarse_version';
 import {Trace} from 'trace/trace';
 import {Traces} from 'trace/traces';
 import {TraceType} from 'trace/trace_type';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
+import {ParserTransitionsShell} from './parser_transitions_shell';
 
 export class TracesParserTransitions extends AbstractTracesParser<PropertyTreeNode> {
-  private readonly wmTransitionTrace: Trace<PropertyTreeNode> | undefined;
-  private readonly shellTransitionTrace: Trace<PropertyTreeNode> | undefined;
+  private readonly wmTransitionTrace: Trace<WmTransition> | undefined;
+  private readonly shellTransitionTrace: Trace<ShellTransition> | undefined;
   private readonly descriptors: string[];
-  private decodedEntries: PropertyTreeNode[] | undefined;
+  private decodedEntries: PerfettoTransition[] | undefined;
+  private shellHandlerMapping:
+    | com.android.wm.shell.IHandlerMapping[]
+    | undefined;
+  private realToBootTimeOffsetNs: bigint | undefined;
 
   constructor(traces: Traces, timestampConverter: ParserTimestampConverter) {
     super(timestampConverter);
@@ -59,17 +67,37 @@ export class TracesParserTransitions extends AbstractTracesParser<PropertyTreeNo
       throw new Error('Missing Shell Transition trace');
     }
 
-    const wmTransitionEntries: PropertyTreeNode[] = await Promise.all(
-      this.wmTransitionTrace.mapEntry((entry) => entry.getValue()),
-    );
+    const shellParser = this.shellTransitionTrace.getParser();
+    assertTrue(shellParser instanceof ParserTransitionsShell);
+    this.shellHandlerMapping = (
+      shellParser as ParserTransitionsShell
+    ).getShellHandlerMapping();
 
-    const shellTransitionEntries: PropertyTreeNode[] = await Promise.all(
-      this.shellTransitionTrace.mapEntry((entry) => entry.getValue()),
-    );
+    const wmOffset = this.wmTransitionTrace
+      .getParser()
+      .getRealToBootTimeOffsetNs();
+    const shellOffset = shellParser.getRealToBootTimeOffsetNs();
+
+    this.realToBootTimeOffsetNs = getMax([wmOffset ?? 0n, shellOffset ?? 0n]);
+    if (this.realToBootTimeOffsetNs === 0n) {
+      this.realToBootTimeOffsetNs = undefined;
+    }
+
+    const wmTransitionEntries = (
+      await Promise.all(
+        this.wmTransitionTrace.mapEntry((entry) => entry.getValue()),
+      )
+    ).map((entry) => this.convertWmToPerfettoTransition(entry));
 
-    const allEntries = wmTransitionEntries.concat(shellTransitionEntries);
+    const shellTransitionEntries = (
+      await Promise.all(
+        this.shellTransitionTrace.mapEntry((entry) => entry.getValue()),
+      )
+    ).map((entry) => this.convertShellToPerfettoTransition(entry));
 
-    this.decodedEntries = this.compressEntries(allEntries);
+    this.decodedEntries = this.compressEntries(
+      wmTransitionEntries.concat(shellTransitionEntries),
+    );
 
     await this.createTimestamps();
   }
@@ -78,9 +106,13 @@ export class TracesParserTransitions extends AbstractTracesParser<PropertyTreeNo
     this.timestamps = [];
     const zeroTs = this.timestampConverter.makeZeroTimestamp();
     for (let index = 0; index < this.getLengthEntries(); index++) {
-      const entry = await this.getEntry(index);
-      const ts = this.getTimestampFromTransitionProperties(entry);
-      this.timestamps.push(ts ?? zeroTs);
+      const entry = assertDefined(this.decodedEntries)[index];
+      const ns = this.getTimestampNsFromTransitionProperties(entry);
+      const ts =
+        ns && ns !== 0n
+          ? this.timestampConverter.makeTimestampFromBootTimeNs(ns)
+          : zeroTs;
+      this.timestamps.push(ts);
     }
   }
 
@@ -89,8 +121,10 @@ export class TracesParserTransitions extends AbstractTracesParser<PropertyTreeNo
   }
 
   override getEntry(index: number): Promise<PropertyTreeNode> {
-    const entry = assertDefined(this.decodedEntries)[index];
-    return Promise.resolve(entry);
+    // Legacy parsers that implement convertToPerfettoPackets should not
+    // parser and provide individual trace entries, as they should be
+    // converted to perfetto using LegacyToPerfettoConverter
+    throw NOT_IMPLEMENTED_ERROR;
   }
 
   override getDescriptors(): string[] {
@@ -106,17 +140,37 @@ export class TracesParserTransitions extends AbstractTracesParser<PropertyTreeNo
   }
 
   override getRealToBootTimeOffsetNs(): bigint | undefined {
-    return undefined;
+    return this.realToBootTimeOffsetNs;
   }
 
-  private compressEntries(
-    allTransitions: PropertyTreeNode[],
-  ): PropertyTreeNode[] {
-    const idToTransition = new Map<number, PropertyTreeNode>();
+  override canConvertToPerfetto(): boolean {
+    return true;
+  }
 
-    for (const transition of allTransitions) {
-      const id = assertDefined(transition.getChildByName('id')).getValue();
+  convertToPerfettoPackets?(sequenceId: number): perfetto.protos.TracePacket[] {
+    const packets = [];
+    packets.push(this.createHandlerMappingPacket(sequenceId));
+
+    for (const entry of assertDefined(this.decodedEntries)) {
+      const packet = perfetto.protos.TracePacket.create();
+      packet.trustedPacketSequenceId = sequenceId;
+      const ns = this.getTimestampNsFromTransitionProperties(entry) ?? 0n;
+      packet.timestamp = Long.fromString(ns.toString());
+      packet.timestampClockId =
+        perfetto.protos.ClockSnapshot.Clock.BuiltinClocks.BOOTTIME;
+      packet.shellTransition = entry;
+      packets.push(packet);
+    }
+
+    return packets;
+  }
 
+  private compressEntries(
+    transitions: PerfettoTransition[],
+  ): PerfettoTransition[] {
+    const idToTransition = new Map<number, PerfettoTransition>();
+    for (const transition of transitions) {
+      const id = assertDefined(transition.id);
       const accumulatedTransition = idToTransition.get(id);
       if (!accumulatedTransition) {
         idToTransition.set(id, transition);
@@ -128,110 +182,129 @@ export class TracesParserTransitions extends AbstractTracesParser<PropertyTreeNo
         idToTransition.set(id, mergedTransition);
       }
     }
-
     const compressedTransitions = Array.from(idToTransition.values());
-    compressedTransitions.forEach((transition) => {
-      EntryPropertiesTreeFactory.TRANSITION_OPERATIONS.forEach((operation) =>
-        operation.apply(transition),
-      );
-    });
     return compressedTransitions.sort((a, b) => this.compareByTimestamp(a, b));
   }
 
-  private compareByTimestamp(a: PropertyTreeNode, b: PropertyTreeNode): number {
-    const aNs = this.getTimestampFromTransitionProperties(a) ?? 0n;
-    const bNs = this.getTimestampFromTransitionProperties(b) ?? 0n;
+  private convertWmToPerfettoTransition(
+    wmTransition: WmTransition,
+  ): PerfettoTransition {
+    const perfettoTransition: PerfettoTransition = {
+      id: wmTransition.id,
+      createTimeNs: this.nullifyIfDefaultValue(wmTransition.createTimeNs),
+      sendTimeNs: this.nullifyIfDefaultValue(wmTransition.sendTimeNs),
+      wmAbortTimeNs: this.nullifyIfDefaultValue(wmTransition.abortTimeNs),
+      finishTimeNs: this.nullifyIfDefaultValue(wmTransition.finishTimeNs),
+      startTransactionId: this.nullifyIfDefaultValue(
+        wmTransition.startTransactionId,
+      ),
+      finishTransactionId: this.nullifyIfDefaultValue(
+        wmTransition.finishTransactionId,
+      ),
+      type: this.nullifyIfDefaultValue(wmTransition.type),
+      targets: this.nullifyIfDefaultValue(wmTransition.targets),
+      flags: this.nullifyIfDefaultValue(wmTransition.flags),
+      startingWindowRemoveTimeNs: this.nullifyIfDefaultValue(
+        wmTransition.startingWindowRemoveTimeNs,
+      ),
+    };
+    return perfettoTransition;
+  }
+
+  private convertShellToPerfettoTransition(
+    shellTransition: ShellTransition,
+  ): PerfettoTransition {
+    const perfettoTransition: PerfettoTransition = {
+      id: shellTransition.id,
+      dispatchTimeNs: this.nullifyIfDefaultValue(
+        shellTransition.dispatchTimeNs,
+      ),
+      mergeTimeNs: this.nullifyIfDefaultValue(shellTransition.mergeTimeNs),
+      mergeRequestTimeNs: this.nullifyIfDefaultValue(
+        shellTransition.mergeRequestTimeNs,
+      ),
+      shellAbortTimeNs: this.nullifyIfDefaultValue(shellTransition.abortTimeNs),
+      handler: this.nullifyIfDefaultValue(shellTransition.handler),
+      mergeTarget: this.nullifyIfDefaultValue(shellTransition.mergeTarget),
+    };
+    return perfettoTransition;
+  }
+
+  private nullifyIfDefaultValue<T extends TransitionProperty>(
+    value: T,
+  ): T | undefined {
+    if (this.isDefaultValue(value)) {
+      return undefined;
+    }
+    return value;
+  }
+
+  private isDefaultValue(value: TransitionProperty): boolean {
+    if (value instanceof Long && value.isZero()) {
+      return true;
+    } else if (typeof value === 'number' && value === 0) {
+      return true;
+    } else if (Array.isArray(value) && value.length === 0) {
+      return true;
+    }
+    return false;
+  }
+
+  private compareByTimestamp(
+    a: PerfettoTransition,
+    b: PerfettoTransition,
+  ): number {
+    const aNs = this.getTimestampNsFromTransitionProperties(a) ?? 0n;
+    const bNs = this.getTimestampNsFromTransitionProperties(b) ?? 0n;
     if (aNs !== bNs) {
       return aNs < bNs ? -1 : 1;
     }
     // fallback to id
-    return assertDefined(a.getChildByName('id')).getValue() <
-      assertDefined(b.getChildByName('id')).getValue()
-      ? -1
-      : 1;
+    assertTrue(a.id !== b.id);
+    return assertDefined(a.id) < assertDefined(b.id) ? -1 : 1;
   }
 
-  private getTimestampFromTransitionProperties(
-    transition: PropertyTreeNode,
-  ): Timestamp | undefined {
+  private getTimestampNsFromTransitionProperties(
+    transition: PerfettoTransition,
+  ): bigint | undefined {
     // Entry timestamps are defined as shell dispatch time - if this is
     // null and send time is not null we fall back on send time
-    return (
-      assertDefined(transition.getChildByName('shellData'))
-        .getChildByName('dispatchTimeNs')
-        ?.getValue() ??
-      assertDefined(transition.getChildByName('wmData'))
-        .getChildByName('sendTimeNs')
-        ?.getValue()
-    );
+    const ns = transition.dispatchTimeNs ?? transition.sendTimeNs;
+    if (!ns) {
+      return undefined;
+    }
+    return BigInt(ns.toString());
   }
 
   private mergePartialTransitions(
-    transition1: PropertyTreeNode,
-    transition2: PropertyTreeNode,
-  ): PropertyTreeNode {
-    const mergedTransition = this.mergeProperties(
-      transition1,
-      transition2,
-      false,
-    );
-
-    const wmData1 = assertDefined(transition1.getChildByName('wmData'));
-    const wmData2 = assertDefined(transition2.getChildByName('wmData'));
-    const mergedWmData = this.mergeProperties(wmData1, wmData2);
-    mergedTransition.addOrReplaceChild(mergedWmData);
-
-    const shellData1 = assertDefined(transition1.getChildByName('shellData'));
-    const shellData2 = assertDefined(transition2.getChildByName('shellData'));
-    const mergedShellData = this.mergeProperties(shellData1, shellData2);
-    mergedTransition.addOrReplaceChild(mergedShellData);
-
-    return mergedTransition;
-  }
-
-  private mergeProperties(
-    node1: PropertyTreeNode,
-    node2: PropertyTreeNode,
-    visitNestedChildren = true,
-  ): PropertyTreeNode {
-    const mergedNode = new PropertyTreeNode(
-      node1.id,
-      node1.name,
-      node1.source,
-      undefined,
-    );
-
-    node1.getAllChildren().forEach((property1) => {
-      if (!visitNestedChildren && property1.getAllChildren().length > 0) {
-        return;
-      }
-
-      const property2 = node2.getChildByName(property1.name);
-      if (
-        !property2 ||
-        property2.getValue()?.toString() < property1.getValue()?.toString()
-      ) {
-        mergedNode.addOrReplaceChild(property1);
-        return;
-      }
-
-      if (visitNestedChildren && property1.getAllChildren().length > 0) {
-        const mergedProperty = this.mergeProperties(property1, property2);
-        mergedNode.addOrReplaceChild(mergedProperty);
-        return;
-      }
-
-      mergedNode.addOrReplaceChild(property2);
-    });
-
-    node2.getAllChildren().forEach((property2) => {
-      const existingProperty = mergedNode.getChildByName(property2.name);
-      if (!existingProperty) {
-        mergedNode.addOrReplaceChild(property2);
-        return;
+    transition1: PerfettoTransition,
+    transition2: PerfettoTransition,
+  ): PerfettoTransition {
+    assertTrue(transition1.id === transition2.id);
+    const mergedTransition = Object.assign({}, transition1);
+    Object.entries(transition2).forEach(([key, value]) => {
+      if (value && !this.isDefaultValue(value)) {
+        Object.assign(mergedTransition, {[key]: value});
       }
     });
+    return mergedTransition;
+  }
 
-    return mergedNode;
+  private createHandlerMappingPacket(
+    sequenceId: number,
+  ): perfetto.protos.TracePacket {
+    const packet = perfetto.protos.TracePacket.create();
+    packet.trustedPacketSequenceId = sequenceId;
+    packet.shellHandlerMappings =
+      perfetto.protos.ShellHandlerMappings.fromObject({
+        mapping: this.shellHandlerMapping,
+      });
+    return packet;
   }
 }
+
+type WmTransition = com.android.server.wm.shell.ITransition;
+type ShellTransition = com.android.wm.shell.ITransition;
+type PerfettoTransition = perfetto.protos.IShellTransition;
+type TransitionTarget = perfetto.protos.ShellTransition.ITarget;
+type TransitionProperty = number | Long | TransitionTarget[] | null | undefined;
diff --git a/tools/winscope/src/parsers/transitions/legacy/traces_parser_transitions_test.ts b/tools/winscope/src/parsers/transitions/legacy/traces_parser_transitions_test.ts
index e72379821..bafcc75f1 100644
--- a/tools/winscope/src/parsers/transitions/legacy/traces_parser_transitions_test.ts
+++ b/tools/winscope/src/parsers/transitions/legacy/traces_parser_transitions_test.ts
@@ -16,24 +16,34 @@
 
 import {assertDefined} from 'common/assert_utils';
 import {
+  getTimestampConverter,
   TimestampConverterUtils,
   timestampEqualityTester,
 } from 'common/time/test_utils';
-import {UnitTestUtils} from 'test/unit/utils';
+import Long from 'long';
+import {FileAndParser} from 'parsers/file_and_parser';
+import {perfetto} from 'protos/perfetto/trace/static';
+import {com} from 'protos/transitions/udc/static';
+import {convertToPerfettoTrace, getTracesParser} from 'test/unit/fixture_utils';
 import {CoarseVersion} from 'trace/coarse_version';
 import {Parser} from 'trace/parser';
+import {TraceFile} from 'trace/trace_file';
 import {TraceType} from 'trace/trace_type';
+import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
+import {TracesParserTransitions} from './traces_parser_transitions';
 
 describe('TracesParserTransitions', () => {
   let parser: Parser<PropertyTreeNode>;
 
   beforeAll(async () => {
     jasmine.addCustomEqualityTester(timestampEqualityTester);
-    parser = (await UnitTestUtils.getTracesParser([
-      'traces/elapsed_and_real_timestamp/wm_transition_trace.pb',
-      'traces/elapsed_and_real_timestamp/shell_transition_trace.pb',
-    ])) as Parser<PropertyTreeNode>;
+    parser = (
+      await getTracesParser([
+        'traces/elapsed_and_real_timestamp/wm_transition_trace.pb',
+        'traces/elapsed_and_real_timestamp/shell_transition_trace.pb',
+      ])
+    ).tracesParser as Parser<PropertyTreeNode>;
   });
 
   it('has expected trace type', () => {
@@ -54,53 +64,226 @@ describe('TracesParserTransitions', () => {
   it('provides timestamps', () => {
     const timestamps = assertDefined(parser.getTimestamps());
     const expected = [
-      TimestampConverterUtils.makeRealTimestamp(1683188477606574664n),
-      TimestampConverterUtils.makeRealTimestamp(1683188477784695636n),
-      TimestampConverterUtils.makeRealTimestamp(1683188479255739215n),
-      TimestampConverterUtils.makeRealTimestamp(1683188481345218790n),
+      TimestampConverterUtils.makeRealTimestamp(1683188477607285317n),
+      TimestampConverterUtils.makeRealTimestamp(1683188477785406289n),
+      TimestampConverterUtils.makeRealTimestamp(1683188479256449868n),
+      TimestampConverterUtils.makeRealTimestamp(1683188481345929443n),
     ];
     expect(timestamps).toEqual(expected);
   });
 
-  it('provides entries', async () => {
-    const entryIds = [
-      (await parser.getEntry(0)).getChildByName('id')?.getValue(),
-      (await parser.getEntry(1)).getChildByName('id')?.getValue(),
-      (await parser.getEntry(2)).getChildByName('id')?.getValue(),
-      (await parser.getEntry(3)).getChildByName('id')?.getValue(),
-    ];
-    expect(entryIds).toEqual([6, 7, 8, 9]);
+  it('does not provide entry', () => {
+    expect(parser.getEntry).toThrow();
   });
 
   it('sets zero timestamp if both dispatch and send time unavailable', async () => {
-    const parser = (await UnitTestUtils.getTracesParser([
+    const result = await getTracesParser([
       'traces/elapsed_and_real_timestamp/wm_transition_trace.pb',
       'traces/elapsed_and_real_timestamp/shell_transition_trace.pb',
-    ])) as Parser<PropertyTreeNode>;
-    const entry = await parser.getEntry(1);
-    entry
-      .getChildByName('shellData')
-      ?.removeChild(entry.id + '.shellData.dispatchTimeNs');
-    entry
-      .getChildByName('wmData')
-      ?.removeChild(entry.id + '.wmData.sendTimeNs');
-
-    await parser.createTimestamps();
-    expect(parser.getTimestamps()?.at(1)).toEqual(
+    ]);
+    const transitionsParser = result.tracesParser as Parser<PropertyTreeNode>;
+    const wmParser = result
+      .constituentParsers[0] as Parser<com.android.server.wm.shell.ITransition>;
+    const shellParser = result
+      .constituentParsers[1] as Parser<com.android.wm.shell.ITransition>;
+
+    const shellEntry = await shellParser.getEntry(1);
+    shellEntry.dispatchTimeNs = null;
+    const shellSpy = spyOn(shellParser, 'getEntry').and.callThrough();
+    shellSpy.withArgs(1).and.returnValue(Promise.resolve(shellEntry));
+
+    const wmEntry = await wmParser.getEntry(1);
+    wmEntry.sendTimeNs = null;
+    const wmSpy = spyOn(wmParser, 'getEntry').and.callThrough();
+    wmSpy.withArgs(1).and.returnValue(Promise.resolve(wmEntry));
+
+    await (transitionsParser as TracesParserTransitions).parse();
+    expect(transitionsParser.getTimestamps()?.at(0)).toEqual(
       TimestampConverterUtils.makeRealTimestamp(0n),
     );
   });
 
   it('fails to parse without both wm and shell transition traces', async () => {
     await expectAsync(
-      UnitTestUtils.getTracesParser([
+      getTracesParser([
         'traces/elapsed_and_real_timestamp/wm_transition_trace.pb',
       ]),
     ).toBeRejected();
     await expectAsync(
-      UnitTestUtils.getTracesParser([
+      getTracesParser([
         'traces/elapsed_and_real_timestamp/shell_transition_trace.pb',
       ]),
     ).toBeRejected();
   });
+
+  it('converts to valid perfetto packets', () => {
+    const packets = parser.convertToPerfettoPackets!(10);
+    expect(packets.length).toEqual(5);
+    packets.forEach((packet) => {
+      expect(packet.trustedPacketSequenceId).toEqual(10);
+    });
+
+    const handlerMappingPacket = packets[0];
+
+    const shellHandlerMappings =
+      perfetto.protos.ShellHandlerMappings.fromObject({
+        mapping: [
+          {id: 2, name: 'com.android.wm.shell.transition.DefaultMixedHandler'},
+          {
+            id: 3,
+            name: 'com.android.wm.shell.recents.RecentsTransitionHandler',
+          },
+        ],
+      });
+    expect(handlerMappingPacket.shellHandlerMappings).toEqual(
+      shellHandlerMappings,
+    );
+
+    const transition6Packet = packets[1];
+    const transition6 = assertDefined(transition6Packet.shellTransition);
+    expect(transition6.id).toEqual(6);
+    const dispatchTime6 = Long.fromString('57649649922341');
+    expect(transition6Packet.timestamp).toEqual(dispatchTime6);
+    expect(transition6Packet.timestampClockId).toEqual(
+      perfetto.protos.ClockSnapshot.Clock.BuiltinClocks.BOOTTIME,
+    );
+    expect(transition6.createTimeNs).toEqual(Long.fromString('57649586217344'));
+    expect(transition6.sendTimeNs).toEqual(Long.fromString('57649646973488'));
+    expect(transition6.wmAbortTimeNs).toBeUndefined();
+    expect(transition6.finishTimeNs).toEqual(Long.fromString('57650183020323'));
+    expect(transition6.type).toEqual(1);
+    expect(transition6.targets?.length).toEqual(2);
+    expect(transition6.flags).toBeUndefined();
+    expect(transition6.startingWindowRemoveTimeNs).toBeUndefined();
+    expect(transition6.dispatchTimeNs).toEqual(dispatchTime6);
+    expect(transition6.mergeTimeNs).toBeUndefined();
+    expect(transition6.mergeRequestTimeNs).toBeUndefined();
+    expect(transition6.shellAbortTimeNs).toBeUndefined();
+    expect(transition6.handler).toEqual(2);
+    expect(transition6.mergeTarget).toBeUndefined();
+
+    const transition7Packet = packets[2];
+    const transition7 = assertDefined(transition7Packet.shellTransition);
+    expect(transition7.id).toEqual(7);
+    const sendTime7 = Long.fromString('57649828043313');
+    expect(transition7Packet.timestamp).toEqual(sendTime7);
+    expect(transition7Packet.timestampClockId).toEqual(
+      perfetto.protos.ClockSnapshot.Clock.BuiltinClocks.BOOTTIME,
+    );
+    expect(transition7.sendTimeNs).toEqual(sendTime7);
+    expect(transition7.dispatchTimeNs).toBeUndefined();
+    expect(transition7.mergeTimeNs).toEqual(Long.fromString('57649829526223'));
+    expect(transition7.shellAbortTimeNs).toEqual(
+      Long.fromString('57649829445249'),
+    );
+    expect(transition7.handler).toBeUndefined();
+
+    const transition8 = assertDefined(packets[3].shellTransition);
+    expect(transition8.id).toEqual(8);
+    expect(transition8.flags).toEqual(128);
+
+    const transition9 = assertDefined(packets[4].shellTransition);
+    expect(transition9.id).toEqual(9);
+    expect(transition9.mergeRequestTimeNs).toEqual(
+      Long.fromString('57653389780131'),
+    );
+    expect(transition9.mergeTarget).toEqual(8);
+  });
+
+  it('converts to valid perfetto trace', async () => {
+    const converter = getTimestampConverter();
+    const perfettoParser = (
+      await convertToPerfettoTrace(
+        [new FileAndParser(new TraceFile(new File([], '')), parser)],
+        converter,
+      )
+    )[0].parser as Parser<HierarchyTreeNode>;
+
+    converter.setRealToBootTimeOffsetNs(
+      assertDefined(perfettoParser.getRealToBootTimeOffsetNs()),
+    );
+    perfettoParser.createTimestamps();
+    expect(perfettoParser.getTimestamps()).toEqual([
+      TimestampConverterUtils.makeRealTimestamp(1683188477607285317n),
+      TimestampConverterUtils.makeRealTimestamp(1683188477785406289n),
+      TimestampConverterUtils.makeRealTimestamp(1683188479256449868n),
+      TimestampConverterUtils.makeRealTimestamp(1683188481345929443n),
+    ]);
+    const entries = [
+      await perfettoParser.getEntry(0),
+      await perfettoParser.getEntry(1),
+      await perfettoParser.getEntry(2),
+      await perfettoParser.getEntry(3),
+    ];
+    const entryIds = entries.map((e) =>
+      e.getEagerPropertyByName('transitionId')?.getValue(),
+    );
+    expect(entryIds).toEqual([6n, 7n, 8n, 9n]);
+
+    const entry = entries[2];
+    const entryProperties = await entry.getAllProperties();
+    expect(entry.getEagerPropertyByName('status')?.getValue()).toEqual(
+      'played',
+    );
+
+    checkEagerPropertyValue(entry, 'sendTimeNs', '2023-05-04, 08:21:19.252');
+    checkPropertyValue(entryProperties, 'startTransactionId', '13086765351920');
+    checkEagerPropertyValue(entry, 'flags', 'TRANSIT_FLAG_IS_RECENTS');
+
+    const layerParticipants = assertDefined(
+      entry.getEagerPropertyByName('layers'),
+    );
+    expect(layerParticipants.getAllChildren().length).toEqual(2);
+    checkPropertyValue(layerParticipants, '0', '113');
+    checkPropertyValue(layerParticipants, '1', '190');
+
+    const windowParticipants = assertDefined(
+      entry.getEagerPropertyByName('windows'),
+    );
+    expect(windowParticipants.getAllChildren().length).toEqual(2);
+    checkPropertyValue(windowParticipants, '0', '179781688');
+    checkPropertyValue(windowParticipants, '1', '184699222');
+
+    const targets = assertDefined(
+      entryProperties.getChildByName('targets'),
+    ).getAllChildren();
+    expect(targets.length).toEqual(2);
+    checkPropertyValue(targets[0], 'layerId', '113');
+    checkPropertyValue(targets[0], 'mode', 'TO_FRONT');
+    checkPropertyValue(
+      targets[0],
+      'flags',
+      'FLAG_MOVED_TO_TOP | FLAG_SHOW_WALLPAPER',
+    );
+    checkPropertyValue(targets[0], 'windowId', '179781688');
+
+    checkEagerPropertyValue(
+      entry,
+      'handler',
+      'com.android.wm.shell.recents.RecentsTransitionHandler',
+    );
+    checkPropertyValue(
+      entryProperties,
+      'handler',
+      'com.android.wm.shell.recents.RecentsTransitionHandler',
+    );
+  });
+
+  function checkEagerPropertyValue(
+    node: HierarchyTreeNode,
+    property: string,
+    value: string,
+  ) {
+    expect(node.getEagerPropertyByName(property)?.formattedValue()).toEqual(
+      value,
+    );
+  }
+
+  function checkPropertyValue(
+    node: PropertyTreeNode,
+    property: string,
+    value: string,
+  ) {
+    expect(node.getChildByName(property)?.formattedValue()).toEqual(value);
+  }
 });
diff --git a/tools/winscope/src/parsers/transitions/operations/add_duration.ts b/tools/winscope/src/parsers/transitions/operations/add_duration.ts
deleted file mode 100644
index ee2446511..000000000
--- a/tools/winscope/src/parsers/transitions/operations/add_duration.ts
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import {assertDefined} from 'common/assert_utils';
-import {Timestamp} from 'common/time/time';
-import {TimeDuration} from 'common/time/time_duration';
-import {TIMESTAMP_NODE_FORMATTER} from 'trace/tree_node/formatters';
-import {AddOperation} from 'trace/tree_node/operations/add_operation';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
-import {DEFAULT_PROPERTY_TREE_NODE_FACTORY} from 'trace/tree_node/property_tree_node_factory';
-
-export class AddDuration extends AddOperation<PropertyTreeNode> {
-  protected override makeProperties(
-    value: PropertyTreeNode,
-  ): PropertyTreeNode[] {
-    const wmDataNode = assertDefined(value.getChildByName('wmData'));
-
-    const sendTime: Timestamp | null | undefined = wmDataNode
-      .getChildByName('sendTimeNs')
-      ?.getValue();
-    const finishTime: Timestamp | null | undefined = wmDataNode
-      .getChildByName('finishTimeNs')
-      ?.getValue();
-
-    if (!sendTime || !finishTime) {
-      return [];
-    }
-
-    const timeDiffNs = finishTime.minus(sendTime.getValueNs()).getValueNs();
-    const timeDiff = new TimeDuration(timeDiffNs);
-
-    const durationNode =
-      DEFAULT_PROPERTY_TREE_NODE_FACTORY.makeCalculatedProperty(
-        value.id,
-        'duration',
-        timeDiff,
-      );
-    durationNode.setFormatter(TIMESTAMP_NODE_FORMATTER);
-
-    return [durationNode];
-  }
-}
diff --git a/tools/winscope/src/parsers/transitions/operations/add_duration_test.ts b/tools/winscope/src/parsers/transitions/operations/add_duration_test.ts
deleted file mode 100644
index 8d1bf629f..000000000
--- a/tools/winscope/src/parsers/transitions/operations/add_duration_test.ts
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import {TimestampConverterUtils} from 'common/time/test_utils';
-import {TimeDuration} from 'common/time/time_duration';
-import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
-import {TIMESTAMP_NODE_FORMATTER} from 'trace/tree_node/formatters';
-import {PropertySource} from 'trace/tree_node/property_tree_node';
-import {AddDuration} from './add_duration';
-
-describe('AddDuration', () => {
-  let operation: AddDuration;
-  const TIMESTAMP_10 = TimestampConverterUtils.makeRealTimestamp(10n);
-  const TIMESTAMP_30 = TimestampConverterUtils.makeRealTimestamp(30n);
-
-  beforeEach(() => {
-    operation = new AddDuration();
-  });
-
-  it('adds duration based on send and finish time', () => {
-    const propertyRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {
-          name: 'wmData',
-          children: [
-            {name: 'sendTimeNs', value: TIMESTAMP_10},
-            {name: 'finishTimeNs', value: TIMESTAMP_30},
-          ],
-        },
-      ])
-      .build();
-
-    const expectedRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {
-          name: 'wmData',
-          children: [
-            {name: 'sendTimeNs', value: TIMESTAMP_10},
-            {name: 'finishTimeNs', value: TIMESTAMP_30},
-          ],
-        },
-        {
-          name: 'duration',
-          value: new TimeDuration(20n),
-          source: PropertySource.CALCULATED,
-          formatter: TIMESTAMP_NODE_FORMATTER,
-        },
-      ])
-      .build();
-
-    operation.apply(propertyRoot);
-    expect(propertyRoot).toEqual(expectedRoot);
-  });
-
-  it('does not add duration due to missing send time', () => {
-    const propertyRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {
-          name: 'wmData',
-          children: [{name: 'finishTimeNs', value: TIMESTAMP_30}],
-        },
-      ])
-      .build();
-
-    const expectedRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {
-          name: 'wmData',
-          children: [{name: 'finishTimeNs', value: TIMESTAMP_30}],
-        },
-      ])
-      .build();
-
-    operation.apply(propertyRoot);
-    expect(propertyRoot).toEqual(expectedRoot);
-  });
-
-  it('does not add duration due to missing finish time', () => {
-    const propertyRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {name: 'wmData', children: [{name: 'sendTimeNs', value: TIMESTAMP_10}]},
-      ])
-      .build();
-
-    const expectedRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {name: 'wmData', children: [{name: 'sendTimeNs', value: TIMESTAMP_10}]},
-      ])
-      .build();
-
-    operation.apply(propertyRoot);
-    expect(propertyRoot).toEqual(expectedRoot);
-  });
-});
diff --git a/tools/winscope/src/parsers/transitions/operations/add_real_to_elapsed_time_offset_timestamp_test.ts b/tools/winscope/src/parsers/transitions/operations/add_real_to_elapsed_time_offset_timestamp_test.ts
deleted file mode 100644
index eb6523c54..000000000
--- a/tools/winscope/src/parsers/transitions/operations/add_real_to_elapsed_time_offset_timestamp_test.ts
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import {TimestampConverterUtils} from 'common/time/test_utils';
-import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
-import {PropertySource} from 'trace/tree_node/property_tree_node';
-import {AddRealToBootTimeOffsetTimestamp} from './add_real_to_elapsed_time_offset_timestamp';
-
-describe('AddRealToBootTimeOffsetTimestamp', () => {
-  it('adds undefined offset', () => {
-    const propertyRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .build();
-
-    const expectedRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {
-          name: 'realToBootTimeOffsetTimestamp',
-          value: undefined,
-          source: PropertySource.CALCULATED,
-        },
-      ])
-      .build();
-
-    const operation = new AddRealToBootTimeOffsetTimestamp(undefined);
-    operation.apply(propertyRoot);
-    expect(propertyRoot).toEqual(expectedRoot);
-  });
-
-  it('adds offset timestamp', () => {
-    const realToBootTimeOffsetTimestamp =
-      TimestampConverterUtils.TIMESTAMP_CONVERTER.makeTimestampFromMonotonicNs(
-        12345n,
-      );
-    const propertyRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .build();
-
-    const expectedRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {
-          name: 'realToBootTimeOffsetTimestamp',
-          value: realToBootTimeOffsetTimestamp,
-          source: PropertySource.CALCULATED,
-        },
-      ])
-      .build();
-
-    const operation = new AddRealToBootTimeOffsetTimestamp(
-      realToBootTimeOffsetTimestamp,
-    );
-    operation.apply(propertyRoot);
-    expect(propertyRoot).toEqual(expectedRoot);
-  });
-});
diff --git a/tools/winscope/src/parsers/transitions/operations/add_root_properties.ts b/tools/winscope/src/parsers/transitions/operations/add_root_properties.ts
deleted file mode 100644
index dc28d2d6d..000000000
--- a/tools/winscope/src/parsers/transitions/operations/add_root_properties.ts
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import {assertDefined} from 'common/assert_utils';
-import {AddOperation} from 'trace/tree_node/operations/add_operation';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
-import {DEFAULT_PROPERTY_TREE_NODE_FACTORY} from 'trace/tree_node/property_tree_node_factory';
-
-export class AddRootProperties extends AddOperation<PropertyTreeNode> {
-  protected override makeProperties(
-    value: PropertyTreeNode,
-  ): PropertyTreeNode[] {
-    const wmData = assertDefined(value.getChildByName('wmData'));
-    const shellData = assertDefined(value.getChildByName('shellData'));
-    const id = wmData.getChildByName('id') ?? shellData.getChildByName('id');
-
-    const rootIdNode =
-      DEFAULT_PROPERTY_TREE_NODE_FACTORY.makeCalculatedProperty(
-        value.id,
-        'id',
-        assertDefined(id).getValue(),
-      );
-
-    return [rootIdNode];
-  }
-}
diff --git a/tools/winscope/src/parsers/transitions/operations/add_root_properties_test.ts b/tools/winscope/src/parsers/transitions/operations/add_root_properties_test.ts
deleted file mode 100644
index b182409cd..000000000
--- a/tools/winscope/src/parsers/transitions/operations/add_root_properties_test.ts
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
-import {PropertySource} from 'trace/tree_node/property_tree_node';
-import {AddRootProperties} from './add_root_properties';
-
-describe('AddRootProperties', () => {
-  let operation: AddRootProperties;
-
-  beforeEach(() => {
-    operation = new AddRootProperties();
-  });
-
-  it('adds properties from wmData to root', () => {
-    const propertyRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {
-          name: 'wmData',
-          children: [{name: 'id', value: 10}],
-        },
-        {name: 'shellData', value: null},
-        {name: 'duration', value: 5n, source: PropertySource.CALCULATED},
-      ])
-      .build();
-
-    const expectedRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {
-          name: 'wmData',
-          children: [{name: 'id', value: 10}],
-        },
-        {name: 'shellData', value: null},
-        {name: 'duration', value: 5n, source: PropertySource.CALCULATED},
-        {name: 'id', value: 10, source: PropertySource.CALCULATED},
-      ])
-      .build();
-
-    operation.apply(propertyRoot);
-    expect(propertyRoot).toEqual(expectedRoot);
-  });
-
-  it('adds properties from shellData to root', () => {
-    const propertyRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {name: 'wmData', value: null},
-        {
-          name: 'shellData',
-          children: [{name: 'id', value: 10}],
-        },
-      ])
-      .build();
-
-    const expectedRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {name: 'wmData', value: null},
-        {
-          name: 'shellData',
-          children: [{name: 'id', value: 10}],
-        },
-        {name: 'id', value: 10, source: PropertySource.CALCULATED},
-      ])
-      .build();
-
-    operation.apply(propertyRoot);
-    expect(propertyRoot).toEqual(expectedRoot);
-  });
-
-  it('takes properties from wmData over shellData', () => {
-    const propertyRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {
-          name: 'wmData',
-          children: [{name: 'id', value: 10}],
-        },
-        {
-          name: 'shellData',
-          children: [{name: 'id', value: 20}],
-        },
-        {name: 'aborted', value: true, source: PropertySource.CALCULATED},
-      ])
-      .build();
-
-    const expectedRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {
-          name: 'wmData',
-          children: [{name: 'id', value: 10}],
-        },
-        {
-          name: 'shellData',
-          children: [{name: 'id', value: 20}],
-        },
-        {name: 'aborted', value: true, source: PropertySource.CALCULATED},
-        {name: 'id', value: 10, source: PropertySource.CALCULATED},
-      ])
-      .build();
-
-    operation.apply(propertyRoot);
-    expect(propertyRoot).toEqual(expectedRoot);
-  });
-});
diff --git a/tools/winscope/src/parsers/transitions/operations/add_status.ts b/tools/winscope/src/parsers/transitions/operations/add_status.ts
deleted file mode 100644
index ea12438fb..000000000
--- a/tools/winscope/src/parsers/transitions/operations/add_status.ts
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import {assertDefined} from 'common/assert_utils';
-import {AddOperation} from 'trace/tree_node/operations/add_operation';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
-import {DEFAULT_PROPERTY_TREE_NODE_FACTORY} from 'trace/tree_node/property_tree_node_factory';
-
-export class AddStatus extends AddOperation<PropertyTreeNode> {
-  protected override makeProperties(
-    value: PropertyTreeNode,
-  ): PropertyTreeNode[] {
-    const wmDataNode = assertDefined(value.getChildByName('wmData'));
-    const shellDataNode = assertDefined(value.getChildByName('shellData'));
-
-    const wmAborted =
-      wmDataNode.getChildByName('abortTimeNs')?.getValue()?.getValueNs() > 0n;
-    const shellAborted =
-      shellDataNode.getChildByName('abortTimeNs')?.getValue()?.getValueNs() >
-      0n;
-
-    const abortedNode =
-      DEFAULT_PROPERTY_TREE_NODE_FACTORY.makeCalculatedProperty(
-        value.id,
-        'aborted',
-        wmAborted || shellAborted,
-      );
-
-    const mergedNode =
-      DEFAULT_PROPERTY_TREE_NODE_FACTORY.makeCalculatedProperty(
-        value.id,
-        'merged',
-        shellDataNode.getChildByName('mergeTimeNs')?.getValue()?.getValueNs() >
-          0n,
-      );
-
-    const playedNode =
-      DEFAULT_PROPERTY_TREE_NODE_FACTORY.makeCalculatedProperty(
-        value.id,
-        'played',
-        wmDataNode.getChildByName('finishTimeNs')?.getValue()?.getValueNs() >
-          0n,
-      );
-
-    return [abortedNode, mergedNode, playedNode];
-  }
-}
diff --git a/tools/winscope/src/parsers/transitions/operations/add_status_test.ts b/tools/winscope/src/parsers/transitions/operations/add_status_test.ts
deleted file mode 100644
index f6c63169a..000000000
--- a/tools/winscope/src/parsers/transitions/operations/add_status_test.ts
+++ /dev/null
@@ -1,244 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import {TimestampConverterUtils} from 'common/time/test_utils';
-import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
-import {PropertySource} from 'trace/tree_node/property_tree_node';
-import {AddStatus} from './add_status';
-
-describe('AddStatus', () => {
-  let operation: AddStatus;
-  const time0 = TimestampConverterUtils.makeRealTimestamp(0n);
-  const time10 = TimestampConverterUtils.makeRealTimestamp(10n);
-
-  beforeEach(() => {
-    operation = new AddStatus();
-  });
-
-  it('adds aborted true due to wm abort time', () => {
-    const propertyRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {name: 'wmData', children: [{name: 'abortTimeNs', value: time10}]},
-        {name: 'shellData', value: null},
-      ])
-      .build();
-
-    const expectedRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {name: 'wmData', children: [{name: 'abortTimeNs', value: time10}]},
-        {name: 'shellData', value: null},
-        {name: 'aborted', value: true, source: PropertySource.CALCULATED},
-        {name: 'merged', value: false, source: PropertySource.CALCULATED},
-        {name: 'played', value: false, source: PropertySource.CALCULATED},
-      ])
-      .build();
-
-    operation.apply(propertyRoot);
-    expect(propertyRoot).toEqual(expectedRoot);
-  });
-
-  it('adds aborted true due to shell abort time', () => {
-    const propertyRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {name: 'shellData', children: [{name: 'abortTimeNs', value: time10}]},
-        {name: 'wmData', value: null},
-      ])
-      .build();
-
-    const expectedRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {name: 'shellData', children: [{name: 'abortTimeNs', value: time10}]},
-        {name: 'wmData', value: null},
-        {name: 'aborted', value: true, source: PropertySource.CALCULATED},
-        {name: 'merged', value: false, source: PropertySource.CALCULATED},
-        {name: 'played', value: false, source: PropertySource.CALCULATED},
-      ])
-      .build();
-
-    operation.apply(propertyRoot);
-    expect(propertyRoot).toEqual(expectedRoot);
-  });
-
-  it('adds aborted false due to 0 abort time', () => {
-    const propertyRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {name: 'wmData', children: [{name: 'abortTimeNs', value: time0}]},
-        {name: 'shellData', children: [{name: 'abortTimeNs', value: time0}]},
-      ])
-      .build();
-
-    const expectedRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {name: 'wmData', children: [{name: 'abortTimeNs', value: time0}]},
-        {
-          name: 'shellData',
-          children: [{name: 'abortTimeNs', value: time0}],
-        },
-        {name: 'aborted', value: false, source: PropertySource.CALCULATED},
-        {name: 'merged', value: false, source: PropertySource.CALCULATED},
-        {name: 'played', value: false, source: PropertySource.CALCULATED},
-      ])
-      .build();
-
-    operation.apply(propertyRoot);
-    expect(propertyRoot).toEqual(expectedRoot);
-  });
-
-  it('adds merged true', () => {
-    const propertyRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {name: 'wmData', value: null},
-        {name: 'shellData', children: [{name: 'mergeTimeNs', value: time10}]},
-      ])
-      .build();
-
-    const expectedRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {name: 'wmData', value: null},
-        {
-          name: 'shellData',
-          children: [{name: 'mergeTimeNs', value: time10}],
-        },
-        {name: 'aborted', value: false, source: PropertySource.CALCULATED},
-        {name: 'merged', value: true, source: PropertySource.CALCULATED},
-        {name: 'played', value: false, source: PropertySource.CALCULATED},
-      ])
-      .build();
-
-    operation.apply(propertyRoot);
-    expect(propertyRoot).toEqual(expectedRoot);
-  });
-
-  it('adds merged false due to 0 merge time', () => {
-    const propertyRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {name: 'wmData', value: null},
-        {name: 'shellData', children: [{name: 'mergeTimeNs', value: time0}]},
-      ])
-      .build();
-
-    const expectedRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {name: 'wmData', value: null},
-        {
-          name: 'shellData',
-          children: [{name: 'mergeTimeNs', value: time0}],
-        },
-        {name: 'aborted', value: false, source: PropertySource.CALCULATED},
-        {name: 'merged', value: false, source: PropertySource.CALCULATED},
-        {name: 'played', value: false, source: PropertySource.CALCULATED},
-      ])
-      .build();
-
-    operation.apply(propertyRoot);
-    expect(propertyRoot).toEqual(expectedRoot);
-  });
-
-  it('adds played true', () => {
-    const propertyRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {
-          name: 'wmData',
-          children: [{name: 'finishTimeNs', value: time10}],
-        },
-        {name: 'shellData', value: null},
-      ])
-      .build();
-
-    const expectedRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {
-          name: 'wmData',
-          children: [{name: 'finishTimeNs', value: time10}],
-        },
-        {name: 'shellData', value: null},
-        {name: 'aborted', value: false, source: PropertySource.CALCULATED},
-        {name: 'merged', value: false, source: PropertySource.CALCULATED},
-        {name: 'played', value: true, source: PropertySource.CALCULATED},
-      ])
-      .build();
-
-    operation.apply(propertyRoot);
-    expect(propertyRoot).toEqual(expectedRoot);
-  });
-
-  it('adds played false due to 0 finish time', () => {
-    const propertyRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {name: 'wmData', value: null},
-        {name: 'shellData', children: [{name: 'finishTimeNs', value: time0}]},
-      ])
-      .build();
-
-    const expectedRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {name: 'wmData', value: null},
-        {
-          name: 'shellData',
-          children: [{name: 'finishTimeNs', value: time0}],
-        },
-        {name: 'aborted', value: false, source: PropertySource.CALCULATED},
-        {name: 'merged', value: false, source: PropertySource.CALCULATED},
-        {name: 'played', value: false, source: PropertySource.CALCULATED},
-      ])
-      .build();
-
-    operation.apply(propertyRoot);
-    expect(propertyRoot).toEqual(expectedRoot);
-  });
-});
diff --git a/tools/winscope/src/parsers/transitions/operations/add_real_to_elapsed_time_offset_timestamp.ts b/tools/winscope/src/parsers/transitions/operations/transform_duration.ts
similarity index 57%
rename from tools/winscope/src/parsers/transitions/operations/add_real_to_elapsed_time_offset_timestamp.ts
rename to tools/winscope/src/parsers/transitions/operations/transform_duration.ts
index e09b4970b..555741e14 100644
--- a/tools/winscope/src/parsers/transitions/operations/add_real_to_elapsed_time_offset_timestamp.ts
+++ b/tools/winscope/src/parsers/transitions/operations/transform_duration.ts
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2024 The Android Open Source Project
+ * Copyright (C) 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,27 +14,23 @@
  * limitations under the License.
  */
 
-import {Timestamp} from 'common/time/time';
+import {TimeDuration} from 'common/time/time_duration';
 import {AddOperation} from 'trace/tree_node/operations/add_operation';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 import {DEFAULT_PROPERTY_TREE_NODE_FACTORY} from 'trace/tree_node/property_tree_node_factory';
 
-export class AddRealToBootTimeOffsetTimestamp extends AddOperation<PropertyTreeNode> {
-  constructor(
-    private readonly realToBootTimeOffsetTimestamp: Timestamp | undefined,
-  ) {
-    super();
-  }
-  protected override makeProperties(
-    value: PropertyTreeNode,
-  ): PropertyTreeNode[] {
-    const offsetNode =
-      DEFAULT_PROPERTY_TREE_NODE_FACTORY.makeCalculatedProperty(
+export class TransformDuration extends AddOperation<PropertyTreeNode> {
+  override makeProperties(value: PropertyTreeNode): PropertyTreeNode[] {
+    const durationNs = value.getChildByName('durationNs');
+    if (durationNs === null || durationNs === undefined) {
+      return [];
+    }
+    const transformedDuration =
+      DEFAULT_PROPERTY_TREE_NODE_FACTORY.makeTpProperty(
         value.id,
-        'realToBootTimeOffsetTimestamp',
-        this.realToBootTimeOffsetTimestamp,
+        durationNs.name,
+        new TimeDuration(BigInt(durationNs.getValue()?.toString())),
       );
-
-    return [offsetNode];
+    return [transformedDuration];
   }
 }
diff --git a/tools/winscope/src/parsers/transitions/operations/transform_duration_test.ts b/tools/winscope/src/parsers/transitions/operations/transform_duration_test.ts
new file mode 100644
index 000000000..b7c2af62f
--- /dev/null
+++ b/tools/winscope/src/parsers/transitions/operations/transform_duration_test.ts
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import {TimeDuration} from 'common/time/time_duration';
+import Long from 'long';
+import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
+import {PropertySource} from 'trace/tree_node/property_tree_node';
+import {TransformDuration} from './transform_duration';
+
+describe('TransformDuration', () => {
+  const expectedRootWithDuration = new PropertyTreeBuilder()
+    .setIsRoot(true)
+    .setRootId('TransitionsTraceEntry')
+    .setName('transition')
+    .setChildren([
+      {
+        name: 'durationNs',
+        value: new TimeDuration(123456n),
+        source: PropertySource.TP,
+      },
+    ])
+    .build();
+
+  it('transforms duration from bigint', () => {
+    const propertyRoot = new PropertyTreeBuilder()
+      .setIsRoot(true)
+      .setRootId('TransitionsTraceEntry')
+      .setName('transition')
+      .setChildren([{name: 'durationNs', value: 123456n}])
+      .build();
+
+    new TransformDuration().apply(propertyRoot);
+    expect(propertyRoot).toEqual(expectedRootWithDuration);
+  });
+  it('transforms duration from long', () => {
+    const propertyRoot = new PropertyTreeBuilder()
+      .setIsRoot(true)
+      .setRootId('TransitionsTraceEntry')
+      .setName('transition')
+      .setChildren([{name: 'durationNs', value: Long.fromNumber(123456)}])
+      .build();
+
+    new TransformDuration().apply(propertyRoot);
+    expect(propertyRoot).toEqual(expectedRootWithDuration);
+  });
+
+  it('robust to missing duration', () => {
+    const propertyRoot = new PropertyTreeBuilder()
+      .setIsRoot(true)
+      .setRootId('TransitionsTraceEntry')
+      .setName('transition')
+      .setChildren([{name: 'duration', value: 123456n}])
+      .build();
+
+    new TransformDuration().apply(propertyRoot);
+    expect(propertyRoot).toEqual(propertyRoot);
+  });
+});
diff --git a/tools/winscope/src/parsers/transitions/operations/update_abort_time_nodes.ts b/tools/winscope/src/parsers/transitions/operations/update_abort_time_nodes.ts
deleted file mode 100644
index b6344a29b..000000000
--- a/tools/winscope/src/parsers/transitions/operations/update_abort_time_nodes.ts
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import {Operation} from 'trace/tree_node/operations/operation';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
-import {DEFAULT_PROPERTY_TREE_NODE_FACTORY} from 'trace/tree_node/property_tree_node_factory';
-
-export class UpdateAbortTimeNodes implements Operation<PropertyTreeNode> {
-  apply(value: PropertyTreeNode) {
-    const wmDataNode = value.getChildByName('wmData');
-    const shellDataNode = value.getChildByName('shellData');
-
-    const existingWmAbortTime = wmDataNode?.getChildByName('wmAbortTimeNs');
-    if (wmDataNode && existingWmAbortTime) {
-      const newAbortTimeNode = this.makeNewAbortTimeNode(
-        wmDataNode.id,
-        existingWmAbortTime,
-      );
-      wmDataNode.addOrReplaceChild(newAbortTimeNode);
-      wmDataNode.removeChild(existingWmAbortTime.id);
-    }
-
-    const existingShellAbortTime =
-      shellDataNode?.getChildByName('shellAbortTimeNs');
-    if (shellDataNode && existingShellAbortTime) {
-      const newAbortTimeNode = this.makeNewAbortTimeNode(
-        shellDataNode.id,
-        existingShellAbortTime,
-      );
-      shellDataNode.addOrReplaceChild(newAbortTimeNode);
-      shellDataNode.removeChild(existingShellAbortTime.id);
-    }
-  }
-
-  makeNewAbortTimeNode(rootId: string, existingNode: PropertyTreeNode) {
-    return DEFAULT_PROPERTY_TREE_NODE_FACTORY.makeProtoProperty(
-      rootId,
-      'abortTimeNs',
-      existingNode.getValue(),
-    );
-  }
-}
diff --git a/tools/winscope/src/parsers/transitions/operations/update_abort_time_nodes_test.ts b/tools/winscope/src/parsers/transitions/operations/update_abort_time_nodes_test.ts
deleted file mode 100644
index 622216d38..000000000
--- a/tools/winscope/src/parsers/transitions/operations/update_abort_time_nodes_test.ts
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
-import {UpdateAbortTimeNodes} from './update_abort_time_nodes';
-
-describe('UpdateAbortTimeNodes', () => {
-  let operation: UpdateAbortTimeNodes;
-
-  beforeEach(() => {
-    operation = new UpdateAbortTimeNodes();
-  });
-
-  it('updates wmAbortTimeNs', () => {
-    const propertyRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {name: 'wmData', children: [{name: 'wmAbortTimeNs', value: 10n}]},
-      ])
-      .build();
-
-    const expectedRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {name: 'wmData', children: [{name: 'abortTimeNs', value: 10n}]},
-      ])
-      .build();
-
-    operation.apply(propertyRoot);
-    expect(propertyRoot).toEqual(expectedRoot);
-  });
-
-  it('updates shellAbortTimeNs', () => {
-    const propertyRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {name: 'shellData', children: [{name: 'shellAbortTimeNs', value: 10n}]},
-      ])
-      .build();
-
-    const expectedRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {name: 'shellData', children: [{name: 'abortTimeNs', value: 10n}]},
-      ])
-      .build();
-
-    operation.apply(propertyRoot);
-    expect(propertyRoot).toEqual(expectedRoot);
-  });
-
-  it('leaves legacy abortTimeNs alone', () => {
-    const propertyRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {name: 'shellData', children: [{name: 'abortTimeNs', value: 10n}]},
-        {name: 'wmData', children: [{name: 'abortTimeNs', value: 10n}]},
-      ])
-      .build();
-
-    const expectedRoot = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionsTraceEntry')
-      .setName('transition')
-      .setChildren([
-        {name: 'shellData', children: [{name: 'abortTimeNs', value: 10n}]},
-        {name: 'wmData', children: [{name: 'abortTimeNs', value: 10n}]},
-      ])
-      .build();
-
-    operation.apply(propertyRoot);
-    expect(propertyRoot).toEqual(expectedRoot);
-  });
-});
diff --git a/tools/winscope/src/parsers/transitions/perfetto/parser_transitions.ts b/tools/winscope/src/parsers/transitions/perfetto/parser_transitions.ts
index ff1dff363..174e37797 100644
--- a/tools/winscope/src/parsers/transitions/perfetto/parser_transitions.ts
+++ b/tools/winscope/src/parsers/transitions/perfetto/parser_transitions.ts
@@ -13,46 +13,107 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-import {assertDefined} from 'common/assert_utils';
+
+import {
+  assertBigIntOrUndefined,
+  assertDefined,
+  assertString,
+} from 'common/assert_utils';
+import {MakeTimestampStrategyType} from 'common/time/time';
+import {ParserTimestampConverter} from 'common/time/timestamp_converter';
+import {HierarchyTreeBuilderLog} from 'parsers/hierarchy_tree_builder_log';
+import {AddDefaults} from 'parsers/operations/add_defaults';
+import {SetFormatters} from 'parsers/operations/set_formatters';
+import {TransformToTimestamp} from 'parsers/operations/transform_to_timestamp';
+import {TranslateIntDef} from 'parsers/operations/translate_intdef';
 import {AbstractParser} from 'parsers/perfetto/abstract_parser';
-import {FakeProtoBuilder} from 'parsers/perfetto/fake_proto_builder';
-import {EntryPropertiesTreeFactory} from 'parsers/transitions/entry_properties_tree_factory';
-import {perfetto} from 'protos/transitions/latest/static';
+import {FakeProtoTransformer} from 'parsers/perfetto/fake_proto_transformer';
+import {queryArgs} from 'parsers/perfetto/utils';
+import {PropertyTreeBuilderFromProto} from 'parsers/property_tree_builder_from_proto';
+import {PropertyTreeBuilderFromQueryRow} from 'parsers/property_tree_builder_from_query_row';
+import {TAMPERED_TRACE_PACKET} from 'parsers/tampered_message_type';
+import {TransformDuration} from 'parsers/transitions/operations/transform_duration';
+import {TransitionType} from 'parsers/transitions/transition_type';
 import {TraceType} from 'trace/trace_type';
+import {
+  EnumFormatter,
+  PropertyFormatter,
+  TIMESTAMP_NODE_FORMATTER,
+  UPPER_CASE_FORMATTER,
+} from 'trace/tree_node/formatters';
+import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
+import {Operation} from 'trace/tree_node/operations/operation';
+import {PropertiesProvider} from 'trace/tree_node/properties_provider';
+import {PropertiesProviderBuilder} from 'trace/tree_node/properties_provider_builder';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
+import {
+  QueryResult,
+  RowIteratorBase,
+  SqlValue,
+} from 'trace_processor/query_result';
+
+export class ParserTransitions extends AbstractParser<HierarchyTreeNode> {
+  private static readonly TRANSITION_FIELD =
+    TAMPERED_TRACE_PACKET.fields['shellTransition'];
+  private static readonly PROTO_TRANSFORMER = new FakeProtoTransformer(
+    assertDefined(ParserTransitions.TRANSITION_FIELD.tamperedMessageType),
+  );
+  private static readonly EAGER_COLUMNS = [
+    'transition_id',
+    'arg_set_id',
+    'transition_type',
+    'send_time_ns',
+    'dispatch_time_ns',
+    'duration_ns',
+    'handler',
+    'status',
+    'flags',
+  ];
+  private static readonly EAGER_TIMESTAMP_PROPERTIES = [
+    'wmAbortTimeNs',
+    'shellAbortTimeNs',
+    'sendTimeNs',
+    'dispatchTimeNs',
+  ];
+  private static readonly LAZY_TIMESTAMP_PROPERTIES = [
+    'wmAbortTimeNs',
+    'shellAbortTimeNs',
+    'createTimeNs',
+    'sendTimeNs',
+    'finishTimeNs',
+    'startingWindowRemoveTimeNs',
+    'dispatchTimeNs',
+    'mergeRequestTimeNs',
+    'mergeTimeNs',
+  ];
+  private static readonly TRANSFORM_DURATION_OPERATION =
+    new TransformDuration();
+  private static readonly TRANSLATE_INTDEF_OPERATION = new TranslateIntDef(
+    ParserTransitions.TRANSITION_FIELD,
+  );
+  private static readonly ADD_DEFAULTS_OPERATION = new AddDefaults(
+    ParserTransitions.TRANSITION_FIELD,
+    ['type', 'targets'],
+  );
+  private static readonly TRANSITION_TYPE_FORMATTER = new EnumFormatter(
+    TransitionType,
+  );
 
-export class ParserTransitions extends AbstractParser<PropertyTreeNode> {
   private handlerIdToName: {[id: number]: string} | undefined = undefined;
-  private readonly internalTableName = 'window_manager_shell_transitions';
-
-  protected override async preProcessTrace() {
-    // Entry timestamps are defined as shell dispatch time, which corresponds
-    // to the ts column of the internal Perfetto table - if this is 0 and
-    // send time is not null we fall back on send time
-    const sql = `
-      CREATE PERFETTO TABLE ${this.getTableName()} AS
-      SELECT
-        STATE.id as id,
-        CASE
-          WHEN (STATE.ts = 0 AND TRANS.int_value IS NOT NULL) THEN TRANS.int_value
-          ELSE STATE.ts END
-        AS ts,
-        STATE.transition_id,
-        STATE.arg_set_id
-      FROM ${this.internalTableName} STATE
-      LEFT JOIN args TRANS
-        ON TRANS.arg_set_id = STATE.arg_set_id AND TRANS.key = 'send_time_ns'
-      ORDER BY id;
-   `;
-    await this.traceProcessor.queryAllRows(sql);
-  }
 
   override getTraceType(): TraceType {
     return TraceType.TRANSITION;
   }
 
-  override async getEntry(index: number): Promise<PropertyTreeNode> {
-    const transitionProto = await this.queryEntry(index);
+  override async getEntry(index: number): Promise<HierarchyTreeNode> {
+    const columns = ParserTransitions.EAGER_COLUMNS.map(
+      (column) => `transitions.${column}`,
+    ).join(', ');
+    const sql =
+      `SELECT ${columns} FROM ${this.getTableName()} as transitions` +
+      ` WHERE transitions.id = ${this.entryIndexToRowIdMap[index]};`;
+    const queryResult = await this.traceProcessor.query(sql);
+
     if (this.handlerIdToName === undefined) {
       const handlers = await this.queryHandlers();
       this.handlerIdToName = {};
@@ -60,127 +121,180 @@ export class ParserTransitions extends AbstractParser<PropertyTreeNode> {
         (it) => (assertDefined(this.handlerIdToName)[it.id] = it.name),
       );
     }
-    return this.makePropertiesTree(transitionProto);
+    return this.makeHierarchyTree(queryResult);
   }
 
   protected override getTableName(): string {
-    return 'transitions_with_updated_ts';
+    return 'window_manager_shell_transitions';
   }
 
-  private async queryEntry(
-    index: number,
-  ): Promise<perfetto.protos.ShellTransition> {
-    const protoBuilder = new FakeProtoBuilder();
-
-    const sql = `
-      SELECT
-        transitions.transition_id,
-        args.key,
-        args.value_type,
-        args.int_value,
-        args.string_value,
-        args.real_value
-      FROM
-        ${this.getTableName()} as transitions
-        INNER JOIN args ON transitions.arg_set_id = args.arg_set_id
-      WHERE transitions.id = ${this.entryIndexToRowIdMap[index]};
-    `;
-    const result = await this.traceProcessor.queryAllRows(sql);
+  protected override getStdLibModuleName(): string {
+    return 'android.winscope.transitions';
+  }
 
+  private async queryHandlers(): Promise<TransitionHandler[]> {
+    const sql =
+      'SELECT handler_id, handler_name FROM window_manager_shell_transition_handlers;';
+    const result = await this.traceProcessor.query(sql);
+
+    const handlers: TransitionHandler[] = [];
     for (const it = result.iter({}); it.valid(); it.next()) {
-      protoBuilder.addArg(
-        it.get('key') as string,
-        it.get('value_type') as string,
-        it.get('int_value') as bigint | undefined,
-        it.get('real_value') as number | undefined,
-        it.get('string_value') as string | undefined,
-      );
+      const handlerid = assertBigIntOrUndefined(it.get('handler_id'));
+      if (handlerid === undefined) continue;
+      handlers.push({
+        id: Number(handlerid),
+        name: assertString(it.get('handler_name')),
+      });
     }
 
-    return protoBuilder.build();
+    return handlers;
+  }
+
+  private async makeHierarchyTree(
+    result: QueryResult,
+  ): Promise<HierarchyTreeNode> {
+    const transitionRow = result.iter({});
+    const transition = await this.makeTransitionsPropertiesProvider(
+      transitionRow,
+    );
+    return new HierarchyTreeBuilderLog()
+      .setRoot(transition)
+      .setChildren([])
+      .build();
   }
 
-  private makePropertiesTree(
-    transitionProto: perfetto.protos.ShellTransition,
-  ): PropertyTreeNode {
-    this.validatePerfettoTransition(transitionProto);
+  private async makeTransitionsPropertiesProvider(
+    transitionRow: RowIteratorBase,
+  ): Promise<PropertiesProvider> {
+    const eagerProperties = await this.makeEagerPropertiesTree(transitionRow);
 
-    const perfettoTransitionInfo = {
-      entry: transitionProto,
-      realToBootTimeOffsetNs: undefined,
-      handlerMapping: this.handlerIdToName,
-      timestampConverter: this.timestampConverter,
-    };
+    const builder = new PropertiesProviderBuilder()
+      .setEagerProperties(eagerProperties)
+      .setEagerOperations(this.getEagerOperations());
 
-    const shellEntryTree = EntryPropertiesTreeFactory.makeShellPropertiesTree(
-      perfettoTransitionInfo,
-      [
-        'createTimeNs',
-        'sendTimeNs',
-        'wmAbortTimeNs',
-        'finishTimeNs',
-        'startTransactionId',
-        'finishTransactionId',
-        'type',
-        'targets',
-        'flags',
-        'startingWindowRemoveTimeNs',
-      ],
+    const argSetId = transitionRow.get('arg_set_id') ?? undefined;
+    if (argSetId !== undefined) {
+      builder
+        .setLazyPropertiesStrategy(this.makeLazyPropertiesStrategy(argSetId))
+        .setLazyOperations(this.getLazyOperations());
+    }
+
+    return builder.build();
+  }
+
+  private async makeEagerPropertiesTree(
+    transitionRow: RowIteratorBase,
+  ): Promise<PropertyTreeNode> {
+    const eagerProperties = new PropertyTreeBuilderFromQueryRow()
+      .setData(transitionRow)
+      .setColumns(ParserTransitions.EAGER_COLUMNS)
+      .setRootId('TransitionTraceEntry')
+      .setRootName('Transition')
+      .build();
+
+    const participants = await this.makeParticipants(transitionRow);
+    eagerProperties.addOrReplaceChild(
+      assertDefined(participants.getChildByName('layers')),
+    );
+    eagerProperties.addOrReplaceChild(
+      assertDefined(participants.getChildByName('windows')),
     );
-    const wmEntryTree = EntryPropertiesTreeFactory.makeWmPropertiesTree(
-      perfettoTransitionInfo,
-      [
-        'dispatchTimeNs',
-        'mergeTimeNs',
-        'mergeRequestTimeNs',
-        'shellAbortTimeNs',
-        'handler',
-        'mergeTarget',
-      ],
+    return eagerProperties;
+  }
+
+  private async makeParticipants(
+    transitionRow: RowIteratorBase,
+  ): Promise<PropertyTreeNode> {
+    const transitionId = assertDefined(
+      transitionRow.get('transition_id'),
+      () => 'transition requires non-null id',
     );
 
-    return EntryPropertiesTreeFactory.makeTransitionPropertiesTree(
-      shellEntryTree,
-      wmEntryTree,
+    const participantsSql =
+      'SELECT DISTINCT window_id, layer_id from android_window_manager_shell_transition_participants' +
+      ` WHERE transition_id = ${transitionId}`;
+    const participantsRes = await this.traceProcessor.query(participantsSql);
+
+    const layers = [];
+    const windows = [];
+    for (const it = participantsRes.iter({}); it.valid(); it.next()) {
+      const layer = it.get('layer_id') ?? undefined;
+      if (layer !== undefined) {
+        layers.push(layer);
+      }
+      const window = it.get('window_id') ?? undefined;
+      if (window !== undefined) {
+        windows.push(window);
+      }
+    }
+    return new PropertyTreeBuilderFromProto()
+      .setData({layers, windows})
+      .setRootId('TransitionTraceEntry')
+      .setRootName('Transition')
+      .build();
+  }
+
+  private getEagerOperations(): Array<Operation<PropertyTreeNode>> {
+    const transformToTimestampEager = new TransformToTimestamp(
+      ParserTransitions.EAGER_TIMESTAMP_PROPERTIES,
+      ParserTransitions.makeTimestampStrategy(this.timestampConverter),
     );
+
+    const customFormattersEager = new Map<string, PropertyFormatter>([
+      ['transitionType', ParserTransitions.TRANSITION_TYPE_FORMATTER],
+      ['handler', new EnumFormatter(assertDefined(this.handlerIdToName))],
+      ['status', UPPER_CASE_FORMATTER],
+      ['durationNs', TIMESTAMP_NODE_FORMATTER],
+    ]);
+
+    return [
+      transformToTimestampEager,
+      ParserTransitions.TRANSFORM_DURATION_OPERATION,
+      new SetFormatters(
+        ParserTransitions.TRANSITION_FIELD,
+        customFormattersEager,
+      ),
+      ParserTransitions.TRANSLATE_INTDEF_OPERATION,
+    ];
   }
 
-  private async queryHandlers(): Promise<TransitionHandler[]> {
-    const sql =
-      'SELECT handler_id, handler_name FROM window_manager_shell_transition_handlers;';
-    const result = await this.traceProcessor.queryAllRows(sql);
+  private getLazyOperations(): Array<Operation<PropertyTreeNode>> {
+    const transformToTimestamp = new TransformToTimestamp(
+      ParserTransitions.LAZY_TIMESTAMP_PROPERTIES,
+      ParserTransitions.makeTimestampStrategy(this.timestampConverter),
+    );
 
-    const handlers: TransitionHandler[] = [];
-    for (const it = result.iter({}); it.valid(); it.next()) {
-      handlers.push({
-        id: it.get('handler_id') as number,
-        name: it.get('handler_name') as string,
-      });
-    }
+    const customFormatters = new Map<string, PropertyFormatter>([
+      ['type', ParserTransitions.TRANSITION_TYPE_FORMATTER],
+      ['mode', ParserTransitions.TRANSITION_TYPE_FORMATTER],
+      ['handler', new EnumFormatter(assertDefined(this.handlerIdToName))],
+    ]);
 
-    return handlers;
+    return [
+      ParserTransitions.ADD_DEFAULTS_OPERATION,
+      transformToTimestamp,
+      new SetFormatters(ParserTransitions.TRANSITION_FIELD, customFormatters),
+      ParserTransitions.TRANSLATE_INTDEF_OPERATION,
+    ];
   }
 
-  private validatePerfettoTransition(
-    transition: perfetto.protos.IShellTransition,
-  ) {
-    if (transition.id === 0) {
-      throw new Error('Transitions entry need a non null id');
-    }
-    if (
-      !transition.createTimeNs &&
-      !transition.sendTimeNs &&
-      !transition.wmAbortTimeNs &&
-      !transition.finishTimeNs &&
-      !transition.dispatchTimeNs &&
-      !transition.mergeRequestTimeNs &&
-      !transition.mergeTimeNs &&
-      !transition.shellAbortTimeNs
-    ) {
-      throw new Error(
-        'Transitions entry requires at least one non-null timestamp',
-      );
-    }
+  private makeLazyPropertiesStrategy(argSetId: SqlValue) {
+    return async () => {
+      const data = await queryArgs(this.traceProcessor, Number(argSetId));
+      return new PropertyTreeBuilderFromProto()
+        .setData(ParserTransitions.PROTO_TRANSFORMER.transform(data))
+        .setRootId('TransitionTraceEntry')
+        .setRootName('Transition')
+        .build();
+    };
+  }
+
+  private static makeTimestampStrategy(
+    timestampConverter: ParserTimestampConverter,
+  ): MakeTimestampStrategyType {
+    return (valueNs: bigint) => {
+      return timestampConverter.makeTimestampFromBootTimeNs(valueNs);
+    };
   }
 }
 
diff --git a/tools/winscope/src/parsers/transitions/perfetto/parser_transitions_test.ts b/tools/winscope/src/parsers/transitions/perfetto/parser_transitions_test.ts
index e1ce8277a..543f0505f 100644
--- a/tools/winscope/src/parsers/transitions/perfetto/parser_transitions_test.ts
+++ b/tools/winscope/src/parsers/transitions/perfetto/parser_transitions_test.ts
@@ -19,19 +19,19 @@ import {
   TimestampConverterUtils,
   timestampEqualityTester,
 } from 'common/time/test_utils';
-import {UnitTestUtils} from 'test/unit/utils';
+import {getPerfettoParser} from 'test/unit/fixture_utils';
 import {CoarseVersion} from 'trace/coarse_version';
 import {Parser} from 'trace/parser';
 import {TraceType} from 'trace/trace_type';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
+import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 
-describe('Perfetto ParserTransitions', () => {
+describe('PerfettoParserTransitions', () => {
   describe('valid trace', () => {
-    let parser: Parser<PropertyTreeNode>;
+    let parser: Parser<HierarchyTreeNode>;
 
     beforeAll(async () => {
       jasmine.addCustomEqualityTester(timestampEqualityTester);
-      parser = await UnitTestUtils.getPerfettoParser(
+      parser = await getPerfettoParser(
         TraceType.TRANSITION,
         'traces/perfetto/shell_transitions_trace.perfetto-trace',
       );
@@ -56,46 +56,93 @@ describe('Perfetto ParserTransitions', () => {
       expect(actual).toEqual(expected);
     });
 
-    it('decodes transition properties', async () => {
+    it('extracts eager properties', async () => {
       const entry = await parser.getEntry(0);
-      const wmDataNode = assertDefined(entry.getChildByName('wmData'));
-      const shellDataNode = assertDefined(entry.getChildByName('shellData'));
 
-      expect(entry.getChildByName('id')?.getValue()).toEqual(32n);
+      expect(entry.getEagerPropertyByName('transitionId')?.getValue()).toEqual(
+        32n,
+      );
+      expect(
+        entry.getEagerPropertyByName('transitionType')?.formattedValue(),
+      ).toEqual('OPEN');
+
+      expect(
+        entry.getEagerPropertyByName('sendTimeNs')?.formattedValue(),
+      ).toEqual('2023-11-21, 13:30:25.442');
+      expect(
+        entry.getEagerPropertyByName('dispatchTimeNs')?.formattedValue(),
+      ).toEqual('2023-11-21, 13:30:25.448');
+      expect(
+        entry.getEagerPropertyByName('durationNs')?.formattedValue(),
+      ).toEqual('528 ms');
+
+      const layerParticipants = assertDefined(
+        entry.getEagerPropertyByName('layers'),
+      ).getAllChildren();
+      expect(layerParticipants.length).toEqual(2);
+      expect(layerParticipants[0].getValue()).toEqual(47n);
+      expect(layerParticipants[1].getValue()).toEqual(398n);
+
+      const windowParticipants = assertDefined(
+        entry.getEagerPropertyByName('windows'),
+      ).getAllChildren();
+      expect(windowParticipants.length).toEqual(2);
+      expect(windowParticipants[0].getValue()).toEqual(159077656n);
+      expect(windowParticipants[1].getValue()).toEqual(193491296n);
+
+      expect(entry.getEagerPropertyByName('handler')?.formattedValue()).toEqual(
+        'com.android.wm.shell.transition.DefaultMixedHandler',
+      );
+      expect(entry.getEagerPropertyByName('status')?.formattedValue()).toEqual(
+        'PLAYED',
+      );
+
+      const entryWithFlags = await parser.getEntry(1);
+      expect(
+        entryWithFlags.getEagerPropertyByName('flags')?.formattedValue(),
+      ).toEqual('TRANSIT_FLAG_IS_RECENTS');
+    });
+
+    it('decodes lazy transition properties', async () => {
+      const entry = await parser.getEntry(0);
+
+      const properties = await entry.getAllProperties();
+
+      expect(properties.getChildByName('id')?.getValue()).toEqual(32);
       expect(
-        wmDataNode.getChildByName('createTimeNs')?.formattedValue(),
+        properties.getChildByName('createTimeNs')?.formattedValue(),
       ).toEqual('2023-11-21, 13:30:25.429');
-      expect(wmDataNode.getChildByName('sendTimeNs')?.formattedValue()).toEqual(
+      expect(properties.getChildByName('sendTimeNs')?.formattedValue()).toEqual(
         '2023-11-21, 13:30:25.442',
       );
       expect(
-        wmDataNode.getChildByName('finishTimeNs')?.formattedValue(),
+        properties.getChildByName('finishTimeNs')?.formattedValue(),
       ).toEqual('2023-11-21, 13:30:25.970');
-      expect(entry.getChildByName('merged')?.getValue()).toBeFalse();
-      expect(entry.getChildByName('played')?.getValue()).toBeTrue();
-      expect(entry.getChildByName('aborted')?.getValue()).toBeFalse();
+      expect(entry.getEagerPropertyByName('status')?.getValue()).toEqual(
+        'played',
+      );
 
       expect(
         assertDefined(
-          wmDataNode.getChildByName('startingWindowRemoveTimeNs'),
+          properties.getChildByName('startingWindowRemoveTimeNs'),
         ).formattedValue(),
       ).toEqual('2023-11-21, 13:30:25.565');
       expect(
         assertDefined(
-          wmDataNode.getChildByName('startTransactionId'),
+          properties.getChildByName('startTransactionId'),
         ).formattedValue(),
       ).toEqual('5811090758076');
       expect(
         assertDefined(
-          wmDataNode.getChildByName('finishTransactionId'),
+          properties.getChildByName('finishTransactionId'),
         ).formattedValue(),
       ).toEqual('5811090758077');
       expect(
-        assertDefined(wmDataNode.getChildByName('type')).formattedValue(),
+        assertDefined(properties.getChildByName('type')).formattedValue(),
       ).toEqual('OPEN');
 
       const targets = assertDefined(
-        wmDataNode.getChildByName('targets'),
+        properties.getChildByName('targets'),
       ).getAllChildren();
       expect(targets.length).toEqual(2);
       expect(
@@ -119,23 +166,22 @@ describe('Perfetto ParserTransitions', () => {
 
       expect(
         assertDefined(
-          shellDataNode.getChildByName('dispatchTimeNs'),
+          properties.getChildByName('dispatchTimeNs'),
         ).formattedValue(),
       ).toEqual('2023-11-21, 13:30:25.448');
-      expect(shellDataNode.getChildByName('mergeRequestTime')).toBeUndefined();
-      expect(shellDataNode.getChildByName('mergeTime')).toBeUndefined();
-      expect(shellDataNode.getChildByName('abortTimeNs')).toBeUndefined();
-      expect(shellDataNode.getChildByName('mergeTarget')).toBeUndefined();
+      expect(properties.getChildByName('mergeRequestTime')).toBeUndefined();
+      expect(properties.getChildByName('mergeTime')).toBeUndefined();
+      expect(properties.getChildByName('shellAbortTimeNs')).toBeUndefined();
+      expect(properties.getChildByName('mergeTarget')).toBeUndefined();
       expect(
-        assertDefined(shellDataNode.getChildByName('handler')).formattedValue(),
+        assertDefined(properties.getChildByName('handler')).formattedValue(),
       ).toEqual('com.android.wm.shell.transition.DefaultMixedHandler');
 
       const entryWithFlags = await parser.getEntry(1);
-      const wmDataWithFlags = assertDefined(
-        entryWithFlags.getChildByName('wmData'),
-      );
       expect(
-        assertDefined(wmDataWithFlags.getChildByName('flags')).formattedValue(),
+        assertDefined(
+          (await entryWithFlags.getAllProperties()).getChildByName('flags'),
+        ).formattedValue(),
       ).toEqual('TRANSIT_FLAG_IS_RECENTS');
     });
   });
diff --git a/tools/winscope/src/parsers/view_capture/legacy/hierarchy_tree_builder_vc.ts b/tools/winscope/src/parsers/view_capture/legacy/hierarchy_tree_builder_vc.ts
deleted file mode 100644
index 575b458d9..000000000
--- a/tools/winscope/src/parsers/view_capture/legacy/hierarchy_tree_builder_vc.ts
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import {assertDefined} from 'common/assert_utils';
-import {HierarchyTreeBuilder} from 'parsers/hierarchy_tree_builder';
-import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
-import {PropertiesProvider} from 'trace/tree_node/properties_provider';
-
-export class HierarchyTreeBuilderVc extends HierarchyTreeBuilder {
-  protected override buildIdentifierToChildrenMap(
-    views: PropertiesProvider[],
-  ): Map<string | number, readonly HierarchyTreeNode[]> {
-    const map = views.reduce((map, view) => {
-      const viewProperties = view.getEagerProperties();
-      const viewNode = this.makeNode(
-        viewProperties.id,
-        viewProperties.name,
-        view,
-      );
-      const hashcode = assertDefined(
-        viewProperties.getChildByName('hashcode'),
-      ).getValue();
-      map.set(hashcode, [viewNode]);
-      return map;
-    }, new Map<string, HierarchyTreeNode[]>());
-    return map;
-  }
-
-  protected override assignParentChildRelationships(
-    node: HierarchyTreeNode,
-    identifierToChildren: Map<string | number, HierarchyTreeNode[]>,
-    isRoot?: boolean,
-  ): void {
-    const childHashcodes =
-      node.getEagerPropertyByName('children')?.getAllChildren() ?? [];
-    for (const hashcode of childHashcodes) {
-      const child = identifierToChildren.get(hashcode.getValue())?.at(0);
-      if (child) {
-        this.setParentChildRelationship(node, child);
-        this.assignParentChildRelationships(child, identifierToChildren);
-      }
-    }
-  }
-}
diff --git a/tools/winscope/src/parsers/view_capture/legacy/hierarchy_tree_builder_vc_test.ts b/tools/winscope/src/parsers/view_capture/legacy/hierarchy_tree_builder_vc_test.ts
deleted file mode 100644
index 29b6c3ae3..000000000
--- a/tools/winscope/src/parsers/view_capture/legacy/hierarchy_tree_builder_vc_test.ts
+++ /dev/null
@@ -1,233 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
-import {TreeNodeUtils} from 'test/unit/tree_node_utils';
-import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
-import {OperationChain} from 'trace/tree_node/operations/operation_chain';
-import {PropertiesProvider} from 'trace/tree_node/properties_provider';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
-import {HierarchyTreeBuilderVc} from './hierarchy_tree_builder_vc';
-
-describe('HierarchyTreeBuilderVc', () => {
-  let builder: HierarchyTreeBuilderVc;
-
-  beforeEach(() => {
-    jasmine.addCustomEqualityTester(TreeNodeUtils.treeNodeEqualityTester);
-    builder = new HierarchyTreeBuilderVc();
-  });
-
-  it('throws error if entry not set', () => {
-    const noEntryError = new Error('root not set');
-    expect(() => builder.setChildren([]).build()).toThrow(noEntryError);
-  });
-
-  it('throws error if nodes not set', () => {
-    const noNodesError = new Error('children not set');
-    const entryPropertyTree = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('ViewNode')
-      .setName('com.android.internal@123456789')
-      .setChildren([
-        {name: 'hashcode', value: 123456789},
-        {name: 'children', value: []},
-      ])
-      .build();
-    const entry = new PropertiesProvider(
-      entryPropertyTree,
-      async () => entryPropertyTree,
-      OperationChain.emptyChain<PropertyTreeNode>(),
-      OperationChain.emptyChain<PropertyTreeNode>(),
-      OperationChain.emptyChain<PropertyTreeNode>(),
-    );
-
-    expect(() => builder.setRoot(entry).build()).toThrow(noNodesError);
-  });
-
-  it('builds root with no children correctly', () => {
-    const entryPropertyTree = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('ViewNode')
-      .setName('com.android.internal@123456789')
-      .setChildren([
-        {name: 'hashcode', value: 123456789},
-        {name: 'children', value: []},
-      ])
-      .build();
-    const entry = new PropertiesProvider(
-      entryPropertyTree,
-      async () => entryPropertyTree,
-      OperationChain.emptyChain<PropertyTreeNode>(),
-      OperationChain.emptyChain<PropertyTreeNode>(),
-      OperationChain.emptyChain<PropertyTreeNode>(),
-    );
-
-    const root = builder.setRoot(entry).setChildren([]).build();
-
-    const expectedRoot = new HierarchyTreeNode(
-      'ViewNode com.android.internal@123456789',
-      'com.android.internal@123456789',
-      new PropertiesProvider(
-        entryPropertyTree,
-        async () => entryPropertyTree,
-        OperationChain.emptyChain<PropertyTreeNode>(),
-        OperationChain.emptyChain<PropertyTreeNode>(),
-        OperationChain.emptyChain<PropertyTreeNode>(),
-      ),
-    );
-
-    expect(root).toEqual(expectedRoot);
-  });
-
-  it('builds root with children correctly', () => {
-    const entryPropertyTree = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('ViewNode')
-      .setName('com.android.internal@123456789')
-      .setChildren([
-        {name: 'hashcode', value: 123456789},
-        {name: 'children', children: [{name: '0', value: 987654321}]},
-      ])
-      .build();
-    const entry = new PropertiesProvider(
-      entryPropertyTree,
-      async () => entryPropertyTree,
-      OperationChain.emptyChain<PropertyTreeNode>(),
-      OperationChain.emptyChain<PropertyTreeNode>(),
-      OperationChain.emptyChain<PropertyTreeNode>(),
-    );
-
-    const node1Props = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('1')
-      .setName('node1')
-      .setChildren([
-        {name: 'hashcode', value: 987654321},
-        {name: 'children', value: []},
-      ])
-      .build();
-    const node1Provider = new PropertiesProvider(
-      node1Props,
-      async () => node1Props,
-      OperationChain.emptyChain<PropertyTreeNode>(),
-      OperationChain.emptyChain<PropertyTreeNode>(),
-      OperationChain.emptyChain<PropertyTreeNode>(),
-    );
-
-    const root = builder.setRoot(entry).setChildren([node1Provider]).build();
-
-    const expectedRoot = new HierarchyTreeNode(
-      'ViewNode com.android.internal@123456789',
-      'com.android.internal@123456789',
-      new PropertiesProvider(
-        entryPropertyTree,
-        async () => entryPropertyTree,
-        OperationChain.emptyChain<PropertyTreeNode>(),
-        OperationChain.emptyChain<PropertyTreeNode>(),
-        OperationChain.emptyChain<PropertyTreeNode>(),
-      ),
-    );
-    expectedRoot.addOrReplaceChild(
-      new HierarchyTreeNode('1 node1', 'node1', node1Provider),
-    );
-
-    expect(root).toEqual(expectedRoot);
-  });
-
-  it('builds root with nested children correctly', () => {
-    const entryPropertyTree = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('ViewNode')
-      .setName('com.android.internal@123456789')
-      .setChildren([
-        {name: 'hashcode', value: 123456789},
-        {name: 'children', children: [{name: '0', value: 987654321}]},
-      ])
-      .build();
-    const entry = new PropertiesProvider(
-      entryPropertyTree,
-      async () => entryPropertyTree,
-      OperationChain.emptyChain<PropertyTreeNode>(),
-      OperationChain.emptyChain<PropertyTreeNode>(),
-      OperationChain.emptyChain<PropertyTreeNode>(),
-    );
-
-    const node1Props = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('1')
-      .setName('node1')
-      .setChildren([
-        {name: 'hashcode', value: 987654321},
-        {name: 'children', children: [{name: '0', value: 464646464}]},
-      ])
-      .build();
-    const node1Provider = new PropertiesProvider(
-      node1Props,
-      async () => node1Props,
-      OperationChain.emptyChain<PropertyTreeNode>(),
-      OperationChain.emptyChain<PropertyTreeNode>(),
-      OperationChain.emptyChain<PropertyTreeNode>(),
-    );
-
-    const node2Props = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('2')
-      .setName('node2')
-      .setChildren([
-        {name: 'hashcode', value: 464646464},
-        {name: 'children', value: []},
-      ])
-      .build();
-    const node2Provider = new PropertiesProvider(
-      node2Props,
-      async () => node2Props,
-      OperationChain.emptyChain<PropertyTreeNode>(),
-      OperationChain.emptyChain<PropertyTreeNode>(),
-      OperationChain.emptyChain<PropertyTreeNode>(),
-    );
-
-    const root = builder
-      .setRoot(entry)
-      .setChildren([node1Provider, node2Provider])
-      .build();
-
-    const expectedRoot = new HierarchyTreeNode(
-      'ViewNode com.android.internal@123456789',
-      'com.android.internal@123456789',
-      new PropertiesProvider(
-        entryPropertyTree,
-        async () => entryPropertyTree,
-        OperationChain.emptyChain<PropertyTreeNode>(),
-        OperationChain.emptyChain<PropertyTreeNode>(),
-        OperationChain.emptyChain<PropertyTreeNode>(),
-      ),
-    );
-    const expectedRootNode = new HierarchyTreeNode(
-      '1 node1',
-      'node1',
-      node1Provider,
-    );
-    const expectedNestedNode = new HierarchyTreeNode(
-      '2 node2',
-      'node2',
-      node2Provider,
-    );
-    expectedRootNode.addOrReplaceChild(expectedNestedNode);
-    expectedRoot.addOrReplaceChild(expectedRootNode);
-
-    expect(root).toEqual(expectedRoot);
-  });
-});
diff --git a/tools/winscope/src/parsers/view_capture/legacy/parser_view_capture.ts b/tools/winscope/src/parsers/view_capture/legacy/parser_view_capture.ts
index ee19533eb..3be4e39a0 100644
--- a/tools/winscope/src/parsers/view_capture/legacy/parser_view_capture.ts
+++ b/tools/winscope/src/parsers/view_capture/legacy/parser_view_capture.ts
@@ -17,16 +17,19 @@
 import {assertDefined} from 'common/assert_utils';
 import {ParserTimestampConverter} from 'common/time/timestamp_converter';
 import {ParsingUtils} from 'parsers/legacy/parsing_utils';
+import root from 'protos/viewcapture/udc/json';
 import {com} from 'protos/viewcapture/udc/static';
 import {Parser} from 'trace/parser';
 import {TraceFile} from 'trace/trace_file';
 import {TraceType} from 'trace/trace_type';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 import {ParserViewCaptureWindow} from './parser_view_capture_window';
-import {ExportedData} from './tampered_protos';
 
 export class ParserViewCapture {
-  private readonly windowParsers: Array<Parser<HierarchyTreeNode>> = [];
+  private static readonly ExportedDataProto = root.lookupType(
+    'com.android.app.viewcapture.data.ExportedData',
+  );
+  private readonly windowParsers: ParserViewCaptureWindow[] = [];
 
   constructor(
     private readonly traceFile: TraceFile,
@@ -40,7 +43,7 @@ export class ParserViewCapture {
       ParserViewCapture.MAGIC_NUMBER,
     );
 
-    const exportedData = ExportedData.decode(
+    const exportedData = ParserViewCapture.ExportedDataProto.decode(
       traceBuffer,
     ) as com.android.app.viewcapture.data.IExportedData;
 
@@ -49,7 +52,7 @@ export class ParserViewCapture {
     );
 
     exportedData.windowData?.forEach(
-      (windowData: com.android.app.viewcapture.data.IWindowData) =>
+      (windowData: com.android.app.viewcapture.data.IWindowData) => {
         this.windowParsers.push(
           new ParserViewCaptureWindow(
             [this.traceFile.getDescriptor()],
@@ -60,7 +63,8 @@ export class ParserViewCapture {
             assertDefined(exportedData.classname),
             this.timestampConverter,
           ),
-        ),
+        );
+      },
     );
   }
 
diff --git a/tools/winscope/src/parsers/view_capture/legacy/parser_view_capture_test.ts b/tools/winscope/src/parsers/view_capture/legacy/parser_view_capture_test.ts
index 80f98d6ad..e8f45045a 100644
--- a/tools/winscope/src/parsers/view_capture/legacy/parser_view_capture_test.ts
+++ b/tools/winscope/src/parsers/view_capture/legacy/parser_view_capture_test.ts
@@ -14,18 +14,19 @@
  * limitations under the License.
  */
 import {assertDefined} from 'common/assert_utils';
+import {utf8Encode} from 'common/string_utils';
 import {
   TimestampConverterUtils,
   timestampEqualityTester,
 } from 'common/time/test_utils';
-import {UnitTestUtils} from 'test/unit/utils';
+import Long from 'long';
+import {perfetto} from 'protos/perfetto/trace/static';
+import {LegacyParserProvider} from 'test/unit/fixture_utils';
 import {CoarseVersion} from 'trace/coarse_version';
-import {CustomQueryType} from 'trace/custom_query';
 import {Parser} from 'trace/parser';
 import {Trace} from 'trace/trace';
 import {TraceType} from 'trace/trace_type';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
-import {PropertySource} from 'trace/tree_node/property_tree_node';
 
 describe('ParserViewCapture', () => {
   let parser: Parser<HierarchyTreeNode>;
@@ -33,10 +34,13 @@ describe('ParserViewCapture', () => {
 
   beforeAll(async () => {
     jasmine.addCustomEqualityTester(timestampEqualityTester);
-    parser = (await UnitTestUtils.getParser(
-      'traces/elapsed_and_real_timestamp/com.google.android.apps.nexuslauncher_0.vc',
-    )) as Parser<HierarchyTreeNode>;
+    parser = await new LegacyParserProvider()
+      .addFilename(
+        'traces/elapsed_and_real_timestamp/com.google.android.apps.nexuslauncher_0.vc',
+      )
+      .getParser<HierarchyTreeNode>();
     trace = Trace.fromParser(parser);
+    jasmine.DEFAULT_TIMEOUT_INTERVAL = 30000;
   });
 
   it('has expected trace type', () => {
@@ -63,24 +67,90 @@ describe('ParserViewCapture', () => {
     expect(assertDefined(parser.getTimestamps()).slice(0, 3)).toEqual(expected);
   });
 
-  it('retrieves trace entry', async () => {
-    const entry = await parser.getEntry(1);
-    expect(entry.id).toEqual(
-      'ViewNode com.android.launcher3.taskbar.TaskbarDragLayer@265160962',
-    );
-    // check calculated properties not overridden by lazily fetched properties
-    expect(
-      (await entry.getAllProperties()).getChildByName('translationX')?.source,
-    ).toEqual(PropertySource.CALCULATED);
+  it('does not provide entry', () => {
+    expect(parser.getEntry).toThrow();
   });
 
-  it('supports VIEW_CAPTURE_METADATA custom query', async () => {
-    const metadata = await trace.customQuery(
-      CustomQueryType.VIEW_CAPTURE_METADATA,
+  it('converts to valid perfetto packets', async () => {
+    const packets = parser.convertToPerfettoPackets!(10, 2, 3);
+    expect(packets.length).toEqual(2000);
+    expect(packets[0].trustedPacketSequenceId).toEqual(10);
+    expect(packets[0].timestamp).toEqual(
+      Long.fromString(BigInt(181114412436130).toString()),
+    );
+    expect(packets[0].timestampClockId).toEqual(
+      perfetto.protos.ClockSnapshot.Clock.BuiltinClocks.BOOTTIME,
+    );
+    expect(packets[0].trustedUid).toEqual(2);
+    expect(packets[0].trustedPid).toEqual(3);
+    expect(packets[0].sequenceFlags).toEqual(3);
+    expect(packets[1].sequenceFlags).toEqual(
+      perfetto.protos.TracePacket.SequenceFlags.SEQ_NEEDS_INCREMENTAL_STATE,
+    );
+
+    const vcData = assertDefined(
+      packets[0].winscopeExtensions?.[
+        '.perfetto.protos.WinscopeExtensionsImpl.viewcapture'
+      ],
+    );
+    expect(vcData.packageNameIid).toEqual(1);
+    expect(vcData.windowNameIid).toEqual(1);
+    expect(vcData.views?.length).toEqual(17);
+
+    const internedData = assertDefined(packets[0].internedData);
+
+    expect(internedData.viewcapturePackageName?.length).toEqual(1);
+    expect(internedData.viewcapturePackageName?.[0].iid).toEqual(
+      Long.fromNumber(1, true),
+    );
+    expect(internedData.viewcapturePackageName?.[0].str).toEqual(
+      utf8Encode('com.google.android.apps.nexuslauncher'),
+    );
+
+    expect(internedData.viewcaptureWindowName?.length).toEqual(1);
+    expect(internedData.viewcaptureWindowName?.[0].iid).toEqual(
+      Long.fromNumber(1, true),
+    );
+    expect(internedData.viewcaptureWindowName?.[0].str).toEqual(
+      utf8Encode('.Taskbar'),
+    );
+
+    expect(internedData.viewcaptureClassName?.length).toEqual(68);
+    expect(internedData.viewcaptureClassName?.[3].iid).toEqual(
+      Long.fromNumber(3, true),
+    );
+    expect(internedData.viewcaptureClassName?.[3].str).toEqual(
+      utf8Encode('com.android.launcher3.views.DoubleShadowBubbleTextView'),
+    );
+
+    expect(internedData.viewcaptureViewId?.length).toEqual(11);
+    expect(internedData.viewcaptureViewId?.[1].iid).toEqual(
+      Long.fromNumber(2, true),
     );
-    expect(metadata.packageName).toEqual(
-      'com.google.android.apps.nexuslauncher',
+    expect(internedData.viewcaptureViewId?.[1].str).toEqual(
+      utf8Encode('id/taskbar_view'),
+    );
+
+    expect(packets[1].internedData).toBeNull();
+  });
+
+  it('converts to valid perfetto trace', async () => {
+    const perfettoParser = await new LegacyParserProvider()
+      .addFilename(
+        'traces/elapsed_and_real_timestamp/com.google.android.apps.nexuslauncher_0.vc',
+      )
+      .setConvertToPerfetto(true)
+      .getParser<HierarchyTreeNode>();
+    expect(perfettoParser.getTimestamps()?.slice(0, 3)).toEqual([
+      TimestampConverterUtils.makeRealTimestamp(1691692936292808460n),
+      TimestampConverterUtils.makeRealTimestamp(1691692936301385080n),
+      TimestampConverterUtils.makeRealTimestamp(1691692936309419870n),
+    ]);
+
+    const entry = await perfettoParser.getEntry(1);
+    expect(entry.name).toEqual(
+      'com.android.launcher3.taskbar.TaskbarDragLayer@265160962',
     );
-    expect(metadata.windowName).toEqual('.Taskbar');
+    expect(entry.getRects()?.length).toEqual(1);
   });
 });
diff --git a/tools/winscope/src/parsers/view_capture/legacy/parser_view_capture_window.ts b/tools/winscope/src/parsers/view_capture/legacy/parser_view_capture_window.ts
index 4bf857e8f..b3d09bcac 100644
--- a/tools/winscope/src/parsers/view_capture/legacy/parser_view_capture_window.ts
+++ b/tools/winscope/src/parsers/view_capture/legacy/parser_view_capture_window.ts
@@ -15,78 +15,32 @@
  */
 
 import {assertDefined} from 'common/assert_utils';
+import {NOT_IMPLEMENTED_ERROR} from 'common/errors';
+import {utf8Encode} from 'common/string_utils';
 import {Timestamp} from 'common/time/time';
 import {ParserTimestampConverter} from 'common/time/timestamp_converter';
-import {AddDefaults} from 'parsers/operations/add_defaults';
-import {SetFormatters} from 'parsers/operations/set_formatters';
-import {TranslateIntDef} from 'parsers/operations/translate_intdef';
-import {RectsComputation} from 'parsers/view_capture/computations/rects_computation';
-import {VisibilityComputation} from 'parsers/view_capture/computations/visibility_computation';
-import {SetRootTransformProperties} from 'parsers/view_capture/operations/set_root_transform_properties';
+import Long from 'long';
+import {perfetto} from 'protos/perfetto/trace/static';
 import {com} from 'protos/viewcapture/udc/static';
 import {CoarseVersion} from 'trace/coarse_version';
 import {
   CustomQueryParserResultTypeMap,
   CustomQueryType,
-  VisitableParserCustomQuery,
 } from 'trace/custom_query';
 import {EntriesRange} from 'trace/index_types';
 import {Parser} from 'trace/parser';
 import {TraceType} from 'trace/trace_type';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
-import {Operation} from 'trace/tree_node/operations/operation';
-import {
-  LazyPropertiesStrategyType,
-  PropertiesProvider,
-} from 'trace/tree_node/properties_provider';
-import {PropertiesProviderBuilder} from 'trace/tree_node/properties_provider_builder';
-import {PropertyTreeBuilderFromProto} from 'trace/tree_node/property_tree_builder_from_proto';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
-import {DEFAULT_PROPERTY_TREE_NODE_FACTORY} from 'trace/tree_node/property_tree_node_factory';
-import {HierarchyTreeBuilderVc} from './hierarchy_tree_builder_vc';
-import {NodeField} from './tampered_protos';
 
 export class ParserViewCaptureWindow implements Parser<HierarchyTreeNode> {
-  private static readonly EAGER_PROPERTIES = [
-    'classnameIndex',
-    'hashcode',
-    'id',
-    'left',
-    'top',
-    'width',
-    'height',
-    'scaleX',
-    'scaleY',
-    'scrollX',
-    'scrollY',
-    'translationX',
-    'translationY',
-    'visibility',
-    'alpha',
-  ];
-  private static readonly DENYLIST_PROPERTIES =
-    ParserViewCaptureWindow.EAGER_PROPERTIES.concat(['children']); // some eager properties are overridden by calculated properties - avoid reloading them on lazy fetch
-
-  private static readonly Operations = {
-    SetFormattersNode: new SetFormatters(NodeField),
-    TranslateIntDefNode: new TranslateIntDef(NodeField),
-    AddDefaultsNodeEager: new AddDefaults(
-      NodeField,
-      ParserViewCaptureWindow.EAGER_PROPERTIES,
-    ),
-    AddDefaultsNodeLazy: new AddDefaults(
-      NodeField,
-      undefined,
-      ParserViewCaptureWindow.DENYLIST_PROPERTIES,
-    ),
-    SetRootTransformProperties: new SetRootTransformProperties(),
-  };
+  private static readonly PACKAGE_OR_WINDOW_IID = 1;
 
   private timestamps: Timestamp[] | undefined;
+  private viewIdToIid = new Map<string, number>();
 
   constructor(
     private readonly descriptors: string[],
-    private readonly frameData: com.android.app.viewcapture.data.IFrameData[],
+    private readonly frameData: FrameData[],
     private readonly realToBootTimeOffsetNs: bigint,
     private readonly packageName: string,
     private readonly windowName: string,
@@ -95,7 +49,7 @@ export class ParserViewCaptureWindow implements Parser<HierarchyTreeNode> {
   ) {}
 
   parse() {
-    throw new Error('Not implemented');
+    throw NOT_IMPLEMENTED_ERROR;
   }
 
   getTraceType(): TraceType {
@@ -127,23 +81,49 @@ export class ParserViewCaptureWindow implements Parser<HierarchyTreeNode> {
   }
 
   getEntry(index: number): Promise<HierarchyTreeNode> {
-    const tree = this.makeHierarchyTree(this.frameData[index]);
-    return Promise.resolve(tree);
+    throw NOT_IMPLEMENTED_ERROR;
+  }
+
+  canConvertToPerfetto(): boolean {
+    return true;
+  }
+
+  convertToPerfettoPackets(
+    sequenceId: number,
+    trustedUid = 1,
+    trustedPid = 1,
+  ): perfetto.protos.TracePacket[] {
+    if (this.frameData.length === 0) {
+      return [];
+    }
+    const packets = this.frameData.map((frame, index) => {
+      const packet = perfetto.protos.TracePacket.create();
+      packet.trustedPacketSequenceId = sequenceId;
+      packet.timestamp = assertDefined(frame.timestamp);
+      packet.timestampClockId =
+        perfetto.protos.ClockSnapshot.Clock.BuiltinClocks.BOOTTIME;
+      packet.trustedUid = trustedUid;
+      packet.trustedPid = trustedPid;
+      packet.sequenceFlags =
+        index === 0
+          ? 3
+          : perfetto.protos.TracePacket.SequenceFlags
+              .SEQ_NEEDS_INCREMENTAL_STATE;
+      packet.winscopeExtensions = {
+        '.perfetto.protos.WinscopeExtensionsImpl.viewcapture':
+          this.convertToPerfettoViewCapture(frame),
+      };
+      return packet;
+    });
+    packets[0].internedData = this.makeInternedData();
+    return packets;
   }
 
   customQuery<Q extends CustomQueryType>(
     type: Q,
     entriesRange: EntriesRange,
   ): Promise<CustomQueryParserResultTypeMap[Q]> {
-    return new VisitableParserCustomQuery(type)
-      .visit(CustomQueryType.VIEW_CAPTURE_METADATA, async () => {
-        const metadata = {
-          packageName: this.packageName,
-          windowName: this.windowName,
-        };
-        return Promise.resolve(metadata);
-      })
-      .getResult();
+    throw NOT_IMPLEMENTED_ERROR;
   }
 
   getDescriptors(): string[] {
@@ -158,118 +138,98 @@ export class ParserViewCaptureWindow implements Parser<HierarchyTreeNode> {
     );
   }
 
-  private makeHierarchyTree(
-    frameDataProto: com.android.app.viewcapture.data.IFrameData,
-  ): HierarchyTreeNode {
-    const nodes = this.makeNodePropertiesProviders(
-      assertDefined(frameDataProto.node),
-      true,
-    );
-    return new HierarchyTreeBuilderVc()
-      .setRoot(nodes[0])
-      .setChildren(nodes.slice(1))
-      .setComputations([new VisibilityComputation(), new RectsComputation()])
-      .build();
-  }
-
-  private makeNodePropertiesProviders(
-    node: com.android.app.viewcapture.data.IViewNode,
-    isRoot = false,
-  ): PropertiesProvider[] {
-    const eagerOperations: Array<Operation<PropertyTreeNode>> = [
-      ParserViewCaptureWindow.Operations.AddDefaultsNodeEager,
-    ];
-    if (isRoot) {
-      eagerOperations.push(
-        ParserViewCaptureWindow.Operations.SetRootTransformProperties,
-      );
+  private convertToPerfettoView(
+    node: ViewNode,
+    parentId: number,
+    perfettoViews: PerfettoView[],
+  ) {
+    if (node.id && !this.viewIdToIid.has(node.id)) {
+      this.viewIdToIid.set(node.id, this.viewIdToIid.size + 1);
     }
+    const nodeId = perfettoViews.length;
+    const perfettoView: perfetto.protos.ViewCapture.IView = {
+      id: nodeId,
+      parentId,
+      hashcode: node.hashcode,
+      viewIdIid: node.id ? this.viewIdToIid.get(node.id) : undefined,
+      classNameIid: node.classnameIndex,
+      left: node.left,
+      top: node.top,
+      width: node.width,
+      height: node.height,
+      scrollX: node.scrollX,
+      scrollY: node.scrollY,
+      translationX: node.translationX,
+      translationY: node.translationY,
+      scaleX: node.scaleX,
+      scaleY: node.scaleY,
+      alpha: node.alpha,
+      willNotDraw: node.willNotDraw,
+      clipChildren: node.clipChildren,
+      visibility: node.visibility,
+      elevation: node.elevation,
+    };
+    perfettoViews.push(perfettoView);
+
+    node.children?.forEach((child) => {
+      this.convertToPerfettoView(child, nodeId, perfettoViews);
+    });
+  }
+
+  private convertToPerfettoViewCapture(
+    frame: FrameData,
+  ): perfetto.protos.ViewCapture {
+    const perfettoViews: PerfettoView[] = [];
+    this.convertToPerfettoView(assertDefined(frame.node), -1, perfettoViews);
+    return perfetto.protos.ViewCapture.fromObject({
+      packageNameIid: ParserViewCaptureWindow.PACKAGE_OR_WINDOW_IID,
+      windowNameIid: ParserViewCaptureWindow.PACKAGE_OR_WINDOW_IID,
+      views: perfettoViews,
+    });
+  }
+
+  private makeInternedData() {
+    const internedWindowNames: perfetto.protos.InternedString[] = [
+      perfetto.protos.InternedString.fromObject({
+        iid: Long.fromNumber(ParserViewCaptureWindow.PACKAGE_OR_WINDOW_IID),
+        str: utf8Encode(this.windowName),
+      }),
+    ];
 
-    const eagerProperties = this.makeEagerPropertiesTree(node);
-    const lazyPropertiesStrategy = this.makeLazyPropertiesStrategy(node);
-
-    const nodeProperties = new PropertiesProviderBuilder()
-      .setEagerProperties(eagerProperties)
-      .setLazyPropertiesStrategy(lazyPropertiesStrategy)
-      .setCommonOperations([
-        ParserViewCaptureWindow.Operations.SetFormattersNode,
-        ParserViewCaptureWindow.Operations.TranslateIntDefNode,
-      ])
-      .setEagerOperations(eagerOperations)
-      .setLazyOperations([
-        ParserViewCaptureWindow.Operations.AddDefaultsNodeLazy,
-      ])
-      .build();
-
-    const propertiesProviders: PropertiesProvider[] = [nodeProperties];
-
-    node.children?.forEach(
-      (childNode: com.android.app.viewcapture.data.IViewNode) => {
-        propertiesProviders.push(
-          ...this.makeNodePropertiesProviders(childNode),
-        );
-      },
-    );
-
-    return propertiesProviders;
-  }
-
-  private makeEagerPropertiesTree(
-    node: com.android.app.viewcapture.data.IViewNode,
-  ): PropertyTreeNode {
-    const denyList: string[] = [];
-
-    let obj = node;
-    do {
-      Object.getOwnPropertyNames(obj).forEach((it) => {
-        if (!ParserViewCaptureWindow.EAGER_PROPERTIES.includes(it)) {
-          denyList.push(it);
-        }
+    const internedClassNames: perfetto.protos.InternedString[] =
+      this.classNames.map((className, index) => {
+        return perfetto.protos.InternedString.fromObject({
+          iid: Long.fromNumber(index),
+          str: utf8Encode(className),
+        });
       });
-      obj = Object.getPrototypeOf(obj);
-    } while (obj);
-
-    const id = `${this.classNames[assertDefined(node.classnameIndex)]}@${
-      node.hashcode
-    }`;
-
-    const nodeProperties = new PropertyTreeBuilderFromProto()
-      .setData(node)
-      .setRootId('ViewNode')
-      .setRootName(id)
-      .setDenyList(denyList)
-      .build();
-
-    nodeProperties.addOrReplaceChild(
-      DEFAULT_PROPERTY_TREE_NODE_FACTORY.makeCalculatedProperty(
-        nodeProperties.id,
-        'children',
-        this.mapChildrenToHashcodes(node.children ?? []),
-      ),
-    );
 
-    return nodeProperties;
-  }
+    const internedPackageNames: perfetto.protos.InternedString[] = [
+      perfetto.protos.InternedString.fromObject({
+        iid: Long.fromNumber(ParserViewCaptureWindow.PACKAGE_OR_WINDOW_IID),
+        str: utf8Encode(this.packageName),
+      }),
+    ];
 
-  private mapChildrenToHashcodes(
-    children: com.android.app.viewcapture.data.IViewNode[],
-  ): number[] {
-    return children.map((child) => assertDefined(child.hashcode));
-  }
+    const internedViewIds: perfetto.protos.InternedString[] = [];
+    assertDefined(this.viewIdToIid).forEach((iid, viewId) => {
+      internedViewIds.push(
+        perfetto.protos.InternedString.fromObject({
+          iid: Long.fromNumber(iid),
+          str: utf8Encode(viewId),
+        }),
+      );
+    });
 
-  private makeLazyPropertiesStrategy(
-    node: com.android.app.viewcapture.data.IViewNode,
-  ): LazyPropertiesStrategyType {
-    return async () => {
-      const id = `${this.classNames[assertDefined(node.classnameIndex)]}@${
-        node.hashcode
-      }`;
-      return new PropertyTreeBuilderFromProto()
-        .setData(node)
-        .setRootId('ViewNode')
-        .setRootName(id)
-        .setDenyList(ParserViewCaptureWindow.DENYLIST_PROPERTIES)
-        .build();
-    };
+    return perfetto.protos.InternedData.fromObject({
+      viewcaptureWindowName: internedWindowNames,
+      viewcaptureClassName: internedClassNames,
+      viewcapturePackageName: internedPackageNames,
+      viewcaptureViewId: internedViewIds,
+    });
   }
 }
+
+type FrameData = com.android.app.viewcapture.data.IFrameData;
+type ViewNode = com.android.app.viewcapture.data.IViewNode;
+type PerfettoView = perfetto.protos.ViewCapture.IView;
diff --git a/tools/winscope/src/parsers/view_capture/operations/set_root_transform_properties.ts b/tools/winscope/src/parsers/view_capture/operations/set_root_transform_properties.ts
deleted file mode 100644
index 2dd2499f8..000000000
--- a/tools/winscope/src/parsers/view_capture/operations/set_root_transform_properties.ts
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import {Operation} from 'trace/tree_node/operations/operation';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
-import {DEFAULT_PROPERTY_TREE_NODE_FACTORY} from 'trace/tree_node/property_tree_node_factory';
-
-export class SetRootTransformProperties implements Operation<PropertyTreeNode> {
-  apply(value: PropertyTreeNode): void {
-    value.addOrReplaceChild(
-      DEFAULT_PROPERTY_TREE_NODE_FACTORY.makeCalculatedProperty(
-        value.id,
-        'scaleX',
-        1,
-      ),
-    );
-    value.addOrReplaceChild(
-      DEFAULT_PROPERTY_TREE_NODE_FACTORY.makeCalculatedProperty(
-        value.id,
-        'scaleY',
-        1,
-      ),
-    );
-    value.addOrReplaceChild(
-      DEFAULT_PROPERTY_TREE_NODE_FACTORY.makeCalculatedProperty(
-        value.id,
-        'translationX',
-        0,
-      ),
-    );
-    value.addOrReplaceChild(
-      DEFAULT_PROPERTY_TREE_NODE_FACTORY.makeCalculatedProperty(
-        value.id,
-        'translationY',
-        0,
-      ),
-    );
-  }
-}
diff --git a/tools/winscope/src/parsers/view_capture/operations/set_root_transform_properties_test.ts b/tools/winscope/src/parsers/view_capture/operations/set_root_transform_properties_test.ts
deleted file mode 100644
index 044c1bf50..000000000
--- a/tools/winscope/src/parsers/view_capture/operations/set_root_transform_properties_test.ts
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
-import {PropertySource} from 'trace/tree_node/property_tree_node';
-import {SetRootTransformProperties} from './set_root_transform_properties';
-
-describe('SetRootTransformProperties', () => {
-  let operation: SetRootTransformProperties;
-
-  beforeEach(() => {
-    operation = new SetRootTransformProperties();
-  });
-
-  it('sets scale and translation properties', () => {
-    const propertyRoot = new PropertyTreeBuilder()
-      .setRootId('test')
-      .setName('node')
-      .setChildren([
-        {name: 'scaleX', value: 2},
-        {name: 'scaleY', value: 2},
-        {name: 'translationX', value: 2},
-        {name: 'translationY', value: 2},
-      ])
-      .build();
-
-    const expectedRoot = new PropertyTreeBuilder()
-      .setRootId('test')
-      .setName('node')
-      .setChildren([
-        {name: 'scaleX', value: 1, source: PropertySource.CALCULATED},
-        {name: 'scaleY', value: 1, source: PropertySource.CALCULATED},
-        {name: 'translationX', value: 0, source: PropertySource.CALCULATED},
-        {name: 'translationY', value: 0, source: PropertySource.CALCULATED},
-      ])
-      .build();
-
-    operation.apply(propertyRoot);
-    expect(propertyRoot).toEqual(expectedRoot);
-  });
-});
diff --git a/tools/winscope/src/parsers/view_capture/perfetto/hierarchy_tree_builder_vc.ts b/tools/winscope/src/parsers/view_capture/perfetto/hierarchy_tree_builder_vc.ts
index ae0abcafa..06909d21c 100644
--- a/tools/winscope/src/parsers/view_capture/perfetto/hierarchy_tree_builder_vc.ts
+++ b/tools/winscope/src/parsers/view_capture/perfetto/hierarchy_tree_builder_vc.ts
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-import {assertDefined} from 'common/assert_utils';
+import {assertDefined, assertNumber} from 'common/assert_utils';
 import {HierarchyTreeBuilder} from 'parsers/hierarchy_tree_builder';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 import {PropertiesProvider} from 'trace/tree_node/properties_provider';
@@ -42,15 +42,13 @@ export class HierarchyTreeBuilderVc extends HierarchyTreeBuilder {
     identifierToChildren: Map<string | number, HierarchyTreeNode[]>,
     isRoot?: boolean,
   ): void {
-    const rootId = assertDefined(
-      root.getEagerPropertyByName('id'),
-    ).getValue() as number;
+    const rootId = assertNumber(root.getEagerPropertyByName('id')?.getValue());
 
     for (const nodes of identifierToChildren.values()) {
       nodes.forEach((node) => {
-        const parentId = assertDefined(
-          node.getEagerPropertyByName('parentId'),
-        ).getValue() as number;
+        const parentId = assertNumber(
+          node.getEagerPropertyByName('parentId')?.getValue(),
+        );
         const parentIsRoot = parentId === rootId;
         const parent = parentIsRoot
           ? root
diff --git a/tools/winscope/src/parsers/view_capture/perfetto/parser_view_capture.ts b/tools/winscope/src/parsers/view_capture/perfetto/parser_view_capture.ts
index da759ba54..176b9c700 100644
--- a/tools/winscope/src/parsers/view_capture/perfetto/parser_view_capture.ts
+++ b/tools/winscope/src/parsers/view_capture/perfetto/parser_view_capture.ts
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-import {assertTrue} from 'common/assert_utils';
+import {assertString, assertTrue} from 'common/assert_utils';
 import {ParserTimestampConverter} from 'common/time/timestamp_converter';
 import {TraceFile} from 'trace/trace_file';
 import {TraceProcessor} from 'trace_processor/trace_processor';
@@ -65,7 +65,6 @@ export class ParserViewCapture {
           windowAndPackage.window,
         ),
     );
-
     const parsePromises = this.windowParsers.map((parser) => parser.parse());
     await Promise.all(parsePromises);
   }
@@ -86,11 +85,11 @@ export class ParserViewCapture {
         ORDER BY package_and_window;
     `;
 
-    const result = await this.traceProcessor.queryAllRows(sql);
+    const result = await this.traceProcessor.query(sql);
 
     const names: WindowAndPackage[] = [];
     for (const it = result.iter({}); it.valid(); it.next()) {
-      const packageAndWindow = it.get('package_and_window') as string;
+      const packageAndWindow = assertString(it.get('package_and_window'));
       const tokens = packageAndWindow.split(',');
       assertTrue(tokens.length === 2);
       names.push({package: tokens[0], window: tokens[1]});
diff --git a/tools/winscope/src/parsers/view_capture/perfetto/parser_view_capture_window.ts b/tools/winscope/src/parsers/view_capture/perfetto/parser_view_capture_window.ts
index 9c1dd1d1c..c4f2bbe7e 100644
--- a/tools/winscope/src/parsers/view_capture/perfetto/parser_view_capture_window.ts
+++ b/tools/winscope/src/parsers/view_capture/perfetto/parser_view_capture_window.ts
@@ -14,19 +14,26 @@
  * limitations under the License.
  */
 
-import {assertDefined} from 'common/assert_utils';
+import {
+  assertBigInt,
+  assertBigIntOrUndefined,
+  assertDefined,
+  assertNumberOrUndefined,
+  assertString,
+  assertStringOrUndefined,
+} from 'common/assert_utils';
 import {ParserTimestampConverter} from 'common/time/timestamp_converter';
 import {AddDefaults} from 'parsers/operations/add_defaults';
 import {SetFormatters} from 'parsers/operations/set_formatters';
 import {AbstractParser} from 'parsers/perfetto/abstract_parser';
 import {FakeProto, FakeProtoBuilder} from 'parsers/perfetto/fake_proto_builder';
 import {FakeProtoTransformer} from 'parsers/perfetto/fake_proto_transformer';
-import {Utils} from 'parsers/perfetto/utils';
-import {TamperedMessageType} from 'parsers/tampered_message_type';
+import {queryEntry} from 'parsers/perfetto/utils';
+import {PropertyTreeBuilderFromProto} from 'parsers/property_tree_builder_from_proto';
+import {TAMPERED_WINSCOPE_EXTENSIONS} from 'parsers/tampered_message_type';
 import {RectsComputation} from 'parsers/view_capture/computations/rects_computation';
 import {VisibilityComputation} from 'parsers/view_capture/computations/visibility_computation';
-import root from 'protos/viewcapture/latest/json';
-import {perfetto} from 'protos/viewcapture/latest/static';
+import {perfetto} from 'protos/perfetto/trace/static';
 import {
   CustomQueryParserResultTypeMap,
   CustomQueryType,
@@ -38,17 +45,16 @@ import {TraceType} from 'trace/trace_type';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 import {PropertiesProvider} from 'trace/tree_node/properties_provider';
 import {PropertiesProviderBuilder} from 'trace/tree_node/properties_provider_builder';
-import {PropertyTreeBuilderFromProto} from 'trace/tree_node/property_tree_builder_from_proto';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 import {TraceProcessor} from 'trace_processor/trace_processor';
 import {HierarchyTreeBuilderVc} from './hierarchy_tree_builder_vc';
 
 export class ParserViewCaptureWindow extends AbstractParser<HierarchyTreeNode> {
-  private static readonly PROTO_WRAPPER_MESSAGE = TamperedMessageType.tamper(
-    root.lookupType('perfetto.protos.Wrapper'),
+  private static readonly PROTO_VIEWCAPTURE_FIELD = assertDefined(
+    TAMPERED_WINSCOPE_EXTENSIONS.fields[
+      '.perfetto.protos.WinscopeExtensionsImpl.viewcapture'
+    ],
   );
-  private static readonly PROTO_VIEWCAPTURE_FIELD =
-    ParserViewCaptureWindow.PROTO_WRAPPER_MESSAGE.fields['viewcapture'];
   private static readonly PROTO_VIEW_FIELD = assertDefined(
     ParserViewCaptureWindow.PROTO_VIEWCAPTURE_FIELD.tamperedMessageType?.fields[
       'views'
@@ -96,7 +102,7 @@ export class ParserViewCaptureWindow extends AbstractParser<HierarchyTreeNode> {
   }
 
   override async getEntry(index: number): Promise<HierarchyTreeNode> {
-    let snapshotProto = (await Utils.queryEntry(
+    let snapshotProto = (await queryEntry(
       this.traceProcessor,
       this.getTableName(),
       this.entryIndexToRowIdMap,
@@ -113,7 +119,7 @@ export class ParserViewCaptureWindow extends AbstractParser<HierarchyTreeNode> {
       views.find((view) => {
         const parentId = assertDefined(
           view.getEagerProperties().getChildByName('parentId'),
-        ).getValue() as number;
+        ).getValue();
         return parentId === -1;
       }),
     );
@@ -159,10 +165,10 @@ export class ParserViewCaptureWindow extends AbstractParser<HierarchyTreeNode> {
           args.string_value = '${this.windowName}'
         ORDER BY vc.ts;
     `;
-    const result = await this.traceProcessor.queryAllRows(sqlRowIdAndTimestamp);
+    const result = await this.traceProcessor.query(sqlRowIdAndTimestamp);
     const entryIndexToRowId: number[] = [];
     for (const it = result.iter({}); it.valid(); it.next()) {
-      const rowId = Number(it.get('id') as bigint);
+      const rowId = Number(it.get('id'));
       entryIndexToRowId.push(rowId);
     }
     return entryIndexToRowId;
@@ -193,16 +199,16 @@ export class ParserViewCaptureWindow extends AbstractParser<HierarchyTreeNode> {
           INNER JOIN args ON vcv.arg_set_id = args.arg_set_id
       WHERE snapshot_id = ${this.entryIndexToRowIdMap[index]};
     `;
-    const result = await this.traceProcessor.queryAllRows(sql);
+    const result = await this.traceProcessor.query(sql);
 
     for (const it = result.iter({}); it.valid(); it.next()) {
-      const builder = getBuilder(it.get('node_id') as number);
+      const builder = getBuilder(Number(assertBigInt(it.get('node_id'))));
       builder.addArg(
-        it.get('key') as string,
-        it.get('value_type') as string,
-        it.get('int_value') as bigint | undefined,
-        it.get('real_value') as number | undefined,
-        it.get('string_value') as string | undefined,
+        assertString(it.get('key')),
+        assertString(it.get('value_type')),
+        assertBigIntOrUndefined(it.get('int_value')),
+        assertNumberOrUndefined(it.get('real_value')),
+        assertStringOrUndefined(it.get('string_value')),
       );
     }
 
@@ -233,13 +239,11 @@ export class ParserViewCaptureWindow extends AbstractParser<HierarchyTreeNode> {
     view: perfetto.protos.ViewCapture.IView,
   ): PropertyTreeNode {
     const rootName = `${(view as FakeProto).className}@${view.hashcode}`;
-
     const nodeProperties = new PropertyTreeBuilderFromProto()
       .setData(view)
-      .setRootId('root-view')
+      .setRootId('ViewNode' + (view.id ?? 0))
       .setRootName(rootName)
       .build();
-
     return nodeProperties;
   }
 }
diff --git a/tools/winscope/src/parsers/view_capture/perfetto/parser_view_capture_window_test.ts b/tools/winscope/src/parsers/view_capture/perfetto/parser_view_capture_window_test.ts
index 2aa0b0958..7e3d0b5aa 100644
--- a/tools/winscope/src/parsers/view_capture/perfetto/parser_view_capture_window_test.ts
+++ b/tools/winscope/src/parsers/view_capture/perfetto/parser_view_capture_window_test.ts
@@ -18,7 +18,7 @@ import {
   TimestampConverterUtils,
   timestampEqualityTester,
 } from 'common/time/test_utils';
-import {UnitTestUtils} from 'test/unit/utils';
+import {getPerfettoParser} from 'test/unit/fixture_utils';
 import {CoarseVersion} from 'trace/coarse_version';
 import {CustomQueryType} from 'trace/custom_query';
 import {Parser} from 'trace/parser';
@@ -26,13 +26,13 @@ import {Trace} from 'trace/trace';
 import {TraceType} from 'trace/trace_type';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 
-describe('Perfetto ParserViewCaptureWindow', () => {
+describe('PerfettoParserViewCaptureWindow', () => {
   let parser: Parser<HierarchyTreeNode>;
   let trace: Trace<HierarchyTreeNode>;
 
   beforeAll(async () => {
     jasmine.addCustomEqualityTester(timestampEqualityTester);
-    parser = (await UnitTestUtils.getPerfettoParser(
+    parser = (await getPerfettoParser(
       TraceType.VIEW_CAPTURE,
       'traces/perfetto/viewcapture.perfetto-trace',
     )) as Parser<HierarchyTreeNode>;
diff --git a/tools/winscope/src/parsers/window_manager/computations/rects_computation_test.ts b/tools/winscope/src/parsers/window_manager/computations/rects_computation_test.ts
index a67f6db44..3c217245c 100644
--- a/tools/winscope/src/parsers/window_manager/computations/rects_computation_test.ts
+++ b/tools/winscope/src/parsers/window_manager/computations/rects_computation_test.ts
@@ -15,7 +15,7 @@
  */
 
 import {assertDefined} from 'common/assert_utils';
-import {perfetto} from 'protos/windowmanager/latest/static';
+import {perfetto} from 'protos/perfetto/trace/static';
 import {com} from 'protos/windowmanager/udc/static';
 import {HierarchyTreeBuilder} from 'test/unit/hierarchy_tree_builder';
 import {TreeNodeUtils} from 'test/unit/tree_node_utils';
diff --git a/tools/winscope/src/parsers/window_manager/custom_query_utils.ts b/tools/winscope/src/parsers/window_manager/custom_query_utils.ts
index d8e99f6b9..58337a342 100644
--- a/tools/winscope/src/parsers/window_manager/custom_query_utils.ts
+++ b/tools/winscope/src/parsers/window_manager/custom_query_utils.ts
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-import {perfetto} from 'protos/windowmanager/latest/static';
+import {perfetto} from 'protos/perfetto/trace/static';
 import {com} from 'protos/windowmanager/udc/static';
 import {
   CustomQueryParserResultTypeMap,
diff --git a/tools/winscope/src/parsers/window_manager/custom_query_utils_test.ts b/tools/winscope/src/parsers/window_manager/custom_query_utils_test.ts
index 7f9038ffb..f6d70c5d0 100644
--- a/tools/winscope/src/parsers/window_manager/custom_query_utils_test.ts
+++ b/tools/winscope/src/parsers/window_manager/custom_query_utils_test.ts
@@ -13,14 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-import {UnitTestUtils} from 'test/unit/utils';
+import {getTrace} from 'test/unit/fixture_utils';
 import {CustomQueryType} from 'trace/custom_query';
 import {TraceType} from 'trace/trace_type';
 
 describe('WmCustomQueryUtils', () =>
   (async () => {
     it('parseWindowsTokenAndTitle()', async () => {
-      const trace = await UnitTestUtils.getTrace(
+      const trace = await getTrace(
         TraceType.WINDOW_MANAGER,
         'traces/elapsed_and_real_timestamp/WindowManager.pb',
       );
diff --git a/tools/winscope/src/parsers/window_manager/legacy/parser_window_manager_dump_test.ts b/tools/winscope/src/parsers/window_manager/legacy/parser_window_manager_dump_test.ts
index b1b864d5d..24ca93bdf 100644
--- a/tools/winscope/src/parsers/window_manager/legacy/parser_window_manager_dump_test.ts
+++ b/tools/winscope/src/parsers/window_manager/legacy/parser_window_manager_dump_test.ts
@@ -15,11 +15,12 @@
  */
 
 import {
+  getTimestampConverter,
   TimestampConverterUtils,
   timestampEqualityTester,
 } from 'common/time/test_utils';
+import {LegacyParserProvider} from 'test/unit/fixture_utils';
 import {TraceBuilder} from 'test/unit/trace_builder';
-import {UnitTestUtils} from 'test/unit/utils';
 import {CoarseVersion} from 'trace/coarse_version';
 import {CustomQueryType} from 'trace/custom_query';
 import {Parser} from 'trace/parser';
@@ -33,9 +34,9 @@ describe('ParserWindowManagerDump', () => {
 
   beforeAll(async () => {
     jasmine.addCustomEqualityTester(timestampEqualityTester);
-    parser = (await UnitTestUtils.getParser(
-      'traces/dump_WindowManager.pb',
-    )) as Parser<HierarchyTreeNode>;
+    parser = await new LegacyParserProvider()
+      .addFilename('traces/elapsed_timestamp/dump_WindowManager.pb')
+      .getParser<HierarchyTreeNode>();
     trace = new TraceBuilder<HierarchyTreeNode>()
       .setType(TraceType.WINDOW_MANAGER)
       .setParser(parser)
@@ -56,10 +57,10 @@ describe('ParserWindowManagerDump', () => {
   });
 
   it('does not apply timezone info', async () => {
-    const parserWithTimezoneInfo = (await UnitTestUtils.getParser(
-      'traces/dump_WindowManager.pb',
-      UnitTestUtils.getTimestampConverter(true),
-    )) as Parser<HierarchyTreeNode>;
+    const parserWithTimezoneInfo = await new LegacyParserProvider()
+      .addFilename('traces/elapsed_timestamp/dump_WindowManager.pb')
+      .setTimestampConverter(getTimestampConverter(true))
+      .getParser<HierarchyTreeNode>();
     expect(parserWithTimezoneInfo.getTraceType()).toEqual(
       TraceType.WINDOW_MANAGER,
     );
diff --git a/tools/winscope/src/parsers/window_manager/legacy/parser_window_manager_test.ts b/tools/winscope/src/parsers/window_manager/legacy/parser_window_manager_test.ts
index 31713b009..001152edd 100644
--- a/tools/winscope/src/parsers/window_manager/legacy/parser_window_manager_test.ts
+++ b/tools/winscope/src/parsers/window_manager/legacy/parser_window_manager_test.ts
@@ -18,8 +18,8 @@ import {
   TimestampConverterUtils,
   timestampEqualityTester,
 } from 'common/time/test_utils';
+import {LegacyParserProvider} from 'test/unit/fixture_utils';
 import {TraceBuilder} from 'test/unit/trace_builder';
-import {UnitTestUtils} from 'test/unit/utils';
 import {CoarseVersion} from 'trace/coarse_version';
 import {CustomQueryType} from 'trace/custom_query';
 import {Parser} from 'trace/parser';
@@ -34,9 +34,9 @@ describe('ParserWindowManager', () => {
 
     beforeAll(async () => {
       jasmine.addCustomEqualityTester(timestampEqualityTester);
-      parser = (await UnitTestUtils.getParser(
-        'traces/elapsed_and_real_timestamp/WindowManager.pb',
-      )) as Parser<HierarchyTreeNode>;
+      parser = await new LegacyParserProvider()
+        .addFilename('traces/elapsed_and_real_timestamp/WindowManager.pb')
+        .getParser<HierarchyTreeNode>();
       trace = new TraceBuilder<HierarchyTreeNode>()
         .setType(TraceType.WINDOW_MANAGER)
         .setParser(parser)
@@ -81,9 +81,9 @@ describe('ParserWindowManager', () => {
     let parser: Parser<HierarchyTreeNode>;
 
     beforeAll(async () => {
-      parser = (await UnitTestUtils.getParser(
-        'traces/elapsed_timestamp/WindowManager.pb',
-      )) as Parser<HierarchyTreeNode>;
+      parser = await new LegacyParserProvider()
+        .addFilename('traces/elapsed_timestamp/WindowManager.pb')
+        .getParser<HierarchyTreeNode>();
     });
 
     it('has expected trace type', () => {
@@ -110,9 +110,11 @@ describe('ParserWindowManager', () => {
     let parser: Parser<HierarchyTreeNode>;
 
     beforeAll(async () => {
-      parser = (await UnitTestUtils.getParser(
-        'traces/elapsed_and_real_timestamp/window_trace_critical.winscope',
-      )) as Parser<HierarchyTreeNode>;
+      parser = await new LegacyParserProvider()
+        .addFilename(
+          'traces/elapsed_and_real_timestamp/window_trace_critical.winscope',
+        )
+        .getParser<HierarchyTreeNode>();
     });
 
     it('has expected trace type', () => {
diff --git a/tools/winscope/src/parsers/window_manager/operations/add_window_type.ts b/tools/winscope/src/parsers/window_manager/operations/add_window_type.ts
index 17f5a26da..50aeb0ac3 100644
--- a/tools/winscope/src/parsers/window_manager/operations/add_window_type.ts
+++ b/tools/winscope/src/parsers/window_manager/operations/add_window_type.ts
@@ -17,7 +17,7 @@
 import {AddOperation} from 'trace/tree_node/operations/add_operation';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 import {DEFAULT_PROPERTY_TREE_NODE_FACTORY} from 'trace/tree_node/property_tree_node_factory';
-import {WindowType, WindowTypePrefix} from 'trace/window_type';
+import {WindowType, WindowTypePrefix} from 'trace/window_manager/window_type';
 
 export class AddWindowType extends AddOperation<PropertyTreeNode> {
   protected override makeProperties(
diff --git a/tools/winscope/src/parsers/window_manager/operations/add_window_type_test.ts b/tools/winscope/src/parsers/window_manager/operations/add_window_type_test.ts
index de27d965e..b05595ee3 100644
--- a/tools/winscope/src/parsers/window_manager/operations/add_window_type_test.ts
+++ b/tools/winscope/src/parsers/window_manager/operations/add_window_type_test.ts
@@ -16,7 +16,7 @@
 
 import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
 import {PropertySource} from 'trace/tree_node/property_tree_node';
-import {WindowType, WindowTypePrefix} from 'trace/window_type';
+import {WindowType, WindowTypePrefix} from 'trace/window_manager/window_type';
 import {AddWindowType} from './add_window_type';
 
 describe('AddWindowType', () => {
diff --git a/tools/winscope/src/parsers/window_manager/perfetto/parser_window_manager.ts b/tools/winscope/src/parsers/window_manager/perfetto/parser_window_manager.ts
index 36a3f00a0..03e70f56f 100644
--- a/tools/winscope/src/parsers/window_manager/perfetto/parser_window_manager.ts
+++ b/tools/winscope/src/parsers/window_manager/perfetto/parser_window_manager.ts
@@ -18,12 +18,12 @@ import {assertDefined} from 'common/assert_utils';
 import {ParserTimestampConverter} from 'common/time/timestamp_converter';
 import {AbstractParser} from 'parsers/perfetto/abstract_parser';
 import {FakeProtoTransformer} from 'parsers/perfetto/fake_proto_transformer';
-import {Utils} from 'parsers/perfetto/utils';
+import {queryEntry} from 'parsers/perfetto/utils';
 import {RectsComputation} from 'parsers/window_manager/computations/rects_computation';
 import {WmCustomQueryUtils} from 'parsers/window_manager/custom_query_utils';
 import {HierarchyTreeBuilderWm} from 'parsers/window_manager/hierarchy_tree_builder_wm';
 import {PropertiesProviderFactory} from 'parsers/window_manager/properties_provider_factory';
-import {perfetto} from 'protos/windowmanager/latest/static';
+import {perfetto} from 'protos/perfetto/trace/static';
 import {
   CustomQueryParserResultTypeMap,
   CustomQueryType,
@@ -58,7 +58,7 @@ export class ParserWindowManager extends AbstractParser<HierarchyTreeNode> {
   }
 
   override async getEntry(index: number): Promise<HierarchyTreeNode> {
-    let entryProto = await Utils.queryEntry(
+    let entryProto = await queryEntry(
       this.traceProcessor,
       this.getTableName(),
       this.entryIndexToRowIdMap,
@@ -86,7 +86,7 @@ export class ParserWindowManager extends AbstractParser<HierarchyTreeNode> {
           [];
 
         const fetchAndParseEntry = async (index: AbsoluteEntryIndex) => {
-          const entryProto = await Utils.queryEntry(
+          const entryProto = await queryEntry(
             this.traceProcessor,
             this.getTableName(),
             this.entryIndexToRowIdMap,
diff --git a/tools/winscope/src/parsers/window_manager/perfetto/parser_window_manager_test.ts b/tools/winscope/src/parsers/window_manager/perfetto/parser_window_manager_test.ts
index 424e5e6a3..f2e8fe5f0 100644
--- a/tools/winscope/src/parsers/window_manager/perfetto/parser_window_manager_test.ts
+++ b/tools/winscope/src/parsers/window_manager/perfetto/parser_window_manager_test.ts
@@ -18,8 +18,8 @@ import {
   TimestampConverterUtils,
   timestampEqualityTester,
 } from 'common/time/test_utils';
+import {getPerfettoParser} from 'test/unit/fixture_utils';
 import {TraceBuilder} from 'test/unit/trace_builder';
-import {UnitTestUtils} from 'test/unit/utils';
 import {CoarseVersion} from 'trace/coarse_version';
 import {CustomQueryType} from 'trace/custom_query';
 import {Parser} from 'trace/parser';
@@ -27,13 +27,13 @@ import {Trace} from 'trace/trace';
 import {TraceType} from 'trace/trace_type';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 
-describe('Perfetto ParserWindowManager', () => {
+describe('PerfettoParserWindowManager', () => {
   let parser: Parser<HierarchyTreeNode>;
   let trace: Trace<HierarchyTreeNode>;
 
   beforeAll(async () => {
     jasmine.addCustomEqualityTester(timestampEqualityTester);
-    parser = (await UnitTestUtils.getPerfettoParser(
+    parser = (await getPerfettoParser(
       TraceType.WINDOW_MANAGER,
       'traces/perfetto/windowmanager.perfetto-trace',
     )) as Parser<HierarchyTreeNode>;
diff --git a/tools/winscope/src/parsers/window_manager/perfetto/tampered_protos_latest.ts b/tools/winscope/src/parsers/window_manager/perfetto/tampered_protos_latest.ts
index ce190665a..1c1bac9b9 100644
--- a/tools/winscope/src/parsers/window_manager/perfetto/tampered_protos_latest.ts
+++ b/tools/winscope/src/parsers/window_manager/perfetto/tampered_protos_latest.ts
@@ -15,16 +15,15 @@
  */
 
 import {assertDefined} from 'common/assert_utils';
-import {TamperedMessageType} from 'parsers/tampered_message_type';
+import {TAMPERED_WINSCOPE_EXTENSIONS} from 'parsers/tampered_message_type';
 import {TamperedProtos} from 'parsers/window_manager/tampered_protos';
-import root from 'protos/windowmanager/latest/json';
 
-const Wrapper = TamperedMessageType.tamper(
-  root.lookupType('perfetto.protos.Wrapper'),
+const entryField = assertDefined(
+  TAMPERED_WINSCOPE_EXTENSIONS.fields[
+    '.perfetto.protos.WinscopeExtensionsImpl.windowmanager'
+  ],
 );
 
-const entryField = assertDefined(Wrapper.fields['windowmanagerTraceEntry']);
-
 const windowManagerServiceField = assertDefined(entryField.tamperedMessageType)
   .fields['windowManagerService'];
 
diff --git a/tools/winscope/src/parsers/window_manager/properties_provider_factory.ts b/tools/winscope/src/parsers/window_manager/properties_provider_factory.ts
index be0d25ece..01fbd0d82 100644
--- a/tools/winscope/src/parsers/window_manager/properties_provider_factory.ts
+++ b/tools/winscope/src/parsers/window_manager/properties_provider_factory.ts
@@ -15,17 +15,17 @@
  */
 
 import {assertDefined} from 'common/assert_utils';
-import {perfetto} from 'protos/windowmanager/latest/static';
+import {PropertyTreeBuilderFromProto} from 'parsers/property_tree_builder_from_proto';
+import {perfetto} from 'protos/perfetto/trace/static';
 import {com} from 'protos/windowmanager/udc/static';
 import {
   LazyPropertiesStrategyType,
   PropertiesProvider,
 } from 'trace/tree_node/properties_provider';
 import {PropertiesProviderBuilder} from 'trace/tree_node/properties_provider_builder';
-import {PropertyTreeBuilderFromProto} from 'trace/tree_node/property_tree_builder_from_proto';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 import {DEFAULT_PROPERTY_TREE_NODE_FACTORY} from 'trace/tree_node/property_tree_node_factory';
-import {WindowTypePrefix} from 'trace/window_type';
+import {WindowTypePrefix} from 'trace/window_manager/window_type';
 import {DENYLIST_PROPERTIES} from './denylist_properties';
 import {EAGER_PROPERTIES} from './eager_properties';
 import {OperationLists, WmOperationLists} from './operations/operation_lists';
diff --git a/tools/winscope/src/styles.css b/tools/winscope/src/styles.css
index 1361b3981..ed9321955 100644
--- a/tools/winscope/src/styles.css
+++ b/tools/winscope/src/styles.css
@@ -40,6 +40,10 @@ app-root {
     user-select: auto !important;
 }
 
+.mat-option, .mat-option-text {
+    user-select: none;
+}
+
 .card-grid {
     width: 100%;
     height: 100%;
@@ -140,7 +144,7 @@ body.dark-mode button.mat-flat-button.mat-primary {
     padding-bottom: 0px;
 }
 
-.no-padding-field .mat-form-field-infix, .no-border-top-field .mat-form-field-infix  {
+.no-padding-field .mat-form-field-infix {
     border-top: 0px;
 }
 
@@ -231,3 +235,14 @@ log-view .headers .mat-form-field-infix {
 .mat-active.no-focus {
     background-color: unset;
 }
+
+.warning-action-boxes label.mat-checkbox-layout {
+    white-space: normal;
+    overflow-wrap: anywhere;
+}
+.warning-action-boxes .mat-checkbox {
+    padding-bottom: 10px;
+}
+.wrapped-checkbox .mat-checkbox-layout, .wrapped-checkbox .mat-checkbox-layout .mat-checkbox-label {
+    white-space: normal;
+}
diff --git a/tools/winscope/src/test/e2e/cross_tool_protocol_test.ts b/tools/winscope/src/test/e2e/cross_tool_protocol_test.ts
index 7186f1d1d..393920ddb 100644
--- a/tools/winscope/src/test/e2e/cross_tool_protocol_test.ts
+++ b/tools/winscope/src/test/e2e/cross_tool_protocol_test.ts
@@ -15,21 +15,26 @@
  */
 
 import {browser, by, element, ElementFinder} from 'protractor';
-import {E2eTestUtils} from './utils';
+import {
+  changeNsTimestampInWinscope,
+  checkServerIsUp,
+  checkWinscopeNsTimestamp,
+  clickViewTracesButton,
+  closeSnackBar,
+  getFixturePath,
+  REMOTE_TOOL_MOCK_URL,
+  setTimeouts,
+} from './utils';
 
 describe('Cross-Tool Protocol', () => {
-  const DEFAULT_TIMEOUT_MS = 50000;
+  const DEFAULT_TIMEOUT_MS = 80000;
 
   beforeEach(async () => {
     await browser.restart();
-    jasmine.DEFAULT_TIMEOUT_INTERVAL = DEFAULT_TIMEOUT_MS;
     await browser.manage().timeouts().setScriptTimeout(DEFAULT_TIMEOUT_MS);
-    await E2eTestUtils.beforeEach(DEFAULT_TIMEOUT_MS);
-    await E2eTestUtils.checkServerIsUp(
-      'Remote tool mock',
-      E2eTestUtils.REMOTE_TOOL_MOCK_URL,
-    );
-    await browser.get(E2eTestUtils.REMOTE_TOOL_MOCK_URL);
+    await setTimeouts(DEFAULT_TIMEOUT_MS, DEFAULT_TIMEOUT_MS);
+    await checkServerIsUp('Remote tool mock', REMOTE_TOOL_MOCK_URL);
+    await browser.get(REMOTE_TOOL_MOCK_URL);
     await browser.wait(
       async () => {
         const handles = await browser.getAllWindowHandles();
@@ -125,7 +130,7 @@ describe('Cross-Tool Protocol', () => {
     await browser.switchTo().window(await getWindowHandleRemoteToolMock());
     const inputFileElement = element(by.css('.button-send-bugreport'));
     await inputFileElement.sendKeys(
-      E2eTestUtils.getFixturePath('bugreports/bugreport_stripped.zip'),
+      getFixturePath('bugreports/bugreport_stripped.zip'),
     );
   }
 
@@ -133,9 +138,7 @@ describe('Cross-Tool Protocol', () => {
     await browser.switchTo().window(await getWindowHandleRemoteToolMock());
     const inputFileElement = element(by.css('.button-send-files'));
     await inputFileElement.sendKeys(
-      E2eTestUtils.getFixturePath(
-        'traces/perfetto/layers_trace.perfetto-trace',
-      ),
+      getFixturePath('traces/perfetto/layers_trace.perfetto-trace'),
     );
   }
 
@@ -147,12 +150,12 @@ describe('Cross-Tool Protocol', () => {
 
   async function clickWinscopeViewTracesButton() {
     await browser.switchTo().window(await getWindowHandleWinscope());
-    await E2eTestUtils.clickViewTracesButton();
+    await clickViewTracesButton();
   }
 
   async function closeWinscopeSnackBar() {
     await browser.switchTo().window(await getWindowHandleWinscope());
-    await E2eTestUtils.closeSnackBar();
+    await closeSnackBar();
   }
 
   async function waitWinscopeTabIsOpen() {
@@ -188,6 +191,7 @@ describe('Cross-Tool Protocol', () => {
     );
 
     const expectedTabParagraphs = [
+      'Search',
       'Surface Flinger',
       'Transactions',
       'Transitions',
@@ -215,12 +219,12 @@ describe('Cross-Tool Protocol', () => {
 
   async function sendTimestampToRemoteTool(value: string) {
     browser.switchTo().window(await getWindowHandleWinscope());
-    await E2eTestUtils.changeNsTimestampInWinscope(value);
+    await changeNsTimestampInWinscope(value);
   }
 
   async function checkWinscopeTimestamp(expectedValue: string) {
     await browser.switchTo().window(await getWindowHandleWinscope());
-    await E2eTestUtils.checkWinscopeNsTimestamp(expectedValue);
+    await checkWinscopeNsTimestamp(expectedValue);
   }
 
   async function checkRemoteToolRealtimeTimestamp(expectedValue: string) {
diff --git a/tools/winscope/src/test/e2e/trace_navigation_test.ts b/tools/winscope/src/test/e2e/trace_navigation_test.ts
index 66e617fff..c9311c541 100644
--- a/tools/winscope/src/test/e2e/trace_navigation_test.ts
+++ b/tools/winscope/src/test/e2e/trace_navigation_test.ts
@@ -15,26 +15,31 @@
  */
 
 import {browser, by, element, ElementFinder} from 'protractor';
-import {E2eTestUtils} from './utils';
+import {
+  clickUploadNewButton,
+  clickViewTracesButton,
+  closeSnackBar,
+  setTimeouts,
+  uploadFixture,
+  WINSCOPE_URL,
+} from './utils';
 
 describe('Trace navigation', () => {
   const DEFAULT_TIMEOUT_MS = 1000;
 
   beforeEach(async () => {
-    await E2eTestUtils.beforeEach(DEFAULT_TIMEOUT_MS);
-    await browser.get(E2eTestUtils.WINSCOPE_URL);
+    await setTimeouts(DEFAULT_TIMEOUT_MS);
+    await browser.get(WINSCOPE_URL);
   });
 
   it('can go between home and trace view pages correctly', async () => {
-    await E2eTestUtils.uploadFixture(
-      'traces/perfetto/layers_trace.perfetto-trace',
-    );
+    await uploadFixture('traces/perfetto/layers_trace.perfetto-trace');
     await checkHomepage();
-    await E2eTestUtils.closeSnackBar();
-    await E2eTestUtils.clickViewTracesButton();
+    await closeSnackBar();
+    await clickViewTracesButton();
     await checkTraceViewPage();
 
-    await E2eTestUtils.clickUploadNewButton();
+    await clickUploadNewButton();
     await checkHomepage();
   });
 
diff --git a/tools/winscope/src/test/e2e/upload_traces_test.ts b/tools/winscope/src/test/e2e/upload_traces_test.ts
index 83268fee8..0d503fdc0 100644
--- a/tools/winscope/src/test/e2e/upload_traces_test.ts
+++ b/tools/winscope/src/test/e2e/upload_traces_test.ts
@@ -15,43 +15,50 @@
  */
 
 import {browser, by, element} from 'protractor';
-import {E2eTestUtils} from './utils';
+import {
+  areMessagesEmitted,
+  clickClearAllButton,
+  clickCloseIcon,
+  clickViewTracesButton,
+  loadBugReport,
+  setTimeouts,
+  uploadFixture,
+  WINSCOPE_URL,
+} from './utils';
 
 describe('Upload traces', () => {
-  const DEFAULT_TIMEOUT_MS = 20000;
+  const DEFAULT_TIMEOUT_MS = 60000;
 
   beforeAll(async () => {
     jasmine.DEFAULT_TIMEOUT_INTERVAL = DEFAULT_TIMEOUT_MS;
   });
 
   beforeEach(async () => {
-    await E2eTestUtils.beforeEach(DEFAULT_TIMEOUT_MS);
-    await browser.get(E2eTestUtils.WINSCOPE_URL);
+    await setTimeouts(DEFAULT_TIMEOUT_MS);
+    await browser.get(WINSCOPE_URL);
   });
 
   it('can clear all files', async () => {
-    await E2eTestUtils.loadBugReport(DEFAULT_TIMEOUT_MS);
-    await E2eTestUtils.clickClearAllButton();
+    await loadBugReport(DEFAULT_TIMEOUT_MS);
+    await clickClearAllButton();
     await checkNoFilesUploaded();
   });
 
   it('can remove a file using the close icon', async () => {
-    await E2eTestUtils.loadBugReport(DEFAULT_TIMEOUT_MS);
-    await E2eTestUtils.clickCloseIcon();
+    await loadBugReport(DEFAULT_TIMEOUT_MS);
+    await clickCloseIcon();
     await checkFileRemoved();
   });
 
   it('can replace an uploaded file with a new file', async () => {
-    await E2eTestUtils.loadBugReport(DEFAULT_TIMEOUT_MS);
-    await E2eTestUtils.uploadFixture(
-      'traces/perfetto/layers_trace.perfetto-trace',
-    );
+    await loadBugReport(DEFAULT_TIMEOUT_MS);
+    await uploadFixture('traces/perfetto/layers_trace.perfetto-trace');
     await checkFileReplaced();
   });
 
   it('can process bugreport', async () => {
-    await E2eTestUtils.loadBugReport(DEFAULT_TIMEOUT_MS);
-    await E2eTestUtils.clickViewTracesButton();
+    await loadBugReport(DEFAULT_TIMEOUT_MS);
+    await clickViewTracesButton();
     await checkRendersSurfaceFlingerView();
   });
 
@@ -63,12 +70,8 @@ describe('Upload traces', () => {
   }
 
   it("doesn't emit messages for valid trace file", async () => {
-    await E2eTestUtils.uploadFixture(
-      'traces/elapsed_and_real_timestamp/SurfaceFlinger.pb',
-    );
-    expect(
-      await E2eTestUtils.areMessagesEmitted(DEFAULT_TIMEOUT_MS),
-    ).toBeFalsy();
+    await uploadFixture('traces/elapsed_and_real_timestamp/SurfaceFlinger.pb');
+    expect(await areMessagesEmitted(DEFAULT_TIMEOUT_MS)).toBeFalsy();
   });
 
   async function checkNoFilesUploaded() {
diff --git a/tools/winscope/src/test/e2e/utils.ts b/tools/winscope/src/test/e2e/utils.ts
index 24ca00f0d..2ca920ec0 100644
--- a/tools/winscope/src/test/e2e/utils.ts
+++ b/tools/winscope/src/test/e2e/utils.ts
@@ -16,415 +16,400 @@
 import * as path from 'path';
 import {browser, by, element, ElementFinder, protractor} from 'protractor';
 
-class E2eTestUtils {
-  static readonly WINSCOPE_URL = 'http://localhost:8080';
-  static readonly REMOTE_TOOL_MOCK_URL = 'http://localhost:8081';
-
-  static async beforeEach(defaultTimeoutMs: number) {
-    await browser.manage().timeouts().implicitlyWait(defaultTimeoutMs);
-    await E2eTestUtils.checkServerIsUp('Winscope', E2eTestUtils.WINSCOPE_URL);
-    await browser.driver.manage().window().maximize();
-  }
+export const WINSCOPE_URL = 'http://localhost:8080';
+export const REMOTE_TOOL_MOCK_URL = 'http://localhost:8081';
+const JASMINE_DEFAULT_TIMEOUT_MS = 40000;
+
+export async function setTimeouts(
+  defaultTimeoutMs: number,
+  jasmineTimeoutMs = JASMINE_DEFAULT_TIMEOUT_MS,
+) {
+  jasmine.DEFAULT_TIMEOUT_INTERVAL = jasmineTimeoutMs;
+  await browser.manage().timeouts().implicitlyWait(defaultTimeoutMs);
+  await checkServerIsUp('Winscope', WINSCOPE_URL);
+  await browser.driver.manage().window().maximize();
+}
 
-  static async checkServerIsUp(name: string, url: string) {
-    try {
-      await browser.get(url);
-    } catch (error) {
-      fail(`${name} server (${url}) looks down. Did you start it?`);
-    }
+export async function checkServerIsUp(name: string, url: string) {
+  try {
+    await browser.get(url);
+  } catch (error) {
+    fail(`${name} server (${url}) looks down. Did you start it?`);
   }
+}
 
-  static async loadTraceAndCheckViewer(
-    fixturePath: string,
-    viewerTabTitle: string,
-    viewerSelector: string,
-  ) {
-    await E2eTestUtils.uploadFixture(fixturePath);
-    await E2eTestUtils.closeSnackBar();
-    await E2eTestUtils.clickViewTracesButton();
-    await E2eTestUtils.clickViewerTabButton(viewerTabTitle);
-
-    const viewerPresent = await element(by.css(viewerSelector)).isPresent();
-    expect(viewerPresent).toBeTruthy();
-  }
+export async function loadTraceAndCheckViewer(
+  fixturePath: string,
+  viewerTabTitle: string,
+  viewerSelector: string,
+) {
+  await uploadFixture(fixturePath);
+  await closeSnackBar();
+  await clickViewTracesButton();
+  await clickViewerTabButton(viewerTabTitle);
+
+  const viewerPresent = await element(by.css(viewerSelector)).isPresent();
+  expect(viewerPresent).toBeTruthy();
+}
 
-  static async loadBugReport(defaulttimeMs: number) {
-    await E2eTestUtils.uploadFixture('bugreports/bugreport_stripped.zip');
-    await E2eTestUtils.checkHasLoadedTracesFromBugReport();
-    expect(await E2eTestUtils.areMessagesEmitted(defaulttimeMs)).toBeTruthy();
-    await E2eTestUtils.checkEmitsUnsupportedFileFormatMessages();
-    await E2eTestUtils.checkEmitsOldDataMessages();
-    await E2eTestUtils.closeSnackBar();
-  }
+export async function loadBugReport(defaulttimeMs: number) {
+  await uploadFixture('bugreports/bugreport_stripped.zip');
+  await checkHasLoadedTracesFromBugReport();
+  expect(await areMessagesEmitted(defaulttimeMs)).toBeTruthy();
+  await checkEmitsUnsupportedFileFormatMessages();
+  await checkEmitsOldDataMessages();
+  await closeSnackBar();
+}
 
-  static async areMessagesEmitted(defaultTimeoutMs: number): Promise<boolean> {
-    // Messages are emitted quickly. There is no Need to wait for the entire
-    // default timeout to understand whether the messages where emitted or not.
-    await browser.manage().timeouts().implicitlyWait(1000);
-    const emitted = await element(by.css('snack-bar')).isPresent();
-    await browser.manage().timeouts().implicitlyWait(defaultTimeoutMs);
-    return emitted;
-  }
+export async function areMessagesEmitted(
+  defaultTimeoutMs: number,
+): Promise<boolean> {
+  // Messages are emitted quickly. There is no Need to wait for the entire
+  // default timeout to understand whether the messages where emitted or not.
+  await browser.manage().timeouts().implicitlyWait(1000);
+  const emitted = await element(by.css('snack-bar')).isPresent();
+  await browser.manage().timeouts().implicitlyWait(defaultTimeoutMs);
+  return emitted;
+}
 
-  static async clickViewTracesButton() {
-    const button = element(by.css('.load-btn'));
-    await button.click();
-  }
+export async function clickViewTracesButton() {
+  const button = element(by.css('.load-btn'));
+  await button.click();
+}
 
-  static async clickClearAllButton() {
-    const button = element(by.css('.clear-all-btn'));
-    await button.click();
-  }
+export async function clickClearAllButton() {
+  const button = element(by.css('.clear-all-btn'));
+  await button.click();
+}
 
-  static async clickCloseIcon() {
-    const button = element.all(by.css('.uploaded-files button')).first();
-    await button.click();
-  }
+export async function clickCloseIcon() {
+  const button = element.all(by.css('.uploaded-files button')).first();
+  await button.click();
+}
 
-  static async clickDownloadTracesButton() {
-    const button = element(by.css('.save-button'));
-    await button.click();
-  }
+export async function clickDownloadTracesButton() {
+  const button = element(by.css('.save-button'));
+  await button.click();
+}
 
-  static async clickUploadNewButton() {
-    const button = element(by.css('.upload-new'));
-    await button.click();
-  }
+export async function clickUploadNewButton() {
+  const button = element(by.css('.upload-new'));
+  await button.click();
+}
 
-  static async closeSnackBar() {
-    const closeButton = element(by.css('.snack-bar-action'));
-    const isPresent = await closeButton.isPresent();
-    if (isPresent) {
-      await closeButton.click();
-    }
+export async function closeSnackBar() {
+  const closeButton = element(by.css('.snack-bar-action'));
+  const isPresent = await closeButton.isPresent();
+  if (isPresent) {
+    await closeButton.click();
   }
+}
 
-  static async clickViewerTabButton(title: string) {
-    const tabs: ElementFinder[] = await element.all(by.css('trace-view .tab'));
-    for (const tab of tabs) {
-      const tabTitle = await tab.getText();
-      if (tabTitle.includes(title)) {
-        await tab.click();
-        return;
-      }
+export async function clickViewerTabButton(title: string) {
+  await browser.wait(
+    async () => {
+      return await element(by.css('trace-view')).isPresent();
+    },
+    20000,
+    'Viewers failed to load',
+  );
+  const tabs: ElementFinder[] = await element.all(by.css('trace-view .tab'));
+  for (const tab of tabs) {
+    const tabTitle = await tab.getText();
+    if (tabTitle.includes(title)) {
+      await tab.click();
+      return;
     }
-    throw new Error(`could not find tab corresponding to ${title}`);
   }
+  throw new Error(`could not find tab corresponding to ${title}`);
+}
 
-  static async checkTimelineTraceSelector(trace: {
-    icon: string;
-    color: string;
-  }) {
-    const traceSelector = element(by.css('#trace-selector'));
-    const text = await traceSelector.getText();
-    expect(text).toContain(trace.icon);
-
-    const icons = await element.all(by.css('.shown-selection .mat-icon'));
-    const iconColors: string[] = [];
-    for (const icon of icons) {
-      iconColors.push(await icon.getCssValue('color'));
-    }
-    expect(
-      iconColors.some((iconColor) => iconColor === trace.color),
-    ).toBeTruthy();
-  }
+export async function checkTimelineTraceSelector(trace: {
+  icon: string;
+  color: string;
+}) {
+  const traceSelector = element(by.css('#trace-selector'));
+  const text = await traceSelector.getText();
+  expect(text).toContain(trace.icon);
+
+  const icons = await element.all(by.css('.shown-selection .mat-icon'));
+  const iconColors: string[] = [];
+  for (const icon of icons) {
+    iconColors.push(await icon.getCssValue('color'));
+  }
+  expect(
+    iconColors.some((iconColor) => iconColor === trace.color),
+  ).toBeTruthy();
+}
 
-  static async checkInitialRealTimestamp(timestamp: string) {
-    await E2eTestUtils.changeRealTimestampInWinscope(timestamp);
-    await E2eTestUtils.checkWinscopeRealTimestamp(timestamp.slice(12));
-    const prevEntryButton = element(by.css('#prev_entry_button'));
-    const isDisabled = await prevEntryButton.getAttribute('disabled');
-    expect(isDisabled).toEqual('true');
-  }
+export async function checkInitialRealTimestamp(timestamp: string) {
+  await changeRealTimestampInWinscope(timestamp);
+  await checkWinscopeRealTimestamp(timestamp.slice(12));
+  const prevEntryButton = element(by.css('#prev_entry_button'));
+  const isDisabled = await prevEntryButton.getAttribute('disabled');
+  expect(isDisabled).toEqual('true');
+}
 
-  static async checkFinalRealTimestamp(timestamp: string) {
-    await E2eTestUtils.changeRealTimestampInWinscope(timestamp);
-    await E2eTestUtils.checkWinscopeRealTimestamp(timestamp.slice(12));
-    const nextEntryButton = element(by.css('#next_entry_button'));
-    const isDisabled = await nextEntryButton.getAttribute('disabled');
-    expect(isDisabled).toEqual('true');
-  }
+export async function checkFinalRealTimestamp(timestamp: string) {
+  await changeRealTimestampInWinscope(timestamp);
+  await checkWinscopeRealTimestamp(timestamp.slice(12));
+  const nextEntryButton = element(by.css('#next_entry_button'));
+  const isDisabled = await nextEntryButton.getAttribute('disabled');
+  expect(isDisabled).toEqual('true');
+}
 
-  static async checkWinscopeRealTimestamp(timestamp: string) {
-    const inputElement = element(by.css('input[name="humanTimeInput"]'));
-    const value = await inputElement.getAttribute('value');
-    expect(value).toEqual(timestamp);
-  }
+export async function checkWinscopeRealTimestamp(timestamp: string) {
+  const inputElement = element(by.css('input[name="humanTimeInput"]'));
+  const value = await inputElement.getAttribute('value');
+  expect(value).toEqual(timestamp);
+}
 
-  static async changeRealTimestampInWinscope(newTimestamp: string) {
-    await E2eTestUtils.updateInputField('', 'humanTimeInput', newTimestamp);
-  }
+export async function changeRealTimestampInWinscope(newTimestamp: string) {
+  await updateInputField('', 'humanTimeInput', newTimestamp);
+}
 
-  static async checkWinscopeNsTimestamp(newTimestamp: string) {
-    const inputElement = element(by.css('input[name="nsTimeInput"]'));
-    const valueWithNsSuffix = await inputElement.getAttribute('value');
-    expect(valueWithNsSuffix).toEqual(newTimestamp + ' ns');
-  }
+export async function checkWinscopeNsTimestamp(newTimestamp: string) {
+  const inputElement = element(by.css('input[name="nsTimeInput"]'));
+  const valueWithNsSuffix = await inputElement.getAttribute('value');
+  expect(valueWithNsSuffix).toEqual(newTimestamp + ' ns');
+}
 
-  static async changeNsTimestampInWinscope(newTimestamp: string) {
-    await E2eTestUtils.updateInputField('', 'nsTimeInput', newTimestamp);
-  }
+export async function changeNsTimestampInWinscope(newTimestamp: string) {
+  await updateInputField('', 'nsTimeInput', newTimestamp);
+}
 
-  static async filterHierarchy(viewer: string, filterString: string) {
-    await E2eTestUtils.updateInputField(
-      `${viewer} hierarchy-view .title-section`,
-      'filter',
-      filterString,
-    );
-  }
+export async function filterHierarchy(viewer: string, filterString: string) {
+  await updateInputField(
+    `${viewer} hierarchy-view .title-section`,
+    'filter',
+    filterString,
+  );
+}
 
-  static async updateInputField(
-    inputFieldSelector: string,
-    inputFieldName: string,
-    newInput: string,
-  ) {
-    const inputElement = element(
-      by.css(`${inputFieldSelector} input[name="${inputFieldName}"]`),
-    );
-    const inputStringStep1 = newInput.slice(0, -1);
-    const inputStringStep2 = newInput.slice(-1) + '\r\n';
-    const script = `document.querySelector("${inputFieldSelector} input[name=\\"${inputFieldName}\\"]").value = "${inputStringStep1}"`;
-    await browser.executeScript(script);
-    await inputElement.sendKeys(inputStringStep2);
-  }
+export async function updateInputField(
+  inputFieldSelector: string,
+  inputFieldName: string,
+  newInput: string,
+) {
+  const inputElement = element(
+    by.css(`${inputFieldSelector} input[name="${inputFieldName}"]`),
+  );
+  const inputStringStep1 = newInput.slice(0, -1);
+  const inputStringStep2 = newInput.slice(-1) + '\r\n';
+  const script = `document.querySelector("${inputFieldSelector} input[name=\\"${inputFieldName}\\"]").value = "${inputStringStep1}"`;
+  await browser.executeScript(script);
+  await inputElement.sendKeys(inputStringStep2);
+}
 
-  static async selectItemInHierarchy(viewer: string, itemName: string) {
-    const nodes: ElementFinder[] = await element.all(
-      by.css(`${viewer} hierarchy-view .node`),
-    );
-    for (const node of nodes) {
-      const id = await node.getAttribute('id');
-      if (id.includes(itemName)) {
-        const desc = node.element(by.css('.description'));
-        await desc.click();
-        return;
-      }
+export async function selectItemInHierarchy(viewer: string, itemName: string) {
+  const nodes: ElementFinder[] = await element.all(
+    by.css(`${viewer} hierarchy-view .node`),
+  );
+  for (const node of nodes) {
+    const id = await node.getAttribute('id');
+    if (id.includes(itemName)) {
+      const desc = node.element(by.css('.description'));
+      await desc.click();
+      return;
     }
-    throw new Error(`could not find item matching ${itemName} in hierarchy`);
   }
+  throw new Error(`could not find item matching ${itemName} in hierarchy`);
+}
 
-  static async applyStateToHierarchyOptions(
-    viewerSelector: string,
-    shouldEnable: boolean,
-  ) {
-    const options: ElementFinder[] = await element.all(
-      by.css(`${viewerSelector} hierarchy-view .view-controls .user-option`),
+export async function applyStateToHierarchyOptions(
+  viewerSelector: string,
+  shouldEnable: boolean,
+) {
+  const options: ElementFinder[] = await element.all(
+    by.css(`${viewerSelector} hierarchy-view .view-controls .user-option`),
+  );
+  for (const option of options) {
+    const isEnabled = !(await option.getAttribute('class')).includes(
+      'not-enabled',
     );
-    for (const option of options) {
-      const isEnabled = !(await option.getAttribute('class')).includes(
-        'not-enabled',
-      );
-      if (shouldEnable && !isEnabled) {
-        await option.click();
-      } else if (!shouldEnable && isEnabled) {
-        await option.click();
-      }
+    if (shouldEnable && !isEnabled) {
+      await option.click();
+    } else if (!shouldEnable && isEnabled) {
+      await option.click();
     }
   }
+}
 
-  static async checkItemInPropertiesTree(
-    viewer: string,
-    itemName: string,
-    expectedText: string,
-  ) {
-    const nodes = await element.all(by.css(`${viewer} .properties-view .node`));
-    for (const node of nodes) {
-      const id: string = await node.getAttribute('id');
-      if (id === 'node' + itemName) {
-        const text = await node.getText();
-        expect(text).toEqual(expectedText);
-        return;
-      }
+export async function checkItemInPropertiesTree(
+  viewer: string,
+  itemName: string,
+  expectedText: string,
+) {
+  const nodes = await element.all(by.css(`${viewer} .properties-view .node`));
+  for (const node of nodes) {
+    const id: string = await node.getAttribute('id');
+    if (id === 'node' + itemName) {
+      const text = await node.getText();
+      expect(text).toEqual(expectedText);
+      return;
     }
-    throw new Error(`could not find item ${itemName} in properties tree`);
   }
+  throw new Error(`could not find item ${itemName} in properties tree`);
+}
 
-  static async checkRectLabel(viewer: string, expectedLabel: string) {
-    const labels = await element.all(
-      by.css(`${viewer} rects-view .rect-label`),
-    );
+export async function checkRectLabel(viewer: string, expectedLabel: string) {
+  const labels = await element.all(by.css(`${viewer} rects-view .rect-label`));
 
-    let foundLabel: ElementFinder | undefined;
+  let foundLabel: ElementFinder | undefined;
 
-    for (const label of labels) {
-      const text = await label.getText();
-      if (text.includes(expectedLabel)) {
-        foundLabel = label;
-        break;
-      }
+  for (const label of labels) {
+    const text = await label.getText();
+    if (text.includes(expectedLabel)) {
+      foundLabel = label;
+      break;
     }
-
-    expect(foundLabel).toBeTruthy();
   }
 
-  static async checkScrollPresent(viewerSelector: string) {
-    await browser.wait(
-      async () => {
-        return await element(by.css(`${viewerSelector} .scroll`)).isPresent();
-      },
-      1000,
-      'Fetching data timeout',
-    );
-  }
+  expect(foundLabel).toBeTruthy();
+}
 
-  static async checkTotalScrollEntries(
-    viewerSelector: string,
-    numberOfEntries: number,
-    scrollToBottom = false,
-  ) {
-    if (scrollToBottom) {
-      const viewport = element(by.css(`${viewerSelector} .scroll`));
-      let lastId: string | undefined;
-      let lastScrollEntryItemId = await E2eTestUtils.getLastScrollEntryItemId(
-        viewerSelector,
-      );
-      while (lastId !== lastScrollEntryItemId) {
-        lastId = lastScrollEntryItemId;
-        await viewport.sendKeys(protractor.Key.END);
-        await new Promise<void>((resolve) => setTimeout(resolve, 500));
-        lastScrollEntryItemId = await E2eTestUtils.getLastScrollEntryItemId(
-          viewerSelector,
-        );
-      }
-    }
-    const lastId = await E2eTestUtils.getLastScrollEntryItemId(viewerSelector);
-    expect(lastId).toEqual(`${numberOfEntries - 1}`);
-  }
+export async function checkScrollPresent(viewerSelector: string) {
+  await browser.wait(
+    async () => {
+      const scrollIsPresent = await element(
+        by.css(`${viewerSelector} .scroll`),
+      ).isPresent();
+      const placeholderPresent = await element(
+        by.css(`${viewerSelector} .fetching-data`),
+      ).isPresent();
+      return scrollIsPresent && !placeholderPresent;
+    },
+    5000,
+    'Fetching data timeout',
+  );
+}
 
-  static async getLastScrollEntryItemId(
-    viewerSelector: string,
-  ): Promise<string> {
-    const entries = await element.all(
-      by.css(`${viewerSelector} .scroll .entry`),
-    );
-    return await entries[entries.length - 1].getAttribute('item-id');
+export async function checkTotalScrollEntries(
+  viewerSelector: string,
+  numberOfEntries: number,
+  scrollToBottom = false,
+) {
+  if (scrollToBottom) {
+    const viewport = element(by.css(`${viewerSelector} .scroll`));
+    let lastId: string | undefined;
+    let lastScrollEntryItemId = await getLastScrollEntryItemId(viewerSelector);
+    while (lastId !== lastScrollEntryItemId) {
+      lastId = lastScrollEntryItemId;
+      await viewport.sendKeys(protractor.Key.END);
+      await new Promise<void>((resolve) => setTimeout(resolve, 500));
+      lastScrollEntryItemId = await getLastScrollEntryItemId(viewerSelector);
+    }
   }
+  const lastId = await getLastScrollEntryItemId(viewerSelector);
+  expect(lastId).toEqual(`${numberOfEntries - 1}`);
+}
 
-  static async checkSelectFilter(
-    viewerSelector: string,
-    filterSelector: string,
-    options: string[],
-    expectedFilteredEntries: number,
-    totalEntries: number,
-  ) {
-    await E2eTestUtils.toggleSelectFilterOptions(
-      viewerSelector,
-      filterSelector,
-      options,
-    );
-    await E2eTestUtils.checkTotalScrollEntries(
-      viewerSelector,
-      expectedFilteredEntries,
-    );
+export async function getLastScrollEntryItemId(
+  viewerSelector: string,
+): Promise<string> {
+  const entries = await element.all(by.css(`${viewerSelector} .scroll .entry`));
+  return await entries[entries.length - 1].getAttribute('item-id');
+}
 
-    await E2eTestUtils.toggleSelectFilterOptions(
-      viewerSelector,
-      filterSelector,
-      options,
-    );
-    await E2eTestUtils.checkTotalScrollEntries(
-      viewerSelector,
-      totalEntries,
-      true,
-    );
-  }
+export async function checkSelectFilter(
+  viewerSelector: string,
+  filterSelector: string,
+  options: string[],
+  expectedFilteredEntries: number,
+  totalEntries: number,
+) {
+  await toggleSelectFilterOptions(viewerSelector, filterSelector, options);
+  await checkTotalScrollEntries(viewerSelector, expectedFilteredEntries);
+
+  await toggleSelectFilterOptions(viewerSelector, filterSelector, options);
+  await checkTotalScrollEntries(viewerSelector, totalEntries, true);
+}
 
-  static async uploadFixture(...paths: string[]) {
-    const inputFile = element(by.css('input[type="file"]'));
+export async function uploadFixture(...paths: string[]) {
+  const inputFile = element(by.css('input[type="file"]'));
 
-    // Uploading multiple files is not properly supported but
-    // chrome handles file paths joined with new lines
-    await inputFile.sendKeys(
-      paths.map((it) => E2eTestUtils.getFixturePath(it)).join('\n'),
-    );
-  }
+  // Uploading multiple files is not properly supported but
+  // chrome handles file paths joined with new lines
+  await inputFile.sendKeys(paths.map((it) => getFixturePath(it)).join('\n'));
+}
 
-  static getFixturePath(filename: string): string {
-    if (path.isAbsolute(filename)) {
-      return filename;
-    }
-    return path.join(
-      E2eTestUtils.getProjectRootPath(),
-      'src/test/fixtures',
-      filename,
-    );
+export function getFixturePath(filename: string): string {
+  if (path.isAbsolute(filename)) {
+    return filename;
   }
+  return path.join(getProjectRootPath(), 'src/test/fixtures', filename);
+}
 
-  private static getProjectRootPath(): string {
-    let root = __dirname;
-    while (path.basename(root) !== 'winscope') {
-      root = path.dirname(root);
-    }
-    return root;
+export function getProjectRootPath(): string {
+  let root = __dirname;
+  while (path.basename(root) !== 'winscope') {
+    root = path.dirname(root);
   }
+  return root;
+}
 
-  private static async checkHasLoadedTracesFromBugReport() {
-    const text = await element(by.css('.uploaded-files')).getText();
-    expect(text).toContain('Window Manager');
-    expect(text).toContain('Surface Flinger');
-    expect(text).toContain('Transactions');
-    expect(text).toContain('Transitions');
-
-    // Should be merged into a single Transitions trace
-    expect(text).not.toContain('WM Transitions');
-    expect(text).not.toContain('Shell Transitions');
-
-    expect(text).toContain('layers_trace_from_transactions.winscope');
-    expect(text).toContain('transactions_trace.winscope');
-    expect(text).toContain('wm_transition_trace.winscope');
-    expect(text).toContain('shell_transition_trace.winscope');
-    expect(text).toContain('window_CRITICAL.proto');
-
-    // discards some traces due to old data
-    expect(text).not.toContain('ProtoLog');
-    expect(text).not.toContain('IME Service');
-    expect(text).not.toContain('IME system_server');
-    expect(text).not.toContain('IME Clients');
-    expect(text).not.toContain('wm_log.winscope');
-    expect(text).not.toContain('ime_trace_service.winscope');
-    expect(text).not.toContain('ime_trace_managerservice.winscope');
-    expect(text).not.toContain('wm_trace.winscope');
-    expect(text).not.toContain('ime_trace_clients.winscope');
-  }
+async function checkHasLoadedTracesFromBugReport() {
+  const text = await element(by.css('.uploaded-files')).getText();
+  expect(text).toContain('Window Manager');
+  expect(text).toContain('Surface Flinger');
+  expect(text).toContain('Transactions');
+  expect(text).toContain('Transitions');
+
+  // Should be merged into a single Transitions trace
+  expect(text).not.toContain('WM Transitions');
+  expect(text).not.toContain('Shell Transitions');
+
+  expect(text).toContain('layers_trace_from_transactions.winscope');
+  expect(text).toContain('transactions_trace.winscope');
+  expect(text).toContain('wm_transition_trace.winscope');
+  expect(text).toContain('shell_transition_trace.winscope');
+  expect(text).toContain('window_CRITICAL.proto');
+
+  // discards some traces due to old data
+  expect(text).not.toContain('ProtoLog');
+  expect(text).not.toContain('IME Service');
+  expect(text).not.toContain('IME system_server');
+  expect(text).not.toContain('IME Clients');
+  expect(text).not.toContain('wm_log.winscope');
+  expect(text).not.toContain('ime_trace_service.winscope');
+  expect(text).not.toContain('ime_trace_managerservice.winscope');
+  expect(text).not.toContain('wm_trace.winscope');
+  expect(text).not.toContain('ime_trace_clients.winscope');
+}
 
-  private static async checkEmitsUnsupportedFileFormatMessages() {
-    const text = await element(by.css('snack-bar')).getText();
-    expect(text).toContain('unsupported format');
-  }
+async function checkEmitsUnsupportedFileFormatMessages() {
+  const text = await element(by.css('snack-bar')).getText();
+  expect(text).toContain('unsupported format');
+}
 
-  private static async checkEmitsOldDataMessages() {
-    const text = await element(by.css('snack-bar')).getText();
-    expect(text).toContain('discarded because data is old');
-  }
+async function checkEmitsOldDataMessages() {
+  const text = await element(by.css('snack-bar')).getText();
+  expect(text).toContain('discarded because data is old');
+}
 
-  private static async toggleSelectFilterOptions(
-    viewerSelector: string,
-    filterSelector: string,
-    options: string[],
-  ) {
-    await element(
-      by.css(
-        `${viewerSelector} .headers ${filterSelector} .mat-select-trigger`,
-      ),
-    ).click();
-    const optionElements: ElementFinder[] = await element.all(
-      by.css('.mat-select-panel .option'),
-    );
-    for (const optionEl of optionElements) {
-      const optionText = (await optionEl.getText()).trim();
-      if (options.some((option) => optionText === option)) {
-        await optionEl.click();
-        options = options.filter((option) => option !== optionText);
-        if (options.length === 0) {
-          break;
-        }
+async function toggleSelectFilterOptions(
+  viewerSelector: string,
+  filterSelector: string,
+  options: string[],
+) {
+  await element(
+    by.css(`${viewerSelector} .headers ${filterSelector} .mat-select-trigger`),
+  ).click();
+  const optionElements: ElementFinder[] = await element.all(
+    by.css('.mat-select-panel .option'),
+  );
+  for (const optionEl of optionElements) {
+    const optionText = (await optionEl.getText()).trim();
+    if (options.some((option) => optionText === option)) {
+      await optionEl.click();
+      options = options.filter((option) => option !== optionText);
+      if (options.length === 0) {
+        break;
       }
     }
-    const backdrop = await element(
-      by.css('.cdk-overlay-backdrop'),
-    ).getWebElement();
-    await browser.actions().mouseMove(backdrop, {x: 0, y: 0}).click().perform();
   }
+  const backdrop = await element(
+    by.css('.cdk-overlay-backdrop'),
+  ).getWebElement();
+  await browser.actions().mouseMove(backdrop, {x: 0, y: 0}).click().perform();
 }
-
-export {E2eTestUtils};
diff --git a/tools/winscope/src/test/e2e/viewer_input_method_clients_test.ts b/tools/winscope/src/test/e2e/viewer_input_method_clients_test.ts
index a92d7830f..20d459089 100644
--- a/tools/winscope/src/test/e2e/viewer_input_method_clients_test.ts
+++ b/tools/winscope/src/test/e2e/viewer_input_method_clients_test.ts
@@ -15,33 +15,43 @@
  */
 
 import {browser, by, element} from 'protractor';
-import {E2eTestUtils} from './utils';
+import {
+  applyStateToHierarchyOptions,
+  changeRealTimestampInWinscope,
+  checkFinalRealTimestamp,
+  checkInitialRealTimestamp,
+  checkItemInPropertiesTree,
+  checkTimelineTraceSelector,
+  checkWinscopeRealTimestamp,
+  loadTraceAndCheckViewer,
+  selectItemInHierarchy,
+  setTimeouts,
+  WINSCOPE_URL,
+} from './utils';
 
 describe('Viewer Input Method Clients', () => {
   const viewerSelector = 'viewer-input-method';
 
   beforeEach(async () => {
-    await E2eTestUtils.beforeEach(1000);
-    await browser.get(E2eTestUtils.WINSCOPE_URL);
+    await setTimeouts(1000, 60000);
+    await browser.get(WINSCOPE_URL);
   });
 
   it('processes trace from zip and navigates correctly', async () => {
-    await E2eTestUtils.loadTraceAndCheckViewer(
-      'traces/deployment_full_trace_phone.zip',
+    await loadTraceAndCheckViewer(
+      'archives/deployment_full_trace_phone.zip',
       'IME Clients',
       viewerSelector,
     );
-    await E2eTestUtils.checkTimelineTraceSelector({
+    await checkTimelineTraceSelector({
       icon: 'keyboard_alt',
       color: 'rgba(255, 150, 75, 1)',
     });
-    await E2eTestUtils.checkInitialRealTimestamp('2022-11-21, 18:05:11.145');
-    await E2eTestUtils.checkFinalRealTimestamp('2022-11-21, 18:05:18.245');
+    await checkInitialRealTimestamp('2022-11-21, 18:05:11.145');
+    await checkFinalRealTimestamp('2022-11-21, 18:05:18.245');
 
-    await E2eTestUtils.changeRealTimestampInWinscope(
-      '2022-11-21, 18:05:14.969',
-    );
-    await E2eTestUtils.checkWinscopeRealTimestamp('18:05:14.969');
+    await changeRealTimestampInWinscope('2022-11-21, 18:05:14.969');
+    await checkWinscopeRealTimestamp('18:05:14.969');
 
     await checkAdditionalProperties();
     await clickWmState();
@@ -51,10 +61,10 @@ describe('Viewer Input Method Clients', () => {
     await clickInputMethodSurface();
     await checkInputMethodSurfaceProperties();
 
-    await E2eTestUtils.selectItemInHierarchy(viewerSelector, 'InputMethod#765');
+    await selectItemInHierarchy(viewerSelector, 'InputMethod#765');
     await checkInputMethodLayerProperties();
 
-    await E2eTestUtils.applyStateToHierarchyOptions(viewerSelector, true);
+    await applyStateToHierarchyOptions(viewerSelector, true);
     await checkHierarchy();
   });
 
@@ -77,25 +87,25 @@ describe('Viewer Input Method Clients', () => {
   }
 
   async function checkInputMethodLayerProperties() {
-    await E2eTestUtils.checkItemInPropertiesTree(
+    await checkItemInPropertiesTree(
       viewerSelector,
       'activeBuffer',
       'activeBuffer:\nw: 1006, h: 2204, stride: 268437760, format: 1',
     );
 
-    await E2eTestUtils.checkItemInPropertiesTree(
+    await checkItemInPropertiesTree(
       viewerSelector,
       'bufferTransform',
       'bufferTransform:\nROT_270',
     );
 
-    await E2eTestUtils.checkItemInPropertiesTree(
+    await checkItemInPropertiesTree(
       viewerSelector,
       'hwcCompositionType',
-      'hwcCompositionType:\nDEVICE',
+      'hwcCompositionType:\nHWC_TYPE_DEVICE',
     );
 
-    await E2eTestUtils.checkItemInPropertiesTree(
+    await checkItemInPropertiesTree(
       viewerSelector,
       'bounds',
       'bounds:\n(0, 0) - (2204, 1006)',
@@ -166,13 +176,13 @@ describe('Viewer Input Method Clients', () => {
   }
 
   async function checkWmStateProperties() {
-    await E2eTestUtils.checkItemInPropertiesTree(
+    await checkItemInPropertiesTree(
       viewerSelector,
       'screenState',
       'screenState:\nSCREEN_STATE_ON',
     );
 
-    await E2eTestUtils.checkItemInPropertiesTree(
+    await checkItemInPropertiesTree(
       viewerSelector,
       'windowFramesValid',
       'windowFramesValid:\ntrue',
@@ -187,13 +197,9 @@ describe('Viewer Input Method Clients', () => {
   }
 
   async function checkImeContainerProperties() {
-    await E2eTestUtils.checkItemInPropertiesTree(
-      viewerSelector,
-      'id',
-      'id:\n12',
-    );
+    await checkItemInPropertiesTree(viewerSelector, 'id', 'id:\n12');
 
-    await E2eTestUtils.checkItemInPropertiesTree(
+    await checkItemInPropertiesTree(
       viewerSelector,
       'bounds',
       'bounds:\n(-10800, -23400) - (10800, 23400)',
@@ -208,19 +214,15 @@ describe('Viewer Input Method Clients', () => {
   }
 
   async function checkInputMethodSurfaceProperties() {
-    await E2eTestUtils.checkItemInPropertiesTree(
-      viewerSelector,
-      'id',
-      'id:\n795',
-    );
+    await checkItemInPropertiesTree(viewerSelector, 'id', 'id:\n795');
 
-    await E2eTestUtils.checkItemInPropertiesTree(
+    await checkItemInPropertiesTree(
       viewerSelector,
       'position',
       'position:\nx: 136, y: 148',
     );
 
-    await E2eTestUtils.checkItemInPropertiesTree(
+    await checkItemInPropertiesTree(
       viewerSelector,
       'transform',
       'transform:\nTRANSLATE',
diff --git a/tools/winscope/src/test/e2e/viewer_input_method_manager_service_test.ts b/tools/winscope/src/test/e2e/viewer_input_method_manager_service_test.ts
index 300765cb8..91422174c 100644
--- a/tools/winscope/src/test/e2e/viewer_input_method_manager_service_test.ts
+++ b/tools/winscope/src/test/e2e/viewer_input_method_manager_service_test.ts
@@ -15,43 +15,50 @@
  */
 
 import {browser, by, element} from 'protractor';
-import {E2eTestUtils} from './utils';
+import {
+  applyStateToHierarchyOptions,
+  changeRealTimestampInWinscope,
+  checkFinalRealTimestamp,
+  checkInitialRealTimestamp,
+  checkItemInPropertiesTree,
+  checkTimelineTraceSelector,
+  checkWinscopeRealTimestamp,
+  loadTraceAndCheckViewer,
+  selectItemInHierarchy,
+  setTimeouts,
+  WINSCOPE_URL,
+} from './utils';
 
 describe('Viewer Input Method Manager Service', () => {
   const viewerSelector = 'viewer-input-method';
 
   beforeEach(async () => {
-    await E2eTestUtils.beforeEach(1000);
-    await browser.get(E2eTestUtils.WINSCOPE_URL);
+    await setTimeouts(1000);
+    await browser.get(WINSCOPE_URL);
   });
 
   it('processes trace from zip and navigates correctly', async () => {
-    await E2eTestUtils.loadTraceAndCheckViewer(
-      'traces/deployment_full_trace_phone.zip',
+    await loadTraceAndCheckViewer(
+      'archives/deployment_full_trace_phone.zip',
       'IME system_server',
       viewerSelector,
     );
-    await E2eTestUtils.checkTimelineTraceSelector({
+    await checkTimelineTraceSelector({
       icon: 'keyboard_alt',
       color: 'rgba(255, 194, 75, 1)',
     });
-    await E2eTestUtils.checkInitialRealTimestamp('2022-11-21, 18:05:11.145');
-    await E2eTestUtils.checkFinalRealTimestamp('2022-11-21, 18:05:18.081');
+    await checkInitialRealTimestamp('2022-11-21, 18:05:11.145');
+    await checkFinalRealTimestamp('2022-11-21, 18:05:18.081');
 
-    await E2eTestUtils.changeRealTimestampInWinscope(
-      '2022-11-21, 18:05:14.713',
-    );
-    await E2eTestUtils.checkWinscopeRealTimestamp('18:05:14.713');
+    await changeRealTimestampInWinscope('2022-11-21, 18:05:14.713');
+    await checkWinscopeRealTimestamp('18:05:14.713');
 
     await checkAdditionalProperties();
     await clickWmState();
     await checkWmStateProperties();
 
-    await E2eTestUtils.applyStateToHierarchyOptions(viewerSelector, false);
-    await E2eTestUtils.selectItemInHierarchy(
-      viewerSelector,
-      'inputMethodManagerService',
-    );
+    await applyStateToHierarchyOptions(viewerSelector, false);
+    await selectItemInHierarchy(viewerSelector, 'inputMethodManagerService');
     await checkManagerServiceProperties();
   });
 
@@ -99,13 +106,13 @@ describe('Viewer Input Method Manager Service', () => {
   }
 
   async function checkWmStateProperties() {
-    await E2eTestUtils.checkItemInPropertiesTree(
+    await checkItemInPropertiesTree(
       viewerSelector,
       'interactiveState',
       'interactiveState:\nINTERACTIVE_STATE_AWAKE',
     );
 
-    await E2eTestUtils.checkItemInPropertiesTree(
+    await checkItemInPropertiesTree(
       viewerSelector,
       'windowFramesValid',
       'windowFramesValid:\ntrue',
@@ -113,25 +120,25 @@ describe('Viewer Input Method Manager Service', () => {
   }
 
   async function checkManagerServiceProperties() {
-    await E2eTestUtils.checkItemInPropertiesTree(
+    await checkItemInPropertiesTree(
       viewerSelector,
       'fieldId',
       'fieldId:\n2131430027',
     );
 
-    await E2eTestUtils.checkItemInPropertiesTree(
+    await checkItemInPropertiesTree(
       viewerSelector,
       'curToken',
       'curToken:\nandroid.os.Binder@a75e797',
     );
 
-    await E2eTestUtils.checkItemInPropertiesTree(
+    await checkItemInPropertiesTree(
       viewerSelector,
       'curFocusedWindowSoftInputMode',
       'curFocusedWindowSoftInputMode:\nSTATE_UNSPECIFIED|ADJUST_RESIZE',
     );
 
-    await E2eTestUtils.checkItemInPropertiesTree(
+    await checkItemInPropertiesTree(
       viewerSelector,
       'inputShown',
       'inputShown:\ntrue',
diff --git a/tools/winscope/src/test/e2e/viewer_input_method_service_test.ts b/tools/winscope/src/test/e2e/viewer_input_method_service_test.ts
index 631980ed5..01a7c9ee4 100644
--- a/tools/winscope/src/test/e2e/viewer_input_method_service_test.ts
+++ b/tools/winscope/src/test/e2e/viewer_input_method_service_test.ts
@@ -15,38 +15,48 @@
  */
 
 import {browser, by, element} from 'protractor';
-import {E2eTestUtils} from './utils';
+import {
+  applyStateToHierarchyOptions,
+  changeRealTimestampInWinscope,
+  checkFinalRealTimestamp,
+  checkInitialRealTimestamp,
+  checkItemInPropertiesTree,
+  checkTimelineTraceSelector,
+  checkWinscopeRealTimestamp,
+  loadTraceAndCheckViewer,
+  selectItemInHierarchy,
+  setTimeouts,
+  WINSCOPE_URL,
+} from './utils';
 
 describe('Viewer Input Method Service', () => {
   const viewerSelector = 'viewer-input-method';
 
   beforeEach(async () => {
-    await E2eTestUtils.beforeEach(1000);
-    await browser.get(E2eTestUtils.WINSCOPE_URL);
+    await setTimeouts(1000);
+    await browser.get(WINSCOPE_URL);
   });
 
   it('processes trace from zip and navigates correctly', async () => {
-    await E2eTestUtils.loadTraceAndCheckViewer(
-      'traces/deployment_full_trace_phone.zip',
+    await loadTraceAndCheckViewer(
+      'archives/deployment_full_trace_phone.zip',
       'IME Service',
       viewerSelector,
     );
-    await E2eTestUtils.checkTimelineTraceSelector({
+    await checkTimelineTraceSelector({
       icon: 'keyboard_alt',
       color: 'rgba(255, 194, 75, 1)',
     });
-    await E2eTestUtils.checkInitialRealTimestamp('2022-11-21, 18:05:12.497');
-    await E2eTestUtils.checkFinalRealTimestamp('2022-11-21, 18:05:18.061');
+    await checkInitialRealTimestamp('2022-11-21, 18:05:12.497');
+    await checkFinalRealTimestamp('2022-11-21, 18:05:18.061');
 
-    await E2eTestUtils.changeRealTimestampInWinscope(
-      '2022-11-21, 18:05:14.720',
-    );
-    await E2eTestUtils.checkWinscopeRealTimestamp('18:05:14.720');
+    await changeRealTimestampInWinscope('2022-11-21, 18:05:14.720');
+    await checkWinscopeRealTimestamp('18:05:14.720');
 
-    await E2eTestUtils.applyStateToHierarchyOptions(viewerSelector, true);
+    await applyStateToHierarchyOptions(viewerSelector, true);
     await checkHierarchy();
 
-    await E2eTestUtils.selectItemInHierarchy(
+    await selectItemInHierarchy(
       viewerSelector,
       'com.google.android.apps.messaging/com.google.android.apps.messaging.ui.search.ZeroStateSearchActivity#786',
     );
@@ -71,25 +81,25 @@ describe('Viewer Input Method Service', () => {
   }
 
   async function checkProperties() {
-    await E2eTestUtils.checkItemInPropertiesTree(
+    await checkItemInPropertiesTree(
       viewerSelector,
       'damageRegion',
       'damageRegion:\nSkRegion((398, 42, 615, 1596))',
     );
 
-    await E2eTestUtils.checkItemInPropertiesTree(
+    await checkItemInPropertiesTree(
       viewerSelector,
       'color',
       'color:\n{empty}, alpha: 0.589',
     );
 
-    await E2eTestUtils.checkItemInPropertiesTree(
+    await checkItemInPropertiesTree(
       viewerSelector,
       'destinationFrame',
       'destinationFrame:\n(0, 0) - (2204, 1080)',
     );
 
-    await E2eTestUtils.checkItemInPropertiesTree(
+    await checkItemInPropertiesTree(
       viewerSelector,
       'layoutParamsFlags',
       'layoutParamsFlags:\nFLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS | FLAG_HARDWARE_ACCELERATED | FLAG_SPLIT_TOUCH | FLAG_LAYOUT_INSET_DECOR | FLAG_LAYOUT_IN_SCREEN | FLAG_NOT_TOUCH_MODAL',
diff --git a/tools/winscope/src/test/e2e/viewer_protolog_test.ts b/tools/winscope/src/test/e2e/viewer_protolog_test.ts
index 529a861c4..1d99416c4 100644
--- a/tools/winscope/src/test/e2e/viewer_protolog_test.ts
+++ b/tools/winscope/src/test/e2e/viewer_protolog_test.ts
@@ -15,38 +15,44 @@
  */
 
 import {browser} from 'protractor';
-import {E2eTestUtils} from './utils';
+import {
+  checkFinalRealTimestamp,
+  checkInitialRealTimestamp,
+  checkScrollPresent,
+  checkSelectFilter,
+  checkTimelineTraceSelector,
+  checkTotalScrollEntries,
+  loadTraceAndCheckViewer,
+  setTimeouts,
+  updateInputField,
+  WINSCOPE_URL,
+} from './utils';
 
 describe('Viewer Protolog', () => {
   const viewerSelector = 'viewer-protolog';
   const totalEntries = 7295;
 
   beforeEach(async () => {
-    jasmine.DEFAULT_TIMEOUT_INTERVAL = 20000;
-    await E2eTestUtils.beforeEach(1000);
-    await browser.get(E2eTestUtils.WINSCOPE_URL);
+    await setTimeouts(1000);
+    await browser.get(WINSCOPE_URL);
   });
 
   it('processes trace from zip and navigates correctly', async () => {
-    await E2eTestUtils.loadTraceAndCheckViewer(
-      'traces/deployment_full_trace_phone.zip',
+    await loadTraceAndCheckViewer(
+      'archives/deployment_full_trace_phone.zip',
       'ProtoLog',
       viewerSelector,
     );
-    await E2eTestUtils.checkScrollPresent(viewerSelector);
-    await E2eTestUtils.checkTotalScrollEntries(
-      viewerSelector,
-      totalEntries,
-      true,
-    );
-    await E2eTestUtils.checkTimelineTraceSelector({
+    await checkScrollPresent(viewerSelector);
+    await checkTotalScrollEntries(viewerSelector, totalEntries, true);
+    await checkTimelineTraceSelector({
       icon: 'notes',
       color: 'rgba(52, 168, 83, 1)',
     });
-    await E2eTestUtils.checkFinalRealTimestamp('2022-11-21, 18:05:18.259');
-    await E2eTestUtils.checkInitialRealTimestamp('2022-11-21, 18:05:09.777');
+    await checkFinalRealTimestamp('2022-11-21, 18:05:18.259');
+    await checkInitialRealTimestamp('2022-11-21, 18:05:09.777');
 
-    await E2eTestUtils.checkSelectFilter(
+    await checkSelectFilter(
       viewerSelector,
       '.source-file',
       ['com/android/server/wm/ActivityStarter.java'],
@@ -54,7 +60,7 @@ describe('Viewer Protolog', () => {
       totalEntries,
     );
 
-    await E2eTestUtils.checkSelectFilter(
+    await checkSelectFilter(
       viewerSelector,
       '.source-file',
       [
@@ -66,11 +72,11 @@ describe('Viewer Protolog', () => {
     );
 
     await filterByText('FREEZE');
-    await E2eTestUtils.checkTotalScrollEntries(viewerSelector, 4);
+    await checkTotalScrollEntries(viewerSelector, 4);
   });
 
   async function filterByText(filterString: string) {
-    await E2eTestUtils.updateInputField(
+    await updateInputField(
       `${viewerSelector} .headers .text`,
       'Search text',
       filterString,
diff --git a/tools/winscope/src/test/e2e/viewer_screen_recording_test.ts b/tools/winscope/src/test/e2e/viewer_screen_recording_test.ts
index f4aada604..bc3dd177e 100644
--- a/tools/winscope/src/test/e2e/viewer_screen_recording_test.ts
+++ b/tools/winscope/src/test/e2e/viewer_screen_recording_test.ts
@@ -14,22 +14,28 @@
  * limitations under the License.
  */
 import {browser, by, element} from 'protractor';
-import {E2eTestUtils} from './utils';
+import {
+  clickViewTracesButton,
+  closeSnackBar,
+  setTimeouts,
+  uploadFixture,
+  WINSCOPE_URL,
+} from './utils';
 
 describe('Viewer ScreenRecording', () => {
   const viewerSelector = 'viewer-media-based';
 
   beforeEach(async () => {
-    await E2eTestUtils.beforeEach(1000);
-    await browser.get(E2eTestUtils.WINSCOPE_URL);
+    await setTimeouts(1000);
+    await browser.get(WINSCOPE_URL);
   });
 
   it('processes trace and renders view', async () => {
-    await E2eTestUtils.uploadFixture(
+    await uploadFixture(
       'traces/elapsed_and_real_timestamp/screen_recording_metadata_v2.mp4',
     );
-    await E2eTestUtils.closeSnackBar();
-    await E2eTestUtils.clickViewTracesButton();
+    await closeSnackBar();
+    await clickViewTracesButton();
 
     const viewer = element(by.css(viewerSelector));
     expect(await viewer.isPresent()).toBeTruthy();
@@ -41,12 +47,12 @@ describe('Viewer ScreenRecording', () => {
   });
 
   it('processes files and renders view with multiple recordings', async () => {
-    await E2eTestUtils.uploadFixture(
+    await uploadFixture(
       'traces/elapsed_and_real_timestamp/screen_recording_metadata_v2.mp4',
       'traces/elapsed_and_real_timestamp/screen_recording_metadata_v2.mp4',
     );
-    await E2eTestUtils.closeSnackBar();
-    await E2eTestUtils.clickViewTracesButton();
+    await closeSnackBar();
+    await clickViewTracesButton();
 
     const viewer = element(by.css(viewerSelector));
     expect(await viewer.isPresent()).toBeTruthy();
diff --git a/tools/winscope/src/test/e2e/viewer_screenshot_test.ts b/tools/winscope/src/test/e2e/viewer_screenshot_test.ts
index 8084a48b9..a1df205dd 100644
--- a/tools/winscope/src/test/e2e/viewer_screenshot_test.ts
+++ b/tools/winscope/src/test/e2e/viewer_screenshot_test.ts
@@ -14,20 +14,26 @@
  * limitations under the License.
  */
 import {browser, by, element} from 'protractor';
-import {E2eTestUtils} from './utils';
+import {
+  clickViewTracesButton,
+  closeSnackBar,
+  setTimeouts,
+  uploadFixture,
+  WINSCOPE_URL,
+} from './utils';
 
 describe('Viewer Screenshot', () => {
   const viewerSelector = 'viewer-media-based';
 
   beforeEach(async () => {
-    await E2eTestUtils.beforeEach(1000);
-    await browser.get(E2eTestUtils.WINSCOPE_URL);
+    await setTimeouts(1000);
+    await browser.get(WINSCOPE_URL);
   });
 
   it('processes file and renders view', async () => {
-    await E2eTestUtils.uploadFixture('traces/screenshot.png');
-    await E2eTestUtils.closeSnackBar();
-    await E2eTestUtils.clickViewTracesButton();
+    await uploadFixture('traces/screenshot/screenshot.png');
+    await closeSnackBar();
+    await clickViewTracesButton();
 
     const viewer = element(by.css(viewerSelector));
     expect(await viewer.isPresent()).toBeTruthy();
@@ -38,12 +44,12 @@ describe('Viewer Screenshot', () => {
   });
 
   it('processes files and renders view with multiple screenshots', async () => {
-    await E2eTestUtils.uploadFixture(
-      'traces/screenshot.png',
-      'traces/screenshot_2.png',
+    await uploadFixture(
+      'traces/screenshot/screenshot.png',
+      'traces/screenshot/screenshot_2.png',
     );
-    await E2eTestUtils.closeSnackBar();
-    await E2eTestUtils.clickViewTracesButton();
+    await closeSnackBar();
+    await clickViewTracesButton();
 
     const viewer = element(by.css(viewerSelector));
     expect(await viewer.isPresent()).toBeTruthy();
diff --git a/tools/winscope/src/test/e2e/viewer_surface_flinger_test.ts b/tools/winscope/src/test/e2e/viewer_surface_flinger_test.ts
index dbd25f674..30ac9bb5e 100644
--- a/tools/winscope/src/test/e2e/viewer_surface_flinger_test.ts
+++ b/tools/winscope/src/test/e2e/viewer_surface_flinger_test.ts
@@ -15,34 +15,40 @@
  */
 
 import {browser, by, element} from 'protractor';
-import {E2eTestUtils} from './utils';
+import {
+  changeRealTimestampInWinscope,
+  checkFinalRealTimestamp,
+  checkInitialRealTimestamp,
+  checkTimelineTraceSelector,
+  checkWinscopeRealTimestamp,
+  filterHierarchy,
+  loadTraceAndCheckViewer,
+  selectItemInHierarchy,
+  setTimeouts,
+  WINSCOPE_URL,
+} from './utils';
 
 describe('Viewer Surface Flinger', () => {
   const viewerSelector = 'viewer-surface-flinger';
 
   beforeEach(async () => {
-    await E2eTestUtils.beforeEach(1000);
-    await browser.get(E2eTestUtils.WINSCOPE_URL);
+    await setTimeouts(1000);
+    await browser.get(WINSCOPE_URL);
   });
 
   it('processes trace from zip and navigates correctly', async () => {
     await loadTraces();
-    await E2eTestUtils.checkTimelineTraceSelector({
+    await checkTimelineTraceSelector({
       icon: 'layers',
       color: 'rgba(78, 205, 230, 1)',
     });
-    await E2eTestUtils.checkInitialRealTimestamp('2022-11-21, 18:05:09.780');
-    await E2eTestUtils.checkFinalRealTimestamp('2022-11-21, 18:05:18.607');
+    await checkInitialRealTimestamp('2022-11-21, 18:05:09.780');
+    await checkFinalRealTimestamp('2022-11-21, 18:05:18.607');
 
-    await E2eTestUtils.changeRealTimestampInWinscope(
-      '2022-11-21, 18:05:11.314',
-    );
-    await E2eTestUtils.checkWinscopeRealTimestamp('18:05:11.314');
-    await E2eTestUtils.filterHierarchy(
-      viewerSelector,
-      'ConversationListActivity#632',
-    );
-    await E2eTestUtils.selectItemInHierarchy(
+    await changeRealTimestampInWinscope('2022-11-21, 18:05:11.314');
+    await checkWinscopeRealTimestamp('18:05:11.314');
+    await filterHierarchy(viewerSelector, 'ConversationListActivity#632');
+    await selectItemInHierarchy(
       viewerSelector,
       'com.google.android.apps.messaging/com.google.android.apps.messaging.ui.ConversationListActivity#632',
     );
@@ -50,8 +56,8 @@ describe('Viewer Surface Flinger', () => {
   });
 
   async function loadTraces() {
-    await E2eTestUtils.loadTraceAndCheckViewer(
-      'traces/deployment_full_trace_phone.zip',
+    await loadTraceAndCheckViewer(
+      'archives/deployment_full_trace_phone.zip',
       'Surface Flinger',
       viewerSelector,
     );
diff --git a/tools/winscope/src/test/e2e/viewer_transactions_test.ts b/tools/winscope/src/test/e2e/viewer_transactions_test.ts
index ef9346d90..1dfd876c3 100644
--- a/tools/winscope/src/test/e2e/viewer_transactions_test.ts
+++ b/tools/winscope/src/test/e2e/viewer_transactions_test.ts
@@ -15,57 +15,57 @@
  */
 
 import {browser, by, element} from 'protractor';
-import {E2eTestUtils} from './utils';
+import {
+  changeRealTimestampInWinscope,
+  checkFinalRealTimestamp,
+  checkInitialRealTimestamp,
+  checkItemInPropertiesTree,
+  checkScrollPresent,
+  checkSelectFilter,
+  checkTimelineTraceSelector,
+  checkTotalScrollEntries,
+  checkWinscopeRealTimestamp,
+  loadTraceAndCheckViewer,
+  setTimeouts,
+  WINSCOPE_URL,
+} from './utils';
 
 describe('Viewer Transactions', () => {
   const viewerSelector = 'viewer-transactions';
   const totalEntries = 9534;
 
   beforeEach(async () => {
-    jasmine.DEFAULT_TIMEOUT_INTERVAL = 20000;
-    await E2eTestUtils.beforeEach(2000);
-    await browser.get(E2eTestUtils.WINSCOPE_URL);
+    await setTimeouts(2000);
+    await browser.get(WINSCOPE_URL);
   });
 
   it('processes trace from zip and navigates correctly', async () => {
-    await E2eTestUtils.loadTraceAndCheckViewer(
-      'traces/deployment_full_trace_phone.zip',
+    await loadTraceAndCheckViewer(
+      'archives/deployment_full_trace_phone.zip',
       'Transactions',
       viewerSelector,
     );
-    await E2eTestUtils.checkScrollPresent(viewerSelector);
-    await E2eTestUtils.checkTotalScrollEntries(
-      viewerSelector,
-      totalEntries,
-      true,
-    );
-    await E2eTestUtils.checkTimelineTraceSelector({
+    await checkScrollPresent(viewerSelector);
+    await checkTotalScrollEntries(viewerSelector, totalEntries, true);
+    await checkTimelineTraceSelector({
       icon: 'show_chart',
       color: 'rgba(13, 101, 45, 1)',
     });
-    await E2eTestUtils.checkFinalRealTimestamp('2022-11-21, 18:05:19.592');
-    await E2eTestUtils.checkInitialRealTimestamp('2022-11-21, 11:36:19.513');
+    await checkFinalRealTimestamp('2022-11-21, 18:05:19.592');
+    await checkInitialRealTimestamp('2022-11-21, 11:36:19.513');
 
-    await E2eTestUtils.changeRealTimestampInWinscope(
-      '2022-11-21, 18:05:17.505',
-    );
-    await E2eTestUtils.checkWinscopeRealTimestamp('18:05:17.505');
+    await changeRealTimestampInWinscope('2022-11-21, 18:05:17.505');
+    await checkWinscopeRealTimestamp('18:05:17.505');
     await checkSelectedEntry();
-    await E2eTestUtils.checkSelectFilter(
-      viewerSelector,
-      '.pid',
-      ['6914'],
-      2,
-      totalEntries,
-    );
-    await E2eTestUtils.checkSelectFilter(
+    await checkSelectFilter(viewerSelector, '.pid', ['6914'], 2, totalEntries);
+    await checkSelectFilter(
       viewerSelector,
       '.uid',
       ['10161'],
       16,
       totalEntries,
     );
-    await E2eTestUtils.checkSelectFilter(
+    await checkSelectFilter(
       viewerSelector,
       '.flags',
       ['eBackgroundBlurRadiusChanged'],
@@ -103,12 +103,12 @@ describe('Viewer Transactions', () => {
     const what = selectedEntry.element(by.css('.flags'));
     expect(await what.getText()).toEqual(whatString);
 
-    await E2eTestUtils.checkItemInPropertiesTree(
+    await checkItemInPropertiesTree(
       viewerSelector,
       'what',
       'what:\n' + whatString,
     );
-    await E2eTestUtils.checkItemInPropertiesTree(
+    await checkItemInPropertiesTree(
       viewerSelector,
       'color',
       'color:\n(0.106, 0.106, 0.106)',
diff --git a/tools/winscope/src/test/e2e/viewer_transitions_test.ts b/tools/winscope/src/test/e2e/viewer_transitions_test.ts
index 892d818e7..b646b2bd8 100644
--- a/tools/winscope/src/test/e2e/viewer_transitions_test.ts
+++ b/tools/winscope/src/test/e2e/viewer_transitions_test.ts
@@ -14,21 +14,27 @@
  * limitations under the License.
  */
 import {browser, by, element} from 'protractor';
-import {E2eTestUtils} from './utils';
+import {
+  clickViewTracesButton,
+  closeSnackBar,
+  setTimeouts,
+  uploadFixture,
+  WINSCOPE_URL,
+} from './utils';
 
 describe('Viewer Transitions', () => {
   beforeEach(async () => {
-    await E2eTestUtils.beforeEach(1000);
-    await browser.get(E2eTestUtils.WINSCOPE_URL);
+    await setTimeouts(1000);
+    await browser.get(WINSCOPE_URL);
   });
 
   it('processes trace and renders view', async () => {
-    await E2eTestUtils.uploadFixture(
+    await uploadFixture(
       'traces/elapsed_and_real_timestamp/wm_transition_trace.pb',
       'traces/elapsed_and_real_timestamp/shell_transition_trace.pb',
     );
-    await E2eTestUtils.closeSnackBar();
-    await E2eTestUtils.clickViewTracesButton();
+    await closeSnackBar();
+    await clickViewTracesButton();
 
     const isViewerRendered = await element(
       by.css('viewer-transitions'),
diff --git a/tools/winscope/src/test/e2e/viewer_window_manager_test.ts b/tools/winscope/src/test/e2e/viewer_window_manager_test.ts
index 267e4660d..030abae57 100644
--- a/tools/winscope/src/test/e2e/viewer_window_manager_test.ts
+++ b/tools/winscope/src/test/e2e/viewer_window_manager_test.ts
@@ -15,71 +15,80 @@
  */
 
 import {browser} from 'protractor';
-import {E2eTestUtils} from './utils';
+import {
+  changeRealTimestampInWinscope,
+  checkFinalRealTimestamp,
+  checkInitialRealTimestamp,
+  checkItemInPropertiesTree,
+  checkRectLabel,
+  checkTimelineTraceSelector,
+  checkWinscopeRealTimestamp,
+  filterHierarchy,
+  loadTraceAndCheckViewer,
+  selectItemInHierarchy,
+  setTimeouts,
+  WINSCOPE_URL,
+} from './utils';
 
 describe('Viewer Window Manager', () => {
   const viewerSelector = 'viewer-window-manager';
 
   beforeEach(async () => {
-    await E2eTestUtils.beforeEach(1000);
-    await browser.get(E2eTestUtils.WINSCOPE_URL);
+    await setTimeouts(1000);
+    await browser.get(WINSCOPE_URL);
   });
 
   it('processes trace from zip and navigates correctly', async () => {
-    await E2eTestUtils.loadTraceAndCheckViewer(
-      'traces/deployment_full_trace_phone.zip',
+    await loadTraceAndCheckViewer(
+      'archives/deployment_full_trace_phone.zip',
       'Window Manager',
       viewerSelector,
     );
-    await E2eTestUtils.checkTimelineTraceSelector({
+    await checkTimelineTraceSelector({
       icon: 'web',
       color: 'rgba(175, 92, 247, 1)',
     });
-    await E2eTestUtils.checkInitialRealTimestamp('2022-11-21, 18:05:09.753');
-    await E2eTestUtils.checkFinalRealTimestamp('2022-11-21, 18:05:18.269');
+    await checkInitialRealTimestamp('2022-11-21, 18:05:09.753');
+    await checkFinalRealTimestamp('2022-11-21, 18:05:18.269');
 
-    await E2eTestUtils.changeRealTimestampInWinscope(
-      '2022-11-21, 18:05:09.753',
-    );
-    await E2eTestUtils.checkWinscopeRealTimestamp('18:05:09.753');
-    await E2eTestUtils.selectItemInHierarchy(viewerSelector, 'root');
+    await changeRealTimestampInWinscope('2022-11-21, 18:05:09.753');
+    await checkWinscopeRealTimestamp('18:05:09.753');
+    await selectItemInHierarchy(viewerSelector, 'root');
     await checkRootProperties();
 
-    await E2eTestUtils.changeRealTimestampInWinscope(
-      '2022-11-21, 18:05:14.544',
-    );
-    await E2eTestUtils.checkWinscopeRealTimestamp('18:05:14.544');
-    await E2eTestUtils.filterHierarchy(viewerSelector, 'InputMethod');
-    await E2eTestUtils.selectItemInHierarchy(viewerSelector, 'InputMethod');
+    await changeRealTimestampInWinscope('2022-11-21, 18:05:14.544');
+    await checkWinscopeRealTimestamp('18:05:14.544');
+    await filterHierarchy(viewerSelector, 'InputMethod');
+    await selectItemInHierarchy(viewerSelector, 'InputMethod');
     await checkInputMethodWindowProperties();
   });
 
   async function checkRootProperties() {
-    await E2eTestUtils.checkItemInPropertiesTree(
+    await checkItemInPropertiesTree(
       viewerSelector,
       'focusedApp',
       'focusedApp:\ncom.google.android.apps.messaging/.ui.ConversationListActivity',
     );
-    await E2eTestUtils.checkRectLabel(
+    await checkRectLabel(
       viewerSelector,
       'com.google.android.apps.messaging/com.google.android.apps.messaging.ui.ConversationListActivity',
     );
   }
 
   async function checkInputMethodWindowProperties() {
-    await E2eTestUtils.checkItemInPropertiesTree(
+    await checkItemInPropertiesTree(
       viewerSelector,
       'fitInsetsTypes',
       'fitInsetsTypes:\nNAVIGATION_BARS | STATUS_BARS',
     );
 
-    await E2eTestUtils.checkItemInPropertiesTree(
+    await checkItemInPropertiesTree(
       viewerSelector,
       'flags',
       'flags:\nFLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS | FLAG_HARDWARE_ACCELERATED | FLAG_SPLIT_TOUCH | FLAG_LAYOUT_IN_SCREEN | FLAG_NOT_FOCUSABLE',
     );
 
-    await E2eTestUtils.checkItemInPropertiesTree(
+    await checkItemInPropertiesTree(
       viewerSelector,
       'compatFrame',
       'compatFrame:\n(136, 74) - (2340, 1080)',
diff --git a/tools/winscope/src/test/e2e/winscope_test.ts b/tools/winscope/src/test/e2e/winscope_test.ts
index bb0d73d56..e0886ca60 100644
--- a/tools/winscope/src/test/e2e/winscope_test.ts
+++ b/tools/winscope/src/test/e2e/winscope_test.ts
@@ -14,12 +14,12 @@
  * limitations under the License.
  */
 import {browser, by, element} from 'protractor';
-import {E2eTestUtils} from './utils';
+import {checkServerIsUp, WINSCOPE_URL} from './utils';
 
 describe('winscope', () => {
   beforeAll(async () => {
-    await E2eTestUtils.checkServerIsUp('Winscope', E2eTestUtils.WINSCOPE_URL);
-    await browser.get(E2eTestUtils.WINSCOPE_URL);
+    await checkServerIsUp('Winscope', WINSCOPE_URL);
+    await browser.get(WINSCOPE_URL);
   });
 
   it('has title', async () => {
diff --git a/tools/winscope/src/test/fixtures/traces/WindowManager.pb.gz b/tools/winscope/src/test/fixtures/archives/WindowManager.pb.gz
similarity index 100%
rename from tools/winscope/src/test/fixtures/traces/WindowManager.pb.gz
rename to tools/winscope/src/test/fixtures/archives/WindowManager.pb.gz
diff --git a/tools/winscope/src/test/fixtures/traces/WindowManager.zip.gz b/tools/winscope/src/test/fixtures/archives/WindowManager.zip.gz
similarity index 100%
rename from tools/winscope/src/test/fixtures/traces/WindowManager.zip.gz
rename to tools/winscope/src/test/fixtures/archives/WindowManager.zip.gz
diff --git a/tools/winscope/src/test/fixtures/traces/deployment_full_trace_phone.zip b/tools/winscope/src/test/fixtures/archives/deployment_full_trace_phone.zip
similarity index 100%
rename from tools/winscope/src/test/fixtures/traces/deployment_full_trace_phone.zip
rename to tools/winscope/src/test/fixtures/archives/deployment_full_trace_phone.zip
diff --git a/tools/winscope/src/test/fixtures/traces/recursive_winscope.zip b/tools/winscope/src/test/fixtures/archives/recursive_winscope.zip
similarity index 100%
rename from tools/winscope/src/test/fixtures/traces/recursive_winscope.zip
rename to tools/winscope/src/test/fixtures/archives/recursive_winscope.zip
diff --git a/tools/winscope/src/test/fixtures/traces/winscope.zip b/tools/winscope/src/test/fixtures/archives/winscope.zip
similarity index 100%
rename from tools/winscope/src/test/fixtures/traces/winscope.zip
rename to tools/winscope/src/test/fixtures/archives/winscope.zip
diff --git a/tools/winscope/src/test/fixtures/bugreports/bugreport_no_trace.zip b/tools/winscope/src/test/fixtures/bugreports/bugreport_no_trace.zip
new file mode 100644
index 000000000..02d394a32
Binary files /dev/null and b/tools/winscope/src/test/fixtures/bugreports/bugreport_no_trace.zip differ
diff --git a/tools/winscope/src/test/fixtures/corrupted_archive.zip b/tools/winscope/src/test/fixtures/invalid_files/corrupted_archive.zip
similarity index 100%
rename from tools/winscope/src/test/fixtures/corrupted_archive.zip
rename to tools/winscope/src/test/fixtures/invalid_files/corrupted_archive.zip
diff --git a/tools/winscope/src/test/fixtures/invalid_files/empty.pb b/tools/winscope/src/test/fixtures/invalid_files/empty.pb
new file mode 100644
index 000000000..e69de29bb
diff --git a/tools/winscope/src/test/fixtures/traces/perfetto/invalid_protolog.perfetto-trace b/tools/winscope/src/test/fixtures/invalid_files/invalid_protolog.perfetto-trace
similarity index 100%
rename from tools/winscope/src/test/fixtures/traces/perfetto/invalid_protolog.perfetto-trace
rename to tools/winscope/src/test/fixtures/invalid_files/invalid_protolog.perfetto-trace
diff --git a/tools/winscope/src/test/fixtures/traces/no_entries_InputMethodClients.pb b/tools/winscope/src/test/fixtures/invalid_files/no_entries_InputMethodClients.pb
similarity index 100%
rename from tools/winscope/src/test/fixtures/traces/no_entries_InputMethodClients.pb
rename to tools/winscope/src/test/fixtures/invalid_files/no_entries_InputMethodClients.pb
diff --git a/tools/winscope/src/test/fixtures/traces/no_entries_view_capture.vc b/tools/winscope/src/test/fixtures/invalid_files/no_entries_view_capture.vc
similarity index 100%
rename from tools/winscope/src/test/fixtures/traces/no_entries_view_capture.vc
rename to tools/winscope/src/test/fixtures/invalid_files/no_entries_view_capture.vc
diff --git a/tools/winscope/src/test/fixtures/traces/perfetto/no_winscope_traces.perfetto-trace b/tools/winscope/src/test/fixtures/invalid_files/no_winscope_traces.perfetto-trace
similarity index 100%
rename from tools/winscope/src/test/fixtures/traces/perfetto/no_winscope_traces.perfetto-trace
rename to tools/winscope/src/test/fixtures/invalid_files/no_winscope_traces.perfetto-trace
diff --git a/tools/winscope/src/test/fixtures/winscope_homepage.jpg b/tools/winscope/src/test/fixtures/invalid_files/winscope_homepage.jpg
similarity index 100%
rename from tools/winscope/src/test/fixtures/winscope_homepage.jpg
rename to tools/winscope/src/test/fixtures/invalid_files/winscope_homepage.jpg
diff --git a/tools/winscope/src/test/fixtures/traces/SFtrace(with_illegal_characters).pb b/tools/winscope/src/test/fixtures/traces/elapsed_and_real_timestamp/SFtrace(with_illegal_characters).pb
similarity index 100%
rename from tools/winscope/src/test/fixtures/traces/SFtrace(with_illegal_characters).pb
rename to tools/winscope/src/test/fixtures/traces/elapsed_and_real_timestamp/SFtrace(with_illegal_characters).pb
diff --git a/tools/winscope/src/test/fixtures/traces/eventlog.winscope b/tools/winscope/src/test/fixtures/traces/elapsed_and_real_timestamp/eventlog.winscope
similarity index 100%
rename from tools/winscope/src/test/fixtures/traces/eventlog.winscope
rename to tools/winscope/src/test/fixtures/traces/elapsed_and_real_timestamp/eventlog.winscope
diff --git a/tools/winscope/src/test/fixtures/traces/eventlog_no_cujs.winscope b/tools/winscope/src/test/fixtures/traces/elapsed_and_real_timestamp/eventlog_no_cujs.winscope
similarity index 100%
rename from tools/winscope/src/test/fixtures/traces/eventlog_no_cujs.winscope
rename to tools/winscope/src/test/fixtures/traces/elapsed_and_real_timestamp/eventlog_no_cujs.winscope
diff --git a/tools/winscope/src/test/fixtures/traces/eventlog_timestamps_not_monotonically_increasing.winscope b/tools/winscope/src/test/fixtures/traces/elapsed_and_real_timestamp/eventlog_timestamps_not_monotonically_increasing.winscope
similarity index 100%
rename from tools/winscope/src/test/fixtures/traces/eventlog_timestamps_not_monotonically_increasing.winscope
rename to tools/winscope/src/test/fixtures/traces/elapsed_and_real_timestamp/eventlog_timestamps_not_monotonically_increasing.winscope
diff --git a/tools/winscope/src/test/fixtures/traces/dump_WindowManager.pb b/tools/winscope/src/test/fixtures/traces/elapsed_timestamp/dump_WindowManager.pb
similarity index 100%
rename from tools/winscope/src/test/fixtures/traces/dump_WindowManager.pb
rename to tools/winscope/src/test/fixtures/traces/elapsed_timestamp/dump_WindowManager.pb
diff --git a/tools/winscope/src/test/fixtures/traces/perfetto/transactions_trace.perfetto-trace b/tools/winscope/src/test/fixtures/traces/perfetto/transactions_trace.perfetto-trace
index fb454043a..187bf36d0 100644
Binary files a/tools/winscope/src/test/fixtures/traces/perfetto/transactions_trace.perfetto-trace and b/tools/winscope/src/test/fixtures/traces/perfetto/transactions_trace.perfetto-trace differ
diff --git a/tools/winscope/src/test/fixtures/traces/screenshot.png b/tools/winscope/src/test/fixtures/traces/screenshot/screenshot.png
similarity index 100%
rename from tools/winscope/src/test/fixtures/traces/screenshot.png
rename to tools/winscope/src/test/fixtures/traces/screenshot/screenshot.png
diff --git a/tools/winscope/src/test/fixtures/traces/screenshot_2.png b/tools/winscope/src/test/fixtures/traces/screenshot/screenshot_2.png
similarity index 100%
rename from tools/winscope/src/test/fixtures/traces/screenshot_2.png
rename to tools/winscope/src/test/fixtures/traces/screenshot/screenshot_2.png
diff --git a/tools/winscope/src/test/unit/dom_test_utils.ts b/tools/winscope/src/test/unit/dom_test_utils.ts
new file mode 100644
index 000000000..c327813ef
--- /dev/null
+++ b/tools/winscope/src/test/unit/dom_test_utils.ts
@@ -0,0 +1,367 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import {Type} from '@angular/core';
+import {ComponentFixture, flush} from '@angular/core/testing';
+import {By} from '@angular/platform-browser';
+import {assertDefined} from 'common/assert_utils';
+import {KeyboardEventKey, KeyboardEventKeyCode} from 'common/dom_utils';
+
+export class DOMTestHelper<T> {
+  constructor(
+    private fixture: ComponentFixture<T>,
+    private root: HTMLElement,
+  ) {}
+
+  detectChanges() {
+    this.fixture.detectChanges();
+  }
+
+  async whenStable() {
+    await this.fixture.whenStable();
+  }
+
+  async whenRenderingDone() {
+    await this.fixture.whenRenderingDone();
+  }
+
+  async detectChangesAndWaitStable() {
+    this.detectChanges();
+    await this.whenStable();
+  }
+
+  async detectChangesAndRenderingDone() {
+    this.detectChanges();
+    await this.fixture.whenRenderingDone();
+  }
+
+  find(selector: string): DOMTestHelper<T> | undefined {
+    const element = this.root.querySelector<HTMLElement>(selector);
+    return element ? new DOMTestHelper(this.fixture, element) : undefined;
+  }
+
+  findAll(selector: string): Array<DOMTestHelper<T>> {
+    const helpers: Array<DOMTestHelper<T>> = [];
+    this.root.querySelectorAll<HTMLElement>(selector).forEach((el) => {
+      helpers.push(new DOMTestHelper(this.fixture, el));
+    });
+    return helpers;
+  }
+
+  findByDirective<T>(component: Type<T>): T | undefined {
+    return (
+      this.fixture.debugElement.query(By.directive(component))
+        ?.componentInstance ?? undefined
+    );
+  }
+
+  findInDocument(selector: string): DOMTestHelper<T> | undefined {
+    const element = document.querySelector<HTMLElement>(selector);
+    return element ? new DOMTestHelper(this.fixture, element) : undefined;
+  }
+
+  get(selector: string): DOMTestHelper<T> {
+    return assertDefined(this.find(selector));
+  }
+
+  getInDocument(selector: string): DOMTestHelper<T> {
+    return assertDefined(this.findInDocument(selector));
+  }
+
+  click() {
+    this.root.click();
+    this.fixture.detectChanges();
+  }
+
+  doubleClick() {
+    this.root.dispatchEvent(new MouseEvent('dblclick'));
+    this.fixture.detectChanges();
+  }
+
+  findAndClick(selector: string): DOMTestHelper<T> {
+    const element = this.get(selector);
+    element.click();
+    return element;
+  }
+
+  findAndClickByIndex(selector: string, index: number): DOMTestHelper<T> {
+    const element = this.findAll(selector)[index];
+    element.click();
+    return element;
+  }
+
+  findAndClickInDocument(selector: string): DOMTestHelper<T> {
+    const element = this.getInDocument(selector);
+    element.click();
+    return element;
+  }
+
+  async clickAndWaitStable(selector: string) {
+    const element = this.get(selector);
+    element.click();
+    await this.whenStable();
+  }
+
+  async clickByIndexAndWaitStable(selector: string, index: number) {
+    const element = this.findAll(selector)[index];
+    element.click();
+    await this.whenStable();
+  }
+
+  async clickLastAndWaitStable(selector: string) {
+    const elements = this.findAll(selector);
+    const element = elements[elements.length - 1];
+    element.click();
+    await this.whenStable();
+  }
+
+  findAndDispatchInput(field: string, value: string): DOMTestHelper<T> {
+    const input = this.get(field + ' input');
+    input.dispatchInput(value);
+    return input;
+  }
+
+  dispatchInput(value: string) {
+    if (
+      !(
+        this.root instanceof HTMLInputElement ||
+        this.root instanceof HTMLTextAreaElement
+      )
+    ) {
+      throw new Error('cannot dispatch input on node ' + this.root.nodeName);
+    }
+    this.root.value = value;
+    this.root.dispatchEvent(new Event('input'));
+    this.fixture.detectChanges();
+  }
+
+  isMatSelectOpen(): boolean {
+    return this.findInDocument('.mat-select-panel') !== undefined;
+  }
+
+  async openMatSelect(index = 0) {
+    const trigger = '.mat-select-trigger';
+    await this.clickByIndexAndWaitStable(trigger, index);
+  }
+
+  clickMatOption() {
+    const panel = this.getMatSelectPanel();
+    panel.findAndClick('mat-option');
+  }
+
+  getMatSelectPanel(): DOMTestHelper<T> {
+    return this.getInDocument('.mat-select-panel');
+  }
+
+  findMatTooltipPanel(): DOMTestHelper<T> | undefined {
+    return this.findInDocument('.mat-tooltip-panel');
+  }
+
+  getSnackBar(): DOMTestHelper<T> {
+    return this.getInDocument('snack-bar');
+  }
+
+  addEventListener(event: string, listener: (event: Event) => void) {
+    this.root.addEventListener(event, listener);
+  }
+
+  keydownEnter(shiftKey = false) {
+    const event = new KeyboardEvent('keydown', {
+      key: KeyboardEventKey.ENTER,
+      shiftKey,
+    });
+    this.dispatchEvent(event);
+  }
+
+  keydownEsc() {
+    this.keydownByKey(KeyboardEventKey.ESCAPE);
+  }
+
+  keydownSpace() {
+    const event = new KeyboardEvent('keydown', {
+      keyCode: KeyboardEventKeyCode.SPACE,
+    });
+    this.dispatchEvent(event);
+  }
+
+  keydownArrowLeft(toDocument = false) {
+    this.keydownByKey(KeyboardEventKey.ARROW_LEFT, toDocument);
+  }
+
+  keydownArrowRight(toDocument = false) {
+    this.keydownByKey(KeyboardEventKey.ARROW_RIGHT, toDocument);
+  }
+
+  keydownArrowUp(toDocument = false) {
+    this.keydownByKey(KeyboardEventKey.ARROW_UP, toDocument);
+  }
+
+  keydownArrowDown(toDocument = false) {
+    this.keydownByKey(KeyboardEventKey.ARROW_DOWN, toDocument);
+  }
+
+  private keydownByKey(key: string, toDocument = false) {
+    const event = new KeyboardEvent('keydown', {key});
+    toDocument
+      ? this.dispatchEventInDocument(event)
+      : this.dispatchEvent(event);
+  }
+
+  focusOut() {
+    this.dispatchEvent(new FocusEvent('focusout'));
+  }
+
+  dragElement(x: number, y: number) {
+    const {left, top} = this.root.getBoundingClientRect();
+    this.dispatchMouseEvent(this.root, 'mousedown', left, top, 0, 0);
+    this.dispatchMouseEvent(document, 'mousemove', left + 1, top + 0, 1, y);
+    this.dispatchMouseEvent(document, 'mousemove', left + x, top + y, x, y);
+    this.dispatchMouseEvent(document, 'mouseup', left + x, top + y, x, y);
+  }
+
+  dispatchEvent(event: Event) {
+    this.root.dispatchEvent(event);
+    this.detectChanges();
+  }
+
+  dispatchEventInDocument(event: Event) {
+    document.dispatchEvent(event);
+    this.detectChanges();
+  }
+
+  getHTMLElement<T extends HTMLElement>() {
+    return this.root as T;
+  }
+
+  getText(): string | undefined {
+    return this.root.textContent?.trim() ?? undefined;
+  }
+
+  checkText(value: string) {
+    expect(this.root.textContent?.trim()).toContain(value);
+  }
+
+  checkTextExact(value: string) {
+    expect(this.root.textContent?.trim()).toEqual(value);
+  }
+
+  checkInnerHTML(value: string, isPresent = true) {
+    isPresent
+      ? expect(this.root.innerHTML).toContain(value)
+      : expect(this.root.innerHTML).not.toContain(value);
+  }
+
+  checkClassName(value: string, isPresent = true) {
+    isPresent
+      ? expect(this.root.className).toContain(value)
+      : expect(this.root.className).not.toContain(value);
+  }
+
+  checkClassNameExact(value: string, isPresent = true) {
+    isPresent
+      ? expect(this.root.className).toEqual(value)
+      : expect(this.root.className).not.toEqual(value);
+  }
+
+  checkDisabled(value: boolean) {
+    if ('disabled' in this.root) {
+      return (this.root as any).disabled === value;
+    }
+    throw new Error('disabled not present on node ' + this.root.nodeName);
+  }
+
+  checkValue(value: string) {
+    if ('value' in this.root) {
+      return (this.root as any).value === value;
+    }
+    throw new Error('value not present on node ' + this.root.nodeName);
+  }
+
+  updateValue(value: string) {
+    (this.root as any).value = value;
+  }
+
+  checkSectionCollapseAndExpand(selector: string, sectionTitle: string) {
+    const section = this.get(selector);
+    section
+      .get('collapsible-section-title .mat-title')
+      .checkTextExact(sectionTitle);
+    section.findAndClick('collapsible-section-title button');
+    section.checkClassName('collapsed');
+    const collapsedSection = this.get('collapsed-sections .collapsed-section');
+    collapsedSection.checkTextExact(sectionTitle + '  arrow_right');
+    collapsedSection.click();
+    this.checkNoCollapsedSectionButtons();
+  }
+
+  checkNoCollapsedSectionButtons() {
+    const collapsedSections = this.get('collapsed-sections');
+    expect(collapsedSections.find('.collapsed-section')).toBeUndefined();
+  }
+
+  async checkTooltip(text: string | undefined) {
+    this.dispatchEvent(new Event('mouseenter'));
+    const panel = this.findMatTooltipPanel();
+    if (text !== undefined) {
+      assertDefined(panel).checkText(text);
+    } else {
+      expect(panel).toBeUndefined();
+    }
+    this.dispatchEvent(new Event('mouseleave'));
+    await this.whenStable();
+  }
+
+  private dispatchMouseEvent(
+    source: Node,
+    type: string,
+    screenX: number,
+    screenY: number,
+    clientX: number,
+    clientY: number,
+  ) {
+    const event = document.createEvent('MouseEvent');
+    event.initMouseEvent(
+      type,
+      true /* canBubble */,
+      false /* cancelable */,
+      window /* view */,
+      0 /* detail */,
+      screenX /* screenX */,
+      screenY /* screenY */,
+      clientX /* clientX */,
+      clientY /* clientY */,
+      false /* ctrlKey */,
+      false /* altKey */,
+      false /* shiftKey */,
+      false /* metaKey */,
+      0 /* button */,
+      null /* relatedTarget */,
+    );
+    Object.defineProperty(event, 'buttons', {get: () => 1});
+    source.dispatchEvent(event);
+    this.detectChanges();
+    flush();
+  }
+}
+
+export async function checkTooltips<T>(
+  elements: Array<DOMTestHelper<T>>,
+  expTooltips: Array<string | undefined>,
+) {
+  for (const [index, el] of elements.entries()) {
+    await el.checkTooltip(expTooltips[index]);
+  }
+}
diff --git a/tools/winscope/src/test/unit/fixture_utils.ts b/tools/winscope/src/test/unit/fixture_utils.ts
index 1e67d1c12..34f2f8b6c 100644
--- a/tools/winscope/src/test/unit/fixture_utils.ts
+++ b/tools/winscope/src/test/unit/fixture_utils.ts
@@ -14,16 +14,28 @@
  * limitations under the License.
  */
 
+import {assertDefined, assertTrue} from 'common/assert_utils';
+import {getTimestampConverter} from 'common/time/test_utils';
+import {TimestampConverter} from 'common/time/timestamp_converter';
 import {getRootUrl} from 'common/url_utils';
+import {FileAndParser} from 'parsers/file_and_parser';
+import {ParserFactory as LegacyParserFactory} from 'parsers/legacy/parser_factory';
+import {LegacyToPerfettoConverter} from 'parsers/legacy_to_perfetto_converter';
+import {
+  getParserWithLatestRealToBootTimeOffset,
+  getParserWithLatestRealToMonotonicTimeOffset,
+} from 'parsers/parser_time_utils';
+import {ParserFactory as PerfettoParserFactory} from 'parsers/perfetto/parser_factory';
+import {TracesParserFactory} from 'parsers/traces/traces_parser_factory';
+import {Parser} from 'trace/parser';
+import {Trace} from 'trace/trace';
+import {Traces} from 'trace/traces';
+import {TraceFile} from 'trace/trace_file';
+import {TraceMetadata} from 'trace/trace_metadata';
+import {TraceEntryTypeMap, TraceType} from 'trace/trace_type';
+import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
+import {TraceBuilder} from './trace_builder';
 
-/**
- * Get a fixture file from the fixtures directory.
- *
- * @param srcFilename The name of the fixture file in the fixtures directory.
- * @param dstFilename The name of the file to save the fixture as. Defaults to
- *     the same name as the source file.
- * @return A promise that resolves to the File object.
- */
 export async function getFixtureFile(
   srcFilename: string,
   dstFilename: string = srcFilename,
@@ -35,3 +47,316 @@ export async function getFixtureFile(
   const file = new File([blob], dstFilename);
   return file;
 }
+
+export class LegacyParserProvider {
+  private filenames: string[] = [];
+  private timestampConverter = getTimestampConverter();
+  private initializeRealToElapsedTimeOffsetNs = true;
+  private metadata: TraceMetadata = {};
+  private convertToPerfetto = false;
+  private existingPerfettoFile: TraceFile | undefined;
+
+  addFilename(value: string) {
+    this.filenames.push(value);
+    return this;
+  }
+
+  setTimestampConverter(value: TimestampConverter) {
+    this.timestampConverter = value;
+    return this;
+  }
+
+  setInitializeRealToElapsedTimeOffsetNs(value: boolean) {
+    this.initializeRealToElapsedTimeOffsetNs = value;
+    return this;
+  }
+
+  setMetadata(value: TraceMetadata) {
+    this.metadata = value;
+    return this;
+  }
+
+  setConvertToPerfetto(value: boolean) {
+    this.convertToPerfetto = value;
+    return this;
+  }
+
+  setExistingPerfettoFile(value: TraceFile) {
+    this.existingPerfettoFile = value;
+    return this;
+  }
+
+  async getParser<T>(): Promise<Parser<T>> {
+    const parsers = await this.getParsers();
+
+    expect(parsers.length)
+      .withContext(
+        `Should have been able to create a parser for ${this.filenames.join(
+          ', ',
+        )}`,
+      )
+      .toBeGreaterThanOrEqual(1);
+
+    return parsers[0] as Parser<T>;
+  }
+
+  async getParsers(): Promise<Array<Parser<object>>> {
+    const files = [];
+    for (const filename of this.filenames) {
+      const file = new TraceFile(
+        await getFixtureFile(assertDefined(filename)),
+        undefined,
+      );
+      files.push(file);
+    }
+    const processedFiles = await new LegacyParserFactory().processFiles(
+      files,
+      this.timestampConverter,
+      this.metadata,
+    );
+
+    createTimestamps(
+      processedFiles.parsers,
+      this.initializeRealToElapsedTimeOffsetNs,
+      this.timestampConverter,
+    );
+
+    const fileAndParsers = this.convertToPerfetto
+      ? await convertToPerfettoTrace(
+          processedFiles.parsers,
+          this.timestampConverter,
+          this.existingPerfettoFile,
+        )
+      : processedFiles.parsers;
+
+    if (this.convertToPerfetto) {
+      this.timestampConverter.clear();
+      createTimestamps(
+        fileAndParsers,
+        this.initializeRealToElapsedTimeOffsetNs,
+        this.timestampConverter,
+      );
+    }
+
+    return fileAndParsers.map((fileAndParser) => {
+      return fileAndParser.parser;
+    });
+  }
+}
+
+export async function convertToPerfettoTrace(
+  fileAndParsers: FileAndParser[],
+  timestampConverter: TimestampConverter,
+  existingPerfettoFile?: TraceFile,
+): Promise<FileAndParser[]> {
+  const parsers = fileAndParsers.map((p) => p.parser);
+  const perfettoTrace =
+    await LegacyToPerfettoConverter.convertToSinglePerfettoFile(
+      parsers,
+      parsers,
+      existingPerfettoFile,
+    );
+  if (perfettoTrace) {
+    const processed = await new PerfettoParserFactory().processFile(
+      perfettoTrace,
+      timestampConverter,
+    );
+    fileAndParsers = processed.parsers.map((parser) => {
+      return new FileAndParser(perfettoTrace, parser);
+    });
+  }
+  return fileAndParsers;
+}
+
+export async function getTrace<T extends TraceType>(
+  type: T,
+  filename: string,
+): Promise<Trace<T>> {
+  const converter = getTimestampConverter(false);
+  const legacyParsers = await new LegacyParserProvider()
+    .addFilename(filename)
+    .setTimestampConverter(converter)
+    .getParsers();
+  expect(legacyParsers.length).toBeLessThanOrEqual(1);
+  if (legacyParsers.length === 1) {
+    expect(legacyParsers[0].getTraceType()).toEqual(type);
+    return new TraceBuilder<T>()
+      .setType(type)
+      .setParser(legacyParsers[0] as unknown as Parser<T>)
+      .build();
+  }
+
+  const perfettoParsers = await getPerfettoParsers(filename);
+  expect(perfettoParsers.length).toEqual(1);
+  expect(perfettoParsers[0].getTraceType()).toEqual(type);
+  return new TraceBuilder<T>()
+    .setType(type)
+    .setParser(perfettoParsers[0] as unknown as Parser<T>)
+    .build();
+}
+
+function createTimestamps(
+  fileAndParsers: FileAndParser[],
+  initializeRealToElapsedTimeOffsetNs: boolean,
+  converter: TimestampConverter,
+) {
+  if (initializeRealToElapsedTimeOffsetNs) {
+    const monotonicOffset = getParserWithLatestRealToMonotonicTimeOffset(
+      fileAndParsers.map((fileAndParser) => fileAndParser.parser),
+    )?.getRealToMonotonicTimeOffsetNs();
+    if (monotonicOffset !== undefined) {
+      converter.setRealToMonotonicTimeOffsetNs(monotonicOffset);
+    }
+    const boottimeOffset = getParserWithLatestRealToBootTimeOffset(
+      fileAndParsers.map((fileAndParser) => fileAndParser.parser),
+    )?.getRealToBootTimeOffsetNs();
+    if (boottimeOffset !== undefined) {
+      converter.setRealToBootTimeOffsetNs(boottimeOffset);
+    }
+  }
+  fileAndParsers.forEach((fileAndParser) => {
+    fileAndParser.parser.createTimestamps();
+  });
+}
+
+export async function getPerfettoParser<T extends TraceType>(
+  traceType: T,
+  fixturePath: string,
+  withUTCOffset = false,
+): Promise<Parser<TraceEntryTypeMap[T]>> {
+  const parsers = await getPerfettoParsers(fixturePath, withUTCOffset);
+  const parser = assertDefined(
+    parsers.find((parser) => parser.getTraceType() === traceType),
+  );
+  return parser as Parser<TraceEntryTypeMap[T]>;
+}
+
+export async function getPerfettoParsers(
+  fixturePath: string,
+  withUTCOffset = false,
+  isPerfetto?: boolean,
+): Promise<Array<Parser<object>>> {
+  const file = await getFixtureFile(fixturePath);
+  const traceFile = new TraceFile(file);
+  const converter = getTimestampConverter(withUTCOffset);
+  const {parsers, isPerfettoTrace} =
+    await new PerfettoParserFactory().processFile(
+      traceFile,
+      converter,
+      undefined,
+    );
+  if (isPerfetto !== undefined) {
+    expect(isPerfettoTrace).toEqual(isPerfetto);
+  }
+  createTimestamps(
+    parsers.map((parser) => {
+      return new FileAndParser(traceFile, parser);
+    }),
+    true,
+    converter,
+  );
+  return parsers;
+}
+
+export async function getTracesParser(
+  filenames: string[],
+  withUTCOffset = false,
+): Promise<{
+  tracesParser: Parser<object>;
+  constituentParsers: Array<Parser<object>>;
+}> {
+  const converter = getTimestampConverter(withUTCOffset);
+  const provider = new LegacyParserProvider();
+  filenames.forEach((filename) => provider.addFilename(filename));
+  const legacyParsers = await provider
+    .setTimestampConverter(converter)
+    .setInitializeRealToElapsedTimeOffsetNs(true)
+    .getParsers();
+
+  const perfettoParsers = (
+    await Promise.all(
+      filenames.map(async (filename) => getPerfettoParsers(filename)),
+    )
+  ).reduce((acc, cur) => acc.concat(cur), []);
+
+  const parsersArray = legacyParsers.concat(perfettoParsers);
+
+  const offset =
+    getParserWithLatestRealToBootTimeOffset(
+      parsersArray,
+    )?.getRealToBootTimeOffsetNs();
+  if (offset !== undefined) {
+    converter.setRealToBootTimeOffsetNs(offset);
+  }
+
+  const traces = new Traces();
+  parsersArray.forEach((parser) => {
+    const trace = Trace.fromParser(parser);
+    traces.addTrace(trace);
+  });
+
+  const tracesParsers = await new TracesParserFactory().createParsers(
+    traces,
+    converter,
+  );
+  assertTrue(
+    tracesParsers.length === 1,
+    () =>
+      `Should have been able to create a traces parser for [${filenames.join()}]`,
+  );
+  return {tracesParser: tracesParsers[0], constituentParsers: parsersArray};
+}
+
+export async function getWindowManagerState(
+  index = 0,
+): Promise<HierarchyTreeNode> {
+  return getTraceEntry(
+    'traces/elapsed_and_real_timestamp/WindowManager.pb',
+    index,
+  );
+}
+
+export async function getImeTraceEntries(): Promise<
+  [Map<TraceType, HierarchyTreeNode>, Map<TraceType, HierarchyTreeNode>]
+> {
+  const [clientsParser, managerServiceParser, serviceParser, sfParser] =
+    (await new LegacyParserProvider()
+      .addFilename('traces/ime/SurfaceFlinger_with_IME.pb')
+      .addFilename('traces/ime/InputMethodService.pb')
+      .addFilename('traces/ime/InputMethodManagerService.pb')
+      .addFilename('traces/ime/InputMethodClients.pb')
+      .setConvertToPerfetto(true)
+      .getParsers()) as Array<Parser<HierarchyTreeNode>>;
+
+  const surfaceFlingerEntry = await sfParser.getEntry(5);
+  const imServiceEntry = await serviceParser.getEntry(0);
+  const imManagerServiceEntry = await managerServiceParser.getEntry(0);
+  const clientsEntry0 = await clientsParser.getEntry(0);
+  const clientsEntry1 = await clientsParser.getEntry(1);
+
+  const windowManagerEntry = await getTraceEntry<HierarchyTreeNode>(
+    'traces/ime/WindowManager_with_IME.pb',
+    2,
+  );
+
+  const entries = new Map<TraceType, HierarchyTreeNode>();
+  entries.set(TraceType.INPUT_METHOD_CLIENTS, clientsEntry0);
+  entries.set(TraceType.INPUT_METHOD_MANAGER_SERVICE, imManagerServiceEntry);
+  entries.set(TraceType.INPUT_METHOD_SERVICE, imServiceEntry);
+  entries.set(TraceType.SURFACE_FLINGER, surfaceFlingerEntry);
+  entries.set(TraceType.WINDOW_MANAGER, windowManagerEntry);
+
+  const secondEntries = new Map<TraceType, HierarchyTreeNode>();
+  secondEntries.set(TraceType.INPUT_METHOD_CLIENTS, clientsEntry1);
+  secondEntries.set(TraceType.SURFACE_FLINGER, surfaceFlingerEntry);
+  secondEntries.set(TraceType.WINDOW_MANAGER, windowManagerEntry);
+
+  return [entries, secondEntries];
+}
+
+async function getTraceEntry<T>(filename: string, index = 0) {
+  const parser = await new LegacyParserProvider()
+    .addFilename(filename)
+    .getParser<T>();
+  return parser.getEntry(index);
+}
diff --git a/tools/winscope/src/test/unit/mock_log_viewer_presenter.ts b/tools/winscope/src/test/unit/mock_log_viewer_presenter.ts
index 4cba67851..5cbb5445b 100644
--- a/tools/winscope/src/test/unit/mock_log_viewer_presenter.ts
+++ b/tools/winscope/src/test/unit/mock_log_viewer_presenter.ts
@@ -82,7 +82,7 @@ the default for its data type.`,
             value: this.trace.getEntry(0).getTimestamp(),
           },
         ],
-        propertiesTree: await this.trace.getEntry(0).getValue(),
+        getPropertiesTree: async () => await this.trace.getEntry(0).getValue(),
       },
       {
         traceEntry: this.trace.getEntry(1),
@@ -94,7 +94,7 @@ the default for its data type.`,
             value: this.trace.getEntry(1).getTimestamp(),
           },
         ],
-        propertiesTree: await this.trace.getEntry(1).getValue(),
+        getPropertiesTree: async () => await this.trace.getEntry(1).getValue(),
       },
       {
         traceEntry: this.trace.getEntry(2),
@@ -106,7 +106,7 @@ the default for its data type.`,
             value: this.trace.getEntry(2).getTimestamp(),
           },
         ],
-        propertiesTree: await this.trace.getEntry(2).getValue(),
+        getPropertiesTree: async () => await this.trace.getEntry(2).getValue(),
       },
       {
         traceEntry: this.trace.getEntry(3),
@@ -118,7 +118,7 @@ the default for its data type.`,
             value: this.trace.getEntry(3).getTimestamp(),
           },
         ],
-        propertiesTree: await this.trace.getEntry(3).getValue(),
+        getPropertiesTree: async () => await this.trace.getEntry(3).getValue(),
       },
     ];
     return entries;
@@ -135,10 +135,7 @@ the default for its data type.`,
     return headers;
   }
 
-  protected override updateFiltersInHeaders(
-    headers: LogHeader[],
-    allEntries: LogEntry[],
-  ) {
+  protected override async updateFiltersInHeaders(headers: LogHeader[]) {
     for (const header of headers) {
       if (header.spec === this.stringColumn) {
         (assertDefined(header.filter) as LogSelectFilter).options = [
diff --git a/tools/winscope/src/test/unit/spy_utils.ts b/tools/winscope/src/test/unit/spy_utils.ts
new file mode 100644
index 000000000..601c52be9
--- /dev/null
+++ b/tools/winscope/src/test/unit/spy_utils.ts
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+export async function waitToBeCalled(
+  spy: jasmine.Spy,
+  times: number = 1,
+  timeout = 10000,
+) {
+  return new Promise<void>((resolve, reject) => {
+    let called = 0;
+    spy.and.callThrough().and.callFake(() => {
+      called++;
+      if (called === times) {
+        resolve();
+      }
+    });
+
+    setTimeout(
+      () => reject(`not called ${times} times within ${timeout}ms`),
+      timeout,
+    );
+  });
+}
diff --git a/tools/winscope/src/test/unit/trace_utils.ts b/tools/winscope/src/test/unit/trace_utils.ts
index a52633113..34bde5c20 100644
--- a/tools/winscope/src/test/unit/trace_utils.ts
+++ b/tools/winscope/src/test/unit/trace_utils.ts
@@ -15,32 +15,57 @@
  */
 
 import {Timestamp} from 'common/time/time';
+import {
+  CustomQueryParserResultTypeMap,
+  CustomQueryType,
+} from 'trace/custom_query';
 import {AbsoluteFrameIndex, Trace} from 'trace/trace';
+import {TraceEntryTypeMap, TraceType} from 'trace/trace_type';
+import {TraceBuilder} from './trace_builder';
 
-export class TraceUtils {
-  static async extractEntries<T>(trace: Trace<T>): Promise<T[]> {
-    const promises = trace.mapEntry(async (entry, index) => {
-      return await entry.getValue();
-    });
-    return await Promise.all(promises);
-  }
+export async function extractEntries<T>(trace: Trace<T>): Promise<T[]> {
+  const promises = trace.mapEntry(async (entry, index) => {
+    return await entry.getValue();
+  });
+  return await Promise.all(promises);
+}
 
-  static extractTimestamps<T>(trace: Trace<T>): Timestamp[] {
-    const timestamps = new Array<Timestamp>();
-    trace.forEachTimestamp((timestamp) => {
-      timestamps.push(timestamp);
-    });
-    return timestamps;
-  }
+export function extractTimestamps<T>(trace: Trace<T>): Timestamp[] {
+  const timestamps = new Array<Timestamp>();
+  trace.forEachTimestamp((timestamp) => {
+    timestamps.push(timestamp);
+  });
+  return timestamps;
+}
 
-  static async extractFrames<T>(
-    trace: Trace<T>,
-  ): Promise<Map<AbsoluteFrameIndex, T[]>> {
-    const frames = new Map<AbsoluteFrameIndex, T[]>();
-    const promises = trace.mapFrame(async (frame, index) => {
-      frames.set(index, await TraceUtils.extractEntries(frame));
-    });
-    await Promise.all(promises);
-    return frames;
+export async function extractFrames<T>(
+  trace: Trace<T>,
+): Promise<Map<AbsoluteFrameIndex, T[]>> {
+  const frames = new Map<AbsoluteFrameIndex, T[]>();
+  const promises = trace.mapFrame(async (frame, index) => {
+    frames.set(index, await extractEntries(frame));
+  });
+  await Promise.all(promises);
+  return frames;
+}
+
+export function makeEmptyTrace<T extends TraceType>(
+  traceType: T,
+  descriptors: string[] = [],
+  parserCustomQueryResult: Array<{
+    queryType: CustomQueryType;
+    result: CustomQueryParserResultTypeMap[CustomQueryType];
+  }> = [],
+): Trace<TraceEntryTypeMap[T]> {
+  const builder = new TraceBuilder<TraceEntryTypeMap[T]>()
+    .setEntries([])
+    .setTimestamps([])
+    .setDescriptors(descriptors)
+    .setType(traceType);
+
+  for (const {queryType, result} of parserCustomQueryResult) {
+    builder.setParserCustomQueryResult(queryType, result);
   }
+
+  return builder.build();
 }
diff --git a/tools/winscope/src/test/unit/traces_utils.ts b/tools/winscope/src/test/unit/traces_utils.ts
index d9699b07b..609826310 100644
--- a/tools/winscope/src/test/unit/traces_utils.ts
+++ b/tools/winscope/src/test/unit/traces_utils.ts
@@ -18,43 +18,41 @@ import {assertDefined} from 'common/assert_utils';
 import {AbsoluteFrameIndex, Trace} from 'trace/trace';
 import {Traces} from 'trace/traces';
 import {TraceType} from 'trace/trace_type';
-import {TraceUtils} from './trace_utils';
+import {extractEntries as extractTraceEntries} from './trace_utils';
 
-export class TracesUtils {
-  static extractTraces(traces: Traces): Array<Trace<{}>> {
-    return traces.mapTrace((trace) => trace);
-  }
+export function extractTraces(traces: Traces): Array<Trace<{}>> {
+  return traces.mapTrace((trace) => trace);
+}
 
-  static async extractEntries(
-    traces: Traces,
-  ): Promise<Map<TraceType, Array<{}>>> {
-    const entries = new Map<TraceType, Array<{}>>();
+export async function extractEntries(
+  traces: Traces,
+): Promise<Map<TraceType, Array<{}>>> {
+  const entries = new Map<TraceType, Array<{}>>();
 
-    const promises = traces.mapTrace(async (trace) => {
-      entries.set(trace.type, await TraceUtils.extractEntries(trace));
-    });
-    await Promise.all(promises);
-
-    return entries;
-  }
-
-  static async extractFrames(
-    traces: Traces,
-  ): Promise<Map<AbsoluteFrameIndex, Map<TraceType, Array<{}>>>> {
-    const frames = new Map<AbsoluteFrameIndex, Map<TraceType, Array<{}>>>();
-
-    const framePromises = traces.mapFrame(async (frame, index) => {
-      frames.set(index, new Map<TraceType, Array<{}>>());
-      const tracePromises = frame.mapTrace(async (trace, type) => {
-        assertDefined(frames.get(index)).set(
-          type,
-          await TraceUtils.extractEntries(trace),
-        );
-      });
-      await Promise.all(tracePromises);
+  const promises = traces.mapTrace(async (trace) => {
+    entries.set(trace.type, await extractTraceEntries(trace));
+  });
+  await Promise.all(promises);
+
+  return entries;
+}
+
+export async function extractFrames(
+  traces: Traces,
+): Promise<Map<AbsoluteFrameIndex, Map<TraceType, Array<{}>>>> {
+  const frames = new Map<AbsoluteFrameIndex, Map<TraceType, Array<{}>>>();
+
+  const framePromises = traces.mapFrame(async (frame, index) => {
+    frames.set(index, new Map<TraceType, Array<{}>>());
+    const tracePromises = frame.mapTrace(async (trace, type) => {
+      assertDefined(frames.get(index)).set(
+        type,
+        await extractTraceEntries(trace),
+      );
     });
-    await Promise.all(framePromises);
+    await Promise.all(tracePromises);
+  });
+  await Promise.all(framePromises);
 
-    return frames;
-  }
+  return frames;
 }
diff --git a/tools/winscope/src/test/unit/tree_node_utils.ts b/tools/winscope/src/test/unit/tree_node_utils.ts
index b962493ca..4cf96d394 100644
--- a/tools/winscope/src/test/unit/tree_node_utils.ts
+++ b/tools/winscope/src/test/unit/tree_node_utils.ts
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-import {TransformTypeFlags} from 'parsers/surface_flinger/transform_utils';
+import {TransformTypeFlags} from 'trace/surface_flinger/transform_utils';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 import {DEFAULT_PROPERTY_TREE_NODE_FACTORY} from 'trace/tree_node/property_tree_node_factory';
diff --git a/tools/winscope/src/test/unit/utils.ts b/tools/winscope/src/test/unit/utils.ts
deleted file mode 100644
index e52738229..000000000
--- a/tools/winscope/src/test/unit/utils.ts
+++ /dev/null
@@ -1,440 +0,0 @@
-/*
- * Copyright (C) 2022 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import {ComponentFixture} from '@angular/core/testing';
-import {assertDefined, assertTrue} from 'common/assert_utils';
-import {TimestampConverterUtils} from 'common/time/test_utils';
-import {Timestamp} from 'common/time/time';
-import {TimestampConverter} from 'common/time/timestamp_converter';
-import {ParserFactory as LegacyParserFactory} from 'parsers/legacy/parser_factory';
-import {ParserFactory as PerfettoParserFactory} from 'parsers/perfetto/parser_factory';
-import {TracesParserFactory} from 'parsers/traces/traces_parser_factory';
-import {Parser} from 'trace/parser';
-import {Trace} from 'trace/trace';
-import {Traces} from 'trace/traces';
-import {TraceFile} from 'trace/trace_file';
-import {TraceMetadata} from 'trace/trace_metadata';
-import {TraceEntryTypeMap, TraceType} from 'trace/trace_type';
-import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
-import {
-  ColumnType,
-  QueryResult,
-  Row,
-  RowIterator,
-} from 'trace_processor/query_result';
-import {TraceProcessorFactory} from 'trace_processor/trace_processor_factory';
-import {getFixtureFile} from './fixture_utils';
-import {TraceBuilder} from './trace_builder';
-
-class UnitTestUtils {
-  static async getTrace<T extends TraceType>(
-    type: T,
-    filename: string,
-  ): Promise<Trace<T>> {
-    const converter = UnitTestUtils.getTimestampConverter(false);
-    const legacyParsers = await UnitTestUtils.getParsers(filename, converter);
-    expect(legacyParsers.length).toBeLessThanOrEqual(1);
-    if (legacyParsers.length === 1) {
-      expect(legacyParsers[0].getTraceType()).toEqual(type);
-      return new TraceBuilder<T>()
-        .setType(type)
-        .setParser(legacyParsers[0] as unknown as Parser<T>)
-        .build();
-    }
-
-    const perfettoParsers = await UnitTestUtils.getPerfettoParsers(filename);
-    expect(perfettoParsers.length).toEqual(1);
-    expect(perfettoParsers[0].getTraceType()).toEqual(type);
-    return new TraceBuilder<T>()
-      .setType(type)
-      .setParser(perfettoParsers[0] as unknown as Parser<T>)
-      .build();
-  }
-
-  static async getParser(
-    filename: string,
-    converter = UnitTestUtils.getTimestampConverter(),
-    initializeRealToElapsedTimeOffsetNs = true,
-    metadata: TraceMetadata = {},
-  ): Promise<Parser<object>> {
-    const parsers = await UnitTestUtils.getParsers(
-      filename,
-      converter,
-      initializeRealToElapsedTimeOffsetNs,
-      metadata,
-    );
-
-    expect(parsers.length)
-      .withContext(`Should have been able to create a parser for ${filename}`)
-      .toBeGreaterThanOrEqual(1);
-
-    return parsers[0];
-  }
-
-  static async getParsers(
-    filename: string,
-    converter = UnitTestUtils.getTimestampConverter(),
-    initializeRealToElapsedTimeOffsetNs = true,
-    metadata: TraceMetadata = {},
-  ): Promise<Array<Parser<object>>> {
-    const file = new TraceFile(await getFixtureFile(filename), undefined);
-    const fileAndParsers = await new LegacyParserFactory().createParsers(
-      [file],
-      converter,
-      metadata,
-    );
-
-    if (initializeRealToElapsedTimeOffsetNs) {
-      const monotonicOffset = fileAndParsers
-        .find(
-          (fileAndParser) =>
-            fileAndParser.parser.getRealToMonotonicTimeOffsetNs() !== undefined,
-        )
-        ?.parser.getRealToMonotonicTimeOffsetNs();
-      if (monotonicOffset !== undefined) {
-        converter.setRealToMonotonicTimeOffsetNs(monotonicOffset);
-      }
-      const bootTimeOffset = fileAndParsers
-        .find(
-          (fileAndParser) =>
-            fileAndParser.parser.getRealToBootTimeOffsetNs() !== undefined,
-        )
-        ?.parser.getRealToBootTimeOffsetNs();
-      if (bootTimeOffset !== undefined) {
-        converter.setRealToBootTimeOffsetNs(bootTimeOffset);
-      }
-    }
-
-    return fileAndParsers.map((fileAndParser) => {
-      fileAndParser.parser.createTimestamps();
-      return fileAndParser.parser;
-    });
-  }
-
-  static async getPerfettoParser<T extends TraceType>(
-    traceType: T,
-    fixturePath: string,
-    withUTCOffset = false,
-  ): Promise<Parser<TraceEntryTypeMap[T]>> {
-    const parsers = await UnitTestUtils.getPerfettoParsers(
-      fixturePath,
-      withUTCOffset,
-    );
-    const parser = assertDefined(
-      parsers.find((parser) => parser.getTraceType() === traceType),
-    );
-    return parser as Parser<TraceEntryTypeMap[T]>;
-  }
-
-  static async getPerfettoParsers(
-    fixturePath: string,
-    withUTCOffset = false,
-  ): Promise<Array<Parser<object>>> {
-    const file = await getFixtureFile(fixturePath);
-    const traceFile = new TraceFile(file);
-    const converter = UnitTestUtils.getTimestampConverter(withUTCOffset);
-    const parsers = await new PerfettoParserFactory().createParsers(
-      traceFile,
-      converter,
-      undefined,
-    );
-    parsers.forEach((parser) => {
-      converter.setRealToBootTimeOffsetNs(
-        assertDefined(parser.getRealToBootTimeOffsetNs()),
-      );
-      parser.createTimestamps();
-    });
-    return parsers;
-  }
-
-  static async getTracesParser(
-    filenames: string[],
-    withUTCOffset = false,
-  ): Promise<Parser<object>> {
-    const converter = UnitTestUtils.getTimestampConverter(withUTCOffset);
-    const legacyParsers = (
-      await Promise.all(
-        filenames.map(async (filename) =>
-          UnitTestUtils.getParsers(filename, converter, true),
-        ),
-      )
-    ).reduce((acc, cur) => acc.concat(cur), []);
-
-    const perfettoParsers = (
-      await Promise.all(
-        filenames.map(async (filename) =>
-          UnitTestUtils.getPerfettoParsers(filename),
-        ),
-      )
-    ).reduce((acc, cur) => acc.concat(cur), []);
-
-    const parsersArray = legacyParsers.concat(perfettoParsers);
-
-    const offset = parsersArray
-      .filter((parser) => parser.getRealToBootTimeOffsetNs() !== undefined)
-      .sort((a, b) =>
-        Number(
-          (a.getRealToBootTimeOffsetNs() ?? 0n) -
-            (b.getRealToBootTimeOffsetNs() ?? 0n),
-        ),
-      )
-      .at(-1)
-      ?.getRealToBootTimeOffsetNs();
-
-    if (offset !== undefined) {
-      converter.setRealToBootTimeOffsetNs(offset);
-    }
-
-    const traces = new Traces();
-    parsersArray.forEach((parser) => {
-      const trace = Trace.fromParser(parser);
-      traces.addTrace(trace);
-    });
-
-    const tracesParsers = await new TracesParserFactory().createParsers(
-      traces,
-      converter,
-    );
-    assertTrue(
-      tracesParsers.length === 1,
-      () =>
-        `Should have been able to create a traces parser for [${filenames.join()}]`,
-    );
-    return tracesParsers[0];
-  }
-
-  static getTimestampConverter(withUTCOffset = false): TimestampConverter {
-    return withUTCOffset
-      ? new TimestampConverter(TimestampConverterUtils.ASIA_TIMEZONE_INFO)
-      : new TimestampConverter(TimestampConverterUtils.UTC_TIMEZONE_INFO);
-  }
-
-  static async getWindowManagerState(index = 0): Promise<HierarchyTreeNode> {
-    return UnitTestUtils.getTraceEntry(
-      'traces/elapsed_and_real_timestamp/WindowManager.pb',
-      index,
-    );
-  }
-
-  static async getLayerTraceEntry(index = 0): Promise<HierarchyTreeNode> {
-    return await UnitTestUtils.getTraceEntry<HierarchyTreeNode>(
-      'traces/elapsed_timestamp/SurfaceFlinger.pb',
-      index,
-    );
-  }
-
-  static async getViewCaptureEntry(): Promise<HierarchyTreeNode> {
-    return await UnitTestUtils.getTraceEntry<HierarchyTreeNode>(
-      'traces/elapsed_and_real_timestamp/com.google.android.apps.nexuslauncher_0.vc',
-    );
-  }
-
-  static async getMultiDisplayLayerTraceEntry(): Promise<HierarchyTreeNode> {
-    return await UnitTestUtils.getTraceEntry<HierarchyTreeNode>(
-      'traces/elapsed_and_real_timestamp/SurfaceFlinger_multidisplay.pb',
-    );
-  }
-
-  static async getImeTraceEntries(): Promise<
-    [Map<TraceType, HierarchyTreeNode>, Map<TraceType, HierarchyTreeNode>]
-  > {
-    let surfaceFlingerEntry: HierarchyTreeNode | undefined;
-    {
-      const parser = (await UnitTestUtils.getParser(
-        'traces/ime/SurfaceFlinger_with_IME.pb',
-      )) as Parser<HierarchyTreeNode>;
-      surfaceFlingerEntry = await parser.getEntry(5);
-    }
-
-    let windowManagerEntry: HierarchyTreeNode | undefined;
-    {
-      const parser = (await UnitTestUtils.getParser(
-        'traces/ime/WindowManager_with_IME.pb',
-      )) as Parser<HierarchyTreeNode>;
-      windowManagerEntry = await parser.getEntry(2);
-    }
-
-    const entries = new Map<TraceType, HierarchyTreeNode>();
-    entries.set(
-      TraceType.INPUT_METHOD_CLIENTS,
-      await UnitTestUtils.getTraceEntry('traces/ime/InputMethodClients.pb'),
-    );
-    entries.set(
-      TraceType.INPUT_METHOD_MANAGER_SERVICE,
-      await UnitTestUtils.getTraceEntry(
-        'traces/ime/InputMethodManagerService.pb',
-      ),
-    );
-    entries.set(
-      TraceType.INPUT_METHOD_SERVICE,
-      await UnitTestUtils.getTraceEntry('traces/ime/InputMethodService.pb'),
-    );
-    entries.set(TraceType.SURFACE_FLINGER, surfaceFlingerEntry);
-    entries.set(TraceType.WINDOW_MANAGER, windowManagerEntry);
-
-    const secondEntries = new Map<TraceType, HierarchyTreeNode>();
-    secondEntries.set(
-      TraceType.INPUT_METHOD_CLIENTS,
-      await UnitTestUtils.getTraceEntry('traces/ime/InputMethodClients.pb', 1),
-    );
-    secondEntries.set(TraceType.SURFACE_FLINGER, surfaceFlingerEntry);
-    secondEntries.set(TraceType.WINDOW_MANAGER, windowManagerEntry);
-
-    return [entries, secondEntries];
-  }
-
-  static async getTraceEntry<T>(filename: string, index = 0) {
-    const parser = (await UnitTestUtils.getParser(filename)) as Parser<T>;
-    return parser.getEntry(index);
-  }
-
-  static checkSectionCollapseAndExpand<T>(
-    htmlElement: HTMLElement,
-    fixture: ComponentFixture<T>,
-    selector: string,
-    sectionTitle: string,
-  ) {
-    const section = assertDefined(htmlElement.querySelector(selector));
-    expect(
-      assertDefined(
-        section.querySelector<HTMLElement>(
-          'collapsible-section-title .mat-title',
-        ),
-      ).textContent,
-    ).toEqual(sectionTitle);
-    const collapseButton = assertDefined(
-      section.querySelector<HTMLElement>('collapsible-section-title button'),
-    );
-    collapseButton.click();
-    fixture.detectChanges();
-    expect(section.classList).toContain('collapsed');
-    const collapsedSections = assertDefined(
-      htmlElement.querySelector('collapsed-sections'),
-    );
-    const collapsedSection = assertDefined(
-      collapsedSections.querySelector('.collapsed-section'),
-    ) as HTMLElement;
-    expect(collapsedSection.textContent?.trim()).toEqual(
-      sectionTitle + '  arrow_right',
-    );
-    collapsedSection.click();
-    fixture.detectChanges();
-    UnitTestUtils.checkNoCollapsedSectionButtons(htmlElement);
-  }
-
-  static checkNoCollapsedSectionButtons(htmlElement: HTMLElement) {
-    const collapsedSections = assertDefined(
-      htmlElement.querySelector('collapsed-sections'),
-    );
-    expect(
-      collapsedSections.querySelectorAll('.collapsed-section').length,
-    ).toEqual(0);
-  }
-
-  static makeEmptyTrace<T extends TraceType>(
-    traceType: T,
-    descriptors: string[] = [],
-  ): Trace<TraceEntryTypeMap[T]> {
-    return new TraceBuilder<TraceEntryTypeMap[T]>()
-      .setEntries([])
-      .setTimestamps([])
-      .setDescriptors(descriptors)
-      .setType(traceType)
-      .build();
-  }
-
-  static makeSearchTraceSpies(
-    ts?: Timestamp,
-    value?: ColumnType,
-  ): [jasmine.SpyObj<QueryResult>, jasmine.SpyObj<RowIterator<Row>>] {
-    const spyQueryResult = jasmine.createSpyObj<QueryResult>('result', [
-      'numRows',
-      'columns',
-      'iter',
-    ]);
-    spyQueryResult.numRows.and.returnValue(1);
-    const columns: string[] = [];
-    if (ts !== undefined) columns.push('ts');
-    columns.push('property');
-    if (value !== undefined) columns.push('value');
-    spyQueryResult.columns.and.returnValue(columns);
-
-    const spyIter = jasmine.createSpyObj<RowIterator<Row>>('iter', [
-      'valid',
-      'next',
-      'get',
-    ]);
-    if (ts !== undefined) {
-      spyIter.get.withArgs('ts').and.returnValue(ts.getValueNs());
-    }
-    spyIter.get.withArgs('property').and.returnValue('test_property');
-    if (value !== undefined) {
-      spyIter.get.withArgs('value').and.returnValue(value);
-    }
-    spyIter.valid.and.returnValue(true);
-    spyIter.next.and.callFake(() =>
-      assertDefined(spyIter).valid.and.returnValue(false),
-    );
-    spyQueryResult.iter.and.returnValue(spyIter);
-
-    return [spyQueryResult, spyIter];
-  }
-
-  static async runQueryAndGetResult(query: string): Promise<QueryResult> {
-    const tp = await TraceProcessorFactory.getSingleInstance();
-    return tp.queryAllRows(query);
-  }
-
-  static async checkTooltips<T>(
-    elements: Element[],
-    expTooltips: Array<string | undefined>,
-    fixture: ComponentFixture<T>,
-  ) {
-    for (const [index, el] of elements.entries()) {
-      el.dispatchEvent(new Event('mouseenter'));
-      fixture.detectChanges();
-      const panel = document.querySelector<HTMLElement>('.mat-tooltip-panel');
-      if (expTooltips[index] !== undefined) {
-        expect(panel?.textContent).toEqual(expTooltips[index]);
-      } else {
-        expect(panel).toBeNull();
-      }
-      el.dispatchEvent(new Event('mouseleave'));
-      fixture.detectChanges();
-      await fixture.whenStable();
-    }
-  }
-
-  static makeFakeWebSocket(): jasmine.SpyObj<WebSocket> {
-    const socket = jasmine.createSpyObj<WebSocket>(
-      'WebSocket',
-      ['onmessage', 'onclose', 'send', 'close', 'onerror'],
-      {'readyState': WebSocket.OPEN, binaryType: 'arraybuffer'},
-    );
-    socket.close.and.callFake(() => {
-      socket.onclose!(new CloseEvent(''));
-    });
-    return socket;
-  }
-
-  static makeFakeWebSocketMessage(
-    data: Blob | ArrayBuffer | number | string,
-  ): MessageEvent {
-    return jasmine.createSpyObj<MessageEvent>([], {'data': data});
-  }
-}
-
-export {UnitTestUtils};
diff --git a/tools/winscope/src/test/unit/web_socket_utils.ts b/tools/winscope/src/test/unit/web_socket_utils.ts
new file mode 100644
index 000000000..8ab709987
--- /dev/null
+++ b/tools/winscope/src/test/unit/web_socket_utils.ts
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+export function makeFakeWebSocket(): jasmine.SpyObj<WebSocket> {
+  const socket = jasmine.createSpyObj<WebSocket>(
+    'WebSocket',
+    ['onmessage', 'onclose', 'send', 'close', 'onerror'],
+    {'readyState': WebSocket.OPEN, binaryType: 'arraybuffer'},
+  );
+  socket.close.and.callFake(() => {
+    socket.onclose!(new CloseEvent('close'));
+  });
+  return socket;
+}
+
+export function makeFakeWebSocketMessage(
+  data: Blob | ArrayBuffer | number | string,
+): MessageEvent {
+  return jasmine.createSpyObj<MessageEvent>([], {'data': data});
+}
diff --git a/tools/winscope/src/test/utils.ts b/tools/winscope/src/test/utils.ts
deleted file mode 100644
index 5524a4e32..000000000
--- a/tools/winscope/src/test/utils.ts
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import {ComponentFixture, flush} from '@angular/core/testing';
-
-export function dispatchMouseEvent(
-  source: Node,
-  type: string,
-  screenX: number,
-  screenY: number,
-  clientX: number,
-  clientY: number,
-) {
-  const event = document.createEvent('MouseEvent');
-
-  event.initMouseEvent(
-    type,
-    true /* canBubble */,
-    false /* cancelable */,
-    window /* view */,
-    0 /* detail */,
-    screenX /* screenX */,
-    screenY /* screenY */,
-    clientX /* clientX */,
-    clientY /* clientY */,
-    false /* ctrlKey */,
-    false /* altKey */,
-    false /* shiftKey */,
-    false /* metaKey */,
-    0 /* button */,
-    null /* relatedTarget */,
-  );
-  Object.defineProperty(event, 'buttons', {get: () => 1});
-
-  source.dispatchEvent(event);
-}
-
-export function dragElement<T>(
-  fixture: ComponentFixture<T>,
-  target: Element,
-  x: number,
-  y: number,
-) {
-  const {left, top} = target.getBoundingClientRect();
-
-  dispatchMouseEvent(target, 'mousedown', left, top, 0, 0);
-  fixture.detectChanges();
-  flush();
-  dispatchMouseEvent(document, 'mousemove', left + 1, top + 0, 1, y);
-  fixture.detectChanges();
-  flush();
-  dispatchMouseEvent(document, 'mousemove', left + x, top + y, x, y);
-  fixture.detectChanges();
-  flush();
-  dispatchMouseEvent(document, 'mouseup', left + x, top + y, x, y);
-  fixture.detectChanges();
-
-  flush();
-}
-
-export async function waitToBeCalled(
-  spy: jasmine.Spy,
-  times: number = 1,
-  timeout = 10000,
-) {
-  return new Promise<void>((resolve, reject) => {
-    let called = 0;
-    spy.and.callThrough().and.callFake(() => {
-      called++;
-      if (called === times) {
-        resolve();
-      }
-    });
-
-    setTimeout(
-      () => reject(`not called ${times} times within ${timeout}ms`),
-      timeout,
-    );
-  });
-}
diff --git a/tools/winscope/src/trace/cuj_type.ts b/tools/winscope/src/trace/cujs/cuj_type.ts
similarity index 100%
rename from tools/winscope/src/trace/cuj_type.ts
rename to tools/winscope/src/trace/cujs/cuj_type.ts
diff --git a/tools/winscope/src/trace/custom_query.ts b/tools/winscope/src/trace/custom_query.ts
index bd6eeb7e1..8d95da1cf 100644
--- a/tools/winscope/src/trace/custom_query.ts
+++ b/tools/winscope/src/trace/custom_query.ts
@@ -21,6 +21,7 @@ export enum CustomQueryType {
   VIEW_CAPTURE_METADATA,
   VSYNCID,
   WM_WINDOWS_TOKEN_AND_TITLE,
+  LOG_TABLE_FILTER_VALUES,
 }
 
 export class ProcessParserResult {
@@ -53,6 +54,12 @@ export class ProcessParserResult {
   ): CustomQueryResultTypeMap<T>[CustomQueryType.WM_WINDOWS_TOKEN_AND_TITLE] {
     return parserResult;
   }
+
+  static [CustomQueryType.LOG_TABLE_FILTER_VALUES]<T>(
+    parserResult: CustomQueryParserResultTypeMap[CustomQueryType.LOG_TABLE_FILTER_VALUES],
+  ): CustomQueryResultTypeMap<T>[CustomQueryType.LOG_TABLE_FILTER_VALUES] {
+    return parserResult;
+  }
 }
 
 export interface CustomQueryParamTypeMap {
@@ -60,6 +67,7 @@ export interface CustomQueryParamTypeMap {
   [CustomQueryType.VIEW_CAPTURE_METADATA]: never;
   [CustomQueryType.VSYNCID]: never;
   [CustomQueryType.WM_WINDOWS_TOKEN_AND_TITLE]: never;
+  [CustomQueryType.LOG_TABLE_FILTER_VALUES]: number;
 }
 
 export interface CustomQueryParserResultTypeMap {
@@ -73,6 +81,7 @@ export interface CustomQueryParserResultTypeMap {
     token: string;
     title: string;
   }>;
+  [CustomQueryType.LOG_TABLE_FILTER_VALUES]: string[];
 }
 
 export interface CustomQueryResultTypeMap<T> {
@@ -86,6 +95,7 @@ export interface CustomQueryResultTypeMap<T> {
     token: string;
     title: string;
   }>;
+  [CustomQueryType.LOG_TABLE_FILTER_VALUES]: string[];
 }
 
 export class VisitableParserCustomQuery<Q extends CustomQueryType> {
diff --git a/tools/winscope/src/trace/frame_mapper_test.ts b/tools/winscope/src/trace/frame_mapper_test.ts
index 6a12320d0..3122f7e8f 100644
--- a/tools/winscope/src/trace/frame_mapper_test.ts
+++ b/tools/winscope/src/trace/frame_mapper_test.ts
@@ -15,7 +15,7 @@
  */
 
 import {TimestampConverterUtils} from 'common/time/test_utils';
-import {TracesUtils} from 'test/unit/traces_utils';
+import {extractFrames} from 'test/unit/traces_utils';
 import {TraceBuilder} from 'test/unit/trace_builder';
 import {CustomQueryType} from './custom_query';
 import {FrameMapper} from './frame_mapper';
@@ -100,7 +100,7 @@ describe('FrameMapper', () => {
         ]),
       );
 
-      expect(await TracesUtils.extractFrames(traces)).toEqual(expectedFrames);
+      expect(await extractFrames(traces)).toEqual(expectedFrames);
     });
   });
 
@@ -168,7 +168,7 @@ describe('FrameMapper', () => {
         ]),
       );
 
-      expect(await TracesUtils.extractFrames(traces)).toEqual(expectedFrames);
+      expect(await extractFrames(traces)).toEqual(expectedFrames);
     });
   });
 
@@ -278,7 +278,7 @@ describe('FrameMapper', () => {
         ]),
       );
 
-      expect(await TracesUtils.extractFrames(traces)).toEqual(expectedFrames);
+      expect(await extractFrames(traces)).toEqual(expectedFrames);
     });
   });
 
@@ -371,7 +371,7 @@ describe('FrameMapper', () => {
         ]),
       );
 
-      expect(await TracesUtils.extractFrames(traces)).toEqual(expectedFrames);
+      expect(await extractFrames(traces)).toEqual(expectedFrames);
     });
   });
 
@@ -425,7 +425,7 @@ describe('FrameMapper', () => {
           [[1, 2], 1],
           [[3], 2],
         ]);
-        expect(await TracesUtils.extractFrames(traces)).toEqual(expectedFrames);
+        expect(await extractFrames(traces)).toEqual(expectedFrames);
       });
 
       it('does not propagate mapping if all vsync ids invalid', async () => {
@@ -472,7 +472,7 @@ describe('FrameMapper', () => {
           [[2], 1],
           [[4], 2],
         ]);
-        expect(await TracesUtils.extractFrames(traces)).toEqual(expectedFrames);
+        expect(await extractFrames(traces)).toEqual(expectedFrames);
       });
 
       async function computeMapping(surfaceFlingerTrace = sfTrace) {
@@ -599,7 +599,7 @@ describe('FrameMapper', () => {
         ]),
       );
 
-      expect(await TracesUtils.extractFrames(traces)).toEqual(expectedFrames);
+      expect(await extractFrames(traces)).toEqual(expectedFrames);
     });
   });
 
diff --git a/tools/winscope/src/trace/parser.ts b/tools/winscope/src/trace/parser.ts
index c0777d80a..cc877412d 100644
--- a/tools/winscope/src/trace/parser.ts
+++ b/tools/winscope/src/trace/parser.ts
@@ -15,6 +15,7 @@
  */
 
 import {Timestamp} from 'common/time/time';
+import {perfetto} from 'protos/perfetto/trace/static';
 import {CoarseVersion} from './coarse_version';
 import {
   CustomQueryParamTypeMap,
@@ -39,4 +40,10 @@ export interface Parser<T> {
   getRealToMonotonicTimeOffsetNs(): bigint | undefined;
   getRealToBootTimeOffsetNs(): bigint | undefined;
   createTimestamps(): void;
+  canConvertToPerfetto(): boolean;
+  convertToPerfettoPackets?(
+    sequenceId: number,
+    trustedUid?: number,
+    trustedPid?: number,
+  ): perfetto.protos.TracePacket[];
 }
diff --git a/tools/winscope/src/trace/parser_mock.ts b/tools/winscope/src/trace/parser_mock.ts
index 89544db35..0011a799a 100644
--- a/tools/winscope/src/trace/parser_mock.ts
+++ b/tools/winscope/src/trace/parser_mock.ts
@@ -14,7 +14,9 @@
  * limitations under the License.
  */
 
+import {NOT_IMPLEMENTED_ERROR} from 'common/errors';
 import {Timestamp} from 'common/time/time';
+import {perfetto} from 'protos/perfetto/trace/static';
 import {CoarseVersion} from './coarse_version';
 import {CustomQueryParserResultTypeMap, CustomQueryType} from './custom_query';
 import {AbsoluteEntryIndex, EntriesRange} from './index_types';
@@ -49,7 +51,7 @@ export class ParserMock<T> implements Parser<T> {
   }
 
   createTimestamps() {
-    throw new Error('Not implemented');
+    throw NOT_IMPLEMENTED_ERROR;
   }
 
   getRealToMonotonicTimeOffsetNs(): bigint | undefined {
@@ -93,4 +95,12 @@ export class ParserMock<T> implements Parser<T> {
   getDescriptors(): string[] {
     return this.descriptors;
   }
+
+  canConvertToPerfetto(): boolean {
+    return this.convertToPerfettoPackets !== undefined;
+  }
+
+  convertToPerfettoPackets:
+    | ((sequenceId: number) => perfetto.protos.TracePacket[])
+    | undefined = undefined;
 }
diff --git a/tools/winscope/src/trace/layer_composition_type.ts b/tools/winscope/src/trace/surface_flinger/layer_composition_type.ts
similarity index 100%
rename from tools/winscope/src/trace/layer_composition_type.ts
rename to tools/winscope/src/trace/surface_flinger/layer_composition_type.ts
diff --git a/tools/winscope/src/parsers/surface_flinger/layer_flag.ts b/tools/winscope/src/trace/surface_flinger/layer_flag.ts
similarity index 86%
rename from tools/winscope/src/parsers/surface_flinger/layer_flag.ts
rename to tools/winscope/src/trace/surface_flinger/layer_flag.ts
index 3804eb9f0..6c3414b75 100644
--- a/tools/winscope/src/parsers/surface_flinger/layer_flag.ts
+++ b/tools/winscope/src/trace/surface_flinger/layer_flag.ts
@@ -22,4 +22,7 @@ export enum LayerFlag {
   ENABLE_BACKPRESSURE = 0x100,
   DISPLAY_DECORATION = 0x200,
   IGNORE_DESTINATION_FRAME = 0x400,
+  LAYER_IS_REFRESH_RATE_INDICATOR = 0x800,
+  CAN_OCCLUDE_PRESENTATION = 0x1000,
+  RECOVERABLE_FROM_BUFFER_STUFFING = 0x2000,
 }
diff --git a/tools/winscope/src/parsers/surface_flinger/transform_utils.ts b/tools/winscope/src/trace/surface_flinger/transform_utils.ts
similarity index 100%
rename from tools/winscope/src/parsers/surface_flinger/transform_utils.ts
rename to tools/winscope/src/trace/surface_flinger/transform_utils.ts
diff --git a/tools/winscope/src/trace/trace.ts b/tools/winscope/src/trace/trace.ts
index 2a33360e2..23cb3d209 100644
--- a/tools/winscope/src/trace/trace.ts
+++ b/tools/winscope/src/trace/trace.ts
@@ -14,7 +14,10 @@
  * limitations under the License.
  */
 
-import {ArrayUtils} from 'common/array_utils';
+import {
+  binarySearchFirstGreater,
+  binarySearchFirstGreaterOrEqual,
+} from 'common/array_utils';
 import {assertDefined} from 'common/assert_utils';
 import {INVALID_TIME_NS, Timestamp} from 'common/time/time';
 import {TimestampUtils} from 'common/time/timestamp_utils';
@@ -262,10 +265,7 @@ export class Trace<T> {
     }
 
     const entry = this.clampEntryToSliceBounds(
-      ArrayUtils.binarySearchFirstGreaterOrEqual(
-        this.getFullTraceTimestamps(),
-        time,
-      ),
+      binarySearchFirstGreaterOrEqual(this.getFullTraceTimestamps(), time),
     );
     if (entry === undefined || entry === this.entriesRange.end) {
       return this.getEntry(this.lengthEntries - 1);
@@ -295,10 +295,7 @@ export class Trace<T> {
     }
 
     const pos = this.clampEntryToSliceBounds(
-      ArrayUtils.binarySearchFirstGreaterOrEqual(
-        this.getFullTraceTimestamps(),
-        time,
-      ),
+      binarySearchFirstGreaterOrEqual(this.getFullTraceTimestamps(), time),
     );
     if (pos === undefined || pos === this.entriesRange.end) {
       return undefined;
@@ -318,7 +315,7 @@ export class Trace<T> {
     }
 
     const pos = this.clampEntryToSliceBounds(
-      ArrayUtils.binarySearchFirstGreater(this.getFullTraceTimestamps(), time),
+      binarySearchFirstGreater(this.getFullTraceTimestamps(), time),
     );
     if (pos === undefined || pos === this.entriesRange.end) {
       return undefined;
@@ -384,7 +381,7 @@ export class Trace<T> {
       start === undefined
         ? this.entriesRange.start
         : this.clampEntryToSliceBounds(
-            ArrayUtils.binarySearchFirstGreaterOrEqual(
+            binarySearchFirstGreaterOrEqual(
               this.getFullTraceTimestamps(),
               start,
             ),
@@ -393,10 +390,7 @@ export class Trace<T> {
       end === undefined
         ? this.entriesRange.end
         : this.clampEntryToSliceBounds(
-            ArrayUtils.binarySearchFirstGreaterOrEqual(
-              this.getFullTraceTimestamps(),
-              end,
-            ),
+            binarySearchFirstGreaterOrEqual(this.getFullTraceTimestamps(), end),
           ) ?? this.entriesRange.end;
     const entries: EntriesRange = {
       start: startEntry,
diff --git a/tools/winscope/src/trace/trace_entry_finder_test.ts b/tools/winscope/src/trace/trace_entry_finder_test.ts
index cc0d3b13a..a5829fea8 100644
--- a/tools/winscope/src/trace/trace_entry_finder_test.ts
+++ b/tools/winscope/src/trace/trace_entry_finder_test.ts
@@ -16,13 +16,13 @@
 
 import {TimestampConverterUtils} from 'common/time/test_utils';
 import {TraceBuilder} from 'test/unit/trace_builder';
-import {UnitTestUtils} from 'test/unit/utils';
+import {makeEmptyTrace} from 'test/unit/trace_utils';
 import {TraceEntryFinder} from './trace_entry_finder';
 import {TracePosition} from './trace_position';
 import {TraceType} from './trace_type';
 
 describe('TraceEntryFinder', () => {
-  const emptyTrace = UnitTestUtils.makeEmptyTrace(TraceType.TEST_TRACE_STRING);
+  const emptyTrace = makeEmptyTrace(TraceType.TEST_TRACE_STRING);
   const ts10 = TimestampConverterUtils.makeRealTimestamp(10n);
   const ts14 = TimestampConverterUtils.makeRealTimestamp(14n);
   const ts16 = TimestampConverterUtils.makeRealTimestamp(16n);
diff --git a/tools/winscope/src/trace/trace_rect_builder.ts b/tools/winscope/src/trace/trace_rect_builder.ts
index a56f5e7fe..5159ebed6 100644
--- a/tools/winscope/src/trace/trace_rect_builder.ts
+++ b/tools/winscope/src/trace/trace_rect_builder.ts
@@ -16,7 +16,7 @@
 
 import {Region} from 'common/geometry/region';
 import {TransformMatrix} from 'common/geometry/transform_matrix';
-import {Transform} from 'parsers/surface_flinger/transform_utils';
+import {Transform} from 'trace/surface_flinger/transform_utils';
 import {TraceRect} from './trace_rect';
 
 export class TraceRectBuilder {
@@ -112,8 +112,8 @@ export class TraceRectBuilder {
     return this;
   }
 
-  setFillRegion(region: Region | undefined) {
-    this.fillRegion = region;
+  setFillRegion(value: Region | undefined) {
+    this.fillRegion = value;
     return this;
   }
 
diff --git a/tools/winscope/src/trace/trace_test.ts b/tools/winscope/src/trace/trace_test.ts
index 204b89062..a014dd9dd 100644
--- a/tools/winscope/src/trace/trace_test.ts
+++ b/tools/winscope/src/trace/trace_test.ts
@@ -18,8 +18,12 @@ import {TimestampConverterUtils} from 'common/time/test_utils';
 import {TIME_UNIT_TO_NANO} from 'common/time/time_units';
 import {ParserBuilder} from 'test/unit/parser_builder';
 import {TraceBuilder} from 'test/unit/trace_builder';
-import {TraceUtils} from 'test/unit/trace_utils';
-import {UnitTestUtils} from 'test/unit/utils';
+import {
+  extractEntries,
+  extractFrames,
+  extractTimestamps,
+  makeEmptyTrace,
+} from 'test/unit/trace_utils';
 import {FrameMapBuilder} from './frame_map_builder';
 import {AbsoluteFrameIndex} from './index_types';
 import {Trace} from './trace';
@@ -68,25 +72,25 @@ describe('Trace', () => {
   });
 
   it('getFrame()', async () => {
-    expect(await TraceUtils.extractFrames(trace.getFrame(0))).toEqual(
+    expect(await extractFrames(trace.getFrame(0))).toEqual(
       new Map<AbsoluteFrameIndex, string[]>([[0, ['entry-0']]]),
     );
-    expect(await TraceUtils.extractFrames(trace.getFrame(1))).toEqual(
+    expect(await extractFrames(trace.getFrame(1))).toEqual(
       new Map<AbsoluteFrameIndex, string[]>([[1, ['entry-1', 'entry-2']]]),
     );
-    expect(await TraceUtils.extractFrames(trace.getFrame(2))).toEqual(
+    expect(await extractFrames(trace.getFrame(2))).toEqual(
       new Map<AbsoluteFrameIndex, string[]>([[2, []]]),
     );
-    expect(await TraceUtils.extractFrames(trace.getFrame(3))).toEqual(
+    expect(await extractFrames(trace.getFrame(3))).toEqual(
       new Map<AbsoluteFrameIndex, string[]>([[3, []]]),
     );
-    expect(await TraceUtils.extractFrames(trace.getFrame(4))).toEqual(
+    expect(await extractFrames(trace.getFrame(4))).toEqual(
       new Map<AbsoluteFrameIndex, string[]>([[4, ['entry-3']]]),
     );
-    expect(await TraceUtils.extractFrames(trace.getFrame(5))).toEqual(
+    expect(await extractFrames(trace.getFrame(5))).toEqual(
       new Map<AbsoluteFrameIndex, string[]>([[5, ['entry-3']]]),
     );
-    expect(await TraceUtils.extractFrames(trace.getFrame(6))).toEqual(
+    expect(await extractFrames(trace.getFrame(6))).toEqual(
       new Map<AbsoluteFrameIndex, string[]>([[6, ['entry-4']]]),
     );
   });
@@ -286,80 +290,72 @@ describe('Trace', () => {
 
     // empty
     {
-      expect(await TraceUtils.extractFrames(slice.sliceEntries(1, 1))).toEqual(
+      expect(await extractFrames(slice.sliceEntries(1, 1))).toEqual(
         expectedFramesEmpty,
       );
-      expect(await TraceUtils.extractEntries(slice.sliceEntries(1, 1))).toEqual(
-        [],
-      );
+      expect(await extractEntries(slice.sliceEntries(1, 1))).toEqual([]);
 
-      expect(
-        await TraceUtils.extractFrames(slice.sliceEntries(-1, -1)),
-      ).toEqual(expectedFramesEmpty);
-      expect(
-        await TraceUtils.extractEntries(slice.sliceEntries(-1, -1)),
-      ).toEqual([]);
-
-      expect(await TraceUtils.extractFrames(slice.sliceEntries(2, 1))).toEqual(
+      expect(await extractFrames(slice.sliceEntries(-1, -1))).toEqual(
         expectedFramesEmpty,
       );
-      expect(await TraceUtils.extractEntries(slice.sliceEntries(2, 1))).toEqual(
-        [],
+      expect(await extractEntries(slice.sliceEntries(-1, -1))).toEqual([]);
+
+      expect(await extractFrames(slice.sliceEntries(2, 1))).toEqual(
+        expectedFramesEmpty,
       );
+      expect(await extractEntries(slice.sliceEntries(2, 1))).toEqual([]);
 
-      expect(
-        await TraceUtils.extractFrames(slice.sliceEntries(-1, -2)),
-      ).toEqual(expectedFramesEmpty);
-      expect(
-        await TraceUtils.extractEntries(slice.sliceEntries(-1, -2)),
-      ).toEqual([]);
+      expect(await extractFrames(slice.sliceEntries(-1, -2))).toEqual(
+        expectedFramesEmpty,
+      );
+      expect(await extractEntries(slice.sliceEntries(-1, -2))).toEqual([]);
     }
 
     // full
     {
-      expect(await TraceUtils.extractEntries(slice.sliceEntries())).toEqual(
+      expect(await extractEntries(slice.sliceEntries())).toEqual(
         expectedEntriesFull,
       );
-      expect(await TraceUtils.extractFrames(slice.sliceEntries())).toEqual(
+      expect(await extractFrames(slice.sliceEntries())).toEqual(
         expectedFramesFull,
       );
 
-      expect(await TraceUtils.extractEntries(slice.sliceEntries(0))).toEqual(
+      expect(await extractEntries(slice.sliceEntries(0))).toEqual(
         expectedEntriesFull,
       );
-      expect(await TraceUtils.extractFrames(slice.sliceEntries(0))).toEqual(
+      expect(await extractFrames(slice.sliceEntries(0))).toEqual(
         expectedFramesFull,
       );
 
-      expect(await TraceUtils.extractEntries(slice.sliceEntries(0, 3))).toEqual(
+      expect(await extractEntries(slice.sliceEntries(0, 3))).toEqual(
         expectedEntriesFull,
       );
-      expect(await TraceUtils.extractFrames(slice.sliceEntries(0, 3))).toEqual(
+      expect(await extractFrames(slice.sliceEntries(0, 3))).toEqual(
         expectedFramesFull,
       );
 
-      expect(await TraceUtils.extractEntries(slice.sliceEntries(-3))).toEqual(
+      expect(await extractEntries(slice.sliceEntries(-3))).toEqual(
         expectedEntriesFull,
       );
-      expect(await TraceUtils.extractFrames(slice.sliceEntries(-3))).toEqual(
+      expect(await extractFrames(slice.sliceEntries(-3))).toEqual(
         expectedFramesFull,
       );
 
-      expect(
-        await TraceUtils.extractEntries(slice.sliceEntries(-3, 3)),
-      ).toEqual(expectedEntriesFull);
-      expect(await TraceUtils.extractFrames(slice.sliceEntries(-3, 3))).toEqual(
+      expect(await extractEntries(slice.sliceEntries(-3, 3))).toEqual(
+        expectedEntriesFull,
+      );
+      expect(await extractFrames(slice.sliceEntries(-3, 3))).toEqual(
         expectedFramesFull,
       );
     }
 
     // slice away front (positive index)
     {
-      expect(await TraceUtils.extractEntries(slice.sliceEntries(1))).toEqual([
+      expect(await extractEntries(slice.sliceEntries(1))).toEqual([
         'entry-2',
         'entry-3',
       ]);
-      expect(await TraceUtils.extractFrames(slice.sliceEntries(1))).toEqual(
+      expect(await extractFrames(slice.sliceEntries(1))).toEqual(
         new Map<AbsoluteFrameIndex, string[]>([
           [1, ['entry-2']],
           [2, []],
@@ -369,52 +365,44 @@ describe('Trace', () => {
         ]),
       );
 
-      expect(await TraceUtils.extractEntries(slice.sliceEntries(2))).toEqual([
-        'entry-3',
-      ]);
-      expect(await TraceUtils.extractFrames(slice.sliceEntries(2))).toEqual(
+      expect(await extractEntries(slice.sliceEntries(2))).toEqual(['entry-3']);
+      expect(await extractFrames(slice.sliceEntries(2))).toEqual(
         new Map<AbsoluteFrameIndex, string[]>([
           [4, ['entry-3']],
           [5, ['entry-3']],
         ]),
       );
 
-      expect(await TraceUtils.extractEntries(slice.sliceEntries(3))).toEqual(
-        [],
-      );
-      expect(await TraceUtils.extractFrames(slice.sliceEntries(3))).toEqual(
+      expect(await extractEntries(slice.sliceEntries(3))).toEqual([]);
+      expect(await extractFrames(slice.sliceEntries(3))).toEqual(
         expectedFramesEmpty,
       );
 
-      expect(await TraceUtils.extractEntries(slice.sliceEntries(4))).toEqual(
-        [],
-      );
-      expect(await TraceUtils.extractFrames(slice.sliceEntries(4))).toEqual(
+      expect(await extractEntries(slice.sliceEntries(4))).toEqual([]);
+      expect(await extractFrames(slice.sliceEntries(4))).toEqual(
         expectedFramesEmpty,
       );
 
-      expect(
-        await TraceUtils.extractEntries(slice.sliceEntries(1000000)),
-      ).toEqual([]);
-      expect(
-        await TraceUtils.extractFrames(slice.sliceEntries(1000000)),
-      ).toEqual(expectedFramesEmpty);
+      expect(await extractEntries(slice.sliceEntries(1000000))).toEqual([]);
+      expect(await extractFrames(slice.sliceEntries(1000000))).toEqual(
+        expectedFramesEmpty,
+      );
     }
 
     // slice away front (negative index)
     {
-      expect(await TraceUtils.extractEntries(slice.sliceEntries(-3))).toEqual(
+      expect(await extractEntries(slice.sliceEntries(-3))).toEqual(
         expectedEntriesFull,
       );
-      expect(await TraceUtils.extractFrames(slice.sliceEntries(-3))).toEqual(
+      expect(await extractFrames(slice.sliceEntries(-3))).toEqual(
         expectedFramesFull,
       );
 
-      expect(await TraceUtils.extractEntries(slice.sliceEntries(-2))).toEqual([
+      expect(await extractEntries(slice.sliceEntries(-2))).toEqual([
         'entry-2',
         'entry-3',
       ]);
-      expect(await TraceUtils.extractFrames(slice.sliceEntries(-2))).toEqual(
+      expect(await extractFrames(slice.sliceEntries(-2))).toEqual(
         new Map<AbsoluteFrameIndex, string[]>([
           [1, ['entry-2']],
           [2, []],
@@ -424,10 +412,8 @@ describe('Trace', () => {
         ]),
       );
 
-      expect(await TraceUtils.extractEntries(slice.sliceEntries(-1))).toEqual([
-        'entry-3',
-      ]);
-      expect(await TraceUtils.extractFrames(slice.sliceEntries(-1))).toEqual(
+      expect(await extractEntries(slice.sliceEntries(-1))).toEqual(['entry-3']);
+      expect(await extractFrames(slice.sliceEntries(-1))).toEqual(
         new Map<AbsoluteFrameIndex, string[]>([
           [4, ['entry-3']],
           [5, ['entry-3']],
@@ -437,69 +423,65 @@ describe('Trace', () => {
 
     // slice away back (positive index)
     {
-      expect(
-        await TraceUtils.extractEntries(slice.sliceEntries(undefined, 2)),
-      ).toEqual(['entry-1', 'entry-2']);
-      expect(
-        await TraceUtils.extractFrames(slice.sliceEntries(undefined, 2)),
-      ).toEqual(
+      expect(await extractEntries(slice.sliceEntries(undefined, 2))).toEqual([
+        'entry-1',
+        'entry-2',
+      ]);
+      expect(await extractFrames(slice.sliceEntries(undefined, 2))).toEqual(
         new Map<AbsoluteFrameIndex, string[]>([[1, ['entry-1', 'entry-2']]]),
       );
 
-      expect(
-        await TraceUtils.extractEntries(slice.sliceEntries(undefined, 1)),
-      ).toEqual(['entry-1']);
-      expect(
-        await TraceUtils.extractFrames(slice.sliceEntries(undefined, 1)),
-      ).toEqual(new Map<AbsoluteFrameIndex, string[]>([[1, ['entry-1']]]));
+      expect(await extractEntries(slice.sliceEntries(undefined, 1))).toEqual([
+        'entry-1',
+      ]);
+      expect(await extractFrames(slice.sliceEntries(undefined, 1))).toEqual(
+        new Map<AbsoluteFrameIndex, string[]>([[1, ['entry-1']]]),
+      );
 
-      expect(
-        await TraceUtils.extractEntries(slice.sliceEntries(undefined, 0)),
-      ).toEqual([]);
-      expect(
-        await TraceUtils.extractFrames(slice.sliceEntries(undefined, 0)),
-      ).toEqual(expectedFramesEmpty);
+      expect(await extractEntries(slice.sliceEntries(undefined, 0))).toEqual(
+        [],
+      );
+      expect(await extractFrames(slice.sliceEntries(undefined, 0))).toEqual(
+        expectedFramesEmpty,
+      );
     }
 
     // slice away back (negative index)
     {
-      expect(
-        await TraceUtils.extractEntries(slice.sliceEntries(undefined, -1)),
-      ).toEqual(['entry-1', 'entry-2']);
-      expect(
-        await TraceUtils.extractFrames(slice.sliceEntries(undefined, -1)),
-      ).toEqual(
+      expect(await extractEntries(slice.sliceEntries(undefined, -1))).toEqual([
+        'entry-1',
+        'entry-2',
+      ]);
+      expect(await extractFrames(slice.sliceEntries(undefined, -1))).toEqual(
         new Map<AbsoluteFrameIndex, string[]>([[1, ['entry-1', 'entry-2']]]),
       );
 
-      expect(
-        await TraceUtils.extractEntries(slice.sliceEntries(undefined, -2)),
-      ).toEqual(['entry-1']);
-      expect(
-        await TraceUtils.extractFrames(slice.sliceEntries(undefined, -2)),
-      ).toEqual(new Map<AbsoluteFrameIndex, string[]>([[1, ['entry-1']]]));
+      expect(await extractEntries(slice.sliceEntries(undefined, -2))).toEqual([
+        'entry-1',
+      ]);
+      expect(await extractFrames(slice.sliceEntries(undefined, -2))).toEqual(
+        new Map<AbsoluteFrameIndex, string[]>([[1, ['entry-1']]]),
+      );
 
-      expect(
-        await TraceUtils.extractEntries(slice.sliceEntries(undefined, -3)),
-      ).toEqual([]);
-      expect(
-        await TraceUtils.extractFrames(slice.sliceEntries(undefined, -3)),
-      ).toEqual(expectedFramesEmpty);
+      expect(await extractEntries(slice.sliceEntries(undefined, -3))).toEqual(
+        [],
+      );
+      expect(await extractFrames(slice.sliceEntries(undefined, -3))).toEqual(
+        expectedFramesEmpty,
+      );
 
-      expect(
-        await TraceUtils.extractEntries(slice.sliceEntries(undefined, -4)),
-      ).toEqual([]);
-      expect(
-        await TraceUtils.extractFrames(slice.sliceEntries(undefined, -4)),
-      ).toEqual(expectedFramesEmpty);
+      expect(await extractEntries(slice.sliceEntries(undefined, -4))).toEqual(
+        [],
+      );
+      expect(await extractFrames(slice.sliceEntries(undefined, -4))).toEqual(
+        expectedFramesEmpty,
+      );
 
       expect(
-        await TraceUtils.extractEntries(
-          slice.sliceEntries(undefined, -1000000),
-        ),
+        await extractEntries(slice.sliceEntries(undefined, -1000000)),
       ).toEqual([]);
       expect(
-        await TraceUtils.extractFrames(slice.sliceEntries(undefined, -1000000)),
+        await extractFrames(slice.sliceEntries(undefined, -1000000)),
       ).toEqual(expectedFramesEmpty);
     }
   });
@@ -520,102 +502,88 @@ describe('Trace', () => {
 
     // empty
     {
-      expect(
-        await TraceUtils.extractEntries(slice.sliceTime(time11, time11)),
-      ).toEqual([]);
-      expect(
-        await TraceUtils.extractFrames(slice.sliceTime(time11, time11)),
-      ).toEqual(expectedFramesEmpty);
+      expect(await extractEntries(slice.sliceTime(time11, time11))).toEqual([]);
+      expect(await extractFrames(slice.sliceTime(time11, time11))).toEqual(
+        expectedFramesEmpty,
+      );
 
-      expect(
-        await TraceUtils.extractEntries(slice.sliceTime(time11, time10)),
-      ).toEqual([]);
-      expect(
-        await TraceUtils.extractFrames(slice.sliceTime(time11, time10)),
-      ).toEqual(expectedFramesEmpty);
+      expect(await extractEntries(slice.sliceTime(time11, time10))).toEqual([]);
+      expect(await extractFrames(slice.sliceTime(time11, time10))).toEqual(
+        expectedFramesEmpty,
+      );
 
-      expect(
-        await TraceUtils.extractEntries(slice.sliceTime(time9, time10)),
-      ).toEqual([]);
-      expect(
-        await TraceUtils.extractFrames(slice.sliceTime(time9, time10)),
-      ).toEqual(expectedFramesEmpty);
+      expect(await extractEntries(slice.sliceTime(time9, time10))).toEqual([]);
+      expect(await extractFrames(slice.sliceTime(time9, time10))).toEqual(
+        expectedFramesEmpty,
+      );
 
-      expect(
-        await TraceUtils.extractEntries(slice.sliceTime(time10, time9)),
-      ).toEqual([]);
-      expect(
-        await TraceUtils.extractFrames(slice.sliceTime(time10, time9)),
-      ).toEqual(expectedFramesEmpty);
+      expect(await extractEntries(slice.sliceTime(time10, time9))).toEqual([]);
+      expect(await extractFrames(slice.sliceTime(time10, time9))).toEqual(
+        expectedFramesEmpty,
+      );
 
-      expect(
-        await TraceUtils.extractEntries(slice.sliceTime(time14, time15)),
-      ).toEqual([]);
-      expect(
-        await TraceUtils.extractFrames(slice.sliceTime(time14, time15)),
-      ).toEqual(expectedFramesEmpty);
+      expect(await extractEntries(slice.sliceTime(time14, time15))).toEqual([]);
+      expect(await extractFrames(slice.sliceTime(time14, time15))).toEqual(
+        expectedFramesEmpty,
+      );
 
-      expect(
-        await TraceUtils.extractEntries(slice.sliceTime(time15, time14)),
-      ).toEqual([]);
-      expect(
-        await TraceUtils.extractFrames(slice.sliceTime(time15, time14)),
-      ).toEqual(expectedFramesEmpty);
+      expect(await extractEntries(slice.sliceTime(time15, time14))).toEqual([]);
+      expect(await extractFrames(slice.sliceTime(time15, time14))).toEqual(
+        expectedFramesEmpty,
+      );
     }
 
     // full
     {
-      expect(await TraceUtils.extractEntries(slice.sliceTime())).toEqual(
+      expect(await extractEntries(slice.sliceTime())).toEqual(
         expectedEntriesFull,
       );
-      expect(await TraceUtils.extractFrames(slice.sliceTime())).toEqual(
+      expect(await extractFrames(slice.sliceTime())).toEqual(
         expectedFramesFull,
       );
 
-      expect(await TraceUtils.extractEntries(slice.sliceTime(time9))).toEqual(
+      expect(await extractEntries(slice.sliceTime(time9))).toEqual(
         expectedEntriesFull,
       );
-      expect(await TraceUtils.extractFrames(slice.sliceTime(time9))).toEqual(
+      expect(await extractFrames(slice.sliceTime(time9))).toEqual(
         expectedFramesFull,
       );
 
-      expect(await TraceUtils.extractEntries(slice.sliceTime(time10))).toEqual(
+      expect(await extractEntries(slice.sliceTime(time10))).toEqual(
         expectedEntriesFull,
       );
-      expect(await TraceUtils.extractFrames(slice.sliceTime(time10))).toEqual(
+      expect(await extractFrames(slice.sliceTime(time10))).toEqual(
         expectedFramesFull,
       );
 
-      expect(
-        await TraceUtils.extractEntries(slice.sliceTime(undefined, time14)),
-      ).toEqual(expectedEntriesFull);
-      expect(
-        await TraceUtils.extractFrames(slice.sliceTime(undefined, time14)),
-      ).toEqual(expectedFramesFull);
+      expect(await extractEntries(slice.sliceTime(undefined, time14))).toEqual(
+        expectedEntriesFull,
+      );
+      expect(await extractFrames(slice.sliceTime(undefined, time14))).toEqual(
+        expectedFramesFull,
+      );
 
-      expect(
-        await TraceUtils.extractEntries(slice.sliceTime(undefined, time15)),
-      ).toEqual(expectedEntriesFull);
-      expect(
-        await TraceUtils.extractFrames(slice.sliceTime(undefined, time15)),
-      ).toEqual(expectedFramesFull);
+      expect(await extractEntries(slice.sliceTime(undefined, time15))).toEqual(
+        expectedEntriesFull,
+      );
+      expect(await extractFrames(slice.sliceTime(undefined, time15))).toEqual(
+        expectedFramesFull,
+      );
 
-      expect(
-        await TraceUtils.extractEntries(slice.sliceTime(time10, time14)),
-      ).toEqual(expectedEntriesFull);
-      expect(
-        await TraceUtils.extractFrames(slice.sliceTime(time10, time14)),
-      ).toEqual(expectedFramesFull);
+      expect(await extractEntries(slice.sliceTime(time10, time14))).toEqual(
+        expectedEntriesFull,
+      );
+      expect(await extractFrames(slice.sliceTime(time10, time14))).toEqual(
+        expectedFramesFull,
+      );
     }
 
     // middle
     {
-      expect(
-        await TraceUtils.extractEntries(slice.sliceTime(time12, time13)),
-      ).toEqual(['entry-3']);
-      expect(
-        await TraceUtils.extractFrames(slice.sliceTime(time12, time13)),
-      ).toEqual(
+      expect(await extractEntries(slice.sliceTime(time12, time13))).toEqual([
+        'entry-3',
+      ]);
+      expect(await extractFrames(slice.sliceTime(time12, time13))).toEqual(
         new Map<AbsoluteFrameIndex, string[]>([
           [4, ['entry-3']],
           [5, ['entry-3']],
@@ -625,69 +593,62 @@ describe('Trace', () => {
 
     // slice away front
     {
-      expect(await TraceUtils.extractEntries(slice.sliceTime(time12))).toEqual([
+      expect(await extractEntries(slice.sliceTime(time12))).toEqual([
         'entry-3',
       ]);
-      expect(await TraceUtils.extractFrames(slice.sliceTime(time12))).toEqual(
+      expect(await extractFrames(slice.sliceTime(time12))).toEqual(
         new Map<AbsoluteFrameIndex, string[]>([
           [4, ['entry-3']],
           [5, ['entry-3']],
         ]),
       );
 
-      expect(await TraceUtils.extractEntries(slice.sliceTime(time13))).toEqual(
-        [],
-      );
-      expect(await TraceUtils.extractFrames(slice.sliceTime(time13))).toEqual(
+      expect(await extractEntries(slice.sliceTime(time13))).toEqual([]);
+      expect(await extractFrames(slice.sliceTime(time13))).toEqual(
         expectedFramesEmpty,
       );
 
-      expect(await TraceUtils.extractEntries(slice.sliceTime(time14))).toEqual(
-        [],
-      );
-      expect(await TraceUtils.extractFrames(slice.sliceTime(time14))).toEqual(
+      expect(await extractEntries(slice.sliceTime(time14))).toEqual([]);
+      expect(await extractFrames(slice.sliceTime(time14))).toEqual(
         expectedFramesEmpty,
       );
 
-      expect(await TraceUtils.extractEntries(slice.sliceTime(time15))).toEqual(
-        [],
-      );
-      expect(await TraceUtils.extractFrames(slice.sliceTime(time15))).toEqual(
+      expect(await extractEntries(slice.sliceTime(time15))).toEqual([]);
+      expect(await extractFrames(slice.sliceTime(time15))).toEqual(
         expectedFramesEmpty,
       );
     }
 
     // slice away back
     {
-      expect(
-        await TraceUtils.extractEntries(slice.sliceTime(undefined, time12)),
-      ).toEqual(['entry-1', 'entry-2']);
-      expect(
-        await TraceUtils.extractFrames(slice.sliceTime(undefined, time12)),
-      ).toEqual(
+      expect(await extractEntries(slice.sliceTime(undefined, time12))).toEqual([
+        'entry-1',
+        'entry-2',
+      ]);
+      expect(await extractFrames(slice.sliceTime(undefined, time12))).toEqual(
         new Map<AbsoluteFrameIndex, string[]>([[1, ['entry-1', 'entry-2']]]),
       );
 
-      expect(
-        await TraceUtils.extractEntries(slice.sliceTime(undefined, time11)),
-      ).toEqual([]);
-      expect(
-        await TraceUtils.extractFrames(slice.sliceTime(undefined, time11)),
-      ).toEqual(expectedFramesEmpty);
+      expect(await extractEntries(slice.sliceTime(undefined, time11))).toEqual(
+        [],
+      );
+      expect(await extractFrames(slice.sliceTime(undefined, time11))).toEqual(
+        expectedFramesEmpty,
+      );
 
-      expect(
-        await TraceUtils.extractEntries(slice.sliceTime(undefined, time10)),
-      ).toEqual([]);
-      expect(
-        await TraceUtils.extractFrames(slice.sliceTime(undefined, time10)),
-      ).toEqual(expectedFramesEmpty);
+      expect(await extractEntries(slice.sliceTime(undefined, time10))).toEqual(
+        [],
+      );
+      expect(await extractFrames(slice.sliceTime(undefined, time10))).toEqual(
+        expectedFramesEmpty,
+      );
 
-      expect(
-        await TraceUtils.extractEntries(slice.sliceTime(undefined, time9)),
-      ).toEqual([]);
-      expect(
-        await TraceUtils.extractFrames(slice.sliceTime(undefined, time9)),
-      ).toEqual(expectedFramesEmpty);
+      expect(await extractEntries(slice.sliceTime(undefined, time9))).toEqual(
+        [],
+      );
+      expect(await extractFrames(slice.sliceTime(undefined, time9))).toEqual(
+        expectedFramesEmpty,
+      );
     }
   });
 
@@ -699,47 +660,43 @@ describe('Trace', () => {
     {
       const expectedEntries = new Array<string>();
       const expectedFrames = new Map<AbsoluteFrameIndex, string[]>([]);
-      expect(await TraceUtils.extractEntries(slice.sliceFrames(1, 1))).toEqual(
+      expect(await extractEntries(slice.sliceFrames(1, 1))).toEqual(
         expectedEntries,
       );
-      expect(await TraceUtils.extractFrames(slice.sliceFrames(1, 1))).toEqual(
+      expect(await extractFrames(slice.sliceFrames(1, 1))).toEqual(
         expectedFrames,
       );
-      expect(await TraceUtils.extractEntries(slice.sliceFrames(5, 1))).toEqual(
+      expect(await extractEntries(slice.sliceFrames(5, 1))).toEqual(
         expectedEntries,
       );
-      expect(await TraceUtils.extractFrames(slice.sliceFrames(5, 1))).toEqual(
+      expect(await extractFrames(slice.sliceFrames(5, 1))).toEqual(
         expectedFrames,
       );
-      expect(await TraceUtils.extractEntries(slice.sliceFrames(3, 2))).toEqual(
+      expect(await extractEntries(slice.sliceFrames(3, 2))).toEqual(
         expectedEntries,
       );
-      expect(await TraceUtils.extractFrames(slice.sliceFrames(3, 2))).toEqual(
+      expect(await extractFrames(slice.sliceFrames(3, 2))).toEqual(
         expectedFrames,
       );
     }
 
     // middle
     {
-      expect(await TraceUtils.extractEntries(slice.sliceFrames(2, 3))).toEqual(
-        [],
-      );
-      expect(await TraceUtils.extractFrames(slice.sliceFrames(2, 3))).toEqual(
+      expect(await extractEntries(slice.sliceFrames(2, 3))).toEqual([]);
+      expect(await extractFrames(slice.sliceFrames(2, 3))).toEqual(
         new Map<AbsoluteFrameIndex, string[]>([[2, []]]),
       );
-      expect(await TraceUtils.extractEntries(slice.sliceFrames(2, 4))).toEqual(
-        [],
-      );
-      expect(await TraceUtils.extractFrames(slice.sliceFrames(2, 4))).toEqual(
+      expect(await extractEntries(slice.sliceFrames(2, 4))).toEqual([]);
+      expect(await extractFrames(slice.sliceFrames(2, 4))).toEqual(
         new Map<AbsoluteFrameIndex, string[]>([
           [2, []],
           [3, []],
         ]),
       );
-      expect(await TraceUtils.extractEntries(slice.sliceFrames(2, 5))).toEqual([
+      expect(await extractEntries(slice.sliceFrames(2, 5))).toEqual([
         'entry-3',
       ]);
-      expect(await TraceUtils.extractFrames(slice.sliceFrames(2, 5))).toEqual(
+      expect(await extractFrames(slice.sliceFrames(2, 5))).toEqual(
         new Map<AbsoluteFrameIndex, string[]>([
           [2, []],
           [3, []],
@@ -758,44 +715,38 @@ describe('Trace', () => {
         [4, ['entry-3']],
         [5, ['entry-3']],
       ]);
-      expect(await TraceUtils.extractEntries(slice.sliceFrames())).toEqual(
+      expect(await extractEntries(slice.sliceFrames())).toEqual(
         expectedEntries,
       );
-      expect(await TraceUtils.extractFrames(slice.sliceFrames())).toEqual(
-        expectedFrames,
+      expect(await extractFrames(slice.sliceFrames())).toEqual(expectedFrames);
+      expect(await extractEntries(slice.sliceFrames(0))).toEqual(
+        expectedEntries,
       );
-      expect(await TraceUtils.extractEntries(slice.sliceFrames(0))).toEqual(
+      expect(await extractFrames(slice.sliceFrames(0))).toEqual(expectedFrames);
+      expect(await extractEntries(slice.sliceFrames(undefined, 6))).toEqual(
         expectedEntries,
       );
-      expect(await TraceUtils.extractFrames(slice.sliceFrames(0))).toEqual(
+      expect(await extractFrames(slice.sliceFrames(undefined, 6))).toEqual(
         expectedFrames,
       );
-      expect(
-        await TraceUtils.extractEntries(slice.sliceFrames(undefined, 6)),
-      ).toEqual(expectedEntries);
-      expect(
-        await TraceUtils.extractFrames(slice.sliceFrames(undefined, 6)),
-      ).toEqual(expectedFrames);
-      expect(await TraceUtils.extractEntries(slice.sliceFrames(1, 6))).toEqual(
+      expect(await extractEntries(slice.sliceFrames(1, 6))).toEqual(
         expectedEntries,
       );
-      expect(await TraceUtils.extractFrames(slice.sliceFrames(1, 6))).toEqual(
+      expect(await extractFrames(slice.sliceFrames(1, 6))).toEqual(
         expectedFrames,
       );
-      expect(await TraceUtils.extractEntries(slice.sliceFrames(0, 7))).toEqual(
+      expect(await extractEntries(slice.sliceFrames(0, 7))).toEqual(
         expectedEntries,
       );
-      expect(await TraceUtils.extractFrames(slice.sliceFrames(0, 7))).toEqual(
+      expect(await extractFrames(slice.sliceFrames(0, 7))).toEqual(
         expectedFrames,
       );
     }
 
     // slice away front
     {
-      expect(await TraceUtils.extractEntries(slice.sliceFrames(2))).toEqual([
-        'entry-3',
-      ]);
-      expect(await TraceUtils.extractFrames(slice.sliceFrames(2))).toEqual(
+      expect(await extractEntries(slice.sliceFrames(2))).toEqual(['entry-3']);
+      expect(await extractFrames(slice.sliceFrames(2))).toEqual(
         new Map<AbsoluteFrameIndex, string[]>([
           [2, []],
           [3, []],
@@ -803,41 +754,35 @@ describe('Trace', () => {
           [5, ['entry-3']],
         ]),
       );
-      expect(await TraceUtils.extractEntries(slice.sliceFrames(4))).toEqual([
-        'entry-3',
-      ]);
-      expect(await TraceUtils.extractFrames(slice.sliceFrames(4))).toEqual(
+      expect(await extractEntries(slice.sliceFrames(4))).toEqual(['entry-3']);
+      expect(await extractFrames(slice.sliceFrames(4))).toEqual(
         new Map<AbsoluteFrameIndex, string[]>([
           [4, ['entry-3']],
           [5, ['entry-3']],
         ]),
       );
-      expect(await TraceUtils.extractEntries(slice.sliceFrames(5))).toEqual([
-        'entry-3',
-      ]);
-      expect(await TraceUtils.extractFrames(slice.sliceFrames(5))).toEqual(
+      expect(await extractEntries(slice.sliceFrames(5))).toEqual(['entry-3']);
+      expect(await extractFrames(slice.sliceFrames(5))).toEqual(
         new Map<AbsoluteFrameIndex, string[]>([[5, ['entry-3']]]),
       );
-      expect(await TraceUtils.extractEntries(slice.sliceFrames(6))).toEqual([]);
-      expect(await TraceUtils.extractFrames(slice.sliceFrames(6))).toEqual(
+      expect(await extractEntries(slice.sliceFrames(6))).toEqual([]);
+      expect(await extractFrames(slice.sliceFrames(6))).toEqual(
         new Map<AbsoluteFrameIndex, string[]>([]),
       );
-      expect(await TraceUtils.extractEntries(slice.sliceFrames(1000))).toEqual(
-        [],
-      );
-      expect(await TraceUtils.extractFrames(slice.sliceFrames(1000))).toEqual(
+      expect(await extractEntries(slice.sliceFrames(1000))).toEqual([]);
+      expect(await extractFrames(slice.sliceFrames(1000))).toEqual(
         new Map<AbsoluteFrameIndex, string[]>([]),
       );
     }
 
     // slice away back
     {
-      expect(
-        await TraceUtils.extractEntries(slice.sliceFrames(undefined, 6)),
-      ).toEqual(['entry-1', 'entry-2', 'entry-3']);
-      expect(
-        await TraceUtils.extractFrames(slice.sliceFrames(undefined, 6)),
-      ).toEqual(
+      expect(await extractEntries(slice.sliceFrames(undefined, 6))).toEqual([
+        'entry-1',
+        'entry-2',
+        'entry-3',
+      ]);
+      expect(await extractFrames(slice.sliceFrames(undefined, 6))).toEqual(
         new Map<AbsoluteFrameIndex, string[]>([
           [1, ['entry-1', 'entry-2']],
           [2, []],
@@ -846,12 +791,12 @@ describe('Trace', () => {
           [5, ['entry-3']],
         ]),
       );
-      expect(
-        await TraceUtils.extractEntries(slice.sliceFrames(undefined, 5)),
-      ).toEqual(['entry-1', 'entry-2', 'entry-3']);
-      expect(
-        await TraceUtils.extractFrames(slice.sliceFrames(undefined, 5)),
-      ).toEqual(
+      expect(await extractEntries(slice.sliceFrames(undefined, 5))).toEqual([
+        'entry-1',
+        'entry-2',
+        'entry-3',
+      ]);
+      expect(await extractFrames(slice.sliceFrames(undefined, 5))).toEqual(
         new Map<AbsoluteFrameIndex, string[]>([
           [1, ['entry-1', 'entry-2']],
           [2, []],
@@ -859,81 +804,76 @@ describe('Trace', () => {
           [4, ['entry-3']],
         ]),
       );
-      expect(
-        await TraceUtils.extractEntries(slice.sliceFrames(undefined, 4)),
-      ).toEqual(['entry-1', 'entry-2']);
-      expect(
-        await TraceUtils.extractFrames(slice.sliceFrames(undefined, 4)),
-      ).toEqual(
+      expect(await extractEntries(slice.sliceFrames(undefined, 4))).toEqual([
+        'entry-1',
+        'entry-2',
+      ]);
+      expect(await extractFrames(slice.sliceFrames(undefined, 4))).toEqual(
         new Map<AbsoluteFrameIndex, string[]>([
           [1, ['entry-1', 'entry-2']],
           [2, []],
           [3, []],
         ]),
       );
-      expect(
-        await TraceUtils.extractEntries(slice.sliceFrames(undefined, 3)),
-      ).toEqual(['entry-1', 'entry-2']);
-      expect(
-        await TraceUtils.extractFrames(slice.sliceFrames(undefined, 3)),
-      ).toEqual(
+      expect(await extractEntries(slice.sliceFrames(undefined, 3))).toEqual([
+        'entry-1',
+        'entry-2',
+      ]);
+      expect(await extractFrames(slice.sliceFrames(undefined, 3))).toEqual(
         new Map<AbsoluteFrameIndex, string[]>([
           [1, ['entry-1', 'entry-2']],
           [2, []],
         ]),
       );
-      expect(
-        await TraceUtils.extractEntries(slice.sliceFrames(undefined, 2)),
-      ).toEqual(['entry-1', 'entry-2']);
-      expect(
-        await TraceUtils.extractFrames(slice.sliceFrames(undefined, 2)),
-      ).toEqual(
+      expect(await extractEntries(slice.sliceFrames(undefined, 2))).toEqual([
+        'entry-1',
+        'entry-2',
+      ]);
+      expect(await extractFrames(slice.sliceFrames(undefined, 2))).toEqual(
         new Map<AbsoluteFrameIndex, string[]>([[1, ['entry-1', 'entry-2']]]),
       );
-      expect(
-        await TraceUtils.extractEntries(slice.sliceFrames(undefined, 1)),
-      ).toEqual([]);
-      expect(
-        await TraceUtils.extractFrames(slice.sliceFrames(undefined, 1)),
-      ).toEqual(new Map<AbsoluteFrameIndex, string[]>());
-      expect(
-        await TraceUtils.extractEntries(slice.sliceFrames(undefined, 0)),
-      ).toEqual([]);
-      expect(
-        await TraceUtils.extractFrames(slice.sliceFrames(undefined, 0)),
-      ).toEqual(new Map<AbsoluteFrameIndex, string[]>());
+      expect(await extractEntries(slice.sliceFrames(undefined, 1))).toEqual([]);
+      expect(await extractFrames(slice.sliceFrames(undefined, 1))).toEqual(
+        new Map<AbsoluteFrameIndex, string[]>(),
+      );
+      expect(await extractEntries(slice.sliceFrames(undefined, 0))).toEqual([]);
+      expect(await extractFrames(slice.sliceFrames(undefined, 0))).toEqual(
+        new Map<AbsoluteFrameIndex, string[]>(),
+      );
     }
   });
 
   it('can slice full trace', async () => {
     // entries
-    expect(await TraceUtils.extractEntries(trace.sliceEntries(1, 1))).toEqual(
-      [],
-    );
-    expect(await TraceUtils.extractEntries(trace.sliceEntries())).toEqual([
+    expect(await extractEntries(trace.sliceEntries(1, 1))).toEqual([]);
+    expect(await extractEntries(trace.sliceEntries())).toEqual([
       'entry-0',
       'entry-1',
       'entry-2',
       'entry-3',
       'entry-4',
     ]);
-    expect(await TraceUtils.extractEntries(trace.sliceEntries(2))).toEqual([
+    expect(await extractEntries(trace.sliceEntries(2))).toEqual([
       'entry-2',
       'entry-3',
       'entry-4',
     ]);
-    expect(await TraceUtils.extractEntries(trace.sliceEntries(-3))).toEqual([
+    expect(await extractEntries(trace.sliceEntries(-3))).toEqual([
       'entry-2',
       'entry-3',
       'entry-4',
     ]);
-    expect(
-      await TraceUtils.extractEntries(trace.sliceEntries(undefined, 3)),
-    ).toEqual(['entry-0', 'entry-1', 'entry-2']);
-    expect(
-      await TraceUtils.extractEntries(trace.sliceEntries(undefined, -2)),
-    ).toEqual(['entry-0', 'entry-1', 'entry-2']);
-    expect(await TraceUtils.extractEntries(trace.sliceEntries(1, 4))).toEqual([
+    expect(await extractEntries(trace.sliceEntries(undefined, 3))).toEqual([
+      'entry-0',
+      'entry-1',
+      'entry-2',
+    ]);
+    expect(await extractEntries(trace.sliceEntries(undefined, -2))).toEqual([
+      'entry-0',
+      'entry-1',
+      'entry-2',
+    ]);
+    expect(await extractEntries(trace.sliceEntries(1, 4))).toEqual([
       'entry-1',
       'entry-2',
       'entry-3',
@@ -942,81 +882,72 @@ describe('Trace', () => {
     // time
     const time12 = TimestampConverterUtils.makeRealTimestamp(12n);
     const time13 = TimestampConverterUtils.makeRealTimestamp(13n);
-    expect(
-      await TraceUtils.extractEntries(trace.sliceTime(time12, time12)),
-    ).toEqual([]);
-    expect(await TraceUtils.extractEntries(trace.sliceTime())).toEqual([
+    expect(await extractEntries(trace.sliceTime(time12, time12))).toEqual([]);
+    expect(await extractEntries(trace.sliceTime())).toEqual([
       'entry-0',
       'entry-1',
       'entry-2',
       'entry-3',
       'entry-4',
     ]);
-    expect(
-      await TraceUtils.extractEntries(trace.sliceTime(time12, time13)),
-    ).toEqual(['entry-3']);
-    expect(await TraceUtils.extractEntries(trace.sliceTime(time12))).toEqual([
+    expect(await extractEntries(trace.sliceTime(time12, time13))).toEqual([
+      'entry-3',
+    ]);
+    expect(await extractEntries(trace.sliceTime(time12))).toEqual([
       'entry-3',
       'entry-4',
     ]);
-    expect(
-      await TraceUtils.extractEntries(trace.sliceTime(undefined, time12)),
-    ).toEqual(['entry-0', 'entry-1', 'entry-2']);
+    expect(await extractEntries(trace.sliceTime(undefined, time12))).toEqual([
+      'entry-0',
+      'entry-1',
+      'entry-2',
+    ]);
 
     // frames
-    expect(await TraceUtils.extractEntries(trace.sliceFrames(1, 1))).toEqual(
-      [],
-    );
-    expect(await TraceUtils.extractEntries(trace.sliceFrames())).toEqual([
+    expect(await extractEntries(trace.sliceFrames(1, 1))).toEqual([]);
+    expect(await extractEntries(trace.sliceFrames())).toEqual([
       'entry-0',
       'entry-1',
       'entry-2',
       'entry-3',
       'entry-4',
     ]);
-    expect(await TraceUtils.extractEntries(trace.sliceFrames(2))).toEqual([
+    expect(await extractEntries(trace.sliceFrames(2))).toEqual([
       'entry-3',
       'entry-4',
     ]);
-    expect(
-      await TraceUtils.extractEntries(trace.sliceFrames(undefined, 5)),
-    ).toEqual(['entry-0', 'entry-1', 'entry-2', 'entry-3']);
-    expect(await TraceUtils.extractEntries(trace.sliceFrames(2, 5))).toEqual([
+    expect(await extractEntries(trace.sliceFrames(undefined, 5))).toEqual([
+      'entry-0',
+      'entry-1',
+      'entry-2',
       'entry-3',
     ]);
+    expect(await extractEntries(trace.sliceFrames(2, 5))).toEqual(['entry-3']);
   });
 
   it('can slice empty trace', async () => {
     const empty = trace.sliceEntries(0, 0);
 
     // entries
-    expect(await TraceUtils.extractEntries(empty.sliceEntries())).toEqual([]);
-    expect(await TraceUtils.extractEntries(empty.sliceEntries(1))).toEqual([]);
-    expect(await TraceUtils.extractEntries(empty.sliceEntries(1, 2))).toEqual(
-      [],
-    );
+    expect(await extractEntries(empty.sliceEntries())).toEqual([]);
+    expect(await extractEntries(empty.sliceEntries(1))).toEqual([]);
+    expect(await extractEntries(empty.sliceEntries(1, 2))).toEqual([]);
 
     // time
     const time12 = TimestampConverterUtils.makeRealTimestamp(12n);
     const time13 = TimestampConverterUtils.makeRealTimestamp(13n);
-    expect(await TraceUtils.extractEntries(empty.sliceTime())).toEqual([]);
-    expect(await TraceUtils.extractEntries(empty.sliceTime(time12))).toEqual(
-      [],
-    );
-    expect(
-      await TraceUtils.extractEntries(empty.sliceTime(time12, time13)),
-    ).toEqual([]);
+    expect(await extractEntries(empty.sliceTime())).toEqual([]);
+    expect(await extractEntries(empty.sliceTime(time12))).toEqual([]);
+    expect(await extractEntries(empty.sliceTime(time12, time13))).toEqual([]);
 
     // frames
-    expect(await TraceUtils.extractEntries(empty.sliceFrames())).toEqual([]);
-    expect(await TraceUtils.extractEntries(empty.sliceFrames(1))).toEqual([]);
-    expect(await TraceUtils.extractEntries(empty.sliceFrames(1, 2))).toEqual(
-      [],
-    );
+    expect(await extractEntries(empty.sliceFrames())).toEqual([]);
+    expect(await extractEntries(empty.sliceFrames(1))).toEqual([]);
+    expect(await extractEntries(empty.sliceFrames(1, 2))).toEqual([]);
   });
 
   it('forEachEntry()', async () => {
-    expect(await TraceUtils.extractEntries(trace)).toEqual([
+    expect(await extractEntries(trace)).toEqual([
       'entry-0',
       'entry-1',
       'entry-2',
@@ -1026,14 +957,14 @@ describe('Trace', () => {
   });
 
   it('forEachTimestamp()', () => {
-    expect(TraceUtils.extractTimestamps(trace)).toEqual([
+    expect(extractTimestamps(trace)).toEqual([
       time10,
       time11,
       time11,
       time12,
       time13,
     ]);
-    expect(TraceUtils.extractTimestamps(trace.sliceEntries(1, -1))).toEqual([
+    expect(extractTimestamps(trace.sliceEntries(1, -1))).toEqual([
       time11,
       time11,
       time12,
@@ -1053,7 +984,7 @@ describe('Trace', () => {
         [5, ['entry-3']],
         [6, ['entry-4']],
       ]);
-      expect(await TraceUtils.extractFrames(trace)).toEqual(expected);
+      expect(await extractFrames(trace)).toEqual(expected);
     }
     // slice
     {
@@ -1064,7 +995,7 @@ describe('Trace', () => {
         [3, []],
         [4, ['entry-3']],
       ]);
-      expect(await TraceUtils.extractFrames(slice)).toEqual(expected);
+      expect(await extractFrames(slice)).toEqual(expected);
     }
   });
 
@@ -1114,14 +1045,14 @@ describe('Trace', () => {
       .build();
 
     // Slice entries
-    expect(await TraceUtils.extractEntries(trace.sliceEntries())).toEqual([
+    expect(await extractEntries(trace.sliceEntries())).toEqual([
       'entry-0',
       'entry-1',
       'entry-2',
       'entry-3',
       'entry-4',
     ]);
-    expect(await TraceUtils.extractFrames(trace.sliceEntries())).toEqual(
+    expect(await extractFrames(trace.sliceEntries())).toEqual(
       new Map<AbsoluteFrameIndex, string[]>([
         [0, ['entry-1']],
         [1, []],
@@ -1129,13 +1060,13 @@ describe('Trace', () => {
       ]),
     );
 
-    expect(await TraceUtils.extractEntries(trace.sliceEntries(1))).toEqual([
+    expect(await extractEntries(trace.sliceEntries(1))).toEqual([
       'entry-1',
       'entry-2',
       'entry-3',
       'entry-4',
     ]);
-    expect(await TraceUtils.extractFrames(trace.sliceEntries(1))).toEqual(
+    expect(await extractFrames(trace.sliceEntries(1))).toEqual(
       new Map<AbsoluteFrameIndex, string[]>([
         [0, ['entry-1']],
         [1, []],
@@ -1143,39 +1074,37 @@ describe('Trace', () => {
       ]),
     );
 
-    expect(await TraceUtils.extractEntries(trace.sliceEntries(2))).toEqual([
+    expect(await extractEntries(trace.sliceEntries(2))).toEqual([
       'entry-2',
       'entry-3',
       'entry-4',
     ]);
-    expect(await TraceUtils.extractFrames(trace.sliceEntries(2))).toEqual(
+    expect(await extractFrames(trace.sliceEntries(2))).toEqual(
       new Map<AbsoluteFrameIndex, string[]>([[2, ['entry-3']]]),
     );
 
-    expect(await TraceUtils.extractEntries(trace.sliceEntries(3))).toEqual([
+    expect(await extractEntries(trace.sliceEntries(3))).toEqual([
       'entry-3',
       'entry-4',
     ]);
-    expect(await TraceUtils.extractFrames(trace.sliceEntries(3))).toEqual(
+    expect(await extractFrames(trace.sliceEntries(3))).toEqual(
       new Map<AbsoluteFrameIndex, string[]>([[2, ['entry-3']]]),
     );
 
-    expect(await TraceUtils.extractEntries(trace.sliceEntries(4))).toEqual([
-      'entry-4',
-    ]);
-    expect(await TraceUtils.extractFrames(trace.sliceEntries(4))).toEqual(
+    expect(await extractEntries(trace.sliceEntries(4))).toEqual(['entry-4']);
+    expect(await extractFrames(trace.sliceEntries(4))).toEqual(
       new Map<AbsoluteFrameIndex, string[]>(),
     );
 
     // Slice time
-    expect(await TraceUtils.extractEntries(trace.sliceTime())).toEqual([
+    expect(await extractEntries(trace.sliceTime())).toEqual([
       'entry-0',
       'entry-1',
       'entry-2',
       'entry-3',
       'entry-4',
     ]);
-    expect(await TraceUtils.extractFrames(trace.sliceTime())).toEqual(
+    expect(await extractFrames(trace.sliceTime())).toEqual(
       new Map<AbsoluteFrameIndex, string[]>([
         [0, ['entry-1']],
         [1, []],
@@ -1183,13 +1112,13 @@ describe('Trace', () => {
       ]),
     );
 
-    expect(await TraceUtils.extractEntries(trace.sliceTime(time11))).toEqual([
+    expect(await extractEntries(trace.sliceTime(time11))).toEqual([
       'entry-1',
       'entry-2',
       'entry-3',
       'entry-4',
     ]);
-    expect(await TraceUtils.extractFrames(trace.sliceTime(time11))).toEqual(
+    expect(await extractFrames(trace.sliceTime(time11))).toEqual(
       new Map<AbsoluteFrameIndex, string[]>([
         [0, ['entry-1']],
         [1, []],
@@ -1197,37 +1126,35 @@ describe('Trace', () => {
       ]),
     );
 
-    expect(await TraceUtils.extractEntries(trace.sliceTime(time12))).toEqual([
+    expect(await extractEntries(trace.sliceTime(time12))).toEqual([
       'entry-2',
       'entry-3',
       'entry-4',
     ]);
-    expect(await TraceUtils.extractFrames(trace.sliceTime(time12))).toEqual(
+    expect(await extractFrames(trace.sliceTime(time12))).toEqual(
       new Map<AbsoluteFrameIndex, string[]>([[2, ['entry-3']]]),
     );
 
-    expect(await TraceUtils.extractEntries(trace.sliceTime(time13))).toEqual([
+    expect(await extractEntries(trace.sliceTime(time13))).toEqual([
       'entry-3',
       'entry-4',
     ]);
-    expect(await TraceUtils.extractFrames(trace.sliceTime(time13))).toEqual(
+    expect(await extractFrames(trace.sliceTime(time13))).toEqual(
       new Map<AbsoluteFrameIndex, string[]>([[2, ['entry-3']]]),
     );
 
-    expect(await TraceUtils.extractEntries(trace.sliceTime(time14))).toEqual([
-      'entry-4',
-    ]);
-    expect(await TraceUtils.extractFrames(trace.sliceTime(time14))).toEqual(
+    expect(await extractEntries(trace.sliceTime(time14))).toEqual(['entry-4']);
+    expect(await extractFrames(trace.sliceTime(time14))).toEqual(
       new Map<AbsoluteFrameIndex, string[]>(),
     );
 
     // Slice frames
-    expect(await TraceUtils.extractEntries(trace.sliceFrames())).toEqual([
+    expect(await extractEntries(trace.sliceFrames())).toEqual([
       'entry-1',
       'entry-2',
       'entry-3',
     ]);
-    expect(await TraceUtils.extractFrames(trace.sliceFrames())).toEqual(
+    expect(await extractFrames(trace.sliceFrames())).toEqual(
       new Map<AbsoluteFrameIndex, string[]>([
         [0, ['entry-1']],
         [1, []],
@@ -1235,22 +1162,18 @@ describe('Trace', () => {
       ]),
     );
 
-    expect(await TraceUtils.extractEntries(trace.sliceFrames(1))).toEqual([
-      'entry-3',
-    ]);
-    expect(await TraceUtils.extractFrames(trace.sliceFrames(1))).toEqual(
+    expect(await extractEntries(trace.sliceFrames(1))).toEqual(['entry-3']);
+    expect(await extractFrames(trace.sliceFrames(1))).toEqual(
       new Map<AbsoluteFrameIndex, string[]>([
         [1, []],
         [2, ['entry-3']],
       ]),
     );
 
-    expect(
-      await TraceUtils.extractEntries(trace.sliceFrames(undefined, 2)),
-    ).toEqual(['entry-1']);
-    expect(
-      await TraceUtils.extractFrames(trace.sliceFrames(undefined, 2)),
-    ).toEqual(
+    expect(await extractEntries(trace.sliceFrames(undefined, 2))).toEqual([
+      'entry-1',
+    ]);
+    expect(await extractFrames(trace.sliceFrames(undefined, 2))).toEqual(
       new Map<AbsoluteFrameIndex, string[]>([
         [0, ['entry-1']],
         [1, []],
@@ -1266,17 +1189,15 @@ describe('Trace', () => {
       .build();
 
     expect(await trace.getEntry(0).getValue()).toEqual('entry-0');
-    expect(await TraceUtils.extractEntries(trace)).toEqual([
+    expect(await extractEntries(trace)).toEqual([
       'entry-0',
       'entry-1',
       'entry-2',
     ]);
-    expect(await TraceUtils.extractEntries(trace.sliceEntries(1, 2))).toEqual([
+    expect(await extractEntries(trace.sliceEntries(1, 2))).toEqual(['entry-1']);
+    expect(await extractEntries(trace.sliceTime(time11, time12))).toEqual([
       'entry-1',
     ]);
-    expect(
-      await TraceUtils.extractEntries(trace.sliceTime(time11, time12)),
-    ).toEqual(['entry-1']);
 
     expect(() => {
       trace.getFrame(0);
@@ -1295,27 +1216,23 @@ describe('Trace', () => {
         .setFrameMap(new FrameMapBuilder(0, 0).build())
         .build();
 
-      expect(await TraceUtils.extractEntries(trace)).toEqual([]);
-      expect(await TraceUtils.extractFrames(trace)).toEqual(
+      expect(await extractEntries(trace)).toEqual([]);
+      expect(await extractFrames(trace)).toEqual(
         new Map<AbsoluteFrameIndex, string[]>(),
       );
 
-      expect(await TraceUtils.extractEntries(trace.sliceEntries(1))).toEqual(
-        [],
-      );
-      expect(await TraceUtils.extractFrames(trace.sliceEntries(1))).toEqual(
+      expect(await extractEntries(trace.sliceEntries(1))).toEqual([]);
+      expect(await extractFrames(trace.sliceEntries(1))).toEqual(
         new Map<AbsoluteFrameIndex, string[]>(),
       );
 
-      expect(await TraceUtils.extractEntries(trace.sliceTime(time11))).toEqual(
-        [],
-      );
-      expect(await TraceUtils.extractFrames(trace.sliceTime(time11))).toEqual(
+      expect(await extractEntries(trace.sliceTime(time11))).toEqual([]);
+      expect(await extractFrames(trace.sliceTime(time11))).toEqual(
         new Map<AbsoluteFrameIndex, string[]>(),
       );
 
-      expect(await TraceUtils.extractEntries(trace.sliceFrames())).toEqual([]);
-      expect(await TraceUtils.extractFrames(trace.sliceFrames())).toEqual(
+      expect(await extractEntries(trace.sliceFrames())).toEqual([]);
+      expect(await extractFrames(trace.sliceFrames())).toEqual(
         new Map<AbsoluteFrameIndex, string[]>(),
       );
     }
@@ -1327,33 +1244,33 @@ describe('Trace', () => {
         .setFrameMap(new FrameMapBuilder(3, 0).build())
         .build();
 
-      expect(await TraceUtils.extractEntries(trace)).toEqual([
+      expect(await extractEntries(trace)).toEqual([
         'entry-0',
         'entry-1',
         'entry-2',
       ]);
-      expect(await TraceUtils.extractFrames(trace)).toEqual(
+      expect(await extractFrames(trace)).toEqual(
         new Map<AbsoluteFrameIndex, string[]>(),
       );
 
-      expect(await TraceUtils.extractEntries(trace.sliceEntries(1))).toEqual([
+      expect(await extractEntries(trace.sliceEntries(1))).toEqual([
         'entry-1',
         'entry-2',
       ]);
-      expect(await TraceUtils.extractFrames(trace.sliceEntries(1))).toEqual(
+      expect(await extractFrames(trace.sliceEntries(1))).toEqual(
         new Map<AbsoluteFrameIndex, string[]>(),
       );
 
-      expect(await TraceUtils.extractEntries(trace.sliceTime(time11))).toEqual([
+      expect(await extractEntries(trace.sliceTime(time11))).toEqual([
         'entry-1',
         'entry-2',
       ]);
-      expect(await TraceUtils.extractFrames(trace.sliceTime(time11))).toEqual(
+      expect(await extractFrames(trace.sliceTime(time11))).toEqual(
         new Map<AbsoluteFrameIndex, string[]>(),
       );
 
-      expect(await TraceUtils.extractEntries(trace.sliceFrames())).toEqual([]);
-      expect(await TraceUtils.extractFrames(trace.sliceFrames())).toEqual(
+      expect(await extractEntries(trace.sliceFrames())).toEqual([]);
+      expect(await extractFrames(trace.sliceFrames())).toEqual(
         new Map<AbsoluteFrameIndex, string[]>(),
       );
     }
@@ -1402,9 +1319,7 @@ describe('Trace', () => {
 
   it('spansMultipleDates()', () => {
     const time0 = TimestampConverterUtils.makeZeroTimestamp();
-    const emptyTrace = UnitTestUtils.makeEmptyTrace(
-      TraceType.TEST_TRACE_STRING,
-    );
+    const emptyTrace = makeEmptyTrace(TraceType.TEST_TRACE_STRING);
     expect(emptyTrace.spansMultipleDates()).toBeFalse();
 
     const traceWithElapsedTimestamps = new TraceBuilder<string>()
diff --git a/tools/winscope/src/trace/trace_type.ts b/tools/winscope/src/trace/trace_type.ts
index a826de21e..8e6abd17b 100644
--- a/tools/winscope/src/trace/trace_type.ts
+++ b/tools/winscope/src/trace/trace_type.ts
@@ -14,6 +14,7 @@
  * limitations under the License.
  */
 
+import {com} from 'protos/transitions/udc/static';
 import {QueryResult} from 'trace_processor/query_result';
 import {MediaBasedTraceEntry} from './media_based_trace_entry';
 import {HierarchyTreeNode} from './tree_node/hierarchy_tree_node';
@@ -57,7 +58,7 @@ export interface TraceEntryTypeMap {
   [TraceType.SCREEN_RECORDING]: MediaBasedTraceEntry;
   [TraceType.SCREENSHOT]: MediaBasedTraceEntry;
   [TraceType.SYSTEM_UI]: object;
-  [TraceType.TRANSACTIONS]: PropertyTreeNode;
+  [TraceType.TRANSACTIONS]: HierarchyTreeNode;
   [TraceType.WAYLAND]: object;
   [TraceType.WAYLAND_DUMP]: object;
   [TraceType.WINDOW_MANAGER]: HierarchyTreeNode;
@@ -65,9 +66,9 @@ export interface TraceEntryTypeMap {
   [TraceType.INPUT_METHOD_MANAGER_SERVICE]: HierarchyTreeNode;
   [TraceType.INPUT_METHOD_SERVICE]: HierarchyTreeNode;
   [TraceType.EVENT_LOG]: PropertyTreeNode;
-  [TraceType.WM_TRANSITION]: PropertyTreeNode;
-  [TraceType.SHELL_TRANSITION]: PropertyTreeNode;
-  [TraceType.TRANSITION]: PropertyTreeNode;
+  [TraceType.WM_TRANSITION]: com.android.server.wm.shell.ITransition;
+  [TraceType.SHELL_TRANSITION]: com.android.wm.shell.ITransition;
+  [TraceType.TRANSITION]: HierarchyTreeNode;
   [TraceType.CUJS]: PropertyTreeNode;
   [TraceType.TEST_TRACE_STRING]: string;
   [TraceType.TEST_TRACE_NUMBER]: number;
@@ -112,7 +113,7 @@ export class TraceTypeUtils {
     return TraceTypeUtils.TRACES_WITH_VIEWERS_DISPLAY_ORDER.includes(t);
   }
 
-  static compareByUiPipelineOrder(t: TraceType, u: TraceType) {
+  static compareByUiPipelineOrder(t: TraceType, u: TraceType): boolean {
     const tIndex = TraceTypeUtils.findIndexInOrder(
       t,
       TraceTypeUtils.UI_PIPELINE_ORDER,
@@ -124,7 +125,7 @@ export class TraceTypeUtils {
     return tIndex >= 0 && uIndex >= 0 && tIndex < uIndex;
   }
 
-  static compareByDisplayOrder(t: TraceType, u: TraceType) {
+  static compareByDisplayOrder(t: TraceType, u: TraceType): number {
     const tIndex = TraceTypeUtils.findIndexInOrder(
       t,
       TraceTypeUtils.TRACES_WITH_VIEWERS_DISPLAY_ORDER,
diff --git a/tools/winscope/src/trace/traces_test.ts b/tools/winscope/src/trace/traces_test.ts
index 42269e745..abc503109 100644
--- a/tools/winscope/src/trace/traces_test.ts
+++ b/tools/winscope/src/trace/traces_test.ts
@@ -18,10 +18,16 @@ import {assertDefined} from 'common/assert_utils';
 import {FunctionUtils} from 'common/function_utils';
 import {TimestampConverterUtils} from 'common/time/test_utils';
 import {TracesBuilder} from 'test/unit/traces_builder';
-import {TracesUtils} from 'test/unit/traces_utils';
+import {
+  extractEntries,
+  extractFrames,
+  extractTraces,
+} from 'test/unit/traces_utils';
 import {TraceBuilder} from 'test/unit/trace_builder';
-import {TraceUtils} from 'test/unit/trace_utils';
-import {UnitTestUtils} from 'test/unit/utils';
+import {
+  extractEntries as extractTraceEntries,
+  makeEmptyTrace,
+} from 'test/unit/trace_utils';
 import {FrameMapBuilder} from './frame_map_builder';
 import {AbsoluteFrameIndex} from './index_types';
 import {Traces} from './traces';
@@ -142,14 +148,14 @@ describe('Traces', () => {
 
   it('getTrace()', async () => {
     expect(
-      await TraceUtils.extractEntries(
+      await extractTraceEntries(
         assertDefined(traces.getTrace(TraceType.TEST_TRACE_STRING)),
       ),
     ).toEqual(
       extractedEntriesFull.get(TraceType.TEST_TRACE_STRING) as string[],
     );
     expect(
-      await TraceUtils.extractEntries(
+      await extractTraceEntries(
         assertDefined(traces.getTrace(TraceType.TEST_TRACE_NUMBER)),
       ),
     ).toEqual(
@@ -165,28 +171,28 @@ describe('Traces', () => {
   });
 
   it('deleteTrace()', () => {
-    const trace0 = UnitTestUtils.makeEmptyTrace(TraceType.TEST_TRACE_STRING);
-    const trace1 = UnitTestUtils.makeEmptyTrace(TraceType.TEST_TRACE_NUMBER);
+    const trace0 = makeEmptyTrace(TraceType.TEST_TRACE_STRING);
+    const trace1 = makeEmptyTrace(TraceType.TEST_TRACE_NUMBER);
 
     const traces = new Traces();
     traces.addTrace(trace0);
     traces.addTrace(trace1);
 
-    expect(TracesUtils.extractTraces(traces)).toEqual([trace0, trace1]);
+    expect(extractTraces(traces)).toEqual([trace0, trace1]);
 
     traces.deleteTrace(trace0);
-    expect(TracesUtils.extractTraces(traces)).toEqual([trace1]);
+    expect(extractTraces(traces)).toEqual([trace1]);
 
     traces.deleteTrace(trace1);
-    expect(TracesUtils.extractTraces(traces)).toEqual([]);
+    expect(extractTraces(traces)).toEqual([]);
 
     traces.deleteTrace(trace1);
-    expect(TracesUtils.extractTraces(traces)).toEqual([]);
+    expect(extractTraces(traces)).toEqual([]);
   });
 
   it('hasTrace()', () => {
-    const trace0 = UnitTestUtils.makeEmptyTrace(TraceType.TEST_TRACE_STRING);
-    const trace1 = UnitTestUtils.makeEmptyTrace(TraceType.TEST_TRACE_NUMBER);
+    const trace0 = makeEmptyTrace(TraceType.TEST_TRACE_STRING);
+    const trace1 = makeEmptyTrace(TraceType.TEST_TRACE_NUMBER);
 
     const traces = new Traces();
     traces.addTrace(trace0);
@@ -199,21 +205,17 @@ describe('Traces', () => {
     // empty
     {
       const slice = traces.sliceTime(time3, time3);
-      expect(await TracesUtils.extractEntries(slice)).toEqual(
-        extractedEntriesEmpty,
-      );
+      expect(await extractEntries(slice)).toEqual(extractedEntriesEmpty);
     }
     // full
     {
       const slice = traces.sliceTime();
-      expect(await TracesUtils.extractEntries(slice)).toEqual(
-        extractedEntriesFull,
-      );
+      expect(await extractEntries(slice)).toEqual(extractedEntriesFull);
     }
     // middle
     {
       const slice = traces.sliceTime(time4, time8);
-      expect(await TracesUtils.extractEntries(slice)).toEqual(
+      expect(await extractEntries(slice)).toEqual(
         new Map<TraceType, Array<{}>>([
           [TraceType.TEST_TRACE_STRING, ['2', '3']],
           [TraceType.TEST_TRACE_NUMBER, [1, 2]],
@@ -223,7 +225,7 @@ describe('Traces', () => {
     // slice away front
     {
       const slice = traces.sliceTime(time8);
-      expect(await TracesUtils.extractEntries(slice)).toEqual(
+      expect(await extractEntries(slice)).toEqual(
         new Map<TraceType, Array<{}>>([
           [TraceType.TEST_TRACE_STRING, ['4']],
           [TraceType.TEST_TRACE_NUMBER, [3, 4]],
@@ -233,7 +235,7 @@ describe('Traces', () => {
     // slice away back
     {
       const slice = traces.sliceTime(undefined, time8);
-      expect(await TracesUtils.extractEntries(slice)).toEqual(
+      expect(await extractEntries(slice)).toEqual(
         new Map<TraceType, Array<{}>>([
           [TraceType.TEST_TRACE_STRING, ['0', '1', '2', '3']],
           [TraceType.TEST_TRACE_NUMBER, [0, 1, 2]],
@@ -246,16 +248,12 @@ describe('Traces', () => {
     // empty
     {
       const slice = traces.sliceFrames(1, 1);
-      expect(await TracesUtils.extractFrames(slice)).toEqual(
-        extractedFramesEmpty,
-      );
+      expect(await extractFrames(slice)).toEqual(extractedFramesEmpty);
     }
     // full
     {
       const slice = traces.sliceFrames();
-      expect(await TracesUtils.extractFrames(slice)).toEqual(
-        extractedFramesFull,
-      );
+      expect(await extractFrames(slice)).toEqual(extractedFramesFull);
     }
     // middle
     {
@@ -263,7 +261,7 @@ describe('Traces', () => {
       const expectedFrames = structuredClone(extractedFramesFull);
       expectedFrames.delete(0);
       expectedFrames.delete(4);
-      expect(await TracesUtils.extractFrames(slice)).toEqual(expectedFrames);
+      expect(await extractFrames(slice)).toEqual(expectedFrames);
     }
     // slice away front
     {
@@ -271,7 +269,7 @@ describe('Traces', () => {
       const expectedFrames = structuredClone(extractedFramesFull);
       expectedFrames.delete(0);
       expectedFrames.delete(1);
-      expect(await TracesUtils.extractFrames(slice)).toEqual(expectedFrames);
+      expect(await extractFrames(slice)).toEqual(expectedFrames);
     }
     // slice away back
     {
@@ -280,23 +278,21 @@ describe('Traces', () => {
       expectedFrames.delete(2);
       expectedFrames.delete(3);
       expectedFrames.delete(4);
-      expect(await TracesUtils.extractFrames(slice)).toEqual(expectedFrames);
+      expect(await extractFrames(slice)).toEqual(expectedFrames);
     }
   });
 
   it('mapTrace()', async () => {
     const promises = traces.mapTrace(async (trace) => {
       const expectedEntries = extractedEntriesFull.get(trace.type) as Array<{}>;
-      const actualEntries = await TraceUtils.extractEntries(trace);
+      const actualEntries = await extractTraceEntries(trace);
       expect(actualEntries).toEqual(expectedEntries);
     });
     await Promise.all(promises);
   });
 
   it('mapFrame()', async () => {
-    expect(await TracesUtils.extractFrames(traces)).toEqual(
-      extractedFramesFull,
-    );
+    expect(await extractFrames(traces)).toEqual(extractedFramesFull);
   });
 
   it('supports empty traces', async () => {
@@ -314,24 +310,20 @@ describe('Traces', () => {
       )
       .build();
 
-    expect(await TracesUtils.extractEntries(traces)).toEqual(
+    expect(await extractEntries(traces)).toEqual(extractedEntriesEmpty);
+    expect(await extractFrames(traces)).toEqual(extractedFramesEmpty);
+
+    expect(await extractEntries(traces.sliceTime(time1, time10))).toEqual(
       extractedEntriesEmpty,
     );
-    expect(await TracesUtils.extractFrames(traces)).toEqual(
+    expect(await extractFrames(traces.sliceTime(time1, time10))).toEqual(
       extractedFramesEmpty,
     );
 
-    expect(
-      await TracesUtils.extractEntries(traces.sliceTime(time1, time10)),
-    ).toEqual(extractedEntriesEmpty);
-    expect(
-      await TracesUtils.extractFrames(traces.sliceTime(time1, time10)),
-    ).toEqual(extractedFramesEmpty);
-
-    expect(await TracesUtils.extractEntries(traces.sliceFrames(0, 10))).toEqual(
+    expect(await extractEntries(traces.sliceFrames(0, 10))).toEqual(
       extractedEntriesEmpty,
     );
-    expect(await TracesUtils.extractFrames(traces.sliceFrames(0, 10))).toEqual(
+    expect(await extractFrames(traces.sliceFrames(0, 10))).toEqual(
       extractedFramesEmpty,
     );
   });
@@ -352,10 +344,8 @@ describe('Traces', () => {
       [TraceType.TEST_TRACE_NUMBER, [0]],
     ]);
 
-    expect(await TracesUtils.extractEntries(traces)).toEqual(expectedEntries);
-    expect(await TracesUtils.extractEntries(traces.sliceTime())).toEqual(
-      expectedEntries,
-    );
+    expect(await extractEntries(traces)).toEqual(expectedEntries);
+    expect(await extractEntries(traces.sliceTime())).toEqual(expectedEntries);
 
     expect(() => {
       traces.sliceFrames();
diff --git a/tools/winscope/src/trace/transition.ts b/tools/winscope/src/trace/transactions/transaction_column_type.ts
similarity index 55%
rename from tools/winscope/src/trace/transition.ts
rename to tools/winscope/src/trace/transactions/transaction_column_type.ts
index 8ed0f9593..49a7fed56 100644
--- a/tools/winscope/src/trace/transition.ts
+++ b/tools/winscope/src/trace/transactions/transaction_column_type.ts
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2024 The Android Open Source Project
+ * Copyright (C) 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,18 +14,13 @@
  * limitations under the License.
  */
 
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
-import {AbsoluteEntryIndex} from './index_types';
-
-export interface Transition {
-  id: number;
-  type: string;
-  sendTime?: PropertyTreeNode;
-  dispatchTime?: PropertyTreeNode;
-  duration?: string;
-  merged: boolean;
-  aborted: boolean;
-  played: boolean;
-  propertiesTree: PropertyTreeNode;
-  traceIndex: AbsoluteEntryIndex;
+export enum TransactionColumnType {
+  TRANSACTION_ID,
+  VSYNC_ID,
+  PID,
+  UID,
+  PROCESS,
+  TRANSACTION_TYPE,
+  LAYER_OR_DISPLAY_ID,
+  FLAGS,
 }
diff --git a/tools/winscope/src/trace/transactions/transaction_type.ts b/tools/winscope/src/trace/transactions/transaction_type.ts
new file mode 100644
index 000000000..ac1f4a318
--- /dev/null
+++ b/tools/winscope/src/trace/transactions/transaction_type.ts
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+export enum TransactionType {
+  DISPLAY_ADDED = 'DISPLAY_ADDED',
+  DISPLAY_REMOVED = 'DISPLAY_REMOVED',
+  DISPLAY_CHANGED = 'DISPLAY_CHANGED',
+  LAYER_ADDED = 'LAYER_ADDED',
+  LAYER_DESTROYED = 'LAYER_DESTROYED',
+  LAYER_CHANGED = 'LAYER_CHANGED',
+  LAYER_HANDLE_DESTROYED = 'LAYER_HANDLE_DESTROYED',
+  NO_OP = 'NOOP',
+}
diff --git a/tools/winscope/src/trace/transitions/status.ts b/tools/winscope/src/trace/transitions/status.ts
new file mode 100644
index 000000000..a8e4908ba
--- /dev/null
+++ b/tools/winscope/src/trace/transitions/status.ts
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+export enum TransitionStatus {
+  ABORTED = 'ABORTED',
+  MERGED = 'MERGED',
+  PLAYED = 'PLAYED',
+}
diff --git a/tools/winscope/src/trace/tree_node/formatters.ts b/tools/winscope/src/trace/tree_node/formatters.ts
index 2e5945e5f..10502bb00 100644
--- a/tools/winscope/src/trace/tree_node/formatters.ts
+++ b/tools/winscope/src/trace/tree_node/formatters.ts
@@ -17,8 +17,8 @@
 import {Timestamp} from 'common/time/time';
 import {TimeDuration} from 'common/time/time_duration';
 import {RawDataUtils} from 'parsers/raw_data_utils';
-import {TransformType} from 'parsers/surface_flinger/transform_utils';
-import {CujType} from 'trace/cuj_type';
+import {CujType} from 'trace/cujs/cuj_type';
+import {TransformType} from 'trace/surface_flinger/transform_utils';
 import {PropertyTreeNode} from './property_tree_node';
 
 const EMPTY_OBJ_STRING = '{empty}';
@@ -260,6 +260,13 @@ class HexFormatter implements PropertyFormatter {
 }
 const HEX_FORMATTER = new HexFormatter();
 
+class UpperCaseFormatter implements PropertyFormatter {
+  format(node: PropertyTreeNode): string {
+    return node.getValue()?.toString().toUpperCase() ?? '';
+  }
+}
+const UPPER_CASE_FORMATTER = new UpperCaseFormatter();
+
 export {
   EMPTY_OBJ_STRING,
   EMPTY_ARRAY_STRING,
@@ -280,4 +287,5 @@ export {
   MATRIX_FORMATTER,
   CUJ_TYPE_FORMATTER,
   HEX_FORMATTER,
+  UPPER_CASE_FORMATTER,
 };
diff --git a/tools/winscope/src/trace/tree_node/formatters_test.ts b/tools/winscope/src/trace/tree_node/formatters_test.ts
index 9e3b5b12f..355aa9cc5 100644
--- a/tools/winscope/src/trace/tree_node/formatters_test.ts
+++ b/tools/winscope/src/trace/tree_node/formatters_test.ts
@@ -16,9 +16,9 @@
 
 import {assertDefined} from 'common/assert_utils';
 import {IDENTITY_MATRIX} from 'common/geometry/transform_matrix';
-import {TransformTypeFlags} from 'parsers/surface_flinger/transform_utils';
 import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
 import {TreeNodeUtils} from 'test/unit/tree_node_utils';
+import {TransformTypeFlags} from 'trace/surface_flinger/transform_utils';
 import {
   BUFFER_FORMATTER,
   COLOR_FORMATTER,
diff --git a/tools/winscope/src/trace/tree_node/properties_provider.ts b/tools/winscope/src/trace/tree_node/properties_provider.ts
index 19dba2974..7110d55ee 100644
--- a/tools/winscope/src/trace/tree_node/properties_provider.ts
+++ b/tools/winscope/src/trace/tree_node/properties_provider.ts
@@ -78,7 +78,9 @@ export class PropertiesProvider {
       children.push(...this.lazyPropertiesRoot.getAllChildren());
     }
 
-    children.forEach((child) => root.addOrReplaceChild(child));
+    children.forEach((child) => {
+      root.addOrReplaceChild(child);
+    });
 
     root.setIsRoot(true);
 
diff --git a/tools/winscope/src/trace/tree_node/property_tree_node.ts b/tools/winscope/src/trace/tree_node/property_tree_node.ts
index b7ead2bb0..84db7f20b 100644
--- a/tools/winscope/src/trace/tree_node/property_tree_node.ts
+++ b/tools/winscope/src/trace/tree_node/property_tree_node.ts
@@ -60,4 +60,5 @@ export enum PropertySource {
   PROTO,
   DEFAULT,
   CALCULATED,
+  TP,
 }
diff --git a/tools/winscope/src/trace/tree_node/property_tree_node_factory.ts b/tools/winscope/src/trace/tree_node/property_tree_node_factory.ts
index 7469b0f18..1e98fc911 100644
--- a/tools/winscope/src/trace/tree_node/property_tree_node_factory.ts
+++ b/tools/winscope/src/trace/tree_node/property_tree_node_factory.ts
@@ -22,10 +22,7 @@ import {
 } from 'trace/tree_node/property_tree_node';
 
 export class PropertyTreeNodeFactory {
-  constructor(
-    private denylistProperties: string[] = [],
-    private visitPrototype = true,
-  ) {}
+  constructor(private denylistProperties: string[] = []) {}
 
   makePropertyRoot(
     rootId: string,
@@ -70,6 +67,10 @@ export class PropertyTreeNodeFactory {
     );
   }
 
+  makeTpProperty(rootId: string, name: string, value: any): PropertyTreeNode {
+    return this.makeProperty(rootId, name, PropertySource.TP, value);
+  }
+
   private makeProperty(
     rootId: string,
     name: string,
@@ -190,7 +191,7 @@ export class PropertyTreeNodeFactory {
           props.push(prop);
         }
       });
-      obj = this.visitPrototype ? Object.getPrototypeOf(obj) : undefined;
+      obj = Object.getPrototypeOf(obj);
     } while (obj);
     return props;
   }
diff --git a/tools/winscope/src/trace/tree_node/property_tree_node_factory_test.ts b/tools/winscope/src/trace/tree_node/property_tree_node_factory_test.ts
index 7c1a490e7..1c683f55c 100644
--- a/tools/winscope/src/trace/tree_node/property_tree_node_factory_test.ts
+++ b/tools/winscope/src/trace/tree_node/property_tree_node_factory_test.ts
@@ -234,4 +234,15 @@ describe('PropertyTreeNodeFactory', () => {
 
     expect(node).toEqual(expectedNode);
   });
+
+  it('makes simple TP property', () => {
+    const node = factory.makeTpProperty('1 root', 'prop', 2);
+    const expectedNode = new PropertyTreeBuilder()
+      .setRootId('1 root')
+      .setName('prop')
+      .setSource(PropertySource.TP)
+      .setValue(2)
+      .build();
+    expect(node).toEqual(expectedNode);
+  });
 });
diff --git a/tools/winscope/src/trace/window_type.ts b/tools/winscope/src/trace/window_manager/window_type.ts
similarity index 100%
rename from tools/winscope/src/trace/window_type.ts
rename to tools/winscope/src/trace/window_manager/window_type.ts
diff --git a/tools/winscope/src/trace_collection/adb/adb_device_connection.ts b/tools/winscope/src/trace_collection/adb/adb_device_connection.ts
index 185a42640..b43446e95 100644
--- a/tools/winscope/src/trace_collection/adb/adb_device_connection.ts
+++ b/tools/winscope/src/trace_collection/adb/adb_device_connection.ts
@@ -14,8 +14,6 @@
  * limitations under the License.
  */
 
-import {UserNotifier} from 'common/user_notifier';
-import {ProxyTracingWarnings} from 'messaging/user_warnings';
 import {ConnectionState} from 'trace_collection/connection_state';
 import {TraceTarget} from 'trace_collection/trace_target';
 import {UiTraceTarget} from 'trace_collection/ui/ui_trace_target';
@@ -68,16 +66,7 @@ export abstract class AdbDeviceConnection {
 
   async checkRoot(): Promise<boolean> {
     const root = await this.runShellCommand('su root id -u');
-    const isRoot = Number(root) === 0;
-    if (!isRoot) {
-      UserNotifier.add(
-        new ProxyTracingWarnings([
-          'Unable to acquire root privileges on the device - ' +
-            `check the output of 'adb -s ${this.id} shell su root id'`,
-        ]),
-      ).notify();
-    }
-    return isRoot;
+    return root === '0';
   }
 
   async updateAvailableTraces() {
@@ -97,22 +86,25 @@ export abstract class AdbDeviceConnection {
   }
 
   async findFiles(path: string, matchers: string[]): Promise<string[]> {
+    const errors = ['No such file', 'Permission denied'];
     if (matchers.length === 0) {
       matchers.push('');
     }
+    const isRoot = await this.checkRoot();
     for (const matcher of matchers) {
-      let matchingFiles: string;
+      let findCmd = `find ${path}`;
       if (matcher.length > 0) {
-        matchingFiles = await this.runShellCommand(
-          `su root find ${path} -name ${matcher}`,
-        );
-      } else {
-        matchingFiles = await this.runShellCommand(`su root find ${path}`);
+        findCmd += ` -name ${matcher}`;
+      }
+      if (isRoot) {
+        findCmd = 'su root ' + findCmd;
       }
+      const matchingFiles = await this.runShellCommand(findCmd);
       const files = matchingFiles
         .split('\n')
         .filter(
-          (file) => !file.includes('No such file') && file.trim().length > 0,
+          (maybeFile) =>
+            !errors.includes(maybeFile) && maybeFile.trim().length > 0,
         );
       if (files.length > 0) {
         return files;
@@ -147,7 +139,7 @@ export abstract class AdbDeviceConnection {
 
     if (this.state === AdbDeviceState.AVAILABLE) {
       const output = await this.runShellCommand(
-        'su root dumpsys SurfaceFlinger --display-id',
+        'dumpsys SurfaceFlinger --display-id',
       );
       if (!output.includes('Display')) {
         this.displays = [];
diff --git a/tools/winscope/src/trace_collection/adb/adb_device_connection_test.ts b/tools/winscope/src/trace_collection/adb/adb_device_connection_test.ts
index f449a5bd9..d02da5468 100644
--- a/tools/winscope/src/trace_collection/adb/adb_device_connection_test.ts
+++ b/tools/winscope/src/trace_collection/adb/adb_device_connection_test.ts
@@ -14,7 +14,6 @@
  * limitations under the License.
  */
 
-import {ProxyTracingWarnings} from 'messaging/user_warnings';
 import {UserNotifierChecker} from 'test/unit/user_notifier_checker';
 import {
   AdbDeviceConnectionListener,
@@ -81,23 +80,6 @@ describe('AdbDeviceConnection', () => {
     expect(connection.getFormattedName()).toEqual('Pixel (35562)');
   });
 
-  it('checks root success', async () => {
-    runShellCmdSpy.withArgs('su root id -u').and.returnValue('0');
-    expect(await connection.checkRoot()).toBeTrue();
-  });
-
-  it('checks root failure', async () => {
-    runShellCmdSpy.withArgs('su root id -u').and.returnValue('1');
-    expect(await connection.checkRoot()).toBeFalse();
-    userNotifierChecker.expectNotified([
-      new ProxyTracingWarnings([
-        'Unable to acquire root privileges on the device - ' +
-          `check the output of 'adb -s 35562 shell su root id'`,
-      ]),
-    ]);
-    userNotifierChecker.reset();
-  });
-
   it('updates availability of wayland trace if available', async () => {
     await connection.updateAvailableTraces();
     expect(listener.onAvailableTracesChange).toHaveBeenCalledOnceWith(
@@ -157,7 +139,7 @@ describe('AdbDeviceConnection', () => {
 
   it('adds display', async () => {
     runShellCmdSpy
-      .withArgs('su root dumpsys SurfaceFlinger --display-id')
+      .withArgs('dumpsys SurfaceFlinger --display-id')
       .and.returnValue('Display 12345 Extra Info displayName="Test Display"');
     await connection.updateProperties({});
     expect(connection.getDisplays()).toEqual([
@@ -167,7 +149,7 @@ describe('AdbDeviceConnection', () => {
 
   it('adds display with missing displayName', async () => {
     runShellCmdSpy
-      .withArgs('su root dumpsys SurfaceFlinger --display-id')
+      .withArgs('dumpsys SurfaceFlinger --display-id')
       .and.returnValue('Display 12345 Extra Info');
     await connection.updateProperties({});
     expect(connection.getDisplays()).toEqual(['12345 Extra Info']);
@@ -175,23 +157,37 @@ describe('AdbDeviceConnection', () => {
 
   it('clears display', async () => {
     runShellCmdSpy
-      .withArgs('su root dumpsys SurfaceFlinger --display-id')
+      .withArgs('dumpsys SurfaceFlinger --display-id')
       .and.returnValue('Display 12345 Extra Info');
     await connection.updateProperties({});
     expect(connection.getDisplays().length).toEqual(1);
     runShellCmdSpy
-      .withArgs('su root dumpsys SurfaceFlinger --display-id')
+      .withArgs('dumpsys SurfaceFlinger --display-id')
       .and.returnValue('');
     await connection.updateProperties({});
     expect(connection.getDisplays().length).toEqual(0);
   });
 
   it('finds files via exact filepath', async () => {
+    runShellCmdSpy.withArgs('find filepath').and.returnValue('file');
+    expect(await connection.findFiles('filepath', [])).toEqual(['file']);
+  });
+
+  it('finds files via exact filepath as root', async () => {
+    setDeviceAsRoot();
     runShellCmdSpy.withArgs('su root find filepath').and.returnValue('file');
     expect(await connection.findFiles('filepath', [])).toEqual(['file']);
   });
 
   it('finds files via first matcher', async () => {
+    runShellCmdSpy.withArgs('find filepath -name m1').and.returnValue('file');
+    expect(await connection.findFiles('filepath', ['m1', 'm2'])).toEqual([
+      'file',
+    ]);
+  });
+
+  it('finds files via first matcher as root', async () => {
+    setDeviceAsRoot();
     runShellCmdSpy
       .withArgs('su root find filepath -name m1')
       .and.returnValue('file');
@@ -201,6 +197,14 @@ describe('AdbDeviceConnection', () => {
   });
 
   it('finds files via second matcher', async () => {
+    runShellCmdSpy.withArgs('find filepath -name m2').and.returnValue('file');
+    expect(await connection.findFiles('filepath', ['m1', 'm2'])).toEqual([
+      'file',
+    ]);
+  });
+
+  it('finds files via second matcher as root', async () => {
+    setDeviceAsRoot();
     runShellCmdSpy
       .withArgs('su root find filepath -name m2')
       .and.returnValue('file');
@@ -210,16 +214,33 @@ describe('AdbDeviceConnection', () => {
   });
 
   it('handles "No such file" error', async () => {
+    runShellCmdSpy.withArgs('find filepath').and.returnValue('No such file');
+    expect(await connection.findFiles('filepath', [])).toEqual([]);
+  });
+
+  it('handles "Permission denied" error', async () => {
     runShellCmdSpy
       .withArgs('su root find filepath')
-      .and.returnValue('No such file');
+      .and.returnValue('Permission denied');
     expect(await connection.findFiles('filepath', [])).toEqual([]);
   });
 
   it('ignores whitespace', async () => {
-    runShellCmdSpy
-      .withArgs('su root find filepath')
-      .and.returnValue('file\n  ');
+    runShellCmdSpy.withArgs('find filepath').and.returnValue('file\n  ');
     expect(await connection.findFiles('filepath', [])).toEqual(['file']);
   });
+
+  it('checks root and returns true for "0" output', async () => {
+    setDeviceAsRoot();
+    expect(await connection.checkRoot()).toBeTrue();
+  });
+
+  it('checks root and returns false for non "0" output', async () => {
+    setDeviceAsRoot();
+    expect(await connection.checkRoot()).toBeTrue();
+  });
+
+  function setDeviceAsRoot() {
+    runShellCmdSpy.withArgs('su root id -u').and.returnValue('0');
+  }
 });
diff --git a/tools/winscope/src/trace_collection/controller/perfetto_session_moderator.ts b/tools/winscope/src/trace_collection/controller/perfetto_session_moderator.ts
index 3209e3e16..537ef3dc9 100644
--- a/tools/winscope/src/trace_collection/controller/perfetto_session_moderator.ts
+++ b/tools/winscope/src/trace_collection/controller/perfetto_session_moderator.ts
@@ -53,7 +53,7 @@ export class PerfettoSessionModerator {
 
   async clearPreviousConfigFiles() {
     console.debug('Clearing perfetto config file for previous tracing session');
-    await this.device.runShellCommand(`su root rm -f ${this.configFilepath}`);
+    await this.device.runShellCommand(`rm -f ${this.configFilepath}`);
     console.debug('Cleared perfetto config file for previous tracing session');
   }
 
@@ -90,30 +90,31 @@ export class PerfettoSessionModerator {
     return queryResult.includes(ds);
   }
 
-  createTracingSession(setupCommands: string[]): TracingSession {
+  createTracingSession(dataSourceConfigs: string[]): TracingSession {
     if (this.isDump) {
-      return new TracingSession(this.makePerfettoDumpTarget(setupCommands));
+      return new TracingSession(this.makePerfettoDumpTarget(dataSourceConfigs));
     } else {
-      return new TracingSession(this.makePerfettoTraceTarget(setupCommands));
+      return new TracingSession(
+        this.makePerfettoTraceTarget(dataSourceConfigs),
+      );
     }
   }
 
-  createSetupCommand(ds: string, config?: string): string {
+  makeConfigDataSource(datasourceName: string, config?: string): string {
     const spacer = '\n    ';
-    return `cat << EOF >> ${this.configFilepath}
-data_sources: {
+    return `data_sources: {
   config {
-    name: "${ds}"${config ? spacer + config : ''}
+    name: "${datasourceName}"${config ? spacer + config : ''}
   }
-}
-EOF`;
+}`;
   }
 
-  private makePerfettoDumpTarget(setupCommands: string[]) {
+  private makePerfettoDumpTarget(dataSourceConfigs: string[]) {
     return new TraceTarget(
       'PerfettoDump',
-      setupCommands,
-      `cat << EOF >> ${PERFETTO_DUMP_CONFIG_FILE}
+      [],
+      `cat << EOF > ${PERFETTO_DUMP_CONFIG_FILE}
+${dataSourceConfigs.join('\n')}
 buffers: {
   size_kb: 500000
   fill_policy: RING_BUFFER
@@ -128,11 +129,33 @@ echo 'Dumped perfetto'`,
     );
   }
 
-  private makePerfettoTraceTarget(setupCommands: string[]) {
+  private makePerfettoTraceTarget(dataSourceConfigs: string[]) {
     return new TraceTarget(
       'PerfettoTrace',
-      setupCommands,
-      `cat << EOF >> ${PERFETTO_TRACE_CONFIG_FILE}
+      [],
+      `cat << EOF > ${PERFETTO_TRACE_CONFIG_FILE}
+${dataSourceConfigs.join('\n')}
+data_sources {
+  config {
+    name: "linux.process_stats"
+    target_buffer: 0
+    process_stats_config {
+      scan_all_processes_on_start: true
+    }
+  }
+}
+data_sources: {
+  config {
+    name: "linux.ftrace"
+    ftrace_config {
+      ftrace_events: "ftrace/print"
+      ftrace_events: "task/task_newtask"
+      ftrace_events: "task/task_rename"
+      atrace_categories: "ss"
+      atrace_categories: "wm"
+    }
+  }
+}
 buffers: {
   size_kb: 500000
   fill_policy: RING_BUFFER
diff --git a/tools/winscope/src/trace_collection/controller/perfetto_session_moderator_test.ts b/tools/winscope/src/trace_collection/controller/perfetto_session_moderator_test.ts
index 32a2e9d5a..1cb44c8b2 100644
--- a/tools/winscope/src/trace_collection/controller/perfetto_session_moderator_test.ts
+++ b/tools/winscope/src/trace_collection/controller/perfetto_session_moderator_test.ts
@@ -50,7 +50,7 @@ describe('PerfettoSessionModerator', () => {
       const moderator = new PerfettoSessionModerator(mockDevice, false);
       await moderator.clearPreviousConfigFiles();
       expect(runShellCmdSpy).toHaveBeenCalledOnceWith(
-        `su root rm -f ${PERFETTO_TRACE_CONFIG_FILE}`,
+        `rm -f ${PERFETTO_TRACE_CONFIG_FILE}`,
       );
     });
 
@@ -58,7 +58,7 @@ describe('PerfettoSessionModerator', () => {
       const moderator = new PerfettoSessionModerator(mockDevice, true);
       await moderator.clearPreviousConfigFiles();
       expect(runShellCmdSpy).toHaveBeenCalledOnceWith(
-        `su root rm -f ${PERFETTO_DUMP_CONFIG_FILE}`,
+        `rm -f ${PERFETTO_DUMP_CONFIG_FILE}`,
       );
     });
   });
@@ -220,13 +220,68 @@ describe('PerfettoSessionModerator', () => {
   });
 
   describe('createTracingSession', () => {
+    const mockConfigDataSources = [
+      `data_sources {
+  config {
+    name: "ds1"
+    extra_config_1 {
+      config_param_1: false
+    }
+  }
+}`,
+      `data_sources {
+  config {
+    name: "ds2"
+    extra_config_2 {
+      config_param_2: 1
+    }
+  }
+}`,
+    ];
     it('trace', () => {
       const moderator = new PerfettoSessionModerator(mockDevice, false);
-      const session = moderator.createTracingSession(['setup1']);
+      const session = moderator.createTracingSession(mockConfigDataSources);
       const expectedTarget = new TraceTarget(
         'PerfettoTrace',
-        ['setup1'],
-        `cat << EOF >> ${PERFETTO_TRACE_CONFIG_FILE}
+        [],
+        `cat << EOF > ${PERFETTO_TRACE_CONFIG_FILE}
+data_sources {
+  config {
+    name: "ds1"
+    extra_config_1 {
+      config_param_1: false
+    }
+  }
+}
+data_sources {
+  config {
+    name: "ds2"
+    extra_config_2 {
+      config_param_2: 1
+    }
+  }
+}
+data_sources {
+  config {
+    name: "linux.process_stats"
+    target_buffer: 0
+    process_stats_config {
+      scan_all_processes_on_start: true
+    }
+  }
+}
+data_sources: {
+  config {
+    name: "linux.ftrace"
+    ftrace_config {
+      ftrace_events: "ftrace/print"
+      ftrace_events: "task/task_newtask"
+      ftrace_events: "task/task_rename"
+      atrace_categories: "ss"
+      atrace_categories: "wm"
+    }
+  }
+}
 buffers: {
   size_kb: 500000
   fill_policy: RING_BUFFER
@@ -254,11 +309,27 @@ echo 'Perfetto trace stopped.'`,
 
     it('dump', () => {
       const moderator = new PerfettoSessionModerator(mockDevice, true);
-      const session = moderator.createTracingSession(['setup1']);
+      const session = moderator.createTracingSession(mockConfigDataSources);
       const expectedTarget = new TraceTarget(
         'PerfettoDump',
-        ['setup1'],
-        `cat << EOF >> ${PERFETTO_DUMP_CONFIG_FILE}
+        [],
+        `cat << EOF > ${PERFETTO_DUMP_CONFIG_FILE}
+data_sources {
+  config {
+    name: "ds1"
+    extra_config_1 {
+      config_param_1: false
+    }
+  }
+}
+data_sources {
+  config {
+    name: "ds2"
+    extra_config_2 {
+      config_param_2: 1
+    }
+  }
+}
 buffers: {
   size_kb: 500000
   fill_policy: RING_BUFFER
@@ -275,58 +346,50 @@ echo 'Dumped perfetto'`,
     });
   });
 
-  describe('createSetupCommand', () => {
+  describe('makeConfigDataSource', () => {
     it('trace', () => {
       const moderator = new PerfettoSessionModerator(mockDevice, false);
-      expect(moderator.createSetupCommand('ds1')).toEqual(
-        `cat << EOF >> ${PERFETTO_TRACE_CONFIG_FILE}
-data_sources: {
+      expect(moderator.makeConfigDataSource('ds1')).toEqual(
+        `data_sources: {
   config {
     name: "ds1"
   }
-}
-EOF`,
+}`,
       );
     });
 
     it('trace with config', () => {
       const moderator = new PerfettoSessionModerator(mockDevice, false);
-      expect(moderator.createSetupCommand('ds1', 'extraconfig {}')).toEqual(
-        `cat << EOF >> ${PERFETTO_TRACE_CONFIG_FILE}
-data_sources: {
+      expect(moderator.makeConfigDataSource('ds1', 'extraconfig {}')).toEqual(
+        `data_sources: {
   config {
     name: "ds1"
     extraconfig {}
   }
-}
-EOF`,
+}`,
       );
     });
 
     it('dump', () => {
       const moderator = new PerfettoSessionModerator(mockDevice, true);
-      expect(moderator.createSetupCommand('ds1')).toEqual(
-        `cat << EOF >> ${PERFETTO_DUMP_CONFIG_FILE}
-data_sources: {
+      expect(moderator.makeConfigDataSource('ds1')).toEqual(
+        `data_sources: {
   config {
     name: "ds1"
   }
-}
-EOF`,
+}`,
       );
     });
 
     it('dump with config', () => {
       const moderator = new PerfettoSessionModerator(mockDevice, true);
-      expect(moderator.createSetupCommand('ds1', 'extraconfig {}')).toEqual(
-        `cat << EOF >> ${PERFETTO_DUMP_CONFIG_FILE}
-data_sources: {
+      expect(moderator.makeConfigDataSource('ds1', 'extraconfig {}')).toEqual(
+        `data_sources: {
   config {
     name: "ds1"
     extraconfig {}
   }
-}
-EOF`,
+}`,
       );
     });
   });
diff --git a/tools/winscope/src/trace_collection/controller/trace_collection_controller.ts b/tools/winscope/src/trace_collection/controller/trace_collection_controller.ts
index 19c914797..3e6056fbd 100644
--- a/tools/winscope/src/trace_collection/controller/trace_collection_controller.ts
+++ b/tools/winscope/src/trace_collection/controller/trace_collection_controller.ts
@@ -179,8 +179,8 @@ export class TraceCollectionController {
     await perfettoModerator.tryStopCurrentPerfettoSession();
     await perfettoModerator.clearPreviousConfigFiles();
     console.debug('Clearing previous tracing session files from device');
-    await device.runShellCommand(`su root rm -rf ${WINSCOPE_BACKUP_DIR}`);
-    await device.runShellCommand(`su root mkdir ${WINSCOPE_BACKUP_DIR}`);
+    await device.runShellCommand(`rm -rf ${WINSCOPE_BACKUP_DIR}`);
+    await device.runShellCommand(`mkdir ${WINSCOPE_BACKUP_DIR}`);
     console.debug('Cleared previous tracing session files from device');
   }
 
diff --git a/tools/winscope/src/trace_collection/controller/trace_collection_controller_test.ts b/tools/winscope/src/trace_collection/controller/trace_collection_controller_test.ts
index ff9b6548a..acd9990ab 100644
--- a/tools/winscope/src/trace_collection/controller/trace_collection_controller_test.ts
+++ b/tools/winscope/src/trace_collection/controller/trace_collection_controller_test.ts
@@ -203,8 +203,8 @@ describe('TraceCollectionController', () => {
       expect(stopCurrentSession).toHaveBeenCalledTimes(1);
       expect(clearPreviousConfigFiles).toHaveBeenCalledTimes(1);
       expect(runShellCmdSpy.calls.allArgs().slice(1, 3).flat()).toEqual([
-        `su root rm -rf ${WINSCOPE_BACKUP_DIR}`,
-        `su root mkdir ${WINSCOPE_BACKUP_DIR}`,
+        `rm -rf ${WINSCOPE_BACKUP_DIR}`,
+        `mkdir ${WINSCOPE_BACKUP_DIR}`,
       ]);
       startSpy.calls.allArgs().forEach((args, index) => {
         expect(args[0].traceName).toEqual(targets[index].traceName);
@@ -278,7 +278,7 @@ describe('TraceCollectionController', () => {
         },
       ];
       const expectedCommands = [
-        `cat << EOF >> /data/misc/perfetto-configs/winscope-proxy-dump.conf
+        `cat << EOF > /data/misc/perfetto-configs/winscope-proxy-dump.conf
 data_sources: {
   config {
     name: "android.surfaceflinger.layers"
@@ -292,8 +292,6 @@ data_sources: {
     }
   }
 }
-EOF`,
-        `cat << EOF >> /data/misc/perfetto-configs/winscope-proxy-dump.conf
 buffers: {
   size_kb: 500000
   fill_policy: RING_BUFFER
@@ -324,8 +322,8 @@ echo 'Dumped perfetto'`,
 
       const expectedCommands = [
         'perfetto --query',
-        `su root rm -rf ${WINSCOPE_BACKUP_DIR}`,
-        `su root mkdir ${WINSCOPE_BACKUP_DIR}`,
+        `rm -rf ${WINSCOPE_BACKUP_DIR}`,
+        `mkdir ${WINSCOPE_BACKUP_DIR}`,
       ].concat(commands);
       runShellCmdSpy.calls.allArgs().forEach((args, index) => {
         expect(args[0]).toEqual(expectedCommands[index]);
diff --git a/tools/winscope/src/trace_collection/controller/tracing_session.ts b/tools/winscope/src/trace_collection/controller/tracing_session.ts
index f5f3b6607..e4dada8ce 100644
--- a/tools/winscope/src/trace_collection/controller/tracing_session.ts
+++ b/tools/winscope/src/trace_collection/controller/tracing_session.ts
@@ -48,6 +48,9 @@ export class TracingSession {
   }
 
   async moveFiles(device: AdbDeviceConnection) {
+    const isRoot = await device.checkRoot();
+    const maybeRootParam = isRoot ? 'su root ' : '';
+
     for (const file of this.target.fileIdentifiers) {
       const filepaths = await device.findFiles(file.path, file.matchers);
 
@@ -57,7 +60,12 @@ export class TracingSession {
         );
         try {
           await device.runShellCommand(
-            `su root [ ! -f ${filepath} ] || su root mv ${filepath} ${WINSCOPE_BACKUP_DIR}${file.destName}`,
+            maybeRootParam +
+              `[ -f ${filepath} ] && ` +
+              maybeRootParam +
+              `cp ${filepath} ${WINSCOPE_BACKUP_DIR}${file.destName} && ` +
+              maybeRootParam +
+              `rm -f ${filepath}`,
           );
           console.debug(
             `Moved ${filepath} to ${WINSCOPE_BACKUP_DIR}${file.destName} on device`,
diff --git a/tools/winscope/src/trace_collection/controller/tracing_session_test.ts b/tools/winscope/src/trace_collection/controller/tracing_session_test.ts
index f73031c6d..77fde70cb 100644
--- a/tools/winscope/src/trace_collection/controller/tracing_session_test.ts
+++ b/tools/winscope/src/trace_collection/controller/tracing_session_test.ts
@@ -36,8 +36,8 @@ describe('TracingSession', () => {
     listener,
   );
   const fileIdentifiers = [
-    new AdbFileIdentifier('test path 1', ['matcher'], 'saved file 1'),
-    new AdbFileIdentifier('test path 2', ['matcher'], 'saved file 2'),
+    new AdbFileIdentifier('test path 1', ['matcher'], 'saved_file_1'),
+    new AdbFileIdentifier('test path 2', ['matcher'], 'saved_file_2'),
   ];
   const sessionName = 'TestSession';
   const stopCmd = 'test stop cmd';
@@ -108,19 +108,45 @@ describe('TracingSession', () => {
       ['test path 2', ['matcher']],
     ]);
     expect(runShellCmdSpy.calls.allArgs()).toEqual([
+      ['su root id -u'],
       [
-        `su root [ ! -f file ] || su root mv file ${WINSCOPE_BACKUP_DIR}saved file 1`,
+        `[ -f file ] && cp file ${WINSCOPE_BACKUP_DIR}saved_file_1 && rm -f file`,
       ],
       [
-        `su root [ ! -f file ] || su root mv file ${WINSCOPE_BACKUP_DIR}saved file 2`,
+        `[ -f file ] && cp file ${WINSCOPE_BACKUP_DIR}saved_file_2 && rm -f file`,
+      ],
+    ]);
+  });
+
+  it('moves files as root', async () => {
+    runShellCmdSpy.and.returnValue(Promise.resolve(''));
+    setDeviceAsRoot();
+    await session.moveFiles(mockDevice);
+    expect(findFilesSpy.calls.allArgs()).toEqual([
+      ['test path 1', ['matcher']],
+      ['test path 2', ['matcher']],
+    ]);
+    expect(runShellCmdSpy.calls.allArgs()).toEqual([
+      ['su root id -u'],
+      [
+        `su root [ -f file ] && su root cp file ${WINSCOPE_BACKUP_DIR}saved_file_1 && su root rm -f file`,
+      ],
+      [
+        `su root [ -f file ] && su root cp file ${WINSCOPE_BACKUP_DIR}saved_file_2 && su root rm -f file`,
       ],
     ]);
   });
 
   it('handles error in move command', async () => {
+    runShellCmdSpy.and.returnValue(Promise.resolve(''));
+    runShellCmdSpy
+      .withArgs(
+        `[ -f file ] && cp file ${WINSCOPE_BACKUP_DIR}saved_file_1 && rm -f file`,
+      )
+      .and.throwError(new Error());
     runShellCmdSpy
       .withArgs(
-        `su root [ ! -f file ] || su root mv file ${WINSCOPE_BACKUP_DIR}saved file 1`,
+        `[ -f file ] && cp file ${WINSCOPE_BACKUP_DIR}saved_file_2 && rm -f file`,
       )
       .and.throwError(new Error());
     await expectAsync(session.moveFiles(mockDevice)).toBeResolved();
@@ -133,4 +159,10 @@ describe('TracingSession', () => {
       expect(endTraceSpy).toHaveBeenCalledWith(...endArgs);
     }
   }
+
+  function setDeviceAsRoot() {
+    runShellCmdSpy
+      .withArgs('su root id -u')
+      .and.returnValue(Promise.resolve('0'));
+  }
 });
diff --git a/tools/winscope/src/trace_collection/controller/user_request_parser.ts b/tools/winscope/src/trace_collection/controller/user_request_parser.ts
index 562838136..1ffe0bd0b 100644
--- a/tools/winscope/src/trace_collection/controller/user_request_parser.ts
+++ b/tools/winscope/src/trace_collection/controller/user_request_parser.ts
@@ -41,6 +41,7 @@ export class UserRequestParser {
     [UiTraceTarget.VIEW_CAPTURE, 'android.viewcapture'],
     [UiTraceTarget.INPUT, 'android.input.inputevent'],
     [UiTraceTarget.SURFACE_FLINGER_DUMP, 'android.surfaceflinger.layers'],
+    [UiTraceTarget.WINDOW_MANAGER_DUMP, 'android.windowmanager'],
   ]);
 
   private perfettoModerator: PerfettoSessionModerator | undefined;
@@ -58,7 +59,7 @@ export class UserRequestParser {
 
   async parse(): Promise<TracingSession[]> {
     const traceTargets: TraceTarget[] = [];
-    const perfettoSetup: string[] = [];
+    const perfettoConfigDataSources: string[] = [];
     const perfettoModerator = assertDefined(this.perfettoModerator);
 
     for (const req of assertDefined(this.requests)) {
@@ -70,9 +71,9 @@ export class UserRequestParser {
         !(await perfettoModerator.isTooManySessions()) && dataSourceAvailable;
 
       if (isPerfetto) {
-        const cmd = this.getPerfettoSetupCommand(req);
-        if (cmd) {
-          perfettoSetup.push(cmd);
+        const configFileDs = this.getPerfettoDataSourceConfig(req);
+        if (configFileDs) {
+          perfettoConfigDataSources.push(configFileDs);
         }
       } else {
         const targets = this.getNonPerfettoTargets(req);
@@ -85,32 +86,36 @@ export class UserRequestParser {
     const sessions = traceTargets.map((target) => {
       return new TracingSession(target);
     });
-    if (perfettoSetup.length > 0) {
-      sessions.push(perfettoModerator.createTracingSession(perfettoSetup));
+    if (perfettoConfigDataSources.length > 0) {
+      sessions.push(
+        perfettoModerator.createTracingSession(perfettoConfigDataSources),
+      );
     }
     return sessions;
   }
 
-  private getPerfettoSetupCommand(req: UserRequest): string | undefined {
+  private getPerfettoDataSourceConfig(req: UserRequest): string | undefined {
     switch (req.target) {
       case UiTraceTarget.SURFACE_FLINGER_TRACE:
-        return this.getSfTracePerfettoSetupCommand(req);
+        return this.getSfTracePerfettoConfigDataSource(req);
       case UiTraceTarget.WINDOW_MANAGER_TRACE:
-        return this.getWmTracePerfettoSetupCommand(req);
+        return this.getWmTracePerfettoConfigDataSource(req);
       case UiTraceTarget.VIEW_CAPTURE:
-        return this.getVcPerfettoSetupCommand();
+        return this.getVcPerfettoConfigDataSource();
       case UiTraceTarget.TRANSACTIONS:
-        return this.getTransactionsPerfettoSetupCommand();
+        return this.getTransactionsPerfettoConfigDataSource();
       case UiTraceTarget.PROTO_LOG:
-        return this.getProtologPerfettoSetupCommand();
+        return this.getProtologPerfettoConfigDataSource();
       case UiTraceTarget.IME:
-        return this.getImePerfettoSetupCommand();
+        return this.getImePerfettoConfigDataSource();
       case UiTraceTarget.TRANSITIONS:
-        return this.getTransitionsPerfettoSetupCommand();
+        return this.getTransitionsPerfettoConfigDataSource();
       case UiTraceTarget.INPUT:
-        return this.getInputPerfettoSetupCommand();
+        return this.getInputPerfettoConfigDataSource();
       case UiTraceTarget.SURFACE_FLINGER_DUMP:
-        return this.getSfDumpPerfettoSetupCommand();
+        return this.getSfDumpPerfettoConfigDataSource();
+      case UiTraceTarget.WINDOW_MANAGER_DUMP:
+        return this.getWmDumpPerfettoConfigDataSource();
       default:
         return undefined;
     }
@@ -149,7 +154,7 @@ export class UserRequestParser {
     }
   }
 
-  private getSfTracePerfettoSetupCommand(req: UserRequest) {
+  private getSfTracePerfettoConfigDataSource(req: UserRequest) {
     const flagsMap: {[key: string]: string} = {
       'input': 'TRACE_FLAG_INPUT',
       'composition': 'TRACE_FLAG_COMPOSITION',
@@ -166,7 +171,7 @@ export class UserRequestParser {
         return `trace_flags: ${flagsMap[flag]}`;
       })
       .join(spacer);
-    return this.perfettoModerator?.createSetupCommand(
+    return this.perfettoModerator?.makeConfigDataSource(
       'android.surfaceflinger.layers',
       `surfaceflinger_layers_config: {
       mode: MODE_ACTIVE${flagsCmd.length === 0 ? '' : spacer + flagsCmd}
@@ -212,7 +217,7 @@ export class UserRequestParser {
     );
   }
 
-  private getWmTracePerfettoSetupCommand(req: UserRequest) {
+  private getWmTracePerfettoConfigDataSource(req: UserRequest) {
     const selectedConfigs = new WmRequestConfigParser().parse(req.config);
 
     const logLevelMap: {[key: string]: string} = {
@@ -228,7 +233,7 @@ export class UserRequestParser {
 
     const logLevel = logLevelMap[selectedConfigs['tracinglevel']];
     const logFrequency = frequencyMap[selectedConfigs['tracingtype']];
-    return this.perfettoModerator?.createSetupCommand(
+    return this.perfettoModerator?.makeConfigDataSource(
       'android.windowmanager',
       `windowmanager_config: {
       log_level: ${logLevel}
@@ -262,8 +267,8 @@ export class UserRequestParser {
     );
   }
 
-  private getVcPerfettoSetupCommand() {
-    return this.perfettoModerator?.createSetupCommand('android.viewcapture');
+  private getVcPerfettoConfigDataSource() {
+    return this.perfettoModerator?.makeConfigDataSource('android.viewcapture');
   }
 
   private getVcLegacyTarget() {
@@ -285,8 +290,8 @@ export class UserRequestParser {
     );
   }
 
-  private getTransactionsPerfettoSetupCommand() {
-    return this.perfettoModerator?.createSetupCommand(
+  private getTransactionsPerfettoConfigDataSource() {
+    return this.perfettoModerator?.makeConfigDataSource(
       'android.surfaceflinger.transactions',
       `surfaceflinger_transactions_config: {
       mode: MODE_ACTIVE
@@ -312,8 +317,8 @@ export class UserRequestParser {
     );
   }
 
-  private getProtologPerfettoSetupCommand() {
-    return this.perfettoModerator?.createSetupCommand(
+  private getProtologPerfettoConfigDataSource() {
+    return this.perfettoModerator?.makeConfigDataSource(
       'android.protolog',
       `protolog_config: {
       tracing_mode: ENABLE_ALL
@@ -339,8 +344,8 @@ export class UserRequestParser {
     );
   }
 
-  private getImePerfettoSetupCommand() {
-    return this.perfettoModerator?.createSetupCommand('android.inputmethod');
+  private getImePerfettoConfigDataSource() {
+    return this.perfettoModerator?.makeConfigDataSource('android.inputmethod');
   }
 
   private getImeLegacyTarget() {
@@ -369,8 +374,8 @@ export class UserRequestParser {
     );
   }
 
-  private getTransitionsPerfettoSetupCommand() {
-    return this.perfettoModerator?.createSetupCommand(
+  private getTransitionsPerfettoConfigDataSource() {
+    return this.perfettoModerator?.makeConfigDataSource(
       'com.android.wm.shell.transition',
     );
   }
@@ -400,8 +405,8 @@ export class UserRequestParser {
     );
   }
 
-  private getInputPerfettoSetupCommand() {
-    return this.perfettoModerator?.createSetupCommand(
+  private getInputPerfettoConfigDataSource() {
+    return this.perfettoModerator?.makeConfigDataSource(
       'android.input.inputevent',
       `android_input_event_config {
       mode: TRACE_MODE_TRACE_ALL
@@ -494,8 +499,8 @@ export class UserRequestParser {
     );
   }
 
-  private getSfDumpPerfettoSetupCommand() {
-    return this.perfettoModerator?.createSetupCommand(
+  private getSfDumpPerfettoConfigDataSource() {
+    return this.perfettoModerator?.makeConfigDataSource(
       'android.surfaceflinger.layers',
       `surfaceflinger_layers_config: {
       mode: MODE_DUMP
@@ -524,6 +529,16 @@ export class UserRequestParser {
     );
   }
 
+  private getWmDumpPerfettoConfigDataSource() {
+    return this.perfettoModerator?.makeConfigDataSource(
+      'android.windowmanager',
+      `windowmanager_config: {
+      log_level: LOG_LEVEL_VERBOSE
+      log_frequency: LOG_FREQUENCY_SINGLE_DUMP
+    }`,
+    );
+  }
+
   private getWmDumpLegacyTarget() {
     return new TraceTarget(
       'WmDumpLegacy',
diff --git a/tools/winscope/src/trace_collection/controller/user_request_parser_test.ts b/tools/winscope/src/trace_collection/controller/user_request_parser_test.ts
index 2902455d4..ea2c598fd 100644
--- a/tools/winscope/src/trace_collection/controller/user_request_parser_test.ts
+++ b/tools/winscope/src/trace_collection/controller/user_request_parser_test.ts
@@ -20,11 +20,7 @@ import {MockAdbDeviceConnection} from 'trace_collection/mock/mock_adb_device_con
 import {AdbFileIdentifier, TraceTarget} from 'trace_collection/trace_target';
 import {UiTraceTarget} from 'trace_collection/ui/ui_trace_target';
 import {UserRequest, UserRequestConfig} from 'trace_collection/user_request';
-import {
-  PerfettoSessionModerator,
-  PERFETTO_DUMP_CONFIG_FILE,
-  PERFETTO_TRACE_CONFIG_FILE,
-} from './perfetto_session_moderator';
+import {PerfettoSessionModerator} from './perfetto_session_moderator';
 import {TracingSession} from './tracing_session';
 import {UserRequestParser} from './user_request_parser';
 
@@ -53,8 +49,7 @@ describe('UserRequestParser', () => {
     ],
   );
   const expectedSfLegacySession = new TracingSession(expectedSfLegacyTarget);
-  const expectedWmPerfettoSetupCommand = `cat << EOF >> ${PERFETTO_TRACE_CONFIG_FILE}
-data_sources: {
+  const expectedWmPerfettoConfigDs = `data_sources: {
   config {
     name: "android.windowmanager"
     windowmanager_config: {
@@ -62,8 +57,7 @@ data_sources: {
       log_frequency: LOG_FREQUENCY_FRAME
     }
   }
-}
-EOF`;
+}`;
   let isTooManySessions: jasmine.Spy;
 
   beforeEach(() => {
@@ -82,7 +76,7 @@ EOF`;
     expect(await parseRequests(req)).toEqual([expectedSfLegacySession]);
   });
 
-  it('makes perfetto session with multiple setup commands', async () => {
+  it('makes perfetto session with multiple data sources', async () => {
     const req: UserRequest[] = [
       {target: UiTraceTarget.SURFACE_FLINGER_TRACE, config: []},
       {target: UiTraceTarget.WINDOW_MANAGER_TRACE, config: []},
@@ -92,17 +86,15 @@ EOF`;
     );
     expect(await parseRequests(req)).toEqual([
       moderator.createTracingSession([
-        `cat << EOF >> ${PERFETTO_TRACE_CONFIG_FILE}
-data_sources: {
+        `data_sources: {
   config {
     name: "android.surfaceflinger.layers"
     surfaceflinger_layers_config: {
       mode: MODE_ACTIVE
     }
   }
-}
-EOF`,
-        expectedWmPerfettoSetupCommand,
+}`,
+        expectedWmPerfettoConfigDs,
       ]),
     ]);
   });
@@ -135,25 +127,23 @@ EOF`,
       .and.returnValue(Promise.resolve(true));
     expect(await parseRequests(req)).toEqual([
       expectedSfLegacySession,
-      moderator.createTracingSession([expectedWmPerfettoSetupCommand]),
+      moderator.createTracingSession([expectedWmPerfettoConfigDs]),
     ]);
   });
 
   describe('makes SF trace perfetto session', () => {
-    const expectedSfSetupCommand = `cat << EOF >> ${PERFETTO_TRACE_CONFIG_FILE}
-data_sources: {
+    const expectedSfConfigDs = `data_sources: {
   config {
     name: "android.surfaceflinger.layers"
     surfaceflinger_layers_config: {
       mode: MODE_ACTIVE
     }
   }
-}
-EOF`;
+}`;
 
     it('without config', async () => {
       await checkPerfettoSessionCreated(
-        expectedSfSetupCommand,
+        expectedSfConfigDs,
         'android.surfaceflinger.layers',
         UiTraceTarget.SURFACE_FLINGER_TRACE,
       );
@@ -161,7 +151,7 @@ EOF`;
 
     it('with invalid config', async () => {
       await checkPerfettoSessionCreated(
-        expectedSfSetupCommand,
+        expectedSfConfigDs,
         'android.surfaceflinger.layers',
         UiTraceTarget.SURFACE_FLINGER_TRACE,
         [{key: 'invalid', value: '123'}],
@@ -169,8 +159,7 @@ EOF`;
     });
 
     it('with flags', async () => {
-      const setupCommand = `cat << EOF >> ${PERFETTO_TRACE_CONFIG_FILE}
-data_sources: {
+      const configDs = `data_sources: {
   config {
     name: "android.surfaceflinger.layers"
     surfaceflinger_layers_config: {
@@ -180,10 +169,9 @@ data_sources: {
       trace_flags: TRACE_FLAG_VIRTUAL_DISPLAYS
     }
   }
-}
-EOF`;
+}`;
       await checkPerfettoSessionCreated(
-        setupCommand,
+        configDs,
         'android.surfaceflinger.layers',
         UiTraceTarget.SURFACE_FLINGER_TRACE,
         [{key: 'input'}, {key: 'hwc'}, {key: 'virtualdisplays'}],
@@ -194,7 +182,7 @@ EOF`;
   describe('makes WM trace perfetto session', () => {
     it('without config', async () => {
       await checkPerfettoSessionCreated(
-        expectedWmPerfettoSetupCommand,
+        expectedWmPerfettoConfigDs,
         'android.windowmanager',
         UiTraceTarget.WINDOW_MANAGER_TRACE,
       );
@@ -202,7 +190,7 @@ EOF`;
 
     it('with invalid config', async () => {
       await checkPerfettoSessionCreated(
-        expectedWmPerfettoSetupCommand,
+        expectedWmPerfettoConfigDs,
         'android.windowmanager',
         UiTraceTarget.WINDOW_MANAGER_TRACE,
         [{key: 'invalid', value: '123'}],
@@ -210,8 +198,7 @@ EOF`;
     });
 
     it('with log level and frequency', async () => {
-      const setupCommand = `cat << EOF >> ${PERFETTO_TRACE_CONFIG_FILE}
-data_sources: {
+      const dataSource = `data_sources: {
   config {
     name: "android.windowmanager"
     windowmanager_config: {
@@ -219,10 +206,9 @@ data_sources: {
       log_frequency: LOG_FREQUENCY_TRANSACTION
     }
   }
-}
-EOF`;
+}`;
       await checkPerfettoSessionCreated(
-        setupCommand,
+        dataSource,
         'android.windowmanager',
         UiTraceTarget.WINDOW_MANAGER_TRACE,
         [
@@ -234,107 +220,94 @@ EOF`;
   });
 
   it('makes VC perfetto session', async () => {
-    const setupCommand = `cat << EOF >> ${PERFETTO_TRACE_CONFIG_FILE}
-data_sources: {
+    const configDs = `data_sources: {
   config {
     name: "android.viewcapture"
   }
-}
-EOF`;
+}`;
     await checkPerfettoSessionCreated(
-      setupCommand,
+      configDs,
       'android.viewcapture',
       UiTraceTarget.VIEW_CAPTURE,
     );
   });
 
   it('makes transactions perfetto session', async () => {
-    const setupCommand = `cat << EOF >> ${PERFETTO_TRACE_CONFIG_FILE}
-data_sources: {
+    const configDs = `data_sources: {
   config {
     name: "android.surfaceflinger.transactions"
     surfaceflinger_transactions_config: {
       mode: MODE_ACTIVE
     }
   }
-}
-EOF`;
+}`;
     await checkPerfettoSessionCreated(
-      setupCommand,
+      configDs,
       'android.surfaceflinger.transactions',
       UiTraceTarget.TRANSACTIONS,
     );
   });
 
   it('makes protolog perfetto session', async () => {
-    const setupCommand = `cat << EOF >> ${PERFETTO_TRACE_CONFIG_FILE}
-data_sources: {
+    const configDs = `data_sources: {
   config {
     name: "android.protolog"
     protolog_config: {
       tracing_mode: ENABLE_ALL
     }
   }
-}
-EOF`;
+}`;
     await checkPerfettoSessionCreated(
-      setupCommand,
+      configDs,
       'android.protolog',
       UiTraceTarget.PROTO_LOG,
     );
   });
 
   it('makes IME perfetto session', async () => {
-    const setupCommand = `cat << EOF >> ${PERFETTO_TRACE_CONFIG_FILE}
-data_sources: {
+    const configDs = `data_sources: {
   config {
     name: "android.inputmethod"
   }
-}
-EOF`;
+}`;
     await checkPerfettoSessionCreated(
-      setupCommand,
+      configDs,
       'android.inputmethod',
       UiTraceTarget.IME,
     );
   });
 
   it('makes transitions perfetto session', async () => {
-    const setupCommand = `cat << EOF >> ${PERFETTO_TRACE_CONFIG_FILE}
-data_sources: {
+    const configDs = `data_sources: {
   config {
     name: "com.android.wm.shell.transition"
   }
-}
-EOF`;
+}`;
     await checkPerfettoSessionCreated(
-      setupCommand,
+      configDs,
       'com.android.wm.shell.transition',
       UiTraceTarget.TRANSITIONS,
     );
   });
 
   it('makes input perfetto session', async () => {
-    const setupCommand = `cat << EOF >> ${PERFETTO_TRACE_CONFIG_FILE}
-data_sources: {
+    const configDs = `data_sources: {
   config {
     name: "android.input.inputevent"
     android_input_event_config {
       mode: TRACE_MODE_TRACE_ALL
     }
   }
-}
-EOF`;
+}`;
     await checkPerfettoSessionCreated(
-      setupCommand,
+      configDs,
       'android.input.inputevent',
       UiTraceTarget.INPUT,
     );
   });
 
   it('makes SF dump perfetto session', async () => {
-    const setupCommand = `cat << EOF >> ${PERFETTO_DUMP_CONFIG_FILE}
-data_sources: {
+    const configDs = `data_sources: {
   config {
     name: "android.surfaceflinger.layers"
     surfaceflinger_layers_config: {
@@ -346,10 +319,9 @@ data_sources: {
       trace_flags: TRACE_FLAG_VIRTUAL_DISPLAYS
     }
   }
-}
-EOF`;
+}`;
     await checkPerfettoSessionCreated(
-      setupCommand,
+      configDs,
       'android.surfaceflinger.layers',
       UiTraceTarget.SURFACE_FLINGER_DUMP,
       [],
@@ -357,6 +329,25 @@ EOF`;
     );
   });
 
+  it('makes WM dump perfetto session', async () => {
+    const configDs = `data_sources: {
+  config {
+    name: "android.windowmanager"
+    windowmanager_config: {
+      log_level: LOG_LEVEL_VERBOSE
+      log_frequency: LOG_FREQUENCY_SINGLE_DUMP
+    }
+  }
+}`;
+    await checkPerfettoSessionCreated(
+      configDs,
+      'android.windowmanager',
+      UiTraceTarget.WINDOW_MANAGER_DUMP,
+      [],
+      new PerfettoSessionModerator(mockDevice, true),
+    );
+  });
+
   describe('makes SF trace legacy session', () => {
     it('without config', async () => {
       await checkSession(expectedSfLegacyTarget, []);
@@ -928,7 +919,7 @@ EOF`;
   }
 
   async function checkPerfettoSessionCreated(
-    setupCmd: string,
+    perfettoDs: string,
     ds: string,
     target: UiTraceTarget,
     config: UserRequestConfig[] = [],
@@ -939,7 +930,7 @@ EOF`;
       .and.returnValue(Promise.resolve(true));
     const req: UserRequest[] = [{target, config}];
     expect(await parseRequests(req, perfettoModerator)).toEqual([
-      perfettoModerator.createTracingSession([setupCmd]),
+      perfettoModerator.createTracingSession([perfettoDs]),
     ]);
   }
 
diff --git a/tools/winscope/src/trace_collection/ui/ui_trace_configuration.ts b/tools/winscope/src/trace_collection/ui/ui_trace_configuration.ts
index 93f39b562..0d60430c0 100644
--- a/tools/winscope/src/trace_collection/ui/ui_trace_configuration.ts
+++ b/tools/winscope/src/trace_collection/ui/ui_trace_configuration.ts
@@ -104,7 +104,7 @@ const sfTraceCheckboxConfigs: CheckboxConfiguration[] = [
     enabled: true,
   },
   {
-    name: 'metadata',
+    name: 'metadata (with offscreen layers)',
     key: 'metadata',
     enabled: false,
   },
@@ -155,7 +155,7 @@ export function makeScreenRecordingSelectionConfigs(
       options,
       value: initialValue,
       optional: true,
-      desc: 'Leave empty to capture active display',
+      desc: 'Leave empty to track and capture display that is on',
       wideField: true,
     },
   ];
diff --git a/tools/winscope/src/trace_collection/wdp/adb_websocket_stream.ts b/tools/winscope/src/trace_collection/wdp/adb_websocket_stream.ts
index 0d2f42295..673fa6f31 100644
--- a/tools/winscope/src/trace_collection/wdp/adb_websocket_stream.ts
+++ b/tools/winscope/src/trace_collection/wdp/adb_websocket_stream.ts
@@ -15,6 +15,7 @@
  */
 
 import {FunctionUtils} from 'common/function_utils';
+import {base64Decode} from 'common/string_utils';
 import {ErrorListener, WebSocketStream} from './websocket_stream';
 
 interface AdbResponse {
@@ -22,6 +23,7 @@ interface AdbResponse {
     type: string;
     message: string;
   };
+  response?: string; // base64-encoded
 }
 
 export type DataListener = (data: Uint8Array) => void;
@@ -41,31 +43,33 @@ export abstract class AdbWebSocketStream extends WebSocketStream {
       this.close();
     };
     sock.onmessage = async (e: MessageEvent) => {
+      let adbResponse: AdbResponse | undefined;
       try {
         if (e.data instanceof ArrayBuffer) {
           this.onData(new Uint8Array(e.data));
         } else if (e.data instanceof Blob) {
           this.onData(new Uint8Array(await e.data.arrayBuffer()));
+        } else if (typeof e.data === 'string') {
+          try {
+            adbResponse = JSON.parse(e.data);
+          } catch (e) {
+            throw new Error('Failed to decode ADB JSON response');
+          }
+          if (adbResponse?.response !== undefined) {
+            this.onData(base64Decode(adbResponse.response));
+          } else {
+            throw new Error('Received empty ADB response');
+          }
         } else {
           throw new Error('Expected message data to be ArrayBuffer or Blob');
         }
       } catch (error) {
         console.debug('WebSocket failed, state: ' + sock.readyState);
-        let adbError: string | undefined;
-        if (typeof e.data === 'string') {
-          try {
-            const data: AdbResponse = JSON.parse(e.data);
-            if (data.error) {
-              adbError = data.error.message;
-            }
-          } catch (e) {
-            // do nothing
-          }
-        }
+        const errMsg = adbResponse?.error?.message;
         this.onError(
           `Could not parse data:\nReceived: ${e.data}` +
             `\nError: ${(error as Error).message}.` +
-            (adbError ? `\nADB Error: ` + adbError : ''),
+            (errMsg ? `\nADB Error: ` + errMsg : ''),
         );
       }
     };
diff --git a/tools/winscope/src/trace_collection/wdp/devices_stream_test.ts b/tools/winscope/src/trace_collection/wdp/devices_stream_test.ts
index 4225bffbd..06b8eee00 100644
--- a/tools/winscope/src/trace_collection/wdp/devices_stream_test.ts
+++ b/tools/winscope/src/trace_collection/wdp/devices_stream_test.ts
@@ -15,7 +15,10 @@
  */
 
 import {TimeUtils} from 'common/time/time_utils';
-import {UnitTestUtils} from 'test/unit/utils';
+import {
+  makeFakeWebSocket,
+  makeFakeWebSocketMessage,
+} from 'test/unit/web_socket_utils';
 import {DevicesStream} from './devices_stream';
 
 describe('DevicesStream', () => {
@@ -26,7 +29,7 @@ describe('DevicesStream', () => {
   let webSocket: jasmine.SpyObj<WebSocket>;
 
   beforeEach(() => {
-    webSocket = UnitTestUtils.makeFakeWebSocket();
+    webSocket = makeFakeWebSocket();
     errorListener.calls.reset();
     stream = new DevicesStream(webSocket, dataListener, errorListener);
   });
@@ -55,6 +58,6 @@ describe('DevicesStream', () => {
   });
 
   function receiveMessage() {
-    webSocket.onmessage!(UnitTestUtils.makeFakeWebSocketMessage('test'));
+    webSocket.onmessage!(makeFakeWebSocketMessage('test'));
   }
 });
diff --git a/tools/winscope/src/trace_collection/wdp/shell_stream_test.ts b/tools/winscope/src/trace_collection/wdp/shell_stream_test.ts
index 3fed5194f..589aa1cbd 100644
--- a/tools/winscope/src/trace_collection/wdp/shell_stream_test.ts
+++ b/tools/winscope/src/trace_collection/wdp/shell_stream_test.ts
@@ -14,8 +14,12 @@
  * limitations under the License.
  */
 
+import {base64Encode} from 'common/string_utils';
 import {TimeUtils} from 'common/time/time_utils';
-import {UnitTestUtils} from 'test/unit/utils';
+import {
+  makeFakeWebSocket,
+  makeFakeWebSocketMessage,
+} from 'test/unit/web_socket_utils';
 import {ShellStream} from './shell_stream';
 
 describe('ShellStream', () => {
@@ -26,7 +30,7 @@ describe('ShellStream', () => {
   let webSocket: jasmine.SpyObj<WebSocket>;
 
   beforeEach(() => {
-    webSocket = UnitTestUtils.makeFakeWebSocket();
+    webSocket = makeFakeWebSocket();
     errorListener.calls.reset();
     stream = new ShellStream(
       webSocket,
@@ -66,20 +70,28 @@ describe('ShellStream', () => {
 
   it('calls data listener on array buffer message', async () => {
     const data = new ArrayBuffer(0);
-    const message = UnitTestUtils.makeFakeWebSocketMessage(data);
+    const message = makeFakeWebSocketMessage(data);
     webSocket.onmessage!(message);
     expect(dataListener).toHaveBeenCalledWith(new Uint8Array(data));
   });
 
   it('calls data listener on blob message', async () => {
     const data = new Blob();
-    const message = UnitTestUtils.makeFakeWebSocketMessage(data);
+    const message = makeFakeWebSocketMessage(data);
     webSocket.onmessage!(message);
     expect(dataListener).toHaveBeenCalledWith(
       new Uint8Array(await data.arrayBuffer()),
     );
   });
 
+  it('calls data listener on AdbResponse json message with response', async () => {
+    const data = Uint8Array.from([]);
+    const messageData = JSON.stringify({response: base64Encode(data)});
+    const message = makeFakeWebSocketMessage(messageData);
+    webSocket.onmessage!(message);
+    expect(dataListener).toHaveBeenCalledWith(data);
+  });
+
   it('resolves complete promise on close', async () => {
     let completed = false;
     stream.complete.then(() => {
@@ -87,34 +99,34 @@ describe('ShellStream', () => {
     });
     await stream.connect();
     expect(completed).toBeFalse();
-    webSocket.onclose!(new CloseEvent(''));
+    webSocket.onclose!(new CloseEvent('close'));
     await TimeUtils.wait(() => completed);
   });
 
-  it('calls error listener if unexpected message type received - AdbResponse json', async () => {
+  it('calls error listener if unexpected message type received - AdbResponse json without response', async () => {
     const data = JSON.stringify({error: {type: '', message: 'failed'}});
-    const message = UnitTestUtils.makeFakeWebSocketMessage(data);
+    const message = makeFakeWebSocketMessage(data);
     webSocket.onmessage!(message);
     expect(errorListener).toHaveBeenCalledOnceWith(
       `Could not parse data:\nReceived: {"error":{"type":"","message":"failed"}}` +
-        `\nError: Expected message data to be ArrayBuffer or Blob.` +
+        `\nError: Received empty ADB response.` +
         `\nADB Error: failed`,
     );
     errorListener.calls.reset();
   });
 
   it('calls error listener if unexpected message type received - unknown string', async () => {
-    const message = UnitTestUtils.makeFakeWebSocketMessage('unknown error');
+    const message = makeFakeWebSocketMessage('unknown error');
     webSocket.onmessage!(message);
     expect(errorListener).toHaveBeenCalledOnceWith(
       `Could not parse data:\nReceived: unknown error` +
-        `\nError: Expected message data to be ArrayBuffer or Blob.`,
+        `\nError: Failed to decode ADB JSON response.`,
     );
     errorListener.calls.reset();
   });
 
   it('calls error listener if unexpected message type received - unknown code', async () => {
-    const message = UnitTestUtils.makeFakeWebSocketMessage(200);
+    const message = makeFakeWebSocketMessage(200);
     webSocket.onmessage!(message);
     expect(errorListener).toHaveBeenCalledOnceWith(
       `Could not parse data:\nReceived: 200` +
diff --git a/tools/winscope/src/trace_collection/wdp/stream_provider_test.ts b/tools/winscope/src/trace_collection/wdp/stream_provider_test.ts
index e4557a609..dc8d6fc70 100644
--- a/tools/winscope/src/trace_collection/wdp/stream_provider_test.ts
+++ b/tools/winscope/src/trace_collection/wdp/stream_provider_test.ts
@@ -14,9 +14,12 @@
  * limitations under the License.
  */
 
-import {stringToByteArray} from 'common/buffer_utils';
-import {UnitTestUtils} from 'test/unit/utils';
-import {waitToBeCalled} from 'test/utils';
+import {binaryEncode} from 'common/string_utils';
+import {waitToBeCalled} from 'test/unit/spy_utils';
+import {
+  makeFakeWebSocket,
+  makeFakeWebSocketMessage,
+} from 'test/unit/web_socket_utils';
 import {StreamProvider} from './stream_provider';
 
 describe('StreamProvider', () => {
@@ -27,7 +30,7 @@ describe('StreamProvider', () => {
   let streamProvider: StreamProvider;
 
   beforeEach(() => {
-    sock = UnitTestUtils.makeFakeWebSocket();
+    sock = makeFakeWebSocket();
     dataListener = jasmine.createSpy();
     errorListener = jasmine.createSpy();
     streamProvider = new StreamProvider();
@@ -46,7 +49,7 @@ describe('StreamProvider', () => {
       }),
     );
 
-    sock.onmessage!(UnitTestUtils.makeFakeWebSocketMessage(''));
+    sock.onmessage!(makeFakeWebSocketMessage(''));
     expect(errorListener).toHaveBeenCalledTimes(1);
 
     const spy = spyOn(stream, 'close');
@@ -72,12 +75,10 @@ describe('StreamProvider', () => {
       }),
     );
 
-    sock.onmessage!(
-      UnitTestUtils.makeFakeWebSocketMessage(stringToByteArray('').buffer),
-    );
+    sock.onmessage!(makeFakeWebSocketMessage(binaryEncode('').buffer));
     expect(dataListener).toHaveBeenCalledTimes(1);
 
-    sock.onmessage!(UnitTestUtils.makeFakeWebSocketMessage(''));
+    sock.onmessage!(makeFakeWebSocketMessage(''));
     expect(errorListener).toHaveBeenCalledTimes(1);
 
     const spy = spyOn(stream, 'close');
@@ -93,7 +94,7 @@ describe('StreamProvider', () => {
     const stream = createDevicesStream();
     await stream.connect();
 
-    sock.onmessage!(UnitTestUtils.makeFakeWebSocketMessage(''));
+    sock.onmessage!(makeFakeWebSocketMessage(''));
     await waitToBeCalled(dataListener, 1);
 
     sock.onerror!(new Event(''));
diff --git a/tools/winscope/src/trace_collection/wdp/sync_stream.ts b/tools/winscope/src/trace_collection/wdp/sync_stream.ts
index 9bccd58d0..e7f9f5622 100644
--- a/tools/winscope/src/trace_collection/wdp/sync_stream.ts
+++ b/tools/winscope/src/trace_collection/wdp/sync_stream.ts
@@ -17,9 +17,9 @@
 import {
   ArrayBufferBuilder,
   BufferToken,
-  byteArrayToString,
   ResizableBuffer,
 } from 'common/buffer_utils';
+import {utf8Decode} from 'common/string_utils';
 import {AdbWebSocketStream} from './adb_websocket_stream';
 import {ErrorListener} from './websocket_stream';
 
@@ -68,7 +68,7 @@ export class SyncStream extends AdbWebSocketStream {
     }
 
     // check start id of next chunk
-    const startId = byteArrayToString(data.slice(0, 4));
+    const startId = utf8Decode(data.slice(0, 4));
     const chunkLength = this.getChunkLength(data.slice(4, 8));
     if (data.length === 8 && startId === SyncStream.DONE_ID) {
       this.close();
@@ -86,9 +86,7 @@ export class SyncStream extends AdbWebSocketStream {
     data = data.slice(8);
 
     // check end id of remaining data
-    const endId = byteArrayToString(
-      data.slice(data.length - 8, data.length - 4),
-    );
+    const endId = utf8Decode(data.slice(data.length - 8, data.length - 4));
     if (this.containsMultipleChunks(endId, chunkLength, data.length)) {
       this.lastChunkOffset = 0;
       this.cmdOut.append(data.slice(0, chunkLength));
diff --git a/tools/winscope/src/trace_collection/wdp/sync_stream_test.ts b/tools/winscope/src/trace_collection/wdp/sync_stream_test.ts
index 19e63e46d..3c0a0b8b8 100644
--- a/tools/winscope/src/trace_collection/wdp/sync_stream_test.ts
+++ b/tools/winscope/src/trace_collection/wdp/sync_stream_test.ts
@@ -14,19 +14,19 @@
  * limitations under the License.
  */
 
+import {ArrayBufferBuilder} from 'common/buffer_utils';
+import {base64Encode, binaryEncode, utf8Decode} from 'common/string_utils';
 import {
-  ArrayBufferBuilder,
-  byteArrayToString,
-  stringToByteArray,
-} from 'common/buffer_utils';
-import {UnitTestUtils} from 'test/unit/utils';
+  makeFakeWebSocket,
+  makeFakeWebSocketMessage,
+} from 'test/unit/web_socket_utils';
 import {SyncStream} from './sync_stream';
 
 describe('SyncStream', () => {
   const serialNumber = '123';
   const errorListener = jasmine.createSpy();
   const testFileDataString = 'test file data';
-  const testFileData = stringToByteArray(testFileDataString);
+  const testFileData = binaryEncode(testFileDataString);
   const testFilepath = 'test_filepath';
   const expectedSendBuffer = new Uint8Array(
     new ArrayBufferBuilder()
@@ -38,7 +38,7 @@ describe('SyncStream', () => {
   let webSocket: jasmine.SpyObj<WebSocket>;
 
   beforeEach(async () => {
-    webSocket = UnitTestUtils.makeFakeWebSocket();
+    webSocket = makeFakeWebSocket();
     errorListener.calls.reset();
     stream = new SyncStream(webSocket, serialNumber, errorListener);
     await stream.connect();
@@ -59,14 +59,14 @@ describe('SyncStream', () => {
     );
   });
 
-  it('calls error listener if unexpected message type received - AdbResponse json', async () => {
+  it('calls error listener if unexpected message type received - AdbResponse json without response', async () => {
     setMessageResponses([
       JSON.stringify({error: {type: '', message: 'failed'}}),
     ]);
     const receivedData = await stream.pullFile(testFilepath);
     expect(errorListener).toHaveBeenCalledOnceWith(
       `Could not parse data:\nReceived: {"error":{"type":"","message":"failed"}}` +
-        `\nError: Expected message data to be ArrayBuffer or Blob.` +
+        `\nError: Received empty ADB response.` +
         `\nADB Error: failed`,
     );
     expect(receivedData).toEqual(Uint8Array.from([]));
@@ -78,7 +78,7 @@ describe('SyncStream', () => {
     const receivedData = await stream.pullFile(testFilepath);
     expect(errorListener).toHaveBeenCalledOnceWith(
       `Could not parse data:\nReceived: unknown error` +
-        `\nError: Expected message data to be ArrayBuffer or Blob.`,
+        `\nError: Failed to decode ADB JSON response.`,
     );
     expect(receivedData).toEqual(Uint8Array.from([]));
     errorListener.calls.reset();
@@ -101,7 +101,7 @@ describe('SyncStream', () => {
       .build();
     setMessageResponses([messageData]);
     const receivedData = await stream.pullFile(testFilepath);
-    expect(byteArrayToString(receivedData)).toEqual(testFileDataString);
+    expect(utf8Decode(receivedData)).toEqual(testFileDataString);
   });
 
   it('pulls file data from one chunk across two messages', async () => {
@@ -115,7 +115,7 @@ describe('SyncStream', () => {
       .build();
     setMessageResponses([messageData1, messageData2]);
     const receivedData = await stream.pullFile(testFilepath);
-    expect(byteArrayToString(receivedData)).toEqual(testFileDataString);
+    expect(utf8Decode(receivedData)).toEqual(testFileDataString);
   });
 
   it('pulls file data from one chunk across three messages', async () => {
@@ -131,7 +131,7 @@ describe('SyncStream', () => {
       .build();
     setMessageResponses([messageData1, messageData2, messageData3]);
     const receivedData = await stream.pullFile(testFilepath);
-    expect(byteArrayToString(receivedData)).toEqual(testFileDataString);
+    expect(utf8Decode(receivedData)).toEqual(testFileDataString);
   });
 
   it('pulls file data from multiple chunks in one message', async () => {
@@ -143,7 +143,7 @@ describe('SyncStream', () => {
       .build();
     setMessageResponses([messageData]);
     const receivedData = await stream.pullFile(testFilepath);
-    expect(byteArrayToString(receivedData)).toEqual(testFileDataString);
+    expect(utf8Decode(receivedData)).toEqual(testFileDataString);
   });
 
   it('pulls file data from multiple chunks, one chunk per message', async () => {
@@ -157,7 +157,7 @@ describe('SyncStream', () => {
       .build();
     setMessageResponses([messageData1, messageData2]);
     const receivedData = await stream.pullFile(testFilepath);
-    expect(byteArrayToString(receivedData)).toEqual(testFileDataString);
+    expect(utf8Decode(receivedData)).toEqual(testFileDataString);
   });
 
   it('pulls file data from multiple chunks across multiple messages', async () => {
@@ -173,7 +173,7 @@ describe('SyncStream', () => {
       .build();
     setMessageResponses([messageData1, messageData2]);
     const receivedData = await stream.pullFile(testFilepath);
-    expect(byteArrayToString(receivedData)).toEqual(testFileDataString);
+    expect(utf8Decode(receivedData)).toEqual(testFileDataString);
   });
 
   it('pulls file data where DATA id is in separate message', async () => {
@@ -185,7 +185,7 @@ describe('SyncStream', () => {
       .build();
     setMessageResponses([messageData1, messageData2]);
     const receivedData = await stream.pullFile(testFilepath);
-    expect(byteArrayToString(receivedData)).toEqual(testFileDataString);
+    expect(utf8Decode(receivedData)).toEqual(testFileDataString);
   });
 
   it('pulls file data where DONE id is in separate message', async () => {
@@ -197,7 +197,7 @@ describe('SyncStream', () => {
       .build();
     setMessageResponses([messageData1, messageData2]);
     const receivedData = await stream.pullFile(testFilepath);
-    expect(byteArrayToString(receivedData)).toEqual(testFileDataString);
+    expect(utf8Decode(receivedData)).toEqual(testFileDataString);
   });
 
   it('pulls file data where DATA and DONE ids in separate messages', async () => {
@@ -212,7 +212,7 @@ describe('SyncStream', () => {
       .build();
     setMessageResponses([messageData1, messageData2, messageData3]);
     const receivedData = await stream.pullFile(testFilepath);
-    expect(byteArrayToString(receivedData)).toEqual(testFileDataString);
+    expect(utf8Decode(receivedData)).toEqual(testFileDataString);
   });
 
   it('robust to file data where length is too small', async () => {
@@ -227,7 +227,7 @@ describe('SyncStream', () => {
       webSocket.onmessage!(message);
     });
     const receivedData = await stream.pullFile(testFilepath);
-    expect(byteArrayToString(receivedData)).toEqual(testFileDataString);
+    expect(utf8Decode(receivedData)).toEqual(testFileDataString);
   });
 
   it('robust to unexpected id at start of chunk', async () => {
@@ -242,7 +242,7 @@ describe('SyncStream', () => {
       .build();
     setMessageResponses([messageData1, messageData2]);
     const receivedData = await stream.pullFile(testFilepath);
-    expect(byteArrayToString(receivedData)).toEqual('tes');
+    expect(utf8Decode(receivedData)).toEqual('tes');
   });
 
   it('pulls file data from blob', async () => {
@@ -251,7 +251,19 @@ describe('SyncStream', () => {
       .build();
     setMessageResponses([new Blob([messageData])]);
     const receivedData = await stream.pullFile(testFilepath);
-    expect(byteArrayToString(receivedData)).toEqual(testFileDataString);
+    expect(utf8Decode(receivedData)).toEqual(testFileDataString);
+  });
+
+  it('pulls file data from AdbResponse json message with response', async () => {
+    const data = new ArrayBufferBuilder()
+      .append(['DATA', testFileData.length, testFileData, 'DONE', emptyByte])
+      .build();
+    const messageData = JSON.stringify({
+      response: base64Encode(new Uint8Array(data)),
+    });
+    setMessageResponses([messageData]);
+    const receivedData = await stream.pullFile(testFilepath);
+    expect(utf8Decode(receivedData)).toEqual(testFileDataString);
   });
 
   function setMessageResponses(
@@ -259,7 +271,7 @@ describe('SyncStream', () => {
   ) {
     webSocket.send.withArgs(expectedSendBuffer).and.callFake(() => {
       messageData.forEach((data) => {
-        const message = UnitTestUtils.makeFakeWebSocketMessage(data);
+        const message = makeFakeWebSocketMessage(data);
         webSocket.onmessage!(message);
       });
     });
diff --git a/tools/winscope/src/trace_collection/wdp/wdp_device_connection.ts b/tools/winscope/src/trace_collection/wdp/wdp_device_connection.ts
index fbc047e69..8dc061dbb 100644
--- a/tools/winscope/src/trace_collection/wdp/wdp_device_connection.ts
+++ b/tools/winscope/src/trace_collection/wdp/wdp_device_connection.ts
@@ -14,11 +14,8 @@
  * limitations under the License.
  */
 
-import {
-  byteArrayToString,
-  ResizableBuffer,
-  stringToByteArray,
-} from 'common/buffer_utils';
+import {ResizableBuffer} from 'common/buffer_utils';
+import {binaryEncode, utf8Decode} from 'common/string_utils';
 import {UserNotifier} from 'common/user_notifier';
 import {WindowUtils} from 'common/window_utils';
 import {
@@ -78,7 +75,7 @@ export class WdpDeviceConnection extends AdbDeviceConnection {
     const stream = this.createShellStream(dataListener, errorListener);
     await stream.connect(cmd);
     await stream.complete;
-    const output = byteArrayToString(cmdOut.get()).trimEnd();
+    const output = utf8Decode(cmdOut.get()).trimEnd();
     this.streamProvider.removeStream(stream);
     return output;
   }
@@ -166,7 +163,7 @@ export class WdpDeviceConnection extends AdbDeviceConnection {
     const stream = this.createShellStream(dataListener);
     this.screenRecordingStreams.set(target.traceName, stream);
     stream.complete.then(() => {
-      const stdout = byteArrayToString(cmdOut.get());
+      const stdout = utf8Decode(cmdOut.get());
       const index = stdout.indexOf('ERROR');
       if (index === -1) {
         return;
@@ -180,7 +177,7 @@ export class WdpDeviceConnection extends AdbDeviceConnection {
       UserNotifier.add(new ProxyTracingErrors([output])).notify();
     });
     await stream.connect();
-    await stream.write(stringToByteArray(target.startCmd));
+    await stream.write(binaryEncode(target.startCmd));
   }
 
   private createShellStream(
diff --git a/tools/winscope/src/trace_collection/wdp/wdp_device_connection_test.ts b/tools/winscope/src/trace_collection/wdp/wdp_device_connection_test.ts
index 6363ee143..3808fe6d0 100644
--- a/tools/winscope/src/trace_collection/wdp/wdp_device_connection_test.ts
+++ b/tools/winscope/src/trace_collection/wdp/wdp_device_connection_test.ts
@@ -14,15 +14,19 @@
  * limitations under the License.
  */
 
-import {ArrayBufferBuilder, stringToByteArray} from 'common/buffer_utils';
+import {ArrayBufferBuilder} from 'common/buffer_utils';
 import {FunctionUtils} from 'common/function_utils';
+import {binaryEncode} from 'common/string_utils';
 import {WindowUtils} from 'common/window_utils';
 import {
   ProxyTracingErrors,
   ProxyTracingWarnings,
 } from 'messaging/user_warnings';
 import {UserNotifierChecker} from 'test/unit/user_notifier_checker';
-import {UnitTestUtils} from 'test/unit/utils';
+import {
+  makeFakeWebSocket,
+  makeFakeWebSocketMessage,
+} from 'test/unit/web_socket_utils';
 import {
   AdbDeviceConnectionListener,
   AdbDeviceState,
@@ -43,7 +47,7 @@ describe('WdpDeviceConnection', () => {
   const testId = 'test id';
   const testApproveUrl = 'test_approve_url';
   let connection: WdpDeviceConnection;
-  const emptyResp = stringToByteArray('').buffer;
+  const emptyResp = binaryEncode('').buffer;
   let popupSpy: jasmine.Spy;
   let openStream: ShellStream | undefined;
 
@@ -189,7 +193,7 @@ describe('WdpDeviceConnection', () => {
         [
           'service check Wayland',
           'screenrecord --version',
-          'su root dumpsys SurfaceFlinger --display-id',
+          'dumpsys SurfaceFlinger --display-id',
         ],
         [],
       );
@@ -299,7 +303,7 @@ describe('WdpDeviceConnection', () => {
           resps: [''],
         },
         {
-          command: stringToByteArray(startCmd),
+          command: binaryEncode(startCmd),
           resps: [''],
         },
       ];
@@ -330,7 +334,7 @@ describe('WdpDeviceConnection', () => {
           resps: [''],
         },
         {
-          command: stringToByteArray(startCmd),
+          command: binaryEncode(startCmd),
           resps: [''],
         },
         {
@@ -352,7 +356,7 @@ describe('WdpDeviceConnection', () => {
           resps: [''],
         },
         {
-          command: stringToByteArray(startCmd),
+          command: binaryEncode(startCmd),
           resps: ['ERROR: please check your display state'],
         },
         {
@@ -376,7 +380,7 @@ describe('WdpDeviceConnection', () => {
   });
 
   describe('fetching file:', () => {
-    const fileData = stringToByteArray('4');
+    const fileData = binaryEncode('4');
     const encodedData = new ArrayBufferBuilder()
       .append([
         'DATA',
@@ -428,7 +432,7 @@ Error: Expected message data to be ArrayBuffer or Blob.`,
   ) {
     const shellStreamSpy = spyOn(StreamProvider.prototype, 'createShellStream');
     shellStreamSpy.and.callFake((device, sock, datalistener, errorlistener) => {
-      const fakeAdbSocket = UnitTestUtils.makeFakeWebSocket();
+      const fakeAdbSocket = makeFakeWebSocket();
       const shellStream = new ShellStream(
         fakeAdbSocket,
         device,
@@ -437,7 +441,7 @@ Error: Expected message data to be ArrayBuffer or Blob.`,
       );
 
       fakeAdbSocket.close.and.callFake(() => {
-        fakeAdbSocket.onclose!(new CloseEvent(''));
+        fakeAdbSocket.onclose!(new CloseEvent('close'));
         spyOn(shellStream, 'isOpen').and.returnValue(false);
       });
 
@@ -445,9 +449,9 @@ Error: Expected message data to be ArrayBuffer or Blob.`,
         fakeAdbSocket.send
           .withArgs(makeServiceCommandJson(command))
           .and.callFake(async () => {
-            const message = UnitTestUtils.makeFakeWebSocketMessage(emptyResp);
+            const message = makeFakeWebSocketMessage(emptyResp);
             fakeAdbSocket.onmessage!(message);
-            fakeAdbSocket.onclose!(new CloseEvent(''));
+            fakeAdbSocket.onclose!(new CloseEvent('close'));
           });
       });
       commandsWithResponse.forEach(({command, resps}) => {
@@ -455,11 +459,11 @@ Error: Expected message data to be ArrayBuffer or Blob.`,
           .withArgs(makeServiceCommandJson(command))
           .and.callFake(async () => {
             resps.forEach((resp) => {
-              const data = stringToByteArray(resp).buffer;
-              const message = UnitTestUtils.makeFakeWebSocketMessage(data);
+              const data = binaryEncode(resp).buffer;
+              const message = makeFakeWebSocketMessage(data);
               fakeAdbSocket.onmessage!(message);
             });
-            fakeAdbSocket.onclose!(new CloseEvent(''));
+            fakeAdbSocket.onclose!(new CloseEvent('close'));
           });
       });
       commandsWithOpenStream.forEach(({command, resps}) => {
@@ -472,8 +476,8 @@ Error: Expected message data to be ArrayBuffer or Blob.`,
         fakeAdbSocket.send.withArgs(data).and.callFake(async () => {
           resps.forEach((resp) => {
             openStream = shellStream;
-            const data = stringToByteArray(resp).buffer;
-            const message = UnitTestUtils.makeFakeWebSocketMessage(data);
+            const data = binaryEncode(resp).buffer;
+            const message = makeFakeWebSocketMessage(data);
             fakeAdbSocket.onmessage!(message);
           });
         });
@@ -483,10 +487,10 @@ Error: Expected message data to be ArrayBuffer or Blob.`,
           .withArgs(makeServiceCommandJson(command))
           .and.callFake(async () => {
             resps.forEach((resp) => {
-              const message = UnitTestUtils.makeFakeWebSocketMessage(resp);
+              const message = makeFakeWebSocketMessage(resp);
               fakeAdbSocket.onmessage!(message);
             });
-            fakeAdbSocket.onclose!(new CloseEvent(''));
+            fakeAdbSocket.onclose!(new CloseEvent('close'));
           });
       });
       return shellStream;
@@ -498,18 +502,18 @@ Error: Expected message data to be ArrayBuffer or Blob.`,
   ) {
     const syncStreamSpy = spyOn(StreamProvider.prototype, 'createSyncStream');
     syncStreamSpy.and.callFake((device, sock, errorlistener) => {
-      const fakeAdbSocket = UnitTestUtils.makeFakeWebSocket();
+      const fakeAdbSocket = makeFakeWebSocket();
       const syncStream = new SyncStream(fakeAdbSocket, device, errorlistener);
 
       fakeAdbSocket.close.and.callFake(() => {
-        fakeAdbSocket.onclose!(new CloseEvent(''));
+        fakeAdbSocket.onclose!(new CloseEvent('close'));
         spyOn(syncStream, 'isOpen').and.returnValue(false);
       });
 
       fakeAdbSocket.send
         .withArgs(makeServiceCommandJson('', 'sync'))
         .and.callFake(async () => {
-          const message = UnitTestUtils.makeFakeWebSocketMessage(emptyResp);
+          const message = makeFakeWebSocketMessage(emptyResp);
           fakeAdbSocket.onmessage!(message);
         });
 
@@ -520,10 +524,10 @@ Error: Expected message data to be ArrayBuffer or Blob.`,
         fakeAdbSocket.send
           .withArgs(new Uint8Array(tokens))
           .and.callFake(async () => {
-            const message = UnitTestUtils.makeFakeWebSocketMessage(data);
+            const message = makeFakeWebSocketMessage(data);
             setTimeout(() => {
               fakeAdbSocket.onmessage!(message);
-              fakeAdbSocket.onclose!(new CloseEvent(''));
+              fakeAdbSocket.onclose!(new CloseEvent('close'));
             }, 50);
           });
       });
diff --git a/tools/winscope/src/trace_collection/wdp/wdp_host_connection_test.ts b/tools/winscope/src/trace_collection/wdp/wdp_host_connection_test.ts
index 7f8d22cc1..9293a05dc 100644
--- a/tools/winscope/src/trace_collection/wdp/wdp_host_connection_test.ts
+++ b/tools/winscope/src/trace_collection/wdp/wdp_host_connection_test.ts
@@ -15,7 +15,10 @@
  */
 
 import {WindowUtils} from 'common/window_utils';
-import {UnitTestUtils} from 'test/unit/utils';
+import {
+  makeFakeWebSocket,
+  makeFakeWebSocketMessage,
+} from 'test/unit/web_socket_utils';
 import {ConnectionState} from 'trace_collection/connection_state';
 import {ConnectionStateListener} from 'trace_collection/connection_state_listener';
 import {DevicesStream} from './devices_stream';
@@ -71,7 +74,7 @@ describe('WdpHostConnection', () => {
     let fakeSocket: WebSocket;
 
     beforeEach(() => {
-      fakeSocket = UnitTestUtils.makeFakeWebSocket();
+      fakeSocket = makeFakeWebSocket();
     });
 
     it('not found', async () => {
@@ -161,7 +164,7 @@ describe('WdpHostConnection', () => {
     };
 
     beforeEach(() => {
-      fakeDevicesSocket = UnitTestUtils.makeFakeWebSocket();
+      fakeDevicesSocket = makeFakeWebSocket();
       spyOn(WdpDeviceConnection.prototype, 'updateProperties');
     });
 
@@ -220,7 +223,7 @@ describe('WdpHostConnection', () => {
       });
       const data = JSON.stringify(response);
       connection.requestDevices().then(() => {
-        const message = UnitTestUtils.makeFakeWebSocketMessage(data);
+        const message = makeFakeWebSocketMessage(data);
         fakeSocket.onmessage!(message);
       });
     });
diff --git a/tools/winscope/src/trace_collection/winscope_proxy/winscope_proxy_device_connection.ts b/tools/winscope/src/trace_collection/winscope_proxy/winscope_proxy_device_connection.ts
index 3049fa146..827162d56 100644
--- a/tools/winscope/src/trace_collection/winscope_proxy/winscope_proxy_device_connection.ts
+++ b/tools/winscope/src/trace_collection/winscope_proxy/winscope_proxy_device_connection.ts
@@ -14,9 +14,10 @@
  * limitations under the License.
  */
 
-import {byteArrayToString} from 'common/buffer_utils';
+import {NOT_IMPLEMENTED_ERROR} from 'common/errors';
 import {FunctionUtils} from 'common/function_utils';
 import {HttpRequestHeaderType, HttpResponse} from 'common/http_request';
+import {utf8Decode} from 'common/string_utils';
 import {UserNotifier} from 'common/user_notifier';
 import {ProxyTracingErrors} from 'messaging/user_warnings';
 import {
@@ -50,7 +51,7 @@ export class WinscopeProxyDeviceConnection extends AdbDeviceConnection {
   }
 
   override async tryAuthorize() {
-    throw new Error('not implemented');
+    throw NOT_IMPLEMENTED_ERROR;
   }
 
   override async runShellCommand(cmd: string): Promise<string> {
@@ -93,7 +94,7 @@ export class WinscopeProxyDeviceConnection extends AdbDeviceConnection {
     filepath: string,
   ) => {
     try {
-      const resp = byteArrayToString(httpResponse.body);
+      const resp = utf8Decode(httpResponse.body);
       const fileToPath = JSON.parse(resp);
       const encodedFileBuffer = fileToPath[filepath];
       return Uint8Array.from(window.atob(encodedFileBuffer), (c) =>
diff --git a/tools/winscope/src/trace_collection/winscope_proxy/winscope_proxy_host_connection_test.ts b/tools/winscope/src/trace_collection/winscope_proxy/winscope_proxy_host_connection_test.ts
index 132b36e3e..83a7c7b7e 100644
--- a/tools/winscope/src/trace_collection/winscope_proxy/winscope_proxy_host_connection_test.ts
+++ b/tools/winscope/src/trace_collection/winscope_proxy/winscope_proxy_host_connection_test.ts
@@ -20,7 +20,7 @@ import {
   HttpRequestStatus,
   HttpResponse,
 } from 'common/http_request';
-import {waitToBeCalled} from 'test/utils';
+import {waitToBeCalled} from 'test/unit/spy_utils';
 import {
   AdbDeviceConnection,
   AdbDeviceState,
diff --git a/tools/winscope/src/trace_processor/deferred.ts b/tools/winscope/src/trace_processor/deferred.ts
index 114fb0c96..9e7d040c2 100644
--- a/tools/winscope/src/trace_processor/deferred.ts
+++ b/tools/winscope/src/trace_processor/deferred.ts
@@ -14,7 +14,7 @@
 
 // Promise wrapper with exposed resolve and reject callbacks.
 export interface Deferred<T> extends Promise<T> {
-  readonly resolve: (value?: T|PromiseLike<T>) => void;
+  readonly resolve: (value?: T | PromiseLike<T>) => void;
   readonly reject: (reason?: any) => void;
 }
 
@@ -22,6 +22,6 @@ export interface Deferred<T> extends Promise<T> {
 export function defer<T>(): Deferred<T> {
   let resolve = null as any;
   let reject = null as any;
-  const p = new Promise((res, rej) => [resolve, reject] = [res, rej]);
+  const p = new Promise((res, rej) => ([resolve, reject] = [res, rej]));
   return Object.assign(p, {resolve, reject}) as any;
 }
diff --git a/tools/winscope/src/trace_processor/engine.ts b/tools/winscope/src/trace_processor/engine.ts
index aae959f02..452e348c3 100644
--- a/tools/winscope/src/trace_processor/engine.ts
+++ b/tools/winscope/src/trace_processor/engine.ts
@@ -12,38 +12,34 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+import {perfetto} from '../../deps_build/trace_processor/ui/tsc/gen/protos';
 import {defer, Deferred} from './deferred';
 import {assertExists, assertTrue} from './logging';
-import {perfetto} from '../../deps_build/trace_processor/ui/tsc/gen/protos';
 import {ProtoRingBuffer} from './proto_ring_buffer';
-import {
-  ComputeMetricArgs,
-  ComputeMetricResult,
-  DisableAndReadMetatraceResult,
-  QueryArgs,
-  ResetTraceProcessorArgs,
-} from './protos';
 import {
   createQueryResult,
-  NUM,
   QueryError,
   QueryResult,
   WritableQueryResult,
 } from './query_result';
+
 import TraceProcessorRpc = perfetto.protos.TraceProcessorRpc;
 import TraceProcessorRpcStream = perfetto.protos.TraceProcessorRpcStream;
 import TPM = perfetto.protos.TraceProcessorRpc.TraceProcessorMethod;
-
-export interface LoadingTracker {
-  beginLoading(): void;
-  endLoading(): void;
-}
-
-export class NullLoadingTracker implements LoadingTracker {
-  beginLoading(): void {}
-  endLoading(): void {}
-}
-
+import MetatraceCategories = perfetto.protos.MetatraceCategories;
+import DisableAndReadMetatraceResult = perfetto.protos.DisableAndReadMetatraceResult;
+import PerfettoSqlStructuredQuery = perfetto.protos.PerfettoSqlStructuredQuery;
+import AnalyzeStructuredQueryResult = perfetto.protos.AnalyzeStructuredQueryResult;
+import ComputeMetricResult = perfetto.protos.ComputeMetricResult;
+import ResetTraceProcessorArgs = perfetto.protos.ResetTraceProcessorArgs;
+import ComputeMetricArgs = perfetto.protos.ComputeMetricArgs;
+import QueryArgs = perfetto.protos.QueryArgs;
+import EnableMetatraceArgs = perfetto.protos.EnableMetatraceArgs;
+import AnalyzeStructuredQueryArgs = perfetto.protos.AnalyzeStructuredQueryArgs;
+import RegisterSqlPackageArgs = perfetto.protos.RegisterSqlPackageArgs;
+
+export type EngineMode = 'WASM' | 'HTTP_RPC';
+export type NewEngineMode = 'USE_HTTP_RPC_IF_AVAILABLE' | 'FORCE_BUILTIN_WASM';
 
 // This is used to skip the decoding of queryResult from protobufjs and deal
 // with it ourselves. See the comment below around `QueryResult.decode = ...`.
@@ -55,6 +51,77 @@ export interface TraceProcessorConfig {
   cropTrackEvents: boolean;
   ingestFtraceInRawTable: boolean;
   analyzeTraceProtoContent: boolean;
+  ftraceDropUntilAllCpusValid: boolean;
+}
+
+const QUERY_LOG_BUFFER_SIZE = 100;
+
+interface QueryLog {
+  readonly tag?: string;
+  readonly query: string;
+  readonly startTime: number;
+  readonly endTime?: number;
+  readonly success?: boolean;
+}
+
+export interface Engine {
+  readonly mode: EngineMode;
+  readonly engineId: string;
+
+  /**
+   * A list of the most recent queries along with their start times, end times
+   * and success status (if completed).
+   */
+  readonly queryLog: ReadonlyArray<QueryLog>;
+
+  /**
+   * Execute a query against the database, returning a promise that resolves
+   * when the query has completed but rejected when the query fails for whatever
+   * reason. On success, the promise will only resolve once all the resulting
+   * rows have been received.
+   *
+   * The promise will be rejected if the query fails.
+   *
+   * @param sql The query to execute.
+   * @param tag An optional tag used to trace the origin of the query.
+   */
+  query(sql: string, tag?: string): Promise<QueryResult>;
+
+  /**
+   * Execute a query against the database, returning a promise that resolves
+   * when the query has completed or failed. The promise will never get
+   * rejected, it will always successfully resolve. Use the returned wrapper
+   * object to determine whether the query completed successfully.
+   *
+   * The promise will only resolve once all the resulting rows have been
+   * received.
+   *
+   * @param sql The query to execute.
+   * @param tag An optional tag used to trace the origin of the query.
+   */
+  tryQuery(sql: string, tag?: string): Promise<QueryResult>;
+
+  /**
+   * Execute one or more metric and get the result.
+   *
+   * @param metrics The metrics to run.
+   * @param format The format of the response.
+   */
+  computeMetric(
+    metrics: string[],
+    format: 'json' | 'prototext' | 'proto',
+  ): Promise<string | Uint8Array>;
+
+  enableMetatrace(categories?: MetatraceCategories): void;
+  stopAndGetMetatrace(): Promise<DisableAndReadMetatraceResult>;
+
+  analyzeStructuredQuery(
+    structuredQueries: PerfettoSqlStructuredQuery[],
+  ): Promise<AnalyzeStructuredQueryResult>;
+
+  getProxy(tag: string): EngineProxy;
+  readonly numRequestsPending: number;
+  readonly failed: string | undefined;
 }
 
 // Abstract interface of a trace proccessor.
@@ -68,11 +135,9 @@ export interface TraceProcessorConfig {
 // 1. Implement the abstract rpcSendRequestBytes() function, sending the
 //    proto-encoded TraceProcessorRpc requests to the TraceProcessor instance.
 // 2. Call onRpcResponseBytes() when response data is received.
-export abstract class Engine {
+export abstract class EngineBase implements Engine {
   abstract readonly id: string;
-  private _cpus?: number[];
-  private _numGpus?: number;
-  private loadingTracker: LoadingTracker;
+  abstract readonly mode: EngineMode;
   private txSeqId = 0;
   private rxSeqId = 0;
   private rxBuf = new ProtoRingBuffer();
@@ -81,14 +146,22 @@ export abstract class Engine {
   private pendingResetTraceProcessors = new Array<Deferred<void>>();
   private pendingQueries = new Array<WritableQueryResult>();
   private pendingRestoreTables = new Array<Deferred<void>>();
-  private pendingComputeMetrics = new Array<Deferred<ComputeMetricResult>>();
+  private pendingComputeMetrics = new Array<Deferred<string | Uint8Array>>();
   private pendingReadMetatrace?: Deferred<DisableAndReadMetatraceResult>;
+  private pendingRegisterSqlPackage?: Deferred<void>;
+  private pendingAnalyzeStructuredQueries?: Deferred<AnalyzeStructuredQueryResult>;
   private _isMetatracingEnabled = false;
+  private _numRequestsPending = 0;
+  private _failed: string | undefined = undefined;
+  private _queryLog: Array<QueryLog> = [];
 
-  constructor(tracker?: LoadingTracker) {
-    this.loadingTracker = tracker ? tracker : new NullLoadingTracker();
+  get queryLog(): ReadonlyArray<QueryLog> {
+    return this._queryLog;
   }
 
+  // TraceController sets this to raf.scheduleFullRedraw().
+  onResponseReceived?: () => void;
+
   // Called to send data to the TraceProcessor instance. This turns into a
   // postMessage() or a HTTP request, depending on the Engine implementation.
   abstract rpcSendRequestBytes(data: Uint8Array): void;
@@ -116,7 +189,7 @@ export abstract class Engine {
     // Here we override the protobufjs-generated code to skip the parsing of the
     // new streaming QueryResult and instead passing it through like a buffer.
     // This is the overall problem: All trace processor responses are wrapped
-    // into a perfetto.protos.TraceProcessorRpc proto message. In all cases %
+    // into a TraceProcessorRpc proto message. In all cases %
     // TPM_QUERY_STREAMING, we want protobufjs to decode the proto bytes and
     // give us a structured object. In the case of TPM_QUERY_STREAMING, instead,
     // we want to deal with the proto parsing ourselves using the new
@@ -126,36 +199,35 @@ export abstract class Engine {
     // 1. We avoid protobufjs decoding the TraceProcessorRpc.query_result field.
     // 2. We stash (a view of) the original buffer into the |rawQueryResult| so
     //    the `case TPM_QUERY_STREAMING` below can take it.
-    perfetto.protos.QueryResult.decode =
-        (reader: protobuf.Reader, length: number) => {
-          const res =
-              perfetto.protos.QueryResult.create() as {} as QueryResultBypass;
-          res.rawQueryResult =
-              reader.buf.subarray(reader.pos, reader.pos + length);
-          // All this works only if protobufjs returns the original ArrayBuffer
-          // from |rpcMsgEncoded|. It should be always the case given the
-          // current implementation. This check mainly guards against future
-          // behavioral changes of protobufjs. We don't want to accidentally
-          // hold onto some internal protobufjs buffer. We are fine holding
-          // onto |rpcMsgEncoded| because those come from ProtoRingBuffer which
-          // is buffer-retention-friendly.
-          assertTrue(res.rawQueryResult.buffer === rpcMsgEncoded.buffer);
-          reader.pos += length;
-          return res as {} as perfetto.protos.QueryResult;
-        };
-
-    const rpc = TraceProcessorRpc.decode(rpcMsgEncoded);
+    perfetto.protos.QueryResult.decode = (reader: protobuf.Reader, length: number) => {
+      const res = perfetto.protos.QueryResult.create() as {} as QueryResultBypass;
+      res.rawQueryResult = reader.buf.subarray(reader.pos, reader.pos + length);
+      // All this works only if protobufjs returns the original ArrayBuffer
+      // from |rpcMsgEncoded|. It should be always the case given the
+      // current implementation. This check mainly guards against future
+      // behavioral changes of protobufjs. We don't want to accidentally
+      // hold onto some internal protobufjs buffer. We are fine holding
+      // onto |rpcMsgEncoded| because those come from ProtoRingBuffer which
+      // is buffer-retention-friendly.
+      assertTrue(res.rawQueryResult.buffer === rpcMsgEncoded.buffer);
+      reader.pos += length;
+      return res as {} as perfetto.protos.QueryResult;
+    };
+
+    const rpc = perfetto.protos.TraceProcessorRpc.decode(rpcMsgEncoded);
 
     if (rpc.fatalError !== undefined && rpc.fatalError.length > 0) {
-      throw new Error(`${rpc.fatalError}`);
+      this.fail(`${rpc.fatalError}`);
     }
 
     // Allow restarting sequences from zero (when reloading the browser).
     if (rpc.seq !== this.rxSeqId + 1 && this.rxSeqId !== 0 && rpc.seq !== 0) {
       // "(ERR:rpc_seq)" is intercepted by error_dialog.ts to show a more
       // graceful and actionable error.
-      throw new Error(`RPC sequence id mismatch cur=${rpc.seq} last=${
-          this.rxSeqId} (ERR:rpc_seq)`);
+      this.fail(
+        `RPC sequence id mismatch ` +
+          `cur=${rpc.seq} last=${this.rxSeqId} (ERR:rpc_seq)`,
+      );
     }
 
     this.rxSeqId = rpc.seq;
@@ -163,7 +235,7 @@ export abstract class Engine {
     let isFinalResponse = true;
 
     switch (rpc.response) {
-      case TPM.TPM_APPEND_TRACE_DATA:
+      case TPM.TPM_APPEND_TRACE_DATA: {
         const appendResult = assertExists(rpc.appendResult);
         const pendingPromise = assertExists(this.pendingParses.shift());
         if (appendResult.error && appendResult.error.length > 0) {
@@ -172,9 +244,17 @@ export abstract class Engine {
           pendingPromise.resolve();
         }
         break;
-      case TPM.TPM_FINALIZE_TRACE_DATA:
-        assertExists(this.pendingEOFs.shift()).resolve();
+      }
+      case TPM.TPM_FINALIZE_TRACE_DATA: {
+        const finalizeResult = assertExists(rpc.finalizeDataResult);
+        const pendingPromise = assertExists(this.pendingEOFs.shift());
+        if (finalizeResult.error && finalizeResult.error.length > 0) {
+          pendingPromise.reject(finalizeResult.error);
+        } else {
+          pendingPromise.resolve();
+        }
         break;
+      }
       case TPM.TPM_RESET_TRACE_PROCESSOR:
         assertExists(this.pendingResetTraceProcessors.shift()).resolve();
         break;
@@ -192,41 +272,72 @@ export abstract class Engine {
         }
         break;
       case TPM.TPM_COMPUTE_METRIC:
-        const metricRes = assertExists(rpc.metricResult) as ComputeMetricResult;
-        const pendingComputeMetric =
-            assertExists(this.pendingComputeMetrics.shift());
+        const metricRes = assertExists(
+          rpc.metricResult,
+        ) as ComputeMetricResult;
+        const pendingComputeMetric = assertExists(
+          this.pendingComputeMetrics.shift(),
+        );
         if (metricRes.error && metricRes.error.length > 0) {
-          const error =
-              new QueryError(`ComputeMetric() error: ${metricRes.error}`, {
-                query: 'COMPUTE_METRIC',
-              });
+          const error = new QueryError(
+            `ComputeMetric() error: ${metricRes.error}`,
+            {
+              query: 'COMPUTE_METRIC',
+            },
+          );
           pendingComputeMetric.reject(error);
         } else {
-          pendingComputeMetric.resolve(metricRes);
+          const result =
+            metricRes.metricsAsPrototext ??
+            metricRes.metricsAsJson ??
+            metricRes.metrics ??
+            '';
+          pendingComputeMetric.resolve(result);
         }
         break;
       case TPM.TPM_DISABLE_AND_READ_METATRACE:
-        const metatraceRes =
-            assertExists(rpc.metatrace) as DisableAndReadMetatraceResult;
+        const metatraceRes = assertExists(
+          rpc.metatrace,
+        ) as DisableAndReadMetatraceResult;
         assertExists(this.pendingReadMetatrace).resolve(metatraceRes);
         this.pendingReadMetatrace = undefined;
         break;
+      case TPM.TPM_REGISTER_SQL_PACKAGE:
+        const registerResult = assertExists(rpc.registerSqlPackageResult);
+        const res = assertExists(this.pendingRegisterSqlPackage);
+        if (registerResult.error && registerResult.error.length > 0) {
+          res.reject(registerResult.error);
+        } else {
+          res.resolve();
+        }
+        break;
+      case TPM.TPM_ANALYZE_STRUCTURED_QUERY:
+        const analyzeRes = assertExists(
+          rpc.analyzeStructuredQueryResult,
+        ) as {} as AnalyzeStructuredQueryResult;
+        const x = assertExists(this.pendingAnalyzeStructuredQueries);
+        x.resolve(analyzeRes);
+        this.pendingAnalyzeStructuredQueries = undefined;
+        break;
       default:
         console.log(
-            'Unexpected TraceProcessor response received: ', rpc.response);
+          'Unexpected TraceProcessor response received: ',
+          rpc.response,
+        );
         break;
-    }  // switch(rpc.response);
+    } // switch(rpc.response);
 
     if (isFinalResponse) {
-      this.loadingTracker.endLoading();
+      --this._numRequestsPending;
     }
+
+    this.onResponseReceived?.();
   }
 
   // TraceProcessor methods below this point.
   // The methods below are called by the various controllers in the UI and
   // deal with marshalling / unmarshaling requests to/from TraceProcessor.
 
-
   // Push trace data into the engine. The engine is supposed to automatically
   // figure out the type of the trace (JSON vs Protobuf).
   parse(data: Uint8Array): Promise<void> {
@@ -236,7 +347,7 @@ export abstract class Engine {
     rpc.request = TPM.TPM_APPEND_TRACE_DATA;
     rpc.appendTraceData = data;
     this.rpcSendRequest(rpc);
-    return asyncRes;  // Linearize with the worker.
+    return asyncRes; // Linearize with the worker.
   }
 
   // Notify the engine that we reached the end of the trace.
@@ -247,26 +358,31 @@ export abstract class Engine {
     const rpc = TraceProcessorRpc.create();
     rpc.request = TPM.TPM_FINALIZE_TRACE_DATA;
     this.rpcSendRequest(rpc);
-    return asyncRes;  // Linearize with the worker.
+    return asyncRes; // Linearize with the worker.
   }
 
   // Updates the TraceProcessor Config. This method creates a new
   // TraceProcessor instance, so it should be called before passing any trace
   // data.
-  resetTraceProcessor(
-      {cropTrackEvents, ingestFtraceInRawTable, analyzeTraceProtoContent}:
-          TraceProcessorConfig): Promise<void> {
+  resetTraceProcessor({
+    cropTrackEvents,
+    ingestFtraceInRawTable,
+    analyzeTraceProtoContent,
+    ftraceDropUntilAllCpusValid,
+  }: TraceProcessorConfig): Promise<void> {
     const asyncRes = defer<void>();
     this.pendingResetTraceProcessors.push(asyncRes);
     const rpc = TraceProcessorRpc.create();
     rpc.request = TPM.TPM_RESET_TRACE_PROCESSOR;
-    const args = rpc.resetTraceProcessorArgs = new ResetTraceProcessorArgs();
-    args.dropTrackEventDataBefore = cropTrackEvents ?
-        ResetTraceProcessorArgs.DropTrackEventDataBefore
-            .TRACK_EVENT_RANGE_OF_INTEREST :
-        ResetTraceProcessorArgs.DropTrackEventDataBefore.NO_DROP;
+    const args = (rpc.resetTraceProcessorArgs =
+      new ResetTraceProcessorArgs());
+    args.dropTrackEventDataBefore = cropTrackEvents
+      ? ResetTraceProcessorArgs.DropTrackEventDataBefore
+          .TRACK_EVENT_RANGE_OF_INTEREST
+      : ResetTraceProcessorArgs.DropTrackEventDataBefore.NO_DROP;
     args.ingestFtraceInRawTable = ingestFtraceInRawTable;
     args.analyzeTraceProtoContent = analyzeTraceProtoContent;
+    args.ftraceDropUntilAllCpusValid = ftraceDropUntilAllCpusValid;
     this.rpcSendRequest(rpc);
     return asyncRes;
   }
@@ -279,18 +395,29 @@ export abstract class Engine {
     const rpc = TraceProcessorRpc.create();
     rpc.request = TPM.TPM_RESTORE_INITIAL_TABLES;
     this.rpcSendRequest(rpc);
-    return asyncRes;  // Linearize with the worker.
+    return asyncRes; // Linearize with the worker.
   }
 
   // Shorthand for sending a compute metrics request to the engine.
-  async computeMetric(metrics: string[]): Promise<ComputeMetricResult> {
-    const asyncRes = defer<ComputeMetricResult>();
+  async computeMetric(
+    metrics: string[],
+    format: 'json' | 'prototext' | 'proto',
+  ): Promise<string | Uint8Array> {
+    const asyncRes = defer<string | Uint8Array>();
     this.pendingComputeMetrics.push(asyncRes);
     const rpc = TraceProcessorRpc.create();
     rpc.request = TPM.TPM_COMPUTE_METRIC;
-    const args = rpc.computeMetricArgs = new ComputeMetricArgs();
+    const args = (rpc.computeMetricArgs = new ComputeMetricArgs());
     args.metricNames = metrics;
-    args.format = ComputeMetricArgs.ResultFormat.TEXTPROTO;
+    if (format === 'json') {
+      args.format = ComputeMetricArgs.ResultFormat.JSON;
+    } else if (format === 'prototext') {
+      args.format = ComputeMetricArgs.ResultFormat.TEXTPROTO;
+    } else if (format === 'proto') {
+      args.format = ComputeMetricArgs.ResultFormat.BINARY_PROTOBUF;
+    } else {
+      throw new Error(`Unknown compute metric format ${format}`);
+    }
     this.rpcSendRequest(rpc);
     return asyncRes;
   }
@@ -303,7 +430,7 @@ export abstract class Engine {
   // the rows incrementally.
   //
   // Example usage:
-  // const res = engine.query('SELECT foo, bar FROM table');
+  // const res = engine.execute('SELECT foo, bar FROM table');
   // console.log(res.numRows());  // Will print 0 because we didn't await.
   // await(res.waitAllRows());
   // console.log(res.numRows());  // Will print the total number of rows.
@@ -314,7 +441,10 @@ export abstract class Engine {
   //
   // Optional |tag| (usually a component name) can be provided to allow
   // attributing trace processor workload to different UI components.
-  query(sqlQuery: string, tag?: string): Promise<QueryResult>&QueryResult {
+  private streamingQuery(
+    sqlQuery: string,
+    tag?: string,
+  ): Promise<QueryResult> & QueryResult {
     const rpc = TraceProcessorRpc.create();
     rpc.request = TPM.TPM_QUERY_STREAMING;
     rpc.queryArgs = new QueryArgs();
@@ -330,15 +460,69 @@ export abstract class Engine {
     return result;
   }
 
+  private logQueryStart(
+    query: string,
+    tag?: string,
+  ): {
+    endTime?: number;
+    success?: boolean;
+  } {
+    const startTime = performance.now();
+    const queryLog: QueryLog = {query, tag, startTime};
+    this._queryLog.push(queryLog);
+    if (this._queryLog.length > QUERY_LOG_BUFFER_SIZE) {
+      this._queryLog.shift();
+    }
+    return queryLog;
+  }
+
+  // Wraps .streamingQuery(), captures errors and re-throws with current stack.
+  //
+  // Note: This function is less flexible than .execute() as it only returns a
+  // promise which must be unwrapped before the QueryResult may be accessed.
+  async query(sqlQuery: string, tag?: string): Promise<QueryResult> {
+    const queryLog = this.logQueryStart(sqlQuery);
+    try {
+      const result = await this.streamingQuery(sqlQuery, tag);
+      queryLog.success = true;
+      return result;
+    } catch (e) {
+      // Replace the error's stack trace with the one from here
+      // Note: It seems only V8 can trace the stack up the promise chain, so its
+      // likely this stack won't be useful on !V8.
+      // See
+      // https://docs.google.com/document/d/13Sy_kBIJGP0XT34V1CV3nkWya4TwYx9L3Yv45LdGB6Q
+      captureStackTrace(e as any);
+      queryLog.success = false;
+      throw e;
+    } finally {
+      queryLog.endTime = performance.now();
+    }
+  }
+
+  async tryQuery(sql: string, tag?: string): Promise<QueryResult> {
+    try {
+      const result = await this.query(sql, tag);
+      return result;
+    } catch (error) {
+      const e = (error as any);
+      const msg = 'message' in e ? `${e.message}` : `${error}`;
+      throw new Error(msg);
+    }
+  }
+
   isMetatracingEnabled(): boolean {
     return this._isMetatracingEnabled;
   }
 
-  enableMetatrace(categories?: perfetto.protos.MetatraceCategories) {
+  enableMetatrace(categories?: MetatraceCategories) {
     const rpc = TraceProcessorRpc.create();
     rpc.request = TPM.TPM_ENABLE_METATRACE;
-    if (categories) {
-      rpc.enableMetatraceArgs = new perfetto.protos.EnableMetatraceArgs();
+    if (
+      categories !== undefined &&
+      categories !== MetatraceCategories.NONE
+    ) {
+      rpc.enableMetatraceArgs = new EnableMetatraceArgs();
       rpc.enableMetatraceArgs.categories = categories;
     }
     this._isMetatracingEnabled = true;
@@ -361,6 +545,45 @@ export abstract class Engine {
     return result;
   }
 
+  registerSqlPackages(pkg: {
+    name: string;
+    modules: {name: string; sql: string}[];
+  }): Promise<void> {
+    if (this.pendingRegisterSqlPackage) {
+      return Promise.reject(new Error('Already registering SQL package'));
+    }
+
+    const result = defer<void>();
+
+    const rpc = TraceProcessorRpc.create();
+    rpc.request = TPM.TPM_REGISTER_SQL_PACKAGE;
+    const args = (rpc.registerSqlPackageArgs =
+      new RegisterSqlPackageArgs());
+    args.packageName = pkg.name;
+    args.modules = pkg.modules;
+    args.allowOverride = true;
+    this.pendingRegisterSqlPackage = result;
+    this.rpcSendRequest(rpc);
+    return result;
+  }
+
+  analyzeStructuredQuery(
+    structuredQueries: PerfettoSqlStructuredQuery[],
+  ): Promise<AnalyzeStructuredQueryResult> {
+    if (this.pendingAnalyzeStructuredQueries) {
+      return Promise.reject(new Error('Already analyzing structured queries'));
+    }
+    const result = defer<AnalyzeStructuredQueryResult>();
+    const rpc = TraceProcessorRpc.create();
+    rpc.request = TPM.TPM_ANALYZE_STRUCTURED_QUERY;
+    const args = (rpc.analyzeStructuredQueryArgs =
+      new AnalyzeStructuredQueryArgs());
+    args.queries = structuredQueries;
+    this.pendingAnalyzeStructuredQueries = result;
+    this.rpcSendRequest(rpc);
+    return result;
+  }
+
   // Marshals the TraceProcessorRpc request arguments and sends the request
   // to the concrete Engine (Wasm or HTTP).
   private rpcSendRequest(rpc: TraceProcessorRpc) {
@@ -370,64 +593,132 @@ export abstract class Engine {
     const outerProto = TraceProcessorRpcStream.create();
     outerProto.msg.push(rpc);
     const buf = TraceProcessorRpcStream.encode(outerProto).finish();
-    this.loadingTracker.beginLoading();
+    ++this._numRequestsPending;
     this.rpcSendRequestBytes(buf);
   }
 
-  // TODO(hjd): When streaming must invalidate this somehow.
-  async getCpus(): Promise<number[]> {
-    if (!this._cpus) {
-      const cpus = [];
-      const queryRes = await this.query(
-          'select distinct(cpu) as cpu from sched order by cpu;');
-      for (const it = queryRes.iter({cpu: NUM}); it.valid(); it.next()) {
-        cpus.push(it.cpu);
-      }
-      this._cpus = cpus;
-    }
-    return this._cpus;
-  }
-
-  async getNumberOfGpus(): Promise<number> {
-    if (!this._numGpus) {
-      const result = await this.query(`
-        select count(distinct(gpu_id)) as gpuCount
-        from gpu_counter_track
-        where name = 'gpufreq';
-      `);
-      this._numGpus = result.firstRow({gpuCount: NUM}).gpuCount;
-    }
-    return this._numGpus;
+  get engineId(): string {
+    return this.id;
   }
 
-  // TODO: This should live in code that's more specific to chrome, instead of
-  // in engine.
-  async getNumberOfProcesses(): Promise<number> {
-    const result = await this.query('select count(*) as cnt from process;');
-    return result.firstRow({cnt: NUM}).cnt;
+  get numRequestsPending(): number {
+    return this._numRequestsPending;
   }
 
   getProxy(tag: string): EngineProxy {
     return new EngineProxy(this, tag);
   }
+
+  protected fail(reason: string) {
+    this._failed = reason;
+    throw new Error(reason);
+  }
+
+  get failed(): string | undefined {
+    return this._failed;
+  }
+
+  abstract dispose(): void;
 }
 
-// Lightweight wrapper over Engine exposing only `query` method and annotating
-// all queries going through it with a tag.
-export class EngineProxy {
-  private engine: Engine;
+// Lightweight engine proxy which annotates all queries with a tag
+export class EngineProxy implements Engine {
+  private engine: EngineBase;
   private tag: string;
+  private disposed = false;
 
-  constructor(engine: Engine, tag: string) {
+  get queryLog() {
+    return this.engine.queryLog;
+  }
+
+  constructor(engine: EngineBase, tag: string) {
     this.engine = engine;
     this.tag = tag;
   }
 
-  query(sqlQuery: string, tag?: string): Promise<QueryResult>&QueryResult {
-    return this.engine.query(sqlQuery, tag || this.tag);
+  async query(query: string, tag?: string): Promise<QueryResult> {
+    if (this.disposed) {
+      // If we are disposed (the trace was closed), return an empty QueryResult
+      // that will never see any data or EOF. We can't do otherwise or it will
+      // cause crashes to code calling firstRow() and expecting data.
+      return createQueryResult({query});
+    }
+    return await this.engine.query(query, tag);
+  }
+
+  async tryQuery(query: string, tag?: string): Promise<QueryResult> {
+    if (this.disposed) {
+      throw new Error(`EngineProxy ${this.tag} was disposed`);
+    }
+    return await this.engine.tryQuery(query, tag);
+  }
+
+  async computeMetric(
+    metrics: string[],
+    format: 'json' | 'prototext' | 'proto',
+  ): Promise<string | Uint8Array> {
+    if (this.disposed) {
+      return defer<string>(); // Return a promise that will hang forever.
+    }
+    return this.engine.computeMetric(metrics, format);
+  }
+
+  enableMetatrace(categories?: MetatraceCategories): void {
+    this.engine.enableMetatrace(categories);
+  }
+
+  stopAndGetMetatrace(): Promise<DisableAndReadMetatraceResult> {
+    return this.engine.stopAndGetMetatrace();
+  }
+
+  analyzeStructuredQuery(
+    structuredQueries: PerfettoSqlStructuredQuery[],
+  ): Promise<AnalyzeStructuredQueryResult> {
+    return this.engine.analyzeStructuredQuery(structuredQueries);
   }
 
   get engineId(): string {
     return this.engine.id;
   }
+
+  getProxy(tag: string): EngineProxy {
+    return this.engine.getProxy(`${this.tag}/${tag}`);
+  }
+
+  get numRequestsPending() {
+    return this.engine.numRequestsPending;
+  }
+
+  get mode() {
+    return this.engine.mode;
+  }
+
+  get failed() {
+    return this.engine.failed;
+  }
+
+  dispose() {
+    this.disposed = true;
+  }
 }
+
+// Capture stack trace and attach to the given error object
+function captureStackTrace(e: Error): void {
+  const stack = new Error().stack;
+  if ('captureStackTrace' in Error) {
+    // V8 specific
+    Error.captureStackTrace(e, captureStackTrace);
+  } else {
+    // Generic
+    Object.defineProperty(e, 'stack', {
+      value: stack,
+      writable: true,
+      configurable: true,
+    });
+  }
+}
+
+// A convenience interface to inject the App in Mithril components.
+export interface EngineAttrs {
+  engine: Engine;
+}
\ No newline at end of file
diff --git a/tools/winscope/src/trace_processor/proto_ring_buffer.ts b/tools/winscope/src/trace_processor/proto_ring_buffer.ts
index da878ce00..0f561ec4f 100644
--- a/tools/winscope/src/trace_processor/proto_ring_buffer.ts
+++ b/tools/winscope/src/trace_processor/proto_ring_buffer.ts
@@ -12,14 +12,23 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-import {assertTrue} from './logging';
+import {assertTrue, assertUnreachable} from './logging';
 
 // This class is the TypeScript equivalent of the identically-named C++ class in
 // //protozero/proto_ring_buffer.h. See comments in that header for a detailed
 // description. The architecture is identical.
 
 const kGrowBytes = 128 * 1024;
-const kMaxMsgSize = 64 * 1024 * 1024;
+const kMaxMsgSize = 1024 * 1024 * 1024;
+
+// There are two ways the buffer can work:
+// 1. 'PROTO_PREAMBLE' is the case where the header before each packet is a
+//    length-encoded protobuf message. This is the case when paring traces or
+//    the TraceProcessor RPC protocol.
+// 2. 'FIXED_SIZE' is the case where the header is a 32-bit integer representing
+//    the size of the message. This is used by the traced tracing protocol in
+//    https://perfetto.dev/docs/design-docs/api-and-abi#socket-protocol.
+export type ProtoTokenizationMode = 'PROTO_PREAMBLE' | 'FIXED_SIZE';
 
 export class ProtoRingBuffer {
   private buf = new Uint8Array(kGrowBytes);
@@ -27,6 +36,8 @@ export class ProtoRingBuffer {
   private rd = 0;
   private wr = 0;
 
+  constructor(private mode: ProtoTokenizationMode = 'PROTO_PREAMBLE') {}
+
   // The caller must call ReadMessage() after each append() call.
   // The |data| might be either copied in the internal ring buffer or returned
   // (% subarray()) to the next ReadMessage() call.
@@ -46,9 +57,11 @@ export class ProtoRingBuffer {
     if (dataLen === 0) return;
     assertTrue(this.fastpath === undefined);
     if (this.rd === this.wr) {
-      const msg = ProtoRingBuffer.tryReadMessage(data, 0, dataLen);
-      if (msg !== undefined &&
-          ((msg.byteOffset + msg.length) === (data.byteOffset + dataLen))) {
+      const msg = this.tryReadMessage(data, 0, dataLen);
+      if (
+        msg !== undefined &&
+        msg.byteOffset + msg.length === data.byteOffset + dataLen
+      ) {
         // Fastpath: in many cases, the underlying stream will effectively
         // preserve the atomicity of messages for most small messages.
         // In this case we can avoid the extra buffer roundtrip and return the
@@ -94,7 +107,7 @@ export class ProtoRingBuffer {
   // The caller is expected to call this in a loop until it returns undefined.
   // Note that a single write to Append() can yield more than one message
   // (see ProtoRingBufferTest.CoalescingStream in the unittest).
-  readMessage(): Uint8Array|undefined {
+  readMessage(): Uint8Array | undefined {
     if (this.fastpath !== undefined) {
       assertTrue(this.rd === this.wr);
       const msg = this.fastpath;
@@ -103,9 +116,9 @@ export class ProtoRingBuffer {
     }
     assertTrue(this.rd <= this.wr);
     if (this.rd >= this.wr) {
-      return undefined;  // Completely empty.
+      return undefined; // Completely empty.
     }
-    const msg = ProtoRingBuffer.tryReadMessage(this.buf, this.rd, this.wr);
+    const msg = this.tryReadMessage(this.buf, this.rd, this.wr);
     if (msg === undefined) return undefined;
     assertTrue(msg.buffer === this.buf.buffer);
     assertTrue(this.buf.byteOffset === 0);
@@ -118,31 +131,48 @@ export class ProtoRingBuffer {
     return msg.slice();
   }
 
-  private static tryReadMessage(
-      data: Uint8Array, dataStart: number, dataEnd: number): Uint8Array
-      |undefined {
+  private tryReadMessage(
+    data: Uint8Array,
+    dataStart: number,
+    dataEnd: number,
+  ): Uint8Array | undefined {
     assertTrue(dataEnd <= data.length);
     let pos = dataStart;
     if (pos >= dataEnd) return undefined;
-    const tag = data[pos++];  // Assume one-byte tag.
-    if (tag >= 0x80 || (tag & 0x07) !== 2 /* len delimited */) {
-      throw new Error(
-          `RPC framing error, unexpected tag ${tag} @ offset ${pos - 1}`);
-    }
-
     let len = 0;
-    for (let shift = 0; /* no check */; shift += 7) {
-      if (pos >= dataEnd) {
-        return undefined;  // Not enough data to read varint.
+
+    if (this.mode === 'PROTO_PREAMBLE') {
+      const tag = data[pos++]; // Assume one-byte tag.
+      if (tag >= 0x80 || (tag & 0x07) !== 2 /* len delimited */) {
+        throw new Error(
+          `RPC framing error, unexpected tag ${tag} @ offset ${pos - 1}`,
+        );
+      }
+
+      for (let shift = 0 /* no check */; ; shift += 7) {
+        if (pos >= dataEnd) {
+          return undefined; // Not enough data to read varint.
+        }
+        const val = data[pos++];
+        len |= ((val & 0x7f) << shift) >>> 0;
+        if (val < 0x80) break;
+      }
+    } else if (this.mode === 'FIXED_SIZE') {
+      for (let i = 0; i < 4; i++) {
+        if (pos >= dataEnd) {
+          return undefined; // Not enough data to read a uint32.
+        }
+        const val = data[pos++] & 0xff;
+        len |= (val << (i * 8)) >>> 0;
       }
-      const val = data[pos++];
-      len |= ((val & 0x7f) << shift) >>> 0;
-      if (val < 0x80) break;
+    } else {
+      assertUnreachable(this.mode);
     }
 
     if (len >= kMaxMsgSize) {
       throw new Error(
-          `RPC framing error, message too large (${len} > ${kMaxMsgSize}`);
+        `RPC framing error, message too large (${len} > ${kMaxMsgSize}`,
+      );
     }
     const end = pos + len;
     if (end > dataEnd) return undefined;
diff --git a/tools/winscope/src/trace_processor/query_result.ts b/tools/winscope/src/trace_processor/query_result.ts
index 24dd2e821..d74db54eb 100644
--- a/tools/winscope/src/trace_processor/query_result.ts
+++ b/tools/winscope/src/trace_processor/query_result.ts
@@ -47,27 +47,24 @@
 // the next batch (if any) within the QueryResultImpl.
 // This object is part of the API exposed to tracks / controllers.
 
-// Import below commented out to prevent the protobufjs initialiation with:
-// `protobuf.util.Long = undefined as any;`
-// The Winscope parsers need the 64-bit proto fields to be retrieved as Long instead of number,
-// otherwise data (e.g. state flags) would be lost because of the 53-bit integer limitation.
-// import './static_initializers';
 import protobuf from 'protobufjs/minimal';
 import {defer, Deferred} from './deferred';
 import {assertExists, assertFalse, assertTrue} from './logging';
 import {utf8Decode} from './string_utils';
+import {duration, Time, time} from './time';
 
+export type SqlValue = string | number | bigint | null | Uint8Array;
+export type ColumnType = SqlValue;
+
+export const UNKNOWN: ColumnType = null;
 export const NUM = 0;
 export const STR = 'str';
-export const NUM_NULL: number|null = 1;
-export const STR_NULL: string|null = 'str_null';
-export const BLOB = new Uint8Array();
-export const BLOB_NULL: Uint8Array|null = new Uint8Array();
+export const NUM_NULL: number | null = 1;
+export const STR_NULL: string | null = 'str_null';
+export const BLOB: Uint8Array = new Uint8Array();
+export const BLOB_NULL: Uint8Array | null = new Uint8Array();
 export const LONG: bigint = 0n;
-export const LONG_NULL: bigint|null = 1n;
-
-export type ColumnType = string|number|bigint|Uint8Array;
-export type SqlValue = ColumnType|null;
+export const LONG_NULL: bigint | null = 1n;
 
 const SHIFT_32BITS = 32n;
 
@@ -79,19 +76,20 @@ export function decodeInt64Varint(buf: Uint8Array, pos: number): bigint {
   let lo: number = 0;
   let i = 0;
 
-  if (buf.length - pos > 4) {  // fast route (lo)
+  if (buf.length - pos > 4) {
+    // fast route (lo)
     for (; i < 4; ++i) {
       // 1st..4th
-      lo = (lo | (buf[pos] & 127) << i * 7) >>> 0;
+      lo = (lo | ((buf[pos] & 127) << (i * 7))) >>> 0;
       if (buf[pos++] < 128) {
         return BigInt(lo);
       }
     }
     // 5th
-    lo = (lo | (buf[pos] & 127) << 28) >>> 0;
-    hi = (hi | (buf[pos] & 127) >> 4) >>> 0;
+    lo = (lo | ((buf[pos] & 127) << 28)) >>> 0;
+    hi = (hi | ((buf[pos] & 127) >> 4)) >>> 0;
     if (buf[pos++] < 128) {
-      return BigInt(hi) << SHIFT_32BITS | BigInt(lo);
+      return (BigInt(hi) << SHIFT_32BITS) | BigInt(lo);
     }
     i = 0;
   } else {
@@ -100,21 +98,22 @@ export function decodeInt64Varint(buf: Uint8Array, pos: number): bigint {
         throw Error('Index out of range');
       }
       // 1st..3rd
-      lo = (lo | (buf[pos] & 127) << i * 7) >>> 0;
+      lo = (lo | ((buf[pos] & 127) << (i * 7))) >>> 0;
       if (buf[pos++] < 128) {
         return BigInt(lo);
       }
     }
     // 4th
-    lo = (lo | (buf[pos++] & 127) << i * 7) >>> 0;
-    return BigInt(hi) << SHIFT_32BITS | BigInt(lo);
+    lo = (lo | ((buf[pos++] & 127) << (i * 7))) >>> 0;
+    return (BigInt(hi) << SHIFT_32BITS) | BigInt(lo);
   }
-  if (buf.length - pos > 4) {  // fast route (hi)
+  if (buf.length - pos > 4) {
+    // fast route (hi)
     for (; i < 5; ++i) {
       // 6th..10th
-      hi = (hi | (buf[pos] & 127) << i * 7 + 3) >>> 0;
+      hi = (hi | ((buf[pos] & 127) << (i * 7 + 3))) >>> 0;
       if (buf[pos++] < 128) {
-        const big = BigInt(hi) << SHIFT_32BITS | BigInt(lo);
+        const big = (BigInt(hi) << SHIFT_32BITS) | BigInt(lo);
         return BigInt.asIntN(64, big);
       }
     }
@@ -124,9 +123,9 @@ export function decodeInt64Varint(buf: Uint8Array, pos: number): bigint {
         throw Error('Index out of range');
       }
       // 6th..10th
-      hi = (hi | (buf[pos] & 127) << i * 7 + 3) >>> 0;
+      hi = (hi | ((buf[pos] & 127) << (i * 7 + 3))) >>> 0;
       if (buf[pos++] < 128) {
-        const big = BigInt(hi) << SHIFT_32BITS | BigInt(lo);
+        const big = (BigInt(hi) << SHIFT_32BITS) | BigInt(lo);
         return BigInt.asIntN(64, big);
       }
     }
@@ -150,13 +149,13 @@ export class QueryError extends Error {
   }
 
   override toString() {
-    return `Query: ${this.query}\n` + super.toString();
+    return `${super.toString()}\nQuery:\n${this.query}`;
   }
 }
 
 // One row extracted from an SQL result:
 export interface Row {
-  [key: string]: ColumnType|null;
+  [key: string]: ColumnType;
 }
 
 // The methods that any iterator has to implement.
@@ -171,7 +170,7 @@ export interface RowIteratorBase {
   // for (const it = queryResult.iter({}); it.valid(); it.next()) {
   //   for (const columnName : queryResult.columns()) {
   //      console.log(it.get(columnName));
-  get(columnName: string): ColumnType|null;
+  get(columnName: string): ColumnType;
 }
 
 // A RowIterator is a type that has all the fields defined in the query spec
@@ -181,9 +180,9 @@ export interface RowIteratorBase {
 // const iter = queryResult.iter({name: STR, surname: STR, id: NUM});
 // for (; iter.valid(); iter.next())
 //  console.log(iter.name, iter.surname);
-export type RowIterator<T extends Row> = RowIteratorBase&T;
+export type RowIterator<T extends Row> = RowIteratorBase & T;
 
-function columnTypeToString(t: ColumnType|null): string {
+function columnTypeToString(t: ColumnType): string {
   switch (t) {
     case NUM:
       return 'NUM';
@@ -201,25 +200,39 @@ function columnTypeToString(t: ColumnType|null): string {
       return 'LONG';
     case LONG_NULL:
       return 'LONG_NULL';
+    case UNKNOWN:
+      return 'UNKNOWN';
     default:
       return `INVALID(${t})`;
   }
 }
 
-function isCompatible(actual: CellType, expected: ColumnType|null): boolean {
+function isCompatible(actual: CellType, expected: ColumnType): boolean {
   switch (actual) {
     case CellType.CELL_NULL:
-      return expected === NUM_NULL || expected === STR_NULL ||
-          expected === BLOB_NULL || expected === LONG_NULL;
+      return (
+        expected === NUM_NULL ||
+        expected === STR_NULL ||
+        expected === BLOB_NULL ||
+        expected === LONG_NULL ||
+        expected === UNKNOWN
+      );
     case CellType.CELL_VARINT:
-      return expected === NUM || expected === NUM_NULL || expected === LONG ||
-          expected === LONG_NULL;
+      return (
+        expected === NUM ||
+        expected === NUM_NULL ||
+        expected === LONG ||
+        expected === LONG_NULL ||
+        expected === UNKNOWN
+      );
     case CellType.CELL_FLOAT64:
-      return expected === NUM || expected === NUM_NULL;
+      return expected === NUM || expected === NUM_NULL || expected === UNKNOWN;
     case CellType.CELL_STRING:
-      return expected === STR || expected === STR_NULL;
+      return expected === STR || expected === STR_NULL || expected === UNKNOWN;
     case CellType.CELL_BLOB:
-      return expected === BLOB || expected === BLOB_NULL;
+      return (
+        expected === BLOB || expected === BLOB_NULL || expected === UNKNOWN
+      );
     default:
       throw new Error(`Unknown CellType ${actual}`);
   }
@@ -234,8 +247,14 @@ enum CellType {
   CELL_BLOB = 5,
 }
 
-const CELL_TYPE_NAMES =
-    ['UNKNOWN', 'NULL', 'VARINT', 'FLOAT64', 'STRING', 'BLOB'];
+const CELL_TYPE_NAMES = [
+  'UNKNOWN',
+  'NULL',
+  'VARINT',
+  'FLOAT64',
+  'STRING',
+  'BLOB',
+];
 
 const TAG_LEN_DELIM = 2;
 
@@ -258,8 +277,11 @@ export interface QueryResult {
   // first result.
   firstRow<T extends Row>(spec: T): T;
 
+  // Like firstRow() but returns undefined if no rows are available.
+  maybeFirstRow<T extends Row>(spec: T): T | undefined;
+
   // If != undefined the query errored out and error() contains the message.
-  error(): string|undefined;
+  error(): string | undefined;
 
   // Returns the number of rows accumulated so far. Note that this number can
   // change over time as more batches are received. It becomes stable only
@@ -269,11 +291,10 @@ export interface QueryResult {
   // If true all rows have been fetched. Calling iter() will iterate through the
   // last row. If false, iter() will return an iterator which might iterate
   // through some rows (or none) but will surely not reach the end.
-
   isComplete(): boolean;
 
   // Returns a promise that is resolved only when all rows (i.e. all batches)
-  // have been fetched. The promise return value is always the object iself.
+  // have been fetched. The promise return value is always the object itself.
   waitAllRows(): Promise<QueryResult>;
 
   // Returns a promise that is resolved when either:
@@ -357,7 +378,7 @@ class QueryResultImpl implements QueryResult, WritableQueryResult {
   numRows(): number {
     return this._numRows;
   }
-  error(): string|undefined {
+  error(): string | undefined {
     return this._error;
   }
   columns(): string[] {
@@ -381,7 +402,15 @@ class QueryResultImpl implements QueryResult, WritableQueryResult {
   firstRow<T extends Row>(spec: T): T {
     const impl = new RowIteratorImplWithRowData(spec, this);
     assertTrue(impl.valid());
-    return impl as {} as RowIterator<T>as T;
+    return impl as {} as RowIterator<T> as T;
+  }
+
+  maybeFirstRow<T extends Row>(spec: T): T | undefined {
+    const impl = new RowIteratorImplWithRowData(spec, this);
+    if (!impl.valid()) {
+      return undefined;
+    }
+    return impl as {} as RowIterator<T> as T;
   }
 
   // Can be called only once.
@@ -425,7 +454,7 @@ class QueryResultImpl implements QueryResult, WritableQueryResult {
     while (reader.pos < reader.len) {
       const tag = reader.uint32();
       switch (tag >>> 3) {
-        case 1:  // column_names
+        case 1: // column_names
           // Only the first batch should contain the column names. If this fires
           // something is going wrong in the handling of the batch stream.
           assertTrue(columnNamesEmptyAtStartOfBatch);
@@ -439,19 +468,19 @@ class QueryResultImpl implements QueryResult, WritableQueryResult {
           // iterating, because column names become iterator object keys.
           for (let i = 1; columnNamesSet.has(colName); ++i) {
             colName = `${origColName}_${i}`;
-            assertTrue(i < 100);  // Give up at some point;
+            assertTrue(i < 100); // Give up at some point;
           }
           columnNamesSet.add(colName);
           this.columnNames.push(colName);
           break;
-        case 2:  // error
+        case 2: // error
           // The query has errored only if the |error| field is non-empty.
           // In protos, we don't distinguish between non-present and empty.
           // Make sure we don't propagate ambiguous empty strings to JS.
           const err = reader.string();
-          this._error = (err !== undefined && err.length) ? err : undefined;
+          this._error = err !== undefined && err.length ? err : undefined;
           break;
-        case 3:  // batch
+        case 3: // batch
           const batchLen = reader.uint32();
           const batchRaw = resBytes.subarray(reader.pos, reader.pos + batchLen);
           reader.pos += batchLen;
@@ -490,8 +519,8 @@ class QueryResultImpl implements QueryResult, WritableQueryResult {
           console.warn(`Unexpected QueryResult field ${tag >>> 3}`);
           reader.skipType(tag & 7);
           break;
-      }  // switch (tag)
-    }    // while (pos < end)
+      } // switch (tag)
+    } // while (pos < end)
 
     if (this.moreRowsPromise !== undefined) {
       this.resolveOrReject(this.moreRowsPromise, this);
@@ -505,11 +534,15 @@ class QueryResultImpl implements QueryResult, WritableQueryResult {
 
   ensureAllRowsPromise(): Promise<QueryResult> {
     if (this.allRowsPromise === undefined) {
-      this.waitAllRows();  // Will populate |this.allRowsPromise|.
+      this.waitAllRows(); // Will populate |this.allRowsPromise|.
     }
     return assertExists(this.allRowsPromise);
   }
 
+  get errorInfo(): QueryErrorInfo {
+    return this._errorInfo;
+  }
+
   private resolveOrReject(promise: Deferred<QueryResult>, arg: QueryResult) {
     if (this._error === undefined) {
       promise.resolve(arg);
@@ -559,27 +592,28 @@ class ResultBatch {
     while (reader.pos < end) {
       const tag = reader.uint32();
       switch (tag >>> 3) {
-        case 1:  // cell types, a packed array containing one CellType per cell.
-          assertTrue((tag & 7) === TAG_LEN_DELIM);  // Must be packed varint.
+        case 1: // cell types, a packed array containing one CellType per cell.
+          assertTrue((tag & 7) === TAG_LEN_DELIM); // Must be packed varint.
           this.cellTypesLen = reader.uint32();
           this.cellTypesOff = reader.pos;
           reader.pos += this.cellTypesLen;
           break;
 
-        case 2:  // varint_cells, a packed varint buffer.
-          assertTrue((tag & 7) === TAG_LEN_DELIM);  // Must be packed varint.
+        case 2: // varint_cells, a packed varint buffer.
+          assertTrue((tag & 7) === TAG_LEN_DELIM); // Must be packed varint.
           const packLen = reader.uint32();
           this.varintOff = reader.pos;
           this.varintLen = packLen;
           assertTrue(reader.buf === batchBytes);
           assertTrue(
-              this.varintOff + this.varintLen <=
-              batchBytes.byteOffset + batchBytes.byteLength);
+            this.varintOff + this.varintLen <=
+              batchBytes.byteOffset + batchBytes.byteLength,
+          );
           reader.pos += packLen;
           break;
 
-        case 3:  // float64_cells, a 64-bit aligned packed fixed64 buffer.
-          assertTrue((tag & 7) === TAG_LEN_DELIM);  // Must be packed varint.
+        case 3: // float64_cells, a 64-bit aligned packed fixed64 buffer.
+          assertTrue((tag & 7) === TAG_LEN_DELIM); // Must be packed varint.
           const f64Len = reader.uint32();
           assertTrue(f64Len % 8 === 0);
           // Float64Array's constructor is evil: the offset is in bytes but the
@@ -587,8 +621,11 @@ class ResultBatch {
           const f64Words = f64Len / 8;
           const f64Off = batchBytes.byteOffset + reader.pos;
           if (f64Off % 8 === 0) {
-            this.float64Cells =
-                new Float64Array(batchBytes.buffer, f64Off, f64Words);
+            this.float64Cells = new Float64Array(
+              batchBytes.buffer,
+              f64Off,
+              f64Words,
+            );
           } else {
             // When using the production code in trace_processor's rpc.cc, the
             // float64 should be 8-bytes aligned. The slow-path case is only for
@@ -599,14 +636,14 @@ class ResultBatch {
           reader.pos += f64Len;
           break;
 
-        case 4:  // blob_cells: one entry per blob.
+        case 4: // blob_cells: one entry per blob.
           assertTrue((tag & 7) === TAG_LEN_DELIM);
           // protobufjs's bytes() under the hoods calls slice() and creates
           // a copy. Fine here as blobs are rare and not a fastpath.
           this.blobCells.push(new Uint8Array(reader.bytes()));
           break;
 
-        case 5:  // string_cells: all the string cells concatenated with \0s.
+        case 5: // string_cells: all the string cells concatenated with \0s.
           assertTrue((tag & 7) === TAG_LEN_DELIM);
           const strLen = reader.uint32();
           assertTrue(reader.pos + strLen <= end);
@@ -619,11 +656,11 @@ class ResultBatch {
           reader.pos += strLen;
           break;
 
-        case 6:  // is_last_batch (boolean).
+        case 6: // is_last_batch (boolean).
           this.isLastBatch = !!reader.bool();
           break;
 
-        case 7:  // padding for realignment, skip silently.
+        case 7: // padding for realignment, skip silently.
           reader.skipType(tag & 7);
           break;
 
@@ -631,8 +668,8 @@ class ResultBatch {
           console.warn(`Unexpected QueryResult.CellsBatch field ${tag >>> 3}`);
           reader.skipType(tag & 7);
           break;
-      }  // switch(tag)
-    }    // while (pos < end)
+      } // switch(tag)
+    } // while (pos < end)
   }
 
   get numCells() {
@@ -659,11 +696,11 @@ class RowIteratorImpl implements RowIteratorBase {
   // the next() hotpath, so we can do this.float64Cells vs
   // this.resultObj.batch[this.batchIdx].float64Cells.
   // These are re-set every time tryMoveToNextBatch() is called (and succeeds).
-  private batchIdx = -1;  // The batch index within |result.batches[]|.
+  private batchIdx = -1; // The batch index within |result.batches[]|.
   private batchBytes = new Uint8Array();
   private columnNames: string[] = [];
   private numColumns = 0;
-  private cellTypesEnd = -1;  // -1 so the 1st next() hits tryMoveToNextBatch().
+  private cellTypesEnd = -1; // -1 so the 1st next() hits tryMoveToNextBatch().
   private float64Cells = new Float64Array();
   private varIntReader = protobuf.Reader.create(this.batchBytes);
   private blobCells: Uint8Array[] = [];
@@ -680,7 +717,7 @@ class RowIteratorImpl implements RowIteratorBase {
   constructor(querySpec: Row, rowData: Row, res: QueryResultImpl) {
     Object.assign(this, querySpec);
     this.rowData = rowData;
-    this.rowSpec = {...querySpec};  // ... -> Copy all the key/value pairs.
+    this.rowSpec = {...querySpec}; // ... -> Copy all the key/value pairs.
     this.resultObj = res;
     this.next();
   }
@@ -689,13 +726,17 @@ class RowIteratorImpl implements RowIteratorBase {
     return this.isValid;
   }
 
+  private makeError(message: string): QueryError {
+    return new QueryError(message, this.resultObj.errorInfo);
+  }
 
-  get(columnName: string): ColumnType|null {
+  get(columnName: string): ColumnType {
     const res = this.rowData[columnName];
     if (res === undefined) {
-      throw new Error(
-          `Column '${columnName}' doesn't exist. ` +
-          `Actual columns: [${this.columnNames.join(',')}]`);
+      throw this.makeError(
+        `Column '${columnName}' doesn't exist. ` +
+          `Actual columns: [${this.columnNames.join(',')}]`,
+      );
     }
     return res;
   }
@@ -716,8 +757,8 @@ class RowIteratorImpl implements RowIteratorBase {
       // whole rows in each QueryResult batch and NOT truncate them midway.
       // If this assert fires the TP RPC logic has a bug.
       assertTrue(
-          this.nextCellTypeOff === this.cellTypesEnd ||
-          this.cellTypesEnd === -1);
+        this.nextCellTypeOff === this.cellTypesEnd || this.cellTypesEnd === -1,
+      );
       if (!this.tryMoveToNextBatch()) {
         this.isValid = false;
         return;
@@ -748,10 +789,12 @@ class RowIteratorImpl implements RowIteratorBase {
             rowData[colName] = val as {} as number;
           } else {
             // LONG, LONG_NULL, or unspecified - return as bigint
-            const value =
-                decodeInt64Varint(this.batchBytes, this.varIntReader.pos);
+            const value = decodeInt64Varint(
+              this.batchBytes,
+              this.varIntReader.pos,
+            );
             rowData[colName] = value;
-            this.varIntReader.skip();  // Skips a varint
+            this.varIntReader.skip(); // Skips a varint
           }
           break;
 
@@ -769,9 +812,9 @@ class RowIteratorImpl implements RowIteratorBase {
           break;
 
         default:
-          throw new Error(`Invalid cell type ${cellType}`);
+          throw this.makeError(`Invalid cell type ${cellType}`);
       }
-    }  // For (cells)
+    } // For (cells)
     this.isValid = true;
   }
 
@@ -802,9 +845,10 @@ class RowIteratorImpl implements RowIteratorBase {
     // Check that all the expected columns are present.
     for (const expectedCol of Object.keys(this.rowSpec)) {
       if (this.columnNames.indexOf(expectedCol) < 0) {
-        throw new Error(
-            `Column ${expectedCol} not found in the SQL result ` +
-            `set {${this.columnNames.join(' ')}}`);
+        throw this.makeError(
+          `Column ${expectedCol} not found in the SQL result ` +
+            `set {${this.columnNames.join(' ')}}`,
+        );
       }
     }
 
@@ -835,19 +879,20 @@ class RowIteratorImpl implements RowIteratorBase {
       let err = '';
       if (!isCompatible(actualType, expType)) {
         if (actualType === CellType.CELL_NULL) {
-          err = 'SQL value is NULL but that was not expected' +
-              ` (expected type: ${columnTypeToString(expType)}). ` +
-              'Did you mean NUM_NULL, LONG_NULL, STR_NULL or BLOB_NULL?';
+          err =
+            'SQL value is NULL but that was not expected' +
+            ` (expected type: ${columnTypeToString(expType)}). ` +
+            'Did you mean NUM_NULL, LONG_NULL, STR_NULL or BLOB_NULL?';
         } else {
-          err = `Incompatible cell type. Expected: ${
-              columnTypeToString(
-                  expType)} actual: ${CELL_TYPE_NAMES[actualType]}`;
+          err = `Incompatible cell type. Expected: ${columnTypeToString(
+            expType,
+          )} actual: ${CELL_TYPE_NAMES[actualType]}`;
         }
       }
       if (err.length > 0) {
-        throw new Error(
-            `Error @ row: ${Math.floor(i / numColumns)} col: '` +
-            `${colName}': ${err}`);
+        const row = Math.floor(i / numColumns);
+        const message = `Error @ row: ${row} col: '${colName}': ${err}`;
+        throw this.makeError(message);
       }
     }
     return true;
@@ -864,7 +909,7 @@ class RowIteratorImplWithRowData implements RowIteratorBase {
 
   next: () => void;
   valid: () => boolean;
-  get: (columnName: string) => ColumnType|null;
+  get: (columnName: string) => ColumnType;
 
   constructor(querySpec: Row, res: QueryResultImpl) {
     const thisAsRow = this as {} as Row;
@@ -882,8 +927,9 @@ class RowIteratorImplWithRowData implements RowIteratorBase {
 //    await engine.query('...') and will get a QueryResult that is guaranteed
 //    to be complete.
 // 2. Clients that know how to handle the streaming can use it straight away.
-class WaitableQueryResultImpl implements QueryResult, WritableQueryResult,
-                                         PromiseLike<QueryResult> {
+class WaitableQueryResultImpl
+  implements QueryResult, WritableQueryResult, PromiseLike<QueryResult>
+{
   private impl: QueryResultImpl;
   private thenCalled = false;
 
@@ -898,6 +944,9 @@ class WaitableQueryResultImpl implements QueryResult, WritableQueryResult,
   firstRow<T extends Row>(spec: T) {
     return this.impl.firstRow(spec);
   }
+  maybeFirstRow<T extends Row>(spec: T) {
+    return this.impl.maybeFirstRow(spec);
+  }
   waitAllRows() {
     return this.impl.waitAllRows();
   }
@@ -933,29 +982,60 @@ class WaitableQueryResultImpl implements QueryResult, WritableQueryResult,
 
   // PromiseLike<QueryResult> implementaton.
 
+  // eslint-disable-next-line @typescript-eslint/no-explicit-any
   then(onfulfilled: any, onrejected: any): any {
     assertFalse(this.thenCalled);
     this.thenCalled = true;
     return this.impl.ensureAllRowsPromise().then(onfulfilled, onrejected);
   }
 
+  // eslint-disable-next-line @typescript-eslint/no-explicit-any
   catch(error: any): any {
     return this.impl.ensureAllRowsPromise().catch(error);
   }
 
+  // eslint-disable-next-line @typescript-eslint/no-explicit-any
   finally(callback: () => void): any {
     return this.impl.ensureAllRowsPromise().finally(callback);
   }
 
   // eslint and clang-format disagree on how to format get[foo](). Let
   // clang-format win:
-  // eslint-disable-next-line keyword-spacing
-  get[Symbol.toStringTag](): string {
+  get [Symbol.toStringTag](): string {
     return 'Promise<WaitableQueryResult>';
   }
 }
 
-export function createQueryResult(errorInfo: QueryErrorInfo): QueryResult&
-    Promise<QueryResult>&WritableQueryResult {
+export function createQueryResult(
+  errorInfo: QueryErrorInfo,
+): QueryResult & Promise<QueryResult> & WritableQueryResult {
   return new WaitableQueryResultImpl(errorInfo);
 }
+
+// Throws if the value cannot be reasonably converted to a bigint.
+// Assumes value is in native time units.
+export function timeFromSql(value: ColumnType): time {
+  if (typeof value === 'bigint') {
+    return Time.fromRaw(value);
+  } else if (typeof value === 'number') {
+    return Time.fromRaw(BigInt(Math.floor(value)));
+  } else if (value === null) {
+    return Time.ZERO;
+  } else {
+    throw Error(`Refusing to create time from unrelated type ${value}`);
+  }
+}
+
+// Throws if the value cannot be reasonably converted to a bigint.
+// Assumes value is in nanoseconds.
+export function durationFromSql(value: ColumnType): duration {
+  if (typeof value === 'bigint') {
+    return value;
+  } else if (typeof value === 'number') {
+    return BigInt(Math.floor(value));
+  } else if (value === null) {
+    return 0n;
+  } else {
+    throw Error(`Refusing to create duration from unrelated type ${value}`);
+  }
+}
diff --git a/tools/winscope/src/trace_processor/test_utils.ts b/tools/winscope/src/trace_processor/test_utils.ts
new file mode 100644
index 000000000..171563bb2
--- /dev/null
+++ b/tools/winscope/src/trace_processor/test_utils.ts
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import {assertDefined,} from 'common/assert_utils';
+import {Timestamp} from 'common/time/time';
+import {
+  ColumnType,
+  QueryResult,
+  Row,
+  RowIterator,
+} from 'trace_processor/query_result';
+import {TraceProcessorFactory} from 'trace_processor/trace_processor_factory';
+
+export function makeSearchTraceSpies(
+    ts?: Timestamp,
+    value?: ColumnType,
+  ): [jasmine.SpyObj<QueryResult>, jasmine.SpyObj<RowIterator<Row>>] {
+  const spyQueryResult = jasmine.createSpyObj<QueryResult>('result', [
+    'numRows',
+    'columns',
+    'iter',
+  ]);
+  spyQueryResult.numRows.and.returnValue(1);
+  const columns: string[] = [];
+  if (ts !== undefined) columns.push('ts');
+  columns.push('property');
+  if (value !== undefined) columns.push('value');
+  spyQueryResult.columns.and.returnValue(columns);
+
+  const spyIter = jasmine.createSpyObj<RowIterator<Row>>('iter', [
+    'valid',
+    'next',
+    'get',
+  ]);
+  if (ts !== undefined) {
+    spyIter.get.withArgs('ts').and.returnValue(ts.getValueNs());
+  }
+  spyIter.get.withArgs('property').and.returnValue('test_property');
+  if (value !== undefined) {
+    spyIter.get.withArgs('value').and.returnValue(value);
+  }
+  spyIter.valid.and.returnValue(true);
+  spyIter.next.and.callFake(() =>
+    assertDefined(spyIter).valid.and.returnValue(false),
+  );
+  spyQueryResult.iter.and.returnValue(spyIter);
+
+  return [spyQueryResult, spyIter];
+}
+
+export async function runQueryAndGetResult(query: string): Promise<QueryResult> {
+  const tp = TraceProcessorFactory.getSingleInstance();
+  return tp.query(query);
+}
+
+function makeSpyQueryResult(): jasmine.SpyObj<QueryResult> {
+  return jasmine.createSpyObj<QueryResult>('result', [
+    'numRows',
+    'firstRow',
+  ]);
+}
+
+export function setNumRowsSpyQueryResult(
+  rows: number,
+  spyQueryResult?: jasmine.SpyObj<QueryResult>,
+): jasmine.SpyObj<QueryResult> {
+  const spy = spyQueryResult ?? makeSpyQueryResult();
+  spy.numRows.and.returnValue(rows);
+  return spy;
+}
+
+export function setFirstRowSpyQueryResult(
+  query: string,
+  tpSpy: jasmine.Spy,
+  result: Row,
+  spyQueryResult?: jasmine.SpyObj<QueryResult>,
+): jasmine.SpyObj<QueryResult> {
+  const spy = spyQueryResult ?? makeSpyQueryResult();
+  spy.firstRow.and.returnValue(result);
+  tpSpy.withArgs(query).and.returnValue(Promise.resolve(spy));
+  return spy;
+}
diff --git a/tools/winscope/src/trace_processor/time.ts b/tools/winscope/src/trace_processor/time.ts
new file mode 100644
index 000000000..15caa232e
--- /dev/null
+++ b/tools/winscope/src/trace_processor/time.ts
@@ -0,0 +1,46 @@
+// Copyright (C) 2018 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+type Brand<T, V extends string> = T & {__type: V};
+
+// The |time| type represents trace time in the same units and domain as trace
+// processor (i.e. typically boot time in nanoseconds, but most of the UI should
+// be completely agnostic to this).
+export type time = Brand<bigint, 'time'>;
+
+// The |duration| type is used to represent the duration of time between two
+// |time|s. The domain is irrelevant because a duration is relative.
+export type duration = bigint;
+
+export class Time {
+  static readonly ZERO = Time.fromRaw(0n);
+
+  // Cast a bigint to a |time|. Supports potentially |undefined| values.
+  // I.e. it performs the following conversions:
+  // - `bigint` -> `time`
+  // - `bigint|undefined` -> `time|undefined`
+  //
+  // Use this function with caution. The function is effectively a no-op in JS,
+  // but using it tells TypeScript that "this value is a time value". It's up to
+  // the caller to ensure the value is in the correct units and time domain.
+  //
+  // If you're reaching for this function after doing some maths on a |time|
+  // value and it's decayed to a |bigint| consider using the static math methods
+  // in |Time| instead, as they will do the appropriate casting for you.
+  static fromRaw(v: bigint): time;
+  static fromRaw(v?: bigint): time | undefined;
+  static fromRaw(v?: bigint): time | undefined {
+    return v as time | undefined;
+  }
+}
diff --git a/tools/winscope/src/trace_processor/trace_processor.ts b/tools/winscope/src/trace_processor/trace_processor.ts
index 29da268af..f239b1ddf 100644
--- a/tools/winscope/src/trace_processor/trace_processor.ts
+++ b/tools/winscope/src/trace_processor/trace_processor.ts
@@ -22,8 +22,8 @@ import {WasmEngineProxy} from './wasm_engine_proxy';
 export class TraceProcessor {
   private wasmEngine: WasmEngineProxy;
 
-  constructor(engineId: string, enginePort: MessagePort) {
-    this.wasmEngine = new WasmEngineProxy(engineId, enginePort);
+  constructor(engineId: string) {
+    this.wasmEngine = new WasmEngineProxy(engineId);
   }
 
   async query(sqlQuery: string): Promise<QueryResult> {
@@ -31,17 +31,6 @@ export class TraceProcessor {
     const result = await this.wasmEngine.query(sqlQuery);
     Analytics.TraceProcessor.logQueryExecutionTime(
       Date.now() - startTimeMs,
-      false
-    );
-    return result;
-  }
-
-  async queryAllRows(sqlQuery: string): Promise<QueryResult> {
-    const startTimeMs = Date.now();
-    const result = await this.wasmEngine.query(sqlQuery).waitAllRows();
-    Analytics.TraceProcessor.logQueryExecutionTime(
-      Date.now() - startTimeMs,
-      true
     );
     return result;
   }
diff --git a/tools/winscope/src/trace_processor/trace_processor_factory.ts b/tools/winscope/src/trace_processor/trace_processor_factory.ts
index c9983bcea..9febbcb8e 100644
--- a/tools/winscope/src/trace_processor/trace_processor_factory.ts
+++ b/tools/winscope/src/trace_processor/trace_processor_factory.ts
@@ -19,13 +19,12 @@ import {getRootUrl} from 'common/url_utils';
 import {TraceProcessor} from './trace_processor';
 import {
   initWasm,
-  resetEngineWorker,
 } from './wasm_engine_proxy';
 
 export class TraceProcessorFactory {
   private static tp?: TraceProcessor;
 
-  static async getSingleInstance(): Promise<TraceProcessor> {
+  static getSingleInstance(): TraceProcessor {
     if (!TraceProcessorFactory.tp) {
       const traceProcessorRootUrl =
         globalConfig.MODE === 'KARMA_TEST'
@@ -34,10 +33,8 @@ export class TraceProcessorFactory {
           : getRootUrl();
       initWasm(traceProcessorRootUrl);
       const engineId = 'random-id';
-      const enginePort = resetEngineWorker();
-      TraceProcessorFactory.tp = new TraceProcessor(engineId, enginePort);
+      TraceProcessorFactory.tp = new TraceProcessor(engineId);
     }
-
     return TraceProcessorFactory.tp;
   }
 }
diff --git a/tools/winscope/src/trace_processor/wasm_engine_proxy.ts b/tools/winscope/src/trace_processor/wasm_engine_proxy.ts
index 9ea76d536..12c797a49 100644
--- a/tools/winscope/src/trace_processor/wasm_engine_proxy.ts
+++ b/tools/winscope/src/trace_processor/wasm_engine_proxy.ts
@@ -12,49 +12,44 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+import {EngineBase} from './engine';
 import {assertExists, assertTrue} from './logging';
-import {Engine, LoadingTracker} from './engine';
 
 let bundlePath: string;
 let idleWasmWorker: Worker;
-let activeWasmWorker: Worker;
 
 export function initWasm(root: string) {
   bundlePath = root + 'engine_bundle.js';
   idleWasmWorker = new Worker(bundlePath);
 }
 
-// This method is called trace_controller whenever a new trace is loaded.
-export function resetEngineWorker(): MessagePort {
-  const channel = new MessageChannel();
-  const port = channel.port1;
-
-  // We keep always an idle worker around, the first one is created by the
-  // main() below, so we can hide the latency of the Wasm initialization.
-  if (activeWasmWorker !== undefined) {
-    activeWasmWorker.terminate();
-  }
-
-  // Swap the active worker with the idle one and create a new idle worker
-  // for the next trace.
-  activeWasmWorker = assertExists(idleWasmWorker);
-  activeWasmWorker.postMessage(port, [port]);
-  idleWasmWorker = new Worker(bundlePath);
-  return channel.port2;
-}
-
 /**
  * This implementation of Engine uses a WASM backend hosted in a separate
- * worker thread.
+ * worker thread. The entrypoint of the worker thread is engine/index.ts.
  */
-export class WasmEngineProxy extends Engine {
+export class WasmEngineProxy extends EngineBase {
+  readonly mode = 'WASM';
   readonly id: string;
   private port: MessagePort;
+  private worker: Worker;
 
-  constructor(id: string, port: MessagePort, loadingTracker?: LoadingTracker) {
-    super(loadingTracker);
+  constructor(id: string) {
+    super();
     this.id = id;
-    this.port = port;
+    const channel = new MessageChannel();
+    const port1 = channel.port1;
+    this.port = channel.port2;
+
+    // We keep an idle instance around to hide the latency of initializing the
+    // instance. Creating the worker (new Worker()) is ~instantaneous, but then
+    // the initialization in the worker thread (i.e. the call to
+    // `new WasmBridge()` that engine/index.ts makes) takes several seconds.
+    // Here we hide that initialization latency by always keeping an idle worker
+    // around. The latency is hidden by the fact that the user usually takes few
+    // seconds until they click on "open trace file" and pick a file.
+    this.worker = assertExists(idleWasmWorker);
+    idleWasmWorker = new Worker(bundlePath);
+    this.worker.postMessage(port1, [port1]);
     this.port.onmessage = this.onMessage.bind(this);
   }
 
@@ -69,4 +64,8 @@ export class WasmEngineProxy extends Engine {
     // TypedArray for each decode operation would be too expensive).
     this.port.postMessage(data);
   }
-}
+
+  dispose() {
+    this.worker.terminate();
+  }
+}
\ No newline at end of file
diff --git a/tools/winscope/src/trace_processor/worker_messages.ts b/tools/winscope/src/trace_processor/worker_messages.ts
deleted file mode 100644
index 166b1cce1..000000000
--- a/tools/winscope/src/trace_processor/worker_messages.ts
+++ /dev/null
@@ -1,30 +0,0 @@
-// Copyright (C) 2021 The Android Open Source Project
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//      http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-// This file defines the API of messages exchanged between frontend and
-// {engine, controller} worker when bootstrapping the workers.
-// Those messages are sent only once. The rest of the communication happens
-// over the MessagePort(s) that are sent in the init message.
-
-// This is so we can create all the workers in a central place in the frontend
-// (Safari still doesn't spawning workers from other workers) but then let them
-// communicate by sending the right MessagePort to them.
-
-// Frontend -> Engine initialization message.
-export interface EngineWorkerInitMessage {
-  // The port used to receive engine messages (e.g., query commands).
-  // The controller owns the other end of the MessageChannel
-  // (see resetEngineWorker()).
-  enginePort: MessagePort;
-}
diff --git a/tools/winscope/src/viewers/common/abstract_hierarchy_viewer_component_test.ts b/tools/winscope/src/viewers/common/abstract_hierarchy_viewer_component_test.ts
new file mode 100644
index 000000000..45e4e9437
--- /dev/null
+++ b/tools/winscope/src/viewers/common/abstract_hierarchy_viewer_component_test.ts
@@ -0,0 +1,148 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import {CommonModule} from '@angular/common';
+import {HttpClientModule} from '@angular/common/http';
+import {Type} from '@angular/core';
+import {ComponentFixtureAutoDetect, TestBed} from '@angular/core/testing';
+import {FormsModule} from '@angular/forms';
+import {MatButtonModule} from '@angular/material/button';
+import {MatCheckboxModule} from '@angular/material/checkbox';
+import {MatDividerModule} from '@angular/material/divider';
+import {MatFormFieldModule} from '@angular/material/form-field';
+import {MatIconModule} from '@angular/material/icon';
+import {MatInputModule} from '@angular/material/input';
+import {MatSelectModule} from '@angular/material/select';
+import {MatSliderModule} from '@angular/material/slider';
+import {MatTooltipModule} from '@angular/material/tooltip';
+import {BrowserAnimationsModule} from '@angular/platform-browser/animations';
+import {assertDefined} from 'common/assert_utils';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
+import {CollapsedSectionsComponent} from 'viewers/components/collapsed_sections_component';
+import {CollapsibleSectionTitleComponent} from 'viewers/components/collapsible_section_title_component';
+import {HierarchyComponent} from 'viewers/components/hierarchy_component';
+import {PropertiesComponent} from 'viewers/components/properties_component';
+import {RectsComponent} from 'viewers/components/rects/rects_component';
+import {SearchBoxComponent} from 'viewers/components/search_box_component';
+import {UserOptionsComponent} from 'viewers/components/user_options_component';
+
+export abstract class AbstractHierarchyViewerComponentTest<T extends object> {
+  execute() {
+    describe('Hierarchy viewer component', () => {
+      let dom: DOMTestHelper<T>;
+      let component: T;
+
+      beforeEach(async () => {
+        [dom, component] = await this.setUpTestEnvironment();
+      });
+
+      it('creates hierarchy view', () => {
+        expect(dom.find('.hierarchy-view')).toBeDefined();
+      });
+
+      it('creates properties view', () => {
+        expect(dom.find('.properties-view')).toBeDefined();
+      });
+
+      it('creates collapsed sections with no buttons', () => {
+        dom.checkNoCollapsedSectionButtons();
+      });
+
+      it('handles hierarchy section collapse/expand', () => {
+        dom.checkSectionCollapseAndExpand(
+          '.hierarchy-view',
+          this.hierarchyTitle,
+        );
+      });
+
+      it('handles properties section collapse/expand', () => {
+        dom.checkSectionCollapseAndExpand(
+          '.properties-view',
+          this.propertiesTitle,
+        );
+      });
+
+      if (this.testRects) {
+        it('creates rects view', () => {
+          expect(dom.find('.rects-view')).toBeDefined();
+        });
+
+        it('handles rects section collapse/expand', () => {
+          dom.checkSectionCollapseAndExpand(
+            '.rects-view',
+            assertDefined(this.rectsTitle),
+          );
+        });
+      }
+    });
+
+    if (this.executeSpecializedTests) {
+      this.executeSpecializedTests();
+    }
+  }
+
+  protected async initializeTestEnvironment<U extends T>(
+    typeofViewer: Type<U>,
+    addedDeclarations: object[] = [],
+  ): Promise<[DOMTestHelper<U>, U]> {
+    const declarations: object[] = [
+      typeofViewer,
+      HierarchyComponent,
+      PropertiesComponent,
+      RectsComponent,
+      CollapsedSectionsComponent,
+      CollapsibleSectionTitleComponent,
+      UserOptionsComponent,
+      SearchBoxComponent,
+    ];
+    if (addedDeclarations) {
+      declarations.push(...addedDeclarations);
+    }
+    await TestBed.configureTestingModule({
+      providers: [{provide: ComponentFixtureAutoDetect, useValue: true}],
+      imports: [
+        CommonModule,
+        MatIconModule,
+        MatDividerModule,
+        MatCheckboxModule,
+        MatSliderModule,
+        MatFormFieldModule,
+        MatInputModule,
+        BrowserAnimationsModule,
+        FormsModule,
+        MatTooltipModule,
+        MatButtonModule,
+        MatSelectModule,
+        HttpClientModule,
+      ],
+      declarations,
+    }).compileComponents();
+
+    const fixture = TestBed.createComponent<U>(typeofViewer);
+    const component = fixture.componentInstance;
+    const dom = new DOMTestHelper(fixture, fixture.nativeElement);
+    dom.detectChanges();
+    return [dom, component];
+  }
+
+  protected abstract readonly testRects: boolean;
+  protected abstract readonly hierarchyTitle: string;
+  protected abstract readonly propertiesTitle: string;
+  protected readonly rectsTitle?: string;
+
+  protected abstract setUpTestEnvironment(): Promise<[DOMTestHelper<T>, T]>;
+  protected executeSpecializedTests?(): void;
+}
diff --git a/tools/winscope/src/viewers/common/abstract_hierarchy_viewer_presenter_test.ts b/tools/winscope/src/viewers/common/abstract_hierarchy_viewer_presenter_test.ts
index f37903ba1..b806b3e76 100644
--- a/tools/winscope/src/viewers/common/abstract_hierarchy_viewer_presenter_test.ts
+++ b/tools/winscope/src/viewers/common/abstract_hierarchy_viewer_presenter_test.ts
@@ -133,7 +133,9 @@ export abstract class AbstractHierarchyViewerPresenterTest<
           await presenter.onAppEvent(this.getPositionUpdate());
           expect(uiData.rectSpec).toEqual(this.expectedInitialRectSpec);
 
-          const rect = assertDefined(uiData.rectsToDraw?.at(2));
+          const rect = assertDefined(uiData.rectsToDraw)[
+            assertDefined(this.rectIndex)
+          ];
           await presenter.onHighlightedIdChange(rect.id);
           expect(uiData.highlightedItem).toEqual(rect.id);
           const propertiesTree = assertDefined(uiData.propertiesTree);
@@ -208,6 +210,7 @@ export abstract class AbstractHierarchyViewerPresenterTest<
   abstract readonly expectedHierarchyOpts: UserOptions;
   abstract readonly expectedPropertiesOpts: UserOptions;
 
+  readonly rectIndex?: number;
   readonly expectedInitialRectSpec?: RectSpec;
   readonly expectedRectsOpts?: UserOptions;
   readonly treeNodeLongName?: string;
diff --git a/tools/winscope/src/viewers/common/abstract_log_viewer_component_test.ts b/tools/winscope/src/viewers/common/abstract_log_viewer_component_test.ts
new file mode 100644
index 000000000..a6b0268a5
--- /dev/null
+++ b/tools/winscope/src/viewers/common/abstract_log_viewer_component_test.ts
@@ -0,0 +1,264 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import {ClipboardModule} from '@angular/cdk/clipboard';
+import {
+  CdkVirtualScrollViewport,
+  ScrollingModule,
+} from '@angular/cdk/scrolling';
+import {HttpClientModule} from '@angular/common/http';
+import {Type} from '@angular/core';
+import {ComponentFixtureAutoDetect, TestBed} from '@angular/core/testing';
+import {FormsModule} from '@angular/forms';
+import {MatButtonModule} from '@angular/material/button';
+import {MatDividerModule} from '@angular/material/divider';
+import {MatFormFieldModule} from '@angular/material/form-field';
+import {MatIconModule} from '@angular/material/icon';
+import {MatInputModule} from '@angular/material/input';
+import {MatSelectModule} from '@angular/material/select';
+import {MatSliderModule} from '@angular/material/slider';
+import {MatTooltipModule} from '@angular/material/tooltip';
+import {BrowserAnimationsModule} from '@angular/platform-browser/animations';
+import {assertDefined} from 'common/assert_utils';
+import {animationFrameScheduler} from 'rxjs';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
+import {CollapsedSectionsComponent} from 'viewers/components/collapsed_sections_component';
+import {CollapsibleSectionTitleComponent} from 'viewers/components/collapsible_section_title_component';
+import {LogComponent} from 'viewers/components/log_component';
+import {PropertiesComponent} from 'viewers/components/properties_component';
+import {PropertyTreeNodeDataViewComponent} from 'viewers/components/property_tree_node_data_view_component';
+import {SearchBoxComponent} from 'viewers/components/search_box_component';
+import {SelectWithFilterComponent} from 'viewers/components/select_with_filter_component';
+import {TreeComponent} from 'viewers/components/tree_component';
+import {TreeNodeComponent} from 'viewers/components/tree_node_component';
+import {ViewerInputComponent} from 'viewers/viewer_input/viewer_input_component';
+import {ViewerJankCujsComponent} from 'viewers/viewer_jank_cujs/viewer_jank_cujs_component';
+import {ViewerProtologComponent} from 'viewers/viewer_protolog/viewer_protolog_component';
+import {ViewerTransactionsComponent} from 'viewers/viewer_transactions/viewer_transactions_component';
+import {ViewerTransitionsComponent} from 'viewers/viewer_transitions/viewer_transitions_component';
+import {ColumnSpec, UiDataLog} from './ui_data_log';
+import {VariableHeightScrollDirective} from './variable_height_scroll_directive';
+
+type LogViewerComponent =
+  | ViewerProtologComponent
+  | ViewerTransactionsComponent
+  | ViewerTransitionsComponent
+  | ViewerInputComponent
+  | ViewerJankCujsComponent;
+
+export abstract class AbstractLogViewerComponentTest<
+  T extends LogViewerComponent,
+> {
+  protected readonly testSpec: ColumnSpec = {
+    name: 'Test Column',
+    cssClass: 'test-class',
+  };
+  protected readonly testField = {spec: this.testSpec, value: 'VALUE'};
+
+  execute() {
+    describe('Log viewer component', () => {
+      let dom: DOMTestHelper<T>;
+      let viewport: CdkVirtualScrollViewport;
+      let component: T;
+
+      describe('common', () => {
+        beforeEach(async () => {
+          [dom, viewport, component] = await this.setUpTestEnvironment();
+        });
+
+        it('can be created', () => {
+          expect(component).toBeTruthy();
+        });
+
+        it('renders log component', () => {
+          expect(dom.find('.log-view')).toBeDefined();
+        });
+
+        it('render headers as filters', () => {
+          const selector = `.headers .filter.${
+            this.testSpec.cssClass.split(' ')[0]
+          }`;
+          expect(dom.find(selector) !== undefined).toEqual(this.hasFilters);
+        });
+
+        it('renders entries with field values', () => {
+          expect(dom.find('.scroll')).toBeDefined();
+          const entry = dom.get(
+            `.scroll .entry .${this.testSpec.cssClass.split(' ')[0]}`,
+          );
+          entry.checkText('VALUE');
+          this.checkTimestampInTable(dom);
+        });
+
+        it('handles go to current time button', () => {
+          expect(dom.find('.go-to-current-time') !== undefined).toEqual(
+            this.hasCurrentTimeButton,
+          );
+        });
+
+        if (this.testProperties) {
+          it('renders properties', () => {
+            expect(dom.find('.properties-view')).toBeDefined();
+          });
+
+          it('creates collapsed sections with no buttons', () => {
+            dom.checkNoCollapsedSectionButtons();
+          });
+
+          it('handles properties section collapse/expand', () => {
+            dom.checkSectionCollapseAndExpand(
+              '.properties-view',
+              assertDefined(this.propertiesSectionTitle),
+            );
+          });
+
+          it('shows message when no entry is selected', () => {
+            const data = assertDefined(component.inputData);
+            (data as any).propertiesTree = undefined;
+            dom.detectChanges();
+            dom
+              .get('.properties-view .placeholder-text')
+              .checkTextExact(assertDefined(this.propertiesPlaceholder));
+          });
+        }
+      });
+
+      if (this.testScroll) {
+        describe('scroll', () => {
+          beforeEach(async () => {
+            [dom, viewport] = this.setUpTestEnvironmentForScroll
+              ? await this.setUpTestEnvironmentForScroll()
+              : await this.setUpTestEnvironment();
+          });
+
+          it('renders initial state', () => {
+            expect(dom.findAll('.entry').length).toEqual(20);
+          });
+
+          it('gets data length', () => {
+            expect(viewport.getDataLength()).toEqual(200);
+          });
+
+          it('should get the rendered range', () => {
+            expect(viewport.getRenderedRange()).toEqual({start: 0, end: 20});
+          });
+
+          it('should scroll to index in large jumps', () => {
+            expect(dom.find(`.entry[item-id="30"]`)).toBeUndefined();
+            checkScrollToIndex(30);
+            expect(dom.find(`.entry[item-id="70"]`)).toBeUndefined();
+            checkScrollToIndex(70);
+          });
+
+          it('should update without jumps as the user scrolls down or up', () => {
+            for (let i = 1; i < 50; i++) {
+              checkScrollToIndex(i);
+            }
+            for (let i = 49; i >= 0; i--) {
+              checkScrollToIndex(i);
+            }
+          });
+
+          function checkScrollToIndex(i: number) {
+            viewport.scrollToIndex(i);
+            viewport.elementRef.nativeElement.dispatchEvent(
+              new Event('scroll'),
+            );
+            animationFrameScheduler.flush();
+            dom.detectChanges();
+            expect(dom.find(`.entry[item-id="${i}"]`)).toBeDefined();
+          }
+        });
+      }
+    });
+
+    if (this.executeSpecializedTests) {
+      this.executeSpecializedTests();
+    }
+  }
+
+  protected async initializeTestEnvironment<U extends T>(
+    initialUiData: UiDataLog,
+    typeofViewer: Type<U>,
+    addedDeclarations: object[] = [],
+  ): Promise<[DOMTestHelper<U>, CdkVirtualScrollViewport, U]> {
+    const declarations: object[] = [
+      typeofViewer,
+      SelectWithFilterComponent,
+      SearchBoxComponent,
+      LogComponent,
+      VariableHeightScrollDirective,
+    ];
+    if (addedDeclarations) {
+      declarations.push(...addedDeclarations);
+    }
+    if (this.testProperties) {
+      declarations.push(
+        ...[
+          CollapsedSectionsComponent,
+          CollapsibleSectionTitleComponent,
+          PropertiesComponent,
+          TreeComponent,
+          TreeNodeComponent,
+          PropertyTreeNodeDataViewComponent,
+        ],
+      );
+    }
+    await TestBed.configureTestingModule({
+      providers: [{provide: ComponentFixtureAutoDetect, useValue: true}],
+      imports: [
+        MatDividerModule,
+        ScrollingModule,
+        MatIconModule,
+        ClipboardModule,
+        MatFormFieldModule,
+        MatButtonModule,
+        MatInputModule,
+        BrowserAnimationsModule,
+        FormsModule,
+        MatSelectModule,
+        MatTooltipModule,
+        HttpClientModule,
+        MatSliderModule,
+      ],
+      declarations,
+    }).compileComponents();
+
+    const fixture = TestBed.createComponent<U>(typeofViewer);
+    const component = fixture.componentInstance;
+    const dom = new DOMTestHelper(fixture, fixture.nativeElement);
+    (component as any).inputData = initialUiData;
+    dom.detectChanges();
+    const viewport = assertDefined(component.logComponent?.scrollComponent);
+    return [dom, viewport, component];
+  }
+
+  protected abstract readonly testProperties: boolean;
+  protected abstract readonly hasCurrentTimeButton: boolean;
+  protected abstract readonly testScroll: boolean;
+  protected readonly hasFilters: boolean = true;
+  protected readonly propertiesSectionTitle?: string;
+  protected readonly propertiesPlaceholder?: string;
+
+  protected abstract setUpTestEnvironment(): Promise<
+    [DOMTestHelper<T>, CdkVirtualScrollViewport, T]
+  >;
+  protected abstract checkTimestampInTable(dom: DOMTestHelper<T>): void;
+  protected setUpTestEnvironmentForScroll?(): Promise<
+    [DOMTestHelper<T>, CdkVirtualScrollViewport]
+  >;
+  protected executeSpecializedTests?(): void;
+}
diff --git a/tools/winscope/src/viewers/common/abstract_log_viewer_presenter.ts b/tools/winscope/src/viewers/common/abstract_log_viewer_presenter.ts
index 203d3699d..5ee324cfe 100644
--- a/tools/winscope/src/viewers/common/abstract_log_viewer_presenter.ts
+++ b/tools/winscope/src/viewers/common/abstract_log_viewer_presenter.ts
@@ -14,7 +14,8 @@
  * limitations under the License.
  */
 
-import {DOMUtils} from 'common/dom_utils';
+import {assertDefined} from 'common/assert_utils';
+import {isElementVisible, KeyboardEventKey} from 'common/dom_utils';
 import {FunctionUtils} from 'common/function_utils';
 import {Timestamp} from 'common/time/time';
 import {Analytics} from 'logging/analytics';
@@ -24,6 +25,7 @@ import {
   WinscopeEventType,
 } from 'messaging/winscope_event';
 import {EmitEvent} from 'messaging/winscope_event_emitter';
+import {CustomQueryType} from 'trace/custom_query';
 import {Trace, TraceEntry} from 'trace/trace';
 import {TraceEntryFinder} from 'trace/trace_entry_finder';
 import {TRACE_INFO} from 'trace/trace_info';
@@ -32,6 +34,7 @@ import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 import {PropertiesPresenter} from 'viewers/common/properties_presenter';
 import {TextFilter} from 'viewers/common/text_filter';
 import {UserOptions} from 'viewers/common/user_options';
+import {LogSelectFilter} from './log_filters';
 import {LogPresenter} from './log_presenter';
 import {LogEntry, LogHeader, UiDataLog} from './ui_data_log';
 import {
@@ -117,9 +120,10 @@ export abstract class AbstractLogViewerPresenter<
     );
 
     document.addEventListener('keydown', async (event: KeyboardEvent) => {
-      const isViewerVisible = DOMUtils.isElementVisible(htmlElement);
+      const isViewerVisible = isElementVisible(htmlElement);
       const isPositionChange =
-        event.key === 'ArrowRight' || event.key === 'ArrowLeft';
+        event.key === KeyboardEventKey.ARROW_RIGHT ||
+        event.key === KeyboardEventKey.ARROW_LEFT;
       if (!isViewerVisible || !isPositionChange) {
         return;
       }
@@ -238,7 +242,7 @@ export abstract class AbstractLogViewerPresenter<
   async onPositionChangeByKeyPress(event: KeyboardEvent) {
     const currIndex = this.uiData.currentIndex;
     if (this.activeTrace === this.trace && currIndex !== undefined) {
-      if (event.key === 'ArrowRight') {
+      if (event.key === KeyboardEventKey.ARROW_RIGHT) {
         event.stopImmediatePropagation();
         if (currIndex < this.uiData.entries.length - 1) {
           const currTimestamp =
@@ -323,7 +327,7 @@ export abstract class AbstractLogViewerPresenter<
       const traceName = TRACE_INFO[this.trace.type].name;
       const propertiesStartTime = Date.now();
 
-      const tree = this.getPropertiesTree();
+      const tree = await this.getPropertiesTree();
       this.propertiesPresenter.setPropertiesTree(tree);
       if (updateDefaultAllowlist && this.updateDefaultAllowlist) {
         this.updateDefaultAllowlist(tree);
@@ -361,19 +365,34 @@ export abstract class AbstractLogViewerPresenter<
     this.uiData.scrollToIndex = this.logPresenter.getScrollToIndex();
   }
 
-  private getPropertiesTree(): PropertyTreeNode | undefined {
+  private async getPropertiesTree(): Promise<PropertyTreeNode | undefined> {
     const entries = this.logPresenter.getFilteredEntries();
     const selectedIndex = this.logPresenter.getSelectedIndex();
     const currentIndex = this.logPresenter.getCurrentIndex();
     if (selectedIndex !== undefined) {
-      return entries.at(selectedIndex)?.propertiesTree;
+      const entry = entries.at(selectedIndex);
+      return entry?.getPropertiesTree
+        ? await entry.getPropertiesTree()
+        : undefined;
     }
     if (currentIndex !== undefined) {
-      return entries.at(currentIndex)?.propertiesTree;
+      const entry = entries.at(currentIndex);
+      return entry?.getPropertiesTree
+        ? await entry.getPropertiesTree()
+        : undefined;
     }
     return undefined;
   }
 
+  protected async updateFilterByCustomQuery(header: LogHeader) {
+    const filterValues = await this.trace.customQuery(
+      CustomQueryType.LOG_TABLE_FILTER_VALUES,
+      assertDefined(header.spec.columnType),
+    );
+    (header.filter as LogSelectFilter).options = filterValues;
+    return;
+  }
+
   protected notifyViewChanged() {
     this.notifyViewCallback(this.uiData);
   }
@@ -383,9 +402,9 @@ export abstract class AbstractLogViewerPresenter<
     headers: LogHeader[],
   ): Promise<LogEntry[]>;
   protected initializeTraceSpecificData?(): Promise<void>;
-  protected updateFiltersInHeaders?(
+  protected async updateFiltersInHeaders?(
     headers: LogHeader[],
     allEntries: LogEntry[],
-  ): void;
+  ): Promise<void>;
   protected updateDefaultAllowlist?(tree: PropertyTreeNode | undefined): void;
 }
diff --git a/tools/winscope/src/viewers/common/abstract_log_viewer_presenter_test.ts b/tools/winscope/src/viewers/common/abstract_log_viewer_presenter_test.ts
index aa80b96aa..8016bb3eb 100644
--- a/tools/winscope/src/viewers/common/abstract_log_viewer_presenter_test.ts
+++ b/tools/winscope/src/viewers/common/abstract_log_viewer_presenter_test.ts
@@ -18,6 +18,8 @@ import {assertDefined} from 'common/assert_utils';
 import {TimestampConverterUtils} from 'common/time/test_utils';
 import {TimeUtils} from 'common/time/time_utils';
 import {TracePositionUpdate} from 'messaging/winscope_event';
+import {setNumRowsSpyQueryResult} from 'trace_processor/test_utils';
+import {TraceProcessor} from 'trace_processor/trace_processor';
 import {
   AbstractLogViewerPresenter,
   NotifyLogViewCallbackType,
@@ -50,6 +52,9 @@ export abstract class AbstractLogViewerPresenterTest<UiData extends UiDataLog> {
         const presenter = await this.createPresenterWithEmptyTrace(
           (newData: UiData) => (uiData = newData),
         );
+        spyOn(TraceProcessor.prototype, 'query').and.returnValue(
+          Promise.resolve(setNumRowsSpyQueryResult(0)),
+        );
         await presenter.onAppEvent(
           TracePositionUpdate.fromTimestamp(
             TimestampConverterUtils.makeRealTimestamp(0n),
diff --git a/tools/winscope/src/viewers/common/abstract_presenter_input_method_test.ts b/tools/winscope/src/viewers/common/abstract_presenter_input_method_test.ts
index 749e29c64..3f38a2b24 100644
--- a/tools/winscope/src/viewers/common/abstract_presenter_input_method_test.ts
+++ b/tools/winscope/src/viewers/common/abstract_presenter_input_method_test.ts
@@ -18,10 +18,11 @@ import {assertDefined} from 'common/assert_utils';
 import {InMemoryStorage} from 'common/store/in_memory_storage';
 import {Store} from 'common/store/store';
 import {TracePositionUpdate} from 'messaging/winscope_event';
+import {getImeTraceEntries} from 'test/unit/fixture_utils';
 import {TraceBuilder} from 'test/unit/trace_builder';
+import {makeEmptyTrace} from 'test/unit/trace_utils';
 import {TreeNodeUtils} from 'test/unit/tree_node_utils';
 import {UserNotifierChecker} from 'test/unit/user_notifier_checker';
-import {UnitTestUtils} from 'test/unit/utils';
 import {Traces} from 'trace/traces';
 import {ImeTraceType, TraceType} from 'trace/trace_type';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
@@ -77,7 +78,7 @@ the default for its data type.`,
 
   override async setUpTestEnvironment(): Promise<void> {
     let secondEntries: Map<TraceType, HierarchyTreeNode>;
-    [this.entries, secondEntries] = await UnitTestUtils.getImeTraceEntries();
+    [this.entries, secondEntries] = await getImeTraceEntries();
     this.traces = new Traces();
     const traceEntries = [assertDefined(this.entries.get(this.imeTraceType))];
     const secondEntry = secondEntries.get(this.imeTraceType);
@@ -126,7 +127,7 @@ the default for its data type.`,
   override createPresenterWithEmptyTrace(
     callback: NotifyHierarchyViewCallbackType<ImeUiData>,
   ): AbstractPresenterInputMethod {
-    const trace = UnitTestUtils.makeEmptyTrace(this.imeTraceType);
+    const trace = makeEmptyTrace(this.imeTraceType);
     const traces = new Traces();
     traces.addTrace(trace);
     return new this.PresenterInputMethod(
@@ -193,8 +194,8 @@ the default for its data type.`,
         Presenter = this.PresenterInputMethod;
         imeTraceType = this.imeTraceType;
         await this.setUpTestEnvironment();
+        traces = new Traces();
         entries = assertDefined(this.entries);
-        await loadTraces();
       });
 
       afterEach(() => {
@@ -333,11 +334,6 @@ the default for its data type.`,
           callback as NotifyHierarchyViewCallbackType<ImeUiData>,
         );
       }
-
-      async function loadTraces() {
-        traces = new Traces();
-        entries = (await UnitTestUtils.getImeTraceEntries())[0];
-      }
     });
   }
 
diff --git a/tools/winscope/src/viewers/common/hierarchy_presenter.ts b/tools/winscope/src/viewers/common/hierarchy_presenter.ts
index 7cef969aa..5c827a703 100644
--- a/tools/winscope/src/viewers/common/hierarchy_presenter.ts
+++ b/tools/winscope/src/viewers/common/hierarchy_presenter.ts
@@ -403,9 +403,6 @@ export class HierarchyPresenter {
   ): Promise<UiHierarchyTreeNode> {
     const uiTree = UiHierarchyTreeNode.from(hierarchyTree);
 
-    if (!this.showHeadings) {
-      uiTree.forEachNodeDfs((node) => node.setShowHeading(false));
-    }
     if (hierarchyTreeIndex !== undefined) {
       const displayName =
         this.getCurrentHierarchyTreeNames(trace)?.at(hierarchyTreeIndex);
@@ -442,6 +439,10 @@ export class HierarchyPresenter {
       );
     }
 
+    if (!this.showHeadings) {
+      uiTree.forEachNodeDfs((node) => node.setShowHeading(false));
+    }
+
     if (this.userOptions['flat']?.enabled) {
       formatter.addOperation(new FlattenChildren());
     }
diff --git a/tools/winscope/src/viewers/common/hierarchy_viewer_presenter_test.ts b/tools/winscope/src/viewers/common/hierarchy_viewer_presenter_test.ts
index dad5d058c..612ae9abc 100644
--- a/tools/winscope/src/viewers/common/hierarchy_viewer_presenter_test.ts
+++ b/tools/winscope/src/viewers/common/hierarchy_viewer_presenter_test.ts
@@ -27,8 +27,8 @@ import {
 import {HierarchyTreeBuilder} from 'test/unit/hierarchy_tree_builder';
 import {MockPresenter} from 'test/unit/mock_hierarchy_viewer_presenter';
 import {TraceBuilder} from 'test/unit/trace_builder';
+import {makeEmptyTrace} from 'test/unit/trace_utils';
 import {TreeNodeUtils} from 'test/unit/tree_node_utils';
-import {UnitTestUtils} from 'test/unit/utils';
 import {Trace} from 'trace/trace';
 import {Traces} from 'trace/traces';
 import {TraceType} from 'trace/trace_type';
@@ -275,7 +275,7 @@ describe('AbstractHierarchyViewerPresenter', () => {
     const callback = (newData: UiDataHierarchy) => {
       uiData = newData;
     };
-    const trace = UnitTestUtils.makeEmptyTrace(TraceType.WINDOW_MANAGER);
+    const trace = makeEmptyTrace(TraceType.WINDOW_MANAGER);
     const traces = new Traces();
     traces.addTrace(trace);
     const presenter = new MockPresenter(
diff --git a/tools/winscope/src/viewers/common/ime_utils.ts b/tools/winscope/src/viewers/common/ime_utils.ts
index ccbbad848..8acabc8e3 100644
--- a/tools/winscope/src/viewers/common/ime_utils.ts
+++ b/tools/winscope/src/viewers/common/ime_utils.ts
@@ -19,7 +19,7 @@ import {Timestamp} from 'common/time/time';
 import {Item} from 'trace/item';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
-import {WindowType} from 'trace/window_type';
+import {WindowType} from 'trace/window_manager/window_type';
 import {TextFilter} from 'viewers/common/text_filter';
 import {WmImeUtils} from 'viewers/common/wm_ime_utils';
 import {TreeNodeFilter, UiTreeUtils} from './ui_tree_utils';
diff --git a/tools/winscope/src/viewers/common/ime_utils_test.ts b/tools/winscope/src/viewers/common/ime_utils_test.ts
index 03bb62fc4..4a36a1c9d 100644
--- a/tools/winscope/src/viewers/common/ime_utils_test.ts
+++ b/tools/winscope/src/viewers/common/ime_utils_test.ts
@@ -14,16 +14,19 @@
  * limitations under the License.
  */
 import {assertDefined} from 'common/assert_utils';
+import {getImeTraceEntries} from 'test/unit/fixture_utils';
 import {UserNotifierChecker} from 'test/unit/user_notifier_checker';
-import {UnitTestUtils} from 'test/unit/utils';
 import {TraceType} from 'trace/trace_type';
+import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 import {ImeUtils} from './ime_utils';
 
 describe('ImeUtils', () => {
   let userNotifierChecker: UserNotifierChecker;
+  let entries: Map<TraceType, HierarchyTreeNode>;
 
-  beforeAll(() => {
+  beforeAll(async () => {
     userNotifierChecker = new UserNotifierChecker();
+    entries = (await getImeTraceEntries())[0];
   });
 
   afterEach(() => {
@@ -32,7 +35,6 @@ describe('ImeUtils', () => {
   });
 
   it('processes WindowManager trace entry', async () => {
-    const entries = (await UnitTestUtils.getImeTraceEntries())[0];
     const processed = ImeUtils.processWindowManagerTraceEntry(
       assertDefined(entries.get(TraceType.WINDOW_MANAGER)),
       undefined,
@@ -98,7 +100,7 @@ describe('ImeUtils', () => {
   });
 
   it('processes SurfaceFlinger trace entry', async () => {
-    const entries = (await UnitTestUtils.getImeTraceEntries())[0];
+    const entries = (await getImeTraceEntries())[0];
     const processedWindowManagerState = ImeUtils.processWindowManagerTraceEntry(
       assertDefined(entries.get(TraceType.WINDOW_MANAGER)),
       undefined,
diff --git a/tools/winscope/src/viewers/common/item_height_predictor.ts b/tools/winscope/src/viewers/common/item_height_predictor.ts
new file mode 100644
index 000000000..33c4bdf1b
--- /dev/null
+++ b/tools/winscope/src/viewers/common/item_height_predictor.ts
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+export abstract class ItemHeightPredictor {
+  protected abstract readonly defaultRowSize: number;
+
+  protected subItemHeight(subItem: string, rowLength: number): number {
+    return Math.ceil(subItem.length / rowLength) * this.defaultRowSize;
+  }
+
+  abstract predictHeight(entry: object): number;
+}
diff --git a/tools/winscope/src/viewers/common/log_presenter.ts b/tools/winscope/src/viewers/common/log_presenter.ts
index 573ed0d02..385a92ac7 100644
--- a/tools/winscope/src/viewers/common/log_presenter.ts
+++ b/tools/winscope/src/viewers/common/log_presenter.ts
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-import {ArrayUtils} from 'common/array_utils';
+import {binarySearchFirstGreaterOrEqual} from 'common/array_utils';
 import {assertDefined} from 'common/assert_utils';
 import {TraceEntry} from 'trace/trace';
 import {StringFilterPredicate} from 'viewers/common/string_filter_predicate';
@@ -200,7 +200,7 @@ export class LogPresenter<Entry extends LogEntry> {
 
     if (this.timeOrderedEntries) {
       return (
-        ArrayUtils.binarySearchFirstGreaterOrEqual(
+        binarySearchFirstGreaterOrEqual(
           this.originalIndicesOfAllEntries,
           this.currentEntry.getIndex(),
         ) ?? this.originalIndicesOfAllEntries.length - 1
diff --git a/tools/winscope/src/viewers/common/log_presenter_test.ts b/tools/winscope/src/viewers/common/log_presenter_test.ts
index 2c0d6dac0..c6ea89901 100644
--- a/tools/winscope/src/viewers/common/log_presenter_test.ts
+++ b/tools/winscope/src/viewers/common/log_presenter_test.ts
@@ -285,7 +285,7 @@ describe('LogPresenter', () => {
             value: timestamp1,
           },
         ],
-        propertiesTree: await trace.getEntry(0).getValue(),
+        getPropertiesTree: async () => await trace.getEntry(0).getValue(),
       },
       {
         traceEntry: trace.getEntry(1),
@@ -303,7 +303,7 @@ describe('LogPresenter', () => {
             value: timestamp2,
           },
         ],
-        propertiesTree: await trace.getEntry(1).getValue(),
+        getPropertiesTree: async () => await trace.getEntry(1).getValue(),
       },
       {
         traceEntry: trace.getEntry(2),
@@ -321,7 +321,7 @@ describe('LogPresenter', () => {
             value: timestamp3,
           },
         ],
-        propertiesTree: await trace.getEntry(2).getValue(),
+        getPropertiesTree: async () => await trace.getEntry(2).getValue(),
       },
       {
         traceEntry: trace.getEntry(3),
@@ -339,7 +339,7 @@ describe('LogPresenter', () => {
             value: timestamp4,
           },
         ],
-        propertiesTree: await trace.getEntry(3).getValue(),
+        getPropertiesTree: async () => await trace.getEntry(3).getValue(),
       },
     ];
   }
diff --git a/tools/winscope/src/viewers/common/log_viewer_presenter_test.ts b/tools/winscope/src/viewers/common/log_viewer_presenter_test.ts
index 6b9f3aa0c..9f9c5468a 100644
--- a/tools/winscope/src/viewers/common/log_viewer_presenter_test.ts
+++ b/tools/winscope/src/viewers/common/log_viewer_presenter_test.ts
@@ -26,7 +26,7 @@ import {
 import {MockPresenter} from 'test/unit/mock_log_viewer_presenter';
 import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
 import {TraceBuilder} from 'test/unit/trace_builder';
-import {UnitTestUtils} from 'test/unit/utils';
+import {makeEmptyTrace} from 'test/unit/trace_utils';
 import {Trace} from 'trace/trace';
 import {TracePosition} from 'trace/trace_position';
 import {TraceType} from 'trace/trace_type';
@@ -228,7 +228,7 @@ describe('AbstractLogViewerPresenter', () => {
     expect(uiData.selectedIndex).toBeUndefined();
     expect(uiData.entries.length).toEqual(4);
     expect(assertDefined(uiData.propertiesTree).id).toEqual(
-      assertDefined(uiData.entries[0].propertiesTree).id,
+      (await getPropertiesTree(0)).id,
     );
     expect(uiData.headers.length).toEqual(3);
     expect((uiData.headers[0].filter as LogSelectFilter).options).toEqual([
@@ -241,7 +241,7 @@ describe('AbstractLogViewerPresenter', () => {
     await sendPositionUpdate(secondPositionUpdate, true);
     expect(uiData.currentIndex).toEqual(1);
     expect(assertDefined(uiData.propertiesTree).id).toEqual(
-      assertDefined(uiData.entries[1].propertiesTree).id,
+      (await getPropertiesTree(1)).id,
     );
   });
 
@@ -278,9 +278,7 @@ describe('AbstractLogViewerPresenter', () => {
     expect(listenerSpy).toHaveBeenCalledTimes(2);
 
     await presenter.onAppEvent(
-      new ActiveTraceChanged(
-        UnitTestUtils.makeEmptyTrace(TraceType.TRANSACTIONS),
-      ),
+      new ActiveTraceChanged(makeEmptyTrace(TraceType.TRANSACTIONS)),
     );
     pressRightArrowKey();
     expect(listenerSpy).toHaveBeenCalledTimes(3);
@@ -437,16 +435,14 @@ describe('AbstractLogViewerPresenter', () => {
   it('updates properties tree when entry clicked', async () => {
     await sendPositionUpdate(positionUpdate, true);
 
+    const expectedId = (await getPropertiesTree(2)).id;
+
     await presenter.onLogEntryClick(2);
-    expect(assertDefined(uiData.propertiesTree).id).toEqual(
-      assertDefined(uiData.entries[2].propertiesTree).id,
-    );
+    expect(assertDefined(uiData.propertiesTree).id).toEqual(expectedId);
 
     // does not remove selection when entry clicked again
     await presenter.onLogEntryClick(2);
-    expect(assertDefined(uiData.propertiesTree).id).toEqual(
-      assertDefined(uiData.entries[2].propertiesTree).id,
-    );
+    expect(assertDefined(uiData.propertiesTree).id).toEqual(expectedId);
   });
 
   it('updates properties tree when changed by key press', async () => {
@@ -456,28 +452,26 @@ describe('AbstractLogViewerPresenter', () => {
     await presenter.onArrowDownPress();
     expect(uiData.selectedIndex).toEqual(1);
     expect(assertDefined(uiData.propertiesTree).id).toEqual(
-      assertDefined(uiData.entries[1].propertiesTree).id,
+      (await getPropertiesTree(1)).id,
     );
 
+    const expectedId0 = (await getPropertiesTree(0)).id;
+
     await presenter.onArrowUpPress();
     expect(uiData.selectedIndex).toEqual(0);
-    expect(assertDefined(uiData.propertiesTree).id).toEqual(
-      assertDefined(uiData.entries[0].propertiesTree).id,
-    );
+    expect(assertDefined(uiData.propertiesTree).id).toEqual(expectedId0);
 
     // does not remove selection if index out of range
     await presenter.onArrowUpPress();
     expect(uiData.selectedIndex).toEqual(0);
-    expect(assertDefined(uiData.propertiesTree).id).toEqual(
-      assertDefined(uiData.entries[0].propertiesTree).id,
-    );
+    expect(assertDefined(uiData.propertiesTree).id).toEqual(expectedId0);
 
     // does not remove selection if index out of range
     await presenter.onLogEntryClick(3);
     await presenter.onArrowDownPress();
     expect(uiData.selectedIndex).toEqual(3);
     expect(assertDefined(uiData.propertiesTree).id).toEqual(
-      assertDefined(uiData.entries[3].propertiesTree).id,
+      (await getPropertiesTree(3)).id,
     );
   });
 
@@ -540,7 +534,7 @@ describe('AbstractLogViewerPresenter', () => {
   });
 
   it('is robust to empty trace', async () => {
-    const trace = UnitTestUtils.makeEmptyTrace(TraceType.TRANSACTIONS);
+    const trace = makeEmptyTrace(TraceType.CUJS);
     const presenter = new MockPresenter(
       trace,
       new InMemoryStorage(),
@@ -588,4 +582,8 @@ describe('AbstractLogViewerPresenter', () => {
     }
     expect(uiData.isFetchingData).toBeFalse();
   }
+
+  async function getPropertiesTree(index: number) {
+    return await assertDefined(uiData.entries[index].getPropertiesTree)();
+  }
 });
diff --git a/tools/winscope/src/viewers/common/operations/add_chips.ts b/tools/winscope/src/viewers/common/operations/add_chips.ts
index 0e5a737b9..75741d49d 100644
--- a/tools/winscope/src/viewers/common/operations/add_chips.ts
+++ b/tools/winscope/src/viewers/common/operations/add_chips.ts
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-import {LayerCompositionType} from 'trace/layer_composition_type';
+import {LayerCompositionType} from 'trace/surface_flinger/layer_composition_type';
 import {Operation} from 'trace/tree_node/operations/operation';
 import {
   DUPLICATE_CHIP,
diff --git a/tools/winscope/src/viewers/common/operations/add_chips_test.ts b/tools/winscope/src/viewers/common/operations/add_chips_test.ts
index 69f0f8784..6e0b36d6b 100644
--- a/tools/winscope/src/viewers/common/operations/add_chips_test.ts
+++ b/tools/winscope/src/viewers/common/operations/add_chips_test.ts
@@ -16,7 +16,7 @@
 
 import {assertDefined} from 'common/assert_utils';
 import {HierarchyTreeBuilder} from 'test/unit/hierarchy_tree_builder';
-import {LayerCompositionType} from 'trace/layer_composition_type';
+import {LayerCompositionType} from 'trace/surface_flinger/layer_composition_type';
 import {
   DUPLICATE_CHIP,
   GPU_CHIP,
diff --git a/tools/winscope/src/viewers/common/properties_presenter.ts b/tools/winscope/src/viewers/common/properties_presenter.ts
index 6df2f62eb..baa41cdab 100644
--- a/tools/winscope/src/viewers/common/properties_presenter.ts
+++ b/tools/winscope/src/viewers/common/properties_presenter.ts
@@ -135,7 +135,7 @@ export class PropertiesPresenter {
     }
 
     const predicatesKeepingChildren = [this.propertiesFilter];
-    const predicatesDiscardingChildren = [];
+    const predicatesDiscardingChildren = [UiTreeUtils.isNotFromTP];
 
     if (this.propertiesDenylist) {
       predicatesDiscardingChildren.push(
diff --git a/tools/winscope/src/viewers/common/scroll_component_tests.ts b/tools/winscope/src/viewers/common/scroll_component_tests.ts
deleted file mode 100644
index 914b5806d..000000000
--- a/tools/winscope/src/viewers/common/scroll_component_tests.ts
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import {CdkVirtualScrollViewport} from '@angular/cdk/scrolling';
-import {ComponentFixture} from '@angular/core/testing';
-import {assertDefined} from 'common/assert_utils';
-import {animationFrameScheduler} from 'rxjs';
-import {ViewerProtologComponent} from 'viewers/viewer_protolog/viewer_protolog_component';
-import {ViewerTransactionsComponent} from 'viewers/viewer_transactions/viewer_transactions_component';
-import {ViewerTransitionsComponent} from 'viewers/viewer_transitions/viewer_transitions_component';
-
-type ScrollComponent =
-  | ViewerProtologComponent
-  | ViewerTransactionsComponent
-  | ViewerTransitionsComponent;
-
-export function executeScrollComponentTests(
-  setUpTestEnvironment: () => Promise<
-    [ComponentFixture<ScrollComponent>, HTMLElement, CdkVirtualScrollViewport]
-  >,
-) {
-  describe('common tests', () => {
-    let fixture: ComponentFixture<ScrollComponent>;
-    let htmlElement: HTMLElement;
-    let viewport: CdkVirtualScrollViewport;
-
-    beforeEach(async () => {
-      [fixture, htmlElement, viewport] = await setUpTestEnvironment();
-    });
-
-    it('renders initial state', () => {
-      const items = htmlElement.querySelectorAll('.entry');
-      expect(items.length).toBe(20);
-    });
-
-    it('gets data length', () => {
-      expect(viewport.getDataLength()).toBe(200);
-    });
-
-    it('should get the rendered range', () => {
-      expect(viewport.getRenderedRange()).toEqual({start: 0, end: 20});
-    });
-
-    it('should scroll to index in large jumps', () => {
-      expect(htmlElement.querySelector(`.entry[item-id="30"]`)).toBeFalsy();
-      checkScrollToIndex(30);
-      expect(htmlElement.querySelector(`.entry[item-id="70"]`)).toBeFalsy();
-      checkScrollToIndex(70);
-    });
-
-    it('should update without jumps as the user scrolls down or up', () => {
-      for (let i = 1; i < 50; i++) {
-        checkScrollToIndex(i);
-      }
-      for (let i = 49; i >= 0; i--) {
-        checkScrollToIndex(i);
-      }
-    });
-
-    function checkScrollToIndex(i: number) {
-      viewport.scrollToIndex(i);
-      viewport.elementRef.nativeElement.dispatchEvent(new Event('scroll'));
-      animationFrameScheduler.flush();
-      fixture.detectChanges();
-      assertDefined(htmlElement.querySelector(`.entry[item-id="${i}"]`));
-    }
-  });
-}
diff --git a/tools/winscope/src/viewers/common/text_filter.ts b/tools/winscope/src/viewers/common/text_filter.ts
index d4dece84d..611ca68af 100644
--- a/tools/winscope/src/viewers/common/text_filter.ts
+++ b/tools/winscope/src/viewers/common/text_filter.ts
@@ -15,7 +15,7 @@
  */
 
 import {FilterFlag} from 'common/filter_flag';
-import {StringUtils} from 'common/string_utils';
+import {isAlpha, isDigit} from 'common/string_utils';
 import {StringFilterPredicate} from 'viewers/common/string_filter_predicate';
 
 export class TextFilter {
@@ -63,7 +63,7 @@ export class TextFilter {
           );
           if (
             nextChar === undefined ||
-            !(StringUtils.isAlpha(nextChar) || StringUtils.isDigit(nextChar))
+            !(isAlpha(nextChar) || isDigit(nextChar))
           ) {
             return true;
           }
diff --git a/tools/winscope/src/viewers/common/ui_data_log.ts b/tools/winscope/src/viewers/common/ui_data_log.ts
index a41841e68..61df6d74e 100644
--- a/tools/winscope/src/viewers/common/ui_data_log.ts
+++ b/tools/winscope/src/viewers/common/ui_data_log.ts
@@ -16,7 +16,7 @@
 
 import {Timestamp} from 'common/time/time';
 import {TraceEntry} from 'trace/trace';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
+import {LazyPropertiesStrategyType} from 'trace/tree_node/properties_provider';
 import {TextFilter} from 'viewers/common/text_filter';
 import {UserOptions} from 'viewers/common/user_options';
 import {LogFilter} from './log_filters';
@@ -39,6 +39,8 @@ export interface UiDataLog {
 export interface ColumnSpec {
   name: string;
   cssClass: string;
+  columnType?: number;
+  canCopy?: boolean;
 }
 
 export class LogHeader {
@@ -48,7 +50,7 @@ export class LogHeader {
 export interface LogEntry {
   traceEntry: TraceEntry<object>;
   fields: LogField[];
-  propertiesTree?: undefined | PropertyTreeNode;
+  getPropertiesTree: LazyPropertiesStrategyType | undefined;
 }
 
 export interface LogField {
diff --git a/tools/winscope/src/viewers/common/ui_hierarchy_tree_node.ts b/tools/winscope/src/viewers/common/ui_hierarchy_tree_node.ts
index a6c1c322a..3b0ec208c 100644
--- a/tools/winscope/src/viewers/common/ui_hierarchy_tree_node.ts
+++ b/tools/winscope/src/viewers/common/ui_hierarchy_tree_node.ts
@@ -40,6 +40,9 @@ export class UiHierarchyTreeNode extends HierarchyTreeNode implements DiffNode {
     const rects = node.getRects();
     if (rects) displayNode.setRects(rects);
 
+    const secondaryRects = node.getSecondaryRects();
+    if (secondaryRects) displayNode.setSecondaryRects(secondaryRects);
+
     if (parent) displayNode.setParent(parent);
 
     const zParent = node.getZParent();
diff --git a/tools/winscope/src/viewers/common/ui_hierarchy_tree_node_test.ts b/tools/winscope/src/viewers/common/ui_hierarchy_tree_node_test.ts
new file mode 100644
index 000000000..1f3421bc8
--- /dev/null
+++ b/tools/winscope/src/viewers/common/ui_hierarchy_tree_node_test.ts
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import {DuplicateLayerIds} from 'messaging/user_warnings';
+import {TreeNodeUtils} from 'test/unit/tree_node_utils';
+import {TraceRectBuilder} from 'trace/trace_rect_builder';
+import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
+import {UiHierarchyTreeNode} from './ui_hierarchy_tree_node';
+
+describe('UiHierarchyTreeNode', () => {
+  let node: HierarchyTreeNode;
+
+  beforeEach(() => {
+    node = TreeNodeUtils.makeHierarchyNode(
+      {id: '1', name: 'node1', prop: true},
+      [{id: '2', name: 'node2'}],
+    );
+  });
+
+  it('transfers id, name and properties', () => {
+    const uiNode = UiHierarchyTreeNode.from(node);
+    expect(uiNode.id).toEqual(node.id);
+    expect(uiNode.name).toEqual(node.name);
+    expect(uiNode.getEagerPropertyByName('prop')?.getValue()).toEqual(true);
+  });
+
+  it('transfers rects', () => {
+    const nodeNoRects = UiHierarchyTreeNode.from(node);
+    expect(nodeNoRects.getRects()).toEqual(undefined);
+    const rects = [
+      new TraceRectBuilder()
+        .setX(0)
+        .setY(0)
+        .setWidth(5)
+        .setHeight(10)
+        .setId('1')
+        .setName('rect1')
+        .setCornerRadius(0)
+        .setDepth(1)
+        .setGroupId(0)
+        .setIsVisible(false)
+        .setIsDisplay(true)
+        .setIsSpy(false)
+        .build(),
+    ];
+    node.setRects(rects);
+    const nodeWithRects = UiHierarchyTreeNode.from(node);
+    expect(nodeWithRects.getRects()).toEqual(rects);
+  });
+
+  it('transfers parent-child relationships', () => {
+    const uiNode = UiHierarchyTreeNode.from(node);
+    expect(uiNode.getParent()).toBeUndefined();
+    const childUiNode = uiNode.getChildByName('node2');
+    expect(childUiNode).toBeInstanceOf(UiHierarchyTreeNode);
+    expect(childUiNode?.getParent()).toEqual(uiNode);
+  });
+
+  it('transfers warnings', () => {
+    expect(UiHierarchyTreeNode.from(node).getWarnings()).toEqual([]);
+    const warning = new DuplicateLayerIds([]);
+    node.addWarning(warning);
+    expect(UiHierarchyTreeNode.from(node).getWarnings()).toEqual([warning]);
+  });
+
+  it('formats id as heading', () => {
+    const uiNode = UiHierarchyTreeNode.from(node);
+    expect(uiNode.heading()).toEqual('1');
+    uiNode.setShowHeading(false);
+    expect(uiNode.heading()).toBeUndefined();
+  });
+});
diff --git a/tools/winscope/src/viewers/common/ui_rect_factory.ts b/tools/winscope/src/viewers/common/ui_rect_factory.ts
index 8c24820c3..1336712ee 100644
--- a/tools/winscope/src/viewers/common/ui_rect_factory.ts
+++ b/tools/winscope/src/viewers/common/ui_rect_factory.ts
@@ -15,10 +15,13 @@
  */
 
 import {assertDefined} from 'common/assert_utils';
+import {Point} from 'common/geometry/point';
 import {TraceRect} from 'trace/trace_rect';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
+import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 import {UiRect} from 'viewers/components/rects/ui_rect';
 import {UiRectBuilder} from 'viewers/components/rects/ui_rect_builder';
+import {DispatchedPointerAxis} from 'viewers/viewer_input/operations/dispatched_pointer_axis';
 
 class UiRectFactory {
   makeUiRects(
@@ -81,6 +84,7 @@ class UiRectFactory {
   makeInputRects(
     hierarchyRoot: HierarchyTreeNode,
     hasContent: (id: string) => boolean,
+    dispatchProperties?: PropertyTreeNode,
   ): UiRect[] {
     const traceRects = this.extractRects(hierarchyRoot, (node) =>
       // The root node contains the display rects, so use the primary rects for the displays.
@@ -88,7 +92,13 @@ class UiRectFactory {
       node.isRoot() ? node.getRects() : node.getSecondaryRects(),
     );
     return traceRects.map((traceRect) => {
+      const {pointers, rays} = this.extractPointersAndRays(
+        traceRect,
+        dispatchProperties,
+      );
+
       const opacity = traceRect.isDisplay ? 1 : traceRect.isSpy ? 0.25 : 0.9;
+
       return new UiRectBuilder()
         .setX(traceRect.x)
         .setY(traceRect.y)
@@ -107,6 +117,8 @@ class UiRectFactory {
         .setDepth(traceRect.depth)
         .setOpacity(opacity)
         .setFillRegion(traceRect.fillRegion)
+        .setPointerLocationsInRect(pointers)
+        .setRayLocationsInDisplay(rays)
         .build();
     });
   }
@@ -126,6 +138,52 @@ class UiRectFactory {
 
     return rects;
   }
+
+  private extractPointersAndRays(
+    traceRect: TraceRect,
+    dispatchProperties: PropertyTreeNode | undefined,
+  ): {pointers: Point[]; rays: Point[]} {
+    const pointers: Point[] = [];
+    const rays: Point[] = [];
+    if (!traceRect.isDisplay && dispatchProperties) {
+      const targetWindow = dispatchProperties?.getAllChildren().find((c) => {
+        const id = c.getChildByName('windowId');
+        return (
+          id !== undefined &&
+          traceRect.id.split(' ')[0] === id.getValue().toString()
+        );
+      });
+
+      targetWindow
+        ?.getChildByName('dispatchedPointer')
+        ?.getAllChildren()
+        .forEach((pointer) => {
+          const rawX = pointer.getChildByName('xInDisplay')?.getValue();
+          const rawY = pointer.getChildByName('yInDisplay')?.getValue();
+          if (rawX !== undefined && rawY !== undefined) {
+            rays.push({x: rawX, y: rawY});
+          }
+
+          const axes = pointer
+            .getChildByName('axisValueInWindow')
+            ?.getAllChildren();
+          let pointerX: number | undefined;
+          let pointerY: number | undefined;
+          axes?.forEach((axisValue) => {
+            const axis = Number(axisValue.getChildByName('axis')?.getValue());
+            if (axis === DispatchedPointerAxis.X) {
+              pointerX = axisValue.getChildByName('value')?.getValue();
+            } else if (axis === DispatchedPointerAxis.Y) {
+              pointerY = axisValue.getChildByName('value')?.getValue();
+            }
+          });
+          if (pointerX !== undefined && pointerY !== undefined) {
+            pointers.push({x: pointerX, y: pointerY});
+          }
+        });
+    }
+    return {pointers, rays};
+  }
 }
 
 export const UI_RECT_FACTORY = new UiRectFactory();
diff --git a/tools/winscope/src/viewers/common/ui_rect_factory_test.ts b/tools/winscope/src/viewers/common/ui_rect_factory_test.ts
index a3d904964..1ffb00e6d 100644
--- a/tools/winscope/src/viewers/common/ui_rect_factory_test.ts
+++ b/tools/winscope/src/viewers/common/ui_rect_factory_test.ts
@@ -15,8 +15,9 @@
  */
 
 import {assertDefined} from 'common/assert_utils';
-import {Transform} from 'parsers/surface_flinger/transform_utils';
 import {HierarchyTreeBuilder} from 'test/unit/hierarchy_tree_builder';
+import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
+import {Transform} from 'trace/surface_flinger/transform_utils';
 import {TraceRectBuilder} from 'trace/trace_rect_builder';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 import {UiRect} from 'viewers/components/rects/ui_rect';
@@ -228,10 +229,6 @@ describe('UI_RECT_FACTORY', () => {
     buildRectAndSetToNode(node1, 1, 1, 1, false, false, true);
     buildRectAndSetToNode(node2, 2, 1, 1, false, false, false);
 
-    function hasContent(id: string) {
-      return id === node1.id;
-    }
-
     const expectedRootRect = new UiRectBuilder()
       .setX(0)
       .setY(0)
@@ -299,6 +296,208 @@ describe('UI_RECT_FACTORY', () => {
     );
   });
 
+  it('adds pointer and ray locations for input rects', () => {
+    const root = new HierarchyTreeBuilder()
+      .setId('TreeEntry')
+      .setName('root')
+      .setChildren([
+        {id: 11, name: 'node11'},
+        {id: 3, name: 'node3'},
+      ])
+      .build();
+    const node11 = assertDefined(root.getChildByName('node11'));
+    const node3 = assertDefined(root.getChildByName('node3'));
+    buildRectAndSetToNode(node11, 1, 1, 1, false, false, false);
+    buildRectAndSetToNode(node3, 1, 1, 1, false, false, false);
+
+    const dispatchedPointer1 = {
+      name: 'dispatchedPointer',
+      children: [
+        {
+          name: 'pointer0',
+          children: [
+            {name: 'xInDisplay', value: 100},
+            {name: 'yInDisplay', value: 100},
+          ],
+        },
+      ],
+    };
+
+    const dispatchedPointer2 = {
+      name: 'dispatchedPointer',
+      children: [
+        {
+          name: 'pointer0',
+          children: [
+            {name: 'xInDisplay', value: 5.25},
+            {name: 'yInDisplay', value: 10.5},
+            {
+              name: 'axisValueInWindow',
+              children: [
+                {name: 'axis2', children: [{name: 'axis', value: 1n}]},
+              ],
+            },
+          ],
+        },
+        {name: 'pointer1', children: [{name: 'xInDisplay', value: 5.25}]},
+        {name: 'pointer2', children: [{name: 'yInDisplay', value: 10.5}]},
+        {
+          name: 'pointer3',
+          children: [
+            {name: 'xInDisplay', value: 20},
+            {name: 'yInDisplay', value: 40},
+            {
+              name: 'axisValueInWindow',
+              children: [{name: 'axis1', children: [{name: 'axis', value: 0}]}],
+            },
+          ],
+        },
+      ],
+    };
+
+    const dispatchedPointer3 = {
+      name: 'dispatchedPointer',
+      children: [
+        {
+          name: 'pointer0',
+          children: [
+            {name: 'xInDisplay', value: 15},
+            {name: 'yInDisplay', value: 15},
+            {
+              name: 'axisValueInWindow',
+              children: [
+                {
+                  name: 'axis1',
+                  children: [
+                    {name: 'axis', value: 0},
+                    {name: 'value', value: 123},
+                  ],
+                },
+                {
+                  name: 'axis2',
+                  children: [
+                    {name: 'axis', value: 1n},
+                    {name: 'value', value: 321.321},
+                  ],
+                },
+              ],
+            },
+          ],
+        },
+        {
+          name: 'pointer1',
+          children: [
+            {
+              name: 'axisValueInWindow',
+              children: [
+                {
+                  name: 'axis2',
+                  children: [
+                    {name: 'axis', value: 1},
+                    {name: 'value', value: 123.123},
+                  ],
+                },
+                {
+                  name: 'axis1',
+                  children: [
+                    {name: 'axis', value: 0n},
+                    {name: 'value', value: 321},
+                  ],
+                },
+              ],
+            },
+          ],
+        },
+      ],
+    };
+
+    const dispatchProperties = new PropertyTreeBuilder()
+      .setRootId('')
+      .setName('')
+      .setChildren([
+        {
+          name: 'window1',
+          children: [
+            {name: 'windowId', value: 1}, // ignored as node1 name does not end in 1
+            dispatchedPointer1,
+          ],
+        },
+        {
+          name: 'window11',
+          children: [{name: 'windowId', value: 11}, dispatchedPointer2],
+        },
+        {
+          name: 'window2',
+          children: [
+            {name: 'windowId', value: 2}, // ignored as hierarchyRoot does not contain node2
+            dispatchedPointer1,
+          ],
+        },
+        {
+          name: 'window3',
+          children: [{name: 'windowId', value: 3n}, dispatchedPointer3],
+        },
+      ])
+      .build();
+
+    const expectedInputRect1 = new UiRectBuilder()
+      .setX(0)
+      .setY(0)
+      .setWidth(1)
+      .setHeight(1)
+      .setId('11 node11')
+      .setLabel('node11')
+      .setCornerRadius(0)
+      .setGroupId(0)
+      .setTransform(Transform.EMPTY.matrix)
+      .setIsVisible(true)
+      .setIsDisplay(false)
+      .setIsActiveDisplay(false)
+      .setIsClickable(true)
+      .setHasContent(false)
+      .setDepth(1)
+      .setOpacity(0.9)
+      .setPointerLocationsInRect([])
+      .setRayLocationsInDisplay([
+        {x: 5.25, y: 10.5},
+        {x: 20, y: 40},
+      ])
+      .build();
+
+    const expectedInputRect2 = new UiRectBuilder()
+      .setX(0)
+      .setY(0)
+      .setWidth(1)
+      .setHeight(1)
+      .setId('3 node3')
+      .setLabel('node3')
+      .setCornerRadius(0)
+      .setGroupId(0)
+      .setTransform(Transform.EMPTY.matrix)
+      .setIsVisible(true)
+      .setIsDisplay(false)
+      .setIsActiveDisplay(false)
+      .setIsClickable(true)
+      .setHasContent(false)
+      .setDepth(1)
+      .setOpacity(0.9)
+      .setPointerLocationsInRect([
+        {x: 123, y: 321.321},
+        {x: 321, y: 123.123},
+      ])
+      .setRayLocationsInDisplay([{x: 15, y: 15}])
+      .build();
+
+    const expectedRects: UiRect[] = [expectedInputRect1, expectedInputRect2];
+    expect(
+      UI_RECT_FACTORY.makeInputRects(root, hasContent, dispatchProperties),
+    ).toEqual(expectedRects);
+  });
+
+  function hasContent(id: string) {
+    return id === node1.id;
+  }
+
   function buildRectAndSetToNode(
     node: HierarchyTreeNode,
     depth: number,
diff --git a/tools/winscope/src/viewers/common/ui_tree_utils.ts b/tools/winscope/src/viewers/common/ui_tree_utils.ts
index 46208adcf..7662fdd5e 100644
--- a/tools/winscope/src/viewers/common/ui_tree_utils.ts
+++ b/tools/winscope/src/viewers/common/ui_tree_utils.ts
@@ -55,6 +55,12 @@ export class UiTreeUtils {
     );
   };
 
+  static isNotFromTP: TreeNodeFilter = (node: TreeNode) => {
+    return (
+      node instanceof UiPropertyTreeNode && node.source !== PropertySource.TP
+    );
+  };
+
   static makeNodeFilter(predicate: StringFilterPredicate): TreeNodeFilter {
     return (node: TreeNode) => {
       return (
diff --git a/tools/winscope/src/viewers/common/variable_height_scroll_directive.ts b/tools/winscope/src/viewers/common/variable_height_scroll_directive.ts
index 1cf1e3902..2c7a7f506 100644
--- a/tools/winscope/src/viewers/common/variable_height_scroll_directive.ts
+++ b/tools/winscope/src/viewers/common/variable_height_scroll_directive.ts
@@ -14,16 +14,32 @@
  * limitations under the License.
  */
 
-import {Input} from '@angular/core';
+import {VIRTUAL_SCROLL_STRATEGY} from '@angular/cdk/scrolling';
+import {Directive, forwardRef, Input} from '@angular/core';
+import {TraceType} from 'trace/trace_type';
 import {VariableHeightScrollStrategy} from './variable_height_scroll_strategy';
 
-export abstract class VariableHeightScrollDirective<T extends object> {
-  abstract scrollStrategy: VariableHeightScrollStrategy;
+@Directive({
+  selector: '[variableHeightScroll]',
+  providers: [
+    {
+      provide: VIRTUAL_SCROLL_STRATEGY,
+      useFactory: (dir: VariableHeightScrollDirective) => dir.scrollStrategy,
+      deps: [forwardRef(() => VariableHeightScrollDirective)],
+    },
+  ],
+})
+export class VariableHeightScrollDirective {
+  readonly scrollStrategy = new VariableHeightScrollStrategy();
 
-  @Input()
-  set scrollItems(items: T[]) {
-    if (this.scrollItems !== items) {
-      this.scrollStrategy.updateItems(items);
+  @Input() traceType: TraceType | undefined;
+
+  @Input() scrollItems: object[] = [];
+
+  ngOnChanges() {
+    this.scrollStrategy.updateItems(this.scrollItems);
+    if (this.traceType !== undefined) {
+      this.scrollStrategy.updateTraceType(this.traceType);
     }
   }
 }
diff --git a/tools/winscope/src/viewers/common/variable_height_scroll_strategy.ts b/tools/winscope/src/viewers/common/variable_height_scroll_strategy.ts
index 0ad2b3304..df9275e48 100644
--- a/tools/winscope/src/viewers/common/variable_height_scroll_strategy.ts
+++ b/tools/winscope/src/viewers/common/variable_height_scroll_strategy.ts
@@ -18,13 +18,19 @@ import {
   CdkVirtualScrollViewport,
   VirtualScrollStrategy,
 } from '@angular/cdk/scrolling';
+import {assertDefined} from 'common/assert_utils';
 import {distinctUntilChanged, Observable, Subject} from 'rxjs';
-
-export abstract class VariableHeightScrollStrategy
-  implements VirtualScrollStrategy
-{
+import {TraceType} from 'trace/trace_type';
+import {InputHeightPredictor} from 'viewers/viewer_input/input_height_predictor';
+import {ProtologHeightPredictor} from 'viewers/viewer_protolog/protolog_height_predictor';
+import {TransactionsHeightPredictor} from 'viewers/viewer_transactions/transactions_height_predictor';
+import {TransitionsHeightPredictor} from 'viewers/viewer_transitions/transitions_height_predictor';
+import {ItemHeightPredictor} from './item_height_predictor';
+
+export class VariableHeightScrollStrategy implements VirtualScrollStrategy {
   static readonly HIDDEN_ELEMENTS_TO_RENDER = 20;
   private scrollItems: object[] = [];
+  private itemHeightPredictor: ItemHeightPredictor | undefined;
   private itemHeightCache = new Map<number, ItemHeight>(); // indexed by scrollIndex
   private wrapper: any = undefined;
   private viewport: CdkVirtualScrollViewport | undefined;
@@ -70,12 +76,32 @@ export abstract class VariableHeightScrollStrategy
 
   updateItems(items: object[]) {
     this.scrollItems = items;
-
     if (this.viewport) {
       this.viewport.checkViewportSize();
     }
   }
 
+  updateTraceType(value: TraceType) {
+    switch (value) {
+      case TraceType.TRANSACTIONS:
+        this.itemHeightPredictor = new TransactionsHeightPredictor();
+        break;
+      case TraceType.PROTO_LOG:
+        this.itemHeightPredictor = new ProtologHeightPredictor();
+        break;
+      case TraceType.TRANSITION:
+        this.itemHeightPredictor = new TransitionsHeightPredictor();
+        break;
+      case TraceType.INPUT_EVENT_MERGED:
+        this.itemHeightPredictor = new InputHeightPredictor();
+        break;
+      default:
+        throw new Error(
+          'unexpected trace type received - no height predictor available',
+        );
+    }
+  }
+
   scrollToIndex(index: number) {
     if (!this.viewport) {
       return;
@@ -95,10 +121,7 @@ export abstract class VariableHeightScrollStrategy
       this.viewport.measureScrollOffset(),
     );
     const range = {
-      start: Math.max(
-        0,
-        scrollIndex - VariableHeightScrollStrategy.HIDDEN_ELEMENTS_TO_RENDER,
-      ),
+      start: Math.max(0, scrollIndex - 5),
       end: Math.min(
         this.viewport.getDataLength(),
         scrollIndex +
@@ -111,7 +134,6 @@ export abstract class VariableHeightScrollStrategy
       this.getOffsetByItemIndex(range.start),
     );
     this.scrolledIndexChangeSubject.next(scrollIndex);
-
     this.updateItemHeightCache();
   }
 
@@ -203,16 +225,12 @@ export abstract class VariableHeightScrollStrategy
     }
   }
 
-  protected subItemHeight(subItem: string, rowLength: number): number {
-    return Math.ceil(subItem.length / rowLength) * this.defaultRowSize;
-  }
-
-  protected abstract readonly defaultRowSize: number;
-
   // best-effort estimate of item height using hardcoded values -
   // we render more items than are in the viewport, and once rendered,
   // the item's actual height is cached and used instead of the estimate
-  protected abstract predictScrollItemHeight(entry: object): number;
+  protected predictScrollItemHeight(entry: object): number {
+    return assertDefined(this.itemHeightPredictor).predictHeight(entry);
+  }
 }
 
 enum ItemHeightSource {
diff --git a/tools/winscope/src/viewers/components/abstract_form_field_component.ts b/tools/winscope/src/viewers/components/abstract_form_field_component.ts
new file mode 100644
index 000000000..ba434a874
--- /dev/null
+++ b/tools/winscope/src/viewers/components/abstract_form_field_component.ts
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import {Input} from '@angular/core';
+import {MatFormField} from '@angular/material/form-field';
+import {isElementOverflowing} from 'common/dom_utils';
+
+export abstract class AbstractFormFieldComponent {
+  @Input() label = 'Search';
+  @Input() appearance = '';
+  @Input() formFieldClass = '';
+
+  disableTooltip(formField: MatFormField) {
+    const el = formField._elementRef.nativeElement;
+    const label = el.querySelector('label');
+    if (label) {
+      return !isElementOverflowing(label);
+    }
+    return true;
+  }
+}
diff --git a/tools/winscope/src/viewers/components/collapsed_sections_component_test.ts b/tools/winscope/src/viewers/components/collapsed_sections_component_test.ts
index e7d774897..da5c6d9e0 100644
--- a/tools/winscope/src/viewers/components/collapsed_sections_component_test.ts
+++ b/tools/winscope/src/viewers/components/collapsed_sections_component_test.ts
@@ -14,27 +14,27 @@
  * limitations under the License.
  */
 
-import {ComponentFixture, TestBed} from '@angular/core/testing';
+import {TestBed} from '@angular/core/testing';
 import {MatButtonModule} from '@angular/material/button';
 import {MatIconModule} from '@angular/material/icon';
 import {assertDefined} from 'common/assert_utils';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
 import {CollapsibleSections} from 'viewers/common/collapsible_sections';
 import {CollapsibleSectionType} from 'viewers/common/collapsible_section_type';
 import {CollapsedSectionsComponent} from './collapsed_sections_component';
 
 describe('CollapsedSectionsComponent', () => {
-  let fixture: ComponentFixture<CollapsedSectionsComponent>;
   let component: CollapsedSectionsComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<CollapsedSectionsComponent>;
 
   beforeEach(async () => {
     await TestBed.configureTestingModule({
       imports: [MatButtonModule, MatIconModule],
       declarations: [CollapsedSectionsComponent],
     }).compileComponents();
-    fixture = TestBed.createComponent(CollapsedSectionsComponent);
+    const fixture = TestBed.createComponent(CollapsedSectionsComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
     component.sections = new CollapsibleSections([
       {
         type: CollapsibleSectionType.RECTS,
@@ -52,7 +52,7 @@ describe('CollapsedSectionsComponent', () => {
         isCollapsed: false,
       },
     ]);
-    fixture.detectChanges();
+    dom.detectChanges();
   });
 
   it('can be created', () => {
@@ -60,31 +60,27 @@ describe('CollapsedSectionsComponent', () => {
   });
 
   it('displays only collapsed sections', () => {
-    let sections = htmlElement.querySelectorAll('.collapsed-section');
+    let sections = dom.findAll('.collapsed-section');
     expect(sections.length).toEqual(1);
-    expect(sections.item(0).textContent).toContain('HIERARCHY');
-    assertDefined(sections.item(0).querySelector('button'));
+    sections[0].checkText('HIERARCHY');
+    expect(sections[0].find('button')).toBeDefined();
 
     assertDefined(component.sections).onCollapseStateChange(
       CollapsibleSectionType.RECTS,
       true,
     );
-    fixture.detectChanges();
-    sections = htmlElement.querySelectorAll('.collapsed-section');
+    dom.detectChanges();
+    sections = dom.findAll('.collapsed-section');
     expect(sections.length).toEqual(2);
-    expect(sections.item(0).textContent).toContain('RECTS');
-    assertDefined(sections.item(0).querySelector('button'));
-    expect(sections.item(1).textContent).toContain('HIERARCHY');
-    assertDefined(sections.item(1).querySelector('button'));
+    sections[0].checkText('RECTS');
+    expect(sections[0].find('button')).toBeDefined();
+    sections[1].checkText('HIERARCHY');
+    expect(sections[1].find('button')).toBeDefined();
   });
 
   it('emits sectionChange event', () => {
     const spy = spyOn(component.sectionChange, 'emit');
-    const expandButton = assertDefined(
-      htmlElement.querySelector('.collapsed-section button'),
-    ) as HTMLElement;
-    expandButton.click();
-    fixture.detectChanges();
+    dom.findAndClick('.collapsed-section button');
     expect(spy).toHaveBeenCalledOnceWith(CollapsibleSectionType.HIERARCHY);
   });
 });
diff --git a/tools/winscope/src/viewers/components/collapsible_section_title_component_test.ts b/tools/winscope/src/viewers/components/collapsible_section_title_component_test.ts
index 9121a11b4..6411d2008 100644
--- a/tools/winscope/src/viewers/components/collapsible_section_title_component_test.ts
+++ b/tools/winscope/src/viewers/components/collapsible_section_title_component_test.ts
@@ -14,27 +14,26 @@
  * limitations under the License.
  */
 
-import {ComponentFixture, TestBed} from '@angular/core/testing';
+import {TestBed} from '@angular/core/testing';
 import {MatButtonModule} from '@angular/material/button';
 import {MatIconModule} from '@angular/material/icon';
-import {assertDefined} from 'common/assert_utils';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
 import {CollapsibleSectionTitleComponent} from './collapsible_section_title_component';
 
 describe('CollapsibleSectionTitleComponent', () => {
-  let fixture: ComponentFixture<CollapsibleSectionTitleComponent>;
   let component: CollapsibleSectionTitleComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<CollapsibleSectionTitleComponent>;
 
   beforeEach(async () => {
     await TestBed.configureTestingModule({
       imports: [MatButtonModule, MatIconModule],
       declarations: [CollapsibleSectionTitleComponent],
     }).compileComponents();
-    fixture = TestBed.createComponent(CollapsibleSectionTitleComponent);
+    const fixture = TestBed.createComponent(CollapsibleSectionTitleComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
     component.title = 'collapsible section';
-    fixture.detectChanges();
+    dom.detectChanges();
   });
 
   it('can be created', () => {
@@ -42,18 +41,13 @@ describe('CollapsibleSectionTitleComponent', () => {
   });
 
   it('displays button and title', () => {
-    assertDefined(htmlElement.querySelector('button'));
-    const title = assertDefined(htmlElement.querySelector('.mat-title'));
-    expect(title.textContent).toContain('COLLAPSIBLE SECTION');
+    expect(dom.find('button')).toBeDefined();
+    dom.get('.mat-title').checkText('COLLAPSIBLE SECTION');
   });
 
   it('emits collapseButtonClicked event', () => {
     const spy = spyOn(component.collapseButtonClicked, 'emit');
-    const collapseButton = assertDefined(
-      htmlElement.querySelector('button'),
-    ) as HTMLElement;
-    collapseButton.click();
-    fixture.detectChanges();
+    dom.findAndClick('button');
     expect(spy).toHaveBeenCalledTimes(1);
   });
 });
diff --git a/tools/winscope/src/viewers/components/coordinates_table_component_test.ts b/tools/winscope/src/viewers/components/coordinates_table_component_test.ts
index 1b7f54887..66194d461 100644
--- a/tools/winscope/src/viewers/components/coordinates_table_component_test.ts
+++ b/tools/winscope/src/viewers/components/coordinates_table_component_test.ts
@@ -14,11 +14,10 @@
  * limitations under the License.
  */
 
-import {ComponentFixture, TestBed} from '@angular/core/testing';
+import {TestBed} from '@angular/core/testing';
 import {CoordinatesTableComponent} from './coordinates_table_component';
 
 describe('CoordinatesTableComponent', () => {
-  let fixture: ComponentFixture<CoordinatesTableComponent>;
   let component: CoordinatesTableComponent;
 
   beforeAll(async () => {
@@ -28,7 +27,7 @@ describe('CoordinatesTableComponent', () => {
   });
 
   beforeEach(() => {
-    fixture = TestBed.createComponent(CoordinatesTableComponent);
+    const fixture = TestBed.createComponent(CoordinatesTableComponent);
     component = fixture.componentInstance;
   });
 
diff --git a/tools/winscope/src/viewers/components/hierarchy_component.ts b/tools/winscope/src/viewers/components/hierarchy_component.ts
index f7e2d6942..e8d4ab8eb 100644
--- a/tools/winscope/src/viewers/components/hierarchy_component.ts
+++ b/tools/winscope/src/viewers/components/hierarchy_component.ts
@@ -24,6 +24,7 @@ import {
   Output,
 } from '@angular/core';
 import {Color} from 'app/colors';
+import {isElementOverflowing, KeyboardEventKey} from 'common/dom_utils';
 import {InMemoryStorage} from 'common/store/in_memory_storage';
 import {PersistentStore} from 'common/store/persistent_store';
 import {Analytics} from 'logging/analytics';
@@ -216,7 +217,7 @@ export class HierarchyComponent {
   }
 
   disableTooltip(el: HTMLElement) {
-    return el.scrollWidth === el.clientWidth;
+    return !isElementOverflowing(el);
   }
 
   getPinnedItemsPadding() {
@@ -230,11 +231,12 @@ export class HierarchyComponent {
     const componentVisible = domRect.height > 0 && domRect.width > 0;
     if (
       componentVisible &&
-      (event.key === 'ArrowDown' || event.key === 'ArrowUp')
+      (event.key === KeyboardEventKey.ARROW_DOWN ||
+        event.key === KeyboardEventKey.ARROW_UP)
     ) {
       event.preventDefault();
       const details = {bubbles: true, detail: this.treeStorage};
-      if (event.key === 'ArrowDown') {
+      if (event.key === KeyboardEventKey.ARROW_DOWN) {
         const arrowEvent = new CustomEvent(
           ViewerEvents.ArrowDownPress,
           details,
diff --git a/tools/winscope/src/viewers/components/hierarchy_component_test.ts b/tools/winscope/src/viewers/components/hierarchy_component_test.ts
index 3e2f12d9c..36fcdd48e 100644
--- a/tools/winscope/src/viewers/components/hierarchy_component_test.ts
+++ b/tools/winscope/src/viewers/components/hierarchy_component_test.ts
@@ -15,11 +15,7 @@
  */
 import {ClipboardModule} from '@angular/cdk/clipboard';
 import {CommonModule} from '@angular/common';
-import {
-  ComponentFixture,
-  ComponentFixtureAutoDetect,
-  TestBed,
-} from '@angular/core/testing';
+import {ComponentFixtureAutoDetect, TestBed} from '@angular/core/testing';
 import {FormsModule} from '@angular/forms';
 import {MatButtonModule} from '@angular/material/button';
 import {MatDividerModule} from '@angular/material/divider';
@@ -33,8 +29,8 @@ import {FilterFlag} from 'common/filter_flag';
 import {InMemoryStorage} from 'common/store/in_memory_storage';
 import {PersistentStore} from 'common/store/persistent_store';
 import {DuplicateLayerIds, MissingLayerIds} from 'messaging/user_warnings';
+import {checkTooltips, DOMTestHelper} from 'test/unit/dom_test_utils';
 import {HierarchyTreeBuilder} from 'test/unit/hierarchy_tree_builder';
-import {UnitTestUtils} from 'test/unit/utils';
 import {TraceType} from 'trace/trace_type';
 import {TextFilter} from 'viewers/common/text_filter';
 import {UiHierarchyTreeNode} from 'viewers/common/ui_hierarchy_tree_node';
@@ -48,9 +44,8 @@ import {SearchBoxComponent} from './search_box_component';
 import {UserOptionsComponent} from './user_options_component';
 
 describe('HierarchyComponent', () => {
-  let fixture: ComponentFixture<HierarchyComponent>;
   let component: HierarchyComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<HierarchyComponent>;
 
   beforeEach(async () => {
     await TestBed.configureTestingModule({
@@ -77,10 +72,9 @@ describe('HierarchyComponent', () => {
         ClipboardModule,
       ],
     }).compileComponents();
-
-    fixture = TestBed.createComponent(HierarchyComponent);
+    const fixture = TestBed.createComponent(HierarchyComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
 
     component.trees = [
       UiHierarchyTreeNode.from(
@@ -103,7 +97,7 @@ describe('HierarchyComponent', () => {
     component.textFilter = new TextFilter();
     component.dependencies = [TraceType.SURFACE_FLINGER];
 
-    fixture.detectChanges();
+    dom.detectChanges();
   });
 
   it('can be created', () => {
@@ -111,22 +105,18 @@ describe('HierarchyComponent', () => {
   });
 
   it('renders title', () => {
-    const title = htmlElement.querySelector('.hierarchy-title');
-    expect(title).toBeTruthy();
+    expect(dom.find('.hierarchy-title')).toBeDefined();
   });
 
   it('renders view controls', () => {
-    const viewControls = htmlElement.querySelector('.view-controls');
-    expect(viewControls).toBeTruthy();
-    const button = htmlElement.querySelector('.view-controls .user-option');
-    expect(button).toBeTruthy(); //renders at least one view control option
+    expect(dom.find('.view-controls')).toBeDefined();
+    expect(dom.find('.view-controls .user-option')).toBeDefined(); //renders at least one view control option
   });
 
   it('renders initial tree elements', () => {
-    const treeView = htmlElement.querySelector('tree-view');
-    expect(treeView).toBeTruthy();
-    expect(assertDefined(treeView).innerHTML).toContain('Root node');
-    expect(assertDefined(treeView).innerHTML).toContain('Child node');
+    const treeView = dom.get('tree-view');
+    treeView.checkText('Root node');
+    treeView.checkText('Child node');
   });
 
   it('renders multiple trees', () => {
@@ -136,173 +126,136 @@ describe('HierarchyComponent', () => {
         new HierarchyTreeBuilder().setId('subtree').setName('subtree').build(),
       ),
     ];
-    fixture.detectChanges();
-    const trees = assertDefined(
-      htmlElement.querySelectorAll('.tree-wrapper .tree'),
-    );
+    dom.detectChanges();
+    const trees = dom.findAll('.tree-wrapper .tree');
     expect(trees.length).toEqual(2);
-    expect(trees.item(1).textContent).toContain('subtree');
+    trees[1].checkText('subtree');
   });
 
   it('renders pinned nodes', () => {
-    const pinnedNodesDiv = htmlElement.querySelector('.pinned-items');
-    expect(pinnedNodesDiv).toBeFalsy();
-
+    expect(dom.find('.pinned-items')).toBeUndefined();
     component.pinnedItems = assertDefined(component.trees);
-    fixture.detectChanges();
-    const pinnedNodeEl = htmlElement.querySelector('.pinned-items tree-node');
-    expect(pinnedNodeEl).toBeTruthy();
+    dom.detectChanges();
+    expect(dom.find('.pinned-items tree-node')).toBeDefined();
   });
 
   it('renders placeholder text', () => {
     component.trees = [];
     component.placeholderText = 'Placeholder text.';
-    fixture.detectChanges();
-    expect(
-      htmlElement.querySelector('.placeholder-text')?.textContent?.trim(),
-    ).toEqual('Placeholder text. Try changing timeline position.');
+    dom.detectChanges();
+    dom
+      .get('.placeholder-text')
+      .checkTextExact('Placeholder text. Try changing timeline position.');
   });
 
   it('handles pinned node click', () => {
     const node = assertDefined(component.trees[0]);
     component.pinnedItems = [node];
-    fixture.detectChanges();
+    dom.detectChanges();
 
     let highlightedItem: UiHierarchyTreeNode | undefined;
-    htmlElement.addEventListener(
-      ViewerEvents.HighlightedNodeChange,
-      (event) => {
-        highlightedItem = (event as CustomEvent).detail.node;
-      },
-    );
-
-    const pinnedNodeEl = assertDefined(
-      htmlElement.querySelector('.pinned-items tree-node'),
-    );
+    dom.addEventListener(ViewerEvents.HighlightedNodeChange, (event) => {
+      highlightedItem = (event as CustomEvent).detail.node;
+    });
 
-    (pinnedNodeEl as HTMLButtonElement).click();
-    fixture.detectChanges();
+    dom.findAndClick('.pinned-items tree-node');
     expect(highlightedItem).toEqual(node);
   });
 
   it('handles pinned item change from tree', () => {
     let pinnedItem: UiHierarchyTreeNode | undefined;
-    htmlElement.addEventListener(
-      ViewerEvents.HierarchyPinnedChange,
-      (event) => {
-        pinnedItem = (event as CustomEvent).detail.pinnedItem;
-      },
-    );
+    dom.addEventListener(ViewerEvents.HierarchyPinnedChange, (event) => {
+      pinnedItem = (event as CustomEvent).detail.pinnedItem;
+    });
     const child = assertDefined(
       component.trees[0].getChildByName('Child node'),
     );
     component.pinnedItems = [child];
-    fixture.detectChanges();
-
-    const pinButton = assertDefined(
-      htmlElement.querySelector('.pinned-items tree-node .pin-node-btn'),
-    );
-    (pinButton as HTMLButtonElement).click();
-    fixture.detectChanges();
+    dom.detectChanges();
 
+    dom.findAndClick('.pinned-items tree-node .pin-node-btn');
     expect(pinnedItem).toEqual(child);
   });
 
   it('handles change in filter', () => {
     let textFilter: TextFilter | undefined;
-    htmlElement.addEventListener(
-      ViewerEvents.HierarchyFilterChange,
-      (event) => {
-        textFilter = (event as CustomEvent).detail;
-      },
-    );
-    const inputEl = assertDefined(
-      htmlElement.querySelector<HTMLInputElement>('.title-section input'),
-    );
-    const flagButton = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.search-box button'),
-    );
-    flagButton.click();
-    fixture.detectChanges();
-
-    inputEl.value = 'Root';
-    inputEl.dispatchEvent(new Event('input'));
-    fixture.detectChanges();
+    dom.addEventListener(ViewerEvents.HierarchyFilterChange, (event) => {
+      textFilter = (event as CustomEvent).detail;
+    });
+    dom.findAndClick('.search-box button');
+    dom.findAndDispatchInput('.title-section', 'Root');
     expect(textFilter).toEqual(new TextFilter('Root', [FilterFlag.MATCH_CASE]));
   });
 
   it('handles collapse button click', () => {
     const spy = spyOn(component.collapseButtonClicked, 'emit');
-    const collapseButton = assertDefined(
-      htmlElement.querySelector('collapsible-section-title button'),
-    ) as HTMLButtonElement;
-    collapseButton.click();
-    fixture.detectChanges();
+    dom.findAndClick('collapsible-section-title button');
     expect(spy).toHaveBeenCalled();
   });
 
   it('shows warnings from all trees', () => {
-    expect(htmlElement.querySelectorAll('.warning').length).toEqual(0);
+    expect(dom.find('.warning')).toBeUndefined();
 
     component.trees = [
       component.trees[0],
       UiHierarchyTreeNode.from(component.trees[0]),
     ];
-    fixture.detectChanges();
+    dom.detectChanges();
     const warning1 = new DuplicateLayerIds([123]);
     component.trees[0].addWarning(warning1);
     const warning2 = new MissingLayerIds();
     component.trees[1].addWarning(warning2);
-    fixture.detectChanges();
-    const warnings = htmlElement.querySelectorAll('.warning');
+    dom.detectChanges();
+    const warnings = dom.findAll('.warning');
     expect(warnings.length).toEqual(2);
-    expect(warnings[0].textContent?.trim()).toEqual(
-      'warning ' + warning1.getMessage(),
-    );
-    expect(warnings[1].textContent?.trim()).toEqual(
-      'warning ' + warning2.getMessage(),
-    );
+    warnings[0].checkTextExact('warning ' + warning1.getMessage());
+    warnings[1].checkTextExact('warning ' + warning2.getMessage());
   });
 
   it('shows warning tooltip if text overflowing', () => {
     const warning = new DuplicateLayerIds([123]);
     component.trees[0].addWarning(warning);
-    fixture.detectChanges();
+    dom.detectChanges();
 
-    const warningEl = assertDefined(htmlElement.querySelector('.warning'));
-    const msgEl = assertDefined(warningEl.querySelector('.warning-message'));
+    const warningEl = dom.get('.warning');
+    const msgEl = dom.get('.warning-message').getHTMLElement();
 
     const spy = spyOnProperty(msgEl, 'scrollWidth').and.returnValue(
       msgEl.clientWidth,
     );
-    UnitTestUtils.checkTooltips([warningEl], [undefined], fixture);
+    checkTooltips([warningEl], [undefined]);
 
     spy.and.returnValue(msgEl.clientWidth + 1);
-    fixture.detectChanges();
-    UnitTestUtils.checkTooltips([warningEl], [warning.getMessage()], fixture);
+    dom.detectChanges();
+    checkTooltips([warningEl], [warning.getMessage()]);
   });
 
   it('handles arrow down key press', () => {
-    testArrowKeyPress(ViewerEvents.ArrowDownPress, 'ArrowDown');
+    testArrowKeyPress(ViewerEvents.ArrowDownPress);
   });
 
   it('handles arrow up key press', () => {
-    testArrowKeyPress(ViewerEvents.ArrowUpPress, 'ArrowUp');
+    testArrowKeyPress(ViewerEvents.ArrowUpPress);
   });
 
-  function testArrowKeyPress(viewerEvent: string, key: string) {
+  function testArrowKeyPress(viewerEvent: string) {
     let storage: InMemoryStorage | undefined;
-    htmlElement.addEventListener(viewerEvent, (event) => {
+    dom.addEventListener(viewerEvent, (event) => {
       storage = (event as CustomEvent).detail;
     });
-    const event = new KeyboardEvent('keydown', {key});
-    document.dispatchEvent(event);
+    let keydown: () => void;
+    if (viewerEvent === ViewerEvents.ArrowDownPress) {
+      keydown = () => dom.keydownArrowDown(true);
+    } else {
+      keydown = () => dom.keydownArrowUp(true);
+    }
+    keydown();
     expect(storage).toEqual(component.treeStorage);
 
     storage = undefined;
-    htmlElement.style.height = '0px';
-    fixture.detectChanges();
-    document.dispatchEvent(event);
+    dom.getHTMLElement().style.height = '0px';
+    dom.detectChanges();
+    keydown();
     expect(storage).toBeUndefined();
   }
 });
diff --git a/tools/winscope/src/viewers/components/hierarchy_tree_node_data_view_component_test.ts b/tools/winscope/src/viewers/components/hierarchy_tree_node_data_view_component_test.ts
index 46af197be..cdff03b25 100644
--- a/tools/winscope/src/viewers/components/hierarchy_tree_node_data_view_component_test.ts
+++ b/tools/winscope/src/viewers/components/hierarchy_tree_node_data_view_component_test.ts
@@ -13,31 +13,28 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-import {ComponentFixture, TestBed} from '@angular/core/testing';
+import {TestBed} from '@angular/core/testing';
 import {MatTooltipModule} from '@angular/material/tooltip';
-import {assertDefined} from 'common/assert_utils';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
 import {TreeNodeUtils} from 'test/unit/tree_node_utils';
-import {UnitTestUtils} from 'test/unit/utils';
 import {VISIBLE_CHIP} from 'viewers/common/chip';
 import {UiHierarchyTreeNode} from 'viewers/common/ui_hierarchy_tree_node';
 import {HierarchyTreeNodeDataViewComponent} from './hierarchy_tree_node_data_view_component';
 
 describe('HierarchyTreeNodeDataViewComponent', () => {
   let testNode: UiHierarchyTreeNode;
-  let fixture: ComponentFixture<HierarchyTreeNodeDataViewComponent>;
   let component: HierarchyTreeNodeDataViewComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<HierarchyTreeNodeDataViewComponent>;
 
   beforeEach(async () => {
     await TestBed.configureTestingModule({
       declarations: [HierarchyTreeNodeDataViewComponent],
       imports: [MatTooltipModule],
     }).compileComponents();
-    fixture = TestBed.createComponent(HierarchyTreeNodeDataViewComponent);
+    const fixture = TestBed.createComponent(HierarchyTreeNodeDataViewComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
-    fixture.detectChanges();
-
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
+    dom.detectChanges();
     testNode = TreeNodeUtils.makeUiHierarchyNode({
       id: 1,
       name: 'test node',
@@ -50,34 +47,26 @@ describe('HierarchyTreeNodeDataViewComponent', () => {
 
   it('shows node heading if set', () => {
     component.node = testNode;
-    fixture.detectChanges();
-    expect(htmlElement.textContent).toEqual('1 - test node');
+    dom.detectChanges();
+    dom.checkTextExact('1 - test node');
     testNode.setShowHeading(false);
-    fixture.detectChanges();
-    expect(htmlElement.textContent).toEqual('test node');
+    dom.detectChanges();
+    dom.checkTextExact('test node');
   });
 
-  it('shows display name if set, with full name on hover', () => {
+  it('shows display name if set, with full name on hover', async () => {
     testNode.setDisplayName('display name');
     component.node = testNode;
-    fixture.detectChanges();
-    expect(htmlElement.textContent).toEqual('1 - display name');
-    const displayName = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.display-name'),
-    );
-    UnitTestUtils.checkTooltips([displayName], ['test node'], fixture);
+    dom.detectChanges();
+    dom.checkTextExact('1 - display name');
+    await dom.get('.display-name').checkTooltip('test node');
   });
 
-  it('shows chips with tooltip on hover', () => {
+  it('shows chips with tooltip on hover', async () => {
     testNode.addChip(VISIBLE_CHIP);
     component.node = testNode;
-    fixture.detectChanges();
-    expect(htmlElement.textContent?.trim()).toEqual(
-      `1 - test node ${VISIBLE_CHIP.short}`,
-    );
-    const chip = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.tree-view-chip'),
-    );
-    UnitTestUtils.checkTooltips([chip], [VISIBLE_CHIP.long], fixture);
+    dom.detectChanges();
+    dom.checkTextExact(`1 - test node ${VISIBLE_CHIP.short}`);
+    await dom.get('.tree-view-chip').checkTooltip(VISIBLE_CHIP.long);
   });
 });
diff --git a/tools/winscope/src/viewers/components/ime_additional_properties_component_test.ts b/tools/winscope/src/viewers/components/ime_additional_properties_component_test.ts
index f8a4fab67..e8df2ca3a 100644
--- a/tools/winscope/src/viewers/components/ime_additional_properties_component_test.ts
+++ b/tools/winscope/src/viewers/components/ime_additional_properties_component_test.ts
@@ -14,12 +14,12 @@
  * limitations under the License.
  */
 import {Component} from '@angular/core';
-import {ComponentFixture, TestBed} from '@angular/core/testing';
+import {TestBed} from '@angular/core/testing';
 import {MatButtonModule} from '@angular/material/button';
 import {MatDividerModule} from '@angular/material/divider';
 import {MatIconModule} from '@angular/material/icon';
 import {MatTooltipModule} from '@angular/material/tooltip';
-import {assertDefined} from 'common/assert_utils';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
 import {TreeNodeUtils} from 'test/unit/tree_node_utils';
 import {ImeAdditionalProperties} from 'viewers/common/ime_additional_properties';
 import {ViewerEvents} from 'viewers/common/viewer_events';
@@ -28,9 +28,8 @@ import {CoordinatesTableComponent} from './coordinates_table_component';
 import {ImeAdditionalPropertiesComponent} from './ime_additional_properties_component';
 
 describe('ImeAdditionalPropertiesComponent', () => {
-  let fixture: ComponentFixture<TestHostComponent>;
   let component: TestHostComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<TestHostComponent>;
 
   beforeEach(async () => {
     await TestBed.configureTestingModule({
@@ -47,22 +46,22 @@ describe('ImeAdditionalPropertiesComponent', () => {
         CoordinatesTableComponent,
       ],
     }).compileComponents();
-    fixture = TestBed.createComponent(TestHostComponent);
+    const fixture = TestBed.createComponent(TestHostComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
-    htmlElement.addEventListener(
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
+    dom.addEventListener(
       ViewerEvents.HighlightedNodeChange,
       component.onHighlightedNodeChange,
     );
-    htmlElement.addEventListener(
+    dom.addEventListener(
       ViewerEvents.HighlightedIdChange,
       component.onHighlightedIdChange,
     );
-    htmlElement.addEventListener(
+    dom.addEventListener(
       ViewerEvents.AdditionalPropertySelected,
       component.onAdditionalPropertySelectedChange,
     );
-    fixture.detectChanges();
+    dom.detectChanges();
   });
 
   it('can be created', () => {
@@ -70,87 +69,65 @@ describe('ImeAdditionalPropertiesComponent', () => {
   });
 
   it('shows client or service sf properties', () => {
-    expect(htmlElement.querySelector('.ime-container')).toBeDefined();
-    expect(htmlElement.querySelector('.input-method-surface')).toBeDefined();
+    expect(dom.find('.ime-container')).toBeDefined();
+    expect(dom.find('.input-method-surface')).toBeDefined();
   });
 
   it('renders placeholder text', () => {
     component.additionalProperties = undefined;
-    fixture.detectChanges();
-    expect(
-      htmlElement.querySelector('.placeholder-text')?.textContent,
-    ).toContain('No IME entry found.');
+    dom.detectChanges();
+    dom.get('.placeholder-text').checkTextExact('No IME entry found.');
   });
 
   it('emits update additional property tree event on wm state button click', () => {
-    const button = assertDefined(
-      htmlElement.querySelector('.wm-state-button'),
-    ) as HTMLButtonElement;
-    expect(button.className).not.toContain('selected');
+    const button = dom.get('.wm-state-button');
+    button.checkClassName('selected', false);
     button.click();
-    fixture.detectChanges();
     expect(component.additionalPropertieTreeName).toEqual(
       'Window Manager State',
     );
-    expect(button.className).toContain('selected');
+    button.checkClassName('selected', true);
   });
 
   it('propagates new ime container layer on button click', () => {
-    const button = assertDefined(
-      htmlElement.querySelector('.ime-container-button'),
-    ) as HTMLButtonElement;
-    expect(button.className).not.toContain('selected');
+    const button = dom.get('.ime-container-button');
+    button.checkClassName('selected', false);
     button.click();
-    fixture.detectChanges();
     expect(component.highlightedItem).toEqual('123');
-    expect(button.className).toContain('selected');
+    button.checkClassName('selected', true);
   });
 
   it('propagates new input method surface layer on button click', () => {
-    const button = assertDefined(
-      htmlElement.querySelector('.input-method-surface-button'),
-    ) as HTMLButtonElement;
-    expect(button.className).not.toContain('selected');
+    const button = dom.get('.input-method-surface-button');
+    button.checkClassName('selected', false);
     button.click();
-    fixture.detectChanges();
     expect(component.highlightedItem).toEqual('456');
-    expect(button.className).toContain('selected');
+    button.checkClassName('selected', true);
   });
 
   it('shows ime manager service wm properties', () => {
     component.isImeManagerService = true;
-    fixture.detectChanges();
-    const imeManagerService = assertDefined(
-      htmlElement.querySelector('.ime-manager-service'),
-    );
-    expect(
-      assertDefined(imeManagerService.querySelector('.wm-state')).textContent,
-    ).toContain('1970-01-01, 00:00:00.000000000');
-    expect(
-      imeManagerService.querySelector('.ime-control-target-button'),
-    ).toBeDefined();
+    dom.detectChanges();
+    const imeManagerService = dom.get('.ime-manager-service');
+    imeManagerService
+      .get('.wm-state')
+      .checkTextExact('1970-01-01, 00:00:00.000000000');
+    expect(dom.find('.ime-control-target-button')).toBeDefined();
   });
 
   it('propagates new property tree node window on button click', () => {
     component.isImeManagerService = true;
-    fixture.detectChanges();
-    const button = assertDefined(
-      htmlElement.querySelector('.ime-control-target-button'),
-    ) as HTMLButtonElement;
-    expect(button.className).not.toContain('selected');
+    dom.detectChanges();
+    const button = dom.get('.ime-control-target-button');
+    button.checkClassName('selected', false);
     button.click();
-    fixture.detectChanges();
     expect(component.additionalPropertieTreeName).toEqual('Ime Control Target');
-    expect(button.className).toContain('selected');
+    button.checkClassName('selected', true);
   });
 
   it('handles collapse button click', () => {
     expect(component.collapseButtonClicked).toBeFalse();
-    const collapseButton = assertDefined(
-      htmlElement.querySelector('collapsible-section-title button'),
-    ) as HTMLButtonElement;
-    collapseButton.click();
-    fixture.detectChanges();
+    dom.findAndClick('collapsible-section-title button');
     expect(component.collapseButtonClicked).toBeTrue();
   });
 
diff --git a/tools/winscope/src/viewers/components/log_component.ts b/tools/winscope/src/viewers/components/log_component.ts
index 8438b6b35..7b7ddd50c 100644
--- a/tools/winscope/src/viewers/components/log_component.ts
+++ b/tools/winscope/src/viewers/components/log_component.ts
@@ -27,7 +27,7 @@ import {
 } from '@angular/core';
 import {MatSelectChange} from '@angular/material/select';
 
-import {DOMUtils} from 'common/dom_utils';
+import {isElementVisible, KeyboardEventKey} from 'common/dom_utils';
 import {Timestamp, TimestampFormatType} from 'common/time/time';
 import {TimeUtils} from 'common/time/time_utils';
 import {TraceType} from 'trace/trace_type';
@@ -60,21 +60,6 @@ import {
             class="log-title"
             [title]="title"
             (collapseButtonClicked)="collapseButtonClicked.emit()"></collapsible-section-title>
-
-        <div class="filters" *ngIf="showFiltersInTitle && getHeadersWithFilters().length > 0">
-          <div class="filter" *ngFor="let header of getHeadersWithFilters()"
-               [class]="header.spec.cssClass">
-            <select-with-filter
-                *ngIf="(header.filter.options?.length ?? 0) > 0"
-                [label]="header.spec.name"
-                [options]="header.filter.options"
-                [outerFilterWidth]="header.filter.outerFilterWidthCss"
-                [innerFilterWidth]="header.filter.innerFilterWidthCss"
-                formFieldClass="no-border-top-field"
-                (selectChange)="onFilterChange($event, header)">
-            </select-with-filter>
-          </div>
-        </div>
       </div>
     </div>
 
@@ -140,31 +125,10 @@ import {
       </div>
 
       <cdk-virtual-scroll-viewport
-          *ngIf="isTransactions()"
-          transactionsVirtualScroll
-          class="scroll"
-          [scrollItems]="entries">
-        <ng-container
-            *cdkVirtualFor="let entry of entries; let i = index"
-            [ngTemplateOutlet]="content"
-            [ngTemplateOutletContext]="{entry: entry, i: i}"> </ng-container>
-      </cdk-virtual-scroll-viewport>
-
-      <cdk-virtual-scroll-viewport
-          *ngIf="isProtolog()"
-          protologVirtualScroll
-          class="scroll"
-          [scrollItems]="entries">
-        <ng-container
-            *cdkVirtualFor="let entry of entries; let i = index"
-            [ngTemplateOutlet]="content"
-            [ngTemplateOutletContext]="{entry: entry, i: i}"> </ng-container>
-      </cdk-virtual-scroll-viewport>
-
-      <cdk-virtual-scroll-viewport
-          *ngIf="isTransitions()"
-          transitionsVirtualScroll
+          *ngIf="!isFixedSizeScrollViewport()"
+          variableHeightScroll
           class="scroll"
+          [traceType]="traceType"
           [scrollItems]="entries">
         <ng-container
             *cdkVirtualFor="let entry of entries; let i = index"
@@ -202,7 +166,7 @@ import {
             </button>
           </div>
 
-          <div [class]="field.spec.cssClass" *ngFor="let field of entry.fields; index as i">
+          <div [class]="field.spec.cssClass + ' cell'" *ngFor="let field of entry.fields; index as i">
             <span class="mat-body-1" *ngIf="!showFieldButton(entry, field)">{{ field.value }}</span>
             <button
                 *ngIf="showFieldButton(entry, field)"
@@ -216,6 +180,13 @@ import {
                 *ngIf="field.icon"
                 aria-hidden="false"
                 [style]="{color: field.iconColor}"> {{field.icon}} </mat-icon>
+            <button
+                mat-icon-button
+                *ngIf="field.spec.canCopy"
+                class="copy-button"
+                [cdkCopyToClipboard]="field.value.toString()">
+              <mat-icon>content_copy</mat-icon>
+            </button>
           </div>
         </div>
       </ng-template>
@@ -257,7 +228,6 @@ export class LogComponent {
   @Input() showCurrentTimeButton = true;
   @Input() traceType: TraceType | undefined;
   @Input() showTraceEntryTimes = true;
-  @Input() showFiltersInTitle = false;
   @Input() padEntries = true;
   @Input() isFetchingData = false;
 
@@ -368,19 +338,29 @@ export class LogComponent {
 
   @HostListener('document:keydown', ['$event'])
   async handleKeyboardEvent(event: KeyboardEvent) {
-    const logComponentVisible = DOMUtils.isElementVisible(
-      this.elementRef.nativeElement,
-    );
-    if (event.key === 'ArrowDown' && logComponentVisible) {
+    const logComponentVisible = isElementVisible(this.elementRef.nativeElement);
+    if (event.key === KeyboardEventKey.ARROW_DOWN && logComponentVisible) {
       event.stopPropagation();
       event.preventDefault();
       this.emitEvent(ViewerEvents.ArrowDownPress);
     }
-    if (event.key === 'ArrowUp' && logComponentVisible) {
+    if (event.key === KeyboardEventKey.ARROW_UP && logComponentVisible) {
       event.stopPropagation();
       event.preventDefault();
       this.emitEvent(ViewerEvents.ArrowUpPress);
     }
+    if (
+      event.key === KeyboardEventKey.ENTER &&
+      logComponentVisible &&
+      this.selectedIndex !== undefined
+    ) {
+      event.stopPropagation();
+      event.preventDefault();
+      this.emitEvent(
+        ViewerEvents.TimestampClick,
+        new TimestampClickDetail(this.entries[this.selectedIndex].traceEntry),
+      );
+    }
   }
 
   isCurrentEntry(index: number): boolean {
@@ -391,23 +371,9 @@ export class LogComponent {
     return index === this.selectedIndex;
   }
 
-  isTransactions() {
-    return this.traceType === TraceType.TRANSACTIONS;
-  }
-
-  isProtolog() {
-    return this.traceType === TraceType.PROTO_LOG;
-  }
-
-  isTransitions() {
-    return this.traceType === TraceType.TRANSITION;
-  }
-
   isFixedSizeScrollViewport() {
-    return !(
-      this.isTransactions() ||
-      this.isProtolog() ||
-      this.isTransitions()
+    return (
+      this.traceType === TraceType.CUJS || this.traceType === TraceType.SEARCH
     );
   }
 
diff --git a/tools/winscope/src/viewers/components/log_component_test.ts b/tools/winscope/src/viewers/components/log_component_test.ts
index d7f607d3d..d34999239 100644
--- a/tools/winscope/src/viewers/components/log_component_test.ts
+++ b/tools/winscope/src/viewers/components/log_component_test.ts
@@ -14,12 +14,9 @@
  * limitations under the License.
  */
 
+import {Clipboard, ClipboardModule} from '@angular/cdk/clipboard';
 import {ScrollingModule} from '@angular/cdk/scrolling';
-import {
-  ComponentFixture,
-  ComponentFixtureAutoDetect,
-  TestBed,
-} from '@angular/core/testing';
+import {ComponentFixtureAutoDetect, TestBed} from '@angular/core/testing';
 import {FormsModule} from '@angular/forms';
 import {MatButtonModule} from '@angular/material/button';
 import {MatPseudoCheckboxModule} from '@angular/material/core';
@@ -29,10 +26,13 @@ import {MatIconModule} from '@angular/material/icon';
 import {MatInputModule} from '@angular/material/input';
 import {MatProgressSpinnerModule} from '@angular/material/progress-spinner';
 import {MatSelectModule} from '@angular/material/select';
+import {MatTooltipModule} from '@angular/material/tooltip';
 import {BrowserAnimationsModule} from '@angular/platform-browser/animations';
 import {assertDefined} from 'common/assert_utils';
+import {KeyboardEventKey} from 'common/dom_utils';
 import {TimestampConverterUtils} from 'common/time/test_utils';
 import {Timestamp} from 'common/time/time';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
 import {TraceBuilder} from 'test/unit/trace_builder';
 import {TraceEntry} from 'trace/trace';
 import {TraceType} from 'trace/trace_type';
@@ -45,6 +45,7 @@ import {
   LogField,
   LogHeader,
 } from 'viewers/common/ui_data_log';
+import {VariableHeightScrollDirective} from 'viewers/common/variable_height_scroll_directive';
 import {
   LogFilterChangeDetail,
   LogTextFilterChangeDetail,
@@ -63,13 +64,17 @@ describe('LogComponent', () => {
   const testColumn2: ColumnSpec = {name: 'test2', cssClass: 'test-2'};
   const testColumn3: ColumnSpec = {name: 'test3', cssClass: 'test-3'};
 
-  let fixture: ComponentFixture<LogComponent>;
   let component: LogComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<LogComponent>;
+  let mockCopyText: jasmine.Spy;
 
   beforeEach(async () => {
+    mockCopyText = jasmine.createSpy();
     await TestBed.configureTestingModule({
-      providers: [{provide: ComponentFixtureAutoDetect, useValue: true}],
+      providers: [
+        {provide: Clipboard, useValue: {copy: mockCopyText}},
+        {provide: ComponentFixtureAutoDetect, useValue: true},
+      ],
       imports: [
         ScrollingModule,
         MatFormFieldModule,
@@ -82,6 +87,8 @@ describe('LogComponent', () => {
         MatIconModule,
         MatPseudoCheckboxModule,
         MatProgressSpinnerModule,
+        MatTooltipModule,
+        ClipboardModule,
       ],
       declarations: [
         LogComponent,
@@ -90,14 +97,14 @@ describe('LogComponent', () => {
         CollapsibleSectionTitleComponent,
         PropertiesComponent,
         SearchBoxComponent,
+        VariableHeightScrollDirective,
       ],
     }).compileComponents();
-
-    fixture = TestBed.createComponent(LogComponent);
+    const fixture = TestBed.createComponent(LogComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
     setComponentInputData();
-    fixture.detectChanges();
+    dom.detectChanges();
   });
 
   it('can be created', () => {
@@ -105,54 +112,31 @@ describe('LogComponent', () => {
   });
 
   it('renders filters', () => {
-    const filtersInTable = htmlElement.querySelectorAll('.entries .filter');
-    expect(filtersInTable.length).toEqual(2);
-    const filtersInTitle = htmlElement.querySelectorAll(
-      '.title-section .filter',
-    );
-    expect(filtersInTitle.length).toEqual(0);
-  });
-
-  it('renders filters in title', () => {
-    component.title = 'Test';
-    component.showFiltersInTitle = true;
-    fixture.detectChanges();
-    const filtersInTable = htmlElement.querySelectorAll('.entries .filter');
-    expect(filtersInTable.length).toEqual(0);
-    const filtersInTitle = htmlElement.querySelectorAll(
-      '.title-section .filter',
-    );
-    expect(filtersInTitle.length).toEqual(2);
+    expect(dom.findAll('.entries .filter').length).toEqual(2);
   });
 
   it('renders entries', () => {
-    expect(htmlElement.querySelector('.scroll')).toBeTruthy();
-
-    const entryText = assertDefined(
-      htmlElement.querySelector('.scroll .entry'),
-    ).textContent;
-    expect(entryText).toContain('Test tag');
-    expect(entryText).toContain('123');
-    expect(entryText).toContain('2ns');
+    const scroll = dom.get('.scroll');
+    const entryText = scroll.get('.entry');
+    entryText.checkText('Test tag');
+    entryText.checkText('123');
+    entryText.checkText('2ns');
   });
 
   it('scrolls to current entry on button click', () => {
     component.currentIndex = 1;
-    fixture.detectChanges();
-    const goToCurrentTimeButton = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.go-to-current-time'),
-    );
+    dom.detectChanges();
     const spy = spyOn(
       assertDefined(component.scrollComponent),
       'scrollToIndex',
     );
-    goToCurrentTimeButton.click();
+    dom.findAndClick('.go-to-current-time');
     expect(spy).toHaveBeenCalledWith(1);
   });
 
   it('applies select filter correctly', async () => {
     const allEntries = component.entries.slice();
-    htmlElement.addEventListener(ViewerEvents.LogFilterChange, (event) => {
+    dom.addEventListener(ViewerEvents.LogFilterChange, (event) => {
       const detail: LogFilterChangeDetail = (event as CustomEvent).detail;
       if (detail.value.length === 0) {
         component.entries = allEntries;
@@ -168,28 +152,20 @@ describe('LogComponent', () => {
         return entryValue.includes(detail.value);
       });
     });
-    expect(htmlElement.querySelectorAll('.entry').length).toEqual(2);
-    const filterTrigger = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.headers .mat-select-trigger'),
-    );
-    filterTrigger.click();
-    await fixture.whenStable();
+    expect(dom.findAll('.entry').length).toEqual(2);
+    await dom.openMatSelect();
 
-    const firstOption = assertDefined(
-      document.querySelector<HTMLElement>('.mat-select-panel .mat-option'),
-    );
+    const firstOption = dom.getMatSelectPanel().get('.mat-option');
     firstOption.click();
-    fixture.detectChanges();
-    expect(htmlElement.querySelectorAll('.entry').length).toEqual(1);
+    expect(dom.findAll('.entry').length).toEqual(1);
 
     firstOption.click();
-    fixture.detectChanges();
-    expect(htmlElement.querySelectorAll('.entry').length).toEqual(2);
+    expect(dom.findAll('.entry').length).toEqual(2);
   });
 
   it('applies text filter correctly', async () => {
     const allEntries = component.entries.slice();
-    htmlElement.addEventListener(ViewerEvents.LogTextFilterChange, (event) => {
+    dom.addEventListener(ViewerEvents.LogTextFilterChange, (event) => {
       const detail: LogTextFilterChangeDetail = (event as CustomEvent).detail;
       if (detail.filter.filterString.length === 0) {
         component.entries = allEntries;
@@ -202,161 +178,167 @@ describe('LogComponent', () => {
         return entryValue.includes(detail.filter.filterString);
       });
     });
-    expect(htmlElement.querySelectorAll('.entry').length).toEqual(2);
+    expect(dom.findAll('.entry').length).toEqual(2);
 
-    const inputEl = assertDefined(
-      htmlElement.querySelector<HTMLInputElement>('.headers input'),
-    );
+    const inputEl = dom.get('.headers input');
+
+    inputEl.dispatchInput('123');
+    expect(dom.findAll('.entry').length).toEqual(2);
+
+    inputEl.dispatchInput('1234');
+    expect(dom.findAll('.entry').length).toEqual(1);
+
+    inputEl.dispatchInput('12345');
+    expect(dom.findAll('.entry').length).toEqual(0);
 
-    inputEl.value = '123';
-    inputEl.dispatchEvent(new Event('input'));
-    fixture.detectChanges();
-    expect(htmlElement.querySelectorAll('.entry').length).toEqual(2);
-
-    inputEl.value = '1234';
-    inputEl.dispatchEvent(new Event('input'));
-    fixture.detectChanges();
-    expect(htmlElement.querySelectorAll('.entry').length).toEqual(1);
-
-    inputEl.value = '12345';
-    inputEl.dispatchEvent(new Event('input'));
-    fixture.detectChanges();
-    expect(htmlElement.querySelectorAll('.entry').length).toEqual(0);
-
-    inputEl.value = '';
-    inputEl.dispatchEvent(new Event('input'));
-    fixture.detectChanges();
-    expect(htmlElement.querySelectorAll('.entry').length).toEqual(2);
+    inputEl.dispatchInput('');
+    expect(dom.findAll('.entry').length).toEqual(2);
   });
 
   it('emits event on arrow key press', () => {
     let downArrowPressedTimes = 0;
-    htmlElement.addEventListener(ViewerEvents.ArrowDownPress, (event) => {
+    dom.addEventListener(ViewerEvents.ArrowDownPress, (event) => {
       downArrowPressedTimes++;
     });
     let upArrowPressedTimes = 0;
-    htmlElement.addEventListener(ViewerEvents.ArrowUpPress, (event) => {
+    dom.addEventListener(ViewerEvents.ArrowUpPress, (event) => {
       upArrowPressedTimes++;
     });
 
-    document.dispatchEvent(new KeyboardEvent('keydown', {key: 'ArrowUp'}));
+    dom.keydownArrowUp(true);
     expect(upArrowPressedTimes).toEqual(1);
 
-    document.dispatchEvent(new KeyboardEvent('keydown', {key: 'ArrowDown'}));
+    dom.keydownArrowDown(true);
     expect(downArrowPressedTimes).toEqual(1);
 
-    document.dispatchEvent(new KeyboardEvent('keydown', {key: 'ArrowUp'}));
+    dom.keydownArrowUp(true);
     expect(upArrowPressedTimes).toEqual(2);
 
-    document.dispatchEvent(new KeyboardEvent('keydown', {key: 'ArrowDown'}));
+    dom.keydownArrowDown(true);
     expect(downArrowPressedTimes).toEqual(2);
   });
 
   it('propagates entry on trace entry timestamp click', () => {
-    const logTimestampButton = assertDefined(
-      htmlElement.querySelectorAll<HTMLElement>('.time-button').item(1),
-    );
+    const logTimestampButton = dom.findAll('.time-button')[1];
     checkEntryPropagatedOnTimestampClick(logTimestampButton);
   });
 
   it('propagates entry on timestamp click with propagateEntryTimestamp set', () => {
-    const logTimestampButton = assertDefined(
-      htmlElement
-        .querySelectorAll<HTMLElement>(`.${testColumn3.cssClass} button`)
-        .item(1),
-    );
+    const logTimestampButton = dom.findAll(
+      `.${testColumn3.cssClass} button`,
+    )[1];
     checkEntryPropagatedOnTimestampClick(logTimestampButton);
   });
 
   it('propagates timestamp on raw timestamp click', () => {
     let timestamp: Timestamp | undefined;
-    htmlElement.addEventListener(ViewerEvents.TimestampClick, (event) => {
+    dom.addEventListener(ViewerEvents.TimestampClick, (event) => {
       const detail: TimestampClickDetail = (event as CustomEvent).detail;
       timestamp = detail.timestamp;
     });
-    const logTimestampButton = assertDefined(
-      htmlElement.querySelector<HTMLElement>(`.${testColumn3.cssClass} button`),
-    );
-    logTimestampButton.click();
-
+    dom.findAndClick(`.${testColumn3.cssClass} button`);
     expect(timestamp).toBeDefined();
   });
 
   it('does not show button for propagateEntryTimestamp field if entry timestamp invalid', () => {
-    expect(
-      htmlElement.querySelectorAll<HTMLButtonElement>(
-        `.${testColumn3.cssClass} .time-button`,
-      ).length,
-    ).toEqual(2);
+    expect(dom.findAll(`.${testColumn3.cssClass} .time-button`).length).toEqual(
+      2,
+    );
     spyOn(component.entries[1].traceEntry, 'hasValidTimestamp').and.returnValue(
       false,
     );
-    fixture.detectChanges();
-    expect(
-      htmlElement.querySelectorAll<HTMLButtonElement>(
-        `.${testColumn3.cssClass} .time-button`,
-      ).length,
-    ).toEqual(1);
+    dom.detectChanges();
+    expect(dom.findAll(`.${testColumn3.cssClass} .time-button`).length).toEqual(
+      1,
+    );
   });
 
   it('changes css class on entry click and does not scroll', () => {
-    htmlElement.addEventListener(ViewerEvents.LogEntryClick, (event) => {
+    dom.addEventListener(ViewerEvents.LogEntryClick, (event) => {
       const index = (event as CustomEvent).detail;
       component.selectedIndex = index;
-      fixture.detectChanges();
+      dom.detectChanges();
     });
 
-    const entry = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.entry[item-id="1"]'),
-    );
-    expect(entry.className).not.toContain('selected');
+    const entry = dom.get('.entry[item-id="1"]');
+    entry.checkClassName('selected', false);
     const spy = spyOn(
       assertDefined(component.scrollComponent),
       'scrollToIndex',
     );
     entry.click();
     expect(spy).not.toHaveBeenCalled();
-    expect(entry.className).toContain('selected');
+    entry.checkClassName('selected', true);
   });
 
   it('shows placeholder text', () => {
-    expect(htmlElement.querySelector('.placeholder-text')).toBeNull();
+    expect(dom.find('.placeholder-text')).toBeUndefined();
     component.entries = [];
-    fixture.detectChanges();
-    expect(htmlElement.querySelector('.placeholder-text')).toBeTruthy();
+    dom.detectChanges();
+    expect(dom.find('.placeholder-text')).toBeDefined();
     component.isFetchingData = true;
-    fixture.detectChanges();
-    expect(htmlElement.querySelector('.placeholder-text')).toBeNull();
+    dom.detectChanges();
+    expect(dom.find('.placeholder-text')).toBeUndefined();
   });
 
   it('shows fetching data message', () => {
-    expect(htmlElement.querySelector('.fetching-data')).toBeNull();
+    expect(dom.find('.fetching-data')).toBeUndefined();
     component.isFetchingData = true;
-    fixture.detectChanges();
-    expect(htmlElement.querySelector('.fetching-data')).toBeTruthy();
+    dom.detectChanges();
+    expect(dom.find('.fetching-data')).toBeDefined();
   });
 
   it('formats timestamp without date unless multiple dates present', () => {
-    const entry = assertDefined(htmlElement.querySelector('.scroll .entry'));
-    expect(entry.textContent?.trim()).toEqual('1ns Test tag 1123 2ns');
+    const entry = dom.get('.scroll .entry');
+    entry.checkTextExact('1ns Test tag 1123 2ns');
 
     const spy = spyOn(component, 'areMultipleDatesPresent').and.returnValue(
       true,
     );
-    fixture.detectChanges();
-    expect(entry.textContent?.trim()).toEqual('1ns Test tag 1123 2ns');
+    dom.detectChanges();
+    entry.checkTextExact('1ns Test tag 1123 2ns');
 
     setComponentInputData(false);
-    fixture.detectChanges();
-    expect(entry.textContent?.trim()).toEqual(
-      '1970-01-01, 00:00:00.000 Test tag 21234 N/A',
-    );
+    dom.detectChanges();
+    entry.checkTextExact('1970-01-01, 00:00:00.000 Test tag 21234 N/A');
 
     spy.and.returnValue(false);
-    fixture.detectChanges();
-    expect(entry.textContent?.trim()).toEqual(
-      '00:00:00.000 Test tag 21234 N/A',
-    );
+    dom.detectChanges();
+    entry.checkTextExact('00:00:00.000 Test tag 21234 N/A');
+  });
+
+  it('shows copy button for spec that can be copied', () => {
+    const entry = dom.get('.scroll .entry .test-2');
+    expect(entry.find('.copy-button')).toBeUndefined();
+    component.entries[0].fields[1].spec = {
+      name: 'test2',
+      cssClass: 'test-2',
+      canCopy: true,
+    };
+    dom.detectChanges();
+    entry.findAndClick('.copy-button');
+    expect(mockCopyText).toHaveBeenCalledOnceWith('123');
+  });
+
+  it('propagates selected entry on keydown enter event', () => {
+    let entry: TraceEntry<object> | undefined;
+    dom.addEventListener(ViewerEvents.TimestampClick, (event) => {
+      const detail: TimestampClickDetail = (event as CustomEvent).detail;
+      entry = detail.entry;
+    });
+    const keydownEnter = new KeyboardEvent('keydown', {
+      key: KeyboardEventKey.ENTER,
+    });
+
+    component.selectedIndex = undefined;
+    dom.detectChanges();
+    dom.dispatchEventInDocument(keydownEnter);
+    expect(entry).toBeUndefined();
+
+    component.selectedIndex = 1;
+    dom.detectChanges();
+    dom.dispatchEventInDocument(keydownEnter);
+    expect(entry).toEqual(component.entries[1].traceEntry);
   });
 
   function setComponentInputData(elapsed = true) {
@@ -388,10 +370,12 @@ describe('LogComponent', () => {
     const entry1: LogEntry = {
       traceEntry: trace.getEntry(0),
       fields: fields1,
+      getPropertiesTree: undefined,
     };
     const entry2: LogEntry = {
       traceEntry: trace.getEntry(1),
       fields: fields2,
+      getPropertiesTree: undefined,
     };
 
     const entries = [entry1, entry2];
@@ -410,9 +394,11 @@ describe('LogComponent', () => {
     component.traceType = TraceType.CUJS;
   }
 
-  function checkEntryPropagatedOnTimestampClick(button: HTMLElement) {
+  function checkEntryPropagatedOnTimestampClick(
+    button: DOMTestHelper<LogComponent>,
+  ) {
     let entry: TraceEntry<object> | undefined;
-    htmlElement.addEventListener(ViewerEvents.TimestampClick, (event) => {
+    dom.addEventListener(ViewerEvents.TimestampClick, (event) => {
       const detail: TimestampClickDetail = (event as CustomEvent).detail;
       entry = detail.entry;
     });
diff --git a/tools/winscope/src/viewers/components/properties_component_test.ts b/tools/winscope/src/viewers/components/properties_component_test.ts
index 5e08546a6..c9d8f9640 100644
--- a/tools/winscope/src/viewers/components/properties_component_test.ts
+++ b/tools/winscope/src/viewers/components/properties_component_test.ts
@@ -15,11 +15,7 @@
  */
 import {ClipboardModule} from '@angular/cdk/clipboard';
 import {CommonModule} from '@angular/common';
-import {
-  ComponentFixture,
-  ComponentFixtureAutoDetect,
-  TestBed,
-} from '@angular/core/testing';
+import {ComponentFixtureAutoDetect, TestBed} from '@angular/core/testing';
 import {FormsModule, ReactiveFormsModule} from '@angular/forms';
 import {MatButtonModule} from '@angular/material/button';
 import {MatDividerModule} from '@angular/material/divider';
@@ -28,9 +24,9 @@ import {MatIconModule} from '@angular/material/icon';
 import {MatInputModule} from '@angular/material/input';
 import {MatTooltipModule} from '@angular/material/tooltip';
 import {BrowserAnimationsModule} from '@angular/platform-browser/animations';
-import {assertDefined} from 'common/assert_utils';
 import {FilterFlag} from 'common/filter_flag';
 import {PersistentStore} from 'common/store/persistent_store';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
 import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
 import {TraceType} from 'trace/trace_type';
 import {TextFilter} from 'viewers/common/text_filter';
@@ -46,9 +42,8 @@ import {TreeNodeComponent} from './tree_node_component';
 import {UserOptionsComponent} from './user_options_component';
 
 describe('PropertiesComponent', () => {
-  let fixture: ComponentFixture<PropertiesComponent>;
   let component: PropertiesComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<PropertiesComponent>;
 
   beforeEach(async () => {
     await TestBed.configureTestingModule({
@@ -77,10 +72,9 @@ describe('PropertiesComponent', () => {
         ClipboardModule,
       ],
     }).compileComponents();
-
-    fixture = TestBed.createComponent(PropertiesComponent);
+    const fixture = TestBed.createComponent(PropertiesComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
 
     component.store = new PersistentStore();
     component.userOptions = {
@@ -93,7 +87,7 @@ describe('PropertiesComponent', () => {
     component.textFilter = new TextFilter();
     component.traceType = TraceType.SURFACE_FLINGER;
 
-    fixture.detectChanges();
+    dom.detectChanges();
   });
 
   it('can be created', () => {
@@ -101,15 +95,12 @@ describe('PropertiesComponent', () => {
   });
 
   it('creates title', () => {
-    const title = htmlElement.querySelector('.properties-title');
-    expect(title).toBeTruthy();
+    expect(dom.find('.properties-title')).toBeDefined();
   });
 
   it('renders view controls', () => {
-    const viewControls = htmlElement.querySelector('.view-controls');
-    expect(viewControls).toBeTruthy();
-    const box = htmlElement.querySelector('.view-controls .user-option');
-    expect(box).toBeTruthy(); //renders at least one view control option
+    expect(dom.find('.view-controls')).toBeDefined();
+    expect(dom.find('.view-controls .user-option')).toBeDefined(); //renders at least one view control option
   });
 
   it('renders tree in proto dump upon selected item', () => {
@@ -120,18 +111,15 @@ describe('PropertiesComponent', () => {
       .build();
     tree.setIsRoot(true);
     component.propertiesTree = UiPropertyTreeNode.from(tree);
-    fixture.detectChanges();
-    const treeEl = htmlElement.querySelector('tree-view');
-    expect(treeEl).toBeTruthy();
+    dom.detectChanges();
+    expect(dom.find('tree-view')).toBeDefined();
   });
 
   it('renders placeholder text', () => {
     component.propertiesTree = undefined;
     component.placeholderText = 'Placeholder text';
-    fixture.detectChanges();
-    expect(
-      htmlElement.querySelector('.placeholder-text')?.textContent,
-    ).toContain('Placeholder text');
+    dom.detectChanges();
+    dom.get('.placeholder-text').checkTextExact('Placeholder text');
   });
 
   it('handles node click', () => {
@@ -142,54 +130,30 @@ describe('PropertiesComponent', () => {
       .build();
     tree.setIsRoot(true);
     component.propertiesTree = UiPropertyTreeNode.from(tree);
-    fixture.detectChanges();
+    dom.detectChanges();
 
     let highlightedItem: string | undefined;
-    htmlElement.addEventListener(
-      ViewerEvents.HighlightedPropertyChange,
-      (event) => {
-        highlightedItem = (event as CustomEvent).detail.id;
-      },
-    );
+    dom.addEventListener(ViewerEvents.HighlightedPropertyChange, (event) => {
+      highlightedItem = (event as CustomEvent).detail.id;
+    });
 
-    const node = assertDefined(
-      htmlElement.querySelector('tree-node'),
-    ) as HTMLElement;
-    node.click();
-    fixture.detectChanges();
+    dom.findAndClick('tree-node');
     expect(highlightedItem).toEqual(tree.id);
   });
 
   it('handles change in filter', () => {
     let textFilter: TextFilter | undefined;
-    htmlElement.addEventListener(
-      ViewerEvents.PropertiesFilterChange,
-      (event) => {
-        textFilter = (event as CustomEvent).detail;
-      },
-    );
-    const inputEl = assertDefined(
-      htmlElement.querySelector<HTMLInputElement>('.title-section input'),
-    );
-    const flagButton = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.search-box button'),
-    );
-    flagButton.click();
-    fixture.detectChanges();
-
-    inputEl.value = 'Root';
-    inputEl.dispatchEvent(new Event('input'));
-    fixture.detectChanges();
+    dom.addEventListener(ViewerEvents.PropertiesFilterChange, (event) => {
+      textFilter = (event as CustomEvent).detail;
+    });
+    dom.findAndClick('.search-box button');
+    dom.findAndDispatchInput('.title-section', 'Root');
     expect(textFilter).toEqual(new TextFilter('Root', [FilterFlag.MATCH_CASE]));
   });
 
   it('handles collapse button click', () => {
     const spy = spyOn(component.collapseButtonClicked, 'emit');
-    const collapseButton = assertDefined(
-      htmlElement.querySelector('collapsible-section-title button'),
-    ) as HTMLButtonElement;
-    collapseButton.click();
-    fixture.detectChanges();
+    dom.findAndClick('collapsible-section-title button');
     expect(spy).toHaveBeenCalled();
   });
 });
diff --git a/tools/winscope/src/viewers/components/properties_table_component_test.ts b/tools/winscope/src/viewers/components/properties_table_component_test.ts
index 0f65caf96..ad11e5279 100644
--- a/tools/winscope/src/viewers/components/properties_table_component_test.ts
+++ b/tools/winscope/src/viewers/components/properties_table_component_test.ts
@@ -13,11 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-import {ComponentFixture, TestBed} from '@angular/core/testing';
+import {TestBed} from '@angular/core/testing';
 import {PropertiesTableComponent} from './properties_table_component';
 
 describe('PropertiesTableComponent', () => {
-  let fixture: ComponentFixture<PropertiesTableComponent>;
   let component: PropertiesTableComponent;
 
   beforeAll(async () => {
@@ -27,7 +26,7 @@ describe('PropertiesTableComponent', () => {
   });
 
   beforeEach(() => {
-    fixture = TestBed.createComponent(PropertiesTableComponent);
+    const fixture = TestBed.createComponent(PropertiesTableComponent);
     component = fixture.componentInstance;
   });
 
diff --git a/tools/winscope/src/viewers/components/property_tree_node_data_view_component_test.ts b/tools/winscope/src/viewers/components/property_tree_node_data_view_component_test.ts
index 87e0c3c35..c3b5fb8d4 100644
--- a/tools/winscope/src/viewers/components/property_tree_node_data_view_component_test.ts
+++ b/tools/winscope/src/viewers/components/property_tree_node_data_view_component_test.ts
@@ -13,16 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-import {
-  ComponentFixture,
-  ComponentFixtureAutoDetect,
-  TestBed,
-} from '@angular/core/testing';
+import {ComponentFixtureAutoDetect, TestBed} from '@angular/core/testing';
 import {MatButtonModule} from '@angular/material/button';
 import {BrowserAnimationsModule} from '@angular/platform-browser/animations';
 import {assertDefined} from 'common/assert_utils';
 import {TimestampConverterUtils} from 'common/time/test_utils';
 import {Timestamp} from 'common/time/time';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
 import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
 import {
   HEX_FORMATTER,
@@ -33,9 +30,8 @@ import {ViewerEvents} from 'viewers/common/viewer_events';
 import {PropertyTreeNodeDataViewComponent} from './property_tree_node_data_view_component';
 
 describe('PropertyTreeNodeDataViewComponent', () => {
-  let fixture: ComponentFixture<PropertyTreeNodeDataViewComponent>;
   let component: PropertyTreeNodeDataViewComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<PropertyTreeNodeDataViewComponent>;
 
   beforeEach(async () => {
     await TestBed.configureTestingModule({
@@ -43,9 +39,9 @@ describe('PropertyTreeNodeDataViewComponent', () => {
       declarations: [PropertyTreeNodeDataViewComponent],
       imports: [MatButtonModule, BrowserAnimationsModule],
     }).compileComponents();
-    fixture = TestBed.createComponent(PropertyTreeNodeDataViewComponent);
+    const fixture = TestBed.createComponent(PropertyTreeNodeDataViewComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
   });
 
   it('can be created', () => {
@@ -54,7 +50,7 @@ describe('PropertyTreeNodeDataViewComponent', () => {
 
   it('can emit timestamp', () => {
     let timestamp: Timestamp | undefined;
-    htmlElement.addEventListener(ViewerEvents.TimestampClick, (event) => {
+    dom.addEventListener(ViewerEvents.TimestampClick, (event) => {
       timestamp = (event as CustomEvent).detail.timestamp;
     });
     const node = UiPropertyTreeNode.from(
@@ -68,13 +64,9 @@ describe('PropertyTreeNodeDataViewComponent', () => {
         .build(),
     );
     component.node = node;
-    fixture.detectChanges();
-
-    assertDefined(
-      htmlElement.querySelector<HTMLElement>('.time-button'),
-    ).click();
-    fixture.detectChanges();
+    dom.detectChanges();
 
+    dom.findAndClick('.time-button');
     expect(assertDefined(timestamp).format()).toEqual(
       '2022-07-29, 20:34:49.102',
     );
@@ -82,12 +74,9 @@ describe('PropertyTreeNodeDataViewComponent', () => {
 
   it('can emit propagatable node', () => {
     let clickedNode: UiPropertyTreeNode | undefined;
-    htmlElement.addEventListener(
-      ViewerEvents.PropagatePropertyClick,
-      (event) => {
-        clickedNode = (event as CustomEvent).detail;
-      },
-    );
+    dom.addEventListener(ViewerEvents.PropagatePropertyClick, (event) => {
+      clickedNode = (event as CustomEvent).detail;
+    });
     const node = UiPropertyTreeNode.from(
       new PropertyTreeBuilder()
         .setRootId('test node')
@@ -98,14 +87,11 @@ describe('PropertyTreeNodeDataViewComponent', () => {
     );
     node.setCanPropagate(true);
     component.node = node;
-    fixture.detectChanges();
+    dom.detectChanges();
 
-    const button = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.inline button'),
-    );
-    expect(button.textContent?.trim()).toEqual('0x3039');
+    const button = dom.get('.inline button');
+    button.checkTextExact('0x3039');
     button.click();
-    fixture.detectChanges();
     expect(clickedNode).toEqual(node);
   });
 });
diff --git a/tools/winscope/src/viewers/components/rects/canvas.ts b/tools/winscope/src/viewers/components/rects/canvas.ts
index 8698aafeb..8f4f2d3a9 100644
--- a/tools/winscope/src/viewers/components/rects/canvas.ts
+++ b/tools/winscope/src/viewers/components/rects/canvas.ts
@@ -13,7 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-import {ArrayUtils} from 'common/array_utils';
+
+import {equal} from 'common/array_utils';
 import {assertDefined, assertUnreachable} from 'common/assert_utils';
 import {Box3D} from 'common/geometry/box3d';
 import {Point3D} from 'common/geometry/point3d';
@@ -71,6 +72,9 @@ export class Canvas {
     fillRegion: 'graphics_fill_region',
     line: 'graphics_line',
     text: 'graphics_text',
+    pointerCircle: 'pointer_circle',
+    pointerCrosshairs: 'pointer_crosshairs',
+    ray: 'ray',
   };
   private static readonly RECT_EDGE_BOLD_WIDTH = 10;
 
@@ -161,8 +165,8 @@ export class Canvas {
     this.camera.top = cameraHeight / 2;
     this.camera.bottom = -cameraHeight / 2;
     const cPos = new THREE.Vector3(0, 0, Canvas.TARGET_SCENE_DIAGONAL)
-      .applyAxisAngle(new THREE.Vector3(1, 0, 0), -camera.rotationAngleX)
-      .applyAxisAngle(new THREE.Vector3(0, 1, 0), camera.rotationAngleY);
+      .applyAxisAngle(new THREE.Vector3(0, 1, 0), camera.rotationAngleY) // y axis rotation
+      .applyAxisAngle(new THREE.Vector3(1, 0, 0), -camera.rotationAngleX); // x axis rotation
     this.camera.position.set(cPos.x, cPos.y, cPos.z);
     this.camera.lookAt(0, 0, 0);
     this.camera.updateProjectionMatrix();
@@ -175,6 +179,7 @@ export class Canvas {
     for (const key of this.lastScene.rectIdToRectGraphics.keys()) {
       if (!rects.some((rect) => rect.id === key)) {
         this.lastScene.rectIdToRectGraphics.delete(key);
+        this.removeRays(key); // rays are added directly to the scene
         this.scene.remove(assertDefined(this.scene.getObjectByName(key)));
       }
     }
@@ -264,6 +269,9 @@ export class Canvas {
     }
     this.addRectBorders(rect, mesh);
 
+    this.addPointersToRect(rect, mesh);
+    this.addRaysToScene(rect);
+
     mesh.position.x = 0;
     mesh.position.y = 0;
     mesh.position.z = rect.topLeft.z;
@@ -401,9 +409,7 @@ export class Canvas {
     if (rect.cornerRadius) {
       color = Canvas.RECT_EDGE_COLOR_ROUNDED;
     } else {
-      color = this.isDarkMode()
-        ? Canvas.RECT_EDGE_COLOR_DARK_MODE
-        : Canvas.RECT_EDGE_COLOR_LIGHT_MODE;
+      color = this.getRectEdgeColor();
     }
     const edgeMaterial = new THREE.LineBasicMaterial({color});
     const lineSegments = new THREE.LineSegments(edgeGeo, edgeMaterial);
@@ -576,12 +582,135 @@ export class Canvas {
     mesh.add(fillMesh);
   }
 
+  private addPointersToRect(rect: UiRect3D, mesh: THREE.Mesh) {
+    for (const loc of rect.pointerLocationsInRect) {
+      const circle = this.makePointerCircle(loc);
+      circle.position.z = 2; // Prevent z-fighting with the parent mesh
+      circle.name = rect.id + Canvas.GRAPHICS_NAMES.pointerCircle;
+      mesh.add(circle);
+
+      const crosshairs = this.makePointerCrosshairs(rect, loc);
+      crosshairs.position.z = 3; // Prevent z-fighting with the parent or circle mesh
+      crosshairs.name = rect.id + Canvas.GRAPHICS_NAMES.pointerCrosshairs;
+      mesh.add(crosshairs);
+    }
+  }
+
+  private makePointerCircle(center: Point3D): THREE.Mesh {
+    const geometry = new THREE.CircleGeometry(10, 20);
+    const material = this.makeLineMaterialFromRectEdgeColor();
+    const mesh = new THREE.Mesh(geometry, material);
+    mesh.position.set(center.x, center.y, 0);
+    return mesh;
+  }
+
+  private makePointerCrosshairs(rect: UiRect3D, center: Point3D): THREE.Mesh {
+    const t = this.isRectHighlighted(rect) ? 6 : 2;
+    const geometry = new THREE.ShapeGeometry(
+      new THREE.Shape()
+        .moveTo(-40, -t + 0.5)
+        .lineTo(-40, t - 0.5)
+        .quadraticCurveTo(-39.75, t - 0.25, -39.5, t)
+        .lineTo(-t - 0.5, t)
+        .quadraticCurveTo(-t - 0.25, t + 0.25, -t, t + 0.5)
+        .lineTo(-t, 39.5)
+        .quadraticCurveTo(-t + 0.25, 39.75, -t + 0.5, 40)
+        .lineTo(t - 0.5, 40)
+        .quadraticCurveTo(t - 0.25, 39.75, t, 39.5)
+        .lineTo(t, t + 0.5)
+        .quadraticCurveTo(t + 0.25, t + 0.25, t + 0.5, t)
+        .lineTo(39.5, t)
+        .quadraticCurveTo(39.75, t - 0.25, 40, t - 0.5)
+        .lineTo(40, -t + 0.5)
+        .quadraticCurveTo(39.75, -t + 0.25, 39.5, -t)
+        .lineTo(t + 0.5, -t)
+        .quadraticCurveTo(t + 0.25, -t - 0.25, t, -t - 0.5)
+        .lineTo(t, -39.5)
+        .quadraticCurveTo(t - 0.25, -39.75, t - 0.5, -40)
+        .lineTo(-t + 0.5, -40)
+        .quadraticCurveTo(-t + 0.25, -39.75, -t, -39.5)
+        .lineTo(-t, -t - 0.5)
+        .quadraticCurveTo(-t - 0.25, -t - 0.25, -t - 0.5, -t)
+        .lineTo(-39.5, -t)
+        .quadraticCurveTo(-39.75, -t + 0.25, -40, -t + 0.5),
+    );
+
+    const material = this.makeLineMaterialFromRectEdgeColor();
+    const mesh = new THREE.Mesh(geometry, material);
+    mesh.position.set(center.x, center.y, 0);
+    return mesh;
+  }
+
+  private addRaysToScene(rect: UiRect3D) {
+    for (const loc of rect.rayLocationsInScene) {
+      const ray = this.makeRay(loc);
+      ray.name = rect.id + Canvas.GRAPHICS_NAMES.ray;
+      this.scene.add(ray);
+    }
+  }
+
+  private makeRay(center: Point3D): THREE.Line {
+    const geometry = new THREE.BufferGeometry().setFromPoints([
+      new THREE.Vector3(0, 0, 0),
+      new THREE.Vector3(0, 0, 1500),
+    ]);
+    const material = this.makeLineMaterialFromRectEdgeColor();
+    const line = new THREE.Line(geometry, material);
+    line.position.set(center.x, center.y, center.z);
+    return line;
+  }
+
+  private updateRectMeshPointers(
+    newRect: UiRect3D,
+    existingRect: UiRect3D,
+    existingMesh: THREE.Mesh,
+  ) {
+    if (
+      this.pointsEqual(
+        newRect.pointerLocationsInRect,
+        existingRect.pointerLocationsInRect,
+      ) &&
+      newRect.colorType === existingRect.colorType
+    ) {
+      return;
+    }
+    this.removeAllByName(
+      existingMesh,
+      existingRect.id + Canvas.GRAPHICS_NAMES.pointerCircle,
+    );
+    this.removeAllByName(
+      existingMesh,
+      existingRect.id + Canvas.GRAPHICS_NAMES.pointerCrosshairs,
+    );
+    this.addPointersToRect(newRect, existingMesh);
+  }
+
+  private updateRays(newRect: UiRect3D, existingRect: UiRect3D) {
+    if (
+      this.pointsEqual(
+        newRect.rayLocationsInScene,
+        existingRect.rayLocationsInScene,
+      ) &&
+      newRect.colorType === existingRect.colorType
+    ) {
+      return;
+    }
+    this.removeRays(existingRect.id);
+    this.addRaysToScene(newRect);
+  }
+
+  private removeRays(rectId: string) {
+    this.removeAllByName(this.scene, rectId + Canvas.GRAPHICS_NAMES.ray);
+  }
+
   private updateExistingRectMesh(
     newRect: UiRect3D,
     existingRect: UiRect3D,
     existingMesh: THREE.Mesh,
   ): THREE.Mesh {
     this.updateRectMeshFillMaterial(newRect, existingRect, existingMesh);
+    this.updateRectMeshPointers(newRect, existingRect, existingMesh);
+    this.updateRays(newRect, existingRect);
     this.updateRectMeshGeometry(newRect, existingRect, existingMesh);
     return existingMesh;
   }
@@ -611,7 +740,7 @@ export class Canvas {
       existingMesh.material = Canvas.TRANSPARENT_MATERIAL;
       this.addFillRegionMesh(newRect, fillMaterial, existingMesh);
     } else if (newRect.fillRegion && existingRect.fillRegion) {
-      const fillRegionChanged = !ArrayUtils.equal(
+      const fillRegionChanged = !equal(
         newRect.fillRegion,
         existingRect.fillRegion,
         (a, b) => {
@@ -745,9 +874,7 @@ export class Canvas {
   private makeLabelMaterial(label: RectLabel): THREE.LineBasicMaterial {
     return new THREE.LineBasicMaterial({
       color: label.isHighlighted
-        ? this.isDarkMode()
-          ? Canvas.RECT_EDGE_COLOR_DARK_MODE
-          : Canvas.RECT_EDGE_COLOR_LIGHT_MODE
+        ? this.getRectEdgeColor()
         : Canvas.LABEL_LINE_COLOR,
     });
   }
@@ -825,7 +952,7 @@ export class Canvas {
     }
 
     if (
-      !ArrayUtils.equal(newLabel.linePoints, existingLabel.linePoints, (a, b) =>
+      !equal(newLabel.linePoints, existingLabel.linePoints, (a, b) =>
         (a as Point3D).isEqual(b as Point3D),
       )
     ) {
@@ -868,6 +995,39 @@ export class Canvas {
       }
     }
   }
+
+  private removeAllByName(root: THREE.Object3D, name: string) {
+    let existingObj = root.getObjectByName(name);
+    while (existingObj) {
+      root.remove(existingObj);
+      existingObj = root.getObjectByName(name);
+    }
+  }
+
+  private pointsEqual(a: Point3D[], b: Point3D[]): boolean {
+    return equal(a, b, (a, b) => {
+      return a instanceof Point3D && b instanceof Point3D && a.isEqual(b);
+    });
+  }
+
+  private isRectHighlighted(rect: UiRect3D): boolean {
+    return (
+      rect.colorType === ColorType.HIGHLIGHTED ||
+      rect.colorType === ColorType.HIGHLIGHTED_WITH_OPACITY
+    );
+  }
+
+  private makeLineMaterialFromRectEdgeColor(): THREE.LineBasicMaterial {
+    return new THREE.LineBasicMaterial({
+      color: this.getRectEdgeColor(),
+    });
+  }
+
+  private getRectEdgeColor(): number {
+    return this.isDarkMode()
+      ? Canvas.RECT_EDGE_COLOR_DARK_MODE
+      : Canvas.RECT_EDGE_COLOR_LIGHT_MODE;
+  }
 }
 
 interface SceneState {
diff --git a/tools/winscope/src/viewers/components/rects/canvas_test.ts b/tools/winscope/src/viewers/components/rects/canvas_test.ts
index d35e21f6e..81304b695 100644
--- a/tools/winscope/src/viewers/components/rects/canvas_test.ts
+++ b/tools/winscope/src/viewers/components/rects/canvas_test.ts
@@ -14,17 +14,18 @@
  * limitations under the License.
  */
 
+import {equal} from 'common/array_utils';
 import {assertDefined} from 'common/assert_utils';
 import {Box3D} from 'common/geometry/box3d';
 import {Distance} from 'common/geometry/distance';
 import {Point3D} from 'common/geometry/point3d';
 import {IDENTITY_MATRIX} from 'common/geometry/transform_matrix';
+import * as THREE from 'three';
+import {CSS2DObject} from 'three/examples/jsm/renderers/CSS2DRenderer';
 import {
   TransformType,
   TransformTypeFlags,
-} from 'parsers/surface_flinger/transform_utils';
-import * as THREE from 'three';
-import {CSS2DObject} from 'three/examples/jsm/renderers/CSS2DRenderer';
+} from 'trace/surface_flinger/transform_utils';
 import {ViewerEvents} from 'viewers/common/viewer_events';
 import {Camera} from './camera';
 import {Canvas} from './canvas';
@@ -525,40 +526,229 @@ describe('Canvas', () => {
       checkBorderColor(rect.id, Canvas.RECT_EDGE_COLOR_PINNED);
     });
 
+    it('adds pointers', () => {
+      const rect = makeUiRect3D(rectId);
+      rect.pointerLocationsInRect = [
+        new Point3D(2, 2, 2),
+        new Point3D(4, 4, 4),
+      ];
+      canvas.updateRects([rect]);
+      checkNextPointer(rect.pointerLocationsInRect[0], new Point3D(2, 2, 3));
+      checkNextPointer(new Point3D(4, 4, 2), new Point3D(4, 4, 3));
+    });
+
+    it('handles changes in number of pointers', () => {
+      const rect = makeUiRect3D(rectId);
+      rect.pointerLocationsInRect = [new Point3D(2, 2, 2)];
+      canvas.updateRects([rect]);
+      const circleId = getPointerCircle(rectId).id;
+      const crosshairsId = getPointerCrosshairs(rectId).id;
+
+      const rect2 = makeUiRect3D(rectId);
+      rect2.pointerLocationsInRect = [new Point3D(2, 2, 2)];
+      canvas.updateRects([rect2]);
+      expect(getPointerCircle(rectId).id).toEqual(circleId);
+      expect(getPointerCrosshairs(rectId).id).toEqual(crosshairsId);
+      expect(countPointers(rectId)).toEqual(1);
+
+      const rect3 = makeUiRect3D(rectId);
+      rect3.pointerLocationsInRect = [
+        new Point3D(2, 2, 2),
+        new Point3D(1, 2, 2),
+      ];
+      canvas.updateRects([rect3]);
+      expect(getPointerCircle(rectId).id).not.toEqual(circleId);
+      expect(getPointerCrosshairs(rectId).id).not.toEqual(crosshairsId);
+      expect(countPointers(rectId)).toEqual(2);
+
+      const rect4 = makeUiRect3D(rectId);
+      rect4.pointerLocationsInRect = [new Point3D(1, 2, 2)];
+      canvas.updateRects([rect4]);
+      const newCircle = getPointerCircle(rectId);
+      expect(newCircle.id).not.toEqual(circleId);
+      expect(getPointerCrosshairs(rectId).id).not.toEqual(crosshairsId);
+      expect(countPointers(rectId)).toEqual(1);
+      checkVectorEqualToPoint(newCircle.position, new Point3D(1, 2, 2));
+    });
+
+    it('changes pointer thickness', () => {
+      const rect = makeUiRect3D(rectId);
+      rect.pointerLocationsInRect = [new Point3D(2, 2, 2)];
+      canvas.updateRects([rect]);
+      const crosshairs = getPointerCrosshairs(rectId);
+      checkGeometryPosition(crosshairs, [-40, -1.5, 0, -40, 1.5, 0]);
+
+      const rect2 = makeUiRect3D(rectId);
+      rect2.colorType = ColorType.HIGHLIGHTED;
+      rect2.pointerLocationsInRect = [new Point3D(2, 2, 2)];
+      canvas.updateRects([rect2]);
+      const crosshairs2 = getPointerCrosshairs(rectId);
+      checkGeometryPosition(crosshairs2, [-40, -5.5, 0, -40, 5.5, 0]);
+
+      const rect3 = makeUiRect3D(rectId);
+      rect3.colorType = ColorType.HIGHLIGHTED_WITH_OPACITY;
+      rect3.pointerLocationsInRect = [new Point3D(2, 2, 2)];
+      canvas.updateRects([rect3]);
+      const crosshairs3 = getPointerCrosshairs(rectId);
+      checkGeometryPosition(crosshairs3, [-40, -5.5, 0, -40, 5.5, 0]);
+    });
+
+    it('adds rays', () => {
+      const rect = makeUiRect3D(rectId);
+      rect.rayLocationsInScene = [new Point3D(2, 2, 2), new Point3D(4, 4, 4)];
+      canvas.updateRects([rect]);
+      checkNextRay(rect.rayLocationsInScene[0]);
+      checkNextRay(rect.rayLocationsInScene[1]);
+    });
+
+    it('handles changes in number of rays', () => {
+      const rect = makeUiRect3D(rectId);
+      rect.rayLocationsInScene = [new Point3D(2, 3, 4)];
+      canvas.updateRects([rect]);
+      const rayId = getRayLine(rectId).id;
+      const rayName = rectId + Canvas.GRAPHICS_NAMES.ray;
+
+      const rect2 = makeUiRect3D(rectId);
+      rect2.rayLocationsInScene = [new Point3D(2, 3, 4)];
+      canvas.updateRects([rect2]);
+      expect(getRayLine(rectId).id).toEqual(rayId);
+      expect(countObject(rayName, graphicsScene)).toEqual(1);
+
+      const rect3 = makeUiRect3D(rectId);
+      rect3.rayLocationsInScene = [new Point3D(2, 3, 4), new Point3D(4, 4, 4)];
+      canvas.updateRects([rect3]);
+      expect(getRayLine(rectId).id).not.toEqual(rayId);
+      expect(countObject(rayName, graphicsScene)).toEqual(2);
+
+      const rect4 = makeUiRect3D(rectId);
+      rect4.rayLocationsInScene = [new Point3D(4, 4, 4)];
+      canvas.updateRects([rect4]);
+      const newRay = getRayLine(rectId);
+      expect(newRay.id).not.toEqual(rayId);
+      expect(countObject(rayName, graphicsScene)).toEqual(1);
+      checkVectorEqualToPoint(newRay.position, rect4.rayLocationsInScene[0]);
+    });
+
     function checkMaterialColorAndOpacity(
-      mesh: THREE.Mesh,
+      mesh: THREE.Mesh | THREE.Line,
       color: THREE.Color | number,
       opacity: number,
     ) {
       const material = mesh.material as THREE.MeshBasicMaterial;
-      if (color instanceof THREE.Color) {
-        expect(material.color).toEqual(color);
-      } else {
-        expect(material.color.getHex()).toEqual(color);
-      }
+      expect(
+        color instanceof THREE.Color ? material.color : material.color.getHex(),
+      ).toEqual(color);
       expect(material.opacity).toEqual(opacity);
     }
 
     function checkBorderColor(id: string, color: THREE.Color | number) {
       const rectMesh = getRectMesh(id);
-      const borderMesh = assertDefined(
-        rectMesh.getObjectByName(id + Canvas.GRAPHICS_NAMES.border),
-      ) as THREE.Mesh;
-      const meshColor = (borderMesh.material as THREE.LineBasicMaterial).color;
+      const border = getBorders(id + Canvas.GRAPHICS_NAMES.border, rectMesh);
+      const meshColor = border.material.color;
       expect(
         color instanceof THREE.Color ? meshColor : meshColor.getHex(),
       ).toEqual(color);
     }
 
-    function getRectMesh(id: string) {
-      return assertDefined(graphicsScene.getObjectByName(id)) as THREE.Mesh;
+    function getBorders(id: string, root: THREE.Object3D) {
+      const segments = assertDefined(root.getObjectByName(id));
+      return segments as THREE.LineSegments<
+        THREE.EdgesGeometry,
+        THREE.LineBasicMaterial
+      >;
     }
 
-    function getFillRegionMesh(id: string) {
+    function getRectMesh(id: string): THREE.Mesh {
+      return getMesh(id, graphicsScene);
+    }
+
+    function getFillRegionMesh(id: string): THREE.Mesh {
       const rectMesh = getRectMesh(id);
-      return assertDefined(
-        rectMesh.getObjectByName(id + Canvas.GRAPHICS_NAMES.fillRegion),
-      ) as THREE.Mesh;
+      return getMesh(id + Canvas.GRAPHICS_NAMES.fillRegion, rectMesh);
+    }
+
+    function getPointerCircle(id: string): THREE.Mesh {
+      const rectMesh = getRectMesh(id);
+      return getMesh(rectId + Canvas.GRAPHICS_NAMES.pointerCircle, rectMesh);
+    }
+
+    function getPointerCrosshairs(id: string): THREE.Mesh {
+      const rectMesh = getRectMesh(id);
+      return getMesh(
+        rectId + Canvas.GRAPHICS_NAMES.pointerCrosshairs,
+        rectMesh,
+      );
+    }
+
+    function checkNextPointer(expCircle: Point3D, expCrosshairs: Point3D) {
+      const expectedColor = Canvas.RECT_EDGE_COLOR_LIGHT_MODE;
+
+      const circle = getPointerCircle(rectId);
+      expect(
+        (circle.geometry as THREE.CircleGeometry).parameters.radius,
+      ).toEqual(10);
+      checkVectorEqualToPoint(circle.position, expCircle);
+      checkMaterialColorAndOpacity(circle, expectedColor, 1);
+
+      const crosshairs = getPointerCrosshairs(rectId);
+      checkVectorEqualToPoint(crosshairs.position, expCrosshairs);
+      checkMaterialColorAndOpacity(circle, expectedColor, 1);
+
+      // change names so next objects can be retrieved from mesh
+      circle.name = 'circle';
+      crosshairs.name = 'crosshairs';
+    }
+
+    function checkNextRay(expectedPosition: Point3D) {
+      const ray = getRayLine(rectId);
+      checkGeometryPosition(ray, [0, 0, 0, 0, 0, 1500]);
+      checkVectorEqualToPoint(ray.position, expectedPosition);
+      checkMaterialColorAndOpacity(ray, Canvas.RECT_EDGE_COLOR_LIGHT_MODE, 1);
+      ray.name = 'ray'; // change name so next can be retrieved from scene
+    }
+
+    function countPointers(id: string) {
+      const rectMesh = getRectMesh(id);
+      const circleCount = countObject(
+        id + Canvas.GRAPHICS_NAMES.pointerCircle,
+        rectMesh,
+      );
+      const crosshairsCount = countObject(
+        id + Canvas.GRAPHICS_NAMES.pointerCrosshairs,
+        rectMesh,
+      );
+      expect(circleCount).toEqual(crosshairsCount);
+      return circleCount;
+    }
+
+    function countObject(name: string, root: THREE.Object3D) {
+      let obj = root.getObjectByName(name);
+      let count = 0;
+      while (obj) {
+        count++;
+        obj.name = 'obj';
+        obj = root.getObjectByName(name);
+      }
+      return count;
+    }
+
+    function getRayLine(id: string): THREE.Line {
+      return getLine(id + Canvas.GRAPHICS_NAMES.ray, graphicsScene);
+    }
+
+    function checkGeometryPosition(
+      obj: THREE.Mesh | THREE.Line,
+      expected: number[],
+    ) {
+      expect(
+        equal(
+          Array.from(obj.geometry.getAttribute('position').array).slice(
+            0,
+            expected.length,
+          ),
+          expected,
+        ),
+      ).toBeTrue();
     }
 
     function updateRectsAndCheckGeometryId(
@@ -674,7 +864,7 @@ describe('Canvas', () => {
       const label = makeRectLabel(rectId);
       canvas.updateLabels([label]);
       const circleMesh = getCircleMesh(rectId);
-      const line = getLine(rectId);
+      const line = getLabelLine(rectId);
       const text = getText(rectId);
       expect(
         (circleMesh.material as THREE.LineBasicMaterial).color.getHex(),
@@ -718,7 +908,7 @@ describe('Canvas', () => {
     it('handles change in line points', () => {
       const label = makeRectLabel(rectId);
       canvas.updateLabels([label]);
-      const line = getLine(rectId);
+      const line = getLabelLine(rectId);
       const geometryId = line.geometry.id;
 
       const newLabel = makeRectLabel(rectId);
@@ -761,15 +951,11 @@ describe('Canvas', () => {
     });
 
     function getCircleMesh(id: string): THREE.Mesh {
-      return assertDefined(
-        graphicsScene.getObjectByName(id + Canvas.GRAPHICS_NAMES.circle),
-      ) as THREE.Mesh;
+      return getMesh(id + Canvas.GRAPHICS_NAMES.circle, graphicsScene);
     }
 
-    function getLine(id: string): THREE.Line {
-      return assertDefined(
-        graphicsScene.getObjectByName(id + Canvas.GRAPHICS_NAMES.line),
-      ) as THREE.Line;
+    function getLabelLine(id: string): THREE.Line {
+      return getLine(id + Canvas.GRAPHICS_NAMES.line, graphicsScene);
     }
 
     function getText(id: string): CSS2DObject {
@@ -777,12 +963,6 @@ describe('Canvas', () => {
         graphicsScene.getObjectByName(id + Canvas.GRAPHICS_NAMES.text),
       ) as CSS2DObject;
     }
-
-    function checkVectorEqualToPoint(vector: THREE.Vector3, point: Point3D) {
-      expect(
-        vector.equals(new THREE.Vector3(point.x, point.y, point.z)),
-      ).toBeTrue();
-    }
   });
 
   describe('renderView', () => {
@@ -909,6 +1089,8 @@ describe('Canvas', () => {
       isOversized: false,
       fillRegion: undefined,
       isPinned: false,
+      pointerLocationsInRect: [],
+      rayLocationsInScene: [],
     };
   }
 
@@ -922,4 +1104,22 @@ describe('Canvas', () => {
       rectId: id,
     };
   }
+
+  function getMesh(id: string, root: THREE.Object3D): THREE.Mesh {
+    const mesh = assertDefined(root.getObjectByName(id));
+    expect(mesh).toBeInstanceOf(THREE.Mesh);
+    return mesh as THREE.Mesh;
+  }
+
+  function getLine(id: string, root: THREE.Object3D): THREE.Line {
+    const mesh = assertDefined(root.getObjectByName(id));
+    expect(mesh).toBeInstanceOf(THREE.Line);
+    return mesh as THREE.Line;
+  }
+
+  function checkVectorEqualToPoint(vector: THREE.Vector3, point: Point3D) {
+    expect(
+      vector.equals(new THREE.Vector3(point.x, point.y, point.z)),
+    ).toBeTrue();
+  }
 });
diff --git a/tools/winscope/src/viewers/components/rects/mapper3d.ts b/tools/winscope/src/viewers/components/rects/mapper3d.ts
index 4fbd1da3e..bbfbd4cb3 100644
--- a/tools/winscope/src/viewers/components/rects/mapper3d.ts
+++ b/tools/winscope/src/viewers/components/rects/mapper3d.ts
@@ -36,12 +36,10 @@ class Mapper3D {
   private static readonly CAMERA_ROTATION_FACTOR_INIT = 1;
   private static readonly DISPLAY_CLUSTER_SPACING = 750;
   private static readonly LABEL_FIRST_Y_OFFSET = 100;
+  private static readonly LABEL_Y_OFFSET = 500;
+  private static readonly SINGLE_LABEL_Y_OFFSET = 100;
   private static readonly LABEL_CIRCLE_RADIUS = 15;
-  private static readonly LABEL_SPACING_INIT_FACTOR = 12.5;
-  private static readonly LABEL_SPACING_PER_RECT_FACTOR = 5;
-  private static readonly LABEL_SPACING_MIN = 200;
   private static readonly MAX_RENDERED_LABELS = 30;
-  private static readonly SINGLE_LABEL_SPACING_FACTOR = 1.75;
   private static readonly Y_AXIS_ROTATION_FACTOR = 1.5;
   private static readonly Z_FIGHTING_EPSILON = 5;
   private static readonly ZOOM_FACTOR_INIT = 1;
@@ -174,8 +172,6 @@ class Mapper3D {
     const rects3d: UiRect3D[] = [];
     const labels3d: RectLabel[] = [];
     let clusterYOffset = 0;
-    let boundingBox: Box3D | undefined;
-
     for (const groupId of this.currentGroupIds) {
       const rects2dForGroupId = this.selectRectsToDraw(this.rects, groupId);
       rects2dForGroupId.sort(this.compareDepth); // decreasing order of depth
@@ -190,22 +186,25 @@ class Mapper3D {
       rects3d.push(...rects3dForGroupId);
       labels3d.push(...labels3dForGroupId);
 
-      boundingBox = this.computeBoundingBox(rects3d, labels3d);
+      const boundingBox = this.computeBoundingBox(
+        rects3dForGroupId,
+        labels3dForGroupId,
+      );
       clusterYOffset += boundingBox.height + Mapper3D.DISPLAY_CLUSTER_SPACING;
     }
 
-    const newBoundingBox =
-      boundingBox ?? this.computeBoundingBox(rects3d, labels3d);
+    const newBoundingBox = this.computeBoundingBox(rects3d, labels3d);
     if (!this.previousBoundingBox || updateBoundingBox) {
       this.previousBoundingBox = newBoundingBox;
     }
 
-    const angleX = this.getCameraXAxisAngle();
+    const {angleX, angleY} = this.getCameraRotationAngles();
+
     const scene: Scene = {
       boundingBox: this.previousBoundingBox,
       camera: {
         rotationAngleX: angleX,
-        rotationAngleY: angleX * Mapper3D.Y_AXIS_ROTATION_FACTOR,
+        rotationAngleY: angleY,
         zoomFactor: this.zoomFactor,
         panScreenDistance: this.panScreenDistance,
       },
@@ -216,8 +215,12 @@ class Mapper3D {
     return scene;
   }
 
-  private getCameraXAxisAngle(): number {
-    return (this.cameraRotationFactor * Math.PI * 45) / 360;
+  private getCameraRotationAngles(): {angleX: number; angleY: number} {
+    const angleX = (this.cameraRotationFactor * Math.PI * 45) / 360;
+    return {
+      angleX,
+      angleY: angleX * Mapper3D.Y_AXIS_ROTATION_FACTOR,
+    };
   }
 
   private compareDepth(a: UiRect, b: UiRect): number {
@@ -299,6 +302,12 @@ class Mapper3D {
         transform: clusterYOffset ? transform.addTy(clusterYOffset) : transform,
         fillRegion,
         isPinned: this.pinnedItems.some((node) => node.id === rect2d.id),
+        pointerLocationsInRect: rect2d.pointerLocationsInRect.map((p) => {
+          return new Point3D(p.x, p.y, z);
+        }),
+        rayLocationsInScene: rect2d.rayLocationsInDisplay.map((p) => {
+          return new Point3D(p.x, p.y, z);
+        }),
       };
       return this.cropOversizedRect(rect, maxDisplaySize);
     });
@@ -379,89 +388,66 @@ class Mapper3D {
   private computeLabels(rects2d: UiRect[], rects3d: UiRect3D[]): RectLabel[] {
     const labels3d: RectLabel[] = [];
 
+    // Consider coordinate system where x-y plane is computer screen, and z-axis
+    // goes into screen. To give final image, y and x axes are rotated by yRot
+    // and xRot, in that order. Axes origin is (x0, y0, z0).
+    // yRot: [Math.cos(angleY)    0                    Math.sin(angleY)]
+    //       [0                   1                    0               ]
+    //       [-Math.sin(angleY)   0                    Math.cos(angleY)]
+
+    // xRot: [1                   0                    0               ]
+    //       [0                   Math.cos(angleX)    -Math.sin(angleX)]
+    //       [0                   Math.sin(angleX)     Math.cos(angleX)]
+    const {angleX, angleY} = this.getCameraRotationAngles();
+
     const bottomRightCorners = rects3d.map((rect) =>
       rect.transform.transformPoint3D(rect.bottomRight),
     );
-    const lowestYPoint = Math.max(...bottomRightCorners.map((p) => p.y));
-    const rightmostXPoint = Math.max(...bottomRightCorners.map((p) => p.x));
-
-    const cameraTiltFactor =
-      Math.sin(this.getCameraXAxisAngle()) / Mapper3D.Y_AXIS_ROTATION_FACTOR;
-    const labelTextYSpacing = Math.max(
-      ((this.onlyRenderSelectedLabel(rects2d) ? rects2d.length : 1) *
-        Mapper3D.LABEL_SPACING_MIN) /
-        Mapper3D.LABEL_SPACING_PER_RECT_FACTOR,
-      lowestYPoint / Mapper3D.LABEL_SPACING_INIT_FACTOR,
+    const x0 = Math.max(...bottomRightCorners.map((p) => p.x)); // max x in image (furthest right in 2D plane)
+    const y0 = Math.max(...bottomRightCorners.map((p) => p.y)); // max y in image (furthest down in 2D plane)
+    const z0 = rects3d[0]?.bottomRight.z; // depth of first rect
+
+    const onlyHighlighted = this.onlyRenderSelectedLabel(rects2d);
+    const firstLabelScaleFactor = Math.max(
+      Math.min(this.zoomFactor, 1 + (8 - rects2d.length) * 0.05),
+      0.25,
     );
-
-    const scaleFactor = Math.max(
-      Math.min(this.zoomFactor ** 2, 1 + (8 - rects2d.length) * 0.05),
-      0.5,
-    );
-
-    let labelY = lowestYPoint + Mapper3D.LABEL_FIRST_Y_OFFSET / scaleFactor;
-    let lastDepth: number | undefined;
+    const fixedYOffset =
+      y0 + Mapper3D.LABEL_FIRST_Y_OFFSET / firstLabelScaleFactor;
+    const multiLabelYOffset = Mapper3D.LABEL_Y_OFFSET / this.zoomFactor;
+    const singleLabelYOffset = Mapper3D.SINGLE_LABEL_Y_OFFSET / this.zoomFactor;
 
     rects2d.forEach((rect2d, index) => {
       if (!rect2d.label) {
         return;
       }
-      const j = rects2d.length - 1 - index; // rects sorted in decreasing order of depth; increment labelY by depth at L - 1 - i
-      if (this.onlyRenderSelectedLabel(rects2d)) {
-        // only render the selected rect label
-        if (!this.isHighlighted(rect2d)) {
-          return;
-        }
-        labelY +=
-          ((rects2d[j].depth / rects2d[0].depth) *
-            labelTextYSpacing *
-            Mapper3D.SINGLE_LABEL_SPACING_FACTOR *
-            this.zSpacingFactor) /
-          Math.sqrt(scaleFactor);
-      } else {
-        if (lastDepth !== undefined) {
-          labelY += ((lastDepth - j) * labelTextYSpacing) / scaleFactor;
-        }
-        lastDepth = j;
-      }
-
-      const rect3d = rects3d[index];
-
-      const bottomLeft = new Point3D(
-        rect3d.topLeft.x,
-        rect3d.topLeft.y,
-        rect3d.topLeft.z,
-      );
-      const topRight = new Point3D(
-        rect3d.bottomRight.x,
-        rect3d.bottomRight.y,
-        rect3d.bottomRight.z,
-      );
-      const lineStarts = [
-        rect3d.transform.transformPoint3D(rect3d.topLeft),
-        rect3d.transform.transformPoint3D(rect3d.bottomRight),
-        rect3d.transform.transformPoint3D(bottomLeft),
-        rect3d.transform.transformPoint3D(topRight),
-      ];
-      let maxIndex = 0;
-      for (let i = 1; i < lineStarts.length; i++) {
-        if (lineStarts[i].x > lineStarts[maxIndex].x) {
-          maxIndex = i;
-        }
+      const isHighlighted = this.isHighlighted(rect2d);
+      if (onlyHighlighted && !isHighlighted) {
+        return;
       }
-      const lineStart = lineStarts[maxIndex];
-
-      const xDiff = rightmostXPoint - lineStart.x;
+      const lineStart = this.getLabelLineStart(rects3d[index]);
+
+      // To accurately offset label in y-direction of original coordinate
+      // system seen by user, we:
+      // - define vector V from axes origin to rect's corner where label starts
+      // - project V into rotated coordinate system
+      // - apply y-coordinate of projection as offset yOffsetXYRot.
+      const xDiff = x0 - lineStart.x;
+      const yDiff = Math.max(0, lineStart.y - y0);
+      const zDiff = lineStart.z - z0;
+      const V = [xDiff, yDiff, zDiff];
+      const zOffsetYRot = V[0] * -Math.sin(angleY) + V[2] * Math.cos(angleY);
+      const yOffsetXYRot =
+        V[1] * Math.cos(angleX) + zOffsetYRot * -Math.sin(angleX);
+
+      const yOffsetIndex = onlyHighlighted
+        ? singleLabelYOffset
+        : multiLabelYOffset;
+      const lineEndY = fixedYOffset + yOffsetXYRot + index * yOffsetIndex;
 
       lineStart.x += Mapper3D.LABEL_CIRCLE_RADIUS / 2;
 
-      const lineEnd = new Point3D(
-        lineStart.x,
-        labelY + xDiff * cameraTiltFactor,
-        lineStart.z,
-      );
-
-      const isHighlighted = this.isHighlighted(rect2d);
+      const lineEnd = new Point3D(lineStart.x, lineEndY, lineStart.z);
 
       const RectLabel: RectLabel = {
         circle: {
@@ -480,6 +466,32 @@ class Mapper3D {
     return labels3d;
   }
 
+  private getLabelLineStart(rect3d: UiRect3D): Point3D {
+    const bottomLeft = new Point3D(
+      rect3d.topLeft.x,
+      rect3d.bottomRight.y - rect3d.topLeft.y,
+      rect3d.topLeft.z,
+    );
+    const topRight = new Point3D(
+      rect3d.bottomRight.x,
+      rect3d.topLeft.y,
+      rect3d.bottomRight.z,
+    );
+    const lineStarts = [
+      rect3d.transform.transformPoint3D(rect3d.topLeft),
+      rect3d.transform.transformPoint3D(rect3d.bottomRight),
+      rect3d.transform.transformPoint3D(bottomLeft),
+      rect3d.transform.transformPoint3D(topRight),
+    ];
+    let rightmostCoordinateIndex = 0;
+    for (let i = 1; i < lineStarts.length; i++) {
+      if (lineStarts[i].x > lineStarts[rightmostCoordinateIndex].x) {
+        rightmostCoordinateIndex = i;
+      }
+    }
+    return lineStarts[rightmostCoordinateIndex];
+  }
+
   private computeBoundingBox(rects: UiRect3D[], labels: RectLabel[]): Box3D {
     if (rects.length === 0) {
       return {
@@ -512,16 +524,6 @@ class Mapper3D {
     };
 
     rects.forEach((rect) => {
-      /*const topLeft: Point3D = {
-        x: rect.center.x - rect.width / 2,
-        y: rect.center.y + rect.height / 2,
-        z: rect.center.z
-      };
-      const bottomRight: Point3D = {
-        x: rect.center.x + rect.width / 2,
-        y: rect.center.y - rect.height / 2,
-        z: rect.center.z
-      };*/
       updateMinMaxCoordinates(rect.topLeft, rect.transform);
       updateMinMaxCoordinates(rect.bottomRight, rect.transform);
     });
diff --git a/tools/winscope/src/viewers/components/rects/rects_component.ts b/tools/winscope/src/viewers/components/rects/rects_component.ts
index 1804435c0..f458d2a8c 100644
--- a/tools/winscope/src/viewers/components/rects/rects_component.ts
+++ b/tools/winscope/src/viewers/components/rects/rects_component.ts
@@ -695,6 +695,7 @@ export class RectsComponent implements OnInit, OnDestroy {
   @HostListener('wheel', ['$event'])
   onScroll(event: WheelEvent) {
     if ((event.target as HTMLElement).className === 'large-rects-canvas') {
+      event.preventDefault();
       if (event.deltaY > 0) {
         Analytics.Navigation.logZoom('scroll', 'rects', 'out');
         this.doZoomOut(RectsComponent.ZOOM_SCROLL_RATIO);
diff --git a/tools/winscope/src/viewers/components/rects/rects_component_test.ts b/tools/winscope/src/viewers/components/rects/rects_component_test.ts
index eea63f5bd..a5eadb4c1 100644
--- a/tools/winscope/src/viewers/components/rects/rects_component_test.ts
+++ b/tools/winscope/src/viewers/components/rects/rects_component_test.ts
@@ -16,7 +16,7 @@
 
 import {CommonModule} from '@angular/common';
 import {Component, ViewChild} from '@angular/core';
-import {ComponentFixture, TestBed} from '@angular/core/testing';
+import {TestBed} from '@angular/core/testing';
 import {MatButtonModule} from '@angular/material/button';
 import {MatButtonToggleModule} from '@angular/material/button-toggle';
 import {MatDividerModule} from '@angular/material/divider';
@@ -31,9 +31,9 @@ import {assertDefined} from 'common/assert_utils';
 import {Box3D} from 'common/geometry/box3d';
 import {TransformMatrix} from 'common/geometry/transform_matrix';
 import {PersistentStore} from 'common/store/persistent_store';
+import {checkTooltips, DOMTestHelper} from 'test/unit/dom_test_utils';
 import {HierarchyTreeBuilder} from 'test/unit/hierarchy_tree_builder';
-import {UnitTestUtils} from 'test/unit/utils';
-import {waitToBeCalled} from 'test/utils';
+import {waitToBeCalled} from 'test/unit/spy_utils';
 import {TraceType} from 'trace/trace_type';
 import {VISIBLE_CHIP} from 'viewers/common/chip';
 import {DisplayIdentifier} from 'viewers/common/display_identifier';
@@ -60,10 +60,11 @@ describe('RectsComponent', () => {
   const rectGroup0 = makeRectWithGroupId(0);
   const rectGroup1 = makeRectWithGroupId(1);
   const rectGroup2 = makeRectWithGroupId(2);
+  const zoomInSelector = '.zoom-in-button';
+  const largeRectsCanvasSelector = '.large-rects-canvas';
 
   let component: TestHostComponent;
-  let fixture: ComponentFixture<TestHostComponent>;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<TestHostComponent>;
   let updateViewPositionSpy: jasmine.Spy<(camera: Camera, box: Box3D) => void>;
   let updateRectsSpy: jasmine.Spy<(rects: UiRect3D[]) => void>;
   let updateLabelsSpy: jasmine.Spy<(labels: RectLabel[]) => void>;
@@ -101,9 +102,9 @@ describe('RectsComponent', () => {
       ],
     }).compileComponents();
 
-    fixture = TestBed.createComponent(TestHostComponent);
+    const fixture = TestBed.createComponent(TestHostComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
   });
 
   afterEach(() => {
@@ -115,35 +116,32 @@ describe('RectsComponent', () => {
   });
 
   it('renders rotation slider', () => {
-    const slider = htmlElement.querySelector('mat-slider.slider-rotation');
-    expect(slider).toBeTruthy();
+    expect(dom.find('mat-slider.slider-rotation')).toBeDefined();
   });
 
   it('renders separation slider', () => {
-    const slider = htmlElement.querySelector('mat-slider.slider-spacing');
-    expect(slider).toBeTruthy();
+    expect(dom.find('mat-slider.slider-spacing')).toBeDefined();
   });
 
   it('renders canvas', () => {
-    const rectsCanvas = htmlElement.querySelector('.large-rects-canvas');
-    expect(rectsCanvas).toBeTruthy();
+    expect(dom.find(largeRectsCanvasSelector)).toBeDefined();
   });
 
   it('draws scene when input data changes', async () => {
-    fixture.detectChanges();
+    dom.detectChanges();
     const boundingBox = updateViewPositionSpy.calls.mostRecent().args[1];
     resetSpies();
 
     checkAllSpiesCalled(0);
     component.rects = [rectGroup0];
-    fixture.detectChanges();
+    dom.detectChanges();
     checkAllSpiesCalled(1);
     expect(updateViewPositionSpy.calls.mostRecent().args[1]).toEqual(
       boundingBox,
     );
 
     component.rects = [rectGroup0];
-    fixture.detectChanges();
+    dom.detectChanges();
     checkAllSpiesCalled(2);
     expect(updateViewPositionSpy.calls.mostRecent().args[1]).toEqual(
       boundingBox,
@@ -151,9 +149,9 @@ describe('RectsComponent', () => {
   });
 
   it('draws scene when rotation slider changes', () => {
-    fixture.detectChanges();
+    dom.detectChanges();
     resetSpies();
-    const slider = assertDefined(htmlElement.querySelector('.slider-rotation'));
+    const slider = dom.get('.slider-rotation');
 
     checkAllSpiesCalled(0);
     slider.dispatchEvent(new MouseEvent('mousedown'));
@@ -164,9 +162,9 @@ describe('RectsComponent', () => {
   });
 
   it('draws scene when spacing slider changes', () => {
-    fixture.detectChanges();
+    dom.detectChanges();
     resetSpies();
-    const slider = assertDefined(htmlElement.querySelector('.slider-spacing'));
+    const slider = dom.get('.slider-spacing');
 
     checkAllSpiesCalled(0);
     slider.dispatchEvent(new MouseEvent('mousedown'));
@@ -174,18 +172,14 @@ describe('RectsComponent', () => {
   });
 
   it('unfocuses spacing slider on click', () => {
-    fixture.detectChanges();
-    const spacingSlider = assertDefined(
-      htmlElement.querySelector('.slider-spacing'),
-    );
+    dom.detectChanges();
+    const spacingSlider = dom.get('.slider-spacing');
     checkSliderUnfocusesOnClick(spacingSlider, 0.02);
   });
 
   it('unfocuses rotation slider on click', () => {
-    fixture.detectChanges();
-    const rotationSlider = assertDefined(
-      htmlElement.querySelector('.slider-rotation'),
-    );
+    dom.detectChanges();
+    const rotationSlider = dom.get('.slider-rotation');
     checkSliderUnfocusesOnClick(rotationSlider, 1);
   });
 
@@ -209,24 +203,21 @@ describe('RectsComponent', () => {
     await checkSelectedDisplay([0], [0]);
     const boundingBox = updateViewPositionSpy.calls.mostRecent().args[1];
 
-    openDisplaysSelect();
+    dom.openMatSelect();
     const options = getDisplayOptions();
-
-    options.item(1).click();
+    options[1].click();
     await checkSelectedDisplay([0, 1], [0, 1], true);
     expect(updateViewPositionSpy.calls.mostRecent().args[1]).not.toEqual(
       boundingBox,
     );
 
-    options.item(0).click();
+    options[0].click();
     await checkSelectedDisplay([1], [1], true);
 
-    options.item(1).click();
+    options[1].click();
     await checkSelectedDisplay([], [], true);
-    const placeholder = assertDefined(
-      htmlElement.querySelector('.placeholder-text'),
-    );
-    expect(placeholder.textContent?.trim()).toEqual('No displays selected.');
+    const placeholder = dom.get('.placeholder-text');
+    placeholder.checkTextExact('No displays selected.');
   });
 
   it('handles display change by "only" button', async () => {
@@ -238,25 +229,21 @@ describe('RectsComponent', () => {
     ];
     await checkSelectedDisplay([0], [0]);
 
-    openDisplaysSelect();
-
-    const onlyButtons = document.querySelectorAll<HTMLElement>(
-      '.mat-select-panel .mat-option .option-only-button',
-    );
-
-    const display0Button = onlyButtons.item(0);
-    const display1Button = onlyButtons.item(1);
+    dom.openMatSelect();
+    const [display0, display1] = dom
+      .getMatSelectPanel()
+      .findAll('.mat-option .option-only-button');
 
     // no change
-    display0Button.click();
+    display0.click();
     await checkSelectedDisplay([0], [0]);
 
-    display1Button.click();
+    display1.click();
     await checkSelectedDisplay([1], [1]);
 
-    assertDefined(display0Button.parentElement).click();
+    assertDefined(display0.getHTMLElement().parentElement).click();
     await checkSelectedDisplay([0, 1], [0, 1], true);
-    display0Button.click();
+    display0.click();
     await checkSelectedDisplay([0], [0], true);
   });
 
@@ -277,7 +264,7 @@ describe('RectsComponent', () => {
 
   it('updates scene on separation slider change', () => {
     component.rects = [rectGroup0, rectGroup0];
-    fixture.detectChanges();
+    dom.detectChanges();
     const boundingBox = updateViewPositionSpy.calls.mostRecent().args[1];
     updateSeparationSlider();
 
@@ -294,7 +281,7 @@ describe('RectsComponent', () => {
 
   it('updates scene on rotation slider change', () => {
     component.rects = [rectGroup0];
-    fixture.detectChanges();
+    dom.detectChanges();
     const boundingBox = updateViewPositionSpy.calls.mostRecent().args[1];
     updateRotationSlider();
 
@@ -323,7 +310,7 @@ describe('RectsComponent', () => {
 
   it('updates scene on shading mode change', () => {
     component.rects = [rectGroup0];
-    fixture.detectChanges();
+    dom.detectChanges();
     const boundingBox = updateViewPositionSpy.calls.mostRecent().args[1];
 
     updateShadingMode(ShadingMode.GRADIENT, ShadingMode.WIRE_FRAME);
@@ -356,7 +343,7 @@ describe('RectsComponent', () => {
   });
 
   it('uses stored rects view settings', () => {
-    fixture.detectChanges();
+    dom.detectChanges();
 
     updateSeparationSlider();
     updateShadingMode(ShadingMode.GRADIENT, ShadingMode.WIRE_FRAME);
@@ -378,21 +365,20 @@ describe('RectsComponent', () => {
     ];
     await checkSelectedDisplay([0], [0]);
 
-    openDisplaysSelect();
+    dom.openMatSelect();
     const options = getDisplayOptions();
-    options.item(1).click();
+    options[1].click();
     await checkSelectedDisplay([0, 1], [0, 1]);
 
-    const fixtureWithSameDisplays = TestBed.createComponent(TestHostComponent);
-    const componentWithSameDisplays = fixtureWithSameDisplays.componentInstance;
+    const fixtureSameDisplays = TestBed.createComponent(TestHostComponent);
+    const componentWithSameDisplays = fixtureSameDisplays.componentInstance;
     componentWithSameDisplays.rects = component.rects;
     componentWithSameDisplays.displays = component.displays;
     await checkSelectedDisplay(
       [0, 1],
       [0, 1],
       false,
-      fixtureWithSameDisplays,
-      fixtureWithSameDisplays.nativeElement,
+      new DOMTestHelper(fixtureSameDisplays, fixtureSameDisplays.nativeElement),
     );
 
     const fixtureWithDisplay1 = TestBed.createComponent(TestHostComponent);
@@ -405,8 +391,7 @@ describe('RectsComponent', () => {
       [1],
       [1],
       false,
-      fixtureWithDisplay1,
-      fixtureWithDisplay1.nativeElement,
+      new DOMTestHelper(fixtureWithDisplay1, fixtureWithDisplay1.nativeElement),
     );
   });
 
@@ -441,10 +426,8 @@ describe('RectsComponent', () => {
     component.displays = [];
     component.rects = [];
     await checkSelectedDisplay([], []);
-    const placeholder = assertDefined(
-      htmlElement.querySelector('.placeholder-text'),
-    );
-    expect(placeholder.textContent?.trim()).toEqual('No rects found.');
+    const placeholder = dom.get('.placeholder-text');
+    placeholder.checkTextExact('No rects found.');
 
     component.rects = [rectGroup0];
     component.displays = [
@@ -475,11 +458,11 @@ describe('RectsComponent', () => {
     component.displays = [
       {displayId: 10, groupId: 0, name: 'Display 0', isActive: false},
     ];
-    fixture.detectChanges();
+    dom.detectChanges();
     component.rects = [rectGroup0];
     component.miniRects = [rectGroup2];
     resetSpies();
-    fixture.detectChanges();
+    dom.detectChanges();
     checkAllSpiesCalled(2);
     expect(
       updateRectsSpy.calls
@@ -492,7 +475,7 @@ describe('RectsComponent', () => {
     component.displays = [
       {displayId: 10, groupId: 0, name: 'Display 0', isActive: false},
     ];
-    fixture.detectChanges();
+    dom.detectChanges();
 
     updateSeparationSlider();
     updateRotationSlider();
@@ -501,7 +484,7 @@ describe('RectsComponent', () => {
     component.rects = [rectGroup0, rectGroup0];
     component.miniRects = [rectGroup0, rectGroup0];
     resetSpies();
-    fixture.detectChanges();
+    dom.detectChanges();
     checkAllSpiesCalled(2);
 
     const largeRectsCamera = assertDefined(
@@ -529,27 +512,27 @@ describe('RectsComponent', () => {
 
   it('redraws mini rects on change', () => {
     component.miniRects = [rectGroup0, rectGroup0];
-    fixture.detectChanges();
+    dom.detectChanges();
     resetSpies();
 
     component.miniRects = [rectGroup0, rectGroup0];
-    fixture.detectChanges();
+    dom.detectChanges();
     checkAllSpiesCalled(1);
   });
 
   it('handles collapse button click', () => {
-    fixture.detectChanges();
+    dom.detectChanges();
     const spy = spyOn(
       assertDefined(component.rectsComponent).collapseButtonClicked,
       'emit',
     );
-    findAndClickElement('collapsible-section-title button');
+    dom.findAndClick('collapsible-section-title button');
     expect(spy).toHaveBeenCalled();
   });
 
   it('updates scene on pinned items change', () => {
     component.rects = [rectGroup0];
-    fixture.detectChanges();
+    dom.detectChanges();
     resetSpies();
 
     component.pinnedItems = [
@@ -557,7 +540,7 @@ describe('RectsComponent', () => {
         new HierarchyTreeBuilder().setId('test-id').setName('0').build(),
       ),
     ];
-    fixture.detectChanges();
+    dom.detectChanges();
     expect(updateViewPositionSpy).toHaveBeenCalledTimes(0);
     expect(updateRectsSpy).toHaveBeenCalledTimes(1);
     expect(updateLabelsSpy).toHaveBeenCalledTimes(0);
@@ -567,27 +550,27 @@ describe('RectsComponent', () => {
 
   it('emits rect id on rect click', () => {
     component.rects = [rectGroup0];
-    fixture.detectChanges();
+    dom.detectChanges();
 
     const testString = 'test_id';
     let id: string | undefined;
-    htmlElement.addEventListener(ViewerEvents.HighlightedIdChange, (event) => {
+    dom.addEventListener(ViewerEvents.HighlightedIdChange, (event) => {
       id = (event as CustomEvent).detail.id;
     });
 
     const spy = spyOn(Canvas.prototype, 'getClickedRectId').and.returnValue(
       undefined,
     );
-    clickLargeRectsCanvas();
+    dom.findAndClick(largeRectsCanvasSelector);
     expect(id).toBeUndefined();
     spy.and.returnValue(testString);
-    clickLargeRectsCanvas();
+    dom.findAndClick(largeRectsCanvasSelector);
     expect(id).toEqual(testString);
   });
 
   it('pans view without emitting rect id', () => {
     component.rects = [rectGroup0];
-    fixture.detectChanges();
+    dom.detectChanges();
     const cameraBefore = updateViewPositionSpy.calls.mostRecent().args[0];
     expect(cameraBefore.panScreenDistance.dx).toEqual(0);
     expect(cameraBefore.panScreenDistance.dy).toEqual(0);
@@ -597,7 +580,7 @@ describe('RectsComponent', () => {
     const testString = 'test_id';
     spyOn(Canvas.prototype, 'getClickedRectId').and.returnValue(testString);
     let id: string | undefined;
-    htmlElement.addEventListener(ViewerEvents.HighlightedIdChange, (event) => {
+    dom.addEventListener(ViewerEvents.HighlightedIdChange, (event) => {
       id = (event as CustomEvent).detail.id;
     });
 
@@ -613,23 +596,22 @@ describe('RectsComponent', () => {
     expect(cameraAfter.panScreenDistance.dy).toEqual(10);
     expect(boundingBoxAfter).toEqual(boundingBoxBefore);
 
-    clickLargeRectsCanvas();
+    dom.findAndClick(largeRectsCanvasSelector);
     expect(id).toBeUndefined();
 
-    clickLargeRectsCanvas();
+    dom.findAndClick(largeRectsCanvasSelector);
     expect(id).toEqual(testString);
   });
 
   it('handles window resize', async () => {
     component.rects = [rectGroup0];
-    fixture.detectChanges();
+    dom.detectChanges();
     const boundingBox = updateViewPositionSpy.calls.mostRecent().args[1];
     resetSpies();
 
     spyOnProperty(window, 'innerWidth').and.returnValue(window.innerWidth / 2);
     window.dispatchEvent(new Event('resize'));
-    fixture.detectChanges();
-    await fixture.whenStable();
+    await dom.detectChangesAndWaitStable();
     await waitToBeCalled(renderViewSpy, 1);
     expect(updateViewPositionSpy).toHaveBeenCalledTimes(1);
     expect(updateRectsSpy).not.toHaveBeenCalled();
@@ -642,11 +624,11 @@ describe('RectsComponent', () => {
   it('handles change in dark mode', async () => {
     component.rects = [rectGroup0];
     component.miniRects = [rectGroup0];
-    fixture.detectChanges();
+    dom.detectChanges();
     resetSpies();
 
     component.isDarkMode = true;
-    fixture.detectChanges();
+    dom.detectChanges();
     expect(updateRectsSpy).toHaveBeenCalledTimes(2);
     expect(updateLabelsSpy).toHaveBeenCalledTimes(2);
     expect(updateViewPositionSpy).toHaveBeenCalledTimes(1); // only for mini rects
@@ -655,13 +637,13 @@ describe('RectsComponent', () => {
 
   it('handles zoom button clicks', () => {
     component.rects = [rectGroup0];
-    fixture.detectChanges();
+    dom.detectChanges();
     const boundingBox = updateViewPositionSpy.calls.mostRecent().args[1];
     const zoomFactor =
       updateViewPositionSpy.calls.mostRecent().args[0].zoomFactor;
     resetSpies();
 
-    clickZoomInButton();
+    dom.findAndClick(zoomInSelector);
     checkZoomedIn(zoomFactor);
     const zoomedInFactor =
       updateViewPositionSpy.calls.mostRecent().args[0].zoomFactor;
@@ -670,7 +652,7 @@ describe('RectsComponent', () => {
     );
     resetSpies();
 
-    findAndClickElement('.zoom-out-button');
+    dom.findAndClick('.zoom-out-button');
     checkZoomedOut(zoomedInFactor);
     expect(updateViewPositionSpy.calls.mostRecent().args[1]).toEqual(
       boundingBox,
@@ -679,48 +661,50 @@ describe('RectsComponent', () => {
 
   it('handles zoom change via scroll event', () => {
     component.rects = [rectGroup0];
-    fixture.detectChanges();
+    dom.detectChanges();
     const zoomFactor =
       updateViewPositionSpy.calls.mostRecent().args[0].zoomFactor;
     resetSpies();
 
-    const rectsElement = assertDefined(htmlElement.querySelector('rects-view'));
+    const rectsElement = dom.get('rects-view');
 
     const zoomInEvent = new WheelEvent('wheel');
     Object.defineProperty(zoomInEvent, 'target', {
-      value: htmlElement.querySelector('.large-rects-canvas'),
+      value: dom.get(largeRectsCanvasSelector).getHTMLElement(),
     });
     Object.defineProperty(zoomInEvent, 'deltaY', {value: 0});
+    spyOn(zoomInEvent, 'preventDefault').and.callThrough();
     rectsElement.dispatchEvent(zoomInEvent);
-    fixture.detectChanges();
-
+    expect(zoomInEvent.preventDefault).toHaveBeenCalledTimes(1);
     checkZoomedIn(zoomFactor);
+
     const zoomedInFactor =
       updateViewPositionSpy.calls.mostRecent().args[0].zoomFactor;
     resetSpies();
 
     const zoomOutEvent = new WheelEvent('wheel');
     Object.defineProperty(zoomOutEvent, 'target', {
-      value: htmlElement.querySelector('.large-rects-canvas'),
+      value: dom.get(largeRectsCanvasSelector).getHTMLElement(),
     });
     Object.defineProperty(zoomOutEvent, 'deltaY', {value: 1});
+    spyOn(zoomOutEvent, 'preventDefault').and.callThrough();
     rectsElement.dispatchEvent(zoomOutEvent);
-    fixture.detectChanges();
+    expect(zoomOutEvent.preventDefault).toHaveBeenCalledTimes(1);
     checkZoomedOut(zoomedInFactor);
   });
 
   it('handles reset button click', () => {
     component.rects = [rectGroup0];
-    fixture.detectChanges();
+    dom.detectChanges();
     const [camera, boundingBox] = updateViewPositionSpy.calls.mostRecent().args;
 
     updateRotationSlider();
     updateSeparationSlider();
-    clickZoomInButton();
+    dom.findAndClick(zoomInSelector);
     panView();
     resetSpies();
 
-    findAndClickElement('.reset-button');
+    dom.findAndClick('.reset-button');
     checkAllSpiesCalled(1);
     const [newCamera, newBoundingBox] =
       updateViewPositionSpy.calls.mostRecent().args;
@@ -730,14 +714,14 @@ describe('RectsComponent', () => {
 
   it('handles change in highlighted item', () => {
     component.rects = [rectGroup0];
-    fixture.detectChanges();
+    dom.detectChanges();
     expect(updateRectsSpy.calls.mostRecent().args[0][0].colorType).toEqual(
       ColorType.VISIBLE,
     );
     resetSpies();
 
     component.highlightedItem = rectGroup0.id;
-    fixture.detectChanges();
+    dom.detectChanges();
 
     expect(updateViewPositionSpy).not.toHaveBeenCalled();
     expect(updateRectsSpy).toHaveBeenCalledTimes(1);
@@ -750,7 +734,7 @@ describe('RectsComponent', () => {
 
   it('handles rect double click', () => {
     component.rects = [rectGroup0];
-    fixture.detectChanges();
+    dom.detectChanges();
     resetSpies();
 
     const testString = 'test_id';
@@ -758,53 +742,45 @@ describe('RectsComponent', () => {
       undefined,
     );
     let detail: RectDblClickDetail | undefined;
-    htmlElement.addEventListener(ViewerEvents.RectsDblClick, (event) => {
+    dom.addEventListener(ViewerEvents.RectsDblClick, (event) => {
       detail = (event as CustomEvent).detail;
     });
 
-    const canvas = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.large-rects-canvas'),
-    );
-    canvas.dispatchEvent(new MouseEvent('dblclick'));
-    fixture.detectChanges();
+    const canvas = dom.get(largeRectsCanvasSelector);
+    canvas.doubleClick();
     expect(detail).toBeUndefined();
     spy.and.returnValue(testString);
 
-    canvas.dispatchEvent(new MouseEvent('dblclick'));
-    fixture.detectChanges();
+    canvas.doubleClick();
     expect(detail).toEqual(new RectDblClickDetail(testString));
   });
 
   it('handles mini rect double click', () => {
     component.rects = [rectGroup0];
-    fixture.detectChanges();
+    dom.detectChanges();
     resetSpies();
 
     let miniRectDoubleClick = false;
-    htmlElement.addEventListener(ViewerEvents.MiniRectsDblClick, (event) => {
+    dom.addEventListener(ViewerEvents.MiniRectsDblClick, (event) => {
       miniRectDoubleClick = true;
     });
 
-    const canvas = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.mini-rects-canvas'),
-    );
-    canvas.dispatchEvent(new MouseEvent('dblclick'));
-    fixture.detectChanges();
+    dom.get('.mini-rects-canvas').doubleClick();
     expect(miniRectDoubleClick).toBeTrue();
   });
 
   it('does not render more that selected label if over 30 rects', () => {
     component.rects = Array.from({length: 30}, () => rectGroup0);
-    fixture.detectChanges();
+    dom.detectChanges();
     expect(updateLabelsSpy.calls.mostRecent().args[0].length).toEqual(30);
 
     const newRect = makeRectWithGroupId(0, true, 'new rect');
     component.rects = component.rects.concat([newRect]);
-    fixture.detectChanges();
+    dom.detectChanges();
     expect(updateLabelsSpy.calls.mostRecent().args[0].length).toEqual(0);
 
     component.highlightedItem = newRect.id;
-    fixture.detectChanges();
+    dom.detectChanges();
     expect(updateLabelsSpy.calls.mostRecent().args[0].length).toEqual(1);
   });
 
@@ -814,37 +790,37 @@ describe('RectsComponent', () => {
       {displayId: 0, groupId: 0, name: 'Display 0', isActive: false},
       {displayId: 1, groupId: 1, name: 'Display 1', isActive: false},
     ];
-    fixture.detectChanges();
+    dom.detectChanges();
     await checkSelectedDisplay([0], [0]);
     expect(updateLabelsSpy.calls.mostRecent().args[0].length).toEqual(1);
 
     component.rects = component.rects.concat([rectGroup1]);
-    fixture.detectChanges();
-    openDisplaysSelect();
-    getDisplayOptions().item(1).click();
+    dom.detectChanges();
+    dom.openMatSelect();
+    getDisplayOptions()[1].click();
     await checkSelectedDisplay([0, 1], [0, 1], true);
 
     expect(updateLabelsSpy.calls.mostRecent().args[0].length).toEqual(0);
 
     component.highlightedItem = rectGroup0.id;
-    fixture.detectChanges();
+    dom.detectChanges();
     expect(updateLabelsSpy.calls.mostRecent().args[0].length).toEqual(1);
   });
 
   it('handles rect type button click', async () => {
     let clicked: TraceRectType | undefined;
-    htmlElement.addEventListener(ViewerEvents.RectTypeButtonClick, (event) => {
+    dom.addEventListener(ViewerEvents.RectTypeButtonClick, (event) => {
       clicked = (event as CustomEvent).detail.type;
     });
-    expect(htmlElement.querySelector('.rect-type-toggle')).toBeNull();
+    expect(dom.find('.rect-type-toggle')).toBeUndefined();
 
     component.rectSpec = {
       type: TraceRectType.LAYERS,
       icon: 'layers',
       legend: [],
     };
-    fixture.detectChanges();
-    expect(htmlElement.querySelector('.rect-type-toggle')).toBeNull();
+    dom.detectChanges();
+    expect(dom.find('.rect-type-toggle')).toBeUndefined();
 
     component.allRectSpecs = [
       component.rectSpec,
@@ -854,22 +830,14 @@ describe('RectsComponent', () => {
         legend: [],
       },
     ];
-    fixture.detectChanges();
-    const buttons = Array.from(
-      htmlElement.querySelectorAll<HTMLElement>('.rect-type-icon'),
-    );
-    expect(buttons[0].textContent?.trim()).toEqual('layers');
-    expect(buttons[1].textContent?.trim()).toEqual('touch_app');
-    await UnitTestUtils.checkTooltips(
-      buttons,
-      ['Show layers', 'Show input windows'],
-      fixture,
-    );
+    dom.detectChanges();
+    const buttons = dom.findAll('.rect-type-icon');
+    buttons[0].checkTextExact('layers');
+    buttons[1].checkTextExact('touch_app');
+    await checkTooltips(buttons, ['Show layers', 'Show input windows']);
     buttons[0].click();
-    fixture.detectChanges();
     expect(clicked).toBeUndefined();
     buttons[1].click();
-    fixture.detectChanges();
     expect(clicked).toEqual(TraceRectType.INPUT_WINDOWS);
   });
 
@@ -879,31 +847,33 @@ describe('RectsComponent', () => {
       icon: 'layers',
       legend: [],
     };
-    fixture.detectChanges();
-    expect(htmlElement.querySelector('.warning')).toBeNull();
+    dom.detectChanges();
+    expect(dom.find('.warning')).toBeUndefined();
 
     component.rectSpec = {
       type: TraceRectType.INPUT_WINDOWS,
       icon: 'touch_app',
       legend: [],
     };
-    fixture.detectChanges();
-    const warning = assertDefined(htmlElement.querySelector('.warning'));
-    expect(
-      warning.querySelector('.warning-message')?.textContent?.trim(),
-    ).toEqual('Showing input windows - change rect type via toggle above');
+    dom.detectChanges();
+    const warning = dom.get('.warning');
+    warning
+      .get('.warning-message')
+      .checkTextExact(
+        'Showing input windows - change rect type via toggle above',
+      );
 
     component.rectSpec = {
       type: TraceRectType.LAYERS,
       icon: 'layers',
       legend: [],
     };
-    fixture.detectChanges();
-    expect(htmlElement.querySelector('.warning')).toBeNull();
+    dom.detectChanges();
+    expect(dom.find('.warning')).toBeUndefined();
   });
 
   it('provides legend from rect spec', () => {
-    expect(htmlElement.querySelector('.rect-legend')).toBeNull();
+    expect(dom.find('.rect-legend')).toBeUndefined();
     const legend = [
       {
         fill: 'blue',
@@ -928,48 +898,40 @@ describe('RectsComponent', () => {
       icon: 'layers',
       legend,
     };
-    fixture.detectChanges();
-    const legendEl = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.rect-legend'),
-    );
-    expect(legendEl.querySelector('.rect-legend-expand-button')).toBeNull();
+    dom.detectChanges();
+    const legendEl = dom.get('.rect-legend');
+    expect(legendEl.find('.rect-legend-expand-button')).toBeUndefined();
 
-    const optionsWrapper = assertDefined(
-      legendEl.querySelector<HTMLElement>('.shading-opts'),
-    );
-    expect(optionsWrapper.className).not.toContain('force-show-all');
+    const optionsWrapper = dom.get('.shading-opts');
+    optionsWrapper.checkClassName('force-show-all', false);
 
-    let options = optionsWrapper.querySelectorAll<HTMLElement>('.shading-opt');
+    let options = optionsWrapper.findAll('.shading-opt');
     expect(options.length).toEqual(3);
     options.forEach((option, i) => checkShadingOpt(option, i, legend));
 
     updateShadingMode(ShadingMode.GRADIENT, ShadingMode.WIRE_FRAME);
-    options = optionsWrapper.querySelectorAll<HTMLElement>('.shading-opt');
+    options = optionsWrapper.findAll('.shading-opt');
     expect(options.length).toEqual(2);
     options.forEach((option, i) => checkShadingOpt(option, i + 1, legend));
 
-    optionsWrapper.style.width = optionsWrapper.clientWidth / 2 + 'px';
-    fixture.detectChanges(); // halve wrapper width so options no longer all fit
-    const expandButton = assertDefined(
-      legendEl.querySelector<HTMLElement>('.rect-legend-expand-button'),
-    );
-    expect(expandButton.textContent).toEqual('more_horiz');
+    const wrapperEl = optionsWrapper.getHTMLElement();
+    wrapperEl.style.width = wrapperEl.clientWidth / 2 + 'px';
+    dom.detectChanges(); // halve wrapper width so options no longer all fit
+    const expandButton = legendEl.get('.rect-legend-expand-button');
+    expandButton.checkTextExact('more_horiz');
     expandButton.click();
-    fixture.detectChanges();
-    expect(optionsWrapper.className).toContain('force-show-all');
-    expect(expandButton.textContent).toEqual('expand_circle_down');
+    optionsWrapper.checkClassName('force-show-all', true);
+    expandButton.checkTextExact('expand_circle_down');
 
     expandButton.click();
-    fixture.detectChanges();
-    expect(expandButton.textContent).toEqual('more_horiz');
-    expect(optionsWrapper.className).not.toContain('force-show-all');
+    expandButton.checkTextExact('more_horiz');
+    optionsWrapper.checkClassName('force-show-all', false);
 
-    expandButton.click();
-    fixture.detectChanges(); // click again to show expanded view
+    expandButton.click(); // click again to show expanded view
 
-    optionsWrapper.style.width = '';
-    fixture.detectChanges(); // button disappears now that options all fit in available space
-    expect(legendEl.querySelector('.rect-legend-expand-button')).toBeNull();
+    wrapperEl.style.width = '';
+    dom.detectChanges(); // button disappears now that options all fit in available space
+    expect(legendEl.find('.rect-legend-expand-button')).toBeUndefined();
   });
 
   function resetSpies() {
@@ -985,14 +947,12 @@ describe('RectsComponent', () => {
     displayNumbers: number[],
     testIds: number[],
     changeInBoundingBox?: boolean,
-    f = fixture,
-    el = htmlElement,
+    d = dom,
   ) {
-    f.detectChanges();
-    await f.whenStable();
-    f.detectChanges();
-    const displaySelect = assertDefined(el.querySelector('.displays-select'));
-    expect(displaySelect.textContent?.trim()).toEqual(
+    await d.detectChangesAndWaitStable();
+    d.detectChanges();
+    const displaySelect = d.get('.displays-select');
+    displaySelect.checkTextExact(
       displayNumbers
         .map((displayNumber) => `Display ${displayNumber}`)
         .join(', '),
@@ -1012,22 +972,17 @@ describe('RectsComponent', () => {
     }
   }
 
-  function findAndClickElement(selector: string) {
-    const el = assertDefined(htmlElement.querySelector<HTMLElement>(selector));
-    el.click();
-    fixture.detectChanges();
-  }
-
-  function checkSliderUnfocusesOnClick(slider: Element, expectedValue: number) {
+  function checkSliderUnfocusesOnClick(
+    slider: DOMTestHelper<TestHostComponent>,
+    expectedValue: number,
+  ) {
     const rectsComponent = assertDefined(component.rectsComponent);
     slider.dispatchEvent(new MouseEvent('mousedown'));
     slider.dispatchEvent(new MouseEvent('mouseup'));
     expect(rectsComponent.getZSpacingFactor()).toEqual(expectedValue);
-    htmlElement.dispatchEvent(
-      new KeyboardEvent('keydown', {key: 'ArrowRight'}),
-    );
+    dom.keydownArrowRight();
     expect(rectsComponent.getZSpacingFactor()).toEqual(expectedValue);
-    htmlElement.dispatchEvent(new KeyboardEvent('keydown', {key: 'ArrowLeft'}));
+    dom.keydownArrowLeft();
     expect(rectsComponent.getZSpacingFactor()).toEqual(expectedValue);
   }
 
@@ -1035,20 +990,20 @@ describe('RectsComponent', () => {
     const rectsComponent = assertDefined(component.rectsComponent);
     expect(rectsComponent.getZSpacingFactor()).toEqual(1);
     rectsComponent.onSeparationSliderChange(0.06);
-    fixture.detectChanges();
+    dom.detectChanges();
     expect(rectsComponent.getZSpacingFactor()).toEqual(0.06);
   }
 
   function updateRotationSlider() {
     const rectsComponent = assertDefined(component.rectsComponent);
     rectsComponent.onRotationSliderChange(0.5);
-    fixture.detectChanges();
+    dom.detectChanges();
   }
 
   function updateShadingMode(before: ShadingMode, after: ShadingMode) {
     const rectsComponent = assertDefined(component.rectsComponent);
     expect(rectsComponent.getShadingMode()).toEqual(before);
-    findAndClickElement('.right-btn-container button.shading-mode');
+    dom.findAndClick('.right-btn-container button.shading-mode');
     expect(rectsComponent.getShadingMode()).toEqual(after);
   }
 
@@ -1086,24 +1041,13 @@ describe('RectsComponent', () => {
   }
 
   function panView() {
-    const canvas = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.large-rects-canvas'),
-    );
+    const canvas = dom.get(largeRectsCanvasSelector);
     canvas.dispatchEvent(new MouseEvent('mousedown'));
     const mouseMoveEvent = new MouseEvent('mousemove');
     Object.defineProperty(mouseMoveEvent, 'movementX', {value: 5});
     Object.defineProperty(mouseMoveEvent, 'movementY', {value: 10});
-    document.dispatchEvent(mouseMoveEvent);
-    document.dispatchEvent(new MouseEvent('mouseup'));
-    fixture.detectChanges();
-  }
-
-  function clickZoomInButton() {
-    findAndClickElement('.zoom-in-button');
-  }
-
-  function clickLargeRectsCanvas() {
-    findAndClickElement('.large-rects-canvas');
+    dom.dispatchEventInDocument(mouseMoveEvent);
+    dom.dispatchEventInDocument(new MouseEvent('mouseup'));
   }
 
   function checkZoomedIn(oldZoomFactor: number) {
@@ -1126,14 +1070,8 @@ describe('RectsComponent', () => {
     ).toBeLessThan(oldZoomFactor);
   }
 
-  function openDisplaysSelect() {
-    findAndClickElement('.displays-section .mat-select-trigger');
-  }
-
   function getDisplayOptions() {
-    return document.querySelectorAll<HTMLElement>(
-      '.mat-select-panel .mat-option',
-    );
+    return dom.getMatSelectPanel().findAll('.mat-option');
   }
 
   function checkAllSpiesCalled(times: number) {
@@ -1146,14 +1084,14 @@ describe('RectsComponent', () => {
   }
 
   function checkShadingOpt(
-    option: HTMLElement,
+    option: DOMTestHelper<TestHostComponent>,
     i: number,
     l: RectLegendOption[],
   ) {
-    const square = assertDefined(option.querySelector<HTMLElement>('.square'));
+    const square = option.get('.square').getHTMLElement();
     expect(square.style.backgroundColor).toEqual(l[i].fill ?? '');
     expect(square.style.borderColor).toEqual(l[i].border);
-    expect(option.textContent).toEqual(
+    option.checkTextExact(
       l[i].fill !== undefined ? l[i].desc : 'question_mark' + l[i].desc,
     );
   }
diff --git a/tools/winscope/src/viewers/components/rects/ui_rect.ts b/tools/winscope/src/viewers/components/rects/ui_rect.ts
index 4a5ae4dfe..4460c7e0d 100644
--- a/tools/winscope/src/viewers/components/rects/ui_rect.ts
+++ b/tools/winscope/src/viewers/components/rects/ui_rect.ts
@@ -14,6 +14,7 @@
  * limitations under the License.
  */
 
+import {Point} from 'common/geometry/point';
 import {Rect} from 'common/geometry/rect';
 import {Region} from 'common/geometry/region';
 import {TransformMatrix} from 'common/geometry/transform_matrix';
@@ -37,6 +38,8 @@ export class UiRect extends Rect {
     readonly hasContent: boolean | undefined,
     readonly opacity: number | undefined,
     readonly fillRegion: Region | undefined,
+    readonly pointerLocationsInRect: Point[] = [],
+    readonly rayLocationsInDisplay: Point[] = [],
   ) {
     super(x, y, w, h);
   }
diff --git a/tools/winscope/src/viewers/components/rects/ui_rect3d.ts b/tools/winscope/src/viewers/components/rects/ui_rect3d.ts
index f6cbb4f00..29d1558dc 100644
--- a/tools/winscope/src/viewers/components/rects/ui_rect3d.ts
+++ b/tools/winscope/src/viewers/components/rects/ui_rect3d.ts
@@ -31,4 +31,6 @@ export interface UiRect3D extends Rect3D {
   isOversized: boolean;
   fillRegion: Rect3D[] | undefined;
   isPinned: boolean;
+  pointerLocationsInRect: Point3D[];
+  rayLocationsInScene: Point3D[];
 }
diff --git a/tools/winscope/src/viewers/components/rects/ui_rect_builder.ts b/tools/winscope/src/viewers/components/rects/ui_rect_builder.ts
index 9d15ef113..0fce3dd6f 100644
--- a/tools/winscope/src/viewers/components/rects/ui_rect_builder.ts
+++ b/tools/winscope/src/viewers/components/rects/ui_rect_builder.ts
@@ -14,6 +14,7 @@
  * limitations under the License.
  */
 
+import {Point} from 'common/geometry/point';
 import {Region} from 'common/geometry/region';
 import {TransformMatrix} from 'common/geometry/transform_matrix';
 import {UiRect} from './ui_rect';
@@ -36,6 +37,8 @@ export class UiRectBuilder {
   hasContent: boolean | undefined;
   opacity: number | undefined;
   fillRegion: Region | undefined;
+  pointerLocationsInRect: Point[] = [];
+  rayLocationsInDisplay: Point[] = [];
 
   setX(value: number) {
     this.x = value;
@@ -117,8 +120,18 @@ export class UiRectBuilder {
     return this;
   }
 
-  setFillRegion(region: Region | undefined) {
-    this.fillRegion = region;
+  setFillRegion(value: Region | undefined) {
+    this.fillRegion = value;
+    return this;
+  }
+
+  setPointerLocationsInRect(value: Point[]) {
+    this.pointerLocationsInRect = value;
+    return this;
+  }
+
+  setRayLocationsInDisplay(value: Point[]) {
+    this.rayLocationsInDisplay = value;
     return this;
   }
 
@@ -193,6 +206,8 @@ export class UiRectBuilder {
       this.hasContent,
       this.opacity,
       this.fillRegion,
+      this.pointerLocationsInRect,
+      this.rayLocationsInDisplay,
     );
   }
 }
diff --git a/tools/winscope/src/viewers/components/search_box_component.ts b/tools/winscope/src/viewers/components/search_box_component.ts
index 36f77cbcf..1c086ae91 100644
--- a/tools/winscope/src/viewers/components/search_box_component.ts
+++ b/tools/winscope/src/viewers/components/search_box_component.ts
@@ -18,6 +18,7 @@ import {Component, EventEmitter, Input, Output} from '@angular/core';
 import {assertDefined} from 'common/assert_utils';
 import {FilterFlag} from 'common/filter_flag';
 import {TextFilter} from 'viewers/common/text_filter';
+import {AbstractFormFieldComponent} from './abstract_form_field_component';
 
 @Component({
   selector: 'search-box',
@@ -28,7 +29,10 @@ import {TextFilter} from 'viewers/common/text_filter';
       [appearance]="appearance"
       [style.height]="height"
       (keydown.esc)="$event.target.blur()"
-      (keydown.enter)="$event.target.blur()">
+      (keydown.enter)="$event.target.blur()"
+      [matTooltip]="label"
+      matTooltipPosition="above"
+      [matTooltipDisabled]="disableTooltip(formField)" #formField>
       <mat-label>{{ label }}</mat-label>
       <input
         matInput
@@ -75,14 +79,11 @@ import {TextFilter} from 'viewers/common/text_filter';
   `,
   ],
 })
-export class SearchBoxComponent {
+export class SearchBoxComponent extends AbstractFormFieldComponent {
   FilterFlag = FilterFlag;
 
   @Input() textFilter: TextFilter | undefined = new TextFilter();
-  @Input() label = 'Search';
   @Input() filterName = 'filter';
-  @Input() appearance = '';
-  @Input() formFieldClass = '';
   @Input() height = '48px';
 
   @Output() readonly filterChange = new EventEmitter<TextFilter>();
diff --git a/tools/winscope/src/viewers/components/search_box_component_test.ts b/tools/winscope/src/viewers/components/search_box_component_test.ts
index ba9d8907e..50289219d 100644
--- a/tools/winscope/src/viewers/components/search_box_component_test.ts
+++ b/tools/winscope/src/viewers/components/search_box_component_test.ts
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-import {ComponentFixture, TestBed} from '@angular/core/testing';
+import {TestBed} from '@angular/core/testing';
 import {FormsModule} from '@angular/forms';
 import {MatButtonModule} from '@angular/material/button';
 import {MatFormFieldModule} from '@angular/material/form-field';
@@ -22,15 +22,14 @@ import {MatIconModule} from '@angular/material/icon';
 import {MatInputModule} from '@angular/material/input';
 import {MatTooltipModule} from '@angular/material/tooltip';
 import {BrowserAnimationsModule} from '@angular/platform-browser/animations';
-import {assertDefined} from 'common/assert_utils';
 import {FilterFlag} from 'common/filter_flag';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
 import {TextFilter} from 'viewers/common/text_filter';
 import {SearchBoxComponent} from './search_box_component';
 
 describe('SearchBoxComponent', () => {
-  let fixture: ComponentFixture<SearchBoxComponent>;
   let component: SearchBoxComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<SearchBoxComponent>;
 
   beforeEach(async () => {
     await TestBed.configureTestingModule({
@@ -45,11 +44,11 @@ describe('SearchBoxComponent', () => {
       ],
       declarations: [SearchBoxComponent],
     }).compileComponents();
-    fixture = TestBed.createComponent(SearchBoxComponent);
+    const fixture = TestBed.createComponent(SearchBoxComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
     component.textFilter = new TextFilter();
-    fixture.detectChanges();
+    dom.detectChanges();
   });
 
   it('can be created', () => {
@@ -57,63 +56,44 @@ describe('SearchBoxComponent', () => {
   });
 
   it('shows custom label', () => {
-    const label = htmlElement.querySelector('.search-box mat-label');
-    expect(label?.textContent).toEqual('Search');
-
+    const label = dom.get('.search-box mat-label');
+    label.checkTextExact('Search');
     component.label = 'custom label';
-    fixture.detectChanges();
-    expect(label?.textContent).toEqual('custom label');
+    dom.detectChanges();
+    label.checkTextExact('custom label');
   });
 
   it('handles change in filter', () => {
     const spy = spyOn(component.filterChange, 'emit');
     expect(component.textFilter?.filterString).toEqual('');
-    expect(htmlElement.querySelector('.highlighted')).toBeNull();
-    changeFilterString('Test');
+    expect(dom.find('.highlighted')).toBeUndefined();
+    dom.findAndDispatchInput('.search-box', 'Test');
     expect(component.textFilter?.filterString).toEqual('Test');
     expect(spy).toHaveBeenCalledWith(new TextFilter('Test'));
-    expect(htmlElement.querySelector('.highlighted')).toBeTruthy();
+    expect(dom.find('.highlighted')).toBeDefined();
   });
 
   it('handles change in flags', () => {
     const spy = spyOn(component.filterChange, 'emit');
-    const buttons =
-      htmlElement.querySelectorAll<HTMLElement>('.search-box button');
+    const buttons = dom.findAll('.search-box button');
     expect(buttons.length).toEqual(3);
 
-    buttons.item(0).click();
-    fixture.detectChanges();
+    buttons[0].click();
     expect(spy).toHaveBeenCalledWith(
       new TextFilter('', [FilterFlag.MATCH_CASE]),
     );
 
-    buttons.item(0).click();
-    fixture.detectChanges();
+    buttons[0].click();
     expect(spy).toHaveBeenCalledWith(new TextFilter());
 
-    buttons.item(2).click();
-    fixture.detectChanges();
+    buttons[2].click();
     expect(spy).toHaveBeenCalledWith(
       new TextFilter('', [FilterFlag.USE_REGEX]),
     );
 
-    buttons.item(1).click();
-    fixture.detectChanges();
+    buttons[1].click();
     expect(spy).toHaveBeenCalledWith(
       new TextFilter('', [FilterFlag.USE_REGEX, FilterFlag.MATCH_WORD]),
     );
   });
-
-  function changeFilterString(
-    newString: string,
-    el = htmlElement,
-    f = fixture,
-  ) {
-    const inputEl = assertDefined(
-      el.querySelector<HTMLInputElement>('.search-box input'),
-    );
-    inputEl.value = newString;
-    inputEl.dispatchEvent(new Event('input'));
-    f.detectChanges();
-  }
 });
diff --git a/tools/winscope/src/viewers/components/select_with_filter_component.ts b/tools/winscope/src/viewers/components/select_with_filter_component.ts
index 5c2fcfb83..5c65534e0 100644
--- a/tools/winscope/src/viewers/components/select_with_filter_component.ts
+++ b/tools/winscope/src/viewers/components/select_with_filter_component.ts
@@ -13,21 +13,34 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-import {Component, EventEmitter, Input, Output} from '@angular/core';
+import {
+  ChangeDetectionStrategy,
+  Component,
+  EventEmitter,
+  Input,
+  Output,
+} from '@angular/core';
+import {MatOption} from '@angular/material/core';
 import {MatSelect, MatSelectChange} from '@angular/material/select';
+import {KeyboardEventCode} from 'common/dom_utils';
+import {AbstractFormFieldComponent} from './abstract_form_field_component';
 
 @Component({
   selector: 'select-with-filter',
+  changeDetection: ChangeDetectionStrategy.OnPush,
   template: `
     <mat-form-field
       [style]="getOuterFormFieldStyle()"
       [style.text-align]="'unset'"
       [appearance]="appearance"
       [class]="formFieldClass"
-      [class.mat-body-2]="!select.value || select.value.length === 0">
+      [matTooltip]="label"
+      matTooltipPosition="above"
+      [matTooltipDisabled]="disableTooltip(formField)"
+      [class.mat-body-2]="!select.value || select.value.length === 0"  #formField>
       <mat-label>{{ label }}</mat-label>
       <mat-select
-        (opened)="filter.focus()"
+        (opened)="onSelectOpened(select, filter)"
         (closed)="onSelectClosed()"
         (selectionChange)="onSelectChange($event)"
         [multiple]="true"
@@ -51,10 +64,12 @@ import {MatSelect, MatSelectChange} from '@angular/material/select';
         </div>
         <mat-divider [vertical]="false"></mat-divider>
         <mat-option
-          *ngFor="let option of options"
+          *ngFor="let option of options; index as i"
           [value]="option"
           class="option no-focus"
-          [class.hidden-option]="hideOption(option)">{{ option }}</mat-option>
+          [class.hidden-option]="hideOption(option)"
+          (click)="onOptClick($event, i, select, matOption)"
+          #matOption>{{ option }}</mat-option>
       </mat-select>
     </mat-form-field>
   `,
@@ -75,19 +90,18 @@ import {MatSelect, MatSelectChange} from '@angular/material/select';
     `,
   ],
 })
-export class SelectWithFilterComponent {
-  @Input() label: string = '';
+export class SelectWithFilterComponent extends AbstractFormFieldComponent {
   @Input() options: string[] = [];
   @Input() outerFilterWidth = '100px';
   @Input() innerFilterWidth = '100';
   @Input() flex = 'none';
-  @Input() appearance = '';
-  @Input() formFieldClass = '';
 
   @Output() readonly selectChange = new EventEmitter<MatSelectChange>();
 
   filterString: string = '';
 
+  private lastClickedIndex: number | undefined;
+
   onSelectChange(event: MatSelectChange) {
     this.selectChange.emit(event);
   }
@@ -109,6 +123,20 @@ export class SelectWithFilterComponent {
     };
   }
 
+  onSelectOpened(select: MatSelect, filter: HTMLInputElement) {
+    const defaultHandleKeydown = select._handleKeydown.bind(select);
+    select._handleKeydown = (event) => {
+      if (event.code === KeyboardEventCode.A && event.ctrlKey) {
+        event.preventDefault();
+        event.stopPropagation();
+        this.handleKeydownCtrlA(select);
+        return;
+      }
+      defaultHandleKeydown(event);
+    };
+    filter.focus();
+  }
+
   onSelectClosed() {
     this.filterString = '';
   }
@@ -117,6 +145,34 @@ export class SelectWithFilterComponent {
     return !option.toLowerCase().includes(this.filterString.toLowerCase());
   }
 
+  onOptClick(e: MouseEvent, i: number, select: MatSelect, option: MatOption) {
+    if (
+      !e.shiftKey ||
+      !select.value ||
+      this.lastClickedIndex === undefined ||
+      Math.abs(i - this.lastClickedIndex) <= 1
+    ) {
+      this.lastClickedIndex = i;
+      return;
+    }
+
+    const optionsToToggle =
+      this.lastClickedIndex < i
+        ? this.options.slice(this.lastClickedIndex, i)
+        : this.options.slice(i + 1, this.lastClickedIndex + 1);
+
+    const filteredOptions = optionsToToggle.filter((o) => !this.hideOption(o));
+
+    if (option.selected) {
+      this.addValuesToSelect(select, filteredOptions);
+    } else {
+      this.removeValuesFromSelect(select, filteredOptions);
+    }
+
+    this.lastClickedIndex = i;
+    this.selectChange.emit(new MatSelectChange(select, select.value));
+  }
+
   selectedOptions(select: MatSelect) {
     return this.options.filter((o) => select.value.includes(o));
   }
@@ -125,4 +181,23 @@ export class SelectWithFilterComponent {
     select.value = select.value.filter((val: string) => val !== option);
     this.selectChange.emit(new MatSelectChange(select, select.value));
   }
+
+  private handleKeydownCtrlA(select: MatSelect) {
+    const allOpts = this.options.filter((o) => !this.hideOption(o));
+    if (allOpts.every((o) => select.value?.includes(o))) {
+      this.removeValuesFromSelect(select, allOpts);
+    } else {
+      this.addValuesToSelect(select, allOpts);
+    }
+    this.selectChange.emit(new MatSelectChange(select, select.value));
+  }
+
+  private addValuesToSelect(select: MatSelect, opts: string[]) {
+    const newValues = new Set((select.value ?? []).concat(opts));
+    select.value = Array.from(newValues);
+  }
+
+  private removeValuesFromSelect(select: MatSelect, opts: string[]) {
+    select.value = select.value.filter((o: string) => !opts.includes(o));
+  }
 }
diff --git a/tools/winscope/src/viewers/components/select_with_filter_component_test.ts b/tools/winscope/src/viewers/components/select_with_filter_component_test.ts
index 1d85d2666..9d734990f 100644
--- a/tools/winscope/src/viewers/components/select_with_filter_component_test.ts
+++ b/tools/winscope/src/viewers/components/select_with_filter_component_test.ts
@@ -16,25 +16,26 @@
 
 import {CommonModule} from '@angular/common';
 import {Component, ViewChild} from '@angular/core';
-import {
-  ComponentFixture,
-  ComponentFixtureAutoDetect,
-  TestBed,
-} from '@angular/core/testing';
+import {ComponentFixtureAutoDetect, TestBed} from '@angular/core/testing';
 import {FormsModule} from '@angular/forms';
 import {MatOptionModule, MatPseudoCheckboxModule} from '@angular/material/core';
 import {MatDividerModule} from '@angular/material/divider';
 import {MatFormFieldModule} from '@angular/material/form-field';
 import {MatInputModule} from '@angular/material/input';
 import {MatSelectModule} from '@angular/material/select';
+import {MatTooltipModule} from '@angular/material/tooltip';
 import {BrowserAnimationsModule} from '@angular/platform-browser/animations';
 import {assertDefined} from 'common/assert_utils';
+import {KeyboardEventCode} from 'common/dom_utils';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
 import {SelectWithFilterComponent} from './select_with_filter_component';
 
 describe('SelectWithFilterComponent', () => {
-  let fixture: ComponentFixture<TestHostComponent>;
+  const filterInputField = '.select-filter';
+  const shiftAndClick = new MouseEvent('click', {shiftKey: true});
   let component: TestHostComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<TestHostComponent>;
+  let selectChangeSpy: jasmine.Spy;
 
   beforeEach(async () => {
     await TestBed.configureTestingModule({
@@ -50,12 +51,21 @@ describe('SelectWithFilterComponent', () => {
         FormsModule,
         MatPseudoCheckboxModule,
         MatDividerModule,
+        MatTooltipModule,
       ],
     }).compileComponents();
-    fixture = TestBed.createComponent(TestHostComponent);
+    const fixture = TestBed.createComponent(TestHostComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
-    fixture.detectChanges();
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
+    dom.detectChanges();
+    selectChangeSpy = spyOn(
+      assertDefined(component.selectWithFilterComponent).selectChange,
+      'emit',
+    );
+  });
+
+  afterAll(() => {
+    dom.detectChanges();
   });
 
   it('can be created', () => {
@@ -63,159 +73,229 @@ describe('SelectWithFilterComponent', () => {
   });
 
   it('applies filter correctly', () => {
-    openSelectPanel();
+    dom.openMatSelect();
 
     const options = getOptions();
     checkHiddenOptions(options, []);
 
-    const inputEl = getFilterInput();
-    dispatchInput(inputEl, '2');
+    const panel = dom.getMatSelectPanel();
+    const input = panel.findAndDispatchInput(filterInputField, '2');
     checkHiddenOptions(options, [0, 1]);
 
-    dispatchInput(inputEl, '');
+    input.dispatchInput('');
     checkHiddenOptions(options, []);
   });
 
   it('maintains selection even if filtered out', () => {
-    const spy = spyOn(
-      assertDefined(component.selectWithFilterComponent).selectChange,
-      'emit',
-    );
-    openSelectPanel();
+    dom.openMatSelect();
 
     const options = getOptions();
     checkHiddenOptions(options, []);
 
     options[0].click();
-    fixture.detectChanges();
-    checkSelectValue(spy, ['0']);
-
-    const inputEl = getFilterInput();
+    checkSelectValue(['0']);
 
-    dispatchInput(inputEl, '2');
+    const panel = dom.getMatSelectPanel();
+    const input = panel.findAndDispatchInput(filterInputField, '2');
     checkHiddenOptions(options, [0, 1]);
 
     options[2].click();
-    checkSelectValue(spy, ['0', '2']);
+    checkSelectValue(['0', '2']);
 
-    dispatchInput(inputEl, '');
+    input.dispatchInput('');
     checkHiddenOptions(options, []);
 
     options[1].click();
-    checkSelectValue(spy, ['0', '1', '2']);
+    checkSelectValue(['0', '1', '2']);
   });
 
   it('applies selection correctly', () => {
-    const spy = spyOn(
-      assertDefined(component.selectWithFilterComponent).selectChange,
-      'emit',
-    );
-    openSelectPanel();
-
+    dom.openMatSelect();
     const options = getOptions();
 
     options[0].click();
-    checkSelectValue(spy, ['0']);
+    checkSelectValue(['0']);
 
     options[0].click();
-    checkSelectValue(spy, []);
+    checkSelectValue([]);
   });
 
   it('applies deselection from pinned selected options', () => {
-    const spy = spyOn(
-      assertDefined(component.selectWithFilterComponent).selectChange,
-      'emit',
-    );
-    openSelectPanel();
+    dom.openMatSelect();
 
     const options = getOptions();
     options[0].click();
-    fixture.detectChanges();
-    checkSelectValue(spy, ['0']);
+    checkSelectValue(['0']);
 
     const pinnedOptions = getPinnedOptions();
     expect(pinnedOptions.length).toEqual(1);
     pinnedOptions[0].click();
-    fixture.detectChanges();
-    checkSelectValue(spy, []);
+    checkSelectValue([]);
     expect(getPinnedOptions().length).toEqual(0);
   });
 
   it('resets filter on close', async () => {
-    openSelectPanel();
+    dom.openMatSelect();
 
     const options = getOptions();
     checkHiddenOptions(options, []);
 
-    const inputEl = getFilterInput();
-    dispatchInput(inputEl, 'A');
+    dom.getMatSelectPanel().findAndDispatchInput(filterInputField, 'A');
     checkHiddenOptions(options, [0, 1, 2]);
 
-    document.querySelector<HTMLElement>('.cdk-overlay-backdrop')?.click();
-    fixture.detectChanges();
-    await fixture.whenStable();
+    dom.getInDocument('.cdk-overlay-backdrop').click();
+    await dom.whenStable();
+    await dom.whenRenderingDone();
 
-    openSelectPanel();
+    dom.openMatSelect();
     checkHiddenOptions(getOptions(), []);
   });
 
-  function openSelectPanel() {
-    assertDefined(
-      htmlElement.querySelector<HTMLElement>('.mat-select-trigger'),
-    ).click();
-  }
+  it('calls default select keydown handler', async () => {
+    dom.openMatSelect();
+    await dom.detectChangesAndWaitStable();
+    await dom.whenRenderingDone();
+    dom.getMatSelectPanel().keydownSpace();
+    checkSelectValue(['0']);
+  });
 
-  function getOptions(): HTMLElement[] {
-    return Array.from(
-      document.querySelectorAll<HTMLElement>('.mat-select-panel .option'),
-    );
+  it('calls custom select keydown handler for CTRL+A', async () => {
+    dom.openMatSelect();
+    await dom.detectChangesAndWaitStable();
+    await dom.whenRenderingDone();
+    const keydownCtrlA = new KeyboardEvent('keydown', {
+      code: KeyboardEventCode.A,
+      ctrlKey: true,
+    });
+    const panel = dom.getMatSelectPanel();
+
+    panel.dispatchEvent(keydownCtrlA);
+    checkSelectValue(['0', '1', '2']);
+
+    panel.dispatchEvent(keydownCtrlA);
+    checkSelectValue([]);
+
+    panel.dispatchEvent(keydownCtrlA);
+    const inputEl = panel.findAndDispatchInput(filterInputField, '2'); // filters out '0' and '1' while all selected
+
+    panel.dispatchEvent(keydownCtrlA);
+    checkSelectValue(['0', '1']);
+
+    panel.dispatchEvent(keydownCtrlA);
+    checkSelectValue(['0', '1', '2']);
+
+    panel.dispatchEvent(keydownCtrlA);
+    inputEl.dispatchInput(''); // removes filter while '0' and '1' selected
+
+    panel.dispatchEvent(keydownCtrlA);
+    checkSelectValue(['0', '1', '2']);
+  });
+
+  it('does not emit second change after shift + click for adjacent options', () => {
+    dom.openMatSelect();
+    const options = getOptions();
+
+    options[0].dispatchEvent(shiftAndClick);
+    expect(selectChangeSpy).toHaveBeenCalledTimes(1);
+
+    options[1].dispatchEvent(shiftAndClick);
+    expect(selectChangeSpy).toHaveBeenCalledTimes(2);
+
+    options[0].dispatchEvent(shiftAndClick);
+    expect(selectChangeSpy).toHaveBeenCalledTimes(3);
+
+    options[1].click();
+    expect(selectChangeSpy).toHaveBeenCalledTimes(4);
+  });
+
+  it('emits second change after shift + click to toggle options in-between', () => {
+    dom.openMatSelect();
+    const options = getOptions();
+
+    options[0].click();
+    selectChangeSpy.calls.reset();
+
+    options[2].dispatchEvent(shiftAndClick);
+    expect(selectChangeSpy).toHaveBeenCalledTimes(2);
+    checkSelectValue(['0', '2', '1'], ['0', '1', '2']);
+    selectChangeSpy.calls.reset();
+
+    options[0].dispatchEvent(shiftAndClick);
+    expect(selectChangeSpy).toHaveBeenCalledTimes(2);
+    checkSelectValue([]);
+  });
+
+  it('sets in-between options to value of clicked option, regardless of current state', () => {
+    component.allOptions.push('3');
+    dom.openMatSelect();
+    const options = getOptions();
+
+    options[2].click();
+    options[3].click();
+    checkSelectValue(['2', '3']);
+    selectChangeSpy.calls.reset();
+
+    options[0].dispatchEvent(shiftAndClick);
+    expect(selectChangeSpy).toHaveBeenCalledTimes(2);
+    checkSelectValue(['0', '2', '3', '1'], ['0', '1', '2', '3']);
+
+    options[2].click();
+    options[3].click();
+    checkSelectValue(['0', '1']);
+    selectChangeSpy.calls.reset();
+
+    options[0].dispatchEvent(shiftAndClick);
+    expect(selectChangeSpy).toHaveBeenCalledTimes(2);
+    checkSelectValue([]);
+  });
+
+  it('only toggles non-hidden options between last and current clicks', () => {
+    component.allOptions.push('10');
+    dom.openMatSelect();
+    const options = getOptions();
+    dom.getMatSelectPanel().findAndDispatchInput(filterInputField, '1');
+
+    options[1].click();
+    selectChangeSpy.calls.reset();
+    options[3].dispatchEvent(shiftAndClick);
+    checkSelectValue(['1', '10']);
+    expect(selectChangeSpy).toHaveBeenCalledTimes(2);
+  });
+
+  function getOptions(): Array<DOMTestHelper<TestHostComponent>> {
+    return Array.from(dom.getMatSelectPanel().findAll('.option'));
   }
 
-  function checkHiddenOptions(options: HTMLElement[], hidden: number[]) {
+  function checkHiddenOptions(
+    options: Array<DOMTestHelper<TestHostComponent>>,
+    hidden: number[],
+  ) {
     expect(options.length).toEqual(3);
     options.forEach((option, index) => {
-      expect(option.textContent).toContain(`${index}`);
-      if (hidden.includes(index)) {
-        expect(option.className).toContain('hidden-option');
-      } else {
-        expect(option.className).not.toContain('hidden-option');
-      }
+      option.checkText(`${index}`);
+      option.checkClassName('hidden-option', hidden.includes(index));
     });
   }
 
-  function getFilterInput(): HTMLInputElement {
-    return assertDefined(
-      document.querySelector<HTMLInputElement>(
-        '.mat-select-panel .select-filter input',
-      ),
-    );
-  }
-
-  function dispatchInput(inputEl: HTMLInputElement, input: string) {
-    inputEl.value = input;
-    inputEl.dispatchEvent(new Event('input'));
-    fixture.detectChanges();
-  }
-
-  function getPinnedOptions(): HTMLElement[] {
+  function getPinnedOptions(): Array<DOMTestHelper<TestHostComponent>> {
     return Array.from(
-      document.querySelectorAll<HTMLElement>(
-        '.mat-select-panel .selected-options .mat-option',
-      ),
+      dom.getMatSelectPanel().findAll('.selected-options .mat-option'),
     ).slice(1);
   }
 
-  function checkSelectValue(spy: jasmine.Spy, expected: string[]) {
-    expect(spy).toHaveBeenCalled();
-    expect(assertDefined(spy.calls.mostRecent().args[0]).value).toEqual(
-      expected,
-    );
-    if (!document.querySelector('.mat-select-panel')) {
-      openSelectPanel();
-    }
+  function checkSelectValue(expValues: string[], expOpts = expValues) {
+    expect(selectChangeSpy).toHaveBeenCalled();
     expect(
-      Array.from(getPinnedOptions()).map((o) => o.textContent?.trim()),
-    ).toEqual(expected);
+      assertDefined(selectChangeSpy.calls.mostRecent().args[0]).value,
+    ).toEqual(expValues);
+    if (!dom.isMatSelectOpen()) {
+      dom.openMatSelect();
+    }
+    const pinnedOptions = getPinnedOptions();
+    expect(pinnedOptions.length).toEqual(expOpts.length);
+    pinnedOptions.forEach((option, index) => {
+      option.checkTextExact(expOpts[index]);
+    });
   }
 
   @Component({
diff --git a/tools/winscope/src/viewers/components/styles/log_component.styles.ts b/tools/winscope/src/viewers/components/styles/log_component.styles.ts
index 7ddd5e1d7..7b0982450 100644
--- a/tools/winscope/src/viewers/components/styles/log_component.styles.ts
+++ b/tools/winscope/src/viewers/components/styles/log_component.styles.ts
@@ -34,10 +34,6 @@ export const logComponentStyles = `
     display: flex;
     flex-direction: row;
     overflow-wrap: anywhere;
-  }
-
-  .headers div,
-  .entries div {
     padding: 4px;
   }
 
@@ -45,6 +41,10 @@ export const logComponentStyles = `
     align-content: center;
   }
 
+  .header, .filter, .cell {
+    padding: 4px;
+  }
+
   .time {
     flex: 1;
     min-width: 135px;
@@ -89,6 +89,11 @@ export const logComponentStyles = `
     width: 75px;
   }
 
+  .process {
+    flex: 1;
+    width: 85px;
+  }
+
   .transaction-type {
     flex: 1;
     min-width: 85px;
@@ -116,10 +121,7 @@ export const logComponentStyles = `
 
   .text {
     flex: 10;
-  }
-
-  .title-section .filters {
-    margin-top: 8px;
+    white-space: pre-wrap;
   }
 
   .transition-id {
@@ -182,10 +184,25 @@ export const logComponentStyles = `
     justify-content: end;
   }
 
-  .status .mat-icon {
+  .entry .source-file {
+    display: flex;
+    align-items: start;
+    justify-content: space-between;
+  }
+
+  .status .mat-icon, .copy-button, .copy-button .mat-icon {
     font-size: 18px;
     width: 18px;
     height: 18px;
+    line-height: 18px;
+  }
+
+  .cell:not(:hover) .copy-button {
+    visibility: hidden;
+  }
+
+  .copy-button .mat-icon {
+    min-width: 18px;
   }
 
   .input-type {
diff --git a/tools/winscope/src/viewers/components/surface_flinger_property_groups_component_test.ts b/tools/winscope/src/viewers/components/surface_flinger_property_groups_component_test.ts
index 919b6bfed..324a5a739 100644
--- a/tools/winscope/src/viewers/components/surface_flinger_property_groups_component_test.ts
+++ b/tools/winscope/src/viewers/components/surface_flinger_property_groups_component_test.ts
@@ -14,15 +14,11 @@
  * limitations under the License.
  */
 import {Component} from '@angular/core';
-import {
-  ComponentFixture,
-  ComponentFixtureAutoDetect,
-  TestBed,
-} from '@angular/core/testing';
+import {ComponentFixtureAutoDetect, TestBed} from '@angular/core/testing';
 import {MatDividerModule} from '@angular/material/divider';
 import {MatIconModule} from '@angular/material/icon';
 import {MatTooltipModule} from '@angular/material/tooltip';
-import {assertDefined} from 'common/assert_utils';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
 import {TreeNodeUtils} from 'test/unit/tree_node_utils';
 import {EMPTY_OBJ_STRING} from 'trace/tree_node/formatters';
 import {SfCuratedProperties} from 'viewers/common/curated_properties';
@@ -32,9 +28,8 @@ import {SurfaceFlingerPropertyGroupsComponent} from './surface_flinger_property_
 import {TransformMatrixComponent} from './transform_matrix_component';
 
 describe('SurfaceFlingerPropertyGroupsComponent', () => {
-  let fixture: ComponentFixture<TestHostComponent>;
   let component: TestHostComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<TestHostComponent>;
 
   beforeEach(async () => {
     await TestBed.configureTestingModule({
@@ -47,10 +42,10 @@ describe('SurfaceFlingerPropertyGroupsComponent', () => {
         CollapsibleSectionTitleComponent,
       ],
     }).compileComponents();
-    fixture = TestBed.createComponent(TestHostComponent);
+    const fixture = TestBed.createComponent(TestHostComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
-    fixture.detectChanges();
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
+    dom.detectChanges();
   });
 
   it('can be created', () => {
@@ -58,22 +53,19 @@ describe('SurfaceFlingerPropertyGroupsComponent', () => {
   });
 
   it('renders flags', () => {
-    const flags = assertDefined(htmlElement.querySelector('.flags'));
-    expect(flags.innerHTML).toMatch('Flags:.*HIDDEN \\(0x1\\)');
+    dom.get('.flags').checkTextExact('Flags: HIDDEN (0x1)');
   });
 
   it('renders simple summary property', () => {
-    const summary = htmlElement.querySelectorAll('.summary').item(0);
-    expect(summary.textContent).toMatch(
-      'Invisible due to: reason 1, reason 2, reason 3',
-    );
+    dom
+      .get('.summary')
+      .checkTextExact('Invisible due to: reason 1, reason 2, reason 3');
   });
 
   it('renders interactive summary property', () => {
-    const summary = htmlElement.querySelectorAll('.summary').item(1);
-    expect(summary.textContent).toContain('Covered by:');
-    const button = assertDefined(summary.querySelector<HTMLElement>('button'));
-    expect(button.textContent).toMatch('1');
+    const summary = dom.findAll('.summary')[1];
+    summary.checkTextExact('Covered by:  1');
+    summary.get('button').checkTextExact('1');
   });
 
   it('emits highlighted id event from layer id in summary', () => {
@@ -84,51 +76,41 @@ describe('SurfaceFlingerPropertyGroupsComponent', () => {
   });
 
   it('displays calculated geometry', () => {
-    const calculatedDiv = assertDefined(
-      htmlElement.querySelector('.geometry .left-column'),
-    );
-    expect(calculatedDiv.querySelector('transform-matrix')).toBeTruthy();
-    expect(
-      assertDefined(calculatedDiv.querySelector('.crop')).innerHTML,
-    ).toContain(EMPTY_OBJ_STRING);
-    expect(
-      assertDefined(calculatedDiv.querySelector('.final-bounds')).innerHTML,
-    ).toContain(EMPTY_OBJ_STRING);
+    const calculatedDiv = dom.get('.geometry .left-column');
+    expect(calculatedDiv.find('transform-matrix')).toBeDefined();
+    calculatedDiv.get('.crop').checkTextExact('Crop: ' + EMPTY_OBJ_STRING);
+    calculatedDiv
+      .get('.final-bounds')
+      .checkTextExact('Final Bounds: ' + EMPTY_OBJ_STRING);
   });
 
   it('displays requested geometry', () => {
-    const requestedDiv = assertDefined(
-      htmlElement.querySelector('.geometry .right-column'),
-    );
-    expect(requestedDiv.querySelector('transform-matrix')).toBeTruthy();
+    const requestedDiv = dom.get('.geometry .right-column');
+    expect(requestedDiv.find('transform-matrix')).toBeDefined();
   });
 
   it('displays buffer info', () => {
-    const sizeDiv = htmlElement.querySelector('.buffer .size');
-    expect(assertDefined(sizeDiv).innerHTML).toContain(EMPTY_OBJ_STRING);
-    const currFrameDiv = htmlElement.querySelector('.buffer .frame-number');
-    expect(assertDefined(currFrameDiv).innerHTML).toContain('0');
-    const transformDiv = htmlElement.querySelector('.buffer .transform');
-    expect(assertDefined(transformDiv).innerHTML).toContain('IDENTITY');
-    const destFrameDiv = htmlElement.querySelector('.buffer .dest-frame');
-    expect(assertDefined(destFrameDiv).innerHTML).toContain(EMPTY_OBJ_STRING);
-    const ignoreFrameDiv = htmlElement.querySelector('.buffer .ignore-frame');
-    expect(assertDefined(ignoreFrameDiv).innerHTML).toContain(
-      'Destination Frame ignored because item has eIgnoreDestinationFrame flag set.',
-    );
+    dom.get('.buffer .size').checkTextExact('Size: ' + EMPTY_OBJ_STRING);
+    dom.get('.buffer .frame-number').checkTextExact('Frame Number: 0');
+    dom.get('.buffer .transform').checkTextExact('Transform: IDENTITY');
+    dom
+      .get('.buffer .dest-frame')
+      .checkTextExact('Destination Frame: ' + EMPTY_OBJ_STRING);
+    dom
+      .get('.buffer .ignore-frame')
+      .checkTextExact(
+        'Destination Frame ignored because item has eIgnoreDestinationFrame flag set.',
+      );
   });
 
   it('displays hierarchy info', () => {
-    const zDiv = htmlElement.querySelector('.hierarchy-info .z-order');
-    expect(assertDefined(zDiv).innerHTML).toContain('0');
-    const relParentDiv = htmlElement.querySelector(
-      '.hierarchy-info .rel-parent',
-    );
-    expect(assertDefined(relParentDiv).innerHTML).toContain('none');
-    const relChildrenDiv = assertDefined(
-      htmlElement.querySelector('.hierarchy-info .rel-children'),
-    );
-    expect(relChildrenDiv.innerHTML).toContain('none');
+    dom.get('.hierarchy-info .z-order').checkTextExact('Z-order: 0');
+    dom
+      .get('.hierarchy-info .rel-parent')
+      .checkTextExact('Relative Parent:  none');
+    dom
+      .get('.hierarchy-info .rel-children')
+      .checkTextExact('Relative Children:  none');
   });
 
   it('emits highlighted id event from layer id in rel z parent', () => {
@@ -137,7 +119,7 @@ describe('SurfaceFlingerPropertyGroupsComponent', () => {
       nodeId: '1 relZParent',
       name: 'relZParent',
     };
-    fixture.detectChanges();
+    dom.detectChanges();
     checkHighlightedIdEventEmittedFromButtonClick(
       '.hierarchy-info .rel-parent button',
       '1 relZParent',
@@ -152,7 +134,7 @@ describe('SurfaceFlingerPropertyGroupsComponent', () => {
         name: 'relZChild',
       },
     ];
-    fixture.detectChanges();
+    dom.detectChanges();
     checkHighlightedIdEventEmittedFromButtonClick(
       '.hierarchy-info .rel-children button',
       '2 relZChild',
@@ -160,75 +142,45 @@ describe('SurfaceFlingerPropertyGroupsComponent', () => {
   });
 
   it('displays simple calculated effects', () => {
-    const calculatedDiv = assertDefined(
-      htmlElement.querySelector('.effects .left-column'),
-    );
-    expect(
-      assertDefined(calculatedDiv.querySelector('.shadow')).innerHTML,
-    ).toContain('1 px');
-    expect(
-      assertDefined(calculatedDiv.querySelector('.blur')).innerHTML,
-    ).toContain('1 px');
-    expect(
-      assertDefined(calculatedDiv.querySelector('.corner-radius')).innerHTML,
-    ).toContain('1 px');
+    const calculatedDiv = dom.get('.effects .left-column');
+    calculatedDiv.get('.shadow').checkTextExact('Shadow Radius: 1 px');
+    calculatedDiv.get('.blur').checkTextExact('Blur Radius: 1 px');
+    calculatedDiv.get('.corner-radius').checkTextExact('Corner Radius: 1 px');
   });
 
   it('displays simple requested effects', () => {
-    const calculatedDiv = assertDefined(
-      htmlElement.querySelector('.effects .right-column'),
-    );
-    expect(
-      assertDefined(calculatedDiv.querySelector('.corner-radius')).innerHTML,
-    ).toContain('1 px');
+    const requestedDiv = dom.get('.effects .right-column');
+    requestedDiv.get('.corner-radius').checkTextExact('Corner Radius: 1 px');
   });
 
   it('displays color and alpha value in effects', () => {
-    const colorDiv = htmlElement.querySelector('.color');
-    expect(assertDefined(colorDiv).innerHTML).toContain(
-      `${EMPTY_OBJ_STRING}, alpha: 1`,
-    );
+    dom.get('.color').checkTextExact(`Color: ${EMPTY_OBJ_STRING}, alpha: 1`);
   });
 
   it('displays not set message if no inputs present', () => {
-    const noInputsMessage = htmlElement.querySelector('.inputs .left-column');
-    expect(assertDefined(noInputsMessage).innerHTML).toContain('not set');
+    dom.get('.inputs .left-column').checkTextExact('Input Channel: not set');
   });
 
   it('displays input window info if available', () => {
     component.properties.hasInputChannel = true;
-    fixture.detectChanges();
+    dom.detectChanges();
 
-    expect(
-      htmlElement.querySelector('.inputs .left-column transform-matrix'),
-    ).toBeTruthy();
+    expect(dom.find('.inputs .left-column transform-matrix')).toBeDefined();
 
-    const configDiv = assertDefined(
-      htmlElement.querySelector('.inputs .right-column'),
-    );
-    expect(
-      assertDefined(configDiv.querySelector('.focusable')).innerHTML,
-    ).toContain('false');
-    expect(
-      assertDefined(configDiv.querySelector('.crop-touch-region')).innerHTML,
-    ).toContain('none');
-    expect(
-      assertDefined(configDiv.querySelector('.replace-touch-region')).innerHTML,
-    ).toContain('false');
-    expect(
-      assertDefined(configDiv.querySelector('.input-config')).innerHTML,
-    ).toContain('null');
+    const configDiv = dom.get('.inputs .right-column');
+    configDiv.get('.focusable').checkTextExact('Focusable: false');
+    configDiv
+      .get('.crop-touch-region')
+      .checkTextExact('Crop touch region with item: none');
+    configDiv
+      .get('.replace-touch-region')
+      .checkTextExact('Replace touch region with crop: false');
+    configDiv.get('.input-config').checkTextExact('Input Config: null');
   });
 
   it('handles collapse button click', () => {
     expect(component.collapseButtonClicked).toBeFalse();
-    const collapseButton = assertDefined(
-      htmlElement.querySelector<HTMLElement>(
-        'collapsible-section-title button',
-      ),
-    );
-    collapseButton.click();
-    fixture.detectChanges();
+    dom.findAndClick('collapsible-section-title button');
     expect(component.collapseButtonClicked).toBeTrue();
   });
 
@@ -237,13 +189,10 @@ describe('SurfaceFlingerPropertyGroupsComponent', () => {
     expectedId: string,
   ) {
     let id = '';
-    htmlElement.addEventListener(ViewerEvents.HighlightedIdChange, (event) => {
+    dom.addEventListener(ViewerEvents.HighlightedIdChange, (event) => {
       id = (event as CustomEvent).detail.id;
     });
-    const button = assertDefined(
-      htmlElement.querySelector<HTMLElement>(selector),
-    );
-    button.click();
+    dom.findAndClick(selector);
     expect(id).toEqual(expectedId);
   }
 
diff --git a/tools/winscope/src/viewers/components/transform_matrix_component_test.ts b/tools/winscope/src/viewers/components/transform_matrix_component_test.ts
index 4e0718bd1..1ea4ba497 100644
--- a/tools/winscope/src/viewers/components/transform_matrix_component_test.ts
+++ b/tools/winscope/src/viewers/components/transform_matrix_component_test.ts
@@ -13,15 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-import {
-  ComponentFixture,
-  ComponentFixtureAutoDetect,
-  TestBed,
-} from '@angular/core/testing';
+import {ComponentFixtureAutoDetect, TestBed} from '@angular/core/testing';
 import {TransformMatrixComponent} from './transform_matrix_component';
 
 describe('TransformMatrixComponent', () => {
-  let fixture: ComponentFixture<TransformMatrixComponent>;
   let component: TransformMatrixComponent;
 
   beforeAll(async () => {
@@ -32,7 +27,7 @@ describe('TransformMatrixComponent', () => {
   });
 
   beforeEach(() => {
-    fixture = TestBed.createComponent(TransformMatrixComponent);
+    const fixture = TestBed.createComponent(TransformMatrixComponent);
     component = fixture.componentInstance;
   });
 
diff --git a/tools/winscope/src/viewers/components/tree_component_test.ts b/tools/winscope/src/viewers/components/tree_component_test.ts
index ae121168d..4a745c9ac 100644
--- a/tools/winscope/src/viewers/components/tree_component_test.ts
+++ b/tools/winscope/src/viewers/components/tree_component_test.ts
@@ -16,10 +16,11 @@
 
 import {Clipboard, ClipboardModule} from '@angular/cdk/clipboard';
 import {Component, ViewChild} from '@angular/core';
-import {ComponentFixture, TestBed} from '@angular/core/testing';
+import {TestBed} from '@angular/core/testing';
 import {MatIconModule} from '@angular/material/icon';
 import {MatTooltipModule} from '@angular/material/tooltip';
 import {assertDefined} from 'common/assert_utils';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
 import {HierarchyTreeBuilder} from 'test/unit/hierarchy_tree_builder';
 import {TreeNodeUtils} from 'test/unit/tree_node_utils';
 import {RectShowState} from 'viewers/common/rect_show_state';
@@ -32,9 +33,8 @@ import {TreeComponent} from './tree_component';
 import {TreeNodeComponent} from './tree_node_component';
 
 describe('TreeComponent', () => {
-  let fixture: ComponentFixture<TestHostComponent>;
   let component: TestHostComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<TestHostComponent>;
   let mockCopyText: jasmine.Spy;
 
   beforeEach(async () => {
@@ -50,109 +50,90 @@ describe('TreeComponent', () => {
       ],
       imports: [MatTooltipModule, MatIconModule, ClipboardModule],
     }).compileComponents();
-    fixture = TestBed.createComponent(TestHostComponent);
+    const fixture = TestBed.createComponent(TestHostComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
   });
 
   it('can be created', () => {
-    fixture.detectChanges();
+    dom.detectChanges();
     expect(component).toBeTruthy();
   });
 
   it('shows node', () => {
-    fixture.detectChanges();
-    expect(htmlElement.querySelector('tree-node')).toBeTruthy();
+    dom.detectChanges();
+    expect(dom.find('tree-node')).toBeDefined();
   });
 
   it('can identify if a parent node has a selected child', () => {
-    fixture.detectChanges();
-    const treeNode = assertDefined(
-      htmlElement.querySelector<HTMLElement>('tree-node'),
-    );
-    expect(treeNode.className.includes('child-selected')).toBeFalse();
+    dom.detectChanges();
+    const treeNode = dom.get('tree-node');
+    treeNode.checkClassName('child-selected', false);
     component.highlightedItem = '3 Child3';
-    fixture.detectChanges();
-    expect(treeNode.className.includes('child-selected')).toBeTrue();
+    dom.detectChanges();
+    treeNode.checkClassName('child-selected', true);
   });
 
   it('highlights node and inner node upon click', () => {
-    fixture.detectChanges();
-    const treeNodes = assertDefined(
-      htmlElement.querySelectorAll<HTMLElement>('tree-node'),
-    );
-
+    dom.detectChanges();
     const spy = spyOn(
       assertDefined(component.treeComponent).highlightedChange,
       'emit',
     );
-    treeNodes.item(0).dispatchEvent(new MouseEvent('click', {detail: 1}));
-    fixture.detectChanges();
+    const treeNodes = dom.findAll('tree-node');
+    treeNodes[0].dispatchEvent(new MouseEvent('click', {detail: 1}));
     expect(spy).toHaveBeenCalledTimes(1);
-
-    treeNodes.item(1).click();
-    fixture.detectChanges();
+    treeNodes[1].click();
     expect(spy).toHaveBeenCalledTimes(2);
   });
 
   it('toggles tree upon node double click', () => {
-    fixture.detectChanges();
-    const toggleButton = assertDefined(
-      htmlElement.querySelector('.toggle-tree-btn'),
-    );
-    expect(toggleButton.textContent?.trim()).toEqual('arrow_drop_down');
+    dom.detectChanges();
+    const toggleButton = dom.get('.toggle-tree-btn');
+    toggleButton.checkTextExact('arrow_drop_down');
     checkIsExpanded(true);
-
     doubleClickFirstNode();
-    expect(toggleButton.textContent?.trim()).toEqual('chevron_right');
+    toggleButton.checkTextExact('chevron_right');
     checkIsExpanded(false);
   });
 
   it('does not toggle tree in flat mode on double click', () => {
-    fixture.detectChanges();
+    dom.detectChanges();
     component.isFlattened = true;
-    fixture.detectChanges();
+    dom.detectChanges();
     doubleClickFirstNode();
     checkIsExpanded(true);
   });
 
   it('pins node on click', () => {
-    fixture.detectChanges();
-    const pinNodeButton = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.pin-node-btn'),
-    );
+    dom.detectChanges();
     const spy = spyOn(
       assertDefined(component.treeComponent).pinnedItemChange,
       'emit',
     );
-    pinNodeButton.click();
-    fixture.detectChanges();
+    dom.findAndClick('.pin-node-btn');
     expect(spy).toHaveBeenCalled();
   });
 
   it('expands tree on expand tree button click', () => {
-    fixture.detectChanges();
+    dom.detectChanges();
     doubleClickFirstNode();
     checkIsExpanded(false);
-
-    assertDefined(
-      htmlElement.querySelector<HTMLElement>('.expand-tree-btn'),
-    ).click();
-    fixture.detectChanges();
+    dom.findAndClick('.expand-tree-btn');
     checkIsExpanded(true);
   });
 
   it('expands tree recursively on node selection', () => {
-    fixture.detectChanges();
+    dom.detectChanges();
     doubleClickFirstNode();
     checkIsExpanded(false);
     component.highlightedItem = '79 Child79';
-    fixture.detectChanges();
+    dom.detectChanges();
     checkIsExpanded(true);
   });
 
   it('scrolls selected node only if not in view', () => {
-    fixture.detectChanges();
+    dom.detectChanges();
     checkNodeScrolling();
   });
 
@@ -161,12 +142,12 @@ describe('TreeComponent', () => {
       assertDefined(component.tree.getChildByName('Child78')),
       assertDefined(component.tree.getChildByName('Child79')),
     ];
-    fixture.detectChanges();
+    dom.detectChanges();
     checkNodeScrolling();
   });
 
   it('sets initial expanded state to true by default for leaf', () => {
-    fixture.detectChanges();
+    dom.detectChanges();
     checkIsExpanded(true);
   });
 
@@ -181,13 +162,13 @@ describe('TreeComponent', () => {
     );
     child.addOrReplaceChild(innerChild);
     component.tree = child;
-    fixture.detectChanges();
+    dom.detectChanges();
     checkIsExpanded(true);
   });
 
   it('sets initial expanded state to false if collapse state exists in store', () => {
     component.useStoredExpandedState = true;
-    fixture.detectChanges();
+    dom.detectChanges();
     // tree expanded by default
     checkIsExpanded(true);
 
@@ -197,105 +178,88 @@ describe('TreeComponent', () => {
 
     // tree collapsed state retained
     component.tree = makeTree();
-    fixture.detectChanges();
+    dom.detectChanges();
     checkIsExpanded(false);
   });
 
   it('renders show state button if applicable', () => {
-    fixture.detectChanges();
-    expect(htmlElement.querySelector('.toggle-rect-show-state-btn')).toBeNull();
-    expect(htmlElement.querySelector('.children.with-gutter')).toBeNull();
-
-    component.rectIdToShowState = new Map([
-      [component.tree.id, RectShowState.HIDE],
-    ]);
-    fixture.detectChanges();
-    expect(htmlElement.querySelector('.children.with-gutter')).toBeTruthy();
-    expect(
-      assertDefined(htmlElement.querySelector('.toggle-rect-show-state-btn'))
-        .textContent,
-    ).toContain('visibility_off');
-
-    component.rectIdToShowState.set(component.tree.id, RectShowState.SHOW);
-    fixture.detectChanges();
-    expect(
-      assertDefined(htmlElement.querySelector('.toggle-rect-show-state-btn'))
-        .textContent,
-    ).toContain('visibility');
+    dom.detectChanges();
+    expect(dom.find('.toggle-rect-show-state-btn')).toBeUndefined();
+    expect(dom.find('.children.with-gutter')).toBeUndefined();
+
+    const id = component.tree.id;
+    component.rectIdToShowState = new Map([[id, RectShowState.HIDE]]);
+    dom.detectChanges();
+    expect(dom.find('.children.with-gutter')).toBeDefined();
+    dom.get('.toggle-rect-show-state-btn').checkTextExact('visibility_off');
+
+    component.rectIdToShowState = new Map([[id, RectShowState.SHOW]]);
+    dom.detectChanges();
+    dom.get('.toggle-rect-show-state-btn').checkTextExact('visibility');
   });
 
   it('handles show state button click', () => {
     component.rectIdToShowState = new Map([
       [component.tree.id, RectShowState.HIDE],
     ]);
-    fixture.detectChanges();
-    const button = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.toggle-rect-show-state-btn'),
-    );
-    expect(button.textContent).toContain('visibility_off');
+    dom.detectChanges();
+    const button = dom.get('.toggle-rect-show-state-btn');
+    button.checkTextExact('visibility_off');
 
     let id = '';
-    htmlElement.addEventListener(ViewerEvents.RectShowStateChange, (event) => {
+    dom.addEventListener(ViewerEvents.RectShowStateChange, (event) => {
       const detail = (event as CustomEvent).detail;
       id = detail.rectId;
       component.rectIdToShowState?.set(detail.rectId, detail.state);
     });
     button.click();
-    fixture.detectChanges();
     expect(component.rectIdToShowState.get(id)).toEqual(RectShowState.SHOW);
-
     button.click();
-    fixture.detectChanges();
     expect(component.rectIdToShowState.get(id)).toEqual(RectShowState.HIDE);
   });
 
   it('shows node at full opacity when applicable', () => {
-    fixture.detectChanges();
-    expect(htmlElement.querySelector('.node.full-opacity')).toBeTruthy();
+    dom.detectChanges();
+    expect(dom.find('.node.full-opacity')).toBeDefined();
 
     component.rectIdToShowState = new Map([
       [component.tree.id, RectShowState.SHOW],
     ]);
-    fixture.detectChanges();
-    expect(htmlElement.querySelector('.node.full-opacity')).toBeTruthy();
+    dom.detectChanges();
+    expect(dom.find('.node.full-opacity')).toBeDefined();
 
     component.tree = TreeNodeUtils.makeUiPropertyNode(
       component.tree.id,
       component.tree.name,
       0,
     );
-    fixture.detectChanges();
-    expect(htmlElement.querySelector('.node.full-opacity')).toBeTruthy();
+    dom.detectChanges();
+    expect(dom.find('.node.full-opacity')).toBeDefined();
   });
 
   it('shows node at non-full opacity when applicable', () => {
     component.rectIdToShowState = new Map([]);
-    fixture.detectChanges();
-    expect(htmlElement.querySelector('.node.full-opacity')).toBeNull();
+    dom.detectChanges();
+    expect(dom.find('.node.full-opacity')).toBeUndefined();
 
     component.rectIdToShowState = new Map([
       [component.tree.id, RectShowState.HIDE],
     ]);
-    fixture.detectChanges();
-    expect(htmlElement.querySelector('.node.full-opacity')).toBeNull();
+    dom.detectChanges();
+    expect(dom.find('.node.full-opacity')).toBeUndefined();
   });
 
   it('copies text via copy button without selecting node', () => {
-    fixture.detectChanges();
-
+    dom.detectChanges();
     component.tree = TreeNodeUtils.makeUiPropertyNode(
       component.tree.id,
       component.tree.name,
       0,
     );
-    fixture.detectChanges();
+    dom.detectChanges();
 
     const spy = spyOn(assertDefined(component.treeComponent), 'onNodeClick');
-    const copyButton = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.icon-wrapper-copy button'),
-    );
-    copyButton.click();
-    fixture.detectChanges();
+    dom.findAndClick('.icon-wrapper-copy button');
     expect(mockCopyText).toHaveBeenCalled();
     expect(spy).not.toHaveBeenCalled();
   });
@@ -315,31 +279,26 @@ describe('TreeComponent', () => {
   }
 
   function doubleClickFirstNode() {
-    assertDefined(
-      htmlElement.querySelector<HTMLElement>('tree-node'),
-    ).dispatchEvent(new MouseEvent('click', {detail: 2}));
-    fixture.detectChanges();
+    dom.get('tree-node').dispatchEvent(new MouseEvent('click', {detail: 2}));
   }
 
   function checkIsExpanded(isExpanded: boolean) {
-    expect(htmlElement.querySelector<HTMLElement>('.children')?.hidden).toEqual(
-      !isExpanded,
-    );
+    expect(dom.get('.children').getHTMLElement().hidden).toEqual(!isExpanded);
   }
 
   function checkNodeScrolling() {
-    const treeNode = assertDefined(htmlElement.querySelector(`#nodeChild79`));
+    const treeNode = dom.get(`#nodeChild79`).getHTMLElement();
     const spy = spyOn(treeNode, 'scrollIntoView').and.callThrough();
 
     component.highlightedItem = 'Root node';
-    fixture.detectChanges();
+    dom.detectChanges();
 
     component.highlightedItem = '79 Child79';
-    fixture.detectChanges();
+    dom.detectChanges();
     expect(spy).toHaveBeenCalledTimes(1);
 
     component.highlightedItem = '78 Child78';
-    fixture.detectChanges();
+    dom.detectChanges();
     expect(spy).toHaveBeenCalledTimes(1);
   }
 
diff --git a/tools/winscope/src/viewers/components/tree_node_component_test.ts b/tools/winscope/src/viewers/components/tree_node_component_test.ts
index 9df330bca..3d6c1eea6 100644
--- a/tools/winscope/src/viewers/components/tree_node_component_test.ts
+++ b/tools/winscope/src/viewers/components/tree_node_component_test.ts
@@ -16,10 +16,11 @@
 
 import {Clipboard, ClipboardModule} from '@angular/cdk/clipboard';
 import {Component, ViewChild} from '@angular/core';
-import {ComponentFixture, TestBed} from '@angular/core/testing';
+import {TestBed} from '@angular/core/testing';
 import {MatIconModule} from '@angular/material/icon';
 import {MatTooltipModule} from '@angular/material/tooltip';
 import {assertDefined} from 'common/assert_utils';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
 import {HierarchyTreeBuilder} from 'test/unit/hierarchy_tree_builder';
 import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
 import {DEFAULT_PROPERTY_FORMATTER} from 'trace/tree_node/formatters';
@@ -31,9 +32,8 @@ import {PropertyTreeNodeDataViewComponent} from './property_tree_node_data_view_
 import {TreeNodeComponent} from './tree_node_component';
 
 describe('TreeNodeComponent', () => {
-  let fixture: ComponentFixture<TestHostComponent>;
   let component: TestHostComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<TestHostComponent>;
   let mockCopyText: jasmine.Spy;
 
   const propertiesTree = UiPropertyTreeNode.from(
@@ -60,10 +60,10 @@ describe('TreeNodeComponent', () => {
       ],
       imports: [MatIconModule, MatTooltipModule, ClipboardModule],
     }).compileComponents();
-    fixture = TestBed.createComponent(TestHostComponent);
+    const fixture = TestBed.createComponent(TestHostComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
-    fixture.detectChanges();
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
+    dom.detectChanges();
   });
 
   it('can be created', () => {
@@ -71,37 +71,24 @@ describe('TreeNodeComponent', () => {
   });
 
   it('can generate hierarchy data view component', () => {
-    const treeNodeDataView = htmlElement.querySelector(
-      'hierarchy-tree-node-data-view',
-    );
-    expect(treeNodeDataView).toBeTruthy();
-    expect(
-      htmlElement.querySelector('property-tree-node-data-view'),
-    ).toBeNull();
+    expect(dom.find('hierarchy-tree-node-data-view')).toBeDefined();
+    expect(dom.find('property-tree-node-data-view')).toBeUndefined();
   });
 
   it('can generate property data view component', () => {
     component.node = propertiesTree;
-    fixture.detectChanges();
-    const treeNodeDataView = htmlElement.querySelector(
-      'property-tree-node-data-view',
-    );
-    expect(treeNodeDataView).toBeTruthy();
-    expect(
-      htmlElement.querySelector('hierarchy-tree-node-data-view'),
-    ).toBeNull();
+    dom.detectChanges();
+    expect(dom.find('property-tree-node-data-view')).toBeDefined();
+    expect(dom.find('hierarchy-tree-node-data-view')).toBeUndefined();
   });
 
   it('can trigger tree toggle on click of chevron', () => {
     const treeNodeComponent = assertDefined(component.treeNodeComponent);
     treeNodeComponent.showChevron = jasmine.createSpy().and.returnValue(true);
-    fixture.detectChanges();
+    dom.detectChanges();
 
     const spy = spyOn(treeNodeComponent.toggleTreeChange, 'emit');
-    const toggleButton = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.toggle-tree-btn'),
-    );
-    toggleButton.click();
+    dom.findAndClick('.toggle-tree-btn');
     expect(spy).toHaveBeenCalled();
   });
 
@@ -110,10 +97,7 @@ describe('TreeNodeComponent', () => {
       assertDefined(component.treeNodeComponent).expandTreeChange,
       'emit',
     );
-    const expandButton = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.expand-tree-btn'),
-    );
-    expandButton.click();
+    dom.findAndClick('.expand-tree-btn');
     expect(spy).toHaveBeenCalled();
   });
 
@@ -124,22 +108,20 @@ describe('TreeNodeComponent', () => {
     );
     component.isInPinnedSection = true;
     component.isSelected = true;
-    fixture.detectChanges();
+    dom.detectChanges();
     expect(spy).not.toHaveBeenCalled();
 
     component.isSelected = false;
     component.isInPinnedSection = false;
-    fixture.detectChanges();
+    dom.detectChanges();
     component.isSelected = true;
-    fixture.detectChanges();
+    dom.detectChanges();
     expect(spy).toHaveBeenCalledTimes(1);
   });
 
   it('assigns diff css classes to expand tree button', () => {
-    const expandButton = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.expand-tree-btn'),
-    );
-    expect(expandButton.className).toEqual('icon-button expand-tree-btn');
+    const expandButton = dom.get('.expand-tree-btn');
+    expandButton.checkClassNameExact('icon-button expand-tree-btn');
     component.node = UiHierarchyTreeNode.from(
       new HierarchyTreeBuilder()
         .setId('LayerTraceEntry')
@@ -150,8 +132,8 @@ describe('TreeNodeComponent', () => {
         .build(),
     );
     component.node.getChildByName('Child 1')?.setDiff(DiffType.ADDED);
-    fixture.detectChanges();
-    expect(expandButton.className).toEqual('icon-button expand-tree-btn added');
+    dom.detectChanges();
+    expandButton.checkClassNameExact('icon-button expand-tree-btn added');
 
     component.node = UiHierarchyTreeNode.from(
       new HierarchyTreeBuilder()
@@ -165,10 +147,8 @@ describe('TreeNodeComponent', () => {
     const child1 = assertDefined(component.node.getChildByName('Child 1'));
     child1.setDiff(DiffType.ADDED);
     child1.getChildByName('Child 2')?.setDiff(DiffType.DELETED);
-    fixture.detectChanges();
-    expect(expandButton.className).toEqual(
-      'icon-button expand-tree-btn modified',
-    );
+    dom.detectChanges();
+    expandButton.checkClassNameExact('icon-button expand-tree-btn modified');
   });
 
   it('pins node on click', () => {
@@ -176,59 +156,45 @@ describe('TreeNodeComponent', () => {
     treeNodeComponent.showPinNodeIcon = jasmine
       .createSpy()
       .and.returnValue(true);
-    fixture.detectChanges();
+    dom.detectChanges();
 
     const spy = spyOn(treeNodeComponent.pinNodeChange, 'emit');
-    const pinNodeButton = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.pin-node-btn'),
-    );
-    pinNodeButton.click();
+    dom.findAndClick('.pin-node-btn');
     expect(spy).toHaveBeenCalledWith(component.node as UiHierarchyTreeNode);
   });
 
   it('can trigger rect show state toggle on click of icon', () => {
     const treeNodeComponent = assertDefined(component.treeNodeComponent);
     treeNodeComponent.showStateIcon = 'visibility';
-    fixture.detectChanges();
+    dom.detectChanges();
 
     const spy = spyOn(treeNodeComponent.rectShowStateChange, 'emit');
-    const showStateButton = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.toggle-rect-show-state-btn'),
-    );
-    showStateButton.click();
+    dom.findAndClick('.toggle-rect-show-state-btn');
     expect(spy).toHaveBeenCalled();
   });
 
   it('does not show copy button for hierarchy tree', () => {
-    expect(htmlElement.querySelector('.icon-wrapper-copy')).toBeNull();
+    expect(dom.find('.icon-wrapper-copy')).toBeUndefined();
   });
 
   it('does not show copy button for property tree node that is not leaf or root', () => {
     component.node = assertDefined(propertiesTree.getChildByName('key2'));
-    fixture.detectChanges();
-    expect(htmlElement.querySelector('.icon-wrapper-copy')).toBeNull();
+    dom.detectChanges();
+    expect(dom.find('.icon-wrapper-copy')).toBeUndefined();
   });
 
   it('copies node name for root of property tree node', () => {
     component.node = propertiesTree;
-    fixture.detectChanges();
-    const copyButton = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.icon-wrapper-copy button'),
-    );
-    copyButton.click();
-    fixture.detectChanges();
+    dom.detectChanges();
+    dom.findAndClick('.icon-wrapper-copy button');
     expect(mockCopyText).toHaveBeenCalledWith(propertiesTree.name);
   });
 
   it('copies property name and value for leaf node', () => {
     component.node = assertDefined(propertiesTree.getChildByName('key1'));
     component.isLeaf = true;
-    fixture.detectChanges();
-    const copyButton = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.icon-wrapper-copy button'),
-    );
-    copyButton.click();
-    fixture.detectChanges();
+    dom.detectChanges();
+    dom.findAndClick('.icon-wrapper-copy button');
     expect(mockCopyText).toHaveBeenCalledWith('key1: value1');
   });
 
diff --git a/tools/winscope/src/viewers/components/user_options_component_test.ts b/tools/winscope/src/viewers/components/user_options_component_test.ts
index d9a56973c..d62897ff0 100644
--- a/tools/winscope/src/viewers/components/user_options_component_test.ts
+++ b/tools/winscope/src/viewers/components/user_options_component_test.ts
@@ -14,19 +14,19 @@
  * limitations under the License.
  */
 
-import {ComponentFixture, TestBed} from '@angular/core/testing';
+import {TestBed} from '@angular/core/testing';
 import {MatButtonModule} from '@angular/material/button';
 import {MatIconModule} from '@angular/material/icon';
 import {assertDefined} from 'common/assert_utils';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
 import {TraceType} from 'trace/trace_type';
 import {VISIBLE_CHIP} from 'viewers/common/chip';
 import {UserOptions} from 'viewers/common/user_options';
 import {UserOptionsComponent} from './user_options_component';
 
 describe('UserOptionsComponent', () => {
-  let fixture: ComponentFixture<UserOptionsComponent>;
   let component: UserOptionsComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<UserOptionsComponent>;
   const testEventType = 'TestEventType';
 
   beforeEach(async () => {
@@ -34,9 +34,9 @@ describe('UserOptionsComponent', () => {
       imports: [MatButtonModule, MatIconModule],
       declarations: [UserOptionsComponent],
     }).compileComponents();
-    fixture = TestBed.createComponent(UserOptionsComponent);
+    const fixture = TestBed.createComponent(UserOptionsComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
     component.userOptions = {
       option1: {
         name: 'option 1',
@@ -58,7 +58,7 @@ describe('UserOptionsComponent', () => {
     };
     component.eventType = testEventType;
     component.traceType = TraceType.SURFACE_FLINGER;
-    fixture.detectChanges();
+    dom.detectChanges();
   });
 
   it('can be created', () => {
@@ -66,47 +66,37 @@ describe('UserOptionsComponent', () => {
   });
 
   it('displays options', () => {
-    const options = htmlElement.querySelectorAll('.user-option');
+    const options = dom.findAll('.user-option');
     expect(options.length).toEqual(3);
 
-    expect(options.item(0).textContent).toContain('option 1');
-    expect(options.item(0).querySelector('.user-option-chip')).toBeNull();
-    expect(options.item(0).querySelector('.mat-icon')).toBeNull();
+    options[0].checkText('option 1');
+    expect(options[0].find('.user-option-chip')).toBeUndefined();
+    expect(options[0].find('.mat-icon')).toBeUndefined();
 
-    expect(options.item(1).textContent).toContain('option with chip');
-    expect(
-      options.item(1).querySelector('.user-option-chip')?.textContent,
-    ).toContain('V');
-    expect(options.item(1).querySelector('.mat-icon')).toBeNull();
+    options[1].checkText('option with chip');
+    options[1].get('.user-option-chip').checkText('V');
+    expect(options[1].find('.mat-icon')).toBeUndefined();
 
-    expect(options.item(2).textContent).toContain('option with icon');
-    expect(options.item(2).querySelector('.user-option-chip')).toBeNull();
-    expect(options.item(2).querySelector('.mat-icon')?.textContent).toContain(
-      'visibility',
-    );
+    options[2].checkText('option with icon');
+    expect(options[2].find('.user-option-chip')).toBeUndefined();
+    options[2].get('.mat-icon').checkTextExact('visibility');
   });
 
   it('disables option if unavailable', () => {
-    let option = assertDefined(htmlElement.querySelector('.user-option'));
-    expect((option as HTMLButtonElement).disabled).toBeFalse();
-
+    const option = dom.get('.user-option');
+    option.checkDisabled(false);
     component.userOptions['option1'].isUnavailable = true;
-    fixture.detectChanges();
-    option = assertDefined(htmlElement.querySelector('.user-option'));
-    expect((option as HTMLInputElement).disabled).toBeTrue();
+    dom.detectChanges();
+    option.checkDisabled(true);
   });
 
   it('emits event on user option change', () => {
     let options: UserOptions | undefined;
-    htmlElement.addEventListener(testEventType, (event) => {
+    dom.addEventListener(testEventType, (event) => {
       options = (event as CustomEvent).detail.userOptions;
     });
     const logSpy = spyOn(component, 'logCallback');
-    const option = assertDefined(
-      htmlElement.querySelector('.user-option'),
-    ) as HTMLInputElement;
-    option.click();
-    fixture.detectChanges();
+    dom.findAndClick('.user-option');
     expect(assertDefined(options)['option1'].enabled).toBeTrue();
     expect(logSpy).toHaveBeenCalled();
   });
diff --git a/tools/winscope/src/viewers/components/view_capture_property_groups_component_test.ts b/tools/winscope/src/viewers/components/view_capture_property_groups_component_test.ts
index 420bd197b..b416fb79a 100644
--- a/tools/winscope/src/viewers/components/view_capture_property_groups_component_test.ts
+++ b/tools/winscope/src/viewers/components/view_capture_property_groups_component_test.ts
@@ -14,22 +14,17 @@
  * limitations under the License.
  */
 import {Component} from '@angular/core';
-import {
-  ComponentFixture,
-  ComponentFixtureAutoDetect,
-  TestBed,
-} from '@angular/core/testing';
+import {ComponentFixtureAutoDetect, TestBed} from '@angular/core/testing';
 import {MatDividerModule} from '@angular/material/divider';
 import {MatTooltipModule} from '@angular/material/tooltip';
-import {assertDefined} from 'common/assert_utils';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
 import {VcCuratedProperties} from 'viewers/common/curated_properties';
 import {TransformMatrixComponent} from './transform_matrix_component';
 import {ViewCapturePropertyGroupsComponent} from './view_capture_property_groups_component';
 
 describe('ViewCapturePropertyGroupsComponent', () => {
-  let fixture: ComponentFixture<TestHostComponent>;
   let component: TestHostComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<TestHostComponent>;
 
   beforeEach(async () => {
     await TestBed.configureTestingModule({
@@ -41,10 +36,10 @@ describe('ViewCapturePropertyGroupsComponent', () => {
         TransformMatrixComponent,
       ],
     }).compileComponents();
-    fixture = TestBed.createComponent(TestHostComponent);
+    const fixture = TestBed.createComponent(TestHostComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
-    fixture.detectChanges();
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
+    dom.detectChanges();
   });
 
   it('can be created', () => {
@@ -52,112 +47,52 @@ describe('ViewCapturePropertyGroupsComponent', () => {
   });
 
   it('displays view section', () => {
-    const viewSection = assertDefined(htmlElement.querySelector('.view'));
-    expect(
-      assertDefined(viewSection.querySelector('.class-name')).innerHTML,
-    ).toContain('test.package.name');
-    expect(
-      assertDefined(viewSection.querySelector('.hashcode')).innerHTML,
-    ).toContain('12345678');
+    const section = dom.get('.view');
+    section.get('.class-name').checkText('test.package.name');
+    section.get('.hashcode').checkText('12345678');
   });
 
   it('displays geometry coordinates section', () => {
-    const coordinatesSection = assertDefined(
-      htmlElement.querySelector('.geometry .coordinates'),
-    );
-    const left = assertDefined(coordinatesSection.querySelector('.left'));
-    expect(left.innerHTML).toContain('Left:');
-    expect(left.innerHTML).toContain('0');
-    const top = assertDefined(coordinatesSection.querySelector('.top'));
-    expect(top.innerHTML).toContain('Top:');
-    expect(top.innerHTML).toContain('5');
-    const elevation = assertDefined(
-      coordinatesSection.querySelector('.elevation'),
-    );
-    expect(elevation.innerHTML).toContain('Elevation:');
-    expect(elevation.innerHTML).toContain('2');
+    const section = dom.get('.geometry .coordinates');
+    section.get('.left').checkTextExact('Left:  0');
+    section.get('.top').checkTextExact('Top:  5');
+    section.get('.elevation').checkTextExact('Elevation:  2');
   });
 
   it('displays geometry size section', () => {
-    const sizeSection = assertDefined(
-      htmlElement.querySelector('.geometry .size'),
-    );
-    const height = assertDefined(sizeSection.querySelector('.height'));
-    expect(height.innerHTML).toContain('Height:');
-    expect(height.innerHTML).toContain('86');
-    const width = assertDefined(sizeSection.querySelector('.width'));
-    expect(width.innerHTML).toContain('Width:');
-    expect(width.innerHTML).toContain('826');
+    const section = dom.get('.geometry .size');
+    section.get('.height').checkTextExact('Height:  86');
+    section.get('.width').checkTextExact('Width:  826');
   });
 
   it('displays geometry translation section', () => {
-    const translationSection = assertDefined(
-      htmlElement.querySelector('.geometry .translation'),
-    );
-    const translationx = assertDefined(
-      translationSection.querySelector('.translationx'),
-    );
-    expect(translationx.innerHTML).toContain('Translation X:');
-    expect(translationx.innerHTML).toContain('0');
-    const translationy = assertDefined(
-      translationSection.querySelector('.translationy'),
-    );
-    expect(translationy.innerHTML).toContain('Translation Y:');
-    expect(translationy.innerHTML).toContain('0');
+    const section = dom.get('.geometry .translation');
+    section.get('.translationx').checkTextExact('Translation X:  0');
+    section.get('.translationy').checkTextExact('Translation Y:  0');
   });
 
   it('displays geometry scroll section', () => {
-    const scrollSection = assertDefined(
-      htmlElement.querySelector('.geometry .scroll'),
-    );
-    const scrollx = assertDefined(scrollSection.querySelector('.scrollx'));
-    expect(scrollx.innerHTML).toContain('Scroll X:');
-    expect(scrollx.innerHTML).toContain('1');
-    const scrolly = assertDefined(scrollSection.querySelector('.scrolly'));
-    expect(scrolly.innerHTML).toContain('Scroll Y:');
-    expect(scrolly.innerHTML).toContain('1');
+    const section = dom.get('.geometry .scroll');
+    section.get('.scrollx').checkTextExact('Scroll X:  1');
+    section.get('.scrolly').checkTextExact('Scroll Y:  1');
   });
 
   it('displays geometry scale section', () => {
-    const scaleSection = assertDefined(
-      htmlElement.querySelector('.geometry .scale'),
-    );
-    const scalex = assertDefined(scaleSection.querySelector('.scalex'));
-    expect(scalex.innerHTML).toContain('Scale X:');
-    expect(scalex.innerHTML).toContain('2');
-    const scaley = assertDefined(scaleSection.querySelector('.scaley'));
-    expect(scaley.innerHTML).toContain('Scale Y:');
-    expect(scaley.innerHTML).toContain('2');
+    const section = dom.get('.geometry .scale');
+    section.get('.scalex').checkTextExact('Scale X:  2');
+    section.get('.scaley').checkTextExact('Scale Y:  2');
   });
 
   it('displays effects translation section', () => {
-    const translationSection = assertDefined(
-      htmlElement.querySelector('.effects .translation'),
-    );
-    const visibility = assertDefined(
-      translationSection.querySelector('.visibility'),
-    );
-    expect(visibility.innerHTML).toContain('Visibility:');
-    expect(visibility.innerHTML).toContain('0');
-    const alpha = assertDefined(translationSection.querySelector('.alpha'));
-    expect(alpha.innerHTML).toContain('Alpha:');
-    expect(alpha.innerHTML).toContain('1');
-    const willNotDraw = assertDefined(
-      translationSection.querySelector('.will-not-draw'),
-    );
-    expect(willNotDraw.innerHTML).toContain('Will Not Draw:');
-    expect(willNotDraw.innerHTML).toContain('true');
+    const section = dom.get('.effects .translation');
+    section.get('.visibility').checkTextExact('Visibility:  0');
+    section.get('.alpha').checkTextExact('Alpha:  1');
+    section.get('.will-not-draw').checkTextExact('Will Not Draw:  true');
   });
 
   it('displays effects misc section', () => {
-    const miscSection = assertDefined(
-      htmlElement.querySelector('.effects .misc'),
-    );
-    const clipChildren = assertDefined(
-      miscSection.querySelector('.clip-children'),
-    );
-    expect(clipChildren.innerHTML).toContain('Clip Children:');
-    expect(clipChildren.innerHTML).toContain('false');
+    const section = dom.get('.effects .misc');
+    section.get('.clip-children').checkTextExact('Clip Children:  false');
   });
 
   @Component({
diff --git a/tools/winscope/src/viewers/components/viewer_input_method_component_test.ts b/tools/winscope/src/viewers/components/viewer_input_method_component_test.ts
index 6759f71b2..a80f5abc8 100644
--- a/tools/winscope/src/viewers/components/viewer_input_method_component_test.ts
+++ b/tools/winscope/src/viewers/components/viewer_input_method_component_test.ts
@@ -14,108 +14,47 @@
  * limitations under the License.
  */
 
-import {CUSTOM_ELEMENTS_SCHEMA} from '@angular/core';
-import {
-  ComponentFixture,
-  ComponentFixtureAutoDetect,
-  TestBed,
-} from '@angular/core/testing';
-import {FormsModule} from '@angular/forms';
-import {MatButtonModule} from '@angular/material/button';
-import {MatDividerModule} from '@angular/material/divider';
-import {MatIconModule} from '@angular/material/icon';
-import {MatTooltipModule} from '@angular/material/tooltip';
-import {UnitTestUtils} from 'test/unit/utils';
-import {TraceType} from 'trace/trace_type';
-import {ImeUiData} from 'viewers/common/ime_ui_data';
-import {CollapsedSectionsComponent} from './collapsed_sections_component';
-import {CollapsibleSectionTitleComponent} from './collapsible_section_title_component';
-import {HierarchyComponent} from './hierarchy_component';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
+import {AbstractHierarchyViewerComponentTest} from 'viewers/common/abstract_hierarchy_viewer_component_test';
 import {ImeAdditionalPropertiesComponent} from './ime_additional_properties_component';
-import {PropertiesComponent} from './properties_component';
 import {ViewerInputMethodComponent} from './viewer_input_method_component';
 
-describe('ViewerInputMethodComponent', () => {
-  let fixture: ComponentFixture<ViewerInputMethodComponent>;
-  let component: ViewerInputMethodComponent;
-  let htmlElement: HTMLElement;
-
-  beforeEach(async () => {
-    await TestBed.configureTestingModule({
-      providers: [{provide: ComponentFixtureAutoDetect, useValue: true}],
-      imports: [
-        MatIconModule,
-        MatDividerModule,
-        MatButtonModule,
-        MatTooltipModule,
-        FormsModule,
-      ],
-      declarations: [
-        ViewerInputMethodComponent,
-        HierarchyComponent,
-        PropertiesComponent,
-        ImeAdditionalPropertiesComponent,
-        CollapsedSectionsComponent,
-        CollapsibleSectionTitleComponent,
-      ],
-      schemas: [CUSTOM_ELEMENTS_SCHEMA],
-    }).compileComponents();
-    fixture = TestBed.createComponent(ViewerInputMethodComponent);
-    component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
-    component.inputData = new ImeUiData(TraceType.INPUT_METHOD_CLIENTS);
-    fixture.detectChanges();
-  });
-
-  it('can be created', () => {
-    expect(component).toBeTruthy();
-  });
-
-  it('creates hierarchy view', () => {
-    const hierarchyView = htmlElement.querySelector('.hierarchy-view');
-    expect(hierarchyView).toBeTruthy();
-  });
-
-  it('creates additional properties view', () => {
-    const additionalProperties = htmlElement.querySelector(
-      '.ime-additional-properties',
-    );
-    expect(additionalProperties).toBeTruthy();
-  });
+class ViewerInputMethodComponentTest extends AbstractHierarchyViewerComponentTest<ViewerInputMethodComponent> {
+  protected override readonly testRects = false;
+  protected override readonly hierarchyTitle = 'HIERARCHY';
+  protected override readonly propertiesTitle = 'PROPERTIES';
+
+  protected override executeSpecializedTests() {
+    describe('Specialized tests', () => {
+      let dom: DOMTestHelper<ViewerInputMethodComponent>;
+      let component: ViewerInputMethodComponent;
+
+      beforeEach(async () => {
+        [dom, component] = await this.setUpTestEnvironment();
+      });
+
+      it('creates additional properties view', () => {
+        expect(dom.find('.ime-additional-properties')).toBeDefined();
+      });
+
+      it('handles ime additional properties section collapse/expand', () => {
+        dom.checkSectionCollapseAndExpand(
+          '.ime-additional-properties',
+          'WM & SF PROPERTIES',
+        );
+      });
+    });
+  }
+
+  protected async setUpTestEnvironment(): Promise<
+    [DOMTestHelper<ViewerInputMethodComponent>, ViewerInputMethodComponent]
+  > {
+    return this.initializeTestEnvironment(ViewerInputMethodComponent, [
+      ImeAdditionalPropertiesComponent,
+    ]);
+  }
+}
 
-  it('creates properties view', () => {
-    const propertiesView = htmlElement.querySelector('.properties-view');
-    expect(propertiesView).toBeTruthy();
-  });
-
-  it('creates collapsed sections with no buttons', () => {
-    UnitTestUtils.checkNoCollapsedSectionButtons(htmlElement);
-  });
-
-  it('handles hierarchy section collapse/expand', () => {
-    UnitTestUtils.checkSectionCollapseAndExpand(
-      htmlElement,
-      fixture,
-      '.hierarchy-view',
-      'HIERARCHY',
-    );
-  });
-
-  it('handles ime additional properties section collapse/expand', () => {
-    UnitTestUtils.checkSectionCollapseAndExpand(
-      htmlElement,
-      fixture,
-      '.ime-additional-properties',
-      'WM & SF PROPERTIES',
-    );
-  });
-
-  it('handles properties section collapse/expand', () => {
-    UnitTestUtils.checkSectionCollapseAndExpand(
-      htmlElement,
-      fixture,
-      '.properties-view',
-      'PROPERTIES',
-    );
-  });
+describe('ViewerInputMethodComponent', () => {
+  new ViewerInputMethodComponentTest().execute();
 });
diff --git a/tools/winscope/src/viewers/viewer_input/input_height_predictor.ts b/tools/winscope/src/viewers/viewer_input/input_height_predictor.ts
new file mode 100644
index 000000000..318dc6333
--- /dev/null
+++ b/tools/winscope/src/viewers/viewer_input/input_height_predictor.ts
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import {assertString} from 'common/assert_utils';
+import {ItemHeightPredictor} from 'viewers/common/item_height_predictor';
+import {InputEntry} from 'viewers/viewer_input/ui_data';
+
+export class InputHeightPredictor extends ItemHeightPredictor {
+  protected override readonly defaultRowSize = 24;
+  private readonly actionCharsPerRow = 11;
+
+  override predictHeight(entry: InputEntry): number {
+    const action = assertString(entry.fields[2].value);
+    return this.subItemHeight(action, this.actionCharsPerRow);
+  }
+}
diff --git a/tools/winscope/src/viewers/viewer_input/operations/dispatched_pointer_axis.ts b/tools/winscope/src/viewers/viewer_input/operations/dispatched_pointer_axis.ts
new file mode 100644
index 000000000..f020ffc45
--- /dev/null
+++ b/tools/winscope/src/viewers/viewer_input/operations/dispatched_pointer_axis.ts
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+export enum DispatchedPointerAxis {
+  X = 0,
+  Y = 1,
+}
diff --git a/tools/winscope/src/viewers/viewer_input/operations/dispatch_entry_formatter.ts b/tools/winscope/src/viewers/viewer_input/operations/format_dispatch_entry.ts
similarity index 92%
rename from tools/winscope/src/viewers/viewer_input/operations/dispatch_entry_formatter.ts
rename to tools/winscope/src/viewers/viewer_input/operations/format_dispatch_entry.ts
index c5c06b636..a7110a8f4 100644
--- a/tools/winscope/src/viewers/viewer_input/operations/dispatch_entry_formatter.ts
+++ b/tools/winscope/src/viewers/viewer_input/operations/format_dispatch_entry.ts
@@ -17,11 +17,9 @@
 import {FixedStringFormatter} from 'trace/tree_node/formatters';
 import {Operation} from 'trace/tree_node/operations/operation';
 import {UiPropertyTreeNode} from 'viewers/common/ui_property_tree_node';
+import {DispatchedPointerAxis} from './dispatched_pointer_axis';
 
-export class DispatchEntryFormatter implements Operation<UiPropertyTreeNode> {
-  static readonly AXIS_X = 0;
-  static readonly AXIS_Y = 1;
-
+export class FormatDispatchEntry implements Operation<UiPropertyTreeNode> {
   constructor(private readonly layerIdToName: Map<number, string>) {}
 
   apply(node: UiPropertyTreeNode): void {
@@ -68,11 +66,11 @@ export class DispatchEntryFormatter implements Operation<UiPropertyTreeNode> {
       let y = '?';
       axisValues?.getAllChildren()?.forEach((axisValue) => {
         const axis = Number(axisValue.getChildByName('axis')?.getValue());
-        if (axis === DispatchEntryFormatter.AXIS_X) {
+        if (axis === DispatchedPointerAxis.X) {
           x = axisValue.getChildByName('value')?.getValue()?.toFixed(2) ?? '?';
           return;
         }
-        if (axis === DispatchEntryFormatter.AXIS_Y) {
+        if (axis === DispatchedPointerAxis.Y) {
           y = axisValue.getChildByName('value')?.getValue()?.toFixed(2) ?? '?';
           return;
         }
diff --git a/tools/winscope/src/viewers/viewer_input/operations/dispatch_entry_formatter_test.ts b/tools/winscope/src/viewers/viewer_input/operations/format_dispatch_entry_test.ts
similarity index 97%
rename from tools/winscope/src/viewers/viewer_input/operations/dispatch_entry_formatter_test.ts
rename to tools/winscope/src/viewers/viewer_input/operations/format_dispatch_entry_test.ts
index 4690660f1..d45eb53d2 100644
--- a/tools/winscope/src/viewers/viewer_input/operations/dispatch_entry_formatter_test.ts
+++ b/tools/winscope/src/viewers/viewer_input/operations/format_dispatch_entry_test.ts
@@ -16,17 +16,17 @@
 
 import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
 import {UiPropertyTreeNode} from 'viewers/common/ui_property_tree_node';
-import {DispatchEntryFormatter} from './dispatch_entry_formatter';
+import {FormatDispatchEntry} from './format_dispatch_entry';
 
-describe('DispatchEntryFormatter', () => {
-  let operation: DispatchEntryFormatter;
+describe('FormatDispatchEntry', () => {
+  let operation: FormatDispatchEntry;
   const layerIdToName = new Map<number, string>([
     [1, 'one'],
     [2, 'two'],
   ]);
 
   beforeEach(() => {
-    operation = new DispatchEntryFormatter(layerIdToName);
+    operation = new FormatDispatchEntry(layerIdToName);
   });
 
   it('formats dispatch entry node', () => {
diff --git a/tools/winscope/src/viewers/viewer_input/operations/input_coordinate_propagator.ts b/tools/winscope/src/viewers/viewer_input/operations/input_coordinate_propagator.ts
index 01800532d..d27966b74 100644
--- a/tools/winscope/src/viewers/viewer_input/operations/input_coordinate_propagator.ts
+++ b/tools/winscope/src/viewers/viewer_input/operations/input_coordinate_propagator.ts
@@ -18,6 +18,7 @@ import {assertDefined} from 'common/assert_utils';
 import {Operation} from 'trace/tree_node/operations/operation';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 import {PropertyTreeNodeFactory} from 'trace/tree_node/property_tree_node_factory';
+import {DispatchedPointerAxis} from './dispatched_pointer_axis';
 
 /**
  * A single input event can be dispatched to multiple windows, where each dispatch
@@ -28,9 +29,6 @@ import {PropertyTreeNodeFactory} from 'trace/tree_node/property_tree_node_factor
  * logged to save space.
  */
 export class InputCoordinatePropagator implements Operation<PropertyTreeNode> {
-  static readonly AXIS_X = 0;
-  static readonly AXIS_Y = 1;
-
   private propertyTreeNodeFactory = new PropertyTreeNodeFactory();
 
   apply(root: PropertyTreeNode): void {
@@ -68,8 +66,8 @@ export class InputCoordinatePropagator implements Operation<PropertyTreeNode> {
           axisValues.getAllChildren().forEach((axisValue) => {
             const axis = Number(axisValue.getChildByName('axis')?.getValue());
             if (
-              axis !== InputCoordinatePropagator.AXIS_X &&
-              axis !== InputCoordinatePropagator.AXIS_Y
+              axis !== DispatchedPointerAxis.X &&
+              axis !== DispatchedPointerAxis.Y
             ) {
               return;
             }
@@ -83,22 +81,14 @@ export class InputCoordinatePropagator implements Operation<PropertyTreeNode> {
           });
 
           // Populate the X and Y axis values
-          if (!populatedAxes.has(InputCoordinatePropagator.AXIS_X)) {
+          if (!populatedAxes.has(DispatchedPointerAxis.X)) {
             const xAxisValue = this.addPropertyTo(axisValues, 'x');
-            this.addPropertyTo(
-              xAxisValue,
-              'axis',
-              InputCoordinatePropagator.AXIS_X,
-            );
+            this.addPropertyTo(xAxisValue, 'axis', DispatchedPointerAxis.X);
             this.addPropertyTo(xAxisValue, 'value', eventXY[0]);
           }
-          if (!populatedAxes.has(InputCoordinatePropagator.AXIS_Y)) {
+          if (!populatedAxes.has(DispatchedPointerAxis.Y)) {
             const yAxisValue = this.addPropertyTo(axisValues, 'y');
-            this.addPropertyTo(
-              yAxisValue,
-              'axis',
-              InputCoordinatePropagator.AXIS_Y,
-            );
+            this.addPropertyTo(yAxisValue, 'axis', DispatchedPointerAxis.Y);
             this.addPropertyTo(yAxisValue, 'value', eventXY[1]);
           }
 
@@ -135,7 +125,7 @@ export class InputCoordinatePropagator implements Operation<PropertyTreeNode> {
     motionEventTree
       .getChildByName('pointer')
       ?.getAllChildren()
-      ?.forEach((pointer) => {
+      .forEach((pointer) => {
         const pointerId = pointer.getChildByName('pointerId')?.getValue();
         if (pointerId === undefined) return;
 
@@ -144,11 +134,11 @@ export class InputCoordinatePropagator implements Operation<PropertyTreeNode> {
         let y: number | undefined;
         axisValues?.getAllChildren()?.forEach((axisValue) => {
           const axis = Number(axisValue.getChildByName('axis')?.getValue());
-          if (axis === InputCoordinatePropagator.AXIS_X) {
+          if (axis === DispatchedPointerAxis.X) {
             x = axisValue.getChildByName('value')?.getValue();
             return;
           }
-          if (axis === InputCoordinatePropagator.AXIS_Y) {
+          if (axis === DispatchedPointerAxis.Y) {
             y = axisValue.getChildByName('value')?.getValue();
             return;
           }
diff --git a/tools/winscope/src/viewers/viewer_input/presenter.ts b/tools/winscope/src/viewers/viewer_input/presenter.ts
index bf8b4a833..bb581714f 100644
--- a/tools/winscope/src/viewers/viewer_input/presenter.ts
+++ b/tools/winscope/src/viewers/viewer_input/presenter.ts
@@ -48,7 +48,7 @@ import {
   convertRectIdToLayerorDisplayName,
   makeDisplayIdentifiers,
 } from 'viewers/viewer_surface_flinger/presenter';
-import {DispatchEntryFormatter} from './operations/dispatch_entry_formatter';
+import {FormatDispatchEntry} from './operations/format_dispatch_entry';
 import {InputCoordinatePropagator} from './operations/input_coordinate_propagator';
 import {InputEntry, UiData} from './ui_data';
 
@@ -111,10 +111,11 @@ export class Presenter extends AbstractLogViewerPresenter<
     {},
     new TextFilter(),
     Presenter.DENYLIST_DISPATCH_PROPERTIES,
-    [new DispatchEntryFormatter(this.layerIdToName)],
+    [new FormatDispatchEntry(this.layerIdToName)],
   );
   protected override keepCalculated = true;
   private readonly currentTargetWindowIds = new Set<string>();
+  private currDispatchProperties: PropertyTreeNode | undefined;
 
   private readonly rectsPresenter = new RectsPresenter(
     PersistentStoreProxy.new<UserOptions>(
@@ -133,10 +134,13 @@ export class Presenter extends AbstractLogViewerPresenter<
       },
       this.storage,
     ),
-    (tree: HierarchyTreeNode) =>
-      UI_RECT_FACTORY.makeInputRects(tree, (id) =>
-        this.currentTargetWindowIds.has(id.split(' ')[0]),
-      ),
+    (tree: HierarchyTreeNode) => {
+      return UI_RECT_FACTORY.makeInputRects(
+        tree,
+        (id) => this.currentTargetWindowIds.has(id.split(' ')[0]),
+        this.currDispatchProperties,
+      );
+    },
     makeDisplayIdentifiers,
     convertRectIdToLayerorDisplayName,
   );
@@ -238,7 +242,7 @@ export class Presenter extends AbstractLogViewerPresenter<
     return uniqueFieldValues;
   }
 
-  protected override updateFiltersInHeaders(
+  protected override async updateFiltersInHeaders(
     headers: LogHeader[],
     entries: LogEntry[],
   ) {
@@ -313,9 +317,7 @@ export class Presenter extends AbstractLogViewerPresenter<
         },
         {
           spec: Presenter.COLUMNS.action,
-          value: assertDefined(eventTree.getChildByName('action'))
-            .formattedValue()
-            .replace('ACTION_', ''),
+          value: Presenter.getInputAction(eventTree),
         },
         {
           spec: Presenter.COLUMNS.deviceId,
@@ -347,12 +349,27 @@ export class Presenter extends AbstractLogViewerPresenter<
             .join(', '),
         },
       ],
-      eventTree,
-      dispatchTree,
+      async () => assertDefined(eventTree),
+      async () => dispatchTree,
       sfEntry,
     );
   }
 
+  private static getInputAction(eventTree: PropertyTreeNode): string {
+    const actionNode = assertDefined(eventTree.getChildByName('action'));
+    const action = actionNode.getValue();
+    const actionMasked = action & 0xff;
+    const pointerIndex = action >> 8;
+    switch (actionMasked) {
+      case 5:
+        return `POINTER_DOWN(${pointerIndex})`;
+      case 6:
+        return `POINTER_UP(${pointerIndex})`;
+      default:
+        return actionNode.formattedValue().replace('ACTION_', '');
+    }
+  }
+
   private getLayerDisplayName(layerId: number): string {
     // Surround the name using the invisible zero-width non-joiner character to ensure
     // the full string is matched while filtering.
@@ -367,10 +384,10 @@ export class Presenter extends AbstractLogViewerPresenter<
   ): string {
     const keyDetails =
       'Keycode: ' +
-        eventTree
-          .getChildByName('keyCode')
-          ?.formattedValue()
-          ?.replace(/^KEYCODE_/, '') ?? '<?>';
+      (eventTree
+        .getChildByName('keyCode')
+        ?.formattedValue()
+        ?.replace(/^KEYCODE_/, '') ?? '<?>');
     return keyDetails + ' ' + Presenter.extractDispatchDetails(dispatchTree);
   }
 
@@ -400,7 +417,9 @@ export class Presenter extends AbstractLogViewerPresenter<
 
   private async updateDispatchPropertiesTree() {
     const inputEntry = this.getCurrentEntry();
-    const tree = inputEntry?.dispatchPropertiesTree;
+    const tree = inputEntry?.getDispatchPropertiesTree
+      ? await inputEntry.getDispatchPropertiesTree()
+      : undefined;
     this.dispatchPropertiesPresenter.setPropertiesTree(tree);
     await this.dispatchPropertiesPresenter.formatPropertiesTree(
       undefined,
@@ -419,18 +438,22 @@ export class Presenter extends AbstractLogViewerPresenter<
     const inputEntry = this.getCurrentEntry();
 
     this.currentTargetWindowIds.clear();
-    inputEntry?.dispatchPropertiesTree
-      ?.getAllChildren()
-      ?.forEach((dispatchEntry) => {
+    this.currDispatchProperties = undefined;
+
+    const dispatchProperties = await inputEntry?.getDispatchPropertiesTree?.();
+    if (dispatchProperties) {
+      dispatchProperties.getAllChildren()?.forEach((dispatchEntry) => {
         const windowId = dispatchEntry.getChildByName('windowId');
         if (windowId !== undefined) {
           this.currentTargetWindowIds.add(`${Number(windowId.getValue())}`);
         }
       });
+    }
 
     if (inputEntry?.surfaceFlingerEntry !== undefined) {
       const startTimeMs = Date.now();
       const node = await inputEntry.surfaceFlingerEntry.getValue();
+      this.currDispatchProperties = dispatchProperties;
       this.rectsPresenter.applyHierarchyTreesChange([
         {trace: this.surfaceFlingerTrace, trees: [node]},
       ]);
diff --git a/tools/winscope/src/viewers/viewer_input/presenter_test.ts b/tools/winscope/src/viewers/viewer_input/presenter_test.ts
index 759bd15df..2bf8c04d2 100644
--- a/tools/winscope/src/viewers/viewer_input/presenter_test.ts
+++ b/tools/winscope/src/viewers/viewer_input/presenter_test.ts
@@ -22,13 +22,13 @@ import {
   TabbedViewSwitchRequest,
   TracePositionUpdate,
 } from 'messaging/winscope_event';
-import {Transform} from 'parsers/surface_flinger/transform_utils';
+import {getTracesParser} from 'test/unit/fixture_utils';
 import {HierarchyTreeBuilder} from 'test/unit/hierarchy_tree_builder';
 import {TracesBuilder} from 'test/unit/traces_builder';
 import {TraceBuilder} from 'test/unit/trace_builder';
-import {UnitTestUtils} from 'test/unit/utils';
 import {CustomQueryType} from 'trace/custom_query';
 import {Parser} from 'trace/parser';
+import {Transform} from 'trace/surface_flinger/transform_utils';
 import {Trace} from 'trace/trace';
 import {Traces} from 'trace/traces';
 import {TRACE_INFO} from 'trace/trace_info';
@@ -42,6 +42,7 @@ import {VISIBLE_CHIP} from 'viewers/common/chip';
 import {LogSelectFilter} from 'viewers/common/log_filters';
 import {TextFilter} from 'viewers/common/text_filter';
 import {LogField, LogHeader} from 'viewers/common/ui_data_log';
+import {UI_RECT_FACTORY} from 'viewers/common/ui_rect_factory';
 import {UserOptions} from 'viewers/common/user_options';
 import {ViewerEvents} from 'viewers/common/viewer_events';
 import {TraceRectType} from 'viewers/components/rects/rect_spec';
@@ -142,9 +143,9 @@ class PresenterInputTest extends AbstractLogViewerPresenterTest<UiData> {
   ];
 
   override async setUpTestEnvironment(): Promise<void> {
-    const parser = (await UnitTestUtils.getTracesParser([
-      'traces/perfetto/input-events.perfetto-trace',
-    ])) as Parser<PropertyTreeNode>;
+    const parser = (
+      await getTracesParser(['traces/perfetto/input-events.perfetto-trace'])
+    ).tracesParser as Parser<PropertyTreeNode>;
 
     this.trace = new TraceBuilder<PropertyTreeNode>()
       .setType(TraceType.INPUT_EVENT_MERGED)
@@ -621,8 +622,18 @@ class PresenterInputTest extends AbstractLogViewerPresenterTest<UiData> {
         );
         expect(uiData.rectsToDraw).toEqual([]);
 
+        const inputEntry = trace.getEntry(1);
+        const spy: jasmine.Spy = spyOn(
+          UI_RECT_FACTORY,
+          'makeInputRects',
+        ).and.callThrough();
         await presenter.onAppEvent(
-          TracePositionUpdate.fromTraceEntry(trace.getEntry(1)),
+          TracePositionUpdate.fromTraceEntry(inputEntry),
+        );
+        const spyArgs = spy.calls.allArgs();
+        expect(spyArgs.length).toEqual(1);
+        expect(spyArgs[0][2]).toEqual(
+          (await inputEntry.getValue()).getChildByName('windowDispatchEvents'),
         );
         expect(uiData.rectsToDraw).toHaveSize(1);
         expect(uiData.rectsToDraw?.at(0)?.id).toEqual('inputRect');
@@ -742,6 +753,33 @@ class PresenterInputTest extends AbstractLogViewerPresenterTest<UiData> {
         );
       });
 
+      it('tests input action formatter', async () => {
+        const presenter = await this.createPresenter(
+          (uiDataLog) => (uiData = uiDataLog as UiData),
+        );
+        await TimeUtils.wait(() => !uiData.isFetchingData);
+        const getInputAction = Presenter['getInputAction'];
+        const mockEventTree = (actionValue: number, formattedValue: string) => {
+          const mockActionNode = jasmine.createSpyObj('PropertyTreeNode', [
+            'getValue',
+            'formattedValue',
+            'getChildByName',
+          ]);
+          mockActionNode.getValue.and.returnValue(actionValue);
+          mockActionNode.formattedValue.and.returnValue(formattedValue);
+          mockActionNode.getChildByName.and.returnValue(mockActionNode);
+          return mockActionNode;
+        };
+        expect(getInputAction(mockEventTree(0, 'ACTION_DOWN'))).toEqual('DOWN');
+        expect(getInputAction(mockEventTree(1, 'ACTION_UP'))).toEqual('UP');
+        expect(
+          getInputAction(mockEventTree(5 | (2 << 8), 'ACTION_POINTER_DOWN')),
+        ).toEqual('POINTER_DOWN(2)');
+        expect(
+          getInputAction(mockEventTree(6 | (5 << 8), 'ACTION_POINTER_UP')),
+        ).toEqual('POINTER_UP(5)');
+      });
+
       async function getTracesWithSf(
         parser: Parser<PropertyTreeNode>,
         layerIdToName: Array<{
diff --git a/tools/winscope/src/viewers/viewer_input/ui_data.ts b/tools/winscope/src/viewers/viewer_input/ui_data.ts
index e4d96db23..9e45857ad 100644
--- a/tools/winscope/src/viewers/viewer_input/ui_data.ts
+++ b/tools/winscope/src/viewers/viewer_input/ui_data.ts
@@ -17,6 +17,7 @@
 import {TraceEntry} from 'trace/trace';
 import {TraceType} from 'trace/trace_type';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
+import {LazyPropertiesStrategyType} from 'trace/tree_node/properties_provider';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 import {DisplayIdentifier} from 'viewers/common/display_identifier';
 import {RectShowState} from 'viewers/common/rect_show_state';
@@ -68,8 +69,8 @@ export class InputEntry implements LogEntry {
   constructor(
     public traceEntry: TraceEntry<PropertyTreeNode>,
     public fields: LogField[],
-    public propertiesTree: PropertyTreeNode | undefined,
-    public dispatchPropertiesTree: PropertyTreeNode | undefined,
+    public getPropertiesTree: LazyPropertiesStrategyType | undefined,
+    public getDispatchPropertiesTree: LazyPropertiesStrategyType | undefined,
     public surfaceFlingerEntry: TraceEntry<HierarchyTreeNode> | undefined,
   ) {}
 }
diff --git a/tools/winscope/src/viewers/viewer_input/viewer_input_component.ts b/tools/winscope/src/viewers/viewer_input/viewer_input_component.ts
index 4ae686646..e02566f24 100644
--- a/tools/winscope/src/viewers/viewer_input/viewer_input_component.ts
+++ b/tools/winscope/src/viewers/viewer_input/viewer_input_component.ts
@@ -14,11 +14,12 @@
  * limitations under the License.
  */
 
-import {Component, Input} from '@angular/core';
+import {Component, Input, ViewChild} from '@angular/core';
 import {TraceType} from 'trace/trace_type';
 import {CollapsibleSections} from 'viewers/common/collapsible_sections';
 import {CollapsibleSectionType} from 'viewers/common/collapsible_section_type';
 import {ViewerEvents} from 'viewers/common/viewer_events';
+import {LogComponent} from 'viewers/components/log_component';
 import {ShadingMode} from 'viewers/components/rects/shading_mode';
 import {
   viewerCardInnerStyle,
@@ -63,7 +64,6 @@ import {UiData} from './ui_data';
           [currentIndex]="inputData?.currentIndex"
           [entries]="inputData?.entries"
           [headers]="inputData?.headers"
-          [showFiltersInTitle]="false"
           [traceType]="${TraceType.INPUT_EVENT_MERGED}"
           [showTraceEntryTimes]="false"
           [showCurrentTimeButton]="false"
@@ -117,6 +117,7 @@ import {UiData} from './ui_data';
   ],
 })
 export class ViewerInputComponent extends ViewerComponent<UiData> {
+  @ViewChild(LogComponent) logComponent?: LogComponent;
   @Input() active = false;
   TraceType = TraceType;
   CollapsibleSectionType = CollapsibleSectionType;
diff --git a/tools/winscope/src/viewers/viewer_input/viewer_input_component_test.ts b/tools/winscope/src/viewers/viewer_input/viewer_input_component_test.ts
index 39615f521..2708a929e 100644
--- a/tools/winscope/src/viewers/viewer_input/viewer_input_component_test.ts
+++ b/tools/winscope/src/viewers/viewer_input/viewer_input_component_test.ts
@@ -14,238 +14,141 @@
  * limitations under the License.
  */
 
-import {ClipboardModule} from '@angular/cdk/clipboard';
-import {ScrollingModule} from '@angular/cdk/scrolling';
-import {HttpClientModule} from '@angular/common/http';
-import {
-  ComponentFixture,
-  ComponentFixtureAutoDetect,
-  TestBed,
-} from '@angular/core/testing';
-import {FormsModule} from '@angular/forms';
-import {MatButtonModule} from '@angular/material/button';
-import {MatDividerModule} from '@angular/material/divider';
-import {MatFormFieldModule} from '@angular/material/form-field';
-import {MatIconModule} from '@angular/material/icon';
-import {MatInputModule} from '@angular/material/input';
-import {MatSelectModule} from '@angular/material/select';
-import {MatSliderModule} from '@angular/material/slider';
-import {MatTooltipModule} from '@angular/material/tooltip';
-import {BrowserAnimationsModule} from '@angular/platform-browser/animations';
+import {CdkVirtualScrollViewport} from '@angular/cdk/scrolling';
 import {assertDefined} from 'common/assert_utils';
 import {TimestampConverterUtils} from 'common/time/test_utils';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
 import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
 import {TraceBuilder} from 'test/unit/trace_builder';
-import {UnitTestUtils} from 'test/unit/utils';
-import {Trace, TraceEntry} from 'trace/trace';
 import {TraceType} from 'trace/trace_type';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
+import {AbstractLogViewerComponentTest} from 'viewers/common/abstract_log_viewer_component_test';
 import {LogSelectFilter} from 'viewers/common/log_filters';
 import {LogHeader} from 'viewers/common/ui_data_log';
-import {CollapsedSectionsComponent} from 'viewers/components/collapsed_sections_component';
-import {CollapsibleSectionTitleComponent} from 'viewers/components/collapsible_section_title_component';
-import {LogComponent} from 'viewers/components/log_component';
-import {PropertiesComponent} from 'viewers/components/properties_component';
-import {PropertyTreeNodeDataViewComponent} from 'viewers/components/property_tree_node_data_view_component';
 import {RectsComponent} from 'viewers/components/rects/rects_component';
-import {SearchBoxComponent} from 'viewers/components/search_box_component';
-import {SelectWithFilterComponent} from 'viewers/components/select_with_filter_component';
-import {TreeComponent} from 'viewers/components/tree_component';
-import {TreeNodeComponent} from 'viewers/components/tree_node_component';
 import {UserOptionsComponent} from 'viewers/components/user_options_component';
 import {InputEntry, UiData} from './ui_data';
 import {ViewerInputComponent} from './viewer_input_component';
 
-describe('ViewerInputComponent', () => {
-  const testSpec = {name: 'Test Column', cssClass: 'test-class'};
-  const testField = {spec: testSpec, value: 'VALUE'};
-  let fixture: ComponentFixture<ViewerInputComponent>;
-  let component: ViewerInputComponent;
-  let htmlElement: HTMLElement;
-
-  let tree: PropertyTreeNode;
-  let trace: Trace<PropertyTreeNode>;
-  let entry: TraceEntry<PropertyTreeNode>;
-
-  beforeAll(async () => {
-    tree = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('AndroidMotionEvent')
-      .setName('entry')
-      .build();
-    trace = new TraceBuilder<PropertyTreeNode>()
-      .setType(TraceType.INPUT_EVENT_MERGED)
-      .setEntries([tree])
-      .setTimestamps([TimestampConverterUtils.makeElapsedTimestamp(20n)])
-      .build();
-    entry = trace.getEntry(0);
-  });
-
-  beforeEach(async () => {
-    await TestBed.configureTestingModule({
-      providers: [{provide: ComponentFixtureAutoDetect, useValue: true}],
-      imports: [
-        MatSliderModule,
-        MatTooltipModule,
-        MatDividerModule,
-        ScrollingModule,
-        MatIconModule,
-        ClipboardModule,
-        MatFormFieldModule,
-        MatButtonModule,
-        MatInputModule,
-        BrowserAnimationsModule,
-        FormsModule,
-        MatSelectModule,
-        HttpClientModule,
-      ],
-      declarations: [
-        ViewerInputComponent,
-        TreeComponent,
-        TreeNodeComponent,
-        PropertyTreeNodeDataViewComponent,
-        PropertiesComponent,
-        CollapsedSectionsComponent,
-        CollapsibleSectionTitleComponent,
-        LogComponent,
-        RectsComponent,
-        SelectWithFilterComponent,
-        SearchBoxComponent,
-        UserOptionsComponent,
-      ],
-    }).compileComponents();
-
-    fixture = TestBed.createComponent(ViewerInputComponent);
-    component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
-
-    component.inputData = makeUiData();
-    fixture.detectChanges();
-  });
-
-  it('can be created', () => {
-    expect(component).toBeTruthy();
-  });
-
-  it('renders filters in header', () => {
-    expect(
-      htmlElement.querySelector(
-        `.headers .filter.${testSpec.cssClass.split(' ')[0]}`,
-      ),
-    ).toBeTruthy();
-    expect(htmlElement.querySelector(`.title-section .filter`)).toBeNull();
-  });
-
-  it('renders entries with field values and no trace timestamp', () => {
-    expect(htmlElement.querySelector('.scroll')).toBeTruthy();
-    const entry = assertDefined(
-      htmlElement.querySelector(
-        `.scroll .entry .${testSpec.cssClass.split(' ')[0]}`,
-      ),
-    );
-    expect(entry.textContent).toContain('VALUE');
-    expect(htmlElement.querySelector('.scroll .entry .time')).toBeNull();
-  });
-
-  it('hides go to current time button', () => {
-    expect(htmlElement.querySelector('.go-to-current-time')).toBeNull();
-  });
-
-  it('shows message when no event is selected', () => {
-    assertDefined(component.inputData).propertiesTree = undefined;
-    assertDefined(component.inputData).dispatchPropertiesTree = undefined;
-    fixture.detectChanges();
-    expect(
-      htmlElement.querySelector('.event-properties .placeholder-text')
-        ?.innerHTML,
-    ).toContain('No selected entry');
-    expect(
-      htmlElement.querySelector('.dispatch-properties .placeholder-text')
-        ?.innerHTML,
-    ).toContain('No selected entry');
-  });
-
-  it('creates collapsed sections with no buttons', () => {
-    UnitTestUtils.checkNoCollapsedSectionButtons(htmlElement);
-  });
-
-  it('handles collapse/expand', () => {
-    UnitTestUtils.checkSectionCollapseAndExpand(
-      htmlElement,
-      fixture,
-      '.rects-view',
-      'INPUT WINDOWS',
-    );
-    UnitTestUtils.checkSectionCollapseAndExpand(
-      htmlElement,
-      fixture,
-      '.event-properties',
-      'EVENT DETAILS',
-    );
-    UnitTestUtils.checkSectionCollapseAndExpand(
-      htmlElement,
-      fixture,
-      '.dispatch-properties',
-      'DISPATCH DETAILS',
-    );
-    UnitTestUtils.checkSectionCollapseAndExpand(
-      htmlElement,
-      fixture,
-      '.log-view',
-      'EVENT LOG',
-    );
-  });
-
-  it('shows rects view when rects are defined', () => {
-    assertDefined(component.inputData).rectsToDraw = [];
-    fixture.detectChanges();
-    expect(htmlElement.querySelector('.rects-view')).toBeTruthy();
-  });
+class ViewerInputComponentTest extends AbstractLogViewerComponentTest<ViewerInputComponent> {
+  protected override readonly testProperties = true;
+  protected override readonly testScroll = false;
+  protected override readonly hasCurrentTimeButton = false;
+  protected override readonly propertiesSectionTitle = 'EVENT DETAILS';
+  protected override readonly propertiesPlaceholder = 'No selected entry.';
+
+  private tree = new PropertyTreeBuilder()
+    .setIsRoot(true)
+    .setRootId('AndroidMotionEvent')
+    .setName('entry')
+    .build();
+  private trace = new TraceBuilder<PropertyTreeNode>()
+    .setType(TraceType.INPUT_EVENT_MERGED)
+    .setEntries([this.tree])
+    .setTimestamps([TimestampConverterUtils.makeElapsedTimestamp(20n)])
+    .build();
+  private entry = this.trace.getEntry(0);
+
+  protected override checkTimestampInTable(
+    dom: DOMTestHelper<ViewerInputComponent>,
+  ): void {
+    expect(dom.find('.scroll .entry .time')).toBeUndefined();
+  }
 
-  it('hides rects view when rects are not defined', () => {
-    assertDefined(component.inputData).rectsToDraw = undefined;
-    fixture.detectChanges();
-    expect(htmlElement.querySelector('.rects-view')).toBeNull();
-  });
+  protected override executeSpecializedTests(): void {
+    describe('Specialized tests', () => {
+      let dom: DOMTestHelper<ViewerInputComponent>;
+      let viewport: CdkVirtualScrollViewport;
+      let component: ViewerInputComponent;
+
+      beforeEach(async () => {
+        [dom, viewport, component] = await this.setUpTestEnvironment();
+      });
+
+      it('handles collapse/expand', () => {
+        dom.checkSectionCollapseAndExpand('.rects-view', 'INPUT WINDOWS');
+        dom.checkSectionCollapseAndExpand('.event-properties', 'EVENT DETAILS');
+        dom.checkSectionCollapseAndExpand(
+          '.dispatch-properties',
+          'DISPATCH DETAILS',
+        );
+        dom.checkSectionCollapseAndExpand('.log-view', 'EVENT LOG');
+      });
+
+      it('shows rects view when rects are defined', () => {
+        assertDefined(component.inputData).rectsToDraw = [];
+        dom.detectChanges();
+        expect(dom.find('.rects-view')).toBeDefined();
+      });
+
+      it('hides rects view when rects are not defined', () => {
+        assertDefined(component.inputData).rectsToDraw = undefined;
+        dom.detectChanges();
+        expect(dom.find('.rects-view')).toBeUndefined();
+      });
+
+      it('shows message when no event is selected', () => {
+        assertDefined(component.inputData).propertiesTree = undefined;
+        assertDefined(component.inputData).dispatchPropertiesTree = undefined;
+        dom.detectChanges();
+        dom
+          .get('.event-properties .placeholder-text')
+          .checkTextExact('No selected entry.');
+        dom
+          .get('.dispatch-properties .placeholder-text')
+          .checkTextExact('No selected entry.');
+      });
+    });
+  }
 
-  function makeUiData(): UiData {
+  protected async setUpTestEnvironment(): Promise<
+    [
+      DOMTestHelper<ViewerInputComponent>,
+      CdkVirtualScrollViewport,
+      ViewerInputComponent,
+    ]
+  > {
     const entries = [
-      createInputEntry(entry, 1),
-      createInputEntry(entry, 2),
-      createInputEntry(entry, 3),
+      this.createInputEntry(),
+      this.createInputEntry(),
+      this.createInputEntry(),
     ];
 
     const uiData = UiData.createEmpty();
-    uiData.headers = [new LogHeader(testSpec, new LogSelectFilter([]))];
+    uiData.headers = [new LogHeader(this.testSpec, new LogSelectFilter([]))];
     uiData.entries = entries;
     uiData.selectedIndex = 0;
 
     uiData.rectsToDraw = [];
-    return uiData;
+    return this.initializeTestEnvironment(uiData, ViewerInputComponent, [
+      RectsComponent,
+      UserOptionsComponent,
+    ]);
   }
 
-  function createInputEntry(
-    entry: TraceEntry<PropertyTreeNode>,
-    num: number,
-  ): InputEntry {
+  private createInputEntry(): InputEntry {
     return new InputEntry(
-      entry,
+      this.entry,
       [
         {
-          spec: testSpec,
+          spec: this.testSpec,
           value: 'VALUE',
           propagateEntryTimestamp: true,
         },
-        testField,
-        testField,
-        testField,
-        testField,
-        testField,
-        testField,
+        this.testField,
+        this.testField,
+        this.testField,
+        this.testField,
+        this.testField,
+        this.testField,
       ],
-      tree,
-      tree,
+      async () => this.tree,
+      async () => this.tree,
       undefined,
     );
   }
+}
+
+describe('ViewerInputComponent', () => {
+  new ViewerInputComponentTest().execute();
 });
diff --git a/tools/winscope/src/viewers/viewer_jank_cujs/presenter.ts b/tools/winscope/src/viewers/viewer_jank_cujs/presenter.ts
index 381c1297a..41941f640 100644
--- a/tools/winscope/src/viewers/viewer_jank_cujs/presenter.ts
+++ b/tools/winscope/src/viewers/viewer_jank_cujs/presenter.ts
@@ -146,7 +146,7 @@ export class Presenter extends AbstractLogViewerPresenter<
           iconColor: statusIconColor,
         },
       ];
-      cujs.push(new CujEntry(entry, fields, cujNode));
+      cujs.push(new CujEntry(entry, fields, async () => cujNode));
     }
 
     return cujs;
diff --git a/tools/winscope/src/viewers/viewer_jank_cujs/presenter_test.ts b/tools/winscope/src/viewers/viewer_jank_cujs/presenter_test.ts
index 0e970390b..f0f98f99e 100644
--- a/tools/winscope/src/viewers/viewer_jank_cujs/presenter_test.ts
+++ b/tools/winscope/src/viewers/viewer_jank_cujs/presenter_test.ts
@@ -17,8 +17,9 @@
 import {assertDefined} from 'common/assert_utils';
 import {InMemoryStorage} from 'common/store/in_memory_storage';
 import {TracePositionUpdate} from 'messaging/winscope_event';
+import {getTracesParser} from 'test/unit/fixture_utils';
 import {TraceBuilder} from 'test/unit/trace_builder';
-import {UnitTestUtils} from 'test/unit/utils';
+import {makeEmptyTrace} from 'test/unit/trace_utils';
 import {Parser} from 'trace/parser';
 import {Trace} from 'trace/trace';
 import {Traces} from 'trace/traces';
@@ -67,9 +68,11 @@ class PresenterJankCujsTest extends AbstractLogViewerPresenterTest<UiData> {
   private positionUpdate: TracePositionUpdate | undefined;
 
   override async setUpTestEnvironment(): Promise<void> {
-    const parser = (await UnitTestUtils.getTracesParser([
-      'traces/eventlog.winscope',
-    ])) as Parser<PropertyTreeNode>;
+    const parser = (
+      await getTracesParser([
+        'traces/elapsed_and_real_timestamp/eventlog.winscope',
+      ])
+    ).tracesParser as Parser<PropertyTreeNode>;
 
     this.trace = new TraceBuilder<PropertyTreeNode>()
       .setType(TraceType.CUJS)
@@ -84,7 +87,7 @@ class PresenterJankCujsTest extends AbstractLogViewerPresenterTest<UiData> {
   override async createPresenterWithEmptyTrace(
     callback: NotifyLogViewCallbackType<UiData>,
   ): Promise<Presenter> {
-    const trace = UnitTestUtils.makeEmptyTrace(TraceType.CUJS);
+    const trace = makeEmptyTrace(TraceType.CUJS);
     return new Presenter(trace, new InMemoryStorage(), callback);
   }
 
diff --git a/tools/winscope/src/viewers/viewer_jank_cujs/ui_data.ts b/tools/winscope/src/viewers/viewer_jank_cujs/ui_data.ts
index 17dbaf966..aedb311f5 100644
--- a/tools/winscope/src/viewers/viewer_jank_cujs/ui_data.ts
+++ b/tools/winscope/src/viewers/viewer_jank_cujs/ui_data.ts
@@ -15,6 +15,7 @@
  */
 
 import {TraceEntry} from 'trace/trace';
+import {LazyPropertiesStrategyType} from 'trace/tree_node/properties_provider';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 import {TextFilter} from 'viewers/common/text_filter';
 import {
@@ -47,7 +48,7 @@ export class CujEntry implements LogEntry {
   constructor(
     public traceEntry: TraceEntry<PropertyTreeNode>,
     public fields: LogField[],
-    public propertiesTree: PropertyTreeNode | undefined,
+    public getPropertiesTree: LazyPropertiesStrategyType | undefined,
   ) {}
 }
 
diff --git a/tools/winscope/src/viewers/viewer_jank_cujs/viewer_jank_cujs_component_test.ts b/tools/winscope/src/viewers/viewer_jank_cujs/viewer_jank_cujs_component_test.ts
index 855102c29..04fe0f4ea 100644
--- a/tools/winscope/src/viewers/viewer_jank_cujs/viewer_jank_cujs_component_test.ts
+++ b/tools/winscope/src/viewers/viewer_jank_cujs/viewer_jank_cujs_component_test.ts
@@ -14,128 +14,80 @@
  * limitations under the License.
  */
 
-import {ClipboardModule} from '@angular/cdk/clipboard';
-import {ScrollingModule} from '@angular/cdk/scrolling';
-import {
-  ComponentFixture,
-  ComponentFixtureAutoDetect,
-  TestBed,
-} from '@angular/core/testing';
-import {MatDividerModule} from '@angular/material/divider';
-import {MatIconModule} from '@angular/material/icon';
-import {assertDefined} from 'common/assert_utils';
+import {CdkVirtualScrollViewport} from '@angular/cdk/scrolling';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
+import {getTracesParser} from 'test/unit/fixture_utils';
 import {TraceBuilder} from 'test/unit/trace_builder';
-import {UnitTestUtils} from 'test/unit/utils';
 import {Parser} from 'trace/parser';
-import {Trace, TraceEntry} from 'trace/trace';
+import {TraceEntry} from 'trace/trace';
 import {TraceType} from 'trace/trace_type';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
-import {LogSelectFilter} from 'viewers/common/log_filters';
+import {AbstractLogViewerComponentTest} from 'viewers/common/abstract_log_viewer_component_test';
 import {LogEntry, LogHeader} from 'viewers/common/ui_data_log';
-import {CollapsedSectionsComponent} from 'viewers/components/collapsed_sections_component';
-import {CollapsibleSectionTitleComponent} from 'viewers/components/collapsible_section_title_component';
-import {LogComponent} from 'viewers/components/log_component';
-import {PropertiesComponent} from 'viewers/components/properties_component';
-import {PropertyTreeNodeDataViewComponent} from 'viewers/components/property_tree_node_data_view_component';
-import {TreeComponent} from 'viewers/components/tree_component';
-import {TreeNodeComponent} from 'viewers/components/tree_node_component';
 import {CujEntry, UiData} from './ui_data';
 import {ViewerJankCujsComponent} from './viewer_jank_cujs_component';
 
-describe('ViewerJankCujsComponent', () => {
-  const testSpec = {name: 'Test Column', cssClass: 'test-class'};
-  const testField = {spec: testSpec, value: 'VALUE'};
-  let fixture: ComponentFixture<ViewerJankCujsComponent>;
-  let component: ViewerJankCujsComponent;
-  let htmlElement: HTMLElement;
+class ViewerJankCujsComponentTest extends AbstractLogViewerComponentTest<ViewerJankCujsComponent> {
+  protected override readonly testProperties = false;
+  protected override readonly testScroll = false;
+  protected override readonly hasCurrentTimeButton = false;
+  protected override readonly hasFilters = false;
 
-  let trace: Trace<PropertyTreeNode>;
-  let entry: TraceEntry<PropertyTreeNode>;
+  protected override checkTimestampInTable(
+    dom: DOMTestHelper<ViewerJankCujsComponent>,
+  ): void {
+    expect(dom.find('.scroll .entry .time')).toBeUndefined();
+  }
 
-  beforeAll(async () => {
-    const parser = (await UnitTestUtils.getTracesParser([
-      'traces/eventlog.winscope',
-    ])) as Parser<PropertyTreeNode>;
+  protected async setUpTestEnvironment(): Promise<
+    [
+      DOMTestHelper<ViewerJankCujsComponent>,
+      CdkVirtualScrollViewport,
+      ViewerJankCujsComponent,
+    ]
+  > {
+    const parser = (
+      await getTracesParser([
+        'traces/elapsed_and_real_timestamp/eventlog.winscope',
+      ])
+    ).tracesParser as Parser<PropertyTreeNode>;
 
-    trace = new TraceBuilder<PropertyTreeNode>()
+    const trace = new TraceBuilder<PropertyTreeNode>()
       .setParser(parser)
       .setType(TraceType.CUJS)
       .build();
 
-    entry = trace.getEntry(0);
-  });
-
-  beforeEach(async () => {
-    await TestBed.configureTestingModule({
-      providers: [{provide: ComponentFixtureAutoDetect, useValue: true}],
-      imports: [
-        MatDividerModule,
-        ScrollingModule,
-        MatIconModule,
-        ClipboardModule,
-      ],
-      declarations: [
-        ViewerJankCujsComponent,
-        TreeComponent,
-        TreeNodeComponent,
-        PropertyTreeNodeDataViewComponent,
-        PropertiesComponent,
-        CollapsedSectionsComponent,
-        CollapsibleSectionTitleComponent,
-        LogComponent,
-      ],
-    }).compileComponents();
-
-    fixture = TestBed.createComponent(ViewerJankCujsComponent);
-    component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
-
-    component.inputData = makeUiData();
-    fixture.detectChanges();
-  });
-
-  it('can be created', () => {
-    expect(component).toBeTruthy();
-  });
-
-  it('renders entries with field values and no trace timestamp', () => {
-    expect(htmlElement.querySelector('.scroll')).toBeTruthy();
-    const entry = assertDefined(
-      htmlElement.querySelector(
-        `.scroll .entry .${testSpec.cssClass.split(' ')[0]}`,
-      ),
-    );
-    expect(entry.textContent).toContain('VALUE');
-    expect(htmlElement.querySelector('.scroll .entry .time')).toBeNull();
-  });
-
-  it('hides go to current time button', () => {
-    expect(htmlElement.querySelector('.go-to-current-time')).toBeNull();
-  });
-
-  function makeUiData(): UiData {
+    const entry = trace.getEntry(0);
     const cujEntries = [
-      createMockCujEntry(entry, 1),
-      createMockCujEntry(entry, 2),
-      createMockCujEntry(entry, 3),
-      createMockCujEntry(entry, 4),
+      this.createMockCujEntry(entry),
+      this.createMockCujEntry(entry),
+      this.createMockCujEntry(entry),
+      this.createMockCujEntry(entry),
     ];
 
     const uiData = UiData.createEmpty();
-    uiData.headers = [new LogHeader(testSpec, new LogSelectFilter([]))];
+    uiData.headers = [new LogHeader(this.testSpec)];
     uiData.entries = cujEntries;
     uiData.selectedIndex = 0;
-    return uiData;
+
+    return this.initializeTestEnvironment(uiData, ViewerJankCujsComponent);
   }
 
-  function createMockCujEntry(
-    entry: TraceEntry<PropertyTreeNode>,
-    i: number,
-  ): LogEntry {
+  private createMockCujEntry(entry: TraceEntry<PropertyTreeNode>): LogEntry {
     return new CujEntry(
       entry,
-      [testField, testField, testField, testField, testField],
+      [
+        this.testField,
+        this.testField,
+        this.testField,
+        this.testField,
+        this.testField,
+      ],
       undefined,
     );
   }
+}
+
+describe('ViewerJankCujsComponent', () => {
+  new ViewerJankCujsComponentTest().execute();
 });
diff --git a/tools/winscope/src/viewers/viewer_media_based/viewer_media_based_component_test.ts b/tools/winscope/src/viewers/viewer_media_based/viewer_media_based_component_test.ts
index 7abbdf52d..38df096f1 100644
--- a/tools/winscope/src/viewers/viewer_media_based/viewer_media_based_component_test.ts
+++ b/tools/winscope/src/viewers/viewer_media_based/viewer_media_based_component_test.ts
@@ -15,7 +15,7 @@
  */
 
 import {Component, ViewChild} from '@angular/core';
-import {ComponentFixture, TestBed} from '@angular/core/testing';
+import {TestBed} from '@angular/core/testing';
 import {MatButtonModule} from '@angular/material/button';
 import {MatCardModule} from '@angular/material/card';
 import {MatIconModule} from '@angular/material/icon';
@@ -23,15 +23,15 @@ import {MatSelectModule} from '@angular/material/select';
 import {MatTooltipModule} from '@angular/material/tooltip';
 import {BrowserAnimationsModule} from '@angular/platform-browser/animations';
 import {assertDefined} from 'common/assert_utils';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
 import {getFixtureFile} from 'test/unit/fixture_utils';
 import {MediaBasedTraceEntry} from 'trace/media_based_trace_entry';
 import {ViewerEvents} from 'viewers/common/viewer_events';
 import {ViewerMediaBasedComponent} from './viewer_media_based_component';
 
 describe('ViewerMediaBasedComponent', () => {
-  let fixture: ComponentFixture<TestHostComponent>;
   let component: TestHostComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<TestHostComponent>;
 
   beforeEach(async () => {
     await TestBed.configureTestingModule({
@@ -45,11 +45,10 @@ describe('ViewerMediaBasedComponent', () => {
       ],
       declarations: [TestHostComponent, ViewerMediaBasedComponent],
     }).compileComponents();
-
-    fixture = TestBed.createComponent(TestHostComponent);
+    const fixture = TestBed.createComponent(TestHostComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
-    fixture.detectChanges();
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
+    dom.detectChanges();
   });
 
   it('can be created', () => {
@@ -57,61 +56,51 @@ describe('ViewerMediaBasedComponent', () => {
   });
 
   it('renders title correctly', () => {
-    const title = assertDefined(htmlElement.querySelector('.overlay-title'));
-    expect(title.textContent).toEqual('Screen recording');
+    const title = dom.get('.overlay-title');
+    title.checkTextExact('Screen recording');
 
     component.titles = ['Screenshot'];
-    fixture.detectChanges();
-    expect(title.textContent).toEqual('Screenshot');
+    dom.detectChanges();
+    title.checkTextExact('Screenshot');
 
     component.titles = ['Screenshot.png'];
-    fixture.detectChanges();
-    expect(title.textContent).toEqual('Screenshot');
+    dom.detectChanges();
+    title.checkTextExact('Screenshot');
 
     component.titles = ['Screenshot.png (parent.zip)'];
-    fixture.detectChanges();
-    expect(title.textContent).toEqual('Screenshot');
+    dom.detectChanges();
+    title.checkTextExact('Screenshot');
 
     component.titles = ['Screenshot (parent.zip)'];
-    fixture.detectChanges();
-    expect(title.textContent).toEqual('Screenshot');
+    dom.detectChanges();
+    title.checkTextExact('Screenshot');
   });
 
   it('can be minimized and maximized', () => {
-    const buttonMinimize = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.button-minimize'),
-    );
-    const videoContainer = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.video-container'),
-    );
+    const buttonMinimize = dom.get('.button-minimize');
+    const videoContainer = dom.get('.video-container').getHTMLElement();
     expect(videoContainer.style.height).toEqual('');
 
     buttonMinimize.click();
-    fixture.detectChanges();
     expect(videoContainer.style.height).toEqual('0px');
 
     buttonMinimize.click();
-    fixture.detectChanges();
     expect(videoContainer.style.height).toEqual('');
   });
 
   it('forces minimized state', () => {
     component.forceMinimize = true;
-    fixture.detectChanges();
+    dom.detectChanges();
 
-    const buttonMinimize = assertDefined(
-      htmlElement.querySelector<HTMLButtonElement>('.button-minimize'),
-    );
-    const videoContainer = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.video-container'),
-    );
+    const buttonMinimize = dom.get('.button-minimize');
+    const videoContainer = dom.get('.video-container').getHTMLElement();
     expect(videoContainer.style.height).toEqual('0px');
-    expect(buttonMinimize.disabled).toBeTrue();
+    buttonMinimize.checkDisabled(true);
 
     component.forceMinimize = false;
-    fixture.detectChanges();
+    dom.detectChanges();
     expect(videoContainer.style.height).toEqual('');
-    expect(buttonMinimize.disabled).toBeFalse();
+    buttonMinimize.checkDisabled(false);
   });
 
   it('shows video', async () => {
@@ -120,92 +109,80 @@ describe('ViewerMediaBasedComponent', () => {
       'traces/elapsed_and_real_timestamp/screen_recording_metadata_v2.mp4',
     );
     component.currentTraceEntries = [new MediaBasedTraceEntry(1, videoFile)];
-    fixture.detectChanges();
-    await fixture.whenStable();
-    const videoContainer = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.video-container'),
-    );
-    expect(videoContainer.querySelector('video')).toBeTruthy();
-    expect(videoContainer.querySelector('img')).toBeNull();
+    await dom.detectChangesAndWaitStable();
+    const videoContainer = dom.get('.video-container');
+    expect(videoContainer.find('video')).toBeDefined();
+    expect(videoContainer.find('img')).toBeUndefined();
     expect(getContainerMaxWidth()).not.toEqual(initialMaxWidth);
   });
 
   it('shows screenshot image', async () => {
     const initialMaxWidth = getContainerMaxWidth();
-    const screenshotFile = await getFixtureFile('traces/screenshot_2.png');
+    const screenshotFile = await getFixtureFile(
+      'traces/screenshot/screenshot_2.png',
+    );
     component.currentTraceEntries = [
       new MediaBasedTraceEntry(0, screenshotFile, true),
     ];
-    fixture.detectChanges();
-    await fixture.whenStable();
+    await dom.detectChangesAndWaitStable();
 
-    const videoContainer = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.video-container'),
-    );
-    expect(videoContainer.querySelector('img')).toBeTruthy();
-    expect(videoContainer.querySelector('video')).toBeNull();
+    const videoContainer = dom.get('.video-container');
+    expect(videoContainer.find('img')).toBeDefined();
+    expect(videoContainer.find('video')).toBeUndefined();
     expect(getContainerMaxWidth()).not.toEqual(initialMaxWidth);
   });
 
   it('shows no frame message', () => {
-    const videoContainer = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.video-container'),
-    );
-    expect(videoContainer.textContent).toContain('No frame to show');
+    dom.get('.video-container').checkTextExact('No frame to show.');
   });
 
-  it('selector changes entry shown', async () => {
+  it('selector changes entry shown', () => {
     component.currentTraceEntries = [
       new MediaBasedTraceEntry(0, new Blob(), true),
       new MediaBasedTraceEntry(0, new Blob(), true),
     ];
     component.titles = ['Screenshot 1', 'Screenshot 2'];
-    fixture.detectChanges();
+    dom.detectChanges();
 
     const screenComponent = assertDefined(component.screenComponent);
     let url = screenComponent.safeUrl;
 
-    await openSelect();
-    const options = document.querySelectorAll<HTMLElement>('mat-option');
+    dom.openMatSelect();
+    const options = dom.getMatSelectPanel().findAll('mat-option');
 
-    options.item(1).click();
-    fixture.detectChanges();
+    options[1].click();
     expect(screenComponent.safeUrl).not.toEqual(url);
     url = screenComponent.safeUrl;
 
-    options.item(1).click();
-    fixture.detectChanges();
+    options[1].click();
     expect(screenComponent.safeUrl).toEqual(url);
 
-    options.item(0).click();
-    fixture.detectChanges();
+    options[0].click();
     expect(screenComponent.safeUrl).not.toEqual(url);
     url = screenComponent.safeUrl;
 
-    options.item(0).click();
-    fixture.detectChanges();
+    options[0].click();
     expect(screenComponent.safeUrl).toEqual(url);
   });
 
-  it('video current time updated correctly on entry change', async () => {
+  it('video current time updated correctly on entry change', () => {
     component.currentTraceEntries = [
       new MediaBasedTraceEntry(10, new Blob(), false),
       new MediaBasedTraceEntry(15, new Blob(), false),
     ];
     component.titles = ['Recording 1', 'Recording 2'];
-    fixture.detectChanges();
+    dom.detectChanges();
 
     expect(
-      htmlElement.querySelector<HTMLVideoElement>('video')?.currentTime,
+      dom.get('video').getHTMLElement<HTMLVideoElement>().currentTime,
     ).toEqual(10);
 
-    await openSelect();
-    const options = document.querySelectorAll<HTMLElement>('mat-option');
+    dom.openMatSelect();
+    const options = dom.getMatSelectPanel().findAll('mat-option');
 
-    options.item(1).click();
-    fixture.detectChanges();
+    options[1].click();
     expect(
-      htmlElement.querySelector<HTMLVideoElement>('video')?.currentTime,
+      dom.get('video').getHTMLElement<HTMLVideoElement>().currentTime,
     ).toEqual(15);
   });
 
@@ -214,23 +191,24 @@ describe('ViewerMediaBasedComponent', () => {
       new MediaBasedTraceEntry(0, new Blob(), true),
     ];
     component.titles = ['Screenshot 1'];
-    fixture.detectChanges();
+    dom.detectChanges();
 
     const screenComponent = assertDefined(component.screenComponent);
     const url = screenComponent.safeUrl;
 
     component.titles = ['Screenshot 1', 'Screenshot 2'];
-    fixture.detectChanges();
+    dom.detectChanges();
     expect(screenComponent.safeUrl).toEqual(url);
   });
 
   it('updates max container size on window resize', async () => {
-    const screenshotFile = await getFixtureFile('traces/screenshot.png');
+    const screenshotFile = await getFixtureFile(
+      'traces/screenshot/screenshot.png',
+    );
     component.currentTraceEntries = [
       new MediaBasedTraceEntry(0, screenshotFile, true),
     ];
-    fixture.detectChanges();
-    await fixture.whenStable();
+    await dom.detectChangesAndWaitStable();
 
     const initialMaxWidth = getContainerMaxWidth();
     const newWindowHeight = window.innerHeight / 2;
@@ -247,42 +225,29 @@ describe('ViewerMediaBasedComponent', () => {
 
   it('emits event on double click', () => {
     let index: number | undefined;
-    htmlElement.addEventListener(ViewerEvents.OverlayDblClick, (event) => {
+    dom.addEventListener(ViewerEvents.OverlayDblClick, (event) => {
       index = (event as CustomEvent).detail;
     });
-    expect(htmlElement.querySelector('.info-icon')).toBeNull();
-    const container = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.container'),
-    );
-    container.dispatchEvent(new MouseEvent('dblclick'));
+    expect(dom.find('.info-icon')).toBeUndefined();
+    const container = dom.get('.container');
+    container.doubleClick();
     expect(index).toBeUndefined();
 
     assertDefined(component.screenComponent).enableDoubleClick = true;
-    fixture.detectChanges();
-    expect(htmlElement.querySelector('.info-icon')).toBeTruthy();
-    container.dispatchEvent(new MouseEvent('dblclick'));
+    dom.detectChanges();
+    expect(dom.find('.info-icon')).toBeDefined();
+    container.doubleClick();
     expect(index).toEqual(0);
   });
 
   function getContainerMaxWidth(): number {
-    const container = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.container'),
-    );
+    const container = dom.get('.container').getHTMLElement();
     return Number(container.style.maxWidth.slice(0, -2));
   }
 
-  async function openSelect() {
-    const selectTrigger = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.mat-select-trigger'),
-    );
-    selectTrigger.click();
-    fixture.detectChanges();
-  }
-
   async function resizeWindow() {
     window.dispatchEvent(new Event('resize'));
-    fixture.detectChanges();
-    await fixture.whenStable();
+    await dom.detectChangesAndWaitStable();
   }
 
   @Component({
diff --git a/tools/winscope/src/viewers/viewer_protolog/presenter.ts b/tools/winscope/src/viewers/viewer_protolog/presenter.ts
index dfbcb1c4e..b4d190ed5 100644
--- a/tools/winscope/src/viewers/viewer_protolog/presenter.ts
+++ b/tools/winscope/src/viewers/viewer_protolog/presenter.ts
@@ -44,6 +44,7 @@ export class Presenter extends AbstractLogViewerPresenter<
     sourceFile: {
       name: 'Source files',
       cssClass: 'source-file',
+      canCopy: true,
     },
     text: {
       name: 'Search text',
@@ -120,7 +121,7 @@ export class Presenter extends AbstractLogViewerPresenter<
     return messages;
   }
 
-  protected override updateFiltersInHeaders(
+  protected override async updateFiltersInHeaders(
     headers: LogHeader[],
     allEntries: ProtologEntry[],
   ) {
diff --git a/tools/winscope/src/viewers/viewer_protolog/presenter_test.ts b/tools/winscope/src/viewers/viewer_protolog/presenter_test.ts
index b33b45f9f..e6e74fcaa 100644
--- a/tools/winscope/src/viewers/viewer_protolog/presenter_test.ts
+++ b/tools/winscope/src/viewers/viewer_protolog/presenter_test.ts
@@ -20,7 +20,7 @@ import {TimestampConverterUtils} from 'common/time/test_utils';
 import {TracePositionUpdate} from 'messaging/winscope_event';
 import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
 import {TraceBuilder} from 'test/unit/trace_builder';
-import {UnitTestUtils} from 'test/unit/utils';
+import {makeEmptyTrace} from 'test/unit/trace_utils';
 import {Trace} from 'trace/trace';
 import {TraceType} from 'trace/trace_type';
 import {
@@ -54,7 +54,7 @@ class PresenterProtologTest extends AbstractLogViewerPresenterTest<UiData> {
     },
     {
       header: new LogHeader(
-        {name: 'Source files', cssClass: 'source-file'},
+        {name: 'Source files', cssClass: 'source-file', canCopy: true},
         new LogSelectFilter(Array.from({length: 3}, () => '')),
       ),
       options: ['sourcefile0', 'sourcefile1', 'sourcefile2'],
@@ -164,7 +164,7 @@ class PresenterProtologTest extends AbstractLogViewerPresenterTest<UiData> {
   override async createPresenterWithEmptyTrace(
     callback: NotifyLogViewCallbackType<UiData>,
   ): Promise<Presenter> {
-    const trace = UnitTestUtils.makeEmptyTrace(TraceType.PROTO_LOG);
+    const trace = makeEmptyTrace(TraceType.PROTO_LOG);
     return new Presenter(trace, callback, new InMemoryStorage());
   }
 
diff --git a/tools/winscope/src/viewers/viewer_protolog/scroll_strategy/protolog_scroll_strategy.ts b/tools/winscope/src/viewers/viewer_protolog/protolog_height_predictor.ts
similarity index 73%
rename from tools/winscope/src/viewers/viewer_protolog/scroll_strategy/protolog_scroll_strategy.ts
rename to tools/winscope/src/viewers/viewer_protolog/protolog_height_predictor.ts
index 52480e71d..8ef2ab6be 100644
--- a/tools/winscope/src/viewers/viewer_protolog/scroll_strategy/protolog_scroll_strategy.ts
+++ b/tools/winscope/src/viewers/viewer_protolog/protolog_height_predictor.ts
@@ -14,19 +14,19 @@
  * limitations under the License.
  */
 
-import {assertDefined} from 'common/assert_utils';
-import {VariableHeightScrollStrategy} from 'viewers/common/variable_height_scroll_strategy';
+import {assertString} from 'common/assert_utils';
+import {ItemHeightPredictor} from 'viewers/common/item_height_predictor';
 import {ProtologEntry} from 'viewers/viewer_protolog/ui_data';
 
-export class ProtologScrollStrategy extends VariableHeightScrollStrategy {
-  protected readonly defaultRowSize = 16;
+export class ProtologHeightPredictor extends ItemHeightPredictor {
+  protected override readonly defaultRowSize = 16;
   private readonly textCharsPerRow = 150;
   private readonly timestampCharsPerRow = 20;
   private readonly sourceFileCharsPerRow = 50;
 
-  protected override predictScrollItemHeight(entry: ProtologEntry): number {
+  override predictHeight(entry: ProtologEntry): number {
     const textHeight = this.subItemHeight(
-      entry.fields[3].value as string,
+      assertString(entry.fields[3].value),
       this.textCharsPerRow,
     );
     const timestampHeight = this.subItemHeight(
@@ -34,7 +34,7 @@ export class ProtologScrollStrategy extends VariableHeightScrollStrategy {
       this.timestampCharsPerRow,
     );
     const sourceFileHeight = this.subItemHeight(
-      assertDefined(entry.fields[2]).value as string,
+      assertString(entry.fields[2].value),
       this.sourceFileCharsPerRow,
     );
     return Math.max(textHeight, timestampHeight, sourceFileHeight);
diff --git a/tools/winscope/src/viewers/viewer_protolog/scroll_strategy/protolog_scroll_directive.ts b/tools/winscope/src/viewers/viewer_protolog/scroll_strategy/protolog_scroll_directive.ts
deleted file mode 100644
index 6c0153fef..000000000
--- a/tools/winscope/src/viewers/viewer_protolog/scroll_strategy/protolog_scroll_directive.ts
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import {VIRTUAL_SCROLL_STRATEGY} from '@angular/cdk/scrolling';
-import {Directive, forwardRef} from '@angular/core';
-import {VariableHeightScrollDirective} from 'viewers/common/variable_height_scroll_directive';
-import {ProtologEntry} from 'viewers/viewer_protolog/ui_data';
-import {ProtologScrollStrategy} from './protolog_scroll_strategy';
-
-@Directive({
-  selector: '[protologVirtualScroll]',
-  providers: [
-    {
-      provide: VIRTUAL_SCROLL_STRATEGY,
-      useFactory: (dir: ProtologScrollDirective) => dir.scrollStrategy,
-      deps: [forwardRef(() => ProtologScrollDirective)],
-    },
-  ],
-})
-export class ProtologScrollDirective extends VariableHeightScrollDirective<ProtologEntry> {
-  scrollStrategy = new ProtologScrollStrategy();
-}
diff --git a/tools/winscope/src/viewers/viewer_protolog/ui_data.ts b/tools/winscope/src/viewers/viewer_protolog/ui_data.ts
index 2d804abd3..3ba47b392 100644
--- a/tools/winscope/src/viewers/viewer_protolog/ui_data.ts
+++ b/tools/winscope/src/viewers/viewer_protolog/ui_data.ts
@@ -40,6 +40,7 @@ export class UiData implements UiDataLog {
 }
 
 export class ProtologEntry implements LogEntry {
+  readonly getPropertiesTree = undefined;
   constructor(
     public traceEntry: TraceEntry<PropertyTreeNode>,
     public fields: LogField[],
diff --git a/tools/winscope/src/viewers/viewer_protolog/viewer_protolog_component_test.ts b/tools/winscope/src/viewers/viewer_protolog/viewer_protolog_component_test.ts
index 1615a64cc..16a611bf8 100644
--- a/tools/winscope/src/viewers/viewer_protolog/viewer_protolog_component_test.ts
+++ b/tools/winscope/src/viewers/viewer_protolog/viewer_protolog_component_test.ts
@@ -14,123 +14,37 @@
  * limitations under the License.
  */
 
-import {
-  CdkVirtualScrollViewport,
-  ScrollingModule,
-} from '@angular/cdk/scrolling';
-import {
-  ComponentFixture,
-  ComponentFixtureAutoDetect,
-  TestBed,
-} from '@angular/core/testing';
-import {FormsModule} from '@angular/forms';
-import {MatButtonModule} from '@angular/material/button';
-import {MatFormFieldModule} from '@angular/material/form-field';
-import {MatIconModule} from '@angular/material/icon';
-import {MatInputModule} from '@angular/material/input';
-import {MatSelectModule} from '@angular/material/select';
-import {BrowserAnimationsModule} from '@angular/platform-browser/animations';
-import {assertDefined} from 'common/assert_utils';
+import {CdkVirtualScrollViewport} from '@angular/cdk/scrolling';
 import {TimestampConverterUtils} from 'common/time/test_utils';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
 import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
 import {TraceBuilder} from 'test/unit/trace_builder';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
+import {AbstractLogViewerComponentTest} from 'viewers/common/abstract_log_viewer_component_test';
 import {LogSelectFilter} from 'viewers/common/log_filters';
-import {executeScrollComponentTests} from 'viewers/common/scroll_component_tests';
 import {LogHeader} from 'viewers/common/ui_data_log';
-import {LogComponent} from 'viewers/components/log_component';
-import {SearchBoxComponent} from 'viewers/components/search_box_component';
-import {SelectWithFilterComponent} from 'viewers/components/select_with_filter_component';
-import {ProtologScrollDirective} from './scroll_strategy/protolog_scroll_directive';
 import {ProtologEntry, UiData} from './ui_data';
 import {ViewerProtologComponent} from './viewer_protolog_component';
 
-describe('ViewerProtologComponent', () => {
-  const testSpec = {name: 'Test Column', cssClass: 'test-class'};
-  const testField = {spec: testSpec, value: 'VALUE'};
-  let fixture: ComponentFixture<ViewerProtologComponent>;
-  let component: ViewerProtologComponent;
-  let htmlElement: HTMLElement;
-
-  describe('Main component', () => {
-    beforeEach(async () => {
-      await setUpTestEnvironment();
-    });
-
-    it('can be created', () => {
-      expect(component).toBeTruthy();
-    });
-
-    it('render headers as filters', () => {
-      expect(
-        htmlElement.querySelector(
-          `.headers .filter.${testSpec.cssClass.split(' ')[0]}`,
-        ),
-      ).toBeTruthy();
-    });
-
-    it('renders entries with field values and no trace timestamp', () => {
-      expect(htmlElement.querySelector('.scroll')).toBeTruthy();
-      const entry = assertDefined(
-        htmlElement.querySelector(
-          `.scroll .entry .${testSpec.cssClass.split(' ')[0]}`,
-        ),
-      );
-      expect(entry.textContent).toContain('VALUE');
-
-      const entryTimestamp = assertDefined(
-        htmlElement.querySelector('.scroll .entry .time'),
-      );
-      expect(entryTimestamp.textContent?.trim()).toEqual('10ns');
-    });
+class ViewerProtologComponentTest extends AbstractLogViewerComponentTest<ViewerProtologComponent> {
+  protected override readonly testProperties = false;
+  protected override readonly hasCurrentTimeButton = true;
+  protected override readonly testScroll = true;
 
-    it('shows go to current time button', () => {
-      expect(htmlElement.querySelector('.go-to-current-time')).toBeTruthy();
-    });
-  });
-
-  describe('Scroll component', () => {
-    executeScrollComponentTests(setUpTestEnvironment);
-  });
+  protected override checkTimestampInTable(
+    dom: DOMTestHelper<ViewerProtologComponent>,
+  ): void {
+    const entryTimestamp = dom.get('.scroll .entry .time');
+    entryTimestamp.checkTextExact('10ns');
+  }
 
-  async function setUpTestEnvironment(): Promise<
+  protected async setUpTestEnvironment(): Promise<
     [
-      ComponentFixture<ViewerProtologComponent>,
-      HTMLElement,
+      DOMTestHelper<ViewerProtologComponent>,
       CdkVirtualScrollViewport,
+      ViewerProtologComponent,
     ]
   > {
-    await TestBed.configureTestingModule({
-      providers: [{provide: ComponentFixtureAutoDetect, useValue: true}],
-      imports: [
-        ScrollingModule,
-        MatFormFieldModule,
-        FormsModule,
-        MatInputModule,
-        BrowserAnimationsModule,
-        MatSelectModule,
-        MatButtonModule,
-        MatIconModule,
-      ],
-      declarations: [
-        ViewerProtologComponent,
-        SelectWithFilterComponent,
-        LogComponent,
-        ProtologScrollDirective,
-        SearchBoxComponent,
-      ],
-    }).compileComponents();
-    fixture = TestBed.createComponent(ViewerProtologComponent);
-    component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
-
-    component.inputData = makeUiData();
-    fixture.detectChanges();
-    const viewport = assertDefined(component.logComponent?.scrollComponent);
-    return [fixture, htmlElement, viewport];
-  }
-
-  function makeUiData(): UiData {
     const propertiesTree = new PropertyTreeBuilder()
       .setRootId('Protolog')
       .setName('tree')
@@ -149,9 +63,9 @@ describe('ViewerProtologComponent', () => {
     for (let i = 0; i < 200; i++) {
       messages.push(
         new ProtologEntry(traceEntry, [
-          testField,
-          testField,
-          testField,
+          this.testField,
+          this.testField,
+          this.testField,
           {
             spec: {name: 'Test Column Text', cssClass: 'test-class-text'},
             value: i % 2 === 0 ? shortMessage : longMessage,
@@ -159,12 +73,20 @@ describe('ViewerProtologComponent', () => {
         ]),
       );
     }
-    return new UiData(
-      [new LogHeader(testSpec, new LogSelectFilter([]))],
+    const uiData = new UiData(
+      [new LogHeader(this.testSpec, new LogSelectFilter([]))],
       messages,
       150,
       undefined,
       undefined,
     );
+    return await this.initializeTestEnvironment(
+      uiData,
+      ViewerProtologComponent,
+    );
   }
+}
+
+describe('ViewerProtologComponent', () => {
+  new ViewerProtologComponentTest().execute();
 });
diff --git a/tools/winscope/src/viewers/viewer_search/active_search_component.ts b/tools/winscope/src/viewers/viewer_search/active_search_component.ts
index f904e46cd..d5a039cb8 100644
--- a/tools/winscope/src/viewers/viewer_search/active_search_component.ts
+++ b/tools/winscope/src/viewers/viewer_search/active_search_component.ts
@@ -26,6 +26,7 @@ import {
 } from '@angular/core';
 import {FormControl, Validators} from '@angular/forms';
 import {assertDefined} from 'common/assert_utils';
+import {KeyboardEventKey} from 'common/dom_utils';
 import {Analytics} from 'logging/analytics';
 
 @Component({
@@ -174,7 +175,7 @@ export class ActiveSearchComponent {
   onTextAreaKeydown(event: KeyboardEvent) {
     event.stopPropagation();
     if (
-      event.key === 'Enter' &&
+      event.key === KeyboardEventKey.ENTER &&
       !event.shiftKey &&
       !this.searchQueryDisabled()
     ) {
diff --git a/tools/winscope/src/viewers/viewer_search/active_search_component_test.ts b/tools/winscope/src/viewers/viewer_search/active_search_component_test.ts
index 1f21e2711..c7407262e 100644
--- a/tools/winscope/src/viewers/viewer_search/active_search_component_test.ts
+++ b/tools/winscope/src/viewers/viewer_search/active_search_component_test.ts
@@ -16,7 +16,7 @@
 
 import {CommonModule, NgTemplateOutlet} from '@angular/common';
 import {Component} from '@angular/core';
-import {ComponentFixture, TestBed} from '@angular/core/testing';
+import {TestBed} from '@angular/core/testing';
 import {FormControl, FormsModule, ReactiveFormsModule} from '@angular/forms';
 import {MatButtonModule} from '@angular/material/button';
 import {MatFormFieldModule} from '@angular/material/form-field';
@@ -26,6 +26,7 @@ import {MatProgressSpinnerModule} from '@angular/material/progress-spinner';
 import {MatTooltipModule} from '@angular/material/tooltip';
 import {BrowserAnimationsModule} from '@angular/platform-browser/animations';
 import {assertDefined} from 'common/assert_utils';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
 import {
   SearchQueryClickDetail,
   ViewerEvents,
@@ -34,9 +35,8 @@ import {ActiveSearchComponent} from './active_search_component';
 
 describe('ActiveSearchComponent', () => {
   const testQuery = 'select * from table';
-  let fixture: ComponentFixture<ActiveSearchComponent>;
   let component: ActiveSearchComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<ActiveSearchComponent>;
 
   beforeEach(async () => {
     await TestBed.configureTestingModule({
@@ -55,14 +55,13 @@ describe('ActiveSearchComponent', () => {
         NgTemplateOutlet,
       ],
     }).compileComponents();
-    fixture = TestBed.createComponent(ActiveSearchComponent);
+    const fixture = TestBed.createComponent(ActiveSearchComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
-
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
     component.isSearchInitialized = true;
     component.lastTraceFailed = false;
     component.saveQueryNameControl = new FormControl();
-    fixture.detectChanges();
+    dom.detectChanges();
   });
 
   it('can be created', () => {
@@ -76,23 +75,21 @@ describe('ActiveSearchComponent', () => {
   it('handles search via enter key', () => {
     const runSearch = () => {
       const textInput = getTextInput();
-      changeInput(textInput, testQuery);
-      pressEnter(textInput);
+      textInput.dispatchInput(testQuery);
+      textInput.keydownEnter();
     };
     runSearchAndCheckHandled(runSearch);
   });
 
   it('does not handle search on enter key + shift key', () => {
     let query: string | undefined;
-    htmlElement
-      .querySelector('viewer-search')
-      ?.addEventListener(ViewerEvents.SearchQueryClick, (event) => {
-        const detail: SearchQueryClickDetail = (event as CustomEvent).detail;
-        query = detail.query;
-      });
+    dom.addEventListener(ViewerEvents.SearchQueryClick, (event) => {
+      const detail: SearchQueryClickDetail = (event as CustomEvent).detail;
+      query = detail.query;
+    });
     const textInput = getTextInput();
-    changeInput(textInput, testQuery);
-    pressEnter(textInput, true);
+    textInput.dispatchInput(testQuery);
+    textInput.keydownEnter(true);
     expect(query).toBeUndefined();
   });
 
@@ -100,83 +97,68 @@ describe('ActiveSearchComponent', () => {
     runSearchByQueryButton();
     component.canAdd = true;
     component.executedQuery = testQuery;
-    fixture.detectChanges();
-    expect(htmlElement.querySelector('.running-query-message')).toBeNull();
-    expect(
-      htmlElement.querySelector<HTMLButtonElement>('.add-button')?.disabled,
-    ).toBeFalse();
+    dom.detectChanges();
+    expect(dom.find('.running-query-message')).toBeUndefined();
+    dom.get('.add-button').checkDisabled(false);
   });
 
   it('handles running query failure', () => {
     runSearchByQueryButton();
     component.canAdd = true;
     component.lastTraceFailed = true;
-    fixture.detectChanges();
-    expect(htmlElement.querySelector('.running-query-message')).toBeNull();
-    expect(
-      htmlElement.querySelector<HTMLButtonElement>('.add-button')?.disabled,
-    ).toBeTrue();
+    dom.detectChanges();
+    expect(dom.find('.running-query-message')).toBeUndefined();
+    dom.get('.add-button').checkDisabled(true);
   });
 
   it('disables search query until initialized', () => {
     component.isSearchInitialized = false;
-    fixture.detectChanges();
-    changeInput(getTextInput(), testQuery);
-    expect(getSearchQueryButton().disabled).toBeTrue();
+    dom.detectChanges();
+    getTextInput().dispatchInput(testQuery);
+    getSearchQueryButton().checkDisabled(true);
 
     component.isSearchInitialized = true;
-    fixture.detectChanges();
-    expect(getSearchQueryButton().disabled).toBeFalse();
+    dom.detectChanges();
+    getSearchQueryButton().checkDisabled(false);
   });
 
   it('clears query', () => {
-    expect(htmlElement.querySelector('.clear-button')).toBeNull();
+    expect(dom.find('.clear-button')).toBeUndefined();
     component.canClear = true;
-    fixture.detectChanges();
-    const clearButton = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.clear-button'),
-    );
+    dom.detectChanges();
+    const clearButton = dom.get('.clear-button');
     spyOn(component.clearQueryClick, 'emit');
-    expect(clearButton.textContent?.trim()).toContain('Clear');
+    clearButton.checkText('Clear');
     clearButton.click();
-    fixture.detectChanges();
     expect(component.clearQueryClick.emit).toHaveBeenCalledTimes(1);
   });
 
   it('adds query', () => {
-    expect(htmlElement.querySelector('.add-button')).toBeNull();
+    expect(dom.find('.add-button')).toBeUndefined();
     component.canAdd = true;
-    fixture.detectChanges();
-    const addButton = assertDefined(
-      htmlElement.querySelector<HTMLButtonElement>('.add-button'),
-    );
-    expect(addButton.textContent?.trim()).toContain('+ Add Query');
-    expect(addButton.disabled).toBeTrue();
+    dom.detectChanges();
+    const addButton = dom.get('.add-button');
+    addButton.checkText('+ Add Query');
+    addButton.checkDisabled(true);
 
     spyOn(component.addQueryClick, 'emit');
     component.executedQuery = testQuery;
-    fixture.detectChanges();
+    dom.detectChanges();
     addButton.click();
-    fixture.detectChanges();
     expect(component.addQueryClick.emit).toHaveBeenCalledTimes(1);
   });
 
   it('labels section', () => {
     component.label = 'test label';
-    fixture.detectChanges();
-    expect(htmlElement.querySelector('.header')?.textContent?.trim()).toEqual(
-      'test label',
-    );
+    dom.detectChanges();
+    dom.get('.header').checkText('test label');
   });
 
   it('shows last query execution time', () => {
-    expect(htmlElement.querySelector('.query-execution-time')).toBeNull();
-
+    expect(dom.find('.query-execution-time')).toBeUndefined();
     component.lastQueryExecutionTime = '10 ms';
-    fixture.detectChanges();
-    expect(
-      htmlElement.querySelector('.query-execution-time')?.textContent?.trim(),
-    ).toEqual('Executed in 10 ms');
+    dom.detectChanges();
+    dom.get('.query-execution-time').checkText('Executed in 10 ms');
   });
 
   it('shows current search information and save query field', () => {
@@ -206,57 +188,29 @@ describe('ActiveSearchComponent', () => {
     ).toEqual('test name');
   });
 
-  function getTextInput(): HTMLTextAreaElement {
-    return assertDefined(
-      htmlElement.querySelector<HTMLTextAreaElement>('.query-field textarea'),
-    );
-  }
-
-  function changeInput(
-    input: HTMLInputElement | HTMLTextAreaElement,
-    query: string,
-  ) {
-    input.value = query;
-    input.dispatchEvent(new Event('input'));
-    fixture.detectChanges();
+  function getTextInput(): DOMTestHelper<ActiveSearchComponent> {
+    return dom.get('.query-field textarea');
   }
 
-  function getSearchQueryButton(): HTMLButtonElement {
-    return assertDefined(
-      htmlElement.querySelector<HTMLButtonElement>(
-        '.query-actions .search-button',
-      ),
-    );
+  function getSearchQueryButton(): DOMTestHelper<ActiveSearchComponent> {
+    return dom.get('.query-actions .search-button');
   }
 
   function runSearchByQueryButton() {
-    changeInput(getTextInput(), testQuery);
+    getTextInput().dispatchInput(testQuery);
     getSearchQueryButton().click();
-    fixture.detectChanges();
   }
 
   function runSearchAndCheckHandled(runSearch: () => void) {
     spyOn(component.searchQueryClick, 'emit');
     runSearch();
     component.runningQuery = true;
-    fixture.detectChanges();
+    dom.detectChanges();
     expect(component.searchQueryClick.emit).toHaveBeenCalledOnceWith(testQuery);
-    expect(getSearchQueryButton().disabled).toBeTrue();
-    const runningQueryMessage = assertDefined(
-      htmlElement.querySelector('.running-query-message'),
-    );
-    expect(runningQueryMessage.textContent?.trim()).toEqual(
-      'timer Calculating results',
-    );
-    expect(runningQueryMessage.querySelector('mat-spinner')).toBeTruthy();
-  }
-
-  function pressEnter(
-    input: HTMLInputElement | HTMLTextAreaElement,
-    shiftKey = false,
-  ) {
-    input.dispatchEvent(new KeyboardEvent('keydown', {key: 'Enter', shiftKey}));
-    fixture.detectChanges();
+    getSearchQueryButton().checkDisabled(true);
+    const runningQueryMessage = dom.get('.running-query-message');
+    runningQueryMessage.checkTextExact('timer Calculating results');
+    expect(runningQueryMessage.find('mat-spinner')).toBeDefined();
   }
 
   @Component({
diff --git a/tools/winscope/src/viewers/viewer_search/presenter_test.ts b/tools/winscope/src/viewers/viewer_search/presenter_test.ts
index 68978b552..326b9f5ce 100644
--- a/tools/winscope/src/viewers/viewer_search/presenter_test.ts
+++ b/tools/winscope/src/viewers/viewer_search/presenter_test.ts
@@ -26,12 +26,13 @@ import {
   TraceSearchRequest,
 } from 'messaging/winscope_event';
 import {TraceBuilder} from 'test/unit/trace_builder';
+import {makeEmptyTrace} from 'test/unit/trace_utils';
 import {UserNotifierChecker} from 'test/unit/user_notifier_checker';
-import {UnitTestUtils} from 'test/unit/utils';
 import {Trace} from 'trace/trace';
 import {Traces} from 'trace/traces';
 import {TraceType} from 'trace/trace_type';
 import {QueryResult} from 'trace_processor/query_result';
+import {makeSearchTraceSpies} from 'trace_processor/test_utils';
 import {
   ClearQueryClickDetail,
   DeleteSavedQueryClickDetail,
@@ -142,7 +143,7 @@ describe('PresenterSearch', () => {
     const query = 'successful empty query';
     await runSearchWithNoRowsAndCheckUiData(
       query,
-      UnitTestUtils.makeEmptyTrace(TraceType.SEARCH, [query, '1']),
+      makeEmptyTrace(TraceType.SEARCH, [query, '1']),
     );
   });
 
@@ -154,10 +155,7 @@ describe('PresenterSearch', () => {
     );
 
     const time100 = TimestampConverterUtils.makeRealTimestamp(100n);
-    const [spyQueryResult, spyIter] = UnitTestUtils.makeSearchTraceSpies(
-      time100,
-      '123',
-    );
+    const [spyQueryResult, spyIter] = makeSearchTraceSpies(time100, '123');
     spyIter.get.withArgs('property').and.returnValue('test_time_ns');
     const spyTimestamp = spyOn(
       TimestampConverterUtils.TIMESTAMP_CONVERTER,
@@ -205,13 +203,13 @@ describe('PresenterSearch', () => {
     const query = 'successful query';
     await runSearchWithNoRowsAndCheckUiData(
       query,
-      UnitTestUtils.makeEmptyTrace(TraceType.SEARCH, [query]),
+      makeEmptyTrace(TraceType.SEARCH, [query]),
     );
     emitEventSpy.calls.reset();
     presenter.addSearch();
     await runSearchWithNoRowsAndCheckUiData(
       query,
-      UnitTestUtils.makeEmptyTrace(TraceType.SEARCH, [query]),
+      makeEmptyTrace(TraceType.SEARCH, [query]),
       2,
       [
         new CurrentSearch(1, query, new SearchResult([], [])),
@@ -222,7 +220,7 @@ describe('PresenterSearch', () => {
 
   it('handles non-search trace added event', async () => {
     const currData = uiData;
-    const trace = UnitTestUtils.makeEmptyTrace(TraceType.SURFACE_FLINGER);
+    const trace = makeEmptyTrace(TraceType.SURFACE_FLINGER);
     await presenter.onAppEvent(new TraceAddRequest(trace));
     expect(uiData).toEqual(currData);
   });
@@ -238,7 +236,7 @@ describe('PresenterSearch', () => {
 
   it('clears current search result when query run again, keeping both in recent searches', async () => {
     const testQuery = 'query to be overwritten';
-    const trace = UnitTestUtils.makeEmptyTrace(TraceType.SEARCH, [testQuery]);
+    const trace = makeEmptyTrace(TraceType.SEARCH, [testQuery]);
     await runSearchWithNoRowsAndCheckUiData(testQuery, trace);
     emitEventSpy.calls.reset();
 
@@ -256,7 +254,7 @@ describe('PresenterSearch', () => {
     emitEventSpy.calls.reset();
 
     const newQuery = 'new query';
-    const newTrace = UnitTestUtils.makeEmptyTrace(TraceType.SEARCH, [newQuery]);
+    const newTrace = makeEmptyTrace(TraceType.SEARCH, [newQuery]);
     await runSearchWithNoRowsAndCheckUiData(newQuery, newTrace);
     emitEventSpy.calls.reset();
 
@@ -304,10 +302,7 @@ describe('PresenterSearch', () => {
 
   it('handles clear query click', async () => {
     const testQuery = 'clear query';
-    const trace = UnitTestUtils.makeEmptyTrace(TraceType.SEARCH, [
-      testQuery,
-      '1',
-    ]);
+    const trace = makeEmptyTrace(TraceType.SEARCH, [testQuery, '1']);
     await runSearchWithNoRowsAndCheckUiData(testQuery, trace);
 
     await presenter.onClearQueryClick(0);
@@ -319,10 +314,7 @@ describe('PresenterSearch', () => {
   it('retains at most 10 recent searches', async () => {
     for (let i = 0; i < 12; i++) {
       const testQuery = 'recent query';
-      const trace = UnitTestUtils.makeEmptyTrace(TraceType.SEARCH, [
-        testQuery,
-        '1',
-      ]);
+      const trace = makeEmptyTrace(TraceType.SEARCH, [testQuery, '1']);
       await presenter.onSearchQueryClick(testQuery, 1);
       await presenter.onAppEvent(new TraceAddRequest(trace));
     }
diff --git a/tools/winscope/src/viewers/viewer_search/search_list_component.ts b/tools/winscope/src/viewers/viewer_search/search_list_component.ts
index 29c68a5c7..73d66ef56 100644
--- a/tools/winscope/src/viewers/viewer_search/search_list_component.ts
+++ b/tools/winscope/src/viewers/viewer_search/search_list_component.ts
@@ -17,6 +17,7 @@
 import {NgTemplateOutlet} from '@angular/common';
 import {Component, Input} from '@angular/core';
 import {FormControl} from '@angular/forms';
+import {isElementOverflowing} from 'common/dom_utils';
 import {ListedSearch} from './ui_data';
 
 @Component({
@@ -119,7 +120,7 @@ export class SearchListComponent {
   searchOptionsTarget: ListedSearch | undefined;
 
   showTooltip(search: ListedSearch, el: HTMLElement) {
-    return search.name !== search.query || el.scrollWidth > el.offsetWidth;
+    return search.name !== search.query || isElementOverflowing(el);
   }
 
   getTooltip(search: ListedSearch) {
diff --git a/tools/winscope/src/viewers/viewer_search/search_list_component_test.ts b/tools/winscope/src/viewers/viewer_search/search_list_component_test.ts
index 513a3b07f..3b9b97e7a 100644
--- a/tools/winscope/src/viewers/viewer_search/search_list_component_test.ts
+++ b/tools/winscope/src/viewers/viewer_search/search_list_component_test.ts
@@ -17,20 +17,18 @@
 import {CdkMenuModule} from '@angular/cdk/menu';
 import {NgTemplateOutlet} from '@angular/common';
 import {Component, ViewChild} from '@angular/core';
-import {ComponentFixture, TestBed} from '@angular/core/testing';
+import {TestBed} from '@angular/core/testing';
 import {MatButtonModule} from '@angular/material/button';
 import {MatIconModule} from '@angular/material/icon';
 import {MatTooltipModule} from '@angular/material/tooltip';
 import {BrowserAnimationsModule} from '@angular/platform-browser/animations';
-import {assertDefined} from 'common/assert_utils';
-import {UnitTestUtils} from 'test/unit/utils';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
 import {ListItemOption, SearchListComponent} from './search_list_component';
 import {ListedSearch} from './ui_data';
 
 describe('SearchListComponent', () => {
-  let fixture: ComponentFixture<TestHostComponent>;
   let component: TestHostComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<TestHostComponent>;
 
   beforeEach(async () => {
     await TestBed.configureTestingModule({
@@ -43,10 +41,10 @@ describe('SearchListComponent', () => {
         MatButtonModule,
       ],
     }).compileComponents();
-    fixture = TestBed.createComponent(TestHostComponent);
+    const fixture = TestBed.createComponent(TestHostComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
-    fixture.detectChanges();
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
+    dom.detectChanges();
   });
 
   it('can be created', () => {
@@ -54,11 +52,11 @@ describe('SearchListComponent', () => {
   });
 
   it('shows placeholder text if no searches', () => {
-    expect(htmlElement.textContent?.trim()).toEqual('');
+    dom.checkTextExact('');
     const placeholderText = 'placeholder text';
     component.placeholderText = placeholderText;
-    fixture.detectChanges();
-    expect(htmlElement.textContent?.trim()).toEqual(placeholderText);
+    dom.detectChanges();
+    dom.checkTextExact(placeholderText);
   });
 
   it('shows search names with tooltips', async () => {
@@ -66,85 +64,73 @@ describe('SearchListComponent', () => {
       new ListedSearch('query1', 'name1'),
       new ListedSearch('query2', 'query2'),
     ];
-    fixture.detectChanges();
+    dom.detectChanges();
 
-    const listedSearches =
-      htmlElement.querySelectorAll<HTMLElement>('.listed-search');
+    const listedSearches = dom.findAll('.listed-search');
     expect(listedSearches.length).toEqual(2);
 
-    const queryName1 = assertDefined(
-      listedSearches[0].querySelector<HTMLElement>('.listed-search-name'),
-    );
-    const queryName2 = assertDefined(
-      listedSearches[1].querySelector<HTMLElement>('.listed-search-name'),
-    );
-    expect(queryName1.textContent?.trim()).toEqual('name1');
-    expect(queryName2.textContent?.trim()).toEqual('query2');
+    const queryName1 = listedSearches[0].get('.listed-search-name');
+    const queryName2 = listedSearches[1].get('.listed-search-name');
+    queryName1.checkTextExact('name1');
+    queryName2.checkTextExact('query2');
 
     // shows tooltip when name and query are different
-    await UnitTestUtils.checkTooltips([queryName1], ['name1: query1'], fixture);
+    await queryName1.checkTooltip('name1: query1');
 
     // does not show tooltip when name and query are the same
-    await UnitTestUtils.checkTooltips([queryName2], [undefined], fixture);
+    await queryName2.checkTooltip(undefined);
 
     // shows tooltip when element is overflowing
-    queryName2.style.maxWidth = queryName2.offsetWidth / 2 + 'px';
-    fixture.detectChanges();
-    await UnitTestUtils.checkTooltips([queryName2], ['query2'], fixture);
+    const query2El = queryName2.getHTMLElement();
+    query2El.style.maxWidth = query2El.offsetWidth / 2 + 'px';
+    dom.detectChanges();
+    await queryName2.checkTooltip('query2');
   });
 
   it('formats search dates', () => {
     spyOn(Date, 'now').and.returnValue(1000);
     component.searches = [new ListedSearch('query1', 'name1')];
-    fixture.detectChanges();
+    dom.detectChanges();
     const expectedDate = new Date(1000);
-    expect(
-      htmlElement
-        .querySelector('.listed-search-date-options')
-        ?.textContent?.trim(),
-    ).toEqual(
-      `${expectedDate
-        .toTimeString()
-        .slice(0, 5)}\n${expectedDate.toLocaleDateString()}`,
-    );
+    dom
+      .get('.listed-search-date-options')
+      .checkTextExact(
+        `${expectedDate
+          .toTimeString()
+          .slice(0, 5)}\n${expectedDate.toLocaleDateString()}`,
+      );
   });
 
-  it('shows options and triggers callback on interaction', () => {
+  it('shows options and triggers callback on interaction', async () => {
     let optionClicked: ListedSearch | undefined;
     component.searches = [new ListedSearch('query1', 'name1')];
-    fixture.detectChanges();
+    dom.detectChanges();
     // does not show menu button if no options
-    expect(htmlElement.querySelector('.listed-search-options')).toBeNull();
+    expect(dom.find('.listed-search-options')).toBeUndefined();
 
     const onClickCallback = (search: ListedSearch) => (optionClicked = search);
     component.listItemOptions = [
       {name: 'option1', icon: 'test', onClickCallback},
     ];
-    fixture.detectChanges();
+    dom.detectChanges();
 
-    const option = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.listed-search-option'),
-    );
-    UnitTestUtils.checkTooltips([option], ['option1'], fixture);
+    const option = dom.get('.listed-search-option');
+    await option.checkTooltip('option1');
     option.click();
     expect(optionClicked).toEqual(component.searches[0]);
   });
 
-  it('shows menu', () => {
+  it('shows menu', async () => {
     component.listItemOptions = [
       {name: 'option1', icon: 'test', menu: component.testTemplate},
     ];
     component.searches = [new ListedSearch('query1', 'name1')];
-    fixture.detectChanges();
-    const option = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.listed-search-option'),
-    );
-    UnitTestUtils.checkTooltips([option], ['option1'], fixture);
+    dom.detectChanges();
+    const option = dom.get('.listed-search-option');
+    await option.checkTooltip('option1');
     option.click();
-    const menu = assertDefined(
-      document.querySelector<HTMLElement>('.context-menu'),
-    );
-    expect(menu.querySelector('.test-menu-item')).toBeTruthy();
+    const menu = dom.getInDocument('.context-menu');
+    expect(menu.find('.test-menu-item')).toBeDefined();
   });
 
   @Component({
diff --git a/tools/winscope/src/viewers/viewer_search/search_result_presenter.ts b/tools/winscope/src/viewers/viewer_search/search_result_presenter.ts
index 21143cd7b..8ebc451fb 100644
--- a/tools/winscope/src/viewers/viewer_search/search_result_presenter.ts
+++ b/tools/winscope/src/viewers/viewer_search/search_result_presenter.ts
@@ -111,7 +111,7 @@ export class SearchResultPresenter extends AbstractLogViewerPresenter<
     return {
       traceEntry,
       fields,
-      propertiesTree: undefined,
+      getPropertiesTree: undefined,
     };
   }
 
diff --git a/tools/winscope/src/viewers/viewer_search/search_result_presenter_test.ts b/tools/winscope/src/viewers/viewer_search/search_result_presenter_test.ts
index 3363a0e91..812ed6856 100644
--- a/tools/winscope/src/viewers/viewer_search/search_result_presenter_test.ts
+++ b/tools/winscope/src/viewers/viewer_search/search_result_presenter_test.ts
@@ -18,10 +18,11 @@ import {assertDefined} from 'common/assert_utils';
 import {TimestampConverterUtils} from 'common/time/test_utils';
 import {TracePositionUpdate} from 'messaging/winscope_event';
 import {TraceBuilder} from 'test/unit/trace_builder';
-import {UnitTestUtils} from 'test/unit/utils';
+import {makeEmptyTrace} from 'test/unit/trace_utils';
 import {Trace} from 'trace/trace';
 import {TraceType} from 'trace/trace_type';
 import {QueryResult, Row, RowIterator} from 'trace_processor/query_result';
+import {makeSearchTraceSpies} from 'trace_processor/test_utils';
 import {NotifyLogViewCallbackType} from 'viewers/common/abstract_log_viewer_presenter';
 import {AbstractLogViewerPresenterTest} from 'viewers/common/abstract_log_viewer_presenter_test';
 import {LogHeader} from 'viewers/common/ui_data_log';
@@ -55,10 +56,7 @@ class SearchResultPresenterTest extends AbstractLogViewerPresenterTest<SearchRes
 
   override async setUpTestEnvironment(): Promise<void> {
     const time100 = TimestampConverterUtils.makeRealTimestamp(100n);
-    const [spyQueryResult, spyIter] = UnitTestUtils.makeSearchTraceSpies(
-      time100,
-      123,
-    );
+    const [spyQueryResult, spyIter] = makeSearchTraceSpies(time100, 123);
     this.spyIter = spyIter;
     this.trace = new TraceBuilder<QueryResult>()
       .setEntries([spyQueryResult])
@@ -78,12 +76,9 @@ class SearchResultPresenterTest extends AbstractLogViewerPresenterTest<SearchRes
     callback: NotifyLogViewCallbackType<SearchResult>,
   ): Promise<SearchResultPresenter> {
     const time100 = TimestampConverterUtils.makeRealTimestamp(100n);
-    const [spyQueryResult, spyIter] = UnitTestUtils.makeSearchTraceSpies(
-      time100,
-      123,
-    );
+    const [spyQueryResult, spyIter] = makeSearchTraceSpies(time100, 123);
     this.spyIter = spyIter;
-    const trace = UnitTestUtils.makeEmptyTrace(TraceType.SEARCH);
+    const trace = makeEmptyTrace(TraceType.SEARCH);
     return new SearchResultPresenter(
       trace,
       callback,
@@ -126,7 +121,7 @@ class SearchResultPresenterTest extends AbstractLogViewerPresenterTest<SearchRes
           {spec: this.expectedHeaders[1].header.spec, value: 'test_property'},
           {spec: this.expectedHeaders[2].header.spec, value: 123},
         ],
-        propertiesTree: undefined,
+        getPropertiesTree: undefined,
       },
     ]);
   }
@@ -137,8 +132,7 @@ class SearchResultPresenterTest extends AbstractLogViewerPresenterTest<SearchRes
 
       it("does not convert 'ts' column value to timestamp if entry timestamp is not valid", async () => {
         const time0 = TimestampConverterUtils.makeZeroTimestamp();
-        const [spyQueryResult, spyIter] =
-          UnitTestUtils.makeSearchTraceSpies(time0);
+        const [spyQueryResult, spyIter] = makeSearchTraceSpies(time0);
         const trace = new TraceBuilder<QueryResult>()
           .setEntries([spyQueryResult])
           .setTimestamps([time0])
diff --git a/tools/winscope/src/viewers/viewer_search/viewer_search_component_test.ts b/tools/winscope/src/viewers/viewer_search/viewer_search_component_test.ts
index a9517c588..fc2054020 100644
--- a/tools/winscope/src/viewers/viewer_search/viewer_search_component_test.ts
+++ b/tools/winscope/src/viewers/viewer_search/viewer_search_component_test.ts
@@ -18,7 +18,7 @@ import {CdkAccordionModule} from '@angular/cdk/accordion';
 import {CdkMenuModule} from '@angular/cdk/menu';
 import {ScrollingModule} from '@angular/cdk/scrolling';
 import {Component, ViewChild} from '@angular/core';
-import {ComponentFixture, TestBed} from '@angular/core/testing';
+import {TestBed} from '@angular/core/testing';
 import {FormsModule, ReactiveFormsModule} from '@angular/forms';
 import {MatButtonModule} from '@angular/material/button';
 import {MatDividerModule} from '@angular/material/divider';
@@ -30,7 +30,8 @@ import {MatTabsModule} from '@angular/material/tabs';
 import {MatTooltipModule} from '@angular/material/tooltip';
 import {BrowserAnimationsModule} from '@angular/platform-browser/animations';
 import {assertDefined} from 'common/assert_utils';
-import {UnitTestUtils} from 'test/unit/utils';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
+import {VariableHeightScrollDirective} from 'viewers/common/variable_height_scroll_directive';
 import {
   AddQueryClickDetail,
   ClearQueryClickDetail,
@@ -49,9 +50,11 @@ import {ViewerSearchComponent} from './viewer_search_component';
 
 describe('ViewerSearchComponent', () => {
   const testQuery = 'select * from table';
-  let fixture: ComponentFixture<TestHostComponent>;
+  const accordionItemSelector = '.accordion-item-header';
+  const searchQuerySelector = '.query-actions .search-button';
+  const listedSearchSelector = '.listed-search-option';
   let component: TestHostComponent;
-  let htmlElement: HTMLElement;
+  let dom: DOMTestHelper<TestHostComponent>;
 
   beforeEach(async () => {
     await TestBed.configureTestingModule({
@@ -63,6 +66,7 @@ describe('ViewerSearchComponent', () => {
         ActiveSearchComponent,
         SearchListComponent,
         LogComponent,
+        VariableHeightScrollDirective,
       ],
       imports: [
         MatFormFieldModule,
@@ -81,12 +85,12 @@ describe('ViewerSearchComponent', () => {
         MatDividerModule,
       ],
     }).compileComponents();
-    fixture = TestBed.createComponent(TestHostComponent);
+    const fixture = TestBed.createComponent(TestHostComponent);
     component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
+    dom = new DOMTestHelper(fixture, fixture.nativeElement);
     component.inputData.initialized = true;
     component.inputData.currentSearches = [new CurrentSearch(1)];
-    fixture.detectChanges();
+    dom.detectChanges();
   });
 
   it('can be created', () => {
@@ -94,46 +98,28 @@ describe('ViewerSearchComponent', () => {
   });
 
   it('creates global search section with tabs', () => {
-    const globalSearch = assertDefined(
-      htmlElement.querySelector('.global-search'),
-    );
-    const searchTabs =
-      globalSearch.querySelectorAll<HTMLElement>('.mat-tab-label');
-    const [searchTab, savedTab, recentTab] = Array.from(searchTabs);
-    expect(searchTab.textContent).toEqual('Search');
-    expect(savedTab.textContent).toEqual('Saved');
-    expect(recentTab.textContent).toEqual('Recent');
+    const globalSearch = dom.get('.global-search');
+    const [searchTab, savedTab, recentTab] =
+      globalSearch.findAll('.mat-tab-label');
+    searchTab.checkTextExact('Search');
+    savedTab.checkTextExact('Saved');
+    recentTab.checkTextExact('Recent');
   });
 
   it('creates collapsed sections with no buttons', () => {
-    UnitTestUtils.checkNoCollapsedSectionButtons(htmlElement);
+    dom.checkNoCollapsedSectionButtons();
   });
 
   it('handles search box section collapse/expand', () => {
-    UnitTestUtils.checkSectionCollapseAndExpand(
-      htmlElement,
-      fixture,
-      '.global-search',
-      'GLOBAL SEARCH',
-    );
+    dom.checkSectionCollapseAndExpand('.global-search', 'GLOBAL SEARCH');
   });
 
   it('handles tabulated results section collapse/expand', () => {
-    UnitTestUtils.checkSectionCollapseAndExpand(
-      htmlElement,
-      fixture,
-      '.search-results',
-      'SEARCH RESULTS',
-    );
+    dom.checkSectionCollapseAndExpand('.search-results', 'SEARCH RESULTS');
   });
 
   it('handles documentation groups section collapse/expand', () => {
-    UnitTestUtils.checkSectionCollapseAndExpand(
-      htmlElement,
-      fixture,
-      '.how-to-search',
-      'HOW TO SEARCH',
-    );
+    dom.checkSectionCollapseAndExpand('.how-to-search', 'HOW TO SEARCH');
   });
 
   it('handles search via search query click', () => {
@@ -142,16 +128,16 @@ describe('ViewerSearchComponent', () => {
 
   it('handles search via run query from saved without creating new active search', async () => {
     component.inputData.savedSearches = [new ListedSearch(testQuery, 'saved1')];
-    fixture.detectChanges();
+    dom.detectChanges();
     await changeTab(1);
-    runSearchAndCheckHandled(runSearchFromListedSearchOption);
+    runSearchAndCheckHandled(() => dom.findAndClick(listedSearchSelector));
   });
 
   it('handles search via run query from recents without creating new active search', async () => {
     component.inputData.recentSearches = [new ListedSearch(testQuery)];
-    fixture.detectChanges();
+    dom.detectChanges();
     await changeTab(2);
-    runSearchAndCheckHandled(runSearchFromListedSearchOption);
+    runSearchAndCheckHandled(() => dom.findAndClick(listedSearchSelector));
   });
 
   it('handles search via run query from saved creating new active search', async () => {
@@ -186,63 +172,57 @@ describe('ViewerSearchComponent', () => {
 
   it('handles running query complete', () => {
     const placeholderCss = '.results-placeholder.placeholder-text';
-    expect(htmlElement.querySelector(placeholderCss)).toBeTruthy();
+    expect(dom.find(placeholderCss)).toBeDefined();
 
-    clickSearchQueryButton();
+    dom.get(searchQuerySelector).click();
     runSearchByQueryButton();
-    expect(htmlElement.querySelector(placeholderCss)).toBeNull();
+    expect(dom.find(placeholderCss)).toBeUndefined();
 
     addCurrentSearchWithResult();
-    expect(htmlElement.querySelector('.query-execution-time')).toBeTruthy();
-    expect(htmlElement.querySelector('log-view')).toBeTruthy();
-    expect(htmlElement.querySelector(placeholderCss)).toBeNull();
+    expect(dom.find('.query-execution-time')).toBeDefined();
+    expect(dom.find('log-view')).toBeDefined();
+    expect(dom.find(placeholderCss)).toBeUndefined();
   });
 
   it('adds search sections', () => {
     const spy = jasmine.createSpy();
-    htmlElement
-      .querySelector('viewer-search')
-      ?.addEventListener(ViewerEvents.AddQueryClick, (event) => {
+    dom
+      .get('viewer-search')
+      .addEventListener(ViewerEvents.AddQueryClick, (event) => {
         const detail: AddQueryClickDetail = (event as CustomEvent).detail;
         expect(detail).toBeFalsy();
         spy();
       });
 
-    let addButton = assertDefined(
-      htmlElement.querySelector<HTMLButtonElement>('.add-button'),
-    );
-    expect(htmlElement.querySelector('.clear-button')).toBeNull();
-    expect(addButton.disabled).toBeTrue();
+    const addButton = dom.get('.add-button');
+    expect(dom.find('.clear-button')).toBeUndefined();
+    addButton.checkDisabled(true);
 
     const data = structuredClone(component.inputData);
     data.currentSearches[0].query = testQuery;
     updateInputDataAndDetectChanges(data);
 
     addButton.click();
-    fixture.detectChanges();
     expect(spy).toHaveBeenCalledTimes(1);
 
     const newData = structuredClone(component.inputData);
     newData.currentSearches.push(new CurrentSearch(2));
     updateInputDataAndDetectChanges(newData);
 
-    const activeSections = htmlElement.querySelectorAll('active-search');
+    const activeSections = dom.findAll('active-search');
     expect(activeSections.length).toEqual(2);
-    expect(activeSections.item(0).querySelector('.clear-button')).toBeTruthy();
-    expect(activeSections.item(1).querySelector('.clear-button')).toBeTruthy();
+    expect(activeSections[0].find('.clear-button')).toBeDefined();
+    expect(activeSections[1].find('.clear-button')).toBeDefined();
 
-    expect(activeSections.item(0).querySelector('.add-button')).toBeNull();
-    addButton = assertDefined(
-      activeSections.item(1).querySelector<HTMLButtonElement>('.add-button'),
-    );
-    expect(addButton.disabled).toBeTrue();
+    expect(activeSections[0].find('.add-button')).toBeUndefined();
+    activeSections[1].get('.add-button').checkDisabled(true);
   });
 
   it('handles multiple results', async () => {
     let uid: number | undefined;
-    htmlElement
-      .querySelector('viewer-search')
-      ?.addEventListener(ViewerEvents.ClearQueryClick, (event) => {
+    dom
+      .get('viewer-search')
+      .addEventListener(ViewerEvents.ClearQueryClick, (event) => {
         const detail: ClearQueryClickDetail = (event as CustomEvent).detail;
         uid = detail.uid;
       });
@@ -251,35 +231,27 @@ describe('ViewerSearchComponent', () => {
     data.currentSearches[0].result = new SearchResult([], []);
     updateInputDataAndDetectChanges(data);
     addCurrentSearchWithResult(testQuery, 2);
-    let resultTabs = htmlElement.querySelectorAll(
-      '.result-tabs .mat-tab-label',
-    );
-    let activeSections =
-      htmlElement.querySelectorAll<HTMLElement>('active-search');
+    let resultTabs = dom.findAll('.result-tabs .mat-tab-label');
+    let activeSections = dom.findAll('active-search');
     expect(activeSections.length).toEqual(2);
     expect(resultTabs.length).toEqual(2);
-    expect(resultTabs.item(0).textContent).toEqual('Query 1');
-    expect(resultTabs.item(1).textContent).toEqual('Query 2');
+    resultTabs[0].checkTextExact('Query 1');
+    resultTabs[1].checkTextExact('Query 2');
 
-    const clearButton = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.clear-button'),
-    );
-    clearButton.click();
-    fixture.detectChanges();
+    dom.findAndClick('.clear-button');
     expect(uid).toEqual(1);
 
-    const finalActiveSection = activeSections.item(1);
-    const spy = spyOn(finalActiveSection, 'scrollIntoView');
+    const spy = spyOn(activeSections[1].getHTMLElement(), 'scrollIntoView');
 
     const newData = structuredClone(component.inputData);
     newData.currentSearches.shift();
     updateInputDataAndDetectChanges(newData);
-    await fixture.whenStable();
+    await dom.whenStable();
 
-    resultTabs = htmlElement.querySelectorAll('.result-tabs .mat-tab-label');
-    activeSections = htmlElement.querySelectorAll('active-search');
+    resultTabs = dom.findAll('.result-tabs .mat-tab-label');
+    activeSections = dom.findAll('active-search');
     expect(resultTabs.length).toEqual(1);
-    expect(resultTabs.item(0).textContent).toEqual('Query 2');
+    resultTabs[0].checkTextExact('Query 2');
     expect(activeSections.length).toEqual(1);
     expect(spy).toHaveBeenCalled();
   });
@@ -289,162 +261,124 @@ describe('ViewerSearchComponent', () => {
     const data = structuredClone(component.inputData);
     data.lastTraceFailed = true;
     updateInputDataAndDetectChanges(data);
-    expect(htmlElement.querySelector('.query-execution-time')).toBeTruthy();
-    expect(htmlElement.querySelector('.running-query-message')).toBeNull();
-    expect(htmlElement.querySelector('log-view')).toBeNull();
-    expect(getSearchQueryButton().disabled).toBeFalse();
+    expect(dom.find('.query-execution-time')).toBeDefined();
+    expect(dom.find('.running-query-message')).toBeUndefined();
+    expect(dom.find('log-view')).toBeUndefined();
+    dom.get(searchQuerySelector).checkDisabled(false);
   });
 
   it('emits event on save query click', () => {
     let detail: SaveQueryClickDetail | undefined;
-    htmlElement
-      .querySelector('viewer-search')
-      ?.addEventListener(ViewerEvents.SaveQueryClick, (event) => {
+    dom
+      .get('viewer-search')
+      .addEventListener(ViewerEvents.SaveQueryClick, (event) => {
         detail = (event as CustomEvent).detail;
       });
     const testName = 'Query 1';
     component.inputData.savedSearches.push(
       new ListedSearch(testQuery, testName),
     );
-    fixture.detectChanges();
+    dom.detectChanges();
     addCurrentSearchWithResult();
-    const saveField = assertDefined(
-      htmlElement.querySelector('.current-search .save-field'),
-    );
-    const saveQueryButton = assertDefined(
-      saveField.querySelector<HTMLElement>('.query-button'),
-    );
-    const input = assertDefined(
-      saveField.querySelector<HTMLInputElement>('input'),
-    );
-    changeInput(input, testName);
-    pressEnter(input);
+    const saveField = dom.get('.current-search .save-field');
+    const saveQueryButton = saveField.get('.query-button');
+    const input = saveField.get('input');
+    input.dispatchInput(testName);
     saveQueryButton.click();
-    fixture.detectChanges();
     expect(detail).toBeUndefined(); // name already exists
 
     const testName2 = 'Query 2';
-    changeInput(input, testName2);
-    pressEnter(input); // save by enter key
+    input.dispatchInput(testName2);
+    input.keydownEnter(); // save by enter key
     expect(detail).toEqual(new SaveQueryClickDetail(testQuery, testName2));
 
     const testName3 = 'Query 3';
-    changeInput(input, testName3);
-    saveQueryButton.click();
-    fixture.detectChanges(); // save by click
+    input.dispatchInput(testName3);
+    saveQueryButton.click(); // save by click
     expect(detail).toEqual(new SaveQueryClickDetail(testQuery, testName3));
   });
 
   it('emits event on delete saved query click', async () => {
     let detail: DeleteSavedQueryClickDetail | undefined;
-    htmlElement
-      .querySelector('viewer-search')
-      ?.addEventListener(ViewerEvents.DeleteSavedQueryClick, (event) => {
+    dom
+      .get('viewer-search')
+      .addEventListener(ViewerEvents.DeleteSavedQueryClick, (event) => {
         detail = (event as CustomEvent).detail;
       });
     const search = new ListedSearch(testQuery);
     component.inputData.savedSearches = [search];
-    fixture.detectChanges();
+    dom.detectChanges();
 
     await changeTab(1);
-    const listedSearchButton = assertDefined(
-      htmlElement.querySelectorAll<HTMLElement>('.listed-search-option'),
-    );
-    listedSearchButton.item(2).click();
+    dom.findAndClickByIndex(listedSearchSelector, 2);
     expect(detail).toEqual(new DeleteSavedQueryClickDetail(search));
   });
 
   it('handles trace search initialization', () => {
     component.inputData.initialized = false;
-    fixture.detectChanges();
+    dom.detectChanges();
     const spy = jasmine.createSpy();
-    htmlElement
-      .querySelector('viewer-search')
-      ?.addEventListener(ViewerEvents.GlobalSearchSectionClick, (event) =>
+    dom
+      .get('viewer-search')
+      .addEventListener(ViewerEvents.GlobalSearchSectionClick, (event) =>
         spy(),
       );
-    const globalSearch = assertDefined(
-      htmlElement.querySelector<HTMLElement>('.global-search'),
-    );
-    expect(globalSearch.querySelector('.message-with-spinner')).toBeNull();
+    const globalSearch = dom.get('.global-search');
+    expect(globalSearch.find('.message-with-spinner')).toBeUndefined();
 
     clickGlobalSearchAndCheckMessage(globalSearch);
     clickGlobalSearchAndCheckMessage(globalSearch);
     expect(spy).toHaveBeenCalledTimes(1);
 
-    changeInput(getTextInput(), testQuery);
-    expect(getSearchQueryButton().disabled).toBeTrue();
+    getTextInput().dispatchInput(testQuery);
+    dom.get(searchQuerySelector).checkDisabled(true);
 
     const data = structuredClone(component.inputData);
     data.initialized = true;
     updateInputDataAndDetectChanges(data);
-    expect(globalSearch.querySelector('.message-with-spinner')).toBeNull();
-    expect(getSearchQueryButton().disabled).toBeFalse();
+    expect(globalSearch.find('.message-with-spinner')).toBeUndefined();
+    dom.get(searchQuerySelector).checkDisabled(false);
   });
 
   it('can open SQL view descriptors in how to section', () => {
-    const accordionItems = htmlElement.querySelectorAll<HTMLElement>(
-      '.how-to-search .accordion-item',
-    );
+    const accordionItems = dom.findAll('.how-to-search .accordion-item');
     expect(accordionItems.length).toEqual(6);
     accordionItems.forEach((item) => checkAccordionItemCollapsed(item));
 
-    clickAccordionItemHeader(accordionItems.item(0));
-    checkAccordionItemExpanded(accordionItems.item(0));
-    checkAccordionItemCollapsed(accordionItems.item(1));
+    accordionItems[0].get(accordionItemSelector).click();
+    checkAccordionItemExpanded(accordionItems[0]);
+    checkAccordionItemCollapsed(accordionItems[1]);
 
-    clickAccordionItemHeader(accordionItems.item(1));
-    checkAccordionItemExpanded(accordionItems.item(0));
-    checkAccordionItemExpanded(accordionItems.item(1));
+    accordionItems[1].get(accordionItemSelector).click();
+    checkAccordionItemExpanded(accordionItems[0]);
+    checkAccordionItemExpanded(accordionItems[1]);
 
-    clickAccordionItemHeader(accordionItems.item(0));
-    checkAccordionItemCollapsed(accordionItems.item(0));
-    checkAccordionItemExpanded(accordionItems.item(1));
+    accordionItems[0].get(accordionItemSelector).click();
+    checkAccordionItemCollapsed(accordionItems[0]);
+    checkAccordionItemExpanded(accordionItems[1]);
   });
 
-  function clickGlobalSearchAndCheckMessage(globalSearch: HTMLElement) {
-    globalSearch.click();
-    fixture.detectChanges();
-    expect(globalSearch.querySelector('.message-with-spinner')).toBeTruthy();
-    expect(getSearchQueryButton().disabled).toBeTrue();
-  }
-
-  function getTextInput(i = 0): HTMLTextAreaElement {
-    return htmlElement
-      .querySelectorAll<HTMLTextAreaElement>('.query-field textarea')
-      .item(i);
-  }
-
-  function changeInput(
-    input: HTMLInputElement | HTMLTextAreaElement,
-    query: string,
+  function clickGlobalSearchAndCheckMessage(
+    globalSearch: DOMTestHelper<TestHostComponent>,
   ) {
-    input.value = query;
-    input.dispatchEvent(new Event('input'));
-    fixture.detectChanges();
-  }
-
-  function getSearchQueryButton(i = 0): HTMLButtonElement {
-    return htmlElement
-      .querySelectorAll<HTMLButtonElement>('.query-actions .search-button')
-      .item(i);
+    globalSearch.click();
+    expect(dom.find('.message-with-spinner')).toBeDefined();
+    dom.get(searchQuerySelector).checkDisabled(true);
   }
 
-  function clickSearchQueryButton(i = 0) {
-    getSearchQueryButton(i).click();
-    fixture.detectChanges();
+  function getTextInput(i = 0): DOMTestHelper<TestHostComponent> {
+    return dom.findAll('.query-field textarea')[i];
   }
 
   function runSearchByQueryButton(i = 0) {
-    changeInput(getTextInput(i), testQuery);
-    clickSearchQueryButton(i);
+    getTextInput(i).dispatchInput(testQuery);
+    dom.findAndClickByIndex(searchQuerySelector, i);
   }
 
   async function changeTab(index: number) {
     const matTabGroups = assertDefined(component.searchComponent?.matTabGroups);
     matTabGroups.first.selectedIndex = index;
-    fixture.detectChanges();
-    await fixture.whenStable();
+    await dom.detectChangesAndWaitStable();
   }
 
   async function checkRunQueryFromOptionsWhenResultPresent(tabIndex: number) {
@@ -452,63 +386,46 @@ describe('ViewerSearchComponent', () => {
     data.currentSearches[0].query = testQuery;
     data.currentSearches[0].result = new SearchResult([], []);
     let query: string | undefined;
-    htmlElement
-      .querySelector('viewer-search')
-      ?.addEventListener(ViewerEvents.AddQueryClick, (event) => {
+    dom
+      .get('viewer-search')
+      .addEventListener(ViewerEvents.AddQueryClick, (event) => {
         const detail: AddQueryClickDetail = (event as CustomEvent).detail;
         query = detail.query;
       });
     updateInputDataAndDetectChanges(data);
 
     await changeTab(tabIndex);
-    runSearchFromListedSearchOption();
+    dom.findAndClick(listedSearchSelector);
     expect(query).toEqual(testQuery);
     await changeTab(0);
     runSearchAndCheckHandled(addCurrentSearchWithResult);
-    const activeSections = htmlElement.querySelectorAll('active-search');
-    expect(activeSections.length).toEqual(2);
-  }
-
-  function runSearchFromListedSearchOption() {
-    assertDefined(
-      htmlElement.querySelector<HTMLElement>('.listed-search-option'),
-    ).click();
-    fixture.detectChanges();
+    expect(dom.findAll('active-search').length).toEqual(2);
   }
 
   function runSearchAndCheckHandled(runSearch: () => void) {
     let query: string | undefined;
-    htmlElement
-      .querySelector('viewer-search')
-      ?.addEventListener(ViewerEvents.SearchQueryClick, (event) => {
+    dom
+      .get('viewer-search')
+      .addEventListener(ViewerEvents.SearchQueryClick, (event) => {
         const detail: SearchQueryClickDetail = (event as CustomEvent).detail;
         query = detail.query;
       });
     runSearch();
     expect(query).toEqual(testQuery);
-    expect(getSearchQueryButton().disabled).toBeTrue();
-    const runningQueryMessage = assertDefined(
-      htmlElement.querySelector('.running-query-message'),
-    );
-    expect(runningQueryMessage.textContent?.trim()).toEqual(
-      'timer Calculating results',
-    );
-    expect(runningQueryMessage.querySelector('mat-spinner')).toBeTruthy();
-  }
-
-  function pressEnter(input: HTMLInputElement, shiftKey = false) {
-    input.dispatchEvent(new KeyboardEvent('keydown', {key: 'Enter', shiftKey}));
-    fixture.detectChanges();
+    dom.get(searchQuerySelector).checkDisabled(true);
+    const runningQueryMessage = dom.get('.running-query-message');
+    runningQueryMessage.checkTextExact('timer Calculating results');
+    expect(runningQueryMessage.find('mat-spinner')).toBeDefined();
   }
 
   async function checkEditQueryFromOptionsWhenResultPresent(tabIndex: number) {
     component.inputData.currentSearches[0].result = new SearchResult([], []);
-    fixture.detectChanges();
+    dom.detectChanges();
 
     let query: string | undefined;
-    htmlElement
-      .querySelector('viewer-search')
-      ?.addEventListener(ViewerEvents.AddQueryClick, (event) => {
+    dom
+      .get('viewer-search')
+      .addEventListener(ViewerEvents.AddQueryClick, (event) => {
         const detail: AddQueryClickDetail = (event as CustomEvent).detail;
         query = detail.query;
       });
@@ -522,34 +439,30 @@ describe('ViewerSearchComponent', () => {
     const data = structuredClone(component.inputData);
     data.currentSearches.push(new CurrentSearch(2, testQuery));
     updateInputDataAndDetectChanges(data);
-    fixture.detectChanges();
-    await fixture.whenStable();
+    await dom.detectChangesAndWaitStable();
     expect(
       component.searchComponent?.matTabGroups?.first.selectedIndex,
     ).toEqual(0);
-    expect(getTextInput(0).value).toEqual('');
-    expect(getTextInput(1).value).toEqual(testQuery);
+    getTextInput(0).checkValue('');
+    getTextInput(1).checkValue(testQuery);
   }
 
   async function checkEditQueryFromOptions(tabIndex: number) {
-    fixture.detectChanges();
+    dom.detectChanges();
     const input = getTextInput();
-    expect(input.value).toEqual('');
+    expect(input.checkValue(''));
     await changeTabAndClickEdit(tabIndex);
     expect(
       component.searchComponent?.matTabGroups?.first.selectedIndex,
     ).toEqual(0);
-    expect(input.value).toEqual(testQuery);
+    expect(input.checkValue(testQuery));
   }
 
   async function changeTabAndClickEdit(tabIndex: number) {
     await changeTab(tabIndex);
-    const listedSearchButton = assertDefined(
-      htmlElement.querySelectorAll<HTMLElement>('.listed-search-option'),
-    );
-    listedSearchButton.item(1).click();
-    fixture.detectChanges();
-    await fixture.whenStable();
+    const listedSearchButton = dom.findAll('.listed-search-option');
+    listedSearchButton[1].click();
+    await dom.whenStable();
   }
 
   function addCurrentSearchWithResult(q = testQuery, uid = 2) {
@@ -559,33 +472,19 @@ describe('ViewerSearchComponent', () => {
     updateInputDataAndDetectChanges(data);
   }
 
-  function getAccordionItemHeader(item: HTMLElement) {
-    return assertDefined(
-      item.querySelector<HTMLElement>('.accordion-item-header'),
-    );
-  }
-
-  function clickAccordionItemHeader(item: HTMLElement) {
-    const header = getAccordionItemHeader(item);
-    header.click();
-    fixture.detectChanges();
-  }
-
-  function checkAccordionItemCollapsed(item: HTMLElement) {
-    const header = getAccordionItemHeader(item);
-    expect(header.textContent).toContain('chevron_right');
-    expect(item.querySelector('.accordion-item-body')).toBeNull();
+  function checkAccordionItemCollapsed(item: DOMTestHelper<TestHostComponent>) {
+    item.get(accordionItemSelector).checkText('chevron_right');
+    expect(item.find('.accordion-item-body')).toBeUndefined();
   }
 
-  function checkAccordionItemExpanded(item: HTMLElement) {
-    const header = getAccordionItemHeader(item);
-    expect(header.textContent).toContain('arrow_drop_down');
-    expect(item.querySelector('.accordion-item-body')).toBeTruthy();
+  function checkAccordionItemExpanded(item: DOMTestHelper<TestHostComponent>) {
+    item.get(accordionItemSelector).checkText('arrow_drop_down');
+    expect(item.find('.accordion-item-body')).toBeDefined();
   }
 
   function updateInputDataAndDetectChanges(data: UiData) {
     component.inputData = data;
-    fixture.detectChanges();
+    dom.detectChanges();
   }
 
   @Component({
diff --git a/tools/winscope/src/viewers/viewer_surface_flinger/presenter.ts b/tools/winscope/src/viewers/viewer_surface_flinger/presenter.ts
index 2ccf5306d..fd8f5c7b7 100644
--- a/tools/winscope/src/viewers/viewer_surface_flinger/presenter.ts
+++ b/tools/winscope/src/viewers/viewer_surface_flinger/presenter.ts
@@ -21,8 +21,8 @@ import {
   TabbedViewSwitchRequest,
   TracePositionUpdate,
 } from 'messaging/winscope_event';
-import {LayerFlag} from 'parsers/surface_flinger/layer_flag';
 import {CustomQueryType} from 'trace/custom_query';
+import {LayerFlag} from 'trace/surface_flinger/layer_flag';
 import {Trace} from 'trace/trace';
 import {Traces} from 'trace/traces';
 import {TraceEntryFinder} from 'trace/trace_entry_finder';
diff --git a/tools/winscope/src/viewers/viewer_surface_flinger/presenter_test.ts b/tools/winscope/src/viewers/viewer_surface_flinger/presenter_test.ts
index 5cc805231..bfc6c328f 100644
--- a/tools/winscope/src/viewers/viewer_surface_flinger/presenter_test.ts
+++ b/tools/winscope/src/viewers/viewer_surface_flinger/presenter_test.ts
@@ -21,10 +21,12 @@ import {
   TabbedViewSwitchRequest,
   TracePositionUpdate,
 } from 'messaging/winscope_event';
+import {LegacyParserProvider} from 'test/unit/fixture_utils';
 import {HierarchyTreeBuilder} from 'test/unit/hierarchy_tree_builder';
 import {TraceBuilder} from 'test/unit/trace_builder';
+import {makeEmptyTrace} from 'test/unit/trace_utils';
+import {TreeNodeUtils} from 'test/unit/tree_node_utils';
 import {UserNotifierChecker} from 'test/unit/user_notifier_checker';
-import {UnitTestUtils} from 'test/unit/utils';
 import {CustomQueryType} from 'trace/custom_query';
 import {Trace} from 'trace/trace';
 import {Traces} from 'trace/traces';
@@ -48,7 +50,6 @@ class PresenterSurfaceFlingerTest extends AbstractHierarchyViewerPresenterTest<U
   private traceSf: Trace<HierarchyTreeNode> | undefined;
   private positionUpdate: TracePositionUpdate | undefined;
   private secondPositionUpdate: TracePositionUpdate | undefined;
-  private positionUpdateMultiDisplayEntry: TracePositionUpdate | undefined;
   private selectedTree: UiHierarchyTreeNode | undefined;
   private selectedTreeAfterPositionUpdate: UiHierarchyTreeNode | undefined;
 
@@ -103,6 +104,7 @@ the default for its data type.`,
     },
   };
 
+  override readonly rectIndex = 15;
   override readonly expectedInitialRectSpec = {
     type: TraceRectType.LAYERS,
     icon: TRACE_INFO[TraceType.SURFACE_FLINGER].icon,
@@ -168,50 +170,39 @@ the default for its data type.`,
     ],
   };
   override readonly treeNodeLongName =
-    'ActivityRecord{64953af u0 com.google.android.apps.nexuslauncher/.NexusLauncherActivity#96';
+    'com.google.android.apps.maps/com.google.android.maps.LimitedMapsActivity#630';
   override readonly treeNodeShortName =
-    'ActivityRecord{64953af u0 com.google.(...).NexusLauncherActivity#96';
+    'com.google.(...).LimitedMapsActivity#630';
 
   override async setUpTestEnvironment(): Promise<void> {
-    const perfettoTrace = await UnitTestUtils.getPerfettoParser(
-      TraceType.SURFACE_FLINGER,
-      'traces/perfetto/layers_trace.perfetto-trace',
-    );
+    const parser = await new LegacyParserProvider()
+      .addFilename(
+        'traces/elapsed_and_real_timestamp/SurfaceFlinger_multidisplay.pb',
+      )
+      .setConvertToPerfetto(true)
+      .getParser<HierarchyTreeNode>();
+
     this.traceSf = new TraceBuilder<HierarchyTreeNode>()
       .setType(TraceType.SURFACE_FLINGER)
       .setEntries([
-        await UnitTestUtils.getLayerTraceEntry(0),
-        await UnitTestUtils.getMultiDisplayLayerTraceEntry(),
-        await UnitTestUtils.getLayerTraceEntry(1),
-        await UnitTestUtils.getTraceEntry<HierarchyTreeNode>(
-          'traces/elapsed_and_real_timestamp/SurfaceFlinger.pb',
-          5,
-        ),
-        await UnitTestUtils.getTraceEntry<HierarchyTreeNode>(
-          'traces/elapsed_and_real_timestamp/SurfaceFlinger.pb',
-          6,
-        ),
-        await UnitTestUtils.getTraceEntry<HierarchyTreeNode>(
-          'traces/elapsed_and_real_timestamp/SurfaceFlinger_with_duplicated_ids.pb',
-        ),
-        await perfettoTrace.getEntry(0),
+        await parser.getEntry(0),
+        await parser.getEntry(1),
+        await parser.getEntry(2),
       ])
       .build();
 
     const firstEntry = this.traceSf.getEntry(0);
     this.positionUpdate = TracePositionUpdate.fromTraceEntry(firstEntry);
-    this.positionUpdateMultiDisplayEntry = TracePositionUpdate.fromTraceEntry(
-      this.traceSf.getEntry(1),
-    );
     this.secondPositionUpdate = TracePositionUpdate.fromTraceEntry(
-      this.traceSf.getEntry(2),
+      this.traceSf.getEntry(1),
     );
 
     const firstEntryDataTree = await firstEntry.getValue();
+
     const layer = assertDefined(
       firstEntryDataTree.findDfs(
         UiTreeUtils.makeIdMatchFilter(
-          '163 Surface(name=b48baf1 InputMethod)/@0x3a7bd57 - animation-leash of insets_animation#163',
+          '576 com.android.car.carlauncher/com.android.car.carlauncher.CarLauncher#576',
         ),
       ),
     );
@@ -220,18 +211,25 @@ the default for its data type.`,
     );
     this.selectedTree = assertDefined(
       selectedTreeParent.getChildByName(
-        'Surface(name=b48baf1 InputMethod)/@0x3a7bd57 - animation-leash of insets_animation#163',
+        'com.android.car.carlauncher/com.android.car.carlauncher.CarLauncher#576',
       ),
     );
-    const treeAfterPosiionUpdateParent = UiHierarchyTreeNode.from(
+
+    const treeAfterPositionUpdateParent = UiHierarchyTreeNode.from(
       assertDefined(
         firstEntryDataTree
-          .findDfs(UiTreeUtils.makeIdMatchFilter('79 Wallpaper BBQ wrapper#79'))
+          .findDfs(
+            UiTreeUtils.makeIdMatchFilter(
+              '630 com.google.android.apps.maps/com.google.android.maps.LimitedMapsActivity#630',
+            ),
+          )
           ?.getZParent(),
       ),
     );
     this.selectedTreeAfterPositionUpdate = assertDefined(
-      treeAfterPosiionUpdateParent.getChildByName('Wallpaper BBQ wrapper#79'),
+      treeAfterPositionUpdateParent.getChildByName(
+        'com.google.android.apps.maps/com.google.android.maps.LimitedMapsActivity#630',
+      ),
     );
     const rect = assertDefined(
       this.selectedTreeAfterPositionUpdate.getRects()?.at(0),
@@ -242,7 +240,7 @@ the default for its data type.`,
   override createPresenterWithEmptyTrace(
     callback: NotifyHierarchyViewCallbackType<UiData>,
   ): Presenter {
-    const trace = UnitTestUtils.makeEmptyTrace(TraceType.SURFACE_FLINGER);
+    const trace = makeEmptyTrace(TraceType.SURFACE_FLINGER);
     const traces = new Traces();
     traces.addTrace(trace);
     return new Presenter(trace, traces, new InMemoryStorage(), callback);
@@ -271,26 +269,24 @@ the default for its data type.`,
   }
 
   override getSelectedTreeAfterPositionUpdate(): UiHierarchyTreeNode {
-    return assertDefined(this.selectedTreeAfterPositionUpdate);
+    return assertDefined(this.selectedTree);
   }
 
   override executePropertiesChecksAfterPositionUpdate(uiData: UiDataHierarchy) {
+    expect(
+      uiData.propertiesTree?.getChildByName('screenBounds')?.formattedValue(),
+    ).toEqual('(0, 0) - (1080, 600)');
     expect(
       assertDefined(
-        uiData.propertiesTree
-          ?.getChildByName('metadata')
-          ?.getChildByName('2')
-          ?.getChildByName('byteOffset'),
+        uiData.propertiesTree?.getChildByName('damageRegion'),
       ).formattedValue(),
-    ).toEqual('2919');
-    expect(uiData.displays).toEqual([
-      {
-        displayId: '4619827677550801152',
-        groupId: 0,
-        name: 'Common Panel',
-        isActive: true,
-      },
-    ]);
+    ).toEqual('SkRegion((0, 0, 1080, 600))');
+    expect(uiData.displays?.at(0)).toEqual({
+      displayId: '4619827259835644672',
+      groupId: 0,
+      name: 'EMU_display_0',
+      isActive: true,
+    });
     expect(assertDefined((uiData as UiData).curatedProperties).flags).toEqual(
       'ENABLE_BACKPRESSURE (0x100)',
     );
@@ -305,13 +301,8 @@ the default for its data type.`,
     uiData: UiDataHierarchy,
   ) {
     expect(
-      assertDefined(
-        uiData.propertiesTree
-          ?.getChildByName('metadata')
-          ?.getChildByName('2')
-          ?.getChildByName('byteOffset'),
-      ).formattedValue(),
-    ).toEqual('44517');
+      uiData.propertiesTree?.getChildByName('damageRegion'),
+    ).toBeUndefined();
   }
 
   override executeSpecializedChecksForPropertiesFromRect(
@@ -320,31 +311,29 @@ the default for its data type.`,
     const curatedProperties = assertDefined(
       (uiData as UiData).curatedProperties,
     );
-    expect(curatedProperties.flags).toEqual('ENABLE_BACKPRESSURE (0x100)');
+    expect(curatedProperties.flags).toEqual(
+      'OPAQUE | ENABLE_BACKPRESSURE (0x102)',
+    );
     expect(curatedProperties.summary).toEqual([
       {
         key: 'Covered by',
         desc: 'Partially or fully covered by these likely translucent layers',
         layerValues: [
           {
-            layerId: '65',
-            nodeId: '65 ScreenDecorOverlayBottom#65',
-            name: 'ScreenDecorOverlayBottom#65',
-          },
-          {
-            layerId: '62',
-            nodeId: '62 ScreenDecorOverlay#62',
-            name: 'ScreenDecorOverlay#62',
+            layerId: '174',
+            nodeId: '174 BottomCarSystemBar#174',
+            name: 'BottomCarSystemBar#174',
           },
           {
-            layerId: '85',
-            nodeId: '85 NavigationBar0#85',
-            name: 'NavigationBar0#85',
+            layerId: '164',
+            nodeId: '164 TopCarSystemBar#164',
+            name: 'TopCarSystemBar#164',
           },
           {
-            layerId: '89',
-            nodeId: '89 StatusBar#89',
-            name: 'StatusBar#89',
+            layerId: '576',
+            nodeId:
+              '576 com.android.car.carlauncher/com.android.car.carlauncher.CarLauncher#576',
+            name: 'com.android.car.carlauncher/com.android.car.carlauncher.CarLauncher#576',
           },
         ],
       },
@@ -400,9 +389,7 @@ the default for its data type.`,
       });
 
       it('handles displays with no visible layers', async () => {
-        await presenter?.onAppEvent(
-          assertDefined(this.positionUpdateMultiDisplayEntry),
-        );
+        await presenter?.onAppEvent(assertDefined(this.positionUpdate));
         expect(uiData?.displays?.length).toEqual(5);
         // we want the displays to be sorted by name
         expect(uiData?.displays).toEqual([
@@ -431,7 +418,7 @@ the default for its data type.`,
             isActive: true,
           },
           {
-            displayId: '11529215046312967684',
+            displayId: '-6917529027396583932',
             groupId: 5,
             name: 'ClusterOsDouble-VD',
             isActive: false,
@@ -467,21 +454,19 @@ the default for its data type.`,
           traceSf.getEntry(0),
         );
         await presenter.onAppEvent(positionUpdate);
-        expect(uiData?.displays).toEqual([
-          {
-            displayId: '4619827677550801152',
-            groupId: 0,
-            name: 'Common Panel',
-            isActive: false,
-          },
-        ]);
+        expect(uiData?.displays[0]).toEqual({
+          displayId: '4619827259835644672',
+          groupId: 0,
+          name: 'EMU_display_0',
+          isActive: false,
+        });
       });
 
       it('updates view capture package names', async () => {
         await createPresenterWithViewCapture(assertDefined(this.traceSf));
         expect(
           uiData.rectsToDraw.filter((rect) => rect.hasContent).length,
-        ).toEqual(2);
+        ).toEqual(1);
       });
 
       it('handles rect double click if view capture trace present', async () => {
@@ -493,9 +478,7 @@ the default for its data type.`,
 
         await presenter.onRectDoubleClick('not in package');
         expect(spy).not.toHaveBeenCalled();
-        await presenter.onRectDoubleClick(
-          'com.google.android.apps.nexuslauncher',
-        );
+        await presenter.onRectDoubleClick('com.android.car.carlauncher');
         expect(spy).toHaveBeenCalledOnceWith(
           new TabbedViewSwitchRequest(traceVc),
         );
@@ -522,19 +505,16 @@ the default for its data type.`,
       it('clears curated properties on position update if no properties tree found', async () => {
         const trace = assertDefined(this.traceSf);
         await presenter.onAppEvent(
-          TracePositionUpdate.fromTraceEntry(trace.getEntry(3)),
+          TracePositionUpdate.fromTraceEntry(trace.getEntry(2)),
         );
 
-        const nodeName =
-          '101 Surface(name=Task=1)/@0x47f46c9 - animation-leash of app_transition#101';
-
-        await presenter.onHighlightedIdChange(nodeName);
+        await presenter.onHighlightedIdChange(
+          '744 1d30e3b VolumeDialogImpl#744',
+        );
         expect(uiData.propertiesTree).toBeDefined();
         expect(uiData.curatedProperties).toBeDefined();
 
-        await presenter.onAppEvent(
-          TracePositionUpdate.fromTraceEntry(trace.getEntry(4)),
-        );
+        await presenter.onAppEvent(assertDefined(this.positionUpdate));
         expect(uiData.propertiesTree).toBeUndefined();
         expect(uiData.curatedProperties).toBeUndefined();
       });
@@ -542,50 +522,43 @@ the default for its data type.`,
       it('updates zOrderRelativeOf formatter and rel-z curated properties correctly', async () => {
         await presenter.onAppEvent(this.getPositionUpdate());
 
-        const nodeWithRelZChild = assertDefined(
+        const nodeWithRelZChild = this.getSelectedTree();
+        const nodeWithRelZParent = assertDefined(
           assertDefined(uiData.hierarchyTrees)[0].findDfs(
             UiTreeUtils.makeNodeFilter(
               new TextFilter(
-                '98 2c99222 com.google.android.apps.nexuslauncher/com.google.android.apps.nexuslauncher.NexusLauncherActivity#98',
+                '626 SurfaceView[com.android.car.carlauncher/com.android.car.carlauncher.CarLauncher]#626',
               ).getFilterPredicate(),
             ),
           ),
         );
-        const nodeWithRelZParent = assertDefined(
-          assertDefined(uiData.hierarchyTrees)[0].findDfs(
-            UiTreeUtils.makeNodeFilter(
-              new TextFilter('13 ImeContainer#13').getFilterPredicate(),
-            ),
-          ),
-        );
 
         await presenter.onHighlightedNodeChange(nodeWithRelZChild);
+        const secondRelZChildName =
+          'Background for SurfaceView[com.android.car.carlauncher/com.android.car.carlauncher.CarLauncher]#628';
         expect(uiData.curatedProperties?.relativeParent).toEqual('none');
         expect(uiData.curatedProperties?.relativeChildren).toEqual([
           {
-            layerId: '13',
+            layerId: '626',
             nodeId: nodeWithRelZParent.id,
             name: nodeWithRelZParent.name,
           },
+          {
+            layerId: '628',
+            nodeId: '628 ' + secondRelZChildName,
+            name: secondRelZChildName,
+          },
         ]);
 
         await presenter.onHighlightedNodeChange(nodeWithRelZParent);
         expect(uiData.curatedProperties?.relativeParent).toEqual({
-          layerId: '98',
+          layerId: '576',
           nodeId: nodeWithRelZChild.id,
           name: nodeWithRelZChild.name,
         });
         expect(uiData.curatedProperties?.relativeChildren).toEqual([]);
       });
 
-      it('adds warnings to ui hierarchy tree node', async () => {
-        await presenter.onAppEvent(this.getPositionUpdate());
-        expect(uiData.hierarchyTrees?.at(0)?.getWarnings().length).toEqual(0);
-        const entry = assertDefined(this.traceSf?.getEntry(5));
-        await presenter.onAppEvent(TracePositionUpdate.fromTraceEntry(entry));
-        expect(uiData.hierarchyTrees?.at(0)?.getWarnings().length).toEqual(1);
-      });
-
       it('sets properties tree but no curated properties for root node', async () => {
         await presenter.onAppEvent(this.getPositionUpdate());
         await presenter.onHighlightedIdChange(
@@ -608,6 +581,7 @@ the default for its data type.`,
               properties: {
                 occludedBy: ['0 layer0'],
                 partiallyOccludedBy: ['2 layer2'],
+                coveredBy: ['3 layer3'],
                 flags: null,
                 zOrderRelativeOf: null,
                 bounds: null,
@@ -660,6 +634,11 @@ the default for its data type.`,
             desc: 'Partially occluded by these opaque layers',
             layerValues: [{layerId: '2', nodeId: '2 layer2', name: 'layer2'}],
           },
+          {
+            key: 'Covered by',
+            desc: 'Partially or fully covered by these likely translucent layers',
+            layerValues: [{layerId: '3', nodeId: '3 layer3', name: 'layer3'}],
+          },
         ]);
         expect(uiData.curatedProperties?.calcColor).toEqual(
           '(0, 0, 0), alpha: 1',
@@ -674,15 +653,15 @@ the default for its data type.`,
       });
 
       it('draws input windows', async () => {
-        await goToEntryWithInputWindows(assertDefined(this.traceSf));
-        expect(uiData.rectsToDraw.length).toEqual(72);
-        expect(uiData.rectsToDraw[1].id).toEqual(
-          '3 Display 0 name="Built-in Screen"#3',
+        await presenter.onAppEvent(this.getPositionUpdate());
+        expect(uiData.rectsToDraw.length).toEqual(27);
+        expect(uiData.rectsToDraw[6].label).toEqual(
+          'Bounds for - com.android.car.carlauncher/com.android.car.carlauncher.CarLauncher#577',
         );
         presenter.onRectTypeButtonClicked(TraceRectType.INPUT_WINDOWS);
-        expect(uiData.rectsToDraw.length).toEqual(9);
-        expect(uiData.rectsToDraw[1].id).toEqual(
-          '76 com.android.systemui.ImageWallpaper#76',
+        expect(uiData.rectsToDraw.length).toEqual(15);
+        expect(uiData.rectsToDraw[6].label).toEqual(
+          'com.google.android.apps.maps/com.google.android.maps.LimitedMapsActivity#630',
         );
         expect(uiData.rectSpec).toEqual(this.expectedInputWindowsSpec);
         expect(uiData.allRectSpecs).toEqual([
@@ -697,7 +676,7 @@ the default for its data type.`,
         await presenter.onHighlightedNodeChange(treeForAlphaCheck);
         expect(
           uiData.propertiesTree?.getChildByName('color')?.formattedValue(),
-        ).toEqual(`${EMPTY_OBJ_STRING}, alpha: 0`);
+        ).toEqual(`${EMPTY_OBJ_STRING}, alpha: 1`);
 
         await presenter.onHighlightedNodeChange(treeForTransformCheck);
         expect(
@@ -712,9 +691,11 @@ the default for its data type.`,
       ): Promise<[Presenter, Trace<HierarchyTreeNode>]> {
         const traceVc = new TraceBuilder<HierarchyTreeNode>()
           .setType(TraceType.VIEW_CAPTURE)
-          .setEntries([await UnitTestUtils.getViewCaptureEntry()])
+          .setEntries([
+            TreeNodeUtils.makeHierarchyNode({id: 'vc id', name: 'vc node'}),
+          ])
           .setParserCustomQueryResult(CustomQueryType.VIEW_CAPTURE_METADATA, {
-            packageName: 'com.google.android.apps.nexuslauncher',
+            packageName: 'com.android.car.carlauncher',
             windowName: 'not_used',
           })
           .build();
@@ -738,16 +719,6 @@ the default for its data type.`,
         await presenter.onAppEvent(positionUpdate);
         return [presenter, traceVc];
       }
-
-      async function goToEntryWithInputWindows(
-        traceSf: Trace<HierarchyTreeNode>,
-      ) {
-        const entryWithInputWindows = assertDefined(traceSf?.getEntry(6));
-        const positionUpdate = TracePositionUpdate.fromTraceEntry(
-          entryWithInputWindows,
-        );
-        await presenter.onAppEvent(positionUpdate);
-      }
     });
   }
 }
diff --git a/tools/winscope/src/viewers/viewer_surface_flinger/viewer_surface_flinger_component_test.ts b/tools/winscope/src/viewers/viewer_surface_flinger/viewer_surface_flinger_component_test.ts
index 701fd50fc..876c8801f 100644
--- a/tools/winscope/src/viewers/viewer_surface_flinger/viewer_surface_flinger_component_test.ts
+++ b/tools/winscope/src/viewers/viewer_surface_flinger/viewer_surface_flinger_component_test.ts
@@ -13,175 +13,87 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-import {CommonModule} from '@angular/common';
-import {HttpClientModule} from '@angular/common/http';
-import {Component, CUSTOM_ELEMENTS_SCHEMA} from '@angular/core';
-import {ComponentFixture, TestBed} from '@angular/core/testing';
-import {FormsModule} from '@angular/forms';
-import {MatButtonModule} from '@angular/material/button';
-import {MatCheckboxModule} from '@angular/material/checkbox';
-import {MatDividerModule} from '@angular/material/divider';
-import {MatFormFieldModule} from '@angular/material/form-field';
-import {MatIconModule} from '@angular/material/icon';
-import {MatInputModule} from '@angular/material/input';
-import {MatSelectModule} from '@angular/material/select';
-import {MatSliderModule} from '@angular/material/slider';
-import {MatTooltipModule} from '@angular/material/tooltip';
-import {BrowserAnimationsModule} from '@angular/platform-browser/animations';
-import {UnitTestUtils} from 'test/unit/utils';
-import {CollapsedSectionsComponent} from 'viewers/components/collapsed_sections_component';
-import {CollapsibleSectionTitleComponent} from 'viewers/components/collapsible_section_title_component';
-import {HierarchyComponent} from 'viewers/components/hierarchy_component';
-import {PropertiesComponent} from 'viewers/components/properties_component';
-import {RectsComponent} from 'viewers/components/rects/rects_component';
+import {Component} from '@angular/core';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
+import {AbstractHierarchyViewerComponentTest} from 'viewers/common/abstract_hierarchy_viewer_component_test';
 import {TraceRectType} from 'viewers/components/rects/rect_spec';
 import {SurfaceFlingerPropertyGroupsComponent} from 'viewers/components/surface_flinger_property_groups_component';
 import {UiData} from './ui_data';
 import {ViewerSurfaceFlingerComponent} from './viewer_surface_flinger_component';
 
-describe('ViewerSurfaceFlingerComponent', () => {
-  let fixture: ComponentFixture<TestHostComponent>;
-  let component: TestHostComponent;
-  let htmlElement: HTMLElement;
-
-  beforeEach(async () => {
-    await TestBed.configureTestingModule({
-      declarations: [
-        TestHostComponent,
-        ViewerSurfaceFlingerComponent,
-        HierarchyComponent,
-        PropertiesComponent,
-        RectsComponent,
-        SurfaceFlingerPropertyGroupsComponent,
-        CollapsedSectionsComponent,
-        CollapsibleSectionTitleComponent,
-      ],
-      imports: [
-        CommonModule,
-        MatIconModule,
-        MatDividerModule,
-        MatCheckboxModule,
-        MatSliderModule,
-        MatFormFieldModule,
-        MatInputModule,
-        BrowserAnimationsModule,
-        FormsModule,
-        MatTooltipModule,
-        MatButtonModule,
-        MatSelectModule,
-        HttpClientModule,
-      ],
-      schemas: [CUSTOM_ELEMENTS_SCHEMA],
-    }).compileComponents();
-    fixture = TestBed.createComponent(TestHostComponent);
-    component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
-    fixture.detectChanges();
-  });
-
-  it('can be created', () => {
-    expect(component).toBeTruthy();
-  });
-
-  it('creates rects view', () => {
-    const rectsView = htmlElement.querySelector('.rects-view');
-    expect(rectsView).toBeTruthy();
-  });
-
-  it('creates hierarchy view', () => {
-    const hierarchyView = htmlElement.querySelector('.hierarchy-view');
-    expect(hierarchyView).toBeTruthy();
-  });
-
-  it('creates property groups view', () => {
-    const propertyGroups = htmlElement.querySelector('.property-groups');
-    expect(propertyGroups).toBeTruthy();
-  });
-
-  it('creates properties view', () => {
-    const propertiesView = htmlElement.querySelector('.properties-view');
-    expect(propertiesView).toBeTruthy();
-  });
-
-  it('creates collapsed sections with no buttons', () => {
-    UnitTestUtils.checkNoCollapsedSectionButtons(htmlElement);
-  });
-
-  it('handles rects section collapse/expand', () => {
-    UnitTestUtils.checkSectionCollapseAndExpand(
-      htmlElement,
-      fixture,
-      '.rects-view',
-      'LAYERS',
-    );
-  });
-
-  it('handles hierarchy section collapse/expand', () => {
-    UnitTestUtils.checkSectionCollapseAndExpand(
-      htmlElement,
-      fixture,
-      '.hierarchy-view',
-      'HIERARCHY',
-    );
-  });
-
-  it('handles property groups section collapse/expand', () => {
-    UnitTestUtils.checkSectionCollapseAndExpand(
-      htmlElement,
-      fixture,
-      '.property-groups',
-      'PROPERTIES',
-    );
-  });
-
-  it('handles properties section collapse/expand', () => {
-    UnitTestUtils.checkSectionCollapseAndExpand(
-      htmlElement,
-      fixture,
-      '.properties-view',
-      'PROTO DUMP',
-    );
-  });
-
-  it('handles rect type change', () => {
-    let uiData = new UiData(undefined);
-    uiData.rectSpec = {
-      type: TraceRectType.LAYERS,
-      icon: '',
-      legend: [],
-    };
-    component.inputData = uiData;
-    fixture.detectChanges();
-
-    UnitTestUtils.checkSectionCollapseAndExpand(
-      htmlElement,
-      fixture,
-      '.rects-view',
-      TraceRectType.LAYERS.toUpperCase(),
-    );
-
-    uiData = new UiData(undefined);
-    uiData.rectSpec = {
-      type: TraceRectType.INPUT_WINDOWS,
-      icon: '',
-      legend: [],
-    };
-    component.inputData = uiData;
-    fixture.detectChanges();
-    UnitTestUtils.checkSectionCollapseAndExpand(
-      htmlElement,
-      fixture,
-      '.rects-view',
-      TraceRectType.INPUT_WINDOWS.toUpperCase(),
-    );
-  });
+@Component({
+  selector: 'host-component',
+  template:
+    '<viewer-surface-flinger [inputData]="inputData"></viewer-surface-flinger>',
+})
+class TestHostComponent {
+  inputData: UiData | undefined;
+}
+
+class ViewerSurfaceFlingerComponentTest extends AbstractHierarchyViewerComponentTest<TestHostComponent> {
+  protected override readonly testRects = true;
+  protected override readonly hierarchyTitle = 'HIERARCHY';
+  protected override readonly propertiesTitle = 'PROTO DUMP';
+  protected override readonly rectsTitle = 'LAYERS';
+
+  protected override executeSpecializedTests() {
+    describe('Specialized tests', () => {
+      let dom: DOMTestHelper<TestHostComponent>;
+      let component: TestHostComponent;
+
+      beforeEach(async () => {
+        [dom, component] = await this.setUpTestEnvironment();
+      });
+
+      it('creates property groups view', () => {
+        expect(dom.find('.property-groups')).toBeDefined();
+      });
+
+      it('handles property groups section collapse/expand', () => {
+        dom.checkSectionCollapseAndExpand('.property-groups', 'PROPERTIES');
+      });
+
+      it('handles rect type change', () => {
+        let uiData = new UiData(undefined);
+        uiData.rectSpec = {
+          type: TraceRectType.LAYERS,
+          icon: '',
+          legend: [],
+        };
+        component.inputData = uiData;
+        dom.detectChanges();
+
+        dom.checkSectionCollapseAndExpand(
+          '.rects-view',
+          TraceRectType.LAYERS.toUpperCase(),
+        );
+
+        uiData = new UiData(undefined);
+        uiData.rectSpec = {
+          type: TraceRectType.INPUT_WINDOWS,
+          icon: '',
+          legend: [],
+        };
+        component.inputData = uiData;
+        dom.detectChanges();
+        dom.checkSectionCollapseAndExpand(
+          '.rects-view',
+          TraceRectType.INPUT_WINDOWS.toUpperCase(),
+        );
+      });
+    });
+  }
 
-  @Component({
-    selector: 'host-component',
-    template:
-      '<viewer-surface-flinger [inputData]="inputData"></viewer-surface-flinger>',
-  })
-  class TestHostComponent {
-    inputData: UiData | undefined;
+  protected async setUpTestEnvironment(): Promise<
+    [DOMTestHelper<TestHostComponent>, TestHostComponent]
+  > {
+    return this.initializeTestEnvironment(TestHostComponent, [
+      ViewerSurfaceFlingerComponent,
+      SurfaceFlingerPropertyGroupsComponent,
+    ]);
   }
+}
+
+describe('ViewerSurfaceFlingerComponent', () => {
+  new ViewerSurfaceFlingerComponentTest().execute();
 });
diff --git a/tools/winscope/src/viewers/viewer_transactions/operations/set_root_display_name.ts b/tools/winscope/src/viewers/viewer_transactions/operations/set_root_display_name.ts
deleted file mode 100644
index e7d0ab9b3..000000000
--- a/tools/winscope/src/viewers/viewer_transactions/operations/set_root_display_name.ts
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import {Operation} from 'trace/tree_node/operations/operation';
-import {UiPropertyTreeNode} from 'viewers/common/ui_property_tree_node';
-
-export class SetRootDisplayNames implements Operation<UiPropertyTreeNode> {
-  apply(node: UiPropertyTreeNode): void {
-    if (node.id.includes('layerChanges')) {
-      node.setDisplayName('LayerState');
-      return;
-    }
-
-    if (
-      node.id.includes('displayChanges') ||
-      node.id.includes('addedDisplays')
-    ) {
-      node.setDisplayName('DisplayState');
-      return;
-    }
-
-    if (node.id.includes('addedLayers')) {
-      node.setDisplayName('LayerCreationArgs');
-      return;
-    }
-
-    if (node.id.includes('destroyedLayers')) {
-      node.setDisplayName('destroyedLayerId');
-      return;
-    }
-
-    if (node.id.includes('removedDisplays')) {
-      node.setDisplayName('removedDisplayId');
-      return;
-    }
-
-    if (node.id.includes('destroyedLayerHandles')) {
-      node.setDisplayName('destroyedLayerHandleId');
-      return;
-    }
-  }
-}
diff --git a/tools/winscope/src/viewers/viewer_transactions/operations/set_root_display_name_test.ts b/tools/winscope/src/viewers/viewer_transactions/operations/set_root_display_name_test.ts
deleted file mode 100644
index 4b20f9a5f..000000000
--- a/tools/winscope/src/viewers/viewer_transactions/operations/set_root_display_name_test.ts
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
-import {UiPropertyTreeNode} from 'viewers/common/ui_property_tree_node';
-import {SetRootDisplayNames} from './set_root_display_name';
-
-describe('SetRootDisplayNames', () => {
-  let operation: SetRootDisplayNames;
-
-  beforeEach(() => {
-    operation = new SetRootDisplayNames();
-  });
-
-  it('sets display name LayerState', () => {
-    const propertyRoot = UiPropertyTreeNode.from(
-      new PropertyTreeBuilder().setRootId('layerChanges').setName('0').build(),
-    );
-
-    operation.apply(propertyRoot);
-    expect(propertyRoot.getDisplayName()).toEqual('LayerState');
-  });
-
-  it('sets display name DisplayState for change in display', () => {
-    const propertyRoot = UiPropertyTreeNode.from(
-      new PropertyTreeBuilder()
-        .setRootId('displayChanges')
-        .setName('0')
-        .build(),
-    );
-
-    operation.apply(propertyRoot);
-    expect(propertyRoot.getDisplayName()).toEqual('DisplayState');
-  });
-
-  it('sets display name DisplayState for added display', () => {
-    const propertyRoot = UiPropertyTreeNode.from(
-      new PropertyTreeBuilder().setRootId('addedDisplays').setName('0').build(),
-    );
-
-    operation.apply(propertyRoot);
-    expect(propertyRoot.getDisplayName()).toEqual('DisplayState');
-  });
-
-  it('sets display name LayerCreationArgs', () => {
-    const propertyRoot = UiPropertyTreeNode.from(
-      new PropertyTreeBuilder().setRootId('addedLayers').setName('0').build(),
-    );
-
-    operation.apply(propertyRoot);
-    expect(propertyRoot.getDisplayName()).toEqual('LayerCreationArgs');
-  });
-
-  it('sets display name destroyedLayerId', () => {
-    const propertyRoot = UiPropertyTreeNode.from(
-      new PropertyTreeBuilder()
-        .setRootId('destroyedLayers')
-        .setName('0')
-        .build(),
-    );
-
-    operation.apply(propertyRoot);
-    expect(propertyRoot.getDisplayName()).toEqual('destroyedLayerId');
-  });
-
-  it('sets display name removedDisplayId', () => {
-    const propertyRoot = UiPropertyTreeNode.from(
-      new PropertyTreeBuilder()
-        .setRootId('removedDisplays')
-        .setName('0')
-        .build(),
-    );
-
-    operation.apply(propertyRoot);
-    expect(propertyRoot.getDisplayName()).toEqual('removedDisplayId');
-  });
-
-  it('sets display name destroyedLayerHandleId', () => {
-    const propertyRoot = UiPropertyTreeNode.from(
-      new PropertyTreeBuilder()
-        .setRootId('destroyedLayerHandles')
-        .setName('0')
-        .build(),
-    );
-
-    operation.apply(propertyRoot);
-    expect(propertyRoot.getDisplayName()).toEqual('destroyedLayerHandleId');
-  });
-});
diff --git a/tools/winscope/src/viewers/viewer_transactions/presenter.ts b/tools/winscope/src/viewers/viewer_transactions/presenter.ts
index 3a9dba010..d042f80cb 100644
--- a/tools/winscope/src/viewers/viewer_transactions/presenter.ts
+++ b/tools/winscope/src/viewers/viewer_transactions/presenter.ts
@@ -18,6 +18,10 @@ import {assertDefined} from 'common/assert_utils';
 import {PersistentStoreProxy} from 'common/store/persistent_store_proxy';
 import {Store} from 'common/store/store';
 import {Trace} from 'trace/trace';
+import {TransactionColumnType} from 'trace/transactions/transaction_column_type';
+import {TransactionType} from 'trace/transactions/transaction_type';
+import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
+import {LazyPropertiesStrategyType} from 'trace/tree_node/properties_provider';
 import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 import {
   AbstractLogViewerPresenter,
@@ -29,24 +33,53 @@ import {PropertiesPresenter} from 'viewers/common/properties_presenter';
 import {TextFilter} from 'viewers/common/text_filter';
 import {LogField, LogHeader} from 'viewers/common/ui_data_log';
 import {UserOptions} from 'viewers/common/user_options';
-import {SetRootDisplayNames} from './operations/set_root_display_name';
-import {TransactionsEntry, TransactionsEntryType, UiData} from './ui_data';
+import {TransactionsEntry, UiData} from './ui_data';
 
 export class Presenter extends AbstractLogViewerPresenter<
   UiData,
-  PropertyTreeNode
+  HierarchyTreeNode
 > {
   private static readonly COLUMNS = {
-    id: {name: 'TX ID', cssClass: 'transaction-id right-align'},
-    vsyncId: {name: 'VSYNC ID', cssClass: 'vsyncid right-align'},
-    pid: {name: 'PID', cssClass: 'pid right-align'},
-    uid: {name: 'UID', cssClass: 'uid right-align'},
-    type: {name: 'TYPE', cssClass: 'transaction-type'},
+    id: {
+      name: 'TX ID',
+      cssClass: 'transaction-id right-align',
+      columnType: TransactionColumnType.TRANSACTION_ID,
+    },
+    vsyncId: {
+      name: 'VSYNC ID',
+      cssClass: 'vsyncid right-align',
+      columnType: TransactionColumnType.VSYNC_ID,
+    },
+    pid: {
+      name: 'PID',
+      cssClass: 'pid right-align',
+      columnType: TransactionColumnType.PID,
+    },
+    uid: {
+      name: 'UID',
+      cssClass: 'uid right-align',
+      columnType: TransactionColumnType.UID,
+    },
+    process: {
+      name: 'PROCESS',
+      cssClass: 'process',
+      columnType: TransactionColumnType.PROCESS,
+    },
+    type: {
+      name: 'TYPE',
+      cssClass: 'transaction-type',
+      columnType: TransactionColumnType.TRANSACTION_TYPE,
+    },
     layerOrDisplayId: {
       name: 'LAYER/DISP ID',
       cssClass: 'layer-or-display-id right-align',
+      columnType: TransactionColumnType.LAYER_OR_DISPLAY_ID,
+    },
+    flags: {
+      name: 'Flags',
+      cssClass: 'flags',
+      columnType: TransactionColumnType.FLAGS,
     },
-    flags: {name: 'Flags', cssClass: 'flags'},
   };
 
   protected override keepCalculated = true;
@@ -69,11 +102,10 @@ export class Presenter extends AbstractLogViewerPresenter<
     ),
     new TextFilter(),
     [],
-    [new SetRootDisplayNames()],
   );
 
   constructor(
-    trace: Trace<PropertyTreeNode>,
+    trace: Trace<HierarchyTreeNode>,
     readonly storage: Store,
     notifyViewCallback: NotifyLogViewCallbackType<UiData>,
   ) {
@@ -92,6 +124,7 @@ export class Presenter extends AbstractLogViewerPresenter<
       ),
       new LogHeader(Presenter.COLUMNS.pid, new LogSelectFilter([])),
       new LogHeader(Presenter.COLUMNS.uid, new LogSelectFilter([])),
+      new LogHeader(Presenter.COLUMNS.process, new LogSelectFilter([])),
       new LogHeader(
         Presenter.COLUMNS.type,
         new LogSelectFilter([], false, '175'),
@@ -148,288 +181,91 @@ export class Presenter extends AbstractLogViewerPresenter<
     ) {
       const entry = this.trace.getEntry(traceIndex);
       const entryNode = entryProtos[traceIndex];
-      const vsyncId = Number(
-        assertDefined(entryNode.getChildByName('vsyncId')).getValue(),
-      );
+      const vsyncId = entryNode.getEagerPropertyByName('vsyncId')?.getValue();
 
-      for (const transactionState of assertDefined(
-        entryNode.getChildByName('transactions'),
-      ).getAllChildren()) {
-        const transactionId = assertDefined(
-          transactionState.getChildByName('transactionId'),
-        ).formattedValue();
-        const pid = assertDefined(
-          transactionState.getChildByName('pid'),
+      for (const transactionNode of entryNode.getAllChildren()) {
+        const transactionType = assertDefined(
+          transactionNode.getEagerPropertyByName('transactionType'),
         ).formattedValue();
-        const uid = assertDefined(
-          transactionState.getChildByName('uid'),
-        ).formattedValue();
-        const layerChanges = assertDefined(
-          transactionState.getChildByName('layerChanges'),
-        ).getAllChildren();
-
-        for (const layerState of layerChanges) {
-          const fields: LogField[] = [
-            {spec: Presenter.COLUMNS.id, value: transactionId},
-            {spec: Presenter.COLUMNS.vsyncId, value: vsyncId},
-            {spec: Presenter.COLUMNS.pid, value: pid},
-            {spec: Presenter.COLUMNS.uid, value: uid},
-            {
-              spec: Presenter.COLUMNS.type,
-              value: TransactionsEntryType.LAYER_CHANGED,
-            },
-            {
-              spec: Presenter.COLUMNS.layerOrDisplayId,
-              value: assertDefined(
-                layerState.getChildByName('layerId'),
-              ).formattedValue(),
-            },
-            {
-              spec: Presenter.COLUMNS.flags,
-              value: assertDefined(
-                layerState.getChildByName('what'),
-              ).formattedValue(),
-            },
-          ];
-          entries.push(new TransactionsEntry(entry, fields, layerState));
-        }
+        const transactionId = transactionNode
+          .getEagerPropertyByName('transactionId')
+          ?.formattedValue();
+        const pid = transactionNode
+          .getEagerPropertyByName('pid')
+          ?.formattedValue();
+        const uid = transactionNode
+          .getEagerPropertyByName('uid')
+          ?.formattedValue();
+        const process = transactionNode
+          .getEagerPropertyByName('processName')
+          ?.formattedValue();
+        const layerId = transactionNode
+          .getEagerPropertyByName('layerId')
+          ?.formattedValue();
+        const displayId = transactionNode
+          .getEagerPropertyByName('displayId')
+          ?.formattedValue();
+        const flags = transactionNode
+          .getEagerPropertyByName('flagsId')
+          ?.formattedValue();
 
-        const displayChanges = assertDefined(
-          transactionState.getChildByName('displayChanges'),
-        ).getAllChildren();
-        for (const displayState of displayChanges) {
-          const fields: LogField[] = [
-            {spec: Presenter.COLUMNS.id, value: transactionId},
-            {spec: Presenter.COLUMNS.vsyncId, value: vsyncId},
-            {spec: Presenter.COLUMNS.pid, value: pid},
-            {spec: Presenter.COLUMNS.uid, value: uid},
-            {
-              spec: Presenter.COLUMNS.type,
-              value: TransactionsEntryType.DISPLAY_CHANGED,
-            },
-            {
-              spec: Presenter.COLUMNS.layerOrDisplayId,
-              value: assertDefined(
-                displayState.getChildByName('id'),
-              ).formattedValue(),
-            },
-            {
-              spec: Presenter.COLUMNS.flags,
-              value: assertDefined(
-                displayState.getChildByName('what'),
-              ).formattedValue(),
-            },
-          ];
-          entries.push(new TransactionsEntry(entry, fields, displayState));
-        }
+        let getPropertiesTree: LazyPropertiesStrategyType | undefined;
+        switch (transactionType) {
+          case TransactionType.LAYER_CHANGED:
+          case TransactionType.DISPLAY_CHANGED:
+          case TransactionType.LAYER_ADDED:
+          case TransactionType.DISPLAY_ADDED:
+            getPropertiesTree = async () => {
+              return await transactionNode.getAllProperties();
+            };
+            break;
 
-        if (layerChanges.length === 0 && displayChanges.length === 0) {
-          const fields: LogField[] = [
-            {spec: Presenter.COLUMNS.id, value: transactionId},
-            {spec: Presenter.COLUMNS.vsyncId, value: vsyncId},
-            {spec: Presenter.COLUMNS.pid, value: pid},
-            {spec: Presenter.COLUMNS.uid, value: uid},
-            {
-              spec: Presenter.COLUMNS.type,
-              value: TransactionsEntryType.NO_OP,
-            },
-            {spec: Presenter.COLUMNS.layerOrDisplayId, value: ''},
-            {spec: Presenter.COLUMNS.flags, value: ''},
-          ];
-          entries.push(new TransactionsEntry(entry, fields, undefined));
+          default:
+            // do nothing
+            break;
         }
-      }
 
-      for (const layerCreationArgs of assertDefined(
-        entryNode.getChildByName('addedLayers'),
-      ).getAllChildren()) {
-        const fields: LogField[] = [
-          {spec: Presenter.COLUMNS.id, value: ''},
-          {spec: Presenter.COLUMNS.vsyncId, value: vsyncId},
-          {spec: Presenter.COLUMNS.pid, value: Presenter.VALUE_NA},
-          {spec: Presenter.COLUMNS.uid, value: Presenter.VALUE_NA},
-          {
-            spec: Presenter.COLUMNS.type,
-            value: TransactionsEntryType.LAYER_ADDED,
-          },
-          {
-            spec: Presenter.COLUMNS.layerOrDisplayId,
-            value: assertDefined(
-              layerCreationArgs.getChildByName('layerId'),
-            ).formattedValue(),
-          },
-          {spec: Presenter.COLUMNS.flags, value: ''},
-        ];
-        entries.push(new TransactionsEntry(entry, fields, layerCreationArgs));
-      }
+        const layerOrDisplayId =
+          (layerId?.length ?? 0) > 0
+            ? assertDefined(layerId)
+            : displayId ?? Presenter.VALUE_NA;
 
-      for (const destroyedLayerId of assertDefined(
-        entryNode.getChildByName('destroyedLayers'),
-      ).getAllChildren()) {
         const fields: LogField[] = [
-          {spec: Presenter.COLUMNS.id, value: ''},
-          {spec: Presenter.COLUMNS.vsyncId, value: vsyncId},
-          {spec: Presenter.COLUMNS.pid, value: Presenter.VALUE_NA},
-          {spec: Presenter.COLUMNS.uid, value: Presenter.VALUE_NA},
           {
-            spec: Presenter.COLUMNS.type,
-            value: TransactionsEntryType.LAYER_DESTROYED,
+            spec: Presenter.COLUMNS.id,
+            value: transactionId ?? Presenter.VALUE_NA,
           },
+          {spec: Presenter.COLUMNS.vsyncId, value: assertDefined(vsyncId)},
+          {spec: Presenter.COLUMNS.pid, value: pid ?? Presenter.VALUE_NA},
+          {spec: Presenter.COLUMNS.uid, value: uid ?? Presenter.VALUE_NA},
           {
-            spec: Presenter.COLUMNS.layerOrDisplayId,
-            value: destroyedLayerId.formattedValue(),
+            spec: Presenter.COLUMNS.process,
+            value: process ?? Presenter.VALUE_NA,
           },
-          {spec: Presenter.COLUMNS.flags, value: ''},
-        ];
-        entries.push(new TransactionsEntry(entry, fields, destroyedLayerId));
-      }
-
-      for (const displayState of assertDefined(
-        entryNode.getChildByName('addedDisplays'),
-      ).getAllChildren()) {
-        const fields: LogField[] = [
-          {spec: Presenter.COLUMNS.id, value: ''},
-          {spec: Presenter.COLUMNS.vsyncId, value: vsyncId},
-          {spec: Presenter.COLUMNS.pid, value: Presenter.VALUE_NA},
-          {spec: Presenter.COLUMNS.uid, value: Presenter.VALUE_NA},
           {
             spec: Presenter.COLUMNS.type,
-            value: TransactionsEntryType.DISPLAY_ADDED,
+            value: transactionType,
           },
           {
             spec: Presenter.COLUMNS.layerOrDisplayId,
-            value: assertDefined(
-              displayState.getChildByName('id'),
-            ).formattedValue(),
+            value: layerOrDisplayId,
           },
           {
             spec: Presenter.COLUMNS.flags,
-            value: assertDefined(
-              displayState.getChildByName('what'),
-            ).formattedValue(),
+            value: flags ?? Presenter.VALUE_NA,
           },
         ];
-        entries.push(new TransactionsEntry(entry, fields, displayState));
-      }
-
-      for (const removedDisplayId of assertDefined(
-        entryNode.getChildByName('removedDisplays'),
-      ).getAllChildren()) {
-        const fields: LogField[] = [
-          {spec: Presenter.COLUMNS.id, value: ''},
-          {spec: Presenter.COLUMNS.vsyncId, value: vsyncId},
-          {spec: Presenter.COLUMNS.pid, value: Presenter.VALUE_NA},
-          {spec: Presenter.COLUMNS.uid, value: Presenter.VALUE_NA},
-          {
-            spec: Presenter.COLUMNS.type,
-            value: TransactionsEntryType.DISPLAY_REMOVED,
-          },
-          {
-            spec: Presenter.COLUMNS.layerOrDisplayId,
-            value: removedDisplayId.formattedValue(),
-          },
-          {spec: Presenter.COLUMNS.flags, value: ''},
-        ];
-        entries.push(new TransactionsEntry(entry, fields, removedDisplayId));
-      }
-
-      for (const destroyedLayerHandleId of assertDefined(
-        entryNode.getChildByName('destroyedLayerHandles'),
-      ).getAllChildren()) {
-        const fields: LogField[] = [
-          {spec: Presenter.COLUMNS.id, value: ''},
-          {spec: Presenter.COLUMNS.vsyncId, value: vsyncId},
-          {spec: Presenter.COLUMNS.pid, value: Presenter.VALUE_NA},
-          {spec: Presenter.COLUMNS.uid, value: Presenter.VALUE_NA},
-          {
-            spec: Presenter.COLUMNS.type,
-            value: TransactionsEntryType.LAYER_HANDLE_DESTROYED,
-          },
-          {
-            spec: Presenter.COLUMNS.layerOrDisplayId,
-            value: destroyedLayerHandleId.formattedValue(),
-          },
-          {spec: Presenter.COLUMNS.flags, value: ''},
-        ];
-        entries.push(
-          new TransactionsEntry(entry, fields, destroyedLayerHandleId),
-        );
+        entries.push(new TransactionsEntry(entry, fields, getPropertiesTree));
       }
     }
-
     return entries;
   }
 
-  protected override updateFiltersInHeaders(
-    headers: LogHeader[],
-    allEntries: TransactionsEntry[],
-  ) {
+  protected override async updateFiltersInHeaders(headers: LogHeader[]) {
     for (const header of headers) {
-      if (header.spec === Presenter.COLUMNS.flags) {
-        (assertDefined(header.filter) as LogSelectFilter).options =
-          this.getUniqueUiDataEntryValues(
-            allEntries,
-            (entry: TransactionsEntry) =>
-              assertDefined(
-                entry.fields.find((f) => f.spec === header.spec)
-                  ?.value as string,
-              )
-                .split('|')
-                .map((flag) => flag.trim()),
-          );
-      } else {
-        (assertDefined(header.filter) as LogSelectFilter).options =
-          this.getUniqueUiDataEntryValues(
-            allEntries,
-            (entry: TransactionsEntry) =>
-              assertDefined(
-                entry.fields.find((f) => f.spec === header.spec),
-              ).value.toString(),
-          );
-      }
+      this.updateFilterByCustomQuery(header);
     }
   }
-
-  private getUniqueUiDataEntryValues<T>(
-    entries: TransactionsEntry[],
-    getValue: (entry: TransactionsEntry) => T | T[],
-  ): T[] {
-    const uniqueValues = new Set<T>();
-    entries.forEach((entry: TransactionsEntry) => {
-      const value = getValue(entry);
-      if (Array.isArray(value)) {
-        value.forEach((val) => uniqueValues.add(val));
-      } else {
-        uniqueValues.add(value);
-      }
-    });
-
-    const result = [...uniqueValues];
-
-    result.sort((a, b) => {
-      const aIsNumber = !isNaN(Number(a));
-      const bIsNumber = !isNaN(Number(b));
-
-      if (aIsNumber && bIsNumber) {
-        return Number(a) - Number(b);
-      } else if (aIsNumber) {
-        return 1; // place number after strings in the result
-      } else if (bIsNumber) {
-        return -1; // place number after strings in the result
-      }
-
-      // a and b are both strings
-      if (a < b) {
-        return -1;
-      } else if (a > b) {
-        return 1;
-      } else {
-        return 0;
-      }
-    });
-
-    return result;
-  }
 }
 
 const layerChangeFlagToPropertiesMap = new Map([
diff --git a/tools/winscope/src/viewers/viewer_transactions/presenter_test.ts b/tools/winscope/src/viewers/viewer_transactions/presenter_test.ts
index 9f4d21c1e..ed8a0ad1c 100644
--- a/tools/winscope/src/viewers/viewer_transactions/presenter_test.ts
+++ b/tools/winscope/src/viewers/viewer_transactions/presenter_test.ts
@@ -18,12 +18,14 @@ import {assertDefined} from 'common/assert_utils';
 import {InMemoryStorage} from 'common/store/in_memory_storage';
 import {TimeUtils} from 'common/time/time_utils';
 import {TracePositionUpdate} from 'messaging/winscope_event';
+import {LegacyParserProvider} from 'test/unit/fixture_utils';
 import {TraceBuilder} from 'test/unit/trace_builder';
-import {UnitTestUtils} from 'test/unit/utils';
-import {Parser} from 'trace/parser';
+import {makeEmptyTrace} from 'test/unit/trace_utils';
+import {CustomQueryType} from 'trace/custom_query';
 import {Trace} from 'trace/trace';
 import {TraceType} from 'trace/trace_type';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
+import {TransactionColumnType} from 'trace/transactions/transaction_column_type';
+import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 import {NotifyLogViewCallbackType} from 'viewers/common/abstract_log_viewer_presenter';
 import {AbstractLogViewerPresenterTest} from 'viewers/common/abstract_log_viewer_presenter_test';
 import {LogSelectFilter} from 'viewers/common/log_filters';
@@ -35,33 +37,64 @@ class PresenterTransactionsTest extends AbstractLogViewerPresenterTest<UiData> {
   override readonly expectedHeaders = [
     {
       header: new LogHeader(
-        {name: 'TX ID', cssClass: 'transaction-id right-align'},
+        {
+          name: 'TX ID',
+          cssClass: 'transaction-id right-align',
+          columnType: TransactionColumnType.TRANSACTION_ID,
+        },
         new LogSelectFilter(Array.from({length: 1295}, () => '')),
       ),
     },
     {
       header: new LogHeader(
-        {name: 'VSYNC ID', cssClass: 'vsyncid right-align'},
-        new LogSelectFilter(Array.from({length: 710}, () => '')),
+        {
+          name: 'VSYNC ID',
+          cssClass: 'vsyncid right-align',
+          columnType: TransactionColumnType.VSYNC_ID,
+        },
+        new LogSelectFilter(Array.from({length: 712}, () => '')),
       ),
     },
     {
       header: new LogHeader(
-        {name: 'PID', cssClass: 'pid right-align'},
+        {
+          name: 'PID',
+          cssClass: 'pid right-align',
+          columnType: TransactionColumnType.PID,
+        },
         new LogSelectFilter(Array.from({length: 8}, () => '')),
       ),
       options: ['N/A', '0', '515', '1593', '2022', '2322', '2463', '3300'],
     },
     {
       header: new LogHeader(
-        {name: 'UID', cssClass: 'uid right-align'},
+        {
+          name: 'UID',
+          cssClass: 'uid right-align',
+          columnType: TransactionColumnType.UID,
+        },
         new LogSelectFilter(Array.from({length: 6}, () => '')),
       ),
       options: ['N/A', '1000', '1003', '10169', '10235', '10239'],
     },
     {
       header: new LogHeader(
-        {name: 'TYPE', cssClass: 'transaction-type'},
+        {
+          name: 'PROCESS',
+          cssClass: 'process',
+          columnType: TransactionColumnType.PROCESS,
+        },
+        new LogSelectFilter(['']),
+      ),
+      options: ['N/A'],
+    },
+    {
+      header: new LogHeader(
+        {
+          name: 'TYPE',
+          cssClass: 'transaction-type',
+          columnType: TransactionColumnType.TRANSACTION_TYPE,
+        },
         new LogSelectFilter(Array.from({length: 6}, () => '')),
       ),
       options: [
@@ -70,28 +103,72 @@ class PresenterTransactionsTest extends AbstractLogViewerPresenterTest<UiData> {
         'LAYER_CHANGED',
         'LAYER_DESTROYED',
         'LAYER_HANDLE_DESTROYED',
-        'NO_OP',
+        'NOOP',
       ],
     },
     {
       header: new LogHeader(
-        {name: 'LAYER/DISP ID', cssClass: 'layer-or-display-id right-align'},
-        new LogSelectFilter(Array.from({length: 117}, () => '')),
+        {
+          name: 'LAYER/DISP ID',
+          cssClass: 'layer-or-display-id right-align',
+          columnType: TransactionColumnType.LAYER_OR_DISPLAY_ID,
+        },
+        new LogSelectFilter(Array.from({length: 116}, () => '')),
       ),
+      options: [
+        'N/A',
+        ...Array.from({length: 114}, (_, i) => `${i + 1}`),
+        '4294967295',
+      ],
     },
     {
       header: new LogHeader(
-        {name: 'Flags', cssClass: 'flags'},
+        {
+          name: 'Flags',
+          cssClass: 'flags',
+          columnType: TransactionColumnType.FLAGS,
+        },
         new LogSelectFilter(
-          Array.from({length: 30}, () => ''),
+          Array.from({length: 29}, () => ''),
           true,
           '250',
           '100%',
         ),
       ),
+      options: [
+        'eAcquireFenceChanged',
+        'eAlphaChanged',
+        'eAutoRefreshChanged',
+        'eBackgroundBlurRadiusChanged',
+        'eBufferChanged',
+        'eBufferCropChanged',
+        'eBufferTransformChanged',
+        'eColorChanged',
+        'eColorSpaceAgnosticChanged',
+        'eCornerRadiusChanged',
+        'eCropChanged',
+        'eDataspaceChanged',
+        'eDestinationFrameChanged',
+        'eDisplayProjectionChanged',
+        'eFlagsChanged',
+        'eFrameRateSelectionPriority',
+        'eHasListenerCallbacksChanged',
+        'eHdrMetadataChanged',
+        'eInputInfoChanged',
+        'eLayerChanged',
+        'eLayerStackChanged',
+        'eMatrixChanged',
+        'eMetadataChanged',
+        'ePositionChanged',
+        'eProducerDisconnect',
+        'eRelativeLayerChanged',
+        'eReparent',
+        'eSurfaceDamageRegionChanged',
+        'eTransformToDisplayInverseChanged',
+      ],
     },
   ];
-  private trace: Trace<PropertyTreeNode> | undefined;
+  private trace: Trace<HierarchyTreeNode> | undefined;
   private positionUpdate: TracePositionUpdate | undefined;
 
   override executeSpecializedTests() {
@@ -115,7 +192,7 @@ class PresenterTransactionsTest extends AbstractLogViewerPresenterTest<UiData> {
         await presenter.onLogEntryClick(10);
         expect(
           assertDefined(uiData.propertiesTree).getAllChildren().length,
-        ).toEqual(8);
+        ).toEqual(10);
         expect(
           uiData.propertiesTree?.getChildByName('transformToDisplayInverse'),
         ).toBeDefined();
@@ -159,10 +236,11 @@ class PresenterTransactionsTest extends AbstractLogViewerPresenterTest<UiData> {
   }
 
   override async setUpTestEnvironment(): Promise<void> {
-    const parser = (await UnitTestUtils.getParser(
-      'traces/elapsed_and_real_timestamp/Transactions.pb',
-    )) as Parser<PropertyTreeNode>;
-    this.trace = new TraceBuilder<PropertyTreeNode>()
+    const parser = await new LegacyParserProvider()
+      .addFilename('traces/elapsed_and_real_timestamp/Transactions.pb')
+      .setConvertToPerfetto(true)
+      .getParser<HierarchyTreeNode>();
+    this.trace = new TraceBuilder<HierarchyTreeNode>()
       .setType(TraceType.TRANSACTIONS)
       .setParser(parser)
       .build();
@@ -174,7 +252,16 @@ class PresenterTransactionsTest extends AbstractLogViewerPresenterTest<UiData> {
   override async createPresenterWithEmptyTrace(
     callback: NotifyLogViewCallbackType<UiData>,
   ): Promise<Presenter> {
-    const trace = UnitTestUtils.makeEmptyTrace(TraceType.TRANSACTIONS);
+    const trace = makeEmptyTrace(
+      TraceType.TRANSACTIONS,
+      [],
+      [
+        {
+          queryType: CustomQueryType.LOG_TABLE_FILTER_VALUES,
+          result: [],
+        },
+      ],
+    );
     return new Presenter(trace, new InMemoryStorage(), callback);
   }
 
diff --git a/tools/winscope/src/viewers/viewer_transactions/scroll_strategy/transactions_scroll_directive.ts b/tools/winscope/src/viewers/viewer_transactions/scroll_strategy/transactions_scroll_directive.ts
deleted file mode 100644
index b380297e4..000000000
--- a/tools/winscope/src/viewers/viewer_transactions/scroll_strategy/transactions_scroll_directive.ts
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2023 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import {VIRTUAL_SCROLL_STRATEGY} from '@angular/cdk/scrolling';
-import {Directive, forwardRef} from '@angular/core';
-import {VariableHeightScrollDirective} from 'viewers/common/variable_height_scroll_directive';
-import {TransactionsEntry} from 'viewers/viewer_transactions/ui_data';
-import {TransactionsScrollStrategy} from './transactions_scroll_strategy';
-
-@Directive({
-  selector: '[transactionsVirtualScroll]',
-  providers: [
-    {
-      provide: VIRTUAL_SCROLL_STRATEGY,
-      useFactory: (dir: TransactionsScrollDirective) => dir.scrollStrategy,
-      deps: [forwardRef(() => TransactionsScrollDirective)],
-    },
-  ],
-})
-export class TransactionsScrollDirective extends VariableHeightScrollDirective<TransactionsEntry> {
-  scrollStrategy = new TransactionsScrollStrategy();
-}
diff --git a/tools/winscope/src/viewers/viewer_transactions/scroll_strategy/transactions_scroll_strategy.ts b/tools/winscope/src/viewers/viewer_transactions/transactions_height_predictor.ts
similarity index 57%
rename from tools/winscope/src/viewers/viewer_transactions/scroll_strategy/transactions_scroll_strategy.ts
rename to tools/winscope/src/viewers/viewer_transactions/transactions_height_predictor.ts
index 00a152e53..ba2b8e36d 100644
--- a/tools/winscope/src/viewers/viewer_transactions/scroll_strategy/transactions_scroll_strategy.ts
+++ b/tools/winscope/src/viewers/viewer_transactions/transactions_height_predictor.ts
@@ -14,19 +14,24 @@
  * limitations under the License.
  */
 
-import {VariableHeightScrollStrategy} from 'viewers/common/variable_height_scroll_strategy';
+import {assertString} from 'common/assert_utils';
+import {TransactionColumnType} from 'trace/transactions/transaction_column_type';
+import {ItemHeightPredictor} from 'viewers/common/item_height_predictor';
 import {TransactionsEntry} from 'viewers/viewer_transactions/ui_data';
 
-export class TransactionsScrollStrategy extends VariableHeightScrollStrategy {
-  protected readonly defaultRowSize = 24;
-  private readonly flagCharsPerRow = 40;
+export class TransactionsHeightPredictor extends ItemHeightPredictor {
+  protected override readonly defaultRowSize = 24;
   private readonly timestampCharsPerRow = 20;
 
-  protected override predictScrollItemHeight(entry: TransactionsEntry): number {
-    const flagsHeight = this.subItemHeight(
-      entry.fields[6].value as string,
-      this.flagCharsPerRow,
+  override predictHeight(entry: TransactionsEntry): number {
+    const flags = assertString(
+      entry.fields.find(
+        (f) => f.spec.columnType === TransactionColumnType.FLAGS,
+      )?.value,
     );
+    const flagsHeight =
+      Math.max(1, Math.ceil(flags.match(/\|/g)?.length ?? 1) / 2) *
+      this.defaultRowSize; // we assume there are on average 2 flags listed per row
     const timestampHeight = this.subItemHeight(
       entry.traceEntry.getTimestamp().format(),
       this.timestampCharsPerRow,
diff --git a/tools/winscope/src/viewers/viewer_transactions/ui_data.ts b/tools/winscope/src/viewers/viewer_transactions/ui_data.ts
index f5bfe1aaf..2646cde47 100644
--- a/tools/winscope/src/viewers/viewer_transactions/ui_data.ts
+++ b/tools/winscope/src/viewers/viewer_transactions/ui_data.ts
@@ -15,7 +15,8 @@
  */
 
 import {TraceEntry} from 'trace/trace';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
+import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
+import {LazyPropertiesStrategyType} from 'trace/tree_node/properties_provider';
 import {
   LogEntry,
   LogField,
@@ -45,19 +46,8 @@ export class UiData implements UiDataLog {
 
 export class TransactionsEntry implements LogEntry {
   constructor(
-    public traceEntry: TraceEntry<PropertyTreeNode>,
+    public traceEntry: TraceEntry<HierarchyTreeNode>,
     public fields: LogField[],
-    public propertiesTree: PropertyTreeNode | undefined,
+    public getPropertiesTree: LazyPropertiesStrategyType | undefined,
   ) {}
 }
-
-export enum TransactionsEntryType {
-  DISPLAY_ADDED = 'DISPLAY_ADDED',
-  DISPLAY_REMOVED = 'DISPLAY_REMOVED',
-  DISPLAY_CHANGED = 'DISPLAY_CHANGED',
-  LAYER_ADDED = 'LAYER_ADDED',
-  LAYER_DESTROYED = 'LAYER_DESTROYED',
-  LAYER_CHANGED = 'LAYER_CHANGED',
-  LAYER_HANDLE_DESTROYED = 'LAYER_HANDLE_DESTROYED',
-  NO_OP = 'NO_OP',
-}
diff --git a/tools/winscope/src/viewers/viewer_transactions/viewer_transactions.ts b/tools/winscope/src/viewers/viewer_transactions/viewer_transactions.ts
index ce1f62e42..ed0244c17 100644
--- a/tools/winscope/src/viewers/viewer_transactions/viewer_transactions.ts
+++ b/tools/winscope/src/viewers/viewer_transactions/viewer_transactions.ts
@@ -18,21 +18,21 @@ import {Store} from 'common/store/store';
 import {Trace} from 'trace/trace';
 import {Traces} from 'trace/traces';
 import {TraceType} from 'trace/trace_type';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
+import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 import {AbstractViewer} from 'viewers/abstract_viewer';
 import {ViewerComponent} from 'viewers/components/viewer_component';
 import {Presenter} from './presenter';
 import {UiData} from './ui_data';
 
-export class ViewerTransactions extends AbstractViewer<PropertyTreeNode> {
+export class ViewerTransactions extends AbstractViewer<HierarchyTreeNode> {
   static readonly DEPENDENCIES: TraceType[] = [TraceType.TRANSACTIONS];
 
-  constructor(trace: Trace<PropertyTreeNode>, traces: Traces, store: Store) {
+  constructor(trace: Trace<HierarchyTreeNode>, traces: Traces, store: Store) {
     super(trace, traces, 'viewer-transactions', store);
   }
 
   protected override initializePresenter(
-    trace: Trace<PropertyTreeNode>,
+    trace: Trace<HierarchyTreeNode>,
     traces: Traces,
     store: Store,
   ): Presenter {
diff --git a/tools/winscope/src/viewers/viewer_transactions/viewer_transactions_component.ts b/tools/winscope/src/viewers/viewer_transactions/viewer_transactions_component.ts
index d1b75fb34..864ed53ad 100644
--- a/tools/winscope/src/viewers/viewer_transactions/viewer_transactions_component.ts
+++ b/tools/winscope/src/viewers/viewer_transactions/viewer_transactions_component.ts
@@ -51,7 +51,7 @@ import {UiData} from './ui_data';
         [traceType]="${TraceType.TRANSACTIONS}"
         [isProtoDump]="false"
         [textFilter]="inputData?.propertiesFilter"
-        placeholderText="No current or selected transaction."
+        placeholderText="No current or selected transaction with additional properties."
         (collapseButtonClicked)="sections.onCollapseStateChange(CollapsibleSectionType.PROPERTIES, true)"
         [class.collapsed]="sections.isSectionCollapsed(CollapsibleSectionType.PROPERTIES)"></properties-view>
     </div>
diff --git a/tools/winscope/src/viewers/viewer_transactions/viewer_transactions_component_test.ts b/tools/winscope/src/viewers/viewer_transactions/viewer_transactions_component_test.ts
index 91e457cc8..5a5371df8 100644
--- a/tools/winscope/src/viewers/viewer_transactions/viewer_transactions_component_test.ts
+++ b/tools/winscope/src/viewers/viewer_transactions/viewer_transactions_component_test.ts
@@ -14,250 +14,147 @@
  * limitations under the License.
  */
 
-import {ClipboardModule} from '@angular/cdk/clipboard';
-import {
-  CdkVirtualScrollViewport,
-  ScrollingModule,
-} from '@angular/cdk/scrolling';
-import {
-  ComponentFixture,
-  ComponentFixtureAutoDetect,
-  TestBed,
-} from '@angular/core/testing';
-import {FormsModule} from '@angular/forms';
-import {MatButtonModule} from '@angular/material/button';
-import {MatDividerModule} from '@angular/material/divider';
-import {MatFormFieldModule} from '@angular/material/form-field';
-import {MatIconModule} from '@angular/material/icon';
-import {MatInputModule} from '@angular/material/input';
-import {MatSelectModule} from '@angular/material/select';
-import {BrowserAnimationsModule} from '@angular/platform-browser/animations';
-import {assertDefined} from 'common/assert_utils';
+import {CdkVirtualScrollViewport} from '@angular/cdk/scrolling';
 import {TimestampConverterUtils} from 'common/time/test_utils';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
+import {HierarchyTreeBuilder} from 'test/unit/hierarchy_tree_builder';
 import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
 import {TraceBuilder} from 'test/unit/trace_builder';
-import {UnitTestUtils} from 'test/unit/utils';
 import {TraceType} from 'trace/trace_type';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
+import {TransactionColumnType} from 'trace/transactions/transaction_column_type';
+import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
+import {AbstractLogViewerComponentTest} from 'viewers/common/abstract_log_viewer_component_test';
 import {LogSelectFilter} from 'viewers/common/log_filters';
-import {executeScrollComponentTests} from 'viewers/common/scroll_component_tests';
 import {LogHeader} from 'viewers/common/ui_data_log';
 import {UiPropertyTreeNode} from 'viewers/common/ui_property_tree_node';
-import {CollapsedSectionsComponent} from 'viewers/components/collapsed_sections_component';
-import {CollapsibleSectionTitleComponent} from 'viewers/components/collapsible_section_title_component';
-import {LogComponent} from 'viewers/components/log_component';
-import {PropertiesComponent} from 'viewers/components/properties_component';
-import {PropertyTreeNodeDataViewComponent} from 'viewers/components/property_tree_node_data_view_component';
-import {SearchBoxComponent} from 'viewers/components/search_box_component';
-import {SelectWithFilterComponent} from 'viewers/components/select_with_filter_component';
-import {TreeComponent} from 'viewers/components/tree_component';
-import {TreeNodeComponent} from 'viewers/components/tree_node_component';
-import {TransactionsScrollDirective} from './scroll_strategy/transactions_scroll_directive';
 import {TransactionsEntry, UiData} from './ui_data';
 import {ViewerTransactionsComponent} from './viewer_transactions_component';
 
-describe('ViewerTransactionsComponent', () => {
-  const testSpec = {name: 'Test Column', cssClass: 'test-class'};
-  const testField = {spec: testSpec, value: 'VALUE'};
-  let fixture: ComponentFixture<ViewerTransactionsComponent>;
-  let component: ViewerTransactionsComponent;
-  let htmlElement: HTMLElement;
-
-  describe('Main component', () => {
-    beforeEach(async () => {
-      await setUpTestEnvironment(() => makeUiData(0));
-    });
-
-    it('can be created', () => {
-      expect(component).toBeTruthy();
-    });
-
-    it('renders log component', () => {
-      expect(htmlElement.querySelector('.log-view')).toBeTruthy();
-    });
-
-    it('render headers as filters', () => {
-      expect(
-        htmlElement.querySelector(
-          `.headers .filter.${testSpec.cssClass.split(' ')[0]}`,
-        ),
-      ).toBeTruthy();
-    });
-
-    it('renders entries with field values and trace timestamp', () => {
-      expect(htmlElement.querySelector('.scroll')).toBeTruthy();
-      const entry = assertDefined(
-        htmlElement.querySelector(
-          `.scroll .entry .${testSpec.cssClass.split(' ')[0]}`,
-        ),
-      );
-      expect(entry.textContent).toContain('VALUE');
-
-      const entryTimestamp = assertDefined(
-        htmlElement.querySelector('.scroll .entry .time'),
-      );
-      expect(entryTimestamp.textContent?.trim()).toEqual('1ns');
-    });
-
-    it('shows go to current time button', () => {
-      expect(htmlElement.querySelector('.go-to-current-time')).toBeTruthy();
-    });
-
-    it('renders properties', () => {
-      expect(htmlElement.querySelector('.properties-view')).toBeTruthy();
-    });
-
-    it('shows message when no transaction is selected', () => {
-      assertDefined(component.inputData).propertiesTree = undefined;
-      fixture.detectChanges();
-      expect(
-        htmlElement.querySelector('.properties-view .placeholder-text')
-          ?.textContent,
-      ).toContain('No current or selected transaction');
-    });
-
-    it('creates collapsed sections with no buttons', () => {
-      UnitTestUtils.checkNoCollapsedSectionButtons(htmlElement);
-    });
-
-    it('handles properties section collapse/expand', () => {
-      UnitTestUtils.checkSectionCollapseAndExpand(
-        htmlElement,
-        fixture,
-        '.properties-view',
-        'PROPERTIES - PROTO DUMP',
-      );
-    });
-
-    function makeUiData(selectedEntryIndex: number): UiData {
-      const propertiesTree = new PropertyTreeBuilder()
-        .setRootId('Transactions')
-        .setName('tree')
-        .setValue(null)
-        .build();
-
-      const ts = TimestampConverterUtils.makeElapsedTimestamp(1n);
-
-      const trace = new TraceBuilder<PropertyTreeNode>()
-        .setEntries([propertiesTree, propertiesTree])
-        .setTimestamps([ts, ts])
-        .build();
-
-      const entry1 = new TransactionsEntry(
-        trace.getEntry(0),
-        Array.from({length: 7}, () => testField),
-        propertiesTree,
-      );
-
-      const uiData = new UiData(
-        [new LogHeader(testSpec, new LogSelectFilter([]))],
-        [entry1],
-        1,
-        selectedEntryIndex,
-        0,
-        UiPropertyTreeNode.from(propertiesTree),
-        {},
-      );
-
-      return uiData;
-    }
-  });
-
-  describe('Scroll component', () => {
-    executeScrollComponentTests(() =>
-      setUpTestEnvironment(makeUiDataForScroll),
-    );
-
-    function makeUiDataForScroll(): UiData {
-      const propertiesTree = new PropertyTreeBuilder()
-        .setRootId('Transactions')
-        .setName('tree')
-        .setValue(null)
-        .build();
-
-      const ts = TimestampConverterUtils.makeElapsedTimestamp(1n);
-
-      const trace = new TraceBuilder<PropertyTreeNode>()
-        .setType(TraceType.TRANSACTIONS)
-        .setEntries([propertiesTree, propertiesTree])
-        .setTimestamps([ts, ts])
-        .build();
-
-      const uiData = new UiData(
-        [],
-        [],
-        0,
-        0,
-        0,
-        UiPropertyTreeNode.from(propertiesTree),
-        {},
-      );
-      const shortMessage = 'flag1 | flag2';
-      const longMessage = shortMessage.repeat(20);
-      const traceEntry = trace.getEntry(0);
-
-      for (let i = 0; i < 200; i++) {
-        const entry = new TransactionsEntry(
-          traceEntry,
-          Array.from({length: 6}, () => testField).concat([
-            {
-              spec: {name: 'Test Column Flags', cssClass: 'test-class-flags'},
-              value: i % 2 === 0 ? shortMessage : longMessage,
-            },
-          ]),
-          propertiesTree,
-        );
-        uiData.entries.push(entry);
-      }
-      return uiData;
-    }
-  });
+class ViewerTransactionsComponentTest extends AbstractLogViewerComponentTest<ViewerTransactionsComponent> {
+  protected override readonly testProperties = true;
+  protected override readonly hasCurrentTimeButton = true;
+  protected override readonly testScroll = true;
+  protected override readonly propertiesSectionTitle =
+    'PROPERTIES - PROTO DUMP';
+  protected override readonly propertiesPlaceholder =
+    'No current or selected transaction with additional properties.';
+
+  protected override checkTimestampInTable(
+    dom: DOMTestHelper<ViewerTransactionsComponent>,
+  ): void {
+    const entryTimestamp = dom.get('.scroll .entry .time');
+    entryTimestamp.checkTextExact('1ns');
+  }
 
-  async function setUpTestEnvironment(
-    makeUiData: () => UiData,
-  ): Promise<
+  protected async setUpTestEnvironment(): Promise<
     [
-      ComponentFixture<ViewerTransactionsComponent>,
-      HTMLElement,
+      DOMTestHelper<ViewerTransactionsComponent>,
       CdkVirtualScrollViewport,
+      ViewerTransactionsComponent,
     ]
   > {
-    await TestBed.configureTestingModule({
-      providers: [{provide: ComponentFixtureAutoDetect, useValue: true}],
-      imports: [
-        MatDividerModule,
-        ScrollingModule,
-        MatIconModule,
-        ClipboardModule,
-        MatFormFieldModule,
-        MatButtonModule,
-        MatInputModule,
-        BrowserAnimationsModule,
-        FormsModule,
-        MatSelectModule,
-      ],
-      declarations: [
-        ViewerTransactionsComponent,
-        TransactionsScrollDirective,
-        SelectWithFilterComponent,
-        CollapsedSectionsComponent,
-        CollapsibleSectionTitleComponent,
-        PropertiesComponent,
-        TreeComponent,
-        TreeNodeComponent,
-        PropertyTreeNodeDataViewComponent,
-        SearchBoxComponent,
-        LogComponent,
-      ],
-    }).compileComponents();
+    const hierarchyTree = new HierarchyTreeBuilder()
+      .setId('Transactions')
+      .setName('tree')
+      .build();
+
+    const propertiesTree = new PropertyTreeBuilder()
+      .setRootId('Transactions')
+      .setName('tree')
+      .setValue(null)
+      .build();
+
+    const ts = TimestampConverterUtils.makeElapsedTimestamp(1n);
+
+    const trace = new TraceBuilder<HierarchyTreeNode>()
+      .setEntries([hierarchyTree, hierarchyTree])
+      .setTimestamps([ts, ts])
+      .build();
+
+    const entry1 = new TransactionsEntry(
+      trace.getEntry(0),
+      Array.from({length: 8}, () => this.testField),
+      async () => propertiesTree,
+    );
+    entry1.fields[7].spec = {
+      name: 'Test Column',
+      cssClass: 'test-class',
+      columnType: TransactionColumnType.FLAGS,
+    };
+
+    const uiData = new UiData(
+      [new LogHeader(this.testSpec, new LogSelectFilter([]))],
+      [entry1],
+      1,
+      0,
+      0,
+      UiPropertyTreeNode.from(propertiesTree),
+      {},
+    );
+    return this.initializeTestEnvironment(uiData, ViewerTransactionsComponent);
+  }
 
-    fixture = TestBed.createComponent(ViewerTransactionsComponent);
-    component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
+  protected override async setUpTestEnvironmentForScroll(): Promise<
+    [DOMTestHelper<ViewerTransactionsComponent>, CdkVirtualScrollViewport]
+  > {
+    const hierarchyTree = new HierarchyTreeBuilder()
+      .setId('Transactions')
+      .setName('tree')
+      .build();
+
+    const propertiesTree = new PropertyTreeBuilder()
+      .setRootId('Transactions')
+      .setName('tree')
+      .setValue(null)
+      .build();
+
+    const ts = TimestampConverterUtils.makeElapsedTimestamp(1n);
+
+    const trace = new TraceBuilder<HierarchyTreeNode>()
+      .setType(TraceType.TRANSACTIONS)
+      .setEntries([hierarchyTree, hierarchyTree])
+      .setTimestamps([ts, ts])
+      .build();
+
+    const uiData = new UiData(
+      [],
+      [],
+      0,
+      0,
+      0,
+      UiPropertyTreeNode.from(propertiesTree),
+      {},
+    );
+    const shortMessage = 'flag1 | flag2';
+    const longMessage = shortMessage.repeat(20);
+    const traceEntry = trace.getEntry(0);
+
+    for (let i = 0; i < 200; i++) {
+      const entry = new TransactionsEntry(
+        traceEntry,
+        Array.from({length: 8}, () => this.testField).concat([
+          {
+            spec: {
+              name: 'Test Column Flags',
+              cssClass: 'test-class-flags',
+              columnType: TransactionColumnType.FLAGS,
+            },
+            value: i % 2 === 0 ? shortMessage : longMessage,
+          },
+        ]),
+        async () => propertiesTree,
+      );
+      uiData.entries.push(entry);
+    }
 
-    component.inputData = makeUiData();
-    fixture.detectChanges();
-    const viewport = assertDefined(component.logComponent?.scrollComponent);
-    return [fixture, htmlElement, viewport];
+    const [dom, viewport] = await this.initializeTestEnvironment(
+      uiData,
+      ViewerTransactionsComponent,
+    );
+    return [dom, viewport];
   }
+}
+
+describe('ViewerTransactionsComponent', () => {
+  new ViewerTransactionsComponentTest().execute();
 });
diff --git a/tools/winscope/src/viewers/viewer_transitions/operations/abstract_update_layers_and_windows.ts b/tools/winscope/src/viewers/viewer_transitions/operations/abstract_update_layers_and_windows.ts
new file mode 100644
index 000000000..cceb7698f
--- /dev/null
+++ b/tools/winscope/src/viewers/viewer_transitions/operations/abstract_update_layers_and_windows.ts
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import {FixedStringFormatter, formatAsHex} from 'trace/tree_node/formatters';
+import {Operation} from 'trace/tree_node/operations/operation';
+import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
+import {TreeNode} from 'trace/tree_node/tree_node';
+
+export abstract class AbstractUpdateLayersAndWindows<T extends TreeNode>
+  implements Operation<T>
+{
+  constructor(
+    private readonly layerIdToName: Map<number, string>,
+    private readonly windowTokenToTitle: Map<string, string>,
+  ) {}
+
+  abstract apply(node: T): void;
+
+  protected updateLayerId(layerId: PropertyTreeNode) {
+    const layerIdValue = layerId.getValue();
+    if (layerIdValue === undefined) {
+      return;
+    }
+    const layerName = this.layerIdToName.get(Number(layerIdValue));
+    if (layerName === undefined) {
+      return;
+    }
+    layerId.setFormatter(
+      new FixedStringFormatter(`${layerIdValue} (${layerName})`),
+    );
+  }
+
+  protected updateWindowId(windowId: PropertyTreeNode) {
+    let windowIdValue = windowId.getValue();
+    if (windowIdValue === undefined) {
+      return;
+    }
+    windowIdValue = Number(windowIdValue);
+    const windowIdString = formatAsHex(windowIdValue);
+    const windowTitle = this.windowTokenToTitle.get(windowIdValue.toString(16));
+    windowId.setFormatter(
+      new FixedStringFormatter(
+        windowTitle
+          ? `${windowIdString} (${windowTitle})`
+          : `${windowIdString}`,
+      ),
+    );
+  }
+}
diff --git a/tools/winscope/src/viewers/viewer_transitions/operations/update_transition_changes_names.ts b/tools/winscope/src/viewers/viewer_transitions/operations/update_transition_changes_names.ts
deleted file mode 100644
index d19b0cfbd..000000000
--- a/tools/winscope/src/viewers/viewer_transitions/operations/update_transition_changes_names.ts
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import {FixedStringFormatter, formatAsHex} from 'trace/tree_node/formatters';
-import {Operation} from 'trace/tree_node/operations/operation';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
-
-export class UpdateTransitionChangesNames
-  implements Operation<PropertyTreeNode>
-{
-  constructor(
-    private readonly layerIdToName: Map<number, string>,
-    private readonly windowTokenToTitle: Map<string, string>,
-  ) {}
-
-  apply(node: PropertyTreeNode): void {
-    node
-      .getChildByName('wmData')
-      ?.getChildByName('targets')
-      ?.getAllChildren()
-      .forEach((target) => {
-        const layerId = target.getChildByName('layerId');
-        if (layerId) {
-          const layerIdValue = Number(layerId.getValue());
-          const layerName = this.layerIdToName.get(layerIdValue);
-          if (layerName) {
-            layerId.setFormatter(
-              new FixedStringFormatter(`${layerIdValue} (${layerName})`),
-            );
-          }
-        }
-
-        const windowId = target.getChildByName('windowId');
-        if (windowId) {
-          const windowIdValue = windowId.getValue();
-          const windowTitle = this.windowTokenToTitle.get(
-            windowIdValue.toString(16),
-          );
-          const windowIdString = formatAsHex(windowIdValue);
-          windowId.setFormatter(
-            new FixedStringFormatter(
-              windowTitle
-                ? `${windowIdString} (${windowTitle})`
-                : `${windowIdString}`,
-            ),
-          );
-        }
-      });
-  }
-}
diff --git a/tools/winscope/src/viewers/viewer_transitions/operations/update_transition_participants.ts b/tools/winscope/src/viewers/viewer_transitions/operations/update_transition_participants.ts
new file mode 100644
index 000000000..439c024cc
--- /dev/null
+++ b/tools/winscope/src/viewers/viewer_transitions/operations/update_transition_participants.ts
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
+import {AbstractUpdateLayersAndWindows} from './abstract_update_layers_and_windows';
+
+export class UpdateTransitionParticipants extends AbstractUpdateLayersAndWindows<HierarchyTreeNode> {
+  apply(node: HierarchyTreeNode): void {
+    node
+      .getEagerPropertyByName('layers')
+      ?.getAllChildren()
+      .forEach((layerId) => {
+        this.updateLayerId(layerId);
+      });
+
+    node
+      .getEagerPropertyByName('windows')
+      ?.getAllChildren()
+      .forEach((windowId) => {
+        this.updateWindowId(windowId);
+      });
+  }
+}
diff --git a/tools/winscope/src/viewers/viewer_transitions/operations/update_transition_participants_test.ts b/tools/winscope/src/viewers/viewer_transitions/operations/update_transition_participants_test.ts
new file mode 100644
index 000000000..6a29f948d
--- /dev/null
+++ b/tools/winscope/src/viewers/viewer_transitions/operations/update_transition_participants_test.ts
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import {HierarchyTreeBuilder} from 'test/unit/hierarchy_tree_builder';
+import {UpdateTransitionParticipants} from './update_transition_participants';
+
+describe('UpdateTransitionParticipants', () => {
+  let operation: UpdateTransitionParticipants;
+
+  beforeEach(() => {
+    const layerIdToName = new Map<number, string>([[2, 'testLayer']]);
+    const windowTokenToTitle = new Map<string, string>([
+      ['97b5518', 'testTitle'],
+    ]);
+
+    operation = new UpdateTransitionParticipants(
+      layerIdToName,
+      windowTokenToTitle,
+    );
+  });
+
+  it('updates layerId and windowToken display names if in maps', () => {
+    const transition = new HierarchyTreeBuilder()
+      .setId('TransitionsTraceEntry')
+      .setName('transition')
+      .setProperties({
+        layers: [2],
+        windows: [159077656n],
+      })
+      .build();
+
+    operation.apply(transition);
+    expect(
+      transition
+        ?.getEagerPropertyByName('layers')
+        ?.getChildByName('0')
+        ?.formattedValue(),
+    ).toEqual('2 (testLayer)');
+
+    expect(
+      transition
+        ?.getEagerPropertyByName('windows')
+        ?.getChildByName('0')
+        ?.formattedValue(),
+    ).toEqual('0x97b5518 (testTitle)');
+  });
+
+  it('updates only windowId display name if neither layer id nor token in maps', () => {
+    const transition = new HierarchyTreeBuilder()
+      .setId('TransitionsTraceEntry')
+      .setName('transition')
+      .setProperties({
+        layers: [1],
+        windows: [193491296n],
+      })
+      .build();
+
+    operation.apply(transition);
+    expect(
+      transition
+        ?.getEagerPropertyByName('layers')
+        ?.getChildByName('0')
+        ?.formattedValue(),
+    ).toEqual('1');
+
+    expect(
+      transition
+        ?.getEagerPropertyByName('windows')
+        ?.getChildByName('0')
+        ?.formattedValue(),
+    ).toEqual('0xb887160');
+  });
+});
diff --git a/tools/winscope/src/viewers/viewer_transitions/operations/update_transition_targets.ts b/tools/winscope/src/viewers/viewer_transitions/operations/update_transition_targets.ts
new file mode 100644
index 000000000..b959cf99d
--- /dev/null
+++ b/tools/winscope/src/viewers/viewer_transitions/operations/update_transition_targets.ts
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
+import {AbstractUpdateLayersAndWindows} from './abstract_update_layers_and_windows';
+
+export class UpdateTransitionTargets extends AbstractUpdateLayersAndWindows<PropertyTreeNode> {
+  apply(node: PropertyTreeNode): void {
+    node
+      ?.getChildByName('targets')
+      ?.getAllChildren()
+      .forEach((target) => {
+        const layerId = target.getChildByName('layerId');
+        if (layerId) {
+          this.updateLayerId(layerId);
+        }
+
+        const windowId = target.getChildByName('windowId');
+        if (windowId) {
+          this.updateWindowId(windowId);
+        }
+      });
+  }
+}
diff --git a/tools/winscope/src/viewers/viewer_transitions/operations/update_transition_changes_names_test.ts b/tools/winscope/src/viewers/viewer_transitions/operations/update_transition_targets_test.ts
similarity index 70%
rename from tools/winscope/src/viewers/viewer_transitions/operations/update_transition_changes_names_test.ts
rename to tools/winscope/src/viewers/viewer_transitions/operations/update_transition_targets_test.ts
index c464ff2e6..1d1a9e670 100644
--- a/tools/winscope/src/viewers/viewer_transitions/operations/update_transition_changes_names_test.ts
+++ b/tools/winscope/src/viewers/viewer_transitions/operations/update_transition_targets_test.ts
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2024 The Android Open Source Project
+ * Copyright (C) 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,10 +15,10 @@
  */
 
 import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
-import {UpdateTransitionChangesNames} from './update_transition_changes_names';
+import {UpdateTransitionTargets} from './update_transition_targets';
 
-describe('UpdateTransitionChangesNames', () => {
-  let operation: UpdateTransitionChangesNames;
+describe('UpdateTransitionTargets', () => {
+  let operation: UpdateTransitionTargets;
 
   beforeEach(() => {
     const layerIdToName = new Map<number, string>([[2, 'testLayer']]);
@@ -26,10 +26,7 @@ describe('UpdateTransitionChangesNames', () => {
       ['97b5518', 'testTitle'],
     ]);
 
-    operation = new UpdateTransitionChangesNames(
-      layerIdToName,
-      windowTokenToTitle,
-    );
+    operation = new UpdateTransitionTargets(layerIdToName, windowTokenToTitle);
   });
 
   it('updates layerId and windowToken display names if in maps', () => {
@@ -39,18 +36,13 @@ describe('UpdateTransitionChangesNames', () => {
       .setName('transition')
       .setChildren([
         {
-          name: 'wmData',
+          name: 'targets',
           children: [
             {
-              name: 'targets',
+              name: '0',
               children: [
-                {
-                  name: '0',
-                  children: [
-                    {name: 'layerId', value: 2},
-                    {name: 'windowId', value: 159077656n},
-                  ],
-                },
+                {name: 'layerId', value: 2},
+                {name: 'windowId', value: 159077656n},
               ],
             },
           ],
@@ -61,7 +53,6 @@ describe('UpdateTransitionChangesNames', () => {
     operation.apply(propertyRoot);
     expect(
       propertyRoot
-        .getChildByName('wmData')
         ?.getChildByName('targets')
         ?.getChildByName('0')
         ?.getChildByName('layerId')
@@ -70,7 +61,6 @@ describe('UpdateTransitionChangesNames', () => {
 
     expect(
       propertyRoot
-        .getChildByName('wmData')
         ?.getChildByName('targets')
         ?.getChildByName('0')
         ?.getChildByName('windowId')
@@ -85,18 +75,13 @@ describe('UpdateTransitionChangesNames', () => {
       .setName('transition')
       .setChildren([
         {
-          name: 'wmData',
+          name: 'targets',
           children: [
             {
-              name: 'targets',
+              name: '0',
               children: [
-                {
-                  name: '0',
-                  children: [
-                    {name: 'layerId', value: 1},
-                    {name: 'windowId', value: 193491296n},
-                  ],
-                },
+                {name: 'layerId', value: 1},
+                {name: 'windowId', value: 193491296n},
               ],
             },
           ],
@@ -107,7 +92,6 @@ describe('UpdateTransitionChangesNames', () => {
     operation.apply(propertyRoot);
     expect(
       propertyRoot
-        .getChildByName('wmData')
         ?.getChildByName('targets')
         ?.getChildByName('0')
         ?.getChildByName('layerId')
@@ -116,7 +100,6 @@ describe('UpdateTransitionChangesNames', () => {
 
     expect(
       propertyRoot
-        .getChildByName('wmData')
         ?.getChildByName('targets')
         ?.getChildByName('0')
         ?.getChildByName('windowId')
diff --git a/tools/winscope/src/viewers/viewer_transitions/presenter.ts b/tools/winscope/src/viewers/viewer_transitions/presenter.ts
index 210ae45a4..e46731fd7 100644
--- a/tools/winscope/src/viewers/viewer_transitions/presenter.ts
+++ b/tools/winscope/src/viewers/viewer_transitions/presenter.ts
@@ -21,8 +21,8 @@ import {CustomQueryType} from 'trace/custom_query';
 import {Trace} from 'trace/trace';
 import {Traces} from 'trace/traces';
 import {TraceType} from 'trace/trace_type';
+import {TransitionStatus} from 'trace/transitions/status';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
 import {
   AbstractLogViewerPresenter,
   NotifyLogViewCallbackType,
@@ -32,12 +32,13 @@ import {LogPresenter} from 'viewers/common/log_presenter';
 import {PropertiesPresenter} from 'viewers/common/properties_presenter';
 import {TextFilter} from 'viewers/common/text_filter';
 import {ColumnSpec, LogField, LogHeader} from 'viewers/common/ui_data_log';
-import {UpdateTransitionChangesNames} from './operations/update_transition_changes_names';
-import {TransitionsEntry, TransitionStatus, UiData} from './ui_data';
+import {UpdateTransitionParticipants} from './operations/update_transition_participants';
+import {UpdateTransitionTargets} from './operations/update_transition_targets';
+import {TransitionsEntry, UiData} from './ui_data';
 
 export class Presenter extends AbstractLogViewerPresenter<
   UiData,
-  PropertyTreeNode
+  HierarchyTreeNode
 > {
   private static readonly COLUMNS = {
     id: {name: 'Id', cssClass: 'transition-id right-align'},
@@ -50,12 +51,16 @@ export class Presenter extends AbstractLogViewerPresenter<
     flags: {name: 'Flags', cssClass: 'flags'},
     status: {name: 'Status', cssClass: 'status right-align'},
   };
-  private transitionTrace: Trace<PropertyTreeNode>;
+  private transitionTrace: Trace<HierarchyTreeNode>;
   private surfaceFlingerTrace: Trace<HierarchyTreeNode> | undefined;
   private windowManagerTrace: Trace<HierarchyTreeNode> | undefined;
   private layerIdToName = new Map<number, string>();
   private windowTokenToTitle = new Map<string, string>();
-  private updateTransitionChangesNames = new UpdateTransitionChangesNames(
+  private updateTransitionParticipants = new UpdateTransitionParticipants(
+    this.layerIdToName,
+    this.windowTokenToTitle,
+  );
+  private updateTransitionTargets = new UpdateTransitionTargets(
     this.layerIdToName,
     this.windowTokenToTitle,
   );
@@ -66,11 +71,11 @@ export class Presenter extends AbstractLogViewerPresenter<
   protected override propertiesPresenter = new PropertiesPresenter(
     {},
     new TextFilter(),
-    [],
+    ['layers', 'windows'],
   );
 
   constructor(
-    trace: Trace<PropertyTreeNode>,
+    trace: Trace<HierarchyTreeNode>,
     traces: Traces,
     readonly storage: Store,
     notifyViewCallback: NotifyLogViewCallbackType<UiData>,
@@ -141,7 +146,7 @@ export class Presenter extends AbstractLogViewerPresenter<
     return transitions;
   }
 
-  protected override updateFiltersInHeaders(headers: LogHeader[]) {
+  protected override async updateFiltersInHeaders(headers: LogHeader[]) {
     headers.forEach((header) => {
       if (!(header.filter instanceof LogSelectFilter)) return;
       header.filter.options = this.getUniqueUiDataEntryValues(header.spec);
@@ -196,35 +201,36 @@ export class Presenter extends AbstractLogViewerPresenter<
       ++traceIndex
     ) {
       const entry = assertDefined(this.trace.getEntry(traceIndex));
-      let transitionNode: PropertyTreeNode;
+      let transitionNode: HierarchyTreeNode;
       try {
         transitionNode = await entry.getValue();
       } catch (e) {
+        console.error(e);
         continue;
       }
-      const wmDataNode = assertDefined(transitionNode.getChildByName('wmData'));
-      const shellDataNode = assertDefined(
-        transitionNode.getChildByName('shellData'),
-      );
-      this.updateTransitionChangesNames.apply(transitionNode);
+      this.updateTransitionParticipants.apply(transitionNode);
 
-      const transitionType = this.extractAndFormatTransitionType(wmDataNode);
-      const handler = this.extractAndFormatHandler(shellDataNode);
-      const participants = this.extractAndFormatParticipants(wmDataNode);
-      const flags = this.extractAndFormatFlags(wmDataNode);
+      const transitionType =
+        this.extractAndFormatTransitionType(transitionNode);
+      const handler = this.extractAndFormatHandler(transitionNode);
+      const participants = this.extractAndFormatParticipants(transitionNode);
+      const flags = this.extractAndFormatFlags(transitionNode);
       const [status, statusIcon, statusIconColor] =
         this.extractAndFormatStatus(transitionNode);
 
-      const sendTs: Timestamp | undefined = wmDataNode
-        .getChildByName('sendTimeNs')
+      const sendTs: Timestamp | undefined = transitionNode
+        .getEagerPropertyByName('sendTimeNs')
         ?.getValue();
-      const dispatchTs: Timestamp | undefined = shellDataNode
-        .getChildByName('dispatchTimeNs')
+      const dispatchTs: Timestamp | undefined = transitionNode
+        .getEagerPropertyByName('dispatchTimeNs')
         ?.getValue();
+
       const fields: LogField[] = [
         {
           spec: Presenter.COLUMNS.id,
-          value: assertDefined(transitionNode.getChildByName('id')).getValue(),
+          value: assertDefined(
+            transitionNode.getEagerPropertyByName('transitionId'),
+          ).getValue(),
         },
         {spec: Presenter.COLUMNS.type, value: transitionType},
         {
@@ -241,8 +247,9 @@ export class Presenter extends AbstractLogViewerPresenter<
         {
           spec: Presenter.COLUMNS.duration,
           value:
-            transitionNode.getChildByName('duration')?.formattedValue() ??
-            Presenter.VALUE_NA,
+            transitionNode
+              .getEagerPropertyByName('durationNs')
+              ?.formattedValue() ?? Presenter.VALUE_NA,
         },
         {spec: Presenter.COLUMNS.handler, value: handler},
         {spec: Presenter.COLUMNS.participants, value: participants},
@@ -254,24 +261,33 @@ export class Presenter extends AbstractLogViewerPresenter<
           iconColor: statusIconColor,
         },
       ];
-      transitions.push(new TransitionsEntry(entry, fields, transitionNode));
+      transitions.push(
+        new TransitionsEntry(entry, fields, async () => {
+          const properties = await transitionNode.getAllProperties();
+          this.updateTransitionTargets.apply(properties);
+          return properties;
+        }),
+      );
     }
 
     return transitions;
   }
 
-  private extractAndFormatTransitionType(wmDataNode: PropertyTreeNode): string {
+  private extractAndFormatTransitionType(
+    transition: HierarchyTreeNode,
+  ): string {
     const transitionType =
-      wmDataNode.getChildByName('type')?.formattedValue() ?? 'NONE';
+      transition.getEagerPropertyByName('transitionType')?.formattedValue() ??
+      'NONE';
     assertDefined(this.uniqueFieldValues.get(Presenter.COLUMNS.type)).add(
       transitionType,
     );
     return transitionType;
   }
 
-  private extractAndFormatHandler(shellDataNode: PropertyTreeNode): string {
+  private extractAndFormatHandler(transition: HierarchyTreeNode): string {
     const handler =
-      shellDataNode.getChildByName('handler')?.formattedValue() ??
+      transition.getEagerPropertyByName('handler')?.formattedValue() ??
       Presenter.VALUE_NA;
     assertDefined(this.uniqueFieldValues.get(Presenter.COLUMNS.handler)).add(
       handler,
@@ -279,9 +295,9 @@ export class Presenter extends AbstractLogViewerPresenter<
     return handler;
   }
 
-  private extractAndFormatFlags(wmDataNode: PropertyTreeNode): string {
+  private extractAndFormatFlags(transition: HierarchyTreeNode): string {
     const flags =
-      wmDataNode.getChildByName('flags')?.formattedValue() ??
+      transition.getEagerPropertyByName('flags')?.formattedValue() ??
       Presenter.VALUE_NA;
 
     const uniqueFlags = assertDefined(
@@ -295,51 +311,53 @@ export class Presenter extends AbstractLogViewerPresenter<
     return flags;
   }
 
-  private extractAndFormatParticipants(wmDataNode: PropertyTreeNode): string {
-    const targets = wmDataNode.getChildByName('targets')?.getAllChildren();
-    if (!targets) return Presenter.VALUE_NA;
+  private extractAndFormatParticipants(transition: HierarchyTreeNode): string {
+    const layers = transition
+      .getEagerPropertyByName('layers')
+      ?.getAllChildren()
+      .map((layer) => {
+        return layer.formattedValue();
+      });
+    const windows = transition
+      .getEagerPropertyByName('windows')
+      ?.getAllChildren()
+      .map((window) => {
+        return window.formattedValue();
+      });
+    if (!layers && !windows) return Presenter.VALUE_NA;
 
-    const layers = new Set<string>();
-    const windows = new Set<string>();
-    targets.forEach((target) => {
-      const layerId = target.getChildByName('layerId');
-      if (layerId) layers.add(layerId.formattedValue());
-      const windowId = target.getChildByName('windowId');
-      if (windowId) windows.add(windowId.formattedValue());
-    });
     const uniqueParticipants = assertDefined(
       this.uniqueFieldValues.get(Presenter.COLUMNS.participants),
     );
-    layers.forEach((layer) => uniqueParticipants.add(layer));
-    windows.forEach((window) => uniqueParticipants.add(window));
+    layers?.forEach((layer) => uniqueParticipants.add(layer));
+    windows?.forEach((window) => uniqueParticipants.add(window));
 
     return `Layers: ${
-      layers.size > 0 ? [...layers].join(', ') : Presenter.VALUE_NA
+      (layers?.length ?? 0) > 0
+        ? assertDefined(layers).join(', ')
+        : Presenter.VALUE_NA
     }\nWindows: ${
-      windows.size > 0 ? [...windows].join(', ') : Presenter.VALUE_NA
+      (windows?.length ?? 0) > 0
+        ? assertDefined(windows).join(', ')
+        : Presenter.VALUE_NA
     }`;
   }
 
   private extractAndFormatStatus(
-    transitionNode: PropertyTreeNode,
+    transitionNode: HierarchyTreeNode,
   ): [string, string | undefined, string | undefined] {
-    let status = Presenter.VALUE_NA;
+    const status =
+      transitionNode.getEagerPropertyByName('status')?.formattedValue() ??
+      Presenter.VALUE_NA;
     let statusIcon: string | undefined;
     let statusIconColor: string | undefined;
-    if (assertDefined(transitionNode.getChildByName('merged')).getValue()) {
-      status = TransitionStatus.MERGED;
+    if (status === TransitionStatus.MERGED) {
       statusIcon = 'merge';
       statusIconColor = 'gray';
-    } else if (
-      assertDefined(transitionNode.getChildByName('aborted')).getValue()
-    ) {
-      status = TransitionStatus.ABORTED;
+    } else if (status === TransitionStatus.ABORTED) {
       statusIcon = 'close';
       statusIconColor = 'red';
-    } else if (
-      assertDefined(transitionNode.getChildByName('played')).getValue()
-    ) {
-      status = TransitionStatus.PLAYED;
+    } else if (status === TransitionStatus.PLAYED) {
       statusIcon = 'check';
       statusIconColor = 'green';
     }
diff --git a/tools/winscope/src/viewers/viewer_transitions/presenter_test.ts b/tools/winscope/src/viewers/viewer_transitions/presenter_test.ts
index 843751a99..9dc38f8c8 100644
--- a/tools/winscope/src/viewers/viewer_transitions/presenter_test.ts
+++ b/tools/winscope/src/viewers/viewer_transitions/presenter_test.ts
@@ -19,15 +19,15 @@ import {InMemoryStorage} from 'common/store/in_memory_storage';
 import {TimestampConverterUtils} from 'common/time/test_utils';
 import {TimeUtils} from 'common/time/time_utils';
 import {TracePositionUpdate} from 'messaging/winscope_event';
+import {getPerfettoParser} from 'test/unit/fixture_utils';
+import {HierarchyTreeBuilder} from 'test/unit/hierarchy_tree_builder';
 import {ParserBuilder} from 'test/unit/parser_builder';
-import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
 import {TracesBuilder} from 'test/unit/traces_builder';
 import {TraceBuilder} from 'test/unit/trace_builder';
-import {UnitTestUtils} from 'test/unit/utils';
 import {Trace} from 'trace/trace';
 import {Traces} from 'trace/traces';
 import {TraceType} from 'trace/trace_type';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
+import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 import {NotifyLogViewCallbackType} from 'viewers/common/abstract_log_viewer_presenter';
 import {AbstractLogViewerPresenterTest} from 'viewers/common/abstract_log_viewer_presenter_test';
 import {LogSelectFilter} from 'viewers/common/log_filters';
@@ -119,16 +119,16 @@ class PresenterTransitionsTest extends AbstractLogViewerPresenterTest<UiData> {
       options: ['MERGED', 'N/A', 'PLAYED'],
     },
   ];
-  private trace: Trace<PropertyTreeNode> | undefined;
+  private trace: Trace<HierarchyTreeNode> | undefined;
   private positionUpdate: TracePositionUpdate | undefined;
 
   override async setUpTestEnvironment(): Promise<void> {
-    const parser = await UnitTestUtils.getPerfettoParser(
+    const parser = await getPerfettoParser(
       TraceType.TRANSITION,
       'traces/perfetto/shell_transitions_trace.perfetto-trace',
     );
 
-    this.trace = new TraceBuilder<PropertyTreeNode>()
+    this.trace = new TraceBuilder<HierarchyTreeNode>()
       .setType(TraceType.TRANSITION)
       .setParser(parser)
       .build();
@@ -175,12 +175,15 @@ class PresenterTransitionsTest extends AbstractLogViewerPresenterTest<UiData> {
     expect(uiData.entries.length).toEqual(4);
 
     const selectedTransition = assertDefined(uiData.propertiesTree);
-    const wmData = assertDefined(selectedTransition.getChildByName('wmData'));
-    expect(wmData.getChildByName('id')?.formattedValue()).toEqual('32');
-    expect(wmData.getChildByName('type')?.formattedValue()).toEqual('OPEN');
-    expect(wmData.getChildByName('createTimeNs')?.formattedValue()).toEqual(
-      '2023-11-21, 13:30:25.429',
+    expect(selectedTransition.getChildByName('id')?.formattedValue()).toEqual(
+      '32',
     );
+    expect(selectedTransition.getChildByName('type')?.formattedValue()).toEqual(
+      'OPEN',
+    );
+    expect(
+      selectedTransition.getChildByName('createTimeNs')?.formattedValue(),
+    ).toEqual('2023-11-21, 13:30:25.429');
 
     const dispatchTimeEntryTs = uiData.entries[0].fields[3];
     expect(dispatchTimeEntryTs?.propagateEntryTimestamp).toBeTrue();
@@ -197,14 +200,14 @@ class PresenterTransitionsTest extends AbstractLogViewerPresenterTest<UiData> {
     describe('Specialized tests', () => {
       it('robust to corrupted transitions trace', async () => {
         const timestamp10 = TimestampConverterUtils.makeRealTimestamp(10n);
-        const trace = new TraceBuilder<PropertyTreeNode>()
+        const trace = new TraceBuilder<HierarchyTreeNode>()
           .setType(TraceType.TRANSITION)
           .setParser(
-            new ParserBuilder<PropertyTreeNode>()
+            new ParserBuilder<HierarchyTreeNode>()
               .setIsCorrupted(true)
               .setEntries([
-                new PropertyTreeBuilder()
-                  .setRootId('TransitionsTraceEntry')
+                new HierarchyTreeBuilder()
+                  .setId('TransitionsTraceEntry')
                   .setName('transition0')
                   .build(),
               ])
diff --git a/tools/winscope/src/viewers/viewer_transitions/scroll_strategy/transitions_scroll_directive.ts b/tools/winscope/src/viewers/viewer_transitions/scroll_strategy/transitions_scroll_directive.ts
deleted file mode 100644
index e41c04fb5..000000000
--- a/tools/winscope/src/viewers/viewer_transitions/scroll_strategy/transitions_scroll_directive.ts
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import {VIRTUAL_SCROLL_STRATEGY} from '@angular/cdk/scrolling';
-import {Directive, forwardRef} from '@angular/core';
-import {VariableHeightScrollDirective} from 'viewers/common/variable_height_scroll_directive';
-import {TransitionsEntry} from 'viewers/viewer_transitions/ui_data';
-import {TransitionsScrollStrategy} from './transitions_scroll_strategy';
-
-@Directive({
-  selector: '[transitionsVirtualScroll]',
-  providers: [
-    {
-      provide: VIRTUAL_SCROLL_STRATEGY,
-      useFactory: (dir: TransitionsScrollDirective) => dir.scrollStrategy,
-      deps: [forwardRef(() => TransitionsScrollDirective)],
-    },
-  ],
-})
-export class TransitionsScrollDirective extends VariableHeightScrollDirective<TransitionsEntry> {
-  scrollStrategy = new TransitionsScrollStrategy();
-}
diff --git a/tools/winscope/src/viewers/viewer_transitions/scroll_strategy/transitions_scroll_strategy.ts b/tools/winscope/src/viewers/viewer_transitions/transitions_height_predictor.ts
similarity index 75%
rename from tools/winscope/src/viewers/viewer_transitions/scroll_strategy/transitions_scroll_strategy.ts
rename to tools/winscope/src/viewers/viewer_transitions/transitions_height_predictor.ts
index 7d822a0ec..0fa18bf93 100644
--- a/tools/winscope/src/viewers/viewer_transitions/scroll_strategy/transitions_scroll_strategy.ts
+++ b/tools/winscope/src/viewers/viewer_transitions/transitions_height_predictor.ts
@@ -14,17 +14,18 @@
  * limitations under the License.
  */
 
-import {VariableHeightScrollStrategy} from 'viewers/common/variable_height_scroll_strategy';
+import {assertString} from 'common/assert_utils';
+import {ItemHeightPredictor} from 'viewers/common/item_height_predictor';
 import {TransitionsEntry} from 'viewers/viewer_transitions/ui_data';
 
-export class TransitionsScrollStrategy extends VariableHeightScrollStrategy {
-  protected readonly defaultRowSize = 36;
+export class TransitionsHeightPredictor extends ItemHeightPredictor {
+  protected override readonly defaultRowSize = 36;
   private readonly participantsCharsPerRow = 25;
   private readonly timestampCharsPerRow = 20;
 
-  protected override predictScrollItemHeight(entry: TransitionsEntry): number {
+  override predictHeight(entry: TransitionsEntry): number {
     const participantsHeight = this.subItemHeight(
-      entry.fields[6].value as string,
+      assertString(entry.fields[6].value),
       this.participantsCharsPerRow,
     );
     const timestampHeight = this.subItemHeight(
diff --git a/tools/winscope/src/viewers/viewer_transitions/ui_data.ts b/tools/winscope/src/viewers/viewer_transitions/ui_data.ts
index 362b3a2aa..56499ef3e 100644
--- a/tools/winscope/src/viewers/viewer_transitions/ui_data.ts
+++ b/tools/winscope/src/viewers/viewer_transitions/ui_data.ts
@@ -15,7 +15,8 @@
  */
 
 import {TraceEntry} from 'trace/trace';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
+import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
+import {LazyPropertiesStrategyType} from 'trace/tree_node/properties_provider';
 import {TextFilter} from 'viewers/common/text_filter';
 import {
   LogEntry,
@@ -45,14 +46,8 @@ export class UiData implements UiDataLog {
 
 export class TransitionsEntry implements LogEntry {
   constructor(
-    public traceEntry: TraceEntry<PropertyTreeNode>,
+    public traceEntry: TraceEntry<HierarchyTreeNode>,
     public fields: LogField[],
-    public propertiesTree: PropertyTreeNode | undefined,
+    public getPropertiesTree: LazyPropertiesStrategyType | undefined,
   ) {}
 }
-
-export enum TransitionStatus {
-  ABORTED = 'ABORTED',
-  MERGED = 'MERGED',
-  PLAYED = 'PLAYED',
-}
diff --git a/tools/winscope/src/viewers/viewer_transitions/viewer_transitions.ts b/tools/winscope/src/viewers/viewer_transitions/viewer_transitions.ts
index d1281404f..f2102d53c 100644
--- a/tools/winscope/src/viewers/viewer_transitions/viewer_transitions.ts
+++ b/tools/winscope/src/viewers/viewer_transitions/viewer_transitions.ts
@@ -17,21 +17,21 @@ import {Store} from 'common/store/store';
 import {Trace} from 'trace/trace';
 import {Traces} from 'trace/traces';
 import {TraceType} from 'trace/trace_type';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
+import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
 import {AbstractViewer} from 'viewers/abstract_viewer';
 import {ViewerComponent} from 'viewers/components/viewer_component';
 import {Presenter} from './presenter';
 import {UiData} from './ui_data';
 
-export class ViewerTransitions extends AbstractViewer<PropertyTreeNode> {
+export class ViewerTransitions extends AbstractViewer<HierarchyTreeNode> {
   static readonly DEPENDENCIES: TraceType[] = [TraceType.TRANSITION];
 
-  constructor(trace: Trace<PropertyTreeNode>, traces: Traces, store: Store) {
+  constructor(trace: Trace<HierarchyTreeNode>, traces: Traces, store: Store) {
     super(trace, traces, 'viewer-transitions', store);
   }
 
   protected override initializePresenter(
-    trace: Trace<PropertyTreeNode>,
+    trace: Trace<HierarchyTreeNode>,
     traces: Traces,
     store: Store,
   ): Presenter {
diff --git a/tools/winscope/src/viewers/viewer_transitions/viewer_transitions_component_test.ts b/tools/winscope/src/viewers/viewer_transitions/viewer_transitions_component_test.ts
index c2d5aad65..938fb39b0 100644
--- a/tools/winscope/src/viewers/viewer_transitions/viewer_transitions_component_test.ts
+++ b/tools/winscope/src/viewers/viewer_transitions/viewer_transitions_component_test.ts
@@ -13,207 +13,98 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-import {ClipboardModule} from '@angular/cdk/clipboard';
-import {
-  CdkVirtualScrollViewport,
-  ScrollingModule,
-} from '@angular/cdk/scrolling';
-import {
-  ComponentFixture,
-  ComponentFixtureAutoDetect,
-  TestBed,
-} from '@angular/core/testing';
-import {FormsModule} from '@angular/forms';
-import {MatButtonModule} from '@angular/material/button';
-import {MatDividerModule} from '@angular/material/divider';
-import {MatFormFieldModule} from '@angular/material/form-field';
-import {MatIconModule} from '@angular/material/icon';
-import {MatInputModule} from '@angular/material/input';
-import {MatSelectModule} from '@angular/material/select';
-import {BrowserAnimationsModule} from '@angular/platform-browser/animations';
-import {assertDefined} from 'common/assert_utils';
+import {CdkVirtualScrollViewport} from '@angular/cdk/scrolling';
 import {TimestampConverterUtils} from 'common/time/test_utils';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
+import {HierarchyTreeBuilder} from 'test/unit/hierarchy_tree_builder';
 import {PropertyTreeBuilder} from 'test/unit/property_tree_builder';
 import {TraceBuilder} from 'test/unit/trace_builder';
-import {UnitTestUtils} from 'test/unit/utils';
-import {Trace, TraceEntry} from 'trace/trace';
+import {TraceEntry} from 'trace/trace';
 import {TraceType} from 'trace/trace_type';
-import {PropertyTreeNode} from 'trace/tree_node/property_tree_node';
+import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
+import {AbstractLogViewerComponentTest} from 'viewers/common/abstract_log_viewer_component_test';
 import {LogSelectFilter} from 'viewers/common/log_filters';
-import {executeScrollComponentTests} from 'viewers/common/scroll_component_tests';
 import {LogHeader} from 'viewers/common/ui_data_log';
-import {CollapsedSectionsComponent} from 'viewers/components/collapsed_sections_component';
-import {CollapsibleSectionTitleComponent} from 'viewers/components/collapsible_section_title_component';
-import {LogComponent} from 'viewers/components/log_component';
-import {PropertiesComponent} from 'viewers/components/properties_component';
-import {PropertyTreeNodeDataViewComponent} from 'viewers/components/property_tree_node_data_view_component';
-import {SearchBoxComponent} from 'viewers/components/search_box_component';
-import {SelectWithFilterComponent} from 'viewers/components/select_with_filter_component';
-import {TreeComponent} from 'viewers/components/tree_component';
-import {TreeNodeComponent} from 'viewers/components/tree_node_component';
-import {TransitionsScrollDirective} from './scroll_strategy/transitions_scroll_directive';
 import {TransitionsEntry, UiData} from './ui_data';
 import {ViewerTransitionsComponent} from './viewer_transitions_component';
 
-describe('ViewerTransitionsComponent', () => {
-  const testSpec = {name: 'Test Column', cssClass: 'test-class'};
-  const testField = {spec: testSpec, value: 'VALUE'};
-  let transitionTree: PropertyTreeNode;
-  let trace: Trace<PropertyTreeNode>;
-  let entry: TraceEntry<PropertyTreeNode>;
-  let fixture: ComponentFixture<ViewerTransitionsComponent>;
-  let component: ViewerTransitionsComponent;
-  let htmlElement: HTMLElement;
-
-  beforeAll(() => {
-    transitionTree = new PropertyTreeBuilder()
-      .setIsRoot(true)
-      .setRootId('TransitionTraceEntry')
-      .setName('transition')
-      .build();
-    trace = new TraceBuilder<PropertyTreeNode>()
-      .setType(TraceType.TRANSITION)
-      .setEntries([transitionTree])
-      .setTimestamps([TimestampConverterUtils.makeElapsedTimestamp(20n)])
-      .build();
-    entry = trace.getEntry(0);
-  });
-
-  describe('Main component', () => {
-    beforeEach(async () => {
-      await setUpTestEnvironment();
-    });
-
-    it('can be created', () => {
-      expect(component).toBeTruthy();
-    });
-
-    it('renders headers with filters', () => {
-      expect(
-        htmlElement.querySelector(
-          `.headers .filter.${testSpec.cssClass.split(' ')[0]}`,
-        ),
-      ).toBeTruthy();
-    });
-
-    it('renders entries with field values and no trace timestamp', () => {
-      expect(htmlElement.querySelector('.scroll')).toBeTruthy();
-      const entry = assertDefined(
-        htmlElement.querySelector(
-          `.scroll .entry .${testSpec.cssClass.split(' ')[0]}`,
-        ),
-      );
-      expect(entry.textContent).toContain('VALUE');
-      expect(htmlElement.querySelector('.scroll .entry .time')).toBeNull();
-    });
-
-    it('hides go to current time button', () => {
-      expect(htmlElement.querySelector('.go-to-current-time')).toBeNull();
-    });
-
-    it('renders properties', () => {
-      expect(htmlElement.querySelector('.properties-view')).toBeTruthy();
-    });
+class ViewerTransitionsComponentTest extends AbstractLogViewerComponentTest<ViewerTransitionsComponent> {
+  protected override readonly testProperties = true;
+  protected override readonly hasCurrentTimeButton = false;
+  protected override readonly testScroll = true;
+  protected override readonly propertiesSectionTitle = 'SELECTED TRANSITION';
+  protected override readonly propertiesPlaceholder =
+    'No current or selected transition.';
 
-    it('shows message when no transition is selected', () => {
-      assertDefined(component.inputData).propertiesTree = undefined;
-      fixture.detectChanges();
-      expect(
-        htmlElement.querySelector('.properties-view .placeholder-text')
-          ?.innerHTML,
-      ).toContain('No current or selected transition');
-    });
+  private readonly transitionTree = new HierarchyTreeBuilder()
+    .setId('TransitionTraceEntry')
+    .setName('transition')
+    .build();
 
-    it('creates collapsed sections with no buttons', () => {
-      UnitTestUtils.checkNoCollapsedSectionButtons(htmlElement);
-    });
+  private readonly transitionProperties = new PropertyTreeBuilder()
+    .setIsRoot(true)
+    .setRootId('TransitionTraceEntry')
+    .setName('transition')
+    .build();
 
-    it('handles properties section collapse/expand', () => {
-      UnitTestUtils.checkSectionCollapseAndExpand(
-        htmlElement,
-        fixture,
-        '.properties-view',
-        'SELECTED TRANSITION',
-      );
-    });
-  });
-
-  describe('Scroll component', () => {
-    executeScrollComponentTests(setUpTestEnvironment);
-  });
+  protected override checkTimestampInTable(
+    dom: DOMTestHelper<ViewerTransitionsComponent>,
+  ): void {
+    expect(dom.find('.scroll .entry .time')).toBeUndefined();
+  }
 
-  async function setUpTestEnvironment(): Promise<
+  protected async setUpTestEnvironment(): Promise<
     [
-      ComponentFixture<ViewerTransitionsComponent>,
-      HTMLElement,
+      DOMTestHelper<ViewerTransitionsComponent>,
       CdkVirtualScrollViewport,
+      ViewerTransitionsComponent,
     ]
   > {
-    await TestBed.configureTestingModule({
-      providers: [{provide: ComponentFixtureAutoDetect, useValue: true}],
-      imports: [
-        MatDividerModule,
-        ScrollingModule,
-        MatIconModule,
-        ClipboardModule,
-        MatFormFieldModule,
-        MatButtonModule,
-        MatInputModule,
-        BrowserAnimationsModule,
-        FormsModule,
-        MatSelectModule,
-      ],
-      declarations: [
-        ViewerTransitionsComponent,
-        TreeComponent,
-        TreeNodeComponent,
-        PropertyTreeNodeDataViewComponent,
-        PropertiesComponent,
-        CollapsedSectionsComponent,
-        CollapsibleSectionTitleComponent,
-        LogComponent,
-        SearchBoxComponent,
-        TransitionsScrollDirective,
-        SelectWithFilterComponent,
-      ],
-    }).compileComponents();
-    fixture = TestBed.createComponent(ViewerTransitionsComponent);
-    component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
-    component.inputData = makeUiData();
-    fixture.detectChanges();
-    const viewport = assertDefined(component.logComponent?.scrollComponent);
-    return [fixture, htmlElement, viewport];
-  }
+    const trace = new TraceBuilder<HierarchyTreeNode>()
+      .setType(TraceType.TRANSITION)
+      .setEntries([this.transitionTree])
+      .setTimestamps([TimestampConverterUtils.makeElapsedTimestamp(20n)])
+      .build();
+    const entry = trace.getEntry(0);
 
-  function makeUiData(): UiData {
     const transitions = [];
     for (let i = 0; i < 200; i++) {
-      transitions.push(createMockTransition(entry, i));
+      transitions.push(this.createMockTransition(entry, i));
     }
     const uiData = UiData.createEmpty();
-    uiData.headers = [new LogHeader(testSpec, new LogSelectFilter([]))];
+    uiData.headers = [new LogHeader(this.testSpec, new LogSelectFilter([]))];
     uiData.entries = transitions;
     uiData.selectedIndex = 0;
-    return uiData;
+
+    return await this.initializeTestEnvironment(
+      uiData,
+      ViewerTransitionsComponent,
+    );
   }
 
-  function createMockTransition(
-    entry: TraceEntry<PropertyTreeNode>,
+  private createMockTransition(
+    entry: TraceEntry<HierarchyTreeNode>,
     i: number,
   ): TransitionsEntry {
     return new TransitionsEntry(
       entry,
       [
-        testField,
-        testField,
-        testField,
-        testField,
-        testField,
-        testField,
-        {spec: testSpec, value: i % 2 === 0 ? 'VALUE' : 'VALUE'.repeat(40)},
+        this.testField,
+        this.testField,
+        this.testField,
+        this.testField,
+        this.testField,
+        this.testField,
+        {
+          spec: this.testSpec,
+          value: i % 2 === 0 ? 'VALUE' : 'VALUE'.repeat(40),
+        },
       ],
-      transitionTree,
+      async () => this.transitionProperties,
     );
   }
+}
+
+describe('ViewerTransitionsComponent', () => {
+  new ViewerTransitionsComponentTest().execute();
 });
diff --git a/tools/winscope/src/viewers/viewer_view_capture/presenter_test.ts b/tools/winscope/src/viewers/viewer_view_capture/presenter_test.ts
index cdd8959c6..94045535f 100644
--- a/tools/winscope/src/viewers/viewer_view_capture/presenter_test.ts
+++ b/tools/winscope/src/viewers/viewer_view_capture/presenter_test.ts
@@ -21,12 +21,18 @@ import {
   TabbedViewSwitchRequest,
   TracePositionUpdate,
 } from 'messaging/winscope_event';
+import {
+  getFixtureFile,
+  getPerfettoParser,
+  LegacyParserProvider,
+} from 'test/unit/fixture_utils';
 import {TraceBuilder} from 'test/unit/trace_builder';
-import {UnitTestUtils} from 'test/unit/utils';
+import {makeEmptyTrace} from 'test/unit/trace_utils';
 import {CustomQueryType} from 'trace/custom_query';
 import {Parser} from 'trace/parser';
 import {Trace} from 'trace/trace';
 import {Traces} from 'trace/traces';
+import {TraceFile} from 'trace/trace_file';
 import {TRACE_INFO} from 'trace/trace_info';
 import {TraceType} from 'trace/trace_type';
 import {HierarchyTreeNode} from 'trace/tree_node/hierarchy_tree_node';
@@ -50,7 +56,7 @@ class PresenterViewCaptureTest extends AbstractHierarchyViewerPresenterTest<UiDa
   override readonly shouldExecuteRectTests = true;
   override readonly shouldExecuteSimplifyNamesTest = true;
   override readonly keepCalculatedPropertiesInChild = false;
-  override readonly keepCalculatedPropertiesInRoot = true;
+  override readonly keepCalculatedPropertiesInRoot = false;
   override readonly expectedHierarchyOpts = {
     showDiff: {
       name: 'Show diff',
@@ -94,6 +100,7 @@ the default for its data type.`,
     },
   };
 
+  override readonly rectIndex = 9;
   override readonly expectedInitialRectSpec = {
     type: TraceRectType.VIEWS,
     icon: TRACE_INFO[TraceType.VIEW_CAPTURE].icon,
@@ -121,45 +128,39 @@ the default for its data type.`,
     ],
   };
   override readonly treeNodeLongName =
-    'com.android.launcher3.taskbar.TaskbarView@80213537';
-  override readonly treeNodeShortName = 'TaskbarView@80213537';
+    'com.google.android.apps.nexuslauncher.allapps.SearchContainerView@53568094';
+  override readonly treeNodeShortName = 'SearchContainerView@53568094';
 
   override async setUpTestEnvironment(): Promise<void> {
-    const parsers = (await UnitTestUtils.getParsers(
-      'traces/elapsed_and_real_timestamp/com.google.android.apps.nexuslauncher_0.vc',
-    )) as Array<Parser<HierarchyTreeNode>>;
+    const parser = (await getPerfettoParser(
+      TraceType.VIEW_CAPTURE,
+      'traces/perfetto/viewcapture.perfetto-trace',
+    )) as Parser<HierarchyTreeNode>;
 
+    const trace = Trace.fromParser(parser);
     this.traces = new Traces();
-    for (const parser of parsers) {
-      this.traces.addTrace(Trace.fromParser(parser));
-    }
+    this.traces.addTrace(trace);
 
-    const traceTaskbar = assertDefined(
-      this.traces.getTraces(TraceType.VIEW_CAPTURE)[0],
-    );
-    const firstEntry = traceTaskbar.getEntry(0);
+    const firstEntry = trace.getEntry(0);
     this.positionUpdate = TracePositionUpdate.fromTraceEntry(firstEntry);
 
-    const traceLauncherActivity = assertDefined(
-      this.traces.getTraces(TraceType.VIEW_CAPTURE)[1],
-    );
-    const firstEntryLauncherActivity = traceLauncherActivity.getEntry(0);
     this.secondPositionUpdate = TracePositionUpdate.fromTraceEntry(
-      firstEntryLauncherActivity,
+      trace.getEntry(1),
     );
 
     const firstEntryDataTree = await firstEntry.getValue();
+
     this.selectedTree = UiHierarchyTreeNode.from(
       assertDefined(
         firstEntryDataTree
           .findDfs(
             UiTreeUtils.makeIdMatchFilter(
-              'ViewNode com.android.launcher3.taskbar.TaskbarView@80213537',
+              'ViewNode44 ' + this.treeNodeLongName,
             ),
           )
           ?.getParent(),
       ),
-    ).getChildByName('com.android.launcher3.taskbar.TaskbarView@80213537');
+    ).getChildByName(this.treeNodeLongName);
   }
 
   override createPresenterWithEmptyTrace(
@@ -207,24 +208,30 @@ the default for its data type.`,
       assertDefined(
         propertiesTree.getChildByName('translationY'),
       ).formattedValue(),
-    ).toEqual('-0.633');
+    ).toEqual('786.506');
+    expect(propertiesTree.getChildByName('translationX')).toBeUndefined();
     expect(uiData.displays).toEqual([
-      {displayId: 0, groupId: 0, name: 'Taskbar', isActive: true},
-      {displayId: 1, groupId: 1, name: 'PhoneWindow@25063d9', isActive: true},
+      {displayId: 0, groupId: 0, name: 'PhoneWindow@4f9be60', isActive: true},
     ]);
-    expect(
-      assertDefined((uiData as UiData).curatedProperties).translationY,
-    ).toEqual('-0.633');
+    const curatedProperties = assertDefined(
+      (uiData as UiData).curatedProperties,
+    );
+    expect(curatedProperties.translationY).toEqual('786.506');
+    expect(curatedProperties.translationX).toEqual('0');
   }
 
   override executePropertiesChecksAfterSecondPositionUpdate(
     uiData: UiDataHierarchy,
   ) {
     const propertiesTree = assertDefined(uiData.propertiesTree);
-    expect(propertiesTree.getChildByName('translationY')).toBeUndefined();
+    expect(
+      assertDefined(
+        propertiesTree.getChildByName('translationY'),
+      ).formattedValue(),
+    ).toEqual('785.500');
     expect(
       assertDefined((uiData as UiData).curatedProperties).translationY,
-    ).toEqual('0');
+    ).toEqual('785.500');
   }
 
   override executeSpecializedChecksForPropertiesFromRect(
@@ -233,10 +240,10 @@ the default for its data type.`,
     const curatedProperties = assertDefined(
       (uiData as UiData).curatedProperties,
     );
-    expect(curatedProperties.translationX).toEqual('233.075');
-    expect(curatedProperties.translationY).toEqual('81');
-    expect(curatedProperties.alpha).toEqual('1');
-    expect(curatedProperties.willNotDraw).toEqual('false');
+    expect(curatedProperties.translationX).toEqual('-9.800');
+    expect(curatedProperties.translationY).toEqual('210.700');
+    expect(curatedProperties.alpha).toEqual('0');
+    expect(curatedProperties.willNotDraw).toEqual('true');
   }
 
   override executeSpecializedTests() {
@@ -269,8 +276,8 @@ the default for its data type.`,
       it('exposes all VC traces', () => {
         const traces = new Traces();
         const vcTraces = [
-          UnitTestUtils.makeEmptyTrace(TraceType.VIEW_CAPTURE),
-          UnitTestUtils.makeEmptyTrace(TraceType.VIEW_CAPTURE),
+          makeEmptyTrace(TraceType.VIEW_CAPTURE),
+          makeEmptyTrace(TraceType.VIEW_CAPTURE),
         ];
         vcTraces.forEach((trace) => traces.addTrace(trace));
         const notifyViewCallback = (newData: UiData) => {
@@ -285,28 +292,36 @@ the default for its data type.`,
       });
 
       it('extracts rects from SF trace', async () => {
-        const sfTrace = new TraceBuilder<HierarchyTreeNode>()
-          .setType(TraceType.SURFACE_FLINGER)
-          .setEntries([await UnitTestUtils.getLayerTraceEntry(0)])
-          .build();
-        const presenter = createPresenterWithSfTrace(
+        const perfettoFile = new TraceFile(
+          await getFixtureFile('traces/perfetto/viewcapture.perfetto-trace'),
+        );
+        const sfTrace = Trace.fromParser(
+          await new LegacyParserProvider()
+            .addFilename('traces/elapsed_timestamp/SurfaceFlinger.pb')
+            .setExistingPerfettoFile(perfettoFile)
+            .setConvertToPerfetto(true)
+            .getParser<HierarchyTreeNode>(),
+        );
+        const presenterWithSfTrace = createPresenterWithSfTrace(
           assertDefined(this.traces),
           sfTrace,
         );
-        await presenter.onAppEvent(assertDefined(this.positionUpdate));
+        await presenterWithSfTrace.onAppEvent(
+          assertDefined(this.positionUpdate),
+        );
         expect(assertDefined(uiData.sfRects).length).toBeGreaterThan(0);
       });
 
       it('handles double click if SF trace present', async () => {
-        const sfTrace = UnitTestUtils.makeEmptyTrace(TraceType.SURFACE_FLINGER);
-        const presenter = createPresenterWithSfTrace(
+        const sfTrace = makeEmptyTrace(TraceType.SURFACE_FLINGER);
+        const presenterWithSfTrace = createPresenterWithSfTrace(
           assertDefined(this.traces),
           sfTrace,
         );
         const spy = jasmine.createSpy();
-        presenter.setEmitEvent(spy);
+        presenterWithSfTrace.setEmitEvent(spy);
 
-        await presenter.onMiniRectsDoubleClick();
+        await presenterWithSfTrace.onMiniRectsDoubleClick();
         expect(spy).toHaveBeenCalledOnceWith(
           new TabbedViewSwitchRequest(sfTrace),
         );
@@ -320,13 +335,14 @@ the default for its data type.`,
       });
 
       it('clears curated properties on position update if no properties tree found', async () => {
-        await presenter.onAppEvent(assertDefined(this.secondPositionUpdate));
-        const nodeName = 'com.android.internal.policy.DecorView@220010144';
+        await presenter.onAppEvent(assertDefined(this.positionUpdate));
+        const nodeName =
+          'com.android.launcher3.allapps.AllAppsRecyclerView@188184411';
         await presenter.onHighlightedIdChange(nodeName);
         expect(uiData.propertiesTree).toBeDefined();
         expect(uiData.curatedProperties).toBeDefined();
 
-        await presenter.onAppEvent(assertDefined(this.positionUpdate));
+        await presenter.onAppEvent(assertDefined(this.secondPositionUpdate));
         expect(uiData.propertiesTree).toBeUndefined();
         expect(uiData.curatedProperties).toBeUndefined();
       });
diff --git a/tools/winscope/src/viewers/viewer_view_capture/viewer_view_capture_component_test.ts b/tools/winscope/src/viewers/viewer_view_capture/viewer_view_capture_component_test.ts
index 3ac24e8fd..9d1304103 100644
--- a/tools/winscope/src/viewers/viewer_view_capture/viewer_view_capture_component_test.ts
+++ b/tools/winscope/src/viewers/viewer_view_capture/viewer_view_capture_component_test.ts
@@ -14,113 +14,23 @@
  * limitations under the License.
  */
 
-import {HttpClientModule} from '@angular/common/http';
-import {CUSTOM_ELEMENTS_SCHEMA} from '@angular/core';
-import {
-  ComponentFixture,
-  ComponentFixtureAutoDetect,
-  TestBed,
-} from '@angular/core/testing';
-import {FormsModule} from '@angular/forms';
-import {MatButtonModule} from '@angular/material/button';
-import {MatDividerModule} from '@angular/material/divider';
-import {MatFormFieldModule} from '@angular/material/form-field';
-import {MatIconModule} from '@angular/material/icon';
-import {MatInputModule} from '@angular/material/input';
-import {MatSelectModule} from '@angular/material/select';
-import {MatTooltipModule} from '@angular/material/tooltip';
-import {BrowserAnimationsModule} from '@angular/platform-browser/animations';
-import {UnitTestUtils} from 'test/unit/utils';
-import {CollapsedSectionsComponent} from 'viewers/components/collapsed_sections_component';
-import {CollapsibleSectionTitleComponent} from 'viewers/components/collapsible_section_title_component';
-import {HierarchyComponent} from 'viewers/components/hierarchy_component';
-import {PropertiesComponent} from 'viewers/components/properties_component';
-import {RectsComponent} from 'viewers/components/rects/rects_component';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
+import {AbstractHierarchyViewerComponentTest} from 'viewers/common/abstract_hierarchy_viewer_component_test';
 import {ViewerViewCaptureComponent} from './viewer_view_capture_component';
 
-describe('ViewerViewCaptureComponent', () => {
-  let fixture: ComponentFixture<ViewerViewCaptureComponent>;
-  let component: ViewerViewCaptureComponent;
-  let htmlElement: HTMLElement;
-
-  beforeEach(async () => {
-    await TestBed.configureTestingModule({
-      providers: [{provide: ComponentFixtureAutoDetect, useValue: true}],
-      imports: [
-        MatIconModule,
-        MatDividerModule,
-        MatTooltipModule,
-        MatButtonModule,
-        MatInputModule,
-        MatFormFieldModule,
-        FormsModule,
-        BrowserAnimationsModule,
-        MatSelectModule,
-        HttpClientModule,
-      ],
-      declarations: [
-        ViewerViewCaptureComponent,
-        HierarchyComponent,
-        PropertiesComponent,
-        RectsComponent,
-        CollapsedSectionsComponent,
-        CollapsibleSectionTitleComponent,
-      ],
-      schemas: [CUSTOM_ELEMENTS_SCHEMA],
-    }).compileComponents();
-    fixture = TestBed.createComponent(ViewerViewCaptureComponent);
-    component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
-    fixture.detectChanges();
-  });
-
-  it('can be created', () => {
-    expect(component).toBeTruthy();
-  });
-
-  it('creates rects view', () => {
-    const rectsView = htmlElement.querySelector('.rects-view');
-    expect(rectsView).toBeTruthy();
-  });
-
-  it('creates hierarchy view', () => {
-    const hierarchyView = htmlElement.querySelector('.hierarchy-view');
-    expect(hierarchyView).toBeTruthy();
-  });
+class ViewerViewCaptureComponentTest extends AbstractHierarchyViewerComponentTest<ViewerViewCaptureComponent> {
+  protected override readonly testRects = true;
+  protected override readonly hierarchyTitle = 'HIERARCHY';
+  protected override readonly propertiesTitle = 'PROPERTIES';
+  protected override readonly rectsTitle = 'SKETCH';
 
-  it('creates properties view', () => {
-    const propertiesView = htmlElement.querySelector('.properties-view');
-    expect(propertiesView).toBeTruthy();
-  });
+  protected async setUpTestEnvironment(): Promise<
+    [DOMTestHelper<ViewerViewCaptureComponent>, ViewerViewCaptureComponent]
+  > {
+    return this.initializeTestEnvironment(ViewerViewCaptureComponent);
+  }
+}
 
-  it('creates collapsed sections with no buttons', () => {
-    UnitTestUtils.checkNoCollapsedSectionButtons(htmlElement);
-  });
-
-  it('handles rects section collapse/expand', () => {
-    UnitTestUtils.checkSectionCollapseAndExpand(
-      htmlElement,
-      fixture,
-      '.rects-view',
-      'SKETCH',
-    );
-  });
-
-  it('handles hierarchy section collapse/expand', () => {
-    UnitTestUtils.checkSectionCollapseAndExpand(
-      htmlElement,
-      fixture,
-      '.hierarchy-view',
-      'HIERARCHY',
-    );
-  });
-
-  it('handles properties section collapse/expand', () => {
-    UnitTestUtils.checkSectionCollapseAndExpand(
-      htmlElement,
-      fixture,
-      '.properties-view',
-      'PROPERTIES',
-    );
-  });
+describe('ViewerViewCaptureComponent', () => {
+  new ViewerViewCaptureComponentTest().execute();
 });
diff --git a/tools/winscope/src/viewers/viewer_window_manager/presenter_test.ts b/tools/winscope/src/viewers/viewer_window_manager/presenter_test.ts
index c4ea5ce28..1e1d32bc3 100644
--- a/tools/winscope/src/viewers/viewer_window_manager/presenter_test.ts
+++ b/tools/winscope/src/viewers/viewer_window_manager/presenter_test.ts
@@ -18,9 +18,10 @@ import {assertDefined} from 'common/assert_utils';
 import {InMemoryStorage} from 'common/store/in_memory_storage';
 import {Store} from 'common/store/store';
 import {TracePositionUpdate} from 'messaging/winscope_event';
+import {getWindowManagerState} from 'test/unit/fixture_utils';
 import {TraceBuilder} from 'test/unit/trace_builder';
+import {makeEmptyTrace} from 'test/unit/trace_utils';
 import {TreeNodeUtils} from 'test/unit/tree_node_utils';
-import {UnitTestUtils} from 'test/unit/utils';
 import {Trace} from 'trace/trace';
 import {Traces} from 'trace/traces';
 import {TRACE_INFO} from 'trace/trace_info';
@@ -96,6 +97,7 @@ the default for its data type.`,
     },
   };
 
+  override readonly rectIndex = 2;
   override readonly expectedInitialRectSpec = {
     type: TraceRectType.WINDOW_STATES,
     icon: TRACE_INFO[TraceType.WINDOW_MANAGER].icon,
@@ -131,8 +133,8 @@ the default for its data type.`,
     this.trace = new TraceBuilder<HierarchyTreeNode>()
       .setType(TraceType.WINDOW_MANAGER)
       .setEntries([
-        await UnitTestUtils.getWindowManagerState(0),
-        await UnitTestUtils.getWindowManagerState(1),
+        await getWindowManagerState(0),
+        await getWindowManagerState(1),
       ])
       .build();
 
@@ -166,7 +168,7 @@ the default for its data type.`,
   override createPresenterWithEmptyTrace(
     callback: NotifyHierarchyViewCallbackType<UiData>,
   ): Presenter {
-    const trace = UnitTestUtils.makeEmptyTrace(TraceType.WINDOW_MANAGER);
+    const trace = makeEmptyTrace(TraceType.WINDOW_MANAGER);
     const traces = new Traces();
     traces.addTrace(trace);
     return new Presenter(trace, traces, new InMemoryStorage(), callback);
@@ -284,7 +286,6 @@ the default for its data type.`,
           TreeNodeUtils.makeUiPropertyNode('', 'hashCode', 32720206),
         );
         await presenter.onAppEvent(this.getPositionUpdate());
-        console.log(uiData.hierarchyTrees?.at(0)?.getAllChildren()[0].id);
         await presenter.onPropagatePropertyClick(validHashcode);
         expect(uiData.highlightedItem).toEqual(
           'DisplayContent 1f3454e Built-in Screen',
diff --git a/tools/winscope/src/viewers/viewer_window_manager/viewer_window_manager_component_test.ts b/tools/winscope/src/viewers/viewer_window_manager/viewer_window_manager_component_test.ts
index 297ea7068..baa5d3af7 100644
--- a/tools/winscope/src/viewers/viewer_window_manager/viewer_window_manager_component_test.ts
+++ b/tools/winscope/src/viewers/viewer_window_manager/viewer_window_manager_component_test.ts
@@ -14,108 +14,23 @@
  * limitations under the License.
  */
 
-import {HttpClientModule} from '@angular/common/http';
-import {CUSTOM_ELEMENTS_SCHEMA} from '@angular/core';
-import {ComponentFixture, TestBed} from '@angular/core/testing';
-import {FormsModule} from '@angular/forms';
-import {MatButtonModule} from '@angular/material/button';
-import {MatDividerModule} from '@angular/material/divider';
-import {MatFormFieldModule} from '@angular/material/form-field';
-import {MatIconModule} from '@angular/material/icon';
-import {MatInputModule} from '@angular/material/input';
-import {MatSelectModule} from '@angular/material/select';
-import {MatTooltipModule} from '@angular/material/tooltip';
-import {BrowserAnimationsModule} from '@angular/platform-browser/animations';
-import {UnitTestUtils} from 'test/unit/utils';
-import {CollapsedSectionsComponent} from 'viewers/components/collapsed_sections_component';
-import {CollapsibleSectionTitleComponent} from 'viewers/components/collapsible_section_title_component';
-import {HierarchyComponent} from 'viewers/components/hierarchy_component';
-import {PropertiesComponent} from 'viewers/components/properties_component';
-import {RectsComponent} from 'viewers/components/rects/rects_component';
+import {DOMTestHelper} from 'test/unit/dom_test_utils';
+import {AbstractHierarchyViewerComponentTest} from 'viewers/common/abstract_hierarchy_viewer_component_test';
 import {ViewerWindowManagerComponent} from './viewer_window_manager_component';
 
-describe('ViewerWindowManagerComponent', () => {
-  let fixture: ComponentFixture<ViewerWindowManagerComponent>;
-  let component: ViewerWindowManagerComponent;
-  let htmlElement: HTMLElement;
-
-  beforeEach(async () => {
-    await TestBed.configureTestingModule({
-      imports: [
-        MatIconModule,
-        MatDividerModule,
-        MatTooltipModule,
-        MatButtonModule,
-        MatInputModule,
-        MatFormFieldModule,
-        FormsModule,
-        BrowserAnimationsModule,
-        MatSelectModule,
-        HttpClientModule,
-      ],
-      declarations: [
-        ViewerWindowManagerComponent,
-        HierarchyComponent,
-        PropertiesComponent,
-        RectsComponent,
-        CollapsedSectionsComponent,
-        CollapsibleSectionTitleComponent,
-      ],
-      schemas: [CUSTOM_ELEMENTS_SCHEMA],
-    }).compileComponents();
-    fixture = TestBed.createComponent(ViewerWindowManagerComponent);
-    component = fixture.componentInstance;
-    htmlElement = fixture.nativeElement;
-    fixture.detectChanges();
-  });
-
-  it('can be created', () => {
-    expect(component).toBeTruthy();
-  });
-
-  it('creates rects view', () => {
-    const rectsView = htmlElement.querySelector('.rects-view');
-    expect(rectsView).toBeTruthy();
-  });
-
-  it('creates hierarchy view', () => {
-    const hierarchyView = htmlElement.querySelector('.hierarchy-view');
-    expect(hierarchyView).toBeTruthy();
-  });
+class ViewerWindowManagerComponentTest extends AbstractHierarchyViewerComponentTest<ViewerWindowManagerComponent> {
+  protected override readonly testRects = true;
+  protected override readonly hierarchyTitle = 'HIERARCHY';
+  protected override readonly propertiesTitle = 'PROPERTIES';
+  protected override readonly rectsTitle = 'WINDOWS';
 
-  it('creates properties view', () => {
-    const propertiesView = htmlElement.querySelector('.properties-view');
-    expect(propertiesView).toBeTruthy();
-  });
+  protected async setUpTestEnvironment(): Promise<
+    [DOMTestHelper<ViewerWindowManagerComponent>, ViewerWindowManagerComponent]
+  > {
+    return this.initializeTestEnvironment(ViewerWindowManagerComponent);
+  }
+}
 
-  it('creates collapsed sections with no buttons', () => {
-    UnitTestUtils.checkNoCollapsedSectionButtons(htmlElement);
-  });
-
-  it('handles rects section collapse/expand', () => {
-    UnitTestUtils.checkSectionCollapseAndExpand(
-      htmlElement,
-      fixture,
-      '.rects-view',
-      'WINDOWS',
-    );
-  });
-
-  it('handles hierarchy section collapse/expand', () => {
-    UnitTestUtils.checkSectionCollapseAndExpand(
-      htmlElement,
-      fixture,
-      '.hierarchy-view',
-      'HIERARCHY',
-    );
-  });
-
-  it('handles properties section collapse/expand', () => {
-    UnitTestUtils.checkSectionCollapseAndExpand(
-      htmlElement,
-      fixture,
-      '.properties-view',
-      'PROPERTIES',
-    );
-  });
+describe('ViewerWindowManagerComponent', () => {
+  new ViewerWindowManagerComponentTest().execute();
 });
diff --git a/tools/winscope/webpack.config.dev.js b/tools/winscope/webpack.config.dev.js
index 2c4ee741d..c343e651a 100644
--- a/tools/winscope/webpack.config.dev.js
+++ b/tools/winscope/webpack.config.dev.js
@@ -48,6 +48,7 @@ const configDev = {
     new CopyPlugin({
       patterns: [
         'deps_build/trace_processor/to_be_served/trace_processor.wasm',
+        'deps_build/trace_processor/to_be_served/trace_processor_memory64.wasm',
         'deps_build/trace_processor/to_be_served/engine_bundle.js',
         {from: 'src/adb/winscope_proxy.py', to: 'winscope_proxy.py'},
         {from: 'src/logo_light_mode.svg', to: 'logo_light_mode.svg'},
diff --git a/vndk/tools/header-checker/Documentation/Development.md b/vndk/tools/header-checker/Documentation/Development.md
index e9dc6c282..4588f1d4c 100644
--- a/vndk/tools/header-checker/Documentation/Development.md
+++ b/vndk/tools/header-checker/Documentation/Development.md
@@ -1,35 +1,19 @@
 # Development
 
-## Checkout source tree
-
-To checkout the source tree, run the following commands:
-
-    $ mkdir aosp-clang-tools
-
-    $ cd aosp-clang-tools
-
-    $ repo init \
-          -u https://android.googlesource.com/platform/manifest \
-          -b clang-tools
-
-    $ repo sync
-
-
 ## Build instructions
 
-To build `header-abi-dumper`, `header-abi-linker` and `header-abi-diff`:
+For Googlers, check out go/repo-init/main-clang-tools and run:
 
     $ OUT_DIR=out \
           development/vndk/tools/header-checker/android/build-prebuilts.sh
 
-
 ## Alternative build instructions
 
 If you have a full source tree, you may build the tools with:
 
     $ source build/envsetup.sh
 
-    $ lunch aosp_arm64-userdebug
+    $ lunch aosp_arm64-trunk_staging-userdebug
 
     $ cd development/vndk/tools/header-checker
 
diff --git a/vndk/tools/sourcedr/ninja/ninja.py b/vndk/tools/sourcedr/ninja/ninja.py
index 17291eceb..5ddc72bbd 100755
--- a/vndk/tools/sourcedr/ninja/ninja.py
+++ b/vndk/tools/sourcedr/ninja/ninja.py
@@ -207,7 +207,7 @@ class EvalStringBuilder(object):
 class Build(object):
     __slots__ = ('explicit_outs', 'implicit_outs', 'rule', 'explicit_ins',
                  'implicit_ins', 'prerequisites', 'bindings',
-                 'depfile_implicit_ins')
+                 'depfile_implicit_ins', 'validations')
 
 
 class Rule(object):
@@ -236,13 +236,14 @@ class TK(object):
     ESC_NEWLINE = 4
     IDENT = 5
     PIPE2 = 6
-    PIPE = 7
-    COLON = 8
-    ASSIGN = 9
+    PIPEAT = 7
+    PIPE = 8
+    COLON = 9
+    ASSIGN = 10
 
     # Non-trivial tokens
-    PATH = 10
-    STRING = 11
+    PATH = 11
+    STRING = 12
 
 
 class TokenMatcher(object):
@@ -340,6 +341,7 @@ class Lexer(object):
         (TK.ESC_NEWLINE, r'\$[\r\n]'),
         (TK.IDENT, r'[\w_.-]+'),
         (TK.PIPE2, r'\|\|'),
+        (TK.PIPEAT, r'\|@'),
         (TK.PIPE, r'\|'),
         (TK.COLON, r':'),
         (TK.ASSIGN, r'='),
@@ -709,13 +711,13 @@ class Parser(object):
 
         # Parse explicit ins
         explicit_ins = self._parse_path_list(
-                {TK.PIPE, TK.PIPE2, TK.NEWLINE, TK.EOF})
+                {TK.PIPE, TK.PIPE2, TK.PIPEAT, TK.NEWLINE, TK.EOF})
 
         # Parse implicit ins
         token = self._lexer.peek()
         if token.kind == TK.PIPE:
             self._lexer.lex()
-            implicit_ins = self._parse_path_list({TK.PIPE2, TK.NEWLINE, TK.EOF})
+            implicit_ins = self._parse_path_list({TK.PIPE2, TK.PIPEAT, TK.NEWLINE, TK.EOF})
         else:
             implicit_ins = tuple()
 
@@ -723,10 +725,18 @@ class Parser(object):
         token = self._lexer.peek()
         if token.kind == TK.PIPE2:
             self._lexer.lex()
-            prerequisites = self._parse_path_list({TK.NEWLINE, TK.EOF})
+            prerequisites = self._parse_path_list({TK.PIPEAT, TK.NEWLINE, TK.EOF})
         else:
             prerequisites = tuple()
 
+        # parse validations
+        token = self._lexer.peek()
+        if token.kind == TK.PIPEAT:
+            self._lexer.lex()
+            validations = self._parse_path_list({TK.NEWLINE, TK.EOF})
+        else:
+            validations = tuple()
+
         self._lexer.lex_match({TK.NEWLINE, TK.EOF})
 
         # Parse local bindings
@@ -746,6 +756,7 @@ class Parser(object):
         build.explicit_ins = eval_path_strings(explicit_ins, env)
         build.implicit_ins = eval_path_strings(implicit_ins, env)
         build.prerequisites = eval_path_strings(prerequisites, env)
+        build.validations = eval_path_strings(validations, env)
         build.depfile_implicit_ins = tuple()
 
         self._builds.append(build)
diff --git a/vndk/tools/sourcedr/ninja/tests/test_ninja.py b/vndk/tools/sourcedr/ninja/tests/test_ninja.py
index 0c0560ce5..3534b3de8 100755
--- a/vndk/tools/sourcedr/ninja/tests/test_ninja.py
+++ b/vndk/tools/sourcedr/ninja/tests/test_ninja.py
@@ -346,6 +346,11 @@ class LexerTest(unittest.TestCase):
         tok = lexer.lex()
         self.assertEqual(ninja.TK.PIPE2, tok.kind)
 
+    def test_lex_pipeat(self):
+        lexer = ninja.Lexer(['|@'])
+        tok = lexer.lex()
+        self.assertEqual(ninja.TK.PIPEAT, tok.kind)
+
     def test_lex_non_trivial(self):
         lexer = ninja.Lexer(['$name'])
         with self.assertRaises(ninja.ParseError):
@@ -537,6 +542,8 @@ class ParserTest(unittest.TestCase):
         self.assertEqual('implicit_in2', build.implicit_ins[1])
         self.assertEqual('order_only1', build.prerequisites[0])
         self.assertEqual('order_only2', build.prerequisites[1])
+        self.assertEqual('validation1', build.validations[0])
+        self.assertEqual('validation2', build.validations[1])
 
         self.assertEqual(('t', '1',), build.bindings['a'])
         self.assertEqual(('t', '2',), build.bindings['b'])
diff --git a/vndk/tools/sourcedr/ninja/tests/testdata/build.ninja b/vndk/tools/sourcedr/ninja/tests/testdata/build.ninja
index 748899b00..08b62e1dd 100644
--- a/vndk/tools/sourcedr/ninja/tests/testdata/build.ninja
+++ b/vndk/tools/sourcedr/ninja/tests/testdata/build.ninja
@@ -1,3 +1,3 @@
-build explicit_out1 explicit_out2 | implicit_out1 implicit_out2 : phony explicit_in1 explicit_in2 | implicit_in1 implicit_in2 || order_only1 order_only2
+build explicit_out1 explicit_out2 | implicit_out1 implicit_out2 : phony explicit_in1 explicit_in2 | implicit_in1 implicit_in2 || order_only1 order_only2 |@ validation1 validation2
   a = 1
   b = 2
```

