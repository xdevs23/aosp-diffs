```diff
diff --git a/.classpath b/.classpath
index 74bf0f716..30d78a895 100644
--- a/.classpath
+++ b/.classpath
@@ -17,7 +17,6 @@
 	<classpathentry kind="src" path="global_configuration"/>
 	<classpathentry excluding="Android.bp" kind="src" path="device_build_interfaces"/>
 	<classpathentry combineaccessrules="false" exported="true" kind="src" path="/tf-remote-client"/>
-	<classpathentry combineaccessrules="false" kind="src" path="/ddmlib"/>
 	<classpathentry combineaccessrules="false" kind="src" path="/loganalysis"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER">
 		<attributes>
@@ -28,7 +27,7 @@
 	<classpathentry kind="var" path="TRADEFED_ROOT/prebuilts/misc/common/devtools-annotations/devtools-annotations-prebuilt.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/prebuilts/misc/common/kxml2/kxml2-2.3.0.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/prebuilts/misc/common/sdklib/sdklib-prebuilt.jar"/>
-	<classpathentry kind="var" path="TRADEFED_ROOT/external/error_prone/error_prone/error_prone_annotations-2.36.0.jar"/>
+	<classpathentry kind="var" path="TRADEFED_ROOT/external/error_prone/error_prone/error_prone_annotations-2.37.0.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/protobuf/libprotobuf-java-full/linux_glibc_common/javac/libprotobuf-java-full.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/junit-params/junit-params/linux_glibc_common/combined/junit-params.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/junit/junit/linux_glibc_common/combined/junit.jar"/>
@@ -64,5 +63,7 @@
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/auto/value/auto_value_annotations/linux_glibc_common/javac/auto_value_annotations.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/googleapis/google/bytestream/bytestream-java-grpc/linux_glibc_common/javac/bytestream-java-grpc.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/googleapis/google/bytestream/bytestream-java-proto/linux_glibc_common/combined/bytestream-java-proto.jar"/>
+	<classpathentry kind="var" path="TRADEFED_ROOT/platform_testing/libraries/androidbuildinternal/libandroid_build_v3_java.jar"/>
+	<classpathentry kind="var" path="TRADEFED_ROOT/platform_testing/libraries/androidbuildinternal/libandroid_build_v2beta1_java.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
diff --git a/Android.bp b/Android.bp
index f4d8b1369..318d1dac0 100644
--- a/Android.bp
+++ b/Android.bp
@@ -326,6 +326,8 @@ java_library_host {
         "grpc-java-netty-shaded",
         "opencensus-java-api",
         "opencensus-java-contrib-grpc-metrics",
+        "libandroid_build_v2beta1_java",
+        "libandroid_build_v3_java",
     ],
     libs: [
         "loganalysis",
diff --git a/avd_util/Android.bp b/avd_util/Android.bp
index 4729bd007..192c1693c 100644
--- a/avd_util/Android.bp
+++ b/avd_util/Android.bp
@@ -33,7 +33,6 @@ java_library_host {
         "gson",
     ],
     libs: [
-        "ddmlib-prebuilt",
         "json-prebuilt",
         "guava",
     ],
diff --git a/avd_util/com/android/tradefed/util/avd/HostOrchestratorClient.java b/avd_util/com/android/tradefed/util/avd/HostOrchestratorClient.java
index 2f42856a5..d462888d1 100644
--- a/avd_util/com/android/tradefed/util/avd/HostOrchestratorClient.java
+++ b/avd_util/com/android/tradefed/util/avd/HostOrchestratorClient.java
@@ -54,6 +54,24 @@ public class HostOrchestratorClient {
         public List<Cvd> cvds;
     }
 
+    public static final class CreateSnapshotRequest {
+        // Snapshot request must be as a json like {"snapshot_id" : "string"}.
+        public String snapshot_id;
+
+        CreateSnapshotRequest(String id) {
+            snapshot_id = id;
+        }
+    }
+
+    public static final class StartCVDRequest {
+        // Snapshot request must be as a json like {"snapshot_id" : "string"}.
+        public String snapshot_id;
+
+        StartCVDRequest(String id) {
+            snapshot_id = id;
+        }
+    }
+
     public static HttpRequest buildListCvdsRequest(String baseURL) {
         return HttpRequest.newBuilder().uri(URI.create(String.format("%s/cvds", baseURL))).build();
     }
@@ -97,6 +115,32 @@ public class HostOrchestratorClient {
                 .build();
     }
 
+    // https://github.com/google/android-cuttlefish/blob/fff7e3487c924435e6f6120345edf1dddb49d50b/frontend/src/host_orchestrator/orchestrator/controller.go#L73
+    public static HttpRequest buildStopInstanceRequest(String baseURL, String group, String name) {
+        return HttpRequest.newBuilder()
+                .uri(URI.create(String.format("%s/cvds/%s/%s/:stop", baseURL, group, name)))
+                .POST(java.net.http.HttpRequest.BodyPublishers.noBody())
+                .build();
+    }
+
+    // https://github.com/google/android-cuttlefish/blob/main/frontend/src/host_orchestrator/orchestrator/controller.go#L89
+    public static HttpRequest buildCreateSnapshotRequest(
+            String baseURL, String group, String name, CreateSnapshotRequest request) {
+        return HttpRequest.newBuilder()
+                .uri(URI.create(String.format("%s/cvds/%s/%s/snapshots", baseURL, group, name)))
+                .POST(java.net.http.HttpRequest.BodyPublishers.ofString(new Gson().toJson(request)))
+                .build();
+    }
+
+    // https://github.com/google/android-cuttlefish/blob/fff7e3487c924435e6f6120345edf1dddb49d50b/frontend/src/host_orchestrator/orchestrator/controller.go#L65
+    public static HttpRequest buildStartCvdRequest(
+            String baseURL, String group, String name, StartCVDRequest request) {
+        return HttpRequest.newBuilder()
+                .uri(URI.create(String.format("%s/cvds/%s/%s/:start", baseURL, group, name)))
+                .POST(java.net.http.HttpRequest.BodyPublishers.ofString(new Gson().toJson(request)))
+                .build();
+    }
+
     public static interface IHoHttpClient {
         HttpResponse<String> send(HttpRequest request)
                 throws IOException, InterruptedException, ErrorResponseException;
diff --git a/avd_util/com/android/tradefed/util/avd/HostOrchestratorUtil.java b/avd_util/com/android/tradefed/util/avd/HostOrchestratorUtil.java
index 756b13ac4..75c12a1d5 100644
--- a/avd_util/com/android/tradefed/util/avd/HostOrchestratorUtil.java
+++ b/avd_util/com/android/tradefed/util/avd/HostOrchestratorUtil.java
@@ -15,18 +15,23 @@
  */
 package com.android.tradefed.util.avd;
 
+import static com.android.tradefed.util.avd.HostOrchestratorClient.CreateSnapshotRequest;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.Cvd;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.ErrorResponseException;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.HoHttpClient;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.IHoHttpClient;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.ListCvdsResponse;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.Operation;
+import static com.android.tradefed.util.avd.HostOrchestratorClient.StartCVDRequest;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.buildCreateBugreportRequest;
+import static com.android.tradefed.util.avd.HostOrchestratorClient.buildCreateSnapshotRequest;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.buildGetOperationRequest;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.buildGetOperationResultRequest;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.buildListCvdsRequest;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.buildPowerwashRequest;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.buildRemoveInstanceRequest;
+import static com.android.tradefed.util.avd.HostOrchestratorClient.buildStartCvdRequest;
+import static com.android.tradefed.util.avd.HostOrchestratorClient.buildStopInstanceRequest;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.saveToFile;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.sendRequest;
 
@@ -148,12 +153,10 @@ public class HostOrchestratorUtil {
         File tempFile = null;
         try {
             tempFile = Files.createTempFile(logName, ".txt").toFile();
-            if (mUseOxygenation) {
-                if (mHOTunnel == null || !mHOTunnel.isAlive()) {
-                    CLog.e("Failed portforwarding Host Orchestrator tunnel.");
-                    FileUtil.deleteFile(tempFile);
-                    return null;
-                }
+            if (mUseOxygenation && (mHOTunnel == null || !mHOTunnel.isAlive())) {
+                CLog.e("Failed portforwarding Host Orchestrator tunnel.");
+                FileUtil.deleteFile(tempFile);
+                return null;
             }
             String baseUrl = getHOBaseUrl(mHOPortNumber);
             HttpRequest request =
@@ -169,22 +172,13 @@ public class HostOrchestratorUtil {
 
     /** Pull CF host logs via Host Orchestrator. */
     public File pullCvdHostLogs() {
-        // Basically, the rough processes to pull CF host logs are
-        // 1. Portforward CURL tunnel.
-        // 2. Run /cvds API and parse the json to get ${GROUP_NAME}.
-        // 3. Run /cvds/${GROUP_NAME}/:bugreport to get ${OPERATION_ID}
-        // 4. Periodically run /operations/${OPERATION_ID}, parse the json util get "done":true.
-        // 5. Run /operations/${OPERATION_ID}/result to get the ${UUID}.
-        // 6. Run /cvdbugreports/${UUID} to download the artifact.
         File cvdLogsDir = null;
         File cvdLogsZip = null;
         try {
             cvdLogsZip = Files.createTempFile(CVD_HOST_LOGZ, ".zip").toFile();
-            if (mUseOxygenation) {
-                if (mHOTunnel == null || !mHOTunnel.isAlive()) {
-                    CLog.e("Failed portforwarding Host Orchestrator CURL tunnel.");
-                    return null;
-                }
+            if (mUseOxygenation && (mHOTunnel == null || !mHOTunnel.isAlive())) {
+                CLog.e("Failed portforwarding Host Orchestrator CURL tunnel.");
+                return null;
             }
             ListCvdsResponse listCvdsRes = listCvds();
             if (listCvdsRes.cvds.size() == 0) {
@@ -228,11 +222,9 @@ public class HostOrchestratorUtil {
      * @return True if device boot complete, false otherwise.
      */
     public boolean deviceBootCompleted(long maxWaitTime) {
-        if (mUseOxygenation) {
-            if (mHOTunnel == null || !mHOTunnel.isAlive()) {
-                CLog.e("Failed portforwarding Host Orchestrator CURL tunnel.");
-                return false;
-            }
+        if (mUseOxygenation && (mHOTunnel == null || !mHOTunnel.isAlive())) {
+            CLog.e("Failed portforwarding Host Orchestrator CURL tunnel.");
+            return false;
         }
         long maxEndTime = System.currentTimeMillis() + maxWaitTime;
         while (System.currentTimeMillis() < maxEndTime) {
@@ -263,25 +255,14 @@ public class HostOrchestratorUtil {
     }
 
     /**
-     * Attempt to powerwash a GCE instance via Host Orchestrator.
+     * Attempt to powerwash a Cuttlefish instance via Host Orchestrator.
      *
      * @return A {@link CommandResult} containing the status and logs.
      */
     public CommandResult powerwashGce() {
-        // Basically, the rough processes to powerwash a GCE instance are
-        // 1. Portforward CURL tunnel
-        // 2. Obtain the necessary information to powerwash a GCE instance via Host Orchestrator.
-        // 3. Attempt to powerwash a GCE instance via Host Orchestrator.
-        // TODO(easoncylee): Flesh out this section when it's ready.
         try {
-            if (mUseOxygenation) {
-                if (mHOTunnel == null || !mHOTunnel.isAlive()) {
-                    CommandResult curlRes = new CommandResult(CommandStatus.EXCEPTION);
-                    String msg = "Failed portforwarding Host Orchestrator tunnel.";
-                    CLog.e(msg);
-                    curlRes.setStderr(msg);
-                    return curlRes;
-                }
+            if (mUseOxygenation && (mHOTunnel == null || !mHOTunnel.isAlive())) {
+                return buildHOFailureResult();
             }
             ListCvdsResponse listCvdsRes = listCvds();
             if (listCvdsRes.cvds.size() == 0) {
@@ -294,27 +275,21 @@ public class HostOrchestratorUtil {
             Operation operation = sendRequest(mHttpClient, httpRequest, Operation.class);
             waitForOperation(mHttpClient, baseUrl, operation.name, WAIT_FOR_OPERATION_TIMEOUT_MS);
         } catch (IOException | InterruptedException | ErrorResponseException | TimeoutException e) {
-            CLog.e("Failed powerwashing gce via Host Orchestrator: %s", e);
+            CLog.e("Failed to powerwash the cuttlefish instance via Host Orchestrator: %s", e);
             return new CommandResult(CommandStatus.EXCEPTION);
         }
         return new CommandResult(CommandStatus.SUCCESS);
     }
 
-    /** Remove Cuttlefish instance via Host Orchestrator. */
+    /**
+     * Attempt to remote a Cuttlefish instance via Host Orchestrator.
+     *
+     * @return A {@link CommandResult} containing the status and logs.
+     */
     public CommandResult removeInstance() {
-        // Basically, the rough processes to remove an instance are
-        // 1. Portforward CURL tunnel
-        // 2. Obtain the group and instance name.
-        // 3. Attempt to remove the Instance via Host Orchestrator.
         try {
-            if (mUseOxygenation) {
-                if (mHOTunnel == null || !mHOTunnel.isAlive()) {
-                    CommandResult curlRes = new CommandResult(CommandStatus.EXCEPTION);
-                    String msg = "Failed portforwarding Host Orchestrator tunnel.";
-                    CLog.e(msg);
-                    curlRes.setStderr(msg);
-                    return curlRes;
-                }
+            if (mUseOxygenation && (mHOTunnel == null || !mHOTunnel.isAlive())) {
+                return buildHOFailureResult();
             }
             ListCvdsResponse listCvdsRes = listCvds();
             if (listCvdsRes.cvds.size() == 0) {
@@ -327,22 +302,103 @@ public class HostOrchestratorUtil {
             Operation operation = sendRequest(mHttpClient, httpRequest, Operation.class);
             waitForOperation(mHttpClient, baseUrl, operation.name, WAIT_FOR_OPERATION_TIMEOUT_MS);
         } catch (IOException | InterruptedException | ErrorResponseException | TimeoutException e) {
-            CLog.e("Failed removing instance via Host Orchestrator: %s", e);
+            CLog.e("Failed to remove the cuttlefish instance via Host Orchestrator: %s", e);
             return new CommandResult(CommandStatus.EXCEPTION);
         }
         return new CommandResult(CommandStatus.SUCCESS);
     }
 
-    /** Attempt to snapshot a Cuttlefish instance via Host Orchestrator. */
-    public CommandResult snapshotGce() {
-        // TODO(b/339304559): Flesh out this section when the host orchestrator is supported.
-        return new CommandResult(CommandStatus.EXCEPTION);
+    /**
+     * Attempt to stop a Cuttlefish instance via Host Orchestrator.
+     *
+     * @return A {@link CommandResult} containing the status and logs.
+     */
+    public CommandResult stopInstance() {
+        try {
+            if (mUseOxygenation && (mHOTunnel == null || !mHOTunnel.isAlive())) {
+                return buildHOFailureResult();
+            }
+            ListCvdsResponse listCvdsRes = listCvds();
+            if (listCvdsRes.cvds.size() == 0) {
+                CLog.e("No cvd found.");
+                return null;
+            }
+            Cvd cvd = listCvdsRes.cvds.get(0);
+            String baseUrl = getHOBaseUrl(mHOPortNumber);
+            HttpRequest httpRequest = buildStopInstanceRequest(baseUrl, cvd.group, cvd.name);
+            Operation operation = sendRequest(mHttpClient, httpRequest, Operation.class);
+            waitForOperation(mHttpClient, baseUrl, operation.name, WAIT_FOR_OPERATION_TIMEOUT_MS);
+        } catch (IOException | InterruptedException | ErrorResponseException | TimeoutException e) {
+            CLog.e("Failed to stop the cuttlefish instance via Host Orchestrator: %s", e);
+            return new CommandResult(CommandStatus.EXCEPTION);
+        }
+        return new CommandResult(CommandStatus.SUCCESS);
     }
 
-    /** Attempt to restore snapshot of a Cuttlefish instance via Host Orchestrator. */
-    public CommandResult restoreSnapshotGce() {
-        // TODO(b/339304559): Flesh out this section when the host orchestrator is supported.
-        return new CommandResult(CommandStatus.EXCEPTION);
+    /**
+     * Attempt to snapshot a Cuttlefish instance with the given id via Host Orchestrator.
+     *
+     * @param snapshotId the id that the snapshot file should be stored.
+     * @return A {@link CommandResult} containing the status and logs.
+     */
+    public CommandResult snapshotInstance(String snapshotId) {
+        try {
+            if (mUseOxygenation && (mHOTunnel == null || !mHOTunnel.isAlive())) {
+                return buildHOFailureResult();
+            }
+            ListCvdsResponse listCvdsRes = listCvds();
+            if (listCvdsRes.cvds.size() == 0) {
+                CLog.e("No cvd found.");
+                return null;
+            }
+            Cvd cvd = listCvdsRes.cvds.get(0);
+            String baseUrl = getHOBaseUrl(mHOPortNumber);
+            HttpRequest httpRequest =
+                    buildCreateSnapshotRequest(
+                            baseUrl, cvd.group, cvd.name, new CreateSnapshotRequest(snapshotId));
+            Operation operation = sendRequest(mHttpClient, httpRequest, Operation.class);
+            waitForOperation(mHttpClient, baseUrl, operation.name, WAIT_FOR_OPERATION_TIMEOUT_MS);
+        } catch (IOException | InterruptedException | ErrorResponseException | TimeoutException e) {
+            CLog.e(
+                    "Failed to snapshot the cuttlefish instance with given id: %s via Host"
+                            + " Orchestrator: %s",
+                    snapshotId, e);
+            return new CommandResult(CommandStatus.EXCEPTION);
+        }
+        return new CommandResult(CommandStatus.SUCCESS);
+    }
+
+    /**
+     * Attempt to start CVD with a given id via Host Orchestrator.
+     *
+     * @param snapshotId the id that the snapshot file should be stored.
+     * @return A {@link CommandResult} containing the status and logs.
+     */
+    public CommandResult startCvd(String snapshotId) {
+        try {
+            if (mUseOxygenation && (mHOTunnel == null || !mHOTunnel.isAlive())) {
+                return buildHOFailureResult();
+            }
+            ListCvdsResponse listCvdsRes = listCvds();
+            if (listCvdsRes.cvds.size() == 0) {
+                CLog.e("No cvd found.");
+                return null;
+            }
+            Cvd cvd = listCvdsRes.cvds.get(0);
+            String baseUrl = getHOBaseUrl(mHOPortNumber);
+            HttpRequest httpRequest =
+                    buildStartCvdRequest(
+                            baseUrl, cvd.group, cvd.name, new StartCVDRequest(snapshotId));
+            Operation operation = sendRequest(mHttpClient, httpRequest, Operation.class);
+            waitForOperation(mHttpClient, baseUrl, operation.name, WAIT_FOR_OPERATION_TIMEOUT_MS);
+        } catch (IOException | InterruptedException | ErrorResponseException | TimeoutException e) {
+            CLog.e(
+                    "Failed to start a cuttlefish instance with the given id: %s via Host"
+                            + " Orchestrator: %s",
+                    snapshotId, e);
+            return new CommandResult(CommandStatus.EXCEPTION);
+        }
+        return new CommandResult(CommandStatus.SUCCESS);
     }
 
     /** Attempt to delete snapshot of a Cuttlefish instance via Host Orchestrator. */
@@ -537,4 +593,12 @@ public class HostOrchestratorUtil {
             mOxygenClient.closeLHPConnection(mHOTunnel);
         }
     }
+
+    private CommandResult buildHOFailureResult() {
+        CommandResult curlRes = new CommandResult(CommandStatus.EXCEPTION);
+        String msg = "Failed portforwarding Host Orchestrator tunnel.";
+        CLog.e(msg);
+        curlRes.setStderr(msg);
+        return curlRes;
+    }
 }
diff --git a/avd_util/javatests/com/android/tradefed/util/avd/HostOrchestratorClientTest.java b/avd_util/javatests/com/android/tradefed/util/avd/HostOrchestratorClientTest.java
index 1b2d15f45..f6e66e7f5 100644
--- a/avd_util/javatests/com/android/tradefed/util/avd/HostOrchestratorClientTest.java
+++ b/avd_util/javatests/com/android/tradefed/util/avd/HostOrchestratorClientTest.java
@@ -16,13 +16,18 @@
 
 package com.android.tradefed.util.avd;
 
+import static com.android.tradefed.util.avd.HostOrchestratorClient.CreateSnapshotRequest;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.ErrorResponseException;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.Operation;
+import static com.android.tradefed.util.avd.HostOrchestratorClient.StartCVDRequest;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.buildCreateBugreportRequest;
+import static com.android.tradefed.util.avd.HostOrchestratorClient.buildCreateSnapshotRequest;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.buildGetOperationRequest;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.buildGetOperationResultRequest;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.buildPowerwashRequest;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.buildRemoveInstanceRequest;
+import static com.android.tradefed.util.avd.HostOrchestratorClient.buildStartCvdRequest;
+import static com.android.tradefed.util.avd.HostOrchestratorClient.buildStopInstanceRequest;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.saveToFile;
 import static com.android.tradefed.util.avd.HostOrchestratorClient.sendRequest;
 
@@ -62,6 +67,31 @@ public class HostOrchestratorClientTest {
     @After
     public void tearDown() {}
 
+    @Test
+    public void testBuildStopInstanceRequest() throws Exception {
+        HttpRequest r = buildStopInstanceRequest("https://ho.test", "group", "name");
+
+        Assert.assertEquals("https://ho.test/cvds/group/name/:stop", r.uri().toString());
+    }
+
+    @Test
+    public void testBuildCreateSnapshotRequest() throws Exception {
+        HttpRequest r =
+                buildCreateSnapshotRequest(
+                        "https://ho.test", "group", "name", new CreateSnapshotRequest("req"));
+
+        Assert.assertEquals("https://ho.test/cvds/group/name/snapshots", r.uri().toString());
+    }
+
+    @Test
+    public void testBuildStartCvdRequest() throws Exception {
+        HttpRequest r =
+                buildStartCvdRequest(
+                        "https://ho.test", "group", "name", new StartCVDRequest("req"));
+
+        Assert.assertEquals("https://ho.test/cvds/group/name/:start", r.uri().toString());
+    }
+
     @Test
     public void testBuildGetOperationRequest() throws Exception {
         HttpRequest r = buildGetOperationRequest("https://ho.test", "opfoo");
diff --git a/avd_util/javatests/com/android/tradefed/util/avd/HostOrchestratorUtilTest.java b/avd_util/javatests/com/android/tradefed/util/avd/HostOrchestratorUtilTest.java
index b3c0a0fa2..aebc35594 100644
--- a/avd_util/javatests/com/android/tradefed/util/avd/HostOrchestratorUtilTest.java
+++ b/avd_util/javatests/com/android/tradefed/util/avd/HostOrchestratorUtilTest.java
@@ -865,6 +865,453 @@ public class HostOrchestratorUtilTest {
         Assert.assertFalse(mHOUtil.deviceBootCompleted(10));
     }
 
+    @Test
+    public void testStopInstance() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        Mockito.doReturn(mMockProcess)
+                .when(mMockClient)
+                .createTunnelViaLHP(
+                        Mockito.eq(LHPTunnelMode.CURL),
+                        Mockito.eq("1111"),
+                        Mockito.eq(INSTANCE_NAME),
+                        Mockito.eq(HOST),
+                        Mockito.eq(TARGET_REGION),
+                        Mockito.eq(ACCOUNTING_USER),
+                        Mockito.eq(OXYGENATION_DEVICE_ID),
+                        Mockito.eq(mExtraOxygenArgs),
+                        Mockito.any());
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient,
+                        mMockHttpClient) {
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        Mockito.when(mMockHttpClient.send(Mockito.any()))
+                .thenReturn(
+                        mockHttpResponse(200, LIST_CVD_RES),
+                        mockHttpResponse(200, OPERATION_RES),
+                        mockHttpResponse(200, OPERATION_DONE_RES));
+        Assert.assertEquals(CommandStatus.SUCCESS, mHOUtil.stopInstance().getStatus());
+    }
+
+    @Test
+    public void testStopInstance_CreateHOFailed() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        Mockito.doReturn(null)
+                .when(mMockClient)
+                .createTunnelViaLHP(
+                        Mockito.eq(LHPTunnelMode.CURL),
+                        Mockito.eq("1111"),
+                        Mockito.eq(INSTANCE_NAME),
+                        Mockito.eq(HOST),
+                        Mockito.eq(TARGET_REGION),
+                        Mockito.eq(ACCOUNTING_USER),
+                        Mockito.eq(OXYGENATION_DEVICE_ID),
+                        Mockito.eq(mExtraOxygenArgs),
+                        Mockito.any());
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient,
+                        mMockHttpClient) {
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        Assert.assertEquals(CommandStatus.EXCEPTION, mHOUtil.stopInstance().getStatus());
+    }
+
+    @Test
+    public void testStopInstance_ListCvdFailed() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        Mockito.doReturn(mMockProcess)
+                .when(mMockClient)
+                .createTunnelViaLHP(
+                        Mockito.eq(LHPTunnelMode.CURL),
+                        Mockito.eq("1111"),
+                        Mockito.eq(INSTANCE_NAME),
+                        Mockito.eq(HOST),
+                        Mockito.eq(TARGET_REGION),
+                        Mockito.eq(ACCOUNTING_USER),
+                        Mockito.eq(OXYGENATION_DEVICE_ID),
+                        Mockito.eq(mExtraOxygenArgs),
+                        Mockito.any());
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient,
+                        mMockHttpClient) {
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        Mockito.when(mMockHttpClient.send(Mockito.any()))
+                .thenReturn(mockHttpResponse(500, "server error"));
+        Assert.assertEquals(CommandStatus.EXCEPTION, mHOUtil.stopInstance().getStatus());
+    }
+
+    @Test
+    public void testStopInstance_EmptyList() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        Mockito.doReturn(mMockProcess)
+                .when(mMockClient)
+                .createTunnelViaLHP(
+                        Mockito.eq(LHPTunnelMode.CURL),
+                        Mockito.eq("1111"),
+                        Mockito.eq(INSTANCE_NAME),
+                        Mockito.eq(HOST),
+                        Mockito.eq(TARGET_REGION),
+                        Mockito.eq(ACCOUNTING_USER),
+                        Mockito.eq(OXYGENATION_DEVICE_ID),
+                        Mockito.eq(mExtraOxygenArgs),
+                        Mockito.any());
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient,
+                        mMockHttpClient) {
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        Mockito.when(mMockHttpClient.send(Mockito.any()))
+                .thenReturn(mockHttpResponse(200, LIST_CVD_EMPTY));
+        Assert.assertNull(mHOUtil.stopInstance());
+    }
+
+    @Test
+    public void testStartCvd() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        Mockito.doReturn(mMockProcess)
+                .when(mMockClient)
+                .createTunnelViaLHP(
+                        Mockito.eq(LHPTunnelMode.CURL),
+                        Mockito.eq("1111"),
+                        Mockito.eq(INSTANCE_NAME),
+                        Mockito.eq(HOST),
+                        Mockito.eq(TARGET_REGION),
+                        Mockito.eq(ACCOUNTING_USER),
+                        Mockito.eq(OXYGENATION_DEVICE_ID),
+                        Mockito.eq(mExtraOxygenArgs),
+                        Mockito.any());
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient,
+                        mMockHttpClient) {
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        Mockito.when(mMockHttpClient.send(Mockito.any()))
+                .thenReturn(
+                        mockHttpResponse(200, LIST_CVD_RES),
+                        mockHttpResponse(200, OPERATION_RES),
+                        mockHttpResponse(200, OPERATION_DONE_RES));
+        Assert.assertEquals(CommandStatus.SUCCESS, mHOUtil.startCvd("id").getStatus());
+    }
+
+    @Test
+    public void testStartCvd_CreateHOFailed() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        Mockito.doReturn(null)
+                .when(mMockClient)
+                .createTunnelViaLHP(
+                        Mockito.eq(LHPTunnelMode.CURL),
+                        Mockito.eq("1111"),
+                        Mockito.eq(INSTANCE_NAME),
+                        Mockito.eq(HOST),
+                        Mockito.eq(TARGET_REGION),
+                        Mockito.eq(ACCOUNTING_USER),
+                        Mockito.eq(OXYGENATION_DEVICE_ID),
+                        Mockito.eq(mExtraOxygenArgs),
+                        Mockito.any());
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient,
+                        mMockHttpClient) {
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        Assert.assertEquals(CommandStatus.EXCEPTION, mHOUtil.startCvd("id").getStatus());
+    }
+
+    @Test
+    public void testStartCvd_ListCvdFailed() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        Mockito.doReturn(mMockProcess)
+                .when(mMockClient)
+                .createTunnelViaLHP(
+                        Mockito.eq(LHPTunnelMode.CURL),
+                        Mockito.eq("1111"),
+                        Mockito.eq(INSTANCE_NAME),
+                        Mockito.eq(HOST),
+                        Mockito.eq(TARGET_REGION),
+                        Mockito.eq(ACCOUNTING_USER),
+                        Mockito.eq(OXYGENATION_DEVICE_ID),
+                        Mockito.eq(mExtraOxygenArgs),
+                        Mockito.any());
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient,
+                        mMockHttpClient) {
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        Mockito.when(mMockHttpClient.send(Mockito.any()))
+                .thenReturn(mockHttpResponse(500, "server error"));
+        Assert.assertEquals(CommandStatus.EXCEPTION, mHOUtil.startCvd("id").getStatus());
+    }
+
+    @Test
+    public void testStartCvd_EmptyList() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        Mockito.doReturn(mMockProcess)
+                .when(mMockClient)
+                .createTunnelViaLHP(
+                        Mockito.eq(LHPTunnelMode.CURL),
+                        Mockito.eq("1111"),
+                        Mockito.eq(INSTANCE_NAME),
+                        Mockito.eq(HOST),
+                        Mockito.eq(TARGET_REGION),
+                        Mockito.eq(ACCOUNTING_USER),
+                        Mockito.eq(OXYGENATION_DEVICE_ID),
+                        Mockito.eq(mExtraOxygenArgs),
+                        Mockito.any());
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient,
+                        mMockHttpClient) {
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        Mockito.when(mMockHttpClient.send(Mockito.any()))
+                .thenReturn(mockHttpResponse(200, LIST_CVD_EMPTY));
+        Assert.assertNull(mHOUtil.startCvd("id"));
+    }
+
+    @Test
+    public void testSnapshotInstance() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        Mockito.doReturn(mMockProcess)
+                .when(mMockClient)
+                .createTunnelViaLHP(
+                        Mockito.eq(LHPTunnelMode.CURL),
+                        Mockito.eq("1111"),
+                        Mockito.eq(INSTANCE_NAME),
+                        Mockito.eq(HOST),
+                        Mockito.eq(TARGET_REGION),
+                        Mockito.eq(ACCOUNTING_USER),
+                        Mockito.eq(OXYGENATION_DEVICE_ID),
+                        Mockito.eq(mExtraOxygenArgs),
+                        Mockito.any());
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient,
+                        mMockHttpClient) {
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        Mockito.when(mMockHttpClient.send(Mockito.any()))
+                .thenReturn(
+                        mockHttpResponse(200, LIST_CVD_RES),
+                        mockHttpResponse(200, OPERATION_RES),
+                        mockHttpResponse(200, OPERATION_DONE_RES));
+        Assert.assertEquals(CommandStatus.SUCCESS, mHOUtil.snapshotInstance("id").getStatus());
+    }
+
+    @Test
+    public void testSnapshotInstance_CreateHOFailed() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        Mockito.doReturn(null)
+                .when(mMockClient)
+                .createTunnelViaLHP(
+                        Mockito.eq(LHPTunnelMode.CURL),
+                        Mockito.eq("1111"),
+                        Mockito.eq(INSTANCE_NAME),
+                        Mockito.eq(HOST),
+                        Mockito.eq(TARGET_REGION),
+                        Mockito.eq(ACCOUNTING_USER),
+                        Mockito.eq(OXYGENATION_DEVICE_ID),
+                        Mockito.eq(mExtraOxygenArgs),
+                        Mockito.any());
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient,
+                        mMockHttpClient) {
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        Assert.assertEquals(CommandStatus.EXCEPTION, mHOUtil.snapshotInstance("id").getStatus());
+    }
+
+    @Test
+    public void testSnapshotInstance_ListCvdFailed() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        Mockito.doReturn(mMockProcess)
+                .when(mMockClient)
+                .createTunnelViaLHP(
+                        Mockito.eq(LHPTunnelMode.CURL),
+                        Mockito.eq("1111"),
+                        Mockito.eq(INSTANCE_NAME),
+                        Mockito.eq(HOST),
+                        Mockito.eq(TARGET_REGION),
+                        Mockito.eq(ACCOUNTING_USER),
+                        Mockito.eq(OXYGENATION_DEVICE_ID),
+                        Mockito.eq(mExtraOxygenArgs),
+                        Mockito.any());
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient,
+                        mMockHttpClient) {
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        Mockito.when(mMockHttpClient.send(Mockito.any()))
+                .thenReturn(mockHttpResponse(500, "server error"));
+        Assert.assertEquals(CommandStatus.EXCEPTION, mHOUtil.snapshotInstance("id").getStatus());
+    }
+
+    @Test
+    public void testSnapshotInstance_EmptyList() throws Exception {
+        Mockito.doReturn(1111).when(mMockClient).createServerSocket();
+        Mockito.doReturn(true).when(mMockProcess).isAlive();
+        Mockito.doReturn(mMockProcess)
+                .when(mMockClient)
+                .createTunnelViaLHP(
+                        Mockito.eq(LHPTunnelMode.CURL),
+                        Mockito.eq("1111"),
+                        Mockito.eq(INSTANCE_NAME),
+                        Mockito.eq(HOST),
+                        Mockito.eq(TARGET_REGION),
+                        Mockito.eq(ACCOUNTING_USER),
+                        Mockito.eq(OXYGENATION_DEVICE_ID),
+                        Mockito.eq(mExtraOxygenArgs),
+                        Mockito.any());
+        mHOUtil =
+                new HostOrchestratorUtil(
+                        true,
+                        mExtraOxygenArgs,
+                        INSTANCE_NAME,
+                        HOST,
+                        OXYGENATION_DEVICE_ID,
+                        TARGET_REGION,
+                        ACCOUNTING_USER,
+                        mMockClient,
+                        mMockHttpClient) {
+                    @Override
+                    protected IRunUtil getRunUtil() {
+                        return mMockRunUtil;
+                    }
+                };
+        Mockito.when(mMockHttpClient.send(Mockito.any()))
+                .thenReturn(mockHttpResponse(200, LIST_CVD_EMPTY));
+        Assert.assertNull(mHOUtil.snapshotInstance("id"));
+    }
+
     private static <T> HttpResponse<T> mockHttpResponse(int statusCode, T body) {
         return new HttpResponse<>() {
             @Override
diff --git a/avd_util/javatests/com/android/tradefed/util/avd/UnitTests.java b/avd_util/javatests/com/android/tradefed/util/avd/UnitTests.java
index f084fed8c..aa20dd676 100644
--- a/avd_util/javatests/com/android/tradefed/util/avd/UnitTests.java
+++ b/avd_util/javatests/com/android/tradefed/util/avd/UnitTests.java
@@ -30,6 +30,7 @@ import org.junit.runners.Suite.SuiteClasses;
 @SuiteClasses({
     AcloudUtilTest.class,
     HostOrchestratorUtilTest.class,
+    HostOrchestratorClientTest.class,
     OxygenClientTest.class,
     InspectionUtilTest.class
 })
diff --git a/common_util/Android.bp b/common_util/Android.bp
index 23be2c345..5aa1b4284 100644
--- a/common_util/Android.bp
+++ b/common_util/Android.bp
@@ -50,7 +50,6 @@ java_library_host {
         "google-http-client-jackson2-1.28.0",
     ],
     libs: [
-        "ddmlib-prebuilt",
         "guava",
         "tradefed-protos",
         "devtools-annotations-prebuilt",
diff --git a/common_util/com/android/ddmlib/Log.java b/common_util/com/android/ddmlib/Log.java
new file mode 100644
index 000000000..ac1f878a9
--- /dev/null
+++ b/common_util/com/android/ddmlib/Log.java
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.ddmlib;
+
+public class Log {
+
+    /** Log Level enum. */
+    public enum LogLevel {
+        VERBOSE(2, "verbose", 'V'), // $NON-NLS-1$
+        DEBUG(3, "debug", 'D'), // $NON-NLS-1$
+        INFO(4, "info", 'I'), // $NON-NLS-1$
+        WARN(5, "warn", 'W'), // $NON-NLS-1$
+        ERROR(6, "error", 'E'), // $NON-NLS-1$
+        ASSERT(7, "assert", 'A'); // $NON-NLS-1$
+
+        private int mPriorityLevel;
+        private String mStringValue;
+        private char mPriorityLetter;
+
+        LogLevel(int intPriority, String stringValue, char priorityChar) {
+            mPriorityLevel = intPriority;
+            mStringValue = stringValue;
+            mPriorityLetter = priorityChar;
+        }
+
+        public static LogLevel getByString(String value) {
+            for (LogLevel mode : values()) {
+                if (mode.mStringValue.equals(value)) {
+                    return mode;
+                }
+            }
+
+            return null;
+        }
+
+        /**
+         * Returns the {@link LogLevel} enum matching the specified letter.
+         *
+         * @param letter the letter matching a <code>LogLevel</code> enum
+         * @return a <code>LogLevel</code> object or <code>null</code> if no match were found.
+         */
+        public static LogLevel getByLetter(char letter) {
+            for (LogLevel mode : values()) {
+                if (mode.mPriorityLetter == letter) {
+                    return mode;
+                }
+            }
+
+            return null;
+        }
+
+        /**
+         * Returns the {@link LogLevel} enum matching the specified letter.
+         *
+         * <p>The letter is passed as a {@link String} argument, but only the first character is
+         * used.
+         *
+         * @param letter the letter matching a <code>LogLevel</code> enum
+         * @return a <code>LogLevel</code> object or <code>null</code> if no match were found.
+         */
+        public static LogLevel getByLetterString(String letter) {
+            if (!letter.isEmpty()) {
+                return getByLetter(letter.charAt(0));
+            }
+
+            return null;
+        }
+
+        /** Returns the letter identifying the priority of the {@link LogLevel}. */
+        public char getPriorityLetter() {
+            return mPriorityLetter;
+        }
+
+        /** Returns the numerical value of the priority. */
+        public int getPriority() {
+            return mPriorityLevel;
+        }
+
+        /** Returns a non translated string representing the LogLevel. */
+        public String getStringValue() {
+            return mStringValue;
+        }
+    }
+
+    /**
+     * Outputs a {@link LogLevel#VERBOSE} level message.
+     *
+     * @param tag The tag associated with the message.
+     * @param message The message to output.
+     */
+    public static void v(String tag, String message) {
+        com.android.tradefed.log.Log.v(tag, message);
+    }
+
+    /**
+     * Outputs a {@link LogLevel#DEBUG} level message.
+     *
+     * @param tag The tag associated with the message.
+     * @param message The message to output.
+     */
+    public static void d(String tag, String message) {
+        com.android.tradefed.log.Log.d(tag, message);
+    }
+
+    /**
+     * Outputs a {@link LogLevel#INFO} level message.
+     *
+     * @param tag The tag associated with the message.
+     * @param message The message to output.
+     */
+    public static void i(String tag, String message) {
+        com.android.tradefed.log.Log.i(tag, message);
+    }
+
+    /**
+     * Outputs a {@link LogLevel#WARN} level message.
+     *
+     * @param tag The tag associated with the message.
+     * @param message The message to output.
+     */
+    public static void w(String tag, String message) {
+        com.android.tradefed.log.Log.w(tag, message);
+    }
+
+    /**
+     * Outputs a {@link LogLevel#ERROR} level message.
+     *
+     * @param tag The tag associated with the message.
+     * @param message The message to output.
+     */
+    public static void e(String tag, String message) {
+        com.android.tradefed.log.Log.e(tag, message);
+    }
+
+    /**
+     * Outputs a {@link LogLevel#ERROR} level {@link Throwable} information.
+     *
+     * @param tag The tag associated with the message.
+     * @param throwable The {@link Throwable} to output.
+     */
+    public static void e(String tag, Throwable throwable) {
+        com.android.tradefed.log.Log.e(tag, throwable);
+    }
+
+    public static void logAndDisplay(LogLevel logLevel, String tag, String message) {
+        com.android.tradefed.log.Log.logAndDisplay(
+                com.android.tradefed.log.Log.LogLevel.convertFromDdmlib(logLevel), tag, message);
+    }
+}
diff --git a/common_util/com/android/ddmlib/testrunner/TestIdentifier.java b/common_util/com/android/ddmlib/testrunner/TestIdentifier.java
new file mode 100644
index 000000000..fbad84730
--- /dev/null
+++ b/common_util/com/android/ddmlib/testrunner/TestIdentifier.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ddmlib.testrunner;
+
+/** Identifies a parsed instrumentation test. */
+public class TestIdentifier {
+
+    private final String mClassName;
+    private final String mTestName;
+
+    // An index of this test.
+    // Test suite may have duplicated test cases (the same test case may be run twice). This
+    // property is used to distinguish them.
+    private final int mTestIndex;
+
+    /**
+     * Creates a test identifier.
+     *
+     * @param className fully qualified class name of the test. Cannot be null.
+     * @param testName name of the test. Cannot be null.
+     */
+    public TestIdentifier(String className, String testName) {
+        this(className, testName, /* testIndex= */ -1);
+    }
+
+    /**
+     * Creates a test identifier with a test index.
+     *
+     * @param className fully qualified class name of the test. Cannot be null.
+     * @param testName name of the test. Cannot be null.
+     * @param testIndex an index of this test run.
+     */
+    public TestIdentifier(String className, String testName, int testIndex) {
+        if (className == null || testName == null) {
+            throw new IllegalArgumentException("className and testName must " + "be non-null");
+        }
+        mClassName = className;
+        mTestName = testName;
+        mTestIndex = testIndex;
+    }
+
+    /** Returns the fully qualified class name of the test. */
+    public String getClassName() {
+        return mClassName;
+    }
+
+    /** Returns the name of the test. */
+    public String getTestName() {
+        return mTestName;
+    }
+
+    /** Returns the index of the test. */
+    public int getTestIndex() {
+        return mTestIndex;
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + ((mClassName == null) ? 0 : mClassName.hashCode());
+        result = prime * result + ((mTestName == null) ? 0 : mTestName.hashCode());
+        result = prime * result + mTestIndex;
+        return result;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) return true;
+        if (obj == null) return false;
+        if (getClass() != obj.getClass()) return false;
+        TestIdentifier other = (TestIdentifier) obj;
+        if (mClassName == null) {
+            if (other.mClassName != null) return false;
+        } else if (!mClassName.equals(other.mClassName)) return false;
+        if (mTestName == null) {
+            if (other.mTestName != null) return false;
+        } else if (!mTestName.equals(other.mTestName)) return false;
+        return mTestIndex == other.mTestIndex;
+    }
+
+    @Override
+    public String toString() {
+        return String.format("%s#%s", getClassName(), getTestName());
+    }
+}
diff --git a/common_util/com/android/ddmlib/testrunner/TestResult.java b/common_util/com/android/ddmlib/testrunner/TestResult.java
new file mode 100644
index 000000000..158cb6efd
--- /dev/null
+++ b/common_util/com/android/ddmlib/testrunner/TestResult.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.ddmlib.testrunner;
+
+import java.util.Arrays;
+import java.util.Map;
+
+/** Container for a result of a single test. */
+public class TestResult {
+
+    public enum TestStatus {
+        /** Test failed. */
+        FAILURE,
+        /** Test passed */
+        PASSED,
+        /** Test started but not ended */
+        INCOMPLETE,
+        /** Test assumption failure */
+        ASSUMPTION_FAILURE,
+        /** Test ignored */
+        IGNORED,
+    }
+
+    private TestStatus mStatus;
+    private String mStackTrace;
+    private Map<String, String> mMetrics;
+    // the start and end time of the test, measured via {@link System#currentTimeMillis()}
+    private long mStartTime = 0;
+    private long mEndTime = 0;
+
+    public TestResult() {
+        mStatus = TestStatus.INCOMPLETE;
+        mStartTime = System.currentTimeMillis();
+    }
+
+    /** Get the {@link TestStatus} result of the test. */
+    public TestStatus getStatus() {
+        return mStatus;
+    }
+
+    /**
+     * Get the associated {@link String} stack trace. Should be <code>null</code> if {@link
+     * #getStatus()} is {@link TestStatus#PASSED}.
+     */
+    public String getStackTrace() {
+        return mStackTrace;
+    }
+
+    /** Get the associated test metrics. */
+    public Map<String, String> getMetrics() {
+        return mMetrics;
+    }
+
+    /** Set the test metrics, overriding any previous values. */
+    public void setMetrics(Map<String, String> metrics) {
+        mMetrics = metrics;
+    }
+
+    /**
+     * Return the {@link System#currentTimeMillis()} time that the {@link
+     * ITestRunListener#testStarted(TestIdentifier)} event was received.
+     */
+    public long getStartTime() {
+        return mStartTime;
+    }
+
+    /**
+     * Allows to set the time when the test was started, to be used with {@link
+     * ITestRunListener#testStarted(TestIdentifier, long)}.
+     */
+    public void setStartTime(long startTime) {
+        mStartTime = startTime;
+    }
+
+    /**
+     * Return the {@link System#currentTimeMillis()} time that the {@link
+     * ITestRunListener#testEnded(TestIdentifier, Map)} event was received.
+     */
+    public long getEndTime() {
+        return mEndTime;
+    }
+
+    /** Set the {@link TestStatus}. */
+    public TestResult setStatus(TestStatus status) {
+        mStatus = status;
+        return this;
+    }
+
+    /** Set the stack trace. */
+    public void setStackTrace(String trace) {
+        mStackTrace = trace;
+    }
+
+    /** Sets the end time */
+    public void setEndTime(long currentTimeMillis) {
+        mEndTime = currentTimeMillis;
+    }
+
+    @Override
+    public int hashCode() {
+        return Arrays.hashCode(new Object[] {mMetrics, mStackTrace, mStatus});
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null) {
+            return false;
+        }
+        if (getClass() != obj.getClass()) {
+            return false;
+        }
+        TestResult other = (TestResult) obj;
+        return equal(mMetrics, other.mMetrics)
+                && equal(mStackTrace, other.mStackTrace)
+                && equal(mStatus, other.mStatus);
+    }
+
+    private static boolean equal(Object a, Object b) {
+        return a == b || (a != null && a.equals(b));
+    }
+}
diff --git a/common_util/com/android/tradefed/invoker/logger/InvocationMetricLogger.java b/common_util/com/android/tradefed/invoker/logger/InvocationMetricLogger.java
index 296d67c90..3dd6d43b6 100644
--- a/common_util/com/android/tradefed/invoker/logger/InvocationMetricLogger.java
+++ b/common_util/com/android/tradefed/invoker/logger/InvocationMetricLogger.java
@@ -287,6 +287,12 @@ public class InvocationMetricLogger {
         CAS_DOWNLOAD_DIR_PREPARE_TIME("cas_download_dir_prepare_time_ms", true),
         CAS_DOWNLOAD_FILE_DOWNLOAD_TIME("cas_download_file_download_time_ms", true),
         CAS_DOWNLOAD_CHUNK_RESTORE_TIME("cas_download_chunk_restore_time_ms", true),
+        // Records CAS mount metrics
+        CAS_MOUNT_TIMEOUT_COUNT("cas_mount_timeout_count", true),
+        CAS_MOUNT_SUCCESS_COUNT("cas_mount_success_count", true),
+        CAS_MOUNT_FAILURE_COUNT("cas_mount_failure_count", true),
+        CAS_MOUNT_SUCCESS_TIME_MS("cas_mount_success_time_ms", true),
+        CAS_MOUNT_FAILURE_TIME_MS("cas_mount_failure_time_ms", true),
 
         // Download Cache
         CACHE_HIT_COUNT("cache_hit_count", true),
@@ -304,6 +310,7 @@ public class InvocationMetricLogger {
         AB_LIST_API_TIME_PAIR("ab_list_api_time_pair", true),
         AB_TEST_ZIP_NAME("ab_test_zip_name", true),
         AB_MODULE_IN_ZIP("ab_module_in_zip", true),
+        ZIP_PATTERN_NO_MATCH("zip_pattern_no_match", true),
 
         // Ab log saver metrics
         AB_LOG_SAVER_STAGING_TIME("ab_log_saver_staging_time", true),
@@ -356,6 +363,8 @@ public class InvocationMetricLogger {
 
         TRACE_INTERNAL_ERROR("trace_internal_error", true),
 
+        INCREMENTAL_FLASHING_ANTI_ROLLBACK_DETECTED(
+                "incremental_flashing_anti_rollback_detected", true),
         INCREMENTAL_FLASHING_TIME("incremental_flashing_time", true),
         INCREMENTAL_FLASHING_WAIT_PARALLEL_SETUP("incremental_flashing_wait_parallel_setup", true),
         INCREMENTAL_FLASHING_ATTEMPT_COUNT("incremental_flashing_attempt_count", true),
@@ -407,6 +416,9 @@ public class InvocationMetricLogger {
         TestContentAnalyzer("TestContentAnalyzer", true),
         screen_on_setup("screen_on_setup", true),
 
+        // Suite and order
+        RUNTIME_EXCLUDE_FILTER("runtime_exclude_filter", true),
+
         // Test caching metrics
         CACHED_MODULE_RESULTS_COUNT("cached_module_results_count", true),
         DEVICE_IMAGE_HASH("device_image_hash", false),
@@ -425,6 +437,7 @@ public class InvocationMetricLogger {
         // Invocation level caching
         INVOCATION_RESULTS_CHECKING_CACHE("invocation_results_checking_cache", true),
         INVOCATION_CACHE_HIT("invocation_cache_hit", true),
+        INVOCATION_CACHE_HIT_WITH_FAILURE("invocation_cache_hit_with_failure", true),
 
         // Oxygenation metrics
         PORTFORWARD_LHP_SUCCESS_COUNT("portfoward_lhp_success_count", true),
diff --git a/common_util/com/android/tradefed/log/Log.java b/common_util/com/android/tradefed/log/Log.java
index 8656f7bf9..617983551 100644
--- a/common_util/com/android/tradefed/log/Log.java
+++ b/common_util/com/android/tradefed/log/Log.java
@@ -15,11 +15,14 @@
  */
 package com.android.tradefed.log;
 
+import com.google.common.collect.Sets;
+
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Locale;
+import java.util.Set;
 
 /**
  * Log class that mirrors the API in main Android sources.
@@ -154,6 +157,7 @@ public final class Log {
     private static LogLevel sLevel = LogLevel.VERBOSE;
 
     private static ILogOutput sLogOutput;
+    private static final Set<ILogOutput> sOutputLoggers = Sets.newCopyOnWriteArraySet();
 
     private Log() {}
 
@@ -214,9 +218,15 @@ public final class Log {
      * @param message The message to output.
      */
     public static void logAndDisplay(LogLevel logLevel, String tag, String message) {
+        if (!sOutputLoggers.isEmpty()) {
+            for (ILogOutput logger : sOutputLoggers) {
+                logger.printAndPromptLog(logLevel, tag, message);
+            }
+        }
+
         if (sLogOutput != null) {
             sLogOutput.printAndPromptLog(logLevel, tag, message);
-        } else {
+        } else if (sOutputLoggers.isEmpty()) {
             println(logLevel, tag, message);
         }
     }
@@ -251,12 +261,26 @@ public final class Log {
         sLogOutput = logOutput;
     }
 
+    public static void addLogger(ILogOutput logOutput) {
+        sOutputLoggers.add(logOutput);
+    }
+
+    public static void removeLogger(ILogOutput logOutput) {
+        sOutputLoggers.remove(logOutput);
+    }
+
     /* currently prints to stdout; could write to a log window */
     private static void println(LogLevel logLevel, String tag, String message) {
         if (logLevel.getPriority() >= sLevel.getPriority()) {
+            if (!sOutputLoggers.isEmpty()) {
+                for (ILogOutput logger : sOutputLoggers) {
+                    logger.printLog(logLevel, tag, message);
+                }
+            }
+
             if (sLogOutput != null) {
                 sLogOutput.printLog(logLevel, tag, message);
-            } else {
+            } else if (sOutputLoggers.isEmpty()) {
                 printLog(logLevel, tag, message);
             }
         }
diff --git a/common_util/com/android/tradefed/result/LogDataType.java b/common_util/com/android/tradefed/result/LogDataType.java
index a60fb7606..fbc31c6c4 100644
--- a/common_util/com/android/tradefed/result/LogDataType.java
+++ b/common_util/com/android/tradefed/result/LogDataType.java
@@ -22,6 +22,7 @@ public enum LogDataType {
     XML("xml", "text/xml", false, true),
     HTML("html", "text/html", true, true),
     PNG("png", "image/png", true, false),
+    PPM("ppm", "image/ppm", false, false),
     MP4("mp4", "video/mp4", true, false),
     EAR("ear", "application/octet-stream", true, false),
     ZIP("zip", "application/zip", true, false),
@@ -101,7 +102,8 @@ public enum LogDataType {
     CUTTLEFISH_LOG("txt", "text/plain", true, true), // Log from cuttlefish instance
     TOMBSTONEZ("zip", "application/zip", true, false),
     BT_SNOOP_LOG("log", "application/octet-stream", false, false), // Bluetooth HCI snoop logs
-    WINSCOPE("winscope.zip", "application/zip", true, false),
+    WINSCOPE("winscope", "application/octet-stream", true, false),
+    BMP("bmp", "image/bmp", true, false),
     /* Unknown file type */
     UNKNOWN("dat", "text/plain", false, false);
 
diff --git a/common_util/com/android/tradefed/result/error/InfraErrorIdentifier.java b/common_util/com/android/tradefed/result/error/InfraErrorIdentifier.java
index 55c5b6dd5..9c27b581e 100644
--- a/common_util/com/android/tradefed/result/error/InfraErrorIdentifier.java
+++ b/common_util/com/android/tradefed/result/error/InfraErrorIdentifier.java
@@ -69,6 +69,7 @@ public enum InfraErrorIdentifier implements ErrorIdentifier {
     NO_WIFI(501_003, FailureStatus.DEPENDENCY_ISSUE),
     NO_DISK_SPACE(501_004, FailureStatus.DEPENDENCY_ISSUE),
     VIRTUAL_WIFI_FAILED_CONNECT(501_005, FailureStatus.DEPENDENCY_ISSUE),
+    ANTI_ROLLBACK_ERROR(501_006, FailureStatus.DEPENDENCY_ISSUE),
 
     // 502_000 - 502_100: Test issues detected by infra
     EXPECTED_TESTS_MISMATCH(502_000, FailureStatus.TEST_FAILURE),
diff --git a/common_util/com/android/tradefed/result/skipped/SkipReason.java b/common_util/com/android/tradefed/result/skipped/SkipReason.java
index 4a75966a5..17d6baa19 100644
--- a/common_util/com/android/tradefed/result/skipped/SkipReason.java
+++ b/common_util/com/android/tradefed/result/skipped/SkipReason.java
@@ -31,7 +31,8 @@ public class SkipReason {
         MANUAL, // Inserted directly via API
         LATENCY, // Test is out of SLO on latency
         ERROR_RATE, // Test is out of SLO on error rate
-        FLAKINESS; // Test is out of SLO on flakiness score
+        FLAKINESS, // Test is out of SLO on flakiness score
+        SMART_TEST_SELECTION; // Test is removed by smart test selection
     }
 
     public SkipReason(String message, String trigger) {
diff --git a/common_util/com/android/tradefed/util/FileUtil.java b/common_util/com/android/tradefed/util/FileUtil.java
index 7d9aca22e..d82ef87c3 100644
--- a/common_util/com/android/tradefed/util/FileUtil.java
+++ b/common_util/com/android/tradefed/util/FileUtil.java
@@ -82,6 +82,8 @@ public class FileUtil {
     };
 
     private static String sChmod = "chmod";
+    private static final List<String> HIGH_LINK_COUNT_FILES =
+            Arrays.asList("libc++.so", "liblog.so");
 
     /** A map of {@link PosixFilePermission} to its corresponding Unix file mode */
     private static final Map<PosixFilePermission, Integer> PERM_MODE_MAP = new HashMap<>();
@@ -505,6 +507,13 @@ public class FileUtil {
                 } catch (IOException ioe) {
                     CLog.e("Error retrieving file or filesystem stats: " + ioe.getMessage());
                 }
+                // For high link count files, fallback to copy.
+                String fileName = path.getFileName().toString();
+                if (HIGH_LINK_COUNT_FILES.contains(fileName)) {
+                    CLog.d("Link count maximum reached for %s, falling back to copy.", fileName);
+                    copyFile(origFile, destFile);
+                    return;
+                }
                 throw e;
             }
             throw e;
@@ -549,7 +558,6 @@ public class FileUtil {
      * @param destDir the destination folder
      * @param ignoreExistingFile If True and the file being linked already exists, skip the
      *     exception.
-     * @param copyInsteadofHardlink Set of files that needs to be copied instead of linked.
      * @throws IOException
      */
     public static void recursiveHardlink(File sourceDir, File destDir, boolean ignoreExistingFile)
diff --git a/common_util/com/android/tradefed/util/ZipUtil.java b/common_util/com/android/tradefed/util/ZipUtil.java
index c0c08b15d..41ed3b17e 100644
--- a/common_util/com/android/tradefed/util/ZipUtil.java
+++ b/common_util/com/android/tradefed/util/ZipUtil.java
@@ -30,6 +30,7 @@ import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.nio.file.FileAlreadyExistsException;
 import java.nio.file.Files;
 import java.nio.file.Paths;
 import java.util.ArrayList;
@@ -703,7 +704,11 @@ public class ZipUtil {
         }
 
         targetFile.getParentFile().mkdirs();
-        Files.createSymbolicLink(Paths.get(targetFile.getPath()), Paths.get(target));
+        try {
+            Files.createSymbolicLink(Paths.get(targetFile.getPath()), Paths.get(target));
+        } catch (FileAlreadyExistsException faee) {
+            CLog.w("Ignoring file already exists for symlink: %s", Paths.get(target));
+        }
     }
 
     protected static void validateDestinationDir(File destDir, String filename) throws IOException {
diff --git a/common_util/com/android/tradefed/util/ZipUtil2.java b/common_util/com/android/tradefed/util/ZipUtil2.java
index 87102e6ed..75e1142b8 100644
--- a/common_util/com/android/tradefed/util/ZipUtil2.java
+++ b/common_util/com/android/tradefed/util/ZipUtil2.java
@@ -26,6 +26,7 @@ import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.nio.file.Files;
+import java.nio.file.Paths;
 import java.util.Enumeration;
 import java.util.HashSet;
 import java.util.Set;
@@ -90,6 +91,9 @@ public class ZipUtil2 {
                     noPermissions.add(entry.getName());
                 }
                 continue;
+            } else if (entry.isUnixSymlink()) {
+                String linkTarget = StreamUtil.getStringFromStream(zipFile.getInputStream(entry));
+                Files.createSymbolicLink(childFile.toPath(), Paths.get(linkTarget));
             } else {
                 if (!extractZipEntry(zipFile, entry, childFile)) {
                     noPermissions.add(entry.getName());
diff --git a/common_util/com/android/tradefed/util/gcs/GoogleApiClientUtilBase.java b/common_util/com/android/tradefed/util/gcs/GoogleApiClientUtilBase.java
index 357d201c4..2b376aa2a 100644
--- a/common_util/com/android/tradefed/util/gcs/GoogleApiClientUtilBase.java
+++ b/common_util/com/android/tradefed/util/gcs/GoogleApiClientUtilBase.java
@@ -181,7 +181,8 @@ public class GoogleApiClientUtilBase {
             CLog.w(
                     "Request to %s failed: %d %s",
                     request.getUrl(), response.getStatusCode(), response.getStatusMessage());
-            if (response.getStatusCode() == 400) {
+            // Bad request and Requested range not satisfiable shouldn't be retried.
+            if (response.getStatusCode() == 400 || response.getStatusCode() == 416) {
                 return false;
             }
             return backOffHandler.handleResponse(request, response, supportsRetry);
diff --git a/common_util/com/android/utils/ArrayUtils.java b/common_util/com/android/utils/ArrayUtils.java
new file mode 100644
index 000000000..4b726211a
--- /dev/null
+++ b/common_util/com/android/utils/ArrayUtils.java
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.utils;
+
+import java.lang.reflect.Array;
+
+// XXX these should be changed to reflect the actual memory allocator we use.
+// it looks like right now objects want to be powers of 2 minus 8
+// and the array size eats another 4 bytes
+
+/**
+ * ArrayUtils contains some methods that you can call to find out the most efficient increments by
+ * which to grow arrays.
+ */
+/* package */ class ArrayUtils {
+    private static final Object[] EMPTY = new Object[0];
+    private static final int CACHE_SIZE = 73;
+    private static Object[] sCache = new Object[CACHE_SIZE];
+
+    private ArrayUtils() {
+        /* cannot be instantiated */
+    }
+
+    public static int idealByteArraySize(int need) {
+        for (int i = 4; i < 32; i++) if (need <= (1 << i) - 12) return (1 << i) - 12;
+
+        return need;
+    }
+
+    public static int idealBooleanArraySize(int need) {
+        return idealByteArraySize(need);
+    }
+
+    public static int idealShortArraySize(int need) {
+        return idealByteArraySize(need * 2) / 2;
+    }
+
+    public static int idealCharArraySize(int need) {
+        return idealByteArraySize(need * 2) / 2;
+    }
+
+    public static int idealIntArraySize(int need) {
+        return idealByteArraySize(need * 4) / 4;
+    }
+
+    public static int idealFloatArraySize(int need) {
+        return idealByteArraySize(need * 4) / 4;
+    }
+
+    public static int idealObjectArraySize(int need) {
+        return idealByteArraySize(need * 4) / 4;
+    }
+
+    public static int idealLongArraySize(int need) {
+        return idealByteArraySize(need * 8) / 8;
+    }
+
+    /**
+     * Checks if the beginnings of two byte arrays are equal.
+     *
+     * @param array1 the first byte array
+     * @param array2 the second byte array
+     * @param length the number of bytes to check
+     * @return true if they're equal, false otherwise
+     */
+    public static boolean equals(byte[] array1, byte[] array2, int length) {
+        if (array1 == array2) {
+            return true;
+        }
+        if (array1 == null || array2 == null || array1.length < length || array2.length < length) {
+            return false;
+        }
+        for (int i = 0; i < length; i++) {
+            if (array1[i] != array2[i]) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Returns an empty array of the specified type. The intent is that it will return the same
+     * empty array every time to avoid reallocation, although this is not guaranteed.
+     */
+    @SuppressWarnings("unchecked")
+    public static <T> T[] emptyArray(Class<T> kind) {
+        if (kind == Object.class) {
+            return (T[]) EMPTY;
+        }
+
+        int bucket = ((System.identityHashCode(kind) / 8) & 0x7FFFFFFF) % CACHE_SIZE;
+        Object cache = sCache[bucket];
+
+        if (cache == null || cache.getClass().getComponentType() != kind) {
+            cache = Array.newInstance(kind, 0);
+            sCache[bucket] = cache;
+
+            // Log.e("cache", "new empty " + kind.getName() + " at " + bucket);
+        }
+
+        return (T[]) cache;
+    }
+
+    /**
+     * Checks that value is present as at least one of the elements of the array.
+     *
+     * @param array the array to check in
+     * @param value the value to check for
+     * @return true if the value is present in the array
+     */
+    public static <T> boolean contains(T[] array, T value) {
+        for (T element : array) {
+            if (element == null) {
+                if (value == null) return true;
+            } else {
+                if (value != null && element.equals(value)) return true;
+            }
+        }
+        return false;
+    }
+}
diff --git a/common_util/com/android/utils/Pair.java b/common_util/com/android/utils/Pair.java
new file mode 100644
index 000000000..0764aed0c
--- /dev/null
+++ b/common_util/com/android/utils/Pair.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.utils;
+
+/**
+ * A Pair class is simply a 2-tuple for use in this package. We might want to think about adding
+ * something like this to a more central utility place, or replace it by a common tuple class if one
+ * exists, or even rewrite the layout classes using this Pair by a more dedicated data structure (so
+ * we don't have to pass around generic signatures as is currently done, though at least the
+ * construction is helped a bit by the {@link #of} factory method.
+ *
+ * @param <S> The type of the first value
+ * @param <T> The type of the second value
+ */
+public final class Pair<S, T> {
+    private final S mFirst;
+    private final T mSecond;
+
+    // Use {@link Pair#of} factory instead since it infers generic types
+    private Pair(S first, T second) {
+        this.mFirst = first;
+        this.mSecond = second;
+    }
+
+    /**
+     * Return the first item in the pair
+     *
+     * @return the first item in the pair
+     */
+    public S getFirst() {
+        return mFirst;
+    }
+
+    /**
+     * Return the second item in the pair
+     *
+     * @return the second item in the pair
+     */
+    public T getSecond() {
+        return mSecond;
+    }
+
+    /**
+     * Constructs a new pair of the given two objects, inferring generic types.
+     *
+     * @param first the first item to store in the pair
+     * @param second the second item to store in the pair
+     * @param <S> the type of the first item
+     * @param <T> the type of the second item
+     * @return a new pair wrapping the two items
+     */
+    public static <S, T> Pair<S, T> of(S first, T second) {
+        return new Pair<S, T>(first, second);
+    }
+
+    @Override
+    public String toString() {
+        return "Pair [first=" + mFirst + ", second=" + mSecond + "]";
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + ((mFirst == null) ? 0 : mFirst.hashCode());
+        result = prime * result + ((mSecond == null) ? 0 : mSecond.hashCode());
+        return result;
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) return true;
+        if (obj == null) return false;
+        if (getClass() != obj.getClass()) return false;
+        Pair other = (Pair) obj;
+        if (mFirst == null) {
+            if (other.mFirst != null) return false;
+        } else if (!mFirst.equals(other.mFirst)) return false;
+        if (mSecond == null) {
+            if (other.mSecond != null) return false;
+        } else if (!mSecond.equals(other.mSecond)) return false;
+        return true;
+    }
+}
diff --git a/common_util/com/android/utils/SparseIntArray.java b/common_util/com/android/utils/SparseIntArray.java
new file mode 100644
index 000000000..daf7653b7
--- /dev/null
+++ b/common_util/com/android/utils/SparseIntArray.java
@@ -0,0 +1,212 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.utils;
+
+/**
+ * SparseIntArrays map integers to integers. Unlike a normal array of integers, there can be gaps in
+ * the indices. It is intended to be more efficient than using a HashMap to map Integers to
+ * Integers.
+ */
+public class SparseIntArray {
+    /** Creates a new SparseIntArray containing no mappings. */
+    public SparseIntArray() {
+        this(10);
+    }
+
+    /**
+     * Creates a new SparseIntArray containing no mappings that will not require any additional
+     * memory allocation to store the specified number of mappings.
+     */
+    public SparseIntArray(int initialCapacity) {
+        initialCapacity = ArrayUtils.idealIntArraySize(initialCapacity);
+
+        mKeys = new int[initialCapacity];
+        mValues = new int[initialCapacity];
+        mSize = 0;
+    }
+
+    /**
+     * Gets the int mapped from the specified key, or <code>0</code> if no such mapping has been
+     * made.
+     */
+    public int get(int key) {
+        return get(key, 0);
+    }
+
+    /**
+     * Gets the int mapped from the specified key, or the specified value if no such mapping has
+     * been made.
+     */
+    public int get(int key, int valueIfKeyNotFound) {
+        int i = binarySearch(mKeys, 0, mSize, key);
+
+        if (i < 0) {
+            return valueIfKeyNotFound;
+        } else {
+            return mValues[i];
+        }
+    }
+
+    /** Removes the mapping from the specified key, if there was any. */
+    public void delete(int key) {
+        int i = binarySearch(mKeys, 0, mSize, key);
+
+        if (i >= 0) {
+            removeAt(i);
+        }
+    }
+
+    /** Removes the mapping at the given index. */
+    public void removeAt(int index) {
+        System.arraycopy(mKeys, index + 1, mKeys, index, mSize - (index + 1));
+        System.arraycopy(mValues, index + 1, mValues, index, mSize - (index + 1));
+        mSize--;
+    }
+
+    /**
+     * Adds a mapping from the specified key to the specified value, replacing the previous mapping
+     * from the specified key if there was one.
+     */
+    public void put(int key, int value) {
+        int i = binarySearch(mKeys, 0, mSize, key);
+
+        if (i >= 0) {
+            mValues[i] = value;
+        } else {
+            i = ~i;
+
+            if (mSize >= mKeys.length) {
+                int n = ArrayUtils.idealIntArraySize(mSize + 1);
+
+                int[] nkeys = new int[n];
+                int[] nvalues = new int[n];
+
+                // Log.e("SparseIntArray", "grow " + mKeys.length + " to " + n);
+                System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
+                System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
+
+                mKeys = nkeys;
+                mValues = nvalues;
+            }
+
+            if (mSize - i != 0) {
+                // Log.e("SparseIntArray", "move " + (mSize - i));
+                System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
+                System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
+            }
+
+            mKeys[i] = key;
+            mValues[i] = value;
+            mSize++;
+        }
+    }
+
+    /** Returns the number of key-value mappings that this SparseIntArray currently stores. */
+    public int size() {
+        return mSize;
+    }
+
+    /**
+     * Given an index in the range <code>0...size()-1</code>, returns the key from the <code>index
+     * </code>th key-value mapping that this SparseIntArray stores.
+     */
+    public int keyAt(int index) {
+        return mKeys[index];
+    }
+
+    /**
+     * Given an index in the range <code>0...size()-1</code>, returns the value from the <code>index
+     * </code>th key-value mapping that this SparseIntArray stores.
+     */
+    public int valueAt(int index) {
+        return mValues[index];
+    }
+
+    /**
+     * Returns the index for which {@link #keyAt} would return the specified key, or a negative
+     * number if the specified key is not mapped.
+     */
+    public int indexOfKey(int key) {
+        return binarySearch(mKeys, 0, mSize, key);
+    }
+
+    /**
+     * Returns an index for which {@link #valueAt} would return the specified key, or a negative
+     * number if no keys map to the specified value. Beware that this is a linear search, unlike
+     * lookups by key, and that multiple keys can map to the same value and this will find only one
+     * of them.
+     */
+    public int indexOfValue(int value) {
+        for (int i = 0; i < mSize; i++) if (mValues[i] == value) return i;
+
+        return -1;
+    }
+
+    /** Removes all key-value mappings from this SparseIntArray. */
+    public void clear() {
+        mSize = 0;
+    }
+
+    /**
+     * Puts a key/value pair into the array, optimizing for the case where the key is greater than
+     * all existing keys in the array.
+     */
+    public void append(int key, int value) {
+        if (mSize != 0 && key <= mKeys[mSize - 1]) {
+            put(key, value);
+            return;
+        }
+
+        int pos = mSize;
+        if (pos >= mKeys.length) {
+            int n = ArrayUtils.idealIntArraySize(pos + 1);
+
+            int[] nkeys = new int[n];
+            int[] nvalues = new int[n];
+
+            // Log.e("SparseIntArray", "grow " + mKeys.length + " to " + n);
+            System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
+            System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
+
+            mKeys = nkeys;
+            mValues = nvalues;
+        }
+
+        mKeys[pos] = key;
+        mValues[pos] = value;
+        mSize = pos + 1;
+    }
+
+    private static int binarySearch(int[] a, int start, int len, int key) {
+        int high = start + len, low = start - 1, guess;
+
+        while (high - low > 1) {
+            guess = (high + low) / 2;
+
+            if (a[guess] < key) low = guess;
+            else high = guess;
+        }
+
+        if (high == start + len) return ~(start + len);
+        else if (a[high] == key) return high;
+        else return ~high;
+    }
+
+    private int[] mKeys;
+    private int[] mValues;
+    private int mSize;
+}
diff --git a/device_build_interfaces/Android.bp b/device_build_interfaces/Android.bp
index 656b3bf39..885014ffd 100644
--- a/device_build_interfaces/Android.bp
+++ b/device_build_interfaces/Android.bp
@@ -28,7 +28,6 @@ java_library_host {
         "com/**/*.java",
     ],
     libs: [
-        "ddmlib-prebuilt",
         "error_prone_annotations",
         "guava",
         "tradefed-protos",
@@ -36,6 +35,7 @@ java_library_host {
         "tradefed-common-util",
         "tf-remote-client",
         "tradefed-result-interfaces",
+        "kxml2-2.3.0",
     ],
     // b/267831518: Pin tradefed and dependencies to Java 11.
     java_version: "11",
diff --git a/device_build_interfaces/com/android/ddmlib/AdbCommandRejectedException.java b/device_build_interfaces/com/android/ddmlib/AdbCommandRejectedException.java
new file mode 100644
index 000000000..6e2a2a8f2
--- /dev/null
+++ b/device_build_interfaces/com/android/ddmlib/AdbCommandRejectedException.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ddmlib;
+
+/** Exception thrown when adb refuses a command. */
+public class AdbCommandRejectedException extends Exception {
+    private static final long serialVersionUID = 1L;
+    private final boolean mIsDeviceOffline;
+    private final boolean mErrorDuringDeviceSelection;
+
+    public AdbCommandRejectedException(String message) {
+        super(message);
+        mIsDeviceOffline = "device offline".equals(message);
+        mErrorDuringDeviceSelection = false;
+    }
+
+    public AdbCommandRejectedException(String message, boolean errorDuringDeviceSelection) {
+        super(message);
+        mErrorDuringDeviceSelection = errorDuringDeviceSelection;
+        mIsDeviceOffline = "device offline".equals(message);
+    }
+
+    /** Returns true if the error is due to the device being offline. */
+    public boolean isDeviceOffline() {
+        return mIsDeviceOffline;
+    }
+
+    /**
+     * Returns whether adb refused to target a given device for the command.
+     *
+     * <p>If false, adb refused the command itself, if true, it refused to target the given device.
+     */
+    public boolean wasErrorDuringDeviceSelection() {
+        return mErrorDuringDeviceSelection;
+    }
+
+    /**
+     * @deprecated This method should only be used by ddmlib to adblib migration code.
+     */
+    @Deprecated
+    public static AdbCommandRejectedException create(String message) {
+        return new AdbCommandRejectedException(message);
+    }
+}
diff --git a/device_build_interfaces/com/android/ddmlib/AvdData.java b/device_build_interfaces/com/android/ddmlib/AvdData.java
new file mode 100644
index 000000000..61ed1a447
--- /dev/null
+++ b/device_build_interfaces/com/android/ddmlib/AvdData.java
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.ddmlib;
+
+import com.android.annotations.Nullable;
+
+import java.nio.file.InvalidPathException;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.Objects;
+
+/** Avd data returned from [IDevice.getAvdData]. */
+public class AvdData {
+
+    @Nullable private final String name;
+
+    @Nullable private final Path nioPath;
+
+    public AvdData(@Nullable String name, @Nullable Path nioPath) {
+        this.name = name;
+        this.nioPath = nioPath;
+    }
+
+    /**
+     * @deprecated Use {@link #AvdData(String, Path)}
+     */
+    @Deprecated
+    public AvdData(@Nullable String name, @Nullable String path) {
+        this.name = name;
+        nioPath = initNioPath(path);
+    }
+
+    @Nullable
+    private static Path initNioPath(@Nullable String path) {
+        if (path == null) {
+            return null;
+        }
+
+        try {
+            return Paths.get(path);
+        } catch (InvalidPathException exception) {
+            return null;
+        }
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(name, nioPath);
+    }
+
+    @Override
+    public boolean equals(@Nullable Object object) {
+        if (!(object instanceof AvdData)) {
+            return false;
+        }
+
+        AvdData avd = (AvdData) object;
+        return Objects.equals(name, avd.name) && Objects.equals(nioPath, avd.nioPath);
+    }
+
+    /** The name of the AVD or null if unavailable or this is a physical device. */
+    @Nullable
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * Returns the absolute path to the virtual device in the file system or null if the emulator
+     * console subcommand failed
+     */
+    @Nullable
+    public Path getNioPath() {
+        return nioPath;
+    }
+
+    /**
+     * The path of the AVD or null if unavailable or this is a physical device.
+     *
+     * <p>The path is the absolute path to the virtual device in the file system. The path is
+     * operating system dependent; it will have / name separators on Linux and \ separators on
+     * Windows.
+     *
+     * @deprecated Use {@link #getNioPath}
+     */
+    @Deprecated
+    @Nullable
+    public String getPath() {
+        if (nioPath == null) {
+            return null;
+        }
+
+        return nioPath.toString();
+    }
+}
diff --git a/device_build_interfaces/com/android/ddmlib/ByteBufferUtil.java b/device_build_interfaces/com/android/ddmlib/ByteBufferUtil.java
new file mode 100644
index 000000000..23aabeacd
--- /dev/null
+++ b/device_build_interfaces/com/android/ddmlib/ByteBufferUtil.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.ddmlib;
+
+import com.android.annotations.NonNull;
+import com.android.tradefed.log.LogUtil.CLog;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+import java.lang.reflect.Field;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.MappedByteBuffer;
+import java.nio.channels.FileChannel;
+
+public class ByteBufferUtil {
+
+    @NonNull
+    public static ByteBuffer mapFile(@NonNull File f, long offset, @NonNull ByteOrder byteOrder)
+            throws IOException {
+        FileInputStream dataFile = new FileInputStream(f);
+        try {
+            FileChannel fc = dataFile.getChannel();
+            MappedByteBuffer buffer =
+                    fc.map(FileChannel.MapMode.READ_ONLY, offset, f.length() - offset);
+            buffer.order(byteOrder);
+            return buffer;
+        } finally {
+            dataFile.close(); // this *also* closes the associated channel, fc
+        }
+    }
+
+    @NonNull
+    public static String getString(@NonNull ByteBuffer buf, int len) {
+        char[] data = new char[len];
+        for (int i = 0; i < len; i++) data[i] = buf.getChar();
+        return new String(data);
+    }
+
+    public static void putString(@NonNull ByteBuffer buf, @NonNull String str) {
+        int len = str.length();
+        for (int i = 0; i < len; i++) buf.putChar(str.charAt(i));
+    }
+
+    /** Please use with care. In most cases leaving the job to the GC is enough. */
+    public static boolean cleanBuffer(@NonNull ByteBuffer buffer) {
+        if (!buffer.isDirect()) return true;
+
+        // in Java 9+, the "official" dispose method is sun.misc.Unsafe#invokeCleaner
+        try {
+            Class<?> unsafeClass =
+                    ByteBufferUtil.class.getClassLoader().loadClass("sun.misc.Unsafe");
+            Field f = unsafeClass.getDeclaredField("theUnsafe");
+            f.setAccessible(true);
+            Object unsafe = f.get(null);
+            MethodType type = MethodType.methodType(void.class, ByteBuffer.class);
+            @SuppressWarnings("JavaLangInvokeHandleSignature")
+            MethodHandle handle =
+                    MethodHandles.lookup().findVirtual(unsafeClass, "invokeCleaner", type);
+            handle.invoke(unsafeClass.cast(unsafe), buffer);
+            return true;
+        } catch (Throwable ex) {
+            // ignore, this is a best effort attempt.
+            CLog.w("ByteBufferUtil.cleanBuffer() failed " + ex);
+            return false;
+        }
+    }
+}
diff --git a/device_build_interfaces/com/android/ddmlib/CanceledException.java b/device_build_interfaces/com/android/ddmlib/CanceledException.java
new file mode 100644
index 000000000..dae0ddaa7
--- /dev/null
+++ b/device_build_interfaces/com/android/ddmlib/CanceledException.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ddmlib;
+
+/**
+ * Abstract exception for exception that can be thrown when a user input cancels the action.
+ *
+ * <p>{@link #wasCanceled()} returns whether the action was canceled because of user input.
+ */
+public abstract class CanceledException extends Exception {
+    private static final long serialVersionUID = 1L;
+
+    CanceledException(String message) {
+        super(message);
+    }
+
+    CanceledException(String message, Throwable cause) {
+        super(message, cause);
+    }
+
+    /** Returns true if the action was canceled by user input. */
+    public abstract boolean wasCanceled();
+}
diff --git a/device_build_interfaces/com/android/ddmlib/CollectingOutputReceiver.java b/device_build_interfaces/com/android/ddmlib/CollectingOutputReceiver.java
new file mode 100644
index 000000000..57a4c0f02
--- /dev/null
+++ b/device_build_interfaces/com/android/ddmlib/CollectingOutputReceiver.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.ddmlib;
+
+import static java.nio.charset.StandardCharsets.UTF_8;
+
+import com.android.annotations.NonNull;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+/** A {@link IShellOutputReceiver} which collects the whole shell output into one {@link String}. */
+public class CollectingOutputReceiver implements IShellOutputReceiver {
+    @NonNull private final CountDownLatch mCompletionLatch;
+    @NonNull private final StringBuffer mOutputBuffer = new StringBuffer();
+    @NonNull private final AtomicBoolean mIsCanceled = new AtomicBoolean(false);
+
+    public CollectingOutputReceiver() {
+        mCompletionLatch = new CountDownLatch(1);
+    }
+
+    public CollectingOutputReceiver(@NonNull CountDownLatch commandCompleteLatch) {
+        mCompletionLatch = commandCompleteLatch;
+    }
+
+    @NonNull
+    public String getOutput() {
+        return mOutputBuffer.toString();
+    }
+
+    @Override
+    public boolean isCancelled() {
+        return mIsCanceled.get();
+    }
+
+    /** Cancels the output collection. */
+    public void cancel() {
+        mIsCanceled.set(true);
+    }
+
+    @Override
+    public void addOutput(byte[] data, int offset, int length) {
+        if (!isCancelled()) {
+            String s = new String(data, offset, length, UTF_8);
+            mOutputBuffer.append(s);
+        }
+    }
+
+    @Override
+    public void flush() {
+        mCompletionLatch.countDown();
+    }
+
+    public boolean isComplete() {
+        return mCompletionLatch.getCount() == 0;
+    }
+
+    public boolean awaitCompletion(long timeout, TimeUnit unit) throws InterruptedException {
+        return mCompletionLatch.await(timeout, unit);
+    }
+}
diff --git a/device_build_interfaces/com/android/ddmlib/DdmPreferences.java b/device_build_interfaces/com/android/ddmlib/DdmPreferences.java
new file mode 100644
index 000000000..6ea56bd45
--- /dev/null
+++ b/device_build_interfaces/com/android/ddmlib/DdmPreferences.java
@@ -0,0 +1,275 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ddmlib;
+
+import com.android.ddmlib.Log.LogLevel;
+
+import java.util.function.Function;
+
+/**
+ * Preferences for the ddm library.
+ *
+ * <p>This class does not handle storing the preferences. It is merely a central point for
+ * applications using the ddmlib to override the default values.
+ *
+ * <p>Various components of the ddmlib query this class to get their values.
+ *
+ * <p>Calls to some <code>set##()</code> methods will update the components using the values right
+ * away, while other methods will have no effect once {@link AndroidDebugBridge#init(boolean)} has
+ * been called.
+ *
+ * <p>Check the documentation of each method.
+ */
+public final class DdmPreferences {
+
+    /** Default value for thread update flag upon client connection. */
+    public static final boolean DEFAULT_INITIAL_THREAD_UPDATE = false;
+
+    /** Default value for heap update flag upon client connection. */
+    public static final boolean DEFAULT_INITIAL_HEAP_UPDATE = false;
+
+    /** Default value for the logcat {@link LogLevel} */
+    public static final LogLevel DEFAULT_LOG_LEVEL = LogLevel.ERROR;
+
+    /** Default timeout values for adb connection (milliseconds) */
+    public static final int DEFAULT_TIMEOUT = 5000; // standard delay, in ms
+
+    /** Default profiler buffer size (megabytes) */
+    public static final int DEFAULT_PROFILER_BUFFER_SIZE_MB = 8;
+
+    /** Default values for the use of the ADBHOST environment variable. */
+    public static final boolean DEFAULT_USE_ADBHOST = false;
+
+    public static final String DEFAULT_ADBHOST_VALUE = "127.0.0.1";
+
+    private static boolean sThreadUpdate = DEFAULT_INITIAL_THREAD_UPDATE;
+    private static boolean sInitialHeapUpdate = DEFAULT_INITIAL_HEAP_UPDATE;
+
+    private static LogLevel sLogLevel = DEFAULT_LOG_LEVEL;
+    private static int sTimeOut = DEFAULT_TIMEOUT;
+    private static int sProfilerBufferSizeMb = DEFAULT_PROFILER_BUFFER_SIZE_MB;
+
+    private static boolean sUseAdbHost = DEFAULT_USE_ADBHOST;
+    private static String sAdbHostValue = DEFAULT_ADBHOST_VALUE;
+    private static int sJdwpMaxPacketSize =
+            getPropertyOrDefault(
+                    "DDMLIB_JDWP_MAX_PACKET_SIZE", 800 * 1024 * 1024, Integer::parseInt);
+
+    /** Enable / Disable the JdwpProxy feature. */
+    private static boolean sJdwpProxyEnabled =
+            getPropertyOrDefault("DDMLIB_JDWP_PROXY_ENABLED", false, Boolean::parseBoolean);
+
+    /** Port used by JdwpProxy feature */
+    private static int sJdwpProxyPort =
+            getPropertyOrDefault("DDMLIB_JDWP_PROXY_PORT", 8599, Integer::parseInt);
+
+    /** Enable / Disable the Ddmlib Command service feature. */
+    private static boolean sDdmlibCommandServiceEnabled =
+            getPropertyOrDefault("DDMLIB_COMMAND_SERVICE_ENABLED", false, Boolean::parseBoolean);
+
+    /** Port used by JdwpProxy feature */
+    private static int sDdmCommandPort =
+            getPropertyOrDefault("DDMLIB_COMMAND_PORT", 8598, Integer::parseInt);
+
+    /**
+     * Returns the initial {@link Client} flag for thread updates.
+     *
+     * @see #setInitialThreadUpdate(boolean)
+     */
+    public static boolean getInitialThreadUpdate() {
+        return sThreadUpdate;
+    }
+
+    /**
+     * Sets the initial {@link Client} flag for thread updates.
+     *
+     * <p>This change takes effect right away, for newly created {@link Client} objects.
+     */
+    public static void setInitialThreadUpdate(boolean state) {
+        sThreadUpdate = state;
+    }
+
+    /**
+     * Returns the initial {@link Client} flag for heap updates.
+     *
+     * @see #setInitialHeapUpdate(boolean)
+     */
+    public static boolean getInitialHeapUpdate() {
+        return sInitialHeapUpdate;
+    }
+
+    /**
+     * Sets the initial {@link Client} flag for heap updates.
+     *
+     * <p>If <code>true</code>, the {@link ClientData} will automatically be updated with the VM
+     * heap information whenever a GC happens.
+     *
+     * <p>This change takes effect right away, for newly created {@link Client} objects.
+     */
+    public static void setInitialHeapUpdate(boolean state) {
+        sInitialHeapUpdate = state;
+    }
+
+    /** Returns the minimum {@link LogLevel} being displayed. */
+    public static LogLevel getLogLevel() {
+        return sLogLevel;
+    }
+
+    /**
+     * Sets the minimum {@link LogLevel} to display.
+     *
+     * <p>This change takes effect right away.
+     */
+    public static void setLogLevel(String value) {
+        sLogLevel = LogLevel.getByString(value);
+    }
+
+    /** Returns the timeout to be used in adb connections (milliseconds). */
+    public static int getTimeOut() {
+        return sTimeOut;
+    }
+
+    /**
+     * Sets the timeout value for adb connection.
+     *
+     * <p>This change takes effect for newly created connections only.
+     *
+     * @param timeOut the timeout value (milliseconds).
+     */
+    public static void setTimeOut(int timeOut) {
+        sTimeOut = timeOut;
+    }
+
+    /** Returns the profiler buffer size (megabytes). */
+    public static int getProfilerBufferSizeMb() {
+        return sProfilerBufferSizeMb;
+    }
+
+    /**
+     * Sets the profiler buffer size value.
+     *
+     * @param bufferSizeMb the buffer size (megabytes).
+     */
+    public static void setProfilerBufferSizeMb(int bufferSizeMb) {
+        sProfilerBufferSizeMb = bufferSizeMb;
+    }
+
+    /** Returns a boolean indicating that the user uses or not the variable ADBHOST. */
+    public static boolean getUseAdbHost() {
+        return sUseAdbHost;
+    }
+
+    /**
+     * Sets the value of the boolean indicating that the user uses or not the variable ADBHOST.
+     *
+     * @param useAdbHost true if the user uses ADBHOST
+     */
+    public static void setUseAdbHost(boolean useAdbHost) {
+        sUseAdbHost = useAdbHost;
+    }
+
+    /** Returns the value of the ADBHOST variable set by the user. */
+    public static String getAdbHostValue() {
+        return sAdbHostValue;
+    }
+
+    /**
+     * Sets the value of the ADBHOST variable.
+     *
+     * @param adbHostValue
+     */
+    public static void setAdbHostValue(String adbHostValue) {
+        sAdbHostValue = adbHostValue;
+    }
+
+    /**
+     * Enable jdwp proxy service allowing for multiple client support DDMLIB clients to be used at
+     * the same time.
+     */
+    public static void enableJdwpProxyService(boolean enabled) {
+        sJdwpProxyEnabled = enabled;
+    }
+
+    public static boolean isJdwpProxyEnabled() {
+        return sJdwpProxyEnabled;
+    }
+
+    /**
+     * Set the port used by the jdwp proxy service. This port should be consistent across all
+     * instances of the jdwp proxy service run on a single machine.
+     *
+     * @param port
+     */
+    public static void setJdwpProxyPort(int port) {
+        sJdwpProxyPort = port;
+    }
+
+    public static int getJdwpProxyPort() {
+        return sJdwpProxyPort;
+    }
+
+    /**
+     * Set the port used by the ddmlib command service. This port is fixed so external services, can
+     * send commands to any running instances of ddmlib.
+     *
+     * @param port
+     */
+    public static void setDdmCommandPort(int port) {
+        sDdmCommandPort = port;
+    }
+
+    public static int getDdmCommandPort() {
+        return sDdmCommandPort;
+    }
+
+    /**
+     * Enable ddmlib command service allowing for external processes (eg ICEBOX) to issue commands
+     * to ddmlib.
+     */
+    public static void enableDdmlibCommandService(boolean enabled) {
+        sDdmlibCommandServiceEnabled = enabled;
+    }
+
+    public static boolean isDdmlibCommandServiceEnabled() {
+        return sDdmlibCommandServiceEnabled;
+    }
+
+    private static <T> T getPropertyOrDefault(String property, T def, Function<String, T> parser) {
+        try {
+            return parser.apply(System.getProperty(property, def + ""));
+        } catch (Exception ignored) {
+            return def;
+        }
+    }
+
+    /**
+     * Packets that are larger than this will throw a buffer overflow exception and disconnect the
+     * client.
+     */
+    public static int getJdwpMaxPacketSize() {
+        return sJdwpMaxPacketSize;
+    }
+
+    public static void setsJdwpMaxPacketSize(int size) {
+        sJdwpMaxPacketSize = size;
+    }
+
+    /** Non accessible constructor. */
+    private DdmPreferences() {
+        // pass, only static methods in the class.
+    }
+}
diff --git a/device_build_interfaces/com/android/ddmlib/FileListingService.java b/device_build_interfaces/com/android/ddmlib/FileListingService.java
new file mode 100644
index 000000000..5a98740e9
--- /dev/null
+++ b/device_build_interfaces/com/android/ddmlib/FileListingService.java
@@ -0,0 +1,883 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ddmlib;
+
+import com.android.annotations.NonNull;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/** Provides {@link IDevice} side file listing service. */
+public final class FileListingService {
+
+    /** Pattern to find filenames that match "*.apk" */
+    private static final Pattern sApkPattern =
+            Pattern.compile(".*\\.apk", Pattern.CASE_INSENSITIVE); // $NON-NLS-1$
+
+    private static final String PM_FULL_LISTING = "pm list packages -f"; // $NON-NLS-1$
+
+    /**
+     * Pattern to parse the output of the 'pm -lf' command.<br>
+     * The output format looks like:<br>
+     * /data/app/myapp.apk=com.mypackage.myapp
+     */
+    private static final Pattern sPmPattern =
+            Pattern.compile("^package:(.+?)=(.+)$"); // $NON-NLS-1$
+
+    /** Top level data folder. */
+    public static final String DIRECTORY_DATA = "data"; // $NON-NLS-1$
+
+    /** Top level sdcard folder. */
+    public static final String DIRECTORY_SDCARD = "sdcard"; // $NON-NLS-1$
+
+    /** Top level mount folder. */
+    public static final String DIRECTORY_MNT = "mnt"; // $NON-NLS-1$
+
+    /** Top level system folder. */
+    public static final String DIRECTORY_SYSTEM = "system"; // $NON-NLS-1$
+
+    /** Top level temp folder. */
+    public static final String DIRECTORY_TEMP = "tmp"; // $NON-NLS-1$
+
+    /** Application folder. */
+    public static final String DIRECTORY_APP = "app"; // $NON-NLS-1$
+
+    public static final long REFRESH_RATE = 5000L;
+
+    /** Refresh test has to be slightly lower for precision issue. */
+    static final long REFRESH_TEST = (long) (REFRESH_RATE * .8);
+
+    /** Entry type: File */
+    public static final int TYPE_FILE = 0;
+
+    /** Entry type: Directory */
+    public static final int TYPE_DIRECTORY = 1;
+
+    /** Entry type: Directory Link */
+    public static final int TYPE_DIRECTORY_LINK = 2;
+
+    /** Entry type: Block */
+    public static final int TYPE_BLOCK = 3;
+
+    /** Entry type: Character */
+    public static final int TYPE_CHARACTER = 4;
+
+    /** Entry type: Link */
+    public static final int TYPE_LINK = 5;
+
+    /** Entry type: Socket */
+    public static final int TYPE_SOCKET = 6;
+
+    /** Entry type: FIFO */
+    public static final int TYPE_FIFO = 7;
+
+    /** Entry type: Other */
+    public static final int TYPE_OTHER = 8;
+
+    /** Device side file separator. */
+    public static final String FILE_SEPARATOR = "/"; // $NON-NLS-1$
+
+    private static final String FILE_ROOT = "/"; // $NON-NLS-1$
+
+    /** Regexp pattern to parse the result from ls. */
+    public static final Pattern LS_L_PATTERN =
+            Pattern.compile(
+                    "^([bcdlsp-][-r][-w][-xsS][-r][-w][-xsS][-r][-w][-xstST])\\s+"
+                            + "(?:\\d+\\s+)?"
+                            + // toolbox ls (<=M) didn't have nlink; toybox's POSIX ls does.
+                            "(\\S+)\\s+(\\S+)\\s+"
+                          + "([\\d\\s,]*)\\s+(\\d{4}-\\d\\d-\\d\\d)\\s+(\\d\\d:\\d\\d)\\s+(.*)$"); //$NON-NLS-1$
+
+    public static final Pattern LS_LD_PATTERN =
+            Pattern.compile(
+                    "d[rwxs-]{9}\\s+"
+                            + // We only use this to match directories!
+                            "(\\d+\\s+)?"
+                            + // toolbox ls (<=M) didn't have nlink; toybox's POSIX ls does.
+                            "\\S+\\s+\\S+\\s+"
+                            + "(\\d+\\s+)?"
+                            + // toolbox ls (<=M) didn't have size; toybox's POSIX ls does.
+                            "[0-9-]{10}\\s+\\d{2}:\\d{2}"
+                            + ".*"
+                            + // toolbox ls (<=M) didn't have the filename in the "/sdcard/" case!
+                            "$"); //$NON-NLS-1$
+
+    /**
+     * Regexp pattern to parse the result from stat. Ex. drwxr-xr-x root root 2021-08-02
+     * 09:20:53.000000000 -0700 4096 /
+     */
+    public static final Pattern STAT_PATTERN =
+            Pattern.compile(
+                    "^([bcdlsp-][-r][-w][-xsS][-r][-w][-xsS][-r][-w][-xstST])\\s+"
+                            + "(\\S+)\\s+"
+                            + "(\\S+)\\s+"
+                            + "(\\d{4}-\\d\\d-\\d\\d)\\s+"
+                            + "(\\d\\d:\\d\\d:\\d\\d\\.\\d+)\\s+"
+                            + "([+-]?\\d+\\s+)?"
+                            + "(\\d+)\\s+"
+                            + "(.*)"
+                            + "$");
+
+    private IDevice mDevice;
+    private FileEntry mRoot;
+
+    // Used for locking so final.
+    private final ArrayList<Thread> mThreadList = new ArrayList<Thread>();
+
+    /** Represents an entry in a directory. This can be a file or a directory. */
+    public static final class FileEntry {
+        /**
+         * Pattern to escape filenames for shell command consumption. This pattern identifies any
+         * special characters that need to be escaped with a backslash.
+         */
+        private static final Pattern sEscapePattern =
+                Pattern.compile("([\\\\()*+?\"'&$#/\\s])"); // $NON-NLS-1$
+
+        /** Comparator object for FileEntry */
+        private static Comparator<FileEntry> sEntryComparator =
+                new Comparator<FileEntry>() {
+                    @Override
+                    public int compare(FileEntry o1, FileEntry o2) {
+                        if (o1 instanceof FileEntry && o2 instanceof FileEntry) {
+                            FileEntry fe1 = o1;
+                            FileEntry fe2 = o2;
+                            return fe1.name.compareTo(fe2.name);
+                        }
+                        return 0;
+                    }
+                };
+
+        FileEntry parent;
+        String name;
+        String info;
+        String permissions;
+        String size;
+        String date;
+        String time;
+        String owner;
+        String group;
+        int type;
+        boolean isAppPackage;
+
+        boolean isRoot;
+
+        /** Indicates whether the entry content has been fetched yet, or not. */
+        long fetchTime = 0;
+
+        final ArrayList<FileEntry> mChildren = new ArrayList<FileEntry>();
+
+        /**
+         * Creates a new file entry.
+         *
+         * @param parent parent entry or null if entry is root
+         * @param name name of the entry.
+         * @param type entry type. Can be one of the following: {@link
+         *     FileListingService#TYPE_FILE}, {@link FileListingService#TYPE_DIRECTORY}, {@link
+         *     FileListingService#TYPE_OTHER}.
+         * @param isRoot whether this is the root dir or not.
+         */
+        public FileEntry(FileEntry parent, String name, int type, boolean isRoot) {
+            this.parent = parent;
+            this.name = name;
+            this.type = type;
+            this.isRoot = isRoot;
+
+            checkAppPackageStatus();
+        }
+
+        /** Returns the name of the entry */
+        public String getName() {
+            return name;
+        }
+
+        /** Returns the size string of the entry, as returned by <code>ls</code>. */
+        public String getSize() {
+            return size;
+        }
+
+        /** Returns the size of the entry. */
+        public int getSizeValue() {
+            return Integer.parseInt(size);
+        }
+
+        /** Returns the date string of the entry, as returned by <code>ls</code>. */
+        public String getDate() {
+            return date;
+        }
+
+        /** Returns the time string of the entry, as returned by <code>ls</code>. */
+        public String getTime() {
+            return time;
+        }
+
+        /** Returns the permission string of the entry, as returned by <code>ls</code>. */
+        public String getPermissions() {
+            return permissions;
+        }
+
+        /** Returns the owner string of the entry, as returned by <code>ls</code>. */
+        public String getOwner() {
+            return owner;
+        }
+
+        /** Returns the group owner of the entry, as returned by <code>ls</code>. */
+        public String getGroup() {
+            return group;
+        }
+
+        /**
+         * Returns the extra info for the entry.
+         *
+         * <p>For a link, it will be a description of the link.
+         *
+         * <p>For an application apk file it will be the application package as returned by the
+         * Package Manager.
+         */
+        public String getInfo() {
+            return info;
+        }
+
+        /**
+         * Return the full path of the entry.
+         *
+         * @return a path string using {@link FileListingService#FILE_SEPARATOR} as separator.
+         */
+        public String getFullPath() {
+            if (isRoot) {
+                return FILE_ROOT;
+            }
+            StringBuilder pathBuilder = new StringBuilder();
+            fillPathBuilder(pathBuilder, false);
+
+            return pathBuilder.toString();
+        }
+
+        /**
+         * Return the fully escaped path of the entry. This path is safe to use in a shell command
+         * line.
+         *
+         * @return a path string using {@link FileListingService#FILE_SEPARATOR} as separator
+         */
+        public String getFullEscapedPath() {
+            StringBuilder pathBuilder = new StringBuilder();
+            fillPathBuilder(pathBuilder, true);
+
+            return pathBuilder.toString();
+        }
+
+        /** Returns the path as a list of segments. */
+        public String[] getPathSegments() {
+            ArrayList<String> list = new ArrayList<String>();
+            fillPathSegments(list);
+
+            return list.toArray(new String[0]);
+        }
+
+        /** Returns the Entry type as an int, which will match one of the TYPE_(...) constants */
+        public int getType() {
+            return type;
+        }
+
+        /** Sets a new type. */
+        public void setType(int type) {
+            this.type = type;
+        }
+
+        /** Returns if the entry is a folder or a link to a folder. */
+        public boolean isDirectory() {
+            return type == TYPE_DIRECTORY || type == TYPE_DIRECTORY_LINK;
+        }
+
+        /** Returns the parent entry. */
+        public FileEntry getParent() {
+            return parent;
+        }
+
+        /**
+         * Returns the cached children of the entry. This returns the cache created from calling
+         * <code>FileListingService.getChildren()</code>.
+         */
+        public FileEntry[] getCachedChildren() {
+            return mChildren.toArray(new FileEntry[0]);
+        }
+
+        /**
+         * Returns the child {@link FileEntry} matching the name. This uses the cached children
+         * list.
+         *
+         * @param name the name of the child to return.
+         * @return the FileEntry matching the name or null.
+         */
+        public FileEntry findChild(String name) {
+            for (FileEntry entry : mChildren) {
+                if (entry.name.equals(name)) {
+                    return entry;
+                }
+            }
+            return null;
+        }
+
+        /** Returns whether the entry is the root. */
+        public boolean isRoot() {
+            return isRoot;
+        }
+
+        void addChild(FileEntry child) {
+            mChildren.add(child);
+        }
+
+        void setChildren(ArrayList<FileEntry> newChildren) {
+            mChildren.clear();
+            mChildren.addAll(newChildren);
+        }
+
+        boolean needFetch() {
+            if (fetchTime == 0) {
+                return true;
+            }
+            long current = System.currentTimeMillis();
+            return current - fetchTime > REFRESH_TEST;
+        }
+
+        /** Returns if the entry is a valid application package. */
+        public boolean isApplicationPackage() {
+            return isAppPackage;
+        }
+
+        /** Returns if the file name is an application package name. */
+        public boolean isAppFileName() {
+            Matcher m = sApkPattern.matcher(name);
+            return m.matches();
+        }
+
+        /**
+         * Recursively fills the pathBuilder with the full path
+         *
+         * @param pathBuilder a StringBuilder used to create the path.
+         * @param escapePath Whether the path need to be escaped for consumption by a shell command
+         *     line.
+         */
+        protected void fillPathBuilder(StringBuilder pathBuilder, boolean escapePath) {
+            if (isRoot) {
+                return;
+            }
+
+            if (parent != null) {
+                parent.fillPathBuilder(pathBuilder, escapePath);
+            }
+            pathBuilder.append(FILE_SEPARATOR);
+            pathBuilder.append(escapePath ? escape(name) : name);
+        }
+
+        /**
+         * Recursively fills the segment list with the full path.
+         *
+         * @param list The list of segments to fill.
+         */
+        protected void fillPathSegments(ArrayList<String> list) {
+            if (isRoot) {
+                return;
+            }
+
+            if (parent != null) {
+                parent.fillPathSegments(list);
+            }
+
+            list.add(name);
+        }
+
+        /**
+         * Sets the internal app package status flag. This checks whether the entry is in an app
+         * directory like /data/app or /system/app
+         */
+        private void checkAppPackageStatus() {
+            isAppPackage = false;
+
+            String[] segments = getPathSegments();
+            if (type == TYPE_FILE && segments.length == 3 && isAppFileName()) {
+                isAppPackage =
+                        DIRECTORY_APP.equals(segments[1])
+                                && (DIRECTORY_SYSTEM.equals(segments[0])
+                                        || DIRECTORY_DATA.equals(segments[0]));
+            }
+        }
+
+        /**
+         * Returns an escaped version of the entry name.
+         *
+         * @param entryName
+         */
+        public static String escape(String entryName) {
+            return sEscapePattern.matcher(entryName).replaceAll("\\\\$1"); // $NON-NLS-1$
+        }
+    }
+
+    private static class LsReceiver extends MultiLineReceiver {
+
+        private ArrayList<FileEntry> mEntryList;
+        private ArrayList<String> mLinkList;
+        private FileEntry[] mCurrentChildren;
+        private FileEntry mParentEntry;
+
+        /**
+         * Create an ls receiver/parser.
+         *
+         * @param currentChildren The list of current children. To prevent collapse during update,
+         *     reusing the same FileEntry objects for files that were already there is paramount.
+         * @param entryList the list of new children to be filled by the receiver.
+         * @param linkList the list of link path to compute post ls, to figure out if the link
+         *     pointed to a file or to a directory.
+         */
+        public LsReceiver(
+                FileEntry parentEntry, ArrayList<FileEntry> entryList, ArrayList<String> linkList) {
+            mParentEntry = parentEntry;
+            mCurrentChildren = parentEntry.getCachedChildren();
+            mEntryList = entryList;
+            mLinkList = linkList;
+        }
+
+        @Override
+        public void processNewLines(@NonNull String[] lines) {
+            for (String line : lines) {
+                // no need to handle empty lines.
+                if (line.isEmpty()) {
+                    continue;
+                }
+
+                // run the line through the regexp
+                Matcher m = LS_L_PATTERN.matcher(line);
+                if (!m.matches()) {
+                    continue;
+                }
+
+                // get the name
+                String name = m.group(7);
+
+                // get the rest of the groups
+                String permissions = m.group(1);
+                String owner = m.group(2);
+                String group = m.group(3);
+                String size = m.group(4);
+                String date = m.group(5);
+                String time = m.group(6);
+                String info = null;
+
+                // and the type
+                int objectType = TYPE_OTHER;
+                switch (permissions.charAt(0)) {
+                    case '-':
+                        objectType = TYPE_FILE;
+                        break;
+                    case 'b':
+                        objectType = TYPE_BLOCK;
+                        break;
+                    case 'c':
+                        objectType = TYPE_CHARACTER;
+                        break;
+                    case 'd':
+                        objectType = TYPE_DIRECTORY;
+                        break;
+                    case 'l':
+                        objectType = TYPE_LINK;
+                        break;
+                    case 's':
+                        objectType = TYPE_SOCKET;
+                        break;
+                    case 'p':
+                        objectType = TYPE_FIFO;
+                        break;
+                }
+
+                // now check what we may be linking to
+                if (objectType == TYPE_LINK) {
+                    String[] segments = name.split("\\s->\\s"); // $NON-NLS-1$
+
+                    // we should have 2 segments
+                    if (segments.length == 2) {
+                        // update the entry name to not contain the link
+                        name = segments[0];
+
+                        // and the link name
+                        info = segments[1];
+
+                        // now get the path to the link
+                        String[] pathSegments = info.split(FILE_SEPARATOR);
+                        if (pathSegments.length == 1) {
+                            // the link is to something in the same directory,
+                            // unless the link is ..
+                            if ("..".equals(pathSegments[0])) { // $NON-NLS-1$
+                                // set the type and we're done.
+                                objectType = TYPE_DIRECTORY_LINK;
+                            } else {
+                                // either we found the object already
+                                // or we'll find it later.
+                            }
+                        }
+                    }
+
+                    // add an arrow in front to specify it's a link.
+                    info = "-> " + info; // $NON-NLS-1$;
+                }
+
+                // get the entry, either from an existing one, or a new one
+                FileEntry entry = getExistingEntry(name);
+                if (entry == null) {
+                    entry = new FileEntry(mParentEntry, name, objectType, false /* isRoot */);
+                }
+
+                // add some misc info
+                entry.permissions = permissions;
+                entry.size = size;
+                entry.date = date;
+                entry.time = time;
+                entry.owner = owner;
+                entry.group = group;
+                if (objectType == TYPE_LINK) {
+                    entry.info = info;
+                }
+
+                mEntryList.add(entry);
+            }
+        }
+
+        /**
+         * Queries for an already existing Entry per name
+         *
+         * @param name the name of the entry
+         * @return the existing FileEntry or null if no entry with a matching name exists.
+         */
+        private FileEntry getExistingEntry(String name) {
+            for (int i = 0; i < mCurrentChildren.length; i++) {
+                FileEntry e = mCurrentChildren[i];
+
+                // since we're going to "erase" the one we use, we need to
+                // check that the item is not null.
+                if (e != null) {
+                    // compare per name, case-sensitive.
+                    if (name.equals(e.name)) {
+                        // erase from the list
+                        mCurrentChildren[i] = null;
+
+                        // and return the object
+                        return e;
+                    }
+                }
+            }
+
+            // couldn't find any matching object, return null
+            return null;
+        }
+
+        @Override
+        public boolean isCancelled() {
+            return false;
+        }
+
+        /**
+         * Determine if any symlinks in the <code entries> list are links-to-directories, and if so
+         * mark them as such.  This allows us to traverse them properly later on.
+         */
+        public void finishLinks(IDevice device, ArrayList<FileEntry> entries)
+                throws TimeoutException,
+                        AdbCommandRejectedException,
+                        ShellCommandUnresponsiveException,
+                        IOException {
+            final int[] nLines = {0};
+            MultiLineReceiver receiver =
+                    new MultiLineReceiver() {
+                        @Override
+                        public void processNewLines(@NonNull String[] lines) {
+                            for (String line : lines) {
+                                Matcher m = LS_LD_PATTERN.matcher(line);
+                                if (m.matches()) {
+                                    nLines[0]++;
+                                }
+                            }
+                        }
+
+                        @Override
+                        public boolean isCancelled() {
+                            return false;
+                        }
+                    };
+
+            for (FileEntry entry : entries) {
+                if (entry.getType() != TYPE_LINK) continue;
+
+                // We simply need to determine whether the referent is a directory or not.
+                // We do this by running `ls -ld ${link}/`.  If the referent exists and is a
+                // directory, we'll see the normal directory listing.  Otherwise, we'll see an
+                // error of some sort.
+                nLines[0] = 0;
+
+                final String command =
+                        String.format("ls -l -d %s%s", entry.getFullEscapedPath(), FILE_SEPARATOR);
+
+                device.executeShellCommand(command, receiver);
+
+                if (nLines[0] > 0) {
+                    // We saw lines matching the directory pattern, so it's a directory!
+                    entry.setType(TYPE_DIRECTORY_LINK);
+                }
+            }
+        }
+    }
+
+    /**
+     * Classes which implement this interface provide a method that deals with asynchronous result
+     * from <code>ls</code> command on the device.
+     *
+     * @see FileListingService#getChildren(FileListingService.FileEntry, boolean,
+     *     FileListingService.IListingReceiver)
+     */
+    public interface IListingReceiver {
+        void setChildren(FileEntry entry, FileEntry[] children);
+
+        void refreshEntry(FileEntry entry);
+    }
+
+    /**
+     * Creates a File Listing Service for a specified {@link IDevice}.
+     *
+     * @param device The Device the service is connected to.
+     */
+    public FileListingService(IDevice device) {
+        mDevice = device;
+    }
+
+    /**
+     * Returns the root element.
+     *
+     * @return the {@link FileEntry} object representing the root element or <code>null</code> if
+     *     the device is invalid.
+     */
+    public FileEntry getRoot() {
+        if (mDevice != null) {
+            if (mRoot == null) {
+                mRoot =
+                        new FileEntry(
+                                null /* parent */,
+                                "" /* name */,
+                                TYPE_DIRECTORY,
+                                true /* isRoot */);
+            }
+
+            return mRoot;
+        }
+
+        return null;
+    }
+
+    /**
+     * Returns the children of a {@link FileEntry}.
+     *
+     * <p>This method supports a cache mechanism and synchronous and asynchronous modes.
+     *
+     * <p>If <var>receiver</var> is <code>null</code>, the device side <code>ls</code> command is
+     * done synchronously, and the method will return upon completion of the command.<br>
+     * If <var>receiver</var> is non <code>null</code>, the command is launched is a separate thread
+     * and upon completion, the receiver will be notified of the result.
+     *
+     * <p>The result for each <code>ls</code> command is cached in the parent <code>FileEntry</code>
+     * . <var>useCache</var> allows usage of this cache, but only if the cache is valid. The cache
+     * is valid only for {@link FileListingService#REFRESH_RATE} ms. After that a new <code>ls
+     * </code> command is always executed.
+     *
+     * <p>If the cache is valid and <code>useCache == true</code>, the method will always simply
+     * return the value of the cache, whether a {@link IListingReceiver} has been provided or not.
+     *
+     * @param entry The parent entry.
+     * @param useCache A flag to use the cache or to force a new ls command.
+     * @param receiver A receiver for asynchronous calls.
+     * @return The list of children or <code>null</code> for asynchronous calls.
+     * @see FileEntry#getCachedChildren()
+     */
+    public FileEntry[] getChildren(
+            final FileEntry entry, boolean useCache, final IListingReceiver receiver) {
+        // first thing we do is check the cache, and if we already have a recent
+        // enough children list, we just return that.
+        if (useCache && !entry.needFetch()) {
+            return entry.getCachedChildren();
+        }
+
+        // if there's no receiver, then this is a synchronous call, and we
+        // return the result of ls
+        if (receiver == null) {
+            doLs(entry);
+            return entry.getCachedChildren();
+        }
+
+        // this is a asynchronous call.
+        // we launch a thread that will do ls and give the listing
+        // to the receiver
+        Thread t = new Thread("ls " + entry.getFullPath()) { // $NON-NLS-1$
+                    @Override
+                    public void run() {
+                        doLs(entry);
+
+                        receiver.setChildren(entry, entry.getCachedChildren());
+
+                        final FileEntry[] children = entry.getCachedChildren();
+                        if (children.length > 0 && children[0].isApplicationPackage()) {
+                            final HashMap<String, FileEntry> map = new HashMap<String, FileEntry>();
+
+                            for (FileEntry child : children) {
+                                String path = child.getFullPath();
+                                map.put(path, child);
+                            }
+
+                            // call pm.
+                            String command = PM_FULL_LISTING;
+                            try {
+                                mDevice.executeShellCommand(
+                                        command,
+                                        new MultiLineReceiver() {
+                                            @Override
+                                            public void processNewLines(@NonNull String[] lines) {
+                                                for (String line : lines) {
+                                                    if (!line.isEmpty()) {
+                                                        // get the filepath and package from the
+                                                        // line
+                                                        Matcher m = sPmPattern.matcher(line);
+                                                        if (m.matches()) {
+                                                            // get the children with that path
+                                                            FileEntry entry = map.get(m.group(1));
+                                                            if (entry != null) {
+                                                                entry.info = m.group(2);
+                                                                receiver.refreshEntry(entry);
+                                                            }
+                                                        }
+                                                    }
+                                                }
+                                            }
+
+                                            @Override
+                                            public boolean isCancelled() {
+                                                return false;
+                                            }
+                                        });
+                            } catch (Exception e) {
+                                // adb failed somehow, we do nothing.
+                            }
+                        }
+
+                        // if another thread is pending, launch it
+                        synchronized (mThreadList) {
+                            // first remove ourselves from the list
+                            mThreadList.remove(this);
+
+                            // then launch the next one if applicable.
+                            if (!mThreadList.isEmpty()) {
+                                Thread t = mThreadList.get(0);
+                                t.start();
+                            }
+                        }
+                    }
+                };
+
+        // we don't want to run multiple ls on the device at the same time, so we
+        // store the thread in a list and launch it only if there's no other thread running.
+        // the thread will launch the next one once it's done.
+        synchronized (mThreadList) {
+            // add to the list
+            mThreadList.add(t);
+
+            // if it's the only one, launch it.
+            if (mThreadList.size() == 1) {
+                t.start();
+            }
+        }
+
+        // and we return null.
+        return null;
+    }
+
+    /**
+     * Returns the children of a {@link FileEntry}.
+     *
+     * <p>This method is the explicit synchronous version of {@link #getChildren(FileEntry, boolean,
+     * IListingReceiver)}. It is roughly equivalent to calling getChildren(FileEntry, false, null)
+     *
+     * @param entry The parent entry.
+     * @return The list of children
+     * @throws TimeoutException in case of timeout on the connection when sending the command.
+     * @throws AdbCommandRejectedException if adb rejects the command.
+     * @throws ShellCommandUnresponsiveException in case the shell command doesn't send any output
+     *     for a period longer than <var>maxTimeToOutputResponse</var>.
+     * @throws IOException in case of I/O error on the connection.
+     */
+    public FileEntry[] getChildrenSync(final FileEntry entry)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    ShellCommandUnresponsiveException,
+                    IOException {
+        doLsAndThrow(entry);
+        return entry.getCachedChildren();
+    }
+
+    private void doLs(FileEntry entry) {
+        try {
+            doLsAndThrow(entry);
+        } catch (Exception e) {
+            // do nothing
+        }
+    }
+
+    private void doLsAndThrow(FileEntry entry)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    ShellCommandUnresponsiveException,
+                    IOException {
+        // create a list that will receive the list of the entries
+        ArrayList<FileEntry> entryList = new ArrayList<FileEntry>();
+
+        // create a list that will receive the link to compute post ls;
+        ArrayList<String> linkList = new ArrayList<String>();
+
+        try {
+            // create the command
+            String command = "ls -l " + entry.getFullEscapedPath(); // $NON-NLS-1$
+            if (entry.isDirectory()) {
+                // If we expect a file to behave like a directory, we should stick a "/" at the end.
+                // This is a good habit, and is mandatory for symlinks-to-directories, which will
+                // otherwise behave like symlinks.
+                command += FILE_SEPARATOR;
+            }
+
+            // create the receiver object that will parse the result from ls
+            LsReceiver receiver = new LsReceiver(entry, entryList, linkList);
+
+            // call ls.
+            mDevice.executeShellCommand(command, receiver);
+
+            // finish the process of the receiver to handle links
+            receiver.finishLinks(mDevice, entryList);
+        } finally {
+            // at this point we need to refresh the viewer
+            entry.fetchTime = System.currentTimeMillis();
+
+            // sort the children and set them as the new children
+            Collections.sort(entryList, FileEntry.sEntryComparator);
+            entry.setChildren(entryList);
+        }
+    }
+}
diff --git a/device_build_interfaces/com/android/ddmlib/IDevice.java b/device_build_interfaces/com/android/ddmlib/IDevice.java
new file mode 100644
index 000000000..7a5a0886b
--- /dev/null
+++ b/device_build_interfaces/com/android/ddmlib/IDevice.java
@@ -0,0 +1,1043 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.ddmlib;
+
+import com.android.annotations.NonNull;
+import com.android.annotations.Nullable;
+import com.android.tradefed.device.server.Client;
+import com.android.tradefed.device.server.ProfileableClient;
+import com.android.tradefed.device.server.SyncService;
+
+import com.google.common.base.Splitter;
+import com.google.common.collect.Sets;
+import com.google.common.util.concurrent.ListenableFuture;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.channels.SocketChannel;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+
+/** A Device. It can be a physical device or an emulator. */
+public interface IDevice extends IShellEnabledDevice {
+    String UNKNOWN_PACKAGE = "";
+
+    /** Emulator Serial Number regexp. */
+    String RE_EMULATOR_SN = "emulator-(\\d+)"; // $NON-NLS-1$
+
+    String PROP_BUILD_VERSION = "ro.build.version.release";
+    String PROP_BUILD_API_LEVEL = "ro.build.version.sdk";
+    String PROP_BUILD_CODENAME = "ro.build.version.codename";
+    String PROP_BUILD_TAGS = "ro.build.tags";
+    String PROP_BUILD_TYPE = "ro.build.type";
+    String PROP_DEVICE_MODEL = "ro.product.model";
+    String PROP_DEVICE_MANUFACTURER = "ro.product.manufacturer";
+    String PROP_DEVICE_CPU_ABI_LIST = "ro.product.cpu.abilist";
+    String PROP_DEVICE_CPU_ABI = "ro.product.cpu.abi";
+    String PROP_DEVICE_CPU_ABI2 = "ro.product.cpu.abi2";
+    String PROP_BUILD_CHARACTERISTICS = "ro.build.characteristics";
+    String PROP_DEVICE_DENSITY = "ro.sf.lcd_density";
+    String PROP_DEVICE_EMULATOR_DENSITY = "qemu.sf.lcd_density";
+    String PROP_DEVICE_LANGUAGE = "persist.sys.language";
+    String PROP_DEVICE_REGION = "persist.sys.country";
+
+    String PROP_DEBUGGABLE = "ro.debuggable";
+
+    /** Serial number of the first connected emulator. */
+    String FIRST_EMULATOR_SN = "emulator-5554"; // $NON-NLS-1$
+
+    /** Device change bit mask: {@link DeviceState} change. */
+    int CHANGE_STATE = 0x0001;
+
+    /** Device change bit mask: {@link Client} list change. */
+    int CHANGE_CLIENT_LIST = 0x0002;
+
+    /** Device change bit mask: build info change. */
+    int CHANGE_BUILD_INFO = 0x0004;
+
+    /** Device change bit mask: {@link ProfileableClient} list change. */
+    int CHANGE_PROFILEABLE_CLIENT_LIST = 0x0008;
+
+    /** Device level software features. */
+    enum Feature {
+        SCREEN_RECORD, // screen recorder available?
+        PROCSTATS, // procstats service (dumpsys procstats) available
+        ABB_EXEC, // Android Binder Bridge available
+        REAL_PKG_NAME, // Reports the real package name, instead of inferring from client
+        // description
+        SKIP_VERIFICATION, // Skips verification on installation.
+        SHELL_V2, // Supports modern `adb shell` features like exit status propagation.
+    }
+
+    /** Device level hardware features. */
+    enum HardwareFeature {
+        WATCH("watch"),
+        EMBEDDED("embedded"),
+        TV("tv"),
+        AUTOMOTIVE("automotive");
+
+        private final String mCharacteristic;
+
+        HardwareFeature(String characteristic) {
+            mCharacteristic = characteristic;
+        }
+
+        public String getCharacteristic() {
+            return mCharacteristic;
+        }
+    }
+
+    /**
+     * @deprecated Use {@link #PROP_BUILD_API_LEVEL}.
+     */
+    @Deprecated String PROP_BUILD_VERSION_NUMBER = PROP_BUILD_API_LEVEL;
+
+    String MNT_EXTERNAL_STORAGE = "EXTERNAL_STORAGE"; // $NON-NLS-1$
+    String MNT_ROOT = "ANDROID_ROOT"; // $NON-NLS-1$
+    String MNT_DATA = "ANDROID_DATA"; // $NON-NLS-1$
+
+    /** The state of a device. */
+    enum DeviceState {
+        BOOTLOADER("bootloader"), // $NON-NLS-1$
+        /** bootloader mode with is-userspace = true though `adb reboot fastboot` */
+        FASTBOOTD("fastbootd"), // $NON-NLS-1$
+        OFFLINE("offline"), // $NON-NLS-1$
+        ONLINE("device"), // $NON-NLS-1$
+        RECOVERY("recovery"), // $NON-NLS-1$
+        /** Device is in "sideload" state either through `adb sideload` or recovery menu */
+        SIDELOAD("sideload"), // $NON-NLS-1$
+        UNAUTHORIZED("unauthorized"), // $NON-NLS-1$
+        DISCONNECTED("disconnected"), // $NON-NLS-1$
+        ;
+
+        private String mState;
+
+        DeviceState(String state) {
+            mState = state;
+        }
+
+        /**
+         * Returns a {@link DeviceState} from the string returned by <code>adb devices</code>.
+         *
+         * @param state the device state.
+         * @return a {@link DeviceState} object or <code>null</code> if the state is unknown.
+         */
+        @Nullable
+        public static DeviceState getState(String state) {
+            for (DeviceState deviceState : values()) {
+                if (deviceState.mState.equals(state)) {
+                    return deviceState;
+                }
+            }
+            return null;
+        }
+
+        public String getState() {
+            return mState;
+        }
+    }
+
+    /** Namespace of a Unix Domain Socket created on the device. */
+    enum DeviceUnixSocketNamespace {
+        ABSTRACT("localabstract"), // $NON-NLS-1$
+        FILESYSTEM("localfilesystem"), // $NON-NLS-1$
+        RESERVED("localreserved"); // $NON-NLS-1$
+
+        private String mType;
+
+        DeviceUnixSocketNamespace(String type) {
+            mType = type;
+        }
+
+        public String getType() {
+            return mType;
+        }
+    }
+
+    /** Returns the serial number of the device. */
+    @NonNull
+    String getSerialNumber();
+
+    /**
+     * Returns the name of the AVD the emulator is running.
+     *
+     * <p>This is only valid if {@link #isEmulator()} returns true.
+     *
+     * <p>If the emulator is not running any AVD (for instance it's running from an Android source
+     * tree build), this method will return "<code>&lt;build&gt;</code>".
+     *
+     * <p><em>Note: Prefer using {@link #getAvdData()} if you want control over the timeout.</em>
+     *
+     * @return the name of the AVD or <code>null</code> if there isn't any.
+     */
+    @Deprecated
+    @Nullable
+    String getAvdName();
+
+    /**
+     * Returns the absolute path to the virtual device in the file system. The path is operating
+     * system dependent; it will have / name separators on Linux and \ separators on Windows.
+     *
+     * <p><em>Note: Prefer using {@link #getAvdData()} if you want control over the timeout.</em>
+     *
+     * @return the AVD path or null if this is a physical device, the emulator console subcommand
+     *     failed, or the emulator's version is older than 30.0.18
+     */
+    @Deprecated
+    @Nullable
+    String getAvdPath();
+
+    /**
+     * Returns information about the AVD the emulator is running.
+     *
+     * <p>{@link AvdData#getName} is the name of the AVD or <code>null</code> if there isn't any.
+     *
+     * <p>{@link AvdData#getPath} is the AVD path or null if this is a physical device, the emulator
+     * console subcommand failed, or the emulator's version is older than 30.0.18
+     *
+     * @return the {@link AvdData} for the device.
+     */
+    default ListenableFuture<AvdData> getAvdData() {
+        throw new UnsupportedOperationException();
+    }
+
+    /** Returns the state of the device. */
+    DeviceState getState();
+
+    /**
+     * Returns the cached device properties. It contains the whole output of 'getprop'
+     *
+     * @deprecated use {@link #getSystemProperty(String)} instead
+     */
+    @Deprecated
+    Map<String, String> getProperties();
+
+    /**
+     * Returns the number of property for this device.
+     *
+     * @deprecated implementation detail
+     */
+    @Deprecated
+    int getPropertyCount();
+
+    /**
+     * Convenience method that attempts to retrieve a property via {@link
+     * #getSystemProperty(String)} with a very short wait time, and swallows exceptions.
+     *
+     * <p><em>Note: Prefer using {@link #getSystemProperty(String)} if you want control over the
+     * timeout.</em>
+     *
+     * @param name the name of the value to return.
+     * @return the value or <code>null</code> if the property value was not immediately available
+     */
+    @Nullable
+    String getProperty(@NonNull String name);
+
+    /** Returns <code>true</code> if properties have been cached */
+    boolean arePropertiesSet();
+
+    /**
+     * A variant of {@link #getProperty(String)} that will attempt to retrieve the given property
+     * from device directly, without using cache. This method should (only) be used for any volatile
+     * properties.
+     *
+     * @param name the name of the value to return.
+     * @return the value or <code>null</code> if the property does not exist
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws ShellCommandUnresponsiveException in case the shell command doesn't send output for a
+     *     given time.
+     * @throws IOException in case of I/O error on the connection.
+     * @deprecated use {@link #getSystemProperty(String)}
+     */
+    @Deprecated
+    String getPropertySync(String name)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    ShellCommandUnresponsiveException,
+                    IOException;
+
+    /**
+     * A combination of {@link #getProperty(String)} and {@link #getPropertySync(String)} that will
+     * attempt to retrieve the property from cache. If not found, will synchronously attempt to
+     * query device directly and repopulate the cache if successful.
+     *
+     * @param name the name of the value to return.
+     * @return the value or <code>null</code> if the property does not exist
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws ShellCommandUnresponsiveException in case the shell command doesn't send output for a
+     *     given time.
+     * @throws IOException in case of I/O error on the connection.
+     * @deprecated use {@link #getSystemProperty(String)} instead
+     */
+    @Deprecated
+    String getPropertyCacheOrSync(String name)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    ShellCommandUnresponsiveException,
+                    IOException;
+
+    /** Returns whether this device supports the given software feature. */
+    boolean supportsFeature(@NonNull Feature feature);
+
+    /** Returns whether this device supports the given hardware feature. */
+    boolean supportsFeature(@NonNull HardwareFeature feature);
+
+    /**
+     * Returns a mount point.
+     *
+     * @param name the name of the mount point to return
+     * @see #MNT_EXTERNAL_STORAGE
+     * @see #MNT_ROOT
+     * @see #MNT_DATA
+     */
+    @Nullable
+    String getMountPoint(@NonNull String name);
+
+    /**
+     * Returns if the device is ready.
+     *
+     * @return <code>true</code> if {@link #getState()} returns {@link DeviceState#ONLINE}.
+     */
+    boolean isOnline();
+
+    /** Returns <code>true</code> if the device is an emulator. */
+    boolean isEmulator();
+
+    /**
+     * Returns if the device is offline.
+     *
+     * @return <code>true</code> if {@link #getState()} returns {@link DeviceState#OFFLINE}.
+     */
+    boolean isOffline();
+
+    /**
+     * Returns if the device is in bootloader mode.
+     *
+     * @return <code>true</code> if {@link #getState()} returns {@link DeviceState#BOOTLOADER}.
+     */
+    boolean isBootLoader();
+
+    /** Returns whether the {@link IDevice} has {@link Client}s. */
+    boolean hasClients();
+
+    /** Returns the array of clients. */
+    Client[] getClients();
+
+    /**
+     * Returns a {@link Client} by its application name.
+     *
+     * @param applicationName the name of the application
+     * @return the <code>Client</code> object or <code>null</code> if no match was found.
+     */
+    Client getClient(String applicationName);
+
+    /** Returns the array of profileable clients. */
+    default ProfileableClient[] getProfileableClients() {
+        return new ProfileableClient[0]; // Returns an empty array by default
+    }
+
+    /**
+     * Force stop an application by its application name. This removes all pending alarms and queued
+     * computation.
+     *
+     * @param applicationName the name of the application
+     */
+    default void forceStop(String applicationName) {}
+
+    /**
+     * Kills an application by its application name. This only destroy the activities, leaving its
+     * state in the Android system alone.
+     *
+     * @param applicationName the name of the application
+     */
+    default void kill(String applicationName) {}
+
+    /**
+     * Returns a {@link SyncService} object to push / pull files to and from the device.
+     *
+     * @return <code>null</code> if the SyncService couldn't be created. This can happen if adb
+     *     refuse to open the connection because the {@link IDevice} is invalid (or got
+     *     disconnected).
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws IOException if the connection with adb failed.
+     */
+    @Nullable
+    SyncService getSyncService() throws TimeoutException, AdbCommandRejectedException, IOException;
+
+    /** Returns a {@link FileListingService} for this device. */
+    FileListingService getFileListingService();
+
+    /**
+     * Takes a screen shot of the device and returns it as a {@link RawImage}.
+     *
+     * @return the screenshot as a <code>RawImage</code> or <code>null</code> if something went
+     *     wrong.
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws IOException in case of I/O error on the connection.
+     */
+    RawImage getScreenshot() throws TimeoutException, AdbCommandRejectedException, IOException;
+
+    RawImage getScreenshot(long timeout, TimeUnit unit)
+            throws TimeoutException, AdbCommandRejectedException, IOException;
+
+    /**
+     * Initiates screen recording on the device if the device supports {@link
+     * Feature#SCREEN_RECORD}.
+     */
+    void startScreenRecorder(
+            @NonNull String remoteFilePath,
+            @NonNull ScreenRecorderOptions options,
+            @NonNull IShellOutputReceiver receiver)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    IOException,
+                    ShellCommandUnresponsiveException;
+
+    /**
+     * @deprecated Use {@link #executeShellCommand(String, IShellOutputReceiver, long, TimeUnit)}.
+     */
+    @Deprecated
+    void executeShellCommand(
+            String command, IShellOutputReceiver receiver, int maxTimeToOutputResponse)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    ShellCommandUnresponsiveException,
+                    IOException;
+
+    /**
+     * Executes a shell command on the device, and sends the result to a <var>receiver</var>
+     *
+     * <p>This is similar to calling <code>
+     * executeShellCommand(command, receiver, DdmPreferences.getTimeOut())</code>.
+     *
+     * @param command the shell command to execute
+     * @param receiver the {@link IShellOutputReceiver} that will receives the output of the shell
+     *     command
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws ShellCommandUnresponsiveException in case the shell command doesn't send output for a
+     *     given time.
+     * @throws IOException in case of I/O error on the connection.
+     * @see #executeShellCommand(String, IShellOutputReceiver, int)
+     * @see DdmPreferences#getTimeOut()
+     */
+    void executeShellCommand(String command, IShellOutputReceiver receiver)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    ShellCommandUnresponsiveException,
+                    IOException;
+
+    /** A version of executeShell command that can take an input stream to send through stdin. */
+    default void executeShellCommand(
+            String command,
+            IShellOutputReceiver receiver,
+            long maxTimeToOutputResponse,
+            TimeUnit maxTimeUnits,
+            @Nullable InputStream is)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    ShellCommandUnresponsiveException,
+                    IOException {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Executes a Binder command on the device, and sends the result to a <var>receiver</var>
+     *
+     * <p>This uses exec:cmd <command> call or faster abb_exec:<command> if both device OS and host
+     * ADB server support Android Binder Bridge execute feature.
+     *
+     * @param parameters the binder command to execute
+     * @param receiver the {@link IShellOutputReceiver} that will receives the output of the binder
+     *     command
+     * @param is optional input stream to send through stdin
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws ShellCommandUnresponsiveException in case the binder command doesn't send output for
+     *     a given time.
+     * @throws IOException in case of I/O error on the connection.
+     * @see DdmPreferences#getTimeOut()
+     */
+    default void executeBinderCommand(
+            String[] parameters,
+            IShellOutputReceiver receiver,
+            long maxTimeToOutputResponse,
+            TimeUnit maxTimeUnits,
+            @Nullable InputStream is)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    ShellCommandUnresponsiveException,
+                    IOException {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Creates a port forwarding between a local and a remote port.
+     *
+     * @param localPort the local port to forward
+     * @param remotePort the remote port.
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws IOException in case of I/O error on the connection.
+     */
+    void createForward(int localPort, int remotePort)
+            throws TimeoutException, AdbCommandRejectedException, IOException;
+
+    /**
+     * Creates a port forwarding between a local TCP port and a remote Unix Domain Socket.
+     *
+     * @param localPort the local port to forward
+     * @param remoteSocketName name of the unix domain socket created on the device
+     * @param namespace namespace in which the unix domain socket was created
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws IOException in case of I/O error on the connection.
+     */
+    void createForward(int localPort, String remoteSocketName, DeviceUnixSocketNamespace namespace)
+            throws TimeoutException, AdbCommandRejectedException, IOException;
+
+    /**
+     * Removes a port forwarding between a local and a remote port.
+     *
+     * @param localPort the local port to forward
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws IOException in case of I/O error on the connection.
+     */
+    default void removeForward(int localPort)
+            throws TimeoutException, AdbCommandRejectedException, IOException {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * @deprecated Use {@link #removeForward(int)}
+     */
+    @Deprecated
+    default void removeForward(int localPort, int remotePort)
+            throws TimeoutException, AdbCommandRejectedException, IOException {
+        removeForward(localPort);
+    }
+
+    /**
+     * @deprecated Use {@link #removeForward(int)}
+     */
+    @Deprecated
+    default void removeForward(
+            int localPort, String remoteSocketName, DeviceUnixSocketNamespace namespace)
+            throws TimeoutException, AdbCommandRejectedException, IOException {
+        removeForward(localPort);
+    }
+
+    /**
+     * Creates a port reversing between a remote and a local port.
+     *
+     * @param remotePort the remote port to reverse.
+     * @param localPort the local port
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws IOException in case of I/O error on the connection.
+     */
+    default void createReverse(int remotePort, int localPort)
+            throws TimeoutException, AdbCommandRejectedException, IOException {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Removes a port reversing between a remote and a local port.
+     *
+     * @param remotePort the remote port.
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws IOException in case of I/O error on the connection.
+     */
+    default void removeReverse(int remotePort)
+            throws TimeoutException, AdbCommandRejectedException, IOException {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Returns the name of the client by pid or <code>null</code> if pid is unknown
+     *
+     * @param pid the pid of the client.
+     */
+    String getClientName(int pid);
+
+    /**
+     * Pushes several files or directories.
+     *
+     * @param local the local files to push
+     * @param remote the remote path representing a directory
+     * @throws IOException in case of I/O error on the connection
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws TimeoutException in case of a timeout reading responses from the device
+     * @throws SyncException if some files could not be pushed
+     */
+    default void push(@NonNull String[] local, @NonNull String remote)
+            throws IOException, AdbCommandRejectedException, TimeoutException, SyncException {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Pushes a single file.
+     *
+     * @param local the local filepath.
+     * @param remote the remote filepath
+     * @throws IOException in case of I/O error on the connection
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws TimeoutException in case of a timeout reading responses from the device
+     * @throws SyncException if the file could not be pushed
+     */
+    void pushFile(@NonNull String local, @NonNull String remote)
+            throws IOException, AdbCommandRejectedException, TimeoutException, SyncException;
+
+    /**
+     * Pulls a single file.
+     *
+     * @param remote the full path to the remote file
+     * @param local The local destination.
+     * @throws IOException in case of an IO exception.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws TimeoutException in case of a timeout reading responses from the device.
+     * @throws SyncException in case of a sync exception.
+     */
+    void pullFile(String remote, String local)
+            throws IOException, AdbCommandRejectedException, TimeoutException, SyncException;
+
+    /**
+     * Installs an Android application on device. This is a helper method that combines the
+     * syncPackageToDevice, installRemotePackage, and removePackage steps
+     *
+     * @param packageFilePath the absolute file system path to file on local host to install
+     * @param reinstall set to <code>true</code> if re-install of app should be performed
+     * @param extraArgs optional extra arguments to pass. See 'adb shell pm install --help' for
+     *     available options.
+     * @throws InstallException if the installation fails.
+     */
+    void installPackage(String packageFilePath, boolean reinstall, String... extraArgs)
+            throws InstallException;
+
+    /**
+     * Installs an Android application on device. This is a helper method that combines the
+     * syncPackageToDevice, installRemotePackage, and removePackage steps
+     *
+     * @param packageFilePath the absolute file system path to file on local host to install
+     * @param reinstall set to <code>true</code> if re-install of app should be performed
+     * @param receiver The {@link InstallReceiver} to be used to monitor the install and get final
+     *     status.
+     * @param extraArgs optional extra arguments to pass. See 'adb shell pm install --help' for
+     *     available options.
+     * @throws InstallException if the installation fails.
+     */
+    void installPackage(
+            String packageFilePath,
+            boolean reinstall,
+            InstallReceiver receiver,
+            String... extraArgs)
+            throws InstallException;
+
+    /**
+     * Installs an Android application on device. This is a helper method that combines the
+     * syncPackageToDevice, installRemotePackage, and removePackage steps
+     *
+     * @param packageFilePath the absolute file system path to file on local host to install
+     * @param reinstall set to <code>true</code> if re-install of app should be performed
+     * @param receiver The {@link InstallReceiver} to be used to monitor the install and get final
+     *     status.
+     * @param maxTimeout the maximum timeout for the command to return. A value of 0 means no max
+     *     timeout will be applied.
+     * @param maxTimeToOutputResponse the maximum amount of time during which the command is allowed
+     *     to not output any response. A value of 0 means the method will wait forever (until the
+     *     <var>receiver</var> cancels the execution) for command output and never throw.
+     * @param maxTimeUnits Units for non-zero {@code maxTimeout} and {@code maxTimeToOutputResponse}
+     *     values.
+     * @param extraArgs optional extra arguments to pass. See 'adb shell pm install --help' for
+     *     available options.
+     * @throws InstallException if the installation fails.
+     */
+    void installPackage(
+            String packageFilePath,
+            boolean reinstall,
+            InstallReceiver receiver,
+            long maxTimeout,
+            long maxTimeToOutputResponse,
+            TimeUnit maxTimeUnits,
+            String... extraArgs)
+            throws InstallException;
+
+    /**
+     * Installs an Android application made of several APK files (one main and 0..n split packages)
+     *
+     * @param apks list of apks to install (1 main APK + 0..n split apks)
+     * @param reinstall set to <code>true</code> if re-install of app should be performed
+     * @param installOptions optional extra arguments to pass. See 'adb shell pm install --help' for
+     *     available options.
+     * @param timeout installation timeout
+     * @param timeoutUnit {@link TimeUnit} corresponding to the timeout parameter
+     * @throws InstallException if the installation fails.
+     */
+    void installPackages(
+            @NonNull List<File> apks,
+            boolean reinstall,
+            @NonNull List<String> installOptions,
+            long timeout,
+            @NonNull TimeUnit timeoutUnit)
+            throws InstallException;
+
+    /**
+     * Installs an Android application made of several APK files (one main and 0..n split packages)
+     * with default timeout
+     *
+     * @param apks list of apks to install (1 main APK + 0..n split apks)
+     * @param reinstall set to <code>true</code> if re-install of app should be performed
+     * @param installOptions optional extra arguments to pass. See 'adb shell pm install --help' for
+     *     available options.
+     * @throws InstallException if the installation fails.
+     */
+    default void installPackages(
+            @NonNull List<File> apks, boolean reinstall, @NonNull List<String> installOptions)
+            throws InstallException {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Gets the information about the most recent installation on this device.
+     *
+     * @return {@link InstallMetrics} metrics describing the installation.
+     */
+    default InstallMetrics getLastInstallMetrics() {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Installs an Android application made of several APK files sitting locally on the device
+     *
+     * @param remoteApks list of apk file paths sitting on the device to install
+     * @param reinstall set to <code>true</code> if re-install of app should be performed
+     * @param installOptions optional extra arguments to pass. See 'adb shell pm install --help' for
+     *     available options.
+     * @param timeout installation timeout
+     * @param timeoutUnit {@link TimeUnit} corresponding to the timeout parameter
+     * @throws InstallException if the installation fails.
+     */
+    default void installRemotePackages(
+            @NonNull List<String> remoteApks,
+            boolean reinstall,
+            @NonNull List<String> installOptions,
+            long timeout,
+            @NonNull TimeUnit timeoutUnit)
+            throws InstallException {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Installs an Android application made of several APK files sitting locally on the device with
+     * default timeout
+     *
+     * @param remoteApks list of apk file paths on the device to install
+     * @param reinstall set to <code>true</code> if re-install of app should be performed
+     * @param installOptions optional extra arguments to pass. See 'adb shell pm install --help' for
+     *     available options.
+     * @throws InstallException if the installation fails.
+     */
+    default void installRemotePackages(
+            @NonNull List<String> remoteApks,
+            boolean reinstall,
+            @NonNull List<String> installOptions)
+            throws InstallException {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Pushes a file to device
+     *
+     * @param localFilePath the absolute path to file on local host
+     * @return {@link String} destination path on device for file
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws IOException in case of I/O error on the connection.
+     * @throws SyncException if an error happens during the push of the package on the device.
+     */
+    String syncPackageToDevice(String localFilePath)
+            throws TimeoutException, AdbCommandRejectedException, IOException, SyncException;
+
+    /**
+     * Installs the application package that was pushed to a temporary location on the device.
+     *
+     * @param remoteFilePath absolute file path to package file on device
+     * @param reinstall set to <code>true</code> if re-install of app should be performed
+     * @param extraArgs optional extra arguments to pass. See 'adb shell pm install --help' for
+     *     available options.
+     * @throws InstallException if the installation fails.
+     * @see #installRemotePackage(String, boolean, InstallReceiver, long, long, TimeUnit, String...)
+     */
+    void installRemotePackage(String remoteFilePath, boolean reinstall, String... extraArgs)
+            throws InstallException;
+
+    /**
+     * Installs the application package that was pushed to a temporary location on the device.
+     *
+     * @param remoteFilePath absolute file path to package file on device
+     * @param reinstall set to <code>true</code> if re-install of app should be performed
+     * @param receiver The {@link InstallReceiver} to be used to monitor the install and get final
+     *     status.
+     * @param extraArgs optional extra arguments to pass. See 'adb shell pm install --help' for
+     *     available options.
+     * @throws InstallException if the installation fails.
+     * @see #installRemotePackage(String, boolean, InstallReceiver, long, long, TimeUnit, String...)
+     */
+    void installRemotePackage(
+            String remoteFilePath, boolean reinstall, InstallReceiver receiver, String... extraArgs)
+            throws InstallException;
+
+    /**
+     * Installs the application package that was pushed to a temporary location on the device.
+     *
+     * @param remoteFilePath absolute file path to package file on device
+     * @param reinstall set to <code>true</code> if re-install of app should be performed
+     * @param receiver The {@link InstallReceiver} to be used to monitor the install and get final
+     *     status.
+     * @param maxTimeout the maximum timeout for the command to return. A value of 0 means no max
+     *     timeout will be applied.
+     * @param maxTimeToOutputResponse the maximum amount of time during which the command is allowed
+     *     to not output any response. A value of 0 means the method will wait forever (until the
+     *     <var>receiver</var> cancels the execution) for command output and never throw.
+     * @param maxTimeUnits Units for non-zero {@code maxTimeout} and {@code maxTimeToOutputResponse}
+     *     values.
+     * @param extraArgs optional extra arguments to pass. See 'adb shell pm install --help' for
+     *     available options.
+     * @throws InstallException if the installation fails.
+     */
+    void installRemotePackage(
+            String remoteFilePath,
+            boolean reinstall,
+            InstallReceiver receiver,
+            long maxTimeout,
+            long maxTimeToOutputResponse,
+            TimeUnit maxTimeUnits,
+            String... extraArgs)
+            throws InstallException;
+
+    /**
+     * Removes a file from device.
+     *
+     * @param remoteFilePath path on device of file to remove
+     * @throws InstallException if the installation fails.
+     */
+    void removeRemotePackage(String remoteFilePath) throws InstallException;
+
+    /**
+     * Uninstalls a package from the device.
+     *
+     * @param packageName the Android application ID to uninstall
+     * @return a {@link String} with an error code, or <code>null</code> if success.
+     * @throws InstallException if the uninstallation fails.
+     */
+    String uninstallPackage(String packageName) throws InstallException;
+
+    /**
+     * Uninstalls an app from the device.
+     *
+     * @param applicationID the Android application ID to uninstall
+     * @param extraArgs optional extra arguments to pass. See 'adb shell pm install --help' for
+     *     available options.
+     * @return a {@link String} with an error code, or <code>null</code> if success.
+     * @throws InstallException if the uninstallation fails.
+     */
+    String uninstallApp(String applicationID, String... extraArgs) throws InstallException;
+
+    /**
+     * Reboot the device.
+     *
+     * @param into the bootloader name to reboot into, or null to just reboot the device.
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws IOException
+     */
+    void reboot(String into) throws TimeoutException, AdbCommandRejectedException, IOException;
+
+    /**
+     * Ask the adb daemon to become root on the device. This may silently fail, and can only succeed
+     * on developer builds. See "adb root" for more information.
+     *
+     * @return true if the adb daemon is running as root, otherwise false.
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command.
+     * @throws ShellCommandUnresponsiveException if the root status cannot be queried.
+     * @throws IOException
+     */
+    boolean root()
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    IOException,
+                    ShellCommandUnresponsiveException;
+
+    /**
+     * Queries the current root-status of the device. See "adb root" for more information.
+     *
+     * @return true if the adb daemon is running as root, otherwise false.
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command.
+     */
+    boolean isRoot()
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    IOException,
+                    ShellCommandUnresponsiveException;
+
+    /**
+     * Return the device's battery level, from 0 to 100 percent.
+     *
+     * <p>The battery level may be cached. Only queries the device for its battery level if 5
+     * minutes have expired since the last successful query.
+     *
+     * @return the battery level or <code>null</code> if it could not be retrieved
+     * @deprecated use {@link #getBattery()}
+     */
+    @Deprecated
+    Integer getBatteryLevel()
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    IOException,
+                    ShellCommandUnresponsiveException;
+
+    /**
+     * Return the device's battery level, from 0 to 100 percent.
+     *
+     * <p>The battery level may be cached. Only queries the device for its battery level if <code>
+     * freshnessMs</code> ms have expired since the last successful query.
+     *
+     * @param freshnessMs
+     * @return the battery level or <code>null</code> if it could not be retrieved
+     * @throws ShellCommandUnresponsiveException
+     * @deprecated use {@link #getBattery(long, TimeUnit)}
+     */
+    @Deprecated
+    Integer getBatteryLevel(long freshnessMs)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    IOException,
+                    ShellCommandUnresponsiveException;
+
+    /**
+     * Return the device's battery level, from 0 to 100 percent.
+     *
+     * <p>The battery level may be cached. Only queries the device for its battery level if 5
+     * minutes have expired since the last successful query.
+     *
+     * @return a {@link Future} that can be used to query the battery level. The Future will return
+     *     a {@link ExecutionException} if battery level could not be retrieved.
+     */
+    @NonNull
+    Future<Integer> getBattery();
+
+    /**
+     * Return the device's battery level, from 0 to 100 percent.
+     *
+     * <p>The battery level may be cached. Only queries the device for its battery level if <code>
+     * freshnessTime</code> has expired since the last successful query.
+     *
+     * @param freshnessTime the desired recency of battery level
+     * @param timeUnit the {@link TimeUnit} of freshnessTime
+     * @return a {@link Future} that can be used to query the battery level. The Future will return
+     *     a {@link ExecutionException} if battery level could not be retrieved.
+     */
+    @NonNull
+    Future<Integer> getBattery(long freshnessTime, @NonNull TimeUnit timeUnit);
+
+    /**
+     * Returns the ABIs supported by this device. The ABIs are sorted in preferred order, with the
+     * first ABI being the most preferred.
+     *
+     * @return the list of ABIs.
+     */
+    @NonNull
+    List<String> getAbis();
+
+    /**
+     * Returns the density bucket of the device screen by reading the value for system property
+     * {@link #PROP_DEVICE_DENSITY}.
+     *
+     * @return the density, or -1 if it cannot be determined.
+     */
+    int getDensity();
+
+    /**
+     * Returns the user's language.
+     *
+     * @return the user's language, or null if it's unknown
+     */
+    @Nullable
+    String getLanguage();
+
+    /**
+     * Returns the user's region.
+     *
+     * @return the user's region, or null if it's unknown
+     */
+    @Nullable
+    String getRegion();
+
+    /**
+     * Invoke the host:exec service on a remote device. Return a socket channel that is connected to
+     * the executing process. Note that exec service does not differentiate stdout and stderr so
+     * whatever is read from the socket can come from either output and be interleaved.
+     *
+     * <p>Ownership of the SocketChannel is relinquished to the caller, it must be explicitly closed
+     * after usage.
+     *
+     * @return A SocketChannel connected to the executing process on the device. after use.
+     */
+    default SocketChannel rawExec(String executable, String[] parameters)
+            throws AdbCommandRejectedException, TimeoutException, IOException {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Invoke the Android Binder Bridge service on a remote device. Return a socket channel that is
+     * connected to the device binder command.
+     *
+     * <p>Ownership of the SocketChannel is relinquished to the caller, it must be explicitly closed
+     * after usage.
+     *
+     * @param service the name of the Android service to connect to
+     * @param parameters the parameters of the binder command
+     * @return A SocketChannel connected to the executing process on the device. after use.
+     */
+    default SocketChannel rawBinder(String service, String[] parameters)
+            throws AdbCommandRejectedException, TimeoutException, IOException {
+        throw new UnsupportedOperationException();
+    }
+
+    /** Returns features obtained by reading the build characteristics property. */
+    default Set<String> getHardwareCharacteristics() throws Exception {
+        String characteristics = getProperty(PROP_BUILD_CHARACTERISTICS);
+        if (characteristics == null) {
+            return Collections.emptySet();
+        }
+
+        return Sets.newHashSet(Splitter.on(',').split(characteristics));
+    }
+}
diff --git a/device_build_interfaces/com/android/ddmlib/IShellEnabledDevice.java b/device_build_interfaces/com/android/ddmlib/IShellEnabledDevice.java
new file mode 100644
index 000000000..0fb44dcf7
--- /dev/null
+++ b/device_build_interfaces/com/android/ddmlib/IShellEnabledDevice.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ddmlib;
+
+import com.android.annotations.NonNull;
+
+import com.google.common.util.concurrent.ListenableFuture;
+
+import java.io.IOException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+
+/** An abstract device that can receive shell commands. */
+public interface IShellEnabledDevice {
+
+    /**
+     * Returns a (humanized) name for this device. Typically this is the AVD name for AVD's, and a
+     * combination of the manufacturer name, model name &amp; serial number for devices.
+     */
+    String getName();
+
+    /**
+     * Executes a shell command on the device, and sends the result to a <var>receiver</var>.
+     *
+     * <p><var>maxTimeToOutputResponse</var> is used as a maximum waiting time when expecting the
+     * command output from the device.<br>
+     * At any time, if the shell command does not output anything for a period longer than
+     * <var>maxTimeToOutputResponse</var>, then the method will throw {@link
+     * ShellCommandUnresponsiveException}.
+     *
+     * <p>For commands like log output, a <var>maxTimeToOutputResponse</var> value of 0, meaning
+     * that the method will never throw and will block until the receiver's {@link
+     * IShellOutputReceiver#isCancelled()} returns <code>true</code>, should be used.
+     *
+     * @param command the shell command to execute
+     * @param receiver the {@link IShellOutputReceiver} that will receives the output of the shell
+     *     command
+     * @param maxTimeToOutputResponse the maximum amount of time during which the command is allowed
+     *     to not output any response. A value of 0 means the method will wait forever (until the
+     *     <var>receiver</var> cancels the execution) for command output and never throw.
+     * @param maxTimeUnits Units for non-zero {@code maxTimeToOutputResponse} values.
+     * @throws TimeoutException in case of timeout on the connection when sending the command.
+     * @throws AdbCommandRejectedException if adb rejects the command.
+     * @throws ShellCommandUnresponsiveException in case the shell command doesn't send any output
+     *     for a period longer than <var>maxTimeToOutputResponse</var>.
+     * @throws IOException in case of I/O error on the connection.
+     * @see DdmPreferences#getTimeOut()
+     */
+    void executeShellCommand(
+            String command,
+            IShellOutputReceiver receiver,
+            long maxTimeToOutputResponse,
+            TimeUnit maxTimeUnits)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    ShellCommandUnresponsiveException,
+                    IOException;
+
+    /**
+     * Executes a shell command on the device, and sends the result to a <var>receiver</var>.
+     *
+     * <p><var>maxTimeToOutputResponse</var> is used as a maximum waiting time when expecting the
+     * command output from the device.<br>
+     * At any time, if the shell command does not output anything for a period longer than
+     * <var>maxTimeToOutputResponse</var>, then the method will throw {@link
+     * ShellCommandUnresponsiveException}.
+     *
+     * <p>For commands like log output, a <var>maxTimeToOutputResponse</var> value of 0, meaning
+     * that the method will never throw and will block until the receiver's {@link
+     * IShellOutputReceiver#isCancelled()} returns <code>true</code>, should be used.
+     *
+     * @param command the shell command to execute
+     * @param receiver the {@link IShellOutputReceiver} that will receives the output of the shell
+     *     command
+     * @param maxTimeout the maximum timeout for the command to return. A value of 0 means no max
+     *     timeout will be applied.
+     * @param maxTimeToOutputResponse the maximum amount of time during which the command is allowed
+     *     to not output any response. A value of 0 means the method will wait forever (until the
+     *     <var>receiver</var> cancels the execution) for command output and never throw.
+     * @param maxTimeUnits Units for non-zero {@code maxTimeout} and {@code maxTimeToOutputResponse}
+     *     values.
+     * @throws TimeoutException in case of timeout on the connection when sending the command.
+     * @throws AdbCommandRejectedException if adb rejects the command.
+     * @throws ShellCommandUnresponsiveException in case the shell command doesn't send any output
+     *     for a period longer than <var>maxTimeToOutputResponse</var>.
+     * @throws IOException in case of I/O error on the connection.
+     * @see DdmPreferences#getTimeOut()
+     */
+    void executeShellCommand(
+            String command,
+            IShellOutputReceiver receiver,
+            long maxTimeout,
+            long maxTimeToOutputResponse,
+            TimeUnit maxTimeUnits)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    ShellCommandUnresponsiveException,
+                    IOException;
+
+    /**
+     * Do a potential asynchronous query for a system property.
+     *
+     * @param name the name of the value to return.
+     * @return a {@link ListenableFuture ListenableFuture.} {@link Future#get() get} may return
+     *     null.
+     */
+    @NonNull
+    ListenableFuture<String> getSystemProperty(@NonNull String name);
+}
diff --git a/device_build_interfaces/com/android/ddmlib/IShellOutputReceiver.java b/device_build_interfaces/com/android/ddmlib/IShellOutputReceiver.java
new file mode 100644
index 000000000..c304dd0ec
--- /dev/null
+++ b/device_build_interfaces/com/android/ddmlib/IShellOutputReceiver.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ddmlib;
+
+/**
+ * Classes which implement this interface provide methods that deal with out from a remote shell
+ * command on a device/emulator.
+ */
+public interface IShellOutputReceiver {
+    /**
+     * Called every time some new data is available.
+     *
+     * @param data The new data.
+     * @param offset The offset at which the new data starts.
+     * @param length The length of the new data.
+     */
+    void addOutput(byte[] data, int offset, int length);
+
+    /**
+     * Called at the end of the process execution (unless the process was canceled). This allows the
+     * receiver to terminate and flush whatever data was not yet processed.
+     */
+    void flush();
+
+    /**
+     * Cancel method to stop the execution of the remote shell command.
+     *
+     * @return true to cancel the execution of the command.
+     */
+    boolean isCancelled();
+}
diff --git a/device_build_interfaces/com/android/ddmlib/InstallCreateReceiver.java b/device_build_interfaces/com/android/ddmlib/InstallCreateReceiver.java
new file mode 100644
index 000000000..28ab17088
--- /dev/null
+++ b/device_build_interfaces/com/android/ddmlib/InstallCreateReceiver.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ddmlib;
+
+import com.android.annotations.Nullable;
+import com.android.tradefed.log.LogUtil.CLog;
+
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * Output receiver for "pm install-create" command line.
+ *
+ * <p>Extension of {@link com.android.ddmlib.InstallReceiver} that can receive a Success message
+ * from ADB followed by a session ID.
+ */
+public class InstallCreateReceiver extends InstallReceiver {
+
+    private static final Pattern successPattern = Pattern.compile("Success: .*\\[(\\d*)\\]");
+
+    private String mSessionId = null;
+
+    /**
+     * Returns the session ID if install-create create session successfully. Returns {@code null} if
+     * failure is seen.
+     */
+    @Nullable
+    public String getSessionId() {
+        if (getSuccessMessage() == null) {
+            return null;
+        }
+        String output = getSuccessMessage();
+        Matcher matcher = successPattern.matcher(output);
+        if (matcher.matches()) {
+            mSessionId = matcher.group(1);
+        } else {
+            mSessionId = null;
+            CLog.e(String.format("Output '%s' doesn't provide session id", output));
+        }
+
+        return mSessionId;
+    }
+}
diff --git a/device_build_interfaces/com/android/ddmlib/InstallException.java b/device_build_interfaces/com/android/ddmlib/InstallException.java
new file mode 100644
index 000000000..b71fae0b0
--- /dev/null
+++ b/device_build_interfaces/com/android/ddmlib/InstallException.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ddmlib;
+
+/** Thrown if installation or uninstallation of application fails. */
+public class InstallException extends CanceledException {
+    private static final long serialVersionUID = 1L;
+
+    private String errorCode;
+
+    public InstallException(Throwable cause) {
+        super(cause.getMessage(), cause);
+    }
+
+    public InstallException(String message) {
+        super(message);
+    }
+
+    public InstallException(String message, String errorCode) {
+        super(message);
+        this.errorCode = errorCode;
+    }
+
+    public InstallException(String message, Throwable cause) {
+        super(message, cause);
+    }
+
+    public String getErrorCode() {
+        return errorCode;
+    }
+
+    /**
+     * Returns true if the installation was canceled by user input. This can typically only happen
+     * in the sync phase.
+     */
+    @Override
+    public boolean wasCanceled() {
+        Throwable cause = getCause();
+        return cause instanceof SyncException && ((SyncException) cause).wasCanceled();
+    }
+}
diff --git a/device_build_interfaces/com/android/ddmlib/InstallMetrics.java b/device_build_interfaces/com/android/ddmlib/InstallMetrics.java
new file mode 100644
index 000000000..61c4c733c
--- /dev/null
+++ b/device_build_interfaces/com/android/ddmlib/InstallMetrics.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.ddmlib;
+
+public class InstallMetrics {
+    private final long uploadStartNs;
+    private final long uploadFinishNs;
+    private final long installStartNs;
+    private final long installFinishNs;
+
+    public InstallMetrics(
+            long uploadStartNs, long uploadFinishNs, long installStartNs, long installFinishNs) {
+        this.uploadStartNs = uploadStartNs;
+        this.uploadFinishNs = uploadFinishNs;
+        this.installStartNs = installStartNs;
+        this.installFinishNs = installFinishNs;
+    }
+
+    /**
+     * Returns the VM clock time at which the APK files in the installation began to be uploaded to
+     * the device.
+     */
+    public long getUploadStartNs() {
+        return uploadStartNs;
+    }
+
+    /**
+     * Return the VM clock time at which the APK files in the installation were finished uploading
+     * to the device.
+     */
+    public long getUploadFinishNs() {
+        return uploadFinishNs;
+    }
+
+    /** Return the VM clock time at which the installation began. */
+    public long getInstallStartNs() {
+        return installStartNs;
+    }
+
+    /** Returns the VM clock time at which the installation completed. */
+    public long getInstallFinishNs() {
+        return installFinishNs;
+    }
+}
diff --git a/device_build_interfaces/com/android/ddmlib/InstallReceiver.java b/device_build_interfaces/com/android/ddmlib/InstallReceiver.java
new file mode 100644
index 000000000..64ad8b2b8
--- /dev/null
+++ b/device_build_interfaces/com/android/ddmlib/InstallReceiver.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ddmlib;
+
+import com.android.annotations.NonNull;
+import com.android.annotations.Nullable;
+
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * Output receiver for "pm install package.apk" command line.
+ *
+ * <p>Use a combination of {@link #isSuccessfullyCompleted()} and {@link #getErrorMessage()} to
+ * decide if the installation was successful and what was the error.
+ */
+public class InstallReceiver extends MultiLineReceiver {
+
+    private static final String SUCCESS_OUTPUT = "Success"; // $NON-NLS-1$
+
+    /**
+     * A pattern to parse strings of the form Failure [ERROR] or Failure [ERROR: description]. Will
+     * capture the "ERROR: description", to use as message, and the "ERROR" part as error code.
+     */
+    private static final Pattern FAILURE_PATTERN =
+            Pattern.compile("Failure\\s+\\[(([^:]*)(:.*)?)\\]"); // $NON-NLS-1$
+
+    private String mErrorMessage = null;
+    private String mSuccessMessage = null;
+    private String mErrorCode = null;
+
+    /**
+     * Track whether the installation was actually successful, regardless of if we get an output
+     * from the command or not.
+     */
+    private boolean mSuccessfullyCompleted = false;
+
+    public InstallReceiver() {}
+
+    @Override
+    public void processNewLines(@NonNull String[] lines) {
+        for (String line : lines) {
+            if (!line.isEmpty()) {
+                if (line.startsWith(SUCCESS_OUTPUT)) {
+                    mSuccessfullyCompleted = true;
+                    mErrorMessage = null;
+                    mSuccessMessage = line;
+                    break;
+                } else {
+                    Matcher m = FAILURE_PATTERN.matcher(line);
+                    if (m.matches()) {
+                        mErrorMessage = m.group(1);
+                        mErrorCode = m.group(2);
+                        mSuccessMessage = null;
+                        mSuccessfullyCompleted = false;
+                        break;
+                    } else {
+                        if (mErrorMessage == null) {
+                            mErrorMessage = "Unknown failure: " + line;
+                            mErrorCode = "UNKNOWN";
+                        } else {
+                            mErrorMessage = mErrorMessage + "\n" + line;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    @Override
+    public boolean isCancelled() {
+        return false;
+    }
+
+    /**
+     * Returns the error message from the installation. Returns null if it was successful or if a
+     * timeout occurred.
+     */
+    @Nullable
+    public String getErrorMessage() {
+        return mErrorMessage;
+    }
+
+    /** Returns the success message from the installation. Returns null if failure is seen. */
+    @Nullable
+    public String getSuccessMessage() {
+        return mSuccessMessage;
+    }
+
+    /**
+     * @return The ERROR_CODE part of a message like: "Failure [ERROR_CODE: description]"
+     */
+    @Nullable
+    public String getErrorCode() {
+        return mErrorCode;
+    }
+
+    /**
+     * Returns true if the installation was fully successful. If {@link #getErrorMessage()} returns
+     * null and {@link #isSuccessfullyCompleted()} returns false, a timeout on device side was most
+     * likely encountered.
+     */
+    public boolean isSuccessfullyCompleted() {
+        return mSuccessfullyCompleted;
+    }
+
+    @Override
+    public void done() {
+        // On API 24, install-commit does not return anything, so we never receive either the
+        // Success or Failure line. If we get to this point and there was no error, we set it to be
+        // successful. Note that in the case of a time out, this method never gets called.
+        super.done();
+        if (mErrorMessage == null) {
+            mSuccessfullyCompleted = true;
+        }
+    }
+}
diff --git a/device_build_interfaces/com/android/ddmlib/MultiLineReceiver.java b/device_build_interfaces/com/android/ddmlib/MultiLineReceiver.java
new file mode 100644
index 000000000..ffb2c8e25
--- /dev/null
+++ b/device_build_interfaces/com/android/ddmlib/MultiLineReceiver.java
@@ -0,0 +1,139 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ddmlib;
+
+import com.android.annotations.NonNull;
+
+import com.google.common.base.Charsets;
+
+import java.util.ArrayList;
+import java.util.Collection;
+
+/**
+ * Base implementation of {@link IShellOutputReceiver}, that takes the raw data coming from the
+ * socket, and convert it into {@link String} objects.
+ *
+ * <p>Additionally, it splits the string by lines.
+ *
+ * <p>Classes extending it must implement {@link #processNewLines(String[])} which receives new
+ * parsed lines as they become available.
+ */
+public abstract class MultiLineReceiver implements IShellOutputReceiver {
+
+    private boolean mTrimLines = true;
+
+    /** unfinished message line, stored for next packet */
+    private String mUnfinishedLine = null;
+
+    private final Collection<String> mArray = new ArrayList<>();
+
+    /**
+     * Set the trim lines flag.
+     *
+     * @param trim whether the lines are trimmed, or not.
+     */
+    public void setTrimLine(boolean trim) {
+        mTrimLines = trim;
+    }
+
+    /* (non-Javadoc)
+     * @see com.android.ddmlib.adb.IShellOutputReceiver#addOutput(
+     *      byte[], int, int)
+     */
+    @Override
+    public final void addOutput(byte[] data, int offset, int length) {
+        if (!isCancelled()) {
+            String s = new String(data, offset, length, Charsets.UTF_8);
+
+            // ok we've got a string
+            // if we had an unfinished line we add it.
+            if (mUnfinishedLine != null) {
+                s = mUnfinishedLine + s;
+                mUnfinishedLine = null;
+            }
+
+            // now we split the lines
+            mArray.clear();
+            int start = 0;
+            do {
+                int index = s.indexOf('\n', start); // $NON-NLS-1$
+
+                // if \n was not found, this is an unfinished line
+                // and we store it to be processed for the next packet
+                if (index == -1) {
+                    mUnfinishedLine = s.substring(start);
+                    break;
+                }
+
+                // we found a \n, in older devices, this is preceded by a \r
+                int newlineLength = 1;
+                if (index > 0 && s.charAt(index - 1) == '\r') {
+                    index--;
+                    newlineLength = 2;
+                }
+
+                // extract the line
+                String line = s.substring(start, index);
+                if (mTrimLines) {
+                    line = line.trim();
+                }
+                mArray.add(line);
+
+                // move start to after the \r\n we found
+                start = index + newlineLength;
+            } while (true);
+
+            if (!mArray.isEmpty()) {
+                // at this point we've split all the lines.
+                // make the array
+                String[] lines = mArray.toArray(new String[0]);
+
+                // send it for final processing
+                processNewLines(lines);
+            }
+        }
+    }
+
+    /* (non-Javadoc)
+     * @see com.android.ddmlib.adb.IShellOutputReceiver#flush()
+     */
+    @Override
+    public void flush() {
+        if (mUnfinishedLine != null) {
+            processNewLines(new String[] {mUnfinishedLine});
+        }
+
+        done();
+    }
+
+    /**
+     * Terminates the process. This is called after the last lines have been through {@link
+     * #processNewLines(String[])}.
+     */
+    public void done() {
+        // do nothing.
+    }
+
+    /**
+     * Called when new lines are being received by the remote process.
+     *
+     * <p>It is guaranteed that the lines are complete when they are given to this method.
+     *
+     * @param lines The array containing the new lines.
+     */
+    public abstract void processNewLines(@NonNull String[] lines);
+}
diff --git a/device_build_interfaces/com/android/ddmlib/MultiReceiver.java b/device_build_interfaces/com/android/ddmlib/MultiReceiver.java
new file mode 100644
index 000000000..6b8abef91
--- /dev/null
+++ b/device_build_interfaces/com/android/ddmlib/MultiReceiver.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ddmlib;
+
+import com.android.annotations.NonNull;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+/**
+ * Base implementation of {@link IShellOutputReceiver}, that takes multiple instances of {@link
+ * IShellOutputReceiver} and broadcast the received data to all of them.
+ */
+public class MultiReceiver implements IShellOutputReceiver {
+
+    private final @NonNull ArrayList<IShellOutputReceiver> myReceivers;
+
+    public MultiReceiver(@NonNull IShellOutputReceiver... receivers) {
+        myReceivers = new ArrayList<>(Arrays.asList(receivers));
+    }
+
+    @Override
+    public void addOutput(@NonNull byte[] data, int offset, int length) {
+        updateReceiverList();
+        for (IShellOutputReceiver receiver : myReceivers) {
+            receiver.addOutput(data, offset, length);
+        }
+    }
+
+    @Override
+    public void flush() {
+        updateReceiverList();
+        for (IShellOutputReceiver receiver : myReceivers) {
+            receiver.flush();
+        }
+        myReceivers.clear();
+    }
+
+    @Override
+    public boolean isCancelled() {
+        updateReceiverList();
+        return myReceivers.isEmpty();
+    }
+
+    /** Removes any cancelled receiver from the current list. */
+    private void updateReceiverList() {
+        myReceivers.removeIf(IShellOutputReceiver::isCancelled);
+    }
+}
diff --git a/device_build_interfaces/com/android/ddmlib/NullOutputReceiver.java b/device_build_interfaces/com/android/ddmlib/NullOutputReceiver.java
new file mode 100644
index 000000000..568c087f0
--- /dev/null
+++ b/device_build_interfaces/com/android/ddmlib/NullOutputReceiver.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ddmlib;
+
+/**
+ * Implementation of {@link IShellOutputReceiver} that does nothing.
+ *
+ * <p>This can be used to execute a remote shell command when the output is not needed.
+ */
+public final class NullOutputReceiver implements IShellOutputReceiver {
+
+    private static NullOutputReceiver sReceiver = new NullOutputReceiver();
+
+    public static IShellOutputReceiver getReceiver() {
+        return sReceiver;
+    }
+
+    /* (non-Javadoc)
+     * @see com.android.ddmlib.adb.IShellOutputReceiver#addOutput(byte[], int, int)
+     */
+    @Override
+    public void addOutput(byte[] data, int offset, int length) {}
+
+    /* (non-Javadoc)
+     * @see com.android.ddmlib.adb.IShellOutputReceiver#flush()
+     */
+    @Override
+    public void flush() {}
+
+    /* (non-Javadoc)
+     * @see com.android.ddmlib.adb.IShellOutputReceiver#isCancelled()
+     */
+    @Override
+    public boolean isCancelled() {
+        return false;
+    }
+}
diff --git a/device_build_interfaces/com/android/ddmlib/PropertyFetcher.java b/device_build_interfaces/com/android/ddmlib/PropertyFetcher.java
new file mode 100644
index 000000000..800504876
--- /dev/null
+++ b/device_build_interfaces/com/android/ddmlib/PropertyFetcher.java
@@ -0,0 +1,285 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.ddmlib;
+
+import com.android.annotations.NonNull;
+import com.android.tradefed.log.LogUtil.CLog;
+
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.collect.Maps;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.SettableFuture;
+
+import java.util.Map;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/** Fetches and caches 'getprop' values from device. */
+public final class PropertyFetcher {
+    /** the amount of time to wait between unsuccessful prop fetch attempts */
+    private static final String GETPROP_COMMAND = "getprop"; // $NON-NLS-1$
+
+    private static final Pattern GETPROP_PATTERN =
+            Pattern.compile("^\\[([^]]+)\\]\\:\\s*\\[(.*)\\]$"); // $NON-NLS-1$
+
+    /** Two patterns in case the property span several lines. */
+    private static final Pattern GETPROP_START_LINE_PATTERN =
+            Pattern.compile("^\\[([^]]+)\\]\\:\\s*\\[(.*)$"); // $NON-NLS-1$
+
+    private static final Pattern GETPROP_END_LINE_PATTERN =
+            Pattern.compile("(.*)\\]$"); // $NON-NLS-1$
+
+    private static final int GETPROP_TIMEOUT_SEC = 2;
+    private static final int EXPECTED_PROP_COUNT = 150;
+
+    private enum CacheState {
+        UNPOPULATED,
+        FETCHING,
+        POPULATED
+    }
+
+    /**
+     * Shell output parser for a getprop command
+     *
+     * <p>We don't process String[] as they are read from the socket because they can be "cut"
+     * anywhere depending on how the socket is read (e.g: We can receive a multiline property with
+     * three values as String[2] and then String[1]). Instead, we buffer all the lines and parse
+     * them once the full stream has be received.
+     */
+    @VisibleForTesting
+    static class GetPropReceiver extends MultiLineReceiver {
+
+        private final Map<String, String> mCollectedProperties =
+                Maps.newHashMapWithExpectedSize(EXPECTED_PROP_COUNT);
+
+        private String[] lines = new String[0];
+
+        @Override
+        public void processNewLines(@NonNull String[] newLines) {
+            String[] tmp = new String[lines.length + newLines.length];
+            System.arraycopy(lines, 0, tmp, 0, lines.length);
+            System.arraycopy(newLines, 0, tmp, lines.length, newLines.length);
+            lines = tmp;
+        }
+
+        @Override
+        public void done() {
+            // We receive an array of lines.
+            // Some properties are single line, e.g.
+            //   [foo.bar] = [blah]
+            // Some properties span multiple lines, e.g.
+            //   [foo.bar] = [line 1\n
+            //   line 2\n
+            //   line 3]
+            String multiLineLabel = null;
+            String multiLineValue = null;
+            for (String line : lines) {
+                // If the line is empty in a multi-line property, we keep it, as its part of the
+                // property field.
+                if (multiLineLabel == null && (line.isEmpty() || line.startsWith("#"))) {
+                    continue;
+                }
+
+                Matcher m = GETPROP_PATTERN.matcher(line);
+                if (m.matches()) {
+                    String label = m.group(1);
+                    String value = m.group(2);
+
+                    if (!label.isEmpty()) {
+                        mCollectedProperties.put(label, value);
+                    }
+                    multiLineLabel = null;
+                    multiLineValue = null;
+                    continue;
+                }
+
+                Matcher multiLinePattern = GETPROP_START_LINE_PATTERN.matcher(line);
+                if (multiLinePattern.matches()) {
+                    multiLineLabel = multiLinePattern.group(1);
+                    if (multiLineLabel.isEmpty()) {
+                        continue;
+                    }
+                    multiLineValue = multiLinePattern.group(2);
+                    continue;
+                }
+
+                Matcher endPattern = GETPROP_END_LINE_PATTERN.matcher(line);
+                if (endPattern.matches()) {
+                    multiLineValue += "\n" + endPattern.group(1);
+                    mCollectedProperties.put(multiLineLabel, multiLineValue);
+                    multiLineLabel = null;
+                    multiLineValue = null;
+                    continue;
+                }
+                // If we are in-progress of a multi-line property.
+                if (multiLineValue != null) {
+                    multiLineValue += "\n" + line;
+                }
+            }
+        }
+
+        @Override
+        public boolean isCancelled() {
+            return false;
+        }
+
+        Map<String, String> getCollectedProperties() {
+            return mCollectedProperties;
+        }
+    }
+
+    private final Map<String, String> mProperties =
+            Maps.newHashMapWithExpectedSize(EXPECTED_PROP_COUNT);
+    private final IDevice mDevice;
+    private CacheState mCacheState = CacheState.UNPOPULATED;
+    private final Map<String, SettableFuture<String>> mPendingRequests =
+            Maps.newHashMapWithExpectedSize(4);
+
+    public PropertyFetcher(IDevice device) {
+        mDevice = device;
+    }
+
+    /** Returns the full list of cached properties. */
+    public synchronized Map<String, String> getProperties() {
+        return mProperties;
+    }
+
+    /**
+     * Ideally we should not cache mutable system properties. But removing cache will result in more
+     * blocking calls. Thus we keep the option to enable it here.
+     */
+    private static boolean sEnableCachingMutableProps = true;
+
+    public static void enableCachingMutableProps(boolean enabled) {
+        sEnableCachingMutableProps = enabled;
+    }
+
+    /**
+     * Make a possibly asynchronous request for a system property value.
+     *
+     * @param name the property name to retrieve
+     * @return a {@link Future} that can be used to retrieve the prop value
+     */
+    @NonNull
+    public synchronized ListenableFuture<String> getProperty(@NonNull String name) {
+        if (!mProperties.isEmpty() && isImmutableProperty(name)) {
+            // cache is populated and this is a ro prop
+            return Futures.immediateFuture(mProperties.get(name));
+        } else if (mCacheState.equals(CacheState.FETCHING)) {
+            return addPendingRequest(name);
+        } else if (mDevice.isOnline() && mCacheState.equals(CacheState.UNPOPULATED)
+                || !isImmutableProperty(name)) {
+            // cache is empty, or this is a volatile prop that requires a query
+            SettableFuture<String> result = addPendingRequest(name);
+            mCacheState = CacheState.FETCHING;
+            initiatePropertiesQuery();
+            return result;
+        } else {
+            // cache is populated and this is a ro prop
+            return Futures.immediateFuture(mProperties.get(name));
+        }
+    }
+
+    private SettableFuture<String> addPendingRequest(String name) {
+        SettableFuture<String> future = mPendingRequests.get(name);
+        if (future == null) {
+            future = SettableFuture.create();
+            mPendingRequests.put(name, future);
+        }
+        return future;
+    }
+
+    private void initiatePropertiesQuery() {
+        String threadName = String.format("query-prop-%s", mDevice.getSerialNumber());
+        Thread propThread =
+                new Thread(threadName) {
+                    @Override
+                    public void run() {
+                        try {
+                            GetPropReceiver propReceiver = new GetPropReceiver();
+                            mDevice.executeShellCommand(
+                                    GETPROP_COMMAND, propReceiver, getTimeout(), TimeUnit.SECONDS);
+                            populateCache(propReceiver.getCollectedProperties());
+                        } catch (Throwable e) {
+                            handleException(e);
+                        }
+                    }
+                };
+        propThread.setDaemon(true);
+        propThread.start();
+    }
+
+    private int getTimeout() {
+        try {
+            return Integer.parseInt(System.getProperty("ddmlib.getprop.timeout.sec"));
+        } catch (NumberFormatException e) {
+            return GETPROP_TIMEOUT_SEC;
+        }
+    }
+
+    private synchronized void populateCache(@NonNull Map<String, String> props) {
+        mCacheState = props.isEmpty() ? CacheState.UNPOPULATED : CacheState.POPULATED;
+        if (!props.isEmpty()) {
+            if (sEnableCachingMutableProps) {
+                mProperties.putAll(props);
+            } else {
+                for (Map.Entry<String, String> entry : props.entrySet()) {
+                    if (isImmutableProperty(entry.getKey())) {
+                        mProperties.put(entry.getKey(), entry.getValue());
+                    }
+                }
+            }
+        }
+        for (Map.Entry<String, SettableFuture<String>> entry : mPendingRequests.entrySet()) {
+            if (sEnableCachingMutableProps || isImmutableProperty(entry.getKey())) {
+                entry.getValue().set(mProperties.get(entry.getKey()));
+            } else {
+                entry.getValue().set(props.get(entry.getKey()));
+            }
+        }
+        mPendingRequests.clear();
+    }
+
+    private synchronized void handleException(Throwable e) {
+        mCacheState = CacheState.UNPOPULATED;
+        String msg =
+                String.format(
+                        "%s getting properties for device %s",
+                        e.getClass().getSimpleName(), mDevice.getSerialNumber());
+        CLog.w(new Throwable(msg, e));
+        for (Map.Entry<String, SettableFuture<String>> entry : mPendingRequests.entrySet()) {
+            entry.getValue().setException(e);
+        }
+        mPendingRequests.clear();
+    }
+
+    /**
+     * Return true if cache is populated.
+     *
+     * @deprecated implementation detail
+     */
+    @Deprecated
+    public synchronized boolean arePropertiesSet() {
+        return CacheState.POPULATED.equals(mCacheState);
+    }
+
+    private static boolean isImmutableProperty(@NonNull String propName) {
+        return propName.startsWith("ro.") || propName.equals(IDevice.PROP_DEVICE_EMULATOR_DENSITY);
+    }
+}
diff --git a/device_build_interfaces/com/android/ddmlib/RawImage.java b/device_build_interfaces/com/android/ddmlib/RawImage.java
new file mode 100644
index 000000000..d7ff27843
--- /dev/null
+++ b/device_build_interfaces/com/android/ddmlib/RawImage.java
@@ -0,0 +1,306 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ddmlib;
+
+import com.android.annotations.Nullable;
+
+import java.awt.color.ColorSpace;
+import java.awt.color.ICC_ColorSpace;
+import java.awt.color.ICC_Profile;
+import java.awt.image.BufferedImage;
+import java.awt.image.ColorModel;
+import java.awt.image.DataBuffer;
+import java.awt.image.DirectColorModel;
+import java.awt.image.WritableRaster;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+/** Data representing an image taken from a device frame buffer. */
+public final class RawImage {
+    public int version;
+    public int bpp;
+    public int colorSpace;
+    public int size;
+    public int width;
+    public int height;
+    public int red_offset;
+    public int red_length;
+    public int blue_offset;
+    public int blue_length;
+    public int green_offset;
+    public int green_length;
+    public int alpha_offset;
+    public int alpha_length;
+
+    public byte[] data;
+
+    // These values must match the values defined in frameworks/base/cmds/screencap
+    public static final int COLOR_SPACE_UNKNOWN = 0;
+    public static final int COLOR_SPACE_SRGB = 1;
+    public static final int COLOR_SPACE_DISPLAY_P3 = 2;
+
+    /**
+     * Reads the header of a RawImage from a {@link ByteBuffer}.
+     *
+     * <p>The way the data is sent over adb is defined in system/core/adb/framebuffer_service.c
+     *
+     * @param version the version of the protocol.
+     * @param buf the buffer to read from.
+     * @return true if success
+     */
+    public boolean readHeader(int version, ByteBuffer buf) {
+        this.version = version;
+
+        if (version == 16) {
+            // compatibility mode with original protocol
+            this.bpp = 16;
+
+            // read actual values.
+            this.size = buf.getInt();
+            this.width = buf.getInt();
+            this.height = buf.getInt();
+
+            // create default values for the rest. Format is 565
+            this.red_offset = 11;
+            this.red_length = 5;
+            this.green_offset = 5;
+            this.green_length = 6;
+            this.blue_offset = 0;
+            this.blue_length = 5;
+            this.alpha_offset = 0;
+            this.alpha_length = 0;
+        } else if (version == 1 || version == 2) {
+            this.bpp = buf.getInt();
+            if (version == 2) {
+                this.colorSpace = buf.getInt();
+            }
+            this.size = buf.getInt();
+            this.width = buf.getInt();
+            this.height = buf.getInt();
+            this.red_offset = buf.getInt();
+            this.red_length = buf.getInt();
+            this.blue_offset = buf.getInt();
+            this.blue_length = buf.getInt();
+            this.green_offset = buf.getInt();
+            this.green_length = buf.getInt();
+            this.alpha_offset = buf.getInt();
+            this.alpha_length = buf.getInt();
+        } else {
+            // unsupported protocol!
+            return false;
+        }
+
+        return true;
+    }
+
+    /**
+     * Returns the mask value for the red color.
+     *
+     * <p>This value is compatible with org.eclipse.swt.graphics.PaletteData
+     */
+    public int getRedMask() {
+        return getMask(red_length, red_offset);
+    }
+
+    /**
+     * Returns the mask value for the green color.
+     *
+     * <p>This value is compatible with org.eclipse.swt.graphics.PaletteData
+     */
+    public int getGreenMask() {
+        return getMask(green_length, green_offset);
+    }
+
+    /**
+     * Returns the mask value for the blue color.
+     *
+     * <p>This value is compatible with org.eclipse.swt.graphics.PaletteData
+     */
+    public int getBlueMask() {
+        return getMask(blue_length, blue_offset);
+    }
+
+    /**
+     * Returns the size of the header for a specific version of the framebuffer adb protocol.
+     *
+     * @param version the version of the protocol
+     * @return the number of int that makes up the header.
+     */
+    public static int getHeaderSize(int version) {
+        switch (version) {
+            case 16: // compatibility mode
+                return 3; // size, width, height
+            case 1:
+                return 12; // bpp, size, width, height, 4*(length, offset)
+            case 2:
+                return 13; // bpp, colorSpace, size, width, height, 4*(length, offset)
+        }
+
+        return 0;
+    }
+
+    /** Returns a rotated version of the image The image is rotated counter-clockwise. */
+    public RawImage getRotated() {
+        RawImage rotated = new RawImage();
+        rotated.version = this.version;
+        rotated.bpp = this.bpp;
+        rotated.colorSpace = this.colorSpace;
+        rotated.size = this.size;
+        rotated.red_offset = this.red_offset;
+        rotated.red_length = this.red_length;
+        rotated.blue_offset = this.blue_offset;
+        rotated.blue_length = this.blue_length;
+        rotated.green_offset = this.green_offset;
+        rotated.green_length = this.green_length;
+        rotated.alpha_offset = this.alpha_offset;
+        rotated.alpha_length = this.alpha_length;
+
+        rotated.width = this.height;
+        rotated.height = this.width;
+
+        int count = this.data.length;
+        rotated.data = new byte[count];
+
+        int byteCount = this.bpp >> 3; // bpp is in bits, we want bytes to match our array
+        final int w = this.width;
+        final int h = this.height;
+        for (int y = 0; y < h; y++) {
+            for (int x = 0; x < w; x++) {
+                System.arraycopy(
+                        this.data,
+                        (y * w + x) * byteCount,
+                        rotated.data,
+                        ((w - x - 1) * h + y) * byteCount,
+                        byteCount);
+            }
+        }
+
+        return rotated;
+    }
+
+    /** Returns an ARGB integer value for the pixel at <var>index</var> in {@link #data}. */
+    public int getARGB(int index) {
+        int value;
+        int r, g, b, a;
+        if (bpp == 16) {
+            value = data[index] & 0x00FF;
+            value |= (data[index + 1] << 8) & 0x0FF00;
+            // RGB565 to RGB888
+            // Multiply by 255/31 to convert from 5 bits (31 max) to 8 bits (255)
+            r = ((value >>> 11) & 0x1f) * 255 / 31;
+            g = ((value >>> 5) & 0x3f) * 255 / 63;
+            b = (value & 0x1f) * 255 / 31;
+            a = 0xFF; // force alpha to opaque if there's no alpha value in the framebuffer.
+        } else if (bpp == 32) {
+            value = data[index] & 0x00FF;
+            value |= (data[index + 1] & 0x00FF) << 8;
+            value |= (data[index + 2] & 0x00FF) << 16;
+            value |= (data[index + 3] & 0x00FF) << 24;
+            r = ((value >>> red_offset) & getMask(red_length)) << (8 - red_length);
+            g = ((value >>> green_offset) & getMask(green_length)) << (8 - green_length);
+            b = ((value >>> blue_offset) & getMask(blue_length)) << (8 - blue_length);
+            a = ((value >>> alpha_offset) & getMask(alpha_length)) << (8 - alpha_length);
+        } else {
+            throw new UnsupportedOperationException(
+                    "RawImage.getARGB(int) only works in 16 and 32 bit mode.");
+        }
+
+        return a << 24 | r << 16 | g << 8 | b;
+    }
+
+    public BufferedImage asBufferedImage() {
+        String profileName = getProfileName();
+        BufferedImage image;
+        if (profileName == null) {
+            //noinspection UndesirableClassUsage
+            image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
+        } else {
+            ICC_Profile profile = ICC_Profile.getInstance(ColorSpace.CS_sRGB);
+            try {
+                profile =
+                        ICC_Profile.getInstance(
+                                getClass()
+                                        .getClassLoader()
+                                        .getResourceAsStream("colorProfiles/" + profileName));
+            } catch (IOException e) {
+                // Ignore
+            }
+            ICC_ColorSpace colorSpace = new ICC_ColorSpace(profile);
+
+            ColorModel colorModel =
+                    new DirectColorModel(
+                            colorSpace,
+                            32,
+                            0x00ff0000,
+                            0x0000ff00,
+                            0x000000ff,
+                            0xff000000,
+                            false,
+                            DataBuffer.TYPE_INT);
+            WritableRaster raster = colorModel.createCompatibleWritableRaster(width, height);
+
+            //noinspection UndesirableClassUsage
+            image = new BufferedImage(colorModel, raster, colorModel.isAlphaPremultiplied(), null);
+        }
+        for (int y = 0; y < height; y++) {
+            for (int x = 0; x < width; x++) {
+                int argb = getARGB((x + y * width) * (bpp / 8));
+                image.setRGB(x, y, argb);
+            }
+        }
+        return image;
+    }
+
+    @Nullable
+    public String getProfileName() {
+        switch (colorSpace) {
+            case RawImage.COLOR_SPACE_UNKNOWN:
+                return null;
+            case RawImage.COLOR_SPACE_SRGB:
+                return "sRGB.icc";
+            case RawImage.COLOR_SPACE_DISPLAY_P3:
+                return "DisplayP3.icc";
+        }
+        return null;
+    }
+
+    /**
+     * creates a mask value based on a length and offset.
+     *
+     * <p>This value is compatible with org.eclipse.swt.graphics.PaletteData
+     */
+    private int getMask(int length, int offset) {
+        int res = getMask(length) << offset;
+
+        // if the bpp is 32 bits then we need to invert it because the buffer is in little endian
+        if (bpp == 32) {
+            return Integer.reverseBytes(res);
+        }
+
+        return res;
+    }
+
+    /**
+     * Creates a mask value based on a length.
+     *
+     * @param length
+     * @return
+     */
+    private static int getMask(int length) {
+        return (1 << length) - 1;
+    }
+}
diff --git a/device_build_interfaces/com/android/ddmlib/ScreenRecorderOptions.java b/device_build_interfaces/com/android/ddmlib/ScreenRecorderOptions.java
new file mode 100644
index 000000000..78d28bcfe
--- /dev/null
+++ b/device_build_interfaces/com/android/ddmlib/ScreenRecorderOptions.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ddmlib;
+
+import java.util.concurrent.TimeUnit;
+
+public class ScreenRecorderOptions {
+    // video size is given by width x height, defaults to device's main display resolution
+    // or 1280x720.
+    public final int width;
+    public final int height;
+
+    // bit rate in Mbps. Defaults to 4Mbps
+    public final int bitrateMbps;
+
+    // time limit, maximum of 3 seconds
+    public final long timeLimit;
+    public final TimeUnit timeLimitUnits;
+
+    // display touches
+    public final boolean showTouches;
+
+    private ScreenRecorderOptions(Builder builder) {
+        width = builder.mWidth;
+        height = builder.mHeight;
+
+        bitrateMbps = builder.mBitRate;
+
+        timeLimit = builder.mTime;
+        timeLimitUnits = builder.mTimeUnits;
+
+        showTouches = builder.mShowTouches;
+    }
+
+    public static class Builder {
+        private int mWidth;
+        private int mHeight;
+        private int mBitRate;
+        private boolean mShowTouches;
+        private long mTime;
+        private TimeUnit mTimeUnits;
+
+        public Builder setSize(int w, int h) {
+            mWidth = w;
+            mHeight = h;
+            return this;
+        }
+
+        public Builder setBitRate(int bitRateMbps) {
+            mBitRate = bitRateMbps;
+            return this;
+        }
+
+        public Builder setTimeLimit(long time, TimeUnit units) {
+            mTime = time;
+            mTimeUnits = units;
+            return this;
+        }
+
+        public Builder setShowTouches(boolean showTouches) {
+            mShowTouches = showTouches;
+            return this;
+        }
+
+        public ScreenRecorderOptions build() {
+            return new ScreenRecorderOptions(this);
+        }
+    }
+}
diff --git a/device_build_interfaces/com/android/ddmlib/ShellCommandUnresponsiveException.java b/device_build_interfaces/com/android/ddmlib/ShellCommandUnresponsiveException.java
new file mode 100644
index 000000000..50060ccac
--- /dev/null
+++ b/device_build_interfaces/com/android/ddmlib/ShellCommandUnresponsiveException.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ddmlib;
+
+/**
+ * Exception thrown when a shell command executed on a device takes too long to send its output.
+ *
+ * <p>The command may not actually be unresponsive, it just has spent too much time not outputting
+ * any thing to the console.
+ */
+public class ShellCommandUnresponsiveException extends Exception {
+    private static final long serialVersionUID = 1L;
+}
diff --git a/device_build_interfaces/com/android/ddmlib/SyncException.java b/device_build_interfaces/com/android/ddmlib/SyncException.java
new file mode 100644
index 000000000..003d09cae
--- /dev/null
+++ b/device_build_interfaces/com/android/ddmlib/SyncException.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ddmlib;
+
+import java.io.IOException;
+
+/**
+ * Exception thrown when a transfer using {@link SyncService} doesn't complete.
+ *
+ * <p>This is different from an {@link IOException} because it's not the underlying connection that
+ * triggered the error, but the adb transfer protocol that didn't work somehow, or that the targets
+ * (local and/or remote) were wrong.
+ */
+public class SyncException extends CanceledException {
+    private static final long serialVersionUID = 1L;
+
+    public enum SyncError {
+        /** canceled transfer */
+        CANCELED("Operation was canceled by the user."),
+        /** Transfer error */
+        TRANSFER_PROTOCOL_ERROR("Adb Transfer Protocol Error."),
+        /** unknown remote object during a pull */
+        NO_REMOTE_OBJECT("Remote object doesn't exist!"),
+        /** Result code when attempting to pull multiple files into a file */
+        TARGET_IS_FILE("Target object is a file."),
+        /** Result code when attempting to pull multiple into a directory that does not exist. */
+        NO_DIR_TARGET("Target directory doesn't exist."),
+        /** wrong encoding on the remote path. */
+        REMOTE_PATH_ENCODING("Remote Path encoding is not supported."),
+        /** remote path that is too long. */
+        REMOTE_PATH_LENGTH("Remote path is too long."),
+        /** error while reading local file. */
+        FILE_READ_ERROR("Reading local file failed!"),
+        /** error while writing local file. */
+        FILE_WRITE_ERROR("Writing local file failed!"),
+        /** attempting to push a directory. */
+        LOCAL_IS_DIRECTORY("Local path is a directory."),
+        /** attempting to push a non-existent file. */
+        NO_LOCAL_FILE("Local path doesn't exist."),
+        /** when the target path of a multi file push is a file. */
+        REMOTE_IS_FILE("Remote path is a file."),
+        /** receiving too much data from the remove device at once */
+        BUFFER_OVERRUN("Receiving too much data.");
+
+        private final String mMessage;
+
+        SyncError(String message) {
+            mMessage = message;
+        }
+
+        public String getMessage() {
+            return mMessage;
+        }
+    }
+
+    private final SyncError mError;
+
+    public SyncException(SyncError error) {
+        super(error.getMessage());
+        mError = error;
+    }
+
+    public SyncException(SyncError error, String message) {
+        super(message);
+        mError = error;
+    }
+
+    public SyncException(SyncError error, Throwable cause) {
+        super(error.getMessage(), cause);
+        mError = error;
+    }
+
+    public SyncError getErrorCode() {
+        return mError;
+    }
+
+    /** Returns true if the sync was canceled by user input. */
+    @Override
+    public boolean wasCanceled() {
+        return mError == SyncError.CANCELED;
+    }
+}
diff --git a/device_build_interfaces/com/android/ddmlib/TimeoutException.java b/device_build_interfaces/com/android/ddmlib/TimeoutException.java
new file mode 100644
index 000000000..115f27a06
--- /dev/null
+++ b/device_build_interfaces/com/android/ddmlib/TimeoutException.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ddmlib;
+
+/** Exception thrown when a connection to Adb failed with a timeout. */
+public class TimeoutException extends Exception {
+    private static final long serialVersionUID = 1L;
+
+    public TimeoutException() {}
+
+    public TimeoutException(String s) {
+        super(s);
+    }
+
+    public TimeoutException(String s, Throwable throwable) {
+        super(s, throwable);
+    }
+
+    public TimeoutException(Throwable throwable) {
+        super(throwable);
+    }
+}
diff --git a/device_build_interfaces/com/android/ddmlib/testrunner/IInstrumentationResultParser.java b/device_build_interfaces/com/android/ddmlib/testrunner/IInstrumentationResultParser.java
new file mode 100644
index 000000000..516519c44
--- /dev/null
+++ b/device_build_interfaces/com/android/ddmlib/testrunner/IInstrumentationResultParser.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.ddmlib.testrunner;
+
+import com.android.annotations.NonNull;
+import com.android.ddmlib.IShellOutputReceiver;
+
+import java.util.HashSet;
+import java.util.Set;
+
+/** Interface for parsing the results of an instrumentation test run from shell. */
+public interface IInstrumentationResultParser extends IShellOutputReceiver {
+
+    /** Relevant test status keys. */
+    class StatusKeys {
+        // Status keys which "am instrument" command uses.
+        public static final String TEST = "test";
+        public static final String CLASS = "class";
+        public static final String STACK = "stack";
+        public static final String NUMTESTS = "numtests";
+        public static final String ERROR = "Error";
+        public static final String SHORTMSG = "shortMsg";
+        public static final String STREAM = "stream";
+        public static final String CURRENT = "current";
+        public static final String ID = "id";
+
+        /** Additional status keys which Ddmlib uses to emit extra test metrics. */
+        public static final String DDMLIB_LOGCAT = "com.android.ddmlib.testrunner.logcat";
+
+        /**
+         * The set of expected status keys. Used to filter which keys should be stored as metrics
+         */
+        public static final Set<String> KNOWN_KEYS = new HashSet<>();
+
+        static {
+            KNOWN_KEYS.add(TEST);
+            KNOWN_KEYS.add(CLASS);
+            KNOWN_KEYS.add(STACK);
+            KNOWN_KEYS.add(NUMTESTS);
+            KNOWN_KEYS.add(ERROR);
+            KNOWN_KEYS.add(SHORTMSG);
+            KNOWN_KEYS.add(STREAM);
+            KNOWN_KEYS.add(CURRENT);
+            KNOWN_KEYS.add(ID);
+            KNOWN_KEYS.add(DDMLIB_LOGCAT);
+        }
+    }
+
+    /** Test result status codes. */
+    class StatusCodes {
+        public static final int START = 1;
+        public static final int IN_PROGRESS = 2;
+
+        // codes used for test completed
+        public static final int ASSUMPTION_FAILURE = -4;
+        public static final int IGNORED = -3;
+        public static final int FAILURE = -2;
+        public static final int ERROR = -1;
+        public static final int OK = 0;
+
+        public static boolean isTerminalState(int statusCode) {
+            return statusCode <= 0;
+        }
+    }
+
+    /** Am instrument session result codes. This code is passed by ActivityManagerService. */
+    class SessionResultCodes {
+        // All tests execution finished. (Some tests may have failed).
+        public static final int FINISHED = -1;
+
+        // Test session has been stopped due to an error.
+        public static final int ERROR = 0;
+    }
+
+    /** Requests cancellation of test run. */
+    void cancel();
+
+    /**
+     * This method is called when "am instrument" command crashes with an exception. All registered
+     * listeners should be notified {@link ITestRunListener#testRunFailed} followed by {@link
+     * ITestRunListener#testRunEnded} if the crash happens during the test execution.
+     */
+    void handleTestRunFailed(@NonNull String errorMsg);
+}
diff --git a/device_build_interfaces/com/android/ddmlib/testrunner/IRemoteAndroidTestRunner.java b/device_build_interfaces/com/android/ddmlib/testrunner/IRemoteAndroidTestRunner.java
new file mode 100644
index 000000000..c6773dcc8
--- /dev/null
+++ b/device_build_interfaces/com/android/ddmlib/testrunner/IRemoteAndroidTestRunner.java
@@ -0,0 +1,275 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ddmlib.testrunner;
+
+import com.android.ddmlib.AdbCommandRejectedException;
+import com.android.ddmlib.IDevice;
+import com.android.ddmlib.ShellCommandUnresponsiveException;
+import com.android.ddmlib.TimeoutException;
+
+import java.io.IOException;
+import java.util.Collection;
+import java.util.concurrent.TimeUnit;
+
+/** Interface for running a Android test command remotely and reporting result to a listener. */
+public interface IRemoteAndroidTestRunner {
+
+    enum TestSize {
+        /** Run tests annotated with SmallTest */
+        SMALL("small"),
+        /** Run tests annotated with MediumTest */
+        MEDIUM("medium"),
+        /** Run tests annotated with LargeTest */
+        LARGE("large");
+
+        private String mRunnerValue;
+
+        /**
+         * Create a {@link TestSize}.
+         *
+         * @param runnerValue the {@link String} value that represents the size that is passed to
+         *     device. Defined on device in android.test.InstrumentationTestRunner.
+         */
+        TestSize(String runnerValue) {
+            mRunnerValue = runnerValue;
+        }
+
+        String getRunnerValue() {
+            return mRunnerValue;
+        }
+
+        /**
+         * Return the {@link TestSize} corresponding to the given Android platform defined value.
+         *
+         * @throws IllegalArgumentException if {@link TestSize} cannot be found.
+         */
+        public static TestSize getTestSize(String value) {
+            // build the error message in the success case too, to avoid two for loops
+            StringBuilder msgBuilder = new StringBuilder("Unknown TestSize ");
+            msgBuilder.append(value);
+            msgBuilder.append(", Must be one of ");
+            for (TestSize size : values()) {
+                if (size.getRunnerValue().equals(value)) {
+                    return size;
+                }
+                msgBuilder.append(size.getRunnerValue());
+                msgBuilder.append(", ");
+            }
+            throw new IllegalArgumentException(msgBuilder.toString());
+        }
+    }
+
+    enum CoverageOutput {
+        DIR,
+        FILE,
+    }
+
+    /** Returns the application package name. */
+    String getPackageName();
+
+    /** Returns the runnerName. */
+    String getRunnerName();
+
+    /**
+     * Sets to run only tests in this class Must be called before 'run'.
+     *
+     * @param className fully qualified class name (eg x.y.z)
+     */
+    void setClassName(String className);
+
+    /**
+     * Sets to run only tests in the provided classes Must be called before 'run'.
+     *
+     * <p>If providing more than one class, requires a InstrumentationTestRunner that supports the
+     * multiple class argument syntax.
+     *
+     * @param classNames array of fully qualified class names (eg x.y.z)
+     */
+    void setClassNames(String[] classNames);
+
+    /**
+     * Sets to run only specified test method Must be called before 'run'.
+     *
+     * @param className fully qualified class name (eg x.y.z)
+     * @param testName method name
+     */
+    void setMethodName(String className, String testName);
+
+    /**
+     * Sets to run all tests in specified package Must be called before 'run'.
+     *
+     * @param packageName fully qualified package name (eg x.y.z)
+     */
+    void setTestPackageName(String packageName);
+
+    /**
+     * Sets to run only tests of given size. Must be called before 'run'.
+     *
+     * @param size the {@link TestSize} to run.
+     */
+    void setTestSize(TestSize size);
+
+    /**
+     * Adds a argument to include in instrumentation command.
+     *
+     * <p>Must be called before 'run'. If an argument with given name has already been provided, its
+     * value will be overridden.
+     *
+     * @param name the name of the instrumentation bundle argument
+     * @param value the value of the argument
+     */
+    void addInstrumentationArg(String name, String value);
+
+    /**
+     * Removes a previously added argument.
+     *
+     * @param name the name of the instrumentation bundle argument to remove
+     */
+    void removeInstrumentationArg(String name);
+
+    /**
+     * Adds a boolean argument to include in instrumentation command.
+     *
+     * <p>
+     *
+     * @see RemoteAndroidTestRunner#addInstrumentationArg
+     * @param name the name of the instrumentation bundle argument
+     * @param value the value of the argument
+     */
+    void addBooleanArg(String name, boolean value);
+
+    /** Sets this test run to log only mode - skips test execution. */
+    void setLogOnly(boolean logOnly);
+
+    /**
+     * Sets this debug mode of this test run. If true, the Android test runner will wait for a
+     * debugger to attach before proceeding with test execution.
+     */
+    void setDebug(boolean debug);
+
+    /**
+     * Sets the location of the additional test output to be copied to host before the test app is
+     * uninstalled. E.g., generated benchmark reports.
+     */
+    void setAdditionalTestOutputLocation(String additionalTestDataPath);
+
+    /** Sets this code coverage mode of this test run. */
+    void setCoverage(boolean coverage);
+
+    /** Sets the location of the generated coverage reports. */
+    void setCoverageReportLocation(String reportPath);
+
+    /** Returns the type of the test coverage produces by the runner. See {@link CoverageOutput}. */
+    CoverageOutput getCoverageOutputType();
+
+    /**
+     * Sets this test run to test collection mode. If true, will skip test execution and will set
+     * all appropriate runner arguments required for a successful test collection.
+     */
+    void setTestCollection(boolean collection);
+
+    /**
+     * @deprecated Use {@link #setMaxTimeToOutputResponse(long, java.util.concurrent.TimeUnit)}.
+     */
+    @Deprecated
+    void setMaxtimeToOutputResponse(int maxTimeToOutputResponse);
+
+    /**
+     * Sets the maximum time allowed between output of the shell command running the tests on the
+     * devices.
+     *
+     * <p>This allows setting a timeout in case the tests can become stuck and never finish. This is
+     * different from the normal timeout on the connection.
+     *
+     * <p>By default no timeout will be specified.
+     *
+     * @param maxTimeToOutputResponse the maximum amount of time during which the command is allowed
+     *     to not output any response. A value of 0 means the method will wait forever (until the
+     *     <var>receiver</var> cancels the execution) for command output and never throw.
+     * @param maxTimeUnits Units for non-zero {@code maxTimeToOutputResponse} and {@code maxTimeout}
+     *     values.
+     * @see IDevice#executeShellCommand(String, com.android.ddmlib.IShellOutputReceiver, long, long,
+     *     TimeUnit)
+     */
+    void setMaxTimeToOutputResponse(long maxTimeToOutputResponse, TimeUnit maxTimeUnits);
+
+    /**
+     * Sets the maximum time allowed for the instrumentation to finish.
+     *
+     * <p>This allows setting a timeout in case the tests can become stuck and never finish. This is
+     * different from the normal timeout on the connection.
+     *
+     * <p>By default no timeout will be specified.
+     *
+     * @param maxTimeout the maximum amount of time during which the command is allowed to not
+     *     output any response. A value of 0 means the method will wait forever (until the
+     *     <var>receiver</var> cancels the execution) for command output and never throw.
+     * @param maxTimeUnits Units for non-zero {@code maxTimeToOutputResponse} and {@code maxTimeout}
+     *     values.
+     * @see IDevice#executeShellCommand(String, com.android.ddmlib.IShellOutputReceiver, long, long,
+     *     TimeUnit)
+     */
+    void setMaxTimeout(long maxTimeout, TimeUnit maxTimeUnits);
+
+    /**
+     * Set a custom run name to be reported to the {@link ITestRunListener} on {@link #run}
+     *
+     * <p>If unspecified, will use package name
+     *
+     * @param runName
+     */
+    void setRunName(String runName);
+
+    /**
+     * Execute this test run.
+     *
+     * <p>Convenience method for {@link #run(Collection)}.
+     *
+     * @param listeners listens for test results
+     * @throws TimeoutException in case of a timeout on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws ShellCommandUnresponsiveException if the device did not output any test result for a
+     *     period longer than the max time to output.
+     * @throws IOException if connection to device was lost.
+     * @see #setMaxtimeToOutputResponse(int)
+     */
+    void run(ITestRunListener... listeners)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    ShellCommandUnresponsiveException,
+                    IOException;
+
+    /**
+     * Execute this test run.
+     *
+     * @param listeners collection of listeners for test results
+     * @throws TimeoutException in case of a timeout on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws ShellCommandUnresponsiveException if the device did not output any test result for a
+     *     period longer than the max time to output.
+     * @throws IOException if connection to device was lost.
+     * @see #setMaxtimeToOutputResponse(int)
+     */
+    void run(Collection<ITestRunListener> listeners)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    ShellCommandUnresponsiveException,
+                    IOException;
+
+    /** Requests cancellation of this test run. */
+    void cancel();
+}
diff --git a/device_build_interfaces/com/android/ddmlib/testrunner/ITestRunListener.java b/device_build_interfaces/com/android/ddmlib/testrunner/ITestRunListener.java
new file mode 100644
index 000000000..7d5a77aea
--- /dev/null
+++ b/device_build_interfaces/com/android/ddmlib/testrunner/ITestRunListener.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ddmlib.testrunner;
+
+import java.util.Map;
+
+/**
+ * Receives event notifications during instrumentation test runs.
+ *
+ * <p>Patterned after org.junit.runner.notification.RunListener
+ *
+ * <p>The sequence of calls will be:
+ *
+ * <ul>
+ *   <li>testRunStarted
+ *   <li>testStarted
+ *   <li>[testFailed]
+ *   <li>[testAssumptionFailure]
+ *   <li>[testIgnored]
+ *   <li>testEnded
+ *   <li>....
+ *   <li>[testRunFailed]
+ *   <li>testRunEnded
+ * </ul>
+ */
+public interface ITestRunListener {
+
+    /**
+     * Reports the start of a test run.
+     *
+     * @param runName the test run name
+     * @param testCount total number of tests in test run
+     */
+    void testRunStarted(String runName, int testCount);
+
+    /**
+     * Reports the start of an individual test case.
+     *
+     * @param test identifies the test
+     */
+    void testStarted(TestIdentifier test);
+
+    /**
+     * Reports the failure of a individual test case.
+     *
+     * <p>Will be called between testStarted and testEnded.
+     *
+     * @param test identifies the test
+     * @param trace stack trace of failure
+     */
+    void testFailed(TestIdentifier test, String trace);
+
+    /**
+     * Called when an atomic test flags that it assumes a condition that is false
+     *
+     * @param test identifies the test
+     * @param trace stack trace of failure
+     */
+    void testAssumptionFailure(TestIdentifier test, String trace);
+
+    /**
+     * Called when a test will not be run, generally because a test method is annotated with
+     * org.junit.Ignore.
+     *
+     * @param test identifies the test
+     */
+    void testIgnored(TestIdentifier test);
+
+    /**
+     * Reports the execution end of an individual test case.
+     *
+     * <p>If {@link #testFailed} was not invoked, this test passed. Also returns any key/value
+     * metrics which may have been emitted during the test case's execution.
+     *
+     * @param test identifies the test
+     * @param testMetrics a {@link Map} of the metrics emitted during the execution of the test case
+     *     by {@code android.app.Instrumentation#sendStatus}. The insertion order is preserved
+     *     unless you emit a same key multiple times. Note that standard keys defined in {@link
+     *     IInstrumentationResultParser.StatusKeys} are filtered out of this Map. Ddmlib may add
+     *     extra test metrics defined in {@link IInstrumentationResultParser.StatusKeys}.
+     */
+    void testEnded(TestIdentifier test, Map<String, String> testMetrics);
+
+    /**
+     * Reports test run failed to complete due to a fatal error.
+     *
+     * @param errorMessage {@link String} describing reason for run failure.
+     */
+    void testRunFailed(String errorMessage);
+
+    /**
+     * Reports test run stopped before completion due to a user request.
+     *
+     * @param elapsedTime device reported elapsed time, in milliseconds
+     * @deprecated This callback is never be invoked. To be deleted.
+     */
+    @Deprecated
+    void testRunStopped(long elapsedTime);
+
+    /**
+     * Reports end of test run.
+     *
+     * @param elapsedTime device reported elapsed time, in milliseconds
+     * @param runMetrics a {@link Map} of the metrics emitted during the execution of the test case
+     *     by {@code android.app.Instrumentation#addResults}. The insertion order is preserved
+     *     unless you emit a same key multiple times. Note that standard keys defined in {@link
+     *     IInstrumentationResultParser.StatusKeys} are filtered out of this Map. Ddmlib may add
+     *     extra test metrics defined in {@link IInstrumentationResultParser.StatusKeys}.
+     */
+    void testRunEnded(long elapsedTime, Map<String, String> runMetrics);
+}
diff --git a/device_build_interfaces/com/android/ddmlib/testrunner/TestRunResult.java b/device_build_interfaces/com/android/ddmlib/testrunner/TestRunResult.java
new file mode 100644
index 000000000..5ea9e50a8
--- /dev/null
+++ b/device_build_interfaces/com/android/ddmlib/testrunner/TestRunResult.java
@@ -0,0 +1,294 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.ddmlib.testrunner;
+
+import com.android.ddmlib.testrunner.TestResult.TestStatus;
+import com.android.tradefed.log.LogUtil.CLog;
+
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * Holds results from a single test run.
+ *
+ * <p>Maintains an accurate count of tests, and tracks incomplete tests.
+ *
+ * <p>Not thread safe! The test* callbacks must be called in order
+ */
+public class TestRunResult implements ITestRunListener {
+    private static final String LOG_TAG = TestRunResult.class.getSimpleName();
+    private String mTestRunName;
+    // Uses a LinkedHashMap to have predictable iteration order
+    private Map<TestIdentifier, TestResult> mTestResults =
+            new LinkedHashMap<TestIdentifier, TestResult>();
+    private Map<String, String> mRunMetrics = new HashMap<String, String>();
+    private boolean mIsRunComplete = false;
+    private long mElapsedTime = 0;
+
+    /** represents sums of tests in each TestStatus state. Indexed by TestStatus.ordinal() */
+    private int[] mStatusCounts = new int[TestStatus.values().length];
+
+    /** tracks if mStatusCounts is accurate, or if it needs to be recalculated */
+    private boolean mIsCountDirty = true;
+
+    private String mRunFailureError = null;
+
+    private boolean mAggregateMetrics = false;
+
+    /** Create an empty{@link TestRunResult}. */
+    public TestRunResult() {
+        mTestRunName = "not started";
+    }
+
+    public void setAggregateMetrics(boolean metricAggregation) {
+        mAggregateMetrics = metricAggregation;
+    }
+
+    /**
+     * @return the test run name
+     */
+    public String getName() {
+        return mTestRunName;
+    }
+
+    /** Returns a map of the test results. */
+    public Map<TestIdentifier, TestResult> getTestResults() {
+        return mTestResults;
+    }
+
+    /**
+     * @return a {@link Map} of the test test run metrics.
+     */
+    public Map<String, String> getRunMetrics() {
+        return mRunMetrics;
+    }
+
+    /** Gets the set of completed tests. */
+    public Set<TestIdentifier> getCompletedTests() {
+        Set<TestIdentifier> completedTests = new LinkedHashSet<TestIdentifier>();
+        for (Map.Entry<TestIdentifier, TestResult> testEntry : getTestResults().entrySet()) {
+            if (!testEntry.getValue().getStatus().equals(TestStatus.INCOMPLETE)) {
+                completedTests.add(testEntry.getKey());
+            }
+        }
+        return completedTests;
+    }
+
+    /**
+     * @return <code>true</code> if test run failed.
+     */
+    public boolean isRunFailure() {
+        return mRunFailureError != null;
+    }
+
+    /**
+     * @return <code>true</code> if test run finished.
+     */
+    public boolean isRunComplete() {
+        return mIsRunComplete;
+    }
+
+    public void setRunComplete(boolean runComplete) {
+        mIsRunComplete = runComplete;
+    }
+
+    /** Gets the number of tests in given state for this run. */
+    public int getNumTestsInState(TestStatus status) {
+        if (mIsCountDirty) {
+            // clear counts
+            for (int i = 0; i < mStatusCounts.length; i++) {
+                mStatusCounts[i] = 0;
+            }
+            // now recalculate
+            for (TestResult r : mTestResults.values()) {
+                mStatusCounts[r.getStatus().ordinal()]++;
+            }
+            mIsCountDirty = false;
+        }
+        return mStatusCounts[status.ordinal()];
+    }
+
+    /** Gets the number of tests in this run. */
+    public int getNumTests() {
+        return mTestResults.size();
+    }
+
+    /** Gets the number of complete tests in this run ie with status != incomplete. */
+    public int getNumCompleteTests() {
+        return getNumTests() - getNumTestsInState(TestStatus.INCOMPLETE);
+    }
+
+    /**
+     * @return <code>true</code> if test run had any failed or error tests.
+     */
+    public boolean hasFailedTests() {
+        return getNumAllFailedTests() > 0;
+    }
+
+    /** Return total number of tests in a failure state (failed, assumption failure) */
+    public int getNumAllFailedTests() {
+        return getNumTestsInState(TestStatus.FAILURE);
+    }
+
+    /** Returns the current run elapsed time. */
+    public long getElapsedTime() {
+        return mElapsedTime;
+    }
+
+    /** Return the run failure error message, <code>null</code> if run did not fail. */
+    public String getRunFailureMessage() {
+        return mRunFailureError;
+    }
+
+    @Override
+    public void testRunStarted(String runName, int testCount) {
+        mTestRunName = runName;
+        mIsRunComplete = false;
+        mRunFailureError = null;
+    }
+
+    @Override
+    public void testStarted(TestIdentifier test) {
+        testStarted(test, System.currentTimeMillis());
+    }
+
+    void testStarted(TestIdentifier test, long startTime) {
+        TestResult res = new TestResult();
+        res.setStartTime(startTime);
+        addTestResult(test, res);
+    }
+
+    private void addTestResult(TestIdentifier test, TestResult testResult) {
+        mIsCountDirty = true;
+        mTestResults.put(test, testResult);
+    }
+
+    private void updateTestResult(TestIdentifier test, TestStatus status, String trace) {
+        TestResult r = mTestResults.get(test);
+        if (r == null) {
+            CLog.d(String.format("received test event without test start for %s", test));
+            r = new TestResult();
+        }
+        r.setStatus(status);
+        r.setStackTrace(trace);
+        addTestResult(test, r);
+    }
+
+    @Override
+    public void testFailed(TestIdentifier test, String trace) {
+        updateTestResult(test, TestStatus.FAILURE, trace);
+    }
+
+    @Override
+    public void testAssumptionFailure(TestIdentifier test, String trace) {
+        updateTestResult(test, TestStatus.ASSUMPTION_FAILURE, trace);
+    }
+
+    @Override
+    public void testIgnored(TestIdentifier test) {
+        updateTestResult(test, TestStatus.IGNORED, null);
+    }
+
+    @Override
+    public void testEnded(TestIdentifier test, Map<String, String> testMetrics) {
+        testEnded(test, System.currentTimeMillis(), testMetrics);
+    }
+
+    void testEnded(TestIdentifier test, long endTime, Map<String, String> testMetrics) {
+        TestResult result = mTestResults.get(test);
+        if (result == null) {
+            result = new TestResult();
+        }
+        if (result.getStatus().equals(TestStatus.INCOMPLETE)) {
+            result.setStatus(TestStatus.PASSED);
+        }
+        result.setEndTime(endTime);
+        result.setMetrics(testMetrics);
+        addTestResult(test, result);
+    }
+
+    @Override
+    public void testRunFailed(String errorMessage) {
+        mRunFailureError = errorMessage;
+    }
+
+    @Override
+    public void testRunStopped(long elapsedTime) {
+        mElapsedTime += elapsedTime;
+        mIsRunComplete = true;
+    }
+
+    @Override
+    public void testRunEnded(long elapsedTime, Map<String, String> runMetrics) {
+        if (mAggregateMetrics) {
+            for (Map.Entry<String, String> entry : runMetrics.entrySet()) {
+                String existingValue = mRunMetrics.get(entry.getKey());
+                String combinedValue = combineValues(existingValue, entry.getValue());
+                mRunMetrics.put(entry.getKey(), combinedValue);
+            }
+        } else {
+            mRunMetrics.putAll(runMetrics);
+        }
+        mElapsedTime += elapsedTime;
+        mIsRunComplete = true;
+    }
+
+    /**
+     * Combine old and new metrics value
+     *
+     * @param existingValue
+     * @param newValue
+     * @return the combination of the two string as Long or Double value.
+     */
+    private String combineValues(String existingValue, String newValue) {
+        if (existingValue != null) {
+            try {
+                Long existingLong = Long.parseLong(existingValue);
+                Long newLong = Long.parseLong(newValue);
+                return Long.toString(existingLong + newLong);
+            } catch (NumberFormatException e) {
+                // not a long, skip to next
+            }
+            try {
+                Double existingDouble = Double.parseDouble(existingValue);
+                Double newDouble = Double.parseDouble(newValue);
+                return Double.toString(existingDouble + newDouble);
+            } catch (NumberFormatException e) {
+                // not a double either, fall through
+            }
+        }
+        // default to overriding existingValue
+        return newValue;
+    }
+
+    /** Returns a user friendly string describing results. */
+    public String getTextSummary() {
+        StringBuilder builder = new StringBuilder();
+        builder.append(String.format("Total tests %d, ", getNumTests()));
+        for (TestStatus status : TestStatus.values()) {
+            int count = getNumTestsInState(status);
+            // only add descriptive state for states that have non zero values, to avoid cluttering
+            // the response
+            if (count > 0) {
+                builder.append(String.format("%s %d, ", status.toString().toLowerCase(), count));
+            }
+        }
+        return builder.toString();
+    }
+}
diff --git a/device_build_interfaces/com/android/ddmlib/testrunner/XmlTestRunListener.java b/device_build_interfaces/com/android/ddmlib/testrunner/XmlTestRunListener.java
new file mode 100644
index 000000000..51ca8587c
--- /dev/null
+++ b/device_build_interfaces/com/android/ddmlib/testrunner/XmlTestRunListener.java
@@ -0,0 +1,342 @@
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ddmlib.testrunner;
+
+import com.android.annotations.NonNull;
+import com.android.ddmlib.testrunner.TestResult.TestStatus;
+import com.android.tradefed.log.Log;
+import com.android.tradefed.log.Log.LogLevel;
+
+import com.google.common.collect.ImmutableMap;
+
+import org.kxml2.io.KXmlSerializer;
+
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+import java.util.Map;
+import java.util.TimeZone;
+
+/**
+ * Writes JUnit results to an XML files in a format consistent with Ant's XMLJUnitResultFormatter.
+ *
+ * <p>Creates a separate XML file per test run.
+ *
+ * @see <a
+ *     href="https://svn.jenkins-ci.org/trunk/hudson/dtkit/dtkit-format/dtkit-junit-model/src/main/resources/com/thalesgroup/dtkit/junit/model/xsd/junit-4.xsd">https://svn.jenkins-ci.org/trunk/hudson/dtkit/dtkit-format/dtkit-junit-model/src/main/resources/com/thalesgroup/dtkit/junit/model/xsd/junit-4.xsd</a>
+ */
+public class XmlTestRunListener implements ITestRunListener {
+
+    private static final String LOG_TAG = "XmlResultReporter";
+
+    private static final String TEST_RESULT_FILE_SUFFIX = ".xml";
+    private static final String TEST_RESULT_FILE_PREFIX = "test_result_";
+
+    private static final String TESTSUITE = "testsuite";
+    private static final String TESTCASE = "testcase";
+    private static final String ERROR = "error";
+    private static final String FAILURE = "failure";
+    private static final String SKIPPED_TAG = "skipped";
+    private static final String ATTR_NAME = "name";
+    private static final String ATTR_TIME = "time";
+    private static final String ATTR_ERRORS = "errors";
+    private static final String ATTR_FAILURES = "failures";
+    private static final String ATTR_SKIPPED = "skipped";
+    private static final String ATTR_ASSERTIOMS = "assertions";
+    private static final String ATTR_TESTS = "tests";
+    // private static final String ATTR_TYPE = "type";
+    // private static final String ATTR_MESSAGE = "message";
+    private static final String PROPERTIES = "properties";
+    private static final String PROPERTY = "property";
+    private static final String ATTR_CLASSNAME = "classname";
+    private static final String TIMESTAMP = "timestamp";
+    private static final String HOSTNAME = "hostname";
+    private static final String SYSTEM_ERR = "system-err";
+
+    /** the XML namespace */
+    private static final String ns = null;
+
+    private String mHostName = "localhost";
+
+    private File mReportDir = new File(System.getProperty("java.io.tmpdir"));
+
+    private String mReportPath = "";
+
+    private TestRunResult mRunResult = new TestRunResult();
+
+    private StringBuilder mSystemError = new StringBuilder();
+
+    /** Sets the report file to use. */
+    public void setReportDir(File file) {
+        mReportDir = file;
+    }
+
+    public void setHostName(String hostName) {
+        mHostName = hostName;
+    }
+
+    /**
+     * Returns the {@link TestRunResult}
+     *
+     * @return the test run results.
+     */
+    public TestRunResult getRunResult() {
+        return mRunResult;
+    }
+
+    @Override
+    public void testRunStarted(String runName, int numTests) {
+        mRunResult = new TestRunResult();
+        mRunResult.testRunStarted(runName, numTests);
+    }
+
+    @Override
+    public void testStarted(TestIdentifier test) {
+        mRunResult.testStarted(test);
+    }
+
+    @Override
+    public void testFailed(TestIdentifier test, String trace) {
+        mRunResult.testFailed(test, trace);
+    }
+
+    @Override
+    public void testAssumptionFailure(TestIdentifier test, String trace) {
+        mRunResult.testAssumptionFailure(test, trace);
+    }
+
+    @Override
+    public void testIgnored(TestIdentifier test) {
+        mRunResult.testIgnored(test);
+    }
+
+    @Override
+    public void testEnded(TestIdentifier test, Map<String, String> testMetrics) {
+        mRunResult.testEnded(test, testMetrics);
+    }
+
+    @Override
+    public void testRunFailed(String errorMessage) {
+        mRunResult.testRunFailed(errorMessage);
+    }
+
+    @Override
+    public void testRunStopped(long elapsedTime) {
+        mRunResult.testRunStopped(elapsedTime);
+    }
+
+    @Override
+    public void testRunEnded(long elapsedTime, Map<String, String> runMetrics) {
+        mRunResult.testRunEnded(elapsedTime, runMetrics);
+        generateDocument(mReportDir, elapsedTime);
+    }
+
+    /** Creates a report file and populates it with the report data from the completed tests. */
+    private void generateDocument(File reportDir, long elapsedTime) {
+        String timestamp = getTimestamp();
+
+        OutputStream stream = null;
+        try {
+            stream = createOutputResultStream(reportDir);
+            KXmlSerializer serializer = new KXmlSerializer();
+            serializer.setOutput(stream, "UTF-8");
+            serializer.startDocument("UTF-8", null);
+            serializer.setFeature("http://xmlpull.org/v1/doc/features.html#indent-output", true);
+            // TODO: insert build info
+            printTestResults(serializer, timestamp, elapsedTime);
+            serializer.endDocument();
+            String msg =
+                    String.format(
+                            "XML test result file generated at %s. %s",
+                            getAbsoluteReportPath(), mRunResult.getTextSummary());
+            Log.logAndDisplay(LogLevel.INFO, LOG_TAG, msg);
+        } catch (IOException e) {
+            Log.e(LOG_TAG, "Failed to generate report data");
+            // TODO: consider throwing exception
+        } finally {
+            if (stream != null) {
+                try {
+                    stream.close();
+                } catch (IOException ignored) {
+                }
+            }
+        }
+    }
+
+    private String getAbsoluteReportPath() {
+        return mReportPath;
+    }
+
+    /** Return the current timestamp as a {@link String}. */
+    String getTimestamp() {
+        SimpleDateFormat dateFormat =
+                new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss", Locale.getDefault());
+        TimeZone gmt = TimeZone.getTimeZone("UTC");
+        dateFormat.setTimeZone(gmt);
+        dateFormat.setLenient(true);
+        String timestamp = dateFormat.format(new Date());
+        return timestamp;
+    }
+
+    /**
+     * Returns the system error message to be written into XML file in "system-err" element. The
+     * element is not created if this returns an empty string.
+     */
+    public String getSystemError() {
+        return mSystemError.toString();
+    }
+
+    /** Add system error message. */
+    public void addSystemError(String systemError) {
+        mSystemError.append(systemError);
+    }
+
+    /**
+     * Creates a {@link File} where the report will be created.
+     *
+     * @param reportDir the root directory of the report.
+     * @return a file
+     * @throws IOException
+     */
+    protected File getResultFile(File reportDir) throws IOException {
+        File reportFile =
+                File.createTempFile(TEST_RESULT_FILE_PREFIX, TEST_RESULT_FILE_SUFFIX, reportDir);
+        Log.i(
+                LOG_TAG,
+                String.format("Created xml report file at %s", reportFile.getAbsolutePath()));
+
+        return reportFile;
+    }
+
+    /** Creates the output stream to use for test results. Exposed for mocking. */
+    OutputStream createOutputResultStream(File reportDir) throws IOException {
+        File reportFile = getResultFile(reportDir);
+        mReportPath = reportFile.getAbsolutePath();
+        return new BufferedOutputStream(new FileOutputStream(reportFile));
+    }
+
+    protected String getTestSuiteName() {
+        return mRunResult.getName();
+    }
+
+    void printTestResults(KXmlSerializer serializer, String timestamp, long elapsedTime)
+            throws IOException {
+        serializer.startTag(ns, TESTSUITE);
+        String name = getTestSuiteName();
+        if (name != null) {
+            serializer.attribute(ns, ATTR_NAME, name);
+        }
+        serializer.attribute(ns, ATTR_TESTS, Integer.toString(mRunResult.getNumTests()));
+        serializer.attribute(
+                ns, ATTR_FAILURES, Integer.toString(mRunResult.getNumAllFailedTests()));
+        // legacy - there are no errors in JUnit4
+        serializer.attribute(ns, ATTR_ERRORS, "0");
+        serializer.attribute(
+                ns,
+                ATTR_SKIPPED,
+                Integer.toString(mRunResult.getNumTestsInState(TestStatus.IGNORED)));
+
+        serializer.attribute(ns, ATTR_TIME, Double.toString((double) elapsedTime / 1000.f));
+        serializer.attribute(ns, TIMESTAMP, timestamp);
+        serializer.attribute(ns, HOSTNAME, mHostName);
+
+        serializer.startTag(ns, PROPERTIES);
+        for (Map.Entry<String, String> entry : getPropertiesAttributes().entrySet()) {
+            serializer.startTag(ns, PROPERTY);
+            serializer.attribute(ns, "name", entry.getKey());
+            serializer.attribute(ns, "value", entry.getValue());
+            serializer.endTag(ns, PROPERTY);
+        }
+        serializer.endTag(ns, PROPERTIES);
+
+        Map<TestIdentifier, TestResult> testResults = mRunResult.getTestResults();
+        for (Map.Entry<TestIdentifier, TestResult> testEntry : testResults.entrySet()) {
+            print(serializer, testEntry.getKey(), testEntry.getValue());
+        }
+
+        String systemError = getSystemError();
+        if (!systemError.isEmpty()) {
+            serializer.startTag(ns, SYSTEM_ERR);
+            serializer.text(systemError);
+            serializer.endTag(ns, SYSTEM_ERR);
+        }
+
+        serializer.endTag(ns, TESTSUITE);
+    }
+
+    /** Get the properties attributes as key value pairs to be included in the test report. */
+    @NonNull
+    protected Map<String, String> getPropertiesAttributes() {
+        return ImmutableMap.of();
+    }
+
+    protected String getTestName(TestIdentifier testId) {
+        return testId.getTestName();
+    }
+
+    void print(KXmlSerializer serializer, TestIdentifier testId, TestResult testResult)
+            throws IOException {
+
+        serializer.startTag(ns, TESTCASE);
+        serializer.attribute(ns, ATTR_NAME, getTestName(testId));
+        serializer.attribute(ns, ATTR_CLASSNAME, testId.getClassName());
+        long elapsedTimeMs = testResult.getEndTime() - testResult.getStartTime();
+        serializer.attribute(ns, ATTR_TIME, Double.toString((double) elapsedTimeMs / 1000.f));
+
+        switch (testResult.getStatus()) {
+            case FAILURE:
+                printFailedTest(serializer, FAILURE, testResult.getStackTrace());
+                break;
+            case ASSUMPTION_FAILURE:
+                printFailedTest(serializer, SKIPPED_TAG, testResult.getStackTrace());
+                break;
+            case IGNORED:
+                serializer.startTag(ns, SKIPPED_TAG);
+                serializer.endTag(ns, SKIPPED_TAG);
+                break;
+            case PASSED:
+            case INCOMPLETE:
+                break;
+        }
+
+        serializer.endTag(ns, TESTCASE);
+    }
+
+    private void printFailedTest(KXmlSerializer serializer, String tag, String stack)
+            throws IOException {
+        serializer.startTag(ns, tag);
+        // TODO: get message of stack trace ?
+        // String msg = testResult.getStackTrace();
+        // if (msg != null && msg.length() > 0) {
+        //     serializer.attribute(ns, ATTR_MESSAGE, msg);
+        // }
+        // TODO: get class name of stackTrace exception
+        // serializer.attribute(ns, ATTR_TYPE, testId.getClassName());
+        serializer.text(sanitize(stack));
+        serializer.endTag(ns, tag);
+    }
+
+    /** Returns the text in a format that is safe for use in an XML document. */
+    private String sanitize(String text) {
+        return text.replace("\0", "<\\0>");
+    }
+}
diff --git a/device_build_interfaces/com/android/ddmlib/utils/ArrayHelper.java b/device_build_interfaces/com/android/ddmlib/utils/ArrayHelper.java
new file mode 100644
index 000000000..ce308ce4c
--- /dev/null
+++ b/device_build_interfaces/com/android/ddmlib/utils/ArrayHelper.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ddmlib.utils;
+
+/**
+ * Utility class providing array to int/long conversion for data received from devices through adb.
+ */
+public final class ArrayHelper {
+
+    /**
+     * Swaps an unsigned value around, and puts the result in an array that can be sent to a device.
+     *
+     * @param value The value to swap.
+     * @param dest the destination array
+     * @param offset the offset in the array where to put the swapped value. Array length must be at
+     *     least offset + 4
+     */
+    public static void swap32bitsToArray(int value, byte[] dest, int offset) {
+        dest[offset] = (byte) (value & 0x000000FF);
+        dest[offset + 1] = (byte) ((value & 0x0000FF00) >> 8);
+        dest[offset + 2] = (byte) ((value & 0x00FF0000) >> 16);
+        dest[offset + 3] = (byte) ((value & 0xFF000000) >> 24);
+    }
+
+    /**
+     * Reads a signed 32 bit integer from an array coming from a device.
+     *
+     * @param value the array containing the int
+     * @param offset the offset in the array at which the int starts
+     * @return the integer read from the array
+     */
+    public static int swap32bitFromArray(byte[] value, int offset) {
+        int v = 0;
+        v |= ((int) value[offset]) & 0x000000FF;
+        v |= (((int) value[offset + 1]) & 0x000000FF) << 8;
+        v |= (((int) value[offset + 2]) & 0x000000FF) << 16;
+        v |= (((int) value[offset + 3]) & 0x000000FF) << 24;
+
+        return v;
+    }
+
+    /**
+     * Reads an unsigned 16 bit integer from an array coming from a device, and returns it as an
+     * 'int'
+     *
+     * @param value the array containing the 16 bit int (2 byte).
+     * @param offset the offset in the array at which the int starts Array length must be at least
+     *     offset + 2
+     * @return the integer read from the array.
+     */
+    public static int swapU16bitFromArray(byte[] value, int offset) {
+        int v = 0;
+        v |= ((int) value[offset]) & 0x000000FF;
+        v |= (((int) value[offset + 1]) & 0x000000FF) << 8;
+
+        return v;
+    }
+
+    /**
+     * Reads a signed 64 bit integer from an array coming from a device.
+     *
+     * @param value the array containing the int
+     * @param offset the offset in the array at which the int starts Array length must be at least
+     *     offset + 8
+     * @return the integer read from the array
+     */
+    public static long swap64bitFromArray(byte[] value, int offset) {
+        long v = 0;
+        v |= ((long) value[offset]) & 0x00000000000000FFL;
+        v |= (((long) value[offset + 1]) & 0x00000000000000FFL) << 8;
+        v |= (((long) value[offset + 2]) & 0x00000000000000FFL) << 16;
+        v |= (((long) value[offset + 3]) & 0x00000000000000FFL) << 24;
+        v |= (((long) value[offset + 4]) & 0x00000000000000FFL) << 32;
+        v |= (((long) value[offset + 5]) & 0x00000000000000FFL) << 40;
+        v |= (((long) value[offset + 6]) & 0x00000000000000FFL) << 48;
+        v |= (((long) value[offset + 7]) & 0x00000000000000FFL) << 56;
+
+        return v;
+    }
+}
diff --git a/device_build_interfaces/com/android/ddmlib/utils/FilePermissionUtil.java b/device_build_interfaces/com/android/ddmlib/utils/FilePermissionUtil.java
new file mode 100644
index 000000000..0948fe1e8
--- /dev/null
+++ b/device_build_interfaces/com/android/ddmlib/utils/FilePermissionUtil.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.ddmlib.utils;
+
+import com.android.annotations.NonNull;
+import com.android.tradefed.log.LogUtil.CLog;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.attribute.PosixFilePermission;
+import java.nio.file.attribute.PosixFilePermissions;
+import java.util.HashSet;
+import java.util.Set;
+
+/** Utility class providing file permission handling. */
+public class FilePermissionUtil {
+
+    /** Helper to get bits value given the permission (rwx) values. */
+    private static int numericalPermission(@NonNull PosixFilePermission p) {
+        switch (p) {
+            case OWNER_READ:
+                return 0400;
+            case OWNER_WRITE:
+                return 0200;
+            case OWNER_EXECUTE:
+                return 0100;
+            case GROUP_READ:
+                return 040;
+            case GROUP_WRITE:
+                return 020;
+            case GROUP_EXECUTE:
+                return 010;
+            case OTHERS_READ:
+                return 04;
+            case OTHERS_WRITE:
+                return 02;
+            case OTHERS_EXECUTE:
+                return 01;
+            default:
+                return 00;
+        }
+    }
+
+    /**
+     * Returns a file's POSIX file permissions.
+     *
+     * @param file path of the file which permissions should be used.
+     * @return permission returns the standard numerical representation of permissions. Returns 0644
+     *     if permissions cannot be determined.
+     */
+    public static int getFilePosixPermission(@NonNull File file) {
+        Set<PosixFilePermission> perms = new HashSet<>();
+        try {
+            perms = Files.getPosixFilePermissions(file.toPath());
+        } catch (IOException e) {
+            CLog.e("Error when reading file permission: " + e.getMessage());
+            // fallback to a default permission.
+            return 0644;
+        } catch (UnsupportedOperationException e) {
+            // Windows special handling, we still try to figure out the permissions.
+            if (file.canRead()) {
+                perms.add(PosixFilePermission.OWNER_READ);
+            }
+            if (file.canWrite()) {
+                perms.add(PosixFilePermission.OWNER_WRITE);
+            }
+            if (file.canExecute()) {
+                perms.add(PosixFilePermission.OWNER_EXECUTE);
+            }
+            // In case we fail to read on Windows we fall back to 0644 again.
+            if (perms.isEmpty()) {
+                return 0644;
+            }
+        }
+        CLog.d(
+                String.format(
+                        "Reading file permission of %s as: %s",
+                        file.getAbsoluteFile(), PosixFilePermissions.toString(perms)));
+        int result = 0;
+        for (PosixFilePermission p : perms) {
+            result += numericalPermission(p);
+        }
+        return result;
+    }
+}
diff --git a/device_build_interfaces/com/android/incfs/install/IBlockFilter.java b/device_build_interfaces/com/android/incfs/install/IBlockFilter.java
new file mode 100644
index 000000000..175a3cf00
--- /dev/null
+++ b/device_build_interfaces/com/android/incfs/install/IBlockFilter.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.incfs.install;
+
+import com.android.annotations.NonNull;
+
+/** Controls whether a block of data that must be delivered to the device should be served. */
+public interface IBlockFilter {
+
+    /**
+     * Callback invoked by the associated {@link IncrementalInstallSession} to determine whether a
+     * block of data requested by the device should be served to the device.
+     *
+     * @return true if the block of data should be served; otherwise, false.
+     */
+    boolean shouldServeBlock(@NonNull PendingBlock block);
+}
diff --git a/device_build_interfaces/com/android/incfs/install/IBlockTransformer.java b/device_build_interfaces/com/android/incfs/install/IBlockTransformer.java
new file mode 100644
index 000000000..587f7a1a7
--- /dev/null
+++ b/device_build_interfaces/com/android/incfs/install/IBlockTransformer.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.incfs.install;
+
+import com.android.annotations.NonNull;
+
+import java.io.IOException;
+
+/** Optional transformation of the data block before sending. */
+public interface IBlockTransformer {
+
+    /**
+     * Callback invoked by the associated {@link IncrementalInstallSession} to transform the block.
+     */
+    @NonNull
+    PendingBlock transform(@NonNull PendingBlock block) throws IOException;
+}
diff --git a/device_build_interfaces/com/android/incfs/install/IDeviceConnection.java b/device_build_interfaces/com/android/incfs/install/IDeviceConnection.java
new file mode 100644
index 000000000..7e35ec7b6
--- /dev/null
+++ b/device_build_interfaces/com/android/incfs/install/IDeviceConnection.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.incfs.install;
+
+import com.android.annotations.NonNull;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+/** Represents a connection to a device that can be read from and written to. */
+public interface IDeviceConnection extends AutoCloseable {
+    interface Factory {
+        /**
+         * Connects to the Android {@code service} on device with the specified parameters, and
+         * returns a connection to the service.
+         */
+        IDeviceConnection connectToService(@NonNull String service, @NonNull String[] parameters)
+                throws IOException;
+    }
+
+    /**
+     * Reads a sequence of bytes from this connection into the given buffer.
+     *
+     * <p>An attempt is made to read up to r bytes to the device, where r is the number of bytes
+     * remaining in the buffer, that is, dst.remaining(), at the moment this method is invoked.
+     *
+     * @param buffer where to store data read from the socket
+     * @param timeOutMs timeout in milliseconds (for the full operation to complete)
+     * @return The number of bytes read, possibly zero, or -1 if the command has ended.
+     * @see {@link java.nio.channels.Selector#select(long timeoutMs)}
+     * @see {@link java.nio.channels.SocketChannel#read(ByteBuffer buffer)}
+     */
+    int read(@NonNull ByteBuffer buffer, long timeOutMs) throws IOException;
+
+    /**
+     * Writes a sequence of bytes to the device from the given buffer.
+     *
+     * <p>An attempt is made to write up to r bytes to the device, where r is the number of bytes
+     * remaining in the buffer, that is, src.remaining(), at the moment this method is invoked. It's
+     *
+     * @param buffer data to be sent
+     * @param timeOutMs timeout in milliseconds (for the full operation to complete)
+     * @return The number of bytes written, possibly zero, or -1 if the command has ended.
+     * @see {@link java.nio.channels.Selector#select(long timeoutMs)}
+     * @see {@link java.nio.channels.SocketChannel#write(ByteBuffer buffer)}
+     */
+    int write(@NonNull ByteBuffer buffer, long timeOutMs) throws IOException;
+}
diff --git a/device_build_interfaces/com/android/incfs/install/ILogger.java b/device_build_interfaces/com/android/incfs/install/ILogger.java
new file mode 100644
index 000000000..42de1e7e6
--- /dev/null
+++ b/device_build_interfaces/com/android/incfs/install/ILogger.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.incfs.install;
+
+import com.android.annotations.NonNull;
+import com.android.annotations.Nullable;
+
+/**
+ * Interface used to display warnings/errors. Pulled into IncFS package to break the dependency from
+ * the rest of ddmlib.
+ *
+ * @see com.android.utils.ILogger
+ */
+public interface ILogger {
+    void error(@Nullable Throwable t, @Nullable String msgFormat, Object... args);
+
+    void warning(@NonNull String msgFormat, Object... args);
+
+    void info(@NonNull String msgFormat, Object... args);
+
+    void verbose(@NonNull String msgFormat, Object... args);
+}
diff --git a/device_build_interfaces/com/android/incfs/install/IncrementalInstallSession.java b/device_build_interfaces/com/android/incfs/install/IncrementalInstallSession.java
new file mode 100644
index 000000000..0cce91cc9
--- /dev/null
+++ b/device_build_interfaces/com/android/incfs/install/IncrementalInstallSession.java
@@ -0,0 +1,322 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.incfs.install;
+
+import com.android.annotations.NonNull;
+import com.android.annotations.Nullable;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Locale;
+import java.util.concurrent.Executor;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Used to create a n incremental package installation session in which the blocks of the installed
+ * APKs are streamed to the device when they need to be read.
+ *
+ * <p>
+ *
+ * <p>Incremental installation uses the Incremental Filesystem (IncFs) to allow installation to
+ * complete before the entire APK has been streamed to the device. This class can be used to start
+ * an incremental installation, control which blocks of the APK are allowed to be streamed to the
+ * device, and wait until APK installation has completed and/or until all blocks have been streamed
+ * to the device.
+ *
+ * <p>
+ *
+ * <p>The connection to the device stays opened until the session is closed, the install fails, the
+ * device connection times-out, or an exception occurs while processing block requests from the
+ * device.
+ *
+ * <p>
+ *
+ * <p>An example use of this class is:
+ *
+ * <pre>{@code try (IncrementalInstallSession session = new IncrementalInstallSession.Builder()
+ *               .addApk(mTestApk0, mTestSignature0)
+ *               .build()) {
+ *         // Start the session on a separate thread.
+ *         session.start(Executors.newCachedThreadPool(), mockDevice.getFactory());
+ *
+ *         // Wait a maximum of 45 seconds for the install to finish.
+ *         session.waitForInstallCompleted(45, TimeUnit.SECONDS);
+ * }</pre>
+ */
+public class IncrementalInstallSession implements AutoCloseable {
+    public static class Builder {
+        private final List<Path> mApks = new ArrayList<>();
+        private final List<Path> mSignatures = new ArrayList<>();
+        private final List<String> mArgs = new ArrayList<>();
+        private IBlockFilter mFilter = (PendingBlock) -> true;
+        private IBlockTransformer mTransformer = (PendingBlock block) -> block;
+        private ILogger mLogger = new NullLogger();
+        private long mResponseTimeoutNs = 0L;
+        private boolean mReinstall;
+
+        public Builder() {}
+
+        /**
+         * Adds an APK to set of APKs to be installed. The app must be signed with APK Signature
+         * Scheme v4.
+         *
+         * @param apk the apk to install
+         * @param signature the v4 signature of the apk
+         */
+        public Builder addApk(@NonNull Path apk, @NonNull Path signature) {
+            mApks.add(apk);
+            mSignatures.add(signature);
+            return this;
+        }
+
+        /**
+         * Adds extra arguments to pass to the installation. See 'adb shell pm install --help' for
+         * available options.
+         *
+         * @param extraArgs the extra arguments to pass to the installation
+         */
+        public Builder addExtraArgs(@NonNull String... extraArgs) {
+            mArgs.addAll(Arrays.asList(extraArgs));
+            return this;
+        }
+
+        /**
+         * Sets whether re-install of an app should be performed.
+         *
+         * @param reinstall whether re-install of an app should be performed
+         */
+        public Builder setAllowReinstall(boolean reinstall) {
+            mReinstall = reinstall;
+            return this;
+        }
+
+        /**
+         * Sets the callback used to determine whether a block of data that must be delivered to the
+         * device should be sent to the device.
+         *
+         * @param filter the callback
+         */
+        public Builder setBlockFilter(@NonNull IBlockFilter filter) {
+            mFilter = filter;
+            return this;
+        }
+
+        /**
+         * Sets the callback used to transform the block of data before sending.
+         *
+         * @param transformer the callback
+         */
+        public Builder setBlockTransformer(@NonNull IBlockTransformer transformer) {
+            mTransformer = transformer;
+            return this;
+        }
+
+        /**
+         * Sets the logger interface used to log errors, warnings, and information regarding the
+         * incremental install session.
+         *
+         * @param logger the callback
+         */
+        public Builder setLogger(@NonNull ILogger logger) {
+            mLogger = logger;
+            return this;
+        }
+
+        /**
+         * Sets the maximum amount of time during which no response from the device is allowed when
+         * invoking {@link #waitForInstallCompleted(long, TimeUnit)} and {@link
+         * #waitForServingCompleted(long, TimeUnit)}.
+         *
+         * @param timeout the maximum amount of time during which no response from the device is
+         *     allowed. A value of 0 allows the specified methods to wait indefinitely for the next
+         *     response from the device
+         * @param maxTimeUnits units for non-zero {@code timeout}
+         */
+        public Builder setResponseTimeout(long timeout, @NonNull TimeUnit maxTimeUnits) {
+            mResponseTimeoutNs = maxTimeUnits.toNanos(timeout);
+            return this;
+        }
+
+        /**
+         * Builds and starts the streaming install session.
+         *
+         * @throws IOException if the apk or signature file are not able to be read or are invalid.
+         */
+        public IncrementalInstallSession build() throws IOException {
+            final ArrayList<String> commandBuilder = new ArrayList<>();
+            commandBuilder.add("install-incremental");
+            if (mReinstall) {
+                commandBuilder.add("-r");
+            }
+            commandBuilder.addAll(mArgs);
+
+            final ArrayList<StreamingApk> apkArguments = new ArrayList<>();
+            for (int i = 0; i < mApks.size(); i++) {
+                final Path apk = mApks.get(i);
+                final Path signature = mSignatures.get(i);
+
+                // Argument format [remoteApkName]:[apkSize]:[apkId]:[signatureBase64]:[mode]
+                // remoteApkName   - name that will represent the apk while its being installed
+                // apkSize         - the number of bytes in the apk file
+                // apkId           - unique identifier for the apk during the install (index of the
+                //                   apk in the mApkArguments)
+                // signatureBase64 - bas64 representation of the signing info
+                // mode            - Block streaming mode (1 for tree and data streaming).
+                final StreamingApk apkArgument =
+                        StreamingApk.generate(apk, signature, mFilter, mLogger);
+                apkArguments.add(apkArgument);
+                commandBuilder.add(
+                        String.format(
+                                Locale.US,
+                                "arg%1$d.apk:%2$d:%1$d:%3$s:1",
+                                i,
+                                Files.size(apk),
+                                apkArgument.getSignatureBase64()));
+            }
+
+            return new IncrementalInstallSession(
+                    commandBuilder.toArray(new String[0]),
+                    apkArguments,
+                    mResponseTimeoutNs,
+                    mTransformer,
+                    mLogger);
+        }
+    }
+
+    @NonNull private final String[] mCommandArgs;
+    @NonNull private final ArrayList<StreamingApk> mApks;
+    private final long mResponseTimeoutNs;
+
+    @NonNull private final IBlockTransformer mTransformer;
+    @NonNull private final ILogger mLogger;
+
+    private IncrementalInstallSessionImpl mImpl;
+
+    private IncrementalInstallSession(
+            @NonNull String[] commandArgs,
+            @NonNull ArrayList<StreamingApk> apks,
+            long responseTimeoutNs,
+            @NonNull IBlockTransformer transformer,
+            @NonNull ILogger logger) {
+        mCommandArgs = commandArgs;
+        mApks = apks;
+        mResponseTimeoutNs = responseTimeoutNs;
+        mTransformer = transformer;
+        mLogger = logger;
+    }
+
+    /**
+     * Starts the streaming install session.
+     *
+     * @param executor the executor on which to start handling block requests from the device
+     * @param conFactory the device connection factory
+     * @throws IOException if an error occurs while communicating with the device
+     */
+    public synchronized IncrementalInstallSession start(
+            @NonNull Executor executor, @NonNull IDeviceConnection.Factory conFactory)
+            throws IOException {
+        if (mImpl != null) {
+            throw new IllegalStateException("Session cannot be started multiple time.");
+        }
+
+        final IDeviceConnection con = conFactory.connectToService("package", mCommandArgs);
+        mImpl =
+                new IncrementalInstallSessionImpl(
+                        con, mApks, mResponseTimeoutNs, mTransformer, mLogger);
+        mImpl.execute(executor);
+        return this;
+    }
+
+    /**
+     * Blocks the current thread until all APKs have been successfully installed. Data serving may
+     * finish before or after the install succeeds.
+     *
+     * @param timeout the maximum amount of time to wait for the installs to finish. A value of 0
+     *     will cause this method to wait indefinitely.
+     * @param units units for non-zero {@code timeout}
+     * @throws IOException if wait times out, an APK fails to be installed, or an exception occurs
+     *     while handling block requests.
+     */
+    public void waitForInstallCompleted(long timeout, @NonNull TimeUnit units)
+            throws IOException, InterruptedException {
+        mImpl.waitForInstallCompleted(timeout, units);
+    }
+
+    /**
+     * Blocks the current thread until all APK data has been streamed to the device. Installation
+     * may finishes before or after serving is completed.
+     *
+     * @param timeout the maximum amount of time to wait for serving to finish. A value of 0 will
+     *     cause this method to wait indefinitely.
+     * @param units units for non-zero {@code timeout}
+     * @throws IOException if wait times out, an APK fails to be streamed, or an exception occurs
+     *     while handling block requests.
+     */
+    public void waitForServingCompleted(long timeout, @NonNull TimeUnit units)
+            throws IOException, InterruptedException {
+        mImpl.waitForServingCompleted(timeout, units);
+    }
+
+    /**
+     * Blocks the current thread until either APK data has been streamed to the device or the
+     * installation is finished.
+     *
+     * @param timeout the maximum amount of time to wait. A value of 0 will cause this method to
+     *     wait indefinitely.
+     * @param units units for non-zero {@code timeout}
+     * @throws IOException if wait times out, an APK fails to be installed, or an exception occurs
+     *     while handling block requests.
+     */
+    public void waitForAnyCompletion(long timeout, @NonNull TimeUnit units)
+            throws IOException, InterruptedException {
+        mImpl.waitForAnyCompletion(timeout, units);
+    }
+
+    /** Cancels communication with the device. */
+    @Override
+    public void close() {
+        try (IncrementalInstallSessionImpl impl = mImpl) {}
+    }
+
+    // Default implementation of a logger.
+    private static class NullLogger implements ILogger {
+
+        @Override
+        public void error(@Nullable Throwable t, @Nullable String msgFormat, Object... args) {
+            // ignored
+        }
+
+        @Override
+        public void warning(@NonNull String msgFormat, Object... args) {
+            // ignored
+        }
+
+        @Override
+        public void info(@NonNull String msgFormat, Object... args) {
+            // ignored
+        }
+
+        @Override
+        public void verbose(@NonNull String msgFormat, Object... args) {
+            // ignored
+        }
+    }
+}
diff --git a/device_build_interfaces/com/android/incfs/install/IncrementalInstallSessionImpl.java b/device_build_interfaces/com/android/incfs/install/IncrementalInstallSessionImpl.java
new file mode 100644
index 000000000..15dcec988
--- /dev/null
+++ b/device_build_interfaces/com/android/incfs/install/IncrementalInstallSessionImpl.java
@@ -0,0 +1,473 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.incfs.install;
+
+import com.android.annotations.NonNull;
+import com.android.annotations.Nullable;
+
+import com.google.common.base.Charsets;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.Executor;
+import java.util.concurrent.TimeUnit;
+
+class IncrementalInstallSessionImpl implements AutoCloseable {
+    private static final int FULL_REQUEST_SIZE = 12;
+    private static final int REQUEST_SIZE = 8;
+    private static final byte RESPONSE_CHUNK_HEADER_SIZE = 4;
+    private static final int RESPONSE_HEADER_SIZE = 10;
+    private static final int DONT_WAIT_TIME_MS = 0;
+    private static final int WAIT_TIME_MS = 10;
+
+    @NonNull private final IDeviceConnection mConnection;
+    @NonNull private final IBlockTransformer mTransformer;
+    @NonNull private final ILogger mLogger;
+    @NonNull private final List<StreamingApk> mApks;
+    private final long mResponseTimeoutNs;
+
+    // The exception that occurred on the thread responsible for communicating with the device.
+    @Nullable private volatile Exception mPendingException;
+
+    // Whether or not the install completed successfully. Package installation can succeed before or
+    // after all pages of the APKs being installed have been streamed to the device (before
+    // streaming has completed).
+    private volatile boolean mInstallSucceeded;
+
+    // Whether or not every block of the APKs being installed have been streamed to the device.
+    private volatile boolean mStreamingCompleted;
+
+    // Whether or not the session has been closed using close().
+    private volatile boolean mClosed;
+
+    IncrementalInstallSessionImpl(
+            @NonNull IDeviceConnection device,
+            @NonNull List<StreamingApk> apks,
+            long responseTimeout,
+            @NonNull IBlockTransformer transformer,
+            @NonNull ILogger logger) {
+        mConnection = device;
+        mApks = apks;
+        mResponseTimeoutNs = responseTimeout;
+        mTransformer = transformer;
+        mLogger = logger;
+    }
+
+    void waitForInstallCompleted(long timeout, TimeUnit timeOutUnits)
+            throws IOException, InterruptedException {
+        waitForCondition(
+                timeOutUnits.toNanos(timeout),
+                WAIT_TIME_MS,
+                () -> {
+                    if (mPendingException != null) {
+                        throw new RuntimeException(mPendingException);
+                    }
+                    return mInstallSucceeded || mClosed
+                            ? ConditionResult.FULFILLED
+                            : ConditionResult.UNFULFILLED;
+                });
+    }
+
+    void waitForServingCompleted(long timeout, TimeUnit timeOutUnits)
+            throws IOException, InterruptedException {
+        waitForCondition(
+                timeOutUnits.toNanos(timeout),
+                WAIT_TIME_MS,
+                () -> {
+                    if (mPendingException != null) {
+                        throw new RuntimeException(mPendingException);
+                    }
+                    return mStreamingCompleted || mClosed
+                            ? ConditionResult.FULFILLED
+                            : ConditionResult.UNFULFILLED;
+                });
+    }
+
+    void waitForAnyCompletion(long timeout, TimeUnit timeOutUnits)
+            throws IOException, InterruptedException {
+        waitForCondition(
+                timeOutUnits.toNanos(timeout),
+                WAIT_TIME_MS,
+                () -> {
+                    if (mPendingException != null) {
+                        throw new RuntimeException(mPendingException);
+                    }
+                    return mInstallSucceeded || mStreamingCompleted || mClosed
+                            ? ConditionResult.FULFILLED
+                            : ConditionResult.UNFULFILLED;
+                });
+    }
+
+    private interface IOSupplier<T> {
+        T get() throws IOException, InterruptedException;
+    }
+
+    private enum ConditionResult {
+        FULFILLED,
+        UNFULFILLED,
+        RESET_TIMEOUT,
+    }
+
+    private void waitForCondition(
+            long timeoutNs, long waitMs, IOSupplier<ConditionResult> condition)
+            throws IOException, InterruptedException {
+        long startNs = System.nanoTime();
+        while (timeoutNs == 0 || startNs + timeoutNs >= System.nanoTime()) {
+            final ConditionResult result = condition.get();
+            if (result == ConditionResult.FULFILLED) {
+                return;
+            }
+            if (waitMs > DONT_WAIT_TIME_MS) {
+                Thread.sleep(waitMs);
+            }
+            if (result == ConditionResult.RESET_TIMEOUT) {
+                startNs = System.nanoTime();
+            }
+        }
+        throw new IOException("timeout while waiting for condition");
+    }
+
+    /** Cancels communication with the device. */
+    @Override
+    public void close() {
+        if (mClosed) {
+            return;
+        }
+        if (!mStreamingCompleted) {
+            try {
+                writeToDevice(buildCloseResponseChunk());
+            } catch (Exception ignore) {
+            }
+        }
+        try {
+            mConnection.close();
+        } catch (Exception ignore) {
+        }
+        mApks.forEach(StreamingApk::close);
+        mClosed = true;
+    }
+
+    void execute(@NonNull Executor executor) {
+        executor.execute(
+                () -> {
+                    try {
+                        // Send 'OKAY' to the `install-incremental` command to start receiving block
+                        // requests.
+                        writeToDevice(ByteBuffer.wrap("OKAY".getBytes(Charsets.UTF_8)));
+                        processDeviceData();
+                    } catch (Exception e) {
+                        mPendingException = e;
+                    }
+                });
+    }
+
+    /**
+     * Continuously reads from the device and responds to block read requests until all blocks have
+     * been served and install succeeds, until installation fails, or until a request is not issued
+     * for {@link #mResponseTimeoutNs} nanoseconds.
+     *
+     * <p>See {@link MagicMatcher} for the list of magics that proceed read requests, and
+     * installation status messages.
+     *
+     * <p>Installation can succeed before or after all of the pages have been streamed to the
+     * device. Similarly, installation can fail before or after all the pages have been streamed to
+     * the device. This method only terminates successfully if all of the blocks have been streamed
+     * to the device and installation has completed successfully, or if {@link #close()} has been
+     * called.
+     *
+     * @throws IOException when installation failure message has been received or an error occurs
+     *     while communicating with the device
+     */
+    private void processDeviceData() throws IOException, InterruptedException {
+        final ByteBuffer buffer = ByteBuffer.allocate(16384);
+        // Switch buffer to read mode - this is what underlying code expects the buffer to be in
+        // between operations.
+        buffer.flip();
+
+        final MagicMatcher magicMatcher = new MagicMatcher();
+        final StringBuilder errorBuilder = new StringBuilder();
+
+        // Wait for installation to succeed and streaming to be complete.
+        waitForCondition(
+                mResponseTimeoutNs,
+                DONT_WAIT_TIME_MS,
+                () -> {
+                    if (mClosed) {
+                        return ConditionResult.FULFILLED;
+                    }
+
+                    // Read only when there is not enough data for better performance.
+                    if (buffer.remaining() < FULL_REQUEST_SIZE) {
+                        // This allows the connection to write to the buffer and then flips it back
+                        // to the read mode.
+                        buffer.compact();
+                        final int count = mConnection.read(buffer, WAIT_TIME_MS);
+                        buffer.flip();
+                        if (count < 0) {
+                            throw new EOFException("EOF");
+                        }
+                    }
+
+                    // Find the next incremental request, install success message, install failure
+                    // message magic to know how to interpret the data following the magic.
+                    final MagicMatcher.MagicType magic = magicMatcher.findMagic(buffer);
+                    if (magic == null) {
+                        return ConditionResult.UNFULFILLED;
+                    }
+
+                    switch (magic) {
+                        case INCREMENTAL:
+                            {
+                                // Wait until a full request has been received from the device.
+                                if (buffer.remaining() >= REQUEST_SIZE) {
+                                    if (processReadData(nextRequest(buffer))) {
+                                        mStreamingCompleted = true;
+                                    }
+                                    // The request has been processed, so move to the next magic.
+                                    magicMatcher.advance();
+                                }
+                                break;
+                            }
+                        case INSTALLATION_FAILURE:
+                            {
+                                // Build the failure message. The contents of the failure message
+                                // start with '[' (parsed in the failure magic) and end with ']'.
+                                while (buffer.hasRemaining()) {
+                                    final byte c = buffer.get();
+                                    if (c == ']') {
+                                        throw new IOException(
+                                                "Installation failure: " + errorBuilder.toString());
+                                    }
+                                    errorBuilder.append((char) c);
+                                }
+                                break;
+                            }
+                        case INSTALLATION_SUCCESS:
+                            {
+                                mInstallSucceeded = true;
+                                // The success message has been processed, so move to the next
+                                // magic.
+                                magicMatcher.advance();
+                                break;
+                            }
+                    }
+                    return (mStreamingCompleted && mInstallSucceeded)
+                            ? ConditionResult.FULFILLED
+                            : ConditionResult.RESET_TIMEOUT;
+                });
+    }
+
+    /**
+     * Returns the next {@link ReadRequest} encoded in the buffer if one exists.
+     *
+     * <p>A block read request has the format: [(int16) requestType][(int16) apkId][(int32)
+     * blockIndex] requestType - the type of read request to perform apkId - the index of the APK in
+     * the install-incremental arguments that the device is requesting to read (only useful when
+     * type is {@link ReadRequest.RequestType#BLOCK_MISSING} or {@link
+     * ReadRequest.RequestType#PREFETCH}). blockIndex - the index of the block of data being
+     * requested (only useful when type is {@link ReadRequest.RequestType#BLOCK_MISSING} or {@link
+     * ReadRequest.RequestType#PREFETCH}).
+     */
+    private static ReadRequest nextRequest(ByteBuffer data) {
+        final short typeData = data.getShort();
+        final ReadRequest.RequestType type;
+        switch (typeData) {
+            case 0:
+                type = ReadRequest.RequestType.SERVING_COMPLETE;
+                break;
+            case 1:
+                type = ReadRequest.RequestType.BLOCK_MISSING;
+                break;
+            case 2:
+                type = ReadRequest.RequestType.PREFETCH;
+                break;
+            case 3:
+                type = ReadRequest.RequestType.DESTROY;
+                break;
+            default:
+                throw new IllegalStateException("Unknown request type " + typeData);
+        }
+        return new ReadRequest(type, data.getShort(), data.getInt());
+    }
+
+    private boolean processReadData(ReadRequest request) throws IOException, InterruptedException {
+        mLogger.verbose("Received %s", request.toString());
+        switch (request.requestType) {
+            case SERVING_COMPLETE:
+                return true;
+            case BLOCK_MISSING:
+            case PREFETCH:
+                final StreamingApk apk = mApks.get(request.apkId);
+                final List<PendingBlock> responses = apk.getBlockResponse(request.blockIndex);
+                writeToDevice(buildResponseChunk(request.apkId, responses));
+                break;
+            case DESTROY:
+                throw new IOException("Destroy request received");
+        }
+        return false;
+    }
+
+    /**
+     * Builds the response to the device indicating the session is terminating incremental
+     * streaming.
+     */
+    private static ByteBuffer buildCloseResponseChunk() {
+        final ByteBuffer buffer =
+                ByteBuffer.allocate(RESPONSE_CHUNK_HEADER_SIZE + RESPONSE_HEADER_SIZE);
+        buffer.putInt(RESPONSE_HEADER_SIZE);
+        buffer.putShort((short) -1);
+        buffer.put((byte) 0);
+        buffer.put((byte) 0);
+        buffer.putInt(0);
+        buffer.putShort((short) 0);
+        buffer.flip();
+        return buffer;
+    }
+
+    /**
+     * Builds the response to the device containing the page data of all the provided pending
+     * blocks.
+     */
+    private ByteBuffer buildResponseChunk(short apkId, @NonNull List<PendingBlock> blocks)
+            throws IOException {
+        if (blocks.isEmpty()) {
+            return ByteBuffer.allocate(0);
+        }
+        final byte BLOCK_KIND_DATA = 0;
+        final byte BLOCK_KIND_HASH = 1;
+        final byte COMPRESSION_KIND_NONE = 0;
+        final byte COMPRESSION_KIND_LZ4 = 1;
+        final int maxSize =
+                RESPONSE_CHUNK_HEADER_SIZE
+                        + (StreamingApk.INCFS_BLOCK_SIZE + RESPONSE_HEADER_SIZE) * blocks.size();
+        final ByteBuffer buffer = ByteBuffer.allocate(maxSize);
+        buffer.position(RESPONSE_CHUNK_HEADER_SIZE);
+
+        int totalSize = 0;
+        for (PendingBlock block : blocks) {
+            block = mTransformer.transform(block);
+            buffer.putShort(apkId);
+            buffer.put(
+                    block.getType() == PendingBlock.Type.APK_DATA
+                            ? BLOCK_KIND_DATA
+                            : BLOCK_KIND_HASH);
+            buffer.put(
+                    block.getCompression() == PendingBlock.Compression.NONE
+                            ? COMPRESSION_KIND_NONE
+                            : COMPRESSION_KIND_LZ4);
+            buffer.putInt(block.getBlockIndex());
+            buffer.putShort(block.getBlockSize());
+            block.readBlockData(buffer);
+            totalSize += RESPONSE_HEADER_SIZE + block.getBlockSize();
+        }
+
+        buffer.putInt(0, totalSize);
+        buffer.flip();
+        return buffer;
+    }
+
+    /**
+     * Write until all {@code data} is written to the device, the timeout expires, or the connection
+     * fails.
+     */
+    private void writeToDevice(final ByteBuffer data) throws IOException, InterruptedException {
+        waitForCondition(
+                mResponseTimeoutNs,
+                DONT_WAIT_TIME_MS,
+                () -> {
+                    if (!data.hasRemaining()) {
+                        return ConditionResult.FULFILLED;
+                    }
+                    if (mConnection.write(data, WAIT_TIME_MS) < 0) {
+                        throw new IOException("channel EOF");
+                    }
+                    return ConditionResult.UNFULFILLED;
+                });
+    }
+
+    private static class MagicMatcher {
+        private enum MagicType {
+            INCREMENTAL,
+            INSTALLATION_FAILURE,
+            INSTALLATION_SUCCESS,
+        }
+
+        private static class Magic {
+            final MagicType type;
+            final byte[] value;
+
+            Magic(MagicType type, byte[] value) {
+                this.type = type;
+                this.value = value;
+            }
+        }
+
+        private static final ArrayList<Magic> MAGICS = new ArrayList<>();
+
+        static {
+            MAGICS.add(new Magic(MagicType.INCREMENTAL, "INCR".getBytes(Charsets.UTF_8)));
+            MAGICS.add(
+                    new Magic(
+                            MagicType.INSTALLATION_FAILURE, "Failure [".getBytes(Charsets.UTF_8)));
+            MAGICS.add(
+                    new Magic(MagicType.INSTALLATION_SUCCESS, "Success".getBytes(Charsets.UTF_8)));
+        }
+
+        private final int[] mPositions = new int[MAGICS.size()];
+        private MagicType mFoundMatch = null;
+
+        /**
+         * Move to the end of the next magic. This method continues matching the magics using the
+         * state of the last invocation of this method. This method continues returning the last
+         * magic found until {@link #advance()} is called.
+         *
+         * @return true if the magic was found; otherwise, false
+         */
+        MagicType findMagic(ByteBuffer buffer) {
+            if (mFoundMatch != null) {
+                return mFoundMatch;
+            }
+            while (buffer.hasRemaining()) {
+                final byte nextByte = buffer.get();
+                for (int i = 0; i < mPositions.length; i++) {
+                    final byte[] magic = MAGICS.get(i).value;
+                    if (nextByte == magic[mPositions[i]]) {
+                        if (++mPositions[i] == magic.length) {
+                            mFoundMatch = MAGICS.get(i).type;
+                            mPositions[i] = 0;
+                            return mFoundMatch;
+                        }
+                    } else if (nextByte == magic[0]) {
+                        mPositions[i] = 1;
+                    } else {
+                        mPositions[i] = 0;
+                    }
+                }
+            }
+            return null;
+        }
+
+        /**
+         * Invoke to allow advance the result of {@link #findMagic(ByteBuffer)} to the next magic.
+         */
+        void advance() {
+            mFoundMatch = null;
+        }
+    }
+}
diff --git a/device_build_interfaces/com/android/incfs/install/PendingBlock.java b/device_build_interfaces/com/android/incfs/install/PendingBlock.java
new file mode 100644
index 000000000..7ae4f833f
--- /dev/null
+++ b/device_build_interfaces/com/android/incfs/install/PendingBlock.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.incfs.install;
+
+import com.android.annotations.NonNull;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.file.Path;
+
+/** A block of data belonging to the APK or signature file that is needed by the device. */
+public class PendingBlock {
+    public enum Type {
+        APK_DATA,
+        SIGNATURE_TREE,
+    }
+
+    public enum Compression {
+        NONE,
+        LZ4,
+    }
+
+    @NonNull private final Path mFilePath;
+    @NonNull private final Type mType;
+    private final int mBlockIndex;
+    private final int mBlockCount;
+
+    @NonNull private final StreamingApk mApk;
+    private final int mBlockOffset;
+    private final short mBlockSize;
+
+    PendingBlock(
+            @NonNull Path filePath,
+            @NonNull Type type,
+            int blockIndex,
+            int blockCount,
+            @NonNull StreamingApk apk,
+            int blockOffset,
+            short blockSize) {
+        this.mFilePath = filePath;
+        this.mType = type;
+        this.mBlockIndex = blockIndex;
+        this.mBlockCount = blockCount;
+        this.mApk = apk;
+        this.mBlockOffset = blockOffset;
+        this.mBlockSize = blockSize;
+    }
+
+    public PendingBlock(@NonNull PendingBlock block) {
+        this.mFilePath = block.mFilePath;
+        this.mType = block.mType;
+        this.mBlockIndex = block.mBlockIndex;
+        this.mBlockCount = block.mBlockCount;
+        this.mApk = block.mApk;
+        this.mBlockOffset = block.mBlockOffset;
+        this.mBlockSize = block.mBlockSize;
+    }
+
+    /** The path to the file in which the block resides. */
+    @NonNull
+    public Path getPath() {
+        return mFilePath;
+    }
+
+    /**
+     * @see PendingBlock.Type
+     */
+    @NonNull
+    public Type getType() {
+        return mType;
+    }
+
+    /**
+     * @see PendingBlock.Compression
+     */
+    @NonNull
+    public Compression getCompression() {
+        return Compression.NONE;
+    }
+
+    /** The index of the data block in the file. */
+    public int getBlockIndex() {
+        return mBlockIndex;
+    }
+
+    /** The number of blocks in the file in which the block resides. */
+    public int getFileBlockCount() {
+        return mBlockCount;
+    }
+
+    /** The size in bytes of the block data. */
+    public short getBlockSize() {
+        return mBlockSize;
+    }
+
+    /** Reads the block data into the buffer at the current position. */
+    public void readBlockData(@NonNull ByteBuffer buffer) throws IOException {
+        mApk.readBlockData(buffer, mType, mBlockOffset, mBlockSize);
+    }
+
+    @Override
+    public String toString() {
+        return "PendingBlock{"
+                + "mFilePath="
+                + mFilePath
+                + ", mType="
+                + mType
+                + ", mBlockIndex="
+                + mBlockIndex
+                + ", mBlockCount="
+                + mBlockCount
+                + ", mBlockOffset="
+                + mBlockOffset
+                + ", mBlockSize="
+                + mBlockSize
+                + '}';
+    }
+}
diff --git a/device_build_interfaces/com/android/incfs/install/ReadRequest.java b/device_build_interfaces/com/android/incfs/install/ReadRequest.java
new file mode 100644
index 000000000..4b2abc7be
--- /dev/null
+++ b/device_build_interfaces/com/android/incfs/install/ReadRequest.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.incfs.install;
+
+import com.android.annotations.NonNull;
+
+/** A request sent from the device for a block of data from an APK being streamed. */
+class ReadRequest {
+    enum RequestType {
+        /** All pages have been successfully received and streaming is complete. */
+        SERVING_COMPLETE,
+        /** The device is requesting a block to be served so it can be read immediately. */
+        BLOCK_MISSING,
+        /**
+         * The device is requesting a block to be served because it predicts the block will be
+         * needed soon.
+         */
+        PREFETCH,
+        /** The device is terminating connection with the host for some unexpected reason. */
+        DESTROY
+    }
+
+    @NonNull final RequestType requestType;
+    final short apkId;
+    final int blockIndex;
+
+    ReadRequest(@NonNull RequestType requestType, short apkId, int blockIndex) {
+        this.requestType = requestType;
+        this.apkId = apkId;
+        this.blockIndex = blockIndex;
+    }
+
+    @Override
+    public String toString() {
+        return "ReadRequest{"
+                + "requestType="
+                + requestType
+                + ", apkId="
+                + apkId
+                + ", blockIndex="
+                + blockIndex
+                + '}';
+    }
+}
diff --git a/device_build_interfaces/com/android/incfs/install/StreamingApk.java b/device_build_interfaces/com/android/incfs/install/StreamingApk.java
new file mode 100644
index 000000000..000974a66
--- /dev/null
+++ b/device_build_interfaces/com/android/incfs/install/StreamingApk.java
@@ -0,0 +1,356 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.incfs.install;
+
+import com.android.annotations.NonNull;
+
+import java.io.BufferedInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.channels.FileChannel;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.Base64;
+import java.util.BitSet;
+import java.util.List;
+import java.util.Optional;
+
+/** Represents an APK being incrementally streamed. */
+class StreamingApk implements AutoCloseable {
+    static final short INCFS_BLOCK_SIZE = 4096;
+    private static final int INCFS_DIGEST_SIZE = 32;
+    private static final int INCFS_MAX_SIGNATURE_SIZE = 8096;
+    private static final int INCFS_HASHES_PER_BLOCK = INCFS_BLOCK_SIZE / INCFS_DIGEST_SIZE;
+
+    @NonNull private final Path mApk;
+    @NonNull private final Path mSignature;
+    @NonNull private final FileChannel mApkChannel;
+    @NonNull private final FileChannel mSignatureChannel;
+    private final long mApkSize;
+    private final long mSignatureSize;
+
+    // The offset of the Merkle tree in the signature file.
+    private final int mTreeOffset;
+
+    // Base64 representation of the signing info.
+    @NonNull private final String mSignatureBase64;
+
+    // Maps block index to whether or not the block has already been sent.
+    private final int mDataBlockCount;
+    private final int mTreeBlockCount;
+    private final BitSet mSentDataBlocks;
+    private final BitSet mSentTreeBlocks;
+
+    @NonNull private final IBlockFilter mBlockFilter;
+    @NonNull private final ILogger mLogger;
+
+    private StreamingApk(
+            @NonNull Path apk,
+            @NonNull Path signature,
+            @NonNull FileChannel apkChannel,
+            @NonNull FileChannel signatureChannel,
+            long apkSize,
+            long sigSize,
+            int treeOffset,
+            @NonNull String signatureBase64,
+            @NonNull IBlockFilter server,
+            @NonNull ILogger logger) {
+        mApk = apk;
+        mSignature = signature;
+        mApkChannel = apkChannel;
+        mSignatureChannel = signatureChannel;
+        mApkSize = apkSize;
+        mSignatureSize = sigSize;
+        mDataBlockCount = numBytesToNumBlocks(apkSize);
+        mTreeBlockCount = verityTreeBlocksForFile(apkSize);
+        mSentDataBlocks = new BitSet(mDataBlockCount);
+        mSentTreeBlocks = new BitSet(mTreeBlockCount);
+        mTreeOffset = treeOffset;
+        mSignatureBase64 = signatureBase64;
+        mBlockFilter = server;
+        mLogger = logger;
+    }
+
+    static StreamingApk generate(
+            @NonNull Path apk,
+            @NonNull Path sig,
+            @NonNull IBlockFilter server,
+            @NonNull ILogger logger)
+            throws IOException {
+        final String base64Sig;
+        final int treeOffset;
+        try (final BufferedInputStream sigIs = new BufferedInputStream(Files.newInputStream(sig))) {
+            final ByteArrayOutputStream base64SigOS = new ByteArrayOutputStream();
+            final OutputStream sigBOS = Base64.getEncoder().wrap(base64SigOS);
+            final int version = readInt32(sigIs, sigBOS, "Failed to read version from " + sig);
+
+            final int hashingInfoSize =
+                    readBytesWithSize(sigIs, sigBOS, "Failed to read hashing info from " + sig);
+
+            final int signingInfoSize =
+                    readBytesWithSize(sigIs, sigBOS, "Failed to read signing info from " + sig);
+
+            final int signatureSize = 12 + hashingInfoSize + signingInfoSize;
+            if (signatureSize > INCFS_MAX_SIGNATURE_SIZE) {
+                throw new IllegalArgumentException(
+                        "Signature is too long. Max allowed is " + INCFS_MAX_SIGNATURE_SIZE);
+            }
+
+            final int treeSize = readInt32(sigIs, null, "Failed to read tree size from " + sig);
+
+            final int expectedTreeSize = verityTreeSizeForFile(Files.size(apk));
+            if (treeSize != expectedTreeSize) {
+                throw new IllegalArgumentException(
+                        "Verity tree size mismatch in signature file: [was "
+                                + treeSize
+                                + ", expected "
+                                + expectedTreeSize
+                                + "]");
+            }
+
+            treeOffset = 4 + signatureSize;
+            base64Sig = new String(base64SigOS.toByteArray());
+        }
+
+        FileChannel apkChannel = null;
+        FileChannel signatureChannel = null;
+        final long apkSize;
+        final long sigSize;
+        try {
+            apkChannel = FileChannel.open(apk);
+            signatureChannel = FileChannel.open(sig);
+            apkSize = apkChannel.size();
+            sigSize = signatureChannel.size();
+        } catch (IOException e) {
+            if (apkChannel != null) {
+                apkChannel.close();
+            }
+            if (signatureChannel != null) {
+                signatureChannel.close();
+            }
+            throw e;
+        }
+        return new StreamingApk(
+                apk,
+                sig,
+                apkChannel,
+                signatureChannel,
+                apkSize,
+                sigSize,
+                treeOffset,
+                base64Sig,
+                server,
+                logger);
+    }
+
+    String getSignatureBase64() {
+        return mSignatureBase64;
+    }
+
+    /**
+     * Retrieves the list of blocks allowed by the {@link IBlockFilter} to be streamed to the device
+     * in order to read the data block at {@code blockIndex}.
+     */
+    List<PendingBlock> getBlockResponse(int blockIndex) {
+        if (blockIndex < 0 || blockIndex >= mDataBlockCount) {
+            throw new IllegalArgumentException("Requested block index is outside range");
+        }
+
+        List<PendingBlock> responses = getTreeBlocksResponsesForDataBlock(blockIndex);
+        if (!mSentDataBlocks.get(blockIndex)) {
+            getDataPendingBlock(blockIndex).ifPresent(responses::add);
+        }
+        return responses;
+    }
+
+    private List<PendingBlock> getTreeBlocksResponsesForDataBlock(int blockIndex) {
+        final int dataBlockCount = mDataBlockCount;
+        final int totalNodeCount = mTreeBlockCount;
+        final int leafNodesCount =
+                (dataBlockCount + INCFS_HASHES_PER_BLOCK - 1) / INCFS_HASHES_PER_BLOCK;
+        final int leafNodesOffset = totalNodeCount - leafNodesCount;
+
+        // Leaf level, sending only 1 block.
+        final int leafIndex = leafNodesOffset + blockIndex / INCFS_HASHES_PER_BLOCK;
+
+        final ArrayList<PendingBlock> responses = new ArrayList<>();
+        if (!mSentTreeBlocks.get(leafIndex)) {
+            getTreePendingBlock(leafIndex).ifPresent(responses::add);
+        }
+
+        // Non-leaf, sending EVERYTHING. This should be done only once.
+        if (leafNodesOffset != 0) {
+            for (int i = 0; i < leafNodesOffset; ++i) {
+                if (!mSentTreeBlocks.get(i)) {
+                    getTreePendingBlock(i).ifPresent(responses::add);
+                }
+            }
+        }
+        return responses;
+    }
+
+    private Optional<PendingBlock> getTreePendingBlock(int treeBlockIndex) {
+        final int blockOffset = mTreeOffset + treeBlockIndex * INCFS_BLOCK_SIZE;
+        final short blockSize = (short) Math.min(mSignatureSize - blockOffset, INCFS_BLOCK_SIZE);
+        final PendingBlock response =
+                new PendingBlock(
+                        mSignature,
+                        PendingBlock.Type.SIGNATURE_TREE,
+                        treeBlockIndex,
+                        mTreeBlockCount,
+                        this,
+                        blockOffset,
+                        blockSize);
+        if (mBlockFilter.shouldServeBlock(response)) {
+            mLogger.verbose("Sending %s", response);
+            mSentTreeBlocks.set(treeBlockIndex, true);
+            return Optional.of(response);
+        }
+        mLogger.verbose("Denied sending %s", response);
+        return Optional.empty();
+    }
+
+    private Optional<PendingBlock> getDataPendingBlock(int index) {
+        final int blockOffset = index * INCFS_BLOCK_SIZE;
+        final short blockSize = (short) Math.min(mApkSize - blockOffset, INCFS_BLOCK_SIZE);
+        final PendingBlock response =
+                new PendingBlock(
+                        mApk,
+                        PendingBlock.Type.APK_DATA,
+                        index,
+                        mDataBlockCount,
+                        this,
+                        blockOffset,
+                        blockSize);
+        if (mBlockFilter.shouldServeBlock(response)) {
+            mLogger.verbose("Sending %s", response);
+            mSentDataBlocks.set(index, true);
+            return Optional.of(response);
+        }
+        mLogger.verbose("Denied sending %s", response);
+        return Optional.empty();
+    }
+
+    /**
+     * Reads the block data from the data or signature file into the buffer. This method only
+     * updates buffer position, not limit.
+     */
+    void readBlockData(
+            @NonNull ByteBuffer buffer,
+            @NonNull PendingBlock.Type type,
+            int blockOffset,
+            short blockSize)
+            throws IOException {
+        final FileChannel channel =
+                (type == PendingBlock.Type.APK_DATA) ? mApkChannel : mSignatureChannel;
+
+        // Set the limit to only read blockSize number of bytes.
+        final int previousLimit = buffer.limit();
+        buffer.limit(buffer.position() + blockSize);
+        try {
+            if ((short) channel.read(buffer, blockOffset) != blockSize) {
+                throw new IOException(
+                        "Failed to read "
+                                + blockSize
+                                + " bytes from "
+                                + ((type == PendingBlock.Type.APK_DATA) ? mApk : mSignature));
+            }
+        } finally {
+            buffer.limit(previousLimit);
+        }
+    }
+
+    /** Returns the number of blocks for a file of the specified size in bytes. */
+    private static int numBytesToNumBlocks(long fileSize) {
+        return (int) (fileSize / INCFS_BLOCK_SIZE) + ((fileSize % INCFS_BLOCK_SIZE == 0) ? 0 : 1);
+    }
+
+    /**
+     * Returns the expected file size of the signature file for an APK file of the given size.
+     *
+     * @param fileSize the size of the APK in bytes
+     */
+    private static int verityTreeSizeForFile(long fileSize) {
+        return verityTreeBlocksForFile(fileSize) * INCFS_BLOCK_SIZE;
+    }
+
+    /**
+     * Returns the number of blocks of the signature file for an APK file of the given size.
+     *
+     * @param fileSize the size of the APK in bytes
+     */
+    private static int verityTreeBlocksForFile(long fileSize) {
+        if (fileSize == 0) {
+            return 0;
+        }
+
+        final int hashPerBlock = INCFS_BLOCK_SIZE / INCFS_DIGEST_SIZE;
+        int totalTreeBlockCount = 0;
+
+        long hashBlockCount = 1 + (fileSize - 1) / INCFS_BLOCK_SIZE;
+        while (hashBlockCount > 1) {
+            hashBlockCount = (hashBlockCount + hashPerBlock - 1) / hashPerBlock;
+            totalTreeBlockCount += hashBlockCount;
+        }
+
+        return totalTreeBlockCount;
+    }
+
+    private static int readInt32(InputStream is, OutputStream accumulator, String errorMessage)
+            throws IOException {
+        final byte[] data = new byte[4];
+        if (is.read(data) != 4) {
+            throw new IOException(errorMessage);
+        }
+        if (accumulator != null) {
+            accumulator.write(data);
+        }
+        return ByteBuffer.wrap(data).order(ByteOrder.LITTLE_ENDIAN).getInt();
+    }
+
+    private static int readBytesWithSize(
+            InputStream is, OutputStream accumulator, String errorMessage) throws IOException {
+        final int size = readInt32(is, accumulator, errorMessage);
+        int length;
+        int totalRead = 0;
+        byte[] buffer = new byte[4096];
+        while (totalRead < size && (length = is.read(buffer, 0, size - totalRead)) > 0) {
+            accumulator.write(buffer, 0, length);
+            totalRead += length;
+        }
+        if (totalRead != size) {
+            throw new IOException(errorMessage);
+        }
+        return size;
+    }
+
+    @Override
+    public void close() {
+        try {
+            mApkChannel.close();
+        } catch (IOException ignore) {
+        }
+        try {
+            mSignatureChannel.close();
+        } catch (IOException ignore) {
+        }
+    }
+}
diff --git a/device_build_interfaces/com/android/incfs/install/adb/ddmlib/AdbDeviceConnection.java b/device_build_interfaces/com/android/incfs/install/adb/ddmlib/AdbDeviceConnection.java
new file mode 100644
index 000000000..d3b7ade1c
--- /dev/null
+++ b/device_build_interfaces/com/android/incfs/install/adb/ddmlib/AdbDeviceConnection.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.incfs.install.adb.ddmlib;
+
+import com.android.annotations.NonNull;
+import com.android.ddmlib.AdbCommandRejectedException;
+import com.android.ddmlib.IDevice;
+import com.android.ddmlib.TimeoutException;
+import com.android.incfs.install.IDeviceConnection;
+import com.android.incfs.install.IncrementalInstallSession;
+import com.android.tradefed.device.server.AndroidDebugBridge;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.Channel;
+import java.nio.channels.SelectionKey;
+import java.nio.channels.Selector;
+import java.nio.channels.SocketChannel;
+import java.util.concurrent.Executor;
+
+/**
+ * Represents a connection to a device through ADB for use with {@link
+ * IncrementalInstallSession.Builder#execute(Executor, IDeviceConnection.Factory, ILogger)}.
+ */
+public class AdbDeviceConnection implements IDeviceConnection {
+    /**
+     * Creates a factory for creating a connection to the device.
+     *
+     * @param deviceSerialNumber the serial of the device to talk to.
+     */
+    public static Factory getFactory(@NonNull String deviceSerialNumber) throws IOException {
+        final AndroidDebugBridge adb = AndroidDebugBridge.getBridge();
+        if (adb == null) {
+            throw new IOException("Unable to connect to adb");
+        }
+        for (final IDevice device : adb.getDevices()) {
+            if (deviceSerialNumber.equals(device.getSerialNumber())) {
+                return new Factory(device);
+            }
+        }
+        throw new IOException("Failed to find device with serial \"" + deviceSerialNumber + "\"");
+    }
+
+    public static class Factory implements IDeviceConnection.Factory {
+        private final IDevice mDevice;
+
+        private Factory(@NonNull IDevice device) {
+            mDevice = device;
+        }
+
+        @Override
+        public IDeviceConnection connectToService(
+                @NonNull String service, @NonNull String[] parameters) throws IOException {
+            final SocketChannel channel;
+            try {
+                channel = mDevice.rawBinder(service, parameters);
+            } catch (AdbCommandRejectedException | TimeoutException e) {
+                throw new IOException(
+                        String.format(
+                                "Failed invoking binder command \"%s %s\"",
+                                service, String.join(" ", parameters)),
+                        e);
+            }
+            channel.configureBlocking(false);
+            return new AdbDeviceConnection(channel);
+        }
+    }
+
+    @NonNull private final SocketChannel mChannel;
+
+    @NonNull private final Selector mReadSelector;
+    @NonNull private final Selector mWriteSelector;
+
+    private AdbDeviceConnection(@NonNull SocketChannel channel) throws IOException {
+        mChannel = channel;
+        mChannel.configureBlocking(false);
+        mReadSelector = Selector.open();
+        mChannel.register(mReadSelector, SelectionKey.OP_READ);
+        mWriteSelector = Selector.open();
+        mChannel.register(mWriteSelector, SelectionKey.OP_WRITE);
+    }
+
+    @Override
+    public int read(@NonNull ByteBuffer dst, long timeoutMs) throws IOException {
+        mReadSelector.select(timeoutMs);
+        return mChannel.read(dst);
+    }
+
+    @Override
+    public int write(@NonNull ByteBuffer src, long timeoutMs) throws IOException {
+        mWriteSelector.select(timeoutMs);
+        return mChannel.write(src);
+    }
+
+    @Override
+    public void close() throws Exception {
+        try (Channel c = mChannel;
+                Selector r = mReadSelector;
+                Selector w = mWriteSelector) {}
+    }
+}
diff --git a/device_build_interfaces/com/android/incfs/install/adb/ddmlib/DeviceConnection.java b/device_build_interfaces/com/android/incfs/install/adb/ddmlib/DeviceConnection.java
new file mode 100644
index 000000000..6b437b2b7
--- /dev/null
+++ b/device_build_interfaces/com/android/incfs/install/adb/ddmlib/DeviceConnection.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.incfs.install.adb.ddmlib;
+
+import com.android.annotations.NonNull;
+import com.android.ddmlib.AdbCommandRejectedException;
+import com.android.ddmlib.IDevice;
+import com.android.ddmlib.TimeoutException;
+import com.android.incfs.install.IDeviceConnection;
+import com.android.incfs.install.IncrementalInstallSession;
+import com.android.tradefed.device.server.AndroidDebugBridge;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.Channel;
+import java.nio.channels.SelectionKey;
+import java.nio.channels.Selector;
+import java.nio.channels.SocketChannel;
+import java.util.concurrent.Executor;
+
+/**
+ * Represents a connection to a device through ADB for use with {@link
+ * IncrementalInstallSession.Builder#execute(Executor, IDeviceConnection.Factory, ILogger)}.
+ */
+public class DeviceConnection implements IDeviceConnection {
+    /**
+     * Creates a factory for creating a connection to the device.
+     *
+     * @param deviceSerialNumber the serial of the device to talk to.
+     */
+    public static Factory getFactory(@NonNull String deviceSerialNumber) throws IOException {
+        final AndroidDebugBridge adb = AndroidDebugBridge.getBridge();
+        if (adb == null) {
+            throw new IOException("Unable to connect to adb");
+        }
+        for (final IDevice device : adb.getDevices()) {
+            if (deviceSerialNumber.equals(device.getSerialNumber())) {
+                return new Factory(device);
+            }
+        }
+        throw new IOException("Failed to find device with serial \"" + deviceSerialNumber + "\"");
+    }
+
+    public static class Factory implements IDeviceConnection.Factory {
+        private final IDevice mDevice;
+
+        private Factory(@NonNull IDevice device) {
+            mDevice = device;
+        }
+
+        @Override
+        public IDeviceConnection connectToService(
+                @NonNull String service, @NonNull String[] parameters) throws IOException {
+            final SocketChannel channel;
+            try {
+                channel = mDevice.rawBinder(service, parameters);
+            } catch (AdbCommandRejectedException | TimeoutException e) {
+                throw new IOException(
+                        String.format(
+                                "Failed invoking binder command \"%s %s\"",
+                                service, String.join(" ", parameters)),
+                        e);
+            }
+            channel.configureBlocking(false);
+            return new DeviceConnection(channel);
+        }
+    }
+
+    @NonNull private final SocketChannel mChannel;
+
+    @NonNull private final Selector mReadSelector;
+    @NonNull private final Selector mWriteSelector;
+
+    private DeviceConnection(@NonNull SocketChannel channel) throws IOException {
+        mChannel = channel;
+        mChannel.configureBlocking(false);
+        mReadSelector = Selector.open();
+        mChannel.register(mReadSelector, SelectionKey.OP_READ);
+        mWriteSelector = Selector.open();
+        mChannel.register(mWriteSelector, SelectionKey.OP_WRITE);
+    }
+
+    @Override
+    public int read(@NonNull ByteBuffer dst, long timeoutMs) throws IOException {
+        mReadSelector.select(timeoutMs);
+        return mChannel.read(dst);
+    }
+
+    @Override
+    public int write(@NonNull ByteBuffer src, long timeoutMs) throws IOException {
+        mWriteSelector.select(timeoutMs);
+        return mChannel.write(src);
+    }
+
+    @Override
+    public void close() throws Exception {
+        try (Channel c = mChannel;
+                Selector r = mReadSelector;
+                Selector w = mWriteSelector) {}
+    }
+}
diff --git a/device_build_interfaces/com/android/incfs/install/adb/ddmlib/DeviceLogger.java b/device_build_interfaces/com/android/incfs/install/adb/ddmlib/DeviceLogger.java
new file mode 100644
index 000000000..9f34e9587
--- /dev/null
+++ b/device_build_interfaces/com/android/incfs/install/adb/ddmlib/DeviceLogger.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.incfs.install.adb.ddmlib;
+
+import com.android.annotations.NonNull;
+import com.android.annotations.Nullable;
+import com.android.incfs.install.ILogger;
+
+/** Bridge class to use utils.ILogger for Incremental. */
+public class DeviceLogger implements ILogger {
+    private @NonNull ILogger mLogger;
+
+    public DeviceLogger(@NonNull ILogger logger) {
+        mLogger = logger;
+    }
+
+    @Override
+    public void error(@Nullable Throwable t, @Nullable String msgFormat, Object... args) {
+        mLogger.error(t, msgFormat, args);
+    }
+
+    @Override
+    public void warning(@NonNull String msgFormat, Object... args) {
+        mLogger.warning(msgFormat, args);
+    }
+
+    @Override
+    public void info(@NonNull String msgFormat, Object... args) {
+        mLogger.info(msgFormat, args);
+    }
+
+    @Override
+    public void verbose(@NonNull String msgFormat, Object... args) {
+        mLogger.verbose(msgFormat, args);
+    }
+}
diff --git a/remote/src/com/android/tradefed/command/remote/DeviceDescriptor.java b/device_build_interfaces/com/android/tradefed/command/remote/DeviceDescriptor.java
similarity index 91%
rename from remote/src/com/android/tradefed/command/remote/DeviceDescriptor.java
rename to device_build_interfaces/com/android/tradefed/command/remote/DeviceDescriptor.java
index 7e7aa6587..26806988b 100644
--- a/remote/src/com/android/tradefed/command/remote/DeviceDescriptor.java
+++ b/device_build_interfaces/com/android/tradefed/command/remote/DeviceDescriptor.java
@@ -52,16 +52,42 @@ public class DeviceDescriptor implements Serializable {
         this(null, false, null, null, null, null, null, null);
     }
 
-    public DeviceDescriptor(String serial, boolean isStubDevice, DeviceAllocationState state,
-            String product, String productVariant, String sdkVersion, String buildId,
+    public DeviceDescriptor(
+            String serial,
+            boolean isStubDevice,
+            DeviceAllocationState state,
+            String product,
+            String productVariant,
+            String sdkVersion,
+            String buildId,
             String batteryLevel) {
-        this(serial, isStubDevice, state, product, productVariant, sdkVersion, buildId,
-                batteryLevel, "", "", "", "");
+        this(
+                serial,
+                isStubDevice,
+                state,
+                product,
+                productVariant,
+                sdkVersion,
+                buildId,
+                batteryLevel,
+                "",
+                "",
+                "",
+                "");
     }
 
-    public DeviceDescriptor(String serial, boolean isStubDevice, DeviceAllocationState state,
-            String product, String productVariant, String sdkVersion, String buildId,
-            String batteryLevel, String deviceClass, String macAddress, String simState,
+    public DeviceDescriptor(
+            String serial,
+            boolean isStubDevice,
+            DeviceAllocationState state,
+            String product,
+            String productVariant,
+            String sdkVersion,
+            String buildId,
+            String batteryLevel,
+            String deviceClass,
+            String macAddress,
+            String simState,
             String simOperator) {
         this(
                 serial,
@@ -370,9 +396,7 @@ public class DeviceDescriptor implements Serializable {
         return mIDevice.getProperty(name);
     }
 
-    /**
-     * Provides a description with serials, product and build id
-     */
+    /** Provides a description with serials, product and build id */
     @Override
     public String toString() {
         return String.format("[%s %s:%s %s]", mSerial, mProduct, mProductVariant, mBuildId);
diff --git a/device_build_interfaces/com/android/tradefed/device/AndroidDebugBridgeWrapper.java b/device_build_interfaces/com/android/tradefed/device/AndroidDebugBridgeWrapper.java
index b60ce237a..f45b753e6 100644
--- a/device_build_interfaces/com/android/tradefed/device/AndroidDebugBridgeWrapper.java
+++ b/device_build_interfaces/com/android/tradefed/device/AndroidDebugBridgeWrapper.java
@@ -16,10 +16,10 @@
 package com.android.tradefed.device;
 
 import com.android.annotations.VisibleForTesting;
-import com.android.ddmlib.AndroidDebugBridge;
-import com.android.ddmlib.AndroidDebugBridge.IDeviceChangeListener;
 import com.android.ddmlib.DdmPreferences;
 import com.android.ddmlib.IDevice;
+import com.android.tradefed.device.server.AndroidDebugBridge;
+import com.android.tradefed.device.server.AndroidDebugBridge.IDeviceChangeListener;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
diff --git a/device_build_interfaces/com/android/tradefed/device/IAndroidDebugBridge.java b/device_build_interfaces/com/android/tradefed/device/IAndroidDebugBridge.java
index fe96d39a6..6d8ac12d3 100644
--- a/device_build_interfaces/com/android/tradefed/device/IAndroidDebugBridge.java
+++ b/device_build_interfaces/com/android/tradefed/device/IAndroidDebugBridge.java
@@ -15,9 +15,9 @@
  */
 package com.android.tradefed.device;
 
-import com.android.ddmlib.AndroidDebugBridge;
-import com.android.ddmlib.AndroidDebugBridge.IDeviceChangeListener;
 import com.android.ddmlib.IDevice;
+import com.android.tradefed.device.server.AndroidDebugBridge;
+import com.android.tradefed.device.server.AndroidDebugBridge.IDeviceChangeListener;
 
 /**
  * Interface definition for {@link com.android.ddmlib.AndroidDebugBridge} methods used in this
diff --git a/device_build_interfaces/com/android/tradefed/device/IDeviceSelection.java b/device_build_interfaces/com/android/tradefed/device/IDeviceSelection.java
index 6daad5f1d..868b936e1 100644
--- a/device_build_interfaces/com/android/tradefed/device/IDeviceSelection.java
+++ b/device_build_interfaces/com/android/tradefed/device/IDeviceSelection.java
@@ -142,4 +142,7 @@ public interface IDeviceSelection extends IMatcher<IDevice> {
 
     /** Sets whether or not we want to do the battery check. */
     public void setRequireBatteryCheck(boolean requireCheck);
+
+    /** Create a temporary placeholder out of the metadata. */
+    public boolean shouldCreateTemporarilyPlaceholder();
 }
diff --git a/device_build_interfaces/com/android/tradefed/device/IDeviceStateMonitor.java b/device_build_interfaces/com/android/tradefed/device/IDeviceStateMonitor.java
index 6524f5b1e..74128a778 100644
--- a/device_build_interfaces/com/android/tradefed/device/IDeviceStateMonitor.java
+++ b/device_build_interfaces/com/android/tradefed/device/IDeviceStateMonitor.java
@@ -220,6 +220,11 @@ public interface IDeviceStateMonitor {
     /** Gets the fastboot mode serial number. */
     public String getFastbootSerialNumber();
 
+    /** Clear any state in device manager. */
+    public default void clearTcpFastbootMonitor() {
+        // Empty by default
+    }
+
     /** Attach a final state to abort waitForDeviceState if reached. */
     public default void attachFinalState(TestDeviceState finalState) {
         // Empty by default
diff --git a/device_build_interfaces/com/android/tradefed/device/IManagedTestDevice.java b/device_build_interfaces/com/android/tradefed/device/IManagedTestDevice.java
index a6cbb1cb2..d22b9b3b8 100644
--- a/device_build_interfaces/com/android/tradefed/device/IManagedTestDevice.java
+++ b/device_build_interfaces/com/android/tradefed/device/IManagedTestDevice.java
@@ -81,6 +81,12 @@ public interface IManagedTestDevice extends ITestDevice {
      */
     public String getFastbootPath();
 
+    /** Sets the path to the adb binary that should be used. */
+    public void setAdbPath(String fastbootPath);
+
+    /** Returns the path of the adb binary being used. */
+    public String getAdbPath();
+
     /**
      * Returns the version string of the fastboot binary being used. Or null if something goes
      * wrong.
diff --git a/device_build_interfaces/com/android/tradefed/device/INativeDevice.java b/device_build_interfaces/com/android/tradefed/device/INativeDevice.java
index 33972d5e3..40e3275cc 100644
--- a/device_build_interfaces/com/android/tradefed/device/INativeDevice.java
+++ b/device_build_interfaces/com/android/tradefed/device/INativeDevice.java
@@ -499,6 +499,54 @@ public interface INativeDevice {
     public String executeAdbCommand(long timeout, Map<String, String> envMap, String... commandArgs)
             throws DeviceNotAvailableException;
 
+    /**
+     * Helper method which executes a adb command as a system command.
+     *
+     * <p>{@link #executeShellCommand(String)} should be used instead wherever possible, as that
+     * method provides better failure detection and performance.
+     *
+     * @param commandArgs the adb command and arguments to run
+     * @return the CommandResult containing output of command.
+     * @throws DeviceNotAvailableException if connection with device is lost and cannot be
+     *     recovered.
+     */
+    public CommandResult executeAdbV2Command(String... commandArgs)
+            throws DeviceNotAvailableException;
+
+    /**
+     * Helper method which executes a adb command as a system command with a specified timeout.
+     *
+     * <p>{@link #executeShellCommand(String)} should be used instead wherever possible, as that
+     * method provides better failure detection and performance.
+     *
+     * @param timeout the time in milliseconds before the device is considered unresponsive, 0L for
+     *     no timeout
+     * @param commandArgs the adb command and arguments to run
+     * @return the CommandResult containing output of command.
+     * @throws DeviceNotAvailableException if connection with device is lost and cannot be
+     *     recovered.
+     */
+    public CommandResult executeAdbV2Command(long timeout, String... commandArgs)
+            throws DeviceNotAvailableException;
+
+    /**
+     * Helper method which executes a adb command as a system command with a specified timeout.
+     *
+     * <p>{@link #executeShellCommand(String)} should be used instead wherever possible, as that
+     * method provides better failure detection and performance.
+     *
+     * @param timeout the time in milliseconds before the device is considered unresponsive, 0L for
+     *     no timeout
+     * @param envMap environment to set for the command
+     * @param commandArgs the adb command and arguments to run
+     * @return the CommandResult containing output of command.
+     * @throws DeviceNotAvailableException if connection with device is lost and cannot be
+     *     recovered.
+     */
+    public CommandResult executeAdbV2Command(
+            long timeout, Map<String, String> envMap, String... commandArgs)
+            throws DeviceNotAvailableException;
+
     /**
      * Helper method which executes a fastboot command as a system command with a default timeout of
      * 2 minutes.
@@ -1203,15 +1251,15 @@ public interface INativeDevice {
     public void nonBlockingReboot() throws DeviceNotAvailableException;
 
     /**
-     * Turns on adb root. If the "enable-root" setting is "false", will log a message and
-     * return without enabling root.
-     * <p/>
-     * Enabling adb root may cause device to disconnect from adb. This method will block until
+     * Turns on adb root. If the "enable-root" setting is "false", will log a message and return
+     * without enabling root.
+     *
+     * <p>Enabling adb root may cause device to disconnect from adb. This method will block until
      * device is available.
      *
      * @return <code>true</code> if successful.
      * @throws DeviceNotAvailableException if connection with device is lost and cannot be
-     * recovered.
+     *     recovered.
      */
     public boolean enableAdbRoot() throws DeviceNotAvailableException;
 
diff --git a/device_build_interfaces/com/android/tradefed/device/ITemporaryDevice.java b/device_build_interfaces/com/android/tradefed/device/ITemporaryDevice.java
new file mode 100644
index 000000000..7a005ce05
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/ITemporaryDevice.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.device;
+
+/** Interface to represent a device that can be a temporary placeholder. */
+public interface ITemporaryDevice {
+
+    public default boolean isTemporary() {
+        return false;
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/ITestDevice.java b/device_build_interfaces/com/android/tradefed/device/ITestDevice.java
index 4518a25de..c5e8276ea 100644
--- a/device_build_interfaces/com/android/tradefed/device/ITestDevice.java
+++ b/device_build_interfaces/com/android/tradefed/device/ITestDevice.java
@@ -208,6 +208,15 @@ public interface ITestDevice extends INativeDevice {
             String... extraArgs)
             throws DeviceNotAvailableException;
 
+    /**
+     * Installs apks with incremental mode.
+     *
+     * @param apkFiles the apk files to install.
+     * @throws DeviceNotAvailableException
+     */
+    public boolean installPackageWithIncrementalMode(
+            File[] apkFiles, String[] extraArgs, String userId) throws DeviceNotAvailableException;
+
     /**
      * Uninstall an Android package from device.
      *
diff --git a/device_build_interfaces/com/android/tradefed/device/NullDevice.java b/device_build_interfaces/com/android/tradefed/device/NullDevice.java
index 99733702c..d452ef80d 100644
--- a/device_build_interfaces/com/android/tradefed/device/NullDevice.java
+++ b/device_build_interfaces/com/android/tradefed/device/NullDevice.java
@@ -18,10 +18,10 @@ package com.android.tradefed.device;
 import com.android.ddmlib.IDevice;
 
 /**
- * A placeholder {@link IDevice} used by {@link DeviceManager} to allocate when
- * {@link IDeviceSelection#nullDeviceRequested()} is <code>true</code>
+ * A placeholder {@link IDevice} used by {@link DeviceManager} to allocate when {@link
+ * IDeviceSelection#nullDeviceRequested()} is <code>true</code>
  */
-public class NullDevice extends StubDevice {
+public class NullDevice extends StubDevice implements ITemporaryDevice {
 
     /** Naming pattern for auto-created null devices */
     public static final String TEMP_NULL_DEVICE_PREFIX = "null-device-temp-";
@@ -41,7 +41,8 @@ public class NullDevice extends StubDevice {
      * Returns true if the device was created temporarily for the invocation and should be deleted
      * afterward.
      */
-    public final boolean isTemporary() {
+    @Override
+    public boolean isTemporary() {
         return mTemporaryDevice;
     }
 }
diff --git a/device_build_interfaces/com/android/tradefed/device/StubDevice.java b/device_build_interfaces/com/android/tradefed/device/StubDevice.java
index 14952deb1..55ac414f6 100644
--- a/device_build_interfaces/com/android/tradefed/device/StubDevice.java
+++ b/device_build_interfaces/com/android/tradefed/device/StubDevice.java
@@ -14,8 +14,8 @@
  * limitations under the License.
  */
 package com.android.tradefed.device;
+
 import com.android.ddmlib.AdbCommandRejectedException;
-import com.android.ddmlib.Client;
 import com.android.ddmlib.FileListingService;
 import com.android.ddmlib.IDevice;
 import com.android.ddmlib.IShellOutputReceiver;
@@ -25,10 +25,9 @@ import com.android.ddmlib.RawImage;
 import com.android.ddmlib.ScreenRecorderOptions;
 import com.android.ddmlib.ShellCommandUnresponsiveException;
 import com.android.ddmlib.SyncException;
-import com.android.ddmlib.SyncService;
 import com.android.ddmlib.TimeoutException;
-import com.android.ddmlib.log.LogReceiver;
-import com.android.sdklib.AndroidVersion;
+import com.android.tradefed.device.server.Client;
+import com.android.tradefed.device.server.SyncService;
 
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.SettableFuture;
@@ -41,6 +40,7 @@ import java.util.List;
 import java.util.Map;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
+
 /** Stub placeholder implementation of a {@link IDevice}. */
 public class StubDevice implements IDevice, Serializable {
     private static final long serialVersionUID = 1L;
@@ -299,18 +299,6 @@ public class StubDevice implements IDevice, Serializable {
     }
     /** {@inheritDoc} */
     @Override
-    public void runEventLogService(LogReceiver receiver)
-            throws TimeoutException, AdbCommandRejectedException, IOException {
-        throw new IOException("stub");
-    }
-    /** {@inheritDoc} */
-    @Override
-    public void runLogService(String logname, LogReceiver receiver)
-            throws TimeoutException, AdbCommandRejectedException, IOException {
-        throw new IOException("stub");
-    }
-    /** {@inheritDoc} */
-    @Override
     public String syncPackageToDevice(String localFilePath)
             throws TimeoutException, AdbCommandRejectedException, IOException, SyncException {
         throw new IOException("stub");
@@ -492,11 +480,7 @@ public class StubDevice implements IDevice, Serializable {
     public String getRegion() {
         return null;
     }
-    /** {@inheritDoc} */
-    @Override
-    public AndroidVersion getVersion() {
-        return null;
-    }
+
     /** {@inheritDoc} */
     @Override
     public boolean isRoot()
diff --git a/device_build_interfaces/com/android/tradefed/device/TestDeviceOptions.java b/device_build_interfaces/com/android/tradefed/device/TestDeviceOptions.java
index 2e64ca7a4..b1ef68a69 100644
--- a/device_build_interfaces/com/android/tradefed/device/TestDeviceOptions.java
+++ b/device_build_interfaces/com/android/tradefed/device/TestDeviceOptions.java
@@ -51,6 +51,8 @@ public class TestDeviceOptions {
         EMULATOR,
         /** Chrome OS VM (betty) */
         CHEEPS,
+        /** Device connected over network */
+        NETWORK_DEVICE,
     }
 
     /** The size of the host which Oxygen virtual device will be running on. */
@@ -116,6 +118,20 @@ public class TestDeviceOptions {
                             + "the same fastboot binary as DeviceManager.")
     private File mFastbootBinary = null;
 
+    @Option(
+            name = "device-adb-binary",
+            description =
+                    "The adb binary to use for the test session. If null, will use "
+                            + "the same adb binary as DeviceManager.")
+    private File mAdbBinary = null;
+
+    @Option(
+            name = "device-adb-server-port",
+            description =
+                    "The port of the adb server associated with the device. By default will be the"
+                            + " 5037.")
+    private String mAdbServerPort = null;
+
     @Option(name = "use-fastboot-erase", description =
             "use fastboot erase instead of fastboot format to wipe partitions")
     private boolean mUseFastbootErase = false;
@@ -142,7 +158,7 @@ public class TestDeviceOptions {
             name = "snapuserd-timeout",
             description = "time to wait for a device to finish committing patches with snapuserd",
             isTimeVal = true)
-    private long mSnapuserdTimeout = 10 * 60 * 1000;
+    private long mSnapuserdTimeout = 20 * 60 * 1000;
 
     @Option(name = "conn-check-url",
             description = "default URL to be used for connectivity checks.")
@@ -232,6 +248,12 @@ public class TestDeviceOptions {
             description = "maximum time in ms to wait for a ADB connection.",
             isTimeVal = true)
     protected long mAdbConnectWaitTime = 2 * 60 * 1000;
+
+    @Option(
+            name = "skip-wait-for-boot-complete",
+            description = "Experimental flag for special device bring up.")
+    private boolean mSkipBootComplete = false;
+
     // ====================== Options Related to Virtual Devices ======================
     @Option(
             name = INSTANCE_TYPE_OPTION,
@@ -423,6 +445,10 @@ public class TestDeviceOptions {
     @Option(name = "force-evaluate-connection")
     private boolean mForceEvaluateDeviceConnection = false;
 
+    @Option(name = "use-ipv6-for-tcp-fastboot",
+            description = "Whether to use IPv6 for TCP fastboot detection.")
+    private boolean mUseIpV6ForTcpFastboot = true;
+
     // END ====================== Options Related to Virtual Devices ======================
 
     // Option related to Remote Device only
@@ -548,6 +574,16 @@ public class TestDeviceOptions {
         return mFastbootBinary;
     }
 
+    /** Returns a specified adb binary to be used. if null, use the DeviceManager one. */
+    public File getAdbBinary() {
+        return mAdbBinary;
+    }
+
+    /** Returns the adb server port associated with the device. if null, use the default one. */
+    public String getAdbServerPort() {
+        return mAdbServerPort;
+    }
+
     /**
      * @return the timeout in msecs for the filesystem to be formatted and the device to reboot
      * after unencryption.
@@ -950,6 +986,8 @@ public class TestDeviceOptions {
                 return "create";
             case EMULATOR:
                 return "create_gf";
+            case NETWORK_DEVICE:
+                return "invalid_shouldnt_be_used";
         }
         throw new RuntimeException("Unexpected InstanceType: " + type);
     }
@@ -1055,5 +1093,13 @@ public class TestDeviceOptions {
     public boolean evaluateDeviceConnection() {
         return mForceEvaluateDeviceConnection;
     }
+
+    public boolean useIpV6ForTcpFastboot() {
+        return mUseIpV6ForTcpFastboot;
+    }
+
+    public boolean shouldSkipBootComplete() {
+        return mSkipBootComplete;
+    }
 }
 
diff --git a/remote/src/com/android/tradefed/device/TestDeviceState.java b/device_build_interfaces/com/android/tradefed/device/TestDeviceState.java
similarity index 91%
rename from remote/src/com/android/tradefed/device/TestDeviceState.java
rename to device_build_interfaces/com/android/tradefed/device/TestDeviceState.java
index 73a8534df..4a109e765 100644
--- a/remote/src/com/android/tradefed/device/TestDeviceState.java
+++ b/device_build_interfaces/com/android/tradefed/device/TestDeviceState.java
@@ -19,8 +19,8 @@ import com.android.ddmlib.IDevice.DeviceState;
 
 /**
  * A more fully featured representation of device state than {@link DeviceState}.
- * <p/>
- * Logically this should extend  {@link DeviceState} to just add the FASTBOOT and NOT_AVAILABLE
+ *
+ * <p>Logically this should extend {@link DeviceState} to just add the FASTBOOT and NOT_AVAILABLE
  * states, but extending enums is not allowed.
  */
 public enum TestDeviceState {
@@ -34,6 +34,7 @@ public enum TestDeviceState {
 
     /**
      * Converts from {@link TestDeviceState} to {@link DeviceState}
+     *
      * @return the {@link DeviceState} or <code>null</code>
      */
     DeviceState getDdmsState() {
@@ -49,9 +50,7 @@ public enum TestDeviceState {
         }
     }
 
-    /**
-     * Returns the {@link TestDeviceState} corresponding to the {@link DeviceState}.
-     */
+    /** Returns the {@link TestDeviceState} corresponding to the {@link DeviceState}. */
     static TestDeviceState getStateByDdms(DeviceState ddmsState) {
         if (ddmsState == null) {
             return TestDeviceState.NOT_AVAILABLE;
diff --git a/device_build_interfaces/com/android/tradefed/device/UserInfo.java b/device_build_interfaces/com/android/tradefed/device/UserInfo.java
index 1ccab4a00..7cc384f3d 100644
--- a/device_build_interfaces/com/android/tradefed/device/UserInfo.java
+++ b/device_build_interfaces/com/android/tradefed/device/UserInfo.java
@@ -23,15 +23,20 @@ package com.android.tradefed.device;
  * <p>Stores data and basic logic around the information for one user.
  */
 public final class UserInfo {
-    // From android.content.pm.UserInfo
+    // From {@link android.os.UserHandle}
+    public static final int USER_SYSTEM = 0;
+    public static final int USER_NULL = -10000;
+
+    // From {@link android.content.pm.UserInfo}
     public static final int FLAG_PRIMARY = 0x00000001;
     public static final int FLAG_GUEST = 0x00000004;
     public static final int FLAG_RESTRICTED = 0x00000008;
     public static final int FLAG_EPHEMERAL = 0x00000100;
     public static final int FLAG_MANAGED_PROFILE = 0x00000020;
     public static final int FLAG_PROFILE = 0x00001000;
-    public static final int USER_SYSTEM = 0;
+    public static final int FLAG_FULL = 0x00000400;
     public static final int FLAG_MAIN = 0x00004000;
+
     public static final int FLAG_FOR_TESTING = 0x00008000;
 
     public static final int FLAGS_NOT_SECONDARY =
@@ -60,10 +65,17 @@ public final class UserInfo {
         PRIMARY,
         /** system user = user 0 */
         SYSTEM,
+        /** undefined user id */
+        NULL,
+        /** Indicates a "full" user, which is a non-profile, human user. */
+        FULL,
         /**
-         * user flagged as main user on the device; on non-hsum main user = system user = user 0 on
-         * hsum main user = first human user.
+         * Indicates the "main" user, which is the designated primary user on the device, as defined
+         * by {@link UserManager#getMainUser()}.
+         *
+         * @deprecated Use FULL instead.
          */
+        @Deprecated
         MAIN,
         /** secondary user, i.e. non-primary and non-system. */
         SECONDARY,
@@ -92,6 +104,14 @@ public final class UserInfo {
             return this == SYSTEM;
         }
 
+        public boolean isFull() {
+            return this == FULL;
+        }
+
+        /**
+         * @deprecated Use {@link #isFull()} instead.
+         */
+        @Deprecated
         public boolean isMain() {
             return this == MAIN;
         }
@@ -163,6 +183,18 @@ public final class UserInfo {
         return mUserId == USER_SYSTEM;
     }
 
+    public boolean isNull() {
+        return mUserId == USER_NULL;
+    }
+
+    public boolean isFull() {
+        return (mFlag & FLAG_FULL) == FLAG_FULL;
+    }
+
+    /**
+     * @deprecated Use {@link #isFull()} instead.
+     */
+    @Deprecated
     public boolean isMain() {
         return (mFlag & FLAG_MAIN) == FLAG_MAIN;
     }
@@ -202,6 +234,10 @@ public final class UserInfo {
                 return isPrimary();
             case SYSTEM:
                 return isSystem();
+            case NULL:
+                return isNull();
+            case FULL:
+                return isFull();
             case MAIN:
                 return isMain();
             case SECONDARY:
diff --git a/device_build_interfaces/com/android/tradefed/device/contentprovider/ContentProviderHandler.java b/device_build_interfaces/com/android/tradefed/device/contentprovider/ContentProviderHandler.java
index 3929797a0..38010fa25 100644
--- a/device_build_interfaces/com/android/tradefed/device/contentprovider/ContentProviderHandler.java
+++ b/device_build_interfaces/com/android/tradefed/device/contentprovider/ContentProviderHandler.java
@@ -21,6 +21,8 @@ import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
 import com.android.tradefed.util.FileUtil;
+import com.android.tradefed.util.IRunUtil;
+import com.android.tradefed.util.RunUtil;
 import com.android.tradefed.util.StreamUtil;
 
 import com.google.common.annotations.VisibleForTesting;
@@ -81,11 +83,16 @@ public class ContentProviderHandler {
     // Error thrown by device if the content provider is not installed for any reason.
     private static final String ERROR_PROVIDER_NOT_INSTALLED =
             "Could not find provider: android.tradefed.contentprovider";
+    // Error thrown by device when content provider is not ready yet.
+    private static final String ERROR_PROVIDER_NOT_READY =
+            "Error while accessing provider:android.tradefed.contentprovider";
 
     private final Integer mUserId;
     private ITestDevice mDevice;
+    private IRunUtil mRunUtil;
     private File mContentProviderApk = null;
     private boolean mReportNotFound = false;
+    private boolean mReportNotReady = false;
 
     /** Constructor. */
     public ContentProviderHandler(ITestDevice device) throws DeviceNotAvailableException {
@@ -97,6 +104,17 @@ public class ContentProviderHandler {
         mDevice = device;
     }
 
+    public void setRunUtil(IRunUtil runUtil) {
+        mRunUtil = runUtil;
+    }
+
+    public IRunUtil getRunUtil() {
+        if (mRunUtil != null) {
+            return mRunUtil;
+        }
+        return RunUtil.getDefault();
+    }
+
     /** Returns the userId that this instance is initialized with. */
     @Nullable
     public Integer getUserId() {
@@ -119,6 +137,7 @@ public class ContentProviderHandler {
     public boolean setUp() throws DeviceNotAvailableException {
         if (mDevice.isPackageInstalled(PACKAGE_NAME, Integer.toString(getEffectiveUserId()))) {
             mReportNotFound = false;
+            mReportNotReady = false;
             return true;
         }
         if (mContentProviderApk == null || !mContentProviderApk.exists()) {
@@ -160,6 +179,7 @@ public class ContentProviderHandler {
         if (CommandStatus.SUCCESS.equals(appOpsResult.getStatus())
                 && appOpsResult.getStdout().contains(PROPERTY_RESULT)) {
             mReportNotFound = false;
+            mReportNotReady = false;
             return true;
         }
         CLog.e(
@@ -308,6 +328,9 @@ public class ContentProviderHandler {
         if (stderr != null && stderr.contains(ERROR_PROVIDER_NOT_INSTALLED)) {
             mReportNotFound = true;
         }
+        if (stderr != null && stderr.contains(ERROR_PROVIDER_NOT_READY)) {
+            mReportNotReady = true;
+        }
         return Strings.isNullOrEmpty(stderr);
     }
 
@@ -476,15 +499,30 @@ public class ContentProviderHandler {
             throws DeviceNotAvailableException {
         String contentUri = createEscapedContentUri(deviceFilePath);
         String pushCommand = String.format("content write --user %d --uri %s", userId, contentUri);
-        CommandResult pushResult = mDevice.executeShellV2Command(pushCommand, fileToPush);
 
-        if (isSuccessful(pushResult)) {
-            return true;
-        }
+        int retryCount = (userId == 0 ? 0 : 3);
+        do {
+            CommandResult pushResult = mDevice.executeShellV2Command(pushCommand, fileToPush);
 
-        CLog.e(
-                "Failed to push a file '%s' at %s using content provider. Error: '%s'",
-                fileToPush, deviceFilePath, pushResult.getStderr());
+            if (isSuccessful(pushResult)) {
+                return true;
+            }
+
+            CLog.e(
+                    "Failed to push a file '%s' at %s using content provider. Error: '%s'",
+                    fileToPush, deviceFilePath, pushResult.getStderr());
+            if (mReportNotFound) {
+                setUp();
+            } else if (!mReportNotReady) {
+                return false;
+            }
+            // Retry in some cases.
+            retryCount--;
+            // Skip sleeping after the last attempt
+            if (retryCount > 0) {
+                getRunUtil().sleep(5000L);
+            }
+        } while (retryCount > 0);
         return false;
     }
 
diff --git a/device_build_interfaces/com/android/tradefed/device/server/AdbDevice.java b/device_build_interfaces/com/android/tradefed/device/server/AdbDevice.java
new file mode 100644
index 000000000..95eda0b8d
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/AdbDevice.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.device.server;
+
+import com.android.ddmlib.IDevice;
+
+import java.util.Objects;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/** Holds the state of a device as reported by the "adb devices -l" command. */
+public final class AdbDevice {
+    private static final Pattern SERIAL_PATTERN =
+            Pattern.compile("([\\S&&[^\\(]]\\S*|\\(.*\\))\\s+(\\S+)\\s*.*$");
+
+    /** Serial number of the device or null if none */
+    private String serial;
+
+    /** Status of the device, or null if unknown. */
+    private IDevice.DeviceState state;
+
+    public AdbDevice(String serial, IDevice.DeviceState state) {
+        this.serial = serial;
+        this.state = state;
+    }
+
+    public String getSerial() {
+        return serial;
+    }
+
+    public IDevice.DeviceState getState() {
+        return state;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        AdbDevice device = (AdbDevice) o;
+        return Objects.equals(serial, device.serial) && state == device.state;
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(serial, state);
+    }
+
+    /**
+     * Parse a single line returned from "adb devices -l" as an AdbDevice or null if the line
+     * doesn't match the expected format.
+     */
+    public static AdbDevice parseAdbLine(String line) {
+        Matcher matcher = SERIAL_PATTERN.matcher(line);
+        if (matcher.matches()) {
+            String serial = matcher.group(1);
+            String stateName = matcher.group(2);
+
+            if (serial != null && serial.startsWith("(")) {
+                serial = null;
+            }
+
+            return new AdbDevice(serial, IDevice.DeviceState.getState(stateName));
+        }
+        return null;
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/AdbHelper.java b/device_build_interfaces/com/android/tradefed/device/server/AdbHelper.java
new file mode 100644
index 000000000..1e7556388
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/AdbHelper.java
@@ -0,0 +1,1318 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.server;
+
+import static java.nio.charset.StandardCharsets.US_ASCII;
+
+import com.android.annotations.NonNull;
+import com.android.annotations.Nullable;
+import com.android.ddmlib.AdbCommandRejectedException;
+import com.android.ddmlib.DdmPreferences;
+import com.android.ddmlib.IDevice;
+import com.android.ddmlib.IShellOutputReceiver;
+import com.android.ddmlib.RawImage;
+import com.android.ddmlib.ShellCommandUnresponsiveException;
+import com.android.ddmlib.TimeoutException;
+import com.android.tradefed.log.Log;
+import com.android.tradefed.log.LogUtil.CLog;
+
+import com.google.common.base.Strings;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.net.InetSocketAddress;
+import java.net.StandardSocketOptions;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.channels.SocketChannel;
+import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
+import java.util.Locale;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Helper class to handle requests and connections to adb.
+ *
+ * <p>{@link AndroidDebugBridge} is the public API to connection to adb, while {@link AdbHelper}
+ * does the low level stuff.
+ *
+ * <p>This currently uses spin-wait non-blocking I/O. A Selector would be more efficient, but seems
+ * like overkill for what we're doing here.
+ */
+public final class AdbHelper {
+
+    static final int WAIT_TIME = 5; // spin-wait sleep, in ms
+
+    static final int ADB_HEADER_SIZE = 4;
+
+    public static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;
+
+    public static final String HOST_TRANSPORT = "host:transport:";
+
+    /** do not instantiate */
+    private AdbHelper() {}
+
+    /**
+     * Invoke the host:exec service on a remote device. Return a socket channel that is connected to
+     * the executing process. Note that exec service does not differentiate stdout and stderr so
+     * whatever is read from the socket can come from either output and be interleaved.
+     *
+     * <p>ddlmib relinquishes ownership of the returned SocketChannel and must be explicitly closed
+     * after use.
+     *
+     * @param socketAddress
+     * @param device the device to connect to. Can be null in which case the connection will be to
+     *     the first available device.
+     * @param executable the absolute path of the executable to run
+     * @param parameters the parameters to get given upon execing the executable
+     * @return
+     * @throws IOException
+     * @throws TimeoutException
+     * @throws AdbCommandRejectedException
+     */
+    public static SocketChannel rawExec(
+            InetSocketAddress socketAddress, IDevice device, String executable, String[] parameters)
+            throws IOException, TimeoutException, AdbCommandRejectedException {
+        final StringBuilder command = new StringBuilder(executable);
+        for (String parameter : parameters) {
+            command.append(" ");
+            command.append(parameter);
+        }
+        return rawAdbService(socketAddress, device, command.toString(), AdbService.EXEC);
+    }
+
+    /**
+     * Invoke the service on a remote device. Return a socket channel that is connected to the
+     * executing process.
+     *
+     * <p>ddlmib relinquishes ownership of the returned SocketChannel and must be explicitly closed
+     * after use.
+     *
+     * @param socketAddress
+     * @param device the device to connect to. Can be null in which case the connection will be to
+     *     the first available device.
+     * @param command the command to execute
+     * @param service the {@link AdbHelper.AdbService} to use to run the command.
+     * @return
+     * @throws IOException
+     * @throws TimeoutException
+     * @throws AdbCommandRejectedException
+     */
+    public static SocketChannel rawAdbService(
+            InetSocketAddress socketAddress, IDevice device, String command, AdbService service)
+            throws IOException, TimeoutException, AdbCommandRejectedException {
+        SocketChannel adbChan = SocketChannel.open(socketAddress);
+        try {
+            adbChan.socket().setTcpNoDelay(true);
+            adbChan.configureBlocking(false);
+            adbChan.setOption(StandardSocketOptions.SO_KEEPALIVE, true);
+            setDevice(adbChan, device);
+
+            String serviceName = service.name().toLowerCase(Locale.US);
+            byte[] request = formAdbRequest(serviceName + ":" + command);
+            write(adbChan, request);
+
+            AdbResponse resp = readAdbResponse(adbChan, false);
+            if (!resp.okay) {
+                Log.e(
+                        "ddms",
+                        "ADB rejected "
+                                + serviceName
+                                + "command ("
+                                + command
+                                + "): "
+                                + resp.message);
+                throw createHiddenException(resp.message);
+            }
+        } catch (Exception e) {
+            adbChan.close();
+            throw e;
+        }
+        return adbChan;
+    }
+
+    /** Response from ADB. */
+    public static class AdbResponse {
+        public AdbResponse() {
+            message = "";
+        }
+
+        public boolean okay; // first 4 bytes in response were "OKAY"?
+
+        public String message; // diagnostic string if #okay is false
+    }
+
+    /**
+     * Create and connect a new pass-through socket, from the host to a port on the device.
+     *
+     * @param adbSockAddr
+     * @param device the device to connect to. Can be null in which case the connection will be to
+     *     the first available device.
+     * @param devicePort the port we're opening
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws IOException in case of I/O error on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     */
+    public static SocketChannel open(InetSocketAddress adbSockAddr, IDevice device, int devicePort)
+            throws IOException, TimeoutException, AdbCommandRejectedException {
+
+        SocketChannel adbChan = SocketChannel.open(adbSockAddr);
+        try {
+            adbChan.socket().setTcpNoDelay(true);
+            adbChan.configureBlocking(false);
+
+            // if the device is not -1, then we first tell adb we're looking to
+            // talk to a specific device
+            setDevice(adbChan, device);
+
+            byte[] req = createAdbForwardRequest(null, devicePort);
+            // Log.hexDump(req);
+
+            write(adbChan, req);
+
+            AdbResponse resp = readAdbResponse(adbChan, false);
+            if (!resp.okay) {
+                throw createHiddenException(resp.message);
+            }
+
+            adbChan.configureBlocking(true);
+        } catch (TimeoutException e) {
+            adbChan.close();
+            throw e;
+        } catch (IOException e) {
+            adbChan.close();
+            throw e;
+        } catch (AdbCommandRejectedException e) {
+            adbChan.close();
+            throw e;
+        }
+
+        return adbChan;
+    }
+
+    /**
+     * Creates and connects a new pass-through socket, from the host to a port on the device.
+     *
+     * @param adbSockAddr
+     * @param deviceSerialNumber the device serial number to connect to. Can be null or empty in
+     *     which case the connection will be to the first available device.
+     * @param pid the process pid to connect to.
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws IOException in case of I/O error on the connection.
+     */
+    public static SocketChannel createPassThroughConnection(
+            InetSocketAddress adbSockAddr, String deviceSerialNumber, int pid)
+            throws TimeoutException, AdbCommandRejectedException, IOException {
+        SocketChannel adbChan = SocketChannel.open(adbSockAddr);
+        try {
+            adbChan.socket().setTcpNoDelay(true);
+            adbChan.configureBlocking(false);
+
+            // if the device is not -1, then we first tell adb we're looking to
+            // talk to a specific device
+            setDevice(adbChan, deviceSerialNumber);
+
+            byte[] req = createJdwpForwardRequest(pid);
+            // Log.hexDump(req);
+
+            write(adbChan, req);
+
+            AdbResponse resp = readAdbResponse(adbChan, false /* readDiagString */);
+            if (!resp.okay) {
+                throw createHiddenException(resp.message);
+            }
+
+            adbChan.configureBlocking(true);
+        } catch (TimeoutException e) {
+            adbChan.close();
+            throw e;
+        } catch (IOException e) {
+            adbChan.close();
+            throw e;
+        } catch (AdbCommandRejectedException e) {
+            adbChan.close();
+            throw e;
+        }
+
+        return adbChan;
+    }
+
+    /**
+     * Creates a port forwarding request for adb. This returns an array containing
+     * "####tcp:{port}:{addStr}".
+     *
+     * @param addrStr the host. Can be null.
+     * @param port the port on the device. This does not need to be numeric.
+     */
+    private static byte[] createAdbForwardRequest(String addrStr, int port) {
+        String reqStr;
+
+        if (addrStr == null) reqStr = "tcp:" + port;
+        else reqStr = "tcp:" + port + ":" + addrStr;
+        return formAdbRequest(reqStr);
+    }
+
+    /**
+     * Creates a port forwarding request to a jdwp process. This returns an array containing
+     * "####jwdp:{pid}".
+     *
+     * @param pid the jdwp process pid on the device.
+     */
+    public static byte[] createJdwpForwardRequest(int pid) {
+        String reqStr = String.format("jdwp:%1$d", pid); // $NON-NLS-1$
+        return formAdbRequest(reqStr);
+    }
+
+    /**
+     * Create an ASCII string preceded by four hex digits. The opening "####" is the length of the
+     * rest of the string, encoded as ASCII hex (case doesn't matter).
+     */
+    public static byte[] formAdbRequest(String payloadString) {
+        byte[] payload = payloadString.getBytes(DEFAULT_CHARSET);
+        assert payload.length <= 9999; // Max encodable length;
+        byte[] header = String.format("%04X", payload.length).getBytes(US_ASCII);
+        assert header.length == ADB_HEADER_SIZE;
+        ByteBuffer request = ByteBuffer.allocate(header.length + payload.length);
+        request.put(header);
+        request.put(payload);
+        return request.array();
+    }
+
+    /**
+     * Reads the response from ADB after a command.
+     *
+     * @param chan The socket channel that is connected to adb.
+     * @param readDiagString If true, we're expecting an OKAY response to be followed by a
+     *     diagnostic string. Otherwise, we only expect the diagnostic string to follow a FAIL.
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws IOException in case of I/O error on the connection.
+     */
+    public static AdbResponse readAdbResponse(SocketChannel chan, boolean readDiagString)
+            throws TimeoutException, IOException {
+        AdbResponse resp = new AdbResponse();
+
+        byte[] reply = new byte[4];
+        read(chan, reply);
+
+        if (isOkay(reply)) {
+            resp.okay = true;
+        } else {
+            readDiagString = true; // look for a reason after the FAIL
+            resp.okay = false;
+        }
+
+        try {
+            // not a loop -- use "while" so we can use "break"
+            //noinspection LoopConditionNotUpdatedInsideLoop
+            while (readDiagString) {
+                // length string is in next 4 bytes
+                byte[] lenBuf = new byte[4];
+                read(chan, lenBuf);
+
+                String lenStr = replyToString(lenBuf);
+
+                int len;
+                try {
+                    len = Integer.parseInt(lenStr, 16);
+                } catch (NumberFormatException nfe) {
+                    Log.w(
+                            "ddms",
+                            "Expected digits, got '"
+                                    + lenStr
+                                    + "': "
+                                    + lenBuf[0]
+                                    + " "
+                                    + lenBuf[1]
+                                    + " "
+                                    + lenBuf[2]
+                                    + " "
+                                    + lenBuf[3]);
+                    Log.w("ddms", "reply was " + replyToString(reply));
+                    break;
+                }
+
+                byte[] msg = new byte[len];
+                read(chan, msg);
+
+                resp.message = replyToString(msg);
+                Log.v(
+                        "ddms",
+                        "Got reply '" + replyToString(reply) + "', diag='" + resp.message + "'");
+
+                break;
+            }
+        } catch (Exception e) {
+            // ignore those, since it's just reading the diagnose string, the response will
+            // contain okay==false anyway.
+        }
+
+        return resp;
+    }
+
+    /**
+     * Retrieve the frame buffer from the device with the given timeout. A timeout of 0 indicates
+     * that it will wait forever.
+     *
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws IOException in case of I/O error on the connection.
+     */
+    public static RawImage getFrameBuffer(
+            InetSocketAddress adbSockAddr, IDevice device, long timeout, TimeUnit unit)
+            throws TimeoutException, AdbCommandRejectedException, IOException {
+
+        RawImage imageParams = new RawImage();
+        byte[] request = formAdbRequest("framebuffer:"); // $NON-NLS-1$
+        byte[] nudge = {0};
+        byte[] reply;
+
+        SocketChannel adbChan = null;
+        try {
+            adbChan = SocketChannel.open(adbSockAddr);
+            adbChan.configureBlocking(false);
+
+            // if the device is not -1, then we first tell adb we're looking to talk
+            // to a specific device
+            setDevice(adbChan, device);
+
+            write(adbChan, request);
+
+            AdbResponse resp = readAdbResponse(adbChan, false /* readDiagString */);
+            if (!resp.okay) {
+                throw createHiddenException(resp.message);
+            }
+
+            // first the protocol version.
+            reply = new byte[4];
+            read(adbChan, reply);
+
+            ByteBuffer buf = ByteBuffer.wrap(reply);
+            buf.order(ByteOrder.LITTLE_ENDIAN);
+
+            int version = buf.getInt();
+
+            // get the header size (this is a count of int)
+            int headerSize = RawImage.getHeaderSize(version);
+
+            // read the header
+            reply = new byte[headerSize * 4];
+            read(adbChan, reply);
+
+            buf = ByteBuffer.wrap(reply);
+            buf.order(ByteOrder.LITTLE_ENDIAN);
+
+            // fill the RawImage with the header
+            if (!imageParams.readHeader(version, buf)) {
+                Log.e("Screenshot", "Unsupported protocol: " + version);
+                return null;
+            }
+
+            Log.d(
+                    "ddms",
+                    "image params: bpp="
+                            + imageParams.bpp
+                            + ", size="
+                            + imageParams.size
+                            + ", width="
+                            + imageParams.width
+                            + ", height="
+                            + imageParams.height);
+
+            write(adbChan, nudge);
+
+            reply = new byte[imageParams.size];
+            read(adbChan, reply, imageParams.size, unit.toMillis(timeout));
+
+            imageParams.data = reply;
+        } finally {
+            if (adbChan != null) {
+                adbChan.close();
+            }
+        }
+
+        return imageParams;
+    }
+
+    /**
+     * Executes a shell command on the device and retrieve the output. The output is handed to
+     * <var>rcvr</var> as it arrives.
+     *
+     * @param adbSockAddr the {@link InetSocketAddress} to adb.
+     * @param command the shell command to execute
+     * @param device the {@link IDevice} on which to execute the command.
+     * @param rcvr the {@link IShellOutputReceiver} that will receives the output of the shell
+     *     command
+     * @param maxTimeout max time for the command to return. A value of 0 means no max timeout will
+     *     be applied.
+     * @param maxTimeToOutputResponse max time between command output. If more time passes between
+     *     command output, the method will throw {@link ShellCommandUnresponsiveException}. A value
+     *     of 0 means the method will wait forever for command output and never throw.
+     * @param maxTimeUnits Units for non-zero {@code maxTimeout} and {@code maxTimeToOutputResponse}
+     *     values.
+     * @throws TimeoutException in case of timeout on the connection when sending the command.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws ShellCommandUnresponsiveException in case the shell command doesn't send any output
+     *     for a period longer than <var>maxTimeToOutputResponse</var>.
+     * @throws IOException in case of I/O error on the connection.
+     * @see DdmPreferences#getTimeOut()
+     */
+    public static void executeRemoteCommand(
+            InetSocketAddress adbSockAddr,
+            String command,
+            IDevice device,
+            IShellOutputReceiver rcvr,
+            long maxTimeout,
+            long maxTimeToOutputResponse,
+            TimeUnit maxTimeUnits)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    ShellCommandUnresponsiveException,
+                    IOException {
+        executeRemoteCommand(
+                adbSockAddr,
+                AdbService.SHELL,
+                command,
+                device,
+                rcvr,
+                maxTimeout,
+                maxTimeToOutputResponse,
+                maxTimeUnits,
+                null /* inputStream */);
+    }
+
+    /**
+     * Executes a shell command on the device and retrieve the output. The output is handed to
+     * <var>rcvr</var> as it arrives.
+     *
+     * @param adbSockAddr the {@link InetSocketAddress} to adb.
+     * @param command the shell command to execute
+     * @param device the {@link IDevice} on which to execute the command.
+     * @param rcvr the {@link IShellOutputReceiver} that will receives the output of the shell
+     *     command
+     * @param maxTimeToOutputResponse max time between command output. If more time passes between
+     *     command output, the method will throw {@link ShellCommandUnresponsiveException}. A value
+     *     of 0 means the method will wait forever for command output and never throw.
+     * @param maxTimeUnits Units for non-zero {@code maxTimeToOutputResponse} values.
+     * @throws TimeoutException in case of timeout on the connection when sending the command.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws ShellCommandUnresponsiveException in case the shell command doesn't send any output
+     *     for a period longer than <var>maxTimeToOutputResponse</var>.
+     * @throws IOException in case of I/O error on the connection.
+     * @see DdmPreferences#getTimeOut()
+     */
+    public static void executeRemoteCommand(
+            InetSocketAddress adbSockAddr,
+            String command,
+            IDevice device,
+            IShellOutputReceiver rcvr,
+            long maxTimeToOutputResponse,
+            TimeUnit maxTimeUnits)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    ShellCommandUnresponsiveException,
+                    IOException {
+        executeRemoteCommand(
+                adbSockAddr,
+                AdbService.SHELL,
+                command,
+                device,
+                rcvr,
+                maxTimeToOutputResponse,
+                maxTimeUnits,
+                null /* inputStream */);
+    }
+
+    /** Identify which adb service the command should target. */
+    public enum AdbService {
+        /** the shell service */
+        SHELL,
+
+        /** The exec service. */
+        EXEC,
+
+        /** The abb service. */
+        ABB_EXEC,
+    }
+
+    /**
+     * Executes a remote command on the device and retrieve the output. The output is handed to
+     * <var>rcvr</var> as it arrives. The command is execute by the remote service identified by the
+     * adbService parameter.
+     *
+     * @param adbSockAddr the {@link InetSocketAddress} to adb.
+     * @param adbService the {@link AdbHelper.AdbService} to use to run the command.
+     * @param command the shell command to execute
+     * @param device the {@link IDevice} on which to execute the command.
+     * @param rcvr the {@link IShellOutputReceiver} that will receives the output of the shell
+     *     command
+     * @param maxTimeout max timeout for the full command to execute. A value of 0 means no timeout.
+     * @param maxTimeToOutputResponse max time between command output. If more time passes between
+     *     command output, the method will throw {@link ShellCommandUnresponsiveException}. A value
+     *     of 0 means the method will wait forever for command output and never throw.
+     * @param maxTimeUnits Units for non-zero {@code maxTimeout} and {@code maxTimeToOutputResponse}
+     *     values.
+     * @param is a optional {@link InputStream} to be streamed up after invoking the command and
+     *     before retrieving the response.
+     * @throws TimeoutException in case of timeout on the connection when sending the command.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws ShellCommandUnresponsiveException in case the shell command doesn't send any output
+     *     for a period longer than <var>maxTimeToOutputResponse</var>.
+     * @throws IOException in case of I/O error on the connection.
+     * @see DdmPreferences#getTimeOut()
+     */
+    public static void executeRemoteCommand(
+            InetSocketAddress adbSockAddr,
+            AdbService adbService,
+            String command,
+            IDevice device,
+            IShellOutputReceiver rcvr,
+            long maxTimeout,
+            long maxTimeToOutputResponse,
+            TimeUnit maxTimeUnits,
+            @Nullable InputStream is)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    ShellCommandUnresponsiveException,
+                    IOException {
+        long maxTimeToOutputMs = 0;
+        if (maxTimeToOutputResponse > 0) {
+            if (maxTimeUnits == null) {
+                throw new NullPointerException("Time unit must not be null for non-zero max.");
+            }
+            maxTimeToOutputMs = maxTimeUnits.toMillis(maxTimeToOutputResponse);
+        }
+        long maxTimeoutMs = 0L;
+        if (maxTimeout > 0L) {
+            if (maxTimeUnits == null) {
+                throw new NullPointerException("Time unit must not be null for non-zero max.");
+            }
+            maxTimeoutMs = maxTimeUnits.toMillis(maxTimeout);
+        }
+
+        Log.v("ddms", "execute: running " + command);
+
+        SocketChannel adbChan = null;
+        try {
+            long startTime = System.currentTimeMillis();
+            adbChan = SocketChannel.open(adbSockAddr);
+            adbChan.configureBlocking(false);
+
+            // if the device is not -1, then we first tell adb we're looking to
+            // talk to a specific device
+            setDevice(adbChan, device);
+
+            byte[] request =
+                    formAdbRequest(
+                            adbService.name().toLowerCase(Locale.US)
+                                    + ":"
+                                    + command); // $NON-NLS-1$
+            write(adbChan, request);
+
+            AdbResponse resp = readAdbResponse(adbChan, false /* readDiagString */);
+            if (!resp.okay) {
+                Log.e("ddms", "ADB rejected shell command (" + command + "): " + resp.message);
+                throw createHiddenException(resp.message);
+            }
+
+            byte[] data = new byte[16384];
+
+            // stream the input file if present.
+            if (is != null) {
+                int read;
+                while ((read = is.read(data)) != -1) {
+                    ByteBuffer buf = ByteBuffer.wrap(data, 0, read);
+                    int writtenTotal = 0;
+                    long lastResponsive = System.currentTimeMillis();
+                    while (buf.hasRemaining()) {
+                        int written = adbChan.write(buf);
+
+                        if (written == 0) {
+                            // If device takes too long to respond to a write command, throw timeout
+                            // exception.
+                            if (maxTimeToOutputMs > 0
+                                    && System.currentTimeMillis() - lastResponsive
+                                            > maxTimeToOutputMs) {
+                                throw new TimeoutException(
+                                        String.format(
+                                                "executeRemoteCommand write timed out after %sms",
+                                                maxTimeToOutputMs));
+                            }
+                        } else {
+                            lastResponsive = System.currentTimeMillis();
+                        }
+
+                        // If the overall timeout exists and is exceeded, we throw timeout
+                        // exception.
+                        if (maxTimeoutMs > 0
+                                && System.currentTimeMillis() - startTime > maxTimeoutMs) {
+                            throw new TimeoutException(
+                                    String.format(
+                                            "executeRemoteCommand timed out after %sms",
+                                            maxTimeoutMs));
+                        }
+
+                        writtenTotal += written;
+                    }
+                    if (writtenTotal != read) {
+                        Log.e(
+                                "ddms",
+                                "ADB write inconsistency, wrote "
+                                        + writtenTotal
+                                        + "expected "
+                                        + read);
+                        throw createHiddenException("write failed");
+                    }
+                }
+            }
+
+            ByteBuffer buf = ByteBuffer.wrap(data);
+            buf.clear();
+            long timeToResponseCount = 0;
+            while (true) {
+                int count;
+
+                if (rcvr != null && rcvr.isCancelled()) {
+                    Log.v("ddms", "execute: cancelled");
+                    break;
+                }
+
+                count = adbChan.read(buf);
+                if (count < 0) {
+                    // we're at the end, we flush the output
+                    rcvr.flush();
+                    Log.v(
+                            "ddms",
+                            "execute '"
+                                    + command
+                                    + "' on '"
+                                    + device
+                                    + "' : EOF hit. Read: "
+                                    + count);
+                    break;
+                } else if (count == 0) {
+                    try {
+                        int wait = WAIT_TIME * 5;
+                        timeToResponseCount += wait;
+                        if (maxTimeToOutputMs > 0 && timeToResponseCount > maxTimeToOutputMs) {
+                            throw new ShellCommandUnresponsiveException();
+                        }
+                        Thread.sleep(wait);
+                    } catch (InterruptedException e) {
+                        Thread.currentThread().interrupt();
+                        // Throw a timeout exception in place of interrupted exception to avoid API
+                        // changes.
+                        throw new TimeoutException(
+                                "executeRemoteCommand interrupted with immediate timeout via"
+                                        + " interruption.");
+                    }
+                } else {
+                    // reset timeout
+                    timeToResponseCount = 0;
+
+                    // send data to receiver if present
+                    if (rcvr != null) {
+                        rcvr.addOutput(buf.array(), buf.arrayOffset(), buf.position());
+                    }
+                    buf.rewind();
+                }
+                // if the overall timeout exists and is exceeded, we throw timeout exception.
+                if (maxTimeoutMs > 0 && System.currentTimeMillis() - startTime > maxTimeoutMs) {
+                    throw new TimeoutException(
+                            String.format(
+                                    "executeRemoteCommand timed out after %sms", maxTimeoutMs));
+                }
+            }
+        } finally {
+            if (adbChan != null) {
+                adbChan.close();
+            }
+            Log.v("ddms", "execute: returning");
+        }
+    }
+
+    /**
+     * Executes a remote command on the device and retrieve the output. The output is handed to
+     * <var>rcvr</var> as it arrives. The command is execute by the remote service identified by the
+     * adbService parameter.
+     *
+     * @param adbSockAddr the {@link InetSocketAddress} to adb.
+     * @param adbService the {@link AdbHelper.AdbService} to use to run the command.
+     * @param command the shell command to execute
+     * @param device the {@link IDevice} on which to execute the command.
+     * @param rcvr the {@link IShellOutputReceiver} that will receives the output of the shell
+     *     command
+     * @param maxTimeToOutputResponse max time between command output. If more time passes between
+     *     command output, the method will throw {@link ShellCommandUnresponsiveException}. A value
+     *     of 0 means the method will wait forever for command output and never throw.
+     * @param maxTimeUnits Units for non-zero {@code maxTimeToOutputResponse} values.
+     * @param is a optional {@link InputStream} to be streamed up after invoking the command and
+     *     before retrieving the response.
+     * @throws TimeoutException in case of timeout on the connection when sending the command.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws ShellCommandUnresponsiveException in case the shell command doesn't send any output
+     *     for a period longer than <var>maxTimeToOutputResponse</var>.
+     * @throws IOException in case of I/O error on the connection.
+     * @see DdmPreferences#getTimeOut()
+     */
+    static void executeRemoteCommand(
+            InetSocketAddress adbSockAddr,
+            AdbService adbService,
+            String command,
+            IDevice device,
+            IShellOutputReceiver rcvr,
+            long maxTimeToOutputResponse,
+            TimeUnit maxTimeUnits,
+            @Nullable InputStream is)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    ShellCommandUnresponsiveException,
+                    IOException {
+        executeRemoteCommand(
+                adbSockAddr,
+                adbService,
+                command,
+                device,
+                rcvr,
+                0L,
+                maxTimeToOutputResponse,
+                maxTimeUnits,
+                is);
+    }
+
+    /**
+     * Creates a port forwarding between a local and a remote port.
+     *
+     * @param adbSockAddr the socket address to connect to adb
+     * @param device the device on which to do the port forwarding
+     * @param localPortSpec specification of the local port to forward, should be of format
+     *     tcp:<port number>
+     * @param remotePortSpec specification of the remote port to forward to, one of: tcp:<port>
+     *     localabstract:<unix domain socket name> localreserved:<unix domain socket name>
+     *     localfilesystem:<unix domain socket name> dev:<character device name> jdwp:<process pid>
+     *     (remote only)
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws IOException in case of I/O error on the connection.
+     */
+    public static void createForward(
+            InetSocketAddress adbSockAddr,
+            IDevice device,
+            String localPortSpec,
+            String remotePortSpec)
+            throws TimeoutException, AdbCommandRejectedException, IOException {
+
+        SocketChannel adbChan = null;
+        try {
+            adbChan = SocketChannel.open(adbSockAddr);
+            adbChan.configureBlocking(false);
+
+            byte[] request =
+                    formAdbRequest(
+                            String.format(
+                                    "host-serial:%1$s:forward:%2$s;%3$s", //$NON-NLS-1$
+                                    device.getSerialNumber(), localPortSpec, remotePortSpec));
+
+            write(adbChan, request);
+
+            AdbResponse resp = readAdbResponse(adbChan, false /* readDiagString */);
+            if (!resp.okay) {
+                Log.w("create-forward", "Error creating forward: " + resp.message);
+                throw createHiddenException(resp.message);
+            }
+        } finally {
+            if (adbChan != null) {
+                adbChan.close();
+            }
+        }
+    }
+
+    /**
+     * Creates a port reversing between a remote and a local port.
+     *
+     * @param adbSockAddr the socket address to connect to adb
+     * @param device the device on which to do the port reversing
+     * @param remotePortSpec specification of the remote port to reverse to, one of: tcp:<port>
+     *     localabstract:<unix domain socket name> localreserved:<unix domain socket name>
+     *     localfilesystem:<unix domain socket name> dev:<character device name> jdwp:<process pid>
+     *     (remote only)
+     * @param localPortSpec specification of the local port, should be of format tcp:<port number>
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws IOException in case of I/O error on the connection.
+     */
+    public static void createReverse(
+            InetSocketAddress adbSockAddr,
+            IDevice device,
+            String remotePortSpec,
+            String localPortSpec)
+            throws TimeoutException, AdbCommandRejectedException, IOException {
+
+        SocketChannel adbChan = null;
+        try {
+            adbChan = SocketChannel.open(adbSockAddr);
+            adbChan.configureBlocking(false);
+
+            byte[] request =
+                    formAdbRequest(
+                            String.format(
+                                    "reverse:forward:%1$s;%2$s", //$NON-NLS-1$
+                                    localPortSpec, remotePortSpec));
+
+            setDevice(adbChan, device.getSerialNumber());
+            write(adbChan, request);
+
+            AdbResponse resp = readAdbResponse(adbChan, false /* readDiagString */);
+            if (!resp.okay) {
+                Log.w("create-reverse", "Error creating reverse: " + resp.message);
+                throw createHiddenException(resp.message);
+            }
+        } finally {
+            if (adbChan != null) {
+                adbChan.close();
+            }
+        }
+    }
+
+    /**
+     * Queries a set of supported features from the host or from a device.
+     *
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws IOException in case of I/O error on the connection.
+     */
+    @NonNull
+    static String queryFeatures(@NonNull String adbFeaturesRequest)
+            throws TimeoutException, AdbCommandRejectedException, IOException {
+
+        try (SocketChannel adbChan = AndroidDebugBridge.openConnection()) {
+            adbChan.configureBlocking(false);
+
+            byte[] request = formAdbRequest(adbFeaturesRequest);
+
+            write(adbChan, request);
+
+            AdbResponse resp = readAdbResponse(adbChan, true /* readDiagString */);
+            if (!resp.okay) {
+                Log.w("features", "Error querying features: " + resp.message);
+                throw createHiddenException(resp.message);
+            }
+
+            return resp.message;
+        }
+    }
+
+    /**
+     * Queries a set of supported features from the device.
+     *
+     * @param device the device on which to do the port forwarding
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws IOException in case of I/O error on the connection.
+     */
+    @NonNull
+    public static String getFeatures(@NonNull IDevice device)
+            throws TimeoutException, AdbCommandRejectedException, IOException {
+        return queryFeatures(String.format("host-serial:%1$s:features", device.getSerialNumber()));
+    }
+
+    /**
+     * Queries a set of supported features from the ADB host.
+     *
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws IOException in case of I/O error on the connection.
+     */
+    @NonNull
+    public static String getHostFeatures()
+            throws TimeoutException, AdbCommandRejectedException, IOException {
+        return queryFeatures("host:host-features");
+    }
+
+    /**
+     * Remove a port forwarding between a local and a remote port.
+     *
+     * @param adbSockAddr the socket address to connect to adb
+     * @param device the device on which to remove the port forwarding
+     * @param localPortSpec specification of the local port that was forwarded, should be of format
+     *     tcp:<port number>
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws IOException in case of I/O error on the connection.
+     */
+    public static void removeForward(
+            InetSocketAddress adbSockAddr, IDevice device, String localPortSpec)
+            throws TimeoutException, AdbCommandRejectedException, IOException {
+
+        SocketChannel adbChan = null;
+        try {
+            adbChan = SocketChannel.open(adbSockAddr);
+            adbChan.configureBlocking(false);
+
+            byte[] request =
+                    formAdbRequest(
+                            String.format(
+                                    "host-serial:%1$s:killforward:%2$s", //$NON-NLS-1$
+                                    device.getSerialNumber(), localPortSpec));
+
+            write(adbChan, request);
+
+            AdbResponse resp = readAdbResponse(adbChan, false /* readDiagString */);
+            if (!resp.okay) {
+                Log.w("remove-forward", "Error removing forward: " + resp.message);
+                throw createHiddenException(resp.message);
+            }
+        } finally {
+            if (adbChan != null) {
+                adbChan.close();
+            }
+        }
+    }
+
+    /**
+     * Remove a port reversing between a remote and a local port.
+     *
+     * @param adbSockAddr the socket address to connect to adb
+     * @param device the device on which to remove the port reversing
+     * @param remotePortSpec specification of the remote port reversed to, one of: tcp:<port>
+     *     localabstract:<unix domain socket name> localreserved:<unix domain socket name>
+     *     localfilesystem:<unix domain socket name> dev:<character device name> jdwp:<process pid>
+     *     (remote only)
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws IOException in case of I/O error on the connection.
+     */
+    public static void removeReverse(
+            InetSocketAddress adbSockAddr, IDevice device, String remotePortSpec)
+            throws TimeoutException, AdbCommandRejectedException, IOException {
+
+        SocketChannel adbChan = null;
+        try {
+            adbChan = SocketChannel.open(adbSockAddr);
+            adbChan.configureBlocking(false);
+
+            byte[] request =
+                    formAdbRequest(
+                            String.format(
+                                    "reverse:killforward:%1$s", remotePortSpec)); // $NON-NLS-1$
+
+            setDevice(adbChan, device.getSerialNumber());
+            write(adbChan, request);
+
+            AdbResponse resp = readAdbResponse(adbChan, false /* readDiagString */);
+            if (!resp.okay) {
+                Log.w("remove-reverse", "Error removing reverse: " + resp.message);
+                throw createHiddenException(resp.message);
+            }
+        } finally {
+            if (adbChan != null) {
+                adbChan.close();
+            }
+        }
+    }
+
+    /** Checks to see if the first four bytes in "reply" are OKAY. */
+    static boolean isOkay(byte[] reply) {
+        return reply[0] == (byte) 'O'
+                && reply[1] == (byte) 'K'
+                && reply[2] == (byte) 'A'
+                && reply[3] == (byte) 'Y';
+    }
+
+    /** Converts an ADB reply to a string. */
+    static String replyToString(byte[] reply) {
+        return new String(reply, DEFAULT_CHARSET);
+    }
+
+    /**
+     * Reads from the socket until the array is filled, or no more data is coming (because the
+     * socket closed or the timeout expired).
+     *
+     * <p>This uses the default time out value.
+     *
+     * @param chan the opened socket to read from. It must be in non-blocking mode for timeouts to
+     *     work
+     * @param data the buffer to store the read data into.
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws IOException in case of I/O error on the connection.
+     */
+    static void read(SocketChannel chan, byte[] data) throws TimeoutException, IOException {
+        read(chan, data, -1, DdmPreferences.getTimeOut());
+    }
+
+    /**
+     * Reads from the socket until the array is filled, the optional length is reached, or no more
+     * data is coming (because the socket closed or the timeout expired). After "timeout"
+     * milliseconds since the previous successful read, this will return whether or not new data has
+     * been found.
+     *
+     * @param chan the opened socket to read from. It must be in non-blocking mode for timeouts to
+     *     work
+     * @param data the buffer to store the read data into.
+     * @param length the length to read or -1 to fill the data buffer completely
+     * @param timeout The timeout value in ms. A timeout of zero means "wait forever".
+     */
+    static void read(SocketChannel chan, byte[] data, int length, long timeout)
+            throws TimeoutException, IOException {
+        ByteBuffer buf = ByteBuffer.wrap(data, 0, length != -1 ? length : data.length);
+        int numWaits = 0;
+
+        while (buf.position() != buf.limit()) {
+            int count;
+
+            count = chan.read(buf);
+            if (count < 0) {
+                Log.d("ddms", "read: channel EOF");
+                throw new EOFException("EOF");
+            } else if (count == 0) {
+                // TODO: need more accurate timeout?
+                if (timeout != 0 && numWaits * WAIT_TIME > timeout) {
+                    Log.d("ddms", "read: timeout");
+                    throw new TimeoutException();
+                }
+                try {
+                    // non-blocking spin
+                    Thread.sleep(WAIT_TIME);
+                } catch (InterruptedException e) {
+                    Thread.currentThread().interrupt();
+                    // Throw a timeout exception in place of interrupted exception to avoid API
+                    // changes.
+                    throw new TimeoutException(
+                            "Read interrupted with immediate timeout via interruption.");
+                }
+                numWaits++;
+            } else {
+                numWaits = 0;
+            }
+        }
+    }
+
+    /**
+     * Write until all data in "data" is written or the connection fails or times out.
+     *
+     * <p>This uses the default time out value.
+     *
+     * @param chan the opened socket to write to.
+     * @param data the buffer to send.
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws IOException in case of I/O error on the connection.
+     */
+    public static void write(SocketChannel chan, byte[] data) throws TimeoutException, IOException {
+        write(chan, data, -1, DdmPreferences.getTimeOut());
+    }
+
+    /**
+     * Write until all data in "data" is written, the optional length is reached, the timeout
+     * expires, or the connection fails. Returns "true" if all data was written.
+     *
+     * @param chan the opened socket to write to.
+     * @param data the buffer to send.
+     * @param length the length to write or -1 to send the whole buffer.
+     * @param timeout The timeout value. A timeout of zero means "wait forever".
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws IOException in case of I/O error on the connection.
+     */
+    public static void write(SocketChannel chan, byte[] data, int length, int timeout)
+            throws TimeoutException, IOException {
+        ByteBuffer buf = ByteBuffer.wrap(data, 0, length != -1 ? length : data.length);
+        int numWaits = 0;
+
+        while (buf.position() != buf.limit()) {
+            int count;
+
+            count = chan.write(buf);
+            if (count < 0) {
+                Log.d("ddms", "write: channel EOF");
+                throw new IOException("channel EOF");
+            } else if (count == 0) {
+                // TODO: need more accurate timeout?
+                if (timeout != 0 && numWaits * WAIT_TIME > timeout) {
+                    Log.d("ddms", "write: timeout");
+                    throw new TimeoutException();
+                }
+                try {
+                    // non-blocking spin
+                    Thread.sleep(WAIT_TIME);
+                } catch (InterruptedException e) {
+                    Thread.currentThread().interrupt();
+                    // Throw a timeout exception in place of interrupted exception to avoid API
+                    // changes.
+                    throw new TimeoutException(
+                            "Write interrupted with immediate timeout via interruption.");
+                }
+                numWaits++;
+            } else {
+                numWaits = 0;
+            }
+        }
+    }
+
+    /**
+     * tells adb to talk to a specific device
+     *
+     * @param adbChan the socket connection to adb
+     * @param deviceSerialNumber the serial of the device to talk to, if null the default device
+     *     selected is the device picked by adb.
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws IOException in case of I/O error on the connection.
+     */
+    public static void setDevice(SocketChannel adbChan, String deviceSerialNumber)
+            throws TimeoutException, AdbCommandRejectedException, IOException {
+        if (Strings.isNullOrEmpty(deviceSerialNumber)) {
+            return;
+        }
+        // tell adb we're looking to talk to a specific device
+        String msg = HOST_TRANSPORT + deviceSerialNumber; // $NON-NLS-1$
+        byte[] device_query = formAdbRequest(msg);
+
+        write(adbChan, device_query);
+
+        AdbResponse resp = readAdbResponse(adbChan, false /* readDiagString */);
+        if (!resp.okay) {
+            throw createHiddenException(resp.message, true /*errorDuringDeviceSelection*/);
+        }
+    }
+
+    /**
+     * Given an {@link IDevice} grab the serial number and tell adb to talk to that device.
+     *
+     * @param adbChan the socket connection to adb.
+     * @param device the device to talk to.
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws IOException in case of I/O error on the connection.
+     */
+    public static void setDevice(SocketChannel adbChan, IDevice device)
+            throws TimeoutException, AdbCommandRejectedException, IOException {
+        // if the device is null, we early out.
+        if (device == null) {
+            return;
+        }
+        setDevice(adbChan, device.getSerialNumber());
+    }
+
+    /**
+     * Reboot the device.
+     *
+     * @param into what to reboot into (recovery, bootloader). Or null to just reboot.
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws IOException in case of I/O error on the connection.
+     */
+    public static void reboot(String into, InetSocketAddress adbSockAddr, IDevice device)
+            throws TimeoutException, AdbCommandRejectedException, IOException {
+        byte[] request;
+        if (into == null) {
+            request = formAdbRequest("reboot:"); // $NON-NLS-1$
+        } else {
+            request = formAdbRequest("reboot:" + into); // $NON-NLS-1$
+        }
+
+        SocketChannel adbChan = null;
+        try {
+            adbChan = SocketChannel.open(adbSockAddr);
+            adbChan.configureBlocking(false);
+
+            // if the device is not -1, then we first tell adb we're looking to talk
+            // to a specific device
+            setDevice(adbChan, device);
+
+            write(adbChan, request);
+        } finally {
+            if (adbChan != null) {
+                adbChan.close();
+            }
+        }
+    }
+
+    /**
+     * Ask the adb demon to become root on the device. This may silently fail, and can only succeed
+     * on developer builds. See "adb root" for more information. If you need to know if succeeded,
+     * you can check the result of executeRemoteCommand on 'echo \$USER_ID', if it is 0 then adbd is
+     * running as root.
+     *
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws IOException in case of I/O error on the connection.
+     */
+    public static void root(@NonNull InetSocketAddress adbSockAddr, @NonNull IDevice device)
+            throws TimeoutException, AdbCommandRejectedException, IOException {
+        byte[] request = formAdbRequest("root:"); // $NON-NLS-1$
+        SocketChannel adbChan = null;
+        try {
+            adbChan = SocketChannel.open(adbSockAddr);
+            adbChan.configureBlocking(false);
+
+            // if the device is not -1, then we first tell adb we're looking to talk
+            // to a specific device
+            setDevice(adbChan, device);
+
+            write(adbChan, request);
+
+            AdbResponse resp = readAdbResponse(adbChan, false /* readDiagString */);
+            if (!resp.okay) {
+                Log.w("root", "Error setting root: " + resp.message);
+                throw createHiddenException(resp.message);
+            }
+
+        } finally {
+            if (adbChan != null) {
+                adbChan.close();
+            }
+        }
+    }
+
+    public static AdbCommandRejectedException createHiddenException(String message) {
+        try {
+            Constructor<AdbCommandRejectedException> ctor =
+                    AdbCommandRejectedException.class.getDeclaredConstructor(String.class);
+            ctor.setAccessible(true);
+            return ctor.newInstance(message);
+        } catch (InstantiationException
+                | IllegalAccessException
+                | IllegalArgumentException
+                | InvocationTargetException
+                | NoSuchMethodException
+                | SecurityException e) {
+            CLog.e(e);
+            throw new CommandRejectedException(message);
+        }
+    }
+
+    public static AdbCommandRejectedException createHiddenException(
+            String message, boolean errorDuringDeviceSelection) {
+        try {
+            Constructor<AdbCommandRejectedException> ctor =
+                    AdbCommandRejectedException.class.getDeclaredConstructor(
+                            String.class, boolean.class);
+            ctor.setAccessible(true);
+            return ctor.newInstance(message, errorDuringDeviceSelection);
+        } catch (InstantiationException
+                | IllegalAccessException
+                | IllegalArgumentException
+                | InvocationTargetException
+                | NoSuchMethodException
+                | SecurityException e) {
+            CLog.e(e);
+            throw new CommandRejectedException(message);
+        }
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/AdbInitOptions.java b/device_build_interfaces/com/android/tradefed/device/server/AdbInitOptions.java
new file mode 100644
index 000000000..a958f5f99
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/AdbInitOptions.java
@@ -0,0 +1,149 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.device.server;
+
+import com.android.annotations.NonNull;
+
+import com.google.common.collect.ImmutableMap;
+
+import java.util.Map;
+
+/**
+ * Options for initialization of AndroidDebugBridge.
+ *
+ * <p>See {@link AdbInitOptions.Builder} for a list of options and their default values.
+ */
+public class AdbInitOptions {
+    /** Default init options. See {@link AdbInitOptions.Builder} for default values. */
+    public static final AdbInitOptions DEFAULT = builder().build();
+
+    /**
+     * Indicates whether or not ddmlib should actively monitor clients using JDWP.
+     *
+     * <p>Ddmlib monitors devices via ADB, but won't monitor the applications running on these
+     * devices unless <var>clientSupport</var> is enabled.
+     *
+     * <ul>
+     *   <li>When <var>clientSupport</var> == <code>true</code>:<br>
+     *       The library monitors the devices and the applications running on them. It will connect
+     *       to each application, as a debugger of sort, to be able to interact with them through
+     *       JDWP packets.
+     *   <li>When <var>clientSupport</var> == <code>false</code>:<br>
+     *       The library only monitors devices. The applications are left untouched, letting other
+     *       tools built on <code>ddmlib</code> to connect a debugger to them.
+     * </ul>
+     *
+     * <p><b>Only one client support enabled tool can run at any given time. If other tools need to
+     * communicate with the underlying ADB daemon, disable client support to avoid clobbering
+     * communications of other tools.</b>
+     *
+     * <p>Note that client support does not prevent debugging of applications running on devices. It
+     * lets debuggers connect to <code>ddmlib</code> which acts as a proxy between the debuggers and
+     * the applications to debug. See {@link ClientImpl#getDebuggerListenPort()}.
+     */
+    public final boolean clientSupport;
+
+    /**
+     * Enable user managed ADB mode where ddmlib will not start, restart, or terminate the ADB
+     * server.
+     */
+    public final boolean userManagedAdbMode;
+
+    /**
+     * ADB server port of the user managed ADB server. Only in effect when in user managed ADB mode.
+     */
+    public final int userManagedAdbPort;
+
+    /** Environment variables specifically for the ADB server process. */
+    public final ImmutableMap<String, String> adbEnvVars;
+
+    /**
+     * @return a new builder with default values.
+     */
+    public static Builder builder() {
+        return new Builder();
+    }
+
+    /** {@link AdbInitOptions.Builder} for default values. */
+    private AdbInitOptions(
+            boolean clientSupport,
+            boolean userManagedAdbMode,
+            int userManagedAdbPort,
+            ImmutableMap<String, String> adbEnvVars) {
+        this.clientSupport = clientSupport;
+        this.userManagedAdbMode = userManagedAdbMode;
+        this.userManagedAdbPort = userManagedAdbPort;
+        this.adbEnvVars = adbEnvVars;
+    }
+
+    /**
+     * Builds initialization options for ADB.
+     *
+     * <p>Default settings are:
+     *
+     * <ul>
+     *   <li>clientSupport = false
+     *   <li>userManagedAdbMode = false
+     * </ul>
+     */
+    public static class Builder {
+        boolean clientSupport = false;
+        boolean userManagedAdbMode = false;
+        int userManagedAdbPort = 0;
+        ImmutableMap.Builder<String, String> envVarBuilder = ImmutableMap.builder();
+
+        /** See {@link AdbInitOptions#clientSupport}. */
+        public Builder setClientSupportEnabled(boolean enabled) {
+            clientSupport = enabled;
+            return this;
+        }
+
+        /**
+         * See {@link AdbInitOptions#userManagedAdbMode} and {@link
+         * AdbInitOptions#userManagedAdbPort}.
+         */
+        public Builder enableUserManagedAdbMode(int port) {
+            userManagedAdbMode = true;
+            userManagedAdbPort = port;
+            return this;
+        }
+
+        /**
+         * Add an environment variable for the ADB process. Note these environment variables won't
+         * be used in user managed ADB mode because ADB server management is entirely up to the
+         * user.
+         */
+        public Builder withEnv(@NonNull String key, String value) {
+            envVarBuilder.put(key, value);
+            return this;
+        }
+
+        /**
+         * Add all environment variables from the given map for the ADB process. Note these
+         * environment variables won't be used in user managed ADB mode because ADB server
+         * management is entirely up to the user.
+         */
+        public Builder withEnv(@NonNull Map<String, String> envVars) {
+            envVarBuilder.putAll(envVars);
+            return this;
+        }
+
+        public AdbInitOptions build() {
+            return new AdbInitOptions(
+                    clientSupport, userManagedAdbMode, userManagedAdbPort, envVarBuilder.build());
+        }
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/AdbSocketUtils.java b/device_build_interfaces/com/android/tradefed/device/server/AdbSocketUtils.java
new file mode 100644
index 000000000..f459bc309
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/AdbSocketUtils.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.device.server;
+
+import com.android.annotations.NonNull;
+
+import com.google.common.io.ByteArrayDataOutput;
+import com.google.common.io.ByteStreams;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.SocketChannel;
+import java.nio.charset.Charset;
+
+public class AdbSocketUtils {
+
+    /**
+     * Fills a ByteBuffer by reading data from a socket.
+     *
+     * @throws IOException if there was not enough data to fill the buffer
+     */
+    static void read(@NonNull SocketChannel socket, @NonNull ByteBuffer buf) throws IOException {
+        while (buf.remaining() > 0) {
+            int count = socket.read(buf);
+            if (count < 0) {
+                throw new EOFException("EOF");
+            }
+        }
+    }
+
+    /**
+     * Reads data of given length from a socket.
+     *
+     * @return the content in a ByteBuffer, with the position at the beginning.
+     * @throws IOException if there was not enough data to fill the buffer
+     */
+    @NonNull
+    static ByteBuffer read(@NonNull SocketChannel socket, int length) throws IOException {
+        ByteBuffer buf = ByteBuffer.allocate(length);
+        read(socket, buf);
+        buf.rewind();
+        return buf;
+    }
+
+    /**
+     * Fills a buffer by reading data from a socket.
+     *
+     * @return the content of the buffer as a string, or null if it failed to convert the buffer.
+     * @throws IOException if there was not enough data to fill the buffer
+     */
+    @NonNull
+    static String read(@NonNull SocketChannel socket, @NonNull byte[] buffer) throws IOException {
+        ByteBuffer buf = ByteBuffer.wrap(buffer, 0, buffer.length);
+        read(socket, buf);
+        return new String(buffer, 0, buf.position(), AdbHelper.DEFAULT_CHARSET);
+    }
+
+    /**
+     * Reads the length of the next message from a socket.
+     *
+     * @param socket The {@link SocketChannel} to read from.
+     * @return the length, or 0 (zero) if no data is available from the socket.
+     * @throws IOException if the connection failed.
+     */
+    static int readLength(@NonNull SocketChannel socket, @NonNull byte[] buffer)
+            throws IOException {
+        String msg = read(socket, buffer);
+
+        if (msg != null) {
+            try {
+                return Integer.parseInt(msg, 16);
+            } catch (NumberFormatException nfe) {
+                // we'll throw an exception below.
+            }
+        }
+
+        // we receive something we can't read. It's better to reset the connection at this point.
+        throw new IOException("Unable to read length");
+    }
+
+    @NonNull
+    static String readNullTerminatedString(@NonNull SocketChannel socket) throws IOException {
+        return readNullTerminatedString(socket, AdbHelper.DEFAULT_CHARSET);
+    }
+
+    @NonNull
+    static String readNullTerminatedString(@NonNull SocketChannel socket, @NonNull Charset charset)
+            throws IOException {
+        byte[] buffer = new byte[64];
+        ByteBuffer buf = ByteBuffer.wrap(buffer, 0, buffer.length);
+        ByteArrayDataOutput output = ByteStreams.newDataOutput(64);
+        boolean end = false;
+        while (!end) {
+            buf.rewind();
+            try {
+                read(socket, buf);
+            } catch (EOFException e) {
+                end = true;
+            }
+            int nullPosition = 0;
+            for (; nullPosition < buf.position(); nullPosition++) {
+                if (buffer[nullPosition] == 0) {
+                    end = true;
+                    break;
+                }
+            }
+            output.write(buffer, 0, nullPosition);
+        }
+        return new String(output.toByteArray(), charset);
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/AdbVersion.java b/device_build_interfaces/com/android/tradefed/device/server/AdbVersion.java
new file mode 100644
index 000000000..ef2a96e4a
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/AdbVersion.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.device.server;
+
+import com.android.annotations.NonNull;
+
+import java.util.Locale;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class AdbVersion implements Comparable<AdbVersion> {
+    public static final AdbVersion UNKNOWN = new AdbVersion(-1, -1, -1);
+
+    /** Matches e.g. ".... 1.0.32" */
+    private static final Pattern ADB_VERSION_PATTERN =
+            Pattern.compile("^.*(\\d+)\\.(\\d+)\\.(\\d+).*");
+
+    public final int major;
+    public final int minor;
+    public final int micro;
+
+    private AdbVersion(int major, int minor, int micro) {
+        this.major = major;
+        this.minor = minor;
+        this.micro = micro;
+    }
+
+    @Override
+    public String toString() {
+        return String.format(Locale.US, "%1$d.%2$d.%3$d", major, minor, micro);
+    }
+
+    @Override
+    public int compareTo(@NonNull AdbVersion o) {
+        if (major != o.major) {
+            return major - o.major;
+        }
+
+        if (minor != o.minor) {
+            return minor - o.minor;
+        }
+
+        return micro - o.micro;
+    }
+
+    @NonNull
+    public static AdbVersion parseFrom(@NonNull String input) {
+        Matcher matcher = ADB_VERSION_PATTERN.matcher(input);
+        if (matcher.matches()) {
+            int major = Integer.parseInt(matcher.group(1));
+            int minor = Integer.parseInt(matcher.group(2));
+            int micro = Integer.parseInt(matcher.group(3));
+            return new AdbVersion(major, minor, micro);
+        } else {
+            return UNKNOWN;
+        }
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (o == null || getClass() != o.getClass()) {
+            return false;
+        }
+
+        AdbVersion version = (AdbVersion) o;
+
+        if (major != version.major) {
+            return false;
+        }
+        if (minor != version.minor) {
+            return false;
+        }
+        return micro == version.micro;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = major;
+        result = 31 * result + minor;
+        result = 31 * result + micro;
+        return result;
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/AllocationInfo.java b/device_build_interfaces/com/android/tradefed/device/server/AllocationInfo.java
new file mode 100644
index 000000000..ad3c44ee8
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/AllocationInfo.java
@@ -0,0 +1,248 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.server;
+
+import com.android.annotations.NonNull;
+import com.android.annotations.Nullable;
+
+import com.google.common.collect.Lists;
+
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Locale;
+
+/** Holds an Allocation information. */
+public class AllocationInfo implements IStackTraceInfo {
+    private final String mAllocatedClass;
+    private final int mAllocNumber;
+    private final int mAllocationSize;
+    private final short mThreadId;
+    private final StackTraceElement[] mStackTrace;
+
+    public enum SortMode {
+        NUMBER,
+        SIZE,
+        CLASS,
+        THREAD,
+        ALLOCATION_SITE,
+        IN_CLASS,
+        IN_METHOD
+    }
+
+    public static final class AllocationSorter implements Comparator<AllocationInfo> {
+
+        private SortMode mSortMode = SortMode.SIZE;
+        private boolean mDescending = true;
+
+        public AllocationSorter() {}
+
+        public void setSortMode(@NonNull SortMode mode) {
+            if (mSortMode == mode) {
+                mDescending = !mDescending;
+            } else {
+                mSortMode = mode;
+            }
+        }
+
+        public void setSortMode(@NonNull SortMode mode, boolean descending) {
+            mSortMode = mode;
+            mDescending = descending;
+        }
+
+        @NonNull
+        public SortMode getSortMode() {
+            return mSortMode;
+        }
+
+        public boolean isDescending() {
+            return mDescending;
+        }
+
+        @Override
+        public int compare(AllocationInfo o1, AllocationInfo o2) {
+            int diff = 0;
+            switch (mSortMode) {
+                case NUMBER:
+                    diff = o1.mAllocNumber - o2.mAllocNumber;
+                    break;
+                case SIZE:
+                    // pass, since diff is init with 0, we'll use SIZE compare below
+                    // as a back up anyway.
+                    break;
+                case CLASS:
+                    diff = o1.mAllocatedClass.compareTo(o2.mAllocatedClass);
+                    break;
+                case THREAD:
+                    diff = o1.mThreadId - o2.mThreadId;
+                    break;
+                case IN_CLASS:
+                    String class1 = o1.getFirstTraceClassName();
+                    String class2 = o2.getFirstTraceClassName();
+                    diff = compareOptionalString(class1, class2);
+                    break;
+                case IN_METHOD:
+                    String method1 = o1.getFirstTraceMethodName();
+                    String method2 = o2.getFirstTraceMethodName();
+                    diff = compareOptionalString(method1, method2);
+                    break;
+                case ALLOCATION_SITE:
+                    String desc1 = o1.getAllocationSite();
+                    String desc2 = o2.getAllocationSite();
+                    diff = compareOptionalString(desc1, desc2);
+                    break;
+            }
+
+            if (diff == 0) {
+                // same? compare on size
+                diff = o1.mAllocationSize - o2.mAllocationSize;
+            }
+
+            if (mDescending) {
+                diff = -diff;
+            }
+
+            return diff;
+        }
+
+        /** compares two strings that could be null */
+        private static int compareOptionalString(String str1, String str2) {
+            if (str1 != null) {
+                if (str2 == null) {
+                    return -1;
+                } else {
+                    return str1.compareTo(str2);
+                }
+            } else {
+                if (str2 == null) {
+                    return 0;
+                } else {
+                    return 1;
+                }
+            }
+        }
+    }
+
+    /*
+     * Simple constructor.
+     */
+    AllocationInfo(
+            int allocNumber,
+            String allocatedClass,
+            int allocationSize,
+            short threadId,
+            StackTraceElement[] stackTrace) {
+        mAllocNumber = allocNumber;
+        mAllocatedClass = allocatedClass;
+        mAllocationSize = allocationSize;
+        mThreadId = threadId;
+        mStackTrace = stackTrace;
+    }
+
+    /**
+     * Returns the allocation number. Allocations are numbered as they happen with the most recent
+     * one having the highest number
+     */
+    public int getAllocNumber() {
+        return mAllocNumber;
+    }
+
+    /** Returns the name of the allocated class. */
+    public String getAllocatedClass() {
+        return mAllocatedClass;
+    }
+
+    /** Returns the size of the allocation. */
+    public int getSize() {
+        return mAllocationSize;
+    }
+
+    /** Returns the id of the thread that performed the allocation. */
+    public short getThreadId() {
+        return mThreadId;
+    }
+
+    /*
+     * (non-Javadoc)
+     * @see com.android.ddmlib.IStackTraceInfo#getStackTrace()
+     */
+    @Override
+    public StackTraceElement[] getStackTrace() {
+        return mStackTrace;
+    }
+
+    public int compareTo(AllocationInfo otherAlloc) {
+        return otherAlloc.mAllocationSize - mAllocationSize;
+    }
+
+    @Nullable
+    public String getAllocationSite() {
+        if (mStackTrace.length > 0) {
+            return mStackTrace[0].toString();
+        }
+        return null;
+    }
+
+    public String getFirstTraceClassName() {
+        if (mStackTrace.length > 0) {
+            return mStackTrace[0].getClassName();
+        }
+
+        return null;
+    }
+
+    public String getFirstTraceMethodName() {
+        if (mStackTrace.length > 0) {
+            return mStackTrace[0].getMethodName();
+        }
+
+        return null;
+    }
+
+    /**
+     * Returns true if the given filter matches case insensitively (according to the given locale)
+     * this allocation info.
+     */
+    public boolean filter(String filter, boolean fullTrace, Locale locale) {
+        return allocatedClassMatches(filter, locale)
+                || !getMatchingStackFrames(filter, fullTrace, locale).isEmpty();
+    }
+
+    public boolean allocatedClassMatches(@NonNull String pattern, @NonNull Locale locale) {
+        return mAllocatedClass.toLowerCase(locale).contains(pattern.toLowerCase(locale));
+    }
+
+    @NonNull
+    public List<String> getMatchingStackFrames(
+            @NonNull String filter, boolean fullTrace, @NonNull Locale locale) {
+        filter = filter.toLowerCase(locale);
+        // check the top of the stack trace always
+        if (mStackTrace.length > 0) {
+            final int length = fullTrace ? mStackTrace.length : 1;
+            List<String> matchingFrames = Lists.newArrayListWithExpectedSize(length);
+            for (int i = 0; i < length; ++i) {
+                String frameString = mStackTrace[i].toString();
+                if (frameString.toLowerCase(locale).contains(filter)) {
+                    matchingFrames.add(frameString);
+                }
+            }
+            return matchingFrames;
+        } else {
+            return Collections.emptyList();
+        }
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/AllocationsParser.java b/device_build_interfaces/com/android/tradefed/device/server/AllocationsParser.java
new file mode 100644
index 000000000..f145ae99b
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/AllocationsParser.java
@@ -0,0 +1,301 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.device.server;
+
+import com.android.annotations.NonNull;
+import com.android.ddmlib.ByteBufferUtil;
+
+import java.nio.ByteBuffer;
+
+public class AllocationsParser {
+
+    /**
+     * Converts a VM class descriptor string ("Landroid/os/Debug;") to a dot-notation class name
+     * ("android.os.Debug").
+     */
+    private static String descriptorToDot(String str) {
+        // count the number of arrays.
+        int array = 0;
+        while (str.startsWith("[")) {
+            str = str.substring(1);
+            array++;
+        }
+
+        int len = str.length();
+
+        /* strip off leading 'L' and trailing ';' if appropriate */
+        if (len >= 2 && str.charAt(0) == 'L' && str.charAt(len - 1) == ';') {
+            str = str.substring(1, len - 1);
+            str = str.replace('/', '.');
+        } else {
+            // convert the basic types
+            if ("C".equals(str)) {
+                str = "char";
+            } else if ("B".equals(str)) {
+                str = "byte";
+            } else if ("Z".equals(str)) {
+                str = "boolean";
+            } else if ("S".equals(str)) {
+                str = "short";
+            } else if ("I".equals(str)) {
+                str = "int";
+            } else if ("J".equals(str)) {
+                str = "long";
+            } else if ("F".equals(str)) {
+                str = "float";
+            } else if ("D".equals(str)) {
+                str = "double";
+            }
+        }
+
+        // now add the array part
+        for (int a = 0; a < array; a++) {
+            str += "[]";
+        }
+
+        return str;
+    }
+
+    /**
+     * Reads a string table out of "data".
+     *
+     * <p>This is just a serial collection of strings, each of which is a four-byte length followed
+     * by UTF-16 data.
+     */
+    private static void readStringTable(ByteBuffer data, String[] strings) {
+        int count = strings.length;
+        int i;
+
+        for (i = 0; i < count; i++) {
+            int nameLen = data.getInt();
+            String descriptor = ByteBufferUtil.getString(data, nameLen);
+            strings[i] = descriptorToDot(descriptor);
+        }
+    }
+
+    /*
+     * Message format:
+     *   Message header (all values big-endian):
+     *     (1b) message header len (to allow future expansion); includes itself
+     *     (1b) entry header len
+     *     (1b) stack frame len
+     *     (2b) number of entries
+     *     (4b) offset to string table from start of message
+     *     (2b) number of class name strings
+     *     (2b) number of method name strings
+     *     (2b) number of source file name strings
+     *   For each entry:
+     *     (4b) total allocation size
+     *     (2b) threadId
+     *     (2b) allocated object's class name index
+     *     (1b) stack depth
+     *     For each stack frame:
+     *       (2b) method's class name
+     *       (2b) method name
+     *       (2b) method source file
+     *       (2b) line number, clipped to 32767; -2 if native; -1 if no source
+     *   (xb) class name strings
+     *   (xb) method name strings
+     *   (xb) source file strings
+     *
+     *   As with other DDM traffic, strings are sent as a 4-byte length
+     *   followed by UTF-16 data.
+     */
+    @NonNull
+    public static AllocationInfo[] parse(@NonNull ByteBuffer data) {
+        data = fixAllocOverflow(data);
+
+        int messageHdrLen, entryHdrLen, stackFrameLen;
+        int numEntries, offsetToStrings;
+        int numClassNames, numMethodNames, numFileNames;
+
+        /*
+         * Read the header.
+         */
+        messageHdrLen = (data.get() & 0xff);
+        entryHdrLen = (data.get() & 0xff);
+        stackFrameLen = (data.get() & 0xff);
+        numEntries = (data.getShort() & 0xffff);
+        offsetToStrings = data.getInt();
+        numClassNames = (data.getShort() & 0xffff);
+        numMethodNames = (data.getShort() & 0xffff);
+        numFileNames = (data.getShort() & 0xffff);
+
+        /*
+         * Skip forward to the strings and read them.
+         */
+        data.position(offsetToStrings);
+
+        String[] classNames = new String[numClassNames];
+        String[] methodNames = new String[numMethodNames];
+        String[] fileNames = new String[numFileNames];
+
+        readStringTable(data, classNames);
+        readStringTable(data, methodNames);
+        readStringTable(data, fileNames);
+
+        /*
+         * Skip back to a point just past the header and start reading
+         * entries.
+         */
+        data.position(messageHdrLen);
+
+        AllocationInfo[] allocations = new AllocationInfo[numEntries];
+        for (int i = 0; i < numEntries; i++) {
+            int totalSize;
+            int threadId, classNameIndex, stackDepth;
+
+            totalSize = data.getInt();
+            threadId = (data.getShort() & 0xffff);
+            classNameIndex = (data.getShort() & 0xffff);
+            stackDepth = (data.get() & 0xff);
+            /* we've consumed 9 bytes; gobble up any extra */
+            for (int skip = 9; skip < entryHdrLen; skip++) {
+                data.get();
+            }
+
+            StackTraceElement[] steArray = new StackTraceElement[stackDepth];
+
+            /*
+             * Pull out the stack trace.
+             */
+            for (int sti = 0; sti < stackDepth; sti++) {
+                int methodClassNameIndex, methodNameIndex;
+                int methodSourceFileIndex;
+                short lineNumber;
+                String methodClassName, methodName, methodSourceFile;
+
+                methodClassNameIndex = (data.getShort() & 0xffff);
+                methodNameIndex = (data.getShort() & 0xffff);
+                methodSourceFileIndex = (data.getShort() & 0xffff);
+                lineNumber = data.getShort();
+
+                methodClassName = classNames[methodClassNameIndex];
+                methodName = methodNames[methodNameIndex];
+                methodSourceFile = fileNames[methodSourceFileIndex];
+
+                steArray[sti] =
+                        new StackTraceElement(
+                                methodClassName, methodName, methodSourceFile, lineNumber);
+
+                /* we've consumed 8 bytes; gobble up any extra */
+                for (int skip = 8; skip < stackFrameLen; skip++) {
+                    data.get();
+                }
+            }
+
+            allocations[i] =
+                    new AllocationInfo(
+                            numEntries - i,
+                            classNames[classNameIndex],
+                            totalSize,
+                            (short) threadId,
+                            steArray);
+        }
+        return allocations;
+    }
+
+    /**
+     * In older versions of Android, there is a bug where the .alloc file will allow the header
+     * field "number of entries" to overflow by 1. This results in the parser thinking there are 0
+     * entries when there are actually 65536 entries in the file (the field is encoded in an
+     * unsigned short).
+     *
+     * <p>This method fixes the entries field if it has overflowed.
+     *
+     * @param original The original data buffer holding the contents of the .alloc file.
+     * @return the original buffer (rewound) if the contents are not affected by the bug, otherwise
+     *     a new buffer with the patched contents.
+     */
+    @NonNull
+    private static ByteBuffer fixAllocOverflow(@NonNull ByteBuffer original) {
+        ByteBuffer output = ByteBuffer.allocate(original.capacity());
+
+        int messageHdrLen = (original.get() & 0xff);
+        output.put((byte) messageHdrLen); // note &0xff upconverts the byte to an int
+        int entryHdrLen = (original.get() & 0xff);
+        output.put((byte) entryHdrLen);
+        int stackFrameLen = (original.get() & 0xff);
+        output.put((byte) stackFrameLen);
+
+        int numEntries = (original.getShort() & 0xffff);
+        if (numEntries != 0) {
+            original.rewind();
+            return original;
+        }
+
+        int offsetToStrings = original.getInt();
+        if (offsetToStrings - messageHdrLen < entryHdrLen + stackFrameLen) {
+            original.rewind();
+            return original;
+        } else {
+            numEntries = 65535;
+            output.putShort((short) numEntries);
+            output.putInt(offsetToStrings);
+        }
+
+        int numClassNames = (original.getShort() & 0xffff);
+        output.putShort((short) numClassNames);
+        int numMethodNames = (original.getShort() & 0xffff);
+        output.putShort((short) numMethodNames);
+        int numFileNames = (original.getShort() & 0xffff);
+        output.putShort((short) numFileNames);
+        for (int i = output.position(); i < messageHdrLen; ++i) {
+            output.put((byte) 0);
+        }
+
+        original.position(messageHdrLen);
+        for (int i = 0; i < numEntries; i++) {
+            int classNameIndex, stackDepth;
+
+            output.putInt(original.getInt());
+            output.putShort(original.getShort());
+            output.putShort(original.getShort());
+            stackDepth = (original.get() & 0xff);
+            output.put((byte) stackDepth);
+
+            // we've consumed 9 bytes; gobble up any extra
+            for (int skip = 9; skip < entryHdrLen; skip++) {
+                output.put(original.get());
+            }
+
+            for (int sti = 0; sti < stackDepth; sti++) {
+                output.putShort(original.getShort());
+                output.putShort(original.getShort());
+                output.putShort(original.getShort());
+                output.putShort(original.getShort());
+
+                // we've consumed 8 bytes; gobble up any extra
+                for (int skip = 8; skip < stackFrameLen; skip++) {
+                    output.put(original.get());
+                }
+            }
+        }
+
+        original.position(offsetToStrings);
+        int stringOffset = output.position();
+        while (original.hasRemaining()) {
+            output.put(original.get());
+        }
+        int end = output.position();
+        output.position(5);
+        output.putInt(stringOffset);
+        output.position(end);
+        output.flip();
+
+        return output;
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/AndroidDebugBridge.java b/device_build_interfaces/com/android/tradefed/device/server/AndroidDebugBridge.java
new file mode 100644
index 000000000..a7b22098a
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/AndroidDebugBridge.java
@@ -0,0 +1,1623 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.server;
+
+import com.android.annotations.NonNull;
+import com.android.annotations.Nullable;
+import com.android.ddmlib.DdmPreferences;
+import com.android.ddmlib.IDevice;
+import com.android.ddmlib.Log.LogLevel;
+import com.android.tradefed.device.server.jdwp.chunkhandler.HandleAppName;
+import com.android.tradefed.device.server.jdwp.chunkhandler.HandleHeap;
+import com.android.tradefed.device.server.jdwp.chunkhandler.HandleHello;
+import com.android.tradefed.device.server.jdwp.chunkhandler.HandleNativeHeap;
+import com.android.tradefed.device.server.jdwp.chunkhandler.HandleProfiling;
+import com.android.tradefed.device.server.jdwp.chunkhandler.HandleTest;
+import com.android.tradefed.device.server.jdwp.chunkhandler.HandleThread;
+import com.android.tradefed.device.server.jdwp.chunkhandler.HandleViewDebug;
+import com.android.tradefed.device.server.jdwp.chunkhandler.HandleWait;
+import com.android.tradefed.log.Log;
+import com.android.tradefed.log.LogUtil.CLog;
+
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.base.Joiner;
+import com.google.common.base.Preconditions;
+import com.google.common.base.Throwables;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Sets;
+import com.google.common.io.Closeables;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.ListeningExecutorService;
+import com.google.common.util.concurrent.SettableFuture;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.lang.Thread.State;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.nio.channels.SocketChannel;
+import java.nio.charset.StandardCharsets;
+import java.security.InvalidParameterException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.Collectors;
+
+/**
+ * A connection to the host-side android debug bridge (adb)
+ *
+ * <p>This is the central point to communicate with any devices, emulators, or the applications
+ * running on them.
+ *
+ * <p><b>{@link #init} must be called before anything is done.</b>
+ */
+public class AndroidDebugBridge {
+    /**
+     * Minimum and maximum version of adb supported. This correspond to ADB_SERVER_VERSION found in
+     * //device/tools/adb/adb.h
+     */
+    public static final AdbVersion MIN_ADB_VERSION = AdbVersion.parseFrom("1.0.20");
+
+    /** Default timeout used when starting the ADB server */
+    public static final int DEFAULT_START_ADB_TIMEOUT_MILLIS = 20_000;
+
+    private static final String ADB = "adb"; // $NON-NLS-1$
+    private static final String DDMS = "ddms"; // $NON-NLS-1$
+    private static final String SERVER_PORT_ENV_VAR = "ANDROID_ADB_SERVER_PORT"; // $NON-NLS-1$
+
+    // Where to find the ADB bridge.
+    static final int DEFAULT_ADB_PORT = 5037;
+
+    // ADB exit value when no Universal C Runtime on Windows
+    private static final int STATUS_DLL_NOT_FOUND = (int) (long) 0xc0000135;
+
+    // Only set when in unit testing mode. This is a hack until we move to devicelib.
+    // http://b.android.com/221925
+    private static boolean sUnitTestMode;
+
+    /** Port where adb server will be started */
+    private static int sAdbServerPort = 0;
+
+    /** Don't automatically manage ADB server. */
+    private static boolean sUserManagedAdbMode = false;
+
+    private static final Object sLastKnownGoodAddressLock = new Object();
+
+    /** Last known good {@link InetSocketAddress} to ADB. */
+    private static InetSocketAddress sLastKnownGoodAddress;
+
+    private static AndroidDebugBridge sThis;
+    private static boolean sInitialized = false;
+    private static boolean sClientSupport;
+    private static Map<String, String> sAdbEnvVars; // env vars to set while launching adb
+
+    /** Full path to adb. */
+    private String mAdbOsLocation = null;
+
+    private boolean mVersionCheck;
+
+    private boolean mStarted = false;
+
+    private DeviceMonitor mDeviceMonitor;
+
+    // lock object for synchronization
+    private static final Object sLock = new Object();
+
+    private static final Set<IDebugBridgeChangeListener> sBridgeListeners =
+            Sets.newCopyOnWriteArraySet();
+
+    private static final Set<IDeviceChangeListener> sDeviceListeners =
+            Sets.newCopyOnWriteArraySet();
+    private static final Set<IClientChangeListener> sClientListeners =
+            Sets.newCopyOnWriteArraySet();
+
+    /**
+     * Classes which implement this interface provide a method that deals with {@link
+     * AndroidDebugBridge} changes (including restarts).
+     */
+    public interface IDebugBridgeChangeListener {
+        /**
+         * Sent when a new {@link AndroidDebugBridge} is connected.
+         *
+         * <p>This is sent from a non UI thread.
+         *
+         * @param bridge the new {@link AndroidDebugBridge} object, null if there were errors while
+         *     initializing the bridge
+         */
+        void bridgeChanged(@Nullable AndroidDebugBridge bridge);
+
+        /**
+         * Sent before trigger a restart.
+         *
+         * <p>Note: Callback is inside a synchronized block so handler should be fast.
+         */
+        default void restartInitiated() {}
+
+        /**
+         * Sent when a restarted is finished.
+         *
+         * <p>Note: Callback is inside a synchronized block so handler should be fast.
+         *
+         * @param isSuccessful if the bridge is successfully restarted.
+         */
+        default void restartCompleted(boolean isSuccessful) {}
+    }
+
+    /**
+     * Classes which implement this interface provide methods that deal with {@link IDevice}
+     * addition, deletion, and changes.
+     */
+    public interface IDeviceChangeListener {
+        /**
+         * Sent when the a device is connected to the {@link AndroidDebugBridge}.
+         *
+         * <p>This is sent from a non UI thread.
+         *
+         * @param device the new device.
+         */
+        void deviceConnected(@NonNull IDevice device);
+
+        /**
+         * Sent when the a device is connected to the {@link AndroidDebugBridge}.
+         *
+         * <p>This is sent from a non UI thread.
+         *
+         * @param device the new device.
+         */
+        void deviceDisconnected(@NonNull IDevice device);
+
+        /**
+         * Sent when a device data changed, or when clients are started/terminated on the device.
+         *
+         * <p>This is sent from a non UI thread.
+         *
+         * @param device the device that was updated.
+         * @param changeMask the mask describing what changed. It can contain any of the following
+         *     values: {@link IDevice#CHANGE_BUILD_INFO}, {@link IDevice#CHANGE_STATE}, {@link
+         *     IDevice#CHANGE_CLIENT_LIST}
+         */
+        void deviceChanged(@NonNull IDevice device, int changeMask);
+    }
+
+    /**
+     * Classes which implement this interface provide methods that deal with {@link ClientImpl}
+     * changes.
+     */
+    public interface IClientChangeListener {
+        /**
+         * Sent when an existing client information changed.
+         *
+         * <p>This is sent from a non UI thread.
+         *
+         * @param client the updated client.
+         * @param changeMask the bit mask describing the changed properties. It can contain any of
+         *     the following values: {@link ClientImpl#CHANGE_INFO}, {@link
+         *     ClientImpl#CHANGE_DEBUGGER_STATUS}, {@link ClientImpl#CHANGE_THREAD_MODE}, {@link
+         *     ClientImpl#CHANGE_THREAD_DATA}, {@link ClientImpl#CHANGE_HEAP_MODE}, {@link
+         *     ClientImpl#CHANGE_HEAP_DATA}, {@link ClientImpl#CHANGE_NATIVE_HEAP_DATA}
+         */
+        void clientChanged(@NonNull Client client, int changeMask);
+    }
+
+    /**
+     * Initialized the library only if needed; deprecated for non-test usages.
+     *
+     * @param clientSupport Indicates whether the library should enable the monitoring and
+     *     interaction with applications running on the devices.
+     * @see #init(boolean)
+     */
+    @Deprecated
+    public static synchronized void initIfNeeded(boolean clientSupport) {
+        if (sInitialized) {
+            return;
+        }
+        init(clientSupport);
+    }
+
+    /**
+     * Initializes the <code>ddm</code> library.
+     *
+     * <p>This must be called once <b>before</b> any call to {@link #createBridge(String, boolean)}.
+     *
+     * <p>The preferences of <code>ddmlib</code> should also be initialized with whatever default
+     * values were changed from the default values.
+     *
+     * <p>When the application quits, {@link #terminate()} should be called.
+     *
+     * @param clientSupport Indicates whether the library should enable the monitoring and
+     *     interaction with applications running on the devices.
+     * @see AndroidDebugBridge#createBridge(String, boolean)
+     * @see DdmPreferences
+     */
+    public static synchronized void init(boolean clientSupport) {
+        init(clientSupport, false, ImmutableMap.of());
+    }
+
+    /**
+     * Similar to {@link #init(boolean)}, with ability to enable libusb and pass a custom set of
+     * env. variables.
+     */
+    public static synchronized void init(
+            boolean clientSupport, boolean useLibusb, @NonNull Map<String, String> env) {
+        init(
+                AdbInitOptions.builder()
+                        .withEnv(env)
+                        .setClientSupportEnabled(clientSupport)
+                        .withEnv("ADB_LIBUSB", useLibusb ? "1" : "0")
+                        .build());
+    }
+
+    /** Similar to {@link #init(boolean)}, with ability to pass a custom set of env. variables. */
+    public static synchronized void init(AdbInitOptions options) {
+        Preconditions.checkState(
+                !sInitialized, "AndroidDebugBridge.init() has already been called.");
+        sInitialized = true;
+        sClientSupport = options.clientSupport;
+        sAdbEnvVars = options.adbEnvVars;
+        sUserManagedAdbMode = options.userManagedAdbMode;
+        sLastKnownGoodAddress = null;
+
+        // Determine port and instantiate socket address.
+        initAdbPort(options.userManagedAdbPort);
+
+        MonitorThread monitorThread = MonitorThread.createInstance();
+        monitorThread.start();
+
+        HandleHello.register(monitorThread);
+        HandleAppName.register(monitorThread);
+        HandleTest.register(monitorThread);
+        HandleThread.register(monitorThread);
+        HandleHeap.register(monitorThread);
+        HandleWait.register(monitorThread);
+        HandleProfiling.register(monitorThread);
+        HandleNativeHeap.register(monitorThread);
+        HandleViewDebug.register(monitorThread);
+    }
+
+    @VisibleForTesting
+    public static void enableFakeAdbServerMode(int port) {
+        Preconditions.checkState(
+                !sInitialized,
+                "AndroidDebugBridge.init() has already been called or "
+                        + "terminate() has not been called yet.");
+        sUnitTestMode = true;
+        sAdbServerPort = port;
+    }
+
+    @VisibleForTesting
+    public static void disableFakeAdbServerMode() {
+        Preconditions.checkState(
+                !sInitialized,
+                "AndroidDebugBridge.init() has already been called or "
+                        + "terminate() has not been called yet.");
+        sUnitTestMode = false;
+        sAdbServerPort = 0;
+    }
+
+    /** Terminates the ddm library. This must be called upon application termination. */
+    public static synchronized void terminate() {
+        // kill the monitoring services
+        if (sThis != null && sThis.mDeviceMonitor != null) {
+            sThis.mDeviceMonitor.stop();
+            sThis.mDeviceMonitor = null;
+        }
+
+        MonitorThread monitorThread = MonitorThread.getInstance();
+        if (monitorThread != null) {
+            monitorThread.quit();
+        }
+
+        sInitialized = false;
+        sThis = null;
+        sLastKnownGoodAddress = null;
+    }
+
+    /**
+     * Returns whether the ddmlib is setup to support monitoring and interacting with {@link
+     * ClientImpl}s running on the {@link IDevice}s.
+     */
+    public static boolean getClientSupport() {
+        return sClientSupport;
+    }
+
+    /**
+     * Returns the socket address of the ADB server on the host.
+     *
+     * <p>This method will try to return a socket address that's known to work by opening a socket
+     * channel to the ADB server. Both IPv4 and IPv6 loopback-address will be attempted. In the
+     * event where neither could connect, this method will fallback to returning the
+     * loopback-address preferred by the JVM. This fallback logic is required to prevent API
+     * breakage.
+     *
+     * <p>If fake ADB server mode is enabled, this method will automatically fallback to legacy
+     * implementation without attempting to connect to ADB.
+     *
+     * @deprecated This method returns a loopback server address that may not match what's used by
+     *     the ADB server. i.e. the JVM may be in IPv4 mode while the ADB server is hosted on the
+     *     IPv6 loopback address. Prefer {@link #openConnection()} instead when opening a connection
+     *     to the ADB server.
+     */
+    @Deprecated
+    public static InetSocketAddress getSocketAddress() {
+        if (!sUnitTestMode) {
+            // Use synchronized access to ensure we only ever open one connection to ADB when we
+            // need to check which local address to use.
+            synchronized (sLastKnownGoodAddressLock) {
+                if (sLastKnownGoodAddress != null) {
+                    return sLastKnownGoodAddress;
+                }
+                try (SocketChannel adbChannel = openConnection()) {
+                    // SocketAddress from adbChannel is created by openConnection and should always
+                    // be an InetSocketAddress.
+                    sLastKnownGoodAddress = (InetSocketAddress) adbChannel.getRemoteAddress();
+                    return sLastKnownGoodAddress;
+                } catch (IOException e) {
+                    // Ignore the failure and fallback to old implementation.
+                }
+            }
+        }
+        return new InetSocketAddress(InetAddress.getLoopbackAddress(), sAdbServerPort);
+    }
+
+    /**
+     * Attempts to connect to the local android debug bridge server.
+     *
+     * @return a connected socket if success
+     * @throws IOException should errors occur when opening the connection
+     */
+    public static SocketChannel openConnection() throws IOException {
+        SocketChannel adbChannel;
+        try {
+            adbChannel = SocketChannel.open(new InetSocketAddress("127.0.0.1", sAdbServerPort));
+        } catch (IOException ipv4Exception) {
+            // Fallback to IPv6.
+            try {
+                adbChannel = SocketChannel.open(new InetSocketAddress("::1", sAdbServerPort));
+            } catch (IOException ipv6Exception) {
+                IOException combinedException =
+                        new IOException(
+                                "Can't find adb server on port "
+                                        + sAdbServerPort
+                                        + ", IPv4 attempt: "
+                                        + ipv4Exception.getMessage()
+                                        + ", IPv6 attempt: "
+                                        + ipv6Exception.getMessage(),
+                                ipv4Exception);
+                combinedException.addSuppressed(ipv6Exception);
+                throw combinedException;
+            }
+        }
+        adbChannel.socket().setTcpNoDelay(true);
+        return adbChannel;
+    }
+
+    /**
+     * Creates a {@link AndroidDebugBridge} that is not linked to any particular executable.
+     *
+     * <p>This bridge will expect adb to be running. It will not be able to start/stop/restart adb.
+     *
+     * <p>If a bridge has already been started, it is directly returned with no changes (similar to
+     * calling {@link #getBridge()}).
+     *
+     * @return a connected bridge, or null if there were errors while creating or connecting to the
+     *     bridge
+     * @deprecated This method may hang if ADB is not responding. Use {@link #createBridge(long,
+     *     TimeUnit)} instead.
+     */
+    @Deprecated
+    @Nullable
+    public static AndroidDebugBridge createBridge() {
+        return createBridge(Long.MAX_VALUE, TimeUnit.MILLISECONDS);
+    }
+
+    /**
+     * Creates a {@link AndroidDebugBridge} that is not linked to any particular executable.
+     *
+     * <p>This bridge will expect adb to be running. It will not be able to start/stop/restart adb.
+     *
+     * <p>If a bridge has already been started, it is directly returned with no changes (similar to
+     * calling {@link #getBridge()}).
+     *
+     * @return a connected bridge, or null if there were errors while creating or connecting to the
+     *     bridge
+     */
+    @Nullable
+    public static AndroidDebugBridge createBridge(long timeout, @NonNull TimeUnit unit) {
+        AndroidDebugBridge localThis;
+        synchronized (sLock) {
+            if (sThis != null) {
+                return sThis;
+            }
+
+            try {
+                localThis = new AndroidDebugBridge();
+                if (!localThis.start(timeout, unit)) {
+                    // We return without notifying listeners, since there were no changes
+                    return null;
+                }
+            } catch (InvalidParameterException e) {
+                // We return without notifying listeners, since there were no changes
+                return null;
+            }
+
+            // Success, store static instance
+            sThis = localThis;
+        }
+
+        // Notify the listeners of the change (outside of the lock to decrease the likelihood
+        // of deadlocks)
+        for (IDebugBridgeChangeListener listener : sBridgeListeners) {
+            // we attempt to catch any exception so that a bad listener doesn't kill our thread
+            try {
+                listener.bridgeChanged(localThis);
+            } catch (Throwable t) {
+                Log.e(DDMS, t);
+            }
+        }
+
+        return localThis;
+    }
+
+    /**
+     * Creates a new debug bridge from the location of the command line tool.
+     *
+     * <p>Any existing server will be disconnected, unless the location is the same and <code>
+     * forceNewBridge</code> is set to false.
+     *
+     * @param osLocation the location of the command line tool 'adb'
+     * @param forceNewBridge force creation of a new bridge even if one with the same location
+     *     already exists.
+     * @return a connected bridge, or null if there were errors while creating or connecting to the
+     *     bridge
+     * @deprecated This method may hang if ADB is not responding. Use {@link #createBridge(String,
+     *     boolean, long, TimeUnit)} instead.
+     */
+    @Deprecated
+    @Nullable
+    public static AndroidDebugBridge createBridge(
+            @NonNull String osLocation, boolean forceNewBridge) {
+        return createBridge(osLocation, forceNewBridge, Long.MAX_VALUE, TimeUnit.MILLISECONDS);
+    }
+
+    /**
+     * Creates a new debug bridge from the location of the command line tool.
+     *
+     * <p>Any existing server will be disconnected, unless the location is the same and <code>
+     * forceNewBridge</code> is set to false.
+     *
+     * @param osLocation the location of the command line tool 'adb'
+     * @param forceNewBridge force creation of a new bridge even if one with the same location
+     *     already exists.
+     * @param timeout the maximum time to wait
+     * @param unit the time unit of the {@code timeout} argument
+     * @return a connected bridge, or null if there were errors while creating or connecting to the
+     *     bridge
+     */
+    @Nullable
+    public static AndroidDebugBridge createBridge(
+            @NonNull String osLocation,
+            boolean forceNewBridge,
+            long timeout,
+            @NonNull TimeUnit unit) {
+        AndroidDebugBridge localThis;
+        synchronized (sLock) {
+            TimeoutRemainder rem = new TimeoutRemainder(timeout, unit);
+            if (!sUnitTestMode) {
+                if (sThis != null) {
+                    if (sThis.mAdbOsLocation != null
+                            && sThis.mAdbOsLocation.equals(osLocation)
+                            && !forceNewBridge) {
+                        // We return without notifying listeners, since there were no changes
+                        return sThis;
+                    } else {
+                        // stop the current server
+                        if (!sThis.stop(rem.getRemainingUnits(), unit)) {
+                            // We return without notifying listeners, since there were no changes
+                            return null;
+                        }
+                    }
+
+                    // We are successfully stopped. We need to notify listeners in all code paths
+                    // past this point.
+                    sThis = null;
+                }
+            }
+
+            try {
+                localThis = new AndroidDebugBridge(osLocation);
+                if (!localThis.start(rem.getRemainingUnits(), unit)) {
+                    // Note: Don't return here, as we want to notify listeners
+                    localThis = null;
+                }
+            } catch (InvalidParameterException e) {
+                // Note: Don't return here, as we want to notify listeners
+                localThis = null;
+            }
+
+            // Success, store static instance
+            sThis = localThis;
+        }
+
+        // Notify the listeners of the change (outside of the lock to decrease the likelihood
+        // of deadlocks)
+        for (IDebugBridgeChangeListener listener : sBridgeListeners) {
+            // we attempt to catch any exception so that a bad listener doesn't kill our thread
+            try {
+                listener.bridgeChanged(localThis);
+            } catch (Throwable t) {
+                Log.e(DDMS, t);
+            }
+        }
+
+        return localThis;
+    }
+
+    /** Returns the current debug bridge. Can be <code>null</code> if none were created. */
+    @Nullable
+    public static AndroidDebugBridge getBridge() {
+        return sThis;
+    }
+
+    /**
+     * Disconnects the current debug bridge, and destroy the object. A new object will have to be
+     * created with {@link #createBridge(String, boolean)}.
+     *
+     * <p>This also stops the current adb host server.
+     *
+     * @deprecated This method may hang if ADB is not responding. Use {@link #disconnectBridge(long,
+     *     TimeUnit)} instead.
+     */
+    @Deprecated
+    public static void disconnectBridge() {
+        disconnectBridge(Long.MAX_VALUE, TimeUnit.MILLISECONDS);
+    }
+
+    /**
+     * Disconnects the current debug bridge, and destroy the object. A new object will have to be
+     * created with {@link #createBridge(String, boolean)}.
+     *
+     * <p>This also stops the current adb host server.
+     *
+     * @return {@code true} if the method succeeds within the specified timeout.
+     */
+    public static boolean disconnectBridge(long timeout, @NonNull TimeUnit unit) {
+        synchronized (sLock) {
+            if (sThis != null) {
+                if (!sThis.stop(timeout, unit)) {
+                    // We could not stop ADB. Assume we are still running.
+                    return false;
+                }
+                // Success, store our local instance
+                sThis = null;
+            }
+        }
+
+        // Notify the listeners of the change (outside of the lock to decrease the likelihood
+        // of deadlocks)
+        for (IDebugBridgeChangeListener listener : sBridgeListeners) {
+            // we attempt to catch any exception so that a bad listener doesn't kill our thread
+            try {
+                listener.bridgeChanged(null);
+            } catch (Throwable t) {
+                Log.e(DDMS, t);
+            }
+        }
+
+        return true;
+    }
+
+    /**
+     * Adds the listener to the collection of listeners who will be notified when a new {@link
+     * AndroidDebugBridge} is connected, by sending it one of the messages defined in the {@link
+     * IDebugBridgeChangeListener} interface.
+     *
+     * @param listener The listener which should be notified.
+     */
+    public static void addDebugBridgeChangeListener(@NonNull IDebugBridgeChangeListener listener) {
+        sBridgeListeners.add(listener);
+
+        AndroidDebugBridge localThis;
+        synchronized (sLock) {
+            localThis = sThis;
+        }
+
+        if (localThis != null) {
+            // we attempt to catch any exception so that a bad listener doesn't kill our thread
+            try {
+                listener.bridgeChanged(localThis);
+            } catch (Throwable t) {
+                Log.e(DDMS, t);
+            }
+        }
+    }
+
+    /**
+     * Removes the listener from the collection of listeners who will be notified when a new {@link
+     * AndroidDebugBridge} is started.
+     *
+     * @param listener The listener which should no longer be notified.
+     */
+    public static void removeDebugBridgeChangeListener(IDebugBridgeChangeListener listener) {
+        sBridgeListeners.remove(listener);
+    }
+
+    @VisibleForTesting
+    public static int getDebugBridgeChangeListenerCount() {
+        return sBridgeListeners.size();
+    }
+
+    /**
+     * Adds the listener to the collection of listeners who will be notified when a {@link IDevice}
+     * is connected, disconnected, or when its properties or its {@link ClientImpl} list changed, by
+     * sending it one of the messages defined in the {@link IDeviceChangeListener} interface.
+     *
+     * @param listener The listener which should be notified.
+     */
+    public static void addDeviceChangeListener(@NonNull IDeviceChangeListener listener) {
+        sDeviceListeners.add(listener);
+    }
+
+    /**
+     * Removes the listener from the collection of listeners who will be notified when a {@link
+     * IDevice} is connected, disconnected, or when its properties or its {@link ClientImpl} list
+     * changed.
+     *
+     * @param listener The listener which should no longer be notified.
+     */
+    public static void removeDeviceChangeListener(IDeviceChangeListener listener) {
+        sDeviceListeners.remove(listener);
+    }
+
+    @VisibleForTesting
+    public static int getDeviceChangeListenerCount() {
+        return sDeviceListeners.size();
+    }
+
+    /**
+     * Adds the listener to the collection of listeners who will be notified when a {@link
+     * ClientImpl} property changed, by sending it one of the messages defined in the {@link
+     * IClientChangeListener} interface.
+     *
+     * @param listener The listener which should be notified.
+     */
+    public static void addClientChangeListener(IClientChangeListener listener) {
+        sClientListeners.add(listener);
+    }
+
+    /**
+     * Removes the listener from the collection of listeners who will be notified when a {@link
+     * ClientImpl} property changes.
+     *
+     * @param listener The listener which should no longer be notified.
+     */
+    public static void removeClientChangeListener(IClientChangeListener listener) {
+        sClientListeners.remove(listener);
+    }
+
+    /**
+     * Returns the devices.
+     *
+     * @see #hasInitialDeviceList()
+     */
+    @NonNull
+    public IDevice[] getDevices() {
+        synchronized (sLock) {
+            if (mDeviceMonitor != null) {
+                return mDeviceMonitor.getDevices();
+            }
+        }
+
+        return new IDevice[0];
+    }
+
+    /**
+     * Returns whether the bridge has acquired the initial list from adb after being created.
+     *
+     * <p>Calling {@link #getDevices()} right after {@link #createBridge(String, boolean)} will
+     * generally result in an empty list. This is due to the internal asynchronous communication
+     * mechanism with <code>adb</code> that does not guarantee that the {@link IDevice} list has
+     * been built before the call to {@link #getDevices()}.
+     *
+     * <p>The recommended way to get the list of {@link IDevice} objects is to create a {@link
+     * IDeviceChangeListener} object.
+     */
+    public boolean hasInitialDeviceList() {
+        if (mDeviceMonitor != null) {
+            return mDeviceMonitor.hasInitialDeviceList();
+        }
+
+        return false;
+    }
+
+    /**
+     * Returns whether the {@link AndroidDebugBridge} object is still connected to the adb daemon.
+     */
+    public boolean isConnected() {
+        MonitorThread monitorThread = MonitorThread.getInstance();
+        if (mDeviceMonitor != null && monitorThread != null) {
+            return mDeviceMonitor.isMonitoring() && monitorThread.getState() != State.TERMINATED;
+        }
+        return false;
+    }
+
+    /**
+     * Returns the number of times the {@link AndroidDebugBridge} object attempted to connect to the
+     * adb daemon.
+     */
+    public int getConnectionAttemptCount() {
+        if (mDeviceMonitor != null) {
+            return mDeviceMonitor.getConnectionAttemptCount();
+        }
+        return -1;
+    }
+
+    /**
+     * Returns the number of times the {@link AndroidDebugBridge} object attempted to restart the
+     * adb daemon.
+     */
+    public int getRestartAttemptCount() {
+        if (mDeviceMonitor != null) {
+            return mDeviceMonitor.getRestartAttemptCount();
+        }
+        return -1;
+    }
+
+    /**
+     * Creates a new bridge.
+     *
+     * @param osLocation the location of the command line tool
+     * @throws InvalidParameterException
+     */
+    private AndroidDebugBridge(String osLocation) throws InvalidParameterException {
+        if (osLocation == null || osLocation.isEmpty()) {
+            throw new InvalidParameterException();
+        }
+        mAdbOsLocation = osLocation;
+
+        try {
+            checkAdbVersion();
+        } catch (IOException e) {
+            throw new IllegalArgumentException(e);
+        }
+    }
+
+    /** Creates a new bridge not linked to any particular adb executable. */
+    private AndroidDebugBridge() {}
+
+    /**
+     * Queries adb for its version number and checks that it is at least {@link #MIN_ADB_VERSION}.
+     */
+    private void checkAdbVersion() throws IOException {
+        // default is bad check
+        mVersionCheck = false;
+
+        if (mAdbOsLocation == null) {
+            return;
+        }
+
+        File adb = new File(mAdbOsLocation);
+        ListenableFuture<AdbVersion> future = getAdbVersion(adb);
+        AdbVersion version;
+        try {
+            version = future.get(DEFAULT_START_ADB_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
+        } catch (InterruptedException e) {
+            return;
+        } catch (java.util.concurrent.TimeoutException e) {
+            String msg = "Unable to obtain result of 'adb version'";
+            CLog.logAndDisplay(LogLevel.ERROR, ADB, msg);
+            return;
+        } catch (ExecutionException e) {
+            CLog.logAndDisplay(LogLevel.ERROR, ADB, e.getCause().getMessage());
+            Throwables.propagateIfInstanceOf(e.getCause(), IOException.class);
+            return;
+        }
+
+        if (version.compareTo(MIN_ADB_VERSION) > 0) {
+            mVersionCheck = true;
+        } else {
+            String message =
+                    String.format(
+                            "Required minimum version of adb: %1$s." + "Current version is %2$s",
+                            MIN_ADB_VERSION, version);
+            CLog.logAndDisplay(LogLevel.ERROR, ADB, message);
+        }
+    }
+
+    interface AdbOutputProcessor<T> {
+        T process(Process process, BufferedReader r) throws IOException;
+    }
+
+    /**
+     * @deprecated Use {@link #execute} which lets you inject an executor
+     */
+    @Deprecated
+    private static <T> ListenableFuture<T> runAdb(
+            @NonNull final File adb, AdbOutputProcessor<T> resultParser, String... command) {
+        final SettableFuture<T> future = SettableFuture.create();
+        new Thread(
+                        () -> {
+                            List<String> args = new ArrayList<>();
+                            args.add(adb.getPath());
+                            args.addAll(Arrays.asList(command));
+                            ProcessBuilder pb = new ProcessBuilder(args);
+                            pb.redirectErrorStream(true);
+
+                            Process p;
+                            try {
+                                p = pb.start();
+                            } catch (IOException e) {
+                                future.setException(e);
+                                return;
+                            }
+
+                            try (BufferedReader br =
+                                    new BufferedReader(new InputStreamReader(p.getInputStream()))) {
+                                future.set(resultParser.process(p, br));
+                            } catch (IOException e) {
+                                future.setException(e);
+                                return;
+                            } catch (RuntimeException e) {
+                                future.setException(e);
+                            }
+                        },
+                        "Running adb")
+                .start();
+        return future;
+    }
+
+    public static ListenableFuture<AdbVersion> getAdbVersion(@NonNull final File adb) {
+        return runAdb(
+                adb,
+                (Process process, BufferedReader br) -> {
+                    StringBuilder sb = new StringBuilder();
+                    String line;
+                    while ((line = br.readLine()) != null) {
+                        AdbVersion version = AdbVersion.parseFrom(line);
+                        if (!AdbVersion.UNKNOWN.equals(version)) {
+                            return version;
+                        }
+                        sb.append(line);
+                        sb.append('\n');
+                    }
+
+                    String errorMessage = "Unable to detect adb version";
+
+                    int exitValue = process.exitValue();
+                    if (exitValue != 0) {
+                        errorMessage += ", exit value: 0x" + Integer.toHexString(exitValue);
+
+                        // Display special message if it is the STATUS_DLL_NOT_FOUND code, and
+                        // ignore adb output
+                        // since it's empty anyway
+                        if (exitValue == STATUS_DLL_NOT_FOUND) {
+                            errorMessage +=
+                                    ". ADB depends on the Windows Universal C Runtime, which is"
+                                        + " usually installed by default via Windows Update. You"
+                                        + " may need to manually fetch and install the runtime"
+                                        + " package here:"
+                                        + " https://support.microsoft.com/en-ca/help/2999226/update-for-universal-c-runtime-in-windows";
+                            throw new RuntimeException(errorMessage);
+                        }
+                    }
+                    if (sb.length() > 0) {
+                        errorMessage += ", adb output: " + sb.toString();
+                    }
+                    throw new RuntimeException(errorMessage);
+                },
+                "version");
+    }
+
+    private static ListenableFuture<List<AdbDevice>> getRawDeviceList(@NonNull final File adb) {
+        return runAdb(
+                adb,
+                (Process process, BufferedReader br) -> {
+                    // The first line of output is a header, not part of the device list. Skip it.
+                    br.readLine();
+                    List<AdbDevice> result = new ArrayList<>();
+                    String line;
+                    while ((line = br.readLine()) != null) {
+                        AdbDevice device = AdbDevice.parseAdbLine(line);
+
+                        if (device != null) {
+                            result.add(device);
+                        }
+                    }
+
+                    return result;
+                },
+                "devices",
+                "-l");
+    }
+
+    @NonNull
+    public static ListenableFuture<String> getVirtualDeviceId(
+            @NonNull ListeningExecutorService service, @NonNull File adb, @NonNull IDevice device) {
+        List<String> command =
+                Arrays.asList(adb.toString(), "-s", device.getSerialNumber(), "emu", "avd", "id");
+
+        return execute(service, command, AndroidDebugBridge::processVirtualDeviceIdCommandOutput);
+    }
+
+    /**
+     * Processes the output of an adb -s serial emu avd id command. In the following example,
+     * Pixel_3_API_29/snap_2019-10-29_17-06-54 is the virtual device ID. It's simply the argument to
+     * the -id flag of the emulator command used to run the virtual device.
+     *
+     * <pre>
+     * $ adb -s emulator-5554 emu avd id
+     * Pixel_3_API_29/snap_2019-10-29_17-06-54
+     * OK
+     * </pre>
+     *
+     * @return the virtual device ID or the empty string if the output is unexpected
+     */
+    @NonNull
+    private static String processVirtualDeviceIdCommandOutput(
+            @NonNull Process process, @NonNull BufferedReader reader) {
+        List<String> lines = reader.lines().collect(Collectors.toList());
+
+        if (lines.size() != 2) {
+            return "";
+        }
+
+        if (!lines.get(1).equals("OK")) {
+            return "";
+        }
+
+        String result = lines.get(0);
+        assert !result.isEmpty();
+
+        return result;
+    }
+
+    @NonNull
+    private static <T> ListenableFuture<T> execute(
+            @NonNull ListeningExecutorService service,
+            @NonNull List<String> command,
+            @NonNull AdbOutputProcessor<T> processor) {
+        return service.submit(
+                () -> {
+                    ProcessBuilder builder = new ProcessBuilder(command);
+                    builder.redirectErrorStream(true);
+
+                    Process process = builder.start();
+
+                    try (BufferedReader in =
+                            new BufferedReader(
+                                    new InputStreamReader(
+                                            process.getInputStream(), StandardCharsets.UTF_8))) {
+                        return processor.process(process, in);
+                    }
+                });
+    }
+
+    /**
+     * Returns the set of devices reported by the adb command-line. This is mainly intended for the
+     * Connection Assistant or other diagnostic tools that need to validate the state of the {@link
+     * #getDevices()} list via another channel. Code that just needs to access the list of devices
+     * should call {@link #getDevices()} instead.
+     */
+    public ListenableFuture<List<AdbDevice>> getRawDeviceList() {
+        if (mAdbOsLocation == null) {
+            SettableFuture<List<AdbDevice>> result = SettableFuture.create();
+            result.set(Collections.emptyList());
+            return result;
+        }
+        File adb = new File(mAdbOsLocation);
+        return getRawDeviceList(adb);
+    }
+
+    /**
+     * Starts the debug bridge.
+     *
+     * @return true if success.
+     */
+    boolean start(long timeout, @NonNull TimeUnit unit) {
+        // Skip server start check if using user managed ADB server
+        if (!sUserManagedAdbMode) {
+            // If we are configured correctly, check if we need to start ADB
+            if (mAdbOsLocation != null && sAdbServerPort != 0) {
+                // If we don't have a valid ADB version (or if we have not checked successfully), we
+                // can't
+                // start
+                if (!mVersionCheck) {
+                    return false;
+                }
+                // Try to start adb
+                if (!startAdb(timeout, unit)) {
+                    return false;
+                }
+            }
+        }
+
+        mStarted = true;
+
+        // Start the underlying services.
+        mDeviceMonitor = new DeviceMonitor(this);
+        mDeviceMonitor.start();
+
+        return true;
+    }
+
+    /**
+     * Kills the debug bridge, and the adb host server.
+     *
+     * @return {@code true} if success within the specified timeout
+     */
+    boolean stop(long timeout, @NonNull TimeUnit unit) {
+        // if we haven't started we return true (i.e. success)
+        if (!mStarted) {
+            return true;
+        }
+
+        TimeoutRemainder rem = new TimeoutRemainder(timeout, unit);
+        // kill the monitoring services
+        if (mDeviceMonitor != null) {
+            mDeviceMonitor.stop();
+            mDeviceMonitor = null;
+        }
+
+        // Don't stop ADB when using user managed ADB server.
+        if (sUserManagedAdbMode) {
+            Log.i(DDMS, "User managed ADB mode: Not stopping ADB server");
+        } else if (!stopAdb(rem.getRemainingUnits(), unit)) {
+            return false;
+        }
+
+        mStarted = false;
+        return true;
+    }
+
+    /**
+     * Restarts adb, but not the services around it.
+     *
+     * @return true if success.
+     * @deprecated This method may hang if ADB is not responding. Use {@link #restart(long,
+     *     TimeUnit)} instead.
+     */
+    @Deprecated
+    public boolean restart() {
+        return restart(Long.MAX_VALUE, TimeUnit.MILLISECONDS);
+    }
+
+    /**
+     * Restarts adb, but not the services around it.
+     *
+     * @return true if success.
+     */
+    public boolean restart(long timeout, @NonNull TimeUnit unit) {
+        if (sUserManagedAdbMode) {
+            Log.e(ADB, "Cannot restart adb when using user managed ADB server."); // $NON-NLS-1$
+            return false;
+        }
+
+        if (mAdbOsLocation == null) {
+            Log.e(
+                    ADB,
+                    "Cannot restart adb when AndroidDebugBridge is created without the"
+                            + " location of adb."); //$NON-NLS-1$
+            return false;
+        }
+
+        if (sAdbServerPort == 0) {
+            Log.e(
+                    ADB,
+                    "ADB server port for restarting AndroidDebugBridge is not set."); // $NON-NLS-1$
+            return false;
+        }
+
+        if (!mVersionCheck) {
+            CLog.logAndDisplay(
+                    LogLevel.ERROR,
+                    ADB,
+                    "Attempting to restart adb, but version check failed!"); //$NON-NLS-1$
+            return false;
+        }
+
+        TimeoutRemainder rem = new TimeoutRemainder(timeout, unit);
+        // Notify the listeners of the change (outside of the lock to decrease the likelihood
+        // of deadlocks)
+        for (IDebugBridgeChangeListener listener : sBridgeListeners) {
+            // we attempt to catch any exception so that a bad listener doesn't kill our thread
+            try {
+                listener.restartInitiated();
+            } catch (Throwable t) {
+                Log.e(DDMS, t);
+            }
+        }
+
+        boolean isSuccessful;
+        synchronized (this) {
+            isSuccessful = stopAdb(rem.getRemainingUnits(), unit);
+            if (!isSuccessful) {
+                Log.w(ADB, "Error stopping ADB without specified timeout");
+            }
+
+            if (isSuccessful) {
+                isSuccessful = startAdb(rem.getRemainingUnits(), unit);
+            }
+
+            if (isSuccessful && mDeviceMonitor == null) {
+                mDeviceMonitor = new DeviceMonitor(this);
+                mDeviceMonitor.start();
+            }
+        }
+
+        // Notify the listeners of the change (outside of the lock to decrease the likelihood
+        // of deadlocks)
+        for (IDebugBridgeChangeListener listener : sBridgeListeners) {
+            // we attempt to catch any exception so that a bad listener doesn't kill our thread
+            try {
+                listener.restartCompleted(isSuccessful);
+            } catch (Throwable t) {
+                Log.e(DDMS, t);
+            }
+        }
+
+        return isSuccessful;
+    }
+
+    /**
+     * Notify the listener of a new {@link IDevice}.
+     *
+     * <p>The notification of the listeners is done in a synchronized block. It is important to
+     * expect the listeners to potentially access various methods of {@link IDevice} as well as
+     * {@link #getDevices()} which use internal locks.
+     *
+     * @param device the new <code>IDevice</code>.
+     */
+    public static void deviceConnected(@NonNull IDevice device) {
+        for (IDeviceChangeListener listener : sDeviceListeners) {
+            // we attempt to catch any exception so that a bad listener doesn't kill our thread
+            try {
+                listener.deviceConnected(device);
+            } catch (Throwable t) {
+                Log.e(DDMS, t);
+            }
+        }
+    }
+
+    /**
+     * Notify the listener of a disconnected {@link IDevice}.
+     *
+     * <p>The notification of the listeners is done in a synchronized block. It is important to
+     * expect the listeners to potentially access various methods of {@link IDevice} as well as
+     * {@link #getDevices()} which use internal locks.
+     *
+     * @param device the disconnected <code>IDevice</code>.
+     */
+    public static void deviceDisconnected(@NonNull IDevice device) {
+        for (IDeviceChangeListener listener : sDeviceListeners) {
+            // we attempt to catch any exception so that a bad listener doesn't kill our
+            // thread
+            try {
+                listener.deviceDisconnected(device);
+            } catch (Throwable t) {
+                Log.e(DDMS, t);
+            }
+        }
+    }
+
+    /**
+     * Notify the listener of a modified {@link IDevice}.
+     *
+     * <p>The notification of the listeners is done in a synchronized block. It is important to
+     * expect the listeners to potentially access various methods of {@link IDevice} as well as
+     * {@link #getDevices()} which use internal locks.
+     *
+     * @param device the modified <code>IDevice</code>.
+     */
+    public static void deviceChanged(@NonNull IDevice device, int changeMask) {
+        // Notify the listeners
+        for (IDeviceChangeListener listener : sDeviceListeners) {
+            // we attempt to catch any exception so that a bad listener doesn't kill our
+            // thread
+            try {
+                listener.deviceChanged(device, changeMask);
+            } catch (Throwable t) {
+                Log.e(DDMS, t);
+            }
+        }
+    }
+
+    /**
+     * Notify the listener of a modified {@link ClientImpl}.
+     *
+     * <p>The notification of the listeners is done in a synchronized block. It is important to
+     * expect the listeners to potentially access various methods of {@link IDevice} as well as
+     * {@link #getDevices()} which use internal locks.
+     *
+     * @param client the modified <code>Client</code>.
+     * @param changeMask the mask indicating what changed in the <code>Client</code>
+     */
+    public static void clientChanged(@NonNull ClientImpl client, int changeMask) {
+        // Notify the listeners
+        for (IClientChangeListener listener : sClientListeners) {
+            // we attempt to catch any exception so that a bad listener doesn't kill our
+            // thread
+            try {
+                listener.clientChanged(client, changeMask);
+            } catch (Throwable t) {
+                Log.e(DDMS, t);
+            }
+        }
+    }
+
+    /**
+     * @return If operating in user managed ADB mode where ddmlib will and should not manage the ADB
+     *     server.
+     */
+    public static boolean isUserManagedAdbMode() {
+        return sUserManagedAdbMode;
+    }
+
+    /**
+     * Starts the adb host side server. This method should not be used when using user managed ADB
+     * server as the server lifecycle should be managed by the user, not ddmlib.
+     *
+     * @return true if success
+     */
+    public synchronized boolean startAdb(long timeout, @NonNull TimeUnit unit) {
+        if (sUserManagedAdbMode) {
+            Log.e(ADB, "startADB should never be called when using user managed ADB server.");
+            return false;
+        }
+
+        if (sUnitTestMode) {
+            // in this case, we assume the FakeAdbServer was already setup by the test code
+            return true;
+        }
+
+        if (mAdbOsLocation == null) {
+            Log.e(
+                    ADB,
+                    "Cannot start adb when AndroidDebugBridge is created without the location"
+                            + " of adb."); //$NON-NLS-1$
+            return false;
+        }
+
+        if (sAdbServerPort == 0) {
+            Log.w(
+                    ADB,
+                    "ADB server port for starting AndroidDebugBridge is not set."); //$NON-NLS-1$
+            return false;
+        }
+
+        Process proc;
+        int status = -1;
+
+        String[] command = getAdbLaunchCommand("start-server");
+        String commandString = Joiner.on(' ').join(command);
+        try {
+            Log.d(DDMS, String.format("Launching '%1$s' to ensure ADB is running.", commandString));
+            ProcessBuilder processBuilder = new ProcessBuilder(command);
+            Map<String, String> env = processBuilder.environment();
+            sAdbEnvVars.forEach(env::put);
+            if (DdmPreferences.getUseAdbHost()) {
+                String adbHostValue = DdmPreferences.getAdbHostValue();
+                if (adbHostValue != null && !adbHostValue.isEmpty()) {
+                    // TODO : check that the String is a valid IP address
+                    env.put("ADBHOST", adbHostValue);
+                }
+            }
+            proc = processBuilder.start();
+
+            ArrayList<String> errorOutput = new ArrayList<String>();
+            ArrayList<String> stdOutput = new ArrayList<String>();
+            status =
+                    grabProcessOutput(
+                            proc,
+                            errorOutput,
+                            stdOutput,
+                            false /* waitForReaders */,
+                            timeout,
+                            unit);
+        } catch (IOException | InterruptedException ioe) {
+            Log.e(DDMS, "Unable to run 'adb': " + ioe.getMessage()); // $NON-NLS-1$
+            // we'll return false;
+        }
+
+        if (status != 0) {
+            Log.e(
+                    DDMS,
+                    String.format(
+                            "'%1$s' failed -- run manually if necessary",
+                            commandString)); // $NON-NLS-1$
+            return false;
+        } else {
+            Log.d(DDMS, String.format("'%1$s' succeeded", commandString)); // $NON-NLS-1$
+            return true;
+        }
+    }
+
+    private String[] getAdbLaunchCommand(String option) {
+        List<String> command = new ArrayList<String>(4);
+        command.add(mAdbOsLocation);
+        if (sAdbServerPort != DEFAULT_ADB_PORT) {
+            command.add("-P"); // $NON-NLS-1$
+            command.add(Integer.toString(sAdbServerPort));
+        }
+        command.add(option);
+        return command.toArray(new String[0]);
+    }
+
+    /**
+     * Stops the adb host side server.
+     *
+     * @return true if success
+     */
+    private synchronized boolean stopAdb(long timeout, @NonNull TimeUnit unit) {
+        if (sUserManagedAdbMode) {
+            Log.e(ADB, "stopADB should never be called when using user managed ADB server.");
+            return false;
+        }
+
+        if (mAdbOsLocation == null) {
+            Log.e(
+                    ADB,
+                    "Cannot stop adb when AndroidDebugBridge is created without the location of"
+                            + " adb.");
+            return false;
+        }
+
+        if (sAdbServerPort == 0) {
+            Log.e(ADB, "ADB server port for restarting AndroidDebugBridge is not set");
+            return false;
+        }
+
+        Process proc;
+        int status = -1;
+
+        String[] command = getAdbLaunchCommand("kill-server"); // $NON-NLS-1$
+        try {
+            proc = Runtime.getRuntime().exec(command);
+            if (proc.waitFor(timeout, unit)) {
+                status = proc.exitValue();
+            } else {
+                proc.destroy();
+                status = -1;
+            }
+        } catch (IOException ioe) {
+            // we'll return false;
+        } catch (InterruptedException ie) {
+            // we'll return false;
+        }
+
+        String commandString = Joiner.on(' ').join(command);
+        if (status != 0) {
+            Log.w(DDMS, String.format("'%1$s' failed -- run manually if necessary", commandString));
+            return false;
+        } else {
+            Log.d(DDMS, String.format("'%1$s' succeeded", commandString));
+            return true;
+        }
+    }
+
+    /**
+     * Get the stderr/stdout outputs of a process and return when the process is done. Both
+     * <b>must</b> be read or the process will block on windows.
+     *
+     * @param process The process to get the output from
+     * @param errorOutput The array to store the stderr output. cannot be null.
+     * @param stdOutput The array to store the stdout output. cannot be null.
+     * @param waitForReaders if true, this will wait for the reader threads.
+     * @return the process return code.
+     * @throws InterruptedException
+     */
+    private static int grabProcessOutput(
+            final Process process,
+            final ArrayList<String> errorOutput,
+            final ArrayList<String> stdOutput,
+            boolean waitForReaders,
+            long timeout,
+            @NonNull TimeUnit unit)
+            throws InterruptedException {
+        assert errorOutput != null;
+        assert stdOutput != null;
+
+        TimeoutRemainder rem = new TimeoutRemainder(timeout, unit);
+
+        // read the lines as they come. if null is returned, it's
+        // because the process finished
+        Thread t1 = new Thread("adb:stderr reader") { // $NON-NLS-1$
+                    @Override
+                    public void run() {
+                        // create a buffer to read the stderr output
+                        InputStreamReader is =
+                                new InputStreamReader(
+                                        process.getErrorStream(), StandardCharsets.UTF_8);
+                        BufferedReader errReader = new BufferedReader(is);
+
+                        try {
+                            while (true) {
+                                String line = errReader.readLine();
+                                if (line != null) {
+                                    Log.e(ADB, line);
+                                    errorOutput.add(line);
+                                } else {
+                                    break;
+                                }
+                            }
+                        } catch (IOException e) {
+                            // do nothing.
+                        } finally {
+                            Closeables.closeQuietly(errReader);
+                        }
+                    }
+                };
+
+        Thread t2 = new Thread("adb:stdout reader") { // $NON-NLS-1$
+                    @Override
+                    public void run() {
+                        InputStreamReader is =
+                                new InputStreamReader(
+                                        process.getInputStream(), StandardCharsets.UTF_8);
+                        BufferedReader outReader = new BufferedReader(is);
+
+                        try {
+                            while (true) {
+                                String line = outReader.readLine();
+                                if (line != null) {
+                                    Log.d(ADB, line);
+                                    stdOutput.add(line);
+                                } else {
+                                    break;
+                                }
+                            }
+                        } catch (IOException e) {
+                            // do nothing.
+                        } finally {
+                            Closeables.closeQuietly(outReader);
+                        }
+                    }
+                };
+
+        t1.start();
+        t2.start();
+
+        // it looks like on windows process#waitFor() can return
+        // before the thread have filled the arrays, so we wait for both threads and the
+        // process itself.
+        long remMillis;
+        if (waitForReaders) {
+            try {
+                remMillis = rem.getRemainingUnits(TimeUnit.MILLISECONDS);
+                if (remMillis > 0) {
+                    t1.join(remMillis);
+                }
+            } catch (InterruptedException ignored) {
+            }
+            remMillis = rem.getRemainingUnits(TimeUnit.MILLISECONDS);
+            try {
+                if (remMillis > 0) {
+                    t2.join(remMillis);
+                }
+            } catch (InterruptedException ignored) {
+            }
+        }
+
+        // get the return code from the process
+        if (process.waitFor(rem.getRemainingUnits(), unit)) {
+            return process.exitValue();
+        } else {
+            Log.w(ADB, "Process did not terminate within specified timeout, killing it");
+            process.destroyForcibly();
+            return -1;
+        }
+    }
+
+    /** Instantiates sSocketAddr with the address of the host's adb process. */
+    private static void initAdbPort(int userManagedAdbPort) {
+        // If we're in unit test mode, we already manually set sAdbServerPort.
+        if (!sUnitTestMode) {
+            if (sUserManagedAdbMode) {
+                sAdbServerPort = userManagedAdbPort;
+            } else {
+                sAdbServerPort = getAdbServerPort();
+            }
+        }
+    }
+
+    /**
+     * Returns the port where adb server should be launched. This looks at:
+     *
+     * <ol>
+     *   <li>The system property ANDROID_ADB_SERVER_PORT
+     *   <li>The environment variable ANDROID_ADB_SERVER_PORT
+     *   <li>Defaults to {@link #DEFAULT_ADB_PORT} if neither the system property nor the env var
+     *       are set.
+     * </ol>
+     *
+     * @return The port number where the host's adb should be expected or started.
+     */
+    private static int getAdbServerPort() {
+        // check system property
+        Integer prop = Integer.getInteger(SERVER_PORT_ENV_VAR);
+        if (prop != null) {
+            try {
+                return validateAdbServerPort(prop.toString());
+            } catch (IllegalArgumentException e) {
+                String msg =
+                        String.format(
+                                "Invalid value (%1$s) for ANDROID_ADB_SERVER_PORT system property.",
+                                prop);
+                Log.w(DDMS, msg);
+            }
+        }
+
+        // when system property is not set or is invalid, parse environment property
+        try {
+            String env = System.getenv(SERVER_PORT_ENV_VAR);
+            if (env != null) {
+                return validateAdbServerPort(env);
+            }
+        } catch (SecurityException ex) {
+            // A security manager has been installed that doesn't allow access to env vars.
+            // So an environment variable might have been set, but we can't tell.
+            // Let's log a warning and continue with ADB's default port.
+            // The issue is that adb would be started (by the forked process having access
+            // to the env vars) on the desired port, but within this process, we can't figure out
+            // what that port is. However, a security manager not granting access to env vars
+            // but allowing to fork is a rare and interesting configuration, so the right
+            // thing seems to be to continue using the default port, as forking is likely to
+            // fail later on in the scenario of the security manager.
+            Log.w(
+                    DDMS,
+                    "No access to env variables allowed by current security manager. "
+                            + "If you've set ANDROID_ADB_SERVER_PORT: it's being ignored.");
+        } catch (IllegalArgumentException e) {
+            String msg =
+                    String.format(
+                            "Invalid value (%1$s) for ANDROID_ADB_SERVER_PORT environment variable"
+                                    + " (%2$s).",
+                            prop, e.getMessage());
+            Log.w(DDMS, msg);
+        }
+
+        // use default port if neither are set
+        return DEFAULT_ADB_PORT;
+    }
+
+    /**
+     * Returns the integer port value if it is a valid value for adb server port
+     *
+     * @param adbServerPort adb server port to validate
+     * @return {@code adbServerPort} as a parsed integer
+     * @throws IllegalArgumentException when {@code adbServerPort} is not bigger than 0 or it is not
+     *     a number at all
+     */
+    private static int validateAdbServerPort(@NonNull String adbServerPort)
+            throws IllegalArgumentException {
+        try {
+            // C tools (adb, emulator) accept hex and octal port numbers, so need to accept them too
+            int port = Integer.decode(adbServerPort);
+            if (port <= 0 || port >= 65535) {
+                throw new IllegalArgumentException("Should be > 0 and < 65535");
+            }
+            return port;
+        } catch (NumberFormatException e) {
+            throw new IllegalArgumentException("Not a valid port number");
+        }
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/BatteryFetcher.java b/device_build_interfaces/com/android/tradefed/device/server/BatteryFetcher.java
new file mode 100644
index 000000000..1759b83db
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/BatteryFetcher.java
@@ -0,0 +1,259 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.device.server;
+
+import com.android.annotations.NonNull;
+import com.android.annotations.Nullable;
+import com.android.ddmlib.IDevice;
+import com.android.ddmlib.MultiLineReceiver;
+import com.android.tradefed.log.LogUtil.CLog;
+
+import com.google.common.util.concurrent.SettableFuture;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/** Fetches battery level from device. */
+class BatteryFetcher {
+
+    /**
+     * On Pixel 3 and Pixel 3 XL devices, the battery level reported in the UI is read from this
+     * "maximum fuel gauge" ("maxfg") file. This is a specific design of these devices.
+     */
+    private static final Set<String> Pixel3_Pixel3XL =
+            new HashSet<>(Arrays.asList("Pixel 3", "Pixel 3 XL"));
+
+    private static final String MAXFG_PATH = "/sys/class/power_supply/maxfg/capacity";
+    private static final String NORMAL_PATH = "/sys/class/power_supply/*/capacity";
+    private static final String PROP_PRODUCT_MODEL = "ro.product.model";
+
+    /** The amount of time to wait between unsuccessful battery fetch attempts. */
+    private static final long BATTERY_TIMEOUT_MS = 2 * 1000; // 2 seconds
+
+    /** Output receiver for "cat /sys/class/power_supply/.../capacity" command line. */
+    static final class SysFsBatteryLevelReceiver extends MultiLineReceiver {
+        private static final Pattern BATTERY_LEVEL = Pattern.compile("^(\\d+)[.\\s]*");
+        private Integer mBatteryLevel;
+
+        /**
+         * Get the parsed battery level.
+         *
+         * @return battery level or <code>null</code> if it cannot be determined
+         */
+        @Nullable
+        public Integer getBatteryLevel() {
+            return mBatteryLevel;
+        }
+
+        @Override
+        public boolean isCancelled() {
+            return false;
+        }
+
+        @Override
+        public void processNewLines(@NonNull String[] lines) {
+            for (String line : lines) {
+                Matcher batteryMatch = BATTERY_LEVEL.matcher(line);
+                if (batteryMatch.matches()) {
+                    if (mBatteryLevel == null) {
+                        mBatteryLevel = Integer.parseInt(batteryMatch.group(1));
+                    } else {
+                        // multiple matches, check if they are different
+                        Integer tmpLevel = Integer.parseInt(batteryMatch.group(1));
+                        if (!mBatteryLevel.equals(tmpLevel)) {
+                            CLog.w(
+                                    String.format(
+                                            "Multiple lines matched with different value; Original:"
+                                                    + " %s, Current: %s (keeping original)",
+                                            mBatteryLevel.toString(), tmpLevel.toString()));
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    /** Output receiver for "dumpsys battery" command line. */
+    private static final class BatteryReceiver extends MultiLineReceiver {
+        private static final Pattern BATTERY_LEVEL = Pattern.compile("\\s*level: (\\d+)");
+        private static final Pattern SCALE = Pattern.compile("\\s*scale: (\\d+)");
+
+        private Integer mBatteryLevel;
+        private Integer mBatteryScale;
+
+        /** Returns the parsed percent battery level, or null if not available. */
+        public @Nullable Integer getBatteryLevel() {
+            if (mBatteryLevel != null && mBatteryScale != null) {
+                return (mBatteryLevel * 100) / mBatteryScale;
+            }
+            return null;
+        }
+
+        @Override
+        public void processNewLines(@NonNull String[] lines) {
+            for (String line : lines) {
+                Matcher batteryMatch = BATTERY_LEVEL.matcher(line);
+                if (batteryMatch.matches()) {
+                    try {
+                        mBatteryLevel = Integer.parseInt(batteryMatch.group(1));
+                    } catch (NumberFormatException e) {
+                        CLog.w(
+                                String.format(
+                                        "Failed to parse %s as an integer", batteryMatch.group(1)));
+                    }
+                }
+                Matcher scaleMatch = SCALE.matcher(line);
+                if (scaleMatch.matches()) {
+                    try {
+                        mBatteryScale = Integer.parseInt(scaleMatch.group(1));
+                    } catch (NumberFormatException e) {
+                        CLog.w(
+                                String.format(
+                                        "Failed to parse %s as an integer", batteryMatch.group(1)));
+                    }
+                }
+            }
+        }
+
+        @Override
+        public boolean isCancelled() {
+            return false;
+        }
+    }
+
+    private Integer mBatteryLevel;
+    private final IDevice mDevice;
+    private long mLastSuccessTime;
+    private SettableFuture<Integer> mPendingRequest;
+
+    public BatteryFetcher(IDevice device) {
+        mDevice = device;
+    }
+
+    /**
+     * Make a possibly asynchronous request for the device's battery level
+     *
+     * @param freshness the desired recentness of battery level
+     * @param timeUnit the {@link TimeUnit} of freshness
+     * @return a {@link Future} that can be used to retrieve the battery level
+     */
+    public synchronized Future<Integer> getBattery(long freshness, TimeUnit timeUnit) {
+        SettableFuture<Integer> result;
+        if (mBatteryLevel == null || isFetchRequired(freshness, timeUnit)) {
+            if (mPendingRequest == null) {
+                // no request underway - start a new one
+                mPendingRequest = SettableFuture.create();
+                initiateBatteryQuery();
+            } else {
+                // fall through - return the already created future from the request already
+                // underway
+            }
+            result = mPendingRequest;
+        } else {
+            // cache is populated within desired freshness
+            result = SettableFuture.create();
+            result.set(mBatteryLevel);
+        }
+        return result;
+    }
+
+    private boolean isFetchRequired(long freshness, TimeUnit timeUnit) {
+        long freshnessMs = timeUnit.toMillis(freshness);
+        return (System.currentTimeMillis() - mLastSuccessTime) > freshnessMs;
+    }
+
+    private void initiateBatteryQuery() {
+        String threadName = String.format("query-battery-%s", mDevice.getSerialNumber());
+        Thread fetchThread =
+                new Thread(threadName) {
+                    @Override
+                    public void run() {
+                        Throwable exception;
+                        try {
+                            // first try to get it from sysfs
+                            SysFsBatteryLevelReceiver sysBattReceiver =
+                                    new SysFsBatteryLevelReceiver();
+                            String batteryLevelFile = NORMAL_PATH;
+                            String mProduct = mDevice.getProperty(PROP_PRODUCT_MODEL);
+                            if (Pixel3_Pixel3XL.contains(mProduct)) {
+                                batteryLevelFile = MAXFG_PATH;
+                            }
+                            mDevice.executeShellCommand(
+                                    "cat " + batteryLevelFile,
+                                    sysBattReceiver,
+                                    BATTERY_TIMEOUT_MS,
+                                    TimeUnit.MILLISECONDS);
+                            if (!setBatteryLevel(sysBattReceiver.getBatteryLevel())) {
+                                // failed! try dumpsys
+                                BatteryReceiver receiver = new BatteryReceiver();
+                                mDevice.executeShellCommand(
+                                        "dumpsys battery",
+                                        receiver,
+                                        BATTERY_TIMEOUT_MS,
+                                        TimeUnit.MILLISECONDS);
+                                if (setBatteryLevel(receiver.getBatteryLevel())) {
+                                    return;
+                                }
+                            } else {
+                                return;
+                            }
+                            exception =
+                                    new IOException(
+                                            "Unrecognized response to battery level queries");
+                        } catch (Throwable e) {
+                            exception = e;
+                        }
+                        handleBatteryLevelFailure(exception);
+                    }
+                };
+        fetchThread.setDaemon(true);
+        fetchThread.start();
+    }
+
+    private synchronized boolean setBatteryLevel(Integer batteryLevel) {
+        if (batteryLevel == null) {
+            return false;
+        }
+        mLastSuccessTime = System.currentTimeMillis();
+        mBatteryLevel = batteryLevel;
+        if (mPendingRequest != null) {
+            mPendingRequest.set(mBatteryLevel);
+        }
+        mPendingRequest = null;
+        return true;
+    }
+
+    private synchronized void handleBatteryLevelFailure(Throwable e) {
+        CLog.w(
+                String.format(
+                        "%s getting battery level for device %s: %s",
+                        e.getClass().getSimpleName(), mDevice.getSerialNumber(), e.getMessage()));
+        if (mPendingRequest != null) {
+            if (!mPendingRequest.setException(e)) {
+                // should never happen
+                CLog.e("Future.setException failed");
+                mPendingRequest.set(null);
+            }
+        }
+        mPendingRequest = null;
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/Client.java b/device_build_interfaces/com/android/tradefed/device/server/Client.java
new file mode 100644
index 000000000..9658491e4
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/Client.java
@@ -0,0 +1,172 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.device.server;
+
+import com.android.annotations.NonNull;
+import com.android.ddmlib.IDevice;
+
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * This represents a single client, usually a Dalvik VM process.
+ *
+ * <p>This class gives access to basic client information, as well as methods to perform actions on
+ * the client.
+ *
+ * <p>More detailed information, usually updated in real time, can be access through the {@link
+ * ClientData} class. Each <code>Client</code> object has its own <code>ClientData</code> accessed
+ * through {@link #getClientData()}.
+ */
+public interface Client {
+
+    int SERVER_PROTOCOL_VERSION = 1;
+
+    /** Client change bit mask: application name change */
+    int CHANGE_NAME = 0x0001;
+
+    /** Client change bit mask: debugger status change */
+    int CHANGE_DEBUGGER_STATUS = 0x0002;
+
+    /** Client change bit mask: debugger port change */
+    int CHANGE_PORT = 0x0004;
+
+    /** Client change bit mask: thread update flag change */
+    int CHANGE_THREAD_MODE = 0x0008;
+
+    /** Client change bit mask: thread data updated */
+    int CHANGE_THREAD_DATA = 0x0010;
+
+    /** Client change bit mask: heap update flag change */
+    int CHANGE_HEAP_MODE = 0x0020;
+
+    /** Client change bit mask: head data updated */
+    int CHANGE_HEAP_DATA = 0x0040;
+
+    /** Client change bit mask: native heap data updated */
+    int CHANGE_NATIVE_HEAP_DATA = 0x0080;
+
+    /** Client change bit mask: thread stack trace updated */
+    int CHANGE_THREAD_STACKTRACE = 0x0100;
+
+    /** Client change bit mask: allocation information updated */
+    int CHANGE_HEAP_ALLOCATIONS = 0x0200;
+
+    /** Client change bit mask: allocation information updated */
+    int CHANGE_HEAP_ALLOCATION_STATUS = 0x0400;
+
+    /** Client change bit mask: allocation information updated */
+    int CHANGE_METHOD_PROFILING_STATUS = 0x0800;
+
+    /** Client change bit mask: hprof data updated */
+    int CHANGE_HPROF = 0x1000;
+
+    /**
+     * Client change bit mask: combination of {@link Client#CHANGE_NAME}, {@link
+     * Client#CHANGE_DEBUGGER_STATUS}, and {@link Client#CHANGE_PORT}.
+     */
+    int CHANGE_INFO = CHANGE_NAME | CHANGE_DEBUGGER_STATUS | CHANGE_PORT;
+
+    /** Returns the {@link IDevice} on which this Client is running. */
+    IDevice getDevice();
+
+    /**
+     * Returns <code>true</code> if the client VM is DDM-aware.
+     *
+     * <p>Calling here is only allowed after the connection has been established.
+     */
+    boolean isDdmAware();
+
+    /** Returns the {@link ClientData} object containing this client information. */
+    @NonNull
+    ClientData getClientData();
+
+    /**
+     * Sends a kill message to the VM. This doesn't necessarily work if the VM is in a crashed
+     * state.
+     */
+    void kill();
+
+    /** Returns whether this {@link ClientImpl} has a valid connection to the application VM. */
+    boolean isValid();
+
+    ///////////////////////// DEBUGGER METHODS ////////////////////////////////////////////
+
+    /** Returns the debugger port for this client. */
+    int getDebuggerListenPort();
+
+    /** Returns <code>true</code> if a debugger is currently attached to the client. */
+    boolean isDebuggerAttached();
+
+    ///////////////////////// PROFILER METHODS ///////////////////////////////////////////
+    /** Forces the client to execute its garbage collector. */
+    void executeGarbageCollector();
+
+    void startMethodTracer() throws IOException;
+
+    void stopMethodTracer() throws IOException;
+
+    void startSamplingProfiler(int samplingInterval, TimeUnit timeUnit) throws IOException;
+
+    void stopSamplingProfiler() throws IOException;
+
+    /**
+     * Sends a request to the VM to send the information about all the allocations that have
+     * happened since the call to {@link #enableAllocationTracker(boolean)} with <var>enable</var>
+     * set to <code>null</code>. This is asynchronous.
+     *
+     * <p>The allocation information can be accessed by {@link ClientData#getAllocations()}. The
+     * notification that the new data is available will be received through {@link
+     * AndroidDebugBridge.IClientChangeListener#clientChanged(ClientImpl, int)} with a <code>
+     * changeMask</code> containing the mask {@link #CHANGE_HEAP_ALLOCATIONS}.
+     */
+    void requestAllocationDetails();
+
+    /**
+     * Enables or disables the Allocation tracker for this client.
+     *
+     * <p>If enabled, the VM will start tracking allocation information. A call to {@link
+     * #requestAllocationDetails()} will make the VM sends the information about all the allocations
+     * that happened between the enabling and the request.
+     *
+     * @param enable
+     * @see #requestAllocationDetails()
+     */
+    void enableAllocationTracker(boolean enabled);
+
+    /**
+     * Debugger VM mirrors can exit behind DDMLib's back, leading to various race or perma-{@link
+     * Client} loss conditions. We need to notify DDMLib that the debugger currently attached is
+     * exiting and killing its VM mirror connection.
+     */
+    void notifyVmMirrorExited();
+
+    void listViewRoots(DebugViewDumpHandler replyHandler) throws IOException;
+
+    void captureView(
+            @NonNull String viewRoot, @NonNull String view, @NonNull DebugViewDumpHandler handler)
+            throws IOException;
+
+    void dumpViewHierarchy(
+            @NonNull String viewRoot,
+            boolean skipChildren,
+            boolean includeProperties,
+            boolean useV2,
+            @NonNull DebugViewDumpHandler handler)
+            throws IOException;
+
+    void dumpDisplayList(@NonNull String viewRoot, @NonNull String view) throws IOException;
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/ClientData.java b/device_build_interfaces/com/android/tradefed/device/server/ClientData.java
new file mode 100644
index 000000000..7654057de
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/ClientData.java
@@ -0,0 +1,907 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.server;
+
+import com.android.annotations.NonNull;
+import com.android.annotations.Nullable;
+import com.android.ddmlib.IDevice;
+import com.android.tradefed.device.server.HeapSegment.HeapSegmentElement;
+
+import java.nio.BufferUnderflowException;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.TreeMap;
+import java.util.TreeSet;
+
+/** Contains the data of a {@link ClientImpl}. */
+public class ClientData {
+    /* This is a place to stash data associated with a Client, such as thread
+     * states or heap data.  ClientData maps 1:1 to Client, but it's a little
+     * cleaner if we separate the data out.
+     *
+     * Message handlers are welcome to stash arbitrary data here.
+     *
+     * IMPORTANT: The data here is written by HandleFoo methods and read by
+     * FooPanel methods, which run in different threads.  All non-trivial
+     * access should be synchronized against the ClientData object.
+     */
+
+    /** Temporary name of VM to be ignored. */
+    public static final String PRE_INITIALIZED = "<pre-initialized>"; // $NON-NLS-1$
+
+    private static final Names UNINITIALIZED = new Names(null, null, null);
+
+    public enum DebuggerStatus {
+        /**
+         * Debugger connection status: not waiting on one, not connected to one, but accepting new
+         * connections. This is the default value.
+         */
+        DEFAULT,
+        /**
+         * Debugger connection status: the application's VM is paused, waiting for a debugger to
+         * connect to it before resuming.
+         */
+        WAITING,
+        /** Debugger connection status : Debugger is connected */
+        ATTACHED,
+        /**
+         * Debugger connection status: The listening port for debugger connection failed to listen.
+         * No debugger will be able to connect.
+         */
+        ERROR
+    }
+
+    public enum AllocationTrackingStatus {
+        /**
+         * Allocation tracking status: unknown.
+         *
+         * <p>This happens right after a {@link ClientImpl} is discovered by the {@link
+         * AndroidDebugBridge}, and before the {@link ClientImpl} answered the query regarding its
+         * allocation tracking status.
+         *
+         * @see ClientImpl#requestAllocationStatus()
+         */
+        UNKNOWN,
+        /** Allocation tracking status: the {@link ClientImpl} is not tracking allocations. */
+        OFF,
+        /** Allocation tracking status: the {@link ClientImpl} is tracking allocations. */
+        ON
+    }
+
+    public enum MethodProfilingStatus {
+        /**
+         * Method profiling status: unknown.
+         *
+         * <p>This happens right after a {@link ClientImpl} is discovered by the {@link
+         * AndroidDebugBridge}, and before the {@link ClientImpl} answered the query regarding its
+         * method profiling status.
+         *
+         * @see ClientImpl#requestMethodProfilingStatus()
+         */
+        UNKNOWN,
+        /** Method profiling status: the {@link ClientImpl} is not profiling method calls. */
+        OFF,
+        /** Method profiling status: the {@link ClientImpl} is tracing method calls. */
+        TRACER_ON,
+        /** Method profiling status: the {@link ClientImpl} is being profiled via sampling. */
+        SAMPLER_ON
+    }
+
+    /**
+     * String for feature enabling starting/stopping method profiling
+     *
+     * @see #hasFeature(String)
+     */
+    public static final String FEATURE_PROFILING = "method-trace-profiling"; // $NON-NLS-1$
+
+    /**
+     * String for feature enabling direct streaming of method profiling data
+     *
+     * @see #hasFeature(String)
+     */
+    public static final String FEATURE_PROFILING_STREAMING =
+            "method-trace-profiling-streaming"; //$NON-NLS-1$
+
+    /**
+     * String for feature enabling sampling profiler.
+     *
+     * @see #hasFeature(String)
+     */
+    public static final String FEATURE_SAMPLING_PROFILER = "method-sample-profiling"; // $NON-NLS-1$
+
+    /**
+     * String for feature indicating support for tracing OpenGL calls.
+     *
+     * @see #hasFeature(String)
+     */
+    public static final String FEATURE_OPENGL_TRACING = "opengl-tracing"; // $NON-NLS-1$
+
+    /**
+     * String for feature indicating support for providing view hierarchy.
+     *
+     * @see #hasFeature(String)
+     */
+    public static final String FEATURE_VIEW_HIERARCHY = "view-hierarchy"; // $NON-NLS-1$
+
+    /**
+     * String for feature allowing to dump hprof files
+     *
+     * @see #hasFeature(String)
+     */
+    public static final String FEATURE_HPROF = "hprof-heap-dump"; // $NON-NLS-1$
+
+    /**
+     * String for feature allowing direct streaming of hprof dumps
+     *
+     * @see #hasFeature(String)
+     */
+    public static final String FEATURE_HPROF_STREAMING = "hprof-heap-dump-streaming"; // $NON-NLS-1$
+
+    @Deprecated private static IHprofDumpHandler sHprofDumpHandler;
+    private static IMethodProfilingHandler sMethodProfilingHandler;
+    private static IAllocationTrackingHandler sAllocationTrackingHandler;
+
+    // owning Client
+    private final ClientImpl mClient;
+
+    // the client's process ID
+    private final int mPid;
+
+    // Java VM identification string
+    private String mVmIdentifier;
+
+    // client's underlying package name (R+ only)
+    private String mPackageName = DeviceImpl.UNKNOWN_PACKAGE;
+
+    // client's self-description
+    private Names mClientNames = UNINITIALIZED;
+
+    // client's ABI
+    private String mAbi;
+
+    // jvm flag: currently only indicates whether checkJni is enabled
+    private String mJvmFlags;
+
+    // is the app native debuggable?
+    private boolean mNativeDebuggable = false;
+
+    // how interested are we in a debugger?
+    private DebuggerStatus mDebuggerInterest;
+
+    // List of supported features by the client.
+    private final HashSet<String> mFeatures = new HashSet<String>();
+
+    // Thread tracking (THCR, THDE).
+    private TreeMap<Integer, ThreadInfo> mThreadMap;
+
+    /** VM Heap data */
+    private final HeapData mHeapData = new HeapData();
+
+    /** Native Heap data */
+    private final HeapData mNativeHeapData = new HeapData();
+
+    /** Hprof data */
+    private HprofData mHprofData = null;
+
+    private HashMap<Integer, HeapInfo> mHeapInfoMap = new HashMap<Integer, HeapInfo>();
+
+    /**
+     * library map info. Stored here since the backtrace data is computed on a need to display
+     * basis.
+     */
+    private ArrayList<NativeLibraryMapInfo> mNativeLibMapInfo =
+            new ArrayList<NativeLibraryMapInfo>();
+
+    /** Native Alloc info list */
+    private ArrayList<NativeAllocationInfo> mNativeAllocationList =
+            new ArrayList<NativeAllocationInfo>();
+
+    private int mNativeTotalMemory;
+
+    private byte[] mAllocationsData;
+    private AllocationInfo[] mAllocations;
+    private AllocationTrackingStatus mAllocationStatus = AllocationTrackingStatus.UNKNOWN;
+
+    @Deprecated private String mPendingHprofDump;
+
+    private MethodProfilingStatus mProfilingStatus = MethodProfilingStatus.UNKNOWN;
+    private String mPendingMethodProfiling;
+
+    /**
+     * Heap Information.
+     *
+     * <p>The heap is composed of several {@link HeapSegment} objects.
+     *
+     * <p>A call to {@link #isHeapDataComplete()} will indicate if the segments (available through
+     * {@link #getHeapSegments()}) represent the full heap.
+     */
+    public static class HeapData {
+        private TreeSet<HeapSegment> mHeapSegments = new TreeSet<HeapSegment>();
+        private boolean mHeapDataComplete = false;
+        private byte[] mProcessedHeapData;
+        private Map<Integer, ArrayList<HeapSegmentElement>> mProcessedHeapMap;
+
+        /** Abandon the current list of heap segments. */
+        public synchronized void clearHeapData() {
+            /* Abandon the old segments instead of just calling .clear().
+             * This lets the user hold onto the old set if it wants to.
+             */
+            mHeapSegments = new TreeSet<HeapSegment>();
+            mHeapDataComplete = false;
+        }
+
+        /**
+         * Add raw HPSG chunk data to the list of heap segments.
+         *
+         * @param data The raw data from an HPSG chunk.
+         */
+        public synchronized void addHeapData(ByteBuffer data) {
+            HeapSegment hs;
+
+            if (mHeapDataComplete) {
+                clearHeapData();
+            }
+
+            try {
+                hs = new HeapSegment(data);
+            } catch (BufferUnderflowException e) {
+                System.err.println("Discarding short HPSG data (length " + data.limit() + ")");
+                return;
+            }
+
+            mHeapSegments.add(hs);
+        }
+
+        /** Called when all heap data has arrived. */
+        public synchronized void sealHeapData() {
+            mHeapDataComplete = true;
+        }
+
+        /** Returns whether the heap data has been sealed. */
+        public boolean isHeapDataComplete() {
+            return mHeapDataComplete;
+        }
+
+        /**
+         * Get the collected heap data, if sealed.
+         *
+         * @return The list of heap segments if the heap data has been sealed, or null if it hasn't.
+         */
+        public Collection<HeapSegment> getHeapSegments() {
+            if (isHeapDataComplete()) {
+                return mHeapSegments;
+            }
+            return null;
+        }
+
+        /**
+         * Sets the processed heap data.
+         *
+         * @param heapData The new heap data (can be null)
+         */
+        public void setProcessedHeapData(byte[] heapData) {
+            mProcessedHeapData = heapData;
+        }
+
+        /**
+         * Get the processed heap data, if present.
+         *
+         * @return the processed heap data, or null.
+         */
+        public byte[] getProcessedHeapData() {
+            return mProcessedHeapData;
+        }
+
+        public void setProcessedHeapMap(Map<Integer, ArrayList<HeapSegmentElement>> heapMap) {
+            mProcessedHeapMap = heapMap;
+        }
+
+        public Map<Integer, ArrayList<HeapSegmentElement>> getProcessedHeapMap() {
+            return mProcessedHeapMap;
+        }
+    }
+
+    public static class HeapInfo {
+        public long maxSizeInBytes;
+        public long sizeInBytes;
+        public long bytesAllocated;
+        public long objectsAllocated;
+        public long timeStamp;
+        public byte reason;
+
+        public HeapInfo(
+                long maxSizeInBytes,
+                long sizeInBytes,
+                long bytesAllocated,
+                long objectsAllocated,
+                long timeStamp,
+                byte reason) {
+            this.maxSizeInBytes = maxSizeInBytes;
+            this.sizeInBytes = sizeInBytes;
+            this.bytesAllocated = bytesAllocated;
+            this.objectsAllocated = objectsAllocated;
+            this.timeStamp = timeStamp;
+            this.reason = reason;
+        }
+    }
+
+    public static class HprofData {
+        public enum Type {
+            FILE,
+            DATA
+        }
+
+        public final Type type;
+        public final String filename;
+        public final byte[] data;
+
+        public HprofData(@NonNull String filename) {
+            type = Type.FILE;
+            this.filename = filename;
+            this.data = null;
+        }
+
+        public HprofData(@NonNull byte[] data) {
+            type = Type.DATA;
+            this.data = data;
+            this.filename = null;
+        }
+    }
+
+    /** Handlers able to act on HPROF dumps. */
+    @Deprecated
+    public interface IHprofDumpHandler {
+        /**
+         * Called when a HPROF dump succeeded.
+         *
+         * @param remoteFilePath the device-side path of the HPROF file.
+         * @param client the client for which the HPROF file was.
+         */
+        void onSuccess(String remoteFilePath, Client client);
+
+        /**
+         * Called when a HPROF dump was successful.
+         *
+         * @param data the data containing the HPROF file, streamed from the VM
+         * @param client the client that was profiled.
+         */
+        void onSuccess(byte[] data, Client client);
+
+        /**
+         * Called when a hprof dump failed to end on the VM side
+         *
+         * @param client the client that was profiled.
+         * @param message an optional (<code>null</code> ok) error message to be displayed.
+         */
+        void onEndFailure(Client client, String message);
+    }
+
+    /** Handlers able to act on Method profiling info */
+    public interface IMethodProfilingHandler {
+        /**
+         * Called when a method tracing was successful.
+         *
+         * @param remoteFilePath the device-side path of the trace file.
+         * @param client the client that was profiled.
+         */
+        void onSuccess(String remoteFilePath, Client client);
+
+        /**
+         * Called when a method tracing was successful.
+         *
+         * @param data the data containing the trace file, streamed from the VM
+         * @param client the client that was profiled.
+         */
+        void onSuccess(byte[] data, Client client);
+
+        /**
+         * Called when method tracing failed to start
+         *
+         * @param client the client that was profiled.
+         * @param message an optional (<code>null</code> ok) error message to be displayed.
+         */
+        void onStartFailure(Client client, String message);
+
+        /**
+         * Called when method tracing failed to end on the VM side
+         *
+         * @param client the client that was profiled.
+         * @param message an optional (<code>null</code> ok) error message to be displayed.
+         */
+        void onEndFailure(Client client, String message);
+    }
+
+    /*
+     * Handlers able to act on allocation tracking info
+     */
+    public interface IAllocationTrackingHandler {
+        /**
+         * Called when an allocation tracking was successful.
+         *
+         * @param data the data containing the encoded allocations. See {@link
+         *     AllocationsParser#parse(ByteBuffer)} for parsing this data.
+         * @param client the client for which allocations were tracked.
+         */
+        void onSuccess(@NonNull byte[] data, @NonNull Client client);
+    }
+
+    public void setHprofData(byte[] data) {
+        mHprofData = new HprofData(data);
+    }
+
+    public void setHprofData(String filename) {
+        mHprofData = new HprofData(filename);
+    }
+
+    public void clearHprofData() {
+        mHprofData = null;
+    }
+
+    public HprofData getHprofData() {
+        return mHprofData;
+    }
+
+    /**
+     * Sets the handler to receive notifications when an HPROF dump succeeded or failed. This method
+     * is deprecated, please register a client listener and listen for CHANGE_HPROF.
+     */
+    @Deprecated
+    public static void setHprofDumpHandler(IHprofDumpHandler handler) {
+        sHprofDumpHandler = handler;
+    }
+
+    @Deprecated
+    public static IHprofDumpHandler getHprofDumpHandler() {
+        return sHprofDumpHandler;
+    }
+
+    /**
+     * Sets the handler to receive notifications when an HPROF dump succeeded or failed. This method
+     * is deprecated, please register a client listener and listen for CHANGE_HPROF.
+     */
+    public static void setMethodProfilingHandler(IMethodProfilingHandler handler) {
+        sMethodProfilingHandler = handler;
+    }
+
+    public static IMethodProfilingHandler getMethodProfilingHandler() {
+        return sMethodProfilingHandler;
+    }
+
+    /**
+     * This method is deprecated. Please register an {@link
+     * AndroidDebugBridge.IClientChangeListener} with {@link
+     * AndroidDebugBridge#addClientChangeListener(AndroidDebugBridge.IClientChangeListener)}
+     */
+    @Deprecated
+    public static void setAllocationTrackingHandler(@NonNull IAllocationTrackingHandler handler) {
+        sAllocationTrackingHandler = handler;
+    }
+
+    @Deprecated
+    @Nullable
+    public static IAllocationTrackingHandler getAllocationTrackingHandler() {
+        return sAllocationTrackingHandler;
+    }
+
+    /** Generic constructor. */
+    public ClientData(@NonNull ClientImpl client, int pid) {
+        mClient = client;
+        mPid = pid;
+
+        mDebuggerInterest = DebuggerStatus.DEFAULT;
+        mThreadMap = new TreeMap<Integer, ThreadInfo>();
+    }
+
+    /** Returns the process ID. */
+    public int getPid() {
+        return mPid;
+    }
+
+    /** Returns the Client's VM identifier. */
+    public String getVmIdentifier() {
+        return mVmIdentifier;
+    }
+
+    /** Sets VM identifier. */
+    public void setVmIdentifier(String ident) {
+        mVmIdentifier = ident;
+    }
+
+    /**
+     * Returns the client description.
+     *
+     * <p>This is generally the name of the package defined in the <code>AndroidManifest.xml</code>.
+     *
+     * @return the client description or <code>null</code> if not the description was not yet sent
+     *     by the client.
+     */
+    @Nullable
+    public String getClientDescription() {
+        return mClientNames.mProcessName;
+    }
+
+    /**
+     * Returns the client's user id.
+     *
+     * @return user id if set, -1 otherwise
+     */
+    public int getUserId() {
+        return mClientNames.mUserId == null ? -1 : mClientNames.mUserId;
+    }
+
+    /**
+     * Returns true if the user id of this client was set. Only devices that support multiple users
+     * will actually return the user id to ddms. For other/older devices, this will not be set.
+     */
+    public boolean isValidUserId() {
+        return mClientNames != UNINITIALIZED;
+    }
+
+    /** Returns the abi flavor (32-bit or 64-bit) of the application, null if unknown or not set. */
+    @Nullable
+    public String getAbi() {
+        return mAbi;
+    }
+
+    /** Returns the VM flags in use, or null if unknown. */
+    public String getJvmFlags() {
+        return mJvmFlags;
+    }
+
+    /**
+     * Sets the process, user ID (i.e. personal vs work profile), and package names.
+     *
+     * <p>There may be a race between HELO and APNM. Rather than try to enforce ordering on the
+     * device, we just don't allow the pre-initialized name to replace a specified one.
+     */
+    public void setNames(Names names) {
+        /*
+         * The application VM is first named <pre-initialized> before being assigned
+         * its real name.
+         * Depending on the timing, we can get an APNM chunk setting this name before
+         * another one setting the final actual name. So if we get a SetClientDescription
+         * with this value we ignore it.
+         */
+        if (!names.mProcessName.isEmpty() && !PRE_INITIALIZED.equals(names.mProcessName)) {
+            mClientNames = names;
+        }
+    }
+
+    public void setAbi(String abi) {
+        mAbi = abi;
+    }
+
+    public void setJvmFlags(String jvmFlags) {
+        mJvmFlags = jvmFlags;
+    }
+
+    public boolean isNativeDebuggable() {
+        return mNativeDebuggable;
+    }
+
+    public void setNativeDebuggable(boolean nativeDebuggable) {
+        mNativeDebuggable = nativeDebuggable;
+    }
+
+    /** Returns the debugger connection status. */
+    public DebuggerStatus getDebuggerConnectionStatus() {
+        return mDebuggerInterest;
+    }
+
+    /** Sets debugger connection status. */
+    public void setDebuggerConnectionStatus(DebuggerStatus status) {
+        mDebuggerInterest = status;
+    }
+
+    /**
+     * Sets the current heap info values for the specified heap.
+     *
+     * @param heapId The heap whose info to update
+     * @param sizeInBytes The size of the heap, in bytes
+     * @param bytesAllocated The number of bytes currently allocated in the heap
+     * @param objectsAllocated The number of objects currently allocated in
+     * @param timeStamp
+     * @param reason
+     */
+    public synchronized void setHeapInfo(
+            int heapId,
+            long maxSizeInBytes,
+            long sizeInBytes,
+            long bytesAllocated,
+            long objectsAllocated,
+            long timeStamp,
+            byte reason) {
+        mHeapInfoMap.put(
+                heapId,
+                new HeapInfo(
+                        maxSizeInBytes,
+                        sizeInBytes,
+                        bytesAllocated,
+                        objectsAllocated,
+                        timeStamp,
+                        reason));
+    }
+
+    /** Returns the {@link HeapData} object for the VM. */
+    public HeapData getVmHeapData() {
+        return mHeapData;
+    }
+
+    /** Returns the {@link HeapData} object for the native code. */
+    public HeapData getNativeHeapData() {
+        return mNativeHeapData;
+    }
+
+    /**
+     * Returns an iterator over the list of known VM heap ids.
+     *
+     * <p>The caller must synchronize on the {@link ClientData} object while iterating.
+     *
+     * @return an iterator over the list of heap ids
+     */
+    public synchronized Iterator<Integer> getVmHeapIds() {
+        return mHeapInfoMap.keySet().iterator();
+    }
+
+    /**
+     * Returns the most-recent info values for the specified VM heap.
+     *
+     * @param heapId The heap whose info should be returned
+     * @return a map containing the info values for the specified heap. Returns <code>null</code> if
+     *     the heap ID is unknown.
+     */
+    public synchronized HeapInfo getVmHeapInfo(int heapId) {
+        return mHeapInfoMap.get(heapId);
+    }
+
+    /** Adds a new thread to the list. */
+    public synchronized void addThread(int threadId, String threadName) {
+        ThreadInfo attr = new ThreadInfo(threadId, threadName);
+        mThreadMap.put(threadId, attr);
+    }
+
+    /** Removes a thread from the list. */
+    public synchronized void removeThread(int threadId) {
+        mThreadMap.remove(threadId);
+    }
+
+    /**
+     * Returns the list of threads as {@link ThreadInfo} objects.
+     *
+     * <p>The list is empty until a thread update was requested with {@link
+     * ClientImpl#requestThreadUpdate()}.
+     */
+    public synchronized ThreadInfo[] getThreads() {
+        Collection<ThreadInfo> threads = mThreadMap.values();
+        return threads.toArray(new ThreadInfo[0]);
+    }
+
+    /** Returns the {@link ThreadInfo} by thread id. */
+    public synchronized ThreadInfo getThread(int threadId) {
+        return mThreadMap.get(threadId);
+    }
+
+    public synchronized void clearThreads() {
+        mThreadMap.clear();
+    }
+
+    /**
+     * Returns the list of {@link NativeAllocationInfo}.
+     *
+     * @see ClientImpl#requestNativeHeapInformation()
+     */
+    public synchronized List<NativeAllocationInfo> getNativeAllocationList() {
+        return Collections.unmodifiableList(mNativeAllocationList);
+    }
+
+    /**
+     * adds a new {@link NativeAllocationInfo} to the {@link ClientImpl}
+     *
+     * @param allocInfo The {@link NativeAllocationInfo} to add.
+     */
+    public synchronized void addNativeAllocation(NativeAllocationInfo allocInfo) {
+        mNativeAllocationList.add(allocInfo);
+    }
+
+    /** Clear the current malloc info. */
+    public synchronized void clearNativeAllocationInfo() {
+        mNativeAllocationList.clear();
+    }
+
+    /**
+     * Returns the total native memory.
+     *
+     * @see ClientImpl#requestNativeHeapInformation()
+     */
+    public synchronized int getTotalNativeMemory() {
+        return mNativeTotalMemory;
+    }
+
+    public synchronized void setTotalNativeMemory(int totalMemory) {
+        mNativeTotalMemory = totalMemory;
+    }
+
+    public synchronized void addNativeLibraryMapInfo(long startAddr, long endAddr, String library) {
+        mNativeLibMapInfo.add(new NativeLibraryMapInfo(startAddr, endAddr, library));
+    }
+
+    /** Returns the list of native libraries mapped in memory for this client. */
+    public synchronized List<NativeLibraryMapInfo> getMappedNativeLibraries() {
+        return Collections.unmodifiableList(mNativeLibMapInfo);
+    }
+
+    public synchronized void setAllocationStatus(AllocationTrackingStatus status) {
+        mAllocationStatus = status;
+    }
+
+    /**
+     * Returns the allocation tracking status.
+     *
+     * @see ClientImpl#requestAllocationStatus()
+     */
+    public synchronized AllocationTrackingStatus getAllocationStatus() {
+        return mAllocationStatus;
+    }
+
+    public synchronized void setAllocationsData(byte[] data) {
+        mAllocationsData = data;
+    }
+
+    /**
+     * Returns the raw data for tracked allocations.
+     *
+     * @see ClientImpl#requestAllocationDetails()
+     */
+    public synchronized byte[] getAllocationsData() {
+        return mAllocationsData;
+    }
+
+    @Deprecated
+    synchronized void setAllocations(AllocationInfo[] allocs) {
+        mAllocations = allocs;
+    }
+
+    /**
+     * Returns the list of tracked allocations.
+     *
+     * @see ClientImpl#requestAllocationDetails()
+     */
+    @Nullable
+    public synchronized AllocationInfo[] getAllocations() {
+        if (mAllocationsData != null) {
+            return AllocationsParser.parse(ByteBuffer.wrap(mAllocationsData));
+        }
+        return null;
+    }
+
+    public void addFeature(String feature) {
+        mFeatures.add(feature);
+    }
+
+    /**
+     * Returns true if the {@link ClientImpl} supports the given <var>feature</var>
+     *
+     * @param feature The feature to test.
+     * @return true if the feature is supported
+     * @see ClientData#FEATURE_PROFILING
+     * @see ClientData#FEATURE_HPROF
+     */
+    public boolean hasFeature(String feature) {
+        return mFeatures.contains(feature);
+    }
+
+    /**
+     * Sets the device-side path to the hprof file being written
+     *
+     * @param pendingHprofDump the file to the hprof file
+     */
+    @Deprecated
+    public void setPendingHprofDump(String pendingHprofDump) {
+        mPendingHprofDump = pendingHprofDump;
+    }
+
+    /** Returns the path to the device-side hprof file being written. */
+    @Deprecated
+    public String getPendingHprofDump() {
+        return mPendingHprofDump;
+    }
+
+    @Deprecated
+    public boolean hasPendingHprofDump() {
+        return mPendingHprofDump != null;
+    }
+
+    public synchronized void setMethodProfilingStatus(MethodProfilingStatus status) {
+        mProfilingStatus = status;
+    }
+
+    /**
+     * Returns the method profiling status.
+     *
+     * @see ClientImpl#requestMethodProfilingStatus()
+     */
+    public synchronized MethodProfilingStatus getMethodProfilingStatus() {
+        return mProfilingStatus;
+    }
+
+    /**
+     * Sets the device-side path to the method profile file being written
+     *
+     * @param pendingMethodProfiling the file being written
+     */
+    public void setPendingMethodProfiling(String pendingMethodProfiling) {
+        mPendingMethodProfiling = pendingMethodProfiling;
+    }
+
+    /** Returns the path to the device-side method profiling file being written. */
+    public String getPendingMethodProfiling() {
+        return mPendingMethodProfiling;
+    }
+
+    /**
+     * Returns the application's real package name if there is protocol support. If there is no
+     * protocol support, returns the attempted derivation of the package name from the app name (to
+     * maintain backward compatibility), or the app name if not successful.
+     */
+    @Nullable
+    public String getPackageName() {
+        // Use the reported package name if the version (R+) supports it.
+        if (mClient.getDevice().supportsFeature(IDevice.Feature.REAL_PKG_NAME)) {
+            return mClientNames.mPackageName;
+        }
+        // Try to infer the package name.
+        // Check for multi-process app name that might have a following format -
+        // "$applicationId:$processName"
+        if (mClientNames.mProcessName == null) {
+            return null;
+        }
+        int colonPos = mClientNames.mProcessName.indexOf(':');
+        return (colonPos == -1)
+                ? mClientNames.mProcessName
+                : mClientNames.mProcessName.substring(0, colonPos);
+    }
+
+    /** Returns the application's data directory. */
+    @NonNull
+    public String getDataDir() {
+        String packageName = getPackageName();
+
+        if (isValidUserId() && getUserId() > 0) {
+            return String.format("/data/user/%d/%s", getUserId(), packageName);
+        }
+        return "/data/data/" + packageName;
+    }
+
+    public static class Names {
+        public final String mProcessName;
+        public final Integer mUserId;
+        public final String mPackageName;
+
+        public Names(String processName, Integer id, String packageName) {
+            this.mProcessName = processName;
+            mUserId = id;
+            this.mPackageName = packageName;
+        }
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/ClientImpl.java b/device_build_interfaces/com/android/tradefed/device/server/ClientImpl.java
new file mode 100644
index 000000000..0008b4f8e
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/ClientImpl.java
@@ -0,0 +1,854 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.server;
+
+import com.android.annotations.NonNull;
+import com.android.ddmlib.DdmPreferences;
+import com.android.ddmlib.IDevice;
+import com.android.tradefed.device.server.AndroidDebugBridge.IClientChangeListener;
+import com.android.tradefed.device.server.jdwp.JdwpAgent;
+import com.android.tradefed.device.server.jdwp.JdwpHandshake;
+import com.android.tradefed.device.server.jdwp.JdwpProtocol;
+import com.android.tradefed.device.server.jdwp.chunkhandler.HandleExit;
+import com.android.tradefed.device.server.jdwp.chunkhandler.HandleHeap;
+import com.android.tradefed.device.server.jdwp.chunkhandler.HandleHello;
+import com.android.tradefed.device.server.jdwp.chunkhandler.HandleNativeHeap;
+import com.android.tradefed.device.server.jdwp.chunkhandler.HandleProfiling;
+import com.android.tradefed.device.server.jdwp.chunkhandler.HandleThread;
+import com.android.tradefed.device.server.jdwp.chunkhandler.HandleViewDebug;
+import com.android.tradefed.device.server.jdwp.chunkhandler.JdwpPacket;
+import com.android.tradefed.log.Log;
+
+import java.io.IOException;
+import java.nio.BufferOverflowException;
+import java.nio.ByteBuffer;
+import java.nio.channels.SelectionKey;
+import java.nio.channels.Selector;
+import java.nio.channels.SocketChannel;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * This represents a single client, usually a Dalvik VM process.
+ *
+ * <p>This class gives access to basic client information, as well as methods to perform actions on
+ * the client.
+ *
+ * <p>More detailed information, usually updated in real time, can be access through the {@link
+ * ClientData} class. Each <code>Client</code> object has its own <code>ClientData</code> accessed
+ * through {@link #getClientData()}.
+ */
+public class ClientImpl extends JdwpAgent implements Client {
+    /**
+     * Users of mChan avoid synchronization issues by taking a local instance of the channel before
+     * using it. This class-level shared instance can be nulled by any thread calling #close() so
+     * volatile is needed to ensure threads don't read stale values if mChan.
+     */
+    private volatile SocketChannel mChan;
+
+    // debugger we're associated with, if any
+    private Debugger mDebugger;
+
+    // chunk handlers stash state data in here
+    private ClientData mClientData;
+
+    // User interface state.  Changing the value causes a message to be
+    // sent to the client.
+    private boolean mThreadUpdateEnabled;
+    private boolean mHeapInfoUpdateEnabled;
+    private boolean mHeapSegmentUpdateEnabled;
+
+    /*
+     * Read/write buffers.  We can get large quantities of data from the
+     * client, e.g. the response to a "give me the list of all known classes"
+     * request from the debugger.  Requests from the debugger, and from us,
+     * are much smaller.
+     *
+     * Pass-through debugger traffic is sent without copying.  "mWriteBuffer"
+     * is only used for data generated within Client.
+     */
+    private static final int INITIAL_BUF_SIZE = 2 * 1024;
+    private ByteBuffer mReadBuffer;
+    private final int mMaxPacketSize = DdmPreferences.getJdwpMaxPacketSize();
+
+    private DeviceImpl mDevice;
+
+    private int mConnState;
+
+    private static final int ST_INIT = 1;
+    private static final int ST_NOT_JDWP = 2;
+    private static final int ST_AWAIT_SHAKE = 10;
+    private static final int ST_NEED_DDM_PKT = 11;
+    private static final int ST_NOT_DDM = 12;
+    private static final int ST_READY = 13;
+    private static final int ST_ERROR = 20;
+    private static final int ST_DISCONNECTED = 21;
+
+    /**
+     * Create an object for a new client connection.
+     *
+     * @param device the device this client belongs to
+     * @param chan the connected {@link SocketChannel}.
+     * @param pid the client pid.
+     */
+    public ClientImpl(DeviceImpl device, SocketChannel chan, int pid) {
+        super(new JdwpProtocol());
+        mDevice = device;
+        mChan = chan;
+        mReadBuffer = ByteBuffer.allocate(INITIAL_BUF_SIZE);
+
+        mConnState = ST_INIT;
+
+        mClientData = new ClientData(this, pid);
+
+        mThreadUpdateEnabled = DdmPreferences.getInitialThreadUpdate();
+        mHeapInfoUpdateEnabled = DdmPreferences.getInitialHeapUpdate();
+        mHeapSegmentUpdateEnabled = DdmPreferences.getInitialHeapUpdate();
+    }
+
+    /** Returns a string representation of the {@link ClientImpl} object. */
+    @Override
+    public String toString() {
+        return "[Client pid: " + mClientData.getPid() + "]";
+    }
+
+    /** Returns the {@link IDevice} on which this Client is running. */
+    @Override
+    public IDevice getDevice() {
+        return mDevice;
+    }
+
+    /** Returns the {@link DeviceImpl} on which this Client is running. */
+    public DeviceImpl getDeviceImpl() {
+        return mDevice;
+    }
+
+    /** Returns the debugger port for this client. */
+    @Override
+    public int getDebuggerListenPort() {
+        return getDebugger() == null ? -1 : getDebugger().getListenPort();
+    }
+
+    /**
+     * Returns <code>true</code> if the client VM is DDM-aware.
+     *
+     * <p>Calling here is only allowed after the connection has been established.
+     */
+    @Override
+    public boolean isDdmAware() {
+        switch (mConnState) {
+            case ST_INIT:
+            case ST_NOT_JDWP:
+            case ST_AWAIT_SHAKE:
+            case ST_NEED_DDM_PKT:
+            case ST_NOT_DDM:
+            case ST_ERROR:
+            case ST_DISCONNECTED:
+                return false;
+            case ST_READY:
+                return true;
+            default:
+                assert false;
+                return false;
+        }
+    }
+
+    /** Returns <code>true</code> if a debugger is currently attached to the client. */
+    @Override
+    public boolean isDebuggerAttached() {
+        return mDebugger != null && mDebugger.isDebuggerAttached();
+    }
+
+    /** Return the Debugger object associated with this client. */
+    Debugger getDebugger() {
+        return mDebugger;
+    }
+
+    /** Returns the {@link ClientData} object containing this client information. */
+    @Override
+    @NonNull
+    public ClientData getClientData() {
+        return mClientData;
+    }
+
+    /** Forces the client to execute its garbage collector. */
+    @Override
+    public void executeGarbageCollector() {
+        try {
+            HandleHeap.sendHPGC(this);
+        } catch (IOException ioe) {
+            Log.w("ddms", "Send of HPGC message failed");
+            // ignore
+        }
+    }
+
+    /**
+     * Toggles method profiling state.
+     *
+     * @deprecated Use {@link #startMethodTracer()}, {@link #stopMethodTracer()}, {@link
+     *     #startSamplingProfiler(int, TimeUnit)} or {@link #stopSamplingProfiler()} instead.
+     */
+    @Deprecated
+    public void toggleMethodProfiling() {
+        try {
+            switch (mClientData.getMethodProfilingStatus()) {
+                case TRACER_ON:
+                    stopMethodTracer();
+                    break;
+                case SAMPLER_ON:
+                    stopSamplingProfiler();
+                    break;
+                case OFF:
+                    startMethodTracer();
+                    break;
+                case UNKNOWN:
+                    Log.w("ddms", "Toggle method profiling failed");
+                    break;
+            }
+        } catch (IOException e) {
+            Log.w("ddms", "Toggle method profiling failed");
+            // ignore
+        }
+    }
+
+    private static int getProfileBufferSize() {
+        return DdmPreferences.getProfilerBufferSizeMb() * 1024 * 1024;
+    }
+
+    @Override
+    public void startMethodTracer() throws IOException {
+        boolean canStream = mClientData.hasFeature(ClientData.FEATURE_PROFILING_STREAMING);
+        int bufferSize = getProfileBufferSize();
+        if (canStream) {
+            HandleProfiling.sendMPSS(this, bufferSize, 0 /*flags*/);
+        } else {
+            String file =
+                    "/sdcard/"
+                            + mClientData.getClientDescription().replaceAll("\\:.*", "")
+                            + ".trace";
+            HandleProfiling.sendMPRS(this, file, bufferSize, 0 /*flags*/);
+        }
+    }
+
+    @Override
+    public void stopMethodTracer() throws IOException {
+        boolean canStream = mClientData.hasFeature(ClientData.FEATURE_PROFILING_STREAMING);
+
+        if (canStream) {
+            HandleProfiling.sendMPSE(this);
+        } else {
+            HandleProfiling.sendMPRE(this);
+        }
+    }
+
+    @Override
+    public void startSamplingProfiler(int samplingInterval, TimeUnit timeUnit) throws IOException {
+        int bufferSize = getProfileBufferSize();
+        HandleProfiling.sendSPSS(this, bufferSize, samplingInterval, timeUnit);
+    }
+
+    @Override
+    public void stopSamplingProfiler() throws IOException {
+        HandleProfiling.sendSPSE(this);
+    }
+
+    public boolean startOpenGlTracing() {
+        boolean canTraceOpenGl = mClientData.hasFeature(ClientData.FEATURE_OPENGL_TRACING);
+        if (!canTraceOpenGl) {
+            return false;
+        }
+
+        try {
+            HandleViewDebug.sendStartGlTracing(this);
+            return true;
+        } catch (IOException e) {
+            Log.w("ddms", "Start OpenGL Tracing failed");
+            return false;
+        }
+    }
+
+    public boolean stopOpenGlTracing() {
+        boolean canTraceOpenGl = mClientData.hasFeature(ClientData.FEATURE_OPENGL_TRACING);
+        if (!canTraceOpenGl) {
+            return false;
+        }
+
+        try {
+            HandleViewDebug.sendStopGlTracing(this);
+            return true;
+        } catch (IOException e) {
+            Log.w("ddms", "Stop OpenGL Tracing failed");
+            return false;
+        }
+    }
+
+    /**
+     * Sends a request to the VM to send the enable status of the method profiling. This is
+     * asynchronous.
+     *
+     * <p>The allocation status can be accessed by {@link ClientData#getAllocationStatus()}. The
+     * notification that the new status is available will be received through {@link
+     * IClientChangeListener#clientChanged(ClientImpl, int)} with a <code>changeMask</code>
+     * containing the mask {@link #CHANGE_HEAP_ALLOCATION_STATUS}.
+     */
+    public void requestMethodProfilingStatus() {
+        try {
+            HandleHeap.sendREAQ(this);
+        } catch (IOException e) {
+            Log.e("ddmlib", e);
+        }
+    }
+
+    /**
+     * Enables or disables the thread update.
+     *
+     * <p>If <code>true</code> the VM will be able to send thread information. Thread information
+     * must be requested with {@link #requestThreadUpdate()}.
+     *
+     * @param enabled the enable flag.
+     */
+    public void setThreadUpdateEnabled(boolean enabled) {
+        mThreadUpdateEnabled = enabled;
+        if (!enabled) {
+            mClientData.clearThreads();
+        }
+
+        try {
+            HandleThread.sendTHEN(this, enabled);
+        } catch (IOException ioe) {
+            // ignore it here; client will clean up shortly
+            ioe.printStackTrace();
+        }
+
+        update(CHANGE_THREAD_MODE);
+    }
+
+    /** Returns whether the thread update is enabled. */
+    public boolean isThreadUpdateEnabled() {
+        return mThreadUpdateEnabled;
+    }
+
+    /**
+     * Sends a thread update request. This is asynchronous.
+     *
+     * <p>The thread info can be accessed by {@link ClientData#getThreads()}. The notification that
+     * the new data is available will be received through {@link
+     * IClientChangeListener#clientChanged(ClientImpl, int)} with a <code>changeMask</code>
+     * containing the mask {@link #CHANGE_THREAD_DATA}.
+     */
+    public void requestThreadUpdate() {
+        HandleThread.requestThreadUpdate(this);
+    }
+
+    /**
+     * Sends a thread stack trace update request. This is asynchronous.
+     *
+     * <p>The thread info can be accessed by {@link ClientData#getThreads()} and {@link
+     * ThreadInfo#getStackTrace()}.
+     *
+     * <p>The notification that the new data is available will be received through {@link
+     * IClientChangeListener#clientChanged(ClientImpl, int)} with a <code>changeMask</code>
+     * containing the mask {@link #CHANGE_THREAD_STACKTRACE}.
+     */
+    public void requestThreadStackTrace(int threadId) {
+        HandleThread.requestThreadStackCallRefresh(this, threadId);
+    }
+
+    /**
+     * Enables or disables the heap update.
+     *
+     * <p>If <code>true</code>, any GC will cause the client to send its heap information.
+     *
+     * <p>The heap information can be accessed by {@link ClientData#getVmHeapData()}.
+     *
+     * <p>The notification that the new data is available will be received through {@link
+     * IClientChangeListener#clientChanged(ClientImpl, int)} with a <code>changeMask</code>
+     * containing the value {@link #CHANGE_HEAP_DATA}.
+     *
+     * @param enabled the enable flag
+     */
+    public void setHeapUpdateEnabled(boolean enabled) {
+        setHeapInfoUpdateEnabled(enabled);
+        setHeapSegmentUpdateEnabled(enabled);
+    }
+
+    public void setHeapInfoUpdateEnabled(boolean enabled) {
+        mHeapInfoUpdateEnabled = enabled;
+
+        try {
+            HandleHeap.sendHPIF(
+                    this, enabled ? HandleHeap.HPIF_WHEN_EVERY_GC : HandleHeap.HPIF_WHEN_NEVER);
+        } catch (IOException ioe) {
+            // ignore it here; client will clean up shortly
+        }
+
+        update(CHANGE_HEAP_MODE);
+    }
+
+    public void setHeapSegmentUpdateEnabled(boolean enabled) {
+        mHeapSegmentUpdateEnabled = enabled;
+
+        try {
+            HandleHeap.sendHPSG(
+                    this,
+                    enabled ? HandleHeap.WHEN_GC : HandleHeap.WHEN_DISABLE,
+                    HandleHeap.WHAT_MERGE);
+        } catch (IOException ioe) {
+            // ignore it here; client will clean up shortly
+        }
+
+        update(CHANGE_HEAP_MODE);
+    }
+
+    public void initializeHeapUpdateStatus() {
+        setHeapInfoUpdateEnabled(mHeapInfoUpdateEnabled);
+    }
+
+    /** Fires a single heap update. */
+    public void updateHeapInfo() {
+        try {
+            HandleHeap.sendHPIF(this, HandleHeap.HPIF_WHEN_NOW);
+        } catch (IOException ioe) {
+            // ignore it here; client will clean up shortly
+        }
+    }
+
+    /**
+     * Returns whether any heap update is enabled.
+     *
+     * @see #setHeapUpdateEnabled(boolean)
+     */
+    public boolean isHeapUpdateEnabled() {
+        return mHeapInfoUpdateEnabled || mHeapSegmentUpdateEnabled;
+    }
+
+    /**
+     * Sends a native heap update request. this is asynchronous.
+     *
+     * <p>The native heap info can be accessed by {@link ClientData#getNativeAllocationList()}. The
+     * notification that the new data is available will be received through {@link
+     * IClientChangeListener#clientChanged(ClientImpl, int)} with a <code>changeMask</code>
+     * containing the mask {@link #CHANGE_NATIVE_HEAP_DATA}.
+     */
+    public boolean requestNativeHeapInformation() {
+        try {
+            HandleNativeHeap.sendNHGT(this);
+            return true;
+        } catch (IOException e) {
+            Log.e("ddmlib", e);
+        }
+
+        return false;
+    }
+
+    @Override
+    public void enableAllocationTracker(boolean enable) {
+        try {
+            HandleHeap.sendREAE(this, enable);
+        } catch (IOException e) {
+            Log.e("ddmlib", e);
+        }
+    }
+
+    /**
+     * Sends a request to the VM to send the enable status of the allocation tracking. This is
+     * asynchronous.
+     *
+     * <p>The allocation status can be accessed by {@link ClientData#getAllocationStatus()}. The
+     * notification that the new status is available will be received through {@link
+     * IClientChangeListener#clientChanged(ClientImpl, int)} with a <code>changeMask</code>
+     * containing the mask {@link #CHANGE_HEAP_ALLOCATION_STATUS}.
+     */
+    public void requestAllocationStatus() {
+        try {
+            HandleHeap.sendREAQ(this);
+        } catch (IOException e) {
+            Log.w("ddmlib", "IO Error while obtaining allocation status");
+        }
+    }
+
+    /**
+     * Sends a request to the VM to send the information about all the allocations that have
+     * happened since the call to {@link #enableAllocationTracker(boolean)} with <var>enable</var>
+     * set to <code>null</code>. This is asynchronous.
+     *
+     * <p>The allocation information can be accessed by {@link ClientData#getAllocations()}. The
+     * notification that the new data is available will be received through {@link
+     * IClientChangeListener#clientChanged(ClientImpl, int)} with a <code>changeMask</code>
+     * containing the mask {@link #CHANGE_HEAP_ALLOCATIONS}.
+     */
+    @Override
+    public void requestAllocationDetails() {
+        try {
+            HandleHeap.sendREAL(this);
+        } catch (IOException e) {
+            Log.e("ddmlib", e);
+        }
+    }
+
+    @Override
+    public void kill() {
+        try {
+            HandleExit.sendEXIT(this, 1);
+        } catch (IOException ioe) {
+            Log.w("ddms", "Send of EXIT message failed");
+            // ignore
+        }
+    }
+
+    /** Registers the client with a Selector, should be called immediately after client creation. */
+    public void register(Selector sel) throws IOException {
+        // Given the only caller of this method is the thread creating this instance, we don't need
+        // synchronization here.
+        SocketChannel chan = mChan;
+        if (chan != null) {
+            chan.register(sel, SelectionKey.OP_READ, this);
+        }
+    }
+
+    /**
+     * Tell the client to open a server socket channel and listen for connections on the specified
+     * port.
+     */
+    void listenForDebugger() throws IOException {
+        mDebugger = new Debugger(this);
+    }
+
+    /**
+     * Initiate the JDWP handshake, should be called immediately after creating client.
+     *
+     * <p>On failure, closes the socket and returns false.
+     */
+    boolean sendHandshake() {
+        ByteBuffer tempBuffer = ByteBuffer.allocate(JdwpHandshake.HANDSHAKE_LEN);
+        try {
+            // assume write buffer can hold 14 bytes
+            JdwpHandshake.putHandshake(tempBuffer);
+            int expectedLen = tempBuffer.position();
+            tempBuffer.flip();
+            // synchronization on mChan not needed because it's called only once immediately after
+            // object creation.
+            if (mChan.write(tempBuffer) != expectedLen) {
+                throw new IOException("partial handshake write");
+            }
+        } catch (IOException ioe) {
+            Log.e("ddms-client", "IO error during handshake: " + ioe.getMessage());
+            mConnState = ST_ERROR;
+            close(true /* notify */);
+            return false;
+        }
+
+        mConnState = ST_AWAIT_SHAKE;
+
+        return true;
+    }
+
+    /**
+     * Send a DDM packet to the client.
+     *
+     * <p>Ideally, we can do this with a single channel write. If that doesn't happen, we have to
+     * prevent anybody else from writing to the channel until this packet completes, so we
+     * synchronize on the channel.
+     *
+     * <p>Another goal is to avoid unnecessary buffer copies, so we write directly out of the
+     * JdwpPacket's ByteBuffer.
+     */
+    @Override
+    protected void send(@NonNull JdwpPacket packet) throws IOException {
+        // Fix to avoid a race condition on mChan. This should be better synchronized
+        // but just capturing the channel here, avoids a NPE.
+        SocketChannel chan = mChan;
+        if (chan == null) {
+            // can happen for e.g. THST packets
+            Log.v("ddms", "Not sending packet -- client is closed");
+            return;
+        }
+
+        packet.log("Client: sending jdwp packet to Android Device");
+        // Synchronizing on this variable is still useful as we do not want more than one
+        // thread writing at the same time to the same channel, and the only change that
+        // can happen to this channel is to be closed and mChan become null.
+        //noinspection SynchronizationOnLocalVariableOrMethodParameter
+        synchronized (chan) {
+            try {
+                packet.write(chan);
+            } catch (IOException ioe) {
+                removeReplyInterceptor(packet.getId());
+                throw ioe;
+            }
+        }
+    }
+
+    /**
+     * Read data from our channel, should only be called from one thread.
+     *
+     * <p>This is called when data is known to be available, and we don't yet have a full packet in
+     * the buffer. If the buffer is at capacity, expand it.
+     */
+    public void read() throws IOException, BufferOverflowException {
+        // Check the channel is not closed, and keep a copy in a local variable to prevent potential
+        // NPE when we actually use the channel in the code below.
+        SocketChannel chan = mChan;
+        if (chan == null) {
+            throw new IOException("Can't read from a closed channel.");
+        }
+        int count;
+
+        if (mReadBuffer.position() == mReadBuffer.capacity()) {
+            if (mReadBuffer.capacity() * 2 > mMaxPacketSize) {
+                Log.e("ddms", "Exceeded MAX_BUF_SIZE!");
+                throw new BufferOverflowException();
+            }
+            Log.d("ddms", "Expanding read buffer to " + mReadBuffer.capacity() * 2);
+
+            ByteBuffer newBuffer = ByteBuffer.allocate(mReadBuffer.capacity() * 2);
+
+            // copy entire buffer to new buffer
+            mReadBuffer.position(0);
+            newBuffer.put(mReadBuffer); // leaves "position" at end of copied
+
+            mReadBuffer = newBuffer;
+        }
+
+        count = chan.read(mReadBuffer);
+        if (count < 0) throw new IOException("read failed");
+
+        Log.v("ddms", "Read " + count + " bytes from " + this);
+        // Log.hexDump("ddms", Log.DEBUG, mReadBuffer.array(),
+        //    mReadBuffer.arrayOffset(), mReadBuffer.position());
+    }
+
+    /**
+     * Return information for the first full JDWP packet in the buffer.
+     *
+     * <p>If we don't yet have a full packet, return null.
+     *
+     * <p>If we haven't yet received the JDWP handshake, we watch for it here and consume it without
+     * admitting to have done so. Upon receipt we send out the "HELO" message, which is why this can
+     * throw an IOException.
+     *
+     * <p>Note the ordering of operations on establishing a connection is:
+     *
+     * <p>Host side: 1) adb track-jdwp 2) Receive updated list of PIDs containing app process. 3)
+     * Open/forward debugger port and connect to device. 4) Perform handshake. 5) Send HELO and wait
+     * for response.
+     *
+     * <p>Device/process side: a) Fork zygote and update ADB with the PID. b) Send APNM if debugger
+     * port is connected ("&lt;pre-initialize&gt;"). c) Bind process to actual application and
+     * package. d) Send updated APNM if debugger port is connected.
+     *
+     * <p>The above two sequence of execution run completely in parallel, with the only constraint
+     * being a) happens before 2).
+     */
+    public JdwpPacket getJdwpPacket() throws IOException {
+
+        /*
+         * On entry, the data starts at offset 0 and ends at "position".
+         * "limit" is set to the buffer capacity.
+         */
+        if (mConnState == ST_AWAIT_SHAKE) {
+            // Sometimes Zygote forking can race and cause the <pre-initialized>
+            // APNM packet to arrive before the handshake. Just get rid of it.
+            consumeInvalidPackets();
+
+            // Normally the first response we get from the client is the response
+            // to our handshake.  It doesn't look like a packet, so we have to
+            // handle it specially.
+            switch (JdwpHandshake.findHandshake(mReadBuffer)) {
+                case JdwpHandshake.HANDSHAKE_GOOD:
+                    Log.d(
+                            "ddms",
+                            "Good handshake from client, sending HELO to " + mClientData.getPid());
+                    JdwpHandshake.consumeHandshake(mReadBuffer);
+                    mConnState = ST_NEED_DDM_PKT;
+                    HandleHello.sendHelloCommands(this, SERVER_PROTOCOL_VERSION);
+                    // see if we have another packet in the buffer
+                    return getJdwpPacket();
+                case JdwpHandshake.HANDSHAKE_BAD:
+                    Log.d("ddms", "Bad handshake from client");
+                    if (MonitorThread.getInstance().getRetryOnBadHandshake()) {
+                        // we should drop the client, but also attempt to reopen it.
+                        // This is done by the DeviceMonitor.
+                        mDevice.getClientTracker().trackClientToDropAndReopen(this);
+                    } else {
+                        // mark it as bad, close the socket, and don't retry
+                        mConnState = ST_NOT_JDWP;
+                        close(true /* notify */);
+                    }
+                    break;
+                case JdwpHandshake.HANDSHAKE_NOTYET:
+                    Log.d("ddms", "No handshake from client yet.");
+                    break;
+                default:
+                    Log.e("ddms", "Unknown packet while waiting for client handshake");
+            }
+            return null;
+        } else if (mConnState == ST_NEED_DDM_PKT
+                || mConnState == ST_NOT_DDM
+                || mConnState == ST_READY) {
+            /*
+             * Normal packet traffic.
+             */
+            if (mReadBuffer.position() != 0) {
+                Log.v("ddms", "Checking " + mReadBuffer.position() + " bytes");
+            }
+            return JdwpPacket.findPacket(mReadBuffer);
+        } else {
+            /*
+             * Not expecting data when in this state.
+             */
+            Log.e("ddms", "Receiving data in state = " + mConnState);
+        }
+
+        return null;
+    }
+
+    /**
+     * It's possible that APNM arrives before the handshake response. It is also invalid for any
+     * packet to arrive before the handshake response. So we just discard all packets before the
+     * handshake response.
+     *
+     * <p>Note that for APNM, we're just throwing them away prior to the handshake, since we'll get
+     * that information in the HELO request/response later.
+     */
+    void consumeInvalidPackets() {
+        while (true) {
+            mReadBuffer.mark();
+            try {
+                JdwpPacket badPacket = JdwpPacket.findPacket(mReadBuffer);
+                if (badPacket != null && !badPacket.isError() && !badPacket.isEmpty()) {
+                    badPacket.consume();
+                } else {
+                    // We didn't find a packet, just reset the position and break out of loop.
+                    mReadBuffer.reset();
+                    break;
+                }
+            } catch (IndexOutOfBoundsException e) {
+                mReadBuffer.reset();
+                break;
+            }
+        }
+    }
+
+    /**
+     * An earlier request resulted in a failure. This is the expected response to a HELO message
+     * when talking to a non-DDM client.
+     */
+    public void packetFailed(JdwpPacket reply) {
+        if (mConnState == ST_NEED_DDM_PKT) {
+            Log.d("ddms", "Marking " + this + " as non-DDM client");
+            mConnState = ST_NOT_DDM;
+        } else if (mConnState != ST_NOT_DDM) {
+            Log.w("ddms", "WEIRD: got JDWP failure packet on DDM req");
+        }
+    }
+
+    /**
+     * The MonitorThread calls this when it sees a DDM request or reply. If we haven't seen a DDM
+     * packet before, we advance the state to ST_READY and return "false". Otherwise, just return
+     * true.
+     *
+     * <p>The idea is to let the MonitorThread know when we first see a DDM packet, so we can send a
+     * broadcast to the handlers when a client connection is made. This method is synchronized so
+     * that we only send the broadcast once.
+     */
+    public synchronized boolean ddmSeen() {
+        if (mConnState == ST_NEED_DDM_PKT) {
+            mConnState = ST_READY;
+            return false;
+        } else if (mConnState != ST_READY) {
+            Log.w("ddms", "WEIRD: in ddmSeen with state=" + mConnState);
+        }
+        return true;
+    }
+
+    /**
+     * Close the client socket channel. If there is a debugger associated with us, close that too.
+     *
+     * <p>Closing a channel automatically unregisters it from the selector. However, we have to
+     * iterate through the selector loop before it actually lets them go and allows the file
+     * descriptors to close. The caller is expected to manage that.
+     *
+     * @param notify Whether or not to notify the listeners of a change.
+     */
+    public void close(boolean notify) {
+        Log.d("ddms", "Closing " + this.toString());
+
+        clear();
+        try {
+            // we could have multiple threads calling close, but it does not matter,
+            // as close() is a no-op if the channel is already closed.
+            SocketChannel chan = mChan;
+            mChan = null;
+            if (chan != null) {
+                chan.close();
+            }
+
+            if (mDebugger != null) {
+                mDebugger.close();
+                mDebugger = null;
+            }
+        } catch (IOException ioe) {
+            Log.w("ddms", "failed to close " + this);
+            // swallow it -- not much else to do
+        }
+
+        mDevice.removeClient(this, notify);
+    }
+
+    @Override
+    public boolean isValid() {
+        return mChan != null;
+    }
+
+    public void update(int changeMask) {
+        mDevice.update(this, changeMask);
+    }
+
+    @Override
+    public void notifyVmMirrorExited() {
+        mDevice.getClientTracker().trackClientToDropAndReopen(this);
+    }
+
+    @Override
+    public void listViewRoots(DebugViewDumpHandler replyHandler) throws IOException {
+        HandleViewDebug.listViewRoots(this, replyHandler);
+    }
+
+    @Override
+    public void captureView(
+            @NonNull String viewRoot, @NonNull String view, @NonNull DebugViewDumpHandler handler)
+            throws IOException {
+        HandleViewDebug.captureView(this, viewRoot, view, handler);
+    }
+
+    @Override
+    public void dumpViewHierarchy(
+            @NonNull String viewRoot,
+            boolean skipChildren,
+            boolean includeProperties,
+            boolean useV2,
+            @NonNull DebugViewDumpHandler handler)
+            throws IOException {
+        HandleViewDebug.dumpViewHierarchy(
+                this, viewRoot, skipChildren, includeProperties, useV2, handler);
+    }
+
+    @Override
+    public void dumpDisplayList(@NonNull String viewRoot, @NonNull String view) throws IOException {
+        HandleViewDebug.dumpDisplayList(this, viewRoot, view);
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/ClientTracker.java b/device_build_interfaces/com/android/tradefed/device/server/ClientTracker.java
new file mode 100644
index 000000000..c1d05c487
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/ClientTracker.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.server;
+
+import com.android.annotations.NonNull;
+
+/** Tracks device {@link ClientImpl clients} */
+public interface ClientTracker {
+    /**
+     * Callback for when a client is disconnected. This callback is meant to notify any threads that
+     * hold a registration to a clients socket to release it.
+     *
+     * @param client that was dropped
+     */
+    void trackDisconnectedClient(@NonNull ClientImpl client);
+
+    /**
+     * Callback for indicating that a client was dropped but an attempt should be made to reopen the
+     * connection with the client.
+     *
+     * @param client that was dropped.
+     */
+    void trackClientToDropAndReopen(@NonNull ClientImpl client);
+
+    /**
+     * Callback to indicate that a device was dropped. An attempt should be made to reopen the
+     * connection with the device and reestablish connection with any of the clients running on that
+     * device.
+     *
+     * @param device that was dropped.
+     */
+    void trackDeviceToDropAndReopen(@NonNull DeviceImpl device);
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/CommandRejectedException.java b/device_build_interfaces/com/android/tradefed/device/server/CommandRejectedException.java
new file mode 100644
index 000000000..1634763cb
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/CommandRejectedException.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.device.server;
+
+public class CommandRejectedException extends RuntimeException {
+    private static final long serialVersionUID = 1L;
+
+    public CommandRejectedException(String message) {
+        super(message);
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/DdmJdwpExtension.java b/device_build_interfaces/com/android/tradefed/device/server/DdmJdwpExtension.java
new file mode 100644
index 000000000..64494e642
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/DdmJdwpExtension.java
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.device.server;
+
+import com.android.annotations.NonNull;
+import com.android.tradefed.device.server.jdwp.JdwpAgent;
+import com.android.tradefed.device.server.jdwp.JdwpExtension;
+import com.android.tradefed.device.server.jdwp.JdwpInterceptor;
+import com.android.tradefed.device.server.jdwp.chunkhandler.ChunkHandler;
+import com.android.tradefed.device.server.jdwp.chunkhandler.JdwpPacket;
+import com.android.tradefed.log.Log;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.HashSet;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+
+public class DdmJdwpExtension extends JdwpExtension {
+
+    // For broadcasts to message handlers
+    public enum Event {
+        // CLIENT_CONNECTED,
+        CLIENT_READY,
+        CLIENT_DISCONNECTED
+    }
+
+    @NonNull private final ConcurrentMap<Integer, ChunkHandler> mHandlerMap;
+
+    public DdmJdwpExtension() {
+        mHandlerMap = new ConcurrentHashMap<Integer, ChunkHandler>();
+    }
+
+    @Override
+    public void intercept(@NonNull ClientImpl client) {
+        client.addJdwpInterceptor(new DdmInterceptor(client));
+    }
+
+    public void registerHandler(int type, @NonNull ChunkHandler handler) {
+        mHandlerMap.putIfAbsent(type, handler);
+    }
+
+    public void broadcast(Event event, @NonNull ClientImpl client) {
+        Log.d("ddms", "broadcast " + event + ": " + client);
+
+        /*
+         * The handler objects appear once in mHandlerMap for each message they
+         * handle. We want to notify them once each, so we convert the HashMap
+         * to a HashSet before we iterate.
+         */
+        HashSet<ChunkHandler> set = new HashSet<ChunkHandler>(mHandlerMap.values());
+        for (ChunkHandler handler : set) {
+            switch (event) {
+                case CLIENT_READY:
+                    try {
+                        handler.clientReady(client);
+                    } catch (IOException ioe) {
+                        // Something failed with the client. It should
+                        // fall out of the list the next time we try to
+                        // do something with it, so we discard the
+                        // exception here and assume cleanup will happen
+                        // later. May need to propagate farther. The
+                        // trouble is that not all values for "event" may
+                        // actually throw an exception.
+                        Log.w("ddms", "Got exception while broadcasting 'ready'");
+                        return;
+                    }
+                    break;
+                case CLIENT_DISCONNECTED:
+                    handler.clientDisconnected(client);
+                    break;
+                default:
+                    throw new UnsupportedOperationException();
+            }
+        }
+    }
+
+    public void ddmSeen(@NonNull ClientImpl client) {
+        // on first DDM packet received, broadcast a "ready" message
+        if (!client.ddmSeen()) {
+            broadcast(Event.CLIENT_READY, client);
+        }
+    }
+
+    /**
+     * Returns "true" if this JDWP packet has a JDWP command type.
+     *
+     * <p>This never returns "true" for reply packets.
+     *
+     * @param packet
+     */
+    static boolean isDdmPacket(JdwpPacket packet) {
+        return !packet.isReply() && packet.is(ChunkHandler.DDMS_CMD_SET, ChunkHandler.DDMS_CMD);
+    }
+
+    public class DdmInterceptor extends JdwpInterceptor {
+
+        @NonNull private final ClientImpl mClient;
+
+        public DdmInterceptor(@NonNull ClientImpl client) {
+            mClient = client;
+        }
+
+        @Override
+        public JdwpPacket intercept(@NonNull JdwpAgent agent, @NonNull JdwpPacket packet) {
+            if (isDdmPacket(packet)) {
+                ddmSeen(mClient);
+                ByteBuffer buf = packet.getPayload();
+                int type = buf.getInt(buf.position());
+                ChunkHandler handler = mHandlerMap.get(type);
+
+                if (handler == null) {
+                    Log.w("ddms", "Received unsupported chunk type " + "ChunkHandler.name(type)");
+                } else {
+                    handler.handlePacket(mClient, packet);
+                }
+                return null;
+            }
+            return packet;
+        }
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/DebugViewDumpHandler.java b/device_build_interfaces/com/android/tradefed/device/server/DebugViewDumpHandler.java
new file mode 100644
index 000000000..916489369
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/DebugViewDumpHandler.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.device.server;
+
+import com.android.ddmlib.ByteBufferUtil;
+import com.android.tradefed.device.server.jdwp.chunkhandler.ChunkHandler;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+public abstract class DebugViewDumpHandler extends ChunkHandler {
+    /** Enable/Disable tracing of OpenGL calls. */
+    public static final int CHUNK_VUGL = type("VUGL");
+
+    /** List <code>ViewRootImpl</code>'s of this process. */
+    public static final int CHUNK_VULW = type("VULW");
+
+    /** Operation on view root, first parameter in packet should be one of VURT_* constants */
+    public static final int CHUNK_VURT = type("VURT");
+
+    /**
+     * Generic View Operation, first parameter in the packet should be one of the VUOP_* constants
+     * below.
+     */
+    public static final int CHUNK_VUOP = type("VUOP");
+
+    private final CountDownLatch mLatch = new CountDownLatch(1);
+    private final int mChunkType;
+
+    public DebugViewDumpHandler(int chunkType) {
+        mChunkType = chunkType;
+    }
+
+    @Override
+    public void clientReady(ClientImpl client) throws IOException {}
+
+    @Override
+    public void clientDisconnected(ClientImpl client) {}
+
+    @Override
+    public void handleChunk(
+            ClientImpl client, int type, ByteBuffer data, boolean isReply, int msgId) {
+        if (type != mChunkType) {
+            handleUnknownChunk(client, type, data, isReply, msgId);
+            return;
+        }
+
+        handleViewDebugResult(data);
+        mLatch.countDown();
+    }
+
+    protected abstract void handleViewDebugResult(ByteBuffer data);
+
+    protected void waitForResult(long timeout, TimeUnit unit) {
+        try {
+            mLatch.await(timeout, unit);
+        } catch (InterruptedException e) {
+            // pass
+        }
+    }
+
+    /** Utility function to copy a String out of a ByteBuffer. */
+    public static String getString(ByteBuffer buf, int len) {
+        return ByteBufferUtil.getString(buf, len);
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/Debugger.java b/device_build_interfaces/com/android/tradefed/device/server/Debugger.java
new file mode 100644
index 000000000..69a53d162
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/Debugger.java
@@ -0,0 +1,425 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.server;
+
+import com.android.annotations.NonNull;
+import com.android.tradefed.device.server.ClientData.DebuggerStatus;
+import com.android.tradefed.device.server.jdwp.JdwpAgent;
+import com.android.tradefed.device.server.jdwp.JdwpHandshake;
+import com.android.tradefed.device.server.jdwp.chunkhandler.JdwpPacket;
+import com.android.tradefed.log.Log;
+
+import com.google.common.annotations.VisibleForTesting;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.nio.BufferOverflowException;
+import java.nio.ByteBuffer;
+import java.nio.channels.SelectionKey;
+import java.nio.channels.Selector;
+import java.nio.channels.ServerSocketChannel;
+import java.nio.channels.SocketChannel;
+
+/** This represents a pending or established connection with a JDWP debugger. */
+public class Debugger extends JdwpAgent {
+
+    enum ConnectionState {
+        ST_NOT_CONNECTED,
+        ST_AWAIT_SHAKE,
+        ST_READY
+    }
+
+    /**
+     * Initial read buffer capacity (must be a power of 2).
+     *
+     * <p>Messages from the debugger are usually pretty small, except for corner cases, such as <a
+     * href="https://issuetracker.google.com/issues/37077879#comment16">creating large strings</a>
+     * for example.
+     */
+    private static final int INITIAL_BUF_SIZE = 1024;
+
+    /** Maximum read buffer capacity/jdwp packet size (must be a power of 2) */
+    private static final int MAX_BUF_SIZE = INITIAL_BUF_SIZE << 14; // 16MB
+
+    private ByteBuffer mReadBuffer;
+
+    private static final int PRE_DATA_BUF_SIZE = 1024;
+    private ByteBuffer mPreDataBuffer;
+
+    /* connection state */
+    private ConnectionState mConnState;
+
+    /* peer */
+    private final ClientImpl mClient; // client we're forwarding to/from
+    private int mListenPort; // listen to me
+    private ServerSocketChannel mListenChannel;
+
+    /* this goes up and down; synchronize methods that access the field */
+    private SocketChannel mChannel;
+
+    /** Create a new Debugger object, configured to listen for connections on a specific port. */
+    public Debugger(ClientImpl client) throws IOException {
+        this(client, 0);
+    }
+
+    @VisibleForTesting
+    Debugger(ClientImpl client, int listenPort) throws IOException {
+        super(client.getJdwpProtocol());
+        mClient = client;
+
+        mListenChannel = ServerSocketChannel.open();
+        mListenChannel.configureBlocking(false); // required for Selector
+
+        InetSocketAddress addr =
+                new InetSocketAddress(
+                        InetAddress.getByName("localhost"), // $NON-NLS-1$
+                        listenPort);
+        mListenChannel.socket().setReuseAddress(true); // enable SO_REUSEADDR
+        mListenChannel.socket().bind(addr);
+        mListenPort = mListenChannel.socket().getLocalPort();
+
+        mReadBuffer = ByteBuffer.allocate(INITIAL_BUF_SIZE);
+        mPreDataBuffer = ByteBuffer.allocate(PRE_DATA_BUF_SIZE);
+        mConnState = ConnectionState.ST_NOT_CONNECTED;
+
+        Log.d("ddms", "Created: " + this.toString());
+    }
+
+    int getListenPort() {
+        return mListenPort;
+    }
+
+    @VisibleForTesting
+    int getReadBufferCapacity() {
+        return mReadBuffer.capacity();
+    }
+
+    @VisibleForTesting
+    int getReadBufferInitialCapacity() {
+        return INITIAL_BUF_SIZE;
+    }
+
+    @VisibleForTesting
+    int getReadBufferMaximumCapacity() {
+        return MAX_BUF_SIZE;
+    }
+
+    @VisibleForTesting
+    ConnectionState getConnectionState() {
+        return mConnState;
+    }
+
+    /** Returns "true" if a debugger is currently attached to us. */
+    boolean isDebuggerAttached() {
+        return mChannel != null;
+    }
+
+    /** Represent the Debugger as a string. */
+    @Override
+    public String toString() {
+        // mChannel != null means we have connection, ST_READY means it's going
+        return "[Debugger "
+                + mListenPort
+                + "-->"
+                + mClient.getClientData().getPid()
+                + ((mConnState != ConnectionState.ST_READY) ? " inactive]" : " active]");
+    }
+
+    /** Register the debugger's listen socket with the Selector. */
+    void registerListener(Selector sel) throws IOException {
+        mListenChannel.register(sel, SelectionKey.OP_ACCEPT, this);
+    }
+
+    /** Return the Client being debugged. */
+    ClientImpl getClient() {
+        return mClient;
+    }
+
+    /**
+     * Accept a new connection, but only if we don't already have one.
+     *
+     * <p>Must be synchronized with other uses of mChannel and mPreBuffer.
+     *
+     * <p>Returns "null" if we're already talking to somebody.
+     */
+    synchronized SocketChannel accept() throws IOException {
+        return accept(mListenChannel);
+    }
+
+    /**
+     * Accept a new connection from the specified listen channel. This is so we can listen on a
+     * dedicated port for the "current" client, where "current" is constantly in flux.
+     *
+     * <p>Must be synchronized with other uses of mChannel and mPreBuffer.
+     *
+     * <p>Returns "null" if we're already talking to somebody.
+     */
+    synchronized SocketChannel accept(ServerSocketChannel listenChan) throws IOException {
+
+        if (listenChan != null) {
+            SocketChannel newChan;
+
+            newChan = listenChan.accept();
+            if (mChannel != null) {
+                Log.w("ddms", "debugger already talking to " + mClient + " on " + mListenPort);
+                newChan.close();
+                return null;
+            }
+            mChannel = newChan;
+            mChannel.configureBlocking(false); // required for Selector
+            mConnState = ConnectionState.ST_AWAIT_SHAKE;
+            return mChannel;
+        }
+
+        return null;
+    }
+
+    /** Close the data connection only. */
+    synchronized void closeData() {
+        try {
+            if (mChannel != null) {
+                mChannel.close();
+                mChannel = null;
+                mConnState = ConnectionState.ST_NOT_CONNECTED;
+
+                ClientData cd = mClient.getClientData();
+                cd.setDebuggerConnectionStatus(DebuggerStatus.DEFAULT);
+                mClient.update(ClientImpl.CHANGE_DEBUGGER_STATUS);
+            }
+        } catch (IOException ioe) {
+            Log.w("ddms", "Failed to close data " + this);
+        }
+    }
+
+    /**
+     * Close the socket that's listening for new connections and (if we're connected) the debugger
+     * data socket.
+     */
+    synchronized void close() {
+        try {
+            if (mListenChannel != null) {
+                mListenChannel.close();
+            }
+            mListenChannel = null;
+            closeData();
+        } catch (IOException ioe) {
+            Log.w("ddms", "Failed to close listener " + this);
+        }
+    }
+
+    // TODO: ?? add a finalizer that verifies the channel was closed
+
+    void processChannelData() {
+        try {
+            /*
+             * Read pending data.
+             */
+            read();
+
+            /*
+             * See if we have a full packet in the buffer. It's possible we have
+             * more than one packet, so we have to loop.
+             */
+            JdwpPacket packet = getJdwpPacket();
+            while (packet != null) {
+                Log.v(
+                        "ddms",
+                        "Forwarding dbg req 0x"
+                                + Integer.toHexString(packet.getId())
+                                + " to "
+                                + getClient());
+                packet.log("Debugger: forwarding jdwp packet from Java Debugger to Client");
+                incoming(packet, getClient());
+
+                packet.consume();
+                packet = getJdwpPacket();
+            }
+        } catch (IOException | BufferOverflowException e) {
+            /*
+             * Close data connection; automatically un-registers dbg from
+             * selector. The failure could be caused by the debugger going away,
+             * or by the client going away and failing to accept our data.
+             * Either way, the debugger connection does not need to exist any
+             * longer. We also need to recycle the connection to the client, so
+             * that the VM sees the debugger disconnect.
+             */
+            Log.d(
+                    "ddms",
+                    "Closing connection to debugger "
+                            + this
+                            + " (recycling client connection as well)");
+            closeData();
+            ClientImpl client = getClient();
+            // we should drop the client, but also attempt to reopen it.
+            // This is done by the DeviceMonitor.
+            ((DeviceImpl) client.getDevice()).getClientTracker().trackClientToDropAndReopen(client);
+        }
+    }
+
+    /**
+     * Read data from our channel.
+     *
+     * <p>This is called when data is known to be available, and we don't yet have a full packet in
+     * the buffer. If the buffer is at capacity, expand it.
+     */
+    void read() throws IOException {
+        int count;
+
+        // Shrink buffer back to initial capacity if last request required a large buffer
+        if (mReadBuffer.position() == 0 && mReadBuffer.capacity() > INITIAL_BUF_SIZE) {
+            Log.i(
+                    "ddms",
+                    String.format(
+                            "Shrinking buffer from %d bytes to %d bytes",
+                            mReadBuffer.capacity(), INITIAL_BUF_SIZE));
+            mReadBuffer = ByteBuffer.allocate(INITIAL_BUF_SIZE);
+        }
+
+        // Expand buffer if we reached maximum capacity
+        if (mReadBuffer.position() == mReadBuffer.capacity()) {
+            int newCapacity = mReadBuffer.capacity() * 2;
+            if (newCapacity > MAX_BUF_SIZE) {
+                Log.w("ddms", String.format("Buffer has reached maximum size of %d", MAX_BUF_SIZE));
+                throw new BufferOverflowException();
+            }
+            Log.d("ddms", "Expanding read buffer to " + newCapacity);
+
+            ByteBuffer newBuffer = ByteBuffer.allocate(newCapacity);
+            mReadBuffer.position(0);
+            newBuffer.put(mReadBuffer); // leaves "position" at end
+
+            mReadBuffer = newBuffer;
+        }
+
+        count = mChannel.read(mReadBuffer);
+        Log.v("ddms", String.format("Read %d bytes from %s", count, this));
+        if (count < 0) throw new IOException("read failed");
+    }
+
+    /**
+     * Return information for the first full JDWP packet in the buffer.
+     *
+     * <p>If we don't yet have a full packet, return null.
+     *
+     * <p>If we haven't yet received the JDWP handshake, we watch for it here and consume it without
+     * admitting to have done so. We also send the handshake response to the debugger, along with
+     * any pending pre-connection data, which is why this can throw an IOException.
+     */
+    JdwpPacket getJdwpPacket() throws IOException {
+        /*
+         * On entry, the data starts at offset 0 and ends at "position".
+         * "limit" is set to the buffer capacity.
+         */
+        if (mConnState == ConnectionState.ST_AWAIT_SHAKE) {
+            int result;
+
+            result = JdwpHandshake.findHandshake(mReadBuffer);
+            // Log.v("ddms", "findHand: " + result);
+            switch (result) {
+                case JdwpHandshake.HANDSHAKE_GOOD:
+                    Log.d("ddms", "Good handshake from debugger");
+                    JdwpHandshake.consumeHandshake(mReadBuffer);
+                    sendHandshake();
+                    mConnState = ConnectionState.ST_READY;
+
+                    ClientData cd = mClient.getClientData();
+                    cd.setDebuggerConnectionStatus(DebuggerStatus.ATTACHED);
+                    mClient.update(ClientImpl.CHANGE_DEBUGGER_STATUS);
+
+                    // see if we have another packet in the buffer
+                    return getJdwpPacket();
+                case JdwpHandshake.HANDSHAKE_BAD:
+                    // not a debugger, throw an exception so we drop the line
+                    Log.d("ddms", "Bad handshake from debugger");
+                    throw new IOException("bad handshake");
+                case JdwpHandshake.HANDSHAKE_NOTYET:
+                    break;
+                default:
+                    Log.e("ddms", "Unknown packet while waiting for client handshake");
+            }
+            return null;
+        } else if (mConnState == ConnectionState.ST_READY) {
+            if (mReadBuffer.position() != 0) {
+                Log.v("ddms", "Checking " + mReadBuffer.position() + " bytes");
+            }
+            return JdwpPacket.findPacket(mReadBuffer);
+        } else {
+            Log.e("ddms", "Receiving data in state = " + mConnState);
+        }
+
+        return null;
+    }
+
+    /**
+     * Send the handshake to the debugger. We also send along any packets we already received from
+     * the client (usually just a VM_START event, if anything at all).
+     */
+    private synchronized void sendHandshake() throws IOException {
+        ByteBuffer tempBuffer = ByteBuffer.allocate(JdwpHandshake.HANDSHAKE_LEN);
+        JdwpHandshake.putHandshake(tempBuffer);
+        int expectedLength = tempBuffer.position();
+        tempBuffer.flip();
+        if (mChannel.write(tempBuffer) != expectedLength) {
+            throw new IOException("partial handshake write");
+        }
+
+        expectedLength = mPreDataBuffer.position();
+        if (expectedLength > 0) {
+            Log.d("ddms", "Sending " + mPreDataBuffer.position() + " bytes of saved data");
+            mPreDataBuffer.flip();
+            if (mChannel.write(mPreDataBuffer) != expectedLength) {
+                throw new IOException("partial pre-data write");
+            }
+            mPreDataBuffer.clear();
+        }
+    }
+
+    /**
+     * Send a packet to the debugger.
+     *
+     * <p>Ideally, we can do this with a single channel write. If that doesn't happen, we have to
+     * prevent anybody else from writing to the channel until this packet completes, so we
+     * synchronize on the channel.
+     *
+     * <p>Another goal is to avoid unnecessary buffer copies, so we write directly out of the
+     * JdwpPacket's ByteBuffer.
+     *
+     * <p>We must synchronize on "mChannel" before writing to it. We want to coordinate the buffered
+     * data with mChannel creation, so this whole method is synchronized.
+     */
+    @Override
+    protected void send(@NonNull JdwpPacket packet) throws IOException {
+        packet.log("Debugger: forwarding jdwp packet from Client to Java Debugger");
+        synchronized (this) {
+            if (mChannel == null) {
+                /*
+                 * Buffer this up so we can send it to the debugger when it
+                 * finally does connect.  This is essential because the VM_START
+                 * message might be telling the debugger that the VM is
+                 * suspended.  The alternative approach would be for us to
+                 * capture and interpret VM_START and send it later if we
+                 * didn't choose to un-suspend the VM for our own purposes.
+                 */
+                Log.d("ddms", "Saving packet 0x" + Integer.toHexString(packet.getId()));
+                packet.move(mPreDataBuffer);
+            } else {
+                packet.write(mChannel);
+            }
+        }
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/DeviceClientMonitorTask.java b/device_build_interfaces/com/android/tradefed/device/server/DeviceClientMonitorTask.java
new file mode 100644
index 000000000..8033b6beb
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/DeviceClientMonitorTask.java
@@ -0,0 +1,588 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.server;
+
+import com.android.annotations.NonNull;
+import com.android.annotations.Nullable;
+import com.android.ddmlib.AdbCommandRejectedException;
+import com.android.ddmlib.DdmPreferences;
+import com.android.ddmlib.IDevice;
+import com.android.ddmlib.TimeoutException;
+import com.android.tradefed.log.Log;
+import com.android.tradefed.log.LogUtil.CLog;
+
+import com.google.common.util.concurrent.Uninterruptibles;
+
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.net.UnknownHostException;
+import java.nio.channels.ClosedChannelException;
+import java.nio.channels.SelectionKey;
+import java.nio.channels.Selector;
+import java.nio.channels.SocketChannel;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * This class is responsible for managing debuggable clients for a registered device. When a device
+ * is registered a connection is established to the adb host then command {@link
+ * ADB_TRACK_JDWP_COMMAND} is sent. This command informs adb to monitor and send state about each
+ * debuggable client. This service then creates a ClientImpl that represents a debuggable process on
+ * the device establishing a handshake and sending a {@link HandleHello.CHUNK_HELO} packet.
+ *
+ * <p>Note that this class tracks {@link com.android.ddmlib.Client}s for all devices tied to an adb
+ * host. Devices are keyed off of the given {@link Socketchannel} connection.
+ */
+class DeviceClientMonitorTask implements Runnable {
+    private volatile boolean mQuit;
+    @NonNull private final Selector mSelector;
+    // Note that mChannelsToRegister is not synchronized other than through the compute* interface.
+    // Therefore, make sure atomic operations are done via that extended API.
+    private final ConcurrentHashMap<SocketChannel, TrackServiceProcessor> mChannelsToRegister =
+            new ConcurrentHashMap<>();
+    private final Set<ClientImpl> mClientsToReopen = new HashSet<>();
+
+    DeviceClientMonitorTask() throws IOException {
+        mSelector = Selector.open();
+    }
+
+    /**
+     * Starts monitoring for debuggable clients on a given device.
+     *
+     * @param device the device to monitor.
+     * @return true if success.
+     */
+    boolean register(@NonNull DeviceImpl device) {
+        SocketChannel socketChannel;
+        try {
+            socketChannel = AndroidDebugBridge.openConnection();
+        } catch (IOException exception) {
+            Log.e(
+                    "DeviceClientMonitorTask",
+                    "Unable to open connection to ADB server: " + exception);
+            return false;
+        }
+        if (socketChannel != null) {
+            try {
+                TrackServiceProcessor processor = new TrackJdwpProcessor(device);
+                boolean result = sendDeviceMonitoringRequest(socketChannel, processor);
+                if (result) {
+                    device.setClientMonitoringSocket(socketChannel);
+                    socketChannel.configureBlocking(false);
+                    mChannelsToRegister.put(socketChannel, processor);
+                    mSelector.wakeup();
+
+                    return true;
+                }
+            } catch (TimeoutException e) {
+                try {
+                    // attempt to close the socket if needed.
+                    socketChannel.close();
+                } catch (IOException e1) {
+                    // we can ignore that one. It may already have been closed.
+                }
+                Log.d(
+                        "DeviceClientMonitorTask",
+                        "Connection Failure when starting to monitor device '"
+                                + device
+                                + "' : timeout");
+            } catch (AdbCommandRejectedException e) {
+                try {
+                    // attempt to close the socket if needed.
+                    socketChannel.close();
+                } catch (IOException e1) {
+                    // we can ignore that one. It may already have been closed.
+                }
+                Log.d(
+                        "DeviceClientMonitorTask",
+                        "Adb refused to start monitoring device '"
+                                + device
+                                + "' : "
+                                + e.getMessage());
+            } catch (IOException e) {
+                try {
+                    // attempt to close the socket if needed.
+                    socketChannel.close();
+                } catch (IOException e1) {
+                    // we can ignore that one. It may already have been closed.
+                }
+                Log.d(
+                        "DeviceClientMonitorTask",
+                        "Connection Failure when starting to monitor device '"
+                                + device
+                                + "' : "
+                                + e.getMessage());
+            }
+        }
+
+        return false;
+    }
+
+    void registerClientToDropAndReopen(ClientImpl client) {
+        synchronized (mClientsToReopen) {
+            Log.d(
+                    "DeviceClientMonitorTask",
+                    "Adding "
+                            + client
+                            + " to list of client to reopen ("
+                            + client.getDebuggerListenPort()
+                            + ").");
+            mClientsToReopen.add(client);
+        }
+        mSelector.wakeup();
+    }
+
+    void free(@NonNull ClientImpl client) {}
+
+    private void processDropAndReopenClients() {
+        synchronized (mClientsToReopen) {
+            MonitorThread monitorThread = MonitorThread.getInstance();
+            for (ClientImpl client : mClientsToReopen) {
+                DeviceImpl device = (DeviceImpl) client.getDevice();
+                int pid = client.getClientData().getPid();
+
+                monitorThread.dropClient(client, false /* notify */);
+
+                // This is kinda bad, but if we don't wait a bit, the client
+                // will never answer the second handshake!
+                Uninterruptibles.sleepUninterruptibly(1, TimeUnit.SECONDS);
+                Log.d("DeviceClientMonitorTask", "Reopening " + client);
+                openClient(device, pid, monitorThread);
+                device.update(IDevice.CHANGE_CLIENT_LIST);
+            }
+            mClientsToReopen.clear();
+        }
+    }
+
+    /** Registers track-jdwp key with the corresponding device's socket channel's selector. */
+    void processChannelsToRegister() {
+        List<SocketChannel> channels = Collections.list(mChannelsToRegister.keys());
+        for (SocketChannel channel : channels) {
+            try {
+                channel.register(mSelector, SelectionKey.OP_READ, mChannelsToRegister.get(channel));
+            } catch (ClosedChannelException e) {
+                Log.w("DeviceClientMonitorTask", "Cannot register already-closed channel.");
+            } finally {
+                mChannelsToRegister.keySet().remove(channel);
+            }
+        }
+    }
+
+    @Override
+    public void run() {
+        do {
+            int count = 0;
+            try {
+                count = mSelector.select();
+            } catch (IOException e) {
+                Log.e("DeviceClientMonitorTask", "Connection error while monitoring clients.");
+                CLog.e(e);
+                return;
+            }
+
+            if (mQuit) {
+                return;
+            }
+
+            processChannelsToRegister();
+            processDropAndReopenClients();
+
+            if (count == 0) {
+                continue;
+            }
+
+            Set<SelectionKey> keys = mSelector.selectedKeys();
+            Iterator<SelectionKey> iter = keys.iterator();
+
+            while (iter.hasNext()) {
+                SelectionKey key = iter.next();
+                iter.remove();
+
+                if (!key.isValid() || !key.isReadable()) {
+                    continue;
+                }
+
+                Object attachment = key.attachment();
+                if (!(attachment instanceof Processor)) {
+                    continue;
+                }
+
+                Processor processor = (Processor) attachment;
+                SocketChannel socket = processor.getSocket();
+                if (socket == null) {
+                    continue;
+                }
+
+                try {
+                    processor.processIncomingData();
+                } catch (IOException ioe) {
+                    Log.d(
+                            "DeviceClientMonitorTask",
+                            "Error reading incoming data: " + ioe.getMessage());
+                    try {
+                        socket.close();
+                    } catch (IOException ignored) {
+                    }
+                    if (processor instanceof TrackServiceProcessor) {
+                        // For TrackServiceProcessor, the socket is for "track-app" or
+                        // "track-jdwp". Reopen them if the device is still connected.
+                        mChannelsToRegister.remove(socket);
+                        DeviceImpl device = processor.getDevice();
+                        device.getClientTracker().trackDeviceToDropAndReopen(device);
+                    }
+                }
+            }
+        } while (!mQuit);
+    }
+
+    public void stop() {
+        mQuit = true;
+        // wake up the secondary loop by closing the selector.
+        mSelector.wakeup();
+    }
+
+    private boolean sendDeviceMonitoringRequest(
+            @NonNull SocketChannel socket, @NonNull TrackServiceProcessor processor)
+            throws TimeoutException, AdbCommandRejectedException, IOException {
+
+        try {
+            AdbHelper.setDevice(socket, processor.getDevice());
+            AdbHelper.write(socket, AdbHelper.formAdbRequest(processor.getCommand()));
+            AdbHelper.AdbResponse resp = AdbHelper.readAdbResponse(socket, false);
+
+            if (!resp.okay) {
+                // request was refused by adb!
+                Log.e("DeviceClientMonitorTask", "adb refused request: " + resp.message);
+            }
+
+            return resp.okay;
+        } catch (TimeoutException e) {
+            Log.e("DeviceClientMonitorTask", "Sending jdwp tracking request timed out!");
+            throw e;
+        } catch (IOException e) {
+            Log.e("DeviceClientMonitorTask", "Sending jdwp tracking request failed!");
+            throw e;
+        }
+    }
+
+    private void updateJdwpClients(@NonNull DeviceImpl device, @NonNull Set<Integer> newPids) {
+        MonitorThread monitorThread = MonitorThread.getInstance();
+
+        List<ClientImpl> clients = device.getClientList();
+        Map<Integer, ClientImpl> existingClients = new HashMap<>();
+
+        synchronized (clients) {
+            for (ClientImpl c : clients) {
+                existingClients.put(c.getClientData().getPid(), c);
+            }
+        }
+
+        Set<ClientImpl> clientsToRemove = new HashSet<>();
+        for (Integer pid : existingClients.keySet()) {
+            if (!newPids.contains(pid)) {
+                clientsToRemove.add(existingClients.get(pid));
+            }
+        }
+
+        Set<Integer> pidsToAdd = new HashSet<Integer>(newPids);
+        pidsToAdd.removeAll(existingClients.keySet());
+        monitorThread.dropClients(clientsToRemove, false);
+
+        // at this point whatever pid is left in the list needs to be converted into Clients.
+        for (int newPid : pidsToAdd) {
+            openClient(device, newPid, monitorThread);
+        }
+
+        if (!pidsToAdd.isEmpty() || !clientsToRemove.isEmpty()) {
+            AndroidDebugBridge.deviceChanged(device, IDevice.CHANGE_CLIENT_LIST);
+        }
+    }
+
+    /** Opens and creates a new client. */
+    private static void openClient(
+            @NonNull DeviceImpl device, int pid, @NonNull MonitorThread monitorThread) {
+
+        SocketChannel clientSocket;
+        try {
+
+            if (DdmPreferences.isJdwpProxyEnabled()) {
+                clientSocket =
+                        AdbHelper.createPassThroughConnection(
+                                new InetSocketAddress(
+                                        "localhost", DdmPreferences.getJdwpProxyPort()),
+                                device.getSerialNumber(),
+                                pid);
+            } else {
+                clientSocket =
+                        AdbHelper.createPassThroughConnection(
+                                AndroidDebugBridge.getSocketAddress(),
+                                device.getSerialNumber(),
+                                pid);
+            }
+
+            // required for Selector
+            clientSocket.configureBlocking(false);
+        } catch (UnknownHostException uhe) {
+            Log.d("DeviceClientMonitorTask", "Unknown Jdwp pid: " + pid);
+            return;
+        } catch (TimeoutException e) {
+            Log.w("DeviceClientMonitorTask", "Failed to connect to client '" + pid + "': timeout");
+            return;
+        } catch (AdbCommandRejectedException e) {
+            Log.d(
+                    "DeviceClientMonitorTask",
+                    "Adb rejected connection to client '" + pid + "': " + e.getMessage());
+            return;
+        } catch (IOException ioe) {
+            Log.w(
+                    "DeviceClientMonitorTask",
+                    "Failed to connect to client '" + pid + "': " + ioe.getMessage());
+            return;
+        }
+
+        createClient(device, pid, clientSocket, monitorThread);
+    }
+
+    /** Creates a client and register it to the monitor thread */
+    private static void createClient(
+            @NonNull DeviceImpl device,
+            int pid,
+            @NonNull SocketChannel socket,
+            @NonNull MonitorThread monitorThread) {
+
+        /*
+         * Successfully connected to something. Create a Client object, add
+         * it to the list, and initiate the JDWP handshake.
+         */
+
+        ClientImpl client = new ClientImpl(device, socket, pid);
+
+        if (client.sendHandshake()) {
+            try {
+                if (AndroidDebugBridge.getClientSupport()) {
+                    client.listenForDebugger();
+                    String msg =
+                            String.format(
+                                    Locale.US,
+                                    "Opening a debugger listener at port %1$d for client with pid"
+                                            + " %2$d",
+                                    client.getDebuggerListenPort(),
+                                    pid);
+                    Log.d("ddms", msg);
+                }
+            } catch (IOException ioe) {
+                client.getClientData().setDebuggerConnectionStatus(ClientData.DebuggerStatus.ERROR);
+                Log.e(
+                        "ddms",
+                        "Can't bind to local " + client.getDebuggerListenPort() + " for debugger");
+                // oh well
+            }
+
+            client.requestAllocationStatus();
+        } else {
+            Log.e("ddms", "Handshake with " + client + " failed!");
+            /*
+             * The handshake send failed. We could remove it now, but if the
+             * failure is "permanent" we'll just keep banging on it and
+             * getting the same result. Keep it in the list with its "error"
+             * state so we don't try to reopen it.
+             */
+        }
+
+        if (client.isValid()) {
+            device.addClient(client);
+            monitorThread.addClient(client);
+        }
+    }
+
+    /**
+     * A Processor instance is the entity to process data coming from a socket. It's always
+     * registered with the Selector in {@link DeviceClientMonitorTask}.
+     *
+     * <p>For each device, there's a {@link TrackServiceProcessor}. it's for the track-jdwp service
+     * through derived class {@link TrackJdwpProcessor}.
+     *
+     * <p>Another type of Processor is {@link CmdlineFileProcessor} which is created to run an adb
+     * shell command to read the /proc/<PID>/cmdline file for the name of a given process.
+     */
+    private abstract class Processor {
+
+        @NonNull final DeviceImpl mDevice;
+
+        Processor(@NonNull DeviceImpl device) {
+            mDevice = device;
+        }
+
+        @NonNull
+        DeviceImpl getDevice() {
+            return mDevice;
+        }
+
+        @Nullable
+        abstract SocketChannel getSocket();
+
+        abstract void processIncomingData() throws IOException;
+    }
+
+    private abstract class TrackServiceProcessor extends Processor {
+
+        TrackServiceProcessor(@NonNull DeviceImpl device) {
+            super(device);
+        }
+
+        @Override
+        @Nullable
+        SocketChannel getSocket() {
+            return getDevice().getClientMonitoringSocket();
+        }
+
+        @NonNull
+        abstract String getCommand();
+    }
+
+    private class TrackJdwpProcessor extends TrackServiceProcessor {
+        TrackJdwpProcessor(@NonNull DeviceImpl device) {
+            super(device);
+        }
+
+        @Override
+        @NonNull
+        String getCommand() {
+            return "track-jdwp";
+        }
+
+        @Override
+        void processIncomingData() throws IOException {
+            if (getSocket() == null) {
+                return;
+            }
+            final byte[] lengthBuffer = new byte[4];
+            int length = AdbSocketUtils.readLength(getSocket(), lengthBuffer);
+
+            // The following reads |length| bytes from the socket channel.
+            // These bytes correspond to the pids of the current set of processes on the device.
+            // It takes this set of pids and compares them with the existing set of clients
+            // for the device. Clients that correspond to pids that are not alive anymore are
+            // dropped, and new clients are created for pids that don't have a corresponding Client.
+
+            if (length >= 0) {
+                // array for the current pids.
+                Set<Integer> newPids = new HashSet<Integer>();
+
+                // get the string data if there are any
+                if (length > 0) {
+                    byte[] buffer = new byte[length];
+                    String result = AdbSocketUtils.read(getSocket(), buffer);
+
+                    // split each line in its own list and create an array of integer pid
+                    String[] pids = result.split("\n"); // $NON-NLS-1$
+
+                    for (String pid : pids) {
+                        try {
+                            newPids.add(Integer.valueOf(pid));
+                        } catch (NumberFormatException nfe) {
+                            // looks like this pid is not really a number. Lets ignore it.
+                        }
+                    }
+                }
+                updateJdwpClients(getDevice(), newPids);
+            }
+        }
+    }
+
+    private class CmdlineFileProcessor extends Processor {
+
+        private final int mPid;
+
+        private int mRetryCount; // The number of attempts left to read the cmdline file.
+
+        @NonNull SocketChannel mSocket; // Socket to execute the adb shell command.
+
+        CmdlineFileProcessor(@NonNull DeviceImpl device, int pid) {
+            // For each pid, make up to 5 attempts to read the cmdline file to get the name.
+            this(device, pid, 5);
+        }
+
+        CmdlineFileProcessor(@NonNull DeviceImpl device, int pid, int retryCount) {
+            super(device);
+            mPid = pid;
+            mRetryCount = retryCount;
+        }
+
+        void connect() {
+            if (mRetryCount <= 0) {
+                Log.w("DeviceClientMonitorTask", "Unexpected cmdline file for PID " + mPid);
+                return;
+            }
+
+            String[] parameters = new String[1];
+            parameters[0] = "/proc/" + mPid + "/cmdline";
+            try {
+                mSocket = getDevice().rawExec("cat", parameters);
+            } catch (AdbCommandRejectedException | TimeoutException | IOException e) {
+                // ignore
+            }
+            if (mSocket == null) {
+                Log.w("DeviceClientMonitorTask", "Cannot register null socket for PID " + mPid);
+                return;
+            }
+            try {
+                mSocket.register(mSelector, SelectionKey.OP_READ, this);
+            } catch (ClosedChannelException e) {
+                Log.w(
+                        "DeviceClientMonitorTask",
+                        "Cannot register already-closed channel to read the name for PID " + mPid);
+            }
+        }
+
+        @Override
+        @Nullable
+        SocketChannel getSocket() {
+            return mSocket;
+        }
+
+        @Override
+        void processIncomingData() throws IOException {
+            if (mSocket == null) {
+                return;
+            }
+            String name = AdbSocketUtils.readNullTerminatedString(mSocket);
+            mSocket.close();
+            if (name.equals("<pre-initialized>")) {
+                // The cmdline file hasn't been initialized when it's read.
+                // Create another processor to read the same file, and register its own socket
+                // to the Selector of DeviceClientMonitorTask.
+                new CmdlineFileProcessor(getDevice(), mPid, --mRetryCount).connect();
+                return;
+            } else if (name.contains("No such file or directory")) {
+                // The process is already dead. Do nothing.
+                // Adb's track-app service will signal the process termination.
+                return;
+            }
+            getDevice().updateProfileableClientName(mPid, name);
+            AndroidDebugBridge.deviceChanged(getDevice(), IDevice.CHANGE_PROFILEABLE_CLIENT_LIST);
+        }
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/DeviceImpl.java b/device_build_interfaces/com/android/tradefed/device/server/DeviceImpl.java
new file mode 100644
index 000000000..eaa21b77d
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/DeviceImpl.java
@@ -0,0 +1,1466 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.device.server;
+
+import com.android.annotations.NonNull;
+import com.android.annotations.Nullable;
+import com.android.annotations.concurrency.GuardedBy;
+import com.android.ddmlib.AdbCommandRejectedException;
+import com.android.ddmlib.AvdData;
+import com.android.ddmlib.CollectingOutputReceiver;
+import com.android.ddmlib.DdmPreferences;
+import com.android.ddmlib.FileListingService;
+import com.android.ddmlib.IDevice;
+import com.android.ddmlib.IShellOutputReceiver;
+import com.android.ddmlib.InstallException;
+import com.android.ddmlib.InstallMetrics;
+import com.android.ddmlib.InstallReceiver;
+import com.android.ddmlib.MultiLineReceiver;
+import com.android.ddmlib.NullOutputReceiver;
+import com.android.ddmlib.PropertyFetcher;
+import com.android.ddmlib.RawImage;
+import com.android.ddmlib.ScreenRecorderOptions;
+import com.android.ddmlib.ShellCommandUnresponsiveException;
+import com.android.ddmlib.SyncException;
+import com.android.ddmlib.TimeoutException;
+import com.android.tradefed.log.Log;
+
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.base.Joiner;
+import com.google.common.collect.Lists;
+import com.google.common.util.concurrent.Atomics;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.SettableFuture;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.channels.SocketChannel;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+
+/** A Device. It can be a physical device or an emulator. */
+public final class DeviceImpl implements IDevice {
+    /** Serial number of the device */
+    private final String mSerialNumber;
+
+    /** Name and path of the AVD */
+    private final SettableFuture<AvdData> mAvdData = SettableFuture.create();
+
+    /** State of the device. */
+    private DeviceState mState;
+
+    /** True if ADB is running as root */
+    private boolean mIsRoot;
+
+    /** Information about the most recent installation via this device */
+    private InstallMetrics lastInstallMetrics;
+
+    /** Device properties. */
+    private final PropertyFetcher mPropFetcher = new PropertyFetcher(this);
+
+    private final Map<String, String> mMountPoints = new HashMap<>();
+
+    private final BatteryFetcher mBatteryFetcher = new BatteryFetcher(this);
+
+    @GuardedBy("mClients")
+    private final List<ClientImpl> mClients = new ArrayList<>();
+
+    /** Maps pid's of clients in {@link #mClients} to their package name. */
+    private final Map<Integer, String> mClientInfo = new ConcurrentHashMap<>();
+
+    @GuardedBy("mProfileableClients")
+    private final List<ProfileableClientImpl> mProfileableClients = new ArrayList<>();
+
+    private final ClientTracker mClientTracer;
+
+    private static final String LOG_TAG = "DeviceImpl";
+    private static final char SEPARATOR = '-';
+
+    private static final long GET_PROP_TIMEOUT_MS = 1000;
+    private static final long INITIAL_GET_PROP_TIMEOUT_MS = 5000;
+    private static final int QUERY_IS_ROOT_TIMEOUT_MS = 1000;
+
+    private static final long INSTALL_TIMEOUT_MINUTES;
+
+    static {
+        String installTimeout = System.getenv("ADB_INSTALL_TIMEOUT");
+        long time = 4;
+        if (installTimeout != null) {
+            try {
+                time = Long.parseLong(installTimeout);
+            } catch (NumberFormatException e) {
+                // use default value
+            }
+        }
+        INSTALL_TIMEOUT_MINUTES = time;
+    }
+
+    /** Socket for the connection monitoring client connection/disconnection. */
+    private SocketChannel mSocketChannel;
+
+    /** Path to the screen recorder binary on the device. */
+    private static final String SCREEN_RECORDER_DEVICE_PATH = "/system/bin/screenrecord";
+
+    private static final long LS_TIMEOUT_SEC = 2;
+
+    /** Flag indicating whether the device has the screen recorder binary. */
+    private Boolean mHasScreenRecorder;
+
+    /** Cached list of hardware characteristics */
+    private Set<String> mHardwareCharacteristics;
+
+    @Nullable private Set<String> mAdbFeatures;
+
+    private String mName;
+
+    @NonNull
+    @Override
+    public String getSerialNumber() {
+        return mSerialNumber;
+    }
+
+    @Nullable
+    @Override
+    public String getAvdName() {
+        AvdData avdData = getCurrentAvdData();
+        return avdData != null ? avdData.getName() : null;
+    }
+
+    @Nullable
+    @Override
+    public String getAvdPath() {
+        AvdData avdData = getCurrentAvdData();
+        return avdData != null ? avdData.getPath() : null;
+    }
+
+    @Nullable
+    private AvdData getCurrentAvdData() {
+        try {
+            return mAvdData.isDone() ? mAvdData.get() : null;
+        } catch (ExecutionException | InterruptedException e) {
+            return null;
+        }
+    }
+
+    @NonNull
+    @Override
+    public ListenableFuture<AvdData> getAvdData() {
+        return mAvdData;
+    }
+
+    void setAvdData(@Nullable AvdData data) {
+        mAvdData.set(data);
+    }
+
+    @NonNull
+    @Override
+    public String getName() {
+        if (mName != null) {
+            return mName;
+        }
+
+        if (isOnline()) {
+            // cache name only if device is online
+            mName = constructName();
+            return mName;
+        } else {
+            return constructName();
+        }
+    }
+
+    @NonNull
+    private String constructName() {
+        if (isEmulator()) {
+            String avdName = getAvdName();
+            if (avdName != null) {
+                return String.format("%s [%s]", avdName, getSerialNumber());
+            } else {
+                return getSerialNumber();
+            }
+        } else {
+            String manufacturer = null;
+            String model = null;
+
+            try {
+                manufacturer = cleanupStringForDisplay(getProperty(PROP_DEVICE_MANUFACTURER));
+                model = cleanupStringForDisplay(getProperty(PROP_DEVICE_MODEL));
+            } catch (Exception e) {
+                // If there are exceptions thrown while attempting to get these properties,
+                // we can just use the serial number, so ignore these exceptions.
+            }
+
+            StringBuilder sb = new StringBuilder(20);
+
+            if (manufacturer != null) {
+                sb.append(manufacturer);
+                sb.append(SEPARATOR);
+            }
+
+            if (model != null) {
+                sb.append(model);
+                sb.append(SEPARATOR);
+            }
+
+            sb.append(getSerialNumber());
+            return sb.toString();
+        }
+    }
+
+    @Nullable
+    private static String cleanupStringForDisplay(String s) {
+        if (s == null) {
+            return null;
+        }
+
+        StringBuilder sb = new StringBuilder(s.length());
+        for (int i = 0; i < s.length(); i++) {
+            char c = s.charAt(i);
+
+            if (Character.isLetterOrDigit(c)) {
+                sb.append(Character.toLowerCase(c));
+            } else {
+                sb.append('_');
+            }
+        }
+
+        return sb.toString();
+    }
+
+    @Override
+    public DeviceState getState() {
+        return mState;
+    }
+
+    /** Changes the state of the device. */
+    void setState(DeviceState state) {
+        mState = state;
+    }
+
+    @NonNull
+    @Override
+    public Map<String, String> getProperties() {
+        return Collections.unmodifiableMap(mPropFetcher.getProperties());
+    }
+
+    @Override
+    public int getPropertyCount() {
+        return mPropFetcher.getProperties().size();
+    }
+
+    @Nullable
+    @Override
+    public String getProperty(@NonNull String name) {
+        Map<String, String> properties = mPropFetcher.getProperties();
+        long timeout = properties.isEmpty() ? INITIAL_GET_PROP_TIMEOUT_MS : GET_PROP_TIMEOUT_MS;
+
+        Future<String> future = mPropFetcher.getProperty(name);
+        try {
+            return future.get(timeout, TimeUnit.MILLISECONDS);
+        } catch (InterruptedException
+                | ExecutionException
+                | java.util.concurrent.TimeoutException e) {
+            // ignore
+        }
+        return null;
+    }
+
+    @Override
+    public boolean arePropertiesSet() {
+        return mPropFetcher.arePropertiesSet();
+    }
+
+    @Override
+    public String getPropertyCacheOrSync(String name) {
+        Future<String> future = mPropFetcher.getProperty(name);
+        try {
+            return future.get();
+        } catch (InterruptedException | ExecutionException e) {
+            // ignore
+        }
+        return null;
+    }
+
+    @Override
+    public String getPropertySync(String name) {
+        Future<String> future = mPropFetcher.getProperty(name);
+        try {
+            return future.get();
+        } catch (InterruptedException | ExecutionException e) {
+            // ignore
+        }
+        return null;
+    }
+
+    @NonNull
+    @Override
+    public ListenableFuture<String> getSystemProperty(@NonNull String name) {
+        return mPropFetcher.getProperty(name);
+    }
+
+    @Override
+    public boolean supportsFeature(@NonNull Feature feature) {
+        switch (feature) {
+            case SCREEN_RECORD:
+                if (supportsFeature(HardwareFeature.WATCH)) {
+                    // Currently physical watches do not support screen recording.
+                    return false;
+                }
+                /*if (!getVersion().isGreaterOrEqualThan(19)) {
+                    return false;
+                }*/
+                if (mHasScreenRecorder == null) {
+                    mHasScreenRecorder = hasBinary(SCREEN_RECORDER_DEVICE_PATH);
+                }
+                return mHasScreenRecorder;
+            case PROCSTATS:
+                // return getVersion().isGreaterOrEqualThan(19);
+                return true;
+            case ABB_EXEC:
+                return getAdbFeatures().contains("abb_exec");
+            case REAL_PKG_NAME:
+                // return getVersion().compareTo(AndroidVersion.VersionCodes.Q, "R") >= 0;
+            case SKIP_VERIFICATION:
+                /*if (getVersion().compareTo(AndroidVersion.VersionCodes.R, null) >= 0) {
+                  return true;
+                } else if (getVersion().compareTo(AndroidVersion.VersionCodes.Q, "R") >= 0) {
+                  String sdkVersionString = getProperty("ro.build.version.preview_sdk");
+                  if (sdkVersionString != null) {
+                    try {
+                      // Only supported on R DP2+.
+                      return Integer.parseInt(sdkVersionString) > 1;
+                    } catch (NumberFormatException e) {
+                      // do nothing and fall through
+                    }
+                  }
+                }*/
+                return false;
+            case SHELL_V2:
+                return getAdbFeatures().contains("shell_v2");
+            default:
+                return false;
+        }
+    }
+
+    @NonNull
+    Set<String> getAdbFeatures() {
+        if (mAdbFeatures != null) {
+            return mAdbFeatures;
+        }
+
+        try {
+            String response = AdbHelper.getFeatures(this);
+            mAdbFeatures = new HashSet<>(Arrays.asList(response.split(",")));
+            response = AdbHelper.getHostFeatures();
+            // We want features supported by both device and host.
+            mAdbFeatures.retainAll(Arrays.asList(response.split(",")));
+        } catch (TimeoutException | AdbCommandRejectedException | IOException e) {
+            Log.e(LOG_TAG, "Error obtaining features: " + e);
+            return new HashSet<>();
+        }
+
+        return mAdbFeatures;
+    }
+
+    // The full list of features can be obtained from /etc/permissions/features*
+    // However, the smaller set of features we are interested in can be obtained by
+    // reading the build characteristics property.
+    @Override
+    public boolean supportsFeature(@NonNull HardwareFeature feature) {
+        try {
+            return getHardwareCharacteristics().contains(feature.getCharacteristic());
+        } catch (Exception e) {
+            return false;
+        }
+    }
+
+    private boolean hasBinary(String path) {
+        CountDownLatch latch = new CountDownLatch(1);
+        CollectingOutputReceiver receiver = new CollectingOutputReceiver(latch);
+        try {
+            executeShellCommand("ls " + path, receiver, LS_TIMEOUT_SEC, TimeUnit.SECONDS);
+        } catch (Exception e) {
+            return false;
+        }
+
+        try {
+            latch.await(LS_TIMEOUT_SEC, TimeUnit.SECONDS);
+        } catch (InterruptedException e) {
+            return false;
+        }
+
+        String value = receiver.getOutput().trim();
+        return !value.endsWith("No such file or directory");
+    }
+
+    @Nullable
+    @Override
+    public String getMountPoint(@NonNull String name) {
+        String mount = mMountPoints.get(name);
+        if (mount == null) {
+            try {
+                mount = queryMountPoint(name);
+                mMountPoints.put(name, mount);
+            } catch (TimeoutException
+                    | AdbCommandRejectedException
+                    | ShellCommandUnresponsiveException
+                    | IOException ignored) {
+            }
+        }
+        return mount;
+    }
+
+    @Nullable
+    private String queryMountPoint(@NonNull final String name)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    ShellCommandUnresponsiveException,
+                    IOException {
+
+        final AtomicReference<String> ref = Atomics.newReference();
+        executeShellCommand(
+                "echo $" + name,
+                new MultiLineReceiver() { //$NON-NLS-1$
+                    @Override
+                    public boolean isCancelled() {
+                        return false;
+                    }
+
+                    @Override
+                    public void processNewLines(@NonNull String[] lines) {
+                        for (String line : lines) {
+                            if (!line.isEmpty()) {
+                                // this should be the only one.
+                                ref.set(line);
+                            }
+                        }
+                    }
+                });
+        return ref.get();
+    }
+
+    @Override
+    public String toString() {
+        return mSerialNumber;
+    }
+
+    /*
+     * (non-Javadoc)
+     * @see com.android.ddmlib.IDevice#isOnline()
+     */
+    @Override
+    public boolean isOnline() {
+        return mState == DeviceState.ONLINE;
+    }
+
+    /*
+     * (non-Javadoc)
+     * @see com.android.ddmlib.IDevice#isEmulator()
+     */
+    @Override
+    public boolean isEmulator() {
+        return mSerialNumber.matches(RE_EMULATOR_SN);
+    }
+
+    /*
+     * (non-Javadoc)
+     * @see com.android.ddmlib.IDevice#isOffline()
+     */
+    @Override
+    public boolean isOffline() {
+        return mState == DeviceState.OFFLINE;
+    }
+
+    /*
+     * (non-Javadoc)
+     * @see com.android.ddmlib.IDevice#isBootLoader()
+     */
+    @Override
+    public boolean isBootLoader() {
+        return mState == DeviceState.BOOTLOADER;
+    }
+
+    @Override
+    @Nullable
+    public SyncService getSyncService()
+            throws TimeoutException, AdbCommandRejectedException, IOException {
+        SyncService syncService = new SyncService(AndroidDebugBridge.getSocketAddress(), this);
+        if (syncService.openSync()) {
+            return syncService;
+        }
+
+        return null;
+    }
+
+    /*
+     * (non-Javadoc)
+     * @see com.android.ddmlib.IDevice#getFileListingService()
+     */
+    @Override
+    public FileListingService getFileListingService() {
+        return new FileListingService(this);
+    }
+
+    @Override
+    public RawImage getScreenshot()
+            throws TimeoutException, AdbCommandRejectedException, IOException {
+        return getScreenshot(0, TimeUnit.MILLISECONDS);
+    }
+
+    @Override
+    public RawImage getScreenshot(long timeout, TimeUnit unit)
+            throws TimeoutException, AdbCommandRejectedException, IOException {
+        return AdbHelper.getFrameBuffer(AndroidDebugBridge.getSocketAddress(), this, timeout, unit);
+    }
+
+    @Override
+    public void startScreenRecorder(
+            @NonNull String remoteFilePath,
+            @NonNull ScreenRecorderOptions options,
+            @NonNull IShellOutputReceiver receiver)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    IOException,
+                    ShellCommandUnresponsiveException {
+        executeShellCommand(getScreenRecorderCommand(remoteFilePath, options), receiver, 0, null);
+    }
+
+    @VisibleForTesting
+    public static String getScreenRecorderCommand(
+            @NonNull String remoteFilePath, @NonNull ScreenRecorderOptions options) {
+        StringBuilder sb = new StringBuilder();
+
+        sb.append("screenrecord");
+        sb.append(' ');
+
+        if (options.width > 0 && options.height > 0) {
+            sb.append("--size ");
+            sb.append(options.width);
+            sb.append('x');
+            sb.append(options.height);
+            sb.append(' ');
+        }
+
+        if (options.bitrateMbps > 0) {
+            sb.append("--bit-rate ");
+            sb.append(options.bitrateMbps * 1000000);
+            sb.append(' ');
+        }
+
+        if (options.timeLimit > 0) {
+            sb.append("--time-limit ");
+            long seconds = TimeUnit.SECONDS.convert(options.timeLimit, options.timeLimitUnits);
+            if (seconds > 180) {
+                seconds = 180;
+            }
+            sb.append(seconds);
+            sb.append(' ');
+        }
+
+        sb.append(remoteFilePath);
+
+        return sb.toString();
+    }
+
+    @Override
+    public void executeShellCommand(String command, IShellOutputReceiver receiver)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    ShellCommandUnresponsiveException,
+                    IOException {
+        AdbHelper.executeRemoteCommand(
+                AndroidDebugBridge.getSocketAddress(),
+                command,
+                this,
+                receiver,
+                DdmPreferences.getTimeOut(),
+                TimeUnit.MILLISECONDS);
+    }
+
+    @Override
+    public void executeShellCommand(
+            String command,
+            IShellOutputReceiver receiver,
+            long maxTimeToOutputResponse,
+            TimeUnit maxTimeUnits,
+            @Nullable InputStream is)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    ShellCommandUnresponsiveException,
+                    IOException {
+        AdbHelper.executeRemoteCommand(
+                AndroidDebugBridge.getSocketAddress(),
+                AdbHelper.AdbService.EXEC,
+                command,
+                this,
+                receiver,
+                0L,
+                maxTimeToOutputResponse,
+                maxTimeUnits,
+                is);
+    }
+
+    @Override
+    public void executeBinderCommand(
+            String[] parameters,
+            IShellOutputReceiver receiver,
+            long maxTimeToOutputResponse,
+            TimeUnit maxTimeUnits,
+            @Nullable InputStream is)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    ShellCommandUnresponsiveException,
+                    IOException {
+        if (supportsFeature(Feature.ABB_EXEC)) {
+            AdbHelper.executeRemoteCommand(
+                    AndroidDebugBridge.getSocketAddress(),
+                    AdbHelper.AdbService.ABB_EXEC,
+                    String.join("\u0000", parameters),
+                    this,
+                    receiver,
+                    0L,
+                    maxTimeToOutputResponse,
+                    maxTimeUnits,
+                    is);
+        } else {
+            executeShellCommand(
+                    "cmd " + String.join(" ", parameters),
+                    receiver,
+                    maxTimeToOutputResponse,
+                    maxTimeUnits,
+                    is);
+        }
+    }
+
+    @Override
+    public void executeShellCommand(
+            String command, IShellOutputReceiver receiver, int maxTimeToOutputResponse)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    ShellCommandUnresponsiveException,
+                    IOException {
+        AdbHelper.executeRemoteCommand(
+                AndroidDebugBridge.getSocketAddress(),
+                command,
+                this,
+                receiver,
+                maxTimeToOutputResponse,
+                TimeUnit.MILLISECONDS);
+    }
+
+    @Override
+    public void executeShellCommand(
+            String command,
+            IShellOutputReceiver receiver,
+            long maxTimeToOutputResponse,
+            TimeUnit maxTimeUnits)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    ShellCommandUnresponsiveException,
+                    IOException {
+        AdbHelper.executeRemoteCommand(
+                AndroidDebugBridge.getSocketAddress(),
+                command,
+                this,
+                receiver,
+                0L,
+                maxTimeToOutputResponse,
+                maxTimeUnits);
+    }
+
+    @Override
+    public void executeShellCommand(
+            String command,
+            IShellOutputReceiver receiver,
+            long maxTimeout,
+            long maxTimeToOutputResponse,
+            TimeUnit maxTimeUnits)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    ShellCommandUnresponsiveException,
+                    IOException {
+        AdbHelper.executeRemoteCommand(
+                AndroidDebugBridge.getSocketAddress(),
+                command,
+                this,
+                receiver,
+                maxTimeout,
+                maxTimeToOutputResponse,
+                maxTimeUnits);
+    }
+
+    @Override
+    public SocketChannel rawExec(String executable, String[] parameters)
+            throws AdbCommandRejectedException, TimeoutException, IOException {
+        return AdbHelper.rawExec(
+                AndroidDebugBridge.getSocketAddress(), this, executable, parameters);
+    }
+
+    @Override
+    public SocketChannel rawBinder(String service, String[] parameters)
+            throws AdbCommandRejectedException, TimeoutException, IOException {
+        final String[] command = new String[parameters.length + 1];
+        command[0] = service;
+        System.arraycopy(parameters, 0, command, 1, parameters.length);
+
+        if (supportsFeature(Feature.ABB_EXEC)) {
+            return AdbHelper.rawAdbService(
+                    AndroidDebugBridge.getSocketAddress(),
+                    this,
+                    String.join("\u0000", command),
+                    AdbHelper.AdbService.ABB_EXEC);
+        } else {
+            return AdbHelper.rawExec(AndroidDebugBridge.getSocketAddress(), this, "cmd", command);
+        }
+    }
+
+    @Override
+    public void createForward(int localPort, int remotePort)
+            throws TimeoutException, AdbCommandRejectedException, IOException {
+        AdbHelper.createForward(
+                AndroidDebugBridge.getSocketAddress(),
+                this,
+                String.format("tcp:%d", localPort), // $NON-NLS-1$
+                String.format("tcp:%d", remotePort)); // $NON-NLS-1$
+    }
+
+    @Override
+    public void createForward(
+            int localPort, String remoteSocketName, DeviceUnixSocketNamespace namespace)
+            throws TimeoutException, AdbCommandRejectedException, IOException {
+        AdbHelper.createForward(
+                AndroidDebugBridge.getSocketAddress(),
+                this,
+                String.format("tcp:%d", localPort), // $NON-NLS-1$
+                String.format("%s:%s", namespace.getType(), remoteSocketName)); // $NON-NLS-1$
+    }
+
+    @Override
+    public void removeForward(int localPort)
+            throws TimeoutException, AdbCommandRejectedException, IOException {
+        AdbHelper.removeForward(
+                AndroidDebugBridge.getSocketAddress(),
+                this,
+                String.format("tcp:%d", localPort)); // $NON-NLS-1$
+    }
+
+    @Override
+    public void createReverse(int remotePort, int localPort)
+            throws TimeoutException, AdbCommandRejectedException, IOException {
+        AdbHelper.createReverse(
+                AndroidDebugBridge.getSocketAddress(),
+                this,
+                String.format(Locale.US, "tcp:%d", localPort), // $NON-NLS-1$
+                String.format(Locale.US, "tcp:%d", remotePort)); // $NON-NLS-1$
+    }
+
+    @Override
+    public void removeReverse(int remotePort)
+            throws TimeoutException, AdbCommandRejectedException, IOException {
+        AdbHelper.removeReverse(
+                AndroidDebugBridge.getSocketAddress(),
+                this,
+                String.format(Locale.US, "tcp:%d", remotePort)); // $NON-NLS-1$
+    }
+
+    // @VisibleForTesting
+    public DeviceImpl(ClientTracker clientTracer, String serialNumber, DeviceState deviceState) {
+        mClientTracer = clientTracer;
+        mSerialNumber = serialNumber;
+        mState = deviceState;
+    }
+
+    public ClientTracker getClientTracker() {
+        return mClientTracer;
+    }
+
+    @Override
+    public boolean hasClients() {
+        synchronized (mClients) {
+            return !mClients.isEmpty();
+        }
+    }
+
+    @Override
+    public ClientImpl[] getClients() {
+        throw new UnsupportedOperationException("You should use #getNativeClients instead");
+    }
+
+    @Override
+    public ClientImpl getClient(String applicationName) {
+        throw new UnsupportedOperationException("You should use #getNativeClients instead");
+    }
+
+    public ClientImpl[] getNativeClients() {
+        synchronized (mClients) {
+            return mClients.toArray(new ClientImpl[0]);
+        }
+    }
+
+    public ClientImpl getNativeClients(String applicationName) {
+        synchronized (mClients) {
+            for (ClientImpl c : mClients) {
+                if (applicationName.equals(c.getClientData().getClientDescription())) {
+                    return c;
+                }
+            }
+        }
+
+        return null;
+    }
+
+    @Override
+    public ProfileableClientImpl[] getProfileableClients() {
+        synchronized (mProfileableClients) {
+            return mProfileableClients.toArray(new ProfileableClientImpl[0]);
+        }
+    }
+
+    @Override
+    public void forceStop(String applicationName) {
+        try {
+            // Force stop the app, even in case it's in the crashed state.
+            executeShellCommand("am force-stop " + applicationName, new NullOutputReceiver());
+        } catch (IOException
+                | TimeoutException
+                | AdbCommandRejectedException
+                | ShellCommandUnresponsiveException ignored) {
+        }
+    }
+
+    @Override
+    public void kill(String applicationName) {
+        try {
+            // Kills the app, even in case it's in the crashed state.
+            executeShellCommand("am kill " + applicationName, new NullOutputReceiver());
+        } catch (IOException
+                | TimeoutException
+                | AdbCommandRejectedException
+                | ShellCommandUnresponsiveException ignored) {
+        }
+    }
+
+    void addClient(ClientImpl client) {
+        synchronized (mClients) {
+            mClients.add(client);
+        }
+
+        addClientInfo(client);
+    }
+
+    List<ClientImpl> getClientList() {
+        synchronized (mClients) {
+            return mClients;
+        }
+    }
+
+    void clearClientList() {
+        synchronized (mClients) {
+            mClients.clear();
+        }
+
+        clearClientInfo();
+    }
+
+    /**
+     * Removes a {@link ClientImpl} from the list.
+     *
+     * @param client the client to remove.
+     * @param notify Whether or not to notify the listeners of a change.
+     */
+    void removeClient(ClientImpl client, boolean notify) {
+        mClientTracer.trackDisconnectedClient(client);
+        synchronized (mClients) {
+            mClients.remove(client);
+        }
+        if (notify) {
+            AndroidDebugBridge.deviceChanged(this, CHANGE_CLIENT_LIST);
+        }
+
+        removeClientInfo(client);
+    }
+
+    void updateProfileableClientList(@NonNull List<ProfileableClientImpl> newClientList) {
+        synchronized (mProfileableClients) {
+            mProfileableClients.clear();
+            mProfileableClients.addAll(newClientList);
+            Collections.sort(
+                    mProfileableClients,
+                    Comparator.comparingInt(c -> c.getProfileableClientData().getPid()));
+        }
+    }
+
+    void updateProfileableClientName(int pid, @NonNull String name) {
+        synchronized (mProfileableClients) {
+            for (ProfileableClientImpl client : mProfileableClients) {
+                if (client.getProfileableClientData().getPid() == pid) {
+                    client.getProfileableClientData().setProcessName(name);
+                    break;
+                }
+            }
+        }
+    }
+
+    void clearProfileableClientList() {
+        synchronized (mProfileableClients) {
+            mProfileableClients.clear();
+        }
+    }
+
+    /** Sets the socket channel on which a track-jdwp command for this device has been sent. */
+    void setClientMonitoringSocket(@NonNull SocketChannel socketChannel) {
+        mSocketChannel = socketChannel;
+    }
+
+    /**
+     * Returns the channel on which responses to the track-jdwp command will be available if it has
+     * been set, null otherwise. The channel is set via {@link
+     * #setClientMonitoringSocket(SocketChannel)}, which is usually invoked when the device goes
+     * online.
+     */
+    @Nullable
+    SocketChannel getClientMonitoringSocket() {
+        return mSocketChannel;
+    }
+
+    void update(int changeMask) {
+        AndroidDebugBridge.deviceChanged(this, changeMask);
+    }
+
+    void update(@NonNull ClientImpl client, int changeMask) {
+        AndroidDebugBridge.clientChanged(client, changeMask);
+        updateClientInfo(client, changeMask);
+    }
+
+    void setMountingPoint(String name, String value) {
+        mMountPoints.put(name, value);
+    }
+
+    private void addClientInfo(ClientImpl client) {
+        ClientData cd = client.getClientData();
+        setClientInfo(cd.getPid(), cd.getPackageName());
+    }
+
+    private void updateClientInfo(ClientImpl client, int changeMask) {
+        if ((changeMask & ClientImpl.CHANGE_NAME) == ClientImpl.CHANGE_NAME) {
+            addClientInfo(client);
+        }
+    }
+
+    private void removeClientInfo(ClientImpl client) {
+        int pid = client.getClientData().getPid();
+        mClientInfo.remove(pid);
+    }
+
+    private void clearClientInfo() {
+        mClientInfo.clear();
+    }
+
+    private void setClientInfo(int pid, String pkgName) {
+        if (pkgName == null) {
+            pkgName = UNKNOWN_PACKAGE;
+        }
+
+        mClientInfo.put(pid, pkgName);
+    }
+
+    @Override
+    public String getClientName(int pid) {
+        return mClientInfo.getOrDefault(pid, UNKNOWN_PACKAGE);
+    }
+
+    @Override
+    public void push(@NonNull String[] local, @NonNull String remote)
+            throws IOException, AdbCommandRejectedException, TimeoutException, SyncException {
+        Log.d(
+                String.join(", ", local),
+                String.format("Uploading %1$s onto device '%2$s'", remote, getSerialNumber()));
+        try (SyncService sync = getSyncService()) {
+            if (sync == null) {
+                throw new IOException("Unable to open sync connection");
+            }
+            String message = String.format("Uploading file onto device '%1$s'", getSerialNumber());
+            Log.d(LOG_TAG, message);
+            sync.push(local, remote, SyncService.getNullProgressMonitor());
+        } catch (TimeoutException e) {
+            Log.e(LOG_TAG, "Error during Sync: timeout.");
+            throw e;
+        } catch (SyncException | IOException e) {
+            Log.e(LOG_TAG, String.format("Error during Sync: %1$s", e.getMessage()));
+            throw e;
+        }
+    }
+
+    @Override
+    public void pushFile(@NonNull String local, @NonNull String remote)
+            throws IOException, AdbCommandRejectedException, TimeoutException, SyncException {
+        String targetFileName = getFileName(local);
+        Log.d(
+                targetFileName,
+                String.format(
+                        "Uploading %1$s onto device '%2$s'", targetFileName, getSerialNumber()));
+
+        try (SyncService sync = getSyncService()) {
+            if (sync == null) {
+                throw new IOException("Unable to open sync connection");
+            }
+            String message = String.format("Uploading file onto device '%1$s'", getSerialNumber());
+            Log.d(LOG_TAG, message);
+            sync.pushFile(local, remote, SyncService.getNullProgressMonitor());
+        } catch (TimeoutException e) {
+            Log.e(LOG_TAG, "Error during Sync: timeout.");
+            throw e;
+        } catch (SyncException | IOException e) {
+            Log.e(LOG_TAG, String.format("Error during Sync: %1$s", e.getMessage()));
+            throw e;
+        }
+    }
+
+    @Override
+    public void pullFile(String remote, String local)
+            throws IOException, AdbCommandRejectedException, TimeoutException, SyncException {
+        SyncService sync = null;
+        try {
+            String targetFileName = getFileName(remote);
+
+            Log.d(
+                    targetFileName,
+                    String.format(
+                            "Downloading %1$s from device '%2$s'",
+                            targetFileName, getSerialNumber()));
+
+            sync = getSyncService();
+            if (sync != null) {
+                String message =
+                        String.format("Downloading file from device '%1$s'", getSerialNumber());
+                Log.d(LOG_TAG, message);
+                sync.pullFile(remote, local, SyncService.getNullProgressMonitor());
+            } else {
+                throw new IOException("Unable to open sync connection!");
+            }
+        } catch (TimeoutException e) {
+            Log.e(LOG_TAG, "Error during Sync: timeout.");
+            throw e;
+
+        } catch (SyncException | IOException e) {
+            Log.e(LOG_TAG, String.format("Error during Sync: %1$s", e.getMessage()));
+            throw e;
+        } finally {
+            if (sync != null) {
+                sync.close();
+            }
+        }
+    }
+
+    @Override
+    public void installPackage(String packageFilePath, boolean reinstall, String... extraArgs)
+            throws InstallException {
+        // Use default basic installReceiver
+        installPackage(packageFilePath, reinstall, new InstallReceiver(), extraArgs);
+    }
+
+    @Override
+    public void installPackage(
+            String packageFilePath,
+            boolean reinstall,
+            InstallReceiver receiver,
+            String... extraArgs)
+            throws InstallException {
+        // Use default values for some timeouts.
+        installPackage(
+                packageFilePath,
+                reinstall,
+                receiver,
+                0L,
+                INSTALL_TIMEOUT_MINUTES,
+                TimeUnit.MINUTES,
+                extraArgs);
+    }
+
+    @Override
+    public void installPackage(
+            String packageFilePath,
+            boolean reinstall,
+            InstallReceiver receiver,
+            long maxTimeout,
+            long maxTimeToOutputResponse,
+            TimeUnit maxTimeUnits,
+            String... extraArgs)
+            throws InstallException {
+        try {
+            long uploadStartNs = System.nanoTime();
+            String remoteFilePath = syncPackageToDevice(packageFilePath);
+            long uploadFinishNs = System.nanoTime();
+            installRemotePackage(
+                    remoteFilePath,
+                    reinstall,
+                    receiver,
+                    maxTimeout,
+                    maxTimeToOutputResponse,
+                    maxTimeUnits,
+                    extraArgs);
+            long installFinishNs = System.nanoTime();
+            removeRemotePackage(remoteFilePath);
+            lastInstallMetrics =
+                    new InstallMetrics(
+                            uploadStartNs, uploadFinishNs, uploadFinishNs, installFinishNs);
+        } catch (IOException | AdbCommandRejectedException | TimeoutException | SyncException e) {
+            throw new InstallException(e);
+        }
+    }
+
+    @Override
+    public void installPackages(
+            @NonNull List<File> apks,
+            boolean reinstall,
+            @NonNull List<String> installOptions,
+            long timeout,
+            @NonNull TimeUnit timeoutUnit)
+            throws InstallException {
+        try {
+            lastInstallMetrics =
+                    SplitApkInstaller.create(this, apks, reinstall, installOptions)
+                            .install(timeout, timeoutUnit);
+        } catch (InstallException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new InstallException(e);
+        }
+    }
+
+    @Override
+    public void installPackages(
+            @NonNull List<File> apks, boolean reinstall, @NonNull List<String> installOptions)
+            throws InstallException {
+        // Use the default single apk installer timeout.
+        installPackages(apks, reinstall, installOptions, INSTALL_TIMEOUT_MINUTES, TimeUnit.MINUTES);
+    }
+
+    @Override
+    public InstallMetrics getLastInstallMetrics() {
+        return lastInstallMetrics;
+    }
+
+    @Override
+    public void installRemotePackages(
+            @NonNull List<String> remoteApks,
+            boolean reinstall,
+            @NonNull List<String> installOptions)
+            throws InstallException {
+        // Use the default installer timeout.
+        installRemotePackages(
+                remoteApks, reinstall, installOptions, INSTALL_TIMEOUT_MINUTES, TimeUnit.MINUTES);
+    }
+
+    @Override
+    public void installRemotePackages(
+            @NonNull List<String> remoteApks,
+            boolean reinstall,
+            @NonNull List<String> installOptions,
+            long timeout,
+            @NonNull TimeUnit timeoutUnit)
+            throws InstallException {
+        try {
+            RemoteSplitApkInstaller.create(this, remoteApks, reinstall, installOptions)
+                    .install(timeout, timeoutUnit);
+        } catch (InstallException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new InstallException(e);
+        }
+    }
+
+    @Override
+    public String syncPackageToDevice(String localFilePath)
+            throws IOException, AdbCommandRejectedException, TimeoutException, SyncException {
+        SyncService sync = null;
+        try {
+            String packageFileName = getFileName(localFilePath);
+            String remoteFilePath = String.format("/data/local/tmp/%1$s", packageFileName);
+
+            Log.d(
+                    packageFileName,
+                    String.format(
+                            "Uploading %1$s onto device '%2$s'",
+                            packageFileName, getSerialNumber()));
+
+            sync = getSyncService();
+            if (sync != null) {
+                String message =
+                        String.format("Uploading file onto device '%1$s'", getSerialNumber());
+                Log.d(LOG_TAG, message);
+                sync.pushFile(localFilePath, remoteFilePath, SyncService.getNullProgressMonitor());
+            } else {
+                throw new IOException("Unable to open sync connection!");
+            }
+            return remoteFilePath;
+        } catch (TimeoutException e) {
+            Log.e(LOG_TAG, "Error during Sync: timeout.");
+            throw e;
+
+        } catch (SyncException | IOException e) {
+            Log.e(LOG_TAG, String.format("Error during Sync: %1$s", e.getMessage()));
+            throw e;
+        } finally {
+            if (sync != null) {
+                sync.close();
+            }
+        }
+    }
+
+    /**
+     * Helper method to retrieve the file name given a local file path
+     *
+     * @param filePath full directory path to file
+     * @return {@link String} file name
+     */
+    private static String getFileName(String filePath) {
+        return new File(filePath).getName();
+    }
+
+    @Override
+    public void installRemotePackage(String remoteFilePath, boolean reinstall, String... extraArgs)
+            throws InstallException {
+        installRemotePackage(remoteFilePath, reinstall, new InstallReceiver(), extraArgs);
+    }
+
+    @Override
+    public void installRemotePackage(
+            String remoteFilePath,
+            boolean reinstall,
+            @NonNull InstallReceiver receiver,
+            String... extraArgs)
+            throws InstallException {
+        installRemotePackage(
+                remoteFilePath,
+                reinstall,
+                receiver,
+                0L,
+                INSTALL_TIMEOUT_MINUTES,
+                TimeUnit.MINUTES,
+                extraArgs);
+    }
+
+    @Override
+    public void installRemotePackage(
+            String remoteFilePath,
+            boolean reinstall,
+            @NonNull InstallReceiver receiver,
+            long maxTimeout,
+            long maxTimeToOutputResponse,
+            TimeUnit maxTimeUnits,
+            String... extraArgs)
+            throws InstallException {
+        try {
+            StringBuilder optionString = new StringBuilder();
+            if (reinstall) {
+                optionString.append("-r ");
+            }
+            if (extraArgs != null) {
+                optionString.append(Joiner.on(' ').join(extraArgs));
+            }
+            String cmd =
+                    String.format(
+                            "pm install %1$s \"%2$s\"", optionString.toString(), remoteFilePath);
+            executeShellCommand(cmd, receiver, maxTimeout, maxTimeToOutputResponse, maxTimeUnits);
+            String error = receiver.getErrorMessage();
+            if (error != null) {
+                throw new InstallException(error, receiver.getErrorCode());
+            }
+        } catch (TimeoutException
+                | AdbCommandRejectedException
+                | ShellCommandUnresponsiveException
+                | IOException e) {
+            throw new InstallException(e);
+        }
+    }
+
+    @Override
+    public void removeRemotePackage(String remoteFilePath) throws InstallException {
+        try {
+            executeShellCommand(
+                    String.format("rm \"%1$s\"", remoteFilePath),
+                    new NullOutputReceiver(),
+                    INSTALL_TIMEOUT_MINUTES,
+                    TimeUnit.MINUTES);
+        } catch (IOException
+                | TimeoutException
+                | AdbCommandRejectedException
+                | ShellCommandUnresponsiveException e) {
+            throw new InstallException(e);
+        }
+    }
+
+    @Override
+    public String uninstallPackage(String packageName) throws InstallException {
+        return uninstallApp(packageName, new String[] {});
+    }
+
+    @Override
+    public String uninstallApp(String applicationID, String... extraArgs) throws InstallException {
+        try {
+            StringBuilder command = new StringBuilder("pm uninstall");
+
+            if (extraArgs != null) {
+                command.append(" ");
+                Joiner.on(' ').appendTo(command, extraArgs);
+            }
+
+            command.append(" ").append(applicationID);
+
+            InstallReceiver receiver = new InstallReceiver();
+            executeShellCommand(
+                    command.toString(), receiver, INSTALL_TIMEOUT_MINUTES, TimeUnit.MINUTES);
+            return receiver.getErrorMessage();
+        } catch (TimeoutException
+                | AdbCommandRejectedException
+                | ShellCommandUnresponsiveException
+                | IOException e) {
+            throw new InstallException(e);
+        }
+    }
+
+    /*
+     * (non-Javadoc)
+     * @see com.android.ddmlib.IDevice#reboot()
+     */
+    @Override
+    public void reboot(String into)
+            throws TimeoutException, AdbCommandRejectedException, IOException {
+        AdbHelper.reboot(into, AndroidDebugBridge.getSocketAddress(), this);
+    }
+
+    @Override
+    public boolean root()
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    IOException,
+                    ShellCommandUnresponsiveException {
+        if (!mIsRoot) {
+            AdbHelper.root(AndroidDebugBridge.getSocketAddress(), this);
+        }
+        return isRoot();
+    }
+
+    @Override
+    public boolean isRoot()
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    ShellCommandUnresponsiveException,
+                    IOException {
+        if (mIsRoot) {
+            return true;
+        }
+        CollectingOutputReceiver receiver = new CollectingOutputReceiver();
+        executeShellCommand(
+                "echo $USER_ID", receiver, QUERY_IS_ROOT_TIMEOUT_MS, TimeUnit.MILLISECONDS);
+        String userID = receiver.getOutput().trim();
+        mIsRoot = userID.equals("0");
+        return mIsRoot;
+    }
+
+    @Override
+    public Integer getBatteryLevel() {
+        // use default of 5 minutes
+        return getBatteryLevel(5 * 60 * 1000);
+    }
+
+    @Override
+    public Integer getBatteryLevel(long freshnessMs) {
+        Future<Integer> futureBattery = getBattery(freshnessMs, TimeUnit.MILLISECONDS);
+        try {
+            return futureBattery.get();
+        } catch (InterruptedException | ExecutionException e) {
+            return null;
+        }
+    }
+
+    @NonNull
+    @Override
+    public Future<Integer> getBattery() {
+        return getBattery(5, TimeUnit.MINUTES);
+    }
+
+    @NonNull
+    @Override
+    public Future<Integer> getBattery(long freshnessTime, @NonNull TimeUnit timeUnit) {
+        return mBatteryFetcher.getBattery(freshnessTime, timeUnit);
+    }
+
+    @NonNull
+    @Override
+    public List<String> getAbis() {
+        /* Try abiList (implemented in L onwards) otherwise fall back to abi and abi2. */
+        String abiList = getProperty(IDevice.PROP_DEVICE_CPU_ABI_LIST);
+        if (abiList != null) {
+            return Lists.newArrayList(abiList.split(","));
+        } else {
+            List<String> abis = Lists.newArrayListWithExpectedSize(2);
+            String abi = getProperty(IDevice.PROP_DEVICE_CPU_ABI);
+            if (abi != null) {
+                abis.add(abi);
+            }
+
+            abi = getProperty(IDevice.PROP_DEVICE_CPU_ABI2);
+            if (abi != null) {
+                abis.add(abi);
+            }
+
+            return abis;
+        }
+    }
+
+    @Override
+    public int getDensity() {
+        String densityValue = getProperty(IDevice.PROP_DEVICE_DENSITY);
+        if (densityValue == null) {
+            densityValue = getProperty(IDevice.PROP_DEVICE_EMULATOR_DENSITY);
+        }
+        if (densityValue != null) {
+            try {
+                return Integer.parseInt(densityValue);
+            } catch (NumberFormatException e) {
+                return -1;
+            }
+        }
+
+        return -1;
+    }
+
+    @Override
+    public String getLanguage() {
+        return getProperties().get(IDevice.PROP_DEVICE_LANGUAGE);
+    }
+
+    @Override
+    public String getRegion() {
+        return getProperty(IDevice.PROP_DEVICE_REGION);
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/DeviceListMonitorTask.java b/device_build_interfaces/com/android/tradefed/device/server/DeviceListMonitorTask.java
new file mode 100644
index 000000000..83155aa46
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/DeviceListMonitorTask.java
@@ -0,0 +1,240 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.server;
+
+import com.android.annotations.NonNull;
+import com.android.annotations.Nullable;
+import com.android.ddmlib.IDevice;
+import com.android.ddmlib.TimeoutException;
+import com.android.tradefed.log.LogUtil.CLog;
+
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.base.Stopwatch;
+import com.google.common.collect.Maps;
+import com.google.common.util.concurrent.Uninterruptibles;
+
+import java.io.IOException;
+import java.nio.channels.AsynchronousCloseException;
+import java.nio.channels.SocketChannel;
+import java.util.Collections;
+import java.util.Map;
+import java.util.concurrent.TimeUnit;
+
+/*
+ * This establishes a socket connection to the adb host, and issues a {@link
+ * #ADB_TRACK_DEVICES_COMMAND}. It then monitors that socket for all changes about device connection
+ * and device state.
+ */
+
+@VisibleForTesting
+public class DeviceListMonitorTask implements Runnable {
+    private static final String ADB_TRACK_DEVICES_COMMAND = "host:track-devices";
+
+    private final byte[] mLengthBuffer = new byte[4];
+
+    private final AndroidDebugBridge mBridge;
+    private final UpdateListener mListener;
+
+    private SocketChannel mAdbConnection = null;
+    private boolean mMonitoring = false;
+    private int mConnectionAttempt = 0;
+    private int mRestartAttemptCount = 0;
+    private Stopwatch mAdbDisconnectionStopwatch;
+    private boolean mInitialDeviceListDone = false;
+
+    private volatile boolean mQuit;
+
+    interface UpdateListener {
+        void connectionError(@NonNull Exception e);
+
+        void deviceListUpdate(@NonNull Map<String, IDevice.DeviceState> devices);
+    }
+
+    DeviceListMonitorTask(@NonNull AndroidDebugBridge bridge, @NonNull UpdateListener listener) {
+        mBridge = bridge;
+        mListener = listener;
+    }
+
+    @Override
+    public void run() {
+        do {
+            if (mAdbConnection == null) {
+                CLog.d("Opening adb connection");
+                try {
+                    mAdbConnection = AndroidDebugBridge.openConnection();
+                } catch (IOException exception) {
+                    CLog.d("Unable to open connection to ADB server: " + exception);
+                }
+                if (mAdbConnection == null) {
+                    mConnectionAttempt++;
+
+                    // Only log on first retry attempt to avoid spamming logs.
+                    if (mConnectionAttempt == 1) {
+                        CLog.e("Cannot reach ADB server, attempting to reconnect.");
+                        mAdbDisconnectionStopwatch = Stopwatch.createStarted();
+                        if (AndroidDebugBridge.isUserManagedAdbMode()) {
+                            CLog.i(
+                                    "Will not automatically restart the ADB server because ddmlib"
+                                            + " is in user managed mode");
+                        }
+                    }
+                    if (!AndroidDebugBridge.isUserManagedAdbMode() && mConnectionAttempt > 10) {
+                        if (!mBridge.startAdb(
+                                AndroidDebugBridge.DEFAULT_START_ADB_TIMEOUT_MILLIS,
+                                TimeUnit.MILLISECONDS)) {
+                            mRestartAttemptCount++;
+                        } else {
+                            CLog.i("adb restarted");
+                            mRestartAttemptCount = 0;
+                        }
+                    }
+                    Uninterruptibles.sleepUninterruptibly(1, TimeUnit.SECONDS);
+                } else {
+                    if (mConnectionAttempt > 0) {
+                        CLog.i(
+                                "ADB connection re-established after "
+                                        + mAdbDisconnectionStopwatch.elapsed(TimeUnit.SECONDS)
+                                        + " seconds.");
+                        mAdbDisconnectionStopwatch.reset();
+                    } else {
+                        CLog.i("Connected to adb for device monitoring");
+                    }
+                    mConnectionAttempt = 0;
+                }
+            }
+
+            try {
+                if (mAdbConnection != null && !mMonitoring) {
+                    mMonitoring = sendDeviceListMonitoringRequest();
+                }
+
+                if (mMonitoring) {
+                    int length = AdbSocketUtils.readLength(mAdbConnection, mLengthBuffer);
+
+                    if (length >= 0) {
+                        // read the incoming message
+                        processIncomingDeviceData(length);
+
+                        // flag the fact that we have build the list at least once.
+                        mInitialDeviceListDone = true;
+                    }
+                }
+            } catch (AsynchronousCloseException ace) {
+                // this happens because of a call to Quit. We do nothing, and the loop will break.
+            } catch (IOException | TimeoutException ex) {
+                handleExceptionInMonitorLoop(ex);
+            }
+        } while (!mQuit);
+    }
+
+    private boolean sendDeviceListMonitoringRequest() throws TimeoutException, IOException {
+        byte[] request = AdbHelper.formAdbRequest(ADB_TRACK_DEVICES_COMMAND);
+
+        try {
+            AdbHelper.write(mAdbConnection, request);
+            AdbHelper.AdbResponse resp = AdbHelper.readAdbResponse(mAdbConnection, false);
+            if (!resp.okay) {
+                // request was refused by adb!
+                CLog.e("adb refused request: " + resp.message);
+            }
+
+            return resp.okay;
+        } catch (IOException e) {
+            CLog.e("DeviceMonitor", "Sending Tracking request failed!");
+            mAdbConnection.close();
+            throw e;
+        }
+    }
+
+    private void handleExceptionInMonitorLoop(@NonNull Exception e) {
+        if (!mQuit) {
+            if (e instanceof TimeoutException) {
+                CLog.e("Adb connection Error: timeout");
+            } else {
+                CLog.e("Adb connection Error:" + e.getMessage());
+            }
+            mMonitoring = false;
+            if (mAdbConnection != null) {
+                try {
+                    mAdbConnection.close();
+                } catch (IOException ioe) {
+                    // we can safely ignore that one.
+                }
+                mAdbConnection = null;
+
+                mListener.connectionError(e);
+            }
+        }
+    }
+
+    /** Processes an incoming device message from the socket */
+    private void processIncomingDeviceData(int length) throws IOException {
+        Map<String, IDevice.DeviceState> result;
+        if (length <= 0) {
+            result = Collections.emptyMap();
+        } else {
+            String response = AdbSocketUtils.read(mAdbConnection, new byte[length]);
+            result = parseDeviceListResponse(response);
+        }
+
+        mListener.deviceListUpdate(result);
+    }
+
+    @VisibleForTesting
+    public static Map<String, IDevice.DeviceState> parseDeviceListResponse(
+            @Nullable String result) {
+        Map<String, IDevice.DeviceState> deviceStateMap = Maps.newHashMap();
+        String[] devices = result == null ? new String[0] : result.split("\n"); // $NON-NLS-1$
+
+        for (String d : devices) {
+            String[] param = d.split("\t"); // $NON-NLS-1$
+            if (param.length == 2) {
+                // new adb uses only serial numbers to identify devices
+                deviceStateMap.put(param[0], IDevice.DeviceState.getState(param[1]));
+            }
+        }
+        return deviceStateMap;
+    }
+
+    boolean isMonitoring() {
+        return mMonitoring;
+    }
+
+    boolean hasInitialDeviceList() {
+        return mInitialDeviceListDone;
+    }
+
+    int getConnectionAttemptCount() {
+        return mConnectionAttempt;
+    }
+
+    int getRestartAttemptCount() {
+        return mRestartAttemptCount;
+    }
+
+    public void stop() {
+        mQuit = true;
+
+        // wakeup the main loop thread by closing the main connection to adb.
+        if (mAdbConnection != null) {
+            try {
+                mAdbConnection.close();
+            } catch (IOException ignored) {
+            }
+        }
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/DeviceMonitor.java b/device_build_interfaces/com/android/tradefed/device/server/DeviceMonitor.java
new file mode 100644
index 000000000..a434a05dd
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/DeviceMonitor.java
@@ -0,0 +1,354 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.server;
+
+import com.android.annotations.NonNull;
+import com.android.annotations.Nullable;
+import com.android.annotations.concurrency.GuardedBy;
+import com.android.ddmlib.IDevice;
+import com.android.ddmlib.IDevice.DeviceState;
+import com.android.tradefed.log.LogUtil.CLog;
+
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+
+import java.io.IOException;
+import java.nio.channels.SocketChannel;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * The {@link DeviceMonitor} monitors devices attached to adb.
+ *
+ * <p>On one thread, it runs the {@link DeviceListMonitorTask}. This establishes a socket connection
+ * to the adb host, and issues a {@link DeviceListMonitorTask.ADB_TRACK_DEVICES_COMMAND}. It then
+ * monitors that socket for all changes about device connection and device state. If {@link
+ * AndroidDebugBridge::getClientSupport} is not enabled the {@link DeviceClientMonitorTask} is not
+ * run, and devices are not registered.
+ *
+ * <p>On another thread it runs the {@link DeviceClientMonitorTask}. This establishes a socket
+ * connection to the adb host per registered device and issues a {@link
+ * DeviceClientMonitorTask.ADB_TRACK_JDWP_COMMAND}. On this connection, it monitors active clients
+ * on the device. Note: a single thread monitors jdwp connections from all devices. The different
+ * socket connections to adb (one per device) are multiplexed over a single selector.
+ */
+public final class DeviceMonitor implements ClientTracker {
+    private final AndroidDebugBridge mServer;
+    private DeviceListMonitorTask mDeviceListMonitorTask;
+    @Nullable private DeviceClientMonitorTask myDeviceClientMonitorTask;
+    private final Object mDevicesGuard = new Object();
+
+    @GuardedBy("mDevicesGuard")
+    private ImmutableList<DeviceImpl> mDevices = ImmutableList.of();
+
+    /**
+     * Creates a new {@link DeviceMonitor} object and links it to the running {@link
+     * AndroidDebugBridge} object.
+     *
+     * @param server the running {@link AndroidDebugBridge}.
+     */
+    public DeviceMonitor(@NonNull AndroidDebugBridge server) {
+        mServer = server;
+    }
+
+    /** Starts the monitoring. */
+    public void start() {
+        try {
+
+            // To terminate thread call stop on each respective task.
+            mDeviceListMonitorTask =
+                    new DeviceListMonitorTask(mServer, new DeviceListUpdateListener());
+            if (AndroidDebugBridge.getClientSupport()) {
+                myDeviceClientMonitorTask = new DeviceClientMonitorTask();
+                new Thread(myDeviceClientMonitorTask, "Device Client Monitor").start();
+            }
+            new Thread(mDeviceListMonitorTask, "Device List Monitor").start(); // $NON-NLS-1$
+        } catch (IOException ex) {
+            // Not expected.
+            CLog.e(ex);
+        }
+    }
+
+    private void jdwpProxyChangedState() {
+        DeviceImpl[] devices;
+        synchronized (mDevicesGuard) {
+            devices = mDevices.toArray(new DeviceImpl[0]);
+        }
+        for (DeviceImpl device : devices) {
+            trackDeviceToDropAndReopen(device);
+        }
+    }
+
+    /** Stops the monitoring. */
+    public void stop() {
+
+        if (mDeviceListMonitorTask != null) {
+            mDeviceListMonitorTask.stop();
+        }
+
+        if (myDeviceClientMonitorTask != null) {
+            myDeviceClientMonitorTask.stop();
+        }
+    }
+
+    /** Returns whether the monitor is currently connected to the debug bridge server. */
+    public boolean isMonitoring() {
+        return mDeviceListMonitorTask != null && mDeviceListMonitorTask.isMonitoring();
+    }
+
+    public int getConnectionAttemptCount() {
+        return mDeviceListMonitorTask == null
+                ? 0
+                : mDeviceListMonitorTask.getConnectionAttemptCount();
+    }
+
+    public int getRestartAttemptCount() {
+        return mDeviceListMonitorTask == null ? 0 : mDeviceListMonitorTask.getRestartAttemptCount();
+    }
+
+    public boolean hasInitialDeviceList() {
+        return mDeviceListMonitorTask != null && mDeviceListMonitorTask.hasInitialDeviceList();
+    }
+
+    /** Returns the devices. */
+    @NonNull
+    public IDevice[] getDevices() {
+        ImmutableList<DeviceImpl> devices;
+        synchronized (mDevicesGuard) {
+            devices = mDevices;
+        }
+        //noinspection ToArrayCallWithZeroLengthArrayArgument
+        return devices.toArray(new IDevice[0]);
+    }
+
+    @NonNull
+    AndroidDebugBridge getServer() {
+        return mServer;
+    }
+
+    @Override
+    public void trackClientToDropAndReopen(@NonNull ClientImpl client) {
+        assert myDeviceClientMonitorTask != null;
+        myDeviceClientMonitorTask.registerClientToDropAndReopen(client);
+    }
+
+    @Override
+    public void trackDisconnectedClient(@NonNull ClientImpl client) {
+        assert myDeviceClientMonitorTask != null;
+        myDeviceClientMonitorTask.free(client);
+    }
+
+    @Override
+    public void trackDeviceToDropAndReopen(@NonNull DeviceImpl device) {
+        boolean hasDevice;
+        synchronized (mDevicesGuard) {
+            hasDevice = mDevices.contains(device);
+        }
+        // restart the monitoring of that device
+        if (hasDevice
+                && AndroidDebugBridge.getClientSupport()
+                && myDeviceClientMonitorTask != null) {
+            CLog.d("Restarting monitoring service for " + device);
+            if (!myDeviceClientMonitorTask.register(device)) {
+                CLog.e("Failed to start monitoring " + device.getSerialNumber());
+            }
+        }
+    }
+
+    /**
+     * Returns an {@link ImmutableList} containing elements from the original collection and
+     * elements from the toAdd collection without elements from the toRemove collection.
+     */
+    private static ImmutableList<DeviceImpl> addRemove(
+            Collection<DeviceImpl> original,
+            Collection<IDevice> toAdd,
+            Collection<IDevice> toRemove) {
+        Set<IDevice> removed = Sets.newHashSet(toRemove);
+        ImmutableList.Builder<DeviceImpl> resultBuilder = ImmutableList.builder();
+        for (DeviceImpl next : original) {
+            if (!removed.contains(next)) {
+                resultBuilder.add(next);
+            }
+        }
+        for (IDevice next : toAdd) {
+            if (next instanceof DeviceImpl) {
+                resultBuilder.add((DeviceImpl) next);
+            }
+        }
+        return resultBuilder.build();
+    }
+
+    /** Updates the device list with the new items received from the monitoring service. */
+    private void updateDevices(@NonNull List<DeviceImpl> newList) {
+        ImmutableList<DeviceImpl> oldDevices;
+        synchronized (mDevicesGuard) {
+            oldDevices = mDevices;
+        }
+        DeviceListComparisonResult result = DeviceListComparisonResult.compare(oldDevices, newList);
+        ImmutableList<DeviceImpl> newDevices = addRemove(oldDevices, result.added, result.removed);
+        synchronized (mDevicesGuard) {
+            mDevices = newDevices;
+        }
+
+        for (IDevice device : result.removed) {
+            removeDevice((DeviceImpl) device);
+            AndroidDebugBridge.deviceDisconnected(device);
+        }
+
+        List<DeviceImpl> newlyOnline = Lists.newArrayListWithExpectedSize(newDevices.size());
+
+        for (Map.Entry<IDevice, DeviceState> entry : result.updated.entrySet()) {
+            DeviceImpl device = (DeviceImpl) entry.getKey();
+            device.setState(entry.getValue());
+            device.update(IDevice.CHANGE_STATE);
+
+            if (device.isOnline()) {
+                newlyOnline.add(device);
+            }
+        }
+
+        for (IDevice device : result.added) {
+            AndroidDebugBridge.deviceConnected(device);
+            if (device.isOnline()) {
+                newlyOnline.add((DeviceImpl) device);
+            }
+        }
+
+        if (AndroidDebugBridge.getClientSupport()) {
+            for (DeviceImpl device : newlyOnline) {
+                if (!myDeviceClientMonitorTask.register(device)) {
+                    CLog.e("Failed to start monitoring " + device.getSerialNumber());
+                }
+            }
+        }
+
+        for (DeviceImpl device : newlyOnline) {
+            setProperties(device);
+
+            // Initiate a property fetch so that future requests can be served out of this cache.
+            // This is necessary for backwards compatibility
+            device.getSystemProperty(IDevice.PROP_BUILD_API_LEVEL);
+        }
+    }
+
+    private void removeDevice(@NonNull DeviceImpl device) {
+        device.setState(DeviceState.DISCONNECTED);
+        device.clearClientList();
+
+        SocketChannel channel = device.getClientMonitoringSocket();
+        if (channel != null) {
+            try {
+                channel.close();
+            } catch (IOException e) {
+                // doesn't really matter if the close fails.
+            }
+        }
+    }
+
+    private static void setProperties(@NonNull DeviceImpl device) {
+        device.setAvdData(null);
+    }
+
+    private class DeviceListUpdateListener implements DeviceListMonitorTask.UpdateListener {
+        @Override
+        public void connectionError(@NonNull Exception e) {
+            // TODO(b/37104675): Clearing the device list in response to an exception is probably
+            // the
+            // wrong thing to do.
+            ImmutableList<DeviceImpl> devices;
+            synchronized (mDevicesGuard) {
+                devices = mDevices;
+                mDevices = ImmutableList.of();
+            }
+            for (DeviceImpl device : devices) {
+                removeDevice(device);
+                AndroidDebugBridge.deviceDisconnected(device);
+            }
+        }
+
+        @Override
+        public void deviceListUpdate(@NonNull Map<String, DeviceState> devices) {
+            List<DeviceImpl> l = Lists.newArrayListWithExpectedSize(devices.size());
+            for (Map.Entry<String, DeviceState> entry : devices.entrySet()) {
+                l.add(new DeviceImpl(DeviceMonitor.this, entry.getKey(), entry.getValue()));
+            }
+            // now merge the new devices with the old ones.
+            updateDevices(l);
+        }
+    }
+
+    @VisibleForTesting
+    public static class DeviceListComparisonResult {
+        @NonNull public final Map<IDevice, DeviceState> updated;
+        @NonNull public final List<IDevice> added;
+        @NonNull public final List<IDevice> removed;
+
+        private DeviceListComparisonResult(
+                @NonNull Map<IDevice, DeviceState> updated,
+                @NonNull List<IDevice> added,
+                @NonNull List<IDevice> removed) {
+            this.updated = updated;
+            this.added = added;
+            this.removed = removed;
+        }
+
+        @NonNull
+        public static DeviceListComparisonResult compare(
+                @NonNull List<? extends IDevice> previous,
+                @NonNull List<? extends IDevice> current) {
+            current = Lists.newArrayList(current);
+
+            final Map<IDevice, DeviceState> updated =
+                    Maps.newHashMapWithExpectedSize(current.size());
+            final List<IDevice> added = Lists.newArrayListWithExpectedSize(1);
+            final List<IDevice> removed = Lists.newArrayListWithExpectedSize(1);
+
+            for (IDevice device : previous) {
+                IDevice currentDevice = find(current, device);
+                if (currentDevice != null) {
+                    if (currentDevice.getState() != device.getState()) {
+                        updated.put(device, currentDevice.getState());
+                    }
+                    current.remove(currentDevice);
+                } else {
+                    removed.add(device);
+                }
+            }
+
+            added.addAll(current);
+
+            return new DeviceListComparisonResult(updated, added, removed);
+        }
+
+        @Nullable
+        private static IDevice find(
+                @NonNull List<? extends IDevice> devices, @NonNull IDevice device) {
+            for (IDevice d : devices) {
+                if (d.getSerialNumber().equals(device.getSerialNumber())) {
+                    return d;
+                }
+            }
+
+            return null;
+        }
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/HeapSegment.java b/device_build_interfaces/com/android/tradefed/device/server/HeapSegment.java
new file mode 100644
index 000000000..a43e33102
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/HeapSegment.java
@@ -0,0 +1,426 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.server;
+
+import com.android.annotations.NonNull;
+
+import java.nio.BufferUnderflowException;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.text.ParseException;
+
+/** Describes the types and locations of objects in a segment of a heap. */
+public final class HeapSegment implements Comparable<HeapSegment> {
+
+    /** Describes an object/region encoded in the HPSG data. */
+    public static class HeapSegmentElement implements Comparable<HeapSegmentElement> {
+
+        /*
+         * Solidity values, which must match the values in
+         * the HPSG data.
+         */
+
+        /** The element describes a free block. */
+        public static final int SOLIDITY_FREE = 0;
+
+        /** The element is strongly-reachable. */
+        public static final int SOLIDITY_HARD = 1;
+
+        /** The element is softly-reachable. */
+        public static final int SOLIDITY_SOFT = 2;
+
+        /** The element is weakly-reachable. */
+        public static final int SOLIDITY_WEAK = 3;
+
+        /** The element is phantom-reachable. */
+        public static final int SOLIDITY_PHANTOM = 4;
+
+        /** The element is pending finalization. */
+        public static final int SOLIDITY_FINALIZABLE = 5;
+
+        /** The element is not reachable, and is about to be swept/freed. */
+        public static final int SOLIDITY_SWEEP = 6;
+
+        /** The reachability of the object is unknown. */
+        public static final int SOLIDITY_INVALID = -1;
+
+        /*
+         * Kind values, which must match the values in
+         * the HPSG data.
+         */
+
+        /** The element describes a data object. */
+        public static final int KIND_OBJECT = 0;
+
+        /** The element describes a class object. */
+        public static final int KIND_CLASS_OBJECT = 1;
+
+        /** The element describes an array of 1-byte elements. */
+        public static final int KIND_ARRAY_1 = 2;
+
+        /** The element describes an array of 2-byte elements. */
+        public static final int KIND_ARRAY_2 = 3;
+
+        /** The element describes an array of 4-byte elements. */
+        public static final int KIND_ARRAY_4 = 4;
+
+        /** The element describes an array of 8-byte elements. */
+        public static final int KIND_ARRAY_8 = 5;
+
+        /** The element describes an unknown type of object. */
+        public static final int KIND_UNKNOWN = 6;
+
+        /** The element describes a native object. */
+        public static final int KIND_NATIVE = 7;
+
+        /** The object kind is unknown or unspecified. */
+        public static final int KIND_INVALID = -1;
+
+        /**
+         * A bit in the HPSG data that indicates that an element should be combined with the element
+         * that follows, typically because an element is too large to be described by a single
+         * element.
+         */
+        private static final int PARTIAL_MASK = 1 << 7;
+
+        /**
+         * Describes the reachability/solidity of the element. Must be set to one of the SOLIDITY_*
+         * values.
+         */
+        private int mSolidity;
+
+        /** Describes the type/kind of the element. Must be set to one of the KIND_* values. */
+        private int mKind;
+
+        /** Describes the length of the element, in bytes. */
+        private int mLength;
+
+        /** Creates an uninitialized element. */
+        public HeapSegmentElement() {
+            setSolidity(SOLIDITY_INVALID);
+            setKind(KIND_INVALID);
+            setLength(-1);
+        }
+
+        /**
+         * Create an element describing the entry at the current position of hpsgData.
+         *
+         * @param hs The heap segment to pull the entry from.
+         * @throws BufferUnderflowException if there is not a whole entry following the current
+         *     position of hpsgData.
+         * @throws ParseException if the provided data is malformed.
+         */
+        public HeapSegmentElement(HeapSegment hs) throws BufferUnderflowException, ParseException {
+            set(hs);
+        }
+
+        /**
+         * Replace the element with the entry at the current position of hpsgData.
+         *
+         * @param hs The heap segment to pull the entry from.
+         * @return this object.
+         * @throws BufferUnderflowException if there is not a whole entry following the current
+         *     position of hpsgData.
+         * @throws ParseException if the provided data is malformed.
+         */
+        public HeapSegmentElement set(HeapSegment hs)
+                throws BufferUnderflowException, ParseException {
+
+            /* TODO: Maybe keep track of the virtual address of each element
+             *       so that they can be examined independently.
+             */
+            ByteBuffer data = hs.mUsageData;
+            int eState = data.get() & 0x000000ff;
+            int eLen = (data.get() & 0x000000ff) + 1;
+
+            while ((eState & PARTIAL_MASK) != 0) {
+
+                /* If the partial bit was set, the next byte should describe
+                 * the same object as the current one.
+                 */
+                int nextState = data.get() & 0x000000ff;
+                if ((nextState & ~PARTIAL_MASK) != (eState & ~PARTIAL_MASK)) {
+                    throw new ParseException("State mismatch", data.position());
+                }
+                eState = nextState;
+                eLen += (data.get() & 0x000000ff) + 1;
+            }
+
+            setSolidity(eState & 0x7);
+            setKind((eState >> 3) & 0x7);
+            setLength(eLen * hs.mAllocationUnitSize);
+
+            return this;
+        }
+
+        public int getSolidity() {
+            return mSolidity;
+        }
+
+        public void setSolidity(int solidity) {
+            this.mSolidity = solidity;
+        }
+
+        public int getKind() {
+            return mKind;
+        }
+
+        public void setKind(int kind) {
+            this.mKind = kind;
+        }
+
+        public int getLength() {
+            return mLength;
+        }
+
+        public void setLength(int length) {
+            this.mLength = length;
+        }
+
+        @Override
+        public int compareTo(@NonNull HeapSegmentElement other) {
+            if (mLength != other.mLength) {
+                return mLength < other.mLength ? -1 : 1;
+            }
+            return 0;
+        }
+    }
+
+    // * The ID of the heap that this segment belongs to.
+    protected int mHeapId;
+
+    // * The size of an allocation unit, in bytes. (e.g., 8 bytes)
+    protected int mAllocationUnitSize;
+
+    // * The virtual address of the start of this segment.
+    protected long mStartAddress;
+
+    // * The offset of this pices from mStartAddress, in bytes.
+    protected int mOffset;
+
+    // * The number of allocation units described in this segment.
+    protected int mAllocationUnitCount;
+
+    // * The raw data that describes the contents of this segment.
+    protected ByteBuffer mUsageData;
+
+    // * mStartAddress is set to this value when the segment becomes invalid.
+    private static final long INVALID_START_ADDRESS = -1;
+
+    /**
+     * Create a new HeapSegment based on the raw contents of an HPSG chunk.
+     *
+     * @param hpsgData The raw data from an HPSG chunk.
+     * @throws BufferUnderflowException if hpsgData is too small to hold the HPSG chunk header data.
+     */
+    public HeapSegment(ByteBuffer hpsgData) throws BufferUnderflowException {
+        /* Read the HPSG chunk header.
+         * These get*() calls may throw a BufferUnderflowException
+         * if the underlying data isn't big enough.
+         */
+        hpsgData.order(ByteOrder.BIG_ENDIAN);
+        mHeapId = hpsgData.getInt();
+        mAllocationUnitSize = hpsgData.get();
+        mStartAddress = hpsgData.getInt() & 0x00000000ffffffffL;
+        mOffset = hpsgData.getInt();
+        mAllocationUnitCount = hpsgData.getInt();
+
+        // Hold onto the remainder of the data.
+        mUsageData = hpsgData.slice();
+        mUsageData.order(ByteOrder.BIG_ENDIAN); // doesn't actually matter
+
+        // Validate the data.
+        // xxx do it
+        // xxx make sure the number of elements matches mAllocationUnitCount.
+        // xxx make sure the last element doesn't have P set
+    }
+
+    /**
+     * See if this segment still contains data, and has not been appended to another segment.
+     *
+     * @return true if this segment has not been appended to another segment.
+     */
+    public boolean isValid() {
+        return mStartAddress != INVALID_START_ADDRESS;
+    }
+
+    /**
+     * See if <code>other</code> comes immediately after this segment.
+     *
+     * @param other The HeapSegment to check.
+     * @return true if <code>other</code> comes immediately after this segment.
+     */
+    public boolean canAppend(HeapSegment other) {
+        return isValid()
+                && other.isValid()
+                && mHeapId == other.mHeapId
+                && mAllocationUnitSize == other.mAllocationUnitSize
+                && getEndAddress() == other.getStartAddress();
+    }
+
+    /**
+     * Append the contents of <code>other</code> to this segment if it describes the segment
+     * immediately after this one.
+     *
+     * @param other The segment to append to this segment, if possible. If appended, <code>other
+     *     </code> will be invalid when this method returns.
+     * @return true if <code>other</code> was successfully appended to this segment.
+     */
+    public boolean append(HeapSegment other) {
+        if (canAppend(other)) {
+            /* Preserve the position.  The mark is not preserved,
+             * but we don't use it anyway.
+             */
+            int pos = mUsageData.position();
+
+            // Guarantee that we have enough room for the new data.
+            if (mUsageData.capacity() - mUsageData.limit() < other.mUsageData.limit()) {
+                /* Grow more than necessary in case another append()
+                 * is about to happen.
+                 */
+                int newSize = mUsageData.limit() + other.mUsageData.limit();
+                ByteBuffer newData = ByteBuffer.allocate(newSize * 2);
+
+                mUsageData.rewind();
+                newData.put(mUsageData);
+                mUsageData = newData;
+            }
+
+            // Copy the data from the other segment and restore the position.
+            other.mUsageData.rewind();
+            mUsageData.put(other.mUsageData);
+            mUsageData.position(pos);
+
+            // Fix this segment's header to cover the new data.
+            mAllocationUnitCount += other.mAllocationUnitCount;
+
+            // Mark the other segment as invalid.
+            other.mStartAddress = INVALID_START_ADDRESS;
+            other.mUsageData = null;
+
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    public long getStartAddress() {
+        return mStartAddress + mOffset;
+    }
+
+    public int getLength() {
+        return mAllocationUnitSize * mAllocationUnitCount;
+    }
+
+    public long getEndAddress() {
+        return getStartAddress() + getLength();
+    }
+
+    public void rewindElements() {
+        if (mUsageData != null) {
+            mUsageData.rewind();
+        }
+    }
+
+    public HeapSegmentElement getNextElement(HeapSegmentElement reuse) {
+        try {
+            if (reuse != null) {
+                return reuse.set(this);
+            } else {
+                return new HeapSegmentElement(this);
+            }
+        } catch (BufferUnderflowException ex) {
+            /* Normal "end of buffer" situation.
+             */
+        } catch (ParseException ex) {
+            /* Malformed data.
+             */
+            // TODO: we should catch this in the constructor
+        }
+        return null;
+    }
+
+    /*
+     * Method overrides for Comparable
+     */
+    @Override
+    public boolean equals(Object o) {
+        if (o instanceof HeapSegment) {
+            return compareTo((HeapSegment) o) == 0;
+        }
+        return false;
+    }
+
+    @Override
+    public int hashCode() {
+        return mHeapId * 31
+                + mAllocationUnitSize * 31
+                + (int) mStartAddress * 31
+                + mOffset * 31
+                + mAllocationUnitCount * 31
+                + mUsageData.hashCode();
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder str = new StringBuilder();
+
+        str.append("HeapSegment { heap ")
+                .append(mHeapId)
+                .append(", start 0x")
+                .append(Integer.toHexString((int) getStartAddress()))
+                .append(", length ")
+                .append(getLength())
+                .append(" }");
+
+        return str.toString();
+    }
+
+    @Override
+    public int compareTo(@NonNull HeapSegment other) {
+        if (mHeapId != other.mHeapId) {
+            return mHeapId < other.mHeapId ? -1 : 1;
+        }
+        if (getStartAddress() != other.getStartAddress()) {
+            return getStartAddress() < other.getStartAddress() ? -1 : 1;
+        }
+
+        /* If two segments have the same start address, the rest of
+         * the fields should be equal.  Go through the motions, though.
+         * Note that we re-check the components of getStartAddress()
+         * (mStartAddress and mOffset) to make sure that all fields in
+         * an equal segment are equal.
+         */
+
+        if (mAllocationUnitSize != other.mAllocationUnitSize) {
+            return mAllocationUnitSize < other.mAllocationUnitSize ? -1 : 1;
+        }
+        if (mStartAddress != other.mStartAddress) {
+            return mStartAddress < other.mStartAddress ? -1 : 1;
+        }
+        if (mOffset != other.mOffset) {
+            return mOffset < other.mOffset ? -1 : 1;
+        }
+        if (mAllocationUnitCount != other.mAllocationUnitCount) {
+            return mAllocationUnitCount < other.mAllocationUnitCount ? -1 : 1;
+        }
+        if (!mUsageData.equals(other.mUsageData)) {
+            return mUsageData.compareTo(other.mUsageData);
+        }
+        return 0;
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/IStackTraceInfo.java b/device_build_interfaces/com/android/tradefed/device/server/IStackTraceInfo.java
new file mode 100644
index 000000000..d732d76bd
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/IStackTraceInfo.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.server;
+
+/** Classes which implement this interface provide a method that returns a stack trace. */
+public interface IStackTraceInfo {
+
+    /** Returns the stack trace. This can be <code>null</code>. */
+    StackTraceElement[] getStackTrace();
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/MonitorThread.java b/device_build_interfaces/com/android/tradefed/device/server/MonitorThread.java
new file mode 100644
index 000000000..1cccadbbe
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/MonitorThread.java
@@ -0,0 +1,419 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.server;
+
+import com.android.ddmlib.IDevice;
+import com.android.tradefed.device.server.jdwp.JdwpExtension;
+import com.android.tradefed.device.server.jdwp.chunkhandler.ChunkHandler;
+import com.android.tradefed.device.server.jdwp.chunkhandler.JdwpPacket;
+import com.android.tradefed.log.Log;
+import com.android.tradefed.log.Log.LogLevel;
+
+import java.io.IOException;
+import java.nio.BufferOverflowException;
+import java.nio.channels.CancelledKeyException;
+import java.nio.channels.SelectionKey;
+import java.nio.channels.Selector;
+import java.nio.channels.ServerSocketChannel;
+import java.nio.channels.SocketChannel;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+
+/** Monitor open connections. */
+public final class MonitorThread extends Thread {
+
+    private final DdmJdwpExtension mDdmJdwpExtension;
+
+    private volatile boolean mQuit = false;
+
+    // List of clients we're paying attention to
+    // Used for locking so final.
+    private final ArrayList<ClientImpl> mClientList;
+
+    // The almighty mux
+    private Selector mSelector;
+
+    private final List<JdwpExtension> mJdwpExtensions;
+
+    // singleton
+    private static MonitorThread sInstance;
+
+    /** Generic constructor. */
+    private MonitorThread() {
+        super("Monitor");
+        mClientList = new ArrayList<>();
+        mDdmJdwpExtension = new DdmJdwpExtension();
+        mJdwpExtensions = new LinkedList<>();
+        mJdwpExtensions.add(mDdmJdwpExtension);
+    }
+
+    /** Creates and return the singleton instance of the client monitor thread. */
+    public static MonitorThread createInstance() {
+        return sInstance = new MonitorThread();
+    }
+
+    /** Get singleton instance of the client monitor thread. */
+    public static MonitorThread getInstance() {
+        return sInstance;
+    }
+
+    /**
+     * Returns "true" if we want to retry connections to clients if we get a bad JDWP handshake
+     * back, "false" if we want to just mark them as bad and leave them alone.
+     */
+    public boolean getRetryOnBadHandshake() {
+        return true; // TODO? make configurable
+    }
+
+    /** Get an array of known clients. */
+    ClientImpl[] getClients() {
+        synchronized (mClientList) {
+            return mClientList.toArray(new ClientImpl[0]);
+        }
+    }
+
+    /** Register "handler" as the handler for type "type". */
+    public synchronized void registerChunkHandler(int type, ChunkHandler handler) {
+        if (sInstance == null) {
+            return;
+        }
+        mDdmJdwpExtension.registerHandler(type, handler);
+    }
+
+    /** Watch for activity from clients and debuggers. */
+    @Override
+    public void run() {
+        Log.d("ddms", "Monitor is up");
+
+        // create a selector
+        try {
+            mSelector = Selector.open();
+        } catch (IOException ioe) {
+            Log.logAndDisplay(
+                    LogLevel.ERROR,
+                    "ddms",
+                    "Failed to initialize Monitor Thread: " + ioe.getMessage());
+            return;
+        }
+
+        while (!mQuit) {
+
+            try {
+                /*
+                 * sync with new registrations: we wait until addClient is done before going through
+                 * and doing mSelector.select() again.
+                 * @see {@link #addClient(Client)}
+                 */
+                synchronized (mClientList) {
+                }
+
+                int count;
+                try {
+                    count = mSelector.select();
+                } catch (IOException ioe) {
+                    ioe.printStackTrace();
+                    continue;
+                } catch (CancelledKeyException cke) {
+                    continue;
+                }
+
+                if (count == 0) {
+                    // somebody called wakeup() ?
+                    // Log.i("ddms", "selector looping");
+                    continue;
+                }
+
+                Set<SelectionKey> keys = mSelector.selectedKeys();
+                Iterator<SelectionKey> iter = keys.iterator();
+
+                while (iter.hasNext()) {
+                    SelectionKey key = iter.next();
+                    iter.remove();
+
+                    try {
+                        if (key.attachment() instanceof ClientImpl) {
+                            processClientActivity(key);
+                        } else if (key.attachment() instanceof Debugger) {
+                            processDebuggerActivity(key);
+                        } else {
+                            Log.e("ddms", "unknown activity key");
+                        }
+                    } catch (Exception e) {
+                        // we don't want to have our thread be killed because of any uncaught
+                        // exception, so we intercept all here.
+                        Log.e("ddms", "Exception during activity from Selector.");
+                        Log.e("ddms", e);
+                    }
+                }
+            } catch (Exception e) {
+                // we don't want to have our thread be killed because of any uncaught
+                // exception, so we intercept all here.
+                Log.e("ddms", "Exception MonitorThread.run()");
+                Log.e("ddms", e);
+            }
+        }
+    }
+
+    /*
+     * Something happened. Figure out what.
+     */
+    private void processClientActivity(SelectionKey key) {
+        ClientImpl client = (ClientImpl) key.attachment();
+
+        try {
+            if (!key.isReadable() || !key.isValid()) {
+                Log.d("ddms", "Invalid key from " + client + ". Dropping client.");
+                dropClient(client, true /* notify */);
+                return;
+            }
+
+            client.read();
+
+            /*
+             * See if we have a full packet in the buffer. It's possible we have
+             * more than one packet, so we have to loop.
+             */
+            JdwpPacket packet = client.getJdwpPacket();
+            while (packet != null) {
+                packet.log("Client: received jdwp packet");
+                client.incoming(packet, client.getDebugger());
+
+                packet.consume();
+                // find next
+                packet = client.getJdwpPacket();
+            }
+        } catch (CancelledKeyException e) {
+            // key was canceled probably due to a disconnected client before we could
+            // read stuff coming from the client, so we drop it.
+            dropClient(client, true /* notify */);
+        } catch (IOException ex) {
+            // something closed down, no need to print anything. The client is simply dropped.
+            dropClient(client, true /* notify */);
+        } catch (Exception ex) {
+            Log.e("ddms", ex);
+
+            /* close the client; automatically un-registers from selector */
+            dropClient(client, true /* notify */);
+
+            if (ex instanceof BufferOverflowException) {
+                Log.w("ddms", "Client data packet exceeded maximum buffer size " + client);
+            } else {
+                // don't know what this is, display it
+                Log.e("ddms", ex);
+            }
+        }
+    }
+
+    /**
+     * Drops a client from the monitor.
+     *
+     * <p>This will lock the {@link ClientImpl} list of the {@link IDevice} running
+     * <var>client</var>.
+     *
+     * @param client
+     * @param notify
+     */
+    public synchronized void dropClient(ClientImpl client, boolean notify) {
+        if (sInstance == null) {
+            return;
+        }
+
+        synchronized (mClientList) {
+            if (!mClientList.remove(client)) {
+                return;
+            }
+        }
+        client.close(notify);
+        mDdmJdwpExtension.broadcast(DdmJdwpExtension.Event.CLIENT_DISCONNECTED, client);
+
+        /*
+         * http://forum.java.sun.com/thread.jspa?threadID=726715&start=0
+         * http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5073504
+         */
+        wakeup();
+    }
+
+    /**
+     * Drops the provided list of clients from the monitor. This will lock the {@link ClientImpl}
+     * list of the {@link IDevice} running each of the clients.
+     */
+    public synchronized void dropClients(Collection<? extends ClientImpl> clients, boolean notify) {
+        for (ClientImpl c : clients) {
+            dropClient(c, notify);
+        }
+    }
+
+    /*
+     * Process activity from one of the debugger sockets. This could be a new
+     * connection or a data packet.
+     */
+    private void processDebuggerActivity(SelectionKey key) {
+        Debugger dbg = (Debugger) key.attachment();
+
+        try {
+            if (key.isAcceptable()) {
+                try {
+                    acceptNewDebugger(dbg, null);
+                } catch (IOException ioe) {
+                    Log.w("ddms", "debugger accept() failed");
+                    ioe.printStackTrace();
+                }
+            } else if (key.isReadable()) {
+                processDebuggerData(key);
+            } else {
+                Log.d("ddm-debugger", "key in unknown state");
+            }
+        } catch (CancelledKeyException cke) {
+            // key has been cancelled we can ignore that.
+        }
+    }
+
+    /*
+     * Accept a new connection from a debugger. If successful, register it with
+     * the Selector.
+     */
+    private void acceptNewDebugger(Debugger dbg, ServerSocketChannel acceptChan)
+            throws IOException {
+
+        synchronized (mClientList) {
+            SocketChannel chan;
+
+            if (acceptChan == null) chan = dbg.accept();
+            else chan = dbg.accept(acceptChan);
+
+            if (chan != null) {
+                chan.socket().setTcpNoDelay(true);
+                wakeup();
+
+                try {
+                    chan.register(mSelector, SelectionKey.OP_READ, dbg);
+                } catch (IOException ioe) {
+                    // failed, drop the connection
+                    dbg.closeData();
+                    throw ioe;
+                } catch (RuntimeException re) {
+                    // failed, drop the connection
+                    dbg.closeData();
+                    throw re;
+                }
+            } else {
+                Log.w("ddms", "ignoring duplicate debugger");
+                // new connection already closed
+            }
+        }
+    }
+
+    /*
+     * We have incoming data from the debugger. Forward it to the client.
+     */
+    private void processDebuggerData(SelectionKey key) {
+        Debugger dbg = (Debugger) key.attachment();
+
+        dbg.processChannelData();
+    }
+
+    /*
+     * Tell the thread that something has changed.
+     */
+    private void wakeup() {
+        // If we didn't started running yet, we might not have a selector set.
+        if (mSelector != null) {
+            mSelector.wakeup();
+        }
+    }
+
+    /** Tell the thread to stop. Called from UI thread. */
+    public synchronized void quit() {
+        mQuit = true;
+        wakeup();
+        Log.d("ddms", "Waiting for Monitor thread");
+        try {
+            this.join();
+            // since we're quitting, lets drop all the client and disconnect
+            // the DebugSelectedPort
+            synchronized (mClientList) {
+                for (ClientImpl c : mClientList) {
+                    c.close(false /* notify */);
+                    mDdmJdwpExtension.broadcast(DdmJdwpExtension.Event.CLIENT_DISCONNECTED, c);
+                }
+                mClientList.clear();
+            }
+
+            if (mSelector != null) {
+                mSelector.close();
+            }
+        } catch (InterruptedException ie) {
+            ie.printStackTrace();
+        } catch (IOException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        }
+
+        sInstance = null;
+    }
+
+    /**
+     * Add a new Client to the list of things we monitor. Also adds the client's channel and the
+     * client's debugger listener to the selection list. This should only be called from one thread
+     * (the VMWatcherThread) to avoid a race between "alreadyOpen" and Client creation.
+     */
+    public synchronized void addClient(ClientImpl client) {
+        if (sInstance == null) {
+            return;
+        }
+
+        Log.d("ddms", "Adding new client " + client);
+
+        synchronized (mClientList) {
+            mClientList.add(client);
+
+            for (JdwpExtension extension : mJdwpExtensions) {
+                extension.intercept(client);
+            }
+
+            /*
+             * Register the Client's socket channel with the selector. We attach
+             * the Client to the SelectionKey. If you try to register a new
+             * channel with the Selector while it is waiting for I/O, you will
+             * block. The solution is to call wakeup() and then hold a lock to
+             * ensure that the registration happens before the Selector goes
+             * back to sleep.
+             */
+            try {
+                wakeup();
+
+                client.register(mSelector);
+
+                Debugger dbg = client.getDebugger();
+                if (dbg != null) {
+                    dbg.registerListener(mSelector);
+                }
+            } catch (IOException ioe) {
+                // not really expecting this to happen
+                ioe.printStackTrace();
+            }
+        }
+    }
+
+    public DdmJdwpExtension getDdmExtension() {
+        return mDdmJdwpExtension;
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/NativeAllocationInfo.java b/device_build_interfaces/com/android/tradefed/device/server/NativeAllocationInfo.java
new file mode 100644
index 000000000..fce2f4ade
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/NativeAllocationInfo.java
@@ -0,0 +1,320 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.server;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * Stores native allocation information.
+ *
+ * <p>Contains number of allocations, their size and the stack trace.
+ *
+ * <p>Note: the ddmlib does not resolve the stack trace automatically. While this class provides
+ * storage for resolved stack trace, this is merely for convenience.
+ */
+public class NativeAllocationInfo {
+    /* Keywords used as delimiters in the string representation of a NativeAllocationInfo */
+    public static final String END_STACKTRACE_KW = "EndStacktrace";
+    public static final String BEGIN_STACKTRACE_KW = "BeginStacktrace:";
+    public static final String TOTAL_SIZE_KW = "TotalSize:";
+    public static final String SIZE_KW = "Size:";
+    public static final String ALLOCATIONS_KW = "Allocations:";
+
+    /* constants for flag bits */
+    private static final int FLAG_ZYGOTE_CHILD = (1 << 31);
+    private static final int FLAG_MASK = FLAG_ZYGOTE_CHILD;
+
+    /** Libraries whose methods will be assumed to be not part of the user code. */
+    private static final List<String> FILTERED_LIBRARIES =
+            Arrays.asList("libc.so", "libc_malloc_debug_leak.so");
+
+    /** Method names that should be assumed to be not part of the user code. */
+    private static final List<Pattern> FILTERED_METHOD_NAME_PATTERNS =
+            Arrays.asList(
+                    Pattern.compile("malloc", Pattern.CASE_INSENSITIVE),
+                    Pattern.compile("calloc", Pattern.CASE_INSENSITIVE),
+                    Pattern.compile("realloc", Pattern.CASE_INSENSITIVE),
+                    Pattern.compile("operator new", Pattern.CASE_INSENSITIVE),
+                    Pattern.compile("memalign", Pattern.CASE_INSENSITIVE));
+
+    private final int mSize;
+
+    private final boolean mIsZygoteChild;
+
+    private int mAllocations;
+    private final ArrayList<Long> mStackCallAddresses = new ArrayList<Long>();
+
+    private ArrayList<NativeStackCallInfo> mResolvedStackCall = null;
+
+    private boolean mIsStackCallResolved = false;
+
+    /**
+     * Constructs a new {@link NativeAllocationInfo}.
+     *
+     * @param size The size of the allocations.
+     * @param allocations the allocation count
+     */
+    public NativeAllocationInfo(int size, int allocations) {
+        this.mSize = size & ~FLAG_MASK;
+        this.mIsZygoteChild = ((size & FLAG_ZYGOTE_CHILD) != 0);
+        this.mAllocations = allocations;
+    }
+
+    /**
+     * Adds a stack call address for this allocation.
+     *
+     * @param address The address to add.
+     */
+    public void addStackCallAddress(long address) {
+        mStackCallAddresses.add(address);
+    }
+
+    /** Returns the size of this allocation. */
+    public int getSize() {
+        return mSize;
+    }
+
+    /** Returns whether the allocation happened in a child of the zygote process. */
+    public boolean isZygoteChild() {
+        return mIsZygoteChild;
+    }
+
+    /** Returns the allocation count. */
+    public int getAllocationCount() {
+        return mAllocations;
+    }
+
+    /**
+     * Returns whether the stack call addresses have been resolved into {@link NativeStackCallInfo}
+     * objects.
+     */
+    public boolean isStackCallResolved() {
+        return mIsStackCallResolved;
+    }
+
+    /**
+     * Returns the stack call of this allocation as raw addresses.
+     *
+     * @return the list of addresses where the allocation happened.
+     */
+    public List<Long> getStackCallAddresses() {
+        return mStackCallAddresses;
+    }
+
+    /**
+     * Sets the resolved stack call for this allocation.
+     *
+     * <p>If <code>resolvedStackCall</code> is non <code>null</code> then {@link
+     * #isStackCallResolved()} will return <code>true</code> after this call.
+     *
+     * @param resolvedStackCall The list of {@link NativeStackCallInfo}.
+     */
+    public synchronized void setResolvedStackCall(List<NativeStackCallInfo> resolvedStackCall) {
+        if (mResolvedStackCall == null) {
+            mResolvedStackCall = new ArrayList<NativeStackCallInfo>();
+        } else {
+            mResolvedStackCall.clear();
+        }
+        mResolvedStackCall.addAll(resolvedStackCall);
+        mIsStackCallResolved = !mResolvedStackCall.isEmpty();
+    }
+
+    /**
+     * Returns the resolved stack call.
+     *
+     * @return An array of {@link NativeStackCallInfo} or <code>null</code> if the stack call was
+     *     not resolved.
+     * @see #setResolvedStackCall(List)
+     * @see #isStackCallResolved()
+     */
+    public synchronized List<NativeStackCallInfo> getResolvedStackCall() {
+        if (mIsStackCallResolved) {
+            return mResolvedStackCall;
+        }
+
+        return null;
+    }
+
+    /**
+     * Indicates whether some other object is "equal to" this one.
+     *
+     * @param obj the reference object with which to compare.
+     * @return <code>true</code> if this object is equal to the obj argument; <code>false</code>
+     *     otherwise.
+     * @see java.lang.Object#equals(java.lang.Object)
+     */
+    @Override
+    public boolean equals(Object obj) {
+        if (obj == this) return true;
+        if (obj instanceof NativeAllocationInfo) {
+            NativeAllocationInfo mi = (NativeAllocationInfo) obj;
+            // compare of size and alloc
+            if (mSize != mi.mSize || mAllocations != mi.mAllocations) {
+                return false;
+            }
+
+            // compare stacks
+            return stackEquals(mi);
+        }
+        return false;
+    }
+
+    public boolean stackEquals(NativeAllocationInfo mi) {
+        if (mStackCallAddresses.size() != mi.mStackCallAddresses.size()) {
+            return false;
+        }
+
+        int count = mStackCallAddresses.size();
+        for (int i = 0; i < count; i++) {
+            long a = mStackCallAddresses.get(i);
+            long b = mi.mStackCallAddresses.get(i);
+            if (a != b) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    @Override
+    public int hashCode() {
+        // Follow Effective Java's recipe re hash codes.
+        // Includes all the fields looked at by equals().
+
+        int result = 17; // arbitrary starting point
+
+        result = 31 * result + mSize;
+        result = 31 * result + mAllocations;
+        result = 31 * result + mStackCallAddresses.size();
+
+        for (long addr : mStackCallAddresses) {
+            result = 31 * result + (int) (addr ^ (addr >>> 32));
+        }
+
+        return result;
+    }
+
+    /**
+     * Returns a string representation of the object.
+     *
+     * @see java.lang.Object#toString()
+     */
+    @Override
+    public String toString() {
+        StringBuilder buffer = new StringBuilder();
+        buffer.append(ALLOCATIONS_KW);
+        buffer.append(' ');
+        buffer.append(mAllocations);
+        buffer.append('\n');
+
+        buffer.append(SIZE_KW);
+        buffer.append(' ');
+        buffer.append(mSize);
+        buffer.append('\n');
+
+        buffer.append(TOTAL_SIZE_KW);
+        buffer.append(' ');
+        buffer.append(mSize * mAllocations);
+        buffer.append('\n');
+
+        if (mResolvedStackCall != null) {
+            buffer.append(BEGIN_STACKTRACE_KW);
+            buffer.append('\n');
+            for (NativeStackCallInfo source : mResolvedStackCall) {
+                long addr = source.getAddress();
+                if (addr == 0) {
+                    continue;
+                }
+
+                if (source.getLineNumber() != -1) {
+                    buffer.append(
+                            String.format(
+                                    "\t%1$08x\t%2$s --- %3$s --- %4$s:%5$d\n",
+                                    addr,
+                                    source.getLibraryName(),
+                                    source.getMethodName(),
+                                    source.getSourceFile(),
+                                    source.getLineNumber()));
+                } else {
+                    buffer.append(
+                            String.format(
+                                    "\t%1$08x\t%2$s --- %3$s --- %4$s\n",
+                                    addr,
+                                    source.getLibraryName(),
+                                    source.getMethodName(),
+                                    source.getSourceFile()));
+                }
+            }
+            buffer.append(END_STACKTRACE_KW);
+            buffer.append('\n');
+        }
+
+        return buffer.toString();
+    }
+
+    /**
+     * Returns the first {@link NativeStackCallInfo} that is relevant.
+     *
+     * <p>A relevant <code>NativeStackCallInfo</code> is a stack call that is not deep in the lower
+     * level of the libc, but the actual method that performed the allocation.
+     *
+     * @return a <code>NativeStackCallInfo</code> or <code>null</code> if the stack call has not
+     *     been processed from the raw addresses.
+     * @see #setResolvedStackCall(List)
+     * @see #isStackCallResolved()
+     */
+    public synchronized NativeStackCallInfo getRelevantStackCallInfo() {
+        if (mIsStackCallResolved && mResolvedStackCall != null) {
+            for (NativeStackCallInfo info : mResolvedStackCall) {
+                if (isRelevantLibrary(info.getLibraryName())
+                        && isRelevantMethod(info.getMethodName())) {
+                    return info;
+                }
+            }
+
+            // couldn't find a relevant one, so we'll return the first one if it exists.
+            if (!mResolvedStackCall.isEmpty()) return mResolvedStackCall.get(0);
+        }
+
+        return null;
+    }
+
+    private boolean isRelevantLibrary(String libPath) {
+        for (String l : FILTERED_LIBRARIES) {
+            if (libPath.endsWith(l)) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    private boolean isRelevantMethod(String methodName) {
+        for (Pattern p : FILTERED_METHOD_NAME_PATTERNS) {
+            Matcher m = p.matcher(methodName);
+            if (m.find()) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/NativeLibraryMapInfo.java b/device_build_interfaces/com/android/tradefed/device/server/NativeLibraryMapInfo.java
new file mode 100644
index 000000000..d134c2b4f
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/NativeLibraryMapInfo.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.server;
+
+/**
+ * Memory address to library mapping for native libraries.
+ *
+ * <p>Each instance represents a single native library and its start and end memory addresses.
+ */
+public final class NativeLibraryMapInfo {
+    private long mStartAddr;
+    private long mEndAddr;
+
+    private String mLibrary;
+
+    /**
+     * Constructs a new native library map info.
+     *
+     * @param startAddr The start address of the library.
+     * @param endAddr The end address of the library.
+     * @param library The name of the library.
+     */
+    NativeLibraryMapInfo(long startAddr, long endAddr, String library) {
+        this.mStartAddr = startAddr;
+        this.mEndAddr = endAddr;
+        this.mLibrary = library;
+    }
+
+    /** Returns the name of the library. */
+    public String getLibraryName() {
+        return mLibrary;
+    }
+
+    /** Returns the start address of the library. */
+    public long getStartAddress() {
+        return mStartAddr;
+    }
+
+    /** Returns the end address of the library. */
+    public long getEndAddress() {
+        return mEndAddr;
+    }
+
+    /**
+     * Returns whether the specified address is inside the library.
+     *
+     * @param address The address to test.
+     * @return <code>true</code> if the address is between the start and end address of the library.
+     * @see #getStartAddress()
+     * @see #getEndAddress()
+     */
+    public boolean isWithinLibrary(long address) {
+        return address >= mStartAddr && address <= mEndAddr;
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/NativeStackCallInfo.java b/device_build_interfaces/com/android/tradefed/device/server/NativeStackCallInfo.java
new file mode 100644
index 000000000..3199dfec1
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/NativeStackCallInfo.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.server;
+
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/** Represents a stack call. This is used to return all of the call information as one object. */
+public final class NativeStackCallInfo {
+    private static final Pattern SOURCE_NAME_PATTERN =
+            Pattern.compile("^(.+):(\\d+)(\\s+\\(discriminator\\s+\\d+\\))?$");
+
+    /** address of this stack frame */
+    private long mAddress;
+
+    /** name of the library */
+    private String mLibrary;
+
+    /** name of the method */
+    private String mMethod;
+
+    /**
+     * name of the source file + line number in the format<br>
+     * &lt;sourcefile&gt;:&lt;linenumber&gt;
+     */
+    private String mSourceFile;
+
+    private int mLineNumber = -1;
+
+    /**
+     * Basic constructor with library, method, and sourcefile information
+     *
+     * @param address address of this stack frame
+     * @param lib The name of the library
+     * @param method the name of the method
+     * @param sourceFile the name of the source file and the line number as
+     *     "[sourcefile]:[fileNumber]"
+     */
+    public NativeStackCallInfo(long address, String lib, String method, String sourceFile) {
+        mAddress = address;
+        mLibrary = lib;
+        mMethod = method;
+
+        Matcher m = SOURCE_NAME_PATTERN.matcher(sourceFile);
+        if (m.matches()) {
+            mSourceFile = m.group(1);
+            try {
+                mLineNumber = Integer.parseInt(m.group(2));
+            } catch (NumberFormatException e) {
+                // do nothing, the line number will stay at -1
+            }
+            if (m.groupCount() == 3 && m.group(3) != null) {
+                // A discriminator was found, add that in the source file name.
+                mSourceFile += m.group(3);
+            }
+        } else {
+            mSourceFile = sourceFile;
+        }
+    }
+
+    /** Returns the address of this stack frame. */
+    public long getAddress() {
+        return mAddress;
+    }
+
+    /** Returns the name of the library name. */
+    public String getLibraryName() {
+        return mLibrary;
+    }
+
+    /** Returns the name of the method. */
+    public String getMethodName() {
+        return mMethod;
+    }
+
+    /** Returns the name of the source file. */
+    public String getSourceFile() {
+        return mSourceFile;
+    }
+
+    /** Returns the line number, or -1 if unknown. */
+    public int getLineNumber() {
+        return mLineNumber;
+    }
+
+    @Override
+    public String toString() {
+        return String.format(
+                "\t%1$08x\t%2$s --- %3$s --- %4$s:%5$d",
+                getAddress(), getLibraryName(), getMethodName(), getSourceFile(), getLineNumber());
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/ProfileableClient.java b/device_build_interfaces/com/android/tradefed/device/server/ProfileableClient.java
new file mode 100644
index 000000000..3b7f10ff6
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/ProfileableClient.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.device.server;
+
+import com.android.annotations.NonNull;
+
+/**
+ * This represents a single profilealbe client, usually an Android VM process.
+ *
+ * <p>This class gives access to basic client information.
+ *
+ * <p>More detailed information, usually updated in real time, can be access through the {@link
+ * ProfileableClientData} class. Each <code>ProfileableClient</code> object has its own <code>
+ * ProfileableClientData</code> accessed through {@link #getProfileableClientData()}.
+ */
+public interface ProfileableClient {
+    /** Returns the {@link ProfileableClientData} object containing this client information. */
+    @NonNull
+    ProfileableClientData getProfileableClientData();
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/ProfileableClientData.java b/device_build_interfaces/com/android/tradefed/device/server/ProfileableClientData.java
new file mode 100644
index 000000000..5468244c4
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/ProfileableClientData.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.device.server;
+
+import com.android.annotations.NonNull;
+
+/** Contains the data of a {@link ProfileableClientImpl}. */
+public class ProfileableClientData {
+    // the client's process ID
+    private final int mPid;
+
+    // client's underlying package name.
+    @NonNull private String mProcessName;
+
+    // client's ABI
+    @NonNull private String mAbi;
+
+    /** Generic constructor. */
+    public ProfileableClientData(int pid, @NonNull String processName, @NonNull String abi) {
+        mPid = pid;
+        mProcessName = processName;
+        mAbi = abi;
+    }
+
+    /** Returns the process ID. */
+    public int getPid() {
+        return mPid;
+    }
+
+    /** Returns the application's process name. */
+    @NonNull
+    public String getProcessName() {
+        return mProcessName;
+    }
+
+    /** Returns the abi flavor (32-bit or 64-bit) of the application, null if unknown or not set. */
+    @NonNull
+    public String getAbi() {
+        return mAbi;
+    }
+
+    public void setProcessName(@NonNull String name) {
+        mProcessName = name;
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/ProfileableClientImpl.java b/device_build_interfaces/com/android/tradefed/device/server/ProfileableClientImpl.java
new file mode 100644
index 000000000..e9fcc00fd
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/ProfileableClientImpl.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.device.server;
+
+import com.android.annotations.NonNull;
+
+/**
+ * This represents a single profileable client, usually a Dalvik VM process.
+ *
+ * <p>This class gives access to basic client information.
+ */
+public class ProfileableClientImpl implements ProfileableClient {
+    // chunk handlers stash state data in here
+    private ProfileableClientData mClientData;
+
+    /** Create an object for a new profileable client. */
+    ProfileableClientImpl(int pid, @NonNull String processName, @NonNull String abi) {
+        mClientData = new ProfileableClientData(pid, processName, abi);
+    }
+
+    /** Returns the {@link ProfileableClientData} object containing this client information. */
+    @Override
+    @NonNull
+    public ProfileableClientData getProfileableClientData() {
+        return mClientData;
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/RemoteSplitApkInstaller.java b/device_build_interfaces/com/android/tradefed/device/server/RemoteSplitApkInstaller.java
new file mode 100644
index 000000000..827df33ac
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/RemoteSplitApkInstaller.java
@@ -0,0 +1,178 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.device.server;
+
+import com.android.annotations.NonNull;
+import com.android.ddmlib.IDevice;
+import com.android.ddmlib.InstallException;
+import com.android.ddmlib.InstallReceiver;
+import com.android.tradefed.log.Log;
+
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+
+public class RemoteSplitApkInstaller extends SplitApkInstallerBase {
+    private static final String LOG_TAG = "RemoteSplitApkInstaller";
+
+    @NonNull private final List<String> mRemoteApkPaths;
+
+    private RemoteSplitApkInstaller(
+            @NonNull IDevice device, @NonNull List<String> remoteApks, @NonNull String options) {
+        super(device, options);
+        this.mRemoteApkPaths = remoteApks;
+    }
+
+    /**
+     * Installs an Android application made of several APK files sitting locally on the device
+     *
+     * @param timeout installation timeout
+     * @param timeoutUnit {@link TimeUnit} corresponding to the timeout parameter
+     * @throws InstallException if the installation fails.
+     */
+    public void install(long timeout, @NonNull TimeUnit unit) throws InstallException {
+        try {
+            // create a installation session.
+            String sessionId = createMultiInstallSession(getOptions(), timeout, unit);
+
+            // install-write each APK with the same sessionId.
+            boolean allWriteSucceeded = true;
+            for (String apkPath : mRemoteApkPaths) {
+                Log.d(
+                        LOG_TAG,
+                        String.format("Add apk %s to install session %s", apkPath, sessionId));
+                allWriteSucceeded = writeRemoteApk(sessionId, apkPath, timeout, unit);
+                if (!allWriteSucceeded) {
+                    Log.e(
+                            LOG_TAG,
+                            String.format(
+                                    "Failed to write install session %s with %s",
+                                    sessionId, apkPath));
+                    break;
+                }
+            }
+
+            // if all files were upload successfully, commit otherwise abandon the installation.
+            if (!allWriteSucceeded) {
+                installAbandon(sessionId, timeout, unit);
+                throw new InstallException("Failed to install-write all apks");
+            } else {
+                installCommit(sessionId, timeout, unit);
+                Log.d(LOG_TAG, "Successfully install apks: " + mRemoteApkPaths.toString());
+            }
+        } catch (InstallException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new InstallException(e);
+        }
+    }
+
+    protected boolean writeRemoteApk(
+            @NonNull String sessionId,
+            @NonNull String filePath,
+            long timeout,
+            @NonNull TimeUnit unit) {
+        String baseName =
+                filePath.lastIndexOf('/') != -1
+                        ? filePath.substring(filePath.lastIndexOf('/'), filePath.length())
+                        : filePath;
+
+        baseName = UNSAFE_PM_INSTALL_SESSION_SPLIT_NAME_CHARS.replaceFrom(baseName, '_');
+
+        String command =
+                String.format(
+                        getPrefix() + " install-write %s %s %s", sessionId, baseName, filePath);
+
+        Log.d(LOG_TAG, String.format("Executing : %s", command));
+        try {
+            InstallReceiver receiver = new InstallReceiver();
+            getDevice().executeShellCommand(command, receiver, timeout, unit);
+            if (receiver.isSuccessfullyCompleted()) {
+                Log.d(
+                        LOG_TAG,
+                        String.format(
+                                "Successfully add %s to install session %s", filePath, sessionId));
+            } else {
+                if (receiver.getErrorMessage() != null) {
+                    Log.e(
+                            LOG_TAG,
+                            String.format(
+                                    "Error install-write %s to session %s by command %s: %s",
+                                    filePath, sessionId, command, receiver.getErrorMessage()));
+                } else {
+                    Log.e(
+                            LOG_TAG,
+                            String.format(
+                                    "Failed to install-write session %s with %s by command %s",
+                                    sessionId, filePath, command));
+                }
+            }
+            return receiver.isSuccessfullyCompleted();
+        } catch (Exception e) {
+            Log.e(LOG_TAG, String.format("%s failed with error %s", command, e));
+            return false;
+        }
+    }
+
+    private static void validateArguments(@NonNull IDevice device, @NonNull List<String> apks) {
+
+        if (apks.isEmpty()) {
+            throw new IllegalArgumentException(
+                    "List of APKs is empty: the main APK must be specified.");
+        }
+    }
+
+    /**
+     * Returns a {@link SplitApkInstaller} for the given list of APKs that are already uploaded to
+     * the given device.
+     *
+     * @param device the device to install APK, must include at least the main APK.
+     * @param applicationId the application id that to install new APKs with.
+     * @param apks list of remote APKs.
+     * @param reInstall whether to enable reinstall option.
+     * @param pmOptions list of install options.
+     */
+    public static RemoteSplitApkInstaller create(
+            @NonNull IDevice device,
+            @NonNull List<String> remoteApks,
+            boolean reInstall,
+            @NonNull List<String> installOptions) {
+        validateArguments(device, remoteApks);
+        return new RemoteSplitApkInstaller(
+                device, remoteApks, getOptions(reInstall, installOptions));
+    }
+
+    /**
+     * Returns a {@link SplitApkInstaller} to install given list of APKs that are already uploaded
+     * to the given device to an existing application on the device.
+     *
+     * @param device the device to install APK.
+     * @param applicationId the application id of the existing application that to install new APKs
+     *     with.
+     * @param apks list of remote APKs.
+     * @param reInstall whether to enable reinstall option.
+     * @param pmOptions list of install options.
+     */
+    public static RemoteSplitApkInstaller create(
+            @NonNull IDevice device,
+            @NonNull String applicationId,
+            @NonNull List<String> remoteApks,
+            boolean reInstall,
+            @NonNull List<String> installOptions) {
+        validateArguments(device, remoteApks);
+        return new RemoteSplitApkInstaller(
+                device, remoteApks, getOptions(reInstall, true, applicationId, installOptions));
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/SplitApkInstaller.java b/device_build_interfaces/com/android/tradefed/device/server/SplitApkInstaller.java
new file mode 100644
index 000000000..dceb2e041
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/SplitApkInstaller.java
@@ -0,0 +1,232 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.device.server;
+
+import com.android.annotations.NonNull;
+import com.android.ddmlib.IDevice;
+import com.android.ddmlib.InstallException;
+import com.android.ddmlib.InstallMetrics;
+import com.android.ddmlib.InstallReceiver;
+import com.android.tradefed.log.Log;
+
+import java.io.BufferedInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+
+public class SplitApkInstaller extends SplitApkInstallerBase {
+    private static final String LOG_TAG = "SplitApkInstaller";
+
+    @NonNull private final List<File> mApks;
+
+    private SplitApkInstaller(
+            @NonNull IDevice device, @NonNull List<File> apks, @NonNull String options) {
+        super(device, options);
+        this.mApks = apks;
+    }
+
+    /**
+     * Installs an Android application made of several APK files by streaming from files on host
+     *
+     * @param timeout installation timeout
+     * @param timeoutUnit {@link TimeUnit} corresponding to the timeout parameter
+     * @return {@link InstallMetrics} metrics for time elapsed during this installation
+     * @throws InstallException if the installation fails.
+     */
+    public InstallMetrics install(long timeout, @NonNull TimeUnit unit) throws InstallException {
+        // Installing multiple APK's is performed as follows:
+        //  # First we create a install session passing in the total size of all APKs
+        //      $ [pm|cmd package] install-create -S <total_size>
+        //      Success: [integer-session-id]   # error if session-id < 0
+        //  # Then for each APK, we perform the following. A unique id per APK is generated
+        //  # as <index>_<name>, the - at the end means that the APK is streamed via stdin
+        //      $ [pm|cmd package] install-write -S <session-id> <per_apk_unique_id> -
+        //  # Finally, we close the session
+        //      $ [pm|cmd package] install-commit <session-id>  (or)
+        //      $ [pm|cmd package] install-abandon <session-id>
+
+        try {
+            // create a installation session.
+            long totalFileSize = 0L;
+            for (File apkFile : mApks) {
+                totalFileSize += apkFile.length();
+            }
+            String option = String.format("-S %d", totalFileSize);
+            if (getOptions() != null) {
+                option = getOptions() + " " + option;
+            }
+            String sessionId = createMultiInstallSession(option, timeout, unit);
+
+            // now upload each APK in turn.
+            int index = 0;
+            boolean allUploadSucceeded = true;
+
+            long uploadStartNs = System.nanoTime();
+            while (allUploadSucceeded && index < mApks.size()) {
+                allUploadSucceeded = uploadApk(sessionId, mApks.get(index), index++, timeout, unit);
+            }
+
+            // if all files were upload successfully, commit otherwise abandon the installation.
+            long uploadFinishNs = System.nanoTime();
+            if (!allUploadSucceeded) {
+                installAbandon(sessionId, timeout, unit);
+                throw new InstallException("Failed to install-write all apks");
+            } else {
+                installCommit(sessionId, timeout, unit);
+                Log.d(LOG_TAG, "Successfully install apks: " + mApks.toString());
+            }
+
+            return new InstallMetrics(
+                    uploadStartNs, uploadFinishNs, uploadFinishNs, System.nanoTime());
+        } catch (InstallException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new InstallException(e);
+        }
+    }
+
+    protected boolean uploadApk(
+            @NonNull String sessionId,
+            @NonNull File fileToUpload,
+            int uniqueId,
+            long timeout,
+            @NonNull TimeUnit unit) {
+        Log.i(
+                LOG_TAG,
+                String.format("Uploading APK %s to session %s", fileToUpload.getPath(), sessionId));
+        if (!fileToUpload.exists()) {
+            Log.e(LOG_TAG, String.format("File not found: %1$s", fileToUpload.getPath()));
+            return false;
+        }
+        if (fileToUpload.isDirectory()) {
+            Log.e(
+                    LOG_TAG,
+                    String.format(
+                            "Directory upload not supported: %s", fileToUpload.getAbsolutePath()));
+            return false;
+        }
+        String baseName =
+                fileToUpload.getName().lastIndexOf('.') != -1
+                        ? fileToUpload
+                                .getName()
+                                .substring(0, fileToUpload.getName().lastIndexOf('.'))
+                        : fileToUpload.getName();
+
+        baseName = UNSAFE_PM_INSTALL_SESSION_SPLIT_NAME_CHARS.replaceFrom(baseName, '_');
+
+        String command =
+                String.format(
+                        getPrefix() + " install-write -S %d %s %d_%s -",
+                        fileToUpload.length(),
+                        sessionId,
+                        uniqueId,
+                        baseName);
+
+        Log.d(LOG_TAG, String.format("Executing : %1$s", command));
+        InputStream inputStream = null;
+        try {
+            inputStream = new BufferedInputStream(new FileInputStream(fileToUpload));
+            InstallReceiver receiver = new InstallReceiver();
+            AdbHelper.executeRemoteCommand(
+                    AndroidDebugBridge.getSocketAddress(),
+                    AdbHelper.AdbService.EXEC,
+                    command,
+                    getDevice(),
+                    receiver,
+                    timeout,
+                    unit,
+                    inputStream);
+            if (receiver.isSuccessfullyCompleted()) {
+                Log.d(LOG_TAG, String.format("Successfully uploaded %1$s", fileToUpload.getName()));
+            } else {
+                Log.e(
+                        LOG_TAG,
+                        String.format(
+                                "Error while uploading %1$s : %2$s",
+                                fileToUpload.getName(), receiver.getErrorMessage()));
+            }
+            return receiver.isSuccessfullyCompleted();
+        } catch (Exception e) {
+            Log.e(sessionId, e);
+            return false;
+        } finally {
+            if (inputStream != null) {
+                try {
+                    inputStream.close();
+                } catch (IOException e) {
+                    Log.e(sessionId, e);
+                }
+            }
+        }
+    }
+
+    private static void validateArguments(@NonNull IDevice device, @NonNull List<File> apks) {
+
+        if (apks.isEmpty()) {
+            throw new IllegalArgumentException(
+                    "List of APKs is empty: the main APK must be specified.");
+        }
+
+        for (File apk : apks) {
+            if (!apk.isFile()) {
+                throw new IllegalArgumentException("Invalid File: " + apk.getPath());
+            }
+        }
+    }
+
+    /**
+     * Returns a {@link SplitApkInstaller} for the given list of APK files from host to the given
+     * device.
+     *
+     * @param device the device to install APK, must include at least the main APK.
+     * @param apks list of APK files.
+     * @param reInstall whether to enable reinstall option.
+     * @param options list of install options.
+     */
+    public static SplitApkInstaller create(
+            @NonNull IDevice device,
+            @NonNull List<File> apks,
+            boolean reInstall,
+            @NonNull List<String> installOptions) {
+        validateArguments(device, apks);
+        return new SplitApkInstaller(device, apks, getOptions(reInstall, installOptions));
+    }
+
+    /**
+     * Returns a {@link SplitApkInstaller} to install given list of APK files from host to an
+     * existing application on the given device.
+     *
+     * @param device the device to install APK.
+     * @param applicationId the application id of the existing application that to install new APKs
+     *     with.
+     * @param apks list of APK files.
+     * @param reInstall whether to enable reinstall option.
+     * @param pmOptions list of install options.
+     */
+    public static SplitApkInstaller create(
+            @NonNull IDevice device,
+            @NonNull String applicationId,
+            @NonNull List<File> apks,
+            boolean reInstall,
+            @NonNull List<String> installOptions) {
+        validateArguments(device, apks);
+        return new SplitApkInstaller(
+                device, apks, getOptions(reInstall, true, applicationId, installOptions));
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/SplitApkInstallerBase.java b/device_build_interfaces/com/android/tradefed/device/server/SplitApkInstallerBase.java
new file mode 100644
index 000000000..ecbd26fd2
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/SplitApkInstallerBase.java
@@ -0,0 +1,187 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.device.server;
+
+import com.android.annotations.NonNull;
+import com.android.ddmlib.AdbCommandRejectedException;
+import com.android.ddmlib.IDevice;
+import com.android.ddmlib.InstallCreateReceiver;
+import com.android.ddmlib.InstallException;
+import com.android.ddmlib.InstallReceiver;
+import com.android.ddmlib.ShellCommandUnresponsiveException;
+import com.android.ddmlib.TimeoutException;
+import com.android.tradefed.log.Log;
+
+import com.google.common.base.CharMatcher;
+import com.google.common.base.Joiner;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+
+public abstract class SplitApkInstallerBase {
+    private static final String LOG_TAG = "SplitApkInstallerBase";
+
+    @NonNull private final IDevice mDevice;
+    @NonNull private final String mOptions;
+    @NonNull private final String mPrefix;
+
+    protected SplitApkInstallerBase(@NonNull IDevice device, @NonNull String options) {
+        this.mDevice = device;
+        this.mOptions = options;
+        /*this.mPrefix =
+        mDevice.getVersion()
+                        .isGreaterOrEqualThan(
+                                AndroidVersion.BINDER_CMD_AVAILABLE.getApiLevel())
+                ? "cmd package"
+                : "pm";*/
+        this.mPrefix = "cmd package";
+    }
+
+    protected String createMultiInstallSession(
+            @NonNull String options, long timeout, @NonNull TimeUnit unit)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    ShellCommandUnresponsiveException,
+                    IOException,
+                    InstallException {
+
+        InstallCreateReceiver receiver = new InstallCreateReceiver();
+        String cmd = mPrefix + " install-create";
+        if (!options.trim().isEmpty()) {
+            cmd = cmd + " " + options;
+        }
+        mDevice.executeShellCommand(cmd, receiver, timeout, unit);
+        String sessionId = receiver.getSessionId();
+        if (sessionId == null) {
+            String message = String.format("'%s'", cmd);
+            if (receiver.getErrorMessage() != null) {
+                message =
+                        String.format("%s returns error '%s'", message, receiver.getErrorMessage());
+            } else if (receiver.getSuccessMessage() != null) {
+                message =
+                        String.format(
+                                "%s returns '%s' without session ID",
+                                message, receiver.getSuccessMessage());
+            } else {
+                message = String.format("Failed to create install session with %s", message);
+            }
+            Log.e(LOG_TAG, message);
+            throw new InstallException(message);
+        }
+        Log.i(
+                LOG_TAG,
+                String.format("Created install session %s with options %s", sessionId, options));
+        return sessionId;
+    }
+
+    protected static final CharMatcher UNSAFE_PM_INSTALL_SESSION_SPLIT_NAME_CHARS =
+            CharMatcher.inRange('a', 'z')
+                    .or(CharMatcher.inRange('A', 'Z'))
+                    .or(CharMatcher.anyOf("_-"))
+                    .negate();
+
+    protected void installCommit(@NonNull String sessionId, long timeout, @NonNull TimeUnit unit)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    ShellCommandUnresponsiveException,
+                    IOException,
+                    InstallException {
+        String command = mPrefix + " install-commit " + sessionId;
+        InstallReceiver receiver = new InstallReceiver();
+        mDevice.executeShellCommand(command, receiver, timeout, unit);
+        if (!receiver.isSuccessfullyCompleted()) {
+            String message =
+                    String.format(
+                            "Failed to commit install session %s with command %s.",
+                            sessionId, command);
+            if (receiver.getErrorMessage() != null) {
+                message += String.format(" Error: %s", receiver.getErrorMessage());
+            }
+            Log.e(LOG_TAG, message);
+            throw new InstallException(message, receiver.getErrorCode());
+        }
+    }
+
+    protected void installAbandon(@NonNull String sessionId, long timeout, @NonNull TimeUnit unit)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    ShellCommandUnresponsiveException,
+                    IOException,
+                    InstallException {
+        String command = mPrefix + " install-abandon " + sessionId;
+        InstallReceiver receiver = new InstallReceiver();
+        mDevice.executeShellCommand(command, receiver, timeout, unit);
+        if (!receiver.isSuccessfullyCompleted()) {
+            Log.e(LOG_TAG, String.format("Failed to abandon install session %s", sessionId));
+        }
+    }
+
+    @NonNull
+    protected IDevice getDevice() {
+        return mDevice;
+    }
+
+    @NonNull
+    protected String getPrefix() {
+        return mPrefix;
+    }
+
+    @NonNull
+    protected String getOptions() {
+        return mOptions;
+    }
+
+    @NonNull
+    protected static String getOptions(boolean reInstall, @NonNull List<String> installOptions) {
+        return getOptions(reInstall, false, null, installOptions);
+    }
+
+    @NonNull
+    protected static String getOptions(
+            boolean reInstall,
+            boolean partialInstall,
+            String applicationId,
+            @NonNull List<String> installOptions) {
+        StringBuilder sb = new StringBuilder();
+
+        if (reInstall) {
+            sb.append("-r");
+        }
+
+        if (partialInstall) {
+            if (sb.length() > 0) {
+                sb.append(" ");
+            }
+            if (applicationId == null) {
+                throw new IllegalArgumentException(
+                        "Cannot do a partial install without knowing the application id");
+            }
+
+            sb.append("-p ");
+            sb.append(applicationId);
+        }
+
+        if (!installOptions.isEmpty()) {
+            if (sb.length() > 0) {
+                sb.append(" ");
+            }
+            sb.append(Joiner.on(" ").join(installOptions));
+        }
+
+        return sb.toString();
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/SyncService.java b/device_build_interfaces/com/android/tradefed/device/server/SyncService.java
new file mode 100644
index 000000000..67cfe8c9c
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/SyncService.java
@@ -0,0 +1,933 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.device.server;
+
+import com.android.annotations.NonNull;
+import com.android.annotations.Nullable;
+import com.android.ddmlib.AdbCommandRejectedException;
+import com.android.ddmlib.DdmPreferences;
+import com.android.ddmlib.FileListingService;
+import com.android.ddmlib.FileListingService.FileEntry;
+import com.android.ddmlib.IDevice;
+import com.android.ddmlib.SyncException;
+import com.android.ddmlib.SyncException.SyncError;
+import com.android.ddmlib.TimeoutException;
+import com.android.ddmlib.utils.ArrayHelper;
+import com.android.ddmlib.utils.FilePermissionUtil;
+import com.android.tradefed.device.server.AdbHelper.AdbResponse;
+import com.android.tradefed.log.Log;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.nio.channels.SocketChannel;
+import java.util.ArrayList;
+import java.util.Date;
+
+/**
+ * Sync service class to push/pull to/from devices/emulators, through the debug bridge.
+ *
+ * <p>To get a {@link SyncService} object, use {@link IDevice#getSyncService()}.
+ */
+public class SyncService implements AutoCloseable {
+
+    private static final byte[] ID_OKAY = {'O', 'K', 'A', 'Y'};
+    private static final byte[] ID_FAIL = {'F', 'A', 'I', 'L'};
+    private static final byte[] ID_STAT = {'S', 'T', 'A', 'T'};
+    private static final byte[] ID_RECV = {'R', 'E', 'C', 'V'};
+    private static final byte[] ID_DATA = {'D', 'A', 'T', 'A'};
+    private static final byte[] ID_DONE = {'D', 'O', 'N', 'E'};
+    private static final byte[] ID_SEND = {'S', 'E', 'N', 'D'};
+    //    private final static byte[] ID_LIST = { 'L', 'I', 'S', 'T' };
+    //    private final static byte[] ID_DENT = { 'D', 'E', 'N', 'T' };
+
+    private static final NullSyncProgressMonitor sNullSyncProgressMonitor =
+            new NullSyncProgressMonitor();
+
+    private static final int S_ISOCK = 0xC000; // type: symbolic link
+    private static final int S_IFLNK = 0xA000; // type: symbolic link
+    private static final int S_IFREG = 0x8000; // type: regular file
+    private static final int S_IFBLK = 0x6000; // type: block device
+    private static final int S_IFDIR = 0x4000; // type: directory
+    private static final int S_IFCHR = 0x2000; // type: character device
+    private static final int S_IFIFO = 0x1000; // type: fifo
+    /*
+        private final static int S_ISUID = 0x0800; // set-uid bit
+        private final static int S_ISGID = 0x0400; // set-gid bit
+        private final static int S_ISVTX = 0x0200; // sticky bit
+        private final static int S_IRWXU = 0x01C0; // user permissions
+        private final static int S_IRUSR = 0x0100; // user: read
+        private final static int S_IWUSR = 0x0080; // user: write
+        private final static int S_IXUSR = 0x0040; // user: execute
+        private final static int S_IRWXG = 0x0038; // group permissions
+        private final static int S_IRGRP = 0x0020; // group: read
+        private final static int S_IWGRP = 0x0010; // group: write
+        private final static int S_IXGRP = 0x0008; // group: execute
+        private final static int S_IRWXO = 0x0007; // other permissions
+        private final static int S_IROTH = 0x0004; // other: read
+        private final static int S_IWOTH = 0x0002; // other: write
+        private final static int S_IXOTH = 0x0001; // other: execute
+    */
+
+    private static final int SYNC_DATA_MAX = 64 * 1024;
+    private static final int REMOTE_PATH_MAX_LENGTH = 1024;
+
+    /**
+     * Classes which implement this interface provide methods that deal with displaying transfer
+     * progress.
+     */
+    public interface ISyncProgressMonitor {
+        /**
+         * Sent when the transfer starts
+         *
+         * @param totalWork the total amount of work.
+         */
+        void start(int totalWork);
+
+        /** Sent when the transfer is finished or interrupted. */
+        void stop();
+
+        /**
+         * Sent to query for possible cancellation.
+         *
+         * @return true if the transfer should be stopped.
+         */
+        boolean isCanceled();
+
+        /**
+         * Sent when a sub task is started.
+         *
+         * @param name the name of the sub task.
+         */
+        void startSubTask(String name);
+
+        /**
+         * Sent when some progress have been made.
+         *
+         * @param work the amount of work done.
+         */
+        void advance(int work);
+    }
+
+    public static class FileStat {
+        private final int myMode;
+        private final int mySize;
+        private final Date myLastModified;
+
+        public FileStat(int mode, int size, int lastModifiedSecs) {
+            myMode = mode;
+            mySize = size;
+            myLastModified = new Date((long) lastModifiedSecs * 1000);
+        }
+
+        public int getMode() {
+            return myMode;
+        }
+
+        public int getSize() {
+            return mySize;
+        }
+
+        public Date getLastModified() {
+            return myLastModified;
+        }
+    }
+
+    /** A Sync progress monitor that does nothing */
+    private static class NullSyncProgressMonitor implements ISyncProgressMonitor {
+        @Override
+        public void advance(int work) {}
+
+        @Override
+        public boolean isCanceled() {
+            return false;
+        }
+
+        @Override
+        public void start(int totalWork) {}
+
+        @Override
+        public void startSubTask(String name) {}
+
+        @Override
+        public void stop() {}
+    }
+
+    private InetSocketAddress mAddress;
+    private IDevice mDevice;
+    private SocketChannel mChannel;
+
+    /** Buffer used to send data. Allocated when needed and reused afterward. */
+    private byte[] mBuffer;
+
+    /**
+     * Creates a Sync service object.
+     *
+     * @param address The address to connect to
+     * @param device the {@link IDevice} that the service connects to.
+     */
+    public SyncService(InetSocketAddress address, IDevice device) {
+        mAddress = address;
+        mDevice = device;
+    }
+
+    /**
+     * Opens the sync connection. This must be called before any calls to push[File] / pull[File].
+     *
+     * @return true if the connection opened, false if adb refuse the connection. This can happen if
+     *     the {@link IDevice} is invalid.
+     * @throws TimeoutException in case of timeout on the connection.
+     * @throws AdbCommandRejectedException if adb rejects the command
+     * @throws IOException If the connection to adb failed.
+     */
+    public boolean openSync() throws TimeoutException, AdbCommandRejectedException, IOException {
+        try {
+            mChannel = SocketChannel.open(mAddress);
+            mChannel.configureBlocking(false);
+
+            // target a specific device
+            AdbHelper.setDevice(mChannel, mDevice);
+
+            byte[] request = AdbHelper.formAdbRequest("sync:"); // $NON-NLS-1$
+            AdbHelper.write(mChannel, request, -1, DdmPreferences.getTimeOut());
+
+            AdbResponse resp = AdbHelper.readAdbResponse(mChannel, false /* readDiagString */);
+
+            if (!resp.okay) {
+                Log.w("ddms", "Got unhappy response from ADB sync req: " + resp.message);
+                mChannel.close();
+                mChannel = null;
+                return false;
+            }
+        } catch (TimeoutException e) {
+            if (mChannel != null) {
+                try {
+                    mChannel.close();
+                } catch (IOException e2) {
+                    // we want to throw the original exception, so we ignore this one.
+                }
+                mChannel = null;
+            }
+
+            throw e;
+        } catch (IOException e) {
+            if (mChannel != null) {
+                try {
+                    mChannel.close();
+                } catch (IOException e2) {
+                    // we want to throw the original exception, so we ignore this one.
+                }
+                mChannel = null;
+            }
+
+            throw e;
+        }
+
+        return true;
+    }
+
+    /** Closes the connection. */
+    @Override
+    public void close() {
+        if (mChannel != null) {
+            try {
+                mChannel.close();
+            } catch (IOException e) {
+                // nothing to be done really...
+            }
+            mChannel = null;
+        }
+    }
+
+    /**
+     * Returns a sync progress monitor that does nothing. This allows background tasks that don't
+     * want/need to display ui, to pass a valid {@link ISyncProgressMonitor}.
+     *
+     * <p>This object can be reused multiple times and can be used by concurrent threads.
+     */
+    public static ISyncProgressMonitor getNullProgressMonitor() {
+        return sNullSyncProgressMonitor;
+    }
+
+    /**
+     * Pulls file(s) or folder(s).
+     *
+     * @param entries the remote item(s) to pull
+     * @param localPath The local destination. If the entries count is &gt; 1 or if the unique entry
+     *     is a folder, this should be a folder.
+     * @param monitor The progress monitor. Cannot be null.
+     * @throws SyncException
+     * @throws IOException
+     * @throws TimeoutException
+     * @see FileListingService.FileEntry
+     * @see #getNullProgressMonitor()
+     */
+    public void pull(FileEntry[] entries, String localPath, ISyncProgressMonitor monitor)
+            throws SyncException, IOException, TimeoutException {
+
+        // first we check the destination is a directory and exists
+        File f = new File(localPath);
+        if (!f.exists()) {
+            throw new SyncException(SyncError.NO_DIR_TARGET);
+        }
+        if (!f.isDirectory()) {
+            throw new SyncException(SyncError.TARGET_IS_FILE);
+        }
+
+        // get a FileListingService object
+        FileListingService fls = new FileListingService(mDevice);
+
+        // compute the number of file to move
+        int total = getTotalRemoteFileSize(entries, fls);
+
+        // start the monitor
+        monitor.start(total);
+
+        doPull(entries, localPath, fls, monitor);
+
+        monitor.stop();
+    }
+
+    /**
+     * Pulls a single file.
+     *
+     * @param remote the remote file
+     * @param localFilename The local destination.
+     * @param monitor The progress monitor. Cannot be null.
+     * @throws IOException in case of an IO exception.
+     * @throws TimeoutException in case of a timeout reading responses from the device.
+     * @throws SyncException in case of a sync exception.
+     * @see FileListingService.FileEntry
+     * @see #getNullProgressMonitor()
+     */
+    public void pullFile(FileEntry remote, String localFilename, ISyncProgressMonitor monitor)
+            throws IOException, SyncException, TimeoutException {
+        int total = remote.getSizeValue();
+        monitor.start(total);
+
+        doPullFile(remote.getFullPath(), localFilename, monitor);
+
+        monitor.stop();
+    }
+
+    /**
+     * Pulls a single file.
+     *
+     * <p>Because this method just deals with a String for the remote file instead of a {@link
+     * FileEntry}, the size of the file being pulled is unknown and the {@link ISyncProgressMonitor}
+     * will not properly show the progress
+     *
+     * @param remoteFilepath the full path to the remote file
+     * @param localFilename The local destination.
+     * @param monitor The progress monitor. Cannot be null.
+     * @throws IOException in case of an IO exception.
+     * @throws TimeoutException in case of a timeout reading responses from the device.
+     * @throws SyncException in case of a sync exception.
+     * @see #getNullProgressMonitor()
+     */
+    public void pullFile(String remoteFilepath, String localFilename, ISyncProgressMonitor monitor)
+            throws TimeoutException, IOException, SyncException {
+        FileStat fileStat = statFile(remoteFilepath);
+        if (fileStat == null) {
+            // attempts to download anyway
+        } else if (fileStat.getMode() == 0) {
+            throw new SyncException(SyncError.NO_REMOTE_OBJECT);
+        }
+
+        monitor.start(0);
+        // TODO: use the {@link FileListingService} to get the file size.
+
+        doPullFile(remoteFilepath, localFilename, monitor);
+
+        monitor.stop();
+    }
+
+    /**
+     * Pushes several files or directories.
+     *
+     * @param local the local files to push
+     * @param remote the remote {@link FileEntry} representing a directory
+     * @param monitor The progress monitor
+     * @throws SyncException if some files could not be pushed
+     * @throws IOException in case of I/O error on the connection
+     * @throws TimeoutException in case of a timeout reading responses from the device
+     */
+    public void push(
+            @NonNull String[] local,
+            @NonNull FileEntry remote,
+            @NonNull ISyncProgressMonitor monitor)
+            throws SyncException, IOException, TimeoutException {
+        if (!remote.isDirectory()) {
+            throw new SyncException(SyncError.REMOTE_IS_FILE);
+        }
+
+        push(local, remote.getFullPath(), monitor);
+    }
+
+    /**
+     * Pushes several files or directories.
+     *
+     * @param local the local files to push
+     * @param remote the remote path representing a directory
+     * @param monitor The progress monitor
+     * @throws SyncException if some files could not be pushed
+     * @throws IOException in case of I/O error on the connection
+     * @throws TimeoutException in case of a timeout reading responses from the device
+     */
+    public void push(
+            @NonNull String[] local, @NonNull String remote, @NonNull ISyncProgressMonitor monitor)
+            throws SyncException, IOException, TimeoutException {
+        // Make a list of File from the list of String
+        ArrayList<File> files = new ArrayList<>();
+        for (String path : local) {
+            files.add(new File(path));
+        }
+
+        // get the total count of the bytes to transfer
+        File[] fileArray = files.toArray(new File[0]);
+        int total = getTotalLocalFileSize(fileArray);
+
+        monitor.start(total);
+
+        doPush(fileArray, remote, monitor);
+
+        monitor.stop();
+    }
+
+    /**
+     * Push a single file.
+     *
+     * @param local the local filepath.
+     * @param remote The remote filepath.
+     * @param monitor The progress monitor. Cannot be null.
+     * @throws SyncException if file could not be pushed
+     * @throws IOException in case of I/O error on the connection.
+     * @throws TimeoutException in case of a timeout reading responses from the device.
+     */
+    public void pushFile(String local, String remote, ISyncProgressMonitor monitor)
+            throws SyncException, IOException, TimeoutException {
+        File f = new File(local);
+        if (!f.exists()) {
+            throw new SyncException(SyncError.NO_LOCAL_FILE);
+        }
+
+        if (f.isDirectory()) {
+            throw new SyncException(SyncError.LOCAL_IS_DIRECTORY);
+        }
+
+        monitor.start((int) f.length());
+
+        doPushFile(local, remote, monitor);
+
+        monitor.stop();
+    }
+
+    /**
+     * compute the recursive file size of all the files in the list. Folder have a weight of 1.
+     *
+     * @param entries
+     * @param fls
+     * @return
+     */
+    private int getTotalRemoteFileSize(FileEntry[] entries, FileListingService fls) {
+        int count = 0;
+        for (FileEntry e : entries) {
+            int type = e.getType();
+            if (type == FileListingService.TYPE_DIRECTORY) {
+                // get the children
+                FileEntry[] children = fls.getChildren(e, false, null);
+                count += getTotalRemoteFileSize(children, fls) + 1;
+            } else if (type == FileListingService.TYPE_FILE) {
+                count += e.getSizeValue();
+            }
+        }
+
+        return count;
+    }
+
+    /**
+     * compute the recursive file size of all the files in the list. Folder have a weight of 1. This
+     * does not check for circular links.
+     *
+     * @param files
+     * @return
+     */
+    private int getTotalLocalFileSize(File[] files) {
+        int count = 0;
+
+        for (File f : files) {
+            if (f.exists()) {
+                if (f.isDirectory()) {
+                    return getTotalLocalFileSize(f.listFiles()) + 1;
+                } else if (f.isFile()) {
+                    count += f.length();
+                }
+            }
+        }
+
+        return count;
+    }
+
+    /**
+     * Pulls multiple files/folders recursively.
+     *
+     * @param entries The list of entry to pull
+     * @param localPath the localpath to a directory
+     * @param fileListingService a FileListingService object to browse through remote directories.
+     * @param monitor the progress monitor. Must be started already.
+     * @throws SyncException if file could not be pushed
+     * @throws IOException in case of I/O error on the connection.
+     * @throws TimeoutException in case of a timeout reading responses from the device.
+     */
+    private void doPull(
+            FileEntry[] entries,
+            String localPath,
+            FileListingService fileListingService,
+            ISyncProgressMonitor monitor)
+            throws SyncException, IOException, TimeoutException {
+
+        for (FileEntry e : entries) {
+            // check if we're cancelled
+            if (monitor.isCanceled()) {
+                throw new SyncException(SyncError.CANCELED);
+            }
+
+            // get type (we only pull directory and files for now)
+            int type = e.getType();
+            if (type == FileListingService.TYPE_DIRECTORY) {
+                monitor.startSubTask(e.getFullPath());
+                String dest = localPath + File.separator + e.getName();
+
+                // make the directory
+                File d = new File(dest);
+                d.mkdir();
+
+                // then recursively call the content. Since we did a ls command
+                // to get the number of files, we can use the cache
+                FileEntry[] children = fileListingService.getChildren(e, true, null);
+                doPull(children, dest, fileListingService, monitor);
+                monitor.advance(1);
+            } else if (type == FileListingService.TYPE_FILE) {
+                monitor.startSubTask(e.getFullPath());
+                String dest = localPath + File.separator + e.getName();
+                doPullFile(e.getFullPath(), dest, monitor);
+            }
+        }
+    }
+
+    /**
+     * Pulls a remote file
+     *
+     * @param remotePath the remote file (length max is 1024)
+     * @param localPath the local destination
+     * @param monitor the monitor. The monitor must be started already.
+     * @throws SyncException if file could not be pushed
+     * @throws IOException in case of I/O error on the connection.
+     * @throws TimeoutException in case of a timeout reading responses from the device.
+     */
+    private void doPullFile(String remotePath, String localPath, ISyncProgressMonitor monitor)
+            throws IOException, SyncException, TimeoutException {
+        byte[] msg = null;
+        byte[] pullResult = new byte[8];
+
+        final int timeOut = DdmPreferences.getTimeOut();
+        byte[] remotePathContent = remotePath.getBytes(AdbHelper.DEFAULT_CHARSET);
+
+        if (remotePathContent.length > REMOTE_PATH_MAX_LENGTH) {
+            throw new SyncException(SyncError.REMOTE_PATH_LENGTH);
+        }
+
+        // create the full request message
+        msg = createFileReq(ID_RECV, remotePathContent);
+
+        // and send it.
+        AdbHelper.write(mChannel, msg, -1, timeOut);
+
+        // read the result, in a byte array containing 2 ints (id, size)
+        AdbHelper.read(mChannel, pullResult, -1, timeOut);
+
+        // check we have the proper data back
+        if (!checkResult(pullResult, ID_DATA) && !checkResult(pullResult, ID_DONE)) {
+            throw new SyncException(
+                    SyncError.TRANSFER_PROTOCOL_ERROR, readErrorMessage(pullResult, timeOut));
+        }
+
+        // access the destination file
+        File f = new File(localPath);
+
+        // create the stream to write in the file. We use a new try/catch block to differentiate
+        // between file and network io exceptions.
+        FileOutputStream fos = null;
+        try {
+            fos = new FileOutputStream(f);
+
+            // the buffer to read the data
+            byte[] data = new byte[SYNC_DATA_MAX];
+
+            // loop to get data until we're done.
+            while (true) {
+                // check if we're cancelled
+                if (monitor.isCanceled()) {
+                    throw new SyncException(SyncError.CANCELED);
+                }
+
+                // if we're done, we stop the loop
+                if (checkResult(pullResult, ID_DONE)) {
+                    break;
+                }
+                if (!checkResult(pullResult, ID_DATA)) {
+                    // hmm there's an error
+                    throw new SyncException(
+                            SyncError.TRANSFER_PROTOCOL_ERROR,
+                            readErrorMessage(pullResult, timeOut));
+                }
+                int length = ArrayHelper.swap32bitFromArray(pullResult, 4);
+                if (length > SYNC_DATA_MAX) {
+                    // buffer overrun!
+                    // error and exit
+                    throw new SyncException(SyncError.BUFFER_OVERRUN);
+                }
+
+                // now read the length we received
+                AdbHelper.read(mChannel, data, length, timeOut);
+
+                // get the header for the next packet.
+                AdbHelper.read(mChannel, pullResult, -1, timeOut);
+
+                // write the content in the file
+                fos.write(data, 0, length);
+
+                monitor.advance(length);
+            }
+
+            fos.flush();
+        } catch (IOException e) {
+            Log.e(
+                    "ddms",
+                    String.format(
+                            "Failed to open local file %s for writing, Reason: %s",
+                            f.getAbsolutePath(), e.toString()));
+            throw new SyncException(SyncError.FILE_WRITE_ERROR);
+        } finally {
+            if (fos != null) {
+                fos.close();
+            }
+        }
+    }
+
+    /**
+     * Push multiple files
+     *
+     * @param fileArray
+     * @param remotePath
+     * @param monitor
+     * @throws SyncException if file could not be pushed
+     * @throws IOException in case of I/O error on the connection.
+     * @throws TimeoutException in case of a timeout reading responses from the device.
+     */
+    private void doPush(File[] fileArray, String remotePath, ISyncProgressMonitor monitor)
+            throws SyncException, IOException, TimeoutException {
+        for (File f : fileArray) {
+            // check if we're canceled
+            if (monitor.isCanceled()) {
+                throw new SyncException(SyncError.CANCELED);
+            }
+            if (f.exists()) {
+                if (f.isDirectory()) {
+                    // append the name of the directory to the remote path
+                    String dest = remotePath + "/" + f.getName(); // $NON-NLS-1S
+                    monitor.startSubTask(dest);
+                    doPush(f.listFiles(), dest, monitor);
+
+                    monitor.advance(1);
+                } else if (f.isFile()) {
+                    // append the name of the file to the remote path
+                    String remoteFile = remotePath + "/" + f.getName(); // $NON-NLS-1S
+                    monitor.startSubTask(remoteFile);
+                    doPushFile(f.getAbsolutePath(), remoteFile, monitor);
+                }
+            }
+        }
+    }
+
+    /**
+     * Push a single file
+     *
+     * @param localPath the local file to push
+     * @param remotePath the remote file (length max is 1024)
+     * @param monitor the monitor. The monitor must be started already.
+     * @throws SyncException if file could not be pushed
+     * @throws IOException in case of I/O error on the connection.
+     * @throws TimeoutException in case of a timeout reading responses from the device.
+     */
+    private void doPushFile(String localPath, String remotePath, ISyncProgressMonitor monitor)
+            throws SyncException, IOException, TimeoutException {
+        FileInputStream fis = null;
+        byte[] msg;
+
+        final int timeOut = DdmPreferences.getTimeOut();
+        File f = new File(localPath);
+
+        try {
+            byte[] remotePathContent = remotePath.getBytes(AdbHelper.DEFAULT_CHARSET);
+
+            if (remotePathContent.length > REMOTE_PATH_MAX_LENGTH) {
+                throw new SyncException(SyncError.REMOTE_PATH_LENGTH);
+            }
+
+            // create the stream to read the file
+            fis = new FileInputStream(f);
+
+            int permissions = FilePermissionUtil.getFilePosixPermission(f);
+            // create the header for the action
+            msg = createSendFileReq(ID_SEND, remotePathContent, permissions);
+
+            // and send it. We use a custom try/catch block to make the difference between
+            // file and network IO exceptions.
+            AdbHelper.write(mChannel, msg, -1, timeOut);
+
+            System.arraycopy(ID_DATA, 0, getBuffer(), 0, ID_DATA.length);
+
+            // look while there is something to read
+            while (true) {
+                // check if we're canceled
+                if (monitor.isCanceled()) {
+                    throw new SyncException(SyncError.CANCELED);
+                }
+
+                // read up to SYNC_DATA_MAX
+                int readCount = fis.read(getBuffer(), 8, SYNC_DATA_MAX);
+
+                if (readCount == -1) {
+                    // we reached the end of the file
+                    break;
+                }
+
+                // now send the data to the device
+                // first write the amount read
+                ArrayHelper.swap32bitsToArray(readCount, getBuffer(), 4);
+
+                // now write it
+                AdbHelper.write(mChannel, getBuffer(), readCount + 8, timeOut);
+
+                // and advance the monitor
+                monitor.advance(readCount);
+            }
+        } finally {
+            // close the local file
+            if (fis != null) {
+                fis.close();
+            }
+        }
+
+        // create the DONE message
+        long time = f.lastModified() / 1000;
+        msg = createReq(ID_DONE, (int) time);
+
+        // and send it.
+        AdbHelper.write(mChannel, msg, -1, timeOut);
+
+        // read the result, in a byte array containing 2 ints
+        // (id, size)
+        byte[] result = new byte[8];
+        AdbHelper.read(mChannel, result, -1 /* full length */, timeOut);
+
+        if (!checkResult(result, ID_OKAY)) {
+            throw new SyncException(
+                    SyncError.TRANSFER_PROTOCOL_ERROR, readErrorMessage(result, timeOut));
+        }
+    }
+
+    /**
+     * Reads an error message from the opened {@link #mChannel}.
+     *
+     * @param result the current adb result. Must contain both FAIL and the length of the message.
+     * @param timeOut
+     * @return
+     * @throws TimeoutException in case of a timeout reading responses from the device.
+     * @throws IOException
+     */
+    private String readErrorMessage(byte[] result, final int timeOut)
+            throws TimeoutException, IOException {
+        if (checkResult(result, ID_FAIL)) {
+            int len = ArrayHelper.swap32bitFromArray(result, 4);
+
+            if (len > 0) {
+                AdbHelper.read(mChannel, getBuffer(), len, timeOut);
+
+                String message = new String(getBuffer(), 0, len);
+                Log.e("ddms", "transfer error: " + message);
+
+                return message;
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * Returns the stat info of the remote file.
+     *
+     * @param path the remote file
+     * @return an FileStat containing the mode, size and last modified info if all went well or null
+     *     otherwise
+     * @throws IOException
+     * @throws TimeoutException in case of a timeout reading responses from the device.
+     */
+    @Nullable
+    public FileStat statFile(@NonNull String path) throws TimeoutException, IOException {
+        // create the stat request message.
+        byte[] msg = createFileReq(ID_STAT, path);
+
+        AdbHelper.write(mChannel, msg, -1 /* full length */, DdmPreferences.getTimeOut());
+
+        // read the result, in a byte array containing 4 ints
+        // (id, mode, size, time)
+        byte[] statResult = new byte[16];
+        AdbHelper.read(mChannel, statResult, -1 /* full length */, DdmPreferences.getTimeOut());
+
+        // check we have the proper data back
+        if (!checkResult(statResult, ID_STAT)) {
+            return null;
+        }
+
+        final int mode = ArrayHelper.swap32bitFromArray(statResult, 4);
+        final int size = ArrayHelper.swap32bitFromArray(statResult, 8);
+        final int lastModifiedSecs = ArrayHelper.swap32bitFromArray(statResult, 12);
+        return new FileStat(mode, size, lastModifiedSecs);
+    }
+
+    /**
+     * Create a command with a code and an int values
+     *
+     * @param command
+     * @param value
+     * @return
+     */
+    private static byte[] createReq(byte[] command, int value) {
+        byte[] array = new byte[8];
+
+        System.arraycopy(command, 0, array, 0, 4);
+        ArrayHelper.swap32bitsToArray(value, array, 4);
+
+        return array;
+    }
+
+    /**
+     * Creates the data array for a stat request.
+     *
+     * @param command the 4 byte command (ID_STAT, ID_RECV, ...)
+     * @param path The path of the remote file on which to execute the command
+     * @return the byte[] to send to the device through adb
+     */
+    private static byte[] createFileReq(byte[] command, String path) {
+        return createFileReq(command, path.getBytes(AdbHelper.DEFAULT_CHARSET));
+    }
+
+    /**
+     * Creates the data array for a file request. This creates an array with a 4 byte command + the
+     * remote file name.
+     *
+     * @param command the 4 byte command (ID_STAT, ID_RECV, ...).
+     * @param path The path, as a byte array, of the remote file on which to execute the command.
+     * @return the byte[] to send to the device through adb
+     */
+    private static byte[] createFileReq(byte[] command, byte[] path) {
+        byte[] array = new byte[8 + path.length];
+
+        System.arraycopy(command, 0, array, 0, 4);
+        ArrayHelper.swap32bitsToArray(path.length, array, 4);
+        System.arraycopy(path, 0, array, 8, path.length);
+
+        return array;
+    }
+
+    private static byte[] createSendFileReq(byte[] command, byte[] path, int mode) {
+        // make the mode into a string
+        String modeStr = "," + (mode & 0777); // $NON-NLS-1S
+        byte[] modeContent = modeStr.getBytes(AdbHelper.DEFAULT_CHARSET);
+        byte[] array = new byte[8 + path.length + modeContent.length];
+
+        System.arraycopy(command, 0, array, 0, 4);
+        ArrayHelper.swap32bitsToArray(path.length + modeContent.length, array, 4);
+        System.arraycopy(path, 0, array, 8, path.length);
+        System.arraycopy(modeContent, 0, array, 8 + path.length, modeContent.length);
+
+        return array;
+    }
+
+    /**
+     * Checks the result array starts with the provided code
+     *
+     * @param result The result array to check
+     * @param code The 4 byte code.
+     * @return true if the code matches.
+     */
+    private static boolean checkResult(byte[] result, byte[] code) {
+        return !(result[0] != code[0]
+                || result[1] != code[1]
+                || result[2] != code[2]
+                || result[3] != code[3]);
+    }
+
+    private static int getFileType(int mode) {
+        if ((mode & S_ISOCK) == S_ISOCK) {
+            return FileListingService.TYPE_SOCKET;
+        }
+
+        if ((mode & S_IFLNK) == S_IFLNK) {
+            return FileListingService.TYPE_LINK;
+        }
+
+        if ((mode & S_IFREG) == S_IFREG) {
+            return FileListingService.TYPE_FILE;
+        }
+
+        if ((mode & S_IFBLK) == S_IFBLK) {
+            return FileListingService.TYPE_BLOCK;
+        }
+
+        if ((mode & S_IFDIR) == S_IFDIR) {
+            return FileListingService.TYPE_DIRECTORY;
+        }
+
+        if ((mode & S_IFCHR) == S_IFCHR) {
+            return FileListingService.TYPE_CHARACTER;
+        }
+
+        if ((mode & S_IFIFO) == S_IFIFO) {
+            return FileListingService.TYPE_FIFO;
+        }
+
+        return FileListingService.TYPE_OTHER;
+    }
+
+    /**
+     * Retrieve the buffer, allocating if necessary
+     *
+     * @return
+     */
+    private byte[] getBuffer() {
+        if (mBuffer == null) {
+            // create the buffer used to read.
+            // we read max SYNC_DATA_MAX, but we need 2 4 bytes at the beginning.
+            mBuffer = new byte[SYNC_DATA_MAX + 8];
+        }
+        return mBuffer;
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/ThreadInfo.java b/device_build_interfaces/com/android/tradefed/device/server/ThreadInfo.java
new file mode 100644
index 000000000..e3acc791e
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/ThreadInfo.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.server;
+
+/** Holds a thread information. */
+public final class ThreadInfo implements IStackTraceInfo {
+    private int mThreadId;
+    private String mThreadName;
+    private int mStatus;
+    private int mTid;
+    private int mUtime;
+    private int mStime;
+    private boolean mIsDaemon;
+    private StackTraceElement[] mTrace;
+    private long mTraceTime;
+
+    // priority?
+    // total CPU used?
+    // method at top of stack?
+
+    /** Construct with basic identification. */
+    ThreadInfo(int threadId, String threadName) {
+        mThreadId = threadId;
+        mThreadName = threadName;
+
+        mStatus = -1;
+        // mTid = mUtime = mStime = 0;
+        // mIsDaemon = false;
+    }
+
+    /** Set with the values we get from a THST chunk. */
+    public void updateThread(int status, int tid, int utime, int stime, boolean isDaemon) {
+
+        mStatus = status;
+        mTid = tid;
+        mUtime = utime;
+        mStime = stime;
+        mIsDaemon = isDaemon;
+    }
+
+    /**
+     * Sets the stack call of the thread.
+     *
+     * @param trace stackcall information.
+     */
+    public void setStackCall(StackTraceElement[] trace) {
+        mTrace = trace;
+        mTraceTime = System.currentTimeMillis();
+    }
+
+    /** Returns the thread's ID. */
+    public int getThreadId() {
+        return mThreadId;
+    }
+
+    /** Returns the thread's name. */
+    public String getThreadName() {
+        return mThreadName;
+    }
+
+    public void setThreadName(String name) {
+        mThreadName = name;
+    }
+
+    /** Returns the system tid. */
+    public int getTid() {
+        return mTid;
+    }
+
+    /** Returns the VM thread status. */
+    public int getStatus() {
+        return mStatus;
+    }
+
+    /** Returns the cumulative user time. */
+    public int getUtime() {
+        return mUtime;
+    }
+
+    /** Returns the cumulative system time. */
+    public int getStime() {
+        return mStime;
+    }
+
+    /** Returns whether this is a daemon thread. */
+    public boolean isDaemon() {
+        return mIsDaemon;
+    }
+
+    /*
+     * (non-Javadoc)
+     * @see com.android.ddmlib.IStackTraceInfo#getStackTrace()
+     */
+    @Override
+    public StackTraceElement[] getStackTrace() {
+        return mTrace;
+    }
+
+    /**
+     * Returns the approximate time of the stacktrace data.
+     *
+     * @see #getStackTrace()
+     */
+    public long getStackCallTime() {
+        return mTraceTime;
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/TimeoutRemainder.java b/device_build_interfaces/com/android/tradefed/device/server/TimeoutRemainder.java
new file mode 100644
index 000000000..de3ec2005
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/TimeoutRemainder.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.device.server;
+
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Utility class to keep track of how much time is left given an initial timeout. This is useful
+ * when a method receives a timeout parameter and needs to perform multiple operations within that
+ * given timeout.
+ *
+ * <p>Note: The implementation keeps track of time using {@link System#nanoTime()} units, meaning
+ * this class is not suitable for timeouts longer than ~290 years.
+ */
+public class TimeoutRemainder {
+    private final SystemNanoTimeProvider nanoTimeProvider;
+    private final long timeout;
+    private final TimeUnit unit;
+
+    /**
+     * Value of system nano time when the timer is created, meaning overflowing occurs every ~290+
+     * years.
+     */
+    private final long startNanos;
+
+    public TimeoutRemainder(long timeout, TimeUnit unit) {
+        this(DefaultSystemNanoTime.getInstance(), timeout, unit);
+    }
+
+    public TimeoutRemainder(SystemNanoTimeProvider nanoTimeProvider, long timeout, TimeUnit unit) {
+        this.nanoTimeProvider = nanoTimeProvider;
+        this.timeout = timeout;
+        this.unit = unit;
+        this.startNanos = elapsedNanos(0);
+    }
+
+    public long getRemainingNanos() {
+        // This needs to handle Long.MAX_VALUE for timeout, i.e. we cannot
+        // overflow. This is ok as elapsedNanos() will never be negative.
+        return this.unit.toNanos(timeout) - elapsedNanos(startNanos);
+    }
+
+    public long getRemainingUnits() {
+        return getRemainingUnits(this.unit);
+    }
+
+    public long getRemainingUnits(TimeUnit unit) {
+        // Using TimeUnit convert() ensures overflows are taken care of
+        return unit.convert(getRemainingNanos(), TimeUnit.NANOSECONDS);
+    }
+
+    private long elapsedNanos(long startNanos) {
+        return this.nanoTimeProvider.nanoTime() - startNanos;
+    }
+
+    public interface SystemNanoTimeProvider {
+        long nanoTime();
+    }
+
+    public static class DefaultSystemNanoTime implements SystemNanoTimeProvider {
+        public static DefaultSystemNanoTime sInstance = new DefaultSystemNanoTime();
+
+        public static DefaultSystemNanoTime getInstance() {
+            return sInstance;
+        }
+
+        @Override
+        public long nanoTime() {
+            return System.nanoTime();
+        }
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/jdwp/JdwpAgent.java b/device_build_interfaces/com/android/tradefed/device/server/jdwp/JdwpAgent.java
new file mode 100644
index 000000000..ce29479e3
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/jdwp/JdwpAgent.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.device.server.jdwp;
+
+import com.android.annotations.NonNull;
+import com.android.annotations.Nullable;
+import com.android.tradefed.device.server.jdwp.chunkhandler.JdwpPacket;
+
+import java.io.IOException;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+
+public abstract class JdwpAgent {
+
+    /** Interceptors waiting for a specific reply id. */
+    @NonNull private final ConcurrentMap<Integer, JdwpInterceptor> mReplyInterceptors;
+
+    @NonNull private final List<JdwpInterceptor> mInterceptors;
+
+    @NonNull private final JdwpProtocol mProtocol;
+
+    public JdwpAgent(@NonNull JdwpProtocol protocol) {
+        mReplyInterceptors = new ConcurrentHashMap<Integer, JdwpInterceptor>();
+        mInterceptors = new LinkedList<JdwpInterceptor>();
+        mProtocol = protocol;
+    }
+
+    /**
+     * Adds an interceptor for a specific reply id. Once this interceptor handles the response, it
+     * will be removed.
+     */
+    protected void addReplyInterceptor(int id, @NonNull JdwpInterceptor interceptor) {
+        mReplyInterceptors.put(id, interceptor);
+    }
+
+    /** Removes, if present, the interceptor to handle a reply with the given id. */
+    protected void removeReplyInterceptor(int id) {
+        mReplyInterceptors.remove(id);
+    }
+
+    public void clear() {
+        mReplyInterceptors.clear();
+    }
+
+    public void addJdwpInterceptor(@NonNull JdwpInterceptor interceptor) {
+        mInterceptors.add(interceptor);
+    }
+
+    public void removeJdwpInterceptor(@NonNull JdwpInterceptor interceptor) {
+        mInterceptors.remove(interceptor);
+    }
+
+    public void incoming(@NonNull JdwpPacket packet, @Nullable JdwpAgent target)
+            throws IOException {
+        mProtocol.incoming(packet, target);
+        int id = packet.getId();
+        if (packet.isReply()) {
+            JdwpInterceptor interceptor = mReplyInterceptors.remove(id);
+            if (interceptor != null) {
+                packet = interceptor.intercept(this, packet);
+            }
+        }
+        for (JdwpInterceptor interceptor : mInterceptors) {
+            if (packet == null) break;
+            packet = interceptor.intercept(this, packet);
+        }
+
+        if (target != null && packet != null) {
+            target.send(packet);
+        }
+    }
+
+    public void send(@NonNull JdwpPacket packet, @NonNull JdwpInterceptor interceptor)
+            throws IOException {
+        mReplyInterceptors.put(packet.getId(), interceptor);
+        send(packet);
+    }
+
+    protected abstract void send(@NonNull JdwpPacket packet) throws IOException;
+
+    @NonNull
+    public JdwpProtocol getJdwpProtocol() {
+        return mProtocol;
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/jdwp/JdwpCommands.java b/device_build_interfaces/com/android/tradefed/device/server/jdwp/JdwpCommands.java
new file mode 100644
index 000000000..9548342d8
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/jdwp/JdwpCommands.java
@@ -0,0 +1,498 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.device.server.jdwp;
+
+import com.android.annotations.NonNull;
+
+/**
+ * JDWP command constants as specified <a
+ * href="http://docs.oracle.com/javase/7/docs/platform/jpda/jdwp/jdwp-protocol.html">here</a>
+ */
+@SuppressWarnings("SpellCheckingInspection")
+public class JdwpCommands {
+    public static final int SET_VM = 1;
+    public static final int CMD_VM_VERSION = 1;
+    public static final int CMD_VM_CLASSESBYSIGNATURE = 2;
+    public static final int CMD_VM_ALLCLASSES = 3;
+    public static final int CMD_VM_ALLTHREADS = 4;
+    public static final int CMD_VM_TOPLEVELTHREADGROUPS = 5;
+    public static final int CMD_VM_DISPOSE = 6;
+    public static final int CMD_VM_IDSIZES = 7;
+    public static final int CMD_VM_SUSPEND = 8;
+    public static final int CMD_VM_RESUME = 9;
+    public static final int CMD_VM_EXIT = 10;
+    public static final int CMD_VM_CREATESTRING = 11;
+    public static final int CMD_VM_CAPABILITIES = 12;
+    public static final int CMD_VM_CLASSPATHS = 13;
+    public static final int CMD_VM_DISPOSEOBJECTS = 14;
+    public static final int CMD_VM_HOLDEVENTS = 15;
+    public static final int CMD_VM_RELEASEEVENTS = 16;
+    public static final int CMD_VM_CAPABILITIESNEW = 17;
+    public static final int CMD_VM_REDEFINECLASSES = 18;
+    public static final int CMD_VM_SETDEFAULTSTRATUM = 19;
+    public static final int CMD_VM_ALLCLASSESWITHGENERIC = 20;
+
+    public static final int SET_REFTYPE = 2;
+    public static final int CMD_REFTYPE_SIGNATURE = 1;
+    public static final int CMD_REFTYPE_CLASSLOADER = 2;
+    public static final int CMD_REFTYPE_MODIFIERS = 3;
+    public static final int CMD_REFTYPE_FIELDS = 4;
+    public static final int CMD_REFTYPE_METHODS = 5;
+    public static final int CMD_REFTYPE_GETVALUES = 6;
+    public static final int CMD_REFTYPE_SOURCEFILE = 7;
+    public static final int CMD_REFTYPE_NESTEDTYPES = 8;
+    public static final int CMD_REFTYPE_STATUS = 9;
+    public static final int CMD_REFTYPE_INTERFACES = 10;
+    public static final int CMD_REFTYPE_CLASSOBJECT = 11;
+    public static final int CMD_REFTYPE_SOURCEDEBUGEXTENSION = 12;
+    public static final int CMD_REFTYPE_SIGNATUREWITHGENERIC = 13;
+    public static final int CMD_REFTYPE_FIELDSWITHGENERIC = 14;
+    public static final int CMD_REFTYPE_METHODSWITHGENERIC = 15;
+
+    public static final int SET_CLASSTYPE = 3;
+    public static final int CMD_CLASSTYPE_SUPERCLASS = 1;
+    public static final int CMD_CLASSTYPE_SETVALUES = 2;
+    public static final int CMD_CLASSTYPE_INVOKEMETHOD = 3;
+    public static final int CMD_CLASSTYPE_NEWINSTANCE = 4;
+
+    public static final int SET_ARRAYTYPE = 4;
+    public static final int CMD_ARRAYTYPE_NEWINSTANCE = 1;
+
+    public static final int SET_INTERFACETYPE = 5;
+
+    public static final int SET_METHOD = 6;
+    public static final int CMD_METHOD_LINETABLE = 1;
+    public static final int CMD_METHOD_VARIABLETABLE = 2;
+    public static final int CMD_METHOD_BYTECODES = 3;
+    public static final int CMD_METHOD_ISOBSOLETE = 4;
+    public static final int CMD_METHOD_VARIABLETABLEWITHGENERIC = 5;
+
+    public static final int SET_FIELD = 8;
+
+    public static final int SET_OBJREF = 9;
+    public static final int CMD_OBJREF_REFERENCETYPE = 1;
+    public static final int CMD_OBJREF_GETVALUES = 2;
+    public static final int CMD_OBJREF_SETVALUES = 3;
+    public static final int CMD_OBJREF_MONITORINFO = 5;
+    public static final int CMD_OBJREF_INVOKEMETHOD = 6;
+    public static final int CMD_OBJREF_DISABLECOLLECTION = 7;
+    public static final int CMD_OBJREF_ENABLECOLLECTION = 8;
+    public static final int CMD_OBJREF_ISCOLLECTED = 9;
+
+    public static final int SET_STRINGREF = 10;
+    public static final int CMD_STRINGREF_VALUE = 1;
+
+    public static final int SET_THREADREF = 11;
+    public static final int CMD_THREADREF_NAME = 1;
+    public static final int CMD_THREADREF_SUSPEND = 2;
+    public static final int CMD_THREADREF_RESUME = 3;
+    public static final int CMD_THREADREF_STATUS = 4;
+    public static final int CMD_THREADREF_THREADGROUP = 5;
+    public static final int CMD_THREADREF_FRAMES = 6;
+    public static final int CMD_THREADREF_FRAMECOUNT = 7;
+    public static final int CMD_THREADREF_OWNEDMONITORS = 8;
+    public static final int CMD_THREADREF_CURRENTCONTENDEDMONITOR = 9;
+    public static final int CMD_THREADREF_STOP = 10;
+    public static final int CMD_THREADREF_INTERRUPT = 11;
+    public static final int CMD_THREADREF_SUSPENDCOUNT = 12;
+
+    public static final int SET_THREADGROUPREF = 12;
+    public static final int CMD_THREADGROUPREF_NAME = 1;
+    public static final int CMD_THREADGROUPREF_PARENT = 2;
+    public static final int CMD_THREADGROUPREF_CHILDREN = 3;
+
+    public static final int SET_ARRAYREF = 13;
+    public static final int CMD_ARRAYREF_LENGTH = 1;
+    public static final int CMD_ARRAYREF_GETVALUES = 2;
+    public static final int CMD_ARRAYREF_SETVALUES = 3;
+
+    public static final int SET_CLASSLOADERREF = 14;
+    public static final int CMD_CLASSLOADERREF_VISIBLECLASSES = 1;
+
+    public static final int SET_EVENTREQUEST = 15;
+    public static final int CMD_EVENTREQUEST_SET = 1;
+    public static final int CMD_EVENTREQUEST_CLEAR = 2;
+    public static final int CMD_EVENTREQUEST_CLEARALLBREAKPOINTS = 3;
+
+    public static final int SET_STACKFRAME = 16;
+    public static final int CMD_STACKFRAME_GETVALUES = 1;
+    public static final int CMD_STACKFRAME_SETVALUES = 2;
+    public static final int CMD_STACKFRAME_THISOBJECT = 3;
+    public static final int CMD_STACKFRAME_POPFRAMES = 4;
+
+    public static final int SET_CLASSOBJECTREF = 17;
+    public static final int CMD_CLASSOBJECTREF_REFLECTEDTYPE = 1;
+
+    public static final int SET_EVENT = 64;
+    public static final int CMD_EVENT_COMPOSITE = 100;
+
+    @NonNull
+    public static String commandSetToString(int cmdSet) {
+        switch (cmdSet) {
+            case SET_VM:
+                return "SET_VM";
+            case SET_REFTYPE:
+                return "SET_REFTYPE";
+            case SET_CLASSTYPE:
+                return "SET_CLASSTYPE";
+            case SET_ARRAYTYPE:
+                return "SET_ARRAYTYPE";
+            case SET_INTERFACETYPE:
+                return "SET_INTERFACETYPE";
+            case SET_METHOD:
+                return "SET_METHOD";
+            case SET_FIELD:
+                return "SET_FIELD";
+            case SET_OBJREF:
+                return "SET_OBJREF";
+            case SET_STRINGREF:
+                return "SET_STRINGREF";
+            case SET_THREADREF:
+                return "SET_THREADREF";
+            case SET_THREADGROUPREF:
+                return "SET_THREADGROUPREF";
+            case SET_ARRAYREF:
+                return "SET_ARRAYREF";
+            case SET_CLASSLOADERREF:
+                return "SET_CLASSLOADERREF";
+            case SET_EVENTREQUEST:
+                return "SET_EVENTREQUEST";
+            case SET_STACKFRAME:
+                return "SET_STACKFRAME";
+            case SET_CLASSOBJECTREF:
+                return "SET_CLASSOBJECTREF";
+            case SET_EVENT:
+                return "SET_EVENT";
+            default:
+                return String.format("SET_%02X", cmdSet);
+        }
+    }
+
+    @NonNull
+    public static String commandToString(int cmdSet, int cmd) {
+        switch (cmdSet) {
+            case SET_VM:
+                {
+                    switch (cmd) {
+                        case CMD_VM_VERSION:
+                            return "CMD_VM_VERSION";
+                        case CMD_VM_CLASSESBYSIGNATURE:
+                            return "CMD_VM_CLASSESBYSIGNATURE";
+                        case CMD_VM_ALLCLASSES:
+                            return "CMD_VM_ALLCLASSES";
+                        case CMD_VM_ALLTHREADS:
+                            return "CMD_VM_ALLTHREADS";
+                        case CMD_VM_TOPLEVELTHREADGROUPS:
+                            return "CMD_VM_TOPLEVELTHREADGROUPS";
+                        case CMD_VM_DISPOSE:
+                            return "CMD_VM_DISPOSE";
+                        case CMD_VM_IDSIZES:
+                            return "CMD_VM_IDSIZES";
+                        case CMD_VM_SUSPEND:
+                            return "CMD_VM_SUSPEND";
+                        case CMD_VM_RESUME:
+                            return "CMD_VM_RESUME";
+                        case CMD_VM_EXIT:
+                            return "CMD_VM_EXIT";
+                        case CMD_VM_CREATESTRING:
+                            return "CMD_VM_CREATESTRING";
+                        case CMD_VM_CAPABILITIES:
+                            return "CMD_VM_CAPABILITIES";
+                        case CMD_VM_CLASSPATHS:
+                            return "CMD_VM_CLASSPATHS";
+                        case CMD_VM_DISPOSEOBJECTS:
+                            return "CMD_VM_DISPOSEOBJECTS";
+                        case CMD_VM_HOLDEVENTS:
+                            return "CMD_VM_HOLDEVENTS";
+                        case CMD_VM_RELEASEEVENTS:
+                            return "CMD_VM_RELEASEEVENTS";
+                        case CMD_VM_CAPABILITIESNEW:
+                            return "CMD_VM_CAPABILITIESNEW";
+                        case CMD_VM_REDEFINECLASSES:
+                            return "CMD_VM_REDEFINECLASSES";
+                        case CMD_VM_SETDEFAULTSTRATUM:
+                            return "CMD_VM_SETDEFAULTSTRATUM";
+                        case CMD_VM_ALLCLASSESWITHGENERIC:
+                            return "CMD_VM_ALLCLASSESWITHGENERIC";
+                        default:
+                            return unknownCommandToString(cmdSet, cmd);
+                    }
+                }
+
+            case SET_REFTYPE:
+                {
+                    switch (cmd) {
+                        case CMD_REFTYPE_SIGNATURE:
+                            return "CMD_REFTYPE_SIGNATURE";
+                        case CMD_REFTYPE_CLASSLOADER:
+                            return "CMD_REFTYPE_CLASSLOADER";
+                        case CMD_REFTYPE_MODIFIERS:
+                            return "CMD_REFTYPE_MODIFIERS";
+                        case CMD_REFTYPE_FIELDS:
+                            return "CMD_REFTYPE_FIELDS";
+                        case CMD_REFTYPE_METHODS:
+                            return "CMD_REFTYPE_METHODS";
+                        case CMD_REFTYPE_GETVALUES:
+                            return "CMD_REFTYPE_GETVALUES";
+                        case CMD_REFTYPE_SOURCEFILE:
+                            return "CMD_REFTYPE_SOURCEFILE";
+                        case CMD_REFTYPE_NESTEDTYPES:
+                            return "CMD_REFTYPE_NESTEDTYPES";
+                        case CMD_REFTYPE_STATUS:
+                            return "CMD_REFTYPE_STATUS";
+                        case CMD_REFTYPE_INTERFACES:
+                            return "CMD_REFTYPE_INTERFACES";
+                        case CMD_REFTYPE_CLASSOBJECT:
+                            return "CMD_REFTYPE_CLASSOBJECT";
+                        case CMD_REFTYPE_SOURCEDEBUGEXTENSION:
+                            return "CMD_REFTYPE_SOURCEDEBUGEXTENSION";
+                        case CMD_REFTYPE_SIGNATUREWITHGENERIC:
+                            return "CMD_REFTYPE_SIGNATUREWITHGENERIC";
+                        case CMD_REFTYPE_FIELDSWITHGENERIC:
+                            return "CMD_REFTYPE_FIELDSWITHGENERIC";
+                        case CMD_REFTYPE_METHODSWITHGENERIC:
+                            return "CMD_REFTYPE_METHODSWITHGENERIC";
+                        default:
+                            return unknownCommandToString(cmdSet, cmd);
+                    }
+                }
+
+            case SET_CLASSTYPE:
+                {
+                    switch (cmd) {
+                        case CMD_CLASSTYPE_SUPERCLASS:
+                            return "CMD_CLASSTYPE_SUPERCLASS";
+                        case CMD_CLASSTYPE_SETVALUES:
+                            return "CMD_CLASSTYPE_SETVALUES";
+                        case CMD_CLASSTYPE_INVOKEMETHOD:
+                            return "CMD_CLASSTYPE_INVOKEMETHOD";
+                        case CMD_CLASSTYPE_NEWINSTANCE:
+                            return "CMD_CLASSTYPE_NEWINSTANCE";
+                        default:
+                            return unknownCommandToString(cmdSet, cmd);
+                    }
+                }
+
+            case SET_ARRAYTYPE:
+                {
+                    switch (cmd) {
+                        case CMD_ARRAYTYPE_NEWINSTANCE:
+                            return "CMD_ARRAYTYPE_NEWINSTANCE";
+                        default:
+                            return unknownCommandToString(cmdSet, cmd);
+                    }
+                }
+
+            case SET_INTERFACETYPE:
+                {
+                    switch (cmd) {
+                        default:
+                            return unknownCommandToString(cmdSet, cmd);
+                    }
+                }
+
+            case SET_METHOD:
+                {
+                    switch (cmd) {
+                        case CMD_METHOD_LINETABLE:
+                            return "CMD_METHOD_LINETABLE";
+                        case CMD_METHOD_VARIABLETABLE:
+                            return "CMD_METHOD_VARIABLETABLE";
+                        case CMD_METHOD_BYTECODES:
+                            return "CMD_METHOD_BYTECODES";
+                        case CMD_METHOD_ISOBSOLETE:
+                            return "CMD_METHOD_ISOBSOLETE";
+                        case CMD_METHOD_VARIABLETABLEWITHGENERIC:
+                            return "CMD_METHOD_VARIABLETABLEWITHGENERIC";
+                        default:
+                            return unknownCommandToString(cmdSet, cmd);
+                    }
+                }
+
+            case SET_FIELD:
+                {
+                    switch (cmd) {
+                        default:
+                            return unknownCommandToString(cmdSet, cmd);
+                    }
+                }
+
+            case SET_OBJREF:
+                {
+                    switch (cmd) {
+                        case CMD_OBJREF_REFERENCETYPE:
+                            return "CMD_OBJREF_REFERENCETYPE";
+                        case CMD_OBJREF_GETVALUES:
+                            return "CMD_OBJREF_GETVALUES";
+                        case CMD_OBJREF_SETVALUES:
+                            return "CMD_OBJREF_SETVALUES";
+                        case CMD_OBJREF_MONITORINFO:
+                            return "CMD_OBJREF_MONITORINFO";
+                        case CMD_OBJREF_INVOKEMETHOD:
+                            return "CMD_OBJREF_INVOKEMETHOD";
+                        case CMD_OBJREF_DISABLECOLLECTION:
+                            return "CMD_OBJREF_DISABLECOLLECTION";
+                        case CMD_OBJREF_ENABLECOLLECTION:
+                            return "CMD_OBJREF_ENABLECOLLECTION";
+                        case CMD_OBJREF_ISCOLLECTED:
+                            return "CMD_OBJREF_ISCOLLECTED";
+                        default:
+                            return unknownCommandToString(cmdSet, cmd);
+                    }
+                }
+
+            case SET_STRINGREF:
+                {
+                    switch (cmd) {
+                        case CMD_STRINGREF_VALUE:
+                            return "CMD_STRINGREF_VALUE";
+                        default:
+                            return unknownCommandToString(cmdSet, cmd);
+                    }
+                }
+
+            case SET_THREADREF:
+                {
+                    switch (cmd) {
+                        case CMD_THREADREF_NAME:
+                            return "CMD_THREADREF_NAME";
+                        case CMD_THREADREF_SUSPEND:
+                            return "CMD_THREADREF_SUSPEND";
+                        case CMD_THREADREF_RESUME:
+                            return "CMD_THREADREF_RESUME";
+                        case CMD_THREADREF_STATUS:
+                            return "CMD_THREADREF_STATUS";
+                        case CMD_THREADREF_THREADGROUP:
+                            return "CMD_THREADREF_THREADGROUP";
+                        case CMD_THREADREF_FRAMES:
+                            return "CMD_THREADREF_FRAMES";
+                        case CMD_THREADREF_FRAMECOUNT:
+                            return "CMD_THREADREF_FRAMECOUNT";
+                        case CMD_THREADREF_OWNEDMONITORS:
+                            return "CMD_THREADREF_OWNEDMONITORS";
+                        case CMD_THREADREF_CURRENTCONTENDEDMONITOR:
+                            return "CMD_THREADREF_CURRENTCONTENDEDMONITOR";
+                        case CMD_THREADREF_STOP:
+                            return "CMD_THREADREF_STOP";
+                        case CMD_THREADREF_INTERRUPT:
+                            return "CMD_THREADREF_INTERRUPT";
+                        case CMD_THREADREF_SUSPENDCOUNT:
+                            return "CMD_THREADREF_SUSPENDCOUNT";
+                        default:
+                            return unknownCommandToString(cmdSet, cmd);
+                    }
+                }
+
+            case SET_THREADGROUPREF:
+                {
+                    switch (cmd) {
+                        case CMD_THREADGROUPREF_NAME:
+                            return "CMD_THREADGROUPREF_NAME";
+                        case CMD_THREADGROUPREF_PARENT:
+                            return "CMD_THREADGROUPREF_PARENT";
+                        case CMD_THREADGROUPREF_CHILDREN:
+                            return "CMD_THREADGROUPREF_CHILDREN";
+                        default:
+                            return unknownCommandToString(cmdSet, cmd);
+                    }
+                }
+
+            case SET_ARRAYREF:
+                {
+                    switch (cmd) {
+                        case CMD_ARRAYREF_LENGTH:
+                            return "CMD_ARRAYREF_LENGTH";
+                        case CMD_ARRAYREF_GETVALUES:
+                            return "CMD_ARRAYREF_GETVALUES";
+                        case CMD_ARRAYREF_SETVALUES:
+                            return "CMD_ARRAYREF_SETVALUES";
+                        default:
+                            return unknownCommandToString(cmdSet, cmd);
+                    }
+                }
+
+            case SET_CLASSLOADERREF:
+                {
+                    switch (cmd) {
+                        case CMD_CLASSLOADERREF_VISIBLECLASSES:
+                            return "CMD_CLASSLOADERREF_VISIBLECLASSES";
+                        default:
+                            return unknownCommandToString(cmdSet, cmd);
+                    }
+                }
+
+            case SET_EVENTREQUEST:
+                {
+                    switch (cmd) {
+                        case CMD_EVENTREQUEST_SET:
+                            return "CMD_EVENTREQUEST_SET";
+                        case CMD_EVENTREQUEST_CLEAR:
+                            return "CMD_EVENTREQUEST_CLEAR";
+                        case CMD_EVENTREQUEST_CLEARALLBREAKPOINTS:
+                            return "CMD_EVENTREQUEST_CLEARALLBREAKPOINTS";
+                        default:
+                            return unknownCommandToString(cmdSet, cmd);
+                    }
+                }
+
+            case SET_STACKFRAME:
+                {
+                    switch (cmd) {
+                        case CMD_STACKFRAME_GETVALUES:
+                            return "CMD_STACKFRAME_GETVALUES";
+                        case CMD_STACKFRAME_SETVALUES:
+                            return "CMD_STACKFRAME_SETVALUES";
+                        case CMD_STACKFRAME_THISOBJECT:
+                            return "CMD_STACKFRAME_THISOBJECT";
+                        case CMD_STACKFRAME_POPFRAMES:
+                            return "CMD_STACKFRAME_POPFRAMES";
+                        default:
+                            return unknownCommandToString(cmdSet, cmd);
+                    }
+                }
+
+            case SET_CLASSOBJECTREF:
+                {
+                    switch (cmd) {
+                        case CMD_CLASSOBJECTREF_REFLECTEDTYPE:
+                            return "CMD_CLASSOBJECTREF_REFLECTEDTYPE";
+                        default:
+                            return unknownCommandToString(cmdSet, cmd);
+                    }
+                }
+
+            case SET_EVENT:
+                {
+                    switch (cmd) {
+                        case CMD_EVENT_COMPOSITE:
+                            return "CMD_EVENT_COMPOSITE";
+                        default:
+                            return unknownCommandToString(cmdSet, cmd);
+                    }
+                }
+
+            default:
+                {
+                    return unknownCommandToString(cmdSet, cmd);
+                }
+        }
+    }
+
+    @NonNull
+    private static String unknownCommandToString(int cmdSet, int command) {
+        return String.format("CMD_%s_%02X", commandSetToString(cmdSet).substring(4), command);
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/jdwp/JdwpExtension.java b/device_build_interfaces/com/android/tradefed/device/server/jdwp/JdwpExtension.java
new file mode 100644
index 000000000..800dad302
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/jdwp/JdwpExtension.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.device.server.jdwp;
+
+import com.android.annotations.NonNull;
+import com.android.tradefed.device.server.ClientImpl;
+
+public abstract class JdwpExtension {
+
+    /** Allows an extension to register interceptors to capture JDWP traffic. */
+    public abstract void intercept(@NonNull ClientImpl client);
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/jdwp/JdwpHandshake.java b/device_build_interfaces/com/android/tradefed/device/server/jdwp/JdwpHandshake.java
new file mode 100644
index 000000000..2d2471c7c
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/jdwp/JdwpHandshake.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.device.server.jdwp;
+
+import java.nio.ByteBuffer;
+
+public class JdwpHandshake {
+    // results from findHandshake
+    public static final int HANDSHAKE_GOOD = 1;
+    public static final int HANDSHAKE_NOTYET = 2;
+    public static final int HANDSHAKE_BAD = 3;
+    // this is sent and expected at the start of a JDWP connection
+    private static final byte[] HANDSHAKE = {
+        'J', 'D', 'W', 'P', '-', 'H', 'a', 'n', 'd', 's', 'h', 'a', 'k', 'e'
+    };
+    public static final int HANDSHAKE_LEN = HANDSHAKE.length;
+
+    /**
+     * Like findPacket(), but when we're expecting the JDWP handshake.
+     *
+     * <p>Returns one of: HANDSHAKE_GOOD - found handshake, looks good HANDSHAKE_BAD - found enough
+     * data, but it's wrong HANDSHAKE_NOTYET - not enough data has been read yet
+     */
+    public static int findHandshake(ByteBuffer buf) {
+        int count = buf.position();
+        int i;
+
+        if (count < HANDSHAKE.length) {
+            return HANDSHAKE_NOTYET;
+        }
+
+        for (i = HANDSHAKE.length - 1; i >= 0; --i) {
+            if (buf.get(i) != HANDSHAKE[i]) {
+                return HANDSHAKE_BAD;
+            }
+        }
+
+        return HANDSHAKE_GOOD;
+    }
+
+    /**
+     * Remove the handshake string from the buffer.
+     *
+     * <p>On entry and exit, "position" is the #of bytes in the buffer.
+     */
+    public static void consumeHandshake(ByteBuffer buf) {
+        // in theory, nothing else can have arrived, so this is overkill
+        buf.flip(); // limit<-posn, posn<-0
+        buf.position(HANDSHAKE.length);
+        buf.compact(); // shift posn...limit, posn<-pending data
+    }
+
+    /**
+     * Copy the handshake string into the output buffer.
+     *
+     * <p>On exit, "buf"s position will be advanced.
+     */
+    public static void putHandshake(ByteBuffer buf) {
+        buf.put(HANDSHAKE);
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/jdwp/JdwpInterceptor.java b/device_build_interfaces/com/android/tradefed/device/server/jdwp/JdwpInterceptor.java
new file mode 100644
index 000000000..336867e1c
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/jdwp/JdwpInterceptor.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.device.server.jdwp;
+
+import com.android.annotations.NonNull;
+import com.android.annotations.Nullable;
+import com.android.tradefed.device.server.jdwp.chunkhandler.JdwpPacket;
+
+public abstract class JdwpInterceptor {
+
+    @Nullable
+    public abstract JdwpPacket intercept(@NonNull JdwpAgent agent, @NonNull JdwpPacket packet);
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/jdwp/JdwpPayload.java b/device_build_interfaces/com/android/tradefed/device/server/jdwp/JdwpPayload.java
new file mode 100644
index 000000000..14e2277aa
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/jdwp/JdwpPayload.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.device.server.jdwp;
+
+import com.android.annotations.NonNull;
+
+import java.nio.ByteBuffer;
+
+public abstract class JdwpPayload {
+
+    public abstract void parse(@NonNull ByteBuffer buffer, @NonNull JdwpProtocol protocol);
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/jdwp/JdwpProtocol.java b/device_build_interfaces/com/android/tradefed/device/server/jdwp/JdwpProtocol.java
new file mode 100644
index 000000000..994e44d28
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/jdwp/JdwpProtocol.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.device.server.jdwp;
+
+import com.android.annotations.NonNull;
+import com.android.annotations.Nullable;
+import com.android.tradefed.device.server.jdwp.chunkhandler.JdwpPacket;
+import com.android.tradefed.device.server.jdwp.packets.CapabilitiesNewReply;
+import com.android.tradefed.device.server.jdwp.packets.IdSizesReply;
+
+import java.nio.ByteBuffer;
+import java.nio.charset.StandardCharsets;
+
+public class JdwpProtocol {
+
+    @Nullable private IdSizesReply mIdSizes;
+
+    public long readObjectId(@NonNull ByteBuffer buffer) {
+        assert mIdSizes != null;
+        return readId(buffer, mIdSizes.objectIDSize);
+    }
+
+    public long readRefTypeId(@NonNull ByteBuffer buffer) {
+        assert mIdSizes != null;
+        return readId(buffer, mIdSizes.refTypeIDSize);
+    }
+
+    public long readMethodId(@NonNull ByteBuffer buffer) {
+        assert mIdSizes != null;
+        return readId(buffer, mIdSizes.methodIDSize);
+    }
+
+    public long readFieldId(@NonNull ByteBuffer buffer) {
+        assert mIdSizes != null;
+        return readId(buffer, mIdSizes.fieldIDSize);
+    }
+
+    private long readId(@NonNull ByteBuffer buffer, int size) {
+        switch (size) {
+            case 1:
+                return buffer.get();
+            case 2:
+                return buffer.getShort();
+            case 4:
+                return buffer.getInt();
+            case 8:
+                return buffer.getLong();
+            default:
+                throw new IllegalArgumentException("Unsupported Id size: " + size);
+        }
+    }
+
+    public String readString(@NonNull ByteBuffer buffer) {
+        int len = buffer.getInt();
+        byte[] utf8 = new byte[len];
+        buffer.get(utf8);
+        return new String(utf8, StandardCharsets.UTF_8);
+    }
+
+    public void incoming(@NonNull JdwpPacket packet, @NonNull JdwpAgent target) {
+        if (packet.is(JdwpCommands.SET_VM, JdwpCommands.CMD_VM_IDSIZES)) {
+            target.addReplyInterceptor(
+                    packet.getId(),
+                    new JdwpInterceptor() {
+                        @Override
+                        public JdwpPacket intercept(
+                                @NonNull JdwpAgent agent, @NonNull JdwpPacket packet) {
+                            mIdSizes = new IdSizesReply();
+                            mIdSizes.parse(packet.getPayload(), JdwpProtocol.this);
+                            return packet;
+                        }
+                    });
+        } else if (packet.is(JdwpCommands.SET_VM, JdwpCommands.CMD_VM_CAPABILITIESNEW)) {
+            target.addReplyInterceptor(
+                    packet.getId(),
+                    new JdwpInterceptor() {
+                        @Override
+                        public JdwpPacket intercept(
+                                @NonNull JdwpAgent agent, @NonNull JdwpPacket packet) {
+                            CapabilitiesNewReply reply = new CapabilitiesNewReply();
+                            reply.parse(packet.getPayload(), JdwpProtocol.this);
+                            packet.setPayload(reply.getConverted());
+                            return packet;
+                        }
+                    });
+        }
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/BadPacketException.java b/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/BadPacketException.java
new file mode 100644
index 000000000..314bdc864
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/BadPacketException.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.server.jdwp.chunkhandler;
+
+/** Thrown if the contents of a packet are bad. */
+@SuppressWarnings("serial")
+public class BadPacketException extends RuntimeException {
+    public BadPacketException() {
+        super();
+    }
+
+    public BadPacketException(String msg) {
+        super(msg);
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/ChunkHandler.java b/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/ChunkHandler.java
new file mode 100644
index 000000000..669096a9b
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/ChunkHandler.java
@@ -0,0 +1,211 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.server.jdwp.chunkhandler;
+
+import com.android.annotations.NonNull;
+import com.android.ddmlib.ByteBufferUtil;
+import com.android.tradefed.device.server.ClientImpl;
+import com.android.tradefed.device.server.MonitorThread;
+import com.android.tradefed.device.server.jdwp.JdwpAgent;
+import com.android.tradefed.device.server.jdwp.JdwpInterceptor;
+import com.android.tradefed.log.Log;
+
+import com.google.common.annotations.VisibleForTesting;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+
+/** Subclass this with a class that handles one or more chunk types. */
+public abstract class ChunkHandler extends JdwpInterceptor {
+
+    public static final int CHUNK_HEADER_LEN = 8; // 4-byte type, 4-byte len
+    public static final ByteOrder CHUNK_ORDER = ByteOrder.BIG_ENDIAN;
+
+    public static final int CHUNK_FAIL = type("FAIL");
+
+    public static final int DDMS_CMD_SET = 0xc7; // 'G' + 128
+
+    public static final int DDMS_CMD = 0x01;
+
+    public ChunkHandler() {}
+
+    /**
+     * Client is ready. The monitor thread calls this method on all handlers when the client is
+     * determined to be DDM-aware (usually after receiving a HELO response.)
+     *
+     * <p>The handler can use this opportunity to initialize client-side activity. Because there's a
+     * fair chance we'll want to send a message to the client, this method can throw an IOException.
+     */
+    public abstract void clientReady(ClientImpl client) throws IOException;
+
+    /**
+     * Client has gone away. Can be used to clean up any resources associated with this client
+     * connection.
+     */
+    public abstract void clientDisconnected(ClientImpl client);
+
+    /**
+     * Handle an incoming chunk. The data, of chunk type "type", begins at the start of "data" and
+     * continues to data.limit().
+     *
+     * <p>If "isReply" is set, then "msgId" will be the ID of the request we sent to the client.
+     * Otherwise, it's the ID generated by the client for this event. Note that it's possible to
+     * receive chunks in reply packets for which we are not registered.
+     *
+     * <p>The handler may not modify the contents of "data".
+     */
+    public abstract void handleChunk(
+            ClientImpl client, int type, ByteBuffer data, boolean isReply, int msgId);
+
+    /**
+     * Handle chunks not recognized by handlers. The handleChunk() method in sub-classes should call
+     * this if the chunk type isn't recognized.
+     */
+    protected void handleUnknownChunk(
+            ClientImpl client, int type, ByteBuffer data, boolean isReply, int msgId) {
+        if (type == CHUNK_FAIL) {
+            int errorCode, msgLen;
+            String msg;
+
+            errorCode = data.getInt();
+            msgLen = data.getInt();
+            msg = ByteBufferUtil.getString(data, msgLen);
+            Log.w("ddms", "WARNING: failure code=" + errorCode + " msg=" + msg);
+        } else {
+            Log.w(
+                    "ddms",
+                    "WARNING: received unknown chunk "
+                            + name(type)
+                            + ": len="
+                            + data.limit()
+                            + ", reply="
+                            + isReply
+                            + ", msgId=0x"
+                            + Integer.toHexString(msgId));
+        }
+        Log.w("ddms", "         client " + client + ", handler " + this);
+    }
+
+    /** Convert a 4-character string to a 32-bit type. */
+    public static int type(String typeName) {
+        int val = 0;
+
+        if (typeName.length() != 4) {
+            Log.e("ddms", "Type name must be 4 letter long");
+            throw new RuntimeException("Type name must be 4 letter long");
+        }
+
+        for (int i = 0; i < 4; i++) {
+            val <<= 8;
+            val |= (byte) typeName.charAt(i);
+        }
+
+        return val;
+    }
+
+    /** Convert an integer type to a 4-character string. */
+    static String name(int type) {
+        char[] ascii = new char[4];
+
+        ascii[0] = (char) ((type >> 24) & 0xff);
+        ascii[1] = (char) ((type >> 16) & 0xff);
+        ascii[2] = (char) ((type >> 8) & 0xff);
+        ascii[3] = (char) (type & 0xff);
+
+        return new String(ascii);
+    }
+
+    /**
+     * Allocate a ByteBuffer with enough space to hold the JDWP packet header and one chunk header
+     * in addition to the demands of the chunk being created.
+     *
+     * <p>"maxChunkLen" indicates the size of the chunk contents only.
+     */
+    @VisibleForTesting
+    public static ByteBuffer allocBuffer(int maxChunkLen) {
+        ByteBuffer buf = ByteBuffer.allocate(JdwpPacket.JDWP_HEADER_LEN + 8 + maxChunkLen);
+        buf.order(CHUNK_ORDER);
+        return buf;
+    }
+
+    /** Return the slice of the JDWP packet buffer that holds just the chunk data. */
+    @VisibleForTesting
+    public static ByteBuffer getChunkDataBuf(ByteBuffer jdwpBuf) {
+        ByteBuffer slice;
+
+        assert jdwpBuf.position() == 0;
+
+        jdwpBuf.position(JdwpPacket.JDWP_HEADER_LEN + CHUNK_HEADER_LEN);
+        slice = jdwpBuf.slice();
+        slice.order(CHUNK_ORDER);
+        jdwpBuf.position(0);
+
+        return slice;
+    }
+
+    /**
+     * Write the chunk header at the start of the chunk.
+     *
+     * <p>Pass in the byte buffer returned by JdwpPacket.getPayload().
+     */
+    @VisibleForTesting
+    public static void finishChunkPacket(JdwpPacket packet, int type, int chunkLen) {
+        ByteBuffer buf = packet.getPayload();
+
+        buf.putInt(0x00, type);
+        buf.putInt(0x04, chunkLen);
+
+        packet.finishPacket(DDMS_CMD_SET, DDMS_CMD, CHUNK_HEADER_LEN + chunkLen);
+    }
+
+    public void handlePacket(ClientImpl client, JdwpPacket packet) {
+        ByteBuffer buf = packet.getPayload();
+        int type = buf.getInt();
+        int length = buf.getInt();
+        Log.d("ddms", "Calling handler for " + name(type) + " [" + this + "] (len=" + length + ")");
+        ByteBuffer ibuf = buf.slice();
+        ByteBuffer roBuf = ibuf.asReadOnlyBuffer(); // enforce R/O
+        roBuf.order(CHUNK_ORDER);
+
+        handleChunk(client, type, roBuf, packet.isReply(), packet.getId());
+    }
+
+    @Override
+    public JdwpPacket intercept(@NonNull JdwpAgent agent, @NonNull JdwpPacket packet) {
+        // TODO: ChunkHandlers are specific to client only packages. Further refactoring
+        // is needed to properly generalize them to JdwpInterceptors
+        if (agent instanceof ClientImpl) {
+            ClientImpl client = (ClientImpl) agent;
+            // TODO: ChunkHandlers are currently all static objects created in static
+            // initializers. For many different reasons they should not be there and should
+            // be moved to another creation mechanism where they are part of the ddm extension
+            // workflow. For now, access the ddmextension directly.
+            MonitorThread.getInstance().getDdmExtension().ddmSeen(client);
+
+            if (packet.isError()) {
+                client.packetFailed(packet);
+            } else if (packet.isEmpty()) {
+                Log.d("ddms", "Got empty reply for 0x" + Integer.toHexString(packet.getId()));
+            } else {
+                handlePacket(client, packet);
+            }
+            return null;
+        }
+        return packet;
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/HandleAppName.java b/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/HandleAppName.java
new file mode 100644
index 000000000..cd7d87845
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/HandleAppName.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.server.jdwp.chunkhandler;
+
+import com.android.ddmlib.ByteBufferUtil;
+import com.android.ddmlib.IDevice;
+import com.android.tradefed.device.server.ClientData;
+import com.android.tradefed.device.server.ClientImpl;
+import com.android.tradefed.device.server.MonitorThread;
+import com.android.tradefed.log.Log;
+
+import java.nio.BufferUnderflowException;
+import java.nio.ByteBuffer;
+
+/** Handle the "app name" chunk (APNM). */
+public final class HandleAppName extends ChunkHandler {
+
+    public static final int CHUNK_APNM = ChunkHandler.type("APNM");
+
+    private static final HandleAppName mInst = new HandleAppName();
+
+    private HandleAppName() {}
+
+    /** Register for the packets we expect to get from the client. */
+    public static void register(MonitorThread mt) {
+        mt.registerChunkHandler(CHUNK_APNM, mInst);
+    }
+
+    /** Client is ready. */
+    @Override
+    public void clientReady(ClientImpl client) {}
+
+    /** Client went away. */
+    @Override
+    public void clientDisconnected(ClientImpl client) {}
+
+    /** Chunk handler entry point. */
+    @Override
+    public void handleChunk(
+            ClientImpl client, int type, ByteBuffer data, boolean isReply, int msgId) {
+
+        Log.d("ddm-appname", "handling " + ChunkHandler.name(type));
+
+        if (type == CHUNK_APNM) {
+            assert !isReply;
+            handleAPNM(client, data);
+        } else {
+            handleUnknownChunk(client, type, data, isReply, msgId);
+        }
+    }
+
+    /*
+     * Handle a reply to our APNM message.
+     */
+    private static void handleAPNM(ClientImpl client, ByteBuffer data) {
+        int appNameLen;
+        String appName;
+
+        appNameLen = data.getInt();
+        appName = ByteBufferUtil.getString(data, appNameLen);
+
+        // Newer devices send user id in the APNM packet.
+        Integer userId = null;
+        if (data.hasRemaining()) {
+            int dataRemaining = data.remaining();
+            try {
+                userId = data.getInt();
+            } catch (BufferUnderflowException e) {
+                Log.e("ddm-appname", "Insufficient data in APNM chunk to retrieve user id.");
+                Log.e("ddm-appname", "Actual chunk length: " + dataRemaining);
+                Log.e("ddm-appname", "Expected chunk length: 4"); // 4 bytes for userId int
+            }
+        }
+
+        // Newer devices (newer than user id support) send the package names associated with the
+        // app.
+        String packageName = IDevice.UNKNOWN_PACKAGE;
+        if (data.hasRemaining()) {
+            int dataRemaining = data.remaining();
+            int packageNameLength = 0;
+            try {
+                packageNameLength = data.getInt();
+                packageName = ByteBufferUtil.getString(data, packageNameLength);
+            } catch (BufferUnderflowException e) {
+                // one integer + utf-16 string
+                int expectedChunkLength = 4 + packageNameLength * 2;
+
+                Log.e("ddm-appname", "Insufficient data in APNM chunk to retrieve package name.");
+                Log.e("ddm-appname", "Actual chunk length: " + dataRemaining);
+                Log.e("ddm-appname", "Expected chunk length: " + expectedChunkLength);
+            }
+        }
+
+        Log.d("ddm-appname", "APNM: app='" + appName + "'");
+
+        ClientData.Names names = new ClientData.Names(appName, userId, packageName);
+
+        ClientData cd = client.getClientData();
+        cd.setNames(names);
+
+        if (client != null) {
+            client.update(ClientImpl.CHANGE_NAME);
+        }
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/HandleExit.java b/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/HandleExit.java
new file mode 100644
index 000000000..9b4d22001
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/HandleExit.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.server.jdwp.chunkhandler;
+
+import com.android.tradefed.device.server.ClientImpl;
+import com.android.tradefed.device.server.MonitorThread;
+import com.android.tradefed.log.Log;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+/** Submit an exit request. */
+public final class HandleExit extends ChunkHandler {
+
+    public static final int CHUNK_EXIT = type("EXIT");
+
+    private static final HandleExit mInst = new HandleExit();
+
+    private HandleExit() {}
+
+    /** Register for the packets we expect to get from the client. */
+    public static void register(MonitorThread mt) {}
+
+    /** Client is ready. */
+    @Override
+    public void clientReady(ClientImpl client) {}
+
+    /** Client went away. */
+    @Override
+    public void clientDisconnected(ClientImpl client) {}
+
+    /** Chunk handler entry point. */
+    @Override
+    public void handleChunk(
+            ClientImpl client, int type, ByteBuffer data, boolean isReply, int msgId) {
+        handleUnknownChunk(client, type, data, isReply, msgId);
+    }
+
+    /** Send an EXIT request to the client. */
+    public static void sendEXIT(ClientImpl client, int status) throws IOException {
+        ByteBuffer rawBuf = allocBuffer(4);
+        JdwpPacket packet = new JdwpPacket(rawBuf);
+        ByteBuffer buf = getChunkDataBuf(rawBuf);
+
+        buf.putInt(status);
+
+        finishChunkPacket(packet, CHUNK_EXIT, buf.position());
+        Log.d("ddm-exit", "Sending " + name(CHUNK_EXIT) + ": " + status);
+        client.send(packet, mInst);
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/HandleHeap.java b/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/HandleHeap.java
new file mode 100644
index 000000000..66004b7e5
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/HandleHeap.java
@@ -0,0 +1,389 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.server.jdwp.chunkhandler;
+
+import com.android.ddmlib.ByteBufferUtil;
+import com.android.tradefed.device.server.ClientData;
+import com.android.tradefed.device.server.ClientData.AllocationTrackingStatus;
+import com.android.tradefed.device.server.ClientData.IHprofDumpHandler;
+import com.android.tradefed.device.server.ClientImpl;
+import com.android.tradefed.device.server.MonitorThread;
+import com.android.tradefed.log.Log;
+
+import java.io.IOException;
+import java.nio.BufferUnderflowException;
+import java.nio.ByteBuffer;
+
+/** Handle heap status updates. */
+public final class HandleHeap extends ChunkHandler {
+
+    public static final int CHUNK_HPIF = type("HPIF");
+    public static final int CHUNK_HPST = type("HPST");
+    public static final int CHUNK_HPEN = type("HPEN");
+    public static final int CHUNK_HPSG = type("HPSG");
+    public static final int CHUNK_HPGC = type("HPGC");
+    public static final int CHUNK_HPDU = type("HPDU");
+    public static final int CHUNK_HPDS = type("HPDS");
+    public static final int CHUNK_REAE = type("REAE");
+    public static final int CHUNK_REAQ = type("REAQ");
+    public static final int CHUNK_REAL = type("REAL");
+
+    // args to sendHPSG
+    public static final int WHEN_DISABLE = 0;
+    public static final int WHEN_GC = 1;
+    public static final int WHAT_MERGE = 0; // merge adjacent objects
+    public static final int WHAT_OBJ = 1; // keep objects distinct
+
+    // args to sendHPIF
+    public static final int HPIF_WHEN_NEVER = 0;
+    public static final int HPIF_WHEN_NOW = 1;
+    public static final int HPIF_WHEN_NEXT_GC = 2;
+    public static final int HPIF_WHEN_EVERY_GC = 3;
+
+    private static final HandleHeap mInst = new HandleHeap();
+
+    private HandleHeap() {}
+
+    /** Register for the packets we expect to get from the client. */
+    public static void register(MonitorThread mt) {
+        mt.registerChunkHandler(CHUNK_HPIF, mInst);
+        mt.registerChunkHandler(CHUNK_HPST, mInst);
+        mt.registerChunkHandler(CHUNK_HPEN, mInst);
+        mt.registerChunkHandler(CHUNK_HPSG, mInst);
+        mt.registerChunkHandler(CHUNK_HPDS, mInst);
+        mt.registerChunkHandler(CHUNK_REAQ, mInst);
+        mt.registerChunkHandler(CHUNK_REAL, mInst);
+    }
+
+    /** Client is ready. */
+    @Override
+    public void clientReady(ClientImpl client) throws IOException {
+        client.initializeHeapUpdateStatus();
+    }
+
+    /** Client went away. */
+    @Override
+    public void clientDisconnected(ClientImpl client) {}
+
+    /** Chunk handler entry point. */
+    @Override
+    public void handleChunk(
+            ClientImpl client, int type, ByteBuffer data, boolean isReply, int msgId) {
+        Log.d("ddm-heap", "handling " + ChunkHandler.name(type));
+
+        if (type == CHUNK_HPIF) {
+            handleHPIF(client, data);
+        } else if (type == CHUNK_HPST) {
+            handleHPST(client, data);
+        } else if (type == CHUNK_HPEN) {
+            handleHPEN(client, data);
+        } else if (type == CHUNK_HPSG) {
+            handleHPSG(client, data);
+        } else if (type == CHUNK_HPDU) {
+            handleHPDU(client, data);
+        } else if (type == CHUNK_HPDS) {
+            handleHPDS(client, data);
+        } else if (type == CHUNK_REAQ) {
+            handleREAQ(client, data);
+        } else if (type == CHUNK_REAL) {
+            handleREAL(client, data);
+        } else {
+            handleUnknownChunk(client, type, data, isReply, msgId);
+        }
+    }
+
+    /*
+     * Handle a heap info message.
+     */
+    private void handleHPIF(ClientImpl client, ByteBuffer data) {
+        Log.d("ddm-heap", "HPIF!");
+        try {
+            int numHeaps = data.getInt();
+
+            for (int i = 0; i < numHeaps; i++) {
+                int heapId = data.getInt();
+                long timeStamp = data.getLong();
+                byte reason = data.get();
+                long maxHeapSize = (long) data.getInt() & 0x00ffffffff;
+                long heapSize = (long) data.getInt() & 0x00ffffffff;
+                long bytesAllocated = (long) data.getInt() & 0x00ffffffff;
+                long objectsAllocated = (long) data.getInt() & 0x00ffffffff;
+
+                client.getClientData()
+                        .setHeapInfo(
+                                heapId,
+                                maxHeapSize,
+                                heapSize,
+                                bytesAllocated,
+                                objectsAllocated,
+                                timeStamp,
+                                reason);
+                client.update(ClientImpl.CHANGE_HEAP_DATA);
+            }
+        } catch (BufferUnderflowException ex) {
+            Log.w("ddm-heap", "malformed HPIF chunk from client");
+        }
+    }
+
+    /** Send an HPIF (HeaP InFo) request to the client. */
+    public static void sendHPIF(ClientImpl client, int when) throws IOException {
+        ByteBuffer rawBuf = allocBuffer(1);
+        JdwpPacket packet = new JdwpPacket(rawBuf);
+        ByteBuffer buf = getChunkDataBuf(rawBuf);
+
+        buf.put((byte) when);
+
+        finishChunkPacket(packet, CHUNK_HPIF, buf.position());
+        Log.d("ddm-heap", "Sending " + name(CHUNK_HPIF) + ": when=" + when);
+        client.send(packet, mInst);
+    }
+
+    /*
+     * Handle a heap segment series start message.
+     */
+    private void handleHPST(ClientImpl client, ByteBuffer data) {
+        /* Clear out any data that's sitting around to
+         * get ready for the chunks that are about to come.
+         */
+        // xxx todo: only clear data that belongs to the heap mentioned in <data>.
+        client.getClientData().getVmHeapData().clearHeapData();
+    }
+
+    /*
+     * Handle a heap segment series end message.
+     */
+    private void handleHPEN(ClientImpl client, ByteBuffer data) {
+        /* Let the UI know that we've received all of the
+         * data for this heap.
+         */
+        // xxx todo: only seal data that belongs to the heap mentioned in <data>.
+        client.getClientData().getVmHeapData().sealHeapData();
+        client.update(ClientImpl.CHANGE_HEAP_DATA);
+    }
+
+    /*
+     * Handle a heap segment message.
+     */
+    private void handleHPSG(ClientImpl client, ByteBuffer data) {
+        byte[] dataCopy = new byte[data.limit()];
+        data.rewind();
+        data.get(dataCopy);
+        data = ByteBuffer.wrap(dataCopy);
+        client.getClientData().getVmHeapData().addHeapData(data);
+        // xxx todo: add to the heap mentioned in <data>
+    }
+
+    /** Sends an HPSG (HeaP SeGment) request to the client. */
+    public static void sendHPSG(ClientImpl client, int when, int what) throws IOException {
+
+        ByteBuffer rawBuf = allocBuffer(2);
+        JdwpPacket packet = new JdwpPacket(rawBuf);
+        ByteBuffer buf = getChunkDataBuf(rawBuf);
+
+        buf.put((byte) when);
+        buf.put((byte) what);
+
+        finishChunkPacket(packet, CHUNK_HPSG, buf.position());
+        Log.d("ddm-heap", "Sending " + name(CHUNK_HPSG) + ": when=" + when + ", what=" + what);
+        client.send(packet, mInst);
+    }
+
+    /** Sends an HPGC request to the client. */
+    public static void sendHPGC(ClientImpl client) throws IOException {
+        ByteBuffer rawBuf = allocBuffer(0);
+        JdwpPacket packet = new JdwpPacket(rawBuf);
+        ByteBuffer buf = getChunkDataBuf(rawBuf);
+
+        // no data
+
+        finishChunkPacket(packet, CHUNK_HPGC, buf.position());
+        Log.d("ddm-heap", "Sending " + name(CHUNK_HPGC));
+        client.send(packet, mInst);
+    }
+
+    /**
+     * Sends an HPDU request to the client.
+     *
+     * <p>We will get an HPDU response when the heap dump has completed. On failure we get a generic
+     * failure response.
+     *
+     * @param fileName name of output file (on device)
+     */
+    public static void sendHPDU(ClientImpl client, String fileName) throws IOException {
+        ByteBuffer rawBuf = allocBuffer(4 + fileName.length() * 2);
+        JdwpPacket packet = new JdwpPacket(rawBuf);
+        ByteBuffer buf = getChunkDataBuf(rawBuf);
+
+        buf.putInt(fileName.length());
+        ByteBufferUtil.putString(buf, fileName);
+
+        finishChunkPacket(packet, CHUNK_HPDU, buf.position());
+        Log.d("ddm-heap", "Sending " + name(CHUNK_HPDU) + " '" + fileName + "'");
+        client.send(packet, mInst);
+        client.getClientData().setPendingHprofDump(fileName);
+    }
+
+    /**
+     * Sends an HPDS request to the client.
+     *
+     * <p>We will get an HPDS response when the heap dump has completed. On failure we get a generic
+     * failure response.
+     *
+     * <p>This is more expensive for the device than HPDU, because the entire heap dump is held in
+     * RAM instead of spooled out to a temp file. On the other hand, permission to write to /sdcard
+     * is not required.
+     *
+     * @param fileName name of output file (on device)
+     */
+    public static void sendHPDS(ClientImpl client) throws IOException {
+        ByteBuffer rawBuf = allocBuffer(0);
+        JdwpPacket packet = new JdwpPacket(rawBuf);
+        ByteBuffer buf = getChunkDataBuf(rawBuf);
+
+        finishChunkPacket(packet, CHUNK_HPDS, buf.position());
+        Log.d("ddm-heap", "Sending " + name(CHUNK_HPDS));
+        client.send(packet, mInst);
+    }
+
+    /*
+     * Handle notification of completion of a HeaP DUmp.
+     */
+    private void handleHPDU(ClientImpl client, ByteBuffer data) {
+        byte result;
+
+        // get the filename and make the client not have pending HPROF dump anymore.
+        String filename = client.getClientData().getPendingHprofDump();
+        client.getClientData().setPendingHprofDump(null);
+
+        // get the dump result
+        result = data.get();
+
+        // get the app-level handler for HPROF dump
+        IHprofDumpHandler handler = ClientData.getHprofDumpHandler();
+        if (result == 0) {
+            if (handler != null) {
+                handler.onSuccess(filename, client);
+            }
+            client.getClientData().setHprofData(filename);
+            Log.d("ddm-heap", "Heap dump request has finished");
+        } else {
+            if (handler != null) {
+                handler.onEndFailure(client, null);
+            }
+            client.getClientData().clearHprofData();
+            Log.w("ddm-heap", "Heap dump request failed (check device log)");
+        }
+        client.update(ClientImpl.CHANGE_HPROF);
+        client.getClientData().clearHprofData();
+    }
+
+    /*
+     * Handle HeaP Dump Streaming response.  "data" contains the full
+     * hprof dump.
+     */
+    private void handleHPDS(ClientImpl client, ByteBuffer data) {
+        byte[] stuff = new byte[data.capacity()];
+        data.get(stuff, 0, stuff.length);
+
+        Log.d("ddm-hprof", "got hprof file, size: " + data.capacity() + " bytes");
+        client.getClientData().setHprofData(stuff);
+        IHprofDumpHandler handler = ClientData.getHprofDumpHandler();
+        if (handler != null) {
+            handler.onSuccess(stuff, client);
+        }
+        client.update(ClientImpl.CHANGE_HPROF);
+        client.getClientData().clearHprofData();
+    }
+
+    /** Sends a REAE (REcent Allocation Enable) request to the client. */
+    public static void sendREAE(ClientImpl client, boolean enable) throws IOException {
+        ByteBuffer rawBuf = allocBuffer(1);
+        JdwpPacket packet = new JdwpPacket(rawBuf);
+        ByteBuffer buf = getChunkDataBuf(rawBuf);
+
+        buf.put((byte) (enable ? 1 : 0));
+
+        finishChunkPacket(packet, CHUNK_REAE, buf.position());
+        Log.d("ddm-heap", "Sending " + name(CHUNK_REAE) + ": " + enable);
+        client.send(packet, mInst);
+    }
+
+    /** Sends a REAQ (REcent Allocation Query) request to the client. */
+    public static void sendREAQ(ClientImpl client) throws IOException {
+        ByteBuffer rawBuf = allocBuffer(0);
+        JdwpPacket packet = new JdwpPacket(rawBuf);
+        ByteBuffer buf = getChunkDataBuf(rawBuf);
+
+        // no data
+
+        finishChunkPacket(packet, CHUNK_REAQ, buf.position());
+        Log.d("ddm-heap", "Sending " + name(CHUNK_REAQ));
+        client.send(packet, mInst);
+    }
+
+    /** Sends a REAL (REcent ALlocation) request to the client. */
+    public static void sendREAL(ClientImpl client) throws IOException {
+        ByteBuffer rawBuf = allocBuffer(0);
+        JdwpPacket packet = new JdwpPacket(rawBuf);
+        ByteBuffer buf = getChunkDataBuf(rawBuf);
+
+        // no data
+
+        finishChunkPacket(packet, CHUNK_REAL, buf.position());
+        Log.d("ddm-heap", "Sending " + name(CHUNK_REAL));
+        client.send(packet, mInst);
+    }
+
+    /*
+     * Handle the response from our REcent Allocation Query message.
+     */
+    private void handleREAQ(ClientImpl client, ByteBuffer data) {
+        boolean enabled;
+
+        enabled = (data.get() != 0);
+        Log.d("ddm-heap", "REAQ says: enabled=" + enabled);
+
+        client.getClientData()
+                .setAllocationStatus(
+                        enabled ? AllocationTrackingStatus.ON : AllocationTrackingStatus.OFF);
+        client.update(ClientImpl.CHANGE_HEAP_ALLOCATION_STATUS);
+    }
+
+    /*
+     * Handle a REcent ALlocation response.
+     */
+    private void handleREAL(ClientImpl client, ByteBuffer data) {
+        Log.e("ddm-heap", "*** Received " + name(CHUNK_REAL));
+
+        byte[] stuff = new byte[data.capacity()];
+        data.get(stuff, 0, stuff.length);
+        data.rewind();
+
+        // Work with legacy global handler.
+        ClientData.IAllocationTrackingHandler handler = ClientData.getAllocationTrackingHandler();
+        if (handler != null) {
+            Log.d("ddm-prof", "got allocations file, size: " + stuff.length + " bytes");
+            handler.onSuccess(stuff, client);
+        }
+
+        client.getClientData().setAllocationsData(stuff);
+        client.update(ClientImpl.CHANGE_HEAP_ALLOCATIONS);
+
+        // Clean up after everything has been notified (synchronously).
+        client.getClientData().setAllocationsData(null);
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/HandleHello.java b/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/HandleHello.java
new file mode 100644
index 000000000..8ab3ad970
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/HandleHello.java
@@ -0,0 +1,238 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.server.jdwp.chunkhandler;
+
+import com.android.ddmlib.ByteBufferUtil;
+import com.android.ddmlib.IDevice;
+import com.android.tradefed.device.server.ClientData;
+import com.android.tradefed.device.server.ClientImpl;
+import com.android.tradefed.device.server.MonitorThread;
+import com.android.tradefed.log.Log;
+
+import java.io.IOException;
+import java.nio.BufferUnderflowException;
+import java.nio.ByteBuffer;
+
+/** Handle the "hello" chunk (HELO) and feature discovery. */
+public final class HandleHello extends ChunkHandler {
+
+    public static final int CHUNK_HELO = ChunkHandler.type("HELO");
+    public static final int CHUNK_FEAT = ChunkHandler.type("FEAT");
+
+    private static final HandleHello mInst = new HandleHello();
+
+    private HandleHello() {}
+
+    /** Register for the packets we expect to get from the client. */
+    public static void register(MonitorThread mt) {
+        mt.registerChunkHandler(CHUNK_HELO, mInst);
+    }
+
+    /** Client is ready. */
+    @Override
+    public void clientReady(ClientImpl client) {
+        Log.d("ddm-hello", "Now ready: " + client);
+    }
+
+    /** Client went away. */
+    @Override
+    public void clientDisconnected(ClientImpl client) {
+        Log.d("ddm-hello", "Now disconnected: " + client);
+    }
+
+    /**
+     * Sends HELLO-type commands to the VM after a good handshake.
+     *
+     * @param client
+     * @param serverProtocolVersion
+     * @throws IOException
+     */
+    public static void sendHelloCommands(ClientImpl client, int serverProtocolVersion)
+            throws IOException {
+        sendHELO(client, serverProtocolVersion);
+        sendFEAT(client);
+        HandleProfiling.sendMPRQ(client);
+    }
+
+    /** Chunk handler entry point. */
+    @Override
+    public void handleChunk(
+            ClientImpl client, int type, ByteBuffer data, boolean isReply, int msgId) {
+
+        Log.d("ddm-hello", "handling " + ChunkHandler.name(type));
+
+        if (type == CHUNK_HELO) {
+            assert isReply;
+            handleHELO(client, data);
+        } else if (type == CHUNK_FEAT) {
+            handleFEAT(client, data);
+        } else {
+            handleUnknownChunk(client, type, data, isReply, msgId);
+        }
+    }
+
+    /*
+     * Handle a reply to our HELO message.
+     */
+    private static void handleHELO(ClientImpl client, ByteBuffer data) {
+        int version, pid, vmIdentLen, appNameLen;
+        String vmIdent, processName;
+
+        version = data.getInt();
+        pid = data.getInt();
+        vmIdentLen = data.getInt();
+        appNameLen = data.getInt();
+
+        vmIdent = ByteBufferUtil.getString(data, vmIdentLen);
+        processName = ByteBufferUtil.getString(data, appNameLen);
+
+        Log.d(
+                "ddm-hello",
+                String.format(
+                        "HELO: v=%d, pid=%d, vm='%s', app='%s'",
+                        version, pid, vmIdent, processName));
+
+        // Newer devices send user id in the APNM packet.
+        Integer userId = null;
+        if (data.hasRemaining()) {
+            try {
+                userId = data.getInt();
+            } catch (BufferUnderflowException e) {
+                // five integers + two utf-16 strings
+                int expectedPacketLength = 20 + appNameLen * 2 + vmIdentLen * 2;
+
+                Log.e("ddm-hello", "Insufficient data in HELO chunk to retrieve user id.");
+                Log.e("ddm-hello", "Actual chunk length: " + data.capacity());
+                Log.e("ddm-hello", "Expected chunk length: " + expectedPacketLength);
+            }
+        }
+
+        // check if the VM has reported information about the ABI
+        boolean validAbi = false;
+        String abi = null;
+        if (data.hasRemaining()) {
+            try {
+                int abiLength = data.getInt();
+                abi = ByteBufferUtil.getString(data, abiLength);
+                validAbi = true;
+            } catch (BufferUnderflowException e) {
+                Log.e("ddm-hello", "Insufficient data in HELO chunk to retrieve ABI.");
+            }
+        }
+
+        boolean hasJvmFlags = false;
+        String jvmFlags = null;
+        if (data.hasRemaining()) {
+            try {
+                int jvmFlagsLength = data.getInt();
+                jvmFlags = ByteBufferUtil.getString(data, jvmFlagsLength);
+                hasJvmFlags = true;
+            } catch (BufferUnderflowException e) {
+                Log.e("ddm-hello", "Insufficient data in HELO chunk to retrieve JVM flags");
+            }
+        }
+
+        boolean nativeDebuggable = false;
+        if (data.hasRemaining()) {
+            try {
+                byte nativeDebuggableByte = data.get();
+                nativeDebuggable = nativeDebuggableByte == 1;
+            } catch (BufferUnderflowException e) {
+                Log.e("ddm-hello", "Insufficient data in HELO chunk to retrieve nativeDebuggable");
+            }
+        }
+
+        String packageName = IDevice.UNKNOWN_PACKAGE;
+        if (data.hasRemaining()) {
+            try {
+                int packageNameLength = data.getInt();
+                packageName = ByteBufferUtil.getString(data, packageNameLength);
+                Log.d("ddm-hello", String.format("HELO: pkg='%s'", packageName));
+            } catch (BufferUnderflowException e) {
+                Log.e("ddm-hello", "Insufficient data in HELO chunk to retrieve packageName");
+            }
+        }
+
+        ClientData cd = client.getClientData();
+
+        if (cd.getPid() == pid) {
+            cd.setVmIdentifier(vmIdent);
+            cd.setNames(new ClientData.Names(processName, userId, packageName));
+
+            if (validAbi) {
+                cd.setAbi(abi);
+            }
+
+            if (hasJvmFlags) {
+                cd.setJvmFlags(jvmFlags);
+            }
+
+            cd.setNativeDebuggable(nativeDebuggable);
+        } else {
+            Log.e(
+                    "ddm-hello",
+                    "Received pid (" + pid + ") does not match client pid (" + cd.getPid() + ")");
+        }
+
+        if (client != null) {
+            client.update(ClientImpl.CHANGE_NAME);
+        }
+    }
+
+    /** Send a HELO request to the client. */
+    public static void sendHELO(ClientImpl client, int serverProtocolVersion) throws IOException {
+        ByteBuffer rawBuf = allocBuffer(4);
+        JdwpPacket packet = new JdwpPacket(rawBuf);
+        ByteBuffer buf = getChunkDataBuf(rawBuf);
+
+        buf.putInt(serverProtocolVersion);
+
+        finishChunkPacket(packet, CHUNK_HELO, buf.position());
+        Log.d(
+                "ddm-hello",
+                "Sending " + name(CHUNK_HELO) + " ID=0x" + Integer.toHexString(packet.getId()));
+        client.send(packet, mInst);
+    }
+
+    /** Handle a reply to our FEAT request. */
+    private static void handleFEAT(ClientImpl client, ByteBuffer data) {
+        int featureCount;
+        int i;
+
+        featureCount = data.getInt();
+        for (i = 0; i < featureCount; i++) {
+            int len = data.getInt();
+            String feature = ByteBufferUtil.getString(data, len);
+            client.getClientData().addFeature(feature);
+
+            Log.d("ddm-hello", "Feature: " + feature);
+        }
+    }
+
+    /** Send a FEAT request to the client. */
+    public static void sendFEAT(ClientImpl client) throws IOException {
+        ByteBuffer rawBuf = allocBuffer(0);
+        JdwpPacket packet = new JdwpPacket(rawBuf);
+        ByteBuffer buf = getChunkDataBuf(rawBuf);
+
+        // no data
+
+        finishChunkPacket(packet, CHUNK_FEAT, buf.position());
+        Log.d("ddm-heap", "Sending " + name(CHUNK_FEAT));
+        client.send(packet, mInst);
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/HandleNativeHeap.java b/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/HandleNativeHeap.java
new file mode 100644
index 000000000..571260a66
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/HandleNativeHeap.java
@@ -0,0 +1,344 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.server.jdwp.chunkhandler;
+
+import com.android.tradefed.device.server.ClientData;
+import com.android.tradefed.device.server.ClientImpl;
+import com.android.tradefed.device.server.MonitorThread;
+import com.android.tradefed.device.server.NativeAllocationInfo;
+import com.android.tradefed.log.Log;
+
+import java.io.BufferedReader;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+
+/** Handle thread status updates. */
+public final class HandleNativeHeap extends ChunkHandler {
+
+    public static final int CHUNK_NHGT = type("NHGT"); // $NON-NLS-1$
+    public static final int CHUNK_NHSG = type("NHSG"); // $NON-NLS-1$
+    public static final int CHUNK_NHST = type("NHST"); // $NON-NLS-1$
+    public static final int CHUNK_NHEN = type("NHEN"); // $NON-NLS-1$
+
+    private static final HandleNativeHeap mInst = new HandleNativeHeap();
+
+    /** Handle getting different sized size_t and pointer reads. */
+    abstract class NativeBuffer {
+        public NativeBuffer(ByteBuffer buffer) {
+            mBuffer = buffer;
+        }
+
+        public abstract int getSizeT();
+
+        public abstract long getPtr();
+
+        protected ByteBuffer mBuffer;
+    }
+
+    /** This class treats size_t and pointer values as 32 bit. */
+    final class NativeBuffer32 extends NativeBuffer {
+        public NativeBuffer32(ByteBuffer buffer) {
+            super(buffer);
+        }
+
+        @Override
+        public int getSizeT() {
+            return mBuffer.getInt();
+        }
+
+        @Override
+        public long getPtr() {
+            return (long) mBuffer.getInt() & 0x00000000ffffffffL;
+        }
+    }
+
+    /** This class treats size_t and pointer values as 64 bit. */
+    final class NativeBuffer64 extends NativeBuffer {
+        public NativeBuffer64(ByteBuffer buffer) {
+            super(buffer);
+        }
+
+        @Override
+        public int getSizeT() {
+            return (int) mBuffer.getLong();
+        }
+
+        @Override
+        public long getPtr() {
+            return mBuffer.getLong();
+        }
+    }
+
+    private HandleNativeHeap() {}
+
+    /** Register for the packets we expect to get from the client. */
+    public static void register(MonitorThread mt) {
+        mt.registerChunkHandler(CHUNK_NHGT, mInst);
+        mt.registerChunkHandler(CHUNK_NHSG, mInst);
+        mt.registerChunkHandler(CHUNK_NHST, mInst);
+        mt.registerChunkHandler(CHUNK_NHEN, mInst);
+    }
+
+    /** Client is ready. */
+    @Override
+    public void clientReady(ClientImpl client) {}
+
+    /** Client went away. */
+    @Override
+    public void clientDisconnected(ClientImpl client) {}
+
+    /** Chunk handler entry point. */
+    @Override
+    public void handleChunk(
+            ClientImpl client, int type, ByteBuffer data, boolean isReply, int msgId) {
+
+        Log.d("ddm-nativeheap", "handling " + ChunkHandler.name(type));
+
+        if (type == CHUNK_NHGT) {
+            handleNHGT(client, data);
+        } else if (type == CHUNK_NHST) {
+            // start chunk before any NHSG chunk(s)
+            client.getClientData().getNativeHeapData().clearHeapData();
+        } else if (type == CHUNK_NHEN) {
+            // end chunk after NHSG chunk(s)
+            client.getClientData().getNativeHeapData().sealHeapData();
+        } else if (type == CHUNK_NHSG) {
+            handleNHSG(client, data);
+        } else {
+            handleUnknownChunk(client, type, data, isReply, msgId);
+        }
+
+        client.update(ClientImpl.CHANGE_NATIVE_HEAP_DATA);
+    }
+
+    /** Send an NHGT (Native Thread GeT) request to the client. */
+    public static void sendNHGT(ClientImpl client) throws IOException {
+
+        ByteBuffer rawBuf = allocBuffer(0);
+        JdwpPacket packet = new JdwpPacket(rawBuf);
+        ByteBuffer buf = getChunkDataBuf(rawBuf);
+
+        // no data in request message
+
+        finishChunkPacket(packet, CHUNK_NHGT, buf.position());
+        Log.d("ddm-nativeheap", "Sending " + name(CHUNK_NHGT));
+        client.send(packet, mInst);
+
+        rawBuf = allocBuffer(2);
+        packet = new JdwpPacket(rawBuf);
+        buf = getChunkDataBuf(rawBuf);
+
+        buf.put((byte) HandleHeap.WHEN_DISABLE);
+        buf.put((byte) HandleHeap.WHAT_OBJ);
+
+        finishChunkPacket(packet, CHUNK_NHSG, buf.position());
+        Log.d("ddm-nativeheap", "Sending " + name(CHUNK_NHSG));
+        client.send(packet, mInst);
+    }
+
+    /*
+     * Handle our native heap data.
+     */
+    private void handleNHGT(ClientImpl client, ByteBuffer data) {
+        ClientData clientData = client.getClientData();
+
+        Log.d("ddm-nativeheap", "NHGT: " + data.limit() + " bytes");
+
+        data.order(ByteOrder.LITTLE_ENDIAN);
+
+        // There are two supported header formats.
+        //
+        // The original version of the header for 32 bit processes:
+        //
+        //   uint32_t mapSize;
+        //   uint32_t mapSize;
+        //   uint32_t allocSize;
+        //   uint32_t allocInfoSize;
+        //   uint32_t totalMemory;
+        //   uint32_t backtrace_size;
+        //
+        // The new header which includes a signature and pointer size:
+        //
+        //   uint32_t signature;   (Which is always 0x812345dd)
+        //   uint16_t version;     (Only version 2 of the new format supported)
+        //   uint16_t pointerSize; (Size in bytes of size_t/pointer values)
+        //   size_t mapSize;
+        //   size_t allocSize;
+        //   size_t allocInfoSize;
+        //   size_t totalMemory;
+        //   size_t backtrace_size;
+        //
+        // If the signature doesn't match, then the code uses the original
+        // header format. If the signature matches, then use the new
+        // header format with variable sizes of size_t and pointers.
+        int signature = data.getInt(0);
+        short pointerSize = 4;
+        if (signature == 0x812345dd) {
+            // Consume signature value.
+            int ignore = data.getInt();
+            short version = data.getShort();
+            if (version != 2) {
+                Log.e("ddms", "Unknown header version: " + version);
+                return;
+            }
+            pointerSize = data.getShort();
+        }
+        NativeBuffer buffer;
+        if (pointerSize == 4) {
+            buffer = new NativeBuffer32(data);
+        } else if (pointerSize == 8) {
+            buffer = new NativeBuffer64(data);
+        } else {
+            Log.e("ddms", "Unknown pointer size: " + pointerSize);
+            return;
+        }
+
+        // clear the previous run
+        clientData.clearNativeAllocationInfo();
+
+        int mapSize = buffer.getSizeT();
+        int allocSize = buffer.getSizeT();
+        int allocInfoSize = buffer.getSizeT();
+        int totalMemory = buffer.getSizeT();
+        int backtraceSize = buffer.getSizeT();
+
+        Log.d("ddms", "mapSize: " + mapSize);
+        Log.d("ddms", "allocSize: " + allocSize);
+        Log.d("ddms", "allocInfoSize: " + allocInfoSize);
+        Log.d("ddms", "totalMemory: " + totalMemory);
+
+        clientData.setTotalNativeMemory(totalMemory);
+
+        // this means that updates aren't turned on.
+        if (allocInfoSize == 0) {
+            return;
+        }
+
+        if (mapSize > 0) {
+            byte[] maps = new byte[mapSize];
+            data.get(maps, 0, mapSize);
+            parseMaps(clientData, maps);
+        }
+
+        int iterations = allocSize / allocInfoSize;
+        for (int i = 0; i < iterations; i++) {
+            NativeAllocationInfo info =
+                    new NativeAllocationInfo(
+                            buffer.getSizeT() /* size */, buffer.getSizeT() /* allocations */);
+
+            for (int j = 0; j < backtraceSize; j++) {
+                long addr = buffer.getPtr();
+                if (addr == 0x0) {
+                    // skip past null addresses
+                    continue;
+                }
+
+                info.addStackCallAddress(addr);
+            }
+            clientData.addNativeAllocation(info);
+        }
+    }
+
+    private void handleNHSG(ClientImpl client, ByteBuffer data) {
+        byte[] dataCopy = new byte[data.limit()];
+        data.rewind();
+        data.get(dataCopy);
+        data = ByteBuffer.wrap(dataCopy);
+        client.getClientData().getNativeHeapData().addHeapData(data);
+
+        if (true) {
+            return;
+        }
+
+        byte[] copy = new byte[data.limit()];
+        data.get(copy);
+
+        ByteBuffer buffer = ByteBuffer.wrap(copy);
+        buffer.order(ByteOrder.BIG_ENDIAN);
+
+        int id = buffer.getInt();
+        int unitsize = buffer.get();
+        long startAddress = buffer.getInt() & 0x00000000ffffffffL;
+        int offset = buffer.getInt();
+        int allocationUnitCount = buffer.getInt();
+
+        // read the usage
+        while (buffer.position() < buffer.limit()) {
+            int eState = buffer.get() & 0x000000ff;
+            int eLen = (buffer.get() & 0x000000ff) + 1;
+        }
+    }
+
+    private void parseMaps(ClientData clientData, byte[] maps) {
+        InputStreamReader input = new InputStreamReader(new ByteArrayInputStream(maps));
+        BufferedReader reader = new BufferedReader(input);
+
+        String line;
+
+        try {
+            while ((line = reader.readLine()) != null) {
+                Log.d("ddms", "line: " + line);
+                // Expected format:
+                //   7fe51f2000-7fe5213000 rw-p 00000000 00:00 0      [stack]
+
+                int library_start = line.lastIndexOf(' ');
+                if (library_start == -1) {
+                    continue;
+                }
+
+                // Assume that any string that starts with a / is a
+                // shared library or executable that we will try to symbolize.
+                String library = line.substring(library_start + 1);
+                if (!library.startsWith("/")) {
+                    continue;
+                }
+
+                // Parse the start and end address range.
+                int dashIndex = line.indexOf('-');
+                int spaceIndex = line.indexOf(' ', dashIndex);
+                if (dashIndex == -1 || spaceIndex == -1) {
+                    continue;
+                }
+
+                long startAddr = 0;
+                long endAddr = 0;
+                try {
+                    startAddr = Long.parseLong(line.substring(0, dashIndex), 16);
+                    endAddr = Long.parseLong(line.substring(dashIndex + 1, spaceIndex), 16);
+                } catch (NumberFormatException e) {
+                    e.printStackTrace();
+                    continue;
+                }
+
+                clientData.addNativeLibraryMapInfo(startAddr, endAddr, library);
+                Log.d(
+                        "ddms",
+                        library
+                                + "("
+                                + Long.toHexString(startAddr)
+                                + " - "
+                                + Long.toHexString(endAddr)
+                                + ")");
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/HandleProfiling.java b/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/HandleProfiling.java
new file mode 100644
index 000000000..cac8b1afa
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/HandleProfiling.java
@@ -0,0 +1,349 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.server.jdwp.chunkhandler;
+
+import com.android.ddmlib.ByteBufferUtil;
+import com.android.tradefed.device.server.ClientData;
+import com.android.tradefed.device.server.ClientData.IMethodProfilingHandler;
+import com.android.tradefed.device.server.ClientData.MethodProfilingStatus;
+import com.android.tradefed.device.server.ClientImpl;
+import com.android.tradefed.device.server.MonitorThread;
+import com.android.tradefed.log.Log;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.util.concurrent.TimeUnit;
+
+/** Handle heap status updates. */
+public final class HandleProfiling extends ChunkHandler {
+
+    public static final int CHUNK_MPRS = type("MPRS");
+    public static final int CHUNK_MPRE = type("MPRE");
+    public static final int CHUNK_MPSS = type("MPSS");
+    public static final int CHUNK_MPSE = type("MPSE");
+    public static final int CHUNK_SPSS = type("SPSS");
+    public static final int CHUNK_SPSE = type("SPSE");
+    public static final int CHUNK_MPRQ = type("MPRQ");
+    public static final int CHUNK_FAIL = type("FAIL");
+
+    private static final HandleProfiling mInst = new HandleProfiling();
+
+    private HandleProfiling() {}
+
+    /** Register for the packets we expect to get from the client. */
+    public static void register(MonitorThread mt) {
+        mt.registerChunkHandler(CHUNK_MPRE, mInst);
+        mt.registerChunkHandler(CHUNK_MPSE, mInst);
+        mt.registerChunkHandler(CHUNK_MPRQ, mInst);
+    }
+
+    /** Client is ready. */
+    @Override
+    public void clientReady(ClientImpl client) throws IOException {}
+
+    /** Client went away. */
+    @Override
+    public void clientDisconnected(ClientImpl client) {}
+
+    /** Chunk handler entry point. */
+    @Override
+    public void handleChunk(
+            ClientImpl client, int type, ByteBuffer data, boolean isReply, int msgId) {
+
+        Log.d("ddm-prof", "handling " + ChunkHandler.name(type));
+
+        if (type == CHUNK_MPRE) {
+            handleMPRE(client, data);
+        } else if (type == CHUNK_MPSE) {
+            handleMPSE(client, data);
+        } else if (type == CHUNK_MPRQ) {
+            handleMPRQ(client, data);
+        } else if (type == CHUNK_FAIL) {
+            handleFAIL(client, data);
+        } else {
+            handleUnknownChunk(client, type, data, isReply, msgId);
+        }
+    }
+
+    /**
+     * Send a MPRS (Method PRofiling Start) request to the client.
+     *
+     * <p>The arguments to this method will eventually be passed to
+     * android.os.Debug.startMethodTracing() on the device.
+     *
+     * @param fileName is the name of the file to which profiling data will be written (on the
+     *     device);
+     * @param bufferSize is the desired buffer size in bytes (8MB is good)
+     * @param flags see startMethodTracing() docs; use 0 for default behavior
+     */
+    public static void sendMPRS(ClientImpl client, String fileName, int bufferSize, int flags)
+            throws IOException {
+
+        ByteBuffer rawBuf = allocBuffer(3 * 4 + fileName.length() * 2);
+        JdwpPacket packet = new JdwpPacket(rawBuf);
+        ByteBuffer buf = getChunkDataBuf(rawBuf);
+
+        buf.putInt(bufferSize);
+        buf.putInt(flags);
+        buf.putInt(fileName.length());
+        ByteBufferUtil.putString(buf, fileName);
+
+        finishChunkPacket(packet, CHUNK_MPRS, buf.position());
+        Log.d(
+                "ddm-prof",
+                "Sending "
+                        + name(CHUNK_MPRS)
+                        + " '"
+                        + fileName
+                        + "', size="
+                        + bufferSize
+                        + ", flags="
+                        + flags);
+        client.send(packet, mInst);
+
+        // record the filename we asked for.
+        client.getClientData().setPendingMethodProfiling(fileName);
+
+        // send a status query. this ensure that the status is properly updated if for some
+        // reason starting the tracing failed.
+        sendMPRQ(client);
+    }
+
+    /** Send a MPRE (Method PRofiling End) request to the client. */
+    public static void sendMPRE(ClientImpl client) throws IOException {
+        ByteBuffer rawBuf = allocBuffer(0);
+        JdwpPacket packet = new JdwpPacket(rawBuf);
+        ByteBuffer buf = getChunkDataBuf(rawBuf);
+
+        // no data
+
+        finishChunkPacket(packet, CHUNK_MPRE, buf.position());
+        Log.d("ddm-prof", "Sending " + name(CHUNK_MPRE));
+        client.send(packet, mInst);
+    }
+
+    /** Handle notification that method profiling has finished writing data to disk. */
+    private void handleMPRE(ClientImpl client, ByteBuffer data) {
+        byte result;
+
+        // get the filename and make the client not have pending HPROF dump anymore.
+        String filename = client.getClientData().getPendingMethodProfiling();
+        client.getClientData().setPendingMethodProfiling(null);
+
+        result = data.get();
+
+        // get the app-level handler for method tracing dump
+        IMethodProfilingHandler handler = ClientData.getMethodProfilingHandler();
+        if (handler != null) {
+            if (result == 0) {
+                handler.onSuccess(filename, client);
+
+                Log.d("ddm-prof", "Method profiling has finished");
+            } else {
+                handler.onEndFailure(client, null /*message*/);
+
+                Log.w("ddm-prof", "Method profiling has failed (check device log)");
+            }
+        }
+
+        client.getClientData().setMethodProfilingStatus(MethodProfilingStatus.OFF);
+        client.update(ClientImpl.CHANGE_METHOD_PROFILING_STATUS);
+    }
+
+    /**
+     * Send a MPSS (Method Profiling Streaming Start) request to the client.
+     *
+     * <p>The arguments to this method will eventually be passed to
+     * android.os.Debug.startMethodTracing() on the device.
+     *
+     * @param bufferSize is the desired buffer size in bytes (8MB is good)
+     * @param flags see startMethodTracing() docs; use 0 for default behavior
+     */
+    public static void sendMPSS(ClientImpl client, int bufferSize, int flags) throws IOException {
+
+        ByteBuffer rawBuf = allocBuffer(2 * 4);
+        JdwpPacket packet = new JdwpPacket(rawBuf);
+        ByteBuffer buf = getChunkDataBuf(rawBuf);
+
+        buf.putInt(bufferSize);
+        buf.putInt(flags);
+
+        finishChunkPacket(packet, CHUNK_MPSS, buf.position());
+        Log.d(
+                "ddm-prof",
+                "Sending " + name(CHUNK_MPSS) + "', size=" + bufferSize + ", flags=" + flags);
+        client.send(packet, mInst);
+
+        // send a status query. this ensure that the status is properly updated if for some
+        // reason starting the tracing failed.
+        sendMPRQ(client);
+    }
+
+    /**
+     * Send a SPSS (Sampling Profiling Streaming Start) request to the client.
+     *
+     * @param bufferSize is the desired buffer size in bytes (8MB is good)
+     * @param samplingInterval sampling interval
+     * @param samplingIntervalTimeUnits units for sampling interval
+     */
+    public static void sendSPSS(
+            ClientImpl client,
+            int bufferSize,
+            int samplingInterval,
+            TimeUnit samplingIntervalTimeUnits)
+            throws IOException {
+        int interval = (int) samplingIntervalTimeUnits.toMicros(samplingInterval);
+
+        ByteBuffer rawBuf = allocBuffer(3 * 4);
+        JdwpPacket packet = new JdwpPacket(rawBuf);
+        ByteBuffer buf = getChunkDataBuf(rawBuf);
+
+        buf.putInt(bufferSize);
+        buf.putInt(0); // flags
+        buf.putInt(interval);
+
+        finishChunkPacket(packet, CHUNK_SPSS, buf.position());
+        Log.d(
+                "ddm-prof",
+                "Sending "
+                        + name(CHUNK_SPSS)
+                        + "', size="
+                        + bufferSize
+                        + ", flags=0, samplingInterval="
+                        + interval);
+        client.send(packet, mInst);
+
+        // send a status query. this ensure that the status is properly updated if for some
+        // reason starting the tracing failed.
+        sendMPRQ(client);
+    }
+
+    /** Send a MPSE (Method Profiling Streaming End) request to the client. */
+    public static void sendMPSE(ClientImpl client) throws IOException {
+        ByteBuffer rawBuf = allocBuffer(0);
+        JdwpPacket packet = new JdwpPacket(rawBuf);
+        ByteBuffer buf = getChunkDataBuf(rawBuf);
+
+        // no data
+
+        finishChunkPacket(packet, CHUNK_MPSE, buf.position());
+        Log.d("ddm-prof", "Sending " + name(CHUNK_MPSE));
+        client.send(packet, mInst);
+    }
+
+    /** Send a SPSE (Sampling Profiling Streaming End) request to the client. */
+    public static void sendSPSE(ClientImpl client) throws IOException {
+        ByteBuffer rawBuf = allocBuffer(0);
+        JdwpPacket packet = new JdwpPacket(rawBuf);
+        ByteBuffer buf = getChunkDataBuf(rawBuf);
+
+        // no data
+
+        finishChunkPacket(packet, CHUNK_SPSE, buf.position());
+        Log.d("ddm-prof", "Sending " + name(CHUNK_SPSE));
+        client.send(packet, mInst);
+    }
+
+    /** Handle incoming profiling data. The MPSE packet includes the complete .trace file. */
+    private void handleMPSE(ClientImpl client, ByteBuffer data) {
+        IMethodProfilingHandler handler = ClientData.getMethodProfilingHandler();
+        if (handler != null) {
+            byte[] stuff = new byte[data.capacity()];
+            data.get(stuff, 0, stuff.length);
+
+            Log.d("ddm-prof", "got trace file, size: " + stuff.length + " bytes");
+
+            handler.onSuccess(stuff, client);
+        }
+
+        client.getClientData().setMethodProfilingStatus(MethodProfilingStatus.OFF);
+        client.update(ClientImpl.CHANGE_METHOD_PROFILING_STATUS);
+    }
+
+    /** Send a MPRQ (Method PRofiling Query) request to the client. */
+    public static void sendMPRQ(ClientImpl client) throws IOException {
+        ByteBuffer rawBuf = allocBuffer(0);
+        JdwpPacket packet = new JdwpPacket(rawBuf);
+        ByteBuffer buf = getChunkDataBuf(rawBuf);
+
+        // no data
+
+        finishChunkPacket(packet, CHUNK_MPRQ, buf.position());
+        Log.d("ddm-prof", "Sending " + name(CHUNK_MPRQ));
+        client.send(packet, mInst);
+    }
+
+    /** Receive response to query. */
+    private void handleMPRQ(ClientImpl client, ByteBuffer data) {
+        byte result;
+
+        result = data.get();
+
+        if (result == 0) {
+            client.getClientData().setMethodProfilingStatus(MethodProfilingStatus.OFF);
+            Log.d("ddm-prof", "Method profiling is not running");
+        } else if (result == 1) {
+            client.getClientData().setMethodProfilingStatus(MethodProfilingStatus.TRACER_ON);
+            Log.d("ddm-prof", "Method tracing is active");
+        } else if (result == 2) {
+            client.getClientData().setMethodProfilingStatus(MethodProfilingStatus.SAMPLER_ON);
+            Log.d("ddm-prof", "Sampler based profiling is active");
+        }
+        client.update(ClientImpl.CHANGE_METHOD_PROFILING_STATUS);
+    }
+
+    private void handleFAIL(ClientImpl client, ByteBuffer data) {
+        /*int errorCode =*/ data.getInt();
+        int length = data.getInt() * 2;
+        String message = null;
+        if (length > 0) {
+            byte[] messageBuffer = new byte[length];
+            data.get(messageBuffer, 0, length);
+            message = new String(messageBuffer);
+        }
+
+        // this can be sent if
+        // - MPRS failed (like wrong permission)
+        // - MPSE failed for whatever reason
+
+        String filename = client.getClientData().getPendingMethodProfiling();
+        if (filename != null) {
+            // reset the pending file.
+            client.getClientData().setPendingMethodProfiling(null);
+
+            // and notify of failure
+            IMethodProfilingHandler handler = ClientData.getMethodProfilingHandler();
+            if (handler != null) {
+                handler.onStartFailure(client, message);
+            }
+        } else {
+            // this is MPRE
+            // notify of failure
+            IMethodProfilingHandler handler = ClientData.getMethodProfilingHandler();
+            if (handler != null) {
+                handler.onEndFailure(client, message);
+            }
+        }
+
+        // send a query to know the current status
+        try {
+            sendMPRQ(client);
+        } catch (IOException e) {
+            Log.e("HandleProfiling", e);
+        }
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/HandleTest.java b/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/HandleTest.java
new file mode 100644
index 000000000..ef4f7efd2
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/HandleTest.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.server.jdwp.chunkhandler;
+
+import com.android.tradefed.device.server.ClientImpl;
+import com.android.tradefed.device.server.MonitorThread;
+import com.android.tradefed.log.Log;
+
+import java.nio.ByteBuffer;
+
+/** Handle thread status updates. */
+public final class HandleTest extends ChunkHandler {
+
+    public static final int CHUNK_TEST = type("TEST");
+
+    private static final HandleTest mInst = new HandleTest();
+
+    private HandleTest() {}
+
+    /** Register for the packets we expect to get from the client. */
+    public static void register(MonitorThread mt) {
+        mt.registerChunkHandler(CHUNK_TEST, mInst);
+    }
+
+    /** Client is ready. */
+    @Override
+    public void clientReady(ClientImpl client) {}
+
+    /** Client went away. */
+    @Override
+    public void clientDisconnected(ClientImpl client) {}
+
+    /** Chunk handler entry point. */
+    @Override
+    public void handleChunk(
+            ClientImpl client, int type, ByteBuffer data, boolean isReply, int msgId) {
+
+        Log.d("ddm-test", "handling " + ChunkHandler.name(type));
+
+        if (type == CHUNK_TEST) {
+            handleTEST(client, data);
+        } else {
+            handleUnknownChunk(client, type, data, isReply, msgId);
+        }
+    }
+
+    /*
+     * Handle a thread creation message.
+     */
+    private static void handleTEST(ClientImpl client, ByteBuffer data) {
+        /*
+         * Can't call data.array() on a read-only ByteBuffer, so we make
+         * a copy.
+         */
+        byte[] copy = new byte[data.limit()];
+        data.get(copy);
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/HandleThread.java b/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/HandleThread.java
new file mode 100644
index 000000000..f70f44792
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/HandleThread.java
@@ -0,0 +1,381 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.server.jdwp.chunkhandler;
+
+import com.android.ddmlib.ByteBufferUtil;
+import com.android.tradefed.device.server.ClientData;
+import com.android.tradefed.device.server.ClientImpl;
+import com.android.tradefed.device.server.MonitorThread;
+import com.android.tradefed.device.server.ThreadInfo;
+import com.android.tradefed.log.Log;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+/** Handle thread status updates. */
+public final class HandleThread extends ChunkHandler {
+
+    public static final int CHUNK_THEN = type("THEN");
+    public static final int CHUNK_THCR = type("THCR");
+    public static final int CHUNK_THDE = type("THDE");
+    public static final int CHUNK_THST = type("THST");
+    public static final int CHUNK_THNM = type("THNM");
+    public static final int CHUNK_STKL = type("STKL");
+
+    private static final HandleThread mInst = new HandleThread();
+
+    // only read/written by requestThreadUpdates()
+    private static volatile boolean sThreadStatusReqRunning = false;
+    private static volatile boolean sThreadStackTraceReqRunning = false;
+
+    private HandleThread() {}
+
+    /** Register for the packets we expect to get from the client. */
+    public static void register(MonitorThread mt) {
+        mt.registerChunkHandler(CHUNK_THCR, mInst);
+        mt.registerChunkHandler(CHUNK_THDE, mInst);
+        mt.registerChunkHandler(CHUNK_THST, mInst);
+        mt.registerChunkHandler(CHUNK_THNM, mInst);
+        mt.registerChunkHandler(CHUNK_STKL, mInst);
+    }
+
+    /** Client is ready. */
+    @Override
+    public void clientReady(ClientImpl client) throws IOException {
+        Log.d("ddm-thread", "Now ready: " + client);
+        if (client.isThreadUpdateEnabled()) {
+            sendTHEN(client, true);
+        }
+    }
+
+    /** Client went away. */
+    @Override
+    public void clientDisconnected(ClientImpl client) {}
+
+    /** Chunk handler entry point. */
+    @Override
+    public void handleChunk(
+            ClientImpl client, int type, ByteBuffer data, boolean isReply, int msgId) {
+
+        Log.d("ddm-thread", "handling " + ChunkHandler.name(type));
+
+        if (type == CHUNK_THCR) {
+            handleTHCR(client, data);
+        } else if (type == CHUNK_THDE) {
+            handleTHDE(client, data);
+        } else if (type == CHUNK_THST) {
+            handleTHST(client, data);
+        } else if (type == CHUNK_THNM) {
+            handleTHNM(client, data);
+        } else if (type == CHUNK_STKL) {
+            handleSTKL(client, data);
+        } else {
+            handleUnknownChunk(client, type, data, isReply, msgId);
+        }
+    }
+
+    /*
+     * Handle a thread creation message.
+     *
+     * We should be tolerant of receiving a duplicate create message.  (It
+     * shouldn't happen with the current implementation.)
+     */
+    private void handleTHCR(ClientImpl client, ByteBuffer data) {
+        int threadId, nameLen;
+        String name;
+
+        threadId = data.getInt();
+        nameLen = data.getInt();
+        name = ByteBufferUtil.getString(data, nameLen);
+
+        Log.v("ddm-thread", "THCR: " + threadId + " '" + name + "'");
+
+        client.getClientData().addThread(threadId, name);
+        client.update(ClientImpl.CHANGE_THREAD_DATA);
+    }
+
+    /*
+     * Handle a thread death message.
+     */
+    private void handleTHDE(ClientImpl client, ByteBuffer data) {
+        int threadId;
+
+        threadId = data.getInt();
+        Log.v("ddm-thread", "THDE: " + threadId);
+
+        client.getClientData().removeThread(threadId);
+        client.update(ClientImpl.CHANGE_THREAD_DATA);
+    }
+
+    /*
+     * Handle a thread status update message.
+     *
+     * Response has:
+     *  (1b) header len
+     *  (1b) bytes per entry
+     *  (2b) thread count
+     * Then, for each thread:
+     *  (4b) threadId (matches value from THCR)
+     *  (1b) thread status
+     *  (4b) tid
+     *  (4b) utime
+     *  (4b) stime
+     */
+    private void handleTHST(ClientImpl client, ByteBuffer data) {
+        int headerLen, bytesPerEntry, extraPerEntry;
+        int threadCount;
+
+        headerLen = (data.get() & 0xff);
+        bytesPerEntry = (data.get() & 0xff);
+        threadCount = data.getShort();
+
+        headerLen -= 4; // we've read 4 bytes
+        while (headerLen-- > 0) {
+            data.get();
+        }
+
+        extraPerEntry = bytesPerEntry - 18; // we want 18 bytes
+
+        Log.v("ddm-thread", "THST: threadCount=" + threadCount);
+
+        /*
+         * For each thread, extract the data, find the appropriate
+         * client, and add it to the ClientData.
+         */
+        for (int i = 0; i < threadCount; i++) {
+            int threadId, status, tid, utime, stime;
+            boolean isDaemon = false;
+
+            threadId = data.getInt();
+            status = data.get();
+            tid = data.getInt();
+            utime = data.getInt();
+            stime = data.getInt();
+            if (bytesPerEntry >= 18) isDaemon = (data.get() != 0);
+
+            Log.v(
+                    "ddm-thread",
+                    "  id="
+                            + threadId
+                            + ", status="
+                            + status
+                            + ", tid="
+                            + tid
+                            + ", utime="
+                            + utime
+                            + ", stime="
+                            + stime);
+
+            ClientData cd = client.getClientData();
+            ThreadInfo threadInfo = cd.getThread(threadId);
+            if (threadInfo != null) threadInfo.updateThread(status, tid, utime, stime, isDaemon);
+            else Log.d("ddms", "Thread with id=" + threadId + " not found");
+
+            // slurp up any extra
+            for (int slurp = extraPerEntry; slurp > 0; slurp--) data.get();
+        }
+
+        client.update(ClientImpl.CHANGE_THREAD_DATA);
+    }
+
+    /*
+     * Handle a THNM (THread NaMe) message.  We get one of these after
+     * somebody calls Thread.setName() on a running thread.
+     */
+    private void handleTHNM(ClientImpl client, ByteBuffer data) {
+        int threadId, nameLen;
+        String name;
+
+        threadId = data.getInt();
+        nameLen = data.getInt();
+        name = ByteBufferUtil.getString(data, nameLen);
+
+        Log.v("ddm-thread", "THNM: " + threadId + " '" + name + "'");
+
+        ThreadInfo threadInfo = client.getClientData().getThread(threadId);
+        if (threadInfo != null) {
+            threadInfo.setThreadName(name);
+            client.update(ClientImpl.CHANGE_THREAD_DATA);
+        } else {
+            Log.d("ddms", "Thread with id=" + threadId + " not found");
+        }
+    }
+
+    /** Parse an incoming STKL. */
+    private void handleSTKL(ClientImpl client, ByteBuffer data) {
+        StackTraceElement[] trace;
+        int i, threadId, stackDepth;
+        @SuppressWarnings("unused")
+        int future;
+
+        future = data.getInt();
+        threadId = data.getInt();
+
+        Log.v("ddms", "STKL: " + threadId);
+
+        /* un-serialize the StackTraceElement[] */
+        stackDepth = data.getInt();
+        trace = new StackTraceElement[stackDepth];
+        for (i = 0; i < stackDepth; i++) {
+            String className, methodName, fileName;
+            int len, lineNumber;
+
+            len = data.getInt();
+            className = ByteBufferUtil.getString(data, len);
+            len = data.getInt();
+            methodName = ByteBufferUtil.getString(data, len);
+            len = data.getInt();
+            if (len == 0) {
+                fileName = null;
+            } else {
+                fileName = ByteBufferUtil.getString(data, len);
+            }
+            lineNumber = data.getInt();
+
+            trace[i] = new StackTraceElement(className, methodName, fileName, lineNumber);
+        }
+
+        ThreadInfo threadInfo = client.getClientData().getThread(threadId);
+        if (threadInfo != null) {
+            threadInfo.setStackCall(trace);
+            client.update(ClientImpl.CHANGE_THREAD_STACKTRACE);
+        } else {
+            Log.d(
+                    "STKL",
+                    String.format(
+                            "Got stackcall for thread %1$d, which does not exist"
+                                    + " (anymore?).", //$NON-NLS-1$
+                            threadId));
+        }
+    }
+
+    /** Send a THEN (THread notification ENable) request to the client. */
+    public static void sendTHEN(ClientImpl client, boolean enable) throws IOException {
+
+        ByteBuffer rawBuf = allocBuffer(1);
+        JdwpPacket packet = new JdwpPacket(rawBuf);
+        ByteBuffer buf = getChunkDataBuf(rawBuf);
+
+        if (enable) {
+            buf.put((byte) 1);
+        } else {
+            buf.put((byte) 0);
+        }
+
+        finishChunkPacket(packet, CHUNK_THEN, buf.position());
+        Log.d("ddm-thread", "Sending " + name(CHUNK_THEN) + ": " + enable);
+        client.send(packet, mInst);
+    }
+
+    /**
+     * Send a STKL (STacK List) request to the client. The VM will suspend the target thread, obtain
+     * its stack, and return it. If the thread is no longer running, a failure result will be
+     * returned.
+     */
+    public static void sendSTKL(ClientImpl client, int threadId) throws IOException {
+
+        if (false) {
+            Log.d("ddm-thread", "would send STKL " + threadId);
+            return;
+        }
+
+        ByteBuffer rawBuf = allocBuffer(4);
+        JdwpPacket packet = new JdwpPacket(rawBuf);
+        ByteBuffer buf = getChunkDataBuf(rawBuf);
+
+        buf.putInt(threadId);
+
+        finishChunkPacket(packet, CHUNK_STKL, buf.position());
+        Log.d("ddm-thread", "Sending " + name(CHUNK_STKL) + ": " + threadId);
+        client.send(packet, mInst);
+    }
+
+    /**
+     * This is called periodically from the UI thread. To avoid locking the UI while we request the
+     * updates, we create a new thread.
+     */
+    public static void requestThreadUpdate(final ClientImpl client) {
+        if (client.isDdmAware() && client.isThreadUpdateEnabled()) {
+            if (sThreadStatusReqRunning) {
+                Log.w("ddms", "Waiting for previous thread update req to finish");
+                return;
+            }
+
+            new Thread("Thread Status Req") {
+                @Override
+                public void run() {
+                    sThreadStatusReqRunning = true;
+                    try {
+                        sendTHST(client);
+                    } catch (IOException ioe) {
+                        Log.d(
+                                "ddms",
+                                "Unable to request thread updates from "
+                                        + client
+                                        + ": "
+                                        + ioe.getMessage());
+                    } finally {
+                        sThreadStatusReqRunning = false;
+                    }
+                }
+            }.start();
+        }
+    }
+
+    public static void requestThreadStackCallRefresh(final ClientImpl client, final int threadId) {
+        if (client.isDdmAware() && client.isThreadUpdateEnabled()) {
+            if (sThreadStackTraceReqRunning) {
+                Log.w("ddms", "Waiting for previous thread stack call req to finish");
+                return;
+            }
+
+            new Thread("Thread Status Req") {
+                @Override
+                public void run() {
+                    sThreadStackTraceReqRunning = true;
+                    try {
+                        sendSTKL(client, threadId);
+                    } catch (IOException ioe) {
+                        Log.d(
+                                "ddms",
+                                "Unable to request thread stack call updates from "
+                                        + client
+                                        + ": "
+                                        + ioe.getMessage());
+                    } finally {
+                        sThreadStackTraceReqRunning = false;
+                    }
+                }
+            }.start();
+        }
+    }
+
+    /*
+     * Send a THST request to the specified client.
+     */
+    private static void sendTHST(ClientImpl client) throws IOException {
+        ByteBuffer rawBuf = allocBuffer(0);
+        JdwpPacket packet = new JdwpPacket(rawBuf);
+        ByteBuffer buf = getChunkDataBuf(rawBuf);
+
+        // nothing much to say
+
+        finishChunkPacket(packet, CHUNK_THST, buf.position());
+        Log.d("ddm-thread", "Sending " + name(CHUNK_THST));
+        client.send(packet, mInst);
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/HandleViewDebug.java b/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/HandleViewDebug.java
new file mode 100644
index 000000000..9cedd83f0
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/HandleViewDebug.java
@@ -0,0 +1,356 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.server.jdwp.chunkhandler;
+
+import com.android.annotations.NonNull;
+import com.android.annotations.Nullable;
+import com.android.ddmlib.ByteBufferUtil;
+import com.android.tradefed.device.server.Client;
+import com.android.tradefed.device.server.ClientImpl;
+import com.android.tradefed.device.server.DebugViewDumpHandler;
+import com.android.tradefed.device.server.MonitorThread;
+import com.android.tradefed.log.Log;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+public final class HandleViewDebug extends ChunkHandler {
+    /** Dump view hierarchy. */
+    private static final int VURT_DUMP_HIERARCHY = 1;
+
+    /** Capture View Layers. */
+    private static final int VURT_CAPTURE_LAYERS = 2;
+
+    /** Dump View Theme. */
+    private static final int VURT_DUMP_THEME = 3;
+
+    /** Capture View. */
+    private static final int VUOP_CAPTURE_VIEW = 1;
+
+    /** Obtain the Display List corresponding to the view. */
+    private static final int VUOP_DUMP_DISPLAYLIST = 2;
+
+    /** Profile a view. */
+    private static final int VUOP_PROFILE_VIEW = 3;
+
+    /** Invoke a method on the view. */
+    private static final int VUOP_INVOKE_VIEW_METHOD = 4;
+
+    /** Set layout parameter. */
+    private static final int VUOP_SET_LAYOUT_PARAMETER = 5;
+
+    private static final String TAG = "ddmlib"; // $NON-NLS-1$
+
+    private static final HandleViewDebug sInstance = new HandleViewDebug();
+
+    private static final DebugViewDumpHandler sViewOpNullChunkHandler =
+            new NullChunkHandler(DebugViewDumpHandler.CHUNK_VUOP);
+
+    private HandleViewDebug() {}
+
+    public static void register(MonitorThread mt) {
+        // TODO: add chunk type for auto window updates
+        // and register here
+        mt.registerChunkHandler(DebugViewDumpHandler.CHUNK_VUGL, sInstance);
+        mt.registerChunkHandler(DebugViewDumpHandler.CHUNK_VULW, sInstance);
+        mt.registerChunkHandler(DebugViewDumpHandler.CHUNK_VUOP, sInstance);
+        mt.registerChunkHandler(DebugViewDumpHandler.CHUNK_VURT, sInstance);
+    }
+
+    @Override
+    public void clientReady(ClientImpl client) throws IOException {}
+
+    @Override
+    public void clientDisconnected(ClientImpl client) {}
+
+    public static void listViewRoots(Client client, DebugViewDumpHandler replyHandler)
+            throws IOException {
+        ByteBuffer buf = allocBuffer(8);
+        JdwpPacket packet = new JdwpPacket(buf);
+        ByteBuffer chunkBuf = getChunkDataBuf(buf);
+        chunkBuf.putInt(1);
+        finishChunkPacket(packet, DebugViewDumpHandler.CHUNK_VULW, chunkBuf.position());
+        ((ClientImpl) client).send(packet, replyHandler);
+    }
+
+    public static void dumpViewHierarchy(
+            @NonNull Client client,
+            @NonNull String viewRoot,
+            boolean skipChildren,
+            boolean includeProperties,
+            boolean useV2,
+            @NonNull DebugViewDumpHandler handler)
+            throws IOException {
+        ByteBuffer buf =
+                allocBuffer(
+                        4 // opcode
+                                + 4 // view root length
+                                + viewRoot.length() * 2 // view root
+                                + 4 // skip children
+                                + 4 // include view properties
+                                + 4); // use Version 2
+        JdwpPacket packet = new JdwpPacket(buf);
+        ByteBuffer chunkBuf = getChunkDataBuf(buf);
+
+        chunkBuf.putInt(VURT_DUMP_HIERARCHY);
+        chunkBuf.putInt(viewRoot.length());
+        ByteBufferUtil.putString(chunkBuf, viewRoot);
+        chunkBuf.putInt(skipChildren ? 1 : 0);
+        chunkBuf.putInt(includeProperties ? 1 : 0);
+        chunkBuf.putInt(useV2 ? 1 : 0);
+
+        finishChunkPacket(packet, DebugViewDumpHandler.CHUNK_VURT, chunkBuf.position());
+        ((ClientImpl) client).send(packet, handler);
+    }
+
+    public static void captureLayers(
+            @NonNull ClientImpl client,
+            @NonNull String viewRoot,
+            @NonNull DebugViewDumpHandler handler)
+            throws IOException {
+        int bufLen = 8 + viewRoot.length() * 2;
+
+        ByteBuffer buf = allocBuffer(bufLen);
+        JdwpPacket packet = new JdwpPacket(buf);
+        ByteBuffer chunkBuf = getChunkDataBuf(buf);
+
+        chunkBuf.putInt(VURT_CAPTURE_LAYERS);
+        chunkBuf.putInt(viewRoot.length());
+        ByteBufferUtil.putString(chunkBuf, viewRoot);
+
+        finishChunkPacket(packet, DebugViewDumpHandler.CHUNK_VURT, chunkBuf.position());
+        client.send(packet, handler);
+    }
+
+    private static void sendViewOpPacket(
+            @NonNull Client client,
+            int op,
+            @NonNull String viewRoot,
+            @NonNull String view,
+            @Nullable byte[] extra,
+            @Nullable DebugViewDumpHandler handler)
+            throws IOException {
+        int bufLen =
+                4
+                        + // opcode
+                        4
+                        + viewRoot.length() * 2
+                        + // view root strlen + view root
+                        4
+                        + view.length() * 2; // view strlen + view
+
+        if (extra != null) {
+            bufLen += extra.length;
+        }
+
+        ByteBuffer buf = allocBuffer(bufLen);
+        JdwpPacket packet = new JdwpPacket(buf);
+        ByteBuffer chunkBuf = getChunkDataBuf(buf);
+
+        chunkBuf.putInt(op);
+        chunkBuf.putInt(viewRoot.length());
+        ByteBufferUtil.putString(chunkBuf, viewRoot);
+
+        chunkBuf.putInt(view.length());
+        ByteBufferUtil.putString(chunkBuf, view);
+
+        if (extra != null) {
+            chunkBuf.put(extra);
+        }
+
+        finishChunkPacket(packet, DebugViewDumpHandler.CHUNK_VUOP, chunkBuf.position());
+        ((ClientImpl) client).send(packet, handler);
+    }
+
+    public static void profileView(
+            @NonNull ClientImpl client,
+            @NonNull String viewRoot,
+            @NonNull String view,
+            @NonNull DebugViewDumpHandler handler)
+            throws IOException {
+        sendViewOpPacket(client, VUOP_PROFILE_VIEW, viewRoot, view, null, handler);
+    }
+
+    public static void captureView(
+            @NonNull Client client,
+            @NonNull String viewRoot,
+            @NonNull String view,
+            @NonNull DebugViewDumpHandler handler)
+            throws IOException {
+        sendViewOpPacket(client, VUOP_CAPTURE_VIEW, viewRoot, view, null, handler);
+    }
+
+    public static void invalidateView(
+            @NonNull ClientImpl client, @NonNull String viewRoot, @NonNull String view)
+            throws IOException {
+        invokeMethod(client, viewRoot, view, "invalidate");
+    }
+
+    public static void requestLayout(
+            @NonNull ClientImpl client, @NonNull String viewRoot, @NonNull String view)
+            throws IOException {
+        invokeMethod(client, viewRoot, view, "requestLayout");
+    }
+
+    public static void dumpDisplayList(
+            @NonNull Client client, @NonNull String viewRoot, @NonNull String view)
+            throws IOException {
+        sendViewOpPacket(
+                client, VUOP_DUMP_DISPLAYLIST, viewRoot, view, null, sViewOpNullChunkHandler);
+    }
+
+    public static void dumpTheme(
+            @NonNull ClientImpl client,
+            @NonNull String viewRoot,
+            @NonNull DebugViewDumpHandler handler)
+            throws IOException {
+        ByteBuffer buf =
+                allocBuffer(
+                        4 // opcode
+                                + 4 // view root length
+                                + viewRoot.length() * 2); // view root
+        JdwpPacket packet = new JdwpPacket(buf);
+        ByteBuffer chunkBuf = getChunkDataBuf(buf);
+
+        chunkBuf.putInt(VURT_DUMP_THEME);
+        chunkBuf.putInt(viewRoot.length());
+        ByteBufferUtil.putString(chunkBuf, viewRoot);
+
+        finishChunkPacket(packet, DebugViewDumpHandler.CHUNK_VURT, chunkBuf.position());
+        client.send(packet, handler);
+    }
+
+    /** A {@link ViewDumpHandler} to use when no response is expected. */
+    private static class NullChunkHandler extends DebugViewDumpHandler {
+        public NullChunkHandler(int chunkType) {
+            super(chunkType);
+        }
+
+        @Override
+        protected void handleViewDebugResult(ByteBuffer data) {}
+    }
+
+    public static void invokeMethod(
+            @NonNull ClientImpl client,
+            @NonNull String viewRoot,
+            @NonNull String view,
+            @NonNull String method,
+            Object... args)
+            throws IOException {
+        int len = 4 + method.length() * 2;
+        if (args != null) {
+            // # of args
+            len += 4;
+
+            // for each argument, we send a char type specifier (2 bytes) and
+            // the arg value (max primitive size = sizeof(double) = 8
+            len += 10 * args.length;
+        }
+
+        byte[] extra = new byte[len];
+        ByteBuffer b = ByteBuffer.wrap(extra);
+
+        b.putInt(method.length());
+        ByteBufferUtil.putString(b, method);
+
+        if (args != null) {
+            b.putInt(args.length);
+
+            for (int i = 0; i < args.length; i++) {
+                Object arg = args[i];
+                if (arg instanceof Boolean) {
+                    b.putChar('Z');
+                    b.put((byte) ((Boolean) arg ? 1 : 0));
+                } else if (arg instanceof Byte) {
+                    b.putChar('B');
+                    b.put((Byte) arg);
+                } else if (arg instanceof Character) {
+                    b.putChar('C');
+                    b.putChar((Character) arg);
+                } else if (arg instanceof Short) {
+                    b.putChar('S');
+                    b.putShort((Short) arg);
+                } else if (arg instanceof Integer) {
+                    b.putChar('I');
+                    b.putInt((Integer) arg);
+                } else if (arg instanceof Long) {
+                    b.putChar('J');
+                    b.putLong((Long) arg);
+                } else if (arg instanceof Float) {
+                    b.putChar('F');
+                    b.putFloat((Float) arg);
+                } else if (arg instanceof Double) {
+                    b.putChar('D');
+                    b.putDouble((Double) arg);
+                } else {
+                    Log.e(
+                            TAG,
+                            "View method invocation only supports primitive arguments, supplied: "
+                                    + arg);
+                    return;
+                }
+            }
+        }
+
+        sendViewOpPacket(
+                client, VUOP_INVOKE_VIEW_METHOD, viewRoot, view, extra, sViewOpNullChunkHandler);
+    }
+
+    public static void setLayoutParameter(
+            @NonNull ClientImpl client,
+            @NonNull String viewRoot,
+            @NonNull String view,
+            @NonNull String parameter,
+            int value)
+            throws IOException {
+        int len = 4 + parameter.length() * 2 + 4;
+        byte[] extra = new byte[len];
+        ByteBuffer b = ByteBuffer.wrap(extra);
+
+        b.putInt(parameter.length());
+        ByteBufferUtil.putString(b, parameter);
+        b.putInt(value);
+        sendViewOpPacket(
+                client, VUOP_SET_LAYOUT_PARAMETER, viewRoot, view, extra, sViewOpNullChunkHandler);
+    }
+
+    @Override
+    public void handleChunk(
+            ClientImpl client, int type, ByteBuffer data, boolean isReply, int msgId) {}
+
+    public static void sendStartGlTracing(ClientImpl client) throws IOException {
+        ByteBuffer buf = allocBuffer(4);
+        JdwpPacket packet = new JdwpPacket(buf);
+
+        ByteBuffer chunkBuf = getChunkDataBuf(buf);
+        chunkBuf.putInt(1);
+        finishChunkPacket(packet, DebugViewDumpHandler.CHUNK_VUGL, chunkBuf.position());
+
+        client.send(packet, null);
+    }
+
+    public static void sendStopGlTracing(ClientImpl client) throws IOException {
+        ByteBuffer buf = allocBuffer(4);
+        JdwpPacket packet = new JdwpPacket(buf);
+
+        ByteBuffer chunkBuf = getChunkDataBuf(buf);
+        chunkBuf.putInt(0);
+        finishChunkPacket(packet, DebugViewDumpHandler.CHUNK_VUGL, chunkBuf.position());
+
+        client.send(packet, null);
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/HandleWait.java b/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/HandleWait.java
new file mode 100644
index 000000000..8e4bfe978
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/HandleWait.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.server.jdwp.chunkhandler;
+
+import com.android.tradefed.device.server.ClientData;
+import com.android.tradefed.device.server.ClientData.DebuggerStatus;
+import com.android.tradefed.device.server.ClientImpl;
+import com.android.tradefed.device.server.MonitorThread;
+import com.android.tradefed.log.Log;
+
+import java.nio.ByteBuffer;
+
+/**
+ * Handle the "wait" chunk (WAIT). These are sent up when the client is waiting for something, e.g.
+ * for a debugger to attach.
+ */
+public final class HandleWait extends ChunkHandler {
+
+    public static final int CHUNK_WAIT = ChunkHandler.type("WAIT");
+
+    private static final HandleWait mInst = new HandleWait();
+
+    private HandleWait() {}
+
+    /** Register for the packets we expect to get from the client. */
+    public static void register(MonitorThread mt) {
+        mt.registerChunkHandler(CHUNK_WAIT, mInst);
+    }
+
+    /** Client is ready. */
+    @Override
+    public void clientReady(ClientImpl client) {}
+
+    /** Client went away. */
+    @Override
+    public void clientDisconnected(ClientImpl client) {}
+
+    /** Chunk handler entry point. */
+    @Override
+    public void handleChunk(
+            ClientImpl client, int type, ByteBuffer data, boolean isReply, int msgId) {
+
+        Log.d("ddm-wait", "handling " + ChunkHandler.name(type));
+
+        if (type == CHUNK_WAIT) {
+            assert !isReply;
+            handleWAIT(client, data);
+        } else {
+            handleUnknownChunk(client, type, data, isReply, msgId);
+        }
+    }
+
+    /*
+     * Handle a reply to our WAIT message.
+     */
+    private static void handleWAIT(ClientImpl client, ByteBuffer data) {
+        byte reason;
+
+        reason = data.get();
+
+        Log.d("ddm-wait", "WAIT: reason=" + reason);
+
+        ClientData cd = client.getClientData();
+        synchronized (cd) {
+            cd.setDebuggerConnectionStatus(DebuggerStatus.WAITING);
+        }
+
+        client.update(ClientImpl.CHANGE_DEBUGGER_STATUS);
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/JdwpPacket.java b/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/JdwpPacket.java
new file mode 100644
index 000000000..eacc29eeb
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/jdwp/chunkhandler/JdwpPacket.java
@@ -0,0 +1,350 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.server.jdwp.chunkhandler;
+
+import com.android.annotations.NonNull;
+import com.android.tradefed.device.server.jdwp.JdwpCommands;
+import com.android.tradefed.log.Log;
+
+import com.google.common.annotations.VisibleForTesting;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.channels.SocketChannel;
+
+/**
+ * A JDWP packet, sitting at the start of a ByteBuffer somewhere.
+ *
+ * <p>This allows us to wrap a "pointer" to the data with the results of decoding the packet.
+ *
+ * <p>None of the operations here are synchronized. If multiple threads will be accessing the same
+ * ByteBuffers, external sync will be required.
+ *
+ * <p>Use the constructor to create an empty packet, or "findPacket()" to wrap a JdwpPacket around
+ * existing data.
+ */
+public final class JdwpPacket {
+    public static final int JDWP_HEADER_LEN = 11;
+
+    private static final int REPLY_PACKET = 0x80;
+
+    @NonNull private final ByteBuffer mBuffer;
+    private int mLength;
+    private int mId;
+    private int mFlags;
+    private int mCmdSet;
+    private int mCmd;
+    private int mErrCode;
+
+    private static int sSerialId = 0x40000000;
+
+    /** Create a new, empty packet, in "buf". */
+    @VisibleForTesting
+    public JdwpPacket(@NonNull ByteBuffer buf) {
+        mBuffer = buf;
+    }
+
+    /**
+     * Finish a packet created with newPacket().
+     *
+     * <p>This always creates a command packet, with the next serial number in sequence.
+     *
+     * <p>We have to take "payloadLength" as an argument because we can't see the position in the
+     * "slice" returned by getPayload(). We could fish it out of the chunk header, but it's legal
+     * for there to be more than one chunk in a JDWP packet.
+     *
+     * <p>On exit, "position" points to the end of the data.
+     */
+    @VisibleForTesting
+    public void finishPacket(int cmdSet, int cmd, int payloadLength) {
+
+        ByteOrder oldOrder = mBuffer.order();
+        mBuffer.order(ChunkHandler.CHUNK_ORDER);
+
+        mLength = JDWP_HEADER_LEN + payloadLength;
+        mId = getNextSerial();
+        mFlags = 0;
+        mCmdSet = cmdSet;
+        mCmd = cmd;
+
+        mBuffer.putInt(0x00, mLength);
+        mBuffer.putInt(0x04, mId);
+        mBuffer.put(0x08, (byte) mFlags);
+        mBuffer.put(0x09, (byte) mCmdSet);
+        mBuffer.put(0x0a, (byte) mCmd);
+
+        mBuffer.order(oldOrder);
+        mBuffer.position(mLength);
+    }
+
+    /**
+     * Get the next serial number. This creates a unique serial number across all connections, not
+     * just for the current connection. This is a useful property when debugging, but isn't
+     * necessary.
+     *
+     * <p>We can't synchronize on an int, so we use a sync method.
+     */
+    private static synchronized int getNextSerial() {
+        return sSerialId++;
+    }
+
+    /**
+     * Return a slice of the byte buffer, positioned past the JDWP header to the start of the chunk
+     * header. The buffer's limit will be set to the size of the payload if the size is known; if
+     * this is a packet under construction the limit will be set to the end of the buffer.
+     *
+     * <p>Doesn't examine the packet at all -- works on empty buffers.
+     */
+    public ByteBuffer getPayload() {
+        ByteBuffer buf;
+        int oldPosn = mBuffer.position();
+
+        mBuffer.position(JDWP_HEADER_LEN);
+        buf = mBuffer.slice(); // goes from position to limit
+        mBuffer.position(oldPosn);
+
+        if (mLength > 0) buf.limit(mLength - JDWP_HEADER_LEN);
+        buf.order(ChunkHandler.CHUNK_ORDER);
+        return buf;
+    }
+
+    /** Returns "true" if this JDWP packet is tagged as a reply. */
+    public boolean isReply() {
+        return (mFlags & REPLY_PACKET) != 0;
+    }
+
+    /** Returns "true" if this JDWP packet is a reply with a nonzero error code. */
+    public boolean isError() {
+        return isReply() && mErrCode != 0;
+    }
+
+    /** Returns "true" if this JDWP packet has no data. */
+    public boolean isEmpty() {
+        return (mLength == JDWP_HEADER_LEN);
+    }
+
+    /**
+     * Return the packet's ID. For a reply packet, this allows us to match the reply with the
+     * original request.
+     */
+    public int getId() {
+        return mId;
+    }
+
+    /**
+     * Return the length of a packet. This includes the header, so an empty packet is 11 bytes long.
+     */
+    public int getLength() {
+        return mLength;
+    }
+
+    /**
+     * Write our packet to "chan".
+     *
+     * <p>The JDWP packet starts at offset 0 and ends at mBuffer.position().
+     */
+    public void write(SocketChannel chan) throws IOException {
+        assert mLength > 0;
+
+        int oldPosn = mBuffer.position();
+        mBuffer.position(0);
+        mBuffer.limit(mLength);
+
+        while (mBuffer.position() != mBuffer.limit()) {
+            chan.write(mBuffer);
+        }
+        // position should now be at end of packet
+        assert mBuffer.position() == mLength;
+
+        mBuffer.limit(mBuffer.capacity());
+        mBuffer.position(oldPosn);
+    }
+
+    /**
+     * "Move" the packet data out of the buffer we're sitting on and into buf at the current
+     * position.
+     */
+    public void move(ByteBuffer buf) {
+        int oldPosn = mBuffer.position();
+
+        mBuffer.position(0);
+        mBuffer.limit(mLength);
+        buf.put(mBuffer);
+
+        mBuffer.limit(mBuffer.capacity());
+        mBuffer.position(oldPosn);
+    }
+
+    /** Helper function to copy the packet into a new buffer. */
+    public void copy(ByteBuffer into) {
+        into.put(mBuffer.array(), 0, mLength);
+    }
+
+    /** Replace the payload of the package with a buffer. The current position is unchanged. */
+    public void setPayload(ByteBuffer buf) {
+        if (mLength - JDWP_HEADER_LEN != buf.remaining()) {
+            throw new UnsupportedOperationException("Changing payload size not supported");
+        }
+
+        int oldPosn = mBuffer.position();
+
+        mBuffer.position(JDWP_HEADER_LEN);
+        mBuffer.put(buf);
+        mBuffer.position(oldPosn);
+    }
+
+    /**
+     * Consume the JDWP packet.
+     *
+     * <p>On entry and exit, "position" is at the end of data in buffer.
+     */
+    public void consume() {
+        /*
+         * The "flip" call sets "limit" equal to the position (usually the
+         * end of data) and "position" equal to zero.
+         *
+         * compact() copies everything from "position" and "limit" to the
+         * start of the buffer, sets "position" to the end of data, and
+         * sets "limit" to the capacity.
+         *
+         * On entry, "position" is set to the amount of data in the buffer
+         * and "limit" is set to the capacity.  We want to call flip()
+         * so that position..limit spans our data, advance "position" past
+         * the current packet, then compact.
+         */
+        mBuffer.flip();
+        mBuffer.position(mLength);
+        mBuffer.compact();
+        mLength = 0;
+    }
+
+    /**
+     * When the "buf" contains JdwpPackets the first 4 bytes are the length of the packet. This
+     * helper function reads the first 4 bytes and validates that the length is at least the size of
+     * the JDWP header.
+     *
+     * @param buf a buffer assumed to contain a jdwp packet.
+     * @return -1 if the length is invalid, otherwise the length of the packet.
+     */
+    public static int getPacketLength(ByteBuffer buf) {
+        int count = buf.position();
+        if (count < JDWP_HEADER_LEN) {
+            return -1;
+        }
+        int length = buf.getInt(0x00);
+        if (length < JDWP_HEADER_LEN) {
+            return -1;
+        }
+        return length;
+    }
+
+    /**
+     * Find the JDWP packet at the start of "buf". The start is known, but the length has to be
+     * parsed out.
+     *
+     * <p>On entry, the packet data in "buf" must start at offset 0 and end at "position". "limit"
+     * should be set to the buffer capacity. This method does not alter "buf"s attributes.
+     *
+     * <p>Returns a new JdwpPacket if a full one is found in the buffer. If not, returns null.
+     * Throws an exception if the data doesn't look like a valid JDWP packet.
+     */
+    private static JdwpPacket findPacket(ByteBuffer buf, boolean setPayload) {
+        int count = buf.position();
+        int length, id, flags, cmdSet, cmd;
+
+        if (count < JDWP_HEADER_LEN) {
+            return null;
+        }
+
+        ByteOrder oldOrder = buf.order();
+        buf.order(ChunkHandler.CHUNK_ORDER);
+
+        length = buf.getInt(0x00);
+        id = buf.getInt(0x04);
+        flags = buf.get(0x08) & 0xff;
+        cmdSet = buf.get(0x09) & 0xff;
+        cmd = buf.get(0x0a) & 0xff;
+
+        buf.order(oldOrder);
+
+        JdwpPacket pkt;
+
+        if (setPayload) {
+            if (length < JDWP_HEADER_LEN) throw new BadPacketException();
+            if (count < length) return null;
+
+            pkt = new JdwpPacket(buf);
+        } else {
+            pkt = new JdwpPacket(ByteBuffer.allocate(0));
+        }
+        // pkt.mBuffer = buf;
+        pkt.mLength = length;
+        pkt.mId = id;
+        pkt.mFlags = flags;
+
+        if ((flags & REPLY_PACKET) == 0) {
+            pkt.mCmdSet = cmdSet;
+            pkt.mCmd = cmd;
+            pkt.mErrCode = -1;
+        } else {
+            pkt.mCmdSet = -1;
+            pkt.mCmd = -1;
+            pkt.mErrCode = cmdSet | (cmd << 8);
+        }
+
+        return pkt;
+    }
+
+    public static JdwpPacket findPacket(ByteBuffer buf) {
+        return findPacket(buf, true);
+    }
+
+    public static JdwpPacket findPacketHeader(ByteBuffer buf) {
+        return findPacket(buf, false);
+    }
+
+    @Override
+    public String toString() {
+        return isReply() ? " < # " + mId : " > " + mCmdSet + "." + mCmd + " # " + mId;
+    }
+
+    public boolean is(int cmdSet, int cmd) {
+        return cmdSet == mCmdSet && cmd == mCmd;
+    }
+
+    public void log(@NonNull String action) {
+        if (isReply()) {
+            Log.d(
+                    "jdwp",
+                    String.format(
+                            "%s: jdwp reply: id=%d, length=%d, flags=%d, error=%d",
+                            action, mId, mLength, mFlags, mErrCode));
+        } else {
+            Log.d(
+                    "jdwp",
+                    String.format(
+                            "%s: jdwp request: id=%d, length=%d, flags=%d, cmdSet=%s, cmd=%s",
+                            action,
+                            mId,
+                            mLength,
+                            mFlags,
+                            JdwpCommands.commandSetToString(mCmdSet),
+                            JdwpCommands.commandToString(mCmdSet, mCmd)));
+        }
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/jdwp/packets/CapabilitiesNewReply.java b/device_build_interfaces/com/android/tradefed/device/server/jdwp/packets/CapabilitiesNewReply.java
new file mode 100644
index 000000000..05bc87ca4
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/jdwp/packets/CapabilitiesNewReply.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.device.server.jdwp.packets;
+
+import com.android.annotations.NonNull;
+import com.android.tradefed.device.server.jdwp.JdwpPayload;
+import com.android.tradefed.device.server.jdwp.JdwpProtocol;
+
+import java.nio.ByteBuffer;
+
+/** The payload of a CapabilitiesNew reply of the JDWP protocol. */
+public class CapabilitiesNewReply extends JdwpPayload {
+    private ByteBuffer converted;
+
+    public static final int CAN_REDEFINE_CLASSES_IDX = 7;
+    public static final int CAN_REDEFINE_CLASSES_DEX_IDX = 31;
+
+    @Override
+    public void parse(@NonNull ByteBuffer buffer, @NonNull JdwpProtocol protocol) {
+        // The secret 31th byte is set to true when the Android device can use RedefineClasses
+        // capabilities on dex files. We will set the 7th byte (original CanRedefineClasses byte)
+        // to true to let JDB knows it is ok to call RedefineClasses.
+        if (buffer.get(CAN_REDEFINE_CLASSES_DEX_IDX) != 0) {
+            buffer.put(CAN_REDEFINE_CLASSES_IDX, (byte) 1);
+            converted = buffer;
+        }
+
+        converted = buffer;
+    }
+
+    /**
+     * Convert the reply payload such that if we are talking to an android device and it has
+     * RedefineClasses capabilities, the CanRedefineClasses byte is set to true. Note that that byte
+     * is normally never set when talking to an Android device because it tries to prevent the
+     * debugger from feed it plan old Java class files.
+     *
+     * @return
+     */
+    public ByteBuffer getConverted() {
+        return converted;
+    }
+}
diff --git a/device_build_interfaces/com/android/tradefed/device/server/jdwp/packets/IdSizesReply.java b/device_build_interfaces/com/android/tradefed/device/server/jdwp/packets/IdSizesReply.java
new file mode 100644
index 000000000..64725c410
--- /dev/null
+++ b/device_build_interfaces/com/android/tradefed/device/server/jdwp/packets/IdSizesReply.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.server.jdwp.packets;
+
+import com.android.annotations.NonNull;
+import com.android.tradefed.device.server.jdwp.JdwpPayload;
+import com.android.tradefed.device.server.jdwp.JdwpProtocol;
+
+import java.nio.ByteBuffer;
+
+public class IdSizesReply extends JdwpPayload {
+
+    public int fieldIDSize;
+    public int methodIDSize;
+    public int objectIDSize;
+    public int refTypeIDSize;
+    public int frameIDSize;
+
+    @Override
+    public void parse(@NonNull ByteBuffer buffer, @NonNull JdwpProtocol protocol) {
+        fieldIDSize = buffer.getInt();
+        methodIDSize = buffer.getInt();
+        objectIDSize = buffer.getInt();
+        refTypeIDSize = buffer.getInt();
+        frameIDSize = buffer.getInt();
+    }
+}
diff --git a/invocation_interfaces/Android.bp b/invocation_interfaces/Android.bp
index 94e9e504d..f3cf27567 100644
--- a/invocation_interfaces/Android.bp
+++ b/invocation_interfaces/Android.bp
@@ -27,7 +27,6 @@ java_library_host {
         "com/**/*.java",
     ],
     libs: [
-        "ddmlib-prebuilt",
         "guava",
         "tradefed-common-util",
         "tradefed-protos",
diff --git a/invocation_interfaces/com/android/tradefed/result/TestRunResult.java b/invocation_interfaces/com/android/tradefed/result/TestRunResult.java
index 0baccf6aa..39b2d16ce 100644
--- a/invocation_interfaces/com/android/tradefed/result/TestRunResult.java
+++ b/invocation_interfaces/com/android/tradefed/result/TestRunResult.java
@@ -15,7 +15,6 @@
  */
 package com.android.tradefed.result;
 
-import com.android.annotations.VisibleForTesting;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
 import com.android.tradefed.result.skipped.SkipReason;
@@ -23,6 +22,8 @@ import com.android.tradefed.retry.MergeStrategy;
 import com.android.tradefed.util.MultiMap;
 import com.android.tradefed.util.proto.TfMetricProtoUtil;
 
+import com.google.common.annotations.VisibleForTesting;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
diff --git a/invocation_interfaces/com/android/tradefed/util/SearchArtifactUtil.java b/invocation_interfaces/com/android/tradefed/util/SearchArtifactUtil.java
index db2fd4e95..a1ecd7e7f 100644
--- a/invocation_interfaces/com/android/tradefed/util/SearchArtifactUtil.java
+++ b/invocation_interfaces/com/android/tradefed/util/SearchArtifactUtil.java
@@ -153,8 +153,48 @@ public class SearchArtifactUtil {
             AltDirBehavior altDirBehavior,
             TestInformation testInfo,
             boolean includeDirectory) {
+        return searchFile(
+                fileName,
+                targetFirst,
+                abi,
+                altDirs,
+                altDirBehavior,
+                testInfo,
+                null,
+                includeDirectory);
+    }
+
+    /**
+     * Searches for a test artifact/dependency file from the test directory.
+     *
+     * @param fileName The name of the file to look for.
+     * @param targetFirst Whether we are favoring target-side files vs. host-side files for the
+     *     search.
+     * @param abi The {@link IAbi} to match the file.
+     * @param altDirs Alternative search paths, in addition to the default search paths.
+     * @param altDirBehavior how alternative search paths should be used against default paths: as
+     *     fallback, or as override; if unspecified, fallback will be used
+     * @param testInfo The {@link TestInformation} of the current test when available.
+     * @param buildInfo The {@link IBuildInfo} of the current test when available.
+     * @param includeDirectory whether to include directories in the search result.
+     * @return The found artifact file or null if none.
+     */
+    public static File searchFile(
+            String fileName,
+            boolean targetFirst,
+            IAbi abi,
+            List<File> altDirs,
+            AltDirBehavior altDirBehavior,
+            TestInformation testInfo,
+            IBuildInfo buildInfo,
+            boolean includeDirectory) {
+        if (buildInfo == null) {
+            // if build info not provided, try to get it from current invocation context
+            buildInfo = singleton.getBuildInfo();
+        }
         List<File> searchDirectories =
-                singleton.getSearchDirectories(targetFirst, altDirs, altDirBehavior, testInfo);
+                singleton.getSearchDirectories(
+                        targetFirst, altDirs, altDirBehavior, testInfo, buildInfo);
         CLog.d("Searching for file %s. Search directories: %s", fileName, searchDirectories);
         // Search in the test directories
         for (File dir : searchDirectories) {
@@ -177,7 +217,6 @@ public class SearchArtifactUtil {
         }
 
         // Search in the build info or stage remote file as fallback
-        IBuildInfo buildInfo = singleton.getBuildInfo();
         if (buildInfo != null) {
             File file = buildInfo.getFile(fileName);
             if (fileExists(file)) {
@@ -213,7 +252,8 @@ public class SearchArtifactUtil {
             boolean targetFirst,
             List<File> altDirs,
             AltDirBehavior altDirBehavior,
-            TestInformation testInfo) {
+            TestInformation testInfo,
+            IBuildInfo buildInfo) {
         List<File> dirs = new LinkedList<>();
         // Prioritize the module directory retrieved from the config obj, as this is the ideal place
         // for all test artifacts.
@@ -223,53 +263,60 @@ public class SearchArtifactUtil {
         }
 
         ExecutionFiles executionFiles = singleton.getExecutionFiles(testInfo);
+        // Add host/testcases or target/testcases directory first
+        File testcasesDir = null;
         if (executionFiles != null) {
-            // Add host/testcases or target/testcases directory first
             FilesKey hostOrTarget = FilesKey.HOST_TESTS_DIRECTORY;
             if (targetFirst) {
                 hostOrTarget = FilesKey.TARGET_TESTS_DIRECTORY;
             }
-            File testcasesDir = executionFiles.get(hostOrTarget);
-            if (fileExists(testcasesDir)) {
-                dirs.add(testcasesDir);
+            File dir = executionFiles.get(hostOrTarget);
+            if (fileExists(dir)) {
+                testcasesDir = dir;
             }
-
-            // Add root test directory
-            File rootTestDir = executionFiles.get(FilesKey.TESTS_DIRECTORY);
-            if (fileExists(rootTestDir)) {
-                dirs.add(rootTestDir);
+        }
+        if (testcasesDir == null && buildInfo != null) {
+            // try getting the testcases directory from the build info.
+            BuildInfoFileKey hostOrTarget = BuildInfoFileKey.HOST_LINKED_DIR;
+            if (targetFirst) {
+                hostOrTarget = BuildInfoFileKey.TARGET_LINKED_DIR;
             }
-        } else {
-            // try getting the search directories from the build info.
-            IBuildInfo buildInfo = singleton.getBuildInfo();
-            if (buildInfo != null) {
-
-                // Add host/testcases or target/testcases directory first
-                BuildInfoFileKey hostOrTarget = BuildInfoFileKey.HOST_LINKED_DIR;
-                if (targetFirst) {
-                    hostOrTarget = BuildInfoFileKey.TARGET_LINKED_DIR;
-                }
-                File testcasesDir = buildInfo.getFile(hostOrTarget);
-                if (fileExists(testcasesDir)) {
-                    dirs.add(testcasesDir);
-                }
+            File dir = buildInfo.getFile(hostOrTarget);
+            if (fileExists(dir)) {
+                testcasesDir = dir;
+            }
+        }
+        if (testcasesDir != null) {
+            dirs.add(testcasesDir);
+        }
 
-                // Add root test directory
-                File rootTestDir = null;
-                if (buildInfo instanceof IDeviceBuildInfo) {
-                    rootTestDir = ((IDeviceBuildInfo) buildInfo).getTestsDir();
-                }
-                if (!fileExists(rootTestDir)) {
-                    rootTestDir = buildInfo.getFile(BuildInfoFileKey.TESTDIR_IMAGE);
-                }
-                if (!fileExists(rootTestDir)) {
-                    rootTestDir = buildInfo.getFile(BuildInfoFileKey.ROOT_DIRECTORY);
-                }
-                if (fileExists(rootTestDir)) {
-                    dirs.add(rootTestDir);
-                }
+        // Add root test directory
+        File rootTestDir = null;
+        if (executionFiles != null) {
+            File dir = executionFiles.get(FilesKey.TESTS_DIRECTORY);
+            if (fileExists(dir)) {
+                rootTestDir = dir;
             }
         }
+        if (rootTestDir == null && buildInfo != null) {
+            // try getting the root test directory from the build info.
+            File dir = null;
+            if (buildInfo instanceof IDeviceBuildInfo) {
+                dir = ((IDeviceBuildInfo) buildInfo).getTestsDir();
+            }
+            if (!fileExists(dir)) {
+                dir = buildInfo.getFile(BuildInfoFileKey.TESTDIR_IMAGE);
+            }
+            if (!fileExists(dir)) {
+                dir = buildInfo.getFile(BuildInfoFileKey.ROOT_DIRECTORY);
+            }
+            if (fileExists(dir)) {
+                rootTestDir = dir;
+            }
+        }
+        if (rootTestDir != null) {
+            dirs.add(rootTestDir);
+        }
 
         // Add alternative directories based on the alt dir behavior
         if (altDirs != null) {
@@ -439,7 +486,7 @@ public class SearchArtifactUtil {
     public static File findModuleDir(String moduleName, boolean targetFirst) {
         try (CloseableTraceScope ignored = new CloseableTraceScope("findModuleDir")) {
             List<File> searchDirectories =
-                    singleton.getSearchDirectories(targetFirst, null, null, null);
+                    singleton.getSearchDirectories(targetFirst, null, null, null, null);
             for (File searchDirectory : searchDirectories) {
                 try {
                     File moduleDir = FileUtil.findDirectory(moduleName, searchDirectory);
diff --git a/isolation/com/android/tradefed/isolation/IsolationRunner.java b/isolation/com/android/tradefed/isolation/IsolationRunner.java
index 99e5043cd..032629712 100644
--- a/isolation/com/android/tradefed/isolation/IsolationRunner.java
+++ b/isolation/com/android/tradefed/isolation/IsolationRunner.java
@@ -36,6 +36,7 @@ import java.io.OutputStream;
 import java.io.PrintStream;
 import java.net.ServerSocket;
 import java.net.Socket;
+import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
 
@@ -123,14 +124,42 @@ public final class IsolationRunner {
         }
     }
 
+    private List<Class<?>> getShardClasses(
+            List<Class<?>> classes, int totalShards, int shardIndex) {
+        if (totalShards < 2) {
+            return classes;
+        }
+        int totalClasses = classes.size();
+        //        int chunkSize = totalClasses / totalShards;
+        int chunkSize = 1;
+        if (totalClasses % totalShards > 0) chunkSize++;
+        List<Class<?>> includedClasses = new ArrayList<>();
+        if (shardIndex >= totalClasses) {
+            return includedClasses;
+        }
+        int startIndex = shardIndex * chunkSize;
+        int endIndex = Math.min((shardIndex + 1) * chunkSize, totalClasses);
+        if (startIndex >= totalClasses) {
+            startIndex = Math.max(0, totalClasses - 1);
+            endIndex = totalClasses;
+        }
+        includedClasses = classes.subList(startIndex, endIndex);
+        return includedClasses;
+    }
+
     private void runTests(OutputStream output, TestParameters params) throws IOException {
         System.out.println("INFO: IsolationRunner: Filters: ");
         System.out.println(params.getFilter());
-
+        System.out.println(
+                "Current Total Shard and Shard Index: "
+                        + params.getTotalShards()
+                        + ", "
+                        + params.getShardIndex());
         List<Class<?>> klasses = this.getClasses(params);
-
+        List<Class<?>> shardKlasses =
+                getShardClasses(klasses, params.getTotalShards(), params.getShardIndex());
         try {
-            for (Class<?> klass : klasses) {
+            for (Class<?> klass : shardKlasses) {
                 IsolationResultForwarder list = new IsolationResultForwarder(output);
                 JUnitCore runnerCore = new JUnitCore();
                 runnerCore.addListener(list);
diff --git a/isolation/isolation_runner.proto b/isolation/isolation_runner.proto
index e6e11167c..33bc37d3d 100644
--- a/isolation/isolation_runner.proto
+++ b/isolation/isolation_runner.proto
@@ -49,6 +49,9 @@ message TestParameters {
   repeated string excludePaths = 3;
   FilterSpec filter = 4;
   bool dryRun = 5;
+  int32 totalShards = 6;
+  int32 shardIndex = 7;
+
 }
 
 message FilterSpec {
diff --git a/javatests/.classpath b/javatests/.classpath
index 60e6a97f4..1adfd49ab 100644
--- a/javatests/.classpath
+++ b/javatests/.classpath
@@ -6,7 +6,6 @@
 	<classpathentry kind="src" path="res"/>
 	<classpathentry kind="src" path="mockito"/>
 	<classpathentry kind="src" path="objenesis"/>
-	<classpathentry combineaccessrules="false" kind="src" path="/ddmlib"/>
 	<classpathentry combineaccessrules="false" kind="src" path="/tf-remote-client"/>
 	<classpathentry combineaccessrules="false" kind="src" path="/tradefederation"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER">
diff --git a/javatests/com/android/tradefed/UnitTests.java b/javatests/com/android/tradefed/UnitTests.java
index 3e009a0d1..83436ab0c 100644
--- a/javatests/com/android/tradefed/UnitTests.java
+++ b/javatests/com/android/tradefed/UnitTests.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010 The Android Open Source Project
+ * Copyright (C) 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,10 +20,12 @@ import com.android.tradefed.auth.ServiceAccountKeyCredentialFactoryTest;
 import com.android.tradefed.build.AppDeviceBuildInfoTest;
 import com.android.tradefed.build.BootstrapBuildProviderTest;
 import com.android.tradefed.build.BuildInfoTest;
+import com.android.tradefed.build.CasFuseDriverProfileTest;
 import com.android.tradefed.build.DeviceBuildDescriptorTest;
 import com.android.tradefed.build.DeviceBuildInfoTest;
 import com.android.tradefed.build.DeviceFolderBuildInfoTest;
 import com.android.tradefed.build.FileDownloadCacheTest;
+import com.android.tradefed.build.FuseMountManagerTest;
 import com.android.tradefed.build.LocalDeviceBuildProviderTest;
 import com.android.tradefed.build.cache.PartialZipDownloadCacheTest;
 import com.android.tradefed.build.content.ArtifactDetailsTest;
@@ -50,6 +52,7 @@ import com.android.tradefed.cluster.ClusterLogSaverTest;
 import com.android.tradefed.cluster.SubprocessConfigBuilderTest;
 import com.android.tradefed.cluster.SubprocessReportingHelperTest;
 import com.android.tradefed.cluster.TestOutputUploaderTest;
+import com.android.tradefed.cluster.TestResourceDownloaderTest;
 import com.android.tradefed.command.CommandFileParserTest;
 import com.android.tradefed.command.CommandFileWatcherTest;
 import com.android.tradefed.command.CommandInterrupterTest;
@@ -136,6 +139,7 @@ import com.android.tradefed.device.metric.HostStatsdMetricCollectorTest;
 import com.android.tradefed.device.metric.JavaCodeCoverageCollectorTest;
 import com.android.tradefed.device.metric.LogcatOnFailureCollectorTest;
 import com.android.tradefed.device.metric.LogcatTimingMetricCollectorTest;
+import com.android.tradefed.device.metric.PerfettoFilePullerCollectorTest;
 import com.android.tradefed.device.metric.PerfettoPullerMetricCollectorTest;
 import com.android.tradefed.device.metric.RebootReasonCollectorTest;
 import com.android.tradefed.device.metric.RuntimeRestartCollectorTest;
@@ -190,11 +194,13 @@ import com.android.tradefed.monitoring.collector.ResourceMetricUtilTest;
 import com.android.tradefed.observatory.TestDiscoveryExecutorTest;
 import com.android.tradefed.observatory.TestDiscoveryInvokerTest;
 import com.android.tradefed.observatory.TestMappingDiscoveryAgentTest;
+import com.android.tradefed.observatory.TestZipDiscoveryExecutorTest;
 import com.android.tradefed.postprocessor.AggregatePostProcessorTest;
 import com.android.tradefed.postprocessor.AveragePostProcessorTest;
 import com.android.tradefed.postprocessor.BasePostProcessorTest;
 import com.android.tradefed.postprocessor.MetricFilePostProcessorTest;
 import com.android.tradefed.postprocessor.PerfettoGenericPostProcessorTest;
+import com.android.tradefed.postprocessor.PerfettoTracePostProcessorTest;
 import com.android.tradefed.postprocessor.StatsdBeforeAfterGaugeMetricPostProcessorTest;
 import com.android.tradefed.postprocessor.StatsdEventMetricPostProcessorTest;
 import com.android.tradefed.postprocessor.StatsdGenericPostProcessorTest;
@@ -294,6 +300,7 @@ import com.android.tradefed.targetprep.InstrumentationPreparerTest;
 import com.android.tradefed.targetprep.KnownFailurePreparerTest;
 import com.android.tradefed.targetprep.LocalEmulatorLaunchTest;
 import com.android.tradefed.targetprep.MixKernelTargetPreparerTest;
+import com.android.tradefed.targetprep.MixRadioTargetPreparerTest;
 import com.android.tradefed.targetprep.ModuleOemTargetPreparerTest;
 import com.android.tradefed.targetprep.ModulePusherTest;
 import com.android.tradefed.targetprep.OtaUpdateDeviceFlasherTest;
@@ -330,6 +337,7 @@ import com.android.tradefed.targetprep.suite.SuiteApkInstallerTest;
 import com.android.tradefed.testtype.AndroidJUnitTestTest;
 import com.android.tradefed.testtype.ArtGTestTest;
 import com.android.tradefed.testtype.ArtRunTestTest;
+import com.android.tradefed.testtype.ArtTestTest;
 import com.android.tradefed.testtype.DeviceBatteryLevelCheckerTest;
 import com.android.tradefed.testtype.DeviceJUnit4ClassRunnerTest;
 import com.android.tradefed.testtype.DeviceSuiteTest;
@@ -370,6 +378,7 @@ import com.android.tradefed.testtype.host.CoverageMeasurementForwarderTest;
 import com.android.tradefed.testtype.junit4.BaseHostJUnit4TestTest;
 import com.android.tradefed.testtype.junit4.DeviceParameterizedRunnerTest;
 import com.android.tradefed.testtype.junit4.JUnit4ResultForwarderTest;
+import com.android.tradefed.testtype.mobly.MoblyArtifactReporterTest;
 import com.android.tradefed.testtype.mobly.MoblyBinaryHostTestTest;
 import com.android.tradefed.testtype.mobly.MoblyYamlResultParserTest;
 import com.android.tradefed.testtype.python.PythonBinaryHostTestTest;
@@ -528,10 +537,12 @@ import org.junit.runners.Suite.SuiteClasses;
     AppDeviceBuildInfoTest.class,
     BootstrapBuildProviderTest.class,
     BuildInfoTest.class,
+    CasFuseDriverProfileTest.class,
     DeviceBuildInfoTest.class,
     DeviceBuildDescriptorTest.class,
     DeviceFolderBuildInfoTest.class,
     FileDownloadCacheTest.class,
+    FuseMountManagerTest.class,
     LocalDeviceBuildProviderTest.class,
 
     // build.cache
@@ -568,6 +579,7 @@ import org.junit.runners.Suite.SuiteClasses;
     SubprocessConfigBuilderTest.class,
     SubprocessReportingHelperTest.class,
     TestOutputUploaderTest.class,
+    TestResourceDownloaderTest.class,
 
     // command
     CommandFileParserTest.class,
@@ -686,6 +698,7 @@ import org.junit.runners.Suite.SuiteClasses;
     JavaCodeCoverageCollectorTest.class,
     LogcatOnFailureCollectorTest.class,
     LogcatTimingMetricCollectorTest.class,
+    PerfettoFilePullerCollectorTest.class,
     PerfettoPullerMetricCollectorTest.class,
     RebootReasonCollectorTest.class,
     RuntimeRestartCollectorTest.class,
@@ -761,6 +774,7 @@ import org.junit.runners.Suite.SuiteClasses;
     TestDiscoveryExecutorTest.class,
     TestDiscoveryInvokerTest.class,
     TestMappingDiscoveryAgentTest.class,
+    TestZipDiscoveryExecutorTest.class,
 
     // postprocessor
     AggregatePostProcessorTest.class,
@@ -768,6 +782,7 @@ import org.junit.runners.Suite.SuiteClasses;
     BasePostProcessorTest.class,
     MetricFilePostProcessorTest.class,
     PerfettoGenericPostProcessorTest.class,
+    PerfettoTracePostProcessorTest.class,
     StatsdBeforeAfterGaugeMetricPostProcessorTest.class,
     StatsdEventMetricPostProcessorTest.class,
     StatsdGenericPostProcessorTest.class,
@@ -862,6 +877,7 @@ import org.junit.runners.Suite.SuiteClasses;
     KnownFailurePreparerTest.class,
     LocalEmulatorLaunchTest.class,
     MixKernelTargetPreparerTest.class,
+    MixRadioTargetPreparerTest.class,
     ModuleOemTargetPreparerTest.class,
     ModulePusherTest.class,
     PushFilePreparerTest.class,
@@ -942,6 +958,7 @@ import org.junit.runners.Suite.SuiteClasses;
     AndroidJUnitTestTest.class,
     ArtGTestTest.class,
     ArtRunTestTest.class,
+    ArtTestTest.class,
     CoverageMeasurementForwarderTest.class,
     DeviceBatteryLevelCheckerTest.class,
     DeviceJUnit4ClassRunnerTest.class,
@@ -988,6 +1005,7 @@ import org.junit.runners.Suite.SuiteClasses;
     JUnit4ResultForwarderTest.class,
 
     // testtype/mobly
+    MoblyArtifactReporterTest.class,
     MoblyBinaryHostTestTest.class,
     MoblyYamlResultParserTest.class,
 
diff --git a/javatests/com/android/tradefed/build/CasFuseDriverProfileTest.java b/javatests/com/android/tradefed/build/CasFuseDriverProfileTest.java
new file mode 100644
index 000000000..ec8c8649d
--- /dev/null
+++ b/javatests/com/android/tradefed/build/CasFuseDriverProfileTest.java
@@ -0,0 +1,166 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.build;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertThrows;
+import static org.junit.Assert.assertTrue;
+
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Path;
+import java.util.Arrays;
+import java.util.List;
+
+/** Unit tests for {@link CasFuseDriverProfile}. */
+@RunWith(JUnit4.class)
+public class CasFuseDriverProfileTest {
+
+    @Rule public TemporaryFolder tempFolder = new TemporaryFolder();
+
+    private CasFuseDriverProfile mProfile;
+    private File mDriverFile;
+
+    @Before
+    public void setUp() throws IOException {
+        mDriverFile = tempFolder.newFile("casviewer-driver");
+        mProfile = new CasFuseDriverProfile(mDriverFile.toPath());
+    }
+
+    @Test
+    public void testValidSourceDataPath_success() throws IOException {
+        File sourceDir = tempFolder.newFolder("valid_source");
+        tempFolder.newFile("valid_source/_chunks_index.json");
+
+        mProfile.validateSourceDataPath(sourceDir.toPath());
+
+        // No exception thrown
+    }
+
+    @Test
+    public void testValidSourceDataPath_directoryDoesNotExist() {
+        File nonExistentDir = new File(tempFolder.getRoot(), "non_existent");
+
+        assertThrows(
+                "Should throw IOException when the source directory does not exist.",
+                IOException.class,
+                () -> mProfile.validateSourceDataPath(nonExistentDir.toPath()));
+    }
+
+    @Test
+    public void testValidSourceDataPath_isAFileNotDirectory() throws IOException {
+        File sourceFile = tempFolder.newFile("source_as_file.txt");
+
+        assertThrows(
+                "Should throw IOException when the source path is a file, not a"
+                    + " directory.",
+                IOException.class,
+                () -> mProfile.validateSourceDataPath(sourceFile.toPath()));
+    }
+
+    @Test
+    public void testValidSourceDataPath_directoryMissingIndexFile() throws IOException {
+        File sourceDir = tempFolder.newFolder("source_missing_index");
+
+        assertThrows(
+                "Should throw IOException when the source directory is missing the chunks"
+                    + " index file.",
+                IOException.class,
+                () -> mProfile.validateSourceDataPath(sourceDir.toPath()));
+    }
+
+    @Test
+    public void testIsMountPointReady_success() throws IOException {
+        File mountPoint = tempFolder.newFolder("ready_mount_point");
+        tempFolder.newFile("ready_mount_point/boot.img");
+
+        assertTrue(
+                "Should return true for a mount point containing boot.img.",
+                mProfile.isMountPointReady(mountPoint.toPath()));
+    }
+
+    @Test
+    public void testIsMountPointReady_missingBootImage() throws IOException {
+        File mountPoint = tempFolder.newFolder("not_ready_mount_point");
+
+        assertFalse(
+                "Should return false if the mount point does not contain boot.img.",
+                mProfile.isMountPointReady(mountPoint.toPath()));
+    }
+
+    @Test
+    public void testIsMountPointReady_mountPointDoesNotExist() {
+        File nonExistentDir = new File(tempFolder.getRoot(), "non_existent_mount_point");
+
+        assertFalse(
+                "Should return false if the mount point directory itself does not exist.",
+                mProfile.isMountPointReady(nonExistentDir.toPath()));
+    }
+
+    @Test
+    public void testBuildMountCommand() {
+        Path sourceDir = new File("/fake/source/dir").toPath();
+        Path mountPoint = new File("/fake/mount/point").toPath();
+        List<String> expectedCommand =
+                Arrays.asList(
+                        mDriverFile.getAbsolutePath(),
+                        "--chunks",
+                        sourceDir.toAbsolutePath().toString(),
+                        "--mount",
+                        mountPoint.toAbsolutePath().toString());
+
+        List<String> actualCommand = mProfile.buildMountCommand(sourceDir, mountPoint);
+
+        assertNotNull("Command list should not be null.", actualCommand);
+        assertEquals(
+                "The generated command should match the expected format.",
+                expectedCommand,
+                actualCommand);
+    }
+
+    @Test
+    public void testGetDriverName() {
+        assertEquals(
+                "The driver name should be 'casviewer'.", "casviewer", mProfile.getDriverName());
+    }
+
+    @Test
+    public void testGetMountTimeoutInMs() {
+        assertEquals(
+                "The default mount timeout should be 500 milliseconds.",
+                500,
+                mProfile.getMountTimeoutInMs());
+    }
+
+    @Test
+    public void testGetMountTimeoutInMs_customTimeout() {
+        mProfile = new CasFuseDriverProfile(mDriverFile.toPath(), 1000);
+        assertEquals(
+                "The custom mount timeout should be 1000 milliseconds.",
+                1000,
+                mProfile.getMountTimeoutInMs());
+    }
+}
diff --git a/javatests/com/android/tradefed/build/FuseMountManagerTest.java b/javatests/com/android/tradefed/build/FuseMountManagerTest.java
new file mode 100644
index 000000000..d30fa927a
--- /dev/null
+++ b/javatests/com/android/tradefed/build/FuseMountManagerTest.java
@@ -0,0 +1,244 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.build;
+
+import static org.junit.Assert.assertThrows;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.doNothing;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.android.tradefed.util.CommandResult;
+import com.android.tradefed.util.CommandStatus;
+import com.android.tradefed.util.IRunUtil;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.junit.MockitoJUnitRunner;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Path;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+
+/** Unit tests for {@link FuseMountManager}. */
+@RunWith(MockitoJUnitRunner.class)
+public class FuseMountManagerTest {
+
+    @Mock private IFuseDriverProfile mMockDriverProfile;
+    @Mock private IRunUtil mMockRunUtil;
+    @Mock private Process mMockProcess;
+    @Mock private CommandResult mMockCommandResult;
+
+    private FuseMountManager mManager;
+    private Path mSourcePath;
+    private Path mMountPoint;
+
+    @Before
+    public void setUp() throws IOException {
+        mManager = new FuseMountManager(mMockDriverProfile, mMockRunUtil);
+
+        mSourcePath = new File("/test/source").toPath();
+        mMountPoint = new File("/test/mount").toPath();
+
+        doNothing().when(mMockDriverProfile).validateSourceDataPath(any(Path.class));
+        when(mMockDriverProfile.buildMountCommand(any(Path.class), any(Path.class)))
+                .thenReturn(Arrays.asList("fuse-driver", "arg1", "arg2"));
+    }
+
+    @Test
+    public void testMount_success() throws Exception {
+        when(mMockRunUtil.runCmdInBackground(any(List.class), any(ByteArrayOutputStream.class))).thenReturn(mMockProcess);
+        when(mMockDriverProfile.getMountTimeoutInMs()).thenReturn(500L);
+        when(mMockDriverProfile.isMountPointReady(mMountPoint)).thenReturn(true);
+
+        mManager.mount(mSourcePath, mMountPoint);
+
+        // Infer success by verifying no exceptions were thrown.
+    }
+
+    @Test
+    public void testMount_alreadyMounted_throwsException() throws Exception {
+        when(mMockRunUtil.runCmdInBackground(any(List.class), any(ByteArrayOutputStream.class))).thenReturn(mMockProcess);
+        when(mMockDriverProfile.getMountTimeoutInMs()).thenReturn(500L);
+        when(mMockDriverProfile.isMountPointReady(mMountPoint)).thenReturn(true);
+        mManager.mount(mSourcePath, mMountPoint); // First mount succeeds
+
+        assertThrows(
+                "Should throw IllegalStateException when mounting to an existing mount point.",
+                IllegalStateException.class,
+                () -> mManager.mount(mSourcePath, mMountPoint));
+    }
+
+    @Test
+    public void testMount_invalidSource_throwsException() throws IOException {
+        doThrow(new IOException()).when(mMockDriverProfile).validateSourceDataPath(any(Path.class));
+
+        assertThrows(
+                "Should throw IllegalArgumentException for an invalid source.",
+                IllegalArgumentException.class,
+                () -> mManager.mount(mSourcePath, mMountPoint));
+    }
+
+    @Test
+    public void testMount_processExitsImmediately_throwsException() throws Exception {
+        when(mMockRunUtil.runCmdInBackground(any(List.class), any(ByteArrayOutputStream.class))).thenReturn(mMockProcess);
+        when(mMockDriverProfile.getMountTimeoutInMs()).thenReturn(500L);
+        when(mMockDriverProfile.isMountPointReady(mMountPoint)).thenReturn(false); // Not ready
+        when(mMockProcess.waitFor(anyLong(), any(TimeUnit.class))).thenReturn(true); // Exited
+        when(mMockProcess.exitValue()).thenReturn(1);
+
+        assertThrows(
+                "Should throw IOException if the mount process exits immediately.",
+                IOException.class,
+                () -> mManager.mount(mSourcePath, mMountPoint));
+    }
+
+    @Test
+    public void testMount_mountTimedOut_throwsExceptionAndCleansUp() throws Exception {
+        when(mMockRunUtil.runCmdInBackground(any(List.class), any(ByteArrayOutputStream.class))).thenReturn(mMockProcess);
+        when(mMockDriverProfile.getMountTimeoutInMs()).thenReturn(500L);
+        when(mMockDriverProfile.isMountPointReady(mMountPoint)).thenReturn(false); // Not ready
+        when(mMockProcess.waitFor(anyLong(), any(TimeUnit.class)))
+                .thenReturn(false); // Still running
+
+        assertThrows(
+                "Should throw IOException if mount point is not ready.",
+                IOException.class,
+                () -> mManager.mount(mSourcePath, mMountPoint));
+
+        verify(mMockProcess).destroyForcibly();
+    }
+
+    @Test
+    public void testMount_interrupted_throwsExceptionAndCleansUp() throws Exception {
+        when(mMockRunUtil.runCmdInBackground(any(List.class), any(ByteArrayOutputStream.class))).thenReturn(mMockProcess);
+        when(mMockDriverProfile.getMountTimeoutInMs()).thenReturn(500L);
+        when(mMockDriverProfile.isMountPointReady(mMountPoint)).thenReturn(false); // Not ready
+        when(mMockProcess.isAlive()).thenReturn(true);
+        doThrow(new InterruptedException())
+                .when(mMockProcess)
+                .waitFor(anyLong(), any(TimeUnit.class));
+
+        assertThrows(
+                "Should throw IOException on InterruptedException.",
+                IOException.class,
+                () -> mManager.mount(mSourcePath, mMountPoint));
+
+        verify(mMockProcess).destroyForcibly();
+        assertTrue(
+                "Thread interrupted status should be set.", Thread.currentThread().isInterrupted());
+    }
+
+    @Test
+    public void testUnmount_gracefulSuccess() throws Exception {
+        // Mock a successful mount first.
+        when(mMockRunUtil.runCmdInBackground(any(List.class), any(ByteArrayOutputStream.class))).thenReturn(mMockProcess);
+        when(mMockDriverProfile.getMountTimeoutInMs()).thenReturn(500L);
+        when(mMockDriverProfile.isMountPointReady(mMountPoint)).thenReturn(true);
+        mManager.mount(mSourcePath, mMountPoint);
+
+        // Process is alive before fusermount and not alive after.
+        when(mMockProcess.isAlive()).thenReturn(true, false);
+        when(mMockRunUtil.runTimedCmd(anyLong(), eq("fusermount"), eq("-u"), any(String.class)))
+                .thenReturn(mMockCommandResult);
+        when(mMockCommandResult.getStatus()).thenReturn(CommandStatus.SUCCESS);
+
+        mManager.unmount(mMountPoint);
+
+        verify(mMockProcess, never()).destroyForcibly();
+    }
+
+    @Test
+    public void testUnmount_gracefulFail_forcefulSuccess() throws Exception {
+        // Mock a successful mount first.
+        when(mMockRunUtil.runCmdInBackground(any(List.class), any(ByteArrayOutputStream.class))).thenReturn(mMockProcess);
+        when(mMockDriverProfile.getMountTimeoutInMs()).thenReturn(500L);
+        when(mMockDriverProfile.isMountPointReady(mMountPoint)).thenReturn(true);
+        mManager.mount(mSourcePath, mMountPoint);
+
+        // Process is alive before and after fusermount.
+        when(mMockProcess.isAlive()).thenReturn(true);
+        when(mMockRunUtil.runTimedCmd(anyLong(), eq("fusermount"), eq("-u"), any(String.class)))
+                .thenReturn(mMockCommandResult);
+        when(mMockCommandResult.getStatus()).thenReturn(CommandStatus.FAILED); // fusermount fails
+        when(mMockProcess.waitFor(2, TimeUnit.SECONDS))
+                .thenReturn(false); // process still doesn't die
+
+        mManager.unmount(mMountPoint);
+
+        verify(mMockProcess).destroyForcibly();
+    }
+
+    @Test
+    public void testUnmount_notMounted_doesNothing() {
+        mManager.unmount(mMountPoint);
+
+        verify(mMockRunUtil, never()).runTimedCmd(anyLong(), any());
+    }
+
+    @Test
+    public void testUnmountAll_concurrentModificationSafe() throws Exception {
+        Path mountPoint1 = new File("/test/mount1").toPath();
+        Path mountPoint2 = new File("/test/mount2").toPath();
+
+        // Mock successful mounts for two different points
+        when(mMockRunUtil.runCmdInBackground(any(List.class), any(ByteArrayOutputStream.class))).thenReturn(mMockProcess);
+        when(mMockDriverProfile.getMountTimeoutInMs()).thenReturn(500L);
+        when(mMockDriverProfile.isMountPointReady(mountPoint1)).thenReturn(true);
+        when(mMockDriverProfile.isMountPointReady(mountPoint2)).thenReturn(true);
+        mManager.mount(mSourcePath, mountPoint1);
+        mManager.mount(mSourcePath, mountPoint2);
+
+        // Mock the unmount behavior
+        when(mMockProcess.isAlive()).thenReturn(true);
+        when(mMockRunUtil.runTimedCmd(anyLong(), eq("fusermount"), eq("-u"), any(String.class)))
+                .thenReturn(mMockCommandResult);
+        when(mMockCommandResult.getStatus()).thenReturn(CommandStatus.SUCCESS);
+
+        mManager.unmountAll();
+        mManager.unmount(mountPoint1);
+
+        // Assert that the internal map is now empty. Test by trying to unmount again, which should
+        // do nothing.
+        // fusermount is called twice, once for each mount point in unmountAll().
+        // fusermount is not called in the unmount() call above.
+        verify(mMockRunUtil, times(1))
+                .runTimedCmd(
+                        anyLong(),
+                        eq("fusermount"),
+                        eq("-u"),
+                        eq(mountPoint1.toAbsolutePath().toString()));
+        verify(mMockRunUtil, times(1))
+                .runTimedCmd(
+                        anyLong(),
+                        eq("fusermount"),
+                        eq("-u"),
+                        eq(mountPoint2.toAbsolutePath().toString()));
+    }
+}
diff --git a/javatests/com/android/tradefed/cluster/TestResourceDownloaderTest.java b/javatests/com/android/tradefed/cluster/TestResourceDownloaderTest.java
new file mode 100644
index 000000000..5970e2388
--- /dev/null
+++ b/javatests/com/android/tradefed/cluster/TestResourceDownloaderTest.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.cluster;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.File;
+import java.net.URL;
+import java.util.List;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Unit tests for {@link TestResourceDownloader}. */
+@RunWith(JUnit4.class)
+public class TestResourceDownloaderTest {
+
+    @Test
+    public void testBuildCurlCommandArgs() throws Exception {
+        URL url = new URL("https://www.example.com");
+        File file = new File("/tmp/test.txt");
+
+        List<String> args = new TestResourceDownloader().buildCurlCommandArgs(url, file);
+        assertEquals("curl -o /tmp/test.txt -fL https://www.example.com", String.join(" ", args));
+
+        List<String> argsWithLimitRate =
+                new TestResourceDownloader("200M").buildCurlCommandArgs(url, file);
+        assertEquals(
+                "curl -o /tmp/test.txt -fL https://www.example.com --limit-rate 200M",
+                String.join(" ", argsWithLimitRate));
+    }
+}
diff --git a/javatests/com/android/tradefed/device/DeviceManagerTest.java b/javatests/com/android/tradefed/device/DeviceManagerTest.java
index 3c207b037..e67a09cf4 100644
--- a/javatests/com/android/tradefed/device/DeviceManagerTest.java
+++ b/javatests/com/android/tradefed/device/DeviceManagerTest.java
@@ -30,13 +30,13 @@ import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-import com.android.ddmlib.AndroidDebugBridge.IDeviceChangeListener;
 import com.android.ddmlib.IDevice;
 import com.android.ddmlib.IDevice.DeviceState;
 import com.android.tradefed.command.remote.DeviceDescriptor;
 import com.android.tradefed.config.IGlobalConfiguration;
 import com.android.tradefed.config.OptionSetter;
 import com.android.tradefed.device.IManagedTestDevice.DeviceEventResponse;
+import com.android.tradefed.device.server.AndroidDebugBridge.IDeviceChangeListener;
 import com.android.tradefed.host.HostOptions;
 import com.android.tradefed.host.IHostOptions;
 import com.android.tradefed.log.ILogRegistry.EventType;
diff --git a/javatests/com/android/tradefed/device/NativeDeviceTest.java b/javatests/com/android/tradefed/device/NativeDeviceTest.java
index bd8dc436f..f326dd290 100644
--- a/javatests/com/android/tradefed/device/NativeDeviceTest.java
+++ b/javatests/com/android/tradefed/device/NativeDeviceTest.java
@@ -36,8 +36,6 @@ import com.android.ddmlib.IShellOutputReceiver;
 import com.android.ddmlib.ShellCommandUnresponsiveException;
 import com.android.ddmlib.SyncException;
 import com.android.ddmlib.SyncException.SyncError;
-import com.android.ddmlib.SyncService;
-import com.android.ddmlib.SyncService.ISyncProgressMonitor;
 import com.android.ddmlib.TimeoutException;
 import com.android.tradefed.build.IBuildInfo;
 import com.android.tradefed.command.remote.DeviceDescriptor;
@@ -46,6 +44,8 @@ import com.android.tradefed.config.OptionSetter;
 import com.android.tradefed.device.IWifiHelper.WifiConnectionResult;
 import com.android.tradefed.device.NativeDevice.RebootMode;
 import com.android.tradefed.device.contentprovider.ContentProviderHandler;
+import com.android.tradefed.device.server.SyncService;
+import com.android.tradefed.device.server.SyncService.ISyncProgressMonitor;
 import com.android.tradefed.host.HostOptions;
 import com.android.tradefed.host.IHostOptions;
 import com.android.tradefed.log.LogUtil.CLog;
@@ -332,7 +332,7 @@ public class NativeDeviceTest {
     /** Unit test for {@link NativeDevice#pushDir(File, String)}. */
     @Test
     public void testPushDir_notADir() throws Exception {
-        assertFalse(mTestDevice.pushDir(new File(""), ""));
+        assertFalse(mTestDevice.pushDir(new File("non-existing-path"), ""));
     }
 
     /** Unit test for {@link NativeDevice#pushDir(File, String)}. */
@@ -892,6 +892,23 @@ public class NativeDeviceTest {
     @Test
     public void testConnectToWifiNetworkIfNeeded_alreadyConnected()
             throws DeviceNotAvailableException {
+        mTestDevice =
+                new TestableAndroidNativeDevice() {
+                    @Override
+                    public boolean enableAdbRoot() throws DeviceNotAvailableException {
+                        return false;
+                    }
+
+                    @Override
+                    IWifiHelper createWifiHelper() throws DeviceNotAvailableException {
+                        return mMockWifi;
+                    }
+
+                    @Override
+                    IWifiHelper createWifiHelper(boolean useV2) throws DeviceNotAvailableException {
+                        return mMockWifi;
+                    }
+                };
         when(mMockWifi.checkConnectivity(mTestDevice.getOptions().getConnCheckUrl()))
                 .thenReturn(true);
 
@@ -1247,6 +1264,23 @@ public class NativeDeviceTest {
     /** Unit test for {@link NativeDevice#checkWifiConnection(String)}. */
     @Test
     public void testCheckWifiConnection() throws DeviceNotAvailableException {
+        mTestDevice =
+                new TestableAndroidNativeDevice() {
+                    @Override
+                    public boolean enableAdbRoot() throws DeviceNotAvailableException {
+                        return false;
+                    }
+
+                    @Override
+                    IWifiHelper createWifiHelper() throws DeviceNotAvailableException {
+                        return mMockWifi;
+                    }
+
+                    @Override
+                    IWifiHelper createWifiHelper(boolean useV2) throws DeviceNotAvailableException {
+                        return mMockWifi;
+                    }
+                };
         when(mMockWifi.isWifiEnabled()).thenReturn(true);
         when(mMockWifi.getSSID()).thenReturn("\"" + FAKE_NETWORK_SSID + "\"");
         when(mMockWifi.hasValidIp()).thenReturn(true);
@@ -1267,6 +1301,23 @@ public class NativeDeviceTest {
     /** Unit test for {@link NativeDevice#isWifiEnabled()}. */
     @Test
     public void testIsWifiEnabled() throws DeviceNotAvailableException {
+        mTestDevice =
+                new TestableAndroidNativeDevice() {
+                    @Override
+                    public boolean enableAdbRoot() throws DeviceNotAvailableException {
+                        return false;
+                    }
+
+                    @Override
+                    IWifiHelper createWifiHelper() throws DeviceNotAvailableException {
+                        return mMockWifi;
+                    }
+
+                    @Override
+                    IWifiHelper createWifiHelper(boolean useV2) throws DeviceNotAvailableException {
+                        return mMockWifi;
+                    }
+                };
         when(mMockWifi.isWifiEnabled()).thenReturn(true);
 
         assertTrue(mTestDevice.isWifiEnabled());
@@ -1277,6 +1328,23 @@ public class NativeDeviceTest {
      */
     @Test
     public void testIsWifiEnabled_exception() throws DeviceNotAvailableException {
+        mTestDevice =
+                new TestableAndroidNativeDevice() {
+                    @Override
+                    public boolean enableAdbRoot() throws DeviceNotAvailableException {
+                        return false;
+                    }
+
+                    @Override
+                    IWifiHelper createWifiHelper() throws DeviceNotAvailableException {
+                        return mMockWifi;
+                    }
+
+                    @Override
+                    IWifiHelper createWifiHelper(boolean useV2) throws DeviceNotAvailableException {
+                        return mMockWifi;
+                    }
+                };
         when(mMockWifi.isWifiEnabled()).thenThrow(new RuntimeException());
 
         assertFalse(mTestDevice.isWifiEnabled());
@@ -1344,6 +1412,23 @@ public class NativeDeviceTest {
     /** Unit test for {@link NativeDevice#reconnectToWifiNetwork()}. */
     @Test
     public void testReconnectToWifiNetwork() throws DeviceNotAvailableException {
+        mTestDevice =
+                new TestableAndroidNativeDevice() {
+                    @Override
+                    public boolean enableAdbRoot() throws DeviceNotAvailableException {
+                        return false;
+                    }
+
+                    @Override
+                    IWifiHelper createWifiHelper() throws DeviceNotAvailableException {
+                        return mMockWifi;
+                    }
+
+                    @Override
+                    IWifiHelper createWifiHelper(boolean useV2) throws DeviceNotAvailableException {
+                        return mMockWifi;
+                    }
+                };
         when(mMockWifi.checkConnectivity(mTestDevice.getOptions().getConnCheckUrl()))
                 .thenReturn(false, true);
 
diff --git a/javatests/com/android/tradefed/device/TestDeviceTest.java b/javatests/com/android/tradefed/device/TestDeviceTest.java
index 9b3efd8fe..46734bc0c 100644
--- a/javatests/com/android/tradefed/device/TestDeviceTest.java
+++ b/javatests/com/android/tradefed/device/TestDeviceTest.java
@@ -30,7 +30,6 @@ import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.Mockito.atLeast;
-import static org.mockito.Mockito.atLeastOnce;
 import static org.mockito.Mockito.doAnswer;
 import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.doThrow;
@@ -47,15 +46,14 @@ import com.android.ddmlib.InstallException;
 import com.android.ddmlib.InstallReceiver;
 import com.android.ddmlib.RawImage;
 import com.android.ddmlib.ShellCommandUnresponsiveException;
-import com.android.ddmlib.SplitApkInstaller;
 import com.android.ddmlib.TimeoutException;
 import com.android.ddmlib.testrunner.IRemoteAndroidTestRunner;
-import com.android.sdklib.AndroidVersion;
 import com.android.tradefed.config.OptionSetter;
 import com.android.tradefed.device.ITestDevice.ApexInfo;
 import com.android.tradefed.device.ITestDevice.MountPointInfo;
 import com.android.tradefed.device.ITestDevice.RecoveryMode;
 import com.android.tradefed.device.contentprovider.ContentProviderHandler;
+import com.android.tradefed.device.server.SplitApkInstaller;
 import com.android.tradefed.error.HarnessRuntimeException;
 import com.android.tradefed.host.HostOptions;
 import com.android.tradefed.host.IHostOptions;
@@ -822,6 +820,9 @@ public class TestDeviceTest {
                         return mMockRunUtil;
                     }
 
+                    @Override
+                    public void disableKeyguard() throws DeviceNotAvailableException {}
+
                     @Override
                     void doReboot(RebootMode rebootMode, @Nullable final String reason)
                             throws DeviceNotAvailableException, UnsupportedOperationException {}
@@ -843,7 +844,6 @@ public class TestDeviceTest {
                         Mockito.anyLong(),
                         (TimeUnit) Mockito.any());
         when(mMockStateMonitor.waitForDeviceOnline()).thenReturn(mMockIDevice);
-        injectSystemProperty(SDK_VERSION, "23");
 
         mTestDevice.executeShellCommand(testCommand, mMockReceiver);
 
@@ -864,24 +864,6 @@ public class TestDeviceTest {
         // expect post boot up steps
         verify(mMockRecovery, times(times))
                 .recoverDevice(Mockito.eq(mMockStateMonitor), Mockito.eq(false));
-        verify(mMockIDevice, times(times))
-                .executeShellCommand(
-                        Mockito.eq("dumpsys input"),
-                        Mockito.any(),
-                        Mockito.anyLong(),
-                        Mockito.eq(TimeUnit.MILLISECONDS));
-        verify(mMockIDevice, times(times))
-                .executeShellCommand(
-                        Mockito.eq(TestDevice.DISMISS_KEYGUARD_WM_CMD),
-                        (IShellOutputReceiver) Mockito.any(),
-                        Mockito.anyLong(),
-                        (TimeUnit) Mockito.any());
-        verify(mMockIDevice, times(times))
-                .executeShellCommand(
-                        Mockito.eq(TestDevice.KEYGUARD_CONTROLLER_CMD),
-                        Mockito.any(),
-                        Mockito.anyLong(),
-                        Mockito.eq(TimeUnit.MILLISECONDS));
     }
 
     private void assertRecoverySuccess()
@@ -920,6 +902,9 @@ public class TestDeviceTest {
                         return mMockRunUtil;
                     }
 
+                    @Override
+                    public void disableKeyguard() throws DeviceNotAvailableException {}
+
                     @Override
                     void doReboot(RebootMode rebootMode, @Nullable final String reason)
                             throws DeviceNotAvailableException, UnsupportedOperationException {}
@@ -954,7 +939,6 @@ public class TestDeviceTest {
                         Mockito.anyLong(),
                         (TimeUnit) Mockito.any());
         assertRecoverySuccess();
-        verifySystemProperty(SDK_VERSION, "23", 1);
     }
 
     /**
@@ -982,6 +966,9 @@ public class TestDeviceTest {
                         return true;
                     }
 
+                    @Override
+                    public void disableKeyguard() throws DeviceNotAvailableException {}
+
                     @Override
                     protected IRunUtil getRunUtil() {
                         return mMockRunUtil;
@@ -1011,7 +998,6 @@ public class TestDeviceTest {
         }
 
         assertRecoverySuccess(TestDevice.MAX_RETRY_ATTEMPTS + 1);
-        verifySystemProperty(SDK_VERSION, "23", 1);
         verify(mMockStateMonitor, times(3)).waitForDeviceOnline();
         verify(mMockIDevice, times(TestDevice.MAX_RETRY_ATTEMPTS + 1))
                 .executeShellCommand(
@@ -1950,32 +1936,6 @@ public class TestDeviceTest {
                         Mockito.eq("--apex"));
     }
 
-    /** Test SplitApkInstaller with Split Apk Not Supported */
-    @Test
-    public void testInstallPackages_splitApkNotSupported() throws Exception {
-        List<File> mLocalApks = new ArrayList<File>();
-        for (int i = 0; i < 3; i++) {
-            mLocalApks.add(File.createTempFile("test", ".apk"));
-        }
-        List<String> mInstallOptions = new ArrayList<String>();
-        try {
-            when(mMockIDevice.getVersion())
-                    .thenReturn(
-                            new AndroidVersion(
-                                    AndroidVersion.ALLOW_SPLIT_APK_INSTALLATION.getApiLevel() - 1));
-
-            SplitApkInstaller.create(mMockIDevice, mLocalApks, true, mInstallOptions);
-            verify(mMockIDevice, times(1)).getVersion();
-            fail("IllegalArgumentException expected");
-        } catch (IllegalArgumentException e) {
-            // expected
-        } finally {
-            for (File apkFile : mLocalApks) {
-                apkFile.delete();
-            }
-        }
-    }
-
     /** Test SplitApkInstaller with Split Apk Supported */
     @Test
     public void testInstallPackages_splitApkSupported() throws Exception {
@@ -1985,12 +1945,7 @@ public class TestDeviceTest {
         }
         List<String> mInstallOptions = new ArrayList<String>();
         try {
-            when(mMockIDevice.getVersion())
-                    .thenReturn(
-                            new AndroidVersion(
-                                    AndroidVersion.ALLOW_SPLIT_APK_INSTALLATION.getApiLevel()));
             SplitApkInstaller.create(mMockIDevice, mLocalApks, true, mInstallOptions);
-            verify(mMockIDevice, atLeastOnce()).getVersion();
         } finally {
             for (File apkFile : mLocalApks) {
                 apkFile.delete();
@@ -4297,6 +4252,9 @@ public class TestDeviceTest {
                     public String getProperty(String name) throws DeviceNotAvailableException {
                         return "R\n";
                     }
+
+                    @Override
+                    public void disableKeyguard() throws DeviceNotAvailableException {}
                 };
         assertTrue(mTestDevice.switchUser(10));
     }
@@ -4345,6 +4303,9 @@ public class TestDeviceTest {
                     protected long getCheckNewUserSleep() {
                         return 100;
                     }
+
+                    @Override
+                    public void disableKeyguard() throws DeviceNotAvailableException {}
                 };
         assertTrue(mTestDevice.switchUser(10));
     }
@@ -6136,18 +6097,19 @@ public class TestDeviceTest {
                 .when(spy)
                 .executeShellV2Command(Mockito.contains("content write"), (File) Mockito.any());
         doReturn(null).when(spy).uninstallPackage(Mockito.eq("android.tradefed.contentprovider"));
+        doReturn(true).when(spy).recoverDevice();
 
         try {
             boolean res = spy.pushFile(tmpFile, fakeRemotePath);
 
             assertFalse(res);
-            // Tried twice due to retry
-            verify(spy, times(2))
+            // Tried 4 times due to retry
+            verify(spy, times(4))
                     .installPackage(Mockito.any(), Mockito.anyBoolean(), Mockito.anyBoolean());
             // Since it fails, requesting the content provider again will re-do setup.
             ContentProviderHandler cp = spy.getContentProvider(mTestDevice.getCurrentUser());
             assertFalse(cp.contentProviderNotFound());
-            verify(spy, times(3))
+            verify(spy, times(4))
                     .installPackage(Mockito.any(), Mockito.anyBoolean(), Mockito.anyBoolean());
             cp.tearDown();
         } finally {
diff --git a/javatests/com/android/tradefed/device/WaitDeviceRecoveryTest.java b/javatests/com/android/tradefed/device/WaitDeviceRecoveryTest.java
index a18ca7f2a..7d3f3fd1c 100644
--- a/javatests/com/android/tradefed/device/WaitDeviceRecoveryTest.java
+++ b/javatests/com/android/tradefed/device/WaitDeviceRecoveryTest.java
@@ -17,21 +17,10 @@ package com.android.tradefed.device;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
+import static org.mockito.Mockito.doReturn;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.Mock;
-import org.mockito.Mockito;
-import org.mockito.MockitoAnnotations;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.doReturn;
-import static org.mockito.Mockito.verify;
 
 import com.android.ddmlib.IDevice;
 import com.android.helper.aoa.UsbDevice;
@@ -48,7 +37,9 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
+import org.mockito.Mock;
 import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
 
 /** Unit tests for {@link WaitDeviceRecovery}. */
 @RunWith(JUnit4.class)
@@ -79,6 +70,7 @@ public class WaitDeviceRecoveryTest {
                 };
 
         when(mMockMonitor.getSerialNumber()).thenReturn("serial");
+        when(mMockMonitor.getFastbootSerialNumber()).thenReturn("serial");
     }
 
     /**
diff --git a/javatests/com/android/tradefed/device/contentprovider/ContentProviderHandlerTest.java b/javatests/com/android/tradefed/device/contentprovider/ContentProviderHandlerTest.java
index d1b6d729a..a994f07f9 100644
--- a/javatests/com/android/tradefed/device/contentprovider/ContentProviderHandlerTest.java
+++ b/javatests/com/android/tradefed/device/contentprovider/ContentProviderHandlerTest.java
@@ -107,10 +107,11 @@ public class ContentProviderHandlerTest {
 
     @Test
     public void testSetUp_alreadyInstalled() throws Exception {
+        mProvider = new ContentProviderHandler(mMockDevice, 0);
         doReturn(true)
                 .when(mMockDevice)
                 .isPackageInstalled(
-                        ContentProviderHandler.PACKAGE_NAME, String.valueOf(TEST_USER_ID));
+                        ContentProviderHandler.PACKAGE_NAME, String.valueOf(0));
 
         assertTrue(mProvider.setUp());
     }
diff --git a/javatests/com/android/tradefed/device/internal/DeviceSnapshotHandlerTest.java b/javatests/com/android/tradefed/device/internal/DeviceSnapshotHandlerTest.java
index e2745ab87..bbe4fbd41 100644
--- a/javatests/com/android/tradefed/device/internal/DeviceSnapshotHandlerTest.java
+++ b/javatests/com/android/tradefed/device/internal/DeviceSnapshotHandlerTest.java
@@ -59,6 +59,8 @@ public class DeviceSnapshotHandlerTest {
     @Test
     public void testSnapshot() throws Exception {
         FeatureResponse.Builder responseBuilder = FeatureResponse.newBuilder();
+        responseBuilder.setResponse(
+                "Attempting snapshot device on device-1.  Snapshot finished in 999 ms.");
         when(mMockClient.triggerFeature(any(), any())).thenReturn(responseBuilder.build());
 
         mHandler.snapshotDevice(mMockDevice, "random_id");
@@ -134,6 +136,8 @@ public class DeviceSnapshotHandlerTest {
     @Test
     public void testRestoreSnapshot() throws Exception {
         FeatureResponse.Builder responseBuilder = FeatureResponse.newBuilder();
+        responseBuilder.setResponse(
+                "Attempting snapshot device on device-1.  Restoring snapshot finished in 999 ms.");
         when(mMockClient.triggerFeature(any(), any())).thenReturn(responseBuilder.build());
 
         mHandler.restoreSnapshotDevice(mMockDevice, "random_id");
@@ -219,9 +223,12 @@ public class DeviceSnapshotHandlerTest {
     @Test
     public void testDeleteSnapshot() throws Exception {
         FeatureResponse.Builder responseBuilder = FeatureResponse.newBuilder();
+        responseBuilder.setResponse(
+                "Attempting snapshot device on device-1.  Snapshot finished in 999 ms.");
         when(mMockClient.triggerFeature(any(), any())).thenReturn(responseBuilder.build());
 
         mHandler.snapshotDevice(mMockDevice, "random_id");
+        mHandler.deleteSnapshot(mMockDevice, "random_id");
     }
 
     @Test
diff --git a/javatests/com/android/tradefed/device/metric/JavaCodeCoverageCollectorTest.java b/javatests/com/android/tradefed/device/metric/JavaCodeCoverageCollectorTest.java
index 935c841af..df5e266ae 100644
--- a/javatests/com/android/tradefed/device/metric/JavaCodeCoverageCollectorTest.java
+++ b/javatests/com/android/tradefed/device/metric/JavaCodeCoverageCollectorTest.java
@@ -507,6 +507,67 @@ public class JavaCodeCoverageCollectorTest {
                 .isEqualTo(partiallyCovered);
     }
 
+    @Test
+    public void testMergeMultipleMeasurementsWithInvalidFiles_logContainsAllData()
+            throws Exception {
+        enableJavaCoverage();
+        mCoverageOptionsSetter.setOptionValue("merge-coverage", "true");
+
+        doReturn("").when(mMockDevice).executeShellCommand(anyString());
+
+        ByteString firstHalfCollector =
+                measurement(firstHalfCovered(JavaCodeCoverageCollector.class));
+        ByteString secondHalfCollector =
+                measurement(secondHalfCovered(JavaCodeCoverageCollector.class));
+        ByteString partialCollectorTest =
+                measurement(partiallyCovered(JavaCodeCoverageCollectorTest.class));
+        ByteString invalidMeasurement =
+                ByteString.copyFromUtf8("This is not a coverage measurement.");
+        File tarGz =
+                createTarGz(
+                        ImmutableMap.of(
+                                "JavaCodeCoverageColletor1.ec",
+                                firstHalfCollector,
+                                "JavaCodeCoverageCollector2.ec",
+                                secondHalfCollector,
+                                "JavaCodeCoverageCollectorTest.ec",
+                                partialCollectorTest,
+                                "InvalidMeasurement.ec",
+                                invalidMeasurement));
+        returnFileContentsOnShellCommand(mMockDevice, tarGz);
+
+        // Simulate a test run.
+        mCodeCoverageCollector.init(mMockContext, mFakeListener);
+        mCodeCoverageCollector.testRunStarted(RUN_NAME, TEST_COUNT);
+        mCodeCoverageCollector.testRunEnded(ELAPSED_TIME, new HashMap<String, Metric>());
+
+        // Validate the logged coverage data.
+        ArgumentCaptor<ByteString> stream = ArgumentCaptor.forClass(ByteString.class);
+        verify(mFakeListener).testLog(anyString(), eq(LogDataType.COVERAGE), stream.capture());
+
+        ExecFileLoader execFileLoader = new ExecFileLoader();
+        execFileLoader.load(stream.getValue().newInput());
+
+        ExecutionDataStore execData = execFileLoader.getExecutionDataStore();
+
+        // Check coverage data for JavaCodeCoverageCollector. All probes should be true if the data
+        // merged successfully.
+        boolean[] fullyCovered = new boolean[PROBE_COUNT];
+        Arrays.fill(fullyCovered, Boolean.TRUE);
+
+        assertThat(execData.contains(vmName(JavaCodeCoverageCollector.class))).isTrue();
+        assertThat(getProbes(JavaCodeCoverageCollector.class, execData)).isEqualTo(fullyCovered);
+
+        // Check coverage data for JavaCodeCoverageCollectorTest. Only the first probe should be
+        // true.
+        boolean[] partiallyCovered = new boolean[PROBE_COUNT];
+        partiallyCovered[0] = true;
+
+        assertThat(execData.contains(vmName(JavaCodeCoverageCollectorTest.class))).isTrue();
+        assertThat(getProbes(JavaCodeCoverageCollectorTest.class, execData))
+                .isEqualTo(partiallyCovered);
+    }
+
     @Test
     public void javaCodeCoverageCollector_rootAndUnrootDeviceTwice() throws Exception {
         enableJavaCoverage();
diff --git a/javatests/com/android/tradefed/device/metric/PerfettoFilePullerCollectorTest.java b/javatests/com/android/tradefed/device/metric/PerfettoFilePullerCollectorTest.java
new file mode 100644
index 000000000..d81d63b32
--- /dev/null
+++ b/javatests/com/android/tradefed/device/metric/PerfettoFilePullerCollectorTest.java
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.device.metric;
+
+import static org.mockito.Mockito.doReturn;
+
+import com.android.tradefed.config.OptionSetter;
+import com.android.tradefed.device.ITestDevice;
+import com.android.tradefed.device.TestDeviceState;
+import com.android.tradefed.invoker.IInvocationContext;
+import com.android.tradefed.invoker.InvocationContext;
+import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
+import com.android.tradefed.result.ITestInvocationListener;
+import com.android.tradefed.result.LogDataType;
+import com.android.tradefed.result.TestDescription;
+import com.android.tradefed.util.proto.TfMetricProtoUtil;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
+
+import java.io.File;
+import java.util.HashMap;
+
+/** Unit tests for {@link PerfettoFilePullerCollector}. */
+@RunWith(JUnit4.class)
+public class PerfettoFilePullerCollectorTest {
+
+    private PerfettoFilePullerCollector mCollector;
+    @Mock private ITestInvocationListener mMockListener;
+    @Mock private ITestDevice mMockDevice;
+
+    @Before
+    public void setUp() throws Exception {
+        MockitoAnnotations.initMocks(this);
+
+        IInvocationContext context = new InvocationContext();
+        doReturn(TestDeviceState.ONLINE).when(mMockDevice).getDeviceState();
+        context.addAllocatedDevice("default", mMockDevice);
+
+        mCollector = Mockito.spy(new PerfettoFilePullerCollector());
+        mCollector.init(context, mMockListener);
+    }
+
+    private void triggerCollector(HashMap<String, Metric> currentMetrics) {
+        TestDescription description = new TestDescription("xyz", "abc");
+
+        mCollector.testRunStarted("runName", 1);
+        mCollector.testStarted(description);
+        mCollector.testEnded(description, currentMetrics);
+        mCollector.testRunEnded(100L, new HashMap<String, Metric>());
+    }
+
+    @Test
+    public void testPullDefault() throws Exception {
+        String traceFileName = "trace.perfetto-trace";
+        String traceDevicePath = "/data/" + traceFileName;
+
+        OptionSetter setter = new OptionSetter(mCollector);
+        setter.setOptionValue("pull-pattern-keys", "perfetto_file_path");
+
+        HashMap<String, Metric> currentMetrics = new HashMap<>();
+        currentMetrics.put("perfetto_file_path", TfMetricProtoUtil.stringToMetric(traceDevicePath));
+
+        Mockito.when(mMockDevice.pullFile(Mockito.eq(traceDevicePath), Mockito.eq(0)))
+                .thenReturn(new File(traceFileName));
+
+        triggerCollector(currentMetrics);
+
+        // Verify that pullFile() was called and the trace file was added to the test logs.
+        Mockito.verify(mMockDevice).pullFile(Mockito.eq(traceDevicePath), Mockito.eq(0));
+        Mockito.verify(mMockListener)
+                .testLog(
+                        Mockito.eq(traceFileName), Mockito.eq(LogDataType.PERFETTO), Mockito.any());
+    }
+
+    @Test
+    public void testPullNoFiles() throws Exception {
+        String traceFileName = "trace.perfetto-trace";
+        String traceDevicePath = "/data/" + traceFileName;
+
+        OptionSetter setter = new OptionSetter(mCollector);
+        setter.setOptionValue("pull-pattern-keys", "perfetto_file_path");
+
+        // No perfetto file path is specified in the metrics.
+        HashMap<String, Metric> currentMetrics = new HashMap<>();
+
+        Mockito.when(mMockDevice.pullFile(Mockito.eq(traceDevicePath), Mockito.eq(0)))
+                .thenReturn(new File(traceFileName));
+
+        triggerCollector(currentMetrics);
+
+        // Verify that pullFile() and testLog() were not called.
+        Mockito.verify(mMockDevice, Mockito.times(0)).pullFile(Mockito.any());
+        Mockito.verify(mMockListener, Mockito.times(0))
+                .testLog(Mockito.any(), Mockito.any(), Mockito.any());
+    }
+
+    @Test
+    public void testPullCompressed() throws Exception {
+        String traceFileName = "trace.perfetto-trace";
+        String traceDevicePath = "/data/" + traceFileName;
+
+        OptionSetter setter = new OptionSetter(mCollector);
+        setter.setOptionValue("pull-pattern-keys", "perfetto_file_path");
+        setter.setOptionValue("compress-perfetto", "true");
+
+        HashMap<String, Metric> currentMetrics = new HashMap<>();
+        currentMetrics.put("perfetto_file_path", TfMetricProtoUtil.stringToMetric(traceDevicePath));
+
+        Mockito.when(mMockDevice.pullFile(Mockito.eq(traceDevicePath), Mockito.eq(0)))
+                .thenReturn(new File(traceFileName));
+
+        triggerCollector(currentMetrics);
+
+        // Verify that pullFile() was not called.
+        Mockito.verify(mMockDevice, Mockito.times(0)).pullFile(Mockito.eq(traceDevicePath));
+
+        // Verify that a compressed trace file was added to the test logs.
+        Mockito.verify(mMockListener)
+                .testLog(
+                        Mockito.matches(String.format("%s.*.gz", traceFileName)),
+                        Mockito.eq(LogDataType.GZIP),
+                        Mockito.any());
+    }
+}
diff --git a/javatests/com/android/tradefed/observatory/TestZipDiscoveryExecutorTest.java b/javatests/com/android/tradefed/observatory/TestZipDiscoveryExecutorTest.java
new file mode 100644
index 000000000..79b11b860
--- /dev/null
+++ b/javatests/com/android/tradefed/observatory/TestZipDiscoveryExecutorTest.java
@@ -0,0 +1,373 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.observatory;
+
+import com.android.tradefed.build.IBuildProvider;
+import com.android.tradefed.command.ICommandOptions;
+import com.android.tradefed.config.Configuration;
+import com.android.tradefed.config.IConfiguration;
+import com.android.tradefed.config.IDeviceConfiguration;
+import com.android.tradefed.config.OptionSetter;
+import com.android.tradefed.sandbox.SandboxOptions;
+import com.android.tradefed.sandbox.TradefedSandbox; // For calling its static method directly
+import com.android.tradefed.testtype.IRemoteTest;
+import com.android.tradefed.testtype.suite.ITestSuite;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import java.util.Set;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.lenient;
+import static org.mockito.Mockito.mock;
+
+import static org.mockito.Mockito.when;
+import static org.mockito.Mockito.withSettings;
+
+/** Unit tests for {@link TestZipDiscoveryExecutor}. */
+@RunWith(JUnit4.class)
+public class TestZipDiscoveryExecutorTest {
+
+    private TestDiscoveryUtil mTestDiscoveryUtil;
+    private IConfiguration mMockConfiguration;
+    private ICommandOptions mMockCommandOptions;
+    private IDeviceConfiguration mMockDeviceConfiguration;
+    private IBuildProvider mMockDiscoverableBuildProvider;
+    private ITestSuite mMockTestSuite;
+    private IRemoteTest mMockRemoteTest;
+
+    private TestZipDiscoveryExecutor mTestZipDiscoveryExecutor;
+
+    @Before
+    public void setUp() throws Exception {
+        mTestDiscoveryUtil = mock(TestDiscoveryUtil.class);
+        mMockConfiguration = mock(IConfiguration.class);
+        mMockCommandOptions = mock(com.android.tradefed.command.ICommandOptions.class);
+        mMockDeviceConfiguration = mock(IDeviceConfiguration.class);
+        mMockDiscoverableBuildProvider =
+                mock(
+                        IBuildProvider.class,
+                        withSettings().extraInterfaces(IDiscoverDependencies.class));
+        mMockTestSuite = mock(ITestSuite.class);
+        mMockRemoteTest = mock(IRemoteTest.class);
+
+        mTestZipDiscoveryExecutor = new TestZipDiscoveryExecutor(mTestDiscoveryUtil);
+
+        // Default behaviors for instance mocks
+        when(mTestDiscoveryUtil.getConfiguration(any(String[].class)))
+                .thenReturn(mMockConfiguration);
+        when(mMockConfiguration.getCommandOptions()).thenReturn(mMockCommandOptions);
+        when(mMockConfiguration.getTests()).thenReturn(Collections.singletonList(mMockRemoteTest));
+        when(mMockConfiguration.getName()).thenReturn("mockConfig");
+
+        lenient().when(mMockCommandOptions.shouldUseSandboxing()).thenReturn(false);
+        lenient().when(mMockCommandOptions.shouldUseRemoteSandboxMode()).thenReturn(false);
+        lenient()
+                .when(mMockConfiguration.getConfigurationObject(Configuration.SANBOX_OPTIONS_TYPE_NAME))
+                .thenReturn(null);
+    }
+
+    @After
+    public void tearDown() {
+        // Reset the static field in the class under test
+        new TestZipDiscoveryExecutor(null);
+    }
+
+    private void assertJsonOutput(String jsonString, Set<String> expectedZips, boolean noPossibleDiscovery)
+            throws JSONException {
+        JSONObject json = new JSONObject(jsonString);
+        assertTrue(
+                "JSON output missing '" + TestDiscoveryInvoker.TEST_ZIP_REGEXES_LIST_KEY + "' key.",
+                json.has(TestDiscoveryInvoker.TEST_ZIP_REGEXES_LIST_KEY));
+        JSONArray zipsArray = json.getJSONArray(TestDiscoveryInvoker.TEST_ZIP_REGEXES_LIST_KEY);
+        assertEquals(
+                "Number of zips in JSON output does not match expected.",
+                expectedZips.size(),
+                zipsArray.length());
+        Set<String> actualZips = new LinkedHashSet<>();
+        for (int i = 0; i < zipsArray.length(); i++) {
+            actualZips.add(zipsArray.getString(i));
+        }
+        assertEquals("Set of zips in JSON output does not match expected.", expectedZips, actualZips);
+
+        if (noPossibleDiscovery) {
+            assertTrue(
+                    "JSON output missing '"
+                            + TestDiscoveryInvoker.NO_POSSIBLE_TEST_DISCOVERY_KEY
+                            + "' key when expected.",
+                    json.has(TestDiscoveryInvoker.NO_POSSIBLE_TEST_DISCOVERY_KEY));
+            assertEquals(
+                    "Value of '"
+                            + TestDiscoveryInvoker.NO_POSSIBLE_TEST_DISCOVERY_KEY
+                            + "' not 'true' as expected.",
+                    "true",
+                    json.getString(TestDiscoveryInvoker.NO_POSSIBLE_TEST_DISCOVERY_KEY));
+        } else {
+            assertFalse(
+                    "JSON output has '"
+                            + TestDiscoveryInvoker.NO_POSSIBLE_TEST_DISCOVERY_KEY
+                            + "' key when not expected.",
+                    json.has(TestDiscoveryInvoker.NO_POSSIBLE_TEST_DISCOVERY_KEY));
+        }
+    }
+
+    // --- Tests for nonTradefedDiscovery ---
+
+    @Test
+    public void discoverTestZips_nonTradefed_unusedAndLiblyric_returnsCameraHalZip() throws Exception {
+        String[] args = {"unused", "some-liblyric-arg"};
+        when(mTestDiscoveryUtil.isTradefedConfiguration(args)).thenReturn(false);
+        String result = mTestZipDiscoveryExecutor.discoverTestZips(args);
+        assertJsonOutput(result, Collections.singleton("camera-hal-tests.zip"), false);
+    }
+
+    @Test
+    public void discoverTestZips_nonTradefed_haiku_returnsHaikuPresubmitZip() throws Exception {
+        String[] args = {"contains_haiku_keyword"};
+        when(mTestDiscoveryUtil.isTradefedConfiguration(args)).thenReturn(false);
+        String result = mTestZipDiscoveryExecutor.discoverTestZips(args);
+        assertJsonOutput(result, Collections.singleton("haiku-presubmit"), false);
+    }
+
+    @Test
+    public void discoverTestZips_nonTradefed_mobly_returnsGeneralTestsZip() throws Exception {
+        String[] args = {"some_mobly_stuff"};
+        when(mTestDiscoveryUtil.isTradefedConfiguration(args)).thenReturn(false);
+        String result = mTestZipDiscoveryExecutor.discoverTestZips(args);
+        assertJsonOutput(result, Collections.singleton("general-tests.zip"), false);
+    }
+
+    @Test
+    public void discoverTestZips_nonTradefed_multipleMatches_returnsAllZips() throws Exception {
+        String[] args = {"contains_haiku_keyword", "some_mobly_stuff"};
+        when(mTestDiscoveryUtil.isTradefedConfiguration(args)).thenReturn(false);
+        String result = mTestZipDiscoveryExecutor.discoverTestZips(args);
+        assertJsonOutput(result, new LinkedHashSet<>(Arrays.asList("haiku-presubmit", "general-tests.zip")), false);
+    }
+
+    @Test
+    public void discoverTestZips_nonTradefed_noMatches_returnsEmptySet() throws Exception {
+        String[] args = {"random_arg"};
+        when(mTestDiscoveryUtil.isTradefedConfiguration(args)).thenReturn(false);
+        String result = mTestZipDiscoveryExecutor.discoverTestZips(args);
+        assertJsonOutput(result, Collections.emptySet(), false);
+    }
+
+    // --- Tests for Tradefed discovery path ---
+
+    @Test
+    public void discoverTestZips_tradefed_noTestsFound_throwsTestDiscoveryException() throws Exception {
+        String[] args = {"config.xml"};
+        when(mTestDiscoveryUtil.isTradefedConfiguration(args)).thenReturn(true);
+        when(mMockConfiguration.getTests()).thenReturn(null);
+        try {
+            mTestZipDiscoveryExecutor.discoverTestZips(args);
+            fail("Should have thrown TestDiscoveryException for no tests found.");
+        } catch (TestDiscoveryException e) {
+            assertTrue(e.getMessage().contains("Tradefed Observatory discovered no tests from the IConfiguration"));
+            assertEquals(DiscoveryExitCode.ERROR, e.exitCode());
+        }
+    }
+
+    @Test
+    public void discoverTestZips_tradefed_emptyTestsFound_throwsTestDiscoveryException() throws Exception {
+        String[] args = {"config.xml"};
+        when(mTestDiscoveryUtil.isTradefedConfiguration(args)).thenReturn(true);
+        when(mMockConfiguration.getTests()).thenReturn(Collections.emptyList());
+        try {
+            mTestZipDiscoveryExecutor.discoverTestZips(args);
+            fail("Should have thrown TestDiscoveryException for empty test list.");
+        } catch (TestDiscoveryException e) {
+            assertTrue(e.getMessage().contains("Tradefed Observatory discovered no tests from the IConfiguration"));
+            assertEquals(DiscoveryExitCode.ERROR, e.exitCode());
+        }
+    }
+
+    @Test
+    public void discoverTestZips_tradefed_useSandboxing_addsDefaultTradefedZips() throws Exception {
+        String[] args = {"config.xml", "--use-sandboxing"};
+        when(mTestDiscoveryUtil.isTradefedConfiguration(args)).thenReturn(true);
+        when(mMockCommandOptions.shouldUseSandboxing()).thenReturn(true);
+        String result = mTestZipDiscoveryExecutor.discoverTestZips(args);
+        Set<String> expectedZips =
+                new LinkedHashSet<>(
+                        Arrays.asList(
+                                "tradefed.zip",
+                                "tradefed-all.zip",
+                                "google-tradefed.zip",
+                                "google-tradefed-all.zip"));
+        assertJsonOutput(result, expectedZips, false);
+    }
+
+    @Test
+    public void discoverTestZips_tradefed_useRemoteSandboxMode_addsDefaultTradefedZips() throws Exception {
+        String[] args = {"config.xml", "--use-remote-sandbox-mode"};
+        when(mTestDiscoveryUtil.isTradefedConfiguration(args)).thenReturn(true);
+        when(mMockCommandOptions.shouldUseRemoteSandboxMode()).thenReturn(true);
+        String result = mTestZipDiscoveryExecutor.discoverTestZips(args);
+        Set<String> expectedZips =
+                new LinkedHashSet<>(
+                        Arrays.asList(
+                                "tradefed.zip",
+                                "tradefed-all.zip",
+                                "google-tradefed.zip",
+                                "google-tradefed-all.zip"));
+        assertJsonOutput(result, expectedZips, false);
+    }
+
+    @Test
+    public void discoverTestZips_tradefed_sandboxOptionsWithCustomZips_addsCustomZips() throws Exception {
+        String[] args = {"config.xml"};
+        when(mTestDiscoveryUtil.isTradefedConfiguration(args)).thenReturn(true);
+        SandboxOptions realSandboxOptions = new SandboxOptions();
+        OptionSetter setter = new OptionSetter(realSandboxOptions);
+        setter.setOptionValue("sandbox-tests-zips", "custom-sandbox-1.zip");
+        setter.setOptionValue("sandbox-tests-zips", "custom-sandbox-2.zip");
+        when(mMockConfiguration.getConfigurationObject(Configuration.SANBOX_OPTIONS_TYPE_NAME))
+                .thenReturn(realSandboxOptions);
+        String result = mTestZipDiscoveryExecutor.discoverTestZips(args);
+        Set<String> expectedZips = new LinkedHashSet<>(Arrays.asList("custom-sandbox-1.zip", "custom-sandbox-2.zip"));
+        assertJsonOutput(result, expectedZips, false);
+    }
+
+    @Test
+    public void discoverTestZips_tradefed_deviceConfigWithDiscoverDependencies_addsProviderZips() throws Exception {
+        String[] args = {"config.xml"};
+        when(mTestDiscoveryUtil.isTradefedConfiguration(args)).thenReturn(true);
+        when(mMockConfiguration.getDeviceConfig()).thenReturn(Collections.singletonList(mMockDeviceConfiguration));
+        when(mMockDeviceConfiguration.getBuildProvider()).thenReturn(mMockDiscoverableBuildProvider);
+        Set<String> providerZips = Collections.singleton("provider-dep.zip");
+        when(((IDiscoverDependencies) mMockDiscoverableBuildProvider).reportTestZipFileFilter())
+                .thenReturn(providerZips);
+        String result = mTestZipDiscoveryExecutor.discoverTestZips(args);
+        assertJsonOutput(result, providerZips, false);
+    }
+
+    @Test
+    public void discoverTestZips_tradefed_deviceConfigWithDiscoverDependenciesReturnsNull_noCrash() throws Exception {
+        String[] args = {"config.xml"};
+        when(mTestDiscoveryUtil.isTradefedConfiguration(args)).thenReturn(true);
+        when(mMockConfiguration.getDeviceConfig()).thenReturn(Collections.singletonList(mMockDeviceConfiguration));
+        when(mMockDeviceConfiguration.getBuildProvider()).thenReturn(mMockDiscoverableBuildProvider);
+        when(((IDiscoverDependencies) mMockDiscoverableBuildProvider).reportTestZipFileFilter())
+                .thenReturn(null);
+        String result = mTestZipDiscoveryExecutor.discoverTestZips(args);
+        assertJsonOutput(result, Collections.emptySet(), false);
+    }
+
+    @Test
+    public void discoverTestZips_tradefed_testSuiteWithSandboxMatching_addsExtraTargets() throws Exception {
+        String[] args = {"config.xml"};
+        String configName = "cts-suite"; // Example: ensure this name has known behavior with real static method
+        when(mTestDiscoveryUtil.isTradefedConfiguration(args)).thenReturn(true);
+        when(mMockConfiguration.getTests()).thenReturn(Collections.singletonList(mMockTestSuite));
+        SandboxOptions realSandboxOptions = new SandboxOptions();
+        OptionSetter setter = new OptionSetter(realSandboxOptions);
+        setter.setOptionValue("sandbox-default-zips", "true");
+        when(mMockConfiguration.getConfigurationObject(Configuration.SANBOX_OPTIONS_TYPE_NAME))
+                .thenReturn(realSandboxOptions);
+        when(mMockConfiguration.getName()).thenReturn(configName);
+
+        // Calling the REAL static method.
+        Set<String> expectedZipsFromRealStaticMethod = TradefedSandbox.matchSandboxExtraBuildTargetByConfigName(configName);
+        System.out.println("Note: Test 'discoverTestZips_tradefed_testSuiteWithSandboxMatching_addsExtraTargets' " +
+                "is calling the real TradefedSandbox.matchSandboxExtraBuildTargetByConfigName for config: '" + configName +
+                "'. Expected output based on real method: " + expectedZipsFromRealStaticMethod);
+
+        String result = mTestZipDiscoveryExecutor.discoverTestZips(args);
+        assertJsonOutput(result, expectedZipsFromRealStaticMethod, false);
+    }
+
+
+    @Test
+    public void discoverTestZips_tradefed_nullTestZipInSetFromBuildProvider_throwsTestDiscoveryException() throws Exception {
+        String[] args = {"config.xml"};
+        when(mTestDiscoveryUtil.isTradefedConfiguration(args)).thenReturn(true);
+        when(mMockConfiguration.getDeviceConfig()).thenReturn(Collections.singletonList(mMockDeviceConfiguration));
+        when(mMockDeviceConfiguration.getBuildProvider()).thenReturn(mMockDiscoverableBuildProvider);
+        Set<String> zipsWithNull = new LinkedHashSet<>();
+        zipsWithNull.add("valid.zip");
+        zipsWithNull.add(null);
+        when(((IDiscoverDependencies) mMockDiscoverableBuildProvider).reportTestZipFileFilter())
+                .thenReturn(zipsWithNull);
+        try {
+            mTestZipDiscoveryExecutor.discoverTestZips(args);
+            fail("Should have thrown TestDiscoveryException for null regex from build provider.");
+        } catch (TestDiscoveryException e) {
+            assertTrue(e.getMessage().contains("discovered null test zip regex"));
+            assertEquals(DiscoveryExitCode.DISCOVERY_RESULTS_CORREPUTED, e.exitCode());
+        }
+    }
+
+    @Test
+    public void discoverTestZips_tradefed_noDiscoveriesMade_reportNoPossibleDiscoveryTrue() throws Exception {
+        String[] args = {"config.xml"};
+        when(mTestDiscoveryUtil.isTradefedConfiguration(args)).thenReturn(true);
+        when(mMockCommandOptions.shouldUseSandboxing()).thenReturn(false);
+        when(mMockCommandOptions.shouldUseRemoteSandboxMode()).thenReturn(false);
+        when(mMockConfiguration.getConfigurationObject(Configuration.SANBOX_OPTIONS_TYPE_NAME)).thenReturn(null);
+        when(mMockConfiguration.getDeviceConfig()).thenReturn(Collections.emptyList());
+        when(mMockConfiguration.getTests()).thenReturn(Collections.singletonList(mMockRemoteTest));
+        String result = mTestZipDiscoveryExecutor.discoverTestZips(args);
+        assertJsonOutput(result, Collections.emptySet(), true);
+    }
+
+    @Test
+    public void discoverTestZips_tradefed_hasOutputResultFile_executesWithoutError() throws Exception {
+        System.out.println("Note: Static logging calls (DdmPreferences, Log, LogRegistry) " +
+                "will use real implementations. This test only checks for runtime errors in this path.");
+        String[] args = {"config.xml"};
+        when(mTestDiscoveryUtil.isTradefedConfiguration(args)).thenReturn(true);
+        when(mTestDiscoveryUtil.hasOutputResultFile()).thenReturn(true);
+
+        try {
+            mTestZipDiscoveryExecutor.discoverTestZips(args);
+        } catch (Exception e) {
+            // Log the exception and fail, as this path should ideally not throw an unexpected error
+            // even with real static calls, unless the real static calls themselves are problematic
+            // in a test environment (e.g. LogRegistry.getLogRegistry().unregisterLogger() failing).
+            e.printStackTrace();
+            fail("discoverTestZips threw an unexpected exception when hasOutputResultFile=true: " + e.getMessage());
+        }
+        assertTrue("Test for hasOutputResultFile=true path completed execution.", true);
+    }
+
+    @Test
+    public void discoverTestZips_tradefed_doesNotHaveOutputResultFile_executesWithoutError() throws Exception {
+        String[] args = {"config.xml"};
+        when(mTestDiscoveryUtil.isTradefedConfiguration(args)).thenReturn(true);
+        when(mTestDiscoveryUtil.hasOutputResultFile()).thenReturn(false); // Key condition
+
+        mTestZipDiscoveryExecutor.discoverTestZips(args); // Should execute without error
+
+        assertTrue("Test for hasOutputResultFile=false path completed execution.", true);
+    }
+}
\ No newline at end of file
diff --git a/javatests/com/android/tradefed/postprocessor/PerfettoGenericPostProcessorTest.java b/javatests/com/android/tradefed/postprocessor/PerfettoGenericPostProcessorTest.java
index 11d9a1f18..eb95d100a 100644
--- a/javatests/com/android/tradefed/postprocessor/PerfettoGenericPostProcessorTest.java
+++ b/javatests/com/android/tradefed/postprocessor/PerfettoGenericPostProcessorTest.java
@@ -51,7 +51,9 @@ import java.io.FileOutputStream;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
+import java.util.Arrays;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
 
 /** Unit tests for {@link PerfettoGenericPostProcessor}. */
@@ -127,8 +129,8 @@ public class PerfettoGenericPostProcessorTest {
         Map<String, Metric.Builder> parsedMetrics =
                 mProcessor.processRunMetricsAndLogs(new HashMap<>(), testLogs);
 
-        assertMetricsContain(parsedMetrics, "perfetto_android_startup-startup-1-startup_id", 1);
-        assertMetricsContain(
+        assertMetricsContainString(parsedMetrics, "perfetto_android_startup-startup-1-startup_id", 1);
+        assertMetricsContainString(
                 parsedMetrics,
                 "perfetto_android_startup-startup-1-package_name-com.google."
                         + "android.apps.nexuslauncher-to_first_frame-dur_ns",
@@ -159,8 +161,8 @@ public class PerfettoGenericPostProcessorTest {
 
         assertFalse("Metric key not expected but found",
                 parsedMetrics.containsKey("android_startup-startup-1-startup_id"));
-        assertMetricsContain(parsedMetrics, "perfetto_newprefix-startup_id", 1);
-        assertMetricsContain(
+        assertMetricsContainString(parsedMetrics, "perfetto_newprefix-startup_id", 1);
+        assertMetricsContainString(
                 parsedMetrics,
                 "perfetto_newprefix-package_name-com.google."
                         + "android.apps.nexuslauncher-to_first_frame-dur_ns",
@@ -185,7 +187,7 @@ public class PerfettoGenericPostProcessorTest {
         Map<String, Metric.Builder> parsedMetrics =
                 mProcessor.processRunMetricsAndLogs(new HashMap<>(), testLogs);
         // Test for non startup metrics exists.
-        assertMetricsContain(
+        assertMetricsContainString(
                 parsedMetrics,
                 "perfetto_android_mem-process_metrics-process_name-"
                         + ".dataservices-total_counters-anon_rss-min",
@@ -206,7 +208,7 @@ public class PerfettoGenericPostProcessorTest {
         Map<String, Metric.Builder> parsedMetrics =
                 mProcessor.processTestMetricsAndLogs(
                         new TestDescription("class", "test"), new HashMap<>(), testLogs);
-        assertMetricsContain(
+        assertMetricsContainString(
                 parsedMetrics,
                 "perfetto_android_mem-process_metrics-process_name-"
                         + ".dataservices-total_counters-anon_rss-min",
@@ -228,7 +230,7 @@ public class PerfettoGenericPostProcessorTest {
         Map<String, Metric.Builder> parsedMetrics =
                 mProcessor.processTestMetricsAndLogs(
                         new TestDescription("class", "test"), new HashMap<>(), testLogs);
-        assertMetricsContain(
+        assertMetricsContainString(
                 parsedMetrics,
                 "custom_all_prefix_android_mem-process_metrics-process_name-"
                         + ".dataservices-total_counters-anon_rss-min",
@@ -248,7 +250,7 @@ public class PerfettoGenericPostProcessorTest {
                         perfettoMetricProtoFile.getAbsolutePath(), "some.url", LogDataType.TEXTPB));
         Map<String, Metric.Builder> parsedMetrics =
                 mProcessor.processRunMetricsAndLogs(new HashMap<>(), testLogs);
-        assertMetricsContain(
+        assertMetricsContainString(
                 parsedMetrics,
                 "perfetto_android_mem-process_metrics-process_name-"
                         + ".dataservices-total_counters-anon_rss-min",
@@ -271,8 +273,8 @@ public class PerfettoGenericPostProcessorTest {
                         perfettoMetricProtoFile.getAbsolutePath(), "some.url", LogDataType.TEXTPB));
         Map<String, Metric.Builder> parsedMetrics =
                 mProcessor.processRunMetricsAndLogs(new HashMap<>(), testLogs);
-        assertMetricsContain(parsedMetrics, "perfetto_android_startup-startup-startup_id", 2);
-        assertMetricsContain(
+        assertMetricsContainString(parsedMetrics, "perfetto_android_startup-startup-startup_id", 2);
+        assertMetricsContainString(
                 parsedMetrics,
                 "perfetto_android_startup-startup-package_name-com.google."
                         + "android.apps.nexuslauncher-to_first_frame-dur_ns",
@@ -297,14 +299,14 @@ public class PerfettoGenericPostProcessorTest {
         Map<String, Metric.Builder> parsedMetrics =
                 mProcessor.processRunMetricsAndLogs(new HashMap<>(), testLogs);
 
-        assertMetricsContain(parsedMetrics, "perfetto_android_startup-startup-1-startup_id", 1);
-        assertMetricsContain(
+        assertMetricsContainString(parsedMetrics, "perfetto_android_startup-startup-1-startup_id", 1);
+        assertMetricsContainString(
                 parsedMetrics,
                 "perfetto_android_startup-startup-1-package_name-com.google."
                         + "android.apps.nexuslauncher-to_first_frame-dur_ns",
                 36175473);
-        assertMetricsContain(parsedMetrics, "perfetto_android_startup-startup-2-startup_id", 2);
-        assertMetricsContain(
+        assertMetricsContainString(parsedMetrics, "perfetto_android_startup-startup-2-startup_id", 2);
+        assertMetricsContainString(
                 parsedMetrics,
                 "perfetto_android_startup-startup-2-package_name-com.google."
                         + "android.apps.nexuslauncher-to_first_frame-dur_ns",
@@ -328,7 +330,7 @@ public class PerfettoGenericPostProcessorTest {
         Map<String, Metric.Builder> parsedMetrics = mProcessor
                 .processRunMetricsAndLogs(new HashMap<>(), testLogs);
 
-        assertMetricsContain(
+        assertMetricsContainString(
                 parsedMetrics,
                 "perfetto_android_hwui_metric-process_info-process_name-com.android.systemui-all_mem_min",
                 15120269);
@@ -353,7 +355,7 @@ public class PerfettoGenericPostProcessorTest {
         Map<String, Metric.Builder> parsedMetrics = mProcessor
                 .processRunMetricsAndLogs(new HashMap<>(), testLogs);
 
-        assertMetricsContain(
+        assertMetricsContainString(
                 parsedMetrics,
                 "perfetto_android_hwui_metric-process_info-process_name-com.android.systemui-"
                 + "rt_cpu_time_ms-2481-all_mem_min",
@@ -376,7 +378,7 @@ public class PerfettoGenericPostProcessorTest {
                         perfettoMetricProtoFile.getAbsolutePath(), "some.url", LogDataType.TEXTPB));
         Map<String, Metric.Builder> parsedMetrics = mProcessor
                 .processRunMetricsAndLogs(new HashMap<>(), testLogs);
-        assertMetricsContain(parsedMetrics, "perfetto_android_cpu-process_info-name-com.google."
+        assertMetricsContainString(parsedMetrics, "perfetto_android_cpu-process_info-name-com.google."
                 + "android.apps.messaging-threads-name-BG Thread #1-core-id-1-metrics-runtime_ns",
                 14376405);
     }
@@ -395,7 +397,7 @@ public class PerfettoGenericPostProcessorTest {
                 new LogFile(perfettoMetricProtoFile.getAbsolutePath(), "some.url", LogDataType.PB));
         Map<String, Metric.Builder> parsedMetrics =
                 mProcessor.processRunMetricsAndLogs(new HashMap<>(), testLogs);
-        assertMetricsContain(
+        assertMetricsContainString(
                 parsedMetrics,
                 "perfetto_android_mem-process_metrics-process_name-"
                         + ".dataservices-total_counters-anon_rss-min",
@@ -438,7 +440,7 @@ public class PerfettoGenericPostProcessorTest {
                         perfettoMetricProtoFile.getAbsolutePath(), "some.url", LogDataType.TEXTPB));
         Map<String, Metric.Builder> parsedMetrics =
                 mProcessor.processRunMetricsAndLogs(new HashMap<>(), testLogs);
-        assertMetricsContain(
+        assertMetricsContainString(
                 parsedMetrics,
                 "perfetto_android_mem-process_metrics-process_name-"
                         + ".dataservices-total_counters-anon_rss-min",
@@ -469,7 +471,7 @@ public class PerfettoGenericPostProcessorTest {
         Map<String, Metric.Builder> parsedMetrics =
                 mProcessor.processRunMetricsAndLogs(new HashMap<>(), testLogs);
 
-        assertMetricsContain(
+        assertMetricsContainString(
                 parsedMetrics,
                 "perfetto.protos.camera_app_metrics-camera_close_latencies-close_ms",
                 388.299723);
@@ -504,12 +506,12 @@ public class PerfettoGenericPostProcessorTest {
         if (DEBUG) {
             printOutputMetricsForDebug(parsedMetrics);
         }
-        assertMetricsContain(
+        assertMetricsContainString(
                 parsedMetrics,
                 "android_jank_cuj-cuj-name-com.android.systemui-name-NOTIFICATION_ADD-timeline_"
                 + "metrics-frame_dur_avg",
                 5040562);
-        assertMetricsContain(
+        assertMetricsContainString(
                 parsedMetrics,
                 "perfetto_android_jank_cuj-cuj-name-NOTIFICATION_ADD-dur",
                 460793302);
@@ -537,18 +539,18 @@ public class PerfettoGenericPostProcessorTest {
         if (DEBUG) {
             printOutputMetricsForDebug(parsedMetrics);
         }
-        assertMetricsContain(parsedMetrics,
+        assertMetricsContainString(parsedMetrics,
                 "perfetto_android_blocking_call-cuj-name-TASKBAR_EXPAND-blocking_calls-name-AIDL"
                         + "::java::ITrustManager::isDeviceSecure::server-total_dur_ms", 1);
 
-        assertMetricsContain(parsedMetrics,
+        assertMetricsContainString(parsedMetrics,
                 "perfetto_android_blocking_call-cuj-name-TASKBAR_EXPAND-blocking_calls-name-AIDL"
                         + "::java::ITrustManager::isDeviceSecure::server-min_dur_ms", 0);
-        assertMetricsContain(parsedMetrics,
+        assertMetricsContainString(parsedMetrics,
                 "perfetto_android_blocking_call-cuj-name-TASKBAR_EXPAND-blocking_calls-name-AIDL"
                         + "::java::ITrustManager::isDeviceSecure::server-max_dur_ms", 1);
 
-        assertMetricsContain(parsedMetrics,
+        assertMetricsContainString(parsedMetrics,
                 "perfetto_android_blocking_call-cuj-name-ACTION_REQUEST_IME_HIDDEN"
                         + "::HIDE_SOFT_INPUT-blocking_calls-name-AIDL::java::ITrustManager"
                         + "::isDeviceSecure::server-total_dur_ms", 1);
@@ -602,33 +604,37 @@ public class PerfettoGenericPostProcessorTest {
         Map<String, Metric.Builder> parsedV2Metrics =
                 mProcessor.processRunMetricsAndLogs(new HashMap<>(), testLogs);
 
-        assertMetricsContain(
+        assertMetricsContainDouble(
                 parsedV2Metrics,
                 "memory_per_process-avg_rss_and_swap-.ShannonImsService",
-                String.format("%f", 121380864.000000));
-        assertMetricsContain(
+                121380864.000000);
+        assertMetricsContainDouble(
                 parsedV2Metrics,
                 "memory_per_process-avg_rss_and_swap-.adservices",
-                String.format("%f", 123408384.000000));
-        assertMetricsContain(
+                123408384.000000);
+        assertMetricsContainDouble(
                 parsedV2Metrics,
                 "memory_per_process-avg_rss_and_swap-/apex/com.android.adbd/bin/adbd",
-                String.format("%f", 10464441.000000));
+                10464441.000000);
 
-        assertMetricsContain(
+        assertMetricsContainDouble(
                 parsedV2Metrics,
                 "total_runtime_per_thread_for_systemui_process-(Paused)KernelPreparation-Signal"
                         + " Catcher-com.android.systemui",
-                String.format("%f", 260051.000000));
-        assertMetricsContain(
+                260051.000000);
+        assertMetricsContainDouble(
                 parsedV2Metrics,
                 "total_runtime_per_thread_for_systemui_process-(Paused)KernelPreparation-binder:12907_9-com.android.systemui",
-                String.format("%f", 158854.000000));
-        assertMetricsContain(
+                158854.000000);
+        assertMetricsContainDouble(
                 parsedV2Metrics,
                 "total_runtime_per_thread_for_systemui_process-(Paused)MarkingPause-Signal"
                         + " Catcher-com.android.systemui",
-                String.format("%f", 548624.000000));
+                548624.000000);
+        assertMetricsContainDoubleRow(
+                parsedV2Metrics,
+                "batt_power_mw",
+                Arrays.asList(456.0,123.0));
     }
 
     /**
@@ -1041,6 +1047,23 @@ public class PerfettoGenericPostProcessorTest {
                         + "    }\n"
                         + "    value: 548624.000000\n"
                         + "  }\n"
+                        + "}\n"
+                        + "metric {\n"
+                        + "  spec {\n"
+                        + "    id: \"batt_power_mw\"\n"
+                        + "  query {\n"
+                        + "    inner_query {\n"
+                        + "      inner_query_id: \"android_battery\"\n"
+                        + "    }\n"
+                        + "  }\n"
+                        + "  value: \"power_mw\"\n"
+                        + "}\n"
+                        + "  row {\n"
+                        + "    value: 456.000000\n"
+                        + "  }\n"
+                        + "  row {\n"
+                        + "    value: 123.000000\n"
+                        + "  }\n"
                         + "}\n";
 
         FileWriter fileWriter = null;
@@ -1103,8 +1126,8 @@ public class PerfettoGenericPostProcessorTest {
         }
     }
 
-    /** Assert that metrics contain a key and a corresponding value. */
-    private void assertMetricsContain(
+    /** Assert that metrics contain a key and a corresponding string value. */
+    private void assertMetricsContainString(
             Map<String, Metric.Builder> metrics, String key, Object value) {
         assertTrue(
                 String.format(
@@ -1122,5 +1145,42 @@ public class PerfettoGenericPostProcessorTest {
                                                                         .getMeasurements()
                                                                         .getSingleString())));
     }
+
+    /** Assert that metrics contain a key and a corresponding double value. */
+    private void assertMetricsContainDouble(
+            Map<String, Metric.Builder> metrics, String key, Double value) {
+        assertTrue(
+                String.format(
+                        "Metric with key containing %s and value %s was expected but not found.",
+                        key, value),
+                metrics.entrySet()
+                        .stream()
+                        .anyMatch(
+                                e ->
+                                        e.getKey().contains(key)
+                                                && value.equals(e.getValue()
+                                                                        .build()
+                                                                        .getMeasurements()
+                                                                        .getSingleDouble())));
+    }
+
+    /** Assert that metrics contain a key and row of corresponding values. */
+    private void assertMetricsContainDoubleRow(
+            Map<String, Metric.Builder> metrics, String key, List<Double> values) {
+        assertTrue(
+                String.format(
+                        "Metric with key containing %s and values %s was expected but not found.",
+                        key, values),
+                metrics.entrySet()
+                        .stream()
+                        .anyMatch(
+                                e ->
+                                        e.getKey().contains(key)
+                                                && values.equals(
+                                                                e.getValue()
+                                                                        .build()
+                                                                        .getMeasurements()
+                                                                        .getDoubleValues().getDoubleValueList())));
+    }
 }
 
diff --git a/javatests/com/android/tradefed/postprocessor/PerfettoTracePostProcessorTest.java b/javatests/com/android/tradefed/postprocessor/PerfettoTracePostProcessorTest.java
new file mode 100644
index 000000000..98c16be12
--- /dev/null
+++ b/javatests/com/android/tradefed/postprocessor/PerfettoTracePostProcessorTest.java
@@ -0,0 +1,442 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.postprocessor;
+
+import com.android.tradefed.config.OptionSetter;
+import com.android.tradefed.metrics.proto.MetricMeasurement.DataType;
+import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
+import com.android.tradefed.result.ITestInvocationListener;
+import com.android.tradefed.result.LogDataType;
+import com.android.tradefed.result.LogFile;
+import com.android.tradefed.util.CommandResult;
+import com.android.tradefed.util.CommandStatus;
+import com.android.tradefed.util.FileUtil;
+
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.ArgumentCaptor;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
+
+import java.io.File;
+import java.nio.file.Files;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/** Unit tests for {@link PerfettoTracePostProcessor}. */
+@RunWith(JUnit4.class)
+public class PerfettoTracePostProcessorTest {
+
+    private PerfettoTracePostProcessor mProcessor;
+    @Mock private ITestInvocationListener mMockListener;
+
+    @Before
+    public void setUp() throws Exception {
+        MockitoAnnotations.initMocks(this);
+        mProcessor = Mockito.spy(new PerfettoTracePostProcessor());
+        mProcessor.init(mMockListener);
+    }
+
+    /** Create a map of test logs containing a perfetto trace file. */
+    private Map<String, LogFile> createTestLogs() {
+        Map<String, LogFile> testLogs = new HashMap<>();
+        testLogs.put(
+                "perfetto_test.perfetto-trace",
+                new LogFile("/path/to/perfetto_test.perfetto-trace", "", LogDataType.PERFETTO));
+        return testLogs;
+    }
+
+    /** Create a map of test logs containing a compressed perfetto trace file. */
+    private Map<String, LogFile> createTestLogsCompressed() {
+        Map<String, LogFile> testLogs = new HashMap<>();
+        testLogs.put(
+                "perfetto_test.perfetto-trace.gz",
+                new LogFile("/path/to/perfetto_test.perfetto-trace.gz", "", LogDataType.GZIP));
+        return testLogs;
+    }
+
+    /** Set up a command result to return the given status when runHostCommand() is called. */
+    private void setUpHostCommandResult(CommandStatus status) {
+        CommandResult cr = new CommandResult(status);
+        Mockito.doReturn(cr)
+                .when(mProcessor)
+                .runHostCommand(Mockito.anyLong(), Mockito.any(), Mockito.any(), Mockito.any());
+    }
+
+    /**
+     * Create a temp file to be returned when getFileFromTestArtifacts() is called with the give
+     * file name.
+     */
+    private File createTestArtifactsFile(String fileName) throws Exception {
+        File tempFile = File.createTempFile(fileName, "");
+        Mockito.doReturn(tempFile).when(mProcessor).getFileFromTestArtifacts(fileName);
+        return tempFile;
+    }
+
+    /** Capture and return the args passed to runHostCommand(). */
+    private List<String> captureHostCommandArgs() {
+        ArgumentCaptor<String[]> captor = ArgumentCaptor.forClass(String[].class);
+        Mockito.verify(mProcessor)
+                .runHostCommand(Mockito.anyLong(), captor.capture(), Mockito.any(), Mockito.any());
+        return Arrays.asList(captor.getValue());
+    }
+
+    @Test
+    public void testNoProcessingFlow() throws Exception {
+        // Run the post processor with empty test logs.
+        Map<String, Metric.Builder> newMetrics =
+                mProcessor.processRunMetricsAndLogs(new HashMap<>(), new HashMap<>());
+
+        // Check no metrics were produced.
+        Assert.assertTrue(newMetrics.size() == 0);
+    }
+
+    /**
+     * Test the defaults args for trace processor shell.
+     *
+     * @throws Exception
+     */
+    @Test
+    public void testTraceProcessorArgsDefaults() throws Exception {
+        setUpHostCommandResult(CommandStatus.SUCCESS);
+
+        File traceProcessorTempFile = createTestArtifactsFile("trace_processor_shell");
+
+        // Run the post processor.
+        mProcessor.processRunMetricsAndLogs(new HashMap<>(), createTestLogs());
+
+        ArgumentCaptor<String[]> captor = ArgumentCaptor.forClass(String[].class);
+        Mockito.verify(mProcessor)
+                .runHostCommand(Mockito.anyLong(), captor.capture(), Mockito.any(), Mockito.any());
+        List<String> args = Arrays.asList(captor.getValue());
+        Assert.assertTrue(args.contains(traceProcessorTempFile.getAbsolutePath()));
+        Assert.assertTrue(args.contains("--run-metrics"));
+        Assert.assertTrue(args.contains("--metrics-output=text"));
+        Assert.assertFalse(args.contains("--summary"));
+        Assert.assertFalse(args.contains("--summary-metrics-v2"));
+        Assert.assertFalse(args.contains("--summary-spec"));
+
+        traceProcessorTempFile.delete();
+    }
+
+    /**
+     * Test that trace processor run metrics are used when running the trace processor shell
+     * command.
+     *
+     * @throws Exception
+     */
+    @Test
+    public void testTraceProcessorAdditionalArgs() throws Exception {
+        // Set the trace processor binary and metrics to non-default values.
+        File traceProcessorBinaryTempFile = File.createTempFile("trace_processor_binary", "");
+        OptionSetter setter = new OptionSetter(mProcessor);
+        setter.setOptionValue("trace-processor-name", "trace_processor_shell");
+        setter.setOptionValue("trace-processor-run-metrics", "android_cpu,android_mem");
+        setter.setOptionValue(
+                "trace-processor-binary", traceProcessorBinaryTempFile.getAbsolutePath());
+
+        setUpHostCommandResult(CommandStatus.SUCCESS);
+
+        // Run the post processor.
+        mProcessor.processRunMetricsAndLogs(new HashMap<>(), createTestLogs());
+
+        // Verifies all the overridden values are taken into account and trace processor
+        // binary is given preference over trace processor shell name.
+        List<String> args = captureHostCommandArgs();
+        Assert.assertTrue(args.contains(traceProcessorBinaryTempFile.getAbsolutePath()));
+        Assert.assertTrue(args.contains("android_cpu,android_mem"));
+        Assert.assertTrue(args.contains("--metrics-output=text"));
+
+        traceProcessorBinaryTempFile.delete();
+    }
+
+    /**
+     * Test that trace processor run metrics V2 only are used when running the trace processor shell
+     * command.
+     *
+     * @throws Exception
+     */
+    @Test
+    public void testTraceProcessorMetricV2Args() throws Exception {
+        OptionSetter setter = new OptionSetter(mProcessor);
+        setter.setOptionValue("perfetto-v1-metrics", "false");
+        setter.setOptionValue("perfetto-v2-metrics", "true");
+
+        setUpHostCommandResult(CommandStatus.SUCCESS);
+
+        File traceProcessorTempFile = createTestArtifactsFile("trace_processor_shell");
+        File summarySpecTempFile =
+                createTestArtifactsFile("memory_per_process-avg_rss_and_swap.textproto");
+
+        // Run the post processor.
+        mProcessor.processRunMetricsAndLogs(new HashMap<>(), createTestLogs());
+
+        List<String> args = captureHostCommandArgs();
+        Assert.assertTrue(args.contains(traceProcessorTempFile.getAbsolutePath()));
+        Assert.assertTrue(args.contains("--summary"));
+        Assert.assertTrue(args.contains("--summary-metrics-v2"));
+        Assert.assertTrue(args.contains("memory_per_process-avg_rss_and_swap"));
+        Assert.assertTrue(args.contains("--summary-spec"));
+        Assert.assertTrue(args.contains(traceProcessorTempFile.getAbsolutePath()));
+        Assert.assertFalse(args.contains("--run-metrics"));
+
+        traceProcessorTempFile.delete();
+        summarySpecTempFile.delete();
+    }
+
+    /**
+     * Test that trace processor run metrics V1 and V2 are used when running the trace processor
+     * shell command.
+     *
+     * @throws Exception
+     */
+    @Test
+    public void testTraceProcessorMetricV1andV2Args() throws Exception {
+        OptionSetter setter = new OptionSetter(mProcessor);
+        setter.setOptionValue("perfetto-v1-metrics", "true");
+        setter.setOptionValue("perfetto-v2-metrics", "true");
+
+        setUpHostCommandResult(CommandStatus.SUCCESS);
+
+        File traceProcessorTempFile = createTestArtifactsFile("trace_processor_shell");
+        File summarySpecTempFile =
+                createTestArtifactsFile("memory_per_process-avg_rss_and_swap.textproto");
+
+        // Run the post processor.
+        mProcessor.processRunMetricsAndLogs(new HashMap<>(), createTestLogs());
+
+        // Capture args from both times the trace processor is run.
+        ArgumentCaptor<String[]> captor = ArgumentCaptor.forClass(String[].class);
+        Mockito.verify(mProcessor, Mockito.times(2))
+                .runHostCommand(Mockito.anyLong(), captor.capture(), Mockito.any(), Mockito.any());
+        List<String[]> args = captor.getAllValues();
+
+        // Verify metric v1 args.
+        Assert.assertEquals(args.get(0)[0], traceProcessorTempFile.getAbsolutePath());
+        Assert.assertEquals(args.get(0)[1], "--run-metrics");
+        Assert.assertEquals(args.get(0)[2], "android_mem");
+        Assert.assertEquals(args.get(0)[3], "--metrics-output=text");
+
+        // Verify metric v2 args.
+        Assert.assertEquals(args.get(1)[0], traceProcessorTempFile.getAbsolutePath());
+        Assert.assertEquals(args.get(1)[1], "--summary");
+        Assert.assertEquals(args.get(1)[2], "--summary-metrics-v2");
+        Assert.assertEquals(args.get(1)[3], "memory_per_process-avg_rss_and_swap");
+        Assert.assertEquals(args.get(1)[4], "--summary-spec");
+        Assert.assertEquals(args.get(1)[5], summarySpecTempFile.getAbsolutePath());
+
+        traceProcessorTempFile.delete();
+        summarySpecTempFile.delete();
+    }
+
+    private double getMetricDouble(Map<String, Metric.Builder> metrics, String key) {
+        return metrics.get(key).getMeasurements().getSingleDouble();
+    }
+
+    private String getMetricString(Map<String, Metric.Builder> metrics, String key) {
+        return metrics.get(key).getMeasurements().getSingleString();
+    }
+
+    /** Test that the trace processor shell outputs run time and status. */
+    @Test
+    public void testTraceProcessorRunTimeAndStatus_success() throws Exception {
+        // Trace processor will return success.
+        setUpHostCommandResult(CommandStatus.SUCCESS);
+
+        File traceProcessorTempFile = createTestArtifactsFile("trace_processor_shell");
+
+        // Run the post processor.
+        Map<String, Metric.Builder> newMetrics =
+                mProcessor.processRunMetricsAndLogs(new HashMap<>(), createTestLogs());
+
+        // Check runtime and status metrics are present.
+        Assert.assertTrue(newMetrics.containsKey("perfetto_trace_processor_runtime"));
+        Assert.assertTrue(getMetricDouble(newMetrics, "perfetto_trace_processor_runtime") >= 0);
+        Assert.assertTrue(newMetrics.containsKey("perfetto_trace_processor_status"));
+        Assert.assertEquals("1", getMetricString(newMetrics, "perfetto_trace_processor_status"));
+
+        traceProcessorTempFile.delete();
+    }
+
+    /** Test that the trace processor shell outputs run time and status even if processing fails. */
+    @Test
+    public void testTraceProcessorRunTimeAndStatus_failure() throws Exception {
+        // Trace processor will return failure.
+        setUpHostCommandResult(CommandStatus.FAILED);
+
+        File traceProcessorTempFile = createTestArtifactsFile("trace_processor_shell");
+
+        // Run the post processor.
+        Map<String, Metric.Builder> newMetrics =
+                mProcessor.processRunMetricsAndLogs(new HashMap<>(), createTestLogs());
+
+        // Check runtime and status metrics are present.
+        Assert.assertTrue(newMetrics.containsKey("perfetto_trace_processor_runtime"));
+        Assert.assertTrue(getMetricDouble(newMetrics, "perfetto_trace_processor_runtime") >= 0);
+        Assert.assertTrue(newMetrics.containsKey("perfetto_trace_processor_status"));
+        Assert.assertEquals("0", getMetricString(newMetrics, "perfetto_trace_processor_status"));
+
+        traceProcessorTempFile.delete();
+    }
+
+    /**
+     * Test that the metric collector reports a negative runtime and failure if the trace processor
+     * is never invoked.
+     */
+    @Test
+    public void testTraceProcessorRunTimeAndStatus_notInvoked() throws Exception {
+        // No trace processor shell means that the trace proessor won't be invoked.
+        Mockito.doReturn(null).when(mProcessor).getFileFromTestArtifacts("trace_processor_shell");
+
+        // Run the post processor.
+        Map<String, Metric.Builder> newMetrics =
+                mProcessor.processRunMetricsAndLogs(new HashMap<>(), createTestLogs());
+
+        // Check runtime and status metrics are present.
+        Assert.assertTrue(newMetrics.containsKey("perfetto_trace_processor_runtime"));
+        Assert.assertTrue(getMetricDouble(newMetrics, "perfetto_trace_processor_runtime") < 0);
+        Assert.assertTrue(newMetrics.containsKey("perfetto_trace_processor_status"));
+        Assert.assertEquals("0", getMetricString(newMetrics, "perfetto_trace_processor_status"));
+    }
+
+    /**
+     * Test that the trace processor shell outputs separate run time and status metrics for v1 and
+     * v2.
+     */
+    @Test
+    public void testTraceProcessorRunTimeAndStatus_V1AndV2() throws Exception {
+        OptionSetter setter = new OptionSetter(mProcessor);
+        setter.setOptionValue("perfetto-v1-metrics", "true");
+        setter.setOptionValue("perfetto-v2-metrics", "true");
+
+        setUpHostCommandResult(CommandStatus.SUCCESS);
+
+        File traceProcessorTempFile = createTestArtifactsFile("trace_processor_shell");
+        File summarySpecTempFile =
+                createTestArtifactsFile("memory_per_process-avg_rss_and_swap.textproto");
+
+        // Run the post processor.
+        Map<String, Metric.Builder> newMetrics =
+                mProcessor.processRunMetricsAndLogs(new HashMap<>(), createTestLogs());
+
+        // Check v1 runtime and status metrics are present.
+        Assert.assertTrue(newMetrics.containsKey("perfetto_trace_processor_runtime"));
+        Assert.assertTrue(getMetricDouble(newMetrics, "perfetto_trace_processor_runtime") >= 0);
+        Assert.assertTrue(newMetrics.containsKey("perfetto_trace_processor_status"));
+        Assert.assertEquals("1", getMetricString(newMetrics, "perfetto_trace_processor_status"));
+
+        // Check v2 runtime and status metrics are present.
+        Assert.assertTrue(newMetrics.containsKey("perfetto_trace_processor_runtime_v2"));
+        Assert.assertTrue(getMetricDouble(newMetrics, "perfetto_trace_processor_runtime_v2") >= 0);
+        Assert.assertTrue(newMetrics.containsKey("perfetto_trace_processor_status_v2"));
+        Assert.assertEquals("1", getMetricString(newMetrics, "perfetto_trace_processor_status_v2"));
+
+        traceProcessorTempFile.delete();
+        summarySpecTempFile.delete();
+    }
+
+    @Test
+    public void testTraceProcessorFileSizeMetric() throws Exception {
+        // Enable the option to collect the file size metric.
+        OptionSetter setter = new OptionSetter(mProcessor);
+        setter.setOptionValue("collect-perfetto-file-size", "true");
+
+        setUpHostCommandResult(CommandStatus.SUCCESS);
+
+        File traceProcessorTempFile = createTestArtifactsFile("trace_processor_shell");
+
+        // Run the post processor.
+        Map<String, Metric.Builder> newMetrics =
+                mProcessor.processRunMetricsAndLogs(new HashMap<>(), createTestLogs());
+
+        // Check the file size metric is correct.
+        Assert.assertTrue(newMetrics.containsKey("perfetto_trace_file_size_bytes"));
+        Assert.assertTrue(
+                newMetrics.get("perfetto_trace_file_size_bytes").getMeasurements().getSingleDouble()
+                        >= 0);
+
+        traceProcessorTempFile.delete();
+    }
+
+    @Test
+    public void testTraceProcessorCompressedTrace() throws Exception {
+        setUpHostCommandResult(CommandStatus.SUCCESS);
+
+        File traceProcessorTempFile = createTestArtifactsFile("trace_processor_shell");
+
+        // Run the post processor with logs containing a compressed trace file.
+        mProcessor.processRunMetricsAndLogs(new HashMap<>(), createTestLogsCompressed());
+
+        // Check the trace file was decompressed before processing.
+        Mockito.verify(mProcessor).decompressFile(Mockito.any());
+
+        traceProcessorTempFile.delete();
+    }
+
+    /** Test the default metric type is set to RAW. */
+    @Test
+    public void testMetricTypeIsRaw() {
+        Assert.assertTrue(mProcessor.getMetricType().equals(DataType.RAW));
+    }
+
+    /**
+     * Test that trace processor runs with --add-sql-package to load additional SQL packages using
+     * the option "add-sql-packages".
+     *
+     * @throws Exception
+     */
+    @Test
+    public void testTraceProcessorAddSqlPackages() throws Exception {
+        OptionSetter setter = new OptionSetter(mProcessor);
+
+        File traceProcessorTempFile = createTestArtifactsFile("trace_processor_shell");
+
+        // add-sql-packages supports multiple values.
+        // The first sql package uses absolute path.
+        File sqlPackage1 = Files.createTempDirectory("sql_package").toFile();
+        setter.setOptionValue("add-sql-packages", sqlPackage1.getAbsolutePath());
+
+        // The second sql package uses relative path.
+        File sqlPackage2 = Files.createTempDirectory("test_artifact_sql_package").toFile();
+        Mockito.when(mProcessor.getDirectoryFromTestArtifacts(sqlPackage2.getName()))
+                .thenReturn(sqlPackage2);
+        setter.setOptionValue("add-sql-packages", sqlPackage2.getName());
+
+        mProcessor.processRunMetricsAndLogs(new HashMap<>(), createTestLogs());
+
+        ArgumentCaptor<String[]> captor = ArgumentCaptor.forClass(String[].class);
+        Mockito.verify(mProcessor)
+                .runHostCommand(Mockito.anyLong(), captor.capture(), Mockito.any(), Mockito.any());
+
+        List<String> args = Arrays.asList(captor.getValue());
+        Assert.assertTrue(args.contains(traceProcessorTempFile.getAbsolutePath()));
+        Assert.assertEquals(
+                args.stream().filter(arg -> arg.equals("--add-sql-package")).count(), 2);
+        Assert.assertTrue(args.contains(sqlPackage1.getAbsolutePath()));
+        Assert.assertTrue(args.contains(sqlPackage2.getAbsolutePath()));
+
+        traceProcessorTempFile.delete();
+        FileUtil.recursiveDelete(sqlPackage1);
+        FileUtil.recursiveDelete(sqlPackage2);
+    }
+}
diff --git a/javatests/com/android/tradefed/presubmit/GeneralTestsConfigValidation.java b/javatests/com/android/tradefed/presubmit/GeneralTestsConfigValidation.java
index 3869b63b9..f76059283 100644
--- a/javatests/com/android/tradefed/presubmit/GeneralTestsConfigValidation.java
+++ b/javatests/com/android/tradefed/presubmit/GeneralTestsConfigValidation.java
@@ -103,6 +103,7 @@ public class GeneralTestsConfigValidation implements IBuildReceiver {
                             "com.android.tradefed.testtype.StubTest",
                             "com.android.tradefed.testtype.ArtRunTest",
                             "com.android.tradefed.testtype.ArtGTest",
+                            "com.android.tradefed.testtype.ArtTest",
                             "com.android.tradefed.testtype.mobly.MoblyBinaryHostTest",
                             "com.android.tradefed.testtype.pandora.PtsBotTest",
                             // VTS runners
@@ -331,7 +332,14 @@ public class GeneralTestsConfigValidation implements IBuildReceiver {
                             "s2-geometry-library-java-tests.config",
                             // TODO(b/404996613): Confirm that this test should be in
                             //  general-tests and exempted for validation.
-                            "DesktopChromeStableTestCases.config"));
+                            "DesktopChromeStableTestCases.config",
+                            "ccdec_vp8_test.config",
+                            "ccdec_vp9_test.config",
+                            "ccdec_h264_test.config",
+                            "ccdec_h265_test.config",
+                            "ccdec_av1_test.config",
+                            "ccenc_vp9_test.config",
+                            "ccenc_h264_test.config"));
 
     @Override
     public void setBuild(IBuildInfo buildInfo) {
diff --git a/javatests/com/android/tradefed/presubmit/TestMappingsValidation.java b/javatests/com/android/tradefed/presubmit/TestMappingsValidation.java
index b5f5e6d32..4a59afd2a 100644
--- a/javatests/com/android/tradefed/presubmit/TestMappingsValidation.java
+++ b/javatests/com/android/tradefed/presubmit/TestMappingsValidation.java
@@ -172,7 +172,6 @@ public class TestMappingsValidation implements IBuildReceiver {
                     "OverlayRemountedTest",
                     "CtsPermission3TestCases",
                     "CtsPermissionUiTestCases",
-                    "sharedlibs_host_tests",
                     "CtsDevicePolicyManagerTestCases",
                     "CtsDevicePolicyManagerTestCases_Permissions",
                     "CtsDevicePolicyManagerTestCases_LockSettingsTest",
diff --git a/javatests/com/android/tradefed/result/resultdb/BatchChannelTest.java b/javatests/com/android/tradefed/result/resultdb/BatchChannelTest.java
new file mode 100644
index 000000000..2335e66f8
--- /dev/null
+++ b/javatests/com/android/tradefed/result/resultdb/BatchChannelTest.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.result.resultdb;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import java.util.ArrayList;
+import java.util.List;
+
+@RunWith(JUnit4.class)
+public final class BatchChannelTest {
+    private BatchUploadClient mClient;
+    private BatchChannel<String> mBatchChannel;
+
+    @Before
+    public void doBeforeEachTest() {
+        mClient = new BatchUploadClient();
+        mBatchChannel =
+                new BatchChannel<>(
+                        10, // Batch size is 10.
+                        "test",
+                        (batch) -> {
+                            mClient.uploadBatch(batch);
+                        });
+    }
+
+    @Test
+    public void uploadBatch_partialBatch() throws InterruptedException {
+        for (int i = 0; i < 11; i++) {
+            mBatchChannel.enqueue(String.valueOf(i));
+        }
+        mBatchChannel.finalizeUpload();
+
+        assertThat(mClient.mBatches).hasSize(2);
+        assertThat(mClient.mBatches.get(0))
+                .containsExactly("0", "1", "2", "3", "4", "5", "6", "7", "8", "9");
+        assertThat(mClient.mBatches.get(1)).containsExactly("10");
+
+        // enqueue after finalizeUpload should throw exception.
+        Assert.assertThrows(IllegalStateException.class, () -> mBatchChannel.enqueue("11"));
+    }
+
+    @Test
+    public void uploadBatch_fullBatch() throws InterruptedException {
+        for (int i = 0; i < 20; i++) {
+            mBatchChannel.enqueue(String.valueOf(i));
+        }
+        mBatchChannel.finalizeUpload();
+
+        assertThat(mClient.mBatches).hasSize(2);
+        assertThat(mClient.mBatches.get(0))
+                .containsExactly("0", "1", "2", "3", "4", "5", "6", "7", "8", "9");
+        assertThat(mClient.mBatches.get(1))
+                .containsExactly("10", "11", "12", "13", "14", "15", "16", "17", "18", "19");
+
+        // enqueue after finalizeUpload should throw exception.
+        Assert.assertThrows(IllegalStateException.class, () -> mBatchChannel.enqueue("20"));
+    }
+
+    @Test
+    public void uploadBatch_uploadFailure() throws InterruptedException {
+        mClient.mShouldUploadFail = true;
+        mBatchChannel.enqueue("1");
+        //  no exception is thrown here.
+        mBatchChannel.finalizeUpload();
+
+        assertThat(mClient.mBatches).hasSize(0);
+    }
+
+    private class BatchUploadClient {
+        private final ArrayList<List<String>> mBatches = new ArrayList<>();
+        private Boolean mShouldUploadFail = false;
+
+        public void uploadBatch(List<String> batch) {
+            if (mShouldUploadFail) {
+                throw new RuntimeException("Failed to upload batch");
+            }
+            mBatches.add(batch);
+        }
+    }
+}
diff --git a/javatests/com/android/tradefed/result/resultdb/ResultDBReporterTest.java b/javatests/com/android/tradefed/result/resultdb/ResultDBReporterTest.java
index a6840d922..b16c41d0a 100644
--- a/javatests/com/android/tradefed/result/resultdb/ResultDBReporterTest.java
+++ b/javatests/com/android/tradefed/result/resultdb/ResultDBReporterTest.java
@@ -17,16 +17,24 @@ package com.android.tradefed.result.resultdb;
 
 import static com.google.common.truth.Truth.assertThat;
 
+import com.android.resultdb.proto.Artifact;
 import com.android.resultdb.proto.CreateInvocationRequest;
 import com.android.resultdb.proto.FailureReason;
+import com.android.resultdb.proto.TestIdentifier;
+import com.android.resultdb.proto.TestIdentifierBase;
 import com.android.resultdb.proto.TestResult;
 import com.android.resultdb.proto.TestStatus;
 import com.android.resultdb.proto.Variant;
 import com.android.tradefed.build.BuildInfo;
+import com.android.tradefed.config.Configuration;
 import com.android.tradefed.config.ConfigurationException;
 import com.android.tradefed.config.OptionSetter;
+import com.android.tradefed.invoker.InvocationContext;
 import com.android.tradefed.result.FailureDescription;
+import com.android.tradefed.result.LogDataType;
+import com.android.tradefed.result.LogFile;
 import com.android.tradefed.result.proto.TestRecordProto;
+import com.android.tradefed.result.skipped.SkipManager;
 import com.android.tradefed.testtype.suite.ModuleDefinition;
 
 import com.google.protobuf.util.Durations;
@@ -37,11 +45,16 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import java.io.UnsupportedEncodingException;
+import java.net.URLEncoder;
+import java.nio.charset.StandardCharsets;
+
 @RunWith(JUnit4.class)
 public class ResultDBReporterTest {
 
     private InvocationSimulator mSimulator;
     private ResultDBReporterTester mReporter;
+    private ConfigurationTester mConfig;
     private OptionSetter mOption;
 
     private class ResultDBReporterTester extends ResultDBReporter {
@@ -53,12 +66,13 @@ public class ResultDBReporterTest {
         }
 
         @Override
-        IRecorderClient createRecorderClient(String invocationId, String updateToken) {
+        IRecorderClient createRecorderClient(
+                String invocationId, String updateToken, Boolean isStaging) {
             return mRecorder;
         }
 
         @Override
-        IRecorderClient createRecorderClient(CreateInvocationRequest request) {
+        IRecorderClient createRecorderClient(CreateInvocationRequest request, Boolean isStaging) {
             return mRecorder;
         }
 
@@ -78,28 +92,57 @@ public class ResultDBReporterTest {
         }
     }
 
+    private class ConfigurationTester extends Configuration {
+
+        SkipManager mSkipManager = new SkipManager();
+
+        public ConfigurationTester(String name, String description) {
+            super(name, description);
+        }
+
+        public void withDemotionFilters() throws ConfigurationException {
+            OptionSetter setter = new OptionSetter(mSkipManager);
+            setter.setOptionValue(
+                    "demotion-filters",
+                    "x86 module-name testClassSkipped#test-name-skipped",
+                    "test-skip-reason");
+            mSkipManager.setup(this, new InvocationContext());
+        }
+
+        @Override
+        public SkipManager getSkipManager() {
+            return mSkipManager;
+        }
+    }
+
     private TestResult.Builder newTestResult(String method) {
         return TestResult.newBuilder()
-                .setTestId(
-                        String.format(
-                                "ants://%s/%s/%s",
-                                "example-module", "com.google.ExampleClass", method))
+                .setTestIdStructured(
+                        TestIdentifier.newBuilder()
+                                .setModuleName("example-module")
+                                .setModuleScheme("junit")
+                                .setModuleVariant(
+                                        Variant.newBuilder()
+                                                .putDef("name", "test tag")
+                                                .putDef("scheduler", "ATP")
+                                                .build())
+                                .setCoarseName("com.google")
+                                .setFineName("ExampleClass")
+                                .setCaseName(method)
+                                .build())
                 .setResultId("1234abcd-00001")
                 .setStartTime(Timestamps.fromSeconds(1536333825L))
                 .setDuration(Durations.fromMillis(100))
                 .setStatus(TestStatus.PASS)
-                .setExpected(true)
-                .setVariant(
-                        Variant.newBuilder()
-                                .putDef("name", "test tag")
-                                .putDef("scheduler", "ATP")
-                                .build());
+                .setExpected(true);
     }
 
     @Before
     public void setUp() throws ConfigurationException {
         mReporter = new ResultDBReporterTester();
         mSimulator = InvocationSimulator.create().withModule("example-module");
+        mConfig = new ConfigurationTester("name", "description");
+        mReporter.setConfiguration(mConfig);
         mOption = new OptionSetter(mReporter);
     }
 
@@ -162,8 +205,10 @@ public class ResultDBReporterTest {
                         .putDef("scheduler", "ATP")
                         .putDef("target", "test-flavor")
                         .build();
-        assertThat(mReporter.mRecorder.getTestResults())
-                .containsExactly(newTestResult("testExampleMethod").setVariant(variant).build());
+        TestResult.Builder expected = newTestResult("testExampleMethod");
+        expected.setTestIdStructured(
+                expected.getTestIdStructured().toBuilder().setModuleVariant(variant).build());
+        assertThat(mReporter.mRecorder.getTestResults()).containsExactly(expected.build());
     }
 
     @Test
@@ -226,7 +271,9 @@ public class ResultDBReporterTest {
                                 .setResultId("1234abcd-00005")
                                 .setStatus(TestStatus.SKIP)
                                 .setStartTime(Timestamps.fromMillis(1536333825800L))
-                                .setSummaryHtml("bug_id: bugId<br>trigger: skip trigger<br>")
+                                .setSummaryHtml(
+                                        "bug_id: bugId<br>trigger: skip trigger<br>reason: skip"
+                                                + " reason message<br>")
                                 .setExpected(true)
                                 .build());
     }
@@ -279,4 +326,95 @@ public class ResultDBReporterTest {
                                 .setSummaryHtml("TF error type: TIMED_OUT")
                                 .build());
     }
+
+    @Test
+    public void shouldUploadDemotedTests() throws ConfigurationException {
+        mConfig.withDemotionFilters();
+        mSimulator
+                .withInvocationAttribute("resultdb_invocation_id", "invocation_001")
+                .withInvocationAttribute("resultdb_invocation_update_token", "update_token")
+                .withModuleAttribute(ModuleDefinition.MODULE_ABI, "x86")
+                .withModuleAttribute(ModuleDefinition.MODULE_NAME, "module-name")
+                .simulateInvocation(mReporter);
+        Variant variant =
+                Variant.newBuilder()
+                        .putDef("module_abi", "x86")
+                        .putDef("name", "test tag")
+                        .putDef("scheduler", "ATP")
+                        .build();
+
+        assertThat(mReporter.mRecorder.getTestResults())
+                .containsExactly(
+                        TestResult.newBuilder()
+                                .setTestIdStructured(
+                                        TestIdentifier.newBuilder()
+                                                .setModuleName("example-module")
+                                                .setModuleScheme("junit")
+                                                .setModuleVariant(variant)
+                                                .setCoarseName("empty-package")
+                                                .setFineName("testClassSkipped")
+                                                .setCaseName("test-name-skipped")
+                                                .build())
+                                .setResultId("1234abcd-00001")
+                                .setStartTime(Timestamps.fromSeconds(1000000L))
+                                .setStatus(TestStatus.SKIP)
+                                .setExpected(true)
+                                .setSummaryHtml(
+                                        "trigger: UNKNOWN_TRIGGER<br>skip_reason_type:"
+                                                + " Demotion<br>reason: test-skip-reason<br>")
+                                .build());
+    }
+
+    @Test
+    public void uploadTestArtifacts() {
+        LogFile testLog = new LogFile("/tmp/test.log", getLogUrl("test.log"), LogDataType.TEXT);
+        LogFile testRunLog =
+                new LogFile("/tmp/test-run.log", getLogUrl("test-run.log"), LogDataType.TEXT);
+        LogFile invocationLog =
+                new LogFile("/tmp/invocation.log", getLogUrl("invocation.log"), LogDataType.PNG);
+        mSimulator
+                .withInvocationAttribute("resultdb_invocation_id", "invocation_001")
+                .withInvocationAttribute("resultdb_invocation_update_token", "update_token")
+                .withTest("com.google.ExampleClass", "testExampleMethod")
+                .withTestLog(testLog)
+                .withTestRunLog(testRunLog)
+                .withInvocationLog(invocationLog)
+                .simulateInvocation(mReporter);
+
+        assertThat(mReporter.mRecorder.getArtifacts())
+                .containsExactly(
+                        Artifact.newBuilder()
+                                .setArtifactId("18274/stub/inv_9000/test.log_9000.dat")
+                                .setContentType("text/plain")
+                                .setTestIdStructured(
+                                        TestIdentifierBase.newBuilder()
+                                                .setModuleName("example-module")
+                                                .setModuleScheme("junit")
+                                                .setCoarseName("com.google")
+                                                .setFineName("ExampleClass")
+                                                .setCaseName("testExampleMethod")
+                                                .build())
+                                .setResultId("1234abcd-00001")
+                                .setTestStatus(TestStatus.PASS)
+                                .build(),
+                        Artifact.newBuilder()
+                                .setArtifactId("18274/stub/inv_9000/test-run.log_9000.dat")
+                                .setContentType("text/plain")
+                                .build(),
+                        Artifact.newBuilder()
+                                .setArtifactId("18274/stub/inv_9000/invocation.log_9000.dat")
+                                .setContentType("image/png")
+                                .build());
+    }
+
+    private String getLogUrl(String log) {
+        try {
+            return String.format(
+                    "https://android-build.googleplex.com/builds/submitted/18274/docs/0/tests/1488327372312/18274/stub/inv_9000/%s_9000.dat",
+                    URLEncoder.encode(log, StandardCharsets.UTF_8.name()));
+        } catch (UnsupportedEncodingException e) {
+            // ignore
+        }
+        return "";
+    }
 }
diff --git a/javatests/com/android/tradefed/result/resultdb/ResultDBUtilTest.java b/javatests/com/android/tradefed/result/resultdb/ResultDBUtilTest.java
index b1f3c42c4..b2e21ae33 100644
--- a/javatests/com/android/tradefed/result/resultdb/ResultDBUtilTest.java
+++ b/javatests/com/android/tradefed/result/resultdb/ResultDBUtilTest.java
@@ -17,6 +17,10 @@ package com.android.tradefed.result.resultdb;
 
 import static com.google.common.truth.Truth.assertThat;
 
+import com.android.resultdb.proto.TestIdentifier;
+import com.android.resultdb.proto.Variant;
+import com.android.tradefed.result.TestDescription;
+
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -57,4 +61,54 @@ public final class ResultDBUtilTest {
         assertThat(ResultDBUtil.makeValidKey("")).isEqualTo("empty_key");
         assertThat(ResultDBUtil.makeValidKey("0key")).isEqualTo("num_0key");
     }
+
+    private TestIdentifier.Builder expectedTestIdentifier =
+            TestIdentifier.newBuilder()
+                    .setModuleName("example-module")
+                    .setModuleScheme("junit")
+                    .setModuleVariant(Variant.getDefaultInstance())
+                    .setCoarseName("com.example.package")
+                    .setFineName("ExampleClass")
+                    .setCaseName("test_name");
+
+    @Test
+    public void toTestIdentifier() {
+        TestDescription testDescription =
+                new TestDescription("com.example.package.ExampleClass", "test_name");
+
+        TestIdentifier testIdentifier =
+                ResultDBUtil.toTestIdentifier(
+                        "example-module", Variant.getDefaultInstance(), testDescription);
+        assertThat(testIdentifier).isEqualTo(expectedTestIdentifier.build());
+    }
+
+    @Test
+    public void toTestIdentifierNoPackage() {
+        TestDescription testDescription = new TestDescription("ExampleClass", "test_name");
+        TestIdentifier testIdentifier =
+                ResultDBUtil.toTestIdentifier(
+                        "example-module", Variant.getDefaultInstance(), testDescription);
+
+        assertThat(testIdentifier)
+                .isEqualTo(
+                        expectedTestIdentifier
+                                .setCoarseName("empty-package")
+                                .setFineName("ExampleClass")
+                                .build());
+    }
+
+    @Test
+    public void toTestIdentifierEmptyClassName() {
+        TestDescription testDescription = new TestDescription("", "test_name");
+        TestIdentifier testIdentifier =
+                ResultDBUtil.toTestIdentifier(
+                        "example-module", Variant.getDefaultInstance(), testDescription);
+
+        assertThat(testIdentifier)
+                .isEqualTo(
+                        expectedTestIdentifier
+                                .setCoarseName("empty-package")
+                                .setFineName("empty-class")
+                                .build());
+    }
 }
diff --git a/javatests/com/android/tradefed/retry/BaseRetryDecisionTest.java b/javatests/com/android/tradefed/retry/BaseRetryDecisionTest.java
index 14a809b55..f6558a74e 100644
--- a/javatests/com/android/tradefed/retry/BaseRetryDecisionTest.java
+++ b/javatests/com/android/tradefed/retry/BaseRetryDecisionTest.java
@@ -334,6 +334,19 @@ public class BaseRetryDecisionTest {
         verify(mMockDevice).reboot();
     }
 
+    @Test
+    public void testShouldRetry_autoRetriable_testcase() throws Exception {
+        OptionSetter setter = new OptionSetter(mRetryDecision);
+        setter.setOptionValue("max-testcase-run-count", "2");
+        setter.setOptionValue("max-testrun-run-count", "3");
+
+        TestRunResult result = createResult(null, FailureDescription.create("failure2"));
+        boolean res = mRetryDecision.shouldRetry(mAutoRetriableClass, 0, Arrays.asList(result));
+        assertTrue(res);
+        res = mRetryDecision.shouldRetry(mAutoRetriableClass, 1, Arrays.asList(result));
+        assertFalse(res);
+    }
+
     @Test
     public void testShouldRetry_skip_retrying_list_test_no_module() throws Exception {
         final String SKIP_RETRYING_LIST = "skip-retrying-list";
@@ -385,4 +398,4 @@ public class BaseRetryDecisionTest {
         result.testRunEnded(500, new HashMap<String, Metric>());
         return result;
     }
-}
+}
\ No newline at end of file
diff --git a/javatests/com/android/tradefed/targetprep/AllTestAppsInstallSetupTest.java b/javatests/com/android/tradefed/targetprep/AllTestAppsInstallSetupTest.java
index a2f7245c2..99e1e265d 100644
--- a/javatests/com/android/tradefed/targetprep/AllTestAppsInstallSetupTest.java
+++ b/javatests/com/android/tradefed/targetprep/AllTestAppsInstallSetupTest.java
@@ -72,7 +72,7 @@ public class AllTestAppsInstallSetupTest {
 
     @Test
     public void testNoTestDir() throws Exception {
-        when(mMockBuildInfo.getTestsDir()).thenReturn(new File(""));
+        when(mMockBuildInfo.getTestsDir()).thenReturn(new File("non-existing-path"));
 
         try {
             mPrep.setUp(mTestInfo);
diff --git a/javatests/com/android/tradefed/targetprep/MixRadioTargetPreparerTest.java b/javatests/com/android/tradefed/targetprep/MixRadioTargetPreparerTest.java
new file mode 100644
index 000000000..06645c4d5
--- /dev/null
+++ b/javatests/com/android/tradefed/targetprep/MixRadioTargetPreparerTest.java
@@ -0,0 +1,304 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.targetprep;
+
+import static org.mockito.Mockito.when;
+
+import com.android.tradefed.build.DeviceBuildInfo;
+import com.android.tradefed.build.IDeviceBuildInfo;
+import com.android.tradefed.config.OptionSetter;
+import com.android.tradefed.device.ITestDevice;
+import com.android.tradefed.invoker.IInvocationContext;
+import com.android.tradefed.invoker.InvocationContext;
+import com.android.tradefed.invoker.TestInformation;
+import com.android.tradefed.util.FileUtil;
+
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mockito;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.FileSystem;
+import java.nio.file.FileSystems;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.attribute.BasicFileAttributeView;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.security.SecureRandom;
+import java.util.Arrays;
+import java.util.concurrent.ThreadLocalRandom;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipOutputStream;
+
+/** Unit tests for {@link MixRadioTargetPreparer} */
+@RunWith(JUnit4.class)
+public class MixRadioTargetPreparerTest {
+    private static final int RANDOM_BYTES_MIN = 4 << 12;
+    private static final int RANDOM_BYTES_MAX = 6 << 20;
+
+    private IInvocationContext mContext;
+    private TestInformation mTestInfo;
+    private IDeviceBuildInfo mBuildInfo;
+
+    @Before
+    public void setUp() throws Exception {
+        mContext = new InvocationContext();
+        mBuildInfo = new DeviceBuildInfo();
+        mBuildInfo.setBuildFlavor("flavor");
+        mContext.addDeviceBuildInfo("device", mBuildInfo);
+        mContext.addAllocatedDevice("device", Mockito.mock(ITestDevice.class));
+        mTestInfo = TestInformation.newBuilder().setInvocationContext(mContext).build();
+    }
+
+    @Test
+    public void testFailsOnMissingDeviceImage() throws Exception {
+        MixRadioTargetPreparer mk = new MixRadioTargetPreparer();
+        File radioImage = FileUtil.createTempFile("device-img-12345", "zip");
+        mBuildInfo.setFile("{radio}radio.img.gz", radioImage, "0");
+        try {
+            mk.setUp(mTestInfo);
+            Assert.fail("Expected TargetSetupError");
+        } catch (TargetSetupError e) {
+            // expected.
+        } finally {
+            FileUtil.recursiveDelete(radioImage);
+        }
+    }
+
+    @Test
+    public void testFailsOnMissingRadioImage() throws Exception {
+        MixRadioTargetPreparer mk = new MixRadioTargetPreparer();
+        File deviceImage = FileUtil.createTempFile("device-img-12345", "zip");
+        mBuildInfo.setFile("device-img", deviceImage, "0");
+
+        String radioImageName = "radio-img-9432383";
+        File srcFile = FileUtil.createTempFile(radioImageName + "_", ".gz");
+        FileUtil.writeToFile(radioImageName, srcFile);
+        mBuildInfo.setFile("baseband", srcFile, "0");
+
+        when(mBuildInfo.getFile(srcFile.getName())).thenReturn(null);
+        try {
+            mContext.addDeviceBuildInfo("device", new DeviceBuildInfo());
+            mk.setUp(mTestInfo);
+            Assert.fail("Expected TargetSetupError");
+        } catch (TargetSetupError e) {
+            // expected.
+        } finally {
+            FileUtil.recursiveDelete(deviceImage);
+            FileUtil.recursiveDelete(srcFile);
+        }
+    }
+
+    private static byte[] getRandomBytes(int size) {
+        byte[] nonce = new byte[size];
+        new SecureRandom().nextBytes(nonce);
+        return nonce;
+    }
+
+    private static byte[] hashFile(File file) throws NoSuchAlgorithmException, IOException {
+        MessageDigest digest = MessageDigest.getInstance("SHA-256");
+        digest.reset();
+        digest.update(Files.readAllBytes(file.toPath()));
+        return digest.digest();
+    }
+
+    private static int getRandomInt() {
+        return ThreadLocalRandom.current().nextInt(RANDOM_BYTES_MIN, RANDOM_BYTES_MAX + 1);
+    }
+
+    static class MixRadioPreparerResource implements AutoCloseable {
+        DeviceBuildInfo deviceBuildInfo;
+        String basebandBuildInfo;
+
+        File deviceImage;
+        File radioImage;
+        File newRadioImage;
+
+        File deviceImageHardLink;
+        File radioImageHardLink;
+        File newRadioImageHardLink;
+
+        byte[] deviceImageDigest;
+        byte[] radioImageDigest;
+        byte[] newRadioImageDigest;
+
+        MixRadioPreparerResource(
+                IInvocationContext context,
+                String deviceBuildId,
+                String basebandBuildId,
+                String newBasebandBuildId)
+                throws Exception {
+            deviceBuildInfo = new DeviceBuildInfo();
+            context.addDeviceBuildInfo("device", deviceBuildInfo);
+            context.addAllocatedDevice("device", Mockito.mock(ITestDevice.class));
+
+            deviceImage = FileUtil.createTempFile("device-img", ".zip");
+            radioImage = FileUtil.createTempFile("radio", ".img");
+            newRadioImage = FileUtil.createTempFile("radio", ".img");
+
+            deviceImageHardLink = FileUtil.createTempFile("device-img-hard-link", ".zip");
+            radioImageHardLink = FileUtil.createTempFile("baseband-hard-link", ".img");
+            newRadioImageHardLink = FileUtil.createTempFile("baseband-hard-link", ".img");
+
+            deviceImageHardLink.delete();
+            radioImageHardLink.delete();
+            newRadioImageHardLink.delete();
+
+            FileUtil.hardlinkFile(deviceImage, deviceImageHardLink);
+            FileUtil.hardlinkFile(radioImage, radioImageHardLink);
+            FileUtil.hardlinkFile(newRadioImage, newRadioImageHardLink);
+
+            try (ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(deviceImage))) {
+                zos.putNextEntry(new ZipEntry("android-info.txt"));
+                zos.write("\n#unused-line\nrequire version-baseband=oldver\nOK\n".getBytes());
+                zos.closeEntry();
+                zos.putNextEntry(new ZipEntry("nonce.img"));
+                zos.write(getRandomBytes(getRandomInt()));
+                zos.closeEntry();
+            }
+
+            Files.write(radioImage.toPath(), getRandomBytes(getRandomInt()));
+            Files.write(newRadioImage.toPath(), getRandomBytes(getRandomInt()));
+
+            if (deviceBuildId != null) {
+                deviceBuildInfo.setDeviceImageFile(deviceImageHardLink, deviceBuildId);
+            }
+            if (basebandBuildId != null) {
+                deviceBuildInfo.setBasebandImage(radioImageHardLink, basebandBuildId);
+            }
+            if (newBasebandBuildId != null) {
+                deviceBuildInfo.setBasebandImage(newRadioImageHardLink, newBasebandBuildId);
+            }
+
+            deviceImageDigest = hashFile(deviceImage);
+            radioImageDigest = hashFile(radioImage);
+            newRadioImageDigest = hashFile(newRadioImage);
+        }
+
+        @Override
+        public void close() throws IOException {
+            try {
+                Assert.assertArrayEquals(deviceImageDigest, hashFile(deviceImage));
+                Assert.assertArrayEquals(radioImageDigest, hashFile(radioImage));
+                Assert.assertArrayEquals(newRadioImageDigest, hashFile(newRadioImage));
+            } catch (NoSuchAlgorithmException e) {
+                Assert.fail("Hash algorithm is not supported: " + e.toString());
+            }
+
+            FileUtil.deleteFile(deviceImage);
+            FileUtil.deleteFile(radioImage);
+            FileUtil.deleteFile(newRadioImage);
+            FileUtil.deleteFile(deviceImageHardLink);
+            FileUtil.deleteFile(radioImageHardLink);
+            FileUtil.deleteFile(newRadioImageHardLink);
+        }
+
+        @Override
+        public String toString() {
+            return String.format(
+                    "buildinfo(%s,%s),images(%s,%s,%s)->(%s,%s,%s)",
+                    deviceBuildInfo,
+                    basebandBuildInfo,
+                    deviceImage,
+                    radioImage,
+                    newRadioImage,
+                    deviceImageHardLink,
+                    radioImageHardLink,
+                    newRadioImageHardLink);
+        }
+    }
+
+    @Test
+    public void testSuccessfulMixRadio() throws Exception {
+        MixRadioTargetPreparer mk = new MixRadioTargetPreparer();
+        OptionSetter setter = new OptionSetter(mk);
+        setter.setOptionValue("radio-file-key", "123456");
+        File testsDir = FileUtil.createTempDir("testsdir");
+        File radioTool = FileUtil.createTempFile("radio_img", null, testsDir);
+        radioTool.renameTo(new File(testsDir, "radio_img"));
+
+        String radioImageName = "radio-img-9432383";
+        File srcFile = FileUtil.createTempFile(radioImageName + "_", ".gz");
+        FileUtil.writeToFile(radioImageName, srcFile);
+        mBuildInfo.setFile("baseband", srcFile, "0");
+
+        try (MixRadioPreparerResource res =
+                new MixRadioPreparerResource(mContext, "666123", "zzz-1.0-YU9P9034__#", "P33145")) {
+            ITestDevice mockDevice = Mockito.mock(ITestDevice.class);
+            when(mockDevice.getSerialNumber()).thenReturn("serial");
+            mContext.addAllocatedDevice("device", mockDevice);
+            mk.setUp(mTestInfo);
+
+            try (FileSystem zip =
+                    FileSystems.newFileSystem(
+                            res.deviceBuildInfo.getDeviceImageFile().toPath(),
+                            (ClassLoader) null)) {
+                Path aInfoPath = zip.getPath("android-info.txt");
+                Path noncePath = zip.getPath("nonce.img");
+                String aInfo = new String(Files.readAllBytes(aInfoPath), StandardCharsets.UTF_8);
+
+                // Check android-info.txt is patched correctly.
+                Assert.assertTrue(
+                        "Processed android-info.txt:\n" + aInfo,
+                        Arrays.stream(aInfo.split("\\r?\\n"))
+                                .allMatch(line -> !line.startsWith("require version-baseband=")));
+                Assert.assertTrue(
+                        "Processed android-info.txt:\n" + aInfo,
+                        Arrays.stream(aInfo.split("\\r?\\n"))
+                                .anyMatch(line -> line.startsWith("#unused-line")));
+
+                // Check both files are regular files.
+                Assert.assertTrue(
+                        zip.provider()
+                                .getFileAttributeView(aInfoPath, BasicFileAttributeView.class)
+                                .readAttributes()
+                                .isRegularFile());
+                Assert.assertTrue(
+                        zip.provider()
+                                .getFileAttributeView(noncePath, BasicFileAttributeView.class)
+                                .readAttributes()
+                                .isRegularFile());
+            }
+
+            Assert.assertEquals(
+                    "radio.img in device is not updated",
+                    new String(
+                            Files.readAllBytes(res.deviceBuildInfo.getBasebandImageFile().toPath()),
+                            StandardCharsets.UTF_8),
+                    new String(
+                            Files.readAllBytes(res.newRadioImage.toPath()),
+                            StandardCharsets.UTF_8));
+
+            Assert.assertEquals(
+                    "baseband version is not updated",
+                    "zzz-1.0-P33145",
+                    res.deviceBuildInfo.getBasebandVersion());
+        } catch (TargetSetupError e) {
+            // expected.
+        } finally {
+            FileUtil.recursiveDelete(radioTool);
+            FileUtil.recursiveDelete(testsDir);
+            FileUtil.recursiveDelete(srcFile);
+        }
+    }
+}
diff --git a/javatests/com/android/tradefed/targetprep/OtaUpdateDeviceFlasherTest.java b/javatests/com/android/tradefed/targetprep/OtaUpdateDeviceFlasherTest.java
index 534578bbe..992073a94 100644
--- a/javatests/com/android/tradefed/targetprep/OtaUpdateDeviceFlasherTest.java
+++ b/javatests/com/android/tradefed/targetprep/OtaUpdateDeviceFlasherTest.java
@@ -176,12 +176,6 @@ public class OtaUpdateDeviceFlasherTest {
         mFlasher.flash(mMockDevice, dbi);
         // verify
         mInOrder.verify(mMockDevice).enableAdbRoot();
-        mInOrder.verify(mMockDevice).executeShellCommand("start");
-        mInOrder.verify(mMockDevice).waitForDeviceAvailable();
-        mInOrder.verify(mMockDevice).executeShellCommand("cmd recovery wipe");
-        mInOrder.verify(mMockDevice).waitForDeviceAvailable();
-        mInOrder.verify(mMockDevice).enableAdbRoot();
-        mInOrder.verify(mMockDevice).executeShellCommand("svc power stayon true");
         mInOrder.verify(mMockDevice)
                 .setProperty(
                         Mockito.eq(OtaUpdateDeviceFlasher.OTA_DOWNGRADE_PROP), Mockito.eq("1"));
@@ -208,12 +202,6 @@ public class OtaUpdateDeviceFlasherTest {
         mFlasher.flash(mMockDevice, dbi);
         // verify
         mInOrder.verify(mMockDevice).enableAdbRoot();
-        mInOrder.verify(mMockDevice).executeShellCommand("start");
-        mInOrder.verify(mMockDevice).waitForDeviceAvailable();
-        mInOrder.verify(mMockDevice).executeShellCommand("cmd recovery wipe");
-        mInOrder.verify(mMockDevice).waitForDeviceAvailable();
-        mInOrder.verify(mMockDevice).enableAdbRoot();
-        mInOrder.verify(mMockDevice).executeShellCommand("svc power stayon true");
         mInOrder.verify(mMockDevice)
                 .setProperty(
                         Mockito.eq(OtaUpdateDeviceFlasher.OTA_DOWNGRADE_PROP), Mockito.eq("1"));
@@ -240,12 +228,6 @@ public class OtaUpdateDeviceFlasherTest {
         mFlasher.flash(mMockDevice, dbi);
         // verify
         mInOrder.verify(mMockDevice).enableAdbRoot();
-        mInOrder.verify(mMockDevice).executeShellCommand("start");
-        mInOrder.verify(mMockDevice).waitForDeviceAvailable();
-        mInOrder.verify(mMockDevice).executeShellCommand("cmd recovery wipe");
-        mInOrder.verify(mMockDevice).waitForDeviceAvailable();
-        mInOrder.verify(mMockDevice).enableAdbRoot();
-        mInOrder.verify(mMockDevice).executeShellCommand("svc power stayon true");
         mInOrder.verify(mMockDevice)
                 .setProperty(
                         Mockito.eq(OtaUpdateDeviceFlasher.OTA_DOWNGRADE_PROP), Mockito.eq("1"));
diff --git a/javatests/com/android/tradefed/targetprep/SwitchUserTargetPreparerTest.java b/javatests/com/android/tradefed/targetprep/SwitchUserTargetPreparerTest.java
index 9f1cf35a4..20be0fc68 100644
--- a/javatests/com/android/tradefed/targetprep/SwitchUserTargetPreparerTest.java
+++ b/javatests/com/android/tradefed/targetprep/SwitchUserTargetPreparerTest.java
@@ -100,7 +100,7 @@ public class SwitchUserTargetPreparerTest {
     }
 
     @Test
-    public void testSetUpRunAsSystem_ifSystemSwitchIsNotAllowed_switchToMain() throws Exception {
+    public void testSetUpRunAsSystem_ifSystemSwitchIsNotAllowed_switchToFull() throws Exception {
         mOptionSetter.setOptionValue("user-type", "system");
 
         // setup
@@ -109,11 +109,10 @@ public class SwitchUserTargetPreparerTest {
                 mMockDevice,
                 /* userIds= */ new Integer[] {0, 10, 11},
                 /* flags= */ new Integer[] {
-                    UserInfo.FLAG_PRIMARY, UserInfo.FLAG_MAIN, UserInfo.FLAG_GUEST
+                    UserInfo.FLAG_PRIMARY, UserInfo.FLAG_FULL, UserInfo.FLAG_GUEST
                 });
 
         when(mMockDevice.isHeadlessSystemUserMode()).thenReturn(true);
-        when(mMockDevice.canSwitchToHeadlessSystemUser()).thenReturn(false);
         when(mMockDevice.switchUser(10)).thenReturn(true);
 
         // act
@@ -124,7 +123,7 @@ public class SwitchUserTargetPreparerTest {
     }
 
     @Test
-    public void testSetUpRunAsSystem_ifSystemSwitchIsNotAllowed_noSwitchIfAlreadyOnMainUser()
+    public void testSetUpRunAsSystem_ifSystemSwitchIsNotAllowed_noSwitchIfAlreadyOnFullUser()
             throws Exception {
         mOptionSetter.setOptionValue("user-type", "system");
 
@@ -134,11 +133,10 @@ public class SwitchUserTargetPreparerTest {
                 mMockDevice,
                 /* userIds= */ new Integer[] {0, 10, 11},
                 /* flags= */ new Integer[] {
-                    UserInfo.FLAG_PRIMARY, UserInfo.FLAG_MAIN, UserInfo.FLAG_GUEST
+                    UserInfo.FLAG_PRIMARY, UserInfo.FLAG_FULL, UserInfo.FLAG_GUEST
                 });
 
         when(mMockDevice.isHeadlessSystemUserMode()).thenReturn(true);
-        when(mMockDevice.canSwitchToHeadlessSystemUser()).thenReturn(false);
 
         // act
         mSwitchUserTargetPreparer.setUp(mTestInformation);
diff --git a/javatests/com/android/tradefed/targetprep/TestAppInstallSetupTest.java b/javatests/com/android/tradefed/targetprep/TestAppInstallSetupTest.java
index 0b1dcfbda..fa39d07b2 100644
--- a/javatests/com/android/tradefed/targetprep/TestAppInstallSetupTest.java
+++ b/javatests/com/android/tradefed/targetprep/TestAppInstallSetupTest.java
@@ -32,7 +32,6 @@ import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-import com.android.incfs.install.IncrementalInstallSession;
 import com.android.tradefed.build.IDeviceBuildInfo;
 import com.android.tradefed.config.ConfigurationException;
 import com.android.tradefed.config.OptionSetter;
@@ -87,8 +86,6 @@ public class TestAppInstallSetupTest {
     private TestInformation mTestInfo;
     @Mock IDeviceBuildInfo mMockBuildInfo;
     @Mock ITestDevice mMockTestDevice;
-    private IncrementalInstallSession.Builder mMockIncrementalInstallSessionBuilder;
-    private IncrementalInstallSession mMockIncrementalInstallSession;
     private File mTestDir;
     private File mBuildTestDir;
     private File mTemporaryFolder;
@@ -147,9 +144,6 @@ public class TestAppInstallSetupTest {
 
         mMockAaptParser = Mockito.mock(AaptParser.class);
 
-        mMockIncrementalInstallSessionBuilder =
-                Mockito.mock(IncrementalInstallSession.Builder.class);
-        mMockIncrementalInstallSession = Mockito.mock(IncrementalInstallSession.class);
         when(mMockTestDevice.getSerialNumber()).thenReturn(SERIAL);
         when(mMockTestDevice.getDeviceDescriptor()).thenReturn(null);
         when(mMockTestDevice.isAppEnumerationSupported()).thenReturn(false);
@@ -360,163 +354,6 @@ public class TestAppInstallSetupTest {
                 .installPackages(Mockito.eq(mTestSplitApkFiles), Mockito.eq(true));
     }
 
-    /**
-     * Tests that the APKs to be installed will be added to the IncrementalInstallSession Builder
-     * object if the "incremental" option is true.
-     */
-    @Test
-    public void testSetup_installIncrementalAddPackages() throws Exception {
-        mPrep =
-                new TestAppInstallSetup() {
-                    @Override
-                    protected String parsePackageName(File testAppFile) {
-                        return PACKAGE_NAME;
-                    }
-
-                    @Override
-                    protected File getLocalPathForFilename(
-                            TestInformation testInfo, String apkFileName) throws TargetSetupError {
-                        if (fakeApk != null && apkFileName.equals(fakeApk.getName())) {
-                            return fakeApk;
-                        }
-                        if (fakeApk2 != null && apkFileName.equals(fakeApk2.getName())) {
-                            return fakeApk2;
-                        }
-                        return null;
-                    }
-
-                    @Override
-                    protected IncrementalInstallSession.Builder
-                            getIncrementalInstallSessionBuilder() {
-                        return mMockIncrementalInstallSessionBuilder;
-                    }
-
-                    @Override
-                    protected void installPackageIncrementally(
-                            IncrementalInstallSession.Builder builder) throws TargetSetupError {
-                        try {
-                            incrementalInstallSession =
-                                    mMockIncrementalInstallSessionBuilder.build();
-                        } catch (IOException e) {
-                            throw new TargetSetupError(
-                                    String.format("Failed to start incremental install session."),
-                                    e);
-                        }
-                    }
-                };
-
-        OptionSetter setter = new OptionSetter(mPrep);
-        setter.setOptionValue("incremental", "true");
-        setter.setOptionValue("test-file-name", APK_NAME);
-
-        mPrep.setUp(mTestInfo);
-
-        Mockito.verify(mMockIncrementalInstallSessionBuilder)
-                .addApk(fakeApk.toPath(), fakeApkSignature.toPath());
-    }
-
-    /**
-     * Test {@link TestAppInstallSetup#setUp(TestInformation)} with a missing v4 signature file
-     * under incremental installation. TargetSetupError expected.
-     */
-    @Test
-    public void testSetup_installIncrementalMissingSignature() throws Exception {
-        final String failure = "Unable to retrieve v4 signature for file:";
-        fakeApkSignature.delete(); // APK cannot be read.
-        mPrep =
-                new TestAppInstallSetup() {
-                    @Override
-                    protected String parsePackageName(File testAppFile) {
-                        return PACKAGE_NAME;
-                    }
-
-                    @Override
-                    protected File getLocalPathForFilename(
-                            TestInformation testInfo, String apkFileName) throws TargetSetupError {
-                        if (fakeApk != null && apkFileName.equals(fakeApk.getName())) {
-                            return fakeApk;
-                        }
-                        if (fakeApk2 != null && apkFileName.equals(fakeApk2.getName())) {
-                            return fakeApk2;
-                        }
-                        return null;
-                    }
-
-                    @Override
-                    protected void installPackageIncrementally(
-                            IncrementalInstallSession.Builder builder) throws TargetSetupError {
-                        try {
-                            incrementalInstallSession =
-                                    mMockIncrementalInstallSessionBuilder.build();
-                        } catch (IOException e) {
-                            throw new TargetSetupError(
-                                    String.format("Failed to start incremental install session."),
-                                    e);
-                        }
-                    }
-                };
-
-        OptionSetter setter = new OptionSetter(mPrep);
-        setter.setOptionValue("incremental", "true");
-        setter.setOptionValue("test-file-name", APK_NAME);
-
-        try {
-            mPrep.setUp(mTestInfo);
-            fail("Expected TargetSetupError");
-        } catch (TargetSetupError e) {
-            assertThat(e).hasMessageThat().contains(APK_NAME);
-            assertThat(e).hasMessageThat().contains(failure);
-        }
-    }
-
-    /**
-     * Tests that the IncrementalInstallSession is built after Builder object is configured under
-     * the incremental installation option.
-     */
-    @Test
-    public void testSetup_installIncrementalSessionIsBuilt() throws Exception {
-        mPrep =
-                new TestAppInstallSetup() {
-                    @Override
-                    protected String parsePackageName(File testAppFile) {
-                        return PACKAGE_NAME;
-                    }
-
-                    @Override
-                    protected File getLocalPathForFilename(
-                            TestInformation testInfo, String apkFileName) throws TargetSetupError {
-                        if (fakeApk != null && apkFileName.equals(fakeApk.getName())) {
-                            return fakeApk;
-                        }
-                        if (fakeApk2 != null && apkFileName.equals(fakeApk2.getName())) {
-                            return fakeApk2;
-                        }
-                        return null;
-                    }
-
-                    @Override
-                    protected void installPackageIncrementally(
-                            IncrementalInstallSession.Builder builder) throws TargetSetupError {
-                        try {
-                            incrementalInstallSession =
-                                    mMockIncrementalInstallSessionBuilder.build();
-                        } catch (IOException e) {
-                            throw new TargetSetupError(
-                                    String.format("Failed to start incremental install session."),
-                                    e);
-                        }
-                    }
-                };
-
-        OptionSetter setter = new OptionSetter(mPrep);
-        setter.setOptionValue("incremental", "true");
-        setter.setOptionValue("test-file-name", APK_NAME);
-
-        mPrep.setUp(mTestInfo);
-
-        Mockito.verify(mMockIncrementalInstallSessionBuilder).build();
-    }
-
     @Test
     public void testSetup_incrementalSetupDisabledExplicitly_noOp() throws Exception {
         when(mMockTestDevice.installPackage(Mockito.eq(fakeApk), Mockito.eq(true)))
@@ -582,6 +419,29 @@ public class TestAppInstallSetupTest {
                 .installPackages(Mockito.eq(mTestSplitApkFiles), Mockito.eq(true));
     }
 
+    @Test
+    public void testInstallFailedConflictingProvider() throws Exception {
+        final String obsoletePackageName = "obsolete.package.name";
+        final String failure = String.format(
+            "%s: the provider name a.b.c is already used by %s [other info]",
+            "INSTALL_FAILED_CONFLICTING_PROVIDER",
+            obsoletePackageName);
+        when(mMockTestDevice.installPackage(Mockito.eq(fakeApk), Mockito.eq(true)))
+                .thenReturn(failure);
+        when(mMockTestDevice.uninstallPackage(obsoletePackageName)).thenReturn(null);
+        when(mMockTestDevice.installPackage(Mockito.eq(fakeApk), Mockito.eq(true)))
+                .thenReturn(null);
+        when(mMockTestDevice.installPackages(Mockito.eq(mTestSplitApkFiles), Mockito.eq(true)))
+                .thenReturn(failure);
+        when(mMockTestDevice.uninstallPackage(obsoletePackageName)).thenReturn(null);
+        when(mMockTestDevice.installPackages(Mockito.eq(mTestSplitApkFiles), Mockito.eq(true)))
+                .thenReturn(null);
+
+        mPrep.setUp(mTestInfo);
+        verify(mMockTestDevice, atLeastOnce())
+                .installPackages(Mockito.eq(mTestSplitApkFiles), Mockito.eq(true));
+    }
+
     /**
      * Test {@link TestAppInstallSetup#setUp(TestInformation)} with a missing apk. TargetSetupError
      * expected.
@@ -851,7 +711,8 @@ public class TestAppInstallSetupTest {
             fail("Should have thrown an exception");
         } catch (TargetSetupError expected) {
             assertEquals(
-                    String.format("Failed to extract info from `%s` using aapt2", fakeApk.getName()),
+                    String.format(
+                            "Failed to extract info from `%s` using aapt2", fakeApk.getName()),
                     expected.getMessage());
         } finally {
         }
diff --git a/javatests/com/android/tradefed/targetprep/sync/IncrementalImageFuncTest.java b/javatests/com/android/tradefed/targetprep/sync/IncrementalImageFuncTest.java
index 72c677252..ff31ad07d 100644
--- a/javatests/com/android/tradefed/targetprep/sync/IncrementalImageFuncTest.java
+++ b/javatests/com/android/tradefed/targetprep/sync/IncrementalImageFuncTest.java
@@ -107,7 +107,6 @@ public class IncrementalImageFuncTest extends BaseHostJUnit4Test {
                         getBuild().getFile("target-image"),
                         getBuild().getFile("create_snapshot.zip"),
                         false,
-                        false,
                         SnapuserdWaitPhase.BLOCK_AFTER_UPDATE,
                         null);
         try {
diff --git a/javatests/com/android/tradefed/testtype/ArtTestTest.java b/javatests/com/android/tradefed/testtype/ArtTestTest.java
new file mode 100644
index 000000000..8de0ecae9
--- /dev/null
+++ b/javatests/com/android/tradefed/testtype/ArtTestTest.java
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+package com.android.tradefed.testtype;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import com.android.tradefed.device.DeviceNotAvailableException;
+import com.android.tradefed.device.ITestDevice;
+import com.android.tradefed.invoker.IInvocationContext;
+import com.android.tradefed.invoker.InvocationContext;
+import com.android.tradefed.invoker.TestInformation;
+import com.android.tradefed.result.ITestInvocationListener;
+import com.android.tradefed.util.CommandResult;
+import com.android.tradefed.util.CommandStatus;
+import com.android.tradefed.util.FileUtil;
+
+import org.json.JSONObject;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+
+/** Unit tests for {@link ArtTest}. */
+@RunWith(JUnit4.class)
+public class ArtTestTest {
+    public static final String INPUT =
+            String.join(
+                    "\n",
+                    "{",
+                    "    \"001-HelloWorld#1f5cdb07\": {",
+                    "      \"adb push\": [",
+                    "        [ \"../target/001-HelloWorld\",\"/data/local/tmp/art/test/1f5cdb07\""
+                            + " ],",
+                    "        [ \"001-HelloWorld/1f5cdb07.sh\","
+                            + " \"/data/local/tmp/art/test/1f5cdb07/run.sh\" ]",
+                    "      ],",
+                    "      \"adb shell\": [",
+                    "        [ \"sh\", \"/data/local/tmp/art/test/1f5cdb07/run.sh\" ]",
+                    "      ],",
+                    "      \"dependencies\": [",
+                    "        \"setup#compile-boot-image\"",
+                    "      ]",
+                    "    },",
+                    "    \"002-Foo#1f5cdb08\": {},",
+                    "    \"003-Bar#1f5cdb09\": {},",
+                    "    \"setup#compile-boot-image\": {",
+                    "      \"adb push\": [",
+                    "        [ \"setup.sh\", \"/data/local/tmp/art/setup.sh\" ]",
+                    "      ],",
+                    "      \"adb shell\": [",
+                    "        [ \"rm\", \"-rf\", \"/data/local/tmp/art/test\" ],",
+                    "        [ \"sh\", \"/data/local/tmp/art/setup.sh\" ]",
+                    "      ]",
+                    "    }",
+                    "}");
+
+    private ArtTest mTest;
+
+    @Mock ITestInvocationListener mListener;
+    @Mock ITestDevice mDevice;
+
+    static class ArtTestForTesting extends ArtTest {
+        @Override
+        File extractTarBall(File dst_dir) throws IOException {
+            File runnerDir = new File(dst_dir, "runner");
+            runnerDir.mkdirs();
+            try (FileWriter fw = new FileWriter(new File(runnerDir, "tests.json"))) {
+                fw.write(INPUT);
+            }
+            return runnerDir;
+        }
+    }
+
+    @Before
+    public void setUp() throws IOException {
+        mTest = new ArtTestForTesting();
+        mListener = mock(ITestInvocationListener.class);
+        mDevice = mock(ITestDevice.class);
+    }
+
+    @Test
+    public void testRunTests() throws DeviceNotAvailableException {
+        // Create mock test info.
+        IInvocationContext context = new InvocationContext();
+        context.addAllocatedDevice("device", mDevice);
+        TestInformation info = TestInformation.newBuilder().setInvocationContext(context).build();
+
+        // Implement mocked methods by just always returning SUCCESS (no device is needed).
+        CommandResult success = new CommandResult(CommandStatus.SUCCESS);
+        when(mDevice.executeShellV2Command(any())).thenReturn(success);
+
+        // Run the test.
+        mTest.run(info, mListener);
+
+        // Check the recorded behaviour of test.  We expected the following commands to be executed:
+        verify(mDevice).executeShellV2Command("rm -rf /data/local/tmp/art/test");
+        verify(mDevice).executeShellV2Command("sh /data/local/tmp/art/setup.sh");
+        verify(mDevice).executeShellV2Command("sh /data/local/tmp/art/test/1f5cdb07/run.sh");
+    }
+
+    @Test
+    public void testSharding() throws Exception {
+        ArtTestForTesting mainTest = new ArtTestForTesting();
+
+        Collection<IRemoteTest> shards = mainTest.split(2);
+        assertEquals(2, shards.size());
+
+        File tempDir = null;
+        try {
+            tempDir = FileUtil.createTempDir("art-test-sharding");
+
+            // Shard 0
+            ArtTest shard0 = (ArtTest) ((List<IRemoteTest>) shards).get(0);
+            assertEquals(0, shard0.mShardIndex);
+            assertEquals(2, shard0.mShardCount);
+            shard0.mRunnerDir = shard0.extractTarBall(new File(tempDir, "shard0_basedir"));
+            Map<String, JSONObject> testsShard0 = shard0.loadTests();
+            assertEquals(3, testsShard0.size());
+            assertTrue(testsShard0.containsKey("001-HelloWorld#1f5cdb07"));
+            assertTrue(testsShard0.containsKey("003-Bar#1f5cdb09"));
+            assertTrue(testsShard0.containsKey("setup#compile-boot-image"));
+
+            // Shard 1
+            ArtTest shard1 = (ArtTest) ((List<IRemoteTest>) shards).get(1);
+            assertEquals(1, shard1.mShardIndex);
+            assertEquals(2, shard1.mShardCount);
+            shard1.mRunnerDir = shard1.extractTarBall(new File(tempDir, "shard1_basedir"));
+            Map<String, JSONObject> testsShard1 = shard1.loadTests();
+            assertEquals(2, testsShard1.size());
+            assertTrue(testsShard1.containsKey("002-Foo#1f5cdb08"));
+            assertTrue(testsShard1.containsKey("setup#compile-boot-image"));
+
+        } finally {
+            FileUtil.recursiveDelete(tempDir);
+        }
+    }
+}
diff --git a/javatests/com/android/tradefed/testtype/InstrumentationTestTest.java b/javatests/com/android/tradefed/testtype/InstrumentationTestTest.java
index 4acd606fe..3c0b350c2 100644
--- a/javatests/com/android/tradefed/testtype/InstrumentationTestTest.java
+++ b/javatests/com/android/tradefed/testtype/InstrumentationTestTest.java
@@ -546,12 +546,12 @@ public class InstrumentationTestTest {
                 .testRunStarted(eq(TEST_PACKAGE_VALUE), eq(2), eq(0), anyLong());
         inOrder.verify(mMockListener).testStarted(eq(TEST1), anyLong());
         inOrder.verify(mMockListener).testEnded(eq(TEST1), anyLong(), eq(EMPTY_STRING_MAP));
-        inOrder.verify(mMockListener)
-                .testRunFailed(
-                        FailureDescription.create(RUN_ERROR_MSG, FailureStatus.TEST_FAILURE));
         inOrder.verify(mMockListener).testStarted(eq(TEST2), anyLong());
         inOrder.verify(mMockListener).testSkipped(eq(TEST2), (SkipReason) any());
         inOrder.verify(mMockListener).testEnded(eq(TEST2), anyLong(), eq(EMPTY_STRING_MAP));
+        inOrder.verify(mMockListener)
+                .testRunFailed(
+                        FailureDescription.create(RUN_ERROR_MSG, FailureStatus.TEST_FAILURE));
         inOrder.verify(mMockListener).testRunEnded(1, EMPTY_STRING_MAP);
         verify(mMockTestDevice).waitForDeviceAvailable();
         verify(mMockTestDevice).pushFile(Mockito.any(), Mockito.any());
diff --git a/javatests/com/android/tradefed/testtype/IsolatedHostTestTest.java b/javatests/com/android/tradefed/testtype/IsolatedHostTestTest.java
index e9e760b2f..04b080bea 100644
--- a/javatests/com/android/tradefed/testtype/IsolatedHostTestTest.java
+++ b/javatests/com/android/tradefed/testtype/IsolatedHostTestTest.java
@@ -18,7 +18,10 @@ package com.android.tradefed.testtype;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
@@ -38,6 +41,8 @@ import com.android.tradefed.testtype.coverage.CoverageOptions;
 import com.android.tradefed.util.FileUtil;
 import com.android.tradefed.util.ResourceUtil;
 
+import com.google.common.collect.Lists;
+
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
@@ -150,28 +155,59 @@ public class IsolatedHostTestTest {
     @Test
     public void testRavenwoodResourcesPositive() throws Exception {
         OptionSetter setter = new OptionSetter(mHostTest);
+
         setter.setOptionValue("use-ravenwood-resources", "true");
+        setter.setOptionValue("jar", "mytest.jar");
+
+        List<String> expectedLdLibraryPath = new ArrayList<>();
+
+        // Set up the directory structure.
+        File testDir = new File(mMockTestDir, "testdir");
+        testDir.mkdirs();
+
+        // Test jar
+        var testJar = new File(testDir, "mytest.jar");
+        testJar.createNewFile();
 
-        File dir = new File(mMockTestDir, "ravenwood-runtime");
-        dir.mkdirs();
-        File.createTempFile("temp", ".jar", dir);
+        File runtimeDir = new File(mMockTestDir, "ravenwood-runtime");
+        runtimeDir.mkdirs();
+        new File(runtimeDir, "runtime1.jar").createNewFile();
+        new File(runtimeDir, "runtime2.jar").createNewFile();
+        new File(runtimeDir, "z00-low-prio-1.jar").createNewFile();
+        new File(runtimeDir, "z10-low-prio-2.jar").createNewFile();
 
         // Create the JNI directories.
-        List<String> ldLibraryPath = new ArrayList<>();
-        makeDirAndAddToList(dir, "lib", ldLibraryPath);
-        makeDirAndAddToList(dir, "lib64", ldLibraryPath);
+        makeDirAndAddToList(testDir, "lib64", expectedLdLibraryPath);
+        makeDirAndAddToList(runtimeDir, "lib64", expectedLdLibraryPath);
 
+        // Set up mockito mocks
         doReturn(mMockTestDir).when(mMockBuildInfo).getFile(BuildInfoFileKey.HOST_LINKED_DIR);
         doReturn(36000).when(mMockServer).getLocalPort();
         doReturn(Inet4Address.getByName("localhost")).when(mMockServer).getInetAddress();
-        assertTrue(mHostTest.compileClassPath().contains("ravenwood-runtime"));
 
+        // ------------ Check start ------------
+
+        // build classpath and check it.
+        var classpath = mHostTest.compileClassPath();
+
+        // Remove the test top directory from classpath
+        classpath = classpath.replace(mMockTestDir.getAbsolutePath() + "/", "");
+
+        // We should have the following jars in classpath in the exact same order.
+        var expected =
+                Lists.newArrayList(
+                        "classpath/tradefed-isolation.jar",
+                        "ravenwood-runtime/runtime1.jar",
+                        "ravenwood-runtime/runtime2.jar",
+                        "testdir/mytest.jar",
+                        "ravenwood-runtime/z00-low-prio-1.jar",
+                        "ravenwood-runtime/z10-low-prio-2.jar");
+        assertEquals(String.join(":", expected), classpath);
+
+        // Check LD_LIBRARY_PATH too
         assertEquals(
-                String.join(java.io.File.pathSeparator, ldLibraryPath),
+                String.join(java.io.File.pathSeparator, expectedLdLibraryPath),
                 mHostTest.compileLdLibraryPathInner(null));
-
-        List<String> commandArgs = mHostTest.compileCommandArgs("", null);
-        assertTrue(commandArgs.contains("-Dandroid.junit.runner=org.junit.runners.JUnit4"));
     }
 
     @Test
@@ -236,12 +272,14 @@ public class IsolatedHostTestTest {
         FileUtil.deleteFile(mHostTest.getCoverageExecFile());
     }
 
-    private OptionSetter setUpSimpleMockJarTest(String jarName) throws Exception {
+    private OptionSetter setUpSimpleMockJarTest(String... jarNames) throws Exception {
         OptionSetter setter = new OptionSetter(mHostTest);
-        File jar = getJarResource("/" + jarName, mMockTestDir, jarName);
         doReturn(mMockTestDir).when(mMockBuildInfo).getFile(BuildInfoFileKey.HOST_LINKED_DIR);
         doReturn(mMockTestDir).when(mMockBuildInfo).getFile(BuildInfoFileKey.TESTDIR_IMAGE);
-        setter.setOptionValue("jar", jar.getName());
+        for (String jarName : jarNames) {
+            File jar = getJarResource("/" + jarName, mMockTestDir, jarName);
+            setter.setOptionValue("jar", jar.getName());
+        }
         setter.setOptionValue("exclude-paths", "org/junit");
         setter.setOptionValue("exclude-paths", "junit");
         return setter;
@@ -587,4 +625,57 @@ public class IsolatedHostTestTest {
                 .testLog((String) Mockito.any(), Mockito.eq(LogDataType.TEXT), Mockito.any());
         verify(mListener).testRunEnded(Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
     }
+
+    @Test
+    public void testSplit() throws Exception {
+        List<IRemoteTest> list = (ArrayList<IRemoteTest>) mHostTest.split(3);
+        assertEquals(3, list.size());
+        assertEquals(
+                "com.android.tradefed.testtype.IsolatedHostTest", list.get(0).getClass().getName());
+        assertEquals(
+                "com.android.tradefed.testtype.IsolatedHostTest", list.get(1).getClass().getName());
+        assertEquals(
+                "com.android.tradefed.testtype.IsolatedHostTest", list.get(2).getClass().getName());
+    }
+
+    @Test
+    public void testOneClass_TwoShards() throws Exception {
+        final String jarName = "SimplePassingTest.jar";
+        setUpSimpleMockJarTest(jarName);
+        TestInformation testInfo = TestInformation.newBuilder().build();
+
+        List<IRemoteTest> shards = (ArrayList<IRemoteTest>) mHostTest.split(2);
+
+        int shardIndex = 0;
+        for (IRemoteTest shard : shards) {
+            mListener = Mockito.mock(ITestInvocationListener.class);
+            shard.run(testInfo, mListener);
+            if (shardIndex == 0) {
+                verify(mListener, times(1)).testRunStarted(anyString(), eq(1));
+            } else {
+                verify(mListener, never()).testRunStarted(anyString(), eq(1));
+            }
+            shardIndex++;
+        }
+        mHostTest.run(testInfo, mListener);
+    }
+
+    @Test
+    public void testTwoClass_TwoShards() throws Exception {
+        final String jarName = "SimplePassingTest.jar";
+        final String jarName2 = "SimpleFailingTest.jar";
+        setUpSimpleMockJarTest(jarName, jarName2);
+
+        TestInformation testInfo = TestInformation.newBuilder().build();
+        List<IRemoteTest> shards = (ArrayList<IRemoteTest>) mHostTest.split(2);
+
+        int shardIndex = 0;
+        for (IRemoteTest shard : shards) {
+            mListener = Mockito.mock(ITestInvocationListener.class);
+            shard.run(testInfo, mListener);
+            verify(mListener, times(1)).testRunStarted(anyString(), eq(1));
+            shardIndex++;
+        }
+        mHostTest.run(testInfo, mListener);
+    }
 }
diff --git a/javatests/com/android/tradefed/testtype/OWNERS b/javatests/com/android/tradefed/testtype/OWNERS
new file mode 100644
index 000000000..157907b25
--- /dev/null
+++ b/javatests/com/android/tradefed/testtype/OWNERS
@@ -0,0 +1 @@
+per-file Art*=dsrbecky@google.com,ngeoffray@google.com
\ No newline at end of file
diff --git a/javatests/com/android/tradefed/testtype/PythonUnitTestResultParserTest.java b/javatests/com/android/tradefed/testtype/PythonUnitTestResultParserTest.java
index 630879dc4..2c6f4fa1a 100644
--- a/javatests/com/android/tradefed/testtype/PythonUnitTestResultParserTest.java
+++ b/javatests/com/android/tradefed/testtype/PythonUnitTestResultParserTest.java
@@ -55,6 +55,7 @@ public class PythonUnitTestResultParserTest {
     public static final String PYTHON_OUTPUT_FILE_2 = "python_output2.txt";
     public static final String PYTHON_OUTPUT_FILE_3 = "python_output3.txt";
     public static final String PYTHON_OUTPUT_FILE_4 = "python_output4.txt";
+    public static final String PYTHON_OUTPUT_FILE_5 = "python_output5.txt";
 
     private PythonUnitTestResultParser mParser;
     @Mock ITestInvocationListener mMockListener;
@@ -455,10 +456,10 @@ public class PythonUnitTestResultParserTest {
     @Test
     public void testParseSingleTestFail() throws Exception {
         String[] output = {
-            "b (a) ... ERROR",
+            "test_b (a) ... ERROR",
             "",
             PythonUnitTestResultParser.EQUAL_LINE,
-            "ERROR: b (a)",
+            "ERROR: test_b (a)",
             PythonUnitTestResultParser.DASH_LINE,
             "Traceback (most recent call last):",
             "  File \"test_rangelib.py\", line 129, in test_reallyfail",
@@ -470,7 +471,7 @@ public class PythonUnitTestResultParserTest {
             "",
             "FAILED (errors=1)"
         };
-        TestDescription id = new TestDescription("a", "b");
+        TestDescription id = new TestDescription("a", "test_b");
 
         mParser.processNewLines(output);
 
@@ -486,10 +487,10 @@ public class PythonUnitTestResultParserTest {
     @Test
     public void testParseSubtestFailure() throws Exception {
         String[] output = {
-            "b (a) ... d (c) ... ok", // Tests with failed subtests don't output a status.
+            "test_b (a) ... test_d (c) ... ok", // Tests with failed subtests don't output a status.
             "",
             PythonUnitTestResultParser.EQUAL_LINE,
-            "FAIL: b (a) (i=3)",
+            "FAIL: test_b (a) (i=3)",
             PythonUnitTestResultParser.DASH_LINE,
             "Traceback (most recent call last):",
             "  File \"example_test.py\", line 129, in test_with_failing_subtests",
@@ -500,8 +501,8 @@ public class PythonUnitTestResultParserTest {
             "",
             "FAILED (failures=1)"
         };
-        TestDescription id = new TestDescription("a", "b");
-        TestDescription id2 = new TestDescription("c", "d");
+        TestDescription id = new TestDescription("a", "test_b");
+        TestDescription id2 = new TestDescription("c", "test_d");
 
         mParser.processNewLines(output);
 
@@ -520,11 +521,11 @@ public class PythonUnitTestResultParserTest {
     @Test
     public void testParseMultiTestFailWithExpectedFailure() throws Exception {
         String[] output = {
-            "b (a) ... expected failure",
-            "d (c) ... ERROR",
+            "test_b (a) ... expected failure",
+            "test_d (c) ... ERROR",
             "",
             PythonUnitTestResultParser.EQUAL_LINE,
-            "ERROR: d (c)",
+            "ERROR: test_d (c)",
             PythonUnitTestResultParser.DASH_LINE,
             "Traceback (most recent call last):",
             "  File \"test_rangelib.py\", line 129, in test_reallyfail",
@@ -536,8 +537,8 @@ public class PythonUnitTestResultParserTest {
             "",
             "FAILED (errors=1)"
         };
-        TestDescription id = new TestDescription("a", "b");
-        TestDescription id2 = new TestDescription("c", "d");
+        TestDescription id = new TestDescription("a", "test_b");
+        TestDescription id2 = new TestDescription("c", "test_d");
 
         mParser.processNewLines(output);
 
@@ -591,14 +592,14 @@ public class PythonUnitTestResultParserTest {
     @Test
     public void testParseSingleTestUnexpectedSuccess() throws Exception {
         String[] output = {
-            "b (a) ... unexpected success",
+            "test_b (a) ... unexpected success",
             "",
             PythonUnitTestResultParser.DASH_LINE,
             "Ran 1 test in 1s",
             "",
             "OK (unexpected success=1)",
         };
-        TestDescription id = new TestDescription("a", "b");
+        TestDescription id = new TestDescription("a", "test_b");
 
         mParser.processNewLines(output);
 
@@ -614,14 +615,14 @@ public class PythonUnitTestResultParserTest {
     @Test
     public void testParseSingleTestSkipped() throws Exception {
         String[] output = {
-            "b (a) ... skipped 'reason foo'",
+            "test_b (a) ... skipped 'reason foo'",
             "",
             PythonUnitTestResultParser.DASH_LINE,
             "Ran 1 test in 1s",
             "",
             "OK (skipped=1)",
         };
-        TestDescription id = new TestDescription("a", "b");
+        TestDescription id = new TestDescription("a", "test_b");
 
         mParser.processNewLines(output);
 
@@ -660,11 +661,11 @@ public class PythonUnitTestResultParserTest {
     @Test
     public void testParseSingleTestFailWithDocString() throws Exception {
         String[] output = {
-            "b (a)",
+            "test_b (a)",
             "doc string foo bar ... ERROR",
             "",
             PythonUnitTestResultParser.EQUAL_LINE,
-            "ERROR: b (a)",
+            "ERROR: test_b (a)",
             "doc string foo bar",
             PythonUnitTestResultParser.DASH_LINE,
             "Traceback (most recent call last):",
@@ -677,7 +678,7 @@ public class PythonUnitTestResultParserTest {
             "",
             "FAILED (errors=1)"
         };
-        TestDescription id = new TestDescription("a", "b");
+        TestDescription id = new TestDescription("a", "test_b");
 
         mParser.processNewLines(output);
 
@@ -778,10 +779,10 @@ public class PythonUnitTestResultParserTest {
     @Test
     public void testCaptureMultilineTraceback() {
         String[] output = {
-            "b (a) ... ERROR",
+            "test_b (a) ... ERROR",
             "",
             PythonUnitTestResultParser.EQUAL_LINE,
-            "ERROR: b (a)",
+            "ERROR: test_b (a)",
             PythonUnitTestResultParser.DASH_LINE,
             "Traceback (most recent call last):",
             "  File \"test_rangelib.py\", line 129, in test_reallyfail",
@@ -1033,6 +1034,22 @@ public class PythonUnitTestResultParserTest {
         mParser.processNewLines(contents);
     }
 
+    @Test
+    public void testSetupClassFailureReportedAsRunFailure() {
+        String[] contents = readInFile(PYTHON_OUTPUT_FILE_5);
+
+        mParser.processNewLines(contents);
+        InOrder inOrder = Mockito.inOrder(mMockListener);
+        String errorMsg =
+                "Traceback (most recent call last):\n"
+                        + "  File \"test_binary.py\", line 54, in setUpClass\n"
+                        + "AssertionError";
+
+        inOrder.verify(mMockListener).testRunStarted("test", 0);
+        inOrder.verify(mMockListener).testRunFailed(errorMsg);
+        verify(mMockListener).testRunEnded(0, new HashMap<String, Metric>());
+    }
+
     /**
      * Helper to read a file from the res/testtype directory and return its contents as a String[]
      *
diff --git a/javatests/com/android/tradefed/testtype/PythonUnitTestRunnerTest.java b/javatests/com/android/tradefed/testtype/PythonUnitTestRunnerTest.java
index b177d5986..904fc9d07 100644
--- a/javatests/com/android/tradefed/testtype/PythonUnitTestRunnerTest.java
+++ b/javatests/com/android/tradefed/testtype/PythonUnitTestRunnerTest.java
@@ -50,10 +50,10 @@ public class PythonUnitTestRunnerTest {
     };
 
     private static final String[] TEST_FAIL_STDERR = {
-        "b (a) ... ERROR",
+        "test_b (a) ... ERROR",
         "",
         PythonUnitTestResultParser.EQUAL_LINE,
-        "ERROR: b (a)",
+        "ERROR: test_b (a)",
         PythonUnitTestResultParser.DASH_LINE,
         "Traceback (most recent call last):",
         "  File \"test_rangelib.py\", line 129, in test_reallyfail",
diff --git a/javatests/com/android/tradefed/testtype/binary/KernelTargetTestTest.java b/javatests/com/android/tradefed/testtype/binary/KernelTargetTestTest.java
index c005c2ddd..1d563bfe0 100644
--- a/javatests/com/android/tradefed/testtype/binary/KernelTargetTestTest.java
+++ b/javatests/com/android/tradefed/testtype/binary/KernelTargetTestTest.java
@@ -18,6 +18,7 @@ package com.android.tradefed.testtype.binary;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyInt;
 import static org.mockito.ArgumentMatchers.anyLong;
 import static org.mockito.ArgumentMatchers.eq;
 
@@ -273,7 +274,9 @@ public class KernelTargetTestTest {
         mCommandResult = new CommandResult(CommandStatus.SUCCESS);
         mCommandResult.setStdout(TEST_KTAP_RESULT_1);
         mCommandResult.setExitCode(0);
-        Mockito.when(mMockITestDevice.executeShellV2Command(eq(TEST_CMD_1), anyLong(), any()))
+        Mockito.when(
+                        mMockITestDevice.executeShellV2Command(
+                                eq(TEST_CMD_1), anyLong(), any(), anyInt()))
                 .thenReturn(mCommandResult);
 
         ArrayList<Pair<TestDescription, Boolean>> expectedTestResults = new ArrayList<>();
diff --git a/javatests/com/android/tradefed/testtype/mobly/MoblyArtifactReporterTest.java b/javatests/com/android/tradefed/testtype/mobly/MoblyArtifactReporterTest.java
new file mode 100644
index 000000000..b50b228e9
--- /dev/null
+++ b/javatests/com/android/tradefed/testtype/mobly/MoblyArtifactReporterTest.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.testtype.mobly;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
+import com.android.tradefed.result.ITestInvocationListener;
+import com.android.tradefed.util.FileUtil;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mockito;
+
+import java.io.File;
+
+/** Unit tests for {@link MoblyYamlResultParser}. */
+@RunWith(JUnit4.class)
+public class MoblyArtifactReporterTest {
+    private MoblyArtifactReporter mReporter;
+    private ITestInvocationListener mMockListener;
+    private File mRootDir;
+
+    private File createTempFiles() throws Exception {
+        File rootDir = FileUtil.createTempDir("root_dir");
+        File classDir = FileUtil.createTempDir("class_dir", rootDir);
+        File testDir = FileUtil.createTempDir("test_dir", classDir);
+        File run_artifact = FileUtil.createTempFile("run_artifact", ".txt", rootDir);
+        File class_artifact = FileUtil.createTempFile("class_artifact", ".txt", classDir);
+        File test_artifact = FileUtil.createTempFile("test_artifact", ".txt", testDir);
+        return rootDir;
+    }
+
+    @Before
+    public void setUp() throws Exception {
+        mMockListener = Mockito.mock(ITestInvocationListener.class);
+        mRootDir = createTempFiles();
+    }
+
+    @After
+    public void tearDown() {
+        FileUtil.recursiveDelete(mRootDir);
+    }
+
+    @Test
+    public void testReportAllRunArtifacts() {
+        MoblyArtifactReporter reporter = new MoblyArtifactReporter(mRootDir);
+
+        reporter.reportRunArtifacts(mMockListener);
+        verify(mMockListener, times(3)).testLog(any(), any(), any());
+        reporter.reportRunArtifacts(mMockListener);
+        verify(mMockListener, times(3)).testLog(any(), any(), any());
+    }
+
+    private MoblyYamlResultRecordHandler.Record createRecord(String testName, String testClass) {
+        return MoblyYamlResultRecordHandler.Record.builder()
+                .setTestName(testName)
+                .setTestClass(testClass)
+                .setBeginTime("null")
+                .setEndTime("null")
+                .build();
+    }
+
+    @Test
+    public void testReportOnlyTestArtifact() {
+        MoblyArtifactReporter reporter = new MoblyArtifactReporter(mRootDir);
+        MoblyYamlResultRecordHandler.Record record = createRecord("test_dir", "class_dir");
+        reporter.reportArtifactsForRecord(mMockListener, record);
+        verify(mMockListener, times(1)).testLog(any(), any(), any());
+    }
+
+    @Test
+    public void testReportTestArtifact_ThenRemainingArtifacts() {
+        MoblyArtifactReporter reporter = new MoblyArtifactReporter(mRootDir);
+        MoblyYamlResultRecordHandler.Record record = createRecord("test_dir", "class_dir");
+        reporter.reportArtifactsForRecord(mMockListener, record);
+        verify(mMockListener, times(1)).testLog(any(), any(), any());
+        reporter.reportRunArtifacts(mMockListener);
+        verify(mMockListener, times(3)).testLog(any(), any(), any());
+    }
+}
diff --git a/javatests/com/android/tradefed/testtype/mobly/MoblyBinaryHostTestTest.java b/javatests/com/android/tradefed/testtype/mobly/MoblyBinaryHostTestTest.java
index 9e62e5f0b..6f6a3aff2 100644
--- a/javatests/com/android/tradefed/testtype/mobly/MoblyBinaryHostTestTest.java
+++ b/javatests/com/android/tradefed/testtype/mobly/MoblyBinaryHostTestTest.java
@@ -47,7 +47,6 @@ import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
 import com.android.tradefed.util.FileUtil;
 import com.android.tradefed.util.IRunUtil;
-import com.android.utils.FileUtils;
 
 import com.google.common.truth.Truth;
 
@@ -87,6 +86,7 @@ public class MoblyBinaryHostTestTest {
     private ITestDevice mMockDevice2;
     private IRunUtil mMockRunUtil;
     private MoblyYamlResultParser mMockParser;
+    private MoblyArtifactReporter mMockArtifactReporter;
     private InputStream mMockSummaryInputStream;
     private File mMoblyTestDir;
     private File mMoblyBinary; // used by mobly-binaries option
@@ -101,6 +101,7 @@ public class MoblyBinaryHostTestTest {
         mMockDevice = Mockito.mock(ITestDevice.class);
         mMockRunUtil = Mockito.mock(IRunUtil.class);
         mMockBuildInfo = Mockito.mock(DeviceBuildInfo.class);
+        mMockArtifactReporter = Mockito.mock(MoblyArtifactReporter.class);
         IInvocationContext context = new InvocationContext();
         context.addAllocatedDevice("device", mMockDevice);
         context.addDeviceBuildInfo("device", mMockBuildInfo);
@@ -114,6 +115,7 @@ public class MoblyBinaryHostTestTest {
         Mockito.doReturn(mTestInfo).when(mSpyTest).getTestInfo();
         Mockito.doReturn(mMockRunUtil).when(mSpyTest).getRunUtil();
         Mockito.doReturn(DEFAULT_TIME_OUT).when(mSpyTest).getTestTimeout();
+        Mockito.doReturn(mMockArtifactReporter).when(mSpyTest).getArtifactReporter();
         Mockito.doReturn("not_adb").when(mSpyTest).getAdbPath();
         mMoblyTestDir = FileUtil.createTempDir("mobly_tests");
         mMoblyBinary = FileUtil.createTempFile("mobly_binary", ".par", mMoblyTestDir);
@@ -143,10 +145,10 @@ public class MoblyBinaryHostTestTest {
                         })
                 .thenAnswer(
                         invocation -> {
-                            FileUtils.createFile(testResult, "");
-                            FileUtils.createFile(
-                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"),
-                                    "log content");
+                            testResult.createNewFile();
+                            FileUtil.writeToFile(
+                                    "log content",
+                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"));
                             return new CommandResult(CommandStatus.SUCCESS);
                         });
 
@@ -164,7 +166,7 @@ public class MoblyBinaryHostTestTest {
 
         mSpyTest.run(mTestInfo, Mockito.mock(ITestInvocationListener.class));
 
-        verify(mSpyTest, never()).reportLogs(any(), any());
+        verify(mMockArtifactReporter, never()).reportRunArtifacts(any());
     }
 
     @Test
@@ -184,10 +186,10 @@ public class MoblyBinaryHostTestTest {
                         })
                 .thenAnswer(
                         invocation -> {
-                            FileUtils.createFile(testResult, "");
-                            FileUtils.createFile(
-                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"),
-                                    "log content");
+                            testResult.createNewFile();
+                            FileUtil.writeToFile(
+                                    "log content",
+                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"));
                             return new CommandResult(CommandStatus.SUCCESS);
                         });
 
@@ -209,7 +211,7 @@ public class MoblyBinaryHostTestTest {
 
         mSpyTest.run(mTestInfo, mockListener);
 
-        verify(mSpyTest, never()).reportLogs(any(), any());
+        verify(mMockArtifactReporter, never()).reportRunArtifacts(any());
         verify(mockListener, times(1)).testRunStarted(eq(mMoblyBinary2.getName()), eq(0));
         verify(mockListener, times(1)).testRunFailed(any(FailureDescription.class));
         verify(mockListener, times(1)).testRunEnded(eq(0L), eq(new HashMap<String, Metric>()));
@@ -233,10 +235,10 @@ public class MoblyBinaryHostTestTest {
                                 anyLong(), any(OutputStream.class), any(OutputStream.class), any()))
                 .thenAnswer(
                         invocation -> {
-                            FileUtils.createFile(testResult, "");
-                            FileUtils.createFile(
-                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"),
-                                    "log content");
+                            testResult.createNewFile();
+                            FileUtil.writeToFile(
+                                    "log content",
+                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"));
                             return new CommandResult(CommandStatus.SUCCESS);
                         });
 
@@ -290,10 +292,10 @@ public class MoblyBinaryHostTestTest {
                         })
                 .thenAnswer(
                         invocation -> {
-                            FileUtils.createFile(testResult, "");
-                            FileUtils.createFile(
-                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"),
-                                    "log content");
+                            testResult.createNewFile();
+                            FileUtil.writeToFile(
+                                    "log content",
+                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"));
                             return new CommandResult(CommandStatus.SUCCESS);
                         });
         CommandResult result = new CommandResult(CommandStatus.SUCCESS);
@@ -326,10 +328,10 @@ public class MoblyBinaryHostTestTest {
                         })
                 .thenAnswer(
                         invocation -> {
-                            FileUtils.createFile(testResult, "");
-                            FileUtils.createFile(
-                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"),
-                                    "log content");
+                            testResult.createNewFile();
+                            FileUtil.writeToFile(
+                                    "log content",
+                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"));
                             return new CommandResult(CommandStatus.SUCCESS);
                         });
 
@@ -354,7 +356,7 @@ public class MoblyBinaryHostTestTest {
                         })
                 .thenAnswer(
                         invocation -> {
-                            FileUtils.createFile(testResult, testResultContent);
+                            FileUtil.writeToFile(testResultContent, testResult);
                             return new CommandResult(CommandStatus.SUCCESS);
                         });
 
@@ -383,7 +385,7 @@ public class MoblyBinaryHostTestTest {
                         })
                 .thenAnswer(
                         invocation -> {
-                            FileUtils.createFile(testResult, testResultContent);
+                            FileUtil.writeToFile(testResultContent, testResult);
                             return new CommandResult(CommandStatus.SUCCESS);
                         });
 
@@ -412,7 +414,7 @@ public class MoblyBinaryHostTestTest {
                         })
                 .thenAnswer(
                         invocation -> {
-                            FileUtils.createFile(testResult, testResultContent);
+                            FileUtil.writeToFile(testResultContent, testResult);
                             return new CommandResult(CommandStatus.FAILED);
                         });
 
@@ -441,7 +443,7 @@ public class MoblyBinaryHostTestTest {
                         })
                 .thenAnswer(
                         invocation -> {
-                            FileUtils.createFile(testResult, testResultContent);
+                            FileUtil.writeToFile(testResultContent, testResult);
                             CommandResult res = new CommandResult(CommandStatus.FAILED);
                             res.setStderr("Some error message");
                             return res;
@@ -497,7 +499,6 @@ public class MoblyBinaryHostTestTest {
 
     @Test
     public void testBuildCommandLineArrayWithOutConfig() throws Exception {
-        Mockito.doNothing().when(mSpyTest).reportLogs(any(), any());
         Mockito.doReturn(DEVICE_SERIAL).when(mMockDevice).getSerialNumber();
         Mockito.doReturn(LOG_PATH).when(mSpyTest).getLogDirAbsolutePath();
         List<String> expOptions = Arrays.asList("--option1", "--option2=test_option");
@@ -518,7 +519,6 @@ public class MoblyBinaryHostTestTest {
 
     @Test
     public void testBuildCommandLineArrayWithOutConfigWithWildcardOn() throws Exception {
-        Mockito.doNothing().when(mSpyTest).reportLogs(any(), any());
         OptionSetter setter = new OptionSetter(mSpyTest);
         setter.setOptionValue("mobly-par-file-name", mMoblyBinary2.getName());
         setter.setOptionValue("mobly-wildcard-config", "true");
@@ -535,10 +535,10 @@ public class MoblyBinaryHostTestTest {
                         })
                 .thenAnswer(
                         invocation -> {
-                            FileUtils.createFile(testResult, "");
-                            FileUtils.createFile(
-                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"),
-                                    "log content");
+                            testResult.createNewFile();
+                            FileUtil.writeToFile(
+                                    "log content",
+                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"));
                             return new CommandResult(CommandStatus.SUCCESS);
                         });
 
@@ -560,7 +560,6 @@ public class MoblyBinaryHostTestTest {
 
     @Test
     public void testRun_testListWithOnlyBadTestNames() throws Exception {
-        Mockito.doNothing().when(mSpyTest).reportLogs(any(), any());
         OptionSetter setter = new OptionSetter(mSpyTest);
         setter.setOptionValue("mobly-binaries", mMoblyBinary.getAbsolutePath());
         File testResult = new File(mSpyTest.getLogDirAbsolutePath(), TEST_RESULT_FILE_NAME);
@@ -574,10 +573,10 @@ public class MoblyBinaryHostTestTest {
                         })
                 .thenAnswer(
                         invocation -> {
-                            FileUtils.createFile(testResult, "");
-                            FileUtils.createFile(
-                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"),
-                                    "log content");
+                            testResult.createNewFile();
+                            FileUtil.writeToFile(
+                                    "log content",
+                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"));
                             return new CommandResult(CommandStatus.SUCCESS);
                         });
 
@@ -590,7 +589,6 @@ public class MoblyBinaryHostTestTest {
 
     @Test
     public void testRun_testListWithOnlyGoodTestNames() throws Exception {
-        Mockito.doNothing().when(mSpyTest).reportLogs(any(), any());
         OptionSetter setter = new OptionSetter(mSpyTest);
         setter.setOptionValue("mobly-binaries", mMoblyBinary.getAbsolutePath());
         File testResult = new File(mSpyTest.getLogDirAbsolutePath(), TEST_RESULT_FILE_NAME);
@@ -600,17 +598,17 @@ public class MoblyBinaryHostTestTest {
                             CommandResult res = new CommandResult(CommandStatus.SUCCESS);
                             res.setStdout(
                                     "==========> ClassTest <==========\n"
-                                        + "test_foo\n"
-                                        + "test_baz\n"
-                                        + "ClassTest.test_bar");
+                                            + "test_foo\n"
+                                            + "test_baz\n"
+                                            + "ClassTest.test_bar");
                             return res;
                         })
                 .thenAnswer(
                         invocation -> {
-                            FileUtils.createFile(testResult, "");
-                            FileUtils.createFile(
-                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"),
-                                    "log content");
+                            testResult.createNewFile();
+                            FileUtil.writeToFile(
+                                    "log content",
+                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"));
                             return new CommandResult(CommandStatus.SUCCESS);
                         });
 
@@ -623,7 +621,6 @@ public class MoblyBinaryHostTestTest {
 
     @Test
     public void testRun_testListWithBadTestNames() throws Exception {
-        Mockito.doNothing().when(mSpyTest).reportLogs(any(), any());
         OptionSetter setter = new OptionSetter(mSpyTest);
         setter.setOptionValue("mobly-binaries", mMoblyBinary.getAbsolutePath());
         File testResult = new File(mSpyTest.getLogDirAbsolutePath(), TEST_RESULT_FILE_NAME);
@@ -633,20 +630,20 @@ public class MoblyBinaryHostTestTest {
                             CommandResult res = new CommandResult(CommandStatus.SUCCESS);
                             res.setStdout(
                                     "==========> ClassTest <==========\n"
-                                        + "test_foo\n"
-                                        + "abc\n"
-                                        + "test_baz\n"
-                                        + "ClassTest.test_bar\n"
-                                        + "ClassTest.\n"
-                                        + "test");
+                                            + "test_foo\n"
+                                            + "abc\n"
+                                            + "test_baz\n"
+                                            + "ClassTest.test_bar\n"
+                                            + "ClassTest.\n"
+                                            + "test");
                             return res;
                         })
                 .thenAnswer(
                         invocation -> {
-                            FileUtils.createFile(testResult, "");
-                            FileUtils.createFile(
-                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"),
-                                    "log content");
+                            testResult.createNewFile();
+                            FileUtil.writeToFile(
+                                    "log content",
+                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"));
                             return new CommandResult(CommandStatus.SUCCESS);
                         });
 
@@ -659,7 +656,6 @@ public class MoblyBinaryHostTestTest {
 
     @Test
     public void testRun_withoutTests() throws Exception {
-        Mockito.doNothing().when(mSpyTest).reportLogs(any(), any());
         OptionSetter setter = new OptionSetter(mSpyTest);
         setter.setOptionValue("mobly-par-file-name", mMoblyBinary2.getName());
         Mockito.doReturn(mMoblyTestDir)
@@ -675,10 +671,10 @@ public class MoblyBinaryHostTestTest {
                         })
                 .thenAnswer(
                         invocation -> {
-                            FileUtils.createFile(testResult, "");
-                            FileUtils.createFile(
-                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"),
-                                    "log content");
+                            testResult.createNewFile();
+                            FileUtil.writeToFile(
+                                    "log content",
+                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"));
                             return new CommandResult(CommandStatus.SUCCESS);
                         });
 
@@ -694,7 +690,6 @@ public class MoblyBinaryHostTestTest {
 
     @Test
     public void testRun_withoutFilters() throws Exception {
-        Mockito.doNothing().when(mSpyTest).reportLogs(any(), any());
         OptionSetter setter = new OptionSetter(mSpyTest);
         setter.setOptionValue("mobly-par-file-name", mMoblyBinary2.getName());
         Mockito.doReturn(mMoblyTestDir)
@@ -710,10 +705,10 @@ public class MoblyBinaryHostTestTest {
                         })
                 .thenAnswer(
                         invocation -> {
-                            FileUtils.createFile(testResult, "");
-                            FileUtils.createFile(
-                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"),
-                                    "log content");
+                            testResult.createNewFile();
+                            FileUtil.writeToFile(
+                                    "log content",
+                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"));
                             return new CommandResult(CommandStatus.SUCCESS);
                         });
 
@@ -735,7 +730,6 @@ public class MoblyBinaryHostTestTest {
 
     @Test
     public void testRun_withIncludeFiltersExact() throws Exception {
-        Mockito.doNothing().when(mSpyTest).reportLogs(any(), any());
         OptionSetter setter = new OptionSetter(mSpyTest);
         setter.setOptionValue("mobly-binaries", mMoblyBinary.getAbsolutePath());
         File testResult = new File(mSpyTest.getLogDirAbsolutePath(), TEST_RESULT_FILE_NAME);
@@ -747,17 +741,17 @@ public class MoblyBinaryHostTestTest {
                             CommandResult res = new CommandResult(CommandStatus.SUCCESS);
                             res.setStdout(
                                     "==========> FooTest <==========\n"
-                                        + "test_foo\n"
-                                        + "test_baz\n"
-                                        + "test_bar");
+                                            + "test_foo\n"
+                                            + "test_baz\n"
+                                            + "test_bar");
                             return res;
                         })
                 .thenAnswer(
                         invocation -> {
-                            FileUtils.createFile(testResult, "");
-                            FileUtils.createFile(
-                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"),
-                                    "log content");
+                            testResult.createNewFile();
+                            FileUtil.writeToFile(
+                                    "log content",
+                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"));
                             return new CommandResult(CommandStatus.SUCCESS);
                         });
 
@@ -786,7 +780,6 @@ public class MoblyBinaryHostTestTest {
 
     @Test
     public void testRun_withIncludeFiltersPrefix() throws Exception {
-        Mockito.doNothing().when(mSpyTest).reportLogs(any(), any());
         OptionSetter setter = new OptionSetter(mSpyTest);
         setter.setOptionValue("mobly-binaries", mMoblyBinary.getAbsolutePath());
         File testResult = new File(mSpyTest.getLogDirAbsolutePath(), TEST_RESULT_FILE_NAME);
@@ -797,17 +790,17 @@ public class MoblyBinaryHostTestTest {
                             CommandResult res = new CommandResult(CommandStatus.SUCCESS);
                             res.setStdout(
                                     "==========> FooTest <==========\n"
-                                        + "test_foo\n"
-                                        + "test_baz\n"
-                                        + "test_bar");
+                                            + "test_foo\n"
+                                            + "test_baz\n"
+                                            + "test_bar");
                             return res;
                         })
                 .thenAnswer(
                         invocation -> {
-                            FileUtils.createFile(testResult, "");
-                            FileUtils.createFile(
-                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"),
-                                    "log content");
+                            testResult.createNewFile();
+                            FileUtil.writeToFile(
+                                    "log content",
+                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"));
                             return new CommandResult(CommandStatus.SUCCESS);
                         });
 
@@ -836,7 +829,6 @@ public class MoblyBinaryHostTestTest {
 
     @Test
     public void testRun_withExcludeFiltersExact() throws Exception {
-        Mockito.doNothing().when(mSpyTest).reportLogs(any(), any());
         OptionSetter setter = new OptionSetter(mSpyTest);
         setter.setOptionValue("mobly-binaries", mMoblyBinary.getAbsolutePath());
         File testResult = new File(mSpyTest.getLogDirAbsolutePath(), TEST_RESULT_FILE_NAME);
@@ -848,17 +840,17 @@ public class MoblyBinaryHostTestTest {
                             CommandResult res = new CommandResult(CommandStatus.SUCCESS);
                             res.setStdout(
                                     "==========> FooTest <==========\n"
-                                        + "test_foo\n"
-                                        + "test_baz\n"
-                                        + "test_bar");
+                                            + "test_foo\n"
+                                            + "test_baz\n"
+                                            + "test_bar");
                             return res;
                         })
                 .thenAnswer(
                         invocation -> {
-                            FileUtils.createFile(testResult, "");
-                            FileUtils.createFile(
-                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"),
-                                    "log content");
+                            testResult.createNewFile();
+                            FileUtil.writeToFile(
+                                    "log content",
+                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"));
                             return new CommandResult(CommandStatus.SUCCESS);
                         });
 
@@ -886,7 +878,6 @@ public class MoblyBinaryHostTestTest {
 
     @Test
     public void testRun_withExcludeFiltersNoTests() throws Exception {
-        Mockito.doNothing().when(mSpyTest).reportLogs(any(), any());
         OptionSetter setter = new OptionSetter(mSpyTest);
         setter.setOptionValue("mobly-binaries", mMoblyBinary.getAbsolutePath());
         File testResult = new File(mSpyTest.getLogDirAbsolutePath(), TEST_RESULT_FILE_NAME);
@@ -899,17 +890,17 @@ public class MoblyBinaryHostTestTest {
                             CommandResult res = new CommandResult(CommandStatus.SUCCESS);
                             res.setStdout(
                                     "==========> FooTest <==========\n"
-                                        + "test_foo\n"
-                                        + "test_baz\n"
-                                        + "test_bar");
+                                            + "test_foo\n"
+                                            + "test_baz\n"
+                                            + "test_bar");
                             return res;
                         })
                 .thenAnswer(
                         invocation -> {
-                            FileUtils.createFile(testResult, "");
-                            FileUtils.createFile(
-                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"),
-                                    "log content");
+                            testResult.createNewFile();
+                            FileUtil.writeToFile(
+                                    "log content",
+                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"));
                             return new CommandResult(CommandStatus.SUCCESS);
                         });
 
@@ -922,7 +913,6 @@ public class MoblyBinaryHostTestTest {
 
     @Test
     public void testRun_withBothIncludeAndExcludeFilters() throws Exception {
-        Mockito.doNothing().when(mSpyTest).reportLogs(any(), any());
         OptionSetter setter = new OptionSetter(mSpyTest);
         setter.setOptionValue("mobly-binaries", mMoblyBinary.getAbsolutePath());
         File testResult = new File(mSpyTest.getLogDirAbsolutePath(), TEST_RESULT_FILE_NAME);
@@ -934,17 +924,17 @@ public class MoblyBinaryHostTestTest {
                             CommandResult res = new CommandResult(CommandStatus.SUCCESS);
                             res.setStdout(
                                     "==========> FooTest <==========\n"
-                                        + "test_foo\n"
-                                        + "test_baz\n"
-                                        + "test_bar");
+                                            + "test_foo\n"
+                                            + "test_baz\n"
+                                            + "test_bar");
                             return res;
                         })
                 .thenAnswer(
                         invocation -> {
-                            FileUtils.createFile(testResult, "");
-                            FileUtils.createFile(
-                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"),
-                                    "log content");
+                            testResult.createNewFile();
+                            FileUtil.writeToFile(
+                                    "log content",
+                                    new File(mSpyTest.getLogDirAbsolutePath(), "log"));
                             return new CommandResult(CommandStatus.SUCCESS);
                         });
 
@@ -972,7 +962,6 @@ public class MoblyBinaryHostTestTest {
 
     @Test
     public void testRun_withSharding() throws Exception {
-        Mockito.doNothing().when(mSpyTest).reportLogs(any(), any());
         OptionSetter setter = new OptionSetter(mSpyTest);
         setter.setOptionValue("mobly-par-file-name", mMoblyBinary2.getName());
         Mockito.doReturn(mMoblyTestDir)
@@ -1005,7 +994,6 @@ public class MoblyBinaryHostTestTest {
 
     @Test
     public void testRun_oneTest_twoShards() throws Exception {
-        Mockito.doNothing().when(mSpyTest).reportLogs(any(), any());
         OptionSetter setter = new OptionSetter(mSpyTest);
         setter.setOptionValue("mobly-par-file-name", mMoblyBinary2.getName());
         Mockito.doReturn(mMoblyTestDir)
@@ -1042,8 +1030,6 @@ public class MoblyBinaryHostTestTest {
 
     @Test
     public void testFilterTests_withIncludeFilters() throws Exception {
-        Mockito.doNothing().when(mSpyTest).reportLogs(any(), any());
-
         mSpyTest.addAllIncludeFilters(
                 Set.of("test_foo", "BarTest#test_bar_1", "BarTest#test_bar_3"));
 
@@ -1077,8 +1063,6 @@ public class MoblyBinaryHostTestTest {
 
     @Test
     public void testFilterTests_withExcludeFilters() throws Exception {
-        Mockito.doNothing().when(mSpyTest).reportLogs(any(), any());
-
         mSpyTest.addAllExcludeFilters(
                 Set.of("FooTest", "BarTest#test_bar_1", "BarTest#test_bar_3"));
 
@@ -1106,8 +1090,6 @@ public class MoblyBinaryHostTestTest {
 
     @Test
     public void testFilterTests_withBothIncludeAndExcludeFilters() throws Exception {
-        Mockito.doNothing().when(mSpyTest).reportLogs(any(), any());
-
         mSpyTest.addAllIncludeFilters(Set.of("BarTest"));
         mSpyTest.addAllExcludeFilters(Set.of("test_bar_1", "BarTest#test_bar_3"));
 
@@ -1135,7 +1117,6 @@ public class MoblyBinaryHostTestTest {
 
     @Test
     public void testBuildCommandLineArrayWithConfig() throws Exception {
-        Mockito.doNothing().when(mSpyTest).reportLogs(any(), any());
         Mockito.doReturn(DEVICE_SERIAL).when(mMockDevice).getSerialNumber();
         Mockito.doReturn(LOG_PATH).when(mSpyTest).getLogDirAbsolutePath();
         List<String> expOptions = Arrays.asList("--option1", "--option2=test_option");
@@ -1177,7 +1158,6 @@ public class MoblyBinaryHostTestTest {
 
     @Test
     public void testProcessYamlTestResultsSuccess() throws Exception {
-        Mockito.doNothing().when(mSpyTest).reportLogs(any(), any());
         mMockSummaryInputStream = Mockito.mock(InputStream.class);
         mMockParser = Mockito.mock(MoblyYamlResultParser.class);
         mSpyTest.processYamlTestResults(
@@ -1192,7 +1172,6 @@ public class MoblyBinaryHostTestTest {
     public void testUpdateConfigFile() throws Exception {
         Mockito.doReturn(DEVICE_SERIAL).when(mMockDevice).getSerialNumber();
         Mockito.doReturn(LOG_PATH).when(mSpyTest).getLogDirAbsolutePath();
-        Mockito.doNothing().when(mSpyTest).reportLogs(any(), any());
         Mockito.doReturn("testBedName").when(mSpyTest).getTestBed();
         String configString =
                 new StringBuilder()
@@ -1235,7 +1214,6 @@ public class MoblyBinaryHostTestTest {
         Mockito.doReturn(DEVICE_SERIAL).when(mMockDevice).getSerialNumber();
         Mockito.doReturn(DEVICE_SERIAL_2).when(mMockDevice2).getSerialNumber();
         Mockito.doReturn(LOG_PATH).when(mSpyTest).getLogDirAbsolutePath();
-        Mockito.doNothing().when(mSpyTest).reportLogs(any(), any());
         Mockito.doReturn("testBedName").when(mSpyTest).getTestBed();
         String configString =
                 new StringBuilder()
@@ -1283,7 +1261,6 @@ public class MoblyBinaryHostTestTest {
         Mockito.doReturn(DEVICE_SERIAL).when(mMockDevice).getSerialNumber();
         Mockito.doReturn(DEVICE_SERIAL_2).when(mMockDevice2).getSerialNumber();
         Mockito.doReturn(LOG_PATH).when(mSpyTest).getLogDirAbsolutePath();
-        Mockito.doNothing().when(mSpyTest).reportLogs(any(), any());
         Mockito.doReturn("testBedName").when(mSpyTest).getTestBed();
         String configString =
                 new StringBuilder()
diff --git a/javatests/com/android/tradefed/testtype/mobly/MoblyYamlResultParserTest.java b/javatests/com/android/tradefed/testtype/mobly/MoblyYamlResultParserTest.java
index ad3865ecc..eac635bca 100644
--- a/javatests/com/android/tradefed/testtype/mobly/MoblyYamlResultParserTest.java
+++ b/javatests/com/android/tradefed/testtype/mobly/MoblyYamlResultParserTest.java
@@ -21,10 +21,12 @@ import static org.junit.Assert.assertTrue;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyLong;
 import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
+import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
 import com.android.tradefed.result.FailureDescription;
 import com.android.tradefed.result.ITestInvocationListener;
 import com.android.tradefed.result.TestDescription;
@@ -76,6 +78,80 @@ public class MoblyYamlResultParserTest {
                 + "AttributeError:\\\n"
                 + "    \\ 'AndroidDevice' object has no attribute 'uia'\\n"
                 + "\"";
+    private static final String SAMPLE_STACK_TRACE_TIMED_OUT =
+            "\"Traceback (most recent call last):\\n"
+                + "  File"
+                + " \\\"/tmp/tf-workfolder56278238750643711/local_atest-virtualenv/lib/python3.12/site-packages/mobly/base_test.py\\\","
+                + " line 1036, in run\\n"
+                + "    setup_class_result = self._setup_class()\\n"
+                + "                       ^^^^^^^^^^^^^^^^^^^\\n"
+                + "  File"
+                + " \\\"/tmp/tf-workfolder56278238750643711/local_atest-virtualenv/lib/python3.12/site-packages/mobly/base_test.py\\\","
+                + " line 418, in _setup_class\\n"
+                + "    self.setup_class()\\n"
+                + "  File \\\"/tmp/Soong.python_okl5njgm/sdv_sample_comm_stack_one_vm_test.py\\\","
+                + " line 16, in setup_class\\n"
+                + "    super().setup_class()\\n"
+                + "  File"
+                + " \\\"/tmp/Soong.python_okl5njgm/sdv_test_fw/test_execution/sdv_base_test.py\\\","
+                + " line 200, in setup_class\\n"
+                + "    self.__prepare_logcat(device)\\n"
+                + "  File"
+                + " \\\"/tmp/Soong.python_okl5njgm/sdv_test_fw/test_execution/sdv_base_test.py\\\","
+                + " line 124, in __prepare_logcat\\n"
+                + "    device.adb().verify_logcat_is_running()\\n"
+                + "  File"
+                + " \\\"/tmp/Soong.python_okl5njgm/sdv_test_fw/test_execution/sdv_device.py\\\","
+                + " line 57, in verify_logcat_is_running\\n"
+                + "    if self.grep_from_logcat(self.LOGCAT_NON_EMPTY_LINES_GREP_TEXT):\\n"
+                + "       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n"
+                + "  File"
+                + " \\\"/tmp/Soong.python_okl5njgm/sdv_test_fw/test_execution/sdv_device.py\\\","
+                + " line 378, in grep_from_logcat\\n"
+                + "    return self.execute_shell_command(logcat_command, raise_exception=False)\\n"
+                + "           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n"
+                + "  File"
+                + " \\\"/tmp/Soong.python_okl5njgm/sdv_test_fw/test_execution/sdv_device.py\\\","
+                + " line 222, in execute_shell_command\\n"
+                + "    self.__android_device.adb.shell(shell_command)\\n"
+                + "  File"
+                + " \\\"/tmp/tf-workfolder56278238750643711/local_atest-virtualenv/lib/python3.12/site-packages/mobly/controllers/android_device_lib/adb.py\\\","
+                + " line 557, in adb_call\\n"
+                + "    return self._exec_adb_cmd(name,\\n"
+                + "           ^^^^^^^^^^^^^^^^^^^^^^^^\\n"
+                + "  File"
+                + " \\\"/tmp/tf-workfolder56278238750643711/local_atest-virtualenv/lib/python3.12/site-packages/mobly/controllers/android_device_lib/adb.py\\\","
+                + " line 291, in _exec_adb_cmd\\n"
+                + "    out = self._exec_cmd(adb_cmd, shell=shell, timeout=timeout,"
+                + " stderr=stderr)\\n"
+                + "          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n"
+                + "  File"
+                + " \\\"/tmp/tf-workfolder56278238750643711/local_atest-virtualenv/lib/python3.12/site-packages/mobly/controllers/android_device_lib/adb.py\\\","
+                + " line 187, in _exec_cmd\\n"
+                + "    (ret, out, err) = utils.run_command(args, shell=shell, timeout=timeout)\\n"
+                + "                     "
+                + " ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n"
+                + "  File"
+                + " \\\"/tmp/tf-workfolder56278238750643711/local_atest-virtualenv/lib/python3.12/site-packages/mobly/utils.py\\\","
+                + " line 481, in run_command\\n"
+                + "    out, err = process.communicate()\\n"
+                + "           ^^^^^^^^^^^^^^^^^^^^^\\n"
+                + "  File \\\"/usr/lib/python3.12/subprocess.py\\\", line 1209, in communicate\\n"
+                + "    stdout, stderr = self._communicate(input, endtime, timeout)\\n"
+                + "                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n"
+                + "  File \\\"/usr/lib/python3.12/subprocess.py\\\", line 2115, in _communicate\\n"
+                + "    ready = selector.select(timeout)\\n"
+                + "            ^^^^^^^^^^^^^^^^^^^^^^^\\n"
+                + "  File \\\"/usr/lib/python3.12/selectors.py\\\", line 415, in select\\n"
+                + "    fd_event_list = self._selector.poll(timeout)\\n"
+                + "                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n"
+                + "  File"
+                + " \\\"/tmp/tf-workfolder56278238750643711/local_atest-virtualenv/lib/python3.12/site-packages/mobly/test_runner.py\\\","
+                + " line 425, in sigterm_handler\\n"
+                + "    raise signals.TestAbortAll('Test received a SIGTERM.')\\n"
+                + "mobly.signals.TestAbortAll: Details=All remaining tests aborted due to: Test"
+                + " received a SIGTERM., Extras=None\\n"
+                + "\"";
     private static final Map<String, Object> mRecordMap;
 
     static {
@@ -137,10 +213,12 @@ public class MoblyYamlResultParserTest {
     private ArgumentCaptor<FailureDescription> mFailureDescriptionCaptor;
     private ArgumentCaptor<TestDescription> mEndDescCaptor;
     private ArgumentCaptor<Long> mEndTimeCaptor;
+    private MoblyArtifactReporter mMockArtifactReporter;
 
     @Before
     public void setUp() throws Exception {
         mMockListener = Mockito.mock(ITestInvocationListener.class);
+        mMockArtifactReporter = Mockito.mock(MoblyArtifactReporter.class);
         mListeners = ImmutableList.of(mMockListener);
         setUpArgumentCaptors();
     }
@@ -163,12 +241,15 @@ public class MoblyYamlResultParserTest {
         mEndTimeCaptor = ArgumentCaptor.forClass(Long.class);
         Mockito.doNothing()
                 .when(mMockListener)
-                .testEnded(mEndDescCaptor.capture(), mEndTimeCaptor.capture(), any(Map.class));
+                .testEnded(
+                        mEndDescCaptor.capture(),
+                        mEndTimeCaptor.capture(),
+                        eq(new HashMap<String, Metric>()));
     }
 
     @Test
     public void testReportToListenersPassRecord() {
-        mParser = new MoblyYamlResultParser(mMockListener, "runName", false);
+        mParser = new MoblyYamlResultParser(mMockListener, "runName", false, mMockArtifactReporter);
         IMoblyYamlResultHandler.ITestResult passRecord =
                 new Record.Builder()
                         .setTestName(DEFAULT_TEST_NAME)
@@ -191,7 +272,7 @@ public class MoblyYamlResultParserTest {
 
     @Test
     public void testReportToListenersFailRecord() {
-        mParser = new MoblyYamlResultParser(mMockListener, "runName", false);
+        mParser = new MoblyYamlResultParser(mMockListener, "runName", false, mMockArtifactReporter);
         IMoblyYamlResultHandler.ITestResult failRecord =
                 new Record.Builder()
                         .setTestName(DEFAULT_TEST_NAME)
@@ -226,7 +307,7 @@ public class MoblyYamlResultParserTest {
 
     @Test
     public void testReportToListenersUserData() {
-        mParser = new MoblyYamlResultParser(mMockListener, "runName", false);
+        mParser = new MoblyYamlResultParser(mMockListener, "runName", false, mMockArtifactReporter);
         List<IMoblyYamlResultHandler.ITestResult> resultCache =
                 ImmutableList.of(new UserData.Builder().setTimestamp(DEFAULT_BEGIN_TIME).build());
         mParser.reportToListeners(mListeners, resultCache);
@@ -237,7 +318,7 @@ public class MoblyYamlResultParserTest {
 
     @Test
     public void testReportToListenersControllerInfo() {
-        mParser = new MoblyYamlResultParser(mMockListener, "runName", false);
+        mParser = new MoblyYamlResultParser(mMockListener, "runName", false, mMockArtifactReporter);
         List<IMoblyYamlResultHandler.ITestResult> resultCache =
                 ImmutableList.of(
                         new ControllerInfo.Builder().setTimestamp("1571681322.791003").build());
@@ -249,7 +330,7 @@ public class MoblyYamlResultParserTest {
 
     @Test
     public void testParseDocumentMapRecordPass() throws Exception {
-        mParser = new MoblyYamlResultParser(mMockListener, "runName", false);
+        mParser = new MoblyYamlResultParser(mMockListener, "runName", false, mMockArtifactReporter);
         Map<String, Object> detailMap = new HashMap<>();
         detailMap.put("Result", "PASS");
         detailMap.put("Stacktrace", "null");
@@ -265,7 +346,7 @@ public class MoblyYamlResultParserTest {
 
     @Test
     public void testParseDocumentMapRecordFail() throws Exception {
-        mParser = new MoblyYamlResultParser(mMockListener, "runName", false);
+        mParser = new MoblyYamlResultParser(mMockListener, "runName", false, mMockArtifactReporter);
         Map<String, Object> detailMap = new HashMap<>();
         detailMap.put("Stacktrace", SAMPLE_STACK_TRACE);
         detailMap.put("Result", "FAIL");
@@ -280,9 +361,39 @@ public class MoblyYamlResultParserTest {
         assertTrue(((Record) result).getStackTrace().contains("Traceback (most recent call last)"));
     }
 
+    @Test
+    public void testReportToListenersFailedTestForTimedout() {
+        mParser = new MoblyYamlResultParser(mMockListener, "runName", false, mMockArtifactReporter);
+        IMoblyYamlResultHandler.ITestResult skipRecord =
+                new Record.Builder()
+                        .setTestName(DEFAULT_TEST_NAME)
+                        .setTestClass(DEFAULT_TEST_CLASS)
+                        .setBeginTime("null")
+                        .setEndTime("null")
+                        .setResult(MoblyYamlResultRecordHandler.RecordResult.SKIP)
+                        .setStackTrace(SAMPLE_STACK_TRACE_TIMED_OUT)
+                        .build();
+        List<IMoblyYamlResultHandler.ITestResult> resultCache = ImmutableList.of(skipRecord);
+        mParser.reportToListeners(mListeners, resultCache);
+
+        assertTrue(
+                mFailureDescriptionCaptor
+                        .getValue()
+                        .getErrorMessage()
+                        .contains("Test received a SIGTERM."));
+        assertTrue(
+                mFailureDescriptionCaptor
+                        .getValue()
+                        .getFailureStatus()
+                        .equals(TestRecordProto.FailureStatus.TIMED_OUT));
+        assertEquals(DEFAULT_TEST_CLASS, mEndDescCaptor.getValue().getClassName());
+        assertEquals(DEFAULT_TEST_NAME, mEndDescCaptor.getValue().getTestName());
+        assertEquals(0L, (long) mEndTimeCaptor.getValue());
+    }
+
     @Test
     public void testParseDocumentMapSummary() throws Exception {
-        mParser = new MoblyYamlResultParser(mMockListener, "runName", false);
+        mParser = new MoblyYamlResultParser(mMockListener, "runName", false, mMockArtifactReporter);
         Map<String, Object> docMap = new HashMap<>();
         docMap.put("Type", "Summary");
         docMap.put("Executed", "10");
@@ -295,7 +406,7 @@ public class MoblyYamlResultParserTest {
 
     @Test
     public void testParseDocumentMapControllerInfo() throws Exception {
-        mParser = new MoblyYamlResultParser(mMockListener, "runName", false);
+        mParser = new MoblyYamlResultParser(mMockListener, "runName", false, mMockArtifactReporter);
         Map<String, Object> docMap = new HashMap<>();
         docMap.put("Type", "ControllerInfo");
         docMap.put("Timestamp", "1571681322.791003");
@@ -307,7 +418,7 @@ public class MoblyYamlResultParserTest {
 
     @Test
     public void testParseDocumentMapUserData() throws Exception {
-        mParser = new MoblyYamlResultParser(mMockListener, "runName", false);
+        mParser = new MoblyYamlResultParser(mMockListener, "runName", false, mMockArtifactReporter);
         Map<String, Object> docMap = new HashMap<>();
         docMap.put("Type", "UserData");
         docMap.put("timestamp", DEFAULT_BEGIN_TIME);
@@ -318,7 +429,7 @@ public class MoblyYamlResultParserTest {
 
     @Test
     public void testParseDocumentMapTestNameList() throws Exception {
-        mParser = new MoblyYamlResultParser(mMockListener, "runName", false);
+        mParser = new MoblyYamlResultParser(mMockListener, "runName", false, mMockArtifactReporter);
         Map<String, Object> docMap = new HashMap<>();
         docMap.put("Type", "TestNameList");
         docMap.put("Requested Tests", Arrays.asList("test1", "test2"));
@@ -328,7 +439,7 @@ public class MoblyYamlResultParserTest {
 
     @Test
     public void testParse() throws Exception {
-        mParser = new MoblyYamlResultParser(mMockListener, "runName", false);
+        mParser = new MoblyYamlResultParser(mMockListener, "runName", false, mMockArtifactReporter);
         MoblyYamlResultParser spyParser = Mockito.spy(mParser);
 
         String passRecord = buildTestRecordString(new HashMap<>());
diff --git a/javatests/com/android/tradefed/testtype/rust/RustBinaryHostTestTest.java b/javatests/com/android/tradefed/testtype/rust/RustBinaryHostTestTest.java
index d8fe4e259..dd9bb0aa4 100644
--- a/javatests/com/android/tradefed/testtype/rust/RustBinaryHostTestTest.java
+++ b/javatests/com/android/tradefed/testtype/rust/RustBinaryHostTestTest.java
@@ -465,10 +465,10 @@ public class RustBinaryHostTestTest {
         try {
             OptionSetter setter = new OptionSetter(mTest);
             setter.setOptionValue("test-file", binary.getAbsolutePath());
-            setter.setOptionValue("exclude-filter", "NotMe");
-            setter.setOptionValue("include-filter", "MyTest#OnlyMe");
-            setter.setOptionValue("exclude-filter", "MyTest#Other");
-            setter.setOptionValue("include-filter", "Me2");
+            setter.setOptionValue("exclude-filter", "binary#NotMe");
+            setter.setOptionValue("include-filter", "binary#MyTest#OnlyMe");
+            setter.setOptionValue("exclude-filter", "binary#MyTest#Other");
+            setter.setOptionValue("include-filter", "binary#Me2");
             // Multiple include filters are run one by one with --list.
             String[] selection1 = new String[] {"test1", "test2"};
             when(mMockRunUtil.runTimedCmd(
diff --git a/javatests/com/android/tradefed/testtype/suite/ITestSuiteTest.java b/javatests/com/android/tradefed/testtype/suite/ITestSuiteTest.java
index cd076b825..e19b6d100 100644
--- a/javatests/com/android/tradefed/testtype/suite/ITestSuiteTest.java
+++ b/javatests/com/android/tradefed/testtype/suite/ITestSuiteTest.java
@@ -303,7 +303,8 @@ public class ITestSuiteTest {
         public void run(TestInformation testInfo, ITestInvocationListener listener)
             throws DeviceNotAvailableException {
             // To simulate that no tests would be run.
-            return;
+            listener.testRunStarted(TEST_CONFIG_NAME, 0);
+            listener.testRunEnded(0, new HashMap<String, Metric>());
         }
     }
 
@@ -762,22 +763,56 @@ public class ITestSuiteTest {
 
         mTestSuite.run(mTestInfo, mMockListener);
 
-        verify(mMockListener, times(1))
-                .testRunStarted(
-                        Mockito.eq(TEST_CONFIG_NAME),
-                        Mockito.eq(1),
-                        Mockito.eq(0),
-                        Mockito.anyLong());
-        verify(mMockListener, times(1))
-                .testRunEnded(Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
         verify(mMockListener).testModuleStarted(Mockito.any());
-        ArgumentCaptor<FailureDescription> captureRunFailure =
-                ArgumentCaptor.forClass(FailureDescription.class);
-        verify(mMockListener).testRunFailed(captureRunFailure.capture());
+        if (mTestSuite.isRemoveModuleBuffering()) {
+            // test run ended will be reported twice. First to report the test count mismatch,
+            // second to report the runtime exception failure
+            verify(mMockListener, times(1))
+                    .testRunStarted(
+                            Mockito.eq(TEST_CONFIG_NAME),
+                            Mockito.eq(1),
+                            Mockito.eq(0),
+                            Mockito.anyLong());
+            verify(mMockListener, times(1))
+                    .testRunStarted(
+                            Mockito.eq(TEST_CONFIG_NAME),
+                            Mockito.eq(0),
+                            Mockito.eq(0),
+                            Mockito.anyLong());
+            verify(mMockListener, times(2))
+                    .testRunEnded(Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
+            ArgumentCaptor<FailureDescription> captureRunFailure =
+                    ArgumentCaptor.forClass(FailureDescription.class);
+            verify(mMockListener, times(2)).testRunFailed(captureRunFailure.capture());
+            FailureDescription failureOne = captureRunFailure.getAllValues().get(0);
+            assertTrue(
+                    failureOne
+                            .getErrorMessage()
+                            .equals(
+                                    "TestRun "
+                                            + TEST_CONFIG_NAME
+                                            + " only ran 0 out of 1 expected tests."));
+            assertEquals(FailureStatus.TEST_FAILURE, failureOne.getFailureStatus());
+            FailureDescription failureTwo = captureRunFailure.getAllValues().get(1);
+            assertTrue(failureTwo.getErrorMessage().equals("unresponsive"));
+            assertEquals(FailureStatus.LOST_SYSTEM_UNDER_TEST, failureTwo.getFailureStatus());
+        } else {
+            verify(mMockListener, times(1))
+                    .testRunStarted(
+                            Mockito.eq(TEST_CONFIG_NAME),
+                            Mockito.eq(1),
+                            Mockito.eq(0),
+                            Mockito.anyLong());
+            verify(mMockListener, times(1))
+                    .testRunEnded(Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
+            ArgumentCaptor<FailureDescription> captureRunFailure =
+                    ArgumentCaptor.forClass(FailureDescription.class);
+            verify(mMockListener).testRunFailed(captureRunFailure.capture());
+            FailureDescription failure = captureRunFailure.getValue();
+            assertTrue(failure.getErrorMessage().equals("unresponsive"));
+            assertEquals(FailureStatus.LOST_SYSTEM_UNDER_TEST, failure.getFailureStatus());
+        }
         verify(mMockListener).testModuleEnded();
-        FailureDescription failure = captureRunFailure.getValue();
-        assertTrue(failure.getErrorMessage().equals("unresponsive"));
-        assertEquals(FailureStatus.LOST_SYSTEM_UNDER_TEST, failure.getFailureStatus());
     }
 
     /**
@@ -828,30 +863,69 @@ public class ITestSuiteTest {
         }
 
         verify(mMockListener, times(2)).testModuleStarted(Mockito.any());
-        verify(mMockListener, times(1))
-                .testRunStarted(
-                        Mockito.eq(TEST_CONFIG_NAME),
-                        Mockito.eq(1),
-                        Mockito.eq(0),
-                        Mockito.anyLong());
-        verify(mMockListener, times(2))
-                .testRunEnded(Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
+        if (mTestSuite.isRemoveModuleBuffering()) {
+            verify(mMockListener, times(1))
+                    .testRunStarted(
+                            Mockito.eq(TEST_CONFIG_NAME),
+                            Mockito.eq(1),
+                            Mockito.eq(0),
+                            Mockito.anyLong());
+            verify(mMockListener, times(1))
+                    .testRunStarted(
+                            Mockito.eq(TEST_CONFIG_NAME),
+                            Mockito.eq(0),
+                            Mockito.eq(0),
+                            Mockito.anyLong());
+            verify(mMockListener)
+                    .testRunStarted(
+                            Mockito.eq("NOT_RUN"), Mockito.eq(0), Mockito.eq(0), Mockito.anyLong());
+            verify(mMockListener, times(3))
+                    .testRunEnded(Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
+            ArgumentCaptor<FailureDescription> captureRunFailure =
+                    ArgumentCaptor.forClass(FailureDescription.class);
+            verify(mMockListener, times(3)).testRunFailed(captureRunFailure.capture());
+
+            List<FailureDescription> failures = captureRunFailure.getAllValues();
+            assertTrue(
+                    failures.get(0)
+                            .getErrorMessage()
+                            .equals(
+                                    "TestRun "
+                                            + TEST_CONFIG_NAME
+                                            + " only ran 0 out of 1 expected tests."));
+            assertTrue(failures.get(1).getErrorMessage().equals("I failed"));
+            assertTrue(
+                    failures.get(2)
+                            .getErrorMessage()
+                            .equals("Module did not run due to device not available."));
+            assertEquals(FailureStatus.TEST_FAILURE, failures.get(0).getFailureStatus());
+            assertEquals(FailureStatus.NOT_EXECUTED, failures.get(2).getFailureStatus());
+        } else {
+            verify(mMockListener, times(1))
+                    .testRunStarted(
+                            Mockito.eq(TEST_CONFIG_NAME),
+                            Mockito.eq(1),
+                            Mockito.eq(0),
+                            Mockito.anyLong());
+            verify(mMockListener, times(2))
+                    .testRunEnded(Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
+            ArgumentCaptor<FailureDescription> captureRunFailure =
+                    ArgumentCaptor.forClass(FailureDescription.class);
+            verify(mMockListener, times(2)).testRunFailed(captureRunFailure.capture());
+            verify(mMockListener)
+                    .testRunStarted(
+                            Mockito.eq("NOT_RUN"), Mockito.eq(0), Mockito.eq(0), Mockito.anyLong());
+            verify(mMockListener).testRunEnded(0L, new HashMap<String, Metric>());
+
+            List<FailureDescription> failures = captureRunFailure.getAllValues();
+            assertTrue(failures.get(0).getErrorMessage().equals("I failed"));
+            assertTrue(
+                    failures.get(1)
+                            .getErrorMessage()
+                            .equals("Module did not run due to device not available."));
+            assertEquals(FailureStatus.NOT_EXECUTED, failures.get(1).getFailureStatus());
+        }
         verify(mMockListener, times(2)).testModuleEnded();
-        ArgumentCaptor<FailureDescription> captureRunFailure =
-                ArgumentCaptor.forClass(FailureDescription.class);
-        verify(mMockListener, times(2)).testRunFailed(captureRunFailure.capture());
-        verify(mMockListener)
-                .testRunStarted(
-                        Mockito.eq("NOT_RUN"), Mockito.eq(0), Mockito.eq(0), Mockito.anyLong());
-        verify(mMockListener).testRunEnded(0L, new HashMap<String, Metric>());
-
-        List<FailureDescription> failures = captureRunFailure.getAllValues();
-        assertTrue(failures.get(0).getErrorMessage().equals("I failed"));
-        assertTrue(
-                failures.get(1)
-                        .getErrorMessage()
-                        .equals("Module did not run due to device not available."));
-        assertEquals(FailureStatus.NOT_EXECUTED, failures.get(1).getFailureStatus());
     }
 
     /**
@@ -893,23 +967,58 @@ public class ITestSuiteTest {
 
         mTestSuite.run(mTestInfo, mMockListener);
 
-        verify(mMockListener, times(1))
-                .testRunStarted(
-                        Mockito.eq(TEST_CONFIG_NAME),
-                        Mockito.eq(1),
-                        Mockito.eq(0),
-                        Mockito.anyLong());
-        verify(mMockListener, times(1))
-                .testRunEnded(Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
         verify(mMockListener).testModuleStarted(Mockito.any());
-        ArgumentCaptor<FailureDescription> captured =
-                ArgumentCaptor.forClass(FailureDescription.class);
-        verify(mMockListener).testRunFailed(captured.capture());
+        if (mTestSuite.isRemoveModuleBuffering()) {
+            // test run ended will be reported twice. First to report the test count mismatch,
+            // second to report the runtime exception failure
+            verify(mMockListener, times(1))
+                    .testRunStarted(
+                            Mockito.eq(TEST_CONFIG_NAME),
+                            Mockito.eq(1),
+                            Mockito.eq(0),
+                            Mockito.anyLong());
+            // another testRunStart event during backfilling of runtime exception failure
+            verify(mMockListener, times(1))
+                    .testRunStarted(
+                            Mockito.eq(TEST_CONFIG_NAME),
+                            Mockito.eq(0),
+                            Mockito.eq(0),
+                            Mockito.anyLong());
+            verify(mMockListener, times(2))
+                    .testRunEnded(Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
+            ArgumentCaptor<FailureDescription> captured =
+                    ArgumentCaptor.forClass(FailureDescription.class);
+            verify(mMockListener, times(2)).testRunFailed(captured.capture());
+
+            FailureDescription exceptionOne = captured.getAllValues().get(0);
+            FailureDescription exceptionTwo = captured.getAllValues().get(1);
+            assertTrue(
+                    exceptionOne
+                            .getErrorMessage()
+                            .contains(
+                                    "TestRun "
+                                            + TEST_CONFIG_NAME
+                                            + " only ran 0 out of 1 expected tests."));
+            assertTrue(exceptionTwo.getErrorMessage().contains("runtime"));
+            assertFalse(exceptionTwo instanceof MultiFailureDescription);
+        } else {
+            verify(mMockListener, times(1))
+                    .testRunStarted(
+                            Mockito.eq(TEST_CONFIG_NAME),
+                            Mockito.eq(1),
+                            Mockito.eq(0),
+                            Mockito.anyLong());
+            verify(mMockListener, times(1))
+                    .testRunEnded(Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
+            ArgumentCaptor<FailureDescription> captured =
+                    ArgumentCaptor.forClass(FailureDescription.class);
+            verify(mMockListener).testRunFailed(captured.capture());
+
+            FailureDescription exception = captured.getValue();
+            assertTrue(exception.getErrorMessage().contains("runtime"));
+            assertFalse(exception instanceof MultiFailureDescription);
+        }
         verify(mMockListener).testModuleEnded();
-
-        FailureDescription exception = captured.getValue();
-        assertTrue(exception.getErrorMessage().contains("runtime"));
-        assertFalse(exception instanceof MultiFailureDescription);
     }
 
     /**
@@ -1957,30 +2066,156 @@ public class ITestSuiteTest {
             assertEquals("unavailable", expected.getMessage());
         }
 
+        verify(mMockListener, times(2)).testModuleStarted(Mockito.any());
+        if (mTestSuite.isRemoveModuleBuffering()) {
+            // test run ended will be reported twice. First to report the test count mismatch,
+            // second to report the DNAE exception failure
+            verify(mMockListener, times(1))
+                    .testRunStarted(
+                            Mockito.eq("in-progress"),
+                            Mockito.eq(1),
+                            Mockito.eq(0),
+                            Mockito.anyLong());
+            verify(mMockListener, times(1))
+                    .testRunStarted(
+                            Mockito.eq("in-progress"),
+                            Mockito.eq(0),
+                            Mockito.eq(0),
+                            Mockito.anyLong());
+            verify(mMockListener, times(1))
+                    .testRunStarted(
+                            Mockito.eq("not-executed"),
+                            Mockito.eq(0),
+                            Mockito.eq(0),
+                            Mockito.anyLong());
+            ArgumentCaptor<FailureDescription> captureRunFailure =
+                    ArgumentCaptor.forClass(FailureDescription.class);
+            verify(mMockListener, times(3)).testRunFailed(captureRunFailure.capture());
+            verify(mMockListener, times(3))
+                    .testRunEnded(Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
+            List<FailureDescription> failures = captureRunFailure.getAllValues();
+            assertTrue(
+                    failures.get(0)
+                            .getErrorMessage()
+                            .equals(
+                                    "TestRun "
+                                            + TEST_CONFIG_NAME
+                                            + " only ran 0 out of 1 expected tests."));
+            assertEquals(FailureStatus.TEST_FAILURE, failures.get(0).getFailureStatus());
+            assertTrue(failures.get(1).getErrorMessage().equals("unavailable"));
+            assertEquals(FailureStatus.LOST_SYSTEM_UNDER_TEST, failures.get(1).getFailureStatus());
+            assertTrue(
+                    failures.get(2)
+                            .getErrorMessage()
+                            .equals("Module did not run due to device not available."));
+            assertEquals(FailureStatus.NOT_EXECUTED, failures.get(2).getFailureStatus());
+        } else {
+            verify(mMockListener, times(1))
+                    .testRunStarted(
+                            Mockito.eq("in-progress"),
+                            Mockito.eq(1),
+                            Mockito.eq(0),
+                            Mockito.anyLong());
+            ArgumentCaptor<FailureDescription> captureRunFailure =
+                    ArgumentCaptor.forClass(FailureDescription.class);
+            verify(mMockListener, times(2)).testRunFailed(captureRunFailure.capture());
+            verify(mMockListener, times(2))
+                    .testRunEnded(Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
+            verify(mMockListener, times(1))
+                    .testRunStarted(
+                            Mockito.eq("not-executed"),
+                            Mockito.eq(0),
+                            Mockito.eq(0),
+                            Mockito.anyLong());
+            List<FailureDescription> failures = captureRunFailure.getAllValues();
+            assertTrue(failures.get(0).getErrorMessage().equals("unavailable"));
+            assertEquals(FailureStatus.LOST_SYSTEM_UNDER_TEST, failures.get(0).getFailureStatus());
+            assertTrue(
+                    failures.get(1)
+                            .getErrorMessage()
+                            .equals("Module did not run due to device not available."));
+            assertEquals(FailureStatus.NOT_EXECUTED, failures.get(1).getFailureStatus());
+        }
+        verify(mMockListener, times(2)).testModuleEnded();
+    }
+
+    /**
+     * Verify module events are not reported when module is skipped via {@link
+     * ITestSuite#shouldModuleRun(ModuleDefinition)}.
+     */
+    @Test
+    public void testRun_withSkippedModule() throws Exception {
+        List<ISystemStatusChecker> sysChecker = new ArrayList<>();
+        sysChecker.add(mMockSysChecker);
+        mTestSuite =
+                new TestSuiteImpl() {
+                    @Override
+                    public LinkedHashMap<String, IConfiguration> loadTests() {
+                        LinkedHashMap<String, IConfiguration> testConfig = new LinkedHashMap<>();
+                        try {
+                            IConfiguration moduleOne =
+                                    ConfigurationFactory.getInstance()
+                                            .createConfigurationFromArgs(
+                                                    new String[] {EMPTY_CONFIG});
+                            moduleOne.setTest(new StubCollectingTest());
+                            testConfig.put("MODULE_1", moduleOne);
+
+                            IConfiguration moduleTwo =
+                                    ConfigurationFactory.getInstance()
+                                            .createConfigurationFromArgs(
+                                                    new String[] {EMPTY_CONFIG});
+                            moduleTwo.setTest(new StubCollectingTest());
+                            testConfig.put("MODULE_2", moduleTwo);
+
+                            IConfiguration moduleThree =
+                                    ConfigurationFactory.getInstance()
+                                            .createConfigurationFromArgs(
+                                                    new String[] {EMPTY_CONFIG});
+                            moduleThree.setTest(new StubCollectingTest());
+                            testConfig.put("MODULE_3", moduleThree);
+                        } catch (ConfigurationException e) {
+                            CLog.e(e);
+                            throw new RuntimeException(e);
+                        }
+                        return testConfig;
+                    }
+
+                    @Override
+                    protected boolean shouldModuleRun(ModuleDefinition module) {
+                        if (module.getId().equals("MODULE_2")) {
+                            // skip module 2
+                            return false;
+                        } else {
+                            return true;
+                        }
+                    }
+                };
+        mTestSuite.setDevice(mMockDevice);
+        mTestSuite.setBuild(mMockBuildInfo);
+        mTestSuite.setInvocationContext(mContext);
+        mTestSuite.setSystemStatusChecker(sysChecker);
+        mTestSuite.setConfiguration(mStubMainConfiguration);
+        OptionSetter setter = new OptionSetter(mTestSuite);
+        setter.setOptionValue("skip-all-system-status-check", "true");
+        setter.setOptionValue("reboot-per-module", "true");
+        when(mMockDevice.getProperty("ro.build.type")).thenReturn("user");
+
+        mTestSuite.run(mTestInfo, mMockListener);
+
         verify(mMockListener, times(2)).testModuleStarted(Mockito.any());
         verify(mMockListener, times(1))
                 .testRunStarted(
-                        Mockito.eq("in-progress"), Mockito.eq(1), Mockito.eq(0), Mockito.anyLong());
-        ArgumentCaptor<FailureDescription> captureRunFailure =
-                ArgumentCaptor.forClass(FailureDescription.class);
-        verify(mMockListener, times(2)).testRunFailed(captureRunFailure.capture());
+                        Mockito.eq("MODULE_1"), Mockito.eq(1), Mockito.eq(0), Mockito.anyLong());
+        verify(mMockListener, times(1))
+                .testRunStarted(
+                        Mockito.eq("MODULE_3"), Mockito.eq(1), Mockito.eq(0), Mockito.anyLong());
+        verify(mMockListener, times(2)).testStarted(Mockito.any(), Mockito.anyLong());
+        verify(mMockListener, times(2))
+                .testEnded(
+                        Mockito.any(), Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
         verify(mMockListener, times(2))
                 .testRunEnded(Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
         verify(mMockListener, times(2)).testModuleEnded();
-        verify(mMockListener, times(1))
-                .testRunStarted(
-                        Mockito.eq("not-executed"),
-                        Mockito.eq(0),
-                        Mockito.eq(0),
-                        Mockito.anyLong());
-        List<FailureDescription> failures = captureRunFailure.getAllValues();
-        assertTrue(failures.get(0).getErrorMessage().equals("unavailable"));
-        assertEquals(FailureStatus.LOST_SYSTEM_UNDER_TEST, failures.get(0).getFailureStatus());
-        assertTrue(
-                failures.get(1)
-                        .getErrorMessage()
-                        .equals("Module did not run due to device not available."));
-        assertEquals(FailureStatus.NOT_EXECUTED, failures.get(1).getFailureStatus());
     }
 
     public static class FakePostProcessor extends BasePostProcessor {
diff --git a/javatests/com/android/tradefed/testtype/suite/RemoteTestTimeOutEnforcerTest.java b/javatests/com/android/tradefed/testtype/suite/RemoteTestTimeOutEnforcerTest.java
index f79fe09a9..02ceae7ca 100644
--- a/javatests/com/android/tradefed/testtype/suite/RemoteTestTimeOutEnforcerTest.java
+++ b/javatests/com/android/tradefed/testtype/suite/RemoteTestTimeOutEnforcerTest.java
@@ -35,6 +35,7 @@ import org.junit.runners.JUnit4;
 import org.mockito.Mockito;
 
 import java.time.Duration;
+import java.util.ArrayList;
 import java.util.HashMap;
 
 /** Unit tests for {@link RemoteTestTimeOutEnforcer}. */
@@ -66,7 +67,9 @@ public class RemoteTestTimeOutEnforcerTest {
         mListener =
                 new ModuleListener(mock(ITestInvocationListener.class), mModuleInvocationContext);
         mEnforcer =
-                new RemoteTestTimeOutEnforcer(mListener, mModuleDefinition, mIRemoteTest, mTimeout);
+                new RemoteTestTimeOutEnforcer(
+                        new ArrayList<>(), mModuleDefinition, mIRemoteTest, mTimeout);
+        mEnforcer.setGranularListener(mListener);
     }
 
     @Test
diff --git a/javatests/com/android/tradefed/testtype/suite/TfSuiteRunnerTest.java b/javatests/com/android/tradefed/testtype/suite/TfSuiteRunnerTest.java
index 3d93d57ea..c8c5e1b21 100644
--- a/javatests/com/android/tradefed/testtype/suite/TfSuiteRunnerTest.java
+++ b/javatests/com/android/tradefed/testtype/suite/TfSuiteRunnerTest.java
@@ -37,7 +37,6 @@ import com.android.tradefed.device.ITestDevice;
 import com.android.tradefed.invoker.IInvocationContext;
 import com.android.tradefed.invoker.InvocationContext;
 import com.android.tradefed.invoker.TestInformation;
-import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
 import com.android.tradefed.result.ILogSaver;
 import com.android.tradefed.result.ITestInvocationListener;
 import com.android.tradefed.testtype.Abi;
@@ -52,14 +51,13 @@ import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
+import org.mockito.ArgumentCaptor;
 import org.mockito.Mock;
-import org.mockito.Mockito;
 import org.mockito.MockitoAnnotations;
 
 import java.io.File;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.List;
@@ -243,21 +241,15 @@ public class TfSuiteRunnerTest {
 
         mRunner.run(testInfo, listener);
 
-        verify(listener, times(2)).testModuleStarted(Mockito.any());
-        verify(listener)
-                .testRunStarted(
-                        Mockito.eq("arm64-v8a suite/stub1"),
-                        Mockito.eq(0),
-                        Mockito.eq(0),
-                        Mockito.anyLong());
-        verify(listener)
-                .testRunStarted(
-                        Mockito.eq("armeabi-v7a suite/stub1"),
-                        Mockito.eq(0),
-                        Mockito.eq(0),
-                        Mockito.anyLong());
-        verify(listener, times(2)).testRunEnded(
-                Mockito.anyLong(), Mockito.<HashMap<String, Metric>>any());
+        ArgumentCaptor<IInvocationContext> contextCaptor =
+                ArgumentCaptor.forClass(IInvocationContext.class);
+        verify(listener, times(2)).testModuleStarted(contextCaptor.capture());
+        assertEquals(
+                "arm64-v8a suite/stub1",
+                contextCaptor.getAllValues().get(0).getAttributes().get("module-id").get(0));
+        assertEquals(
+                "armeabi-v7a suite/stub1",
+                contextCaptor.getAllValues().get(1).getAttributes().get("module-id").get(0));
         verify(listener, times(2)).testModuleEnded();
     }
 
diff --git a/javatests/com/android/tradefed/util/PerfettoTraceRecorderFuncTest.java b/javatests/com/android/tradefed/util/PerfettoTraceRecorderFuncTest.java
index bac7db422..dcd03be64 100644
--- a/javatests/com/android/tradefed/util/PerfettoTraceRecorderFuncTest.java
+++ b/javatests/com/android/tradefed/util/PerfettoTraceRecorderFuncTest.java
@@ -66,7 +66,7 @@ public class PerfettoTraceRecorderFuncTest implements IDeviceTest {
 
     @Test
     public void testPerfettoTraceRecorded() throws IOException {
-        mPerfettoTraceRecorder.startTrace(getDevice(), null);
+        mPerfettoTraceRecorder.startTrace(getDevice(), null, null);
         RunUtil.getDefault().sleep(5000); // collect trace for five seconds
         File traceFile = mPerfettoTraceRecorder.stopTrace(getDevice());
 
diff --git a/javatests/com/android/tradefed/util/SearchArtifactUtilTest.java b/javatests/com/android/tradefed/util/SearchArtifactUtilTest.java
index 9a42d4169..ff321f7a0 100644
--- a/javatests/com/android/tradefed/util/SearchArtifactUtilTest.java
+++ b/javatests/com/android/tradefed/util/SearchArtifactUtilTest.java
@@ -63,7 +63,7 @@ public class SearchArtifactUtilTest {
             searchDirectories.add(searchDirectory);
 
             SearchArtifactUtil.singleton = Mockito.mock(SearchArtifactUtil.class);
-            when(SearchArtifactUtil.singleton.getSearchDirectories(false, null, null, null))
+            when(SearchArtifactUtil.singleton.getSearchDirectories(false, null, null, null, null))
                     .thenReturn(searchDirectories);
             when(SearchArtifactUtil.singleton.findModuleName()).thenReturn("correctModule");
 
@@ -99,7 +99,7 @@ public class SearchArtifactUtilTest {
             searchDirectories.add(searchDirectory);
 
             SearchArtifactUtil.singleton = Mockito.mock(SearchArtifactUtil.class);
-            when(SearchArtifactUtil.singleton.getSearchDirectories(false, null, null, null))
+            when(SearchArtifactUtil.singleton.getSearchDirectories(false, null, null, null, null))
                     .thenReturn(searchDirectories);
             when(SearchArtifactUtil.singleton.findModuleName()).thenReturn(null);
 
@@ -144,7 +144,7 @@ public class SearchArtifactUtilTest {
             searchDirectories.add(searchDirectory);
 
             SearchArtifactUtil.singleton = Mockito.mock(SearchArtifactUtil.class);
-            when(SearchArtifactUtil.singleton.getSearchDirectories(false, null, null, null))
+            when(SearchArtifactUtil.singleton.getSearchDirectories(false, null, null, null, null))
                     .thenReturn(searchDirectories);
             when(SearchArtifactUtil.singleton.findModuleName()).thenReturn("correctModule");
 
@@ -183,7 +183,7 @@ public class SearchArtifactUtilTest {
             searchDirectories.add(searchDirectory);
 
             SearchArtifactUtil.singleton = Mockito.mock(SearchArtifactUtil.class);
-            when(SearchArtifactUtil.singleton.getSearchDirectories(false, null, null, null))
+            when(SearchArtifactUtil.singleton.getSearchDirectories(false, null, null, null, null))
                     .thenReturn(searchDirectories);
             when(SearchArtifactUtil.singleton.findModuleName()).thenReturn(null);
 
@@ -219,7 +219,7 @@ public class SearchArtifactUtilTest {
             searchDirectories.add(searchDirectory);
 
             SearchArtifactUtil.singleton = Mockito.mock(SearchArtifactUtil.class);
-            when(SearchArtifactUtil.singleton.getSearchDirectories(false, null, null, null))
+            when(SearchArtifactUtil.singleton.getSearchDirectories(false, null, null, null, null))
                     .thenReturn(searchDirectories);
             when(SearchArtifactUtil.singleton.findModuleName()).thenReturn(null);
 
@@ -250,7 +250,7 @@ public class SearchArtifactUtilTest {
             searchDirectories.add(searchDirectory);
 
             SearchArtifactUtil.singleton = Mockito.mock(SearchArtifactUtil.class);
-            when(SearchArtifactUtil.singleton.getSearchDirectories(false, null, null, null))
+            when(SearchArtifactUtil.singleton.getSearchDirectories(false, null, null, null, null))
                     .thenReturn(searchDirectories);
             when(SearchArtifactUtil.singleton.findModuleName()).thenReturn("correctModule");
 
@@ -288,7 +288,7 @@ public class SearchArtifactUtilTest {
             searchDirectories.add(searchDirectory);
 
             SearchArtifactUtil.singleton = Mockito.mock(SearchArtifactUtil.class);
-            when(SearchArtifactUtil.singleton.getSearchDirectories(false, null, null, null))
+            when(SearchArtifactUtil.singleton.getSearchDirectories(false, null, null, null, null))
                     .thenReturn(searchDirectories);
             when(SearchArtifactUtil.singleton.findModuleName()).thenReturn("correctModule");
             when(SearchArtifactUtil.singleton.getExecutionFiles(null)).thenReturn(executionFiles);
@@ -327,12 +327,14 @@ public class SearchArtifactUtilTest {
             searchDirectories.add(searchDirectory);
 
             SearchArtifactUtil.singleton = Mockito.mock(SearchArtifactUtil.class);
-            when(SearchArtifactUtil.singleton.getSearchDirectories(false, null, null, null))
+            when(SearchArtifactUtil.singleton.getSearchDirectories(
+                            false, null, null, null, buildInfo))
                     .thenReturn(searchDirectories);
             when(SearchArtifactUtil.singleton.findModuleName()).thenReturn("correctModule");
-            when(SearchArtifactUtil.singleton.getBuildInfo()).thenReturn(buildInfo);
 
-            File f = SearchArtifactUtil.searchFile(correctFile.getName(), false);
+            File f =
+                    SearchArtifactUtil.searchFile(
+                            correctFile.getName(), false, null, null, null, null, buildInfo, false);
             Truth.assertThat(f).isNotNull();
             Truth.assertThat(f.getAbsolutePath()).isEqualTo(correctFile.getAbsolutePath());
         } finally {
@@ -375,7 +377,7 @@ public class SearchArtifactUtilTest {
             when(SearchArtifactUtil.singleton.findModuleName()).thenReturn("correctModule");
             when(SearchArtifactUtil.singleton.getExecutionFiles(null)).thenReturn(executionFiles);
             when(SearchArtifactUtil.singleton.getSearchDirectories(
-                            false, altDirs, AltDirBehavior.OVERRIDE, null))
+                            false, altDirs, AltDirBehavior.OVERRIDE, null, null))
                     .thenCallRealMethod();
 
             File f =
@@ -424,7 +426,7 @@ public class SearchArtifactUtilTest {
 
             SearchArtifactUtil.singleton = Mockito.mock(SearchArtifactUtil.class);
             when(SearchArtifactUtil.singleton.getExecutionFiles(null)).thenReturn(executionFiles);
-            when(SearchArtifactUtil.singleton.getSearchDirectories(true, null, null, null))
+            when(SearchArtifactUtil.singleton.getSearchDirectories(true, null, null, null, null))
                     .thenCallRealMethod();
 
             File dir = SearchArtifactUtil.findModuleDir("correctModule", true);
@@ -471,7 +473,7 @@ public class SearchArtifactUtilTest {
 
             SearchArtifactUtil.singleton = Mockito.mock(SearchArtifactUtil.class);
             when(SearchArtifactUtil.singleton.getExecutionFiles(null)).thenReturn(executionFiles);
-            when(SearchArtifactUtil.singleton.getSearchDirectories(false, null, null, null))
+            when(SearchArtifactUtil.singleton.getSearchDirectories(false, null, null, null, null))
                     .thenCallRealMethod();
 
             File dir = SearchArtifactUtil.findModuleDir("correctModule", false);
diff --git a/javatests/com/android/tradefed/util/proto/TfMetricProtoUtilTest.java b/javatests/com/android/tradefed/util/proto/TfMetricProtoUtilTest.java
index 4a5d19739..0a5dd195f 100644
--- a/javatests/com/android/tradefed/util/proto/TfMetricProtoUtilTest.java
+++ b/javatests/com/android/tradefed/util/proto/TfMetricProtoUtilTest.java
@@ -35,8 +35,7 @@ import java.util.Map;
 public class TfMetricProtoUtilTest {
 
     /**
-     * Test that the downgrade conversion to the old map converts the simple value in String. but
-     * complex values are lost since there are no good way to convert them.
+     * Test that the downgrade conversion to the old map converts values to String.
      */
     @Test
     public void testCompatibleConvert() {
@@ -56,14 +55,14 @@ public class TfMetricProtoUtilTest {
         // List of floats
         Measurements m4 =
                 Measurements.newBuilder()
-                        .setDoubleValues(DoubleValues.newBuilder().addDoubleValue(5.5f).build())
+                        .setDoubleValues(DoubleValues.newBuilder().addDoubleValue(5.5f).addDoubleValue(10f).build())
                         .build();
         metrics.put("key4", createMetric(m4));
 
         // List of strings
         Measurements m5 =
                 Measurements.newBuilder()
-                        .setStringValues(StringValues.newBuilder().addStringValue("value").build())
+                        .setStringValues(StringValues.newBuilder().addStringValue("value").addStringValue("value2").build())
                         .build();
         metrics.put("key5", createMetric(m5));
 
@@ -72,11 +71,13 @@ public class TfMetricProtoUtilTest {
         metrics.put("key6", createMetric(m6));
 
         Map<String, String> results = TfMetricProtoUtil.compatibleConvert(metrics);
-        // Only the single values are converted.
+
         assertEquals("5.5", results.get("key1"));
         assertEquals("10", results.get("key2"));
         assertEquals("value", results.get("key3"));
-        assertEquals(3, results.size());
+        assertEquals("5.5,10.0", results.get("key4"));
+        assertEquals("value,value2", results.get("key5"));
+        assertEquals(5, results.size());
     }
 
     /** Test the utility that create a single string measurement from a String. */
diff --git a/javatests/res/testtype/python_output5.txt b/javatests/res/testtype/python_output5.txt
new file mode 100644
index 000000000..9e6ec0059
--- /dev/null
+++ b/javatests/res/testtype/python_output5.txt
@@ -0,0 +1,9 @@
+setUpClass (__main__.CustomTestClassName) ... ERROR
+======================================================================
+ERROR: setUpClass (__main__.CustomTestClassName)
+----------------------------------------------------------------------
+Traceback (most recent call last):
+  File "test_binary.py", line 54, in setUpClass
+AssertionError
+----------------------------------------------------------------------
+Ran 0 tests in 0.000s
\ No newline at end of file
diff --git a/proto/instrumentation_data.proto b/proto/instrumentation_data.proto
new file mode 100644
index 000000000..3af0ffd6f
--- /dev/null
+++ b/proto/instrumentation_data.proto
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+syntax = "proto2";
+
+package android.am;
+
+option java_package = "com.android.commands.am";
+
+message ResultsBundleEntry {
+  optional string key = 1;
+  optional string value_string = 2;
+  optional sint32 value_int = 3;
+  optional float value_float = 4;
+  optional double value_double = 5;
+  optional sint64 value_long = 6;
+  optional ResultsBundle value_bundle = 7;
+  optional bytes value_bytes = 8;
+}
+message ResultsBundle {
+  repeated ResultsBundleEntry entries = 1;
+}
+message TestStatus {
+  optional sint32 result_code = 3;
+  optional ResultsBundle results = 4;
+  optional string logcat = 5;
+}
+enum SessionStatusCode {
+  /**
+   * The command ran successfully. This does not imply that the tests passed.
+   */
+  SESSION_FINISHED = 0;
+  /**
+   * There was an unrecoverable error running the tests.
+   */
+  SESSION_ABORTED = 1;
+}
+message SessionStatus {
+  optional SessionStatusCode status_code = 1;
+  optional string error_text = 2;
+  optional sint32 result_code = 3;
+  optional ResultsBundle results = 4;
+}
+message Session {
+  repeated TestStatus test_status = 1;
+  optional SessionStatus session_status = 2;
+}
+
diff --git a/proto/resultdb/OWNERS b/proto/resultdb/OWNERS
new file mode 100644
index 000000000..46282f50c
--- /dev/null
+++ b/proto/resultdb/OWNERS
@@ -0,0 +1 @@
+include /src/com/android/tradefed/result/resultdb/OWNERS
diff --git a/proto/resultdb/artifact.proto b/proto/resultdb/artifact.proto
index cec9300bf..8b7ad8eb8 100644
--- a/proto/resultdb/artifact.proto
+++ b/proto/resultdb/artifact.proto
@@ -1,18 +1,18 @@
 /*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
+* Copyright (C) 2020 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
 
 syntax = "proto3";
 
@@ -21,6 +21,7 @@ package luci.resultdb.v1;
 import "google/api/field_behavior.proto";
 import "google/protobuf/timestamp.proto";
 import public "tools/tradefederation/core/proto/resultdb/test_result.proto";
+import public "tools/tradefederation/core/proto/resultdb/common.proto";
 
 option go_package = "go.chromium.org/luci/resultdb/proto/v1;resultpb";
 option java_package = "com.android.resultdb.proto";
@@ -32,7 +33,7 @@ option java_multiple_files = true;
 // An invocation-level artifact might be related to tests, or it might not, for
 // example it may be used to store build step logs when streaming support is
 // added.
-// Next id: 11.
+// Next id: 15.
 message Artifact {
   // Can be used to refer to this artifact.
   // Format:
@@ -44,7 +45,34 @@ message Artifact {
   // https://golang.org/pkg/net/url/#PathEscape (see also https://aip.dev/122),
   // and ARTIFACT_ID is documented below.
   // Examples: "screenshot.png", "traces/a.txt".
-  string name = 1;
+  string name = 1 [
+    (google.api.field_behavior) = OUTPUT_ONLY,
+    (google.api.field_behavior) = IMMUTABLE
+  ];
+
+  // The structured test identifier. Uniquely identifies the test that was run, excluding variant.
+  //
+  // This field is only populated for test-result-level artifacts.
+  // MUST set if result_id is set.
+  // MUST NOT set for legacy uploader where test id should be specified in the parent.
+  TestIdentifierBase test_id_structured = 12 [(google.api.field_behavior) = IMMUTABLE];
+
+  // A unique identifier of the test in a LUCI project, excluding variant.
+  // Regex: ^[[::print::]]{1,512}$
+  //
+  // This is the flat-form encoding of the test_id_structured above,
+  // only populated for test-result-level artifacts.
+  // See TestIdentifier for details how a structured test identifier is converted
+  // to flat test ID.
+  //
+  // Output only.
+  string test_id = 13 [(google.api.field_behavior) = OUTPUT_ONLY, (google.api.field_behavior) = IMMUTABLE];
+
+
+  // This field is only populated for test-result-level artifacts.
+  // MUST set if test_id_structured is set.
+  // MUST NOT set for legacy uploader where result id should be specified in the parent.
+  string result_id = 14 [(google.api.field_behavior) = IMMUTABLE];
 
   // A local identifier of the artifact, unique within the parent resource.
   // MAY have slashes, but MUST NOT start with a slash.
diff --git a/proto/resultdb/common.proto b/proto/resultdb/common.proto
index 29c252989..ddf57e015 100644
--- a/proto/resultdb/common.proto
+++ b/proto/resultdb/common.proto
@@ -1,34 +1,35 @@
 /*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
+* Copyright (C) 2019 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
 
 syntax = "proto3";
 
 package luci.resultdb.v1;
 
 import "google/protobuf/timestamp.proto";
+import "google/api/field_behavior.proto";
 
 option go_package = "go.chromium.org/luci/resultdb/proto/v1;resultpb";
 option java_package = "com.android.resultdb.proto";
 option java_multiple_files = true;
 
-// A key-value map describing one variant of a test case.
+// A key-value map describing one variant of a module.
 //
-// The same test case can be executed in different ways, for example on
+// A module can be executed in different ways, for example on
 // different OS, GPUs, with different compile options or runtime flags.
-// A variant definition captures one variant.
+// A variant definition captures one such variant.
 // A test case with a specific variant definition is called test variant.
 //
 // Guidelines for variant definition design:
@@ -54,6 +55,10 @@ message Variant {
   // The definition of the variant.
   // Key and values must be valid StringPair keys and values, see their
   // constraints.
+  //
+  // These values must be the same for all tests in a given execution of
+  // a module. Variants specific to a particular test case should be
+  // encoded in the test method name (see TestIdentifier.method).
   map<string, string> def = 1;
 }
 
@@ -67,6 +72,227 @@ message StringPair {
   string value = 2;
 }
 
+// TestIdentifier represents the identity of a test in structured form.
+// It includes information about the configuration the test was run in (e.g.
+// build configuration, CPU architecture, OS).
+//
+// The structured test identifier represented in this proto corresponds to
+// the flat test identifier with the following form:
+// :{module_name}!{module_scheme}:{coarse_name}:{fine_name}#{case_name}
+//
+// and variant matching module_variant. (Note that {case_name} may in turn
+// include multiple components separated by colons, see 'Extended depth
+// hierarchies' under case_name below.)
+//
+// The precise algorithm for encoding a structured test ID to a flat
+// test ID is an implementation detail of ResultDB and must not be relied
+// upon by clients. Use the provided encode and decode functions in the
+// pbutil library if you need to encode or decode them. BigQuery exports
+// should include the structured form Test ID to avoid clients needing
+// to decode IDs.
+//
+// Special treatment exists for legacy test identifiers, for which
+// module_name = "legacy", module_scheme = "legacy", coarse_name = "",
+// fine_name = "" and case_name = <legacy_id>. For these, the corresponding
+// flat test ID is simply:
+// {case_name}
+//
+// (no escaping applies to this form, although method starting with ':'
+// is illegal for legacy test identifiers).
+//
+// See go/resultdb-test-hierarchy-design for more details.
+//
+// Limits: the encoded flat test ID (as per rules above) must be less than
+// 512 bytes in UTF-8.
+message TestIdentifier {
+  // The name of the module being tested. A module is a set of tests which run
+  // with the same test harness, and typically corresponds with a unit of
+  // build, such as a bazel test target.
+  //
+  // For example, "CtsSdkExtensionsTestCases" or "chrome/test:blink_webkit_tests".
+  //
+  // Note: Modules are identified by the combination of module_name and scheme, not
+  // only module_name. See `scheme` field below for more.
+  //
+  // Constraints:
+  // - Limited to 300 bytes of valid, printable UTF-8. For the purposes of this
+  //   definition, the unicode replacement character (U+FFFD) is not considered printable.
+  //   See also length limits on `TestIdentifier` as a whole.
+  // - All unicode must be in Normalization Form C.
+  // - Use of spaces is allowed, but discouraged.
+  string module_name = 1;
+
+  // The scheme of the module, for example, "junit" or "gtest".
+  //
+  // Must match one of the schemes in the ResultDB service configuration (see
+  // go/resultdb-schemes). Additional values can be configured as needed.
+  //
+  // Note: modules are identified by the combination of module_name, module_variant and
+  // module_scheme.
+  // Nonetheless, when presenting data on a frontend, it is acceptable to not show the scheme
+  // as it exists primarily to allow customisation of the labels shown next to the coarse_name,
+  // fine_name and case_name fields.
+  // When uploading data it is STRONGLY DISCOURAGED to use different schemes with the same
+  // module name as it may lead to ambiguous UI for users.
+  //
+  // Limited to ^[a-z][a-z0-9]{0,19}$.
+  string module_scheme = 2;
+
+  // Description of one specific way of running the tests in a module,
+  // e.g. specific ABI (x64/x86/...), build flags and/or operating system.
+  //
+  // Variants identify the unique ways the module was run compared to every other way
+  // the module is run by the LUCI project. As such, some variant key-value pairs
+  // may be repeated for all modules in an invocation.
+  //
+  // N.B. Presently this is always the same as test_result.variant but semantics could
+  // diverge in future if variants are introduced at other levels.
+  Variant module_variant = 3;
+
+  // Hash of the module variant.
+  // hex(sha256(sorted(''.join('%s:%s\n' for k, v in module_variant.items()))))[:8].
+  string module_variant_hash = 4 [(google.api.field_behavior) = OUTPUT_ONLY];
+
+  // Intermediate hierarchy - coarse name.
+  //
+  // For example "com.android.os.ext".
+  //
+  // A scheme dependent value used to organise the test into a coarse group of related tests,
+  // such as a package or directory.
+  // If the scheme does not define a coarse grouping, this must be blank.
+  // If only one intermediate hierarchy level is used for a scheme, it is always the
+  // fine hierarchy level.
+  //
+  // Constraints:
+  // - Must match constraints set by the module's scheme.
+  // - Limited to 300 bytes of printable UTF-8. For the purposes of this
+  //   definition, the unicode replacement character (U+FFFD) is not considered printable.
+  //   See also length limits on `TestIdentifier` as a whole.
+  // - Must not start with one of the characters in [ !"#$%'()*+,] (i.e. U+0020 to U+002C).
+  // - All unicode must be in Normalization Form C.
+  // - Use of spaces is allowed, but discouraged.
+  string coarse_name = 5;
+
+  // Interemdiate hierarchy - fine name.
+  //
+  // For example "SdkExtensionsTest" or "WebDialogBrowserTest".
+  //
+  // A finer grouping within the above coarse grouping (if any), e.g. class or file.
+  // If the scheme does not define a fine grouping, this must be blank.
+  //
+  // Constraints:
+  // - Must match constraints set by the module's scheme.
+  // - Limited to 300 bytes of printable UTF-8. For the purposes of this
+  //   definition, the unicode replacement character (U+FFFD) is not considered printable.
+  //   See also length limits on `TestIdentifier` as a whole.
+  // - Must not start with one of the characters in [ !"#$%'()*+,] (i.e. U+0020 to U+002C).
+  // - All unicode must be in Normalization Form C.
+  // - Use of spaces is allowed, but discouraged.
+  string fine_name = 6;
+
+  // The identifier of test case within the above fine grouping.
+  //
+  // For example "testBadArgument" or "topLevelTest:with_context:does_something".
+  //
+  // This is the finest granularity component of the test identifier, and typically
+  // refers to sub-file granularity unless no such granularity exists.
+  //
+  // Application guidance:
+  // * Standard usage: E.g. GTest methods, JUnit methods, etc.
+  //
+  //   Put the test method name in this field, escaping any colons (':')
+  //   and backlashes ('\') with a backslash '\'.
+  //   If your tests have additional hierarchy in the test case name,
+  //   consider the section on 'Extended depth hierarchies' below.
+  //
+  // * Class/package-level setup/teardown:
+  //
+  //   Use the special value "*fixture" when reporting the result of
+  //   setup and teardown common to tests in the same fine_name.
+  //
+  // * Extended depth hierarchies:
+  //
+  //   When uploading a test case from an extended depth hierarchy, use the separator ':'
+  //   to separate the components of the test case identifier (e.g. the describe blocks
+  //   in a jest/mocha test). Text between the separators must have all occurrences
+  //   of ':' and '\' escaped with a backslash ('\') to avoid other colons being interpreted
+  //   as separators. Each component of such a hierarchical test case ID must not be empty.
+  //   E.g. 'topLevelTest:' is not valid.
+  //
+  //   Rationale and Important Caveats
+  //
+  //   Most test hierarchy should be captured by the module, coarse and fine names.
+  //   For example, the module typically captures the compilation unit, the coarse name
+  //   the directory (e.g. package name) and the fine name the file (e.g. class name).
+  //   This leaves the case name to capture sub-file granularity, which
+  //   in many frameworks is simply the method name.
+  //
+  //   However, some frameworks have additional levels of test hierarchy within the
+  //   "file" level. For example, Jest and Mocha allow tests to be nested within
+  //   an arbitrary number of describe('subscope', func() { ... }) blocks. There may
+  //   also be parameterisations of tests. For such cases, we offer a standardised
+  //   way to express the additional hierarchy using colons (':') to separate components.
+  //   UI may give special treatment to components so expressed in future.
+  //
+  //   Only consider uploading separate results for each test in such an additional
+  //   depth hierarchy if all of the following hold:
+  //   - Passes are reported for each test, not just failures.
+  //   - Tests are independent (e.g. a assertion failure does not cause multiple
+  //     failing results, e.g. failure of the child test does not also cause the
+  //     parent to fail or vice-versa as is typical in many 'subtest' arrangements).
+  //   - In case of retries, you are happy for each test passing individually at least
+  //     once to allow CL submission. I.E. they do not all have to pass in the same run.
+  //
+  //   The above criteria are important to keep the test results view understandable in
+  //   case of retries, and to protect the data model that downstream clients
+  //   rely on (e.g. clients must report passes where they report failures).
+  //
+  //   If they cannot be met, do not upload separate tests results and prefer to upload one
+  //   test result per top-level method. Currently Mocha and Jest tests, and parameterised
+  //   GTest methods are the only cases where it is known these requirements can be met. Python
+  //   unittests and go subtests do not meet the requirements due to falling foul of the
+  //   independence requirement (and in case of python unittests, also the inability to
+  //   report passes for subtests).
+  //
+  // Constraints:
+  // - Must not start with one of the characters in [ !"#$%'()*+,] (i.e. U+0020 to U+002C),
+  //   unless it is to write the value "*fixture".
+  // - The use of the ':' character is reserved for denoting variable depth/extended depth
+  //   hierarchies. If you do not intend this semantic, you must escape it using a backslash.
+  //   (You must also escape all backslashes that are not denoting an escape sequence with
+  //   a backslash.)
+  // - When the case_name is broken up by ':', each such component must be non-empty.
+  // - Limited to 512 bytes of printable UTF-8. For the purposes of this
+  //   definition, the unicode replacement character (U+FFFD) is not considered printable.
+  //   See also length limits on `TestIdentifier` as a whole.
+  // - All unicode must be in Normalization Form C.
+  // - Use of spaces is allowed, but discouraged.
+  // - Legacy test identifiers (in module "legacy") are exempted from some of the
+  //   above constraints to facilitate backwards compatibility but use of this quirk is
+  //   discouraged.
+  string case_name = 7;
+}
+
+// TestIdentifierBase represent a structured test id message without variant information.
+// See luci.resultdb.v1.TestIdentifier for the full message structured test id message.
+message TestIdentifierBase {
+
+  // Equivalent of luci.resultdb.v1.TestIdentifier.module_name.
+  string module_name = 1;
+
+  // Equivalent of luci.resultdb.v1.TestIdentifier.module_scheme.
+  string module_scheme = 2;
+
+  // Equivalent of luci.resultdb.v1.TestIdentifier.coarse_name.
+  string coarse_name = 5;
+
+  // Equivalent of luci.resultdb.v1.TestIdentifier.fine_name.
+  string fine_name = 6;
+
+  // Equivalent of luci.resultdb.v1.TestIdentifier.case_name.
+  string case_name = 7;
+}
+
 // GitilesCommit specifies the position of the gitiles commit an invocation
 // ran against, in a repository's commit log. More specifically, a ref's commit
 // log.
diff --git a/proto/resultdb/experiments.proto b/proto/resultdb/experiments.proto
new file mode 100644
index 000000000..5c2786a0a
--- /dev/null
+++ b/proto/resultdb/experiments.proto
@@ -0,0 +1,52 @@
+/*
+* Copyright (C) 2024 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+syntax = "proto3";
+
+package luci.resultdb.v1;
+
+option go_package = "go.chromium.org/luci/resultdb/proto/v1;resultpb";
+option java_package = "com.android.resultdb.proto";
+option java_multiple_files = true;
+
+// Service that contains experiments.
+//
+// Reliability and backwards compatibility is not assured. Do not
+// depend on this service from your production environment or anywhere
+// you cannot accept breakage at any time.
+//
+// Use of LUCI is subject to the Google [Terms of Service](https://policies.google.com/terms)
+// and [Privacy Policy](https://policies.google.com/privacy).
+service Experiments {
+  // Sample RPC to allow verification the server is up and running.
+  // Replace with actual RPC.
+  rpc Echo(EchoRequest) returns (EchoResponse) {};
+}
+
+// A request message for Echo RPC.
+message EchoRequest {
+  // A message, which is to be returned in the response.
+  //
+  // Must consist only of printable ASCII characters.
+  // Max 1024 characters. Mandatory.
+  string message = 1;
+}
+
+// A response message for Echo RPC.
+message EchoResponse {
+  // The message, which was provided in the request.
+  string message = 1;
+}
diff --git a/proto/resultdb/failure_reason.proto b/proto/resultdb/failure_reason.proto
index a5629fe3b..b267fb0e4 100644
--- a/proto/resultdb/failure_reason.proto
+++ b/proto/resultdb/failure_reason.proto
@@ -1,18 +1,18 @@
 /*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
+* Copyright (C) 2021 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
 
 syntax = "proto3";
 
diff --git a/proto/resultdb/instruction.proto b/proto/resultdb/instruction.proto
index 4d5459060..04c83f54b 100644
--- a/proto/resultdb/instruction.proto
+++ b/proto/resultdb/instruction.proto
@@ -1,18 +1,18 @@
 /*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
+* Copyright (C) 2024 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
 
 syntax = "proto3";
 
diff --git a/proto/resultdb/invocation.proto b/proto/resultdb/invocation.proto
index 4d49d9c89..38de97a8e 100644
--- a/proto/resultdb/invocation.proto
+++ b/proto/resultdb/invocation.proto
@@ -1,18 +1,18 @@
 /*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
+* Copyright (C) 2019 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
 
 syntax = "proto3";
 
@@ -25,7 +25,6 @@ import public "tools/tradefederation/core/proto/resultdb/common.proto";
 import public "tools/tradefederation/core/proto/resultdb/instruction.proto";
 import public "tools/tradefederation/core/proto/resultdb/predicate.proto";
 
-
 option go_package = "go.chromium.org/luci/resultdb/proto/v1;resultpb";
 option java_package = "com.android.resultdb.proto";
 option java_multiple_files = true;
@@ -73,7 +72,12 @@ message Invocation {
   // At creation time this can be set to FINALIZING e.g. if this invocation is
   // a simple wrapper of another and will itself not be modified.
   //
-  // Otherwise this is an output only field.
+  // When updating invocation, this can be set to FINALIZING. If set, this will trigger
+  // the finalization process of the invocation. This is useful for the cases when
+  // we want the update and the finalization to happen in the same transaction to
+  // prevent update-update race. This will guarantee eventual consistency.
+  //
+  // In other cases this is an output only field.
   State state = 2;
 
   // When the invocation was created.
diff --git a/proto/resultdb/notification.proto b/proto/resultdb/notification.proto
new file mode 100644
index 000000000..b249b5a16
--- /dev/null
+++ b/proto/resultdb/notification.proto
@@ -0,0 +1,116 @@
+/*
+* Copyright (C) 2022 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+syntax = "proto3";
+
+package luci.resultdb.v1;
+
+import "google/protobuf/timestamp.proto";
+import public "tools/tradefederation/core/proto/resultdb/invocation.proto";
+
+option go_package = "go.chromium.org/luci/resultdb/proto/v1;resultpb";
+option java_package = "com.android.resultdb.proto";
+option java_multiple_files = true;
+
+// A message notifying that an invocation has been finalized,
+// i.e. that an invocation's test results are now immutable and are
+// safe to be exported.
+//
+// The message is sent over the `v1.invocation_finalized` Cloud Pub/Sub
+// topic in JSON-serialized form.
+//
+// Next id: 6.
+message InvocationFinalizedNotification {
+    // The name of the invocation that was finalized.
+    // Format: invocations/{INVOCATION_ID}.
+    string invocation = 1;
+
+    // The LUCI realm that owns the invocation.
+    // E.g. "chromium:ci".
+    string realm = 2;
+
+    // Whether this invocation is a root of the invocation graph for export purposes.
+    //
+    // To help downstream systems (like LUCI Analysis) make sense of test results,
+    // and gather overall context for a result, ResultDB data export is centered
+    // around export roots.
+    //
+    // See more in invocation.proto.
+    bool is_export_root = 3;
+
+    // The hostname of the luci.resultdb.v1.ResultDB service which
+    // can be used to query more information about the invocation(s)
+    // notified in this message.
+    string resultdb_host = 4;
+
+    // When the invocation was created.
+    google.protobuf.Timestamp create_time = 5;
+}
+
+// InvocationReadyForExportNotification notifies that the properties, test results
+// and artifacts directly inside invocation `invocation`, within the context of
+// export root `root_invocation`, are now immutable and ready for consumption
+// by downstream systems.
+//
+// If a given invocation is included by multiple export roots, a message will
+// be sent for each such root.
+//
+// When sent over v1.invocation_ready_for_export Cloud Pub/Sub, an attribute
+// "luci_project" will be attached to the message, which will contain the
+// LUCI Project of the `root_invocation_realm`.
+//
+// Next ID: 8.
+message InvocationReadyForExportNotification {
+    // The hostname of the luci.resultdb.v1.ResultDB service which
+    // can be used to query more information about the invocation(s)
+    // notified in this message.
+    string resultdb_host = 6;
+
+    // The export root with respect to which the export is occurring.
+    //
+    // Format: invocations/{ROOT_INVOCATION_ID}.
+    string root_invocation = 1;
+
+    // The LUCI realm that owns the root invocation.
+    string root_invocation_realm = 2;
+
+    // When the root invocation was created.
+    google.protobuf.Timestamp root_create_time = 7;
+
+    // The name of the ResultDB invocation included by root_invocation whose
+    // immediate properties, test results and artifacts are now immutable
+    // (in FINALIZING OR FINALIZED state). Note that child invocations included
+    // by `invocation` may not yet be immutable.
+    //
+    // This may be equal to root_invocation, to indicate test results, artifacts
+    // and properties immediately inside root_invocation are immutable and ready
+    // for ingestion.
+    //
+    // Format: invocations/{INVOCATION_ID}.
+    string invocation = 3;
+
+    // The LUCI realm that owns `invocation`.
+    string invocation_realm = 4;
+
+    // The resolved sources for `invocation`, if any.
+    //
+    // As sources may be inherited, the sources resolved for the same
+    // invocation may vary between export roots. This typically occurs when
+    // a project uses testing task deduplication, and the different sources
+    // deduplicate to the same testing task as they compile to
+    // byte-for-byte-identical testing artifacts.
+    luci.resultdb.v1.Sources sources = 5;
+}
diff --git a/proto/resultdb/predicate.proto b/proto/resultdb/predicate.proto
index 96525ce66..bcf9b1f5b 100644
--- a/proto/resultdb/predicate.proto
+++ b/proto/resultdb/predicate.proto
@@ -1,18 +1,18 @@
 /*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
+* Copyright (C) 2019 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
 
 syntax = "proto3";
 
diff --git a/proto/resultdb/recorder.proto b/proto/resultdb/recorder.proto
index 7ae42fb90..60f48b241 100644
--- a/proto/resultdb/recorder.proto
+++ b/proto/resultdb/recorder.proto
@@ -1,18 +1,18 @@
 /*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
+* Copyright (C) 2019 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
 
 syntax = "proto3";
 
@@ -21,15 +21,13 @@ package luci.resultdb.v1;
 import "google/api/field_behavior.proto";
 import "google/protobuf/empty.proto";
 import "google/protobuf/field_mask.proto";
-
-import public "tools/tradefederation/core/proto/resultdb/invocation.proto";
 import public "tools/tradefederation/core/proto/resultdb/artifact.proto";
+import public "tools/tradefederation/core/proto/resultdb/invocation.proto";
 import public "tools/tradefederation/core/proto/resultdb/test_result.proto";
 
 option go_package = "go.chromium.org/luci/resultdb/proto/v1;resultpb";
 option java_package = "com.android.resultdb.proto";
 option java_multiple_files = true;
-option java_generic_services = true;
 
 // Service to record test results.
 //
@@ -39,6 +37,9 @@ option java_generic_services = true;
 //
 // RPCs that mutate an invocation return FAILED_PRECONDITION error code if the
 // invocation is finalized.
+//
+// Use of LUCI is subject to the Google [Terms of Service](https://policies.google.com/terms)
+// and [Privacy Policy](https://policies.google.com/privacy).
 service Recorder {
 
   // == Invocations ============================================================
@@ -156,6 +157,14 @@ message BatchCreateInvocationsResponse {
 // A request message for UpdateInvocation RPC.
 message UpdateInvocationRequest {
   // Invocation to update.
+  // If updating tags, the existing tags will be replaced with the new ones.
+  //
+  // If the state of the invocation is set to FINALIZING (with correct update_mask),
+  // this will trigger the finalization process of the invocation.
+  //
+  // This is useful for the cases when we want the update and the finalization
+  // to happen in the same transaction to prevent update-update race. This will
+  // guarantee eventual consistency.
   Invocation invocation = 1 [ (google.api.field_behavior) = REQUIRED ];
 
   // The list of fields to be updated.
@@ -297,10 +306,17 @@ message BatchCreateTestExonerationsResponse {
 
 // A request message for CreateArtifactRequest.
 message CreateArtifactRequest {
-  // Name of the parent resource where the artifact will be created.
+
+  // Name of the parent invocation, see Invocation.name.
+  //
+  // To create test result-level artifacts, set test_id_structured and result_id on
+  // the Artifact. Otherwise, to create invocation-level artifacts, leave
+  // test_id_structured and result_id blank.
   //
-  // For invocation-level artifacts, it is the invocation name.
-  // For test-result-level artifacts, it is the TestResult name.
+  // Legacy uploaders can also use the name format:
+  // invocations/{INVOCATION_ID}/tests/{URL_ENCODED_TEST_ID}/results/{RESULT_ID}
+  // to create test result-level artifacts (in this case, test_id_structured and
+  // result_id MUST be left blank on the Artifact).
   string parent = 1 [ (google.api.field_behavior) = REQUIRED ];
 
   // Artifact to upload.
@@ -311,11 +327,17 @@ message CreateArtifactRequest {
 }
 
 // A request message for BatchCreateArtifactsRequest.
+// Next ID: 4.
 message BatchCreateArtifactsRequest {
+  // Required. Name of the parent invocation, see Invocation.name.
+  // Can only be empty for legacy uploaders which specify requests[i].parent.
+  string parent = 3 [ (google.api.field_behavior) = REQUIRED ];
+
   // Requests to create Artifacts.
   // The sum of the content lengths MUST be <= 10MiB.
-  // The parents of all the requests must be derived from the same invocation.
-  //
+  // requests[i].parent MUST be either empty or equal to parent in this
+  // message.
+  // For legacy uploader requests[i].parent MUST be derived from the same invocation.
   // Up to 500 requests.
   repeated CreateArtifactRequest requests = 2;
 }
diff --git a/proto/resultdb/resultdb.proto b/proto/resultdb/resultdb.proto
new file mode 100644
index 000000000..ddf4e953d
--- /dev/null
+++ b/proto/resultdb/resultdb.proto
@@ -0,0 +1,1163 @@
+/*
+* Copyright (C) 2019 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+syntax = "proto3";
+
+package luci.resultdb.v1;
+
+import "google/protobuf/timestamp.proto";
+import "google/api/field_behavior.proto";
+import "google/protobuf/field_mask.proto";
+import public "tools/tradefederation/core/proto/resultdb/artifact.proto";
+import public "tools/tradefederation/core/proto/resultdb/common.proto";
+import public "tools/tradefederation/core/proto/resultdb/instruction.proto";
+import public "tools/tradefederation/core/proto/resultdb/invocation.proto";
+import public "tools/tradefederation/core/proto/resultdb/predicate.proto";
+import public "tools/tradefederation/core/proto/resultdb/test_result.proto";
+import public "tools/tradefederation/core/proto/resultdb/test_variant.proto";
+import public "tools/tradefederation/core/proto/resultdb/test_metadata.proto";
+
+option go_package = "go.chromium.org/luci/resultdb/proto/v1;resultpb";
+option java_package = "com.android.resultdb.proto";
+option java_multiple_files = true;
+
+// Service to read test results.
+//
+// Use of LUCI is subject to the Google [Terms of Service](https://policies.google.com/terms)
+// and [Privacy Policy](https://policies.google.com/privacy).
+service ResultDB {
+  // Retrieves an invocation.
+  rpc GetInvocation(GetInvocationRequest) returns (Invocation) {};
+
+  // Retrieve names of all root invocations for a given invocation.
+  rpc QueryRootInvocationNames(QueryRootInvocationNamesRequest) returns (QueryRootInvocationNamesResponse) {};
+
+  // == Test results ===========================================================
+
+  // Retrieves a test result.
+  rpc GetTestResult(GetTestResultRequest) returns (TestResult) {};
+
+  // Retrieves test results for a parent invocation.
+  //
+  // Note: response does not contain test results of included invocations.
+  // Use QueryTestResults instead.
+  rpc ListTestResults(ListTestResultsRequest)
+      returns (ListTestResultsResponse) {};
+
+  // Retrieves a test exoneration.
+  rpc GetTestExoneration(GetTestExonerationRequest) returns (TestExoneration) {
+  };
+
+  // Retrieves test exonerations for a parent invocation.
+  //
+  // Note: response does not contain test results of included invocations.
+  // Use QueryTestExonerations instead.
+  rpc ListTestExonerations(ListTestExonerationsRequest)
+      returns (ListTestExonerationsResponse) {};
+
+  // Retrieves test results from an invocation, recursively.
+  // Supports invocation inclusions.
+  // Supports advanced filtering.
+  // Examples: go/resultdb-rpc#querytestresults
+  rpc QueryTestResults(QueryTestResultsRequest)
+      returns (QueryTestResultsResponse) {};
+
+  // Retrieves test exonerations from an invocation.
+  // Supports invocation inclusions.
+  // Supports advanced filtering.
+  rpc QueryTestExonerations(QueryTestExonerationsRequest)
+      returns (QueryTestExonerationsResponse) {};
+
+  // Retrieves the test result statistics of an invocation.
+  // Currently supports total number of test results belong to the invocation,
+  // directly and indirectly.
+  rpc QueryTestResultStatistics(QueryTestResultStatisticsRequest)
+      returns (QueryTestResultStatisticsResponse) {};
+
+  // Calculate new test variants by running the difference between the tests
+  // run in the given invocation against the submitted test history for the
+  // source.
+  rpc QueryNewTestVariants(QueryNewTestVariantsRequest)
+      returns (QueryNewTestVariantsResponse) {};
+
+  // Retrieves test verdicts for a test run. A test run comprises only
+  // the test results from a single invocation and not its included
+  // invocations.
+  //
+  // Useful to incrementally ingest test results for an export root as its
+  // individual constituent invocations finalize, in conjunction with
+  // the invocations-ready-for-export pub/sub.
+  //
+  // Compared to the ListTestResults RPC, this RPC ensures all results
+  // for a test variant are returned together, which is useful when
+  // ingesting results into analyses that treat retried test results
+  // in a given test run differently to the first retry.
+  //
+  // To use, the caller must have `resultdb.testResults.list` permission
+  // on the queried invocation.
+  rpc QueryRunTestVerdicts(QueryRunTestVerdictsRequest) returns (QueryRunTestVerdictsResponse) {};
+
+  // Retrieves test verdicts from an invocation, recursively.
+  // Supports invocation inclusions.
+  rpc QueryTestVariants(QueryTestVariantsRequest) returns (QueryTestVariantsResponse) {};
+
+  // Retrieves test variants from a single invocation, matching the specified
+  // test IDs and hashes.
+  rpc BatchGetTestVariants(BatchGetTestVariantsRequest) returns (BatchGetTestVariantsResponse) {};
+
+  // Retrieves test metadata from a LUCI project, matching the predicate.
+  rpc QueryTestMetadata(QueryTestMetadataRequest) returns (QueryTestMetadataResponse) {};
+
+  // Retrieves an instruction for step or test result.
+  // If the instruction contains placeholders, they will not be replaced.
+  // The callers of this RPC are responsible to populate the placeholders with real data.
+  rpc GetInstruction(GetInstructionRequest) returns (Instruction) {};
+
+  // Retrieves the instruction and the dependency chain for all targets.
+  // A maximum depth can be specified for the maximum number of dependency nodes to be returned.
+  // If an error occurs while traversing a chain (e.g. circular dependency, permission, not found...),
+  // the chain will stop and the rpc will return whatever it has found so far.
+  rpc QueryInstruction(QueryInstructionRequest) returns (QueryInstructionResponse) {};
+
+  // == Artifacts =============================================================
+
+  // Retrieves an artifact.
+  rpc GetArtifact(GetArtifactRequest) returns (Artifact) {};
+
+  // Retrieves artifacts for a parent invocation/testResult.
+  //
+  // Note: if the parent is an invocation, the response does not contain
+  // artifacts of included invocations. Use QueryArtifacts instead.
+  rpc ListArtifacts(ListArtifactsRequest) returns (ListArtifactsResponse) {};
+
+  // Retrieves artifacts from an invocation, recursively.
+  // Can retrieve artifacts of test results included in the invocation
+  // directly or indirectly.
+  // Supports invocation inclusions.
+  rpc QueryArtifacts(QueryArtifactsRequest) returns (QueryArtifactsResponse) {};
+
+  // Lists the artifact contents as a list of log lines and
+  // performs best effort extraction of log information
+  // such as severity and timestamp for each line.
+  //
+  // Currently supports artifacts with content types: [text/plain,]
+  rpc ListArtifactLines(ListArtifactLinesRequest) returns (ListArtifactLinesResponse) {};
+
+  // Retrieves the line ranges in the given failure that do not usually appear
+  // in logs from passes.
+  //
+  // Lines are normalized before comparison to remove numbers, dates, tmp file
+  // paths, etc.
+  //
+  // Due to missed normalizations, sampling error or other reasons, this may
+  // not eliminate all lines that appear in passes.
+  rpc QueryArtifactFailureOnlyLines(QueryArtifactFailureOnlyLinesRequest) returns (QueryArtifactFailureOnlyLinesResponse) {};
+
+  // == Log Search =============================================================
+
+  // Queries result level artifacts that matches a search_string. Support regex or exact match.
+  // Results are grouped by test_id, variant_hash, artifact_id.
+  // Within each group, artifacts are sorted by recency and at most 3 are returned.
+  // To obtain more matching artifacts of a particular group, uses QueryTestVariantArtifacts.
+  rpc QueryTestVariantArtifactGroups(QueryTestVariantArtifactGroupsRequest) returns (
+    QueryTestVariantArtifactGroupsResponse) {}
+
+  // Queries test result artifacts that match a search_string for given test_id, variant_hash and artifact_id.
+  rpc QueryTestVariantArtifacts(QueryTestVariantArtifactsRequest) returns (
+    QueryTestVariantArtifactsResponse) {}
+
+  // Queries invocation level artifacts that matches a search_string. Support regex or exact match.
+  // Results are grouped by variant_union_hash, artifact_id.
+  // Within each group, artifacts are sorted by recency and at most 3 are returned.
+  // To obtain more matching artifacts of a particular group, uses QueryInvocationVariantArtifacts.
+  rpc QueryInvocationVariantArtifactGroups(QueryInvocationVariantArtifactGroupsRequest) returns (
+    QueryInvocationVariantArtifactGroupsResponse) {}
+
+  // Queries invocation artifacts that match a search_string for given variant_union_hash and artifact_id.
+  rpc QueryInvocationVariantArtifacts(QueryInvocationVariantArtifactsRequest) returns (
+    QueryInvocationVariantArtifactsResponse) {}
+}
+
+// A request message for GetInvocation RPC.
+message GetInvocationRequest {
+  // The name of the invocation to request, see Invocation.name.
+  string name = 1 [ (google.api.field_behavior) = REQUIRED ];
+}
+
+// A request message for QueryRootInvocationNames RPC.
+message QueryRootInvocationNamesRequest {
+  // The name of the invocation to request, see Invocation.name.
+  string name = 1 [ (google.api.field_behavior) = REQUIRED ];
+}
+
+// A response message for QueryRootInvocationNames RPC.
+message QueryRootInvocationNamesResponse {
+  // The name of all root invocations to the invocation in the request.
+  // A root either
+  //   - has is_export_root = true, or
+  //   - has no parent invocation.
+  //
+  // If the invocation to request is already a root,
+  // the root_invocation_names will only contains the invocation in the request
+  // (i.e. a invocation can be its own root).
+  //
+  // root_invocation_names can be empty when no root is found (in the presence of cycles).
+  repeated string root_invocation_names = 1;
+}
+
+
+// A request message for GetTestResult RPC.
+message GetTestResultRequest {
+  // The name of the test result to request, see TestResult.name.
+  string name = 1 [ (google.api.field_behavior) = REQUIRED ];
+}
+
+// A request message for ListTestResults RPC.
+message ListTestResultsRequest {
+  // Name of the invocation, e.g. "invocations/{id}".
+  string invocation = 1 [ (google.api.field_behavior) = REQUIRED ];
+
+  // The maximum number of test results to return.
+  //
+  // The service may return fewer than this value.
+  // If unspecified, at most 100 test results will be returned.
+  // The maximum value is 1000; values above 1000 will be coerced to 1000.
+  int32 page_size = 2;
+
+  // A page token, received from a previous `ListTestResults` call.
+  // Provide this to retrieve the subsequent page.
+  //
+  // When paginating, all other parameters provided to `ListTestResults` MUST
+  // match the call that provided the page token.
+  string page_token = 3;
+
+  // Fields to include in the response.
+  // If not set, the default mask is used where summary_html and tags are
+  // excluded.
+  // Test result names will always be included even if "name" is not a part of
+  // the mask.
+  google.protobuf.FieldMask read_mask = 4;
+}
+
+// A response message for ListTestResults RPC.
+message ListTestResultsResponse {
+  // The test results from the specified invocation.
+  repeated TestResult test_results = 1;
+
+  // A token, which can be sent as `page_token` to retrieve the next page.
+  // If this field is omitted, there were no subsequent pages at the time of
+  // request.
+  // If the invocation is not finalized, more results may appear later.
+  string next_page_token = 2;
+}
+
+// A request message for GetTestExoneration RPC.
+message GetTestExonerationRequest {
+  // The name of the test exoneration to request, see TestExoneration.name.
+  string name = 1;
+}
+
+// A request message for ListTestExonerations RPC.
+message ListTestExonerationsRequest {
+  // Name of the invocation, e.g. "invocations/{id}".
+  string invocation = 1 [ (google.api.field_behavior) = REQUIRED ];
+
+  // The maximum number of test exonerations to return.
+  //
+  // The service may return fewer than this value.
+  // If unspecified, at most 100 test exonerations will be returned.
+  // The maximum value is 1000; values above 1000 will be coerced to 1000.
+  int32 page_size = 2;
+
+  // A page token, received from a previous `ListTestExonerations` call.
+  // Provide this to retrieve the subsequent page.
+  //
+  // When paginating, all other parameters provided to `ListTestExonerations`
+  // MUST match the call that provided the page token.
+  string page_token = 3;
+}
+
+// A response message for ListTestExonerations RPC.
+message ListTestExonerationsResponse {
+  // The test exonerations from the specified invocation.
+  repeated TestExoneration test_exonerations = 1;
+
+  // A token, which can be sent as `page_token` to retrieve the next page.
+  // If this field is omitted, there were no subsequent pages at the time of
+  // request.
+  // If the invocation is not finalized, more results may appear later.
+  string next_page_token = 2;
+}
+
+// A request message for QueryTestResults RPC.
+message QueryTestResultsRequest {
+  // Retrieve test results included in these invocations, directly or indirectly
+  // (via Invocation.included_invocations).
+  //
+  // Specifying multiple invocations is equivalent to querying one invocation
+  // that includes these.
+  repeated string invocations = 1;
+
+  // A test result in the response must satisfy this predicate.
+  TestResultPredicate predicate = 2;
+
+  // The maximum number of test results to return.
+  //
+  // The service may return fewer than this value.
+  // If unspecified, at most 100 test results will be returned.
+  // The maximum value is 1000; values above 1000 will be coerced to 1000.
+  int32 page_size = 4;
+
+  // A page token, received from a previous `QueryTestResults` call.
+  // Provide this to retrieve the subsequent page.
+  //
+  // When paginating, all other parameters provided to `QueryTestResults` MUST
+  // match the call that provided the page token.
+  string page_token = 5;
+
+  // Fields to include in the response.
+  // If not set, the default mask is used where summary_html, properties and tags are
+  // excluded.
+  // Test result names will always be included even if "name" is not a part of
+  // the mask.
+  google.protobuf.FieldMask read_mask = 6;
+}
+
+// A response message for QueryTestResults RPC.
+message QueryTestResultsResponse {
+  // Matched test results.
+  // Ordered by parent invocation ID, test ID and result ID.
+  repeated TestResult test_results = 1;
+
+  // A token, which can be sent as `page_token` to retrieve the next page.
+  // If this field is omitted, there were no subsequent pages at the time of
+  // request.
+  string next_page_token = 2;
+}
+
+// A request message for QueryTestExonerations RPC.
+message QueryTestExonerationsRequest {
+  // Retrieve test exonerations included in these invocations, directly or
+  // indirectly (via Invocation.included_invocations).
+  //
+  // As of February 2025, a maximum of one invocation may be specified.
+  repeated string invocations = 1;
+
+  // A test exoneration in the response must satisfy this predicate.
+  TestExonerationPredicate predicate = 2
+      [ (google.api.field_behavior) = REQUIRED ];
+
+  // The maximum number of test exonerations to return.
+  //
+  // The service may return fewer than this value.
+  // If unspecified, at most 100 test exonerations will be returned.
+  // The maximum value is 1000; values above 1000 will be coerced to 1000.
+  int32 page_size = 4;
+
+  // A page token, received from a previous `QueryTestExonerations` call.
+  // Provide this to retrieve the subsequent page.
+  //
+  // When paginating, all other parameters provided to `QueryTestExonerations`
+  // MUST match the call that provided the page token.
+  string page_token = 5;
+}
+
+// A response message for QueryTestExonerations RPC.
+message QueryTestExonerationsResponse {
+  // The test exonerations matching the predicate.
+  // Ordered by parent invocation ID, test ID and exoneration ID.
+  repeated TestExoneration test_exonerations = 1;
+
+  // A token, which can be sent as `page_token` to retrieve the next page.
+  // If this field is omitted, there were no subsequent pages at the time of
+  // request.
+  string next_page_token = 2;
+}
+
+// A request message for QueryTestResultStatistics RPC.
+message QueryTestResultStatisticsRequest {
+  // Retrieve statistics of test result belong to these invocations,
+  // directly or indirectly (via Invocation.included_invocations).
+  //
+  // Specifying multiple invocations is equivalent to requesting one invocation
+  // that includes these.
+  repeated string invocations = 1;
+}
+
+// A response message for QueryTestResultStatistics RPC.
+message QueryTestResultStatisticsResponse {
+  // Total number of test results.
+  int64 total_test_results = 1;
+}
+
+// A request message for GetArtifact RPC.
+message GetArtifactRequest {
+  // The name of the artifact to request, see Artifact.name.
+  string name = 1 [ (google.api.field_behavior) = REQUIRED ];
+}
+
+// A request message for ListArtifacts RPC.
+message ListArtifactsRequest {
+  // Name of the parent, e.g. an invocation (see Invocation.name) or
+  // a test result (see TestResult.name).
+  string parent = 1 [ (google.api.field_behavior) = REQUIRED ];
+
+  // The maximum number of artifacts to return.
+  //
+  // The service may return fewer than this value.
+  // If unspecified, at most 100 artifacts will be returned.
+  // The maximum value is 1000; values above 1000 will be coerced to 1000.
+  int32 page_size = 2;
+
+  // A page token, received from a previous `ListArtifacts` call.
+  // Provide this to retrieve the subsequent page.
+  //
+  // When paginating, all other parameters provided to `ListArtifacts` MUST
+  // match the call that provided the page token.
+  string page_token = 3;
+}
+
+// A response message for ListArtifacts RPC.
+message ListArtifactsResponse {
+  // The artifacts from the specified parent.
+  repeated Artifact artifacts = 1;
+
+  // A token, which can be sent as `page_token` to retrieve the next page.
+  // If this field is omitted, there were no subsequent pages at the time of
+  // request.
+  // If the invocation is not finalized, more results may appear later.
+  string next_page_token = 2;
+}
+
+// A request message for QueryArtifacts RPC.
+message QueryArtifactsRequest {
+  // Retrieve artifacts included in these invocations, directly or indirectly
+  // (via Invocation.included_invocations and via contained test results).
+  //
+  // Specifying multiple invocations is equivalent to querying one invocation
+  // that includes these.
+  repeated string invocations = 1;
+
+  // An artifact in the response must satisfy this predicate.
+  ArtifactPredicate predicate = 2;
+
+  // The maximum number of artifacts to return.
+  //
+  // The service may return fewer than this value.
+  // If unspecified, at most 100 artifacts will be returned.
+  // The maximum value is 1000; values above 1000 will be coerced to 1000.
+  int32 page_size = 4;
+
+  // A page token, received from a previous `QueryArtifacts` call.
+  // Provide this to retrieve the subsequent page.
+  //
+  // When paginating, all other parameters provided to `QueryArtifacts` MUST
+  // match the call that provided the page token.
+  string page_token = 5;
+}
+
+// A response message for QueryArtifacts RPC.
+message QueryArtifactsResponse {
+  // Matched artifacts.
+  // First invocation-level artifacts, then test-result-level artifacts
+  // ordered by parent invocation ID, test ID and artifact ID.
+  repeated Artifact artifacts = 1;
+
+  // A token, which can be sent as `page_token` to retrieve the next page.
+  // If this field is omitted, there were no subsequent pages at the time of
+  // request.
+  string next_page_token = 2;
+}
+
+// A request message for ListArtifactLines RPC.
+message ListArtifactLinesRequest {
+  // Retrieve log lines for this artifact.
+  // Format:
+  // - For invocation-level artifacts:
+  //   "invocations/{INVOCATION_ID}/artifacts/{ARTIFACT_ID}".
+  // - For test-result-level artifacts:
+  //   "invocations/{INVOCATION_ID}/tests/{URL_ESCAPED_TEST_ID}/results/{RESULT_ID}/artifacts/{ARTIFACT_ID}".
+  string parent = 1;
+
+  // The maximum number of log lines to return.
+  //
+  // The service may return fewer than this value.
+  // The response size will be truncated to 10MB
+  // if the size of matching lines is larger than 10MB.
+  // If unspecified or is equal to 0, a max of 10MB of lines will be returned.
+  // Negative page sizes are not allowed.
+  int32 page_size = 2;
+}
+
+// A response for ListArtifactLines RPC
+message ListArtifactLinesResponse {
+
+  // The log lines in the artifact.
+  repeated ArtifactLine lines = 1;
+}
+
+// A request for the QueryArtifactFailureOnlyLines RPC.
+message QueryArtifactFailureOnlyLinesRequest {
+  // Retrieve log lines for this artifact.
+  // Invocation level artifacts are not yet supported.
+  // Format:
+  // - For test-result-level artifacts:
+  //   "invocations/{INVOCATION_ID}/tests/{URL_ESCAPED_TEST_ID}/results/{RESULT_ID}/artifacts/{ARTIFACT_ID}".
+  string parent = 1;
+
+  // If set to true, the content of the log lines will be returned in the
+  // response.  If left missing or false, only the line range indexes will
+  // be returned.
+  bool include_content = 2;
+
+  // The maximum number of line ranges to return.
+  //
+  // The service may return fewer than this value.
+  // If unspecified, at most 1000 line ranges will be returned.
+  // The maximum value is 10,000; values above 10,000 will be coerced to 10,000.
+  int32 page_size = 4;
+
+  // A page token, received from a previous `QueryArtifactFailureOnlyLines` call.
+  // Provide this to retrieve the subsequent page.
+  //
+  // When paginating, all other parameters provided to `QueryArtifactFailureOnlyLines` MUST
+  // match the call that provided the page token.
+  string page_token = 5;
+}
+
+// A response for the QueryArtifactFailureOnlyLines RPC.
+message QueryArtifactFailureOnlyLinesResponse {
+  // A representation of a range of lines in an artifact, where lines are
+  // represented by their index.  The first line is line 0.
+  message LineRange {
+    // The line index of the start of the line range.  The start is inclusive,
+    // i.e. the start line is included in the range.
+    int32 start = 1;
+    // The line index of the end of the line range.  The end is exclusive, i.e.
+    // the end line is not included in the range.
+    int32 end = 2;
+    // The content of the lines in the range.
+    // Only included if include_content in the request is set to true.
+    repeated string lines = 3;
+  }
+
+  // Line ranges [start, end) in the requested artifact that do not typically
+  // appear versions of the artifact from passing test results.
+  // Line ranges are returned in sorted ascending order.
+  repeated LineRange failure_only_line_ranges = 1;
+
+  // A token, which can be sent as `page_token` to retrieve the next page.
+  // If this field is omitted, there were no subsequent pages at the time of
+  // request.
+  string next_page_token = 2;
+}
+
+// A request message for QueryTestVariants RPC.
+// Next id: 9.
+message QueryTestVariantsRequest {
+  // Retrieve test verdicts included in these invocations, directly or indirectly
+  // (via Invocation.included_invocations).
+  //
+  // As of April 2024, a maximum of one invocation may be specified.
+  repeated string invocations = 2;
+
+  // A test variant must satisfy this predicate.
+  TestVariantPredicate predicate = 6;
+
+  // The maximum number of test results to be included in a test variant.
+  //
+  // If a test variant has more results than the limit, the remaining results
+  // will not be returned.
+  // If unspecified, at most 10 results will be included in a test variant.
+  // The maximum value is 100; values above 100 will be coerced to 100.
+  int32 result_limit = 8;
+
+  // The maximum number of test variants to return.
+  //
+  // The service may return fewer than this value.
+  // If unspecified, at most 100 test variants will be returned.
+  // The maximum value is 10,000; values above 10,000 will be coerced to 10,000.
+  int32 page_size = 4;
+
+  // A page token, received from a previous `QueryTestVariants` call.
+  // Provide this to retrieve the subsequent page.
+  //
+  // When paginating, all other parameters provided to `QueryTestVariants` MUST
+  // match the call that provided the page token.
+  string page_token = 5;
+
+  // Fields to include in the response.
+  // If not set, the default mask is used where all fields are included.
+  //
+  // The following fields in results.*.result will NEVER be included even when
+  // specified:
+  // * test_id
+  // * variant_hash
+  // * variant
+  // * test_metadata
+  // Those values can be found in the parent test variant objects.
+  //
+  // The following fields will ALWAYS be included even when NOT specified:
+  // * test_id
+  // * variant_hash
+  // * status
+  google.protobuf.FieldMask read_mask = 7;
+}
+
+// A response message for QueryTestVariants RPC.
+message QueryTestVariantsResponse {
+  // Matched test variants.
+  // Ordered by TestVariantStatus, test_id, then variant_hash
+  repeated TestVariant test_variants = 1;
+
+  // A token, which can be sent as `page_token` to retrieve the next page.
+  // If this field is omitted, there were no subsequent pages at the time of
+  // request.
+  string next_page_token = 2;
+
+  // The code sources tested by the returned test variants. The sources are keyed
+  // by an ID which allows them to be cross-referenced from TestVariant.sources_id.
+  //
+  // The sources are returned via this map instead of directly on the TestVariant
+  // to avoid excessive response size. Each source message could be up to a few
+  // kilobytes and there are usually no more than a handful of different sources
+  // tested in an invocation, so deduplicating them here reduces response size.
+  map<string, Sources> sources = 3;
+}
+
+// Request message for QueryRunTestVerdicts RPC.
+message QueryRunTestVerdictsRequest {
+  // Retrieve test verdicts for the test run represented by this invocation.
+  // Format: invocations/{INVOCATION_ID}.
+  string invocation = 1;
+
+  // The maximum number of test results to be included in a test variant.
+  //
+  // If a test variant has more results than the limit, the remaining results
+  // will not be returned.
+  // If unspecified, at most 10 results will be included in a test variant.
+  // The maximum value is 100; values above 100 will be coerced to 100.
+  int32 result_limit = 2;
+
+  // The maximum number of test variants to return.
+  //
+  // The service may return fewer than this value.
+  // If unspecified, at most 1000 test variants will be returned.
+  // The maximum value is 10,000; values above 10,000 will be coerced to 10,000.
+  // Page sizes smaller than the maximum may be returned at the server's
+  // discretion, for example, due to keep the response size tractable for
+  // the server.
+  int32 page_size = 3;
+
+  // A page token, received from a previous `QueryRunTestVerdicts` call.
+  // Provide this to retrieve the subsequent page.
+  //
+  // When paginating, all other parameters provided to
+  // `QueryRunTestVerdicts` MUST match the call that provided the page
+  // token.
+  string page_token = 4;
+}
+
+// A response message for QueryRunTestVerdicts RPC.
+message QueryRunTestVerdictsResponse {
+  // Test verdicts for the run.
+  //
+  // Ordered by test_id, then variant_hash.
+  repeated RunTestVerdict run_test_verdicts = 1;
+
+  // A token, which can be sent as `page_token` to retrieve the next page.
+  // If this field is omitted, there were no subsequent pages at the time of
+  // request.
+  string next_page_token = 2;
+}
+
+// A request message for BatchGetTestVariants RPC.
+message BatchGetTestVariantsRequest {
+  message TestVariantIdentifier {
+    // The unique identifier of the test in a LUCI project. See the comment on
+    // TestResult.test_id for full documentation.
+    string test_id = 1 [ (google.api.field_behavior) = REQUIRED ];
+
+    // Hash of the variant. See the comment on TestResult.variant_hash for full
+    // documentation.
+    string variant_hash = 2 [ (google.api.field_behavior) = REQUIRED ];
+  }
+
+  // Name of the invocation that the test variants are in.
+  string invocation = 1;
+
+  // A list of test IDs and variant hashes, identifying the requested test
+  // variants. Size is limited to 500. Any request for more than 500 variants
+  // will return an error.
+  repeated TestVariantIdentifier test_variants = 2;
+
+  // The maximum number of test results to be included in a test variant.
+  //
+  // If a test variant has more results than the limit, the remaining results
+  // will not be returned.
+  // If unspecified, at most 10 results will be included in a test variant.
+  // The maximum value is 100; values above 100 will be coerced to 100.
+  int32 result_limit = 3;
+}
+
+// A response message for BatchGetTestVariants RPC.
+message BatchGetTestVariantsResponse {
+  // Test variants matching the requests. Any variants that weren't found are
+  // omitted from the response. Clients shouldn't rely on the ordering of this
+  // field, as no particular order is guaranteed.
+  repeated TestVariant test_variants = 1;
+
+  // The code sources tested by the returned test variants. The sources are keyed
+  // by an ID which allows them to be cross-referenced from TestVariant.sources_id.
+  //
+  // The sources are returned via this map instead of directly on the TestVariant
+  // to avoid excessive response size. Each source message could be up to a few
+  // kilobytes and there are usually no more than a handful of different sources
+  // tested in an invocation, so deduplicating them here reduces response size.
+  map<string, Sources> sources = 2;
+}
+
+// A request message for QueryTestMetadata RPC.
+message QueryTestMetadataRequest {
+  // The LUCI Project to query.
+  string project = 1 [(google.api.field_behavior) = REQUIRED];
+
+  // Filters to apply to the returned test metadata.
+  TestMetadataPredicate predicate = 2;
+
+  // The maximum number of test metadata entries to return.
+  //
+  // The service may return fewer than this value.
+  // If unspecified, at most 1000 test metadata entries will be returned.
+  // The maximum value is 100K; values above 100K will be coerced to 100K.
+  int32 page_size = 3;
+
+  // A page token, received from a previous `QueryTestMetadata` call.
+  // Provide this to retrieve the subsequent page.
+  //
+  // When paginating, all other parameters provided to `QueryTestMetadata` MUST
+  // match the call that provided the page token.
+  string page_token = 4;
+}
+
+// A response message for QueryTestMetadata RPC.
+message QueryTestMetadataResponse {
+  // The matched testMetadata.
+  repeated TestMetadataDetail testMetadata = 1;
+
+  // A token, which can be sent as `page_token` to retrieve the next page.
+  // If this field is omitted, there were no subsequent pages at the time of
+  // request.
+  string next_page_token = 2;
+}
+
+// A request message for QueryNewTestVariants RPC.
+// To use this RPC, callers need:
+// - resultdb.baselines.get in the realm the <baseline_project>:@project, where
+//   baseline_project is the LUCI project that contains the baseline.
+// - resultdb.testResults.list in the realm of the invocation which is being
+//   queried.
+message QueryNewTestVariantsRequest {
+  // Name of the invocation, e.g. "invocations/{id}".
+  string invocation = 1 [ (google.api.field_behavior) = REQUIRED ];
+
+  // The baseline to compare test variants against, to determine if they are new.
+  // e.g. projects/{project}/baselines/{baseline_id}.
+  // For example, in the project "chromium", the baseline_id may be
+  // "try:linux-rel".
+  string baseline = 2 [ (google.api.field_behavior) = REQUIRED ];
+}
+
+// A response message for QueryNewTestVariants RPC.
+message QueryNewTestVariantsResponse {
+
+  // Represents a new test, which contains minimal information to uniquely identify a TestVariant.
+  message NewTestVariant {
+    // A unique identifier of the test in a LUCI project.
+    // Regex: ^[[::print::]]{1,256}$
+    //
+    // Refer to TestResult.test_id for details.
+    string test_id = 1;
+
+    // Hash of the variant.
+    // hex(sha256(sorted(''.join('%s:%s\n' for k, v in variant.items())))).
+    string variant_hash = 2;
+  }
+
+  // Indicates whether the baseline has been populated with at least 72 hours
+  // of data and the results can be relied upon.
+  bool is_baseline_ready = 1;
+
+
+  // Test variants that are new, meaning that they have not been part of
+  // a submitted run prior.
+  repeated NewTestVariant new_test_variants = 2;
+}
+
+message GetInstructionRequest {
+  // Name of the instruction. The format is:
+  // invocations/{invocation_id}/instructions/{instruction_id}
+  string name = 1;
+}
+
+// Request for QueryInstructionDependencies RPC.
+message QueryInstructionRequest {
+  // Name of the instruction to query for. The format is:
+  // invocations/{invocation_id}/instructions/{instruction_id}
+  string name = 1;
+
+  // The maximum depth to traverse the dependency chain. Default is 5.
+  // The maximum value we support is 10, value bigger than 10 will be adjusted to 10.
+  // Non-positive value will be adjusted to the default.
+  int32 dependency_max_depth = 2;
+}
+
+// Response for QueryInstructionDependencies RPC.
+message QueryInstructionResponse {
+  // The instruction.
+  Instruction instruction = 1;
+
+  // Dependency chain, one for each target.
+  repeated InstructionDependencyChain dependency_chains = 2;
+}
+
+// The dependency chain for one target.
+message InstructionDependencyChain {
+  // Target of the dependency chain.
+  InstructionTarget target = 1;
+
+  // Captures information about a dependency.
+  message Node {
+    // The instruction name that the dependency belongs to.
+    // The format is invocations/{invocation_id}/instructions/{instruction_id}.
+    // We need this for the UI to resolve the placeholders of the content.
+    string instruction_name = 1;
+
+    // Content of the dependency.
+    // Placeholders (if existed) will be returned as-is.
+    // The caller of this RPC is responsible for resolving the placeholders.
+    string content = 2;
+
+    // In case the traversal encounters an error, the error will be returned in this field.
+    // If an error is returned, it will only be returned in the last dependency node,
+    // after that, the chain will stop.
+    string error = 3;
+
+    // The descriptive name of the instruction that the dependency belongs to.
+    // In the following cases, the descriptive name will not be set:
+    // - If the user does not have the permission to access the instruction for the node, or
+    // - If the instruction cannot be found.
+    string descriptive_name = 4;
+  }
+
+  // List of dependencies.
+  // The list will be sorted by the position in the dependency chain.
+  // The direct dependency will be at position 0.
+  // If the dependency traversing encounters an error, the last node will contain the error.
+  repeated Node nodes = 2;
+}
+
+message QueryTestVariantArtifactGroupsRequest {
+  // The LUCI project (required).
+  string project = 1;
+
+  // The search string to search in text artifact content (required).
+  // Support regex or exact match.
+  ArtifactContentMatcher search_string = 2;
+
+  // The test id matcher to restrict the scope of the search (optional).
+  IDMatcher test_id_matcher = 3;
+
+  // The artifact id matcher to restrict the scope of the search (optional).
+  IDMatcher artifact_id_matcher = 4;
+
+  // The lower bound of the time range to search in UTC time (exclusive) (required).
+  // start_time must not be before 20 July 2024 UTC.
+  // start_time must be less than the end time.
+  // The duration between start_time and end_time must not be greater than 7 days.
+  google.protobuf.Timestamp start_time = 5;
+
+  // The upper bound of the time range to search in UTC time (inclusive) (required).
+  google.protobuf.Timestamp end_time = 6;
+
+  // The maximum number of match groups to return. The service may return fewer than
+  // this value.
+  // If unspecified, at most 100 items will be returned.
+  // The maximum value is 100; values above 100 will be coerced to 100.
+  int32 page_size = 7;
+
+  // A page token, received from a previous `QueryTestVariantArtifactGroups` call.
+  // Provide this to retrieve the subsequent page.
+  //
+  // When paginating, all other parameters provided to `QueryTestVariantArtifactGroups` must
+  // match the call that provided the page token.
+  string page_token = 8;
+}
+
+message QueryTestVariantArtifactGroupsResponse {
+  // Represents one group of matched artifacts.
+  // test_id, variant_hash and artifact_id form the group key.
+  message MatchGroup {
+    // The LUCI test id.
+    string test_id = 1;
+
+    // The hash of the variant.
+    string variant_hash = 2;
+
+    // The definition of the variant.
+    // Description of one specific way of running the test,
+    // e.g. a specific bucket, builder and a test suite.
+    Variant variant = 3;
+
+    // ID of the artifact.
+    string artifact_id = 4;
+
+    // Artifacts that matches the search for this (test id, variant_hash, artifact id) combination.
+    // Return at most 3 items, ordered by partition time DESC, artifact name ASC.
+    repeated ArtifactMatchingContent artifacts = 5;
+
+    // The total number of matching artifacts for this (test id, variant_hash, artifact id) combination.
+    int32 matching_count = 6;
+  }
+
+  // Test variant artifacts are grouped by test_id, variant_hash and artifact_id.
+  // Groups are ordered by partition_time of the most recent artifact DESC in the group, test id, variant hash, artifact id.
+  repeated MatchGroup groups  = 1;
+
+  // A token, which can be sent as `page_token` to retrieve the next page.
+  // If this field is omitted, there are no subsequent pages.
+  string next_page_token = 2;
+}
+
+message QueryTestVariantArtifactsRequest {
+  // The LUCI project (required).
+  string project =1;
+
+  // The search string to search in text artifact content (required).
+  // Support regex or exact match.
+  ArtifactContentMatcher search_string = 2;
+
+  // The test id. (required).
+  string test_id = 3;
+
+  // The variant hash (required).
+  string variant_hash = 4;
+
+  // The artifact id (required).
+  string artifact_id = 5;
+
+  // The lower bound of the time range to search in UTC time (exclusive) (required).
+  // start_time must not be before 20 July 2024 UTC.
+  // start_time must be less than the end time.
+  // The duration between start_time and end_time must not be greater than 7 days.
+  google.protobuf.Timestamp start_time = 6;
+
+  // The upper bound of the time range to search in UTC time (inclusive) (required).
+  google.protobuf.Timestamp end_time = 7;
+
+  // The maximum number of items to return. The service may return fewer than
+  // this value.
+  // If unspecified, at most 100 items will be returned.
+  // The maximum value is 100; values above 100 will be coerced to 100.
+  int32 page_size = 8;
+
+  // A page token, received from a previous `QueryTestVariantArtifacts` call.
+  // Provide this to retrieve the subsequent page.
+  //
+  // When paginating, all other parameters provided to `QueryTestVariantArtifacts` must
+  // match the call that provided the page token.
+  string page_token = 9;
+}
+
+message QueryTestVariantArtifactsResponse {
+  // Artifacts that matches the search.
+  // Ordered by partition_time DESC, artifact name.
+  repeated ArtifactMatchingContent artifacts = 1;
+
+  // A token, which can be sent as `page_token` to retrieve the next page.
+  // If this field is omitted, there are no subsequent pages.
+  string next_page_token = 2;
+}
+
+message QueryInvocationVariantArtifactGroupsRequest {
+  // The LUCI project (required).
+  string project = 1;
+
+  // The search string to search in text artifact content (required).
+  // Support regex or exact match.
+  ArtifactContentMatcher search_string = 2;
+
+  // The artifact id matcher to restrict the scope of the search (optional).
+  IDMatcher artifact_id_matcher = 3;
+
+  // The lower bound of the time range to search in UTC time (exclusive) (required).
+  // start_time must not be before 20 July 2024 UTC.
+  // start_time must be less than the end time.
+  // The duration between start_time and end_time must not be greater than 7 days.
+  google.protobuf.Timestamp start_time = 4;
+
+  // The upper bound of the time range to search in UTC time (inclusive) (required).
+  google.protobuf.Timestamp end_time = 5;
+
+  // The maximum number of match groups to return. The service may return fewer than
+  // this value.
+  // If unspecified, at most 100 items will be returned.
+  // The maximum value is 100; values above 100 will be coerced to 100.
+  int32 page_size = 6;
+
+  // A page token, received from a previous `QueryInvocationVariantArtifactGroups` call.
+  // Provide this to retrieve the subsequent page.
+  //
+  // When paginating, all other parameters provided to `QueryInvocationVariantArtifactGroups` must
+  // match the call that provided the page token.
+  string page_token = 7;
+}
+
+message QueryInvocationVariantArtifactGroupsResponse {
+  // Represents one group of matched artifacts.
+  // variant_union_hash and artifact_id form the group key.
+  message MatchGroup {
+    // Hash of the union of all variants of test results directly included by the invocation.
+    string variant_union_hash = 1;
+
+    // Union of all variants of test results directly included by the invocation.
+    // Roughly defines a specific way to run an invocation.
+    Variant variant_union = 2;
+
+    // ID of the artifact.
+    string artifact_id = 3;
+
+    // Artifacts that matches the search for this (variant_union_hash, artifact id) combination.
+    // Return at most 3 items, ordered by partition time DESC, artifact name ASC.
+    repeated ArtifactMatchingContent artifacts = 4;
+
+    // The total number of matching artifacts for this (variant_union_hash, artifact id) combination.
+    int32 matching_count = 5;
+  }
+
+  // Invocation variant artifacts  are grouped by variant_union_hash and artifact_id.
+  // Ordered by partition_time of the most recent artifact DESC in the group, variant_union_hash, artifact id.
+  repeated MatchGroup groups  = 1;
+
+  // A token, which can be sent as `page_token` to retrieve the next page.
+  // If this field is omitted, there are no subsequent pages.
+  string next_page_token = 2;
+}
+
+message QueryInvocationVariantArtifactsRequest {
+  // The LUCI project (required).
+  string project = 1;
+
+  // The search string to search in text artifact content (required).
+  // Support regex or exact match.
+  ArtifactContentMatcher search_string = 2;
+
+  // Hash of the union of all variants of test results directly included by the invocation (required).
+  string variant_union_hash = 3;
+
+  // The artifact id (required).
+  string artifact_id = 4;
+
+  // The lower bound of the time range to search in UTC time (exclusive) (required).
+  // start_time must not be before 20 July 2024 UTC.
+  // start_time must be less than the end time.
+  // The duration between start_time and end_time must not be greater than 7 days.
+  google.protobuf.Timestamp start_time = 5;
+
+  // The upper bound of the time range to search in UTC time (inclusive) (required).
+  google.protobuf.Timestamp end_time = 6;
+
+  // The maximum number of items to return. The service may return fewer than
+  // this value.
+  // If unspecified, at most 100 items will be returned.
+  // The maximum value is 100; values above 100 will be coerced to 100.
+  int32 page_size = 7;
+
+  // A page token, received from a previous `QueryInvocationVariantArtifacts` call.
+  // Provide this to retrieve the subsequent page.
+  //
+  // When paginating, all other parameters provided to `QueryInvocationVariantArtifacts` must
+  // match the call that provided the page token.
+  string page_token = 8;
+}
+
+message QueryInvocationVariantArtifactsResponse {
+  // Artifacts that matches the search.
+  // Ordered by partition_time DESC, artifact name.
+  repeated ArtifactMatchingContent artifacts = 1;
+
+  // A token, which can be sent as `page_token` to retrieve the next page.
+  // If this field is omitted, there are no subsequent pages.
+  string next_page_token = 2;
+}
+
+// Represent a artifact that contains a match.
+message ArtifactMatchingContent {
+  // Name of the artifact.
+  // - For invocation-level artifacts:
+  //   "invocations/{INVOCATION_ID}/artifacts/{ARTIFACT_ID}".
+  // - For test-result-level artifacts:
+  //   "invocations/{INVOCATION_ID}/tests/{URL_ESCAPED_TEST_ID}/results/{RESULT_ID}/artifacts/{ARTIFACT_ID}".
+  string name = 1;
+
+  // Partition time of the artifact.
+  // This is the creation time of the direct parent invocation.
+  google.protobuf.Timestamp partition_time = 2;
+
+  // The test result status, only populated if it is a result level artifact .
+  TestStatus test_status = 3;
+
+  // Part of the artifact content that contains the first occurrence of the match.
+  // The snippet is at most 10 KiB.
+  // Prioritize fiting first match into the 10KiB first, divided the remaining bytes equally
+  // to fit content immediately before and after the first match, including at most one more line above and below.
+  // If the first match is more than 10KiB, it will be truncated.
+  // Ellipsis ("...") are added, if the snippet is truncated.
+  string snippet = 4;
+
+  // Represent the byte location of a match in snippet.
+  message Match {
+    // Start byte index of the match, inclusive.
+    int32 start_index = 1;
+    // End byte index of the match, exclusive.
+    int32 end_index = 2;
+  }
+
+  // All non-overlapping matches exists in the snippet from front to end in order (i.e. matches[i].end_index <= matches[i+1].start_index).
+  repeated Match matches = 5;
+}
+
+// Used to match a artifact content.
+message ArtifactContentMatcher {
+  oneof matcher {
+    // The string is a regex expression. Use regex match to find matching artifact content.
+    string regex_contain = 1;
+
+    // Use case insensitive equality match with this string to find matching artifact content.
+    string contain = 2;
+  }
+}
+
+// Used to match IDs (eg. test id, artifact id).
+message IDMatcher {
+  oneof matcher {
+    // The id should has a matching prefix.
+    string has_prefix = 1;
+
+    // The id should exactly equal to this string.
+    string exact_equal = 2;
+  }
+}
\ No newline at end of file
diff --git a/proto/resultdb/schema.proto b/proto/resultdb/schema.proto
new file mode 100644
index 000000000..ab090f8bb
--- /dev/null
+++ b/proto/resultdb/schema.proto
@@ -0,0 +1,137 @@
+/*
+* Copyright (C) 2025 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+syntax = "proto3";
+
+package luci.resultdb.v1;
+
+option go_package = "go.chromium.org/luci/resultdb/proto/v1;resultpb";
+option java_package = "com.android.resultdb.proto";
+option java_multiple_files = true;
+
+// Service to read test schema.
+//
+// Use of LUCI is subject to the Google [Terms of Service](https://policies.google.com/terms)
+// and [Privacy Policy](https://policies.google.com/privacy).
+service Schemas {
+  // Reads information about the test result schema used on this ResultDB deployment.
+  rpc Get(GetSchemaRequest) returns (Schema) {};
+
+  // Reads information about a particular test scheme.
+  rpc GetScheme(GetSchemeRequest) returns (Scheme) {};
+}
+
+message GetSchemaRequest {
+  // The resource name of the schema to retrieve.
+  // Note: This is currently a https://google.aip.dev/156 singleton resource, so
+  // the only valid resource name is "schema".
+  string name = 1;
+}
+
+// Schema contains information about the schema used for test results.
+message Schema {
+  // The resource name of the schema.
+  // Currently, this is always "schema".
+  string name = 1;
+
+  // The schemes available for use in test identifiers, by scheme identifier.
+  map<string, Scheme> schemes = 2;
+}
+
+message GetSchemeRequest {
+  // The resource name of the scheme to retrieve.
+  // Format: schema/schemes/{scheme_id}.
+  string name = 1;
+}
+
+// A scheme represents a kind of test type. For example, a JUnit tests
+// or Google Tests. Schemes control how tests with that type are
+// presented on the UI.
+//
+// Tests are associated with a type at the module level, via the module
+// type field.
+//
+// Schemes are ResultDB deployment-level configuration.
+//
+// Next id: 6.
+message Scheme {
+  // The resource name of the scheme.
+  // Format: schema/schemes/{id}.
+  string name = 1;
+
+  // The identifier for the scheme, e.g. 'junit'.
+  //
+  // Limited to ^[a-z][a-z0-9]{0,19}$.
+  string id = 2;
+
+  // A human readable name for the scheme, describing the test type.
+  // For example, "JUnit" or "Web Tests".
+  //
+  // Please pay attention to capitalisation (should be similar to examples above)
+  // and avoid any punctuation.
+  string human_readable_name = 3;
+
+  // Configuration for a level of test hierarchy.
+  message Level {
+    // The human readable name for the hierarchy level, as it should appear on the UI.
+    // For example, "Package", "Class" or "Method".
+    //
+    // Please pay attention to capitalisation (should be similar to examples above)
+    // and avoid any punctuation.
+    //
+    // Required.
+    string human_readable_name = 1;
+
+    // The regexp that defines valid values for this field. The value here will be
+    // wrapped in ^...$. Validation will apply to all newly uploaded test results.
+    // Use RE2 syntax.
+    //
+    // If blank, all values are taken to be valid.
+    //
+    // Please take care changing this value, as uploads may start to fail.
+    string validation_regexp = 2;
+  }
+
+  // The coarse level in the test hierarchy. Optional.
+  //
+  // If it is set, this level is enabled and a value for this hierarchy level must be set
+  // for all test results using this scheme.
+  // If it is not set, a value for this hierarchy level must NOT be set for test results
+  // using this scheme.
+  //
+  // Enabling or disabling a hierarchy level after it has been created is not permitted unless
+  // no data has been uploaded for the scheme.
+  //
+  // If only one of coarse and fine hierarchy should be enabled, enable the fine hierarchy
+  // only.
+  Level coarse = 4;
+
+  // The fine level in the test hierarchy. Optional.
+  //
+  // If it is set, this level is enabled and a value for this hierarchy level must be set
+  // for all test results using this scheme.
+  // If it is not set, a value for this hierarchy level must NOT be set for test results
+  // using this scheme.
+  //
+  // Enabling or disabling a hierarchy level on a scheme after it is already being used
+  // will result in existing uploads breaking and break presentation of already uploaded
+  // data. Please use extreme caution if doing this; generally, it is better to define
+  // a new scheme instead.
+  Level fine = 5;
+
+  // The case level in the test hierarchy. This is the finest level. Required.
+  Level case = 6;
+}
diff --git a/proto/resultdb/test_metadata.proto b/proto/resultdb/test_metadata.proto
index f1015e258..8bd113619 100644
--- a/proto/resultdb/test_metadata.proto
+++ b/proto/resultdb/test_metadata.proto
@@ -1,18 +1,18 @@
 /*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
+* Copyright (C) 2020 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
 
 syntax = "proto3";
 
@@ -59,6 +59,9 @@ message TestMetadataDetail {
 // Information about a test.
 message TestMetadata {
   // The original test name.
+  // Deprecated: This was an attempt to solve the problem of test IDs that were
+  // too long to show on the UI. Structured test IDs are now the recommended
+  // solution instead.
   string name = 1;
 
   // Where the test is defined, e.g. the file name.
@@ -84,6 +87,9 @@ message TestMetadata {
   //
   // If this field is specified, properties_schema must also be specified.
   google.protobuf.Struct properties = 5;
+
+  // The test ID this test previously had.
+  string previous_test_id = 6;
 }
 
 // Location of the test definition.
diff --git a/proto/resultdb/test_result.proto b/proto/resultdb/test_result.proto
index a81581628..77f9efb46 100644
--- a/proto/resultdb/test_result.proto
+++ b/proto/resultdb/test_result.proto
@@ -1,18 +1,18 @@
 /*
- * Copyright (C) 2024 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
+* Copyright (C) 2019 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
 
 syntax = "proto3";
 
@@ -56,25 +56,28 @@ message TestResult {
     (google.api.field_behavior) = IMMUTABLE
   ];
 
-  // Test id, a unique identifier of the test in a LUCI project.
+  // The structured test identifier.
+  //
+  // Uniquely identifies the test that was run, including the specific way of running that
+  // test, e.g. build configuration, CPU architecture, OS.
+  //
+  // When uploading results, this should be specified in preference
+  // to test_id and variant. (Uploading test_id and variant is supported only for
+  // legacy uploaders).
+  TestIdentifier test_id_structured = 19 [(google.api.field_behavior) = IMMUTABLE];
+
+  // A unique identifier of the test in a LUCI project, excluding variant.
   // Regex: ^[[::print::]]{1,512}$
   //
-  // If two tests have a common test id prefix that ends with a
-  // non-alphanumeric character, they considered a part of a group. Examples:
-  // - "a/b/c"
-  // - "a/b/d"
-  // - "a/b/e:x"
-  // - "a/b/e:y"
-  // - "a/f"
-  // This defines the following groups:
-  // - All items belong to one group because of the common prefix "a/"
-  // - Within that group, the first 4 form a sub-group because of the common
-  //   prefix "a/b/"
-  // - Within that group, "a/b/e:x" and "a/b/e:y" form a sub-group because of
-  //   the common prefix "a/b/e:".
-  // This can be used in UI.
-  // LUCI does not interpret test ids in any other way.
-  string test_id = 2 [(google.api.field_behavior) = IMMUTABLE];
+  // This is the flat-form encoding of the structured test variant ID above,
+  // excluding information about the specific way of running test (e.g. build configuration,
+  // CPU architecture). Such information is captured separately in the `variant` field below.
+  //
+  // See TestIdentifier for details how a structured test identifier is converted
+  // to flat test ID.
+  //
+  // Output only. (Except for legacy uploaders.)
+  string test_id = 2 [(google.api.field_behavior) = OUTPUT_ONLY, (google.api.field_behavior) = IMMUTABLE];
 
   // Identifies a test result in a given invocation and test id.
   // Regex: ^[a-z0-9\-_.]{1,32}$
@@ -84,8 +87,10 @@ message TestResult {
   ];
 
   // Description of one specific way of running the test,
-  // e.g. a specific bucket, builder and a test suite.
-  Variant variant = 4 [(google.api.field_behavior) = IMMUTABLE];
+  // e.g. build configuration, CPU architecture, OS.
+  //
+  // Output only. (Except for legacy uploaders.)
+  Variant variant = 4 [(google.api.field_behavior) = OUTPUT_ONLY, (google.api.field_behavior) = IMMUTABLE];
 
   // Whether the result of test case execution is expected.
   // In a typical Chromium CL, 99%+ of test results are expected.
@@ -226,6 +231,7 @@ enum SkipReason {
 // for an unexpected result of a test variant.
 // For example, the test variant fails both with and without CL, so it is not
 // CL's fault.
+// Next ID: 10.
 message TestExoneration {
   // Can be used to refer to this test exoneration, e.g. in
   // ResultDB.GetTestExoneration RPC.
@@ -240,13 +246,34 @@ message TestExoneration {
     (google.api.field_behavior) = IMMUTABLE
   ];
 
-  // Test identifier, see TestResult.test_id.
-  string test_id = 2;
+  // The structured test identifier.
+  //
+  // Uniquely identifies the test that was run, including the specific way of running that
+  // test, e.g. build configuration, CPU architecture, OS.
+  //
+  // When uploading results, this should be specified in preference
+  // to test_id and variant. (Uploading test_id and variant is supported only for
+  // legacy uploaders).
+  TestIdentifier test_id_structured = 9 [(google.api.field_behavior) = IMMUTABLE];
 
-  // Description of the variant of the test, see Variant type.
-  // Unlike TestResult.extra_variant_pairs, this one must be a full definition
-  // of the variant, i.e. it is not combined with Invocation.base_test_variant.
-  Variant variant = 3;
+  // A unique identifier of the test in a LUCI project, excluding variant.
+  // Regex: ^[[::print::]]{1,512}$
+  //
+  // This is the flat-form encoding of the structured test variant ID above,
+  // excluding information about the specific way of running test (e.g. build configuration,
+  // CPU architecture). Such information is captured separately in the `variant` field below.
+  //
+  // See TestIdentifier for details how a structured test identifier is converted
+  // to flat test ID.
+  //
+  // Output only. (Except for legacy uploaders.)
+  string test_id = 2 [(google.api.field_behavior) = OUTPUT_ONLY, (google.api.field_behavior) = IMMUTABLE];
+
+  // Description of one specific way of running the test,
+  // e.g. build configuration, CPU architecture, OS.
+  //
+  // Output only. (Except for legacy uploaders.)
+  Variant variant = 3 [(google.api.field_behavior) = OUTPUT_ONLY, (google.api.field_behavior) = IMMUTABLE];
 
   // Identifies an exoneration in a given invocation and test id.
   // It is server-generated.
diff --git a/proto/resultdb/test_variant.proto b/proto/resultdb/test_variant.proto
new file mode 100644
index 000000000..c6482016e
--- /dev/null
+++ b/proto/resultdb/test_variant.proto
@@ -0,0 +1,157 @@
+/*
+* Copyright (C) 2021 The Android Open Source Project
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*      http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+syntax = "proto3";
+
+package luci.resultdb.v1;
+
+import "google/api/field_behavior.proto";
+import public "tools/tradefederation/core/proto/resultdb/common.proto";
+import public "tools/tradefederation/core/proto/resultdb/test_metadata.proto";
+import public "tools/tradefederation/core/proto/resultdb/test_result.proto";
+
+option go_package = "go.chromium.org/luci/resultdb/proto/v1;resultpb";
+option java_package = "com.android.resultdb.proto";
+option java_multiple_files = true;
+
+// Represents a matching test variant with its outcomes.
+// Also known as a test verdict.
+message TestVariant {
+  // A unique identifier of the test in a LUCI project.
+  // Regex: ^[[::print::]]{1,512}$
+  //
+  // Refer to TestResult.test_id for details.
+  string test_id = 1;
+
+  // Description of one specific way of running the test,
+  // e.g. a specific bucket, builder and a test suite.
+  Variant variant = 2;
+
+  // Hash of the variant.
+  // hex(sha256(sorted(''.join('%s:%s\n' for k, v in variant.items())))).
+  string variant_hash = 3;
+
+  // Status of the test variant.
+  TestVariantStatus status = 4;
+
+  // Outcomes of the test variant.
+  repeated TestResultBundle results = 5;
+
+  // Test exonerations if any test variant is exonerated.
+  repeated TestExoneration exonerations = 6;
+
+  // Information about the test at the time of its execution.
+  //
+  // All test results of the same test variant should report the same test
+  // metadata. This RPC relies on this rule and returns test metadata from
+  // *arbitrary* result of the test variant.
+  TestMetadata test_metadata = 7;
+
+  // Whether the
+  //    - test metadata; or
+  //    - the variant definition; or
+  //    - both the test metadata and variant definition
+  // have been masked from the test variant.
+  //
+  // Output only.
+  bool is_masked = 8 [(google.api.field_behavior) = OUTPUT_ONLY];
+
+  // The identity of the code sources tested. This ID can be used
+  // to lookup of the actual sources in QueryTestVariantsResponse.sources.
+  //
+  // All test results of the same test variant should be attached to the same
+  // sources (via their respective invocation(s)). This RPC relies upon this
+  // and returns sources from an *arbitrary* result of the test variant.
+  //
+  // If the code sources tested are not available, this field is blank.
+  string sources_id = 9;
+
+  // Contain the data for instruction for the test verdict.
+  // To find out the instruction for a test verdict, we select an *arbitrary*
+  // test result in the test verdict and get its instruction.
+  // Note: If in this test verdict, if there are different instructions for
+  // test result, the result may be undeterministic.
+  VerdictInstruction instruction = 10;
+}
+
+message VerdictInstruction {
+  // Name of the instruction.
+  // Format: invocations/<invocation id>/instructions/<instruction id>
+  string instruction = 1;
+}
+
+// Outcomes of an execution of the test variant.
+message TestResultBundle {
+  // Result of the test variant execution.
+  TestResult result = 1;
+}
+
+// Status of a test variant.
+enum TestVariantStatus {
+  // a test variant must not have this status.
+  // This is only used when filtering variants.
+  TEST_VARIANT_STATUS_UNSPECIFIED = 0;
+  // The test variant has no exonerations, and all results are unexpected.
+  UNEXPECTED = 10;
+  // The test variant has no exonerations, and all results are unexpectedly skipped.
+  UNEXPECTEDLY_SKIPPED = 20;
+  // The test variant has no exonerations, and has both expected and unexpected
+  // results.
+  FLAKY = 30;
+  // The test variant has one or more test exonerations.
+  EXONERATED = 40;
+  // A special value that matches any test variant which doesn't have the status
+  // EXPECTED. This includes all the above statuses. It will never be present on
+  // returned results, it's only for use in predicates.
+  UNEXPECTED_MASK = 45;
+  // The test variant has no exonerations, and all results are expected.
+  EXPECTED = 50;
+}
+
+// Represents a function TestVariant -> bool.
+// Empty message matches all test variants.
+message TestVariantPredicate {
+  // A test variant must have this status.
+  TestVariantStatus status = 1;
+}
+
+// The outcome of a test variant in a test run (a single invocation,
+// excluding any included invocations).
+message RunTestVerdict {
+  // A unique identifier of the test in a LUCI project.
+  // Regex: ^[[::print::]]{1,256}$
+  //
+  // Refer to TestResult.test_id for details.
+  string test_id = 1;
+
+  // Description of one specific way of running the test,
+  // e.g. a specific bucket, builder and a test suite.
+  Variant variant = 2;
+
+  // Hash of the variant.
+  // hex(sha256(sorted(''.join('%s:%s\n' for k, v in variant.items())))).
+  string variant_hash = 3;
+
+  // Outcomes of the test variant.
+  repeated TestResultBundle results = 4;
+
+  // Information about the test at the time of its execution.
+  //
+  // All test results of the same test variant should report the same test
+  // metadata. This RPC relies on this rule and returns test metadata from
+  // *arbitrary* result of the test variant.
+  TestMetadata test_metadata = 5;
+}
diff --git a/remote/.classpath b/remote/.classpath
index b61747f1f..143133e92 100644
--- a/remote/.classpath
+++ b/remote/.classpath
@@ -1,7 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
 	<classpathentry kind="src" path="src"/>
-	<classpathentry combineaccessrules="false" kind="src" path="/ddmlib"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER">
 		<attributes>
 			<attribute name="module" value="true"/>
@@ -11,6 +10,6 @@
 	<classpathentry kind="var" path="TRADEFED_ROOT/prebuilts/misc/common/sdklib/sdklib-prebuilt.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/prebuilts/misc/common/tools-common/tools-common-prebuilt.jar"/>
 	<classpathentry kind="var" path="TRADEFED_ROOT/out/soong/.intermediates/external/guava/guava/linux_glibc_common/javac-header/guava.jar"/>
-	<classpathentry kind="var" path="TRADEFED_ROOT/external/error_prone/error_prone/error_prone_annotations-2.36.0.jar"/>
+	<classpathentry kind="var" path="TRADEFED_ROOT/external/error_prone/error_prone/error_prone_annotations-2.37.0.jar"/>
 	<classpathentry kind="output" path="bin"/>
 </classpath>
diff --git a/remote/Android.bp b/remote/Android.bp
index 693de8819..eee5b1041 100644
--- a/remote/Android.bp
+++ b/remote/Android.bp
@@ -30,10 +30,7 @@ tradefed_java_library_host {
   static_libs: [
     "json-prebuilt",
     "jsr305",
-    "tools-common-prebuilt",
-    "sdklib-prebuilt",
     "guava",
-    "ddmlib-prebuilt",
     "devtools-annotations-prebuilt",
   ],
   // b/267831518: Pin tradefed and dependencies to Java 11.
diff --git a/res/config/template/preparers/futility-preparer.xml b/res/config/template/preparers/futility-preparer.xml
new file mode 100644
index 000000000..8b6639a6f
--- /dev/null
+++ b/res/config/template/preparers/futility-preparer.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2021 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<configuration description="Preparer for futility setup." >
+    <target_preparer class="com.android.tradefed.targetprep.FutilityCommandPreparer" />
+</configuration>
diff --git a/res/perfetto/record_android_trace b/res/perfetto/record_android_trace
old mode 100644
new mode 100755
index 321e3f667..55d824ad3
--- a/res/perfetto/record_android_trace
+++ b/res/perfetto/record_android_trace
@@ -25,26 +25,26 @@ import http.server
 import os
 import re
 import shutil
+import signal
 import socketserver
 import subprocess
 import sys
 import time
 import webbrowser
 
-
 # ----- Amalgamator: begin of python/perfetto/prebuilts/manifests/tracebox.py
-# This file has been generated by: /usr/local/google/home/lalitm/perfetto/tools/roll-prebuilts v30.0
+# This file has been generated by: tools/roll-prebuilts v50.1
 TRACEBOX_MANIFEST = [{
     'arch':
         'mac-amd64',
     'file_name':
         'tracebox',
     'file_size':
-        1415504,
+        1679744,
     'url':
-        'https://commondatastorage.googleapis.com/perfetto-luci-artifacts/v30.0/mac-amd64/tracebox',
+        'https://commondatastorage.googleapis.com/perfetto-luci-artifacts/v50.1/mac-amd64/tracebox',
     'sha256':
-        'a3c7576144c77c20e278cd9cf530a33bd07bbbe5b4fab568da073287cf9f10ba',
+        '04a27c01acd91100339b4a2d34a8178a3154882fbddeb1fadb601e0297017408',
     'platform':
         'darwin',
     'machine': ['x86_64']
@@ -54,11 +54,11 @@ TRACEBOX_MANIFEST = [{
     'file_name':
         'tracebox',
     'file_size':
-        1309048,
+        1542024,
     'url':
-        'https://commondatastorage.googleapis.com/perfetto-luci-artifacts/v30.0/mac-arm64/tracebox',
+        'https://commondatastorage.googleapis.com/perfetto-luci-artifacts/v50.1/mac-arm64/tracebox',
     'sha256':
-        '28036a713bb5711783584207dc972eb864c665d22fae5d04c5269bc562401f2b',
+        '78c630ad773eb4095f329fe9198b27bad2b316750ba4e69d5bedabfc1df928bf',
     'platform':
         'darwin',
     'machine': ['arm64']
@@ -68,11 +68,11 @@ TRACEBOX_MANIFEST = [{
     'file_name':
         'tracebox',
     'file_size':
-        2309752,
+        2456240,
     'url':
-        'https://commondatastorage.googleapis.com/perfetto-luci-artifacts/v30.0/linux-amd64/tracebox',
+        'https://commondatastorage.googleapis.com/perfetto-luci-artifacts/v50.1/linux-amd64/tracebox',
     'sha256':
-        '1596849e3a44a3066cfea59e8795b9ad808e975c5a12a01c9839c447495042e7',
+        'd44b36286c5f61ba2f1034492cd6184942a598e81212dde84feda5d97e7f3a27',
     'platform':
         'linux',
     'machine': ['x86_64']
@@ -82,11 +82,11 @@ TRACEBOX_MANIFEST = [{
     'file_name':
         'tracebox',
     'file_size':
-        1361728,
+        1503072,
     'url':
-        'https://commondatastorage.googleapis.com/perfetto-luci-artifacts/v30.0/linux-arm/tracebox',
+        'https://commondatastorage.googleapis.com/perfetto-luci-artifacts/v50.1/linux-arm/tracebox',
     'sha256':
-        'cb2887dbf2f2c04980bc55f49b8abde3930e7e786061bb740f525f4a6983f819',
+        '8ce5ee92c156a7127d56664738b8b09ae6611004262435d4a1088a14b358d7c3',
     'platform':
         'linux',
     'machine': ['armv6l', 'armv7l', 'armv8l']
@@ -96,11 +96,11 @@ TRACEBOX_MANIFEST = [{
     'file_name':
         'tracebox',
     'file_size':
-        2255864,
+        2342864,
     'url':
-        'https://commondatastorage.googleapis.com/perfetto-luci-artifacts/v30.0/linux-arm64/tracebox',
+        'https://commondatastorage.googleapis.com/perfetto-luci-artifacts/v50.1/linux-arm64/tracebox',
     'sha256':
-        '42e4c81031bb489cc0ff8c38abb992adf21f1826beadaba036e2ad7dd44f8110',
+        '2aab0cbfc0676f26d1758c331b9ca92c5a8420ba13714e6c95ad061bcae12e06',
     'platform':
         'linux',
     'machine': ['aarch64']
@@ -110,44 +110,44 @@ TRACEBOX_MANIFEST = [{
     'file_name':
         'tracebox',
     'file_size':
-        1148884,
+        1373628,
     'url':
-        'https://commondatastorage.googleapis.com/perfetto-luci-artifacts/v30.0/android-arm/tracebox',
+        'https://commondatastorage.googleapis.com/perfetto-luci-artifacts/v50.1/android-arm/tracebox',
     'sha256':
-        '0fa492d3a91e8967b786654d1f990ce38921c993039f055f622336b8619463de'
+        '02f4b54fa8de1a84a4b65996c20dbea83ca0554b6dd852ca202224e5733744e4'
 }, {
     'arch':
         'android-arm64',
     'file_name':
         'tracebox',
     'file_size':
-        1751720,
+        2168744,
     'url':
-        'https://commondatastorage.googleapis.com/perfetto-luci-artifacts/v30.0/android-arm64/tracebox',
+        'https://commondatastorage.googleapis.com/perfetto-luci-artifacts/v50.1/android-arm64/tracebox',
     'sha256':
-        '7ec7e9c077c5c0f6b8513411990ab0dd74c6a745f345c9ab35f58829ad367518'
+        '267ab827d9120f9c8777dff4c3d6525ee753760e6ab4d650acf7dc3c40213096'
 }, {
     'arch':
         'android-x86',
     'file_name':
         'tracebox',
     'file_size':
-        1742764,
+        2375348,
     'url':
-        'https://commondatastorage.googleapis.com/perfetto-luci-artifacts/v30.0/android-x86/tracebox',
+        'https://commondatastorage.googleapis.com/perfetto-luci-artifacts/v50.1/android-x86/tracebox',
     'sha256':
-        'e513c920b17bbf1379f4ca9cf3445151e28da8668b05db9ae2d84ec436ab6b20'
+        'c8da94cf40c39ed87b54fe68258bc24733ac2e5bbc23199c4c31bbbacfc8abf8'
 }, {
     'arch':
         'android-x64',
     'file_name':
         'tracebox',
     'file_size':
-        2017960,
+        2207568,
     'url':
-        'https://commondatastorage.googleapis.com/perfetto-luci-artifacts/v30.0/android-x64/tracebox',
+        'https://commondatastorage.googleapis.com/perfetto-luci-artifacts/v50.1/android-x64/tracebox',
     'sha256':
-        'd6e4793ff198b9ae8c8f2bc0568f6f25273a1ebb5bd44c6ed319e8e8eecb9478'
+        '083ac2b95f19941c3859b32a480cfd6acfbb874489cce08e228ba05784714e58'
 }]
 
 # ----- Amalgamator: end of python/perfetto/prebuilts/manifests/tracebox.py
@@ -199,6 +199,7 @@ The intended usage is:
 import hashlib
 import os
 import platform
+import random
 import subprocess
 import sys
 
@@ -225,9 +226,10 @@ def download_or_get_cached(file_name, url, sha256):
       if digest == sha256:
         needs_download = False
 
-  if needs_download:
-    # Either the filed doesn't exist or the SHA256 doesn't match.
-    tmp_path = bin_path + '.tmp'
+  if needs_download:  # The file doesn't exist or the SHA256 doesn't match.
+    # Use a unique random file to guard against concurrent executions.
+    # See https://github.com/google/perfetto/issues/786 .
+    tmp_path = '%s.%d.tmp' % (bin_path, random.randint(0, 100000))
     print('Downloading ' + url)
     subprocess.check_call(['curl', '-f', '-L', '-#', '-o', tmp_path, url])
     with open(tmp_path, 'rb') as fd:
@@ -237,8 +239,9 @@ def download_or_get_cached(file_name, url, sha256):
                       (url, actual_sha256, sha256))
     os.chmod(tmp_path, 0o755)
     os.replace(tmp_path, bin_path)
-    with open(sha256_path, 'w') as f:
+    with open(tmp_path, 'w') as f:
       f.write(sha256)
+    os.replace(tmp_path, sha256_path)
   return bin_path
 
 
@@ -277,6 +280,7 @@ def run_perfetto_prebuilt(manifest):
     sys.exit(subprocess.check_call([bin_path, *sys.argv[1:]]))
   os.execv(bin_path, [bin_path] + sys.argv[1:])
 
+
 # ----- Amalgamator: end of python/perfetto/prebuilts/perfetto_prebuilts.py
 
 # ----- Amalgamator: begin of python/perfetto/common/repo_utils.py
@@ -316,6 +320,7 @@ def repo_root():
 def repo_dir(rel_path):
   return os.path.join(repo_root() or '', rel_path)
 
+
 # ----- Amalgamator: end of python/perfetto/common/repo_utils.py
 
 # This is not required. It's only used as a fallback if no adb is found on the
@@ -351,18 +356,23 @@ class ANSI:
 class HttpHandler(http.server.SimpleHTTPRequestHandler):
 
   def end_headers(self):
-    self.send_header('Access-Control-Allow-Origin', '*')
-    return super().end_headers()
+    self.send_header('Access-Control-Allow-Origin', self.server.allow_origin)
+    self.send_header('Cache-Control', 'no-cache')
+    super().end_headers()
 
   def do_GET(self):
-    self.server.last_request = self.path
-    return super().do_GET()
+    if self.path != '/' + self.server.expected_fname:
+      self.send_error(404, "File not found")
+      return
+
+    self.server.fname_get_completed = True
+    super().do_GET()
 
   def do_POST(self):
     self.send_error(404, "File not found")
 
 
-def main():
+def setup_arguments():
   atexit.register(kill_all_subprocs_on_exit)
   default_out_dir_str = '~/traces/'
   default_out_dir = os.path.expanduser(default_out_dir_str)
@@ -382,9 +392,15 @@ def main():
   help = 'Output file or directory (default: %s)' % default_out_dir_str
   parser.add_argument('-o', '--out', default=default_out_dir, help=help)
 
-  help = 'Don\'t open in the browser'
+  help = 'Don\'t open or serve the trace'
   parser.add_argument('-n', '--no-open', action='store_true', help=help)
 
+  help = 'Don\'t open in browser, but still serve trace (good for remote use)'
+  parser.add_argument('--no-open-browser', action='store_true', help=help)
+
+  help = 'The web address used to open trace files'
+  parser.add_argument('--origin', default='https://ui.perfetto.dev', help=help)
+
   help = 'Force the use of the sideloaded binaries rather than system daemons'
   parser.add_argument('--sideload', action='store_true', help=help)
 
@@ -392,6 +408,9 @@ def main():
           'Implies --sideload')
   parser.add_argument('--sideload-path', default=None, help=help)
 
+  help = 'Ignores any tracing guardrails which might be used'
+  parser.add_argument('--no-guardrails', action='store_true', help=help)
+
   help = 'Don\'t run `adb root` run as user (only when sideloading)'
   parser.add_argument('-u', '--user', action='store_true', help=help)
 
@@ -435,6 +454,17 @@ def main():
   help = 'Can be generated with https://ui.perfetto.dev/#!/record'
   grp.add_argument('-c', '--config', default=None, help=help)
 
+  help = 'Parse input from --config as binary proto (default: parse as text)'
+  grp.add_argument('--bin', action='store_true', help=help)
+
+  help = ('Pass the trace through the trace reporter API. Only works when '
+          'using the full trace config (-c) with the reporter package name '
+          "'android.perfetto.cts.reporter' and the reporter class name "
+          "'android.perfetto.cts.reporter.PerfettoReportService' with the "
+          'reporter installed on the device (see '
+          'tools/install_test_reporter_app.py).')
+  grp.add_argument('--reporter-api', action='store_true', help=help)
+
   args = parser.parse_args()
   args.sideload = args.sideload or args.sideload_path is not None
 
@@ -466,6 +496,27 @@ def main():
          'Did you mean to pass -c / --config ?'), ANSI.RED)
     sys.exit(1)
 
+  if args.reporter_api and not args.config:
+    prt('Must pass --config when using --reporter-api', ANSI.RED)
+    parser.print_help()
+    sys.exit(1)
+
+  return args
+
+
+class SignalException(Exception):
+  pass
+
+
+def signal_handler(sig, frame):
+  raise SignalException('Received signal ' + str(sig))
+
+
+signal.signal(signal.SIGINT, signal_handler)
+signal.signal(signal.SIGTERM, signal_handler)
+
+
+def start_trace(args, print_log=True):
   perfetto_cmd = 'perfetto'
   device_dir = '/data/misc/perfetto-traces/'
 
@@ -507,7 +558,22 @@ def main():
   fname = '%s-%s.pftrace' % (tstamp, os.urandom(3).hex())
   device_file = device_dir + fname
 
-  cmd = [perfetto_cmd, '--background', '--txt', '-o', device_file]
+  cmd = [perfetto_cmd, '--background']
+  if not args.bin:
+    cmd.append('--txt')
+
+  if args.no_guardrails:
+    cmd.append('--no-guardrails')
+
+  if args.reporter_api:
+    # Remove all old reporter files to avoid polluting the file we will extract
+    # later.
+    adb('shell',
+        'rm /sdcard/Android/data/android.perfetto.cts.reporter/files/*').wait()
+    cmd.append('--upload')
+  else:
+    cmd.extend(['-o', device_file])
+
   on_device_config = None
   on_host_config = None
   if args.config is not None:
@@ -538,9 +604,6 @@ def main():
       cmd += ['--app', '\'' + app + '\'']
     cmd += args.events
 
-  # Perfetto will error out with a proper message if both a config file and
-  # short options are specified. No need to replicate that logic.
-
   # Work out the output file or directory.
   if args.out.endswith('/') or os.path.isdir(args.out):
     host_dir = args.out
@@ -555,7 +618,8 @@ def main():
     shutil.os.makedirs(host_dir)
 
   with open(on_host_config or os.devnull, 'rb') as f:
-    print('Running ' + ' '.join(cmd))
+    if print_log:
+      print('Running ' + ' '.join(cmd))
     proc = adb('shell', *cmd, stdin=f, stdout=subprocess.PIPE)
     proc_out = proc.communicate()[0].decode().strip()
     if on_device_config is not None:
@@ -569,19 +633,20 @@ def main():
     if match is None:
       prt('Failed to read the pid from perfetto --background', ANSI.RED)
       prt(proc_out)
-      adb('shell', 'rm -f ' + device_file).wait()
       sys.exit(1)
     bg_pid = match.group(1)
     exit_code = proc.wait()
 
   if exit_code != 0:
     prt('Perfetto invocation failed', ANSI.RED)
-    adb('shell', 'rm -f ' + device_file).wait()
     sys.exit(1)
 
   prt('Trace started. Press CTRL+C to stop', ANSI.BLACK + ANSI.BG_BLUE)
-  logcat = adb('logcat', '-v', 'brief', '-s', 'perfetto', '-b', 'main', '-T',
-               '1')
+  log_level = "-v"
+  if not print_log:
+    log_level = "-e"
+  logcat = adb('logcat', log_level, 'brief', '-s', 'perfetto', '-b', 'main',
+               '-T', '1')
 
   ctrl_c_count = 0
   adb_failure_count = 0
@@ -610,27 +675,50 @@ def main():
       adb_failure_count += 1
       if adb_failure_count >= MAX_ADB_FAILURES:
         prt('Too many unrecoverable ADB failures, bailing out', ANSI.RED)
-        adb('shell', 'rm -f ' + device_file).wait()
         sys.exit(1)
       time.sleep(2)
-    except KeyboardInterrupt:
+    except (KeyboardInterrupt, SignalException):
       sig = 'TERM' if ctrl_c_count == 0 else 'KILL'
       ctrl_c_count += 1
-      prt('Stopping the trace (SIG%s)' % sig, ANSI.BLACK + ANSI.BG_YELLOW)
+      if print_log:
+        prt('Stopping the trace (SIG%s)' % sig, ANSI.BLACK + ANSI.BG_YELLOW)
       adb('shell', 'kill -%s %s' % (sig, bg_pid)).wait()
 
   logcat.kill()
   logcat.wait()
 
-  prt('\n')
-  prt('Pulling into %s' % host_file, ANSI.BOLD)
+  if args.reporter_api:
+    if print_log:
+      prt('Waiting a few seconds to allow reporter to copy trace')
+    time.sleep(5)
+
+    ret = adb(
+        'shell',
+        'cp /sdcard/Android/data/android.perfetto.cts.reporter/files/* ' +
+        device_file).wait()
+    if ret != 0:
+      prt('Failed to extract reporter trace', ANSI.RED)
+      sys.exit(1)
+
+  if print_log:
+    prt('\n')
+    prt('Pulling into %s' % host_file, ANSI.BOLD)
   adb('pull', device_file, host_file).wait()
   adb('shell', 'rm -f ' + device_file).wait()
 
   if not args.no_open:
-    prt('\n')
-    prt('Opening the trace (%s) in the browser' % host_file)
-    open_trace_in_browser(host_file)
+    if print_log:
+      prt('\n')
+      prt('Opening the trace (%s) in the browser' % host_file)
+    open_browser = not args.no_open_browser
+    open_trace_in_browser(host_file, open_browser, args.origin)
+
+  return host_file
+
+
+def main():
+  args = setup_arguments()
+  start_trace(args)
 
 
 def prt(msg, colors=ANSI.END):
@@ -658,28 +746,36 @@ def find_adb():
     sys.exit(1)
 
 
-def open_trace_in_browser(path):
+def open_trace_in_browser(path, open_browser, origin):
   # We reuse the HTTP+RPC port because it's the only one allowed by the CSP.
   PORT = 9001
+  path = os.path.abspath(path)
   os.chdir(os.path.dirname(path))
   fname = os.path.basename(path)
   socketserver.TCPServer.allow_reuse_address = True
   with socketserver.TCPServer(('127.0.0.1', PORT), HttpHandler) as httpd:
-    webbrowser.open_new_tab(
-        'https://ui.perfetto.dev/#!/?url=http://127.0.0.1:%d/%s' %
-        (PORT, fname))
-    while httpd.__dict__.get('last_request') != '/' + fname:
+    address = f'{origin}/#!/?url=http://127.0.0.1:{PORT}/{fname}&referrer=record_android_trace'
+    if open_browser:
+      webbrowser.open_new_tab(address)
+    else:
+      print(f'Open URL in browser: {address}')
+
+    httpd.expected_fname = fname
+    httpd.fname_get_completed = None
+    httpd.allow_origin = origin
+    while httpd.fname_get_completed is None:
       httpd.handle_request()
 
 
-def adb(*args, stdin=devnull, stdout=None):
+def adb(*args, stdin=devnull, stdout=None, stderr=None):
   cmd = [adb_path, *args]
   setpgrp = None
   if os.name != 'nt':
     # On Linux/Mac, start a new process group so all child processes are killed
     # on exit. Unsupported on Windows.
     setpgrp = lambda: os.setpgrp()
-  proc = subprocess.Popen(cmd, stdin=stdin, stdout=stdout, preexec_fn=setpgrp)
+  proc = subprocess.Popen(
+      cmd, stdin=stdin, stdout=stdout, stderr=stderr, preexec_fn=setpgrp)
   procs.append(proc)
   return proc
 
diff --git a/res/prompts/on_device.txt b/res/prompts/on_device.txt
new file mode 100644
index 000000000..43aa15115
--- /dev/null
+++ b/res/prompts/on_device.txt
@@ -0,0 +1,19 @@
+As an Android expert, you are investigating the failure of the following test:
+{TEST_NAME}
+which failed with the following stacktrace quoted:
+"""
+{STACK_TRACE}
+"""
+The attached logcat was captured during the failure on the device, it has been preprocessed
+for higher verbosity and ease the parsing.
+
+LOGCAT:
+"""
+{LOGCAT}
+"""
+
+Could you extract the relevant snippets of logs and analyze possible root cause of the failure ?
+
+Pay attention to the following:
+- When does the failed test method starts in the logcat as reported via TestRunner tags, logs after the failed method starts are usually more relevant.
+- Avoid guessing the original source code and creating example codes that assume the original code.
\ No newline at end of file
diff --git a/src/com/android/ddmlib/testrunner/RemoteAndroidTestRunner.java b/src/com/android/ddmlib/testrunner/RemoteAndroidTestRunner.java
new file mode 100644
index 000000000..c275e5dcc
--- /dev/null
+++ b/src/com/android/ddmlib/testrunner/RemoteAndroidTestRunner.java
@@ -0,0 +1,465 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.ddmlib.testrunner;
+
+import com.android.annotations.NonNull;
+import com.android.ddmlib.AdbCommandRejectedException;
+import com.android.ddmlib.IDevice;
+import com.android.ddmlib.IShellEnabledDevice;
+import com.android.ddmlib.ShellCommandUnresponsiveException;
+import com.android.ddmlib.TimeoutException;
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.result.ddmlib.InstrumentationProtoResultParser;
+import com.android.tradefed.result.ddmlib.InstrumentationResultParser;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Hashtable;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.concurrent.TimeUnit;
+import java.util.function.BiFunction;
+
+/** Runs a Android test command remotely and reports results. */
+public class RemoteAndroidTestRunner implements IRemoteAndroidTestRunner {
+
+    /** Represents a status reporter mode in am instrument command options. */
+    public enum StatusReporterMode {
+        /**
+         * Use raw text message to receive status from am instrument command.
+         *
+         * @deprecated Use {@link #PROTO_STD} for API level 26 and above.
+         */
+        @Deprecated
+        RAW_TEXT("-r", 0, InstrumentationResultParser::new),
+
+        /**
+         * Use instrumentationData protobuf status reporter to receive status from am instrument
+         * command.
+         */
+        PROTO_STD("-m", 26, InstrumentationProtoResultParser::new);
+
+        StatusReporterMode(
+                String amInstrumentCommandArg,
+                int minApiLevel,
+                BiFunction<String, Collection<ITestRunListener>, IInstrumentationResultParser>
+                        parserFactory) {
+            this.amInstrumentCommandArg = amInstrumentCommandArg;
+            this.minApiLevel = minApiLevel;
+            this.parserFactory = parserFactory;
+        }
+
+        private final String amInstrumentCommandArg;
+        private final int minApiLevel;
+        private final BiFunction<String, Collection<ITestRunListener>, IInstrumentationResultParser>
+                parserFactory;
+
+        /**
+         * Returns a command line arg for am instrument command to specify this status reporter
+         * mode.
+         */
+        public String getAmInstrumentCommandArg() {
+            return amInstrumentCommandArg;
+        }
+
+        /**
+         * Returns the minimum Android API level which supports this instrumentation status report
+         * type.
+         */
+        public int getMinimumApiLevel() {
+            return minApiLevel;
+        }
+
+        /**
+         * Create the {@link InstrumentationResultParser} that can be used to parse the
+         * instrumentation output.
+         *
+         * @param runName The name of the run to use.
+         * @param listeners The listeners where to report the results.
+         * @return An instance of {@link InstrumentationResultParser}.
+         */
+        public IInstrumentationResultParser createInstrumentationResultParser(
+                @NonNull String runName, @NonNull Collection<ITestRunListener> listeners) {
+            return parserFactory.apply(runName, listeners);
+        }
+    }
+
+    private final StatusReporterMode mStatusReporterMode;
+
+    private final String mPackageName;
+    private final String mRunnerName;
+    private IShellEnabledDevice mRemoteDevice;
+    // default to no timeout
+    private long mMaxTimeoutMs = 0L;
+    private long mMaxTimeToOutputResponseMs = 0L;
+
+    private String mRunName = null;
+
+    /** map of name-value instrumentation argument pairs */
+    private Map<String, String> mArgMap;
+
+    private IInstrumentationResultParser mParser;
+
+    private static final String LOG_TAG = "RemoteAndroidTest";
+    private static final String DEFAULT_RUNNER_NAME = "android.test.InstrumentationTestRunner";
+
+    private static final char CLASS_SEPARATOR = ',';
+    private static final char METHOD_SEPARATOR = '#';
+    private static final char RUNNER_SEPARATOR = '/';
+
+    // defined instrumentation argument names
+    private static final String CLASS_ARG_NAME = "class";
+    private static final String LOG_ARG_NAME = "log";
+    private static final String DEBUG_ARG_NAME = "debug";
+    private static final String COVERAGE_ARG_NAME = "coverage";
+    private static final String PACKAGE_ARG_NAME = "package";
+    private static final String SIZE_ARG_NAME = "size";
+    private static final String DELAY_MSEC_ARG_NAME = "delay_msec";
+    private String mRunOptions = "";
+
+    private static final int TEST_COLLECTION_TIMEOUT = 2 * 60 * 1000; // 2 min
+
+    /**
+     * Creates a remote Android test runner.
+     *
+     * @param packageName the Android application package that contains the tests to run
+     * @param runnerName the instrumentation test runner to execute. If null, will use default
+     *     runner
+     * @param remoteDevice the Android device to execute tests on
+     * @param statusReporterMode the status reporter mode to be used for am instrument command
+     */
+    public RemoteAndroidTestRunner(
+            String packageName,
+            String runnerName,
+            IShellEnabledDevice remoteDevice,
+            StatusReporterMode statusReporterMode) {
+
+        mPackageName = packageName;
+        mRunnerName = runnerName;
+        mRemoteDevice = remoteDevice;
+        mStatusReporterMode = statusReporterMode;
+        mArgMap = new Hashtable<String, String>();
+    }
+
+    /**
+     * Alternate constructor. Uses default {@code statusReporterMode}.
+     *
+     * @param packageName the Android application package that contains the tests to run
+     * @param runnerName the instrumentation test runner to execute. If null, will use default
+     *     runner
+     * @param remoteDevice the Android device to execute tests on
+     */
+    public RemoteAndroidTestRunner(
+            String packageName, String runnerName, IShellEnabledDevice remoteDevice) {
+        this(packageName, runnerName, remoteDevice, StatusReporterMode.RAW_TEXT);
+    }
+
+    /**
+     * Alternate constructor. Uses default instrumentation runner.
+     *
+     * @param packageName the Android application package that contains the tests to run
+     * @param remoteDevice the Android device to execute tests on
+     */
+    public RemoteAndroidTestRunner(String packageName, IShellEnabledDevice remoteDevice) {
+        this(packageName, null, remoteDevice);
+    }
+
+    @Override
+    public String getPackageName() {
+        return mPackageName;
+    }
+
+    @Override
+    public String getRunnerName() {
+        if (mRunnerName == null) {
+            return DEFAULT_RUNNER_NAME;
+        }
+        return mRunnerName;
+    }
+
+    /** Returns the complete instrumentation component path. */
+    protected String getRunnerPath() {
+        return getPackageName() + RUNNER_SEPARATOR + getRunnerName();
+    }
+
+    @Override
+    public void setClassName(String className) {
+        // The class name may contain the dollar sign, so needs to be quoted.
+        addInstrumentationArg(CLASS_ARG_NAME, "'" + className + "'");
+    }
+
+    @Override
+    public void setClassNames(String[] classNames) {
+        StringBuilder classArgBuilder = new StringBuilder();
+
+        for (int i = 0; i < classNames.length; i++) {
+            if (i != 0) {
+                classArgBuilder.append(CLASS_SEPARATOR);
+            }
+            classArgBuilder.append(classNames[i]);
+        }
+        setClassName(classArgBuilder.toString());
+    }
+
+    @Override
+    public void setMethodName(String className, String testName) {
+        setClassName(className + METHOD_SEPARATOR + testName);
+    }
+
+    @Override
+    public void setTestPackageName(String packageName) {
+        addInstrumentationArg(PACKAGE_ARG_NAME, packageName);
+    }
+
+    @Override
+    public void addInstrumentationArg(String name, String value) {
+        if (name == null || value == null) {
+            throw new IllegalArgumentException("name or value arguments cannot be null");
+        }
+        mArgMap.put(name, value);
+    }
+
+    @Override
+    public void removeInstrumentationArg(String name) {
+        if (name == null) {
+            throw new IllegalArgumentException("name argument cannot be null");
+        }
+        mArgMap.remove(name);
+    }
+
+    @Override
+    public void addBooleanArg(String name, boolean value) {
+        addInstrumentationArg(name, Boolean.toString(value));
+    }
+
+    @Override
+    public void setLogOnly(boolean logOnly) {
+        addBooleanArg(LOG_ARG_NAME, logOnly);
+    }
+
+    @Override
+    public void setDebug(boolean debug) {
+        addBooleanArg(DEBUG_ARG_NAME, debug);
+    }
+
+    @Override
+    public void setAdditionalTestOutputLocation(String additionalTestDataPath) {
+        addInstrumentationArg("additionalTestOutputDir", additionalTestDataPath);
+    }
+
+    @Override
+    public void setCoverage(boolean coverage) {
+        addBooleanArg(COVERAGE_ARG_NAME, coverage);
+    }
+
+    @Override
+    public void setCoverageReportLocation(String reportPath) {
+        addInstrumentationArg("coverageFile", reportPath);
+    }
+
+    @Override
+    public CoverageOutput getCoverageOutputType() {
+        return CoverageOutput.FILE;
+    }
+
+    @Override
+    public void setTestSize(TestSize size) {
+        addInstrumentationArg(SIZE_ARG_NAME, size.getRunnerValue());
+    }
+
+    @Override
+    public void setTestCollection(boolean collect) {
+        if (collect) {
+            // skip test execution
+            setLogOnly(true);
+            // force a timeout for test collection
+            setMaxTimeToOutputResponse(TEST_COLLECTION_TIMEOUT, TimeUnit.MILLISECONDS);
+            if (getApiLevel() < 16) {
+                // On older platforms, collecting tests can fail for large volume of tests.
+                // Insert a small delay between each test to prevent this
+                addInstrumentationArg(DELAY_MSEC_ARG_NAME, "15" /* ms */);
+            }
+        } else {
+            setLogOnly(false);
+            // restore timeout to its original set value
+            setMaxTimeToOutputResponse(mMaxTimeToOutputResponseMs, TimeUnit.MILLISECONDS);
+            if (getApiLevel() < 16) {
+                // remove delay
+                removeInstrumentationArg(DELAY_MSEC_ARG_NAME);
+            }
+        }
+    }
+
+    /**
+     * Attempts to retrieve the Api level of the Android device
+     *
+     * @return the api level or -1 if the communication with the device wasn't successful
+     */
+    private int getApiLevel() {
+        try {
+            return Integer.parseInt(
+                    mRemoteDevice.getSystemProperty(IDevice.PROP_BUILD_API_LEVEL).get());
+        } catch (Exception e) {
+            return -1;
+        }
+    }
+
+    @Deprecated
+    @Override
+    public void setMaxtimeToOutputResponse(int maxTimeToOutputResponse) {
+        setMaxTimeToOutputResponse(maxTimeToOutputResponse, TimeUnit.MILLISECONDS);
+    }
+
+    @Override
+    public void setMaxTimeToOutputResponse(long maxTimeToOutputResponse, TimeUnit maxTimeUnits) {
+        mMaxTimeToOutputResponseMs = maxTimeUnits.toMillis(maxTimeToOutputResponse);
+    }
+
+    @Override
+    public void setMaxTimeout(long maxTimeout, TimeUnit maxTimeUnits) {
+        mMaxTimeoutMs = maxTimeUnits.toMillis(maxTimeout);
+    }
+
+    @Override
+    public void setRunName(String runName) {
+        mRunName = runName;
+    }
+
+    @Override
+    public void run(ITestRunListener... listeners)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    ShellCommandUnresponsiveException,
+                    IOException {
+        run(Arrays.asList(listeners));
+    }
+
+    @Override
+    public void run(Collection<ITestRunListener> listeners)
+            throws TimeoutException,
+                    AdbCommandRejectedException,
+                    ShellCommandUnresponsiveException,
+                    IOException {
+        final String runCaseCommandStr = getAmInstrumentCommand();
+        CLog.i(String.format("Running %1$s on %2$s", runCaseCommandStr, mRemoteDevice.getName()));
+        String runName = mRunName == null ? mPackageName : mRunName;
+        mParser = createParser(runName, listeners);
+
+        try {
+            mRemoteDevice.executeShellCommand(
+                    runCaseCommandStr,
+                    mParser,
+                    mMaxTimeoutMs,
+                    mMaxTimeToOutputResponseMs,
+                    TimeUnit.MILLISECONDS);
+        } catch (IOException e) {
+            CLog.w(
+                    String.format(
+                            "IOException %1$s when running tests %2$s on %3$s",
+                            e.toString(), getPackageName(), mRemoteDevice.getName()));
+            // rely on parser to communicate results to listeners
+            mParser.handleTestRunFailed(e.toString());
+            throw e;
+        } catch (ShellCommandUnresponsiveException e) {
+            CLog.w(
+                    String.format(
+                            "ShellCommandUnresponsiveException %1$s when running tests %2$s on"
+                                    + " %3$s",
+                            e.toString(), getPackageName(), mRemoteDevice.getName()));
+            mParser.handleTestRunFailed(
+                    String.format(
+                            "Failed to receive adb shell test output within %1$d ms. Test may have "
+                                    + "timed out, or adb connection to device became unresponsive",
+                            mMaxTimeToOutputResponseMs));
+            throw e;
+        } catch (TimeoutException e) {
+            CLog.w(
+                    String.format(
+                            "TimeoutException when running tests %1$s on %2$s",
+                            getPackageName(), mRemoteDevice.getName()));
+            mParser.handleTestRunFailed(e.toString());
+            throw e;
+        } catch (AdbCommandRejectedException e) {
+            CLog.w(
+                    String.format(
+                            "AdbCommandRejectedException %1$s when running tests %2$s on %3$s",
+                            e.toString(), getPackageName(), mRemoteDevice.getName()));
+            mParser.handleTestRunFailed(e.toString());
+            throw e;
+        }
+    }
+
+    /**
+     * Create the {@link InstrumentationResultParser} that will be used to parse the instrumentation
+     * output.
+     *
+     * @param runName The name of the run to use.
+     * @param listeners The listeners where to report the results.
+     * @return An instance of {@link InstrumentationResultParser}.
+     */
+    @NonNull
+    public IInstrumentationResultParser createParser(
+            @NonNull String runName, @NonNull Collection<ITestRunListener> listeners) {
+        return mStatusReporterMode.createInstrumentationResultParser(runName, listeners);
+    }
+
+    @NonNull
+    public String getAmInstrumentCommand() {
+        return String.format(
+                "am instrument -w %1$s %2$s %3$s %4$s",
+                mStatusReporterMode.getAmInstrumentCommandArg(),
+                getRunOptions(),
+                getArgsCommand(),
+                getRunnerPath());
+    }
+
+    /** Returns options for the am instrument command. */
+    @NonNull
+    public String getRunOptions() {
+        return mRunOptions;
+    }
+
+    /**
+     * Sets options for the am instrument command. See com/android/commands/am/Am.java for full list
+     * of options.
+     */
+    public void setRunOptions(@NonNull String options) {
+        mRunOptions = options;
+    }
+
+    @Override
+    public void cancel() {
+        if (mParser != null) {
+            mParser.cancel();
+        }
+    }
+
+    /**
+     * Returns the full instrumentation command line syntax for the provided instrumentation
+     * arguments. Returns an empty string if no arguments were specified.
+     */
+    protected String getArgsCommand() {
+        StringBuilder commandBuilder = new StringBuilder();
+        for (Entry<String, String> argPair : mArgMap.entrySet()) {
+            final String argCmd =
+                    String.format(" -e %1$s %2$s", argPair.getKey(), argPair.getValue());
+            commandBuilder.append(argCmd);
+        }
+        return commandBuilder.toString();
+    }
+}
diff --git a/src/com/android/tradefed/ai/ApiResponse.java b/src/com/android/tradefed/ai/ApiResponse.java
new file mode 100644
index 000000000..d6aaf818f
--- /dev/null
+++ b/src/com/android/tradefed/ai/ApiResponse.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.ai;
+
+import com.android.tradefed.ai.ContentRequest.Content;
+
+import java.util.List;
+
+/** Class to parse the return value of the API. */
+public class ApiResponse {
+    public List<Candidate> candidates;
+    public UsageMetadata usageMetadata;
+
+    public class Candidate {
+        public Content content;
+
+        @Override
+        public String toString() {
+            return "Candidate [content=" + content + "]";
+        }
+    }
+
+    public class UsageMetadata {
+        public long promptTokenCount;
+        public long candidatesTokenCount;
+        public long totalTokenCount;
+
+        @Override
+        public String toString() {
+            return "UsageMetadata [promptTokenCount="
+                    + promptTokenCount
+                    + ", candidatesTokenCount="
+                    + candidatesTokenCount
+                    + ", totalTokenCount="
+                    + totalTokenCount
+                    + "]";
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "ApiResponse [candidates=" + candidates + ", usageMetadata=" + usageMetadata + "]";
+    }
+}
diff --git a/src/com/android/tradefed/ai/ContentRequest.java b/src/com/android/tradefed/ai/ContentRequest.java
new file mode 100644
index 000000000..6879bf24c
--- /dev/null
+++ b/src/com/android/tradefed/ai/ContentRequest.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.ai;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/** Class to build the request to the API. */
+public class ContentRequest {
+    private List<Content> contents;
+
+    public ContentRequest(String textPrompt) {
+        this(textPrompt, new ArrayList<>());
+    }
+
+    public ContentRequest(String textPrompt, List<InlineData> inlineData) {
+        contents = new ArrayList<ContentRequest.Content>();
+        List<Part> parts = new ArrayList<ContentRequest.Part>();
+        parts.add(new Part(textPrompt));
+        for (InlineData data : inlineData) {
+            parts.add(new Part(data));
+        }
+        Content content = new Content(parts);
+        contents.add(content);
+    }
+
+    public class Content {
+        private List<Part> parts;
+
+        public Content(Part part) {
+            parts = new ArrayList<ContentRequest.Part>();
+            parts.add(part);
+        }
+
+        public Content(List<Part> parts) {
+            this.parts = new ArrayList<ContentRequest.Part>();
+            this.parts.addAll(parts);
+        }
+
+        @Override
+        public String toString() {
+            return "Content [parts=" + parts + "]";
+        }
+    }
+
+    public class Part {
+        private String text;
+        private InlineData inline_data;
+
+        public Part(String text) {
+            this.text = text;
+        }
+
+        public Part(InlineData data) {
+            this.inline_data = data;
+        }
+
+        @Override
+        public String toString() {
+            return "Part [text=" + text + ", inline_data=" + inline_data + "]";
+        }
+    }
+
+    public static class InlineData {
+        public String mime_type;
+        public String data;
+
+        public InlineData(String mimeType, String data) {
+            this.mime_type = mimeType;
+            this.data = data;
+        }
+
+        @Override
+        public String toString() {
+            return "InlineData [mime_type=" + mime_type + ", data=" + data + "]";
+        }
+    }
+}
diff --git a/src/com/android/tradefed/ai/CurlGenAiClient.java b/src/com/android/tradefed/ai/CurlGenAiClient.java
new file mode 100644
index 000000000..0902be229
--- /dev/null
+++ b/src/com/android/tradefed/ai/CurlGenAiClient.java
@@ -0,0 +1,150 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.ai;
+
+import com.android.tradefed.ai.ContentRequest.InlineData;
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.util.CommandResult;
+import com.android.tradefed.util.CommandStatus;
+import com.android.tradefed.util.FileUtil;
+import com.android.tradefed.util.RunUtil;
+
+import com.google.gson.Gson;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Provide a central client to interact with GenAi API and make prompt requests. This requires a
+ * valid API_KEY to be set.
+ */
+public class CurlGenAiClient {
+
+    private static final String API_URL =
+            "https://generativelanguage.googleapis.com/v1beta/models/";
+
+    /** List of model available to be used. */
+    public enum Model {
+        GEMINI_2_0_FLASH("gemini-2.0-flash"),
+        GEMINI_2_5_FLASH("gemini-2.5-flash-preview-05-20");
+
+        private final String modelName;
+
+        Model(String modelName) {
+            this.modelName = modelName;
+        }
+    }
+
+    /**
+     * Request a prompt to execute.
+     *
+     * @param apiKey The API_KEY to be used for the query.
+     * @param prompt The prompt being used.
+     */
+    public PromptResponse runPrompt(String apiKey, String prompt) {
+        return runPrompt(
+                Model.GEMINI_2_5_FLASH, apiKey, prompt, new ArrayList<ContentRequest.InlineData>());
+    }
+
+    /**
+     * Request a prompt to execute.
+     *
+     * @param apiKey The API_KEY to be used for the query.
+     * @param prompt The prompt being used.
+     * @param data The inline file data to be associated with the prompt.
+     */
+    public PromptResponse runPrompt(String apiKey, String prompt, List<InlineData> data) {
+        return runPrompt(Model.GEMINI_2_5_FLASH, apiKey, prompt, data);
+    }
+
+    /**
+     * Request a prompt to execute.
+     *
+     * @param model The model to be used.
+     * @param apiKey The API_KEY to be used for the query.
+     * @param prompt The prompt being used.
+     * @param data The inline file data to be associated with the prompt.
+     */
+    public PromptResponse runPrompt(
+            Model model, String apiKey, String prompt, List<InlineData> data) {
+        String query = buildQuery(model, apiKey);
+        try {
+            File request = FileUtil.createTempFile("curl-request", ".json");
+            FileUtil.writeToFile(createJsonQuery(prompt, data), request);
+            File response = FileUtil.createTempFile("curl-response", ".json");
+
+            CommandResult results =
+                    RunUtil.getDefault()
+                            .runTimedCmd(
+                                    0,
+                                    new String[] {
+                                        "curl",
+                                        query,
+                                        "-H",
+                                        "Content-Type: application/json",
+                                        "-X",
+                                        "POST",
+                                        "-d",
+                                        "@" + request.getAbsolutePath(),
+                                        "-o",
+                                        response.getAbsolutePath()
+                                    });
+            // TODO: Throw errors in case of errors
+            if (CommandStatus.SUCCESS.equals(results.getStatus())) {
+                String outputJson = FileUtil.readStringFromFile(response);
+                CLog.d("output: %s", outputJson);
+                try {
+                    JSONObject jsonObject = new JSONObject(outputJson);
+                    if (jsonObject.has("error")) {
+                        CLog.e("error with the query");
+                        return null;
+                    } else {
+                        Gson gson = new Gson();
+                        ApiResponse rep = gson.fromJson(outputJson, ApiResponse.class);
+                        CLog.d("%s", rep);
+                    }
+                } catch (JSONException je) {
+                    CLog.e(je);
+                }
+                return new PromptResponse(request, response);
+            } else {
+                CLog.e("Issue when running the query:");
+                CLog.e("stdout: %s", results.getStdout());
+                CLog.e("stderr: %s", results.getStderr());
+            }
+        } catch (Exception e) {
+            CLog.e(e);
+        }
+        return null;
+    }
+
+    private String createJsonQuery(String prompt, List<InlineData> inlineData) {
+        ContentRequest req = new ContentRequest(prompt, inlineData);
+        Gson gson = new Gson();
+        String json = gson.toJson(req);
+        return json;
+    }
+
+    private String buildQuery(Model model, String apiKey) {
+        String url = API_URL + model.modelName + ":generateContent?key=" + apiKey;
+        return url;
+    }
+}
diff --git a/src/com/android/tradefed/ai/PromptResponse.java b/src/com/android/tradefed/ai/PromptResponse.java
new file mode 100644
index 000000000..8af769a62
--- /dev/null
+++ b/src/com/android/tradefed/ai/PromptResponse.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.ai;
+
+import com.android.tradefed.util.FileUtil;
+
+import java.io.File;
+
+/** Representation of the prompt request and its response */
+public class PromptResponse {
+
+    private File request;
+    private File response;
+
+    public PromptResponse(File request, File response) {
+        this.request = request;
+        this.response = response;
+    }
+
+    public File getRequest() {
+        return request;
+    }
+
+    public File getResponse() {
+        return response;
+    }
+
+    public void clean() {
+        FileUtil.deleteFile(request);
+        FileUtil.deleteFile(response);
+    }
+}
diff --git a/src/com/android/tradefed/ai/PromptUtility.java b/src/com/android/tradefed/ai/PromptUtility.java
new file mode 100644
index 000000000..9f067380d
--- /dev/null
+++ b/src/com/android/tradefed/ai/PromptUtility.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.ai;
+
+import com.android.tradefed.ai.ContentRequest.InlineData;
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.result.TestDescription;
+import com.android.tradefed.util.FileUtil;
+import com.android.tradefed.util.ResourceUtil;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+/** A utility to craft prompts from context. */
+public class PromptUtility {
+
+    /** Reference to prompt template stored in resources */
+    public enum PromptTemplate {
+        ON_DEVICE("/prompts/on_device.txt"), // TEST_NAME, STACK_TRACE, LOGCAT
+        HOST_DRIVEN("/prompts/host_driven.txt");
+
+        private final String templateResource;
+
+        PromptTemplate(String resource) {
+            this.templateResource = resource;
+        }
+
+        public String getTemplateResource() {
+            return templateResource;
+        }
+    }
+
+    /**
+     * Craft a prompt based on a template
+     *
+     * @param apiKey
+     * @param template
+     * @param description
+     * @param stacktrace
+     * @param contextFiles
+     */
+    public static PromptResponse runPromptTemplate(
+            String apiKey,
+            PromptTemplate template,
+            TestDescription description,
+            String stacktrace,
+            Map<String, File> contextFiles) {
+        CurlGenAiClient client = new CurlGenAiClient();
+        File templatePrompt = null;
+        try {
+            // Load template
+            templatePrompt = FileUtil.createTempFile("prompt", ".txt");
+            ResourceUtil.extractResourceToFile(template.getTemplateResource(), templatePrompt);
+            String templatePromptString = FileUtil.readStringFromFile(templatePrompt);
+            // Replace template
+            // TODO: Avoid doing this in-memory
+            templatePromptString =
+                    templatePromptString.replace("{TEST_NAME}", description.toString());
+            templatePromptString = templatePromptString.replace("{STACK_TRACE}", stacktrace);
+            List<InlineData> data = new ArrayList<ContentRequest.InlineData>();
+            if (contextFiles.containsKey("LOGCAT")) {
+                File logcat = contextFiles.get("LOGCAT");
+                // InlineData id = new InlineData("text/plain", encodeFileToBase64(logcat));
+                // data.add(id);
+                templatePromptString =
+                        templatePromptString.replace(
+                                "{LOGCAT}", FileUtil.readStringFromFile(logcat));
+            }
+            // Execute
+            PromptResponse response = client.runPrompt(apiKey, templatePromptString, data);
+            CLog.d("Prompt response: %s", response.getResponse());
+            return response;
+        } catch (IOException e) {
+            CLog.e(e);
+        } finally {
+            FileUtil.deleteFile(templatePrompt);
+        }
+        return null;
+    }
+}
diff --git a/src/com/android/tradefed/build/CasFuseDriverProfile.java b/src/com/android/tradefed/build/CasFuseDriverProfile.java
new file mode 100644
index 000000000..0a5798928
--- /dev/null
+++ b/src/com/android/tradefed/build/CasFuseDriverProfile.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.build;
+
+import com.android.tradefed.build.IFuseDriverProfile;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.List;
+import java.util.Arrays;
+
+/**
+ * CasDriverProfile is a specific implementation of IFuseDriverProfile for device images which are
+ * FastCDC chunked directories.
+ */
+public class CasFuseDriverProfile implements IFuseDriverProfile {
+
+    private final Path mDriverPath;
+    private static final String CHUNKS_INDEX_FILENAME = "_chunks_index.json";
+    // All device images are expected to have a boot image file.
+    private static final String BOOT_IMAGE_FILENAME = "boot.img";
+    private long mMountTimeoutInMs = 500;
+
+    /**
+     * Creates a new CasFuseDriverProfile with the given driver path.
+     *
+     * @param driverPath The path to the driver binary.
+     */
+    public CasFuseDriverProfile(Path driverPath) {
+        this.mDriverPath = driverPath;
+    }
+
+  /**
+     * Creates a new CasFuseDriverProfile with the given driver path and mount timeout.
+     *
+     * @param driverPath The path to the driver binary.
+     * @param mountTimeoutInMs The timeout in milliseconds to wait for the mount point to be ready.
+     */
+    public CasFuseDriverProfile(Path driverPath, int mountTimeoutInMs) {
+        this.mDriverPath = driverPath;
+        this.mMountTimeoutInMs = mountTimeoutInMs;
+    }
+
+    @Override
+    public void validateSourceDataPath(Path sourceDataPath) throws IOException {
+        if (!Files.exists(sourceDataPath) || !Files.isDirectory(sourceDataPath)) {
+            throw new IOException(
+                    String.format(
+                            "Source data path %s is not a directory",
+                            sourceDataPath.toAbsolutePath()));
+        }
+        Path chunksIndexFilePath = sourceDataPath.resolve(CHUNKS_INDEX_FILENAME);
+        if (!Files.exists(chunksIndexFilePath)) {
+            throw new IOException(
+                    String.format(
+                            "Source data path %s does not have a chunks index file",
+                            sourceDataPath.toAbsolutePath()));
+        }
+    }
+
+    @Override
+    public boolean isMountPointReady(Path mountPoint) {
+        return Files.exists(mountPoint.resolve(BOOT_IMAGE_FILENAME));
+    }
+
+    @Override
+    public List<String> buildMountCommand(Path sourceDataPath, Path mountPoint) {
+        return Arrays.asList(
+                mDriverPath.toAbsolutePath().toString(),
+                "--chunks",
+                sourceDataPath.toAbsolutePath().toString(),
+                "--mount",
+                mountPoint.toAbsolutePath().toString());
+    }
+
+    @Override
+    public long getMountTimeoutInMs() {
+        return mMountTimeoutInMs;
+    }
+
+    @Override
+    public String getDriverName() {
+        return "casviewer";
+    }
+}
diff --git a/src/com/android/tradefed/build/FuseMountManager.java b/src/com/android/tradefed/build/FuseMountManager.java
new file mode 100644
index 000000000..c990322ea
--- /dev/null
+++ b/src/com/android/tradefed/build/FuseMountManager.java
@@ -0,0 +1,220 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.build;
+
+import com.android.tradefed.invoker.logger.InvocationMetricLogger;
+import com.android.tradefed.invoker.logger.InvocationMetricLogger.InvocationMetricKey;
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.util.IRunUtil;
+import com.android.tradefed.util.RunUtil;
+import com.android.tradefed.util.CommandResult;
+import com.android.tradefed.util.CommandStatus;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.TimeUnit;
+
+// FuseMountManager is a class that manages mounting and unmounting FUSE filesystems.
+// It is responsible for starting and stopping the FUSE driver processes, and for ensuring that
+// the mount points are ready to be used.
+public class FuseMountManager {
+    private final IFuseDriverProfile mDriverProfile;
+    private final IRunUtil mRunUtil;
+    // Map to associate a mount point with its running process
+    private final Map<Path, Process> activeMounts = new ConcurrentHashMap<>();
+
+    /**
+     * Creates a new FuseMountManager with the given driver profile.
+     *
+     * @param driverProfile The driver profile to use.
+     */
+    public FuseMountManager(IFuseDriverProfile driverProfile) {
+        this(driverProfile, RunUtil.getDefault());
+    }
+
+    /**
+     * Creates a new FuseMountManager with the given driver profile and run util.
+     *
+     * @param driverProfile The driver profile to use.
+     * @param runUtil The run util to use.
+     */
+    public FuseMountManager(IFuseDriverProfile driverProfile, IRunUtil runUtil) {
+        this.mDriverProfile = driverProfile;
+        this.mRunUtil = runUtil;
+    }
+
+    /**
+     * Mounts the given source data path at the given mount point.
+     *
+     * @param sourceDataPath The source data path to mount.
+     * @param mountPoint The mount point to mount the source data path at.
+     * @throws IOException If the mount process fails to start.
+     */
+    public void mount(Path sourceDataPath, Path mountPoint) throws IOException, InterruptedException {
+        final long startTime = System.currentTimeMillis();
+        CLog.i(
+                "Mount '%s' at: %s",
+                sourceDataPath.toAbsolutePath().toString(), mountPoint.toAbsolutePath().toString());
+
+        if (activeMounts.containsKey(mountPoint)) {
+            throw new IllegalStateException(
+                    "A mount already exists at:" + mountPoint.toAbsolutePath().toString());
+        }
+
+        try {
+            mDriverProfile.validateSourceDataPath(sourceDataPath);
+        } catch (IOException e) {
+            throw new IllegalArgumentException(
+                    String.format("Invalid source data path: %s", sourceDataPath.toAbsolutePath()),
+                    e);
+        }
+
+        List<String> command = mDriverProfile.buildMountCommand(sourceDataPath, mountPoint);
+        Process process = null;
+
+        try (ByteArrayOutputStream capturedOutput = new ByteArrayOutputStream()) {
+            process = mRunUtil.runCmdInBackground(command, capturedOutput);
+            if (process == null) { // Unlikely to happen.
+                throw new IOException("runCmdInBackground returned a null process.");
+            }
+
+            final long pollIntervalMs = 100;
+            final long deadline = System.currentTimeMillis() + mDriverProfile.getMountTimeoutInMs();
+            while (System.currentTimeMillis() < deadline) {
+                if (mDriverProfile.isMountPointReady(mountPoint)) {
+                    // SUCCESS: The mount is ready.
+                    long duration = System.currentTimeMillis() - startTime;
+                    InvocationMetricLogger.addInvocationMetrics(
+                            InvocationMetricKey.CAS_MOUNT_SUCCESS_COUNT, 1);
+                    InvocationMetricLogger.addInvocationMetrics(
+                            InvocationMetricKey.CAS_MOUNT_SUCCESS_TIME_MS, duration);
+                    CLog.i(
+                            "Done mounting '%s' at: %s (took %d ms)",
+                            sourceDataPath, mountPoint, duration);
+                    activeMounts.put(mountPoint, process);
+                    return; // Exit the method on success.
+                }
+
+                if (process.waitFor(pollIntervalMs, TimeUnit.MILLISECONDS)) {
+                    // FAILURE: Process exited prematurely.
+                    throw new IOException(
+                            String.format(
+                                    "FUSE process '%s' failed on startup. Exit Code: %d. Output:"
+                                            + " %s",
+                                    command,
+                                    process.exitValue(),
+                                    capturedOutput.toString(StandardCharsets.UTF_8)));
+                }
+            }
+
+            // FAILURE: Timed out waiting for the mount point to become ready.
+            process.destroyForcibly();
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricKey.CAS_MOUNT_TIMEOUT_COUNT, 1);
+            throw new IOException(
+                    String.format(
+                            "Mount process started but mount point is not ready (timed out)."
+                                    + " Output: %s",
+                            capturedOutput.toString(StandardCharsets.UTF_8)));
+
+        } catch (IOException | InterruptedException e) {
+            // FAILURE: Handle all exceptions from the try block here.
+            if (process != null && process.isAlive()) {
+                process.destroyForcibly();
+            }
+            // Log generic failure metrics for any exception path.
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricKey.CAS_MOUNT_FAILURE_COUNT, 1);
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricKey.CAS_MOUNT_FAILURE_TIME_MS,
+                    System.currentTimeMillis() - startTime);
+            // Re-throw the exception to the caller.
+            if (e instanceof InterruptedException) {
+                Thread.currentThread().interrupt();
+                throw new IOException("Mount operation was interrupted.", e);
+            }
+            throw e; // Not InterruptedException.
+        }
+    }
+
+    /**
+     * Unmounts the given mount point.
+     *
+     * @param mountPoint The mount point to unmount.
+     */
+    public void unmount(Path mountPoint) {
+        CLog.d("Unmount: %s", mountPoint.toAbsolutePath().toString());
+
+        Process process = activeMounts.get(mountPoint);
+        if (process == null) {
+            CLog.w("No mount found at: %s", mountPoint.toAbsolutePath().toString());
+            return;
+        }
+        if (!process.isAlive()) {
+            CLog.w("Already unmounted: %s", mountPoint.toAbsolutePath().toString());
+            activeMounts.remove(mountPoint); // Atomically remove from map
+            return;
+        }
+
+        try {
+            // Attempt graceful shutdown first (the preferred way)
+            CommandResult result =
+                    mRunUtil.runTimedCmd(
+                            10000, "fusermount", "-u", mountPoint.toAbsolutePath().toString());
+            if (result.getStatus() != CommandStatus.SUCCESS) {
+                CLog.w(
+                        "Graceful shutdown with 'fusermount -u' failed. Stderr: "
+                                + result.getStderr());
+                // Wait for up to 2 seconds to see if the process terminated despite the error
+                process.waitFor(2, java.util.concurrent.TimeUnit.SECONDS);
+            }
+
+        } catch (InterruptedException e) {
+            CLog.e(
+                    "fusermount command failed or timed out. Will attempt to kill the process"
+                            + " directly. Error: %s",
+                    e.getMessage());
+        } finally {
+            // Forcibly kill the driver process
+            activeMounts.remove(mountPoint); // Atomically remove from map
+            if (process.isAlive()) {
+                CLog.d(
+                        "fusermount did not terminate the process for \'%s\'. Forcibly destroying"
+                                + " it.",
+                        mountPoint.toAbsolutePath().toString());
+                process.destroyForcibly();
+                // Don't wait for the process to terminate as there isn't much we can do if it
+                // doesn't.
+            }
+        }
+
+        CLog.d("Done unmounting: %s", mountPoint.toAbsolutePath().toString());
+    }
+
+    /** Unmounts all tracked filesystems. */
+    public void unmountAll() {
+        List<Path> copyOfMountPoints = new ArrayList<>(activeMounts.keySet());
+        for (Path mountPoint : copyOfMountPoints) {
+            unmount(mountPoint);
+        }
+    }
+}
diff --git a/src/com/android/tradefed/build/IFuseDriverProfile.java b/src/com/android/tradefed/build/IFuseDriverProfile.java
new file mode 100644
index 000000000..fe4c6a9e9
--- /dev/null
+++ b/src/com/android/tradefed/build/IFuseDriverProfile.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.build;
+
+import java.io.IOException;
+import java.nio.file.Path;
+import java.util.List;
+
+/**
+ * Defines the specific behavior of a particular FUSE driver, allowing the MountManager to be
+ * generic.
+ */
+public interface IFuseDriverProfile {
+
+    /**
+     * The default timeout to wait for the mount point to be ready.
+     *
+     * @return The default timeout in milliseconds.
+     */
+    default long getMountTimeoutInMs() {
+        return 500;
+    }
+
+    /**
+     * Validates that the source data path is suitable for this specific FUSE driver.
+     *
+     * @param sourceDataPath The source data path to check.
+     * @throws IOException If the source data path is not valid.
+     */
+    void validateSourceDataPath(Path sourceDataPath) throws IOException;
+
+    /**
+     * Checks if the mount point is ready to be used.
+     *
+     * @param mountPoint The mount point to check.
+     * @return True if the mount point is ready, false otherwise.
+     */
+    default boolean isMountPointReady(Path mountPoint) {
+        return true;
+    }
+
+    /**
+     * Creates the command line to execute the mount command.
+     *
+     * @param sourceDataPath The source data path.
+     * @param mountPoint The target mount point.
+     * @return A list of string representing the command line to execute.
+     */
+    List<String> buildMountCommand(Path sourceDataPath, Path mountPoint);
+
+    /**
+     * A descriptive name for this driver type.
+     *
+     * @return The driver's name (e.g., "FastCDC", "sshfs").
+     */
+    String getDriverName();
+}
diff --git a/src/com/android/tradefed/build/content/DeviceMerkleTree.java b/src/com/android/tradefed/build/content/DeviceMerkleTree.java
index 846106a21..3be99247c 100644
--- a/src/com/android/tradefed/build/content/DeviceMerkleTree.java
+++ b/src/com/android/tradefed/build/content/DeviceMerkleTree.java
@@ -36,6 +36,10 @@ public class DeviceMerkleTree {
     public static Digest buildFromContext(
             ContentAnalysisContext context, AnalysisHeuristic analysisLevel) {
         try {
+            if (context.abortAnalysis()) {
+                CLog.d("Device digest computation isn't supported.");
+                return null;
+            }
             ArtifactDetails currentContent =
                     ArtifactDetails.parseFile(
                             context.contentInformation().currentContent, context.contentEntry());
diff --git a/src/com/android/tradefed/build/content/ImageContentAnalyzer.java b/src/com/android/tradefed/build/content/ImageContentAnalyzer.java
index 0996a7fa1..b76aef16b 100644
--- a/src/com/android/tradefed/build/content/ImageContentAnalyzer.java
+++ b/src/com/android/tradefed/build/content/ImageContentAnalyzer.java
@@ -65,6 +65,10 @@ public class ImageContentAnalyzer {
         allDescriptors.removeIf(d -> d.path.startsWith("META/"));
         allDescriptors.removeIf(d -> d.path.startsWith("PREBUILT_IMAGES/"));
         allDescriptors.removeIf(d -> d.path.startsWith("RADIO/"));
+        // Remove compilation paths, they are linked to underlying jars and apps
+        allDescriptors.removeIf(
+            d -> (d.path.startsWith("SYSTEM_OTHER/") || d.path.startsWith("SYSTEM/"))
+                && (d.path.endsWith(".odex") || d.path.endsWith(".vdex") || d.path.endsWith(".art") || d.path.endsWith(".oat")));
 
         if (analysisLevel.ordinal() >= AnalysisHeuristic.REMOVE_EXEMPTION.ordinal()) {
             boolean removed = false;
diff --git a/src/com/android/tradefed/build/content/TestContentAnalyzer.java b/src/com/android/tradefed/build/content/TestContentAnalyzer.java
index 691678415..6cdd3dc89 100644
--- a/src/com/android/tradefed/build/content/TestContentAnalyzer.java
+++ b/src/com/android/tradefed/build/content/TestContentAnalyzer.java
@@ -142,9 +142,13 @@ public class TestContentAnalyzer {
                     CLog.d("Content analysis results for %s: invalid", ac.contentEntry());
                 } else {
                     CLog.d("content analysis results for %s: %s", ac.contentEntry(), results);
+                    String key = TESTS_DIR_KEY + "_" + ac.contentEntry();
+                    // Normalize the build-id if it's part of the name
+                    if (key.contains(information.getBuildInfo().getBuildId())) {
+                        key = key.replace(information.getBuildInfo().getBuildId(), "ABCDEF");
+                    }
                     results.addArtifactDigestMapping(
-                            TESTS_DIR_KEY + "_" + ac.contentEntry(),
-                            ContentMerkleTree.buildTestsDirFromContext(ac, discoveredModules));
+                            key, ContentMerkleTree.buildTestsDirFromContext(ac, discoveredModules));
                 }
                 allResults.add(results);
             }
diff --git a/src/com/android/tradefed/cluster/ClusterBuildProvider.java b/src/com/android/tradefed/cluster/ClusterBuildProvider.java
index 0663e0864..580982cc6 100644
--- a/src/com/android/tradefed/cluster/ClusterBuildProvider.java
+++ b/src/com/android/tradefed/cluster/ClusterBuildProvider.java
@@ -65,6 +65,11 @@ public class ClusterBuildProvider implements IBuildProvider {
     @Option(name = "build-target", description = "Build target name")
     private String mBuildTarget = "stub";
 
+    @Option(
+            name = "curl-limit-rate",
+            description = "Curl limit rate for downloading test resources")
+    private String mCurlLimitRate = null;
+
     @Option(name = "build-attribute", description = "Build attributes to supply")
     private Map<String, String> mBuildAttributes = new HashMap<String, String>();
 
@@ -378,7 +383,7 @@ public class ClusterBuildProvider implements IBuildProvider {
 
     @VisibleForTesting
     TestResourceDownloader createTestResourceDownloader() {
-        return new TestResourceDownloader();
+        return new TestResourceDownloader(mCurlLimitRate);
     }
 
     @VisibleForTesting
diff --git a/src/com/android/tradefed/cluster/TestResourceDownloader.java b/src/com/android/tradefed/cluster/TestResourceDownloader.java
index d819ce8e3..082f38a0d 100644
--- a/src/com/android/tradefed/cluster/TestResourceDownloader.java
+++ b/src/com/android/tradefed/cluster/TestResourceDownloader.java
@@ -15,6 +15,7 @@
  */
 package com.android.tradefed.cluster;
 
+import com.android.annotations.VisibleForTesting;
 import com.android.loganalysis.util.ArrayUtil;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.util.CommandResult;
@@ -22,6 +23,7 @@ import com.android.tradefed.util.CommandStatus;
 import com.android.tradefed.util.FileUtil;
 import com.android.tradefed.util.IRunUtil;
 import com.android.tradefed.util.RunUtil;
+import com.google.common.base.Strings;
 import java.io.File;
 import java.io.IOException;
 import java.net.URL;
@@ -34,8 +36,17 @@ public class TestResourceDownloader {
     private static final long RETRY_INTERVAL_MS = 10 * 1000;
     private static final int MAX_RETRY_COUNT = 2;
 
+    private final String mCurlLimitRate;
     private IRunUtil mRunUtil = null;
 
+    public TestResourceDownloader(String curlLimitRate) {
+        mCurlLimitRate = curlLimitRate;
+    }
+
+    public TestResourceDownloader() {
+        this(null);
+    }
+
     public void download(String urlString, File dest) throws IOException {
         final URL url = new URL(urlString);
         final String protocol = url.getProtocol();
@@ -78,12 +89,23 @@ public class TestResourceDownloader {
         }
         if ("http".equals(protocol) || "https".equals(protocol)) {
             // FIXME: Check whether curl is available on a host.
-            // Add -L option to handle redirect.
-            return ArrayUtil.list("curl", "-o", file.getAbsolutePath(), "-fL", url.toString());
+            return buildCurlCommandArgs(url, file);
         }
         throw new UnsupportedOperationException("protocol " + protocol + " is not supported");
     }
 
+    @VisibleForTesting
+    List<String> buildCurlCommandArgs(URL url, File file) {
+        // Add -L option to handle redirect.
+        List<String> args =
+                ArrayUtil.list("curl", "-o", file.getAbsolutePath(), "-fL", url.toString());
+        if (!Strings.isNullOrEmpty(mCurlLimitRate)) {
+            args.add("--limit-rate");
+            args.add(mCurlLimitRate);
+        }
+        return args;
+    }
+
     IRunUtil getRunUtil() {
         if (mRunUtil == null) {
             mRunUtil = new RunUtil();
diff --git a/src/com/android/tradefed/command/CommandOptions.java b/src/com/android/tradefed/command/CommandOptions.java
index b5f654546..a1955804d 100644
--- a/src/com/android/tradefed/command/CommandOptions.java
+++ b/src/com/android/tradefed/command/CommandOptions.java
@@ -258,6 +258,13 @@ public class CommandOptions implements ICommandOptions {
             description = "Map of experimental flags that can be used for feature gating projects.")
     private Map<String, String> mExperimentalFlags = new LinkedHashMap<>();
 
+    @Option(
+            name = "rollout-flags",
+            description =
+                    "Map of rollout flags to enable features completely. Rollout flags are ignored"
+                            + " when TF objects are not present.")
+    private Map<String, String> mRolloutFlags = new LinkedHashMap<>();
+
     @Option(
             name = "skip-trybot-experiment",
             description = "Whether to skip experiments for TRYBOT runs.")
@@ -381,6 +388,25 @@ public class CommandOptions implements ICommandOptions {
                     "Actually enable the reporting of invocation caching status in presubmit.")
     private boolean mEnableCachingInvocationResultsInPresubmit = false;
 
+    @Option(
+            name = "delegation-environment",
+            description =
+                    "Option for compatibility with TradefedDelegator to receive environment"
+                            + " options. inop if not using delegation mode.")
+    private Map<String, String> mDelegationEnvironment = new LinkedHashMap<>();
+
+    @Option(
+            name = "skip-parent-process-logcat",
+            description = "Whether to skip logcat for parent process.")
+    private boolean mSkipParentProcessLogcat = false;
+
+    @Option(
+            name = "keep-post-processor-order",
+            description =
+                    "Whether to apply post processors in the order they are mentioned in the"
+                            + " config.")
+    private boolean mKeepPostProcessorOrder = false;
+
     /**
      * Set the help mode for the config.
      * <p/>
@@ -686,6 +712,12 @@ public class CommandOptions implements ICommandOptions {
         return mExperimentalFlags;
     }
 
+    /** {@inheritDoc} */
+    @Override
+    public Map<String, String> getRolloutFlags() {
+        return mRolloutFlags;
+    }
+
     /** {@inheritDoc} */
     @Override
     public boolean skipTrybotExperiment() {
@@ -929,4 +961,16 @@ public class CommandOptions implements ICommandOptions {
     public boolean reportInvocationCacheResultsInPresubmit() {
         return mEnableCachingInvocationResultsInPresubmit;
     }
+
+    /** {@inheritDoc} */
+    @Override
+    public boolean shouldSkipParentProcessLogcat() {
+        return mSkipParentProcessLogcat;
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public boolean keepPostProcessorOrder() {
+        return mKeepPostProcessorOrder;
+    }
 }
diff --git a/src/com/android/tradefed/command/CommandRunner.java b/src/com/android/tradefed/command/CommandRunner.java
index 949362be3..cb655bd02 100644
--- a/src/com/android/tradefed/command/CommandRunner.java
+++ b/src/com/android/tradefed/command/CommandRunner.java
@@ -38,14 +38,14 @@ import com.google.common.annotations.VisibleForTesting;
 import org.json.JSONException;
 import org.json.JSONObject;
 
+import sun.misc.Signal;
+import sun.misc.SignalHandler;
+
 import java.io.File;
 import java.io.IOException;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ExecutionException;
 
-import sun.misc.Signal;
-import sun.misc.SignalHandler;
-
 /**
  * An alternate TradeFederation entry point that will run command specified in command
  * line arguments and then quit.
@@ -60,6 +60,7 @@ public class CommandRunner {
 
     public static final String EXCEPTION_KEY = "serialized_exception";
     public static final String START_FEATURE_SERVER = "START_FEATURE_SERVER";
+    public static final String DEVICE_DISCOVERY_TIMEOUT = "DEVICE_DISCOVERY_TIMEOUT";
     private static final long CHECK_DEVICE_TIMEOUT = 60000;
 
     public CommandRunner() {}
@@ -103,6 +104,13 @@ public class CommandRunner {
     /** Returns the timeout after which to check for the command. */
     @VisibleForTesting
     long getCheckDeviceTimeout() {
+        if (System.getenv(DEVICE_DISCOVERY_TIMEOUT) != null) {
+            try {
+                return Long.parseLong(System.getenv(DEVICE_DISCOVERY_TIMEOUT));
+            } catch (NumberFormatException e) {
+                // Ignore
+            }
+        }
         return CHECK_DEVICE_TIMEOUT;
     }
 
@@ -128,6 +136,8 @@ public class CommandRunner {
             }
 
             mScheduler = getCommandScheduler();
+            mScheduler.setMaxPollTime(getCheckDeviceTimeout() / 10);
+            mScheduler.setPrintSchedulingWarning(true);
             mScheduler.setClearcutClient(client);
             mScheduler.start();
             SignalHandler handler =
diff --git a/src/com/android/tradefed/command/CommandScheduler.java b/src/com/android/tradefed/command/CommandScheduler.java
index 02a768d30..45847a1f7 100644
--- a/src/com/android/tradefed/command/CommandScheduler.java
+++ b/src/com/android/tradefed/command/CommandScheduler.java
@@ -45,6 +45,7 @@ import com.android.tradefed.device.DeviceAllocationState;
 import com.android.tradefed.device.DeviceManager;
 import com.android.tradefed.device.DeviceManager.FastbootDevice;
 import com.android.tradefed.device.DeviceNotAvailableException;
+import com.android.tradefed.device.DeviceSelectionOptions;
 import com.android.tradefed.device.DeviceUnresponsiveException;
 import com.android.tradefed.device.FreeDeviceState;
 import com.android.tradefed.device.IDeviceManager;
@@ -181,6 +182,7 @@ public class CommandScheduler extends Thread implements ICommandScheduler, IComm
     private boolean mStopScheduling = false;
 
     private boolean mStarted = false;
+    private boolean mPrintSchedulingWarning = false;
 
     private WaitObj mCommandProcessWait = new WaitObj();
 
@@ -683,6 +685,31 @@ public class CommandScheduler extends Thread implements ICommandScheduler, IComm
                         }
                     }
                 }
+                // Set TF rollout flags
+                List<String> ignoredFlags = new LinkedList<>();
+                for (Map.Entry<String, String> entry :
+                        config.getCommandOptions().getRolloutFlags().entrySet()) {
+                    try {
+                        String optionName = entry.getKey();
+                        String optionValue = entry.getValue();
+                        // Support map flags, where optionValue is a key=value pair
+                        int equalsIndex = optionValue.indexOf('=');
+                        if (equalsIndex != -1) {
+                            String mapKey = optionValue.substring(0, equalsIndex);
+                            String mapValue = optionValue.substring(equalsIndex + 1);
+                            config.injectOptionValue(optionName, mapKey, mapValue);
+                        } else {
+                            config.injectOptionValue(optionName, optionValue);
+                        }
+                    } catch (ConfigurationException e) {
+                        ignoredFlags.add(entry.getKey());
+                    }
+                }
+                // report the ignored rollout flags
+                if (!ignoredFlags.isEmpty()) {
+                    CLog.w("Rollout flags ignored: %s", ignoredFlags);
+                }
+
                 mCmd.commandStarted();
                 long invocTimeout = config.getCommandOptions().getInvocationTimeout();
                 if (invocTimeout > 0) {
@@ -1336,7 +1363,7 @@ public class CommandScheduler extends Thread implements ICommandScheduler, IComm
                     // clean warned list to avoid piling over time.
                     mUnscheduledWarning.remove(cmd);
                 } else {
-                    if (!mUnscheduledWarning.contains(cmd)) {
+                    if (mPrintSchedulingWarning || !mUnscheduledWarning.contains(cmd)) {
                         CLog.logAndDisplay(
                                 LogLevel.DEBUG,
                                 "No available device matching all the "
@@ -1503,6 +1530,7 @@ public class CommandScheduler extends Thread implements ICommandScheduler, IComm
                                         getKeyStoreClient(),
                                         ImmutableSet.of(
                                                 Configuration.DEVICE_REQUIREMENTS_TYPE_NAME,
+                                                Configuration.CMD_OPTIONS_TYPE_NAME,
                                                 Configuration.LOGGER_TYPE_NAME,
                                                 Configuration.LOG_SAVER_TYPE_NAME,
                                                 Configuration.RESULT_REPORTER_TYPE_NAME),
@@ -1975,6 +2003,12 @@ public class CommandScheduler extends Thread implements ICommandScheduler, IComm
         if (config.getDeviceConfig().isEmpty()) {
             return null;
         }
+        TradefedDelegator delegator = null;
+        if (config.getConfigurationObject(TradefedDelegator.DELEGATE_OBJECT) != null) {
+            delegator =
+                    (TradefedDelegator)
+                            config.getConfigurationObject(TradefedDelegator.DELEGATE_OBJECT);
+        }
         // If we need to replicate the setup on all devices
         ParentShardReplicate.replicatedSetup(config, getKeyStoreClient());
         synchronized (this) {
@@ -1983,9 +2017,17 @@ public class CommandScheduler extends Thread implements ICommandScheduler, IComm
                 if (excludeDevices.contains(deviceConfig.getDeviceName())) {
                     continue;
                 }
+                boolean useFakeDevice = deviceConfig.isFake();
+                if (delegator != null && delegator.noopAllocation()) {
+                    CLog.logAndDisplay(
+                            com.android.tradefed.log.Log.LogLevel.WARN, "Using fake device.");
+                    useFakeDevice = true;
+                    // Match the request to null to leverage the fake device
+                    ((DeviceSelectionOptions) deviceConfig.getDeviceRequirements())
+                            .setNullDeviceRequested(true);
+                }
                 device =
-                        manager.allocateDevice(
-                                deviceConfig.getDeviceRequirements(), deviceConfig.isFake());
+                        manager.allocateDevice(deviceConfig.getDeviceRequirements(), useFakeDevice);
                 if (device != null) {
                     devices.put(deviceConfig.getDeviceName(), device);
                 } else {
@@ -2645,4 +2687,14 @@ public class CommandScheduler extends Thread implements ICommandScheduler, IComm
         }
         return false;
     }
+
+    @Override
+    public void setMaxPollTime(long polling) {
+        mPollTime = polling;
+    }
+
+    @Override
+    public void setPrintSchedulingWarning(boolean print) {
+        mPrintSchedulingWarning = print;
+    }
 }
diff --git a/src/com/android/tradefed/command/ICommandOptions.java b/src/com/android/tradefed/command/ICommandOptions.java
index 94045eda2..4ade80490 100644
--- a/src/com/android/tradefed/command/ICommandOptions.java
+++ b/src/com/android/tradefed/command/ICommandOptions.java
@@ -192,6 +192,12 @@ public interface ICommandOptions {
     /** Returns the experimental flags map, that can be used to feature gate projects. */
     public Map<String, String> getExperimentalFlags();
 
+    /**
+     * Returns the rollout flags map. Rollout flags are different from experimental flags, as they
+     * are intended to be used for every invocation.
+     */
+    public Map<String, String> getRolloutFlags();
+
     /** Whether to skip experiments for TRYBOT runs. */
     public boolean skipTrybotExperiment();
 
@@ -317,4 +323,10 @@ public interface ICommandOptions {
 
     /** Returns true if we should report invocation cache results when available in presubmit. */
     public boolean reportInvocationCacheResultsInPresubmit();
+
+    /** Whether to skip logcat for parent process. */
+    public boolean shouldSkipParentProcessLogcat();
+
+    /** Whether to apply post processors in the order they are mentioned in the config. */
+    public boolean keepPostProcessorOrder();
 }
diff --git a/src/com/android/tradefed/command/ICommandScheduler.java b/src/com/android/tradefed/command/ICommandScheduler.java
index 0fbdbec7b..2e788ef34 100644
--- a/src/com/android/tradefed/command/ICommandScheduler.java
+++ b/src/com/android/tradefed/command/ICommandScheduler.java
@@ -340,4 +340,12 @@ public interface ICommandScheduler {
 
     /** Returns true if the device is used by an active invocation thread. */
     public boolean isDeviceInInvocationThread(ITestDevice device);
+
+    public default void setMaxPollTime(long polling) {
+        // Empty on purpose
+    }
+
+    public default void setPrintSchedulingWarning(boolean print) {
+        // Empty on purpose
+    }
 }
diff --git a/src/com/android/tradefed/config/proxy/TradefedDelegator.java b/src/com/android/tradefed/config/proxy/TradefedDelegator.java
index 15e772fb1..a28e3d1ab 100644
--- a/src/com/android/tradefed/config/proxy/TradefedDelegator.java
+++ b/src/com/android/tradefed/config/proxy/TradefedDelegator.java
@@ -27,7 +27,9 @@ import java.io.File;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 
 /** Objects that helps delegating the invocation to another Tradefed binary. */
@@ -37,6 +39,7 @@ public class TradefedDelegator {
     public static final String DELEGATE_OBJECT = "DELEGATE";
 
     private static final String DELETEGATED_OPTION_NAME = "delegated-tf";
+    private static final String DELEGATED_OPTION_NOOP_ALLOCATION = "delegated-tf-noop-allocation";
 
     @Option(
             name = DELETEGATED_OPTION_NAME,
@@ -45,6 +48,13 @@ public class TradefedDelegator {
                             + " the invocation")
     private File mDelegatedTfRootDir;
 
+    @Option(
+            name = DELEGATED_OPTION_NOOP_ALLOCATION,
+            description =
+                    "Allow to bypass allocation at delegation level. This isn't safe if device is"
+                            + " managed by Tradefed.")
+    private boolean mDelegatedNoopAllocation = false;
+
     @Option(
             name = CommandOptions.INVOCATION_DATA,
             description = "Mirror of CommandOptions#INVOCATION_DATA")
@@ -59,6 +69,13 @@ public class TradefedDelegator {
                             + "it so it knows how to parse it.")
     private List<String> mCtsParams = new ArrayList<>();
 
+    @Option(
+            name = "delegation-environment",
+            description =
+                    "Option for compatibility with TradefedDelegator to receive environment"
+                            + " options.")
+    private Map<String, String> mDelegationEnvironment = new LinkedHashMap<>();
+
     private String[] mCommandLine = null;
 
     /** Whether or not trigger the delegation logic. */
@@ -71,6 +88,10 @@ public class TradefedDelegator {
         return mDelegatedTfRootDir;
     }
 
+    public boolean noopAllocation() {
+        return mDelegatedNoopAllocation;
+    }
+
     /** Creates the classpath out of the jars in the directory. */
     public String createClasspath() throws IOException {
         Set<File> jars = FileUtil.findFilesObject(mDelegatedTfRootDir, ".*\\.jar");
@@ -85,6 +106,10 @@ public class TradefedDelegator {
         return mCommandLine;
     }
 
+    public Map<String, String> getEnvironment() {
+        return mDelegationEnvironment;
+    }
+
     /**
      * Returns whether or not this is the staging environment. We do not want to delegate in staging
      * by default, only if the "staging_delegated" is set.
@@ -101,18 +126,28 @@ public class TradefedDelegator {
     public static String[] clearCommandline(String[] originalCommand)
             throws ConfigurationException {
         String[] commandLine = clearCommandlineFromOneArg(originalCommand, DELETEGATED_OPTION_NAME);
+        commandLine =
+                clearCommandlineFromOneArg(commandLine, DELEGATED_OPTION_NOOP_ALLOCATION, true);
         return commandLine;
     }
 
     /** Remove a given option from the command line. */
     public static String[] clearCommandlineFromOneArg(String[] originalCommand, String optionName)
             throws ConfigurationException {
+        return clearCommandlineFromOneArg(originalCommand, optionName, false);
+    }
+
+    /** Remove a given option from the command line. */
+    public static String[] clearCommandlineFromOneArg(String[] originalCommand, String optionName, boolean booleanOption)
+            throws ConfigurationException {
         List<String> argsList = new ArrayList<>(Arrays.asList(originalCommand));
         try {
             while (argsList.contains("--" + optionName)) {
                 int index = argsList.indexOf("--" + optionName);
                 if (index != -1) {
-                    argsList.remove(index + 1);
+                    if (!booleanOption) {
+                        argsList.remove(index + 1);
+                    }
                     argsList.remove(index);
                 }
             }
diff --git a/src/com/android/tradefed/device/DeviceManager.java b/src/com/android/tradefed/device/DeviceManager.java
index 9e3624b2e..677509f2a 100644
--- a/src/com/android/tradefed/device/DeviceManager.java
+++ b/src/com/android/tradefed/device/DeviceManager.java
@@ -16,7 +16,6 @@
 
 package com.android.tradefed.device;
 
-import com.android.ddmlib.AndroidDebugBridge.IDeviceChangeListener;
 import com.android.ddmlib.DdmPreferences;
 import com.android.ddmlib.IDevice;
 import com.android.ddmlib.IDevice.DeviceState;
@@ -29,6 +28,7 @@ import com.android.tradefed.config.OptionClass;
 import com.android.tradefed.device.IDeviceMonitor.DeviceLister;
 import com.android.tradefed.device.IManagedTestDevice.DeviceEventResponse;
 import com.android.tradefed.device.cloud.VmRemoteDevice;
+import com.android.tradefed.device.server.AndroidDebugBridge.IDeviceChangeListener;
 import com.android.tradefed.host.IHostOptions;
 import com.android.tradefed.invoker.tracing.CloseableTraceScope;
 import com.android.tradefed.log.ILogRegistry.EventType;
@@ -100,7 +100,6 @@ public class DeviceManager implements IDeviceManager {
     static final IDeviceSelection ANY_DEVICE_OPTIONS = new DeviceSelectionOptions();
     private static final String NULL_DEVICE_SERIAL_PREFIX = "null-device";
     private static final String EMULATOR_SERIAL_PREFIX = "emulator";
-    private static final String TCP_DEVICE_SERIAL_PREFIX = "tcp-device";
     private static final String GCE_DEVICE_SERIAL_PREFIX = "gce-device";
     private static final String REMOTE_DEVICE_SERIAL_PREFIX = "remote-device";
     private static final String LOCAL_VIRTUAL_DEVICE_SERIAL_PREFIX = "local-virtual-device";
@@ -669,7 +668,10 @@ public class DeviceManager implements IDeviceManager {
     @Override
     public ITestDevice allocateDevice(IDeviceSelection options, boolean isTemporary) {
         checkInit();
-        if (isTemporary) {
+        if (options.shouldCreateTemporarilyPlaceholder()) {
+            String serial = options.getSerials().get(0);
+            addAvailableDevice(new RemoteAvdIDevice(serial, serial, true));
+        } else if (isTemporary) {
             String rand = UUID.randomUUID().toString();
             String serial = String.format("%s%s", NullDevice.TEMP_NULL_DEVICE_PREFIX, rand);
             addAvailableDevice(new NullDevice(serial, true));
@@ -722,14 +724,15 @@ public class DeviceManager implements IDeviceManager {
     public void freeDevice(ITestDevice device, FreeDeviceState deviceState) {
         checkInit();
         IManagedTestDevice managedDevice = (IManagedTestDevice) device;
-        // Reset fastboot path to original one no matter what
+        // Reset adb/fastboot path to original one no matter what
+        managedDevice.setAdbPath(getAdbPath());
         managedDevice.setFastbootPath(getFastbootPath());
         // force stop capturing logcat just to be sure
         managedDevice.stopLogcat();
         IDevice ideviceToReturn = device.getIDevice();
-        if (ideviceToReturn instanceof NullDevice) {
-            NullDevice nullDevice = (NullDevice) ideviceToReturn;
-            if (nullDevice.isTemporary()) {
+        if (ideviceToReturn instanceof ITemporaryDevice) {
+            ITemporaryDevice idevice = (ITemporaryDevice) ideviceToReturn;
+            if (idevice.isTemporary()) {
                 DeviceEventResponse r =
                         mManagedDeviceList.handleDeviceEvent(
                                 managedDevice, DeviceEvent.FREE_UNKNOWN);
@@ -1639,8 +1642,26 @@ public class DeviceManager implements IDeviceManager {
 
     /** {@inheritDoc} */
     @Override
-    public void addMonitoringTcpFastbootDevice(String serial, String fastboot_serial) {
-        mMonitoringTcpFastbootDevices.put(serial, fastboot_serial);
+    public void addMonitoringTcpFastbootDevice(String serial, String fastbootSerial) {
+        CLog.logAndDisplay(
+                LogLevel.DEBUG,
+                "Monitoring fastboot serial '%s' for device '%s'",
+                fastbootSerial,
+                serial);
+        mMonitoringTcpFastbootDevices.put(serial, fastbootSerial);
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public void removeMonitoringTcpFastbootDevice(String serial) {
+        String removed = mMonitoringTcpFastbootDevices.remove(serial);
+        if (removed != null) {
+            CLog.logAndDisplay(
+                    LogLevel.DEBUG,
+                    "Remove monitoring fastboot serial '%s' for device '%s'",
+                    removed,
+                    serial);
+        }
     }
 
     /** {@inheritDoc} */
diff --git a/src/com/android/tradefed/device/DeviceSelectionOptions.java b/src/com/android/tradefed/device/DeviceSelectionOptions.java
index ba9fa39fa..b21511aac 100644
--- a/src/com/android/tradefed/device/DeviceSelectionOptions.java
+++ b/src/com/android/tradefed/device/DeviceSelectionOptions.java
@@ -107,6 +107,11 @@ public class DeviceSelectionOptions implements IDeviceSelection {
             description = "start a placeholder for a gce device that will be connected later.")
     private boolean mGceDeviceRequested = false;
 
+    @Option(
+            name = "create-temporary-placeholder",
+            description = "Create a temporary virtual device placeholder for the invocation.")
+    private boolean mCreateTemporaryPlaceholder = false;
+
     @Option(name = "device-type", description = "The type of the device requested to be allocated.")
     private DeviceRequestedType mRequestedType = null;
 
@@ -797,6 +802,11 @@ public class DeviceSelectionOptions implements IDeviceSelection {
         return mNoMatchReason;
     }
 
+    @Override
+    public boolean shouldCreateTemporarilyPlaceholder() {
+        return mCreateTemporaryPlaceholder;
+    }
+
     /**
      * Helper factory method to create a {@link IDeviceSelection} that will only match device
      * with given serial
diff --git a/src/com/android/tradefed/device/FastbootHelper.java b/src/com/android/tradefed/device/FastbootHelper.java
index fe251fd03..1892ce38a 100644
--- a/src/com/android/tradefed/device/FastbootHelper.java
+++ b/src/com/android/tradefed/device/FastbootHelper.java
@@ -136,7 +136,10 @@ public class FastbootHelper {
         long TIMEOUT = 1500;
 
         for (Entry<String, String> entry : serials.entrySet()) {
-            CLog.v("Run 'fastboot -s %s getvar is-userspace' command", entry.getValue());
+            CLog.logAndDisplay(
+                    LogLevel.DEBUG,
+                    "Run 'fastboot -s %s getvar is-userspace' command",
+                    entry.getValue());
             CommandResult fastbootResult =
                     mRunUtil.runTimedCmdSilently(
                             TIMEOUT,
diff --git a/src/com/android/tradefed/device/IDeviceManager.java b/src/com/android/tradefed/device/IDeviceManager.java
index f9485aad3..f6c2a8784 100644
--- a/src/com/android/tradefed/device/IDeviceManager.java
+++ b/src/com/android/tradefed/device/IDeviceManager.java
@@ -16,7 +16,6 @@
 
 package com.android.tradefed.device;
 
-import com.android.ddmlib.AndroidDebugBridge;
 import com.android.tradefed.command.remote.DeviceDescriptor;
 import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.IRunUtil;
@@ -309,6 +308,10 @@ public interface IDeviceManager {
      */
     public void addMonitoringTcpFastbootDevice(String serial, String fastboot_serial);
 
+    public default void removeMonitoringTcpFastbootDevice(String serial) {
+        // Empty by default.
+    }
+
     /**
      * Returns whether or not we should check in {@link NativeDeviceStateMonitor} the file system is
      * mounted properly.
diff --git a/src/com/android/tradefed/device/ManagedDeviceList.java b/src/com/android/tradefed/device/ManagedDeviceList.java
index 0367e9b70..d1edada45 100644
--- a/src/com/android/tradefed/device/ManagedDeviceList.java
+++ b/src/com/android/tradefed/device/ManagedDeviceList.java
@@ -20,6 +20,7 @@ import com.android.ddmlib.IDevice;
 import com.android.tradefed.device.DeviceManager.FastbootDevice;
 import com.android.tradefed.device.IDeviceSelection.BaseDeviceType;
 import com.android.tradefed.device.IManagedTestDevice.DeviceEventResponse;
+import com.android.tradefed.log.Log.LogLevel;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.util.ConditionPriorityBlockingQueue.IMatcher;
 
@@ -216,7 +217,11 @@ class ManagedDeviceList implements Iterable<IManagedTestDevice> {
                 } else if (state.equals(d.getDeviceState())) {
                     // device was previously on fastboot, assume its gone now
                     d.setDeviceState(TestDeviceState.NOT_AVAILABLE);
-                    CLog.d("Device %s was in %s and not found anymore", serial, state);
+                    CLog.logAndDisplay(
+                            LogLevel.DEBUG,
+                            "Device %s was in %s and not found anymore",
+                            serial,
+                            state);
                     toRemove.add(d);
                 }
             }
@@ -320,6 +325,11 @@ class ManagedDeviceList implements Iterable<IManagedTestDevice> {
                     if (d != null) {
                         d.setTrackingSerial(realSerial);
                     }
+                    CLog.logAndDisplay(
+                            LogLevel.DEBUG,
+                            "Tracking '%s' via it's realSerial '%s'",
+                            serial,
+                            realSerial);
                     serial = realSerial.trim();
                     setTracking = true;
                 }
diff --git a/src/com/android/tradefed/device/ManagedTestDeviceFactory.java b/src/com/android/tradefed/device/ManagedTestDeviceFactory.java
index 1380deaec..d25c608aa 100644
--- a/src/com/android/tradefed/device/ManagedTestDeviceFactory.java
+++ b/src/com/android/tradefed/device/ManagedTestDeviceFactory.java
@@ -121,10 +121,7 @@ public class ManagedTestDeviceFactory implements IManagedTestDeviceFactory {
                                         mDeviceManager, idevice, mFastbootEnabled),
                                 mAllocationMonitor);
             } else {
-                Set<String> nativeSerials = new HashSet<>();
-                if (System.getenv(NOTIFY_AS_NATIVE) != null) {
-                    nativeSerials.addAll(Arrays.asList(System.getenv(NOTIFY_AS_NATIVE).split(",")));
-                }
+                Set<String> nativeSerials = getNativeDeviceSerials();
                 if (nativeSerials.contains(idevice.getSerialNumber())) {
                     testDevice =
                             new NativeDevice(
@@ -144,10 +141,22 @@ public class ManagedTestDeviceFactory implements IManagedTestDeviceFactory {
                 }
             }
         } else {
-            // Default to-go device is Android full stack device.
-            testDevice = new TestDevice(idevice,
-                    new DeviceStateMonitor(mDeviceManager, idevice, mFastbootEnabled),
-                    mAllocationMonitor);
+            Set<String> nativeSerials = getNativeDeviceSerials();
+            if (nativeSerials.contains(idevice.getSerialNumber())) {
+                testDevice =
+                        new NativeDevice(
+                                idevice,
+                                new NativeDeviceStateMonitor(
+                                        mDeviceManager, idevice, mFastbootEnabled),
+                                mAllocationMonitor);
+            } else {
+                // Default to-go device is Android full stack device.
+                testDevice =
+                        new TestDevice(
+                                idevice,
+                                new DeviceStateMonitor(mDeviceManager, idevice, mFastbootEnabled),
+                                mAllocationMonitor);
+            }
         }
 
         if (idevice instanceof FastbootDevice) {
@@ -161,6 +170,7 @@ public class ManagedTestDeviceFactory implements IManagedTestDeviceFactory {
         }
         testDevice.setFastbootEnabled(mFastbootEnabled);
         testDevice.setFastbootPath(mDeviceManager.getFastbootPath());
+        testDevice.setAdbPath(mDeviceManager.getAdbPath());
         return testDevice;
     }
 
@@ -193,6 +203,14 @@ public class ManagedTestDeviceFactory implements IManagedTestDeviceFactory {
         mFastbootEnabled = enable;
     }
 
+    private Set<String> getNativeDeviceSerials() {
+        Set<String> nativeSerials = new HashSet<>();
+        if (System.getenv(NOTIFY_AS_NATIVE) != null) {
+            nativeSerials.addAll(Arrays.asList(System.getenv(NOTIFY_AS_NATIVE).split(",")));
+        }
+        return nativeSerials;
+    }
+
     /**
      * Helper to device if it's a serial from a remotely connected device. serial format of tcp
      * device is <ip or locahost>:<port>
diff --git a/src/com/android/tradefed/device/NativeDevice.java b/src/com/android/tradefed/device/NativeDevice.java
index 3f4c8d4ba..6785c7899 100644
--- a/src/com/android/tradefed/device/NativeDevice.java
+++ b/src/com/android/tradefed/device/NativeDevice.java
@@ -25,7 +25,6 @@ import com.android.ddmlib.Log.LogLevel;
 import com.android.ddmlib.ShellCommandUnresponsiveException;
 import com.android.ddmlib.SyncException;
 import com.android.ddmlib.SyncException.SyncError;
-import com.android.ddmlib.SyncService;
 import com.android.ddmlib.TimeoutException;
 import com.android.ddmlib.testrunner.IRemoteAndroidTestRunner;
 import com.android.ddmlib.testrunner.ITestRunListener;
@@ -43,6 +42,8 @@ import com.android.tradefed.device.connection.AbstractConnection;
 import com.android.tradefed.device.connection.DefaultConnection;
 import com.android.tradefed.device.connection.DefaultConnection.ConnectionBuilder;
 import com.android.tradefed.device.contentprovider.ContentProviderHandler;
+import com.android.tradefed.device.server.CommandRejectedException;
+import com.android.tradefed.device.server.SyncService;
 import com.android.tradefed.error.HarnessRuntimeException;
 import com.android.tradefed.host.IHostOptions;
 import com.android.tradefed.invoker.logger.InvocationMetricLogger;
@@ -231,6 +232,8 @@ public class NativeDevice
     private LogcatReceiver mLogcatReceiver;
     private boolean mFastbootEnabled = true;
     private String mFastbootPath = "fastboot";
+    private String mAdbPath = "adb";
+    private String mAdbServerPort = null;
 
     protected TestDeviceOptions mOptions = new TestDeviceOptions();
     private Process mEmulatorProcess;
@@ -263,6 +266,7 @@ public class NativeDevice
     private String mTrackingSerialNumber = null;
     private String mFastbootSerialNumber = null;
     private File mUnpackedFastbootDir = null;
+    private File mUnpackedAdbDir = null;
     // Connection for the device.
     private AbstractConnection mConnection;
     private GceAvdInfo mConnectionAvd;
@@ -312,6 +316,8 @@ public class NativeDevice
     protected class AdbAction implements DeviceAction {
         /** the output from the command */
         String mOutput = null;
+
+        CommandResult mResult = null;
         private String[] mCmd;
         private long mTimeout;
         private boolean mIsShellCommand;
@@ -339,26 +345,26 @@ public class NativeDevice
             for (String key : mEnvMap.keySet()) {
                 runUtil.setEnvVariable(key, mEnvMap.get(key));
             }
-            CommandResult result = runUtil.runTimedCmd(mTimeout, mCmd);
+            mResult = runUtil.runTimedCmd(mTimeout, mCmd);
             // TODO: how to determine device not present with command failing for other reasons
-            if (result.getStatus() == CommandStatus.EXCEPTION) {
-                logExceptionAndOutput(result);
+            if (mResult.getStatus() == CommandStatus.EXCEPTION) {
+                logExceptionAndOutput(mResult);
                 throw new IOException("CommandStatus was EXCEPTION, details in host log");
-            } else if (result.getStatus() == CommandStatus.TIMED_OUT) {
-                logExceptionAndOutput(result);
+            } else if (mResult.getStatus() == CommandStatus.TIMED_OUT) {
+                logExceptionAndOutput(mResult);
                 throw new TimeoutException("CommandStatus was TIMED_OUT, details in host log");
-            } else if (result.getStatus() == CommandStatus.FAILED) {
+            } else if (mResult.getStatus() == CommandStatus.FAILED) {
 
-                logExceptionAndOutput(result);
+                logExceptionAndOutput(mResult);
                 if (mIsShellCommand) {
                     // Interpret as communication failure for shell commands
                     throw new IOException("CommandStatus was FAILED, details in host log");
                 } else {
-                    mOutput = result.getStdout();
+                    mOutput = mResult.getStdout();
                     return false;
                 }
             }
-            mOutput = result.getStdout();
+            mOutput = mResult.getStdout();
             return true;
         }
     }
@@ -396,7 +402,10 @@ public class NativeDevice
             if (mResult.getStatus() == CommandStatus.EXCEPTION) {
                 throw new IOException(mResult.getStderr());
             } else if (mResult.getStatus() == CommandStatus.TIMED_OUT) {
-                throw new TimeoutException(mResult.getStderr());
+                String message =
+                        String.format(
+                                "Stdout: %s\nStderr: %s", mResult.getStdout(), mResult.getStderr());
+                throw new TimeoutException(message);
             }
             String stdErr = mResult.getStderr();
             if (stdErr != null) {
@@ -519,8 +528,43 @@ public class NativeDevice
                 setFastbootPath(mOptions.getFastbootBinary().getAbsolutePath());
             }
         }
+        if (mOptions.getAdbServerPort() != null) {
+            mAdbServerPort = mOptions.getAdbServerPort();
+        } else {
+            mAdbServerPort = null;
+        }
+        if (mOptions.getAdbBinary() != null) {
+            // Setup adb, if it's zipped, unzip it
+            if (".zip".equals(FileUtil.getExtension(mOptions.getAdbBinary().getName()))) {
+                // Unzip the fastboot files
+                try {
+                    mUnpackedAdbDir =
+                            ZipUtil2.extractZipToTemp(mOptions.getAdbBinary(), "unpacked-adb");
+                    File unpackedAdb = FileUtil.findFile(mUnpackedAdbDir, "adb");
+                    if (unpackedAdb == null) {
+                        throw new HarnessRuntimeException(
+                                String.format(
+                                        "device-adb-binary was set, but didn't contain a"
+                                                + " adb binary."),
+                                InfraErrorIdentifier.OPTION_CONFIGURATION_ERROR);
+                    }
+                    setAdbPath(unpackedAdb.getAbsolutePath());
+                } catch (IOException e) {
+                    CLog.e("Failed to unpacked zipped adb.");
+                    CLog.e(e);
+                    FileUtil.recursiveDelete(mUnpackedAdbDir);
+                    mUnpackedAdbDir = null;
+                }
+            } else {
+                setAdbPath(mOptions.getAdbBinary().getAbsolutePath());
+            }
+        }
         mStateMonitor.setDefaultOnlineTimeout(options.getOnlineTimeout());
         mStateMonitor.setDefaultAvailableTimeout(options.getAvailableTimeout());
+        if (NativeDeviceStateMonitor.class.isAssignableFrom(mStateMonitor.getClass())) {
+            ((NativeDeviceStateMonitor) mStateMonitor)
+                    .setSkipBootComplete(options.shouldSkipBootComplete());
+        }
     }
 
     /**
@@ -1417,6 +1461,13 @@ public class NativeDevice
         throw new UnsupportedOperationException("No support for Package Manager's features");
     }
 
+    /** {@inheritDoc} */
+    @Override
+    public boolean installPackageWithIncrementalMode(
+            File[] apkFiles, String[] extraArgs, String userId) throws DeviceNotAvailableException {
+        throw new UnsupportedOperationException("No support for Package Manager's features");
+    }
+
     /**
      * {@inheritDoc}
      */
@@ -1630,7 +1681,9 @@ public class NativeDevice
                     new DeviceAction() {
                         @Override
                         public boolean run()
-                                throws TimeoutException, IOException, AdbCommandRejectedException,
+                                throws TimeoutException,
+                                        IOException,
+                                        AdbCommandRejectedException,
                                         SyncException {
                             SyncService syncService = null;
                             boolean status = false;
@@ -1644,6 +1697,10 @@ public class NativeDevice
                                         interpolatePathVariables(remoteFilePath),
                                         SyncService.getNullProgressMonitor());
                                 status = true;
+                                CLog.d(
+                                        "pushed %s to %s",
+                                        localFile.getAbsolutePath(),
+                                        interpolatePathVariables(remoteFilePath));
                             } catch (SyncException e) {
                                 CLog.w(
                                         "Failed to push %s to %s on device %s. Message: '%s'. "
@@ -2448,6 +2505,30 @@ public class NativeDevice
         return adbAction.mOutput;
     }
 
+    /** {@inheritDoc} */
+    @Override
+    public CommandResult executeAdbV2Command(String... cmdArgs) throws DeviceNotAvailableException {
+        return executeAdbV2Command(getCommandTimeout(), cmdArgs);
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public CommandResult executeAdbV2Command(long timeout, String... cmdArgs)
+            throws DeviceNotAvailableException {
+        return executeAdbV2Command(getCommandTimeout(), new HashMap<>(), cmdArgs);
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public CommandResult executeAdbV2Command(
+            long timeout, Map<String, String> envMap, String... cmdArgs)
+            throws DeviceNotAvailableException {
+        final String[] fullCmd = buildAdbCommand(cmdArgs);
+        AdbAction adbAction = new AdbAction(timeout, fullCmd, "shell".equals(cmdArgs[0]), envMap);
+        performDeviceAction(String.format("adb %s", cmdArgs[0]), adbAction, MAX_RETRY_ATTEMPTS);
+        return adbAction.mResult;
+    }
+
     /**
      * {@inheritDoc}
      */
@@ -2630,8 +2711,13 @@ public class NativeDevice
      * Builds the OS command for the given adb command and args
      */
     private String[] buildAdbCommand(String... commandArgs) {
-        return ArrayUtil.buildArray(new String[] {"adb", "-s", getSerialNumber()},
-                commandArgs);
+        if (mAdbServerPort != null) {
+            return ArrayUtil.buildArray(
+                    new String[] {getAdbPath(), "-s", getSerialNumber(), "-P", mAdbServerPort},
+                    commandArgs);
+        }
+        return ArrayUtil.buildArray(
+                new String[] {getAdbPath(), "-s", getSerialNumber()}, commandArgs);
     }
 
     /** Builds the OS command for the given adb shell command session and args */
@@ -2650,7 +2736,9 @@ public class NativeDevice
             exitStatusProbe = new String[] {};
         }
         return ArrayUtil.buildArray(
-                new String[] {"adb", "-s", getSerialNumber(), "shell"},
+                new String[] {getAdbPath(), "-s", getSerialNumber()},
+                mAdbServerPort != null ? new String[] {"-P", mAdbServerPort} : new String[] {},
+                new String[] {"shell"},
                 commandArgs,
                 exitStatusProbe);
     }
@@ -2703,7 +2791,7 @@ public class NativeDevice
                         // this is a logic problem, doesn't need recovery or to be retried
                         return false;
                     }
-                } catch (AdbCommandRejectedException e) {
+                } catch (AdbCommandRejectedException | CommandRejectedException e) {
                     // Workaround to not recover device if TCP adb is used.
                     if (isAdbTcp()
                             && (action instanceof RebootDeviceAction)
@@ -2725,7 +2813,17 @@ public class NativeDevice
                             actionDescription, getSerialNumber());
                 }
                 if (shouldRecover) {
-                    recoverDevice();
+                    boolean recovered = recoverDevice();
+                    if (!recovered) {
+                        throw new DeviceNotAvailableException(
+                                String.format(
+                                        "Attempted %s without communication success and recovery"
+                                                + " was not running. Aborting.",
+                                        actionDescription),
+                                lastException,
+                                getSerialNumber(),
+                                DeviceErrorIdentifier.DEVICE_UNRESPONSIVE);
+                    }
                 }
             }
             if (retryAttempts > 0) {
@@ -3324,7 +3422,12 @@ public class NativeDevice
      */
     @Override
     public boolean checkConnectivity() throws DeviceNotAvailableException {
-        IWifiHelper wifi = createWifiHelper();
+        IWifiHelper wifi = null;
+        if (!getOptions().useCmdWifiCommands() || !enableAdbRoot() || getApiLevel() < 31) {
+            wifi = createWifiHelper(false);
+        } else {
+            wifi = createWifiHelper(true);
+        }
         return wifi.checkConnectivity(mOptions.getConnCheckUrl());
     }
 
@@ -3354,7 +3457,12 @@ public class NativeDevice
      */
     @Override
     public boolean isWifiEnabled() throws DeviceNotAvailableException {
-        final IWifiHelper wifi = createWifiHelper();
+        IWifiHelper wifi = null;
+        if (!getOptions().useCmdWifiCommands() || !enableAdbRoot() || getApiLevel() < 31) {
+            wifi = createWifiHelper(false);
+        } else {
+            wifi = createWifiHelper(true);
+        }
         try {
             return wifi.isWifiEnabled();
         } catch (RuntimeException e) {
@@ -3700,10 +3808,7 @@ public class NativeDevice
 
             if (RebootMode.REBOOT_INTO_FASTBOOTD.equals(mode)
                     && getHostOptions().isFastbootdEnable()) {
-                if (!mStateMonitor.waitForDeviceFastbootd(
-                        getFastbootPath(), mOptions.getFastbootTimeout())) {
-                    recoverDeviceFromFastbootd();
-                }
+                waitForDeviceFastbootD();
             } else {
                 waitForDeviceBootloader();
             }
@@ -4001,6 +4106,7 @@ public class NativeDevice
         if (isStateBootloaderOrFastbootd()) {
             CLog.i("device %s in %s. Rebooting to userspace.", getSerialNumber(), getDeviceState());
             executeFastbootCommand("reboot");
+            postAdbReboot(rebootMode);
         } else {
             if (mOptions.shouldDisableReboot()) {
                 CLog.i("Device reboot disabled by options, skipped.");
@@ -4014,7 +4120,7 @@ public class NativeDevice
                         getSerialNumber(), rebootMode.name(), reason);
             }
             doAdbReboot(rebootMode, reason);
-            postAdbReboot();
+            postAdbReboot(rebootMode);
         }
     }
 
@@ -4023,13 +4129,18 @@ public class NativeDevice
      *
      * @throws DeviceNotAvailableException
      */
-    protected void postAdbReboot() throws DeviceNotAvailableException {
+    protected void postAdbReboot(RebootMode rebootMode) throws DeviceNotAvailableException {
         // Check if device shows as unavailable (as expected after reboot).
         boolean notAvailable = waitForDeviceNotAvailable(DEFAULT_UNAVAILABLE_TIMEOUT);
         if (!notAvailable) {
             CLog.w("Did not detect device %s becoming unavailable after reboot", getSerialNumber());
         }
-        getConnection().reconnect(getSerialNumber());
+        if (RebootMode.REBOOT_INTO_BOOTLOADER.equals(rebootMode)
+                || RebootMode.REBOOT_INTO_FASTBOOTD.equals(rebootMode)) {
+            CLog.d("Skipping postAdbReboot reconnection for mode %s", rebootMode);
+        } else {
+            getConnection().reconnect(getSerialNumber());
+        }
     }
 
     /**
@@ -4173,9 +4284,9 @@ public class NativeDevice
 
     /**
      * Override if the device needs some specific actions to be taken after adb root and before the
-     * device is back online.
-     * Default implementation doesn't include any addition actions.
-     * adb root is not guaranteed to be enabled at this stage.
+     * device is back online. Default implementation doesn't include any addition actions. adb root
+     * is not guaranteed to be enabled at this stage.
+     *
      * @throws DeviceNotAvailableException
      */
     public void postAdbRootAction() throws DeviceNotAvailableException {
@@ -4184,30 +4295,26 @@ public class NativeDevice
 
     /**
      * Override if the device needs some specific actions to be taken after adb unroot and before
-     * the device is back online.
-     * Default implementation doesn't include any additional actions.
-     * adb root is not guaranteed to be disabled at this stage.
+     * the device is back online. Default implementation doesn't include any additional actions. adb
+     * root is not guaranteed to be disabled at this stage.
+     *
      * @throws DeviceNotAvailableException
      */
     public void postAdbUnrootAction() throws DeviceNotAvailableException {
         getConnection().reconnect(getSerialNumber());
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    /** {@inheritDoc} */
     @Override
     public boolean isAdbRoot() throws DeviceNotAvailableException {
         String output = executeShellCommand("id");
         return output.contains("uid=0(root)");
     }
 
-    /**
-     * {@inheritDoc}
-     */
+    /** {@inheritDoc} */
     @Override
-    public boolean unlockDevice() throws DeviceNotAvailableException,
-            UnsupportedOperationException {
+    public boolean unlockDevice()
+            throws DeviceNotAvailableException, UnsupportedOperationException {
         if (!isEncryptionSupported()) {
             throw new UnsupportedOperationException(String.format("Can't unlock device %s: "
                     + "encryption not supported", getSerialNumber()));
@@ -4372,12 +4479,16 @@ public class NativeDevice
     /** {@inheritDoc} */
     @Override
     public void waitForDeviceBootloader() throws DeviceNotAvailableException {
-        if (mOptions.useUpdatedBootloaderStatus()) {
+        if (mOptions.useUpdatedBootloaderStatus()
+                && !getFastbootSerialNumber().startsWith("tcp:")) {
             CommandResult commandResult =
                     simpleFastbootCommand(
                             mOptions.getFastbootTimeout(),
                             buildFastbootCommand("getvar", "product"));
             if (!CommandStatus.SUCCESS.equals(commandResult.getStatus())) {
+                if (getDeviceState().equals(TestDeviceState.FASTBOOT)) {
+                    return;
+                }
                 CLog.e(
                         "Waiting for device in bootloader. Status: %s.\nstdout:%s\nstderr:%s",
                         commandResult.getStatus(),
@@ -4394,6 +4505,13 @@ public class NativeDevice
         }
     }
 
+    public void waitForDeviceFastbootD() throws DeviceNotAvailableException {
+        if (!mStateMonitor.waitForDeviceFastbootd(
+                getFastbootPath(), mOptions.getFastbootTimeout())) {
+            recoverDeviceFromFastbootd();
+        }
+    }
+
     /** {@inheritDoc} */
     @Override
     public boolean waitForDeviceInSideload(long waitTime) {
@@ -4479,6 +4597,18 @@ public class NativeDevice
         return mFastbootPath;
     }
 
+    /** {@inheritDoc} */
+    @Override
+    public void setAdbPath(String adbPath) {
+        mAdbPath = adbPath;
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public String getAdbPath() {
+        return mAdbPath;
+    }
+
     /** {@inheritDoc} */
     @Override
     public String getFastbootVersion() {
@@ -4558,12 +4688,14 @@ public class NativeDevice
             return mFastbootSerialNumber;
         }
 
-        mFastbootSerialNumber = getLinkLocalIpv6FastbootSerial();
-        if (mFastbootSerialNumber != null) {
-            CLog.i(
-                    "Device %s's fastboot serial number is %s",
-                    getSerialNumber(), mFastbootSerialNumber);
-            return mFastbootSerialNumber;
+        if (getOptions().useIpV6ForTcpFastboot()) {
+            mFastbootSerialNumber = getLinkLocalIpv6FastbootSerial();
+            if (mFastbootSerialNumber != null) {
+                CLog.i(
+                        "Device %s's fastboot serial number is %s",
+                        getSerialNumber(), mFastbootSerialNumber);
+                return mFastbootSerialNumber;
+            }
         }
 
         // Fallback to the same serial over TCP. Used for emulator cases (i.e Cuttlefish).
@@ -5436,7 +5568,11 @@ public class NativeDevice
         FileUtil.deleteFile(mExecuteShellCommandLogs);
         mExecuteShellCommandLogs = null;
         FileUtil.recursiveDelete(mUnpackedFastbootDir);
+        mUnpackedFastbootDir = null;
+        FileUtil.recursiveDelete(mUnpackedAdbDir);
+        mUnpackedAdbDir = null;
         getConnection().tearDownConnection();
+        getMonitor().clearTcpFastbootMonitor();
         mConnectionAvd = null;
         mDeviceActionReceivers.clear();
         mFastbootSerialNumber = null;
@@ -5528,8 +5664,8 @@ public class NativeDevice
         IDevice idevice = getIDevice();
         try {
             boolean isTemporary = false;
-            if (idevice instanceof NullDevice) {
-                isTemporary = ((NullDevice) idevice).isTemporary();
+            if (idevice instanceof ITemporaryDevice) {
+                isTemporary = ((ITemporaryDevice) idevice).isTemporary();
             }
             if (shortDescriptor) {
                 // Return only info that do not require device inspection
@@ -6156,6 +6292,7 @@ public class NativeDevice
         // Construct a content provider if null, or if the current user has changed since last time.
         if (mContentProvider == null || mContentProvider.getUserId() != userId) {
             mContentProvider = new ContentProviderHandler(this, userId);
+            mContentProvider.setRunUtil(getRunUtil());
         }
         // Force the install if we saw an error with content provider installation.
         if (mContentProvider.contentProviderNotFound()) {
@@ -6293,11 +6430,6 @@ public class NativeDevice
      */
     @Override
     public boolean startTradeInModeTesting(final int timeoutMs) throws DeviceNotAvailableException {
-        if (!enableAdbRoot()) {
-            CLog.w("Trade in mode requires root.");
-            return false;
-        }
-
         final CommandResult result =
                 executeShellV2Command(
                         "tradeinmode wait-until-ready testing start",
diff --git a/src/com/android/tradefed/device/NativeDeviceStateMonitor.java b/src/com/android/tradefed/device/NativeDeviceStateMonitor.java
index 3280fd8da..144ce29ef 100644
--- a/src/com/android/tradefed/device/NativeDeviceStateMonitor.java
+++ b/src/com/android/tradefed/device/NativeDeviceStateMonitor.java
@@ -78,6 +78,7 @@ public class NativeDeviceStateMonitor implements IDeviceStateMonitor {
     private final boolean mFastbootEnabled;
     private boolean mMountFileSystemCheckEnabled = false;
     private TestDeviceState mFinalState = null;
+    private boolean mSkipBootComplete = false;
 
     protected static final String PERM_DENIED_ERROR_PATTERN = "Permission denied";
 
@@ -132,6 +133,11 @@ public class NativeDeviceStateMonitor implements IDeviceStateMonitor {
         }
     }
 
+    @Override
+    public void clearTcpFastbootMonitor() {
+        mMgr.removeMonitoringTcpFastbootDevice(getSerialNumber());
+    }
+
     /**
      * {@inheritDoc}
      */
@@ -314,6 +320,12 @@ public class NativeDeviceStateMonitor implements IDeviceStateMonitor {
      */
     @Override
     public boolean waitForBootComplete(final long waitTime) {
+        if (mSkipBootComplete) {
+            CLog.w(
+                    "You have enabled --skip-wait-for-boot-complete the check will be skipped."
+                            + " Proceed at your own risk.");
+            return true;
+        }
         try (CloseableTraceScope ignored = new CloseableTraceScope("waitForBootComplete")) {
             CLog.i("Waiting %d ms for device %s boot complete", waitTime, getSerialNumber());
             long start = System.currentTimeMillis();
@@ -544,7 +556,19 @@ public class NativeDeviceStateMonitor implements IDeviceStateMonitor {
         if (fastbootd) {
             mode = TestDeviceState.FASTBOOTD;
         }
-        boolean result = waitForDeviceState(mode, waitTime);
+        boolean result = false;
+        // For a tcp connection, break down the wait due to the connection aspect which change the
+        // behavior.
+        if (getFastbootSerialNumber().contains("tcp:")) {
+            for (int i = 0; i < 4; i++) {
+                result = waitForDeviceState(mode, waitTime / 4);
+                if (result) {
+                    break;
+                }
+            }
+        } else {
+            result = waitForDeviceState(mode, waitTime);
+        }
         mMgr.removeFastbootListener(listener);
         return result;
     }
@@ -702,6 +726,10 @@ public class NativeDeviceStateMonitor implements IDeviceStateMonitor {
         return mDevice.getSerialNumber().contains(":");
     }
 
+    public void setSkipBootComplete(boolean skipBootComplete) {
+        mSkipBootComplete = skipBootComplete;
+    }
+
     /**
      * Exposed for testing
      * @return {@link CollectingOutputReceiver}
diff --git a/src/com/android/tradefed/device/RemoteAndroidDevice.java b/src/com/android/tradefed/device/RemoteAndroidDevice.java
index 0ad92d59d..ad92af850 100644
--- a/src/com/android/tradefed/device/RemoteAndroidDevice.java
+++ b/src/com/android/tradefed/device/RemoteAndroidDevice.java
@@ -18,7 +18,10 @@ package com.android.tradefed.device;
 import com.android.ddmlib.IDevice;
 import com.android.tradefed.command.remote.DeviceDescriptor;
 import com.android.tradefed.device.connection.DefaultConnection;
+import com.android.tradefed.log.LogUtil.CLog;
 
+import java.net.InetAddress;
+import java.net.UnknownHostException;
 import java.util.Map;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -59,9 +62,18 @@ public class RemoteAndroidDevice extends TestDevice {
         String[] serial = serialString.split(":");
         if (serial.length == 2) {
             // Check first part is an IP
-            Matcher match = IP_PATTERN.matcher(serial[0]);
+            String hostname = serial[0];
+            Matcher match = IP_PATTERN.matcher(hostname);
             if (!match.find()) {
-                return false;
+                try {
+                    InetAddress address = InetAddress.getByName(hostname);
+                    String ipAddress = address.getHostAddress();
+                    CLog.d("The ip address of " + hostname + " is: " + ipAddress);
+                    return true;
+                } catch (UnknownHostException e) {
+                    CLog.e("Unable to find the IP address for " + hostname);
+                    return false;
+                }
             }
             // Check second part if a port
             try {
diff --git a/src/com/android/tradefed/device/RemoteAvdIDevice.java b/src/com/android/tradefed/device/RemoteAvdIDevice.java
index 087d9d213..34fe8350b 100644
--- a/src/com/android/tradefed/device/RemoteAvdIDevice.java
+++ b/src/com/android/tradefed/device/RemoteAvdIDevice.java
@@ -21,9 +21,11 @@ import com.android.ddmlib.IDevice;
  * A placeholder {@link IDevice} used by {@link DeviceManager} to allocate when {@link
  * DeviceSelectionOptions#gceDeviceRequested()} is <code>true</code>
  */
-public class RemoteAvdIDevice extends StubDevice implements IConfigurableVirtualDevice {
+public class RemoteAvdIDevice extends StubDevice
+        implements IConfigurableVirtualDevice, ITemporaryDevice {
 
     private String mKnownDeviceIp = null;
+    private boolean mIsTemporaryDevice = false;
     protected String mUser = null;
     protected Integer mDeviceNumOffset = null;
 
@@ -37,6 +39,12 @@ public class RemoteAvdIDevice extends StubDevice implements IConfigurableVirtual
         this.mKnownDeviceIp = knownDeviceIp;
     }
 
+    public RemoteAvdIDevice(String serial, String knownDeviceIp, boolean isTemporary) {
+        super(serial, false);
+        this.mKnownDeviceIp = knownDeviceIp;
+        this.mIsTemporaryDevice = isTemporary;
+    }
+
     public RemoteAvdIDevice(String serial, String knownDeviceIp, String user, Integer offset) {
         super(serial, false);
         this.mKnownDeviceIp = knownDeviceIp;
@@ -61,4 +69,9 @@ public class RemoteAvdIDevice extends StubDevice implements IConfigurableVirtual
     public Integer getDeviceNumOffset() {
         return mDeviceNumOffset;
     }
+
+    @Override
+    public boolean isTemporary() {
+        return mIsTemporaryDevice;
+    }
 }
diff --git a/src/com/android/tradefed/device/TestDevice.java b/src/com/android/tradefed/device/TestDevice.java
index 460979b79..339f217d9 100644
--- a/src/com/android/tradefed/device/TestDevice.java
+++ b/src/com/android/tradefed/device/TestDevice.java
@@ -629,6 +629,43 @@ public class TestDevice extends NativeDevice {
         return internalInstallPackage(packageFile, reinstall, args);
     }
 
+    /** {@inheritDoc} */
+    @Override
+    public boolean installPackageWithIncrementalMode(
+            File[] apkFiles, String[] extraArgs, String userId) throws DeviceNotAvailableException {
+        List<String> adbCmd = new ArrayList<>();
+        adbCmd.add("install");
+        adbCmd.add("--incremental");
+        boolean runtimePermissionSupported = isRuntimePermissionSupported();
+        if (runtimePermissionSupported) {
+            adbCmd.add("-g");
+        }
+        if (userId != null) {
+            adbCmd.add("--user");
+            adbCmd.add(userId);
+        }
+        if (extraArgs.length > 0) {
+            adbCmd.addAll(Arrays.asList(extraArgs));
+        }
+        if (apkFiles.length > 1) {
+            adbCmd.add("install-multiple");
+        }
+        for (File apk : apkFiles) {
+            adbCmd.add(apk.getAbsolutePath());
+        }
+        CommandResult res = executeAdbV2Command(adbCmd.toArray(new String[0]));
+        if (!CommandStatus.SUCCESS.equals(res.getStatus())) {
+            CLog.e("Failed to install with incremental mode, output: %s", res);
+            throw new DeviceNotAvailableException(
+                    String.format(
+                            "Failed to install with incremental mode on device %s, output: %s",
+                            getSerialNumber(), res),
+                    getSerialNumber(),
+                    DeviceErrorIdentifier.APK_INSTALLATION_FAILED);
+        }
+        return true;
+    }
+
     /**
      * {@inheritDoc}
      */
@@ -1181,12 +1218,12 @@ public class TestDevice extends NativeDevice {
             CLog.i(
                     "Attempting to disable keyguard on %s using %s",
                     getSerialNumber(), DISMISS_KEYGUARD_WM_CMD);
-            String output = executeShellCommand(DISMISS_KEYGUARD_WM_CMD);
-            CLog.i("output of %s: %s", DISMISS_KEYGUARD_WM_CMD, output);
+            CommandResult output = executeShellV2Command(DISMISS_KEYGUARD_WM_CMD);
+            CLog.i("output of %s: %s", DISMISS_KEYGUARD_WM_CMD, output.getStdout());
         } else {
             CLog.i("Command: %s, is not supported, falling back to %s", DISMISS_KEYGUARD_WM_CMD,
                     DISMISS_KEYGUARD_CMD);
-            executeShellCommand(DISMISS_KEYGUARD_CMD);
+            executeShellV2Command(DISMISS_KEYGUARD_CMD);
         }
         verifyKeyguardDismissed();
     }
@@ -1302,7 +1339,7 @@ public class TestDevice extends NativeDevice {
                 CLog.v("framework reboot: device unresponsive to shell command, using fallback");
                 return false;
             }
-            postAdbReboot();
+            postAdbReboot(rebootMode);
             return true;
         } else {
             CLog.v("framework reboot: not supported");
@@ -3122,8 +3159,8 @@ public class TestDevice extends NativeDevice {
     }
 
     /**
-     * Establish an adb connection to microdroid by letting Android forward the connection to
-     * microdroid. Wait until the connection is established and microdroid is booted.
+     * Establish an adb connection to microdroid, and wait until the connection is established
+     * and microdroid is booted.
      */
     private void adbConnectToMicrodroid(
             String cid, String microdroidSerial, int vmAdbPort, long adbConnectTimeoutMs) {
@@ -3137,8 +3174,6 @@ public class TestDevice extends NativeDevice {
         final String serial = getSerialNumber();
         final String from = "tcp:" + vmAdbPort;
         final String to = "vsock:" + cid + ":5555";
-        getRunUtil()
-                .runTimedCmd(10000, deviceManager.getAdbPath(), "-s", serial, "forward", from, to);
 
         boolean disconnected = true;
         while (disconnected && timeoutMillis >= 0) {
diff --git a/src/com/android/tradefed/device/WaitDeviceRecovery.java b/src/com/android/tradefed/device/WaitDeviceRecovery.java
index b1540ee3e..4d28faa68 100644
--- a/src/com/android/tradefed/device/WaitDeviceRecovery.java
+++ b/src/com/android/tradefed/device/WaitDeviceRecovery.java
@@ -229,7 +229,7 @@ public class WaitDeviceRecovery implements IDeviceRecovery {
             throws DeviceNotAvailableException {
         if (!mDisableUnresponsiveReboot) {
             CLog.i("Device %s unresponsive. Rebooting...", monitor.getSerialNumber());
-            rebootDevice(device, null);
+            rebootDevice(device, null, monitor);
             IDevice newdevice = monitor.waitForDeviceOnline(mOnlineWaitTime);
             if (newdevice == null) {
                 handleDeviceNotAvailable(monitor, false);
@@ -335,7 +335,7 @@ public class WaitDeviceRecovery implements IDeviceRecovery {
             handleDeviceBootloaderOrFastbootNotAvailable(monitor, "bootloader");
             return;
         }
-        rebootDevice(device, "bootloader");
+        rebootDevice(device, "bootloader", monitor);
         if (!monitor.waitForDeviceBootloader(mBootloaderWaitTime)) {
             throw new DeviceNotAvailableException(
                     String.format(
@@ -354,7 +354,7 @@ public class WaitDeviceRecovery implements IDeviceRecovery {
             handleDeviceBootloaderOrFastbootNotAvailable(monitor, "fastbootd");
             return;
         }
-        rebootDevice(device, "fastboot");
+        rebootDevice(device, "fastboot", monitor);
         if (!monitor.waitForDeviceFastbootd(mFastbootPath, mBootloaderWaitTime)) {
             throw new DeviceNotAvailableException(
                     String.format(
@@ -368,14 +368,14 @@ public class WaitDeviceRecovery implements IDeviceRecovery {
             throws DeviceNotAvailableException {
         CLog.i(
                 "Found device %s in fastbootd but potentially unresponsive.",
-                monitor.getSerialNumber());
+                monitor.getFastbootSerialNumber());
         // TODO: retry reboot
         getRunUtil()
                 .runTimedCmd(
                         mFastbootWaitTime,
                         mFastbootPath,
                         "-s",
-                        monitor.getSerialNumber(),
+                        monitor.getFastbootSerialNumber(),
                         "reboot",
                         "fastboot");
         // wait for device to reboot
@@ -383,8 +383,9 @@ public class WaitDeviceRecovery implements IDeviceRecovery {
         if (!monitor.waitForDeviceFastbootd(mFastbootPath, mBootloaderWaitTime)) {
             throw new DeviceNotAvailableException(
                     String.format(
-                            "Device %s not in fastbootd after reboot", monitor.getSerialNumber()),
-                    monitor.getSerialNumber(),
+                            "Device %s not in fastbootd after reboot",
+                            monitor.getFastbootSerialNumber()),
+                    monitor.getFastbootSerialNumber(),
                     DeviceErrorIdentifier.DEVICE_UNAVAILABLE);
         }
         // running a meaningless command just to see whether the device is responsive.
@@ -394,15 +395,15 @@ public class WaitDeviceRecovery implements IDeviceRecovery {
                                 mFastbootWaitTime,
                                 mFastbootPath,
                                 "-s",
-                                monitor.getSerialNumber(),
+                                monitor.getFastbootSerialNumber(),
                                 "getvar",
                                 "product");
         if (result.getStatus().equals(CommandStatus.TIMED_OUT)) {
             throw new DeviceNotAvailableException(
                     String.format(
                             "Device %s is in fastbootd but unresponsive",
-                            monitor.getSerialNumber()),
-                    monitor.getSerialNumber(),
+                            monitor.getFastbootSerialNumber()),
+                    monitor.getFastbootSerialNumber(),
                     DeviceErrorIdentifier.DEVICE_UNRESPONSIVE);
         }
     }
@@ -413,28 +414,43 @@ public class WaitDeviceRecovery implements IDeviceRecovery {
      */
     private void handleDeviceBootloaderUnresponsive(IDeviceStateMonitor monitor)
             throws DeviceNotAvailableException {
-        CLog.i("Found device %s in fastboot but potentially unresponsive.",
-                monitor.getSerialNumber());
+        CLog.i(
+                "Found device %s in fastboot but potentially unresponsive.",
+                monitor.getFastbootSerialNumber());
         // TODO: retry reboot
-        getRunUtil().runTimedCmd(mFastbootWaitTime, mFastbootPath, "-s", monitor.getSerialNumber(),
-                "reboot-bootloader");
+        getRunUtil()
+                .runTimedCmd(
+                        mFastbootWaitTime,
+                        mFastbootPath,
+                        "-s",
+                        monitor.getFastbootSerialNumber(),
+                        "reboot-bootloader");
         // wait for device to reboot
         monitor.waitForDeviceNotAvailable(20*1000);
         if (!monitor.waitForDeviceBootloader(mBootloaderWaitTime)) {
             throw new DeviceNotAvailableException(
                     String.format(
-                            "Device %s not in bootloader after reboot", monitor.getSerialNumber()),
-                    monitor.getSerialNumber(),
+                            "Device %s not in bootloader after reboot",
+                            monitor.getFastbootSerialNumber()),
+                    monitor.getFastbootSerialNumber(),
                     DeviceErrorIdentifier.DEVICE_UNAVAILABLE);
         }
         // running a meaningless command just to see whether the device is responsive.
-        CommandResult result = getRunUtil().runTimedCmd(mFastbootWaitTime, mFastbootPath, "-s",
-                monitor.getSerialNumber(), "getvar", "product");
+        CommandResult result =
+                getRunUtil()
+                        .runTimedCmd(
+                                mFastbootWaitTime,
+                                mFastbootPath,
+                                "-s",
+                                monitor.getFastbootSerialNumber(),
+                                "getvar",
+                                "product");
         if (result.getStatus().equals(CommandStatus.TIMED_OUT)) {
             throw new DeviceNotAvailableException(
                     String.format(
-                            "Device %s is in fastboot but unresponsive", monitor.getSerialNumber()),
-                    monitor.getSerialNumber(),
+                            "Device %s is in fastboot but unresponsive",
+                            monitor.getFastbootSerialNumber()),
+                    monitor.getFastbootSerialNumber(),
                     DeviceErrorIdentifier.DEVICE_UNRESPONSIVE);
         }
     }
@@ -445,9 +461,13 @@ public class WaitDeviceRecovery implements IDeviceRecovery {
      * @param device the {@link IDevice} to reboot.
      * @param mode The mode into which to reboot the device. null being regular reboot.
      */
-    private void rebootDevice(IDevice device, String mode) throws DeviceNotAvailableException {
+    private void rebootDevice(IDevice device, String mode, IDeviceStateMonitor monitor)
+            throws DeviceNotAvailableException {
         try {
             device.reboot(mode);
+            if (mode == null) {
+                monitor.waitForDeviceNotAvailable(20000L);
+            }
         } catch (IOException e) {
             CLog.w(
                     "%s: failed to reboot %s: %s",
@@ -551,7 +571,7 @@ public class WaitDeviceRecovery implements IDeviceRecovery {
                     rebootDevice(
                             device, null
                             /** regular mode */
-                            );
+                            , monitor);
                     if (waitForDevice(monitor, recoverTillOnline)) {
                         // Success
                         CLog.d("Device recovered from recovery mode and is online.");
diff --git a/src/com/android/tradefed/device/WifiHelper.java b/src/com/android/tradefed/device/WifiHelper.java
index 7330364d9..fc87637ad 100644
--- a/src/com/android/tradefed/device/WifiHelper.java
+++ b/src/com/android/tradefed/device/WifiHelper.java
@@ -543,15 +543,21 @@ public class WifiHelper implements IWifiHelper {
 
     private boolean checkConnectivityV2(long timeout) throws DeviceNotAvailableException {
         long startTime = System.currentTimeMillis();
+        CommandResult statusOutput = null;
         while (System.currentTimeMillis() < (startTime + timeout)) {
-            CommandResult statusOutput =
-                    mDevice.executeShellV2Command(String.format("cmd -w wifi status"));
+            statusOutput = mDevice.executeShellV2Command(String.format("cmd -w wifi status"));
             if (CommandStatus.SUCCESS.equals(statusOutput.getStatus())
                     && statusOutput.getStdout().contains("Wifi is connected")) {
                 return true;
             }
             getRunUtil().sleep(getPollTime());
         }
+        if (statusOutput != null) {
+            // if wifi connection failed, log the last status output for debugging
+            CLog.d(
+                    "Current wifi status:\n%s\nstderr:%s",
+                    statusOutput.getStdout(), statusOutput.getStderr());
+        }
         CLog.w("Wifi is not connected after timeout: %d ms.", timeout);
         return false;
     }
diff --git a/src/com/android/tradefed/device/cloud/GceAvdInfo.java b/src/com/android/tradefed/device/cloud/GceAvdInfo.java
index e79ee7192..cc7fa8488 100644
--- a/src/com/android/tradefed/device/cloud/GceAvdInfo.java
+++ b/src/com/android/tradefed/device/cloud/GceAvdInfo.java
@@ -489,6 +489,8 @@ public class GceAvdInfo {
                 gceAvdInfos.add(gceAvdInfo);
                 InvocationMetricLogger.addInvocationMetrics(
                         InvocationMetricKey.CF_OXYGENATION_VERSION, oxygenationVersion);
+                InvocationMetricLogger.addInvocationMetrics(
+                        InvocationMetricKey.CF_OXYGEN_VERSION, oxygenationVersion);
             }
         } else {
             Matcher matcher = OXYGEN_LEASE_RESPONSE_PATTERN.matcher(output);
diff --git a/src/com/android/tradefed/device/cloud/GceManager.java b/src/com/android/tradefed/device/cloud/GceManager.java
index 9df6449f7..6d9f0c669 100644
--- a/src/com/android/tradefed/device/cloud/GceManager.java
+++ b/src/com/android/tradefed/device/cloud/GceManager.java
@@ -1016,7 +1016,7 @@ public class GceManager {
         }
 
         // TODO(b/280177749): Remove the special logic after Oxygen side is cleaned up.
-        if (options.useOxygen() && options.useOxygenationDevice()) {
+        if (options.useOxygen() && !options.useOxygenationDevice()) {
             output =
                     remoteSshCommandExec(
                             gceAvd,
@@ -1046,7 +1046,7 @@ public class GceManager {
         }
         String deviceFilePath = match.group(2);
         String pullOutput;
-        if (options.useOxygen() && options.useOxygenationDevice()) {
+        if (options.useOxygen() && !options.useOxygenationDevice()) {
             pullOutput =
                     remoteSshCommandExec(
                             gceAvd,
diff --git a/src/com/android/tradefed/device/connection/AdbSshConnection.java b/src/com/android/tradefed/device/connection/AdbSshConnection.java
index 4f6e2bec4..bd62d2d70 100644
--- a/src/com/android/tradefed/device/connection/AdbSshConnection.java
+++ b/src/com/android/tradefed/device/connection/AdbSshConnection.java
@@ -730,6 +730,13 @@ public class AdbSshConnection extends AdbTcpConnection {
                     DeviceErrorIdentifier.DEVICE_UNAVAILABLE);
         }
         if (getDevice().getOptions().useCvdCF()) {
+            // TODO(b/421052178): Remove the bypass once bug is fixed.
+            if (getDevice().getOptions().useOxygenationDevice()) {
+                CLog.i("deleteSnapshotGce is not implemented in Oxygenation yet. skip.");
+                deleteRes = new CommandResult();
+                deleteRes.setStatus(CommandStatus.SUCCESS);
+                return deleteRes;
+            }
             deleteRes = mHOUtil.deleteSnapshotGce(snapshotId);
         } else {
             // Get the user from options instance-user if user is null.
@@ -778,7 +785,7 @@ public class AdbSshConnection extends AdbTcpConnection {
         }
 
         if (getDevice().getOptions().useCvdCF()) {
-            snapshotRes = mHOUtil.snapshotGce();
+            snapshotRes = mHOUtil.snapshotInstance(snapshotId);
         } else {
             // Get the user from options instance-user if user is null.
             if (user == null) {
@@ -836,7 +843,7 @@ public class AdbSshConnection extends AdbTcpConnection {
         stopGce(user, offset);
         CommandResult restoreRes = null;
         if (getDevice().getOptions().useCvdCF()) {
-            restoreRes = mHOUtil.restoreSnapshotGce();
+            restoreRes = mHOUtil.startCvd(snapshotId);
         } else {
             // Get the user from options instance-user if user is null.
             if (user == null) {
@@ -904,7 +911,7 @@ public class AdbSshConnection extends AdbTcpConnection {
         long startTime = System.currentTimeMillis();
         CommandResult stopRes = null;
         if (getDevice().getOptions().useCvdCF()) {
-            stopRes = mHOUtil.removeInstance();
+            stopRes = mHOUtil.stopInstance();
         } else {
             // Get the user from options instance-user if user is null.
             if (user == null) {
@@ -1240,11 +1247,6 @@ public class AdbSshConnection extends AdbTcpConnection {
                             && devices.indexOf("localhost:") == -1
                             && devices.indexOf("0.0.0.0:") == -1) {
                         CLog.e("No adb devices found on the host.");
-                        if (inspectionResult == null) {
-                            return new DeviceInspectionResult(
-                                    DeviceErrorIdentifier.DEVICE_UNAVAILABLE,
-                                    "No adb devices found on the host.");
-                        }
                     } else {
                         // Collect bugreport as the device is available with adb
                         try {
diff --git a/src/com/android/tradefed/device/connection/AdbTcpConnection.java b/src/com/android/tradefed/device/connection/AdbTcpConnection.java
index 739b6579e..962315d15 100644
--- a/src/com/android/tradefed/device/connection/AdbTcpConnection.java
+++ b/src/com/android/tradefed/device/connection/AdbTcpConnection.java
@@ -57,6 +57,8 @@ public class AdbTcpConnection extends DefaultConnection {
     private File mAdbConnectLogs = null;
 
     private Map<ITestDevice, String> mInvocationSnapshots;
+    private String mHostname = null;
+    private String mPort = null;
 
     public AdbTcpConnection(ConnectionBuilder builder) {
         super(builder);
@@ -279,6 +281,9 @@ public class AdbTcpConnection extends DefaultConnection {
 
     /** Return the hostname associated with the device. Extracted from the serial. */
     public String getHostName(String serial) {
+        if (mHostname != null) {
+            return mHostname;
+        }
         if (!RemoteAndroidDevice.checkSerialFormatValid(serial)) {
             throw new RuntimeException(
                     String.format(
@@ -286,11 +291,15 @@ public class AdbTcpConnection extends DefaultConnection {
                                     + "should look like <hostname>:<port>",
                             serial));
         }
-        return serial.split(":")[0];
+        mHostname = serial.split(":")[0];
+        return mHostname;
     }
 
     /** Return the port number asociated with the device. Extracted from the serial. */
     public String getPortNum(String serial) {
+        if (mPort != null) {
+            return mPort;
+        }
         if (!RemoteAndroidDevice.checkSerialFormatValid(serial)) {
             throw new RuntimeException(
                     String.format(
@@ -298,6 +307,7 @@ public class AdbTcpConnection extends DefaultConnection {
                                     + "should look like <hostname>:<port>",
                             serial));
         }
-        return serial.split(":")[1];
+        mPort = serial.split(":")[1];
+        return mPort;
     }
 }
diff --git a/src/com/android/tradefed/device/connection/DefaultConnection.java b/src/com/android/tradefed/device/connection/DefaultConnection.java
index a0f138b91..954a9e56e 100644
--- a/src/com/android/tradefed/device/connection/DefaultConnection.java
+++ b/src/com/android/tradefed/device/connection/DefaultConnection.java
@@ -18,10 +18,10 @@ package com.android.tradefed.device.connection;
 import com.android.ddmlib.IDevice;
 import com.android.tradefed.build.IBuildInfo;
 import com.android.tradefed.device.IConfigurableVirtualDevice;
+import com.android.tradefed.device.ITemporaryDevice;
 import com.android.tradefed.device.ITestDevice;
 import com.android.tradefed.device.ManagedTestDeviceFactory;
 import com.android.tradefed.device.NativeDevice;
-import com.android.tradefed.device.NullDevice;
 import com.android.tradefed.device.RemoteAndroidDevice;
 import com.android.tradefed.device.RemoteAvdIDevice;
 import com.android.tradefed.device.TestDeviceOptions.InstanceType;
@@ -93,6 +93,10 @@ public class DefaultConnection extends AbstractConnection {
                 return new AdbSshConnection(builder);
             }
         }
+        if (type.equals(InstanceType.NETWORK_DEVICE)) {
+            CLog.d("NETWORK_DEVICE type, using an adb tcp connection");
+            return new AdbTcpConnection(builder);
+        }
 
         return new DefaultConnection(builder);
     }
@@ -152,8 +156,8 @@ public class DefaultConnection extends AbstractConnection {
             mInitialUser = null;
             mInitialDeviceNumOffset = null;
         }
-        if (idevice instanceof NullDevice) {
-            mTemporaryHolder = ((NullDevice) idevice).isTemporary();
+        if (idevice instanceof ITemporaryDevice) {
+            mTemporaryHolder = ((ITemporaryDevice) idevice).isTemporary();
         } else {
             mTemporaryHolder = false;
         }
diff --git a/src/com/android/tradefed/device/internal/DeviceSnapshotHandler.java b/src/com/android/tradefed/device/internal/DeviceSnapshotHandler.java
index d6a9320c0..996256d19 100644
--- a/src/com/android/tradefed/device/internal/DeviceSnapshotHandler.java
+++ b/src/com/android/tradefed/device/internal/DeviceSnapshotHandler.java
@@ -151,6 +151,9 @@ public class DeviceSnapshotHandler {
             } catch (IOException | RuntimeException e) {
                 CLog.e("Failed to deserialize snapshot error response: %s", e.getMessage());
             }
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricKey.DEVICE_SNAPSHOT_FAILURE_COUNT, 1);
+
             if (o instanceof DeviceNotAvailableException) {
                 throw (DeviceNotAvailableException) o;
             } else if (o instanceof IHarnessException) {
@@ -181,6 +184,10 @@ public class DeviceSnapshotHandler {
         } else {
             InvocationMetricLogger.addInvocationMetrics(
                     InvocationMetricKey.DEVICE_SNAPSHOT_FAILURE_COUNT, 1);
+            throw new HarnessRuntimeException(
+                    "Exception while snapshotting the device. Unknown error response: "
+                            + response.getResponse(),
+                    InfraErrorIdentifier.UNDETERMINED);
         }
     }
 
@@ -224,6 +231,9 @@ public class DeviceSnapshotHandler {
             } catch (IOException | RuntimeException e) {
                 CLog.e("Failed to deserialize snapshot error response: %s", e.getMessage());
             }
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricKey.DEVICE_SNAPSHOT_RESTORE_FAILURE_COUNT, 1);
+
             if (o instanceof DeviceNotAvailableException) {
                 throw (DeviceNotAvailableException) o;
             } else if (o instanceof IHarnessException) {
@@ -260,6 +270,10 @@ public class DeviceSnapshotHandler {
         } else {
             InvocationMetricLogger.addInvocationMetrics(
                     InvocationMetricKey.DEVICE_SNAPSHOT_RESTORE_FAILURE_COUNT, 1);
+            throw new HarnessRuntimeException(
+                    "Exception while restoring the device. Unknown error response: "
+                            + response.getResponse(),
+                    InfraErrorIdentifier.UNDETERMINED);
         }
     }
 }
diff --git a/src/com/android/tradefed/device/metric/BaseDeviceMetricCollector.java b/src/com/android/tradefed/device/metric/BaseDeviceMetricCollector.java
index 032cdafda..d1f171dfd 100644
--- a/src/com/android/tradefed/device/metric/BaseDeviceMetricCollector.java
+++ b/src/com/android/tradefed/device/metric/BaseDeviceMetricCollector.java
@@ -91,6 +91,7 @@ public class BaseDeviceMetricCollector implements IMetricCollector, IDeviceActio
     private DeviceMetricData mRunData;
     private DeviceMetricData mTestData;
     private String mRunName;
+    private String mTestName;
 
     /**
      * Variable for whether or not to skip the collection of one test case because it was filtered.
@@ -446,6 +447,7 @@ public class BaseDeviceMetricCollector implements IMetricCollector, IDeviceActio
     public final void testStarted(TestDescription test, long startTime) {
         if (!mDeviceNoAvailable) {
             mTestData = new DeviceMetricData(mContext);
+            mTestName = test.toString();
             mSkipTestCase = shouldSkip(test);
             if (!mSkipTestCase) {
                 long start = System.currentTimeMillis();
@@ -641,6 +643,15 @@ public class BaseDeviceMetricCollector implements IMetricCollector, IDeviceActio
         return mRunName;
     }
 
+    /**
+     * Returns the name of test {@code mTestName} that triggers the collector.
+     *
+     * @return mTestName, the current test name.
+     */
+    public String getTestName() {
+        return mTestName;
+    }
+
     public String getModuleName() {
         return mContext.getAttributes().get(ModuleDefinition.MODULE_NAME) != null
                 ? mContext.getAttributes().get(ModuleDefinition.MODULE_NAME).get(0)
diff --git a/src/com/android/tradefed/device/metric/DeviceTraceCollector.java b/src/com/android/tradefed/device/metric/DeviceTraceCollector.java
index c6ab2e7f5..826196b6e 100644
--- a/src/com/android/tradefed/device/metric/DeviceTraceCollector.java
+++ b/src/com/android/tradefed/device/metric/DeviceTraceCollector.java
@@ -16,6 +16,7 @@
 
 package com.android.tradefed.device.metric;
 
+import com.android.tradefed.config.Option;
 import com.android.tradefed.device.DeviceNotAvailableException;
 import com.android.tradefed.device.ITestDevice;
 import com.android.tradefed.invoker.IInvocationContext;
@@ -30,12 +31,24 @@ import java.io.File;
 import java.io.IOException;
 import java.util.LinkedHashMap;
 import java.util.Map;
+
 /**
  * Collector that will start perfetto trace when a test run starts and log trace file at the end.
  */
 public class DeviceTraceCollector extends BaseDeviceMetricCollector {
-    // Format of the trace name should be: device-trace_<device-serial>_<trace-count>_<event-name>.
-    private static final String NAME_FORMAT = "device-trace_%s_%d_%s";
+    @Option(
+            name = "trace-config-file",
+            description =
+                    "Name of the trace config file in the test artifacts. "
+                            + "Can be used to optionally override the default trace config.")
+    private String mTraceConfigFile = null;
+
+    @Option(name = "per-run", description = "Whether to collect traces per-run or per-test.")
+    private boolean mPerRun = true;
+
+    // Format of the trace name should be:
+    // device-trace_<device-serial>_<run-or-test-name>_<trace-count>_<event-name>.
+    private static final String NAME_FORMAT = "device-trace_%s_%s_%d_%s";
     private PerfettoTraceRecorder mPerfettoTraceRecorder = new PerfettoTraceRecorder();
     // package name for an instrumentation test, null otherwise.
     private String mInstrumentationPkgName;
@@ -52,8 +65,16 @@ public class DeviceTraceCollector extends BaseDeviceMetricCollector {
     public void extraInit(IInvocationContext context, ITestInvocationListener listener)
             throws DeviceNotAvailableException {
         super.extraInit(context, listener);
-        for (ITestDevice device : getRealDevices()) {
-            startTraceOnDevice(device);
+
+        if (mPerRun) {
+            startCollecting();
+        }
+    }
+
+    @Override
+    public void onTestStart(DeviceMetricData testData) throws DeviceNotAvailableException {
+        if (!mPerRun) {
+            startCollecting();
         }
     }
 
@@ -61,8 +82,30 @@ public class DeviceTraceCollector extends BaseDeviceMetricCollector {
     public void onTestRunEnd(
             DeviceMetricData runData, Map<String, MetricMeasurement.Metric> currentRunMetrics)
             throws DeviceNotAvailableException {
+        if (mPerRun) {
+            stopCollecting("testRunEnded");
+        }
+    }
+
+    @Override
+    public void onTestEnd(
+            DeviceMetricData testData,
+            final Map<String, MetricMeasurement.Metric> currentTestCaseMetrics)
+            throws DeviceNotAvailableException {
+        if (!mPerRun) {
+            stopCollecting("testEnded");
+        }
+    }
+
+    private void startCollecting() {
+        for (ITestDevice device : getRealDevices()) {
+            startTraceOnDevice(device);
+        }
+    }
+
+    private void stopCollecting(String eventName) {
         for (ITestDevice device : getRealDevices()) {
-            collectTraceFileFromDevice(device, "testRunEnded");
+            collectTraceFileFromDevice(device, eventName);
         }
         logTraceFiles();
     }
@@ -75,7 +118,7 @@ public class DeviceTraceCollector extends BaseDeviceMetricCollector {
             if (mInstrumentationPkgName != null) {
                 extraConfigs.put("atrace_apps", String.format("\"%s\"", mInstrumentationPkgName));
             }
-            mPerfettoTraceRecorder.startTrace(device, extraConfigs);
+            mPerfettoTraceRecorder.startTrace(device, mTraceConfigFile, extraConfigs);
         } catch (IOException e) {
             CLog.d(
                     "Failed to start perfetto trace on %s trace-count:%d with error: %s",
@@ -97,10 +140,20 @@ public class DeviceTraceCollector extends BaseDeviceMetricCollector {
                 eventName,
                 mTraceCountMap.get(device),
                 traceFile.length());
+
+        String runOrTestName = mPerRun ? getRunName() : getTestName();
+        if (runOrTestName == null) {
+            CLog.w(
+                    "Failed to get run or test name on device:%s event:%s trace-count:%d.",
+                    device.getSerialNumber(), eventName, mTraceCountMap.get(device));
+            runOrTestName = "";
+        }
+
         String name =
                 String.format(
                         NAME_FORMAT,
                         device.getSerialNumber(),
+                        runOrTestName,
                         mTraceCountMap.get(device),
                         eventName);
         mTraceFilesMap.put(traceFile, name);
@@ -112,6 +165,7 @@ public class DeviceTraceCollector extends BaseDeviceMetricCollector {
                 super.testLog(entry.getValue(), LogDataType.PERFETTO, source);
             }
         }
+        mTraceFilesMap.clear();
     }
 
     public void setInstrumentationPkgName(String packageName) {
@@ -123,6 +177,7 @@ public class DeviceTraceCollector extends BaseDeviceMetricCollector {
         super.rebootStarted(device);
         // save previous trace running on this device.
         collectTraceFileFromDevice(device, "rebootStarted");
+        logTraceFiles();
     }
 
     @Override
diff --git a/src/com/android/tradefed/device/metric/FilePullerLogCollector.java b/src/com/android/tradefed/device/metric/FilePullerLogCollector.java
index 7996c7c0f..066b9f520 100644
--- a/src/com/android/tradefed/device/metric/FilePullerLogCollector.java
+++ b/src/com/android/tradefed/device/metric/FilePullerLogCollector.java
@@ -61,6 +61,7 @@ public class FilePullerLogCollector extends FilePullerDeviceMetricCollector {
 
         // Try to infer the type. This will be improved eventually, see todo on the class.
         String ext = FileUtil.getExtension(metricFile.getName()).toLowerCase();
+        String baseName = FileUtil.getBaseName(metricFile.getName());
         if (".hprof".equals(ext)) {
             return LogDataType.HPROF;
         } else if (".mp4".equals(ext)) {
@@ -69,14 +70,17 @@ public class FilePullerLogCollector extends FilePullerDeviceMetricCollector {
             return LogDataType.PB;
         } else if (".png".equals(ext)) {
             return LogDataType.PNG;
+        } else if (".ppm".equals(ext)) {
+            return LogDataType.PPM;
+        } else if (baseName.contains("winscope") || baseName.contains("uiTrace")) {
+            return LogDataType.WINSCOPE;
         } else if (".perfetto-trace".equals(ext)) {
             return LogDataType.PERFETTO;
         } else if (".zip".equals(ext)) {
             return LogDataType.ZIP;
         } else if (".uix".equals(ext)) {
             return LogDataType.UIX;
-        } else if (".textproto".equals(ext)
-                && FileUtil.getBaseName(metricFile.getName()).contains("_goldResult")) {
+        } else if (".textproto".equals(ext) && baseName.contains("_goldResult")) {
             return LogDataType.GOLDEN_RESULT_PROTO;
         } else if (".trace".equals(ext)) {
             return LogDataType.TRACE;
@@ -84,9 +88,8 @@ public class FilePullerLogCollector extends FilePullerDeviceMetricCollector {
             return LogDataType.BT_SNOOP_LOG;
         } else if (".json".equals(ext)) {
             return LogDataType.JSON;
-        } else if (FileUtil.getBaseName(metricFile.getName()).contains("winscope")
-                || FileUtil.getBaseName(metricFile.getName()).contains("uiTrace_")) {
-            return LogDataType.WINSCOPE;
+        } else if (".bmp".equals(ext)) {
+            return LogDataType.BMP;
         }
         return LogDataType.TEXT;
     }
diff --git a/src/com/android/tradefed/device/metric/JavaCodeCoverageCollector.java b/src/com/android/tradefed/device/metric/JavaCodeCoverageCollector.java
index 820b87faf..aab1f94fc 100644
--- a/src/com/android/tradefed/device/metric/JavaCodeCoverageCollector.java
+++ b/src/com/android/tradefed/device/metric/JavaCodeCoverageCollector.java
@@ -135,35 +135,35 @@ public final class JavaCodeCoverageCollector extends BaseDeviceMetricCollector
         }
 
         for (ITestDevice device : getRealDevices()) {
-            File testCoverage = null;
-            File coverageTarGz = null;
-            File untarDir = null;
-
             try (AdbRootElevator adbRoot = new AdbRootElevator(device)) {
-                try {
-                    if (mConfiguration.getCoverageOptions().isCoverageFlushEnabled()) {
-                        getCoverageFlusher(device).forceCoverageFlush();
-                    }
+                if (mConfiguration.getCoverageOptions().isCoverageFlushEnabled()) {
+                    getCoverageFlusher(device).forceCoverageFlush();
+                }
 
-                    // Pull and log the test coverage file.
-                    if (testCoveragePath != null) {
-                        if (!new File(testCoveragePath).isAbsolute()) {
-                            testCoveragePath =
-                                    "/sdcard/googletest/internal_use/" + testCoveragePath;
-                        }
-                        testCoverage = device.pullFile(testCoveragePath);
-                        if (testCoverage == null) {
-                            // Log a warning only, since multi-device tests will not have this file
-                            // on
-                            // all devices.
-                            CLog.w(
-                                    "Failed to pull test coverage file %s from the device.",
-                                    testCoveragePath);
-                        } else {
+                // Pull and log the test coverage file.
+                if (testCoveragePath != null) {
+                    if (!new File(testCoveragePath).isAbsolute()) {
+                        testCoveragePath = "/sdcard/googletest/internal_use/" + testCoveragePath;
+                    }
+                    File testCoverage = device.pullFile(testCoveragePath);
+                    if (testCoverage == null) {
+                        // Log a warning only, since multi-device tests will not have this file
+                        // on all devices.
+                        CLog.w(
+                                "Failed to pull test coverage file %s from the device.",
+                                testCoveragePath);
+                    } else {
+                        try {
                             saveCoverageMeasurement(testCoverage);
+                        } finally {
+                            FileUtil.deleteFile(testCoverage);
                         }
                     }
+                }
 
+                File coverageTarGz = null;
+                File untarDir = null;
+                try {
                     // Stream compressed coverage measurements from /data/misc/trace to the host.
                     coverageTarGz = FileUtil.createTempFile("java_coverage", ".tar.gz");
                     try (OutputStream out =
@@ -177,9 +177,7 @@ public final class JavaCodeCoverageCollector extends BaseDeviceMetricCollector
                                         TimeUnit.MILLISECONDS,
                                         1);
                         if (!CommandStatus.SUCCESS.equals(result.getStatus())) {
-                            CLog.e(
-                                    "Failed to stream coverage data from the device: %s",
-                                    result.toString());
+                            throw new IOException(result.toString());
                         }
                     }
 
@@ -189,14 +187,11 @@ public final class JavaCodeCoverageCollector extends BaseDeviceMetricCollector
                         saveCoverageMeasurement(new File(coveragePath));
                     }
                 } catch (IOException e) {
-                    throw new RuntimeException(e);
+                    CLog.e("Failed to stream coverage data from the device");
+                    CLog.e(e);
                 } finally {
-                    // Clean up local coverage files.
-                    FileUtil.deleteFile(testCoverage);
                     FileUtil.deleteFile(coverageTarGz);
                     FileUtil.recursiveDelete(untarDir);
-
-                    // Clean up device coverage files.
                     cleanUpDeviceCoverageFiles(device);
                 }
             }
@@ -210,7 +205,8 @@ public final class JavaCodeCoverageCollector extends BaseDeviceMetricCollector
                 mExecFileLoader.save(mergedCoverage, false);
                 logCoverageMeasurement(mergedCoverage);
             } catch (IOException e) {
-                throw new RuntimeException(e);
+                CLog.e("Failed to save merged coverage data.");
+                CLog.e(e);
             } finally {
                 mExecFileLoader = null;
                 FileUtil.deleteFile(mergedCoverage);
@@ -219,12 +215,17 @@ public final class JavaCodeCoverageCollector extends BaseDeviceMetricCollector
     }
 
     /** Saves Java coverage file data. */
-    private void saveCoverageMeasurement(File coverageFile) throws IOException {
+    private void saveCoverageMeasurement(File coverageFile) {
         if (shouldMergeCoverage()) {
             if (mExecFileLoader == null) {
                 mExecFileLoader = new ExecFileLoader();
             }
-            mExecFileLoader.load(coverageFile);
+            try {
+                mExecFileLoader.load(coverageFile);
+            } catch (IOException e) {
+                CLog.w("Failed to load coverage measurement %s.", coverageFile);
+                CLog.w(e);
+            }
         } else {
             logCoverageMeasurement(coverageFile);
         }
diff --git a/src/com/android/tradefed/invoker/DelegatedInvocationExecution.java b/src/com/android/tradefed/invoker/DelegatedInvocationExecution.java
index 02f5434d3..1ce5e8f28 100644
--- a/src/com/android/tradefed/invoker/DelegatedInvocationExecution.java
+++ b/src/com/android/tradefed/invoker/DelegatedInvocationExecution.java
@@ -55,6 +55,7 @@ import java.net.ServerSocket;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
+import java.util.Map.Entry;
 
 /** {@link InvocationExecution} which delegate the execution to another Tradefed binary. */
 public class DelegatedInvocationExecution extends InvocationExecution {
@@ -164,7 +165,7 @@ public class DelegatedInvocationExecution extends InvocationExecution {
             mStderrFile = FileUtil.createTempFile("stderr_delegate_", ".log", mTmpDelegatedDir);
             mStderr = new FileOutputStream(mStderrFile);
             mStdout = new FileOutputStream(mStdoutFile);
-            IRunUtil runUtil = createRunUtil(receiver.getSocketServerPort(), config);
+            IRunUtil runUtil = createRunUtil(receiver.getSocketServerPort(), config, delegator);
             CommandResult result = null;
             RuntimeException runtimeException = null;
             CLog.d("Command line: %s", commandLine);
@@ -231,12 +232,17 @@ public class DelegatedInvocationExecution extends InvocationExecution {
         FileUtil.deleteFile(mGlobalConfig);
     }
 
-    private IRunUtil createRunUtil(int port, IConfiguration config) throws IOException {
+    private IRunUtil createRunUtil(int port, IConfiguration config, TradefedDelegator delegator)
+            throws IOException {
         IRunUtil runUtil = new RunUtil();
         // Handle the global configs for the subprocess
         runUtil.unsetEnvVariable(GlobalConfiguration.GLOBAL_CONFIG_VARIABLE);
         runUtil.unsetEnvVariable(GlobalConfiguration.GLOBAL_CONFIG_SERVER_CONFIG_VARIABLE);
         runUtil.setEnvVariablePriority(EnvPriority.SET);
+        // Add the user injected environment
+        for (Entry<String, String> envKeyValue : delegator.getEnvironment().entrySet()) {
+            runUtil.setEnvVariable(envKeyValue.getKey(), envKeyValue.getValue());
+        }
         mGlobalConfig = createGlobalConfig();
         runUtil.setEnvVariable(
                 GlobalConfiguration.GLOBAL_CONFIG_VARIABLE, mGlobalConfig.getAbsolutePath());
diff --git a/src/com/android/tradefed/invoker/InvocationCacheHelper.java b/src/com/android/tradefed/invoker/InvocationCacheHelper.java
index 357bff890..c85826fa5 100644
--- a/src/com/android/tradefed/invoker/InvocationCacheHelper.java
+++ b/src/com/android/tradefed/invoker/InvocationCacheHelper.java
@@ -27,6 +27,7 @@ import com.android.tradefed.invoker.logger.InvocationMetricLogger;
 import com.android.tradefed.invoker.logger.InvocationMetricLogger.InvocationMetricKey;
 import com.android.tradefed.invoker.tracing.CloseableTraceScope;
 import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.result.proto.InvocationProtoResultReporter;
 import com.android.tradefed.result.proto.ModuleProtoResultReporter;
 import com.android.tradefed.util.CacheClientFactory;
 import com.android.tradefed.util.FileUtil;
@@ -45,6 +46,9 @@ import java.util.Map.Entry;
 /** Utility to handle uploading and looking up invocation cache results. */
 public class InvocationCacheHelper {
 
+    private static final String CACHE_ERROR = "%%%CACHE_ERROR%%%";
+    private static File sCacheDirectory;
+
     /** Describes the cache results. */
     public static class CacheInvocationResultDescriptor {
         private final boolean cacheHit;
@@ -68,14 +72,20 @@ public class InvocationCacheHelper {
      * Upload invocation results
      *
      * @param mainConfig
-     * @param protoResults
+     * @param protoResultsReporter
      * @param testInfo
      */
     public static void uploadInvocationResults(
-            IConfiguration mainConfig, File protoResults, TestInformation testInfo) {
+            IConfiguration mainConfig,
+            InvocationProtoResultReporter protoResultsReporter,
+            TestInformation testInfo) {
         if (testInfo.getDevices().size() > 1) {
             return;
         }
+        if (protoResultsReporter == null) {
+            return;
+        }
+        File protoResults = protoResultsReporter.getOutputFile();
         boolean emptyTestsDir = false;
         File invocationTestsDir = null;
         if (testInfo.getBuildInfo().getFile(BuildInfoFileKey.ROOT_DIRECTORY) == null
@@ -91,11 +101,11 @@ public class InvocationCacheHelper {
             CLog.d("Cannot handle testsdir.");
             return;
         }
+        File errorInCache = null;
         try (CloseableTraceScope ignored = new CloseableTraceScope("upload_invocation_results")) {
             String cacheInstance = mainConfig.getCommandOptions().getRemoteCacheInstanceName();
             ICacheClient cacheClient =
-                    CacheClientFactory.createCacheClient(
-                            CurrentInvocation.getWorkFolder(), cacheInstance);
+                    CacheClientFactory.createCacheClient(getCacheDirectory(), cacheInstance);
             invocationTestsDir =
                     FileUtil.createNamedTempDir(CurrentInvocation.getWorkFolder(), "invoc-cache");
             ExecutableAction action =
@@ -104,13 +114,19 @@ public class InvocationCacheHelper {
                             getCommonCommandLine(mainConfig.getCommandLine()),
                             computeEnvironment(mainConfig),
                             60000L);
-            ExecutableActionResult result = ExecutableActionResult.create(0, protoResults, null);
+            if (protoResultsReporter.stopCaching()) {
+                errorInCache = FileUtil.createTempFile("cache-error", ".txt");
+                FileUtil.writeToFile(CACHE_ERROR, errorInCache);
+            }
+            ExecutableActionResult result =
+                    ExecutableActionResult.create(0, protoResults, errorInCache);
             CLog.d("Uploading cache for %s and %s", action, protoResults);
             cacheClient.uploadCache(action, result);
         } catch (IOException | RuntimeException | InterruptedException e) {
             CLog.e(e);
         } finally {
             FileUtil.recursiveDelete(invocationTestsDir);
+            FileUtil.deleteFile(errorInCache);
         }
     }
 
@@ -138,11 +154,11 @@ public class InvocationCacheHelper {
             CLog.d("Cannot handle testsdir.");
             return new CacheInvocationResultDescriptor(false, null);
         }
+        ExecutableActionResult cachedResults = null;
         try (CloseableTraceScope ignored = new CloseableTraceScope("lookup_invocation_results")) {
             String cacheInstance = mainConfig.getCommandOptions().getRemoteCacheInstanceName();
             ICacheClient cacheClient =
-                    CacheClientFactory.createCacheClient(
-                            CurrentInvocation.getWorkFolder(), cacheInstance);
+                    CacheClientFactory.createCacheClient(getCacheDirectory(), cacheInstance);
             invocationTestsDir =
                     FileUtil.createNamedTempDir(CurrentInvocation.getWorkFolder(), "invoc-cache");
             ExecutableAction action =
@@ -154,10 +170,16 @@ public class InvocationCacheHelper {
             CLog.d("Looking up cache for %s", action);
             InvocationMetricLogger.addInvocationMetrics(
                     InvocationMetricKey.INVOCATION_RESULTS_CHECKING_CACHE, 1);
-            ExecutableActionResult cachedResults = cacheClient.lookupCache(action);
+            cachedResults = cacheClient.lookupCache(action);
             if (cachedResults == null) {
                 CLog.d("No cached results for the invocation.");
                 return null;
+            } else if (cachedResults.stdErr() != null &&
+                           FileUtil.readStringFromFile(cachedResults.stdErr()).contains(CACHE_ERROR)) {
+                InvocationMetricLogger.addInvocationMetrics(
+                        InvocationMetricKey.INVOCATION_CACHE_HIT_WITH_FAILURE, 1);
+                CLog.d("Cached invocation but with failures.");
+                return null;
             } else {
                 InvocationMetricLogger.addInvocationMetrics(
                         InvocationMetricKey.INVOCATION_CACHE_HIT, 1);
@@ -171,14 +193,16 @@ public class InvocationCacheHelper {
                                     metadata.get(ModuleProtoResultReporter.INVOCATION_ID_KEY));
                     CLog.d(details);
                 }
-                FileUtil.deleteFile(cachedResults.stdOut());
-                FileUtil.deleteFile(cachedResults.stdErr());
                 return new CacheInvocationResultDescriptor(true, details);
             }
         } catch (IOException | RuntimeException | InterruptedException e) {
             CLog.e(e);
         } finally {
             FileUtil.recursiveDelete(invocationTestsDir);
+            if (cachedResults != null) {
+                FileUtil.deleteFile(cachedResults.stdOut());
+                FileUtil.deleteFile(cachedResults.stdErr());
+            }
         }
         return null;
     }
@@ -212,10 +236,40 @@ public class InvocationCacheHelper {
             commandArray =
                     TradefedDelegator.clearCommandlineFromOneArg(commandArray, "invocation-data");
             commandArray = TradefedDelegator.clearCommandlineFromOneArg(commandArray, "build-id");
+            commandArray =
+                    TradefedDelegator.clearCommandlineFromOneArg(commandArray, "cts-build-id");
             commandArray = TradefedDelegator.clearCommandlineFromOneArg(commandArray, "serial");
+            commandArray =
+                    TradefedDelegator.clearCommandlineFromOneArg(
+                            commandArray, "extra-target-downloads");
+            commandArray =
+                    TradefedDelegator.clearCommandlineFromOneArg(commandArray, "gce-driver-param");
+            commandArray =
+                    TradefedDelegator.clearCommandlineFromOneArg(
+                            commandArray, "max-testcase-run-count");
+            commandArray =
+                    TradefedDelegator.clearCommandlineFromOneArg(
+                            commandArray, "max-testrun-run-count");
+            commandArray =
+                    TradefedDelegator.clearCommandlineFromOneArg(
+                            commandArray, "retry-strategy");
+            commandArray =
+                    TradefedDelegator.clearCommandlineFromOneArg(
+                            commandArray, "reboot-at-last-retry", true);
         } catch (ConfigurationException e) {
             throw new RuntimeException(e);
         }
         return Arrays.asList(commandArray);
     }
+
+    private static File getCacheDirectory() throws IOException {
+        if (sCacheDirectory == null) {
+            synchronized (InvocationCacheHelper.class) {
+                if (sCacheDirectory == null) {
+                    sCacheDirectory = FileUtil.createTempDir("invocation-cache-dir");
+                }
+            }
+        }
+        return sCacheDirectory;
+    }
 }
diff --git a/src/com/android/tradefed/invoker/InvocationExecution.java b/src/com/android/tradefed/invoker/InvocationExecution.java
index 1ebfa7f77..a2014c679 100644
--- a/src/com/android/tradefed/invoker/InvocationExecution.java
+++ b/src/com/android/tradefed/invoker/InvocationExecution.java
@@ -34,6 +34,7 @@ import com.android.tradefed.config.filter.GetPreviousPassedHelper;
 import com.android.tradefed.device.DeviceNotAvailableException;
 import com.android.tradefed.device.ITestDevice;
 import com.android.tradefed.device.NativeDevice;
+import com.android.tradefed.device.SnapuserdWaitPhase;
 import com.android.tradefed.device.StubDevice;
 import com.android.tradefed.device.cloud.GceAvdInfo;
 import com.android.tradefed.device.cloud.GceManager;
@@ -1180,6 +1181,11 @@ public class InvocationExecution implements IInvocationExecution {
         long start = System.currentTimeMillis();
         try (CloseableTraceScope ignored =
                 new CloseableTraceScope(InvocationMetricKey.test_execution.name())) {
+            TestInvocation.waitForSnapuserd(
+                    info,
+                    config,
+                    SnapuserdWaitPhase.BLOCK_BEFORE_TEST,
+                    TestInvocation.isSubprocess(config));
             GetPreviousPassedHelper previousPassHelper = new GetPreviousPassedHelper();
             // Add new exclude filters to global filters
             Set<String> previousPassedFilters = previousPassHelper.getPreviousPassedFilters(config);
diff --git a/src/com/android/tradefed/invoker/TestInvocation.java b/src/com/android/tradefed/invoker/TestInvocation.java
index 82742bad6..0b6f1a6dd 100644
--- a/src/com/android/tradefed/invoker/TestInvocation.java
+++ b/src/com/android/tradefed/invoker/TestInvocation.java
@@ -126,6 +126,7 @@ import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
@@ -368,8 +369,11 @@ public class TestInvocation implements ITestInvocation {
         } finally {
             mTestDone = true;
             long bugreportStartTime = System.currentTimeMillis();
+            boolean isSubprocess = isSubprocess(config);
+            boolean shouldSkipParentProcessLog =
+                    config.getCommandOptions().shouldSkipParentProcessLogcat();
             // Only capture logcat for TEST if we started the test phase.
-            if (mTestStarted) {
+            if (mTestStarted && (isSubprocess || !shouldSkipParentProcessLog)) {
                 for (ITestDevice device : context.getDevices()) {
                     invocationPath.reportLogs(device, listener, Stage.TEST);
                 }
@@ -642,8 +646,6 @@ public class TestInvocation implements ITestInvocation {
             logDeviceBatteryLevel(testInfo.getContext(), "setup -> test");
             mTestStarted = true;
             CurrentInvocation.setActionInProgress(ActionInProgress.TEST);
-            waitForSnapuserd(
-                    testInfo, config, SnapuserdWaitPhase.BLOCK_BEFORE_TEST, isSubprocess(config));
             invocationPath.runTests(testInfo, config, listener);
         } finally {
             if (mClient != null) {
@@ -1173,7 +1175,13 @@ public class TestInvocation implements ITestInvocation {
             if (!config.getPostProcessors().isEmpty()) {
                 ITestInvocationListener forwarder = new ResultAndLogForwarder(allListeners);
                 // Post-processors are the first layer around the final reporters.
-                for (IPostProcessor postProcessor : config.getPostProcessors()) {
+                List<IPostProcessor> postProcessors = config.getPostProcessors();
+                if (config.getCommandOptions().keepPostProcessorOrder()) {
+                    // reverse the post-processor list so that the first post-processor in the list
+                    // becomes the outermost post-processor and the first to receive events.
+                    Collections.reverse(postProcessors);
+                }
+                for (IPostProcessor postProcessor : postProcessors) {
                     if (postProcessor.isDisabled()) {
                         CLog.d("%s has been disabled. skipping.", postProcessor);
                     } else {
@@ -1315,11 +1323,8 @@ public class TestInvocation implements ITestInvocation {
                     reportHostLog(listener, config);
                     reportInvocationEnded(config, info.getContext(), listener, 0L);
                     // Still upload results for caching
-                    if (mInvocationProtoResultReporter != null
-                            && !mInvocationProtoResultReporter.stopCaching()) {
-                        InvocationCacheHelper.uploadInvocationResults(
-                                config, mInvocationProtoResultReporter.getOutputFile(), info);
-                    }
+                    InvocationCacheHelper.uploadInvocationResults(
+                            config, mInvocationProtoResultReporter, info);
                     return;
                 }
             }
@@ -1463,11 +1468,8 @@ public class TestInvocation implements ITestInvocation {
 
             performInvocation(config, info, invocationPath, listener, deviceInit);
             setExitCode(ExitCode.NO_ERROR, null);
-            if (mInvocationProtoResultReporter != null
-                    && !mInvocationProtoResultReporter.stopCaching()) {
-                InvocationCacheHelper.uploadInvocationResults(
-                        config, mInvocationProtoResultReporter.getOutputFile(), info);
-            }
+            InvocationCacheHelper.uploadInvocationResults(
+                    config, mInvocationProtoResultReporter, info);
         } catch (IOException e) {
             CLog.e(e);
         } finally {
@@ -2100,7 +2102,7 @@ public class TestInvocation implements ITestInvocation {
     }
 
     /** Always complete snapuserd before proceeding into test. */
-    private void waitForSnapuserd(
+    static void waitForSnapuserd(
             TestInformation testInfo,
             IConfiguration config,
             SnapuserdWaitPhase currentPhase,
diff --git a/src/com/android/tradefed/result/ConsoleResultReporter.java b/src/com/android/tradefed/result/ConsoleResultReporter.java
index 8723d566c..3d0ade1ea 100644
--- a/src/com/android/tradefed/result/ConsoleResultReporter.java
+++ b/src/com/android/tradefed/result/ConsoleResultReporter.java
@@ -221,7 +221,7 @@ public class ConsoleResultReporter extends TestResultListener
                         "%s: %s: %s (%dms)\n",
                         testTag,
                         testId.toString(),
-                        testResult.getStatus(),
+                        testResult.getResultStatus(),
                         testResult.getEndTime() - testResult.getStartTime()));
         String stack = testResult.getStackTrace();
         if (stack != null && !stack.isEmpty()) {
diff --git a/src/com/android/tradefed/result/LUCIResultReporter.java b/src/com/android/tradefed/result/LUCIResultReporter.java
index 7df8177ea..61bdc8a77 100644
--- a/src/com/android/tradefed/result/LUCIResultReporter.java
+++ b/src/com/android/tradefed/result/LUCIResultReporter.java
@@ -186,10 +186,7 @@ public class LUCIResultReporter extends CollectingTestListener
         for (TestRunResult runResult : runResults) {
             // Populate run name.
             StringBuilder runNameAndTimestamp = new StringBuilder();
-            if (!runResult.getRunMetrics().isEmpty()) {
-                String reportingUnit = runResult.getName();
-                runNameAndTimestamp.append(String.format("%s%s", reportingUnit, RESULT_SEPARATOR));
-            }
+            runNameAndTimestamp.append(String.format("%s%s", runResult.getName(), RESULT_SEPARATOR));
             // Get test result of test case(s) in the test run.
             Map<TestDescription, TestResult> testResultMap = runResult.getTestResults();
             // Loop over all test cases and populate test result for LUCI.
diff --git a/src/com/android/tradefed/result/ModuleResultsAndMetricsForwarder.java b/src/com/android/tradefed/result/ModuleResultsAndMetricsForwarder.java
index cc9300235..6b3cb1b94 100644
--- a/src/com/android/tradefed/result/ModuleResultsAndMetricsForwarder.java
+++ b/src/com/android/tradefed/result/ModuleResultsAndMetricsForwarder.java
@@ -17,7 +17,10 @@
 package com.android.tradefed.result;
 
 import com.android.tradefed.invoker.logger.CurrentInvocation.IsolationGrade;
+import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.metrics.proto.MetricMeasurement;
+import com.android.tradefed.result.error.InfraErrorIdentifier;
+import com.android.tradefed.result.proto.TestRecordProto;
 import com.android.tradefed.util.proto.TfMetricProtoUtil;
 
 import java.util.ArrayList;
@@ -36,6 +39,11 @@ public class ModuleResultsAndMetricsForwarder extends ResultAndLogForwarder {
     private List<String> mTestMappingSources = new ArrayList<>();
     private static final String TEST_MAPPING_SOURCE = "test_mapping_source";
     private String mModuleId = null;
+    private boolean mSkip = false;
+    private int mTestCount;
+    private int mTestsRan;
+    private String mCurrentRunName;
+    private boolean mTestRunFailed = false;
 
     public ModuleResultsAndMetricsForwarder(ITestInvocationListener... listeners) {
         super(listeners);
@@ -55,9 +63,9 @@ public class ModuleResultsAndMetricsForwarder extends ResultAndLogForwarder {
         mModuleId = moduleId;
     }
 
-    @Override
-    public void testRunStarted(String runName, int testCount) {
-        super.testRunStarted(mModuleId, testCount);
+    /** Whether or not to mark all the test cases skipped. */
+    public void setMarkTestsSkipped(boolean skip) {
+        mSkip = skip;
     }
 
     @Override
@@ -68,25 +76,38 @@ public class ModuleResultsAndMetricsForwarder extends ResultAndLogForwarder {
     @Override
     public void testRunStarted(String runName, int testCount, int attemptNumber, long startTime) {
         super.testRunStarted(mModuleId, testCount, attemptNumber, startTime);
+        mTestRunFailed = false;
+        mCurrentRunName = runName;
+        mTestCount = testCount;
     }
 
     @Override
     public void testStarted(TestDescription test) {
-        super.testStarted(test);
+        testStarted(test, System.currentTimeMillis());
     }
 
     @Override
     public void testStarted(TestDescription test, long startTime) {
         super.testStarted(test, startTime);
+        mTestsRan++;
+        if (mSkip) {
+            super.testIgnored(test);
+        }
     }
 
     @Override
     public void testFailed(TestDescription test, String trace) {
+        if (mSkip) {
+            return;
+        }
         super.testFailed(test, trace);
     }
 
     @Override
     public void testFailed(TestDescription test, FailureDescription failure) {
+        if (mSkip) {
+            return;
+        }
         super.testFailed(test, failure);
     }
 
@@ -112,16 +133,30 @@ public class ModuleResultsAndMetricsForwarder extends ResultAndLogForwarder {
     @Override
     public void testRunFailed(String errorMessage) {
         super.testRunFailed(errorMessage);
+        mTestRunFailed = true;
     }
 
     @Override
     public void testRunFailed(FailureDescription failure) {
         super.testRunFailed(failure);
+        mTestRunFailed = true;
     }
 
     @Override
     public void testRunEnded(
             long elapsedTime, HashMap<String, MetricMeasurement.Metric> runMetrics) {
+        if (!mTestRunFailed && (mTestsRan != mTestCount)) {
+            String error =
+                    String.format(
+                            "TestRun %s only ran %d out of %d expected tests.",
+                            mCurrentRunName, mTestsRan, mTestCount);
+            FailureDescription mismatch =
+                    FailureDescription.create(error)
+                            .setFailureStatus(TestRecordProto.FailureStatus.TEST_FAILURE)
+                            .setErrorIdentifier(InfraErrorIdentifier.EXPECTED_TESTS_MISMATCH);
+            CLog.e(error);
+            super.testRunFailed(mismatch);
+        }
         if (!IsolationGrade.NOT_ISOLATED.equals(mAttemptIsolation)) {
             runMetrics.put(
                     "run-isolated", TfMetricProtoUtil.stringToMetric(mAttemptIsolation.toString()));
@@ -129,10 +164,30 @@ public class ModuleResultsAndMetricsForwarder extends ResultAndLogForwarder {
             mAttemptIsolation = IsolationGrade.NOT_ISOLATED;
         }
         super.testRunEnded(elapsedTime, runMetrics);
+        mTestRunFailed = false;
+        mTestCount = 0;
+        mTestsRan = 0;
+        mCurrentRunName = null;
     }
 
     @Override
     public void testRunEnded(long elapsedTimeMillis, Map<String, String> runMetrics) {
+        if (!mTestRunFailed && (mTestsRan != mTestCount)) {
+            String error =
+                    String.format(
+                            "TestRun %s only ran %d out of %d expected tests.",
+                            mCurrentRunName, mTestsRan, mTestCount);
+            FailureDescription mismatch =
+                    FailureDescription.create(error)
+                            .setFailureStatus(TestRecordProto.FailureStatus.TEST_FAILURE)
+                            .setErrorIdentifier(InfraErrorIdentifier.EXPECTED_TESTS_MISMATCH);
+            CLog.e(error);
+            super.testRunFailed(mismatch);
+        }
         super.testRunEnded(elapsedTimeMillis, runMetrics);
+        mTestRunFailed = false;
+        mTestCount = 0;
+        mTestsRan = 0;
+        mCurrentRunName = null;
     }
 }
diff --git a/src/com/android/tradefed/result/resultdb/BatchChannel.java b/src/com/android/tradefed/result/resultdb/BatchChannel.java
new file mode 100644
index 000000000..3efbe8d5f
--- /dev/null
+++ b/src/com/android/tradefed/result/resultdb/BatchChannel.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.result.resultdb;
+
+import com.android.tradefed.log.LogUtil.CLog;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
+
+/** Helper class to batch upload test result and artifacts. */
+public class BatchChannel<T> {
+
+    private final int mMaxBatchSize;
+    // Item name, only used for logging.
+    private final String mItemName;
+    private final LinkedBlockingQueue<T> mItemQueue;
+    private final BatchUploadAction<T> mBatchUploadAction;
+    // Executor
+    private final ExecutorService executorService;
+
+    // Shutdown flag
+    private volatile boolean mShutdownRequested = false;
+
+    public BatchChannel(int maxBatchSize, String itemName, BatchUploadAction<T> batchUploadAction) {
+        if (maxBatchSize <= 0) {
+            throw new IllegalArgumentException("maxBatchSize must be positive.");
+        }
+        this.mItemName = itemName;
+        this.mItemQueue = new LinkedBlockingQueue<>();
+        this.executorService = Executors.newSingleThreadExecutor();
+        this.mMaxBatchSize = maxBatchSize;
+        this.mBatchUploadAction = batchUploadAction;
+        executorService.execute(() -> processQueue());
+    }
+
+    private void processQueue() {
+        CLog.i("Uploader Service started for %s. Batch Size: %s", mItemName, mMaxBatchSize);
+        List<T> batch = new ArrayList<>(mMaxBatchSize);
+        while (!mShutdownRequested || !mItemQueue.isEmpty()) {
+            try {
+                // Wait for 10 seconds for more items.
+                T item = mItemQueue.poll(10000L, TimeUnit.MILLISECONDS);
+                if (item != null) {
+                    batch.add(item);
+                }
+            } catch (InterruptedException e) {
+                // Exit if the thread is interrupted.
+                CLog.e(
+                        "Uploader Service interrupted while polling for %s:%s ",
+                        mItemName, e.getMessage());
+                Thread.currentThread().interrupt();
+                return;
+            }
+            boolean batchIsFull = batch.size() >= mMaxBatchSize;
+            if (batchIsFull) {
+                try {
+                    // Trigger batch upload if batch is full.
+                    mBatchUploadAction.uploadBatch(new ArrayList<>(batch));
+                    batch.clear();
+                } catch (Exception e) {
+                    // We log the error, we log the error and clear the batch to avoid infinite
+                    // loops on errors. This means that we will lose the batch.
+                    // TODO: ResultDB may reject the test result upload request if some fields are
+                    // invalid
+                    // (eg. test identifier is too long).
+                    // We need some way to surface this error to avoid silently dropping
+                    // test results.
+                    CLog.e("Failed to upload batch %s: %s", mItemName, e.getMessage());
+                    batch.clear();
+                    // continue the loop, upload other batches.
+                }
+            }
+        }
+
+        // Upload the last batch.
+        if (!batch.isEmpty()) {
+            try {
+                mBatchUploadAction.uploadBatch(new ArrayList<>(batch));
+            } catch (Exception e) {
+                // We log the error, we just log the error. This means that we will lose the batch.
+                CLog.e("Failed to upload batch %s: %s", mItemName, e.getMessage());
+            }
+        }
+    }
+
+    public void enqueue(T item) throws InterruptedException {
+        if (mShutdownRequested) {
+            throw new IllegalStateException(
+                    "Uploader service finalizing. Cannot enqueue new" + mItemName);
+        }
+        mItemQueue.put(item);
+    }
+
+    public void finalizeUpload() throws InterruptedException {
+        CLog.i("Uploader Service finalizing %s.", mItemName);
+        mShutdownRequested = true;
+        executorService.shutdown();
+        if (!executorService.awaitTermination(60, TimeUnit.SECONDS)) {
+            CLog.i(
+                    "Uploader tasks for %s did not finish within the timeout. Forcing shutdown...",
+                    mItemName);
+            executorService.shutdownNow();
+        } else {
+            CLog.i("Main thread: All pending batch uploads completed %s.", mItemName);
+        }
+    }
+
+    /** Action to be performed when a batch of items is ready to be uploaded. */
+    @FunctionalInterface
+    public interface BatchUploadAction<T> {
+        void uploadBatch(List<T> batch) throws Exception;
+    }
+}
diff --git a/src/com/android/tradefed/result/resultdb/IRecorderClient.java b/src/com/android/tradefed/result/resultdb/IRecorderClient.java
index ca3ebcc10..88bfa2424 100644
--- a/src/com/android/tradefed/result/resultdb/IRecorderClient.java
+++ b/src/com/android/tradefed/result/resultdb/IRecorderClient.java
@@ -15,6 +15,7 @@
  */
 package com.android.tradefed.result.resultdb;
 
+import com.android.resultdb.proto.Artifact;
 import com.android.resultdb.proto.Invocation;
 import com.android.resultdb.proto.TestResult;
 import com.android.resultdb.proto.UpdateInvocationRequest;
@@ -27,9 +28,30 @@ public interface IRecorderClient {
 
     public Invocation updateInvocation(UpdateInvocationRequest request);
 
+    /**
+     * Finalize the invocation. This method should be called after all test results and artifacts
+     * have been uploaded.
+     */
     public Invocation finalizeInvocation();
 
+    /**
+     * Enqueue a test result to upload to ResultDB.
+     *
+     * @param result The test result to upload.
+     */
     public void uploadTestResult(TestResult result);
 
-    public void finalizeTestResults();
+    /**
+     * Enqueue an artifact to upload to ResultDB.
+     *
+     * @param artifact The artifact to upload.
+     */
+    public void uploadArtifact(Artifact artifact);
+
+    /**
+     * Finalize the upload of test results and artifacts. This method should be called after all
+     * test results and artifacts have been uploaded. Any uploadTestResult and uploadArtifact calls
+     * after this method will be ignored.
+     */
+    public void finalizeUpload();
 }
diff --git a/src/com/android/tradefed/result/resultdb/OWNERS b/src/com/android/tradefed/result/resultdb/OWNERS
new file mode 100644
index 000000000..396844b6d
--- /dev/null
+++ b/src/com/android/tradefed/result/resultdb/OWNERS
@@ -0,0 +1,6 @@
+# LUCI Test team
+beining@google.com
+mwarton@google.com
+meiring@google.com
+mdraz@google.com
+nqmtuan@google.com
\ No newline at end of file
diff --git a/src/com/android/tradefed/result/resultdb/Client.java b/src/com/android/tradefed/result/resultdb/RecorderClient.java
similarity index 59%
rename from src/com/android/tradefed/result/resultdb/Client.java
rename to src/com/android/tradefed/result/resultdb/RecorderClient.java
index 6438fe0f5..5549b79fd 100644
--- a/src/com/android/tradefed/result/resultdb/Client.java
+++ b/src/com/android/tradefed/result/resultdb/RecorderClient.java
@@ -15,7 +15,10 @@
  */
 package com.android.tradefed.result.resultdb;
 
+import com.android.resultdb.proto.Artifact;
+import com.android.resultdb.proto.BatchCreateArtifactsRequest;
 import com.android.resultdb.proto.BatchCreateTestResultsRequest;
+import com.android.resultdb.proto.CreateArtifactRequest;
 import com.android.resultdb.proto.CreateInvocationRequest;
 import com.android.resultdb.proto.CreateTestResultRequest;
 import com.android.resultdb.proto.FinalizeInvocationRequest;
@@ -39,22 +42,20 @@ import io.grpc.ManagedChannel;
 import io.grpc.ManagedChannelBuilder;
 import io.grpc.Metadata;
 import io.grpc.MethodDescriptor;
+import io.grpc.StatusRuntimeException;
 import io.grpc.auth.MoreCallCredentials;
 
 import java.io.IOException;
-import java.util.ArrayList;
 import java.util.List;
 import java.util.UUID;
 import java.util.concurrent.Executors;
 
 /** ResultDB recorder client that uploads test results to ResultDB. */
-public class Client implements IRecorderClient {
+public class RecorderClient implements IRecorderClient {
 
     // The key for the update token used to create/update resources undera ResultDB invocation.
     private static final Metadata.Key<String> UPDATE_TOKEN_METADATA_KEY =
             Metadata.Key.of("update-token", Metadata.ASCII_STRING_MARSHALLER);
-    private final Uploader mUploader;
-    private final Thread mUploadThread;
     // The id of the ResultDB invocation used in upload results, update and finalize invocation
     // request. Currently only one ResultDB invocation per TF invocation is supported.
     private String mInvocationId;
@@ -62,47 +63,58 @@ public class Client implements IRecorderClient {
 
     private final RecorderGrpc.RecorderBlockingStub mStub;
     private final Credentials mCredentials;
-
-    // Both prod and staging Tradedfed instances should report to ResultDB prod server.
-    public static final String SERVER_ADDRESS = "results.api.cr.dev";
     public static final int SERVER_PORT = 443;
 
-    private Client() {
+    private final BatchChannel<TestResult> mTestResultChannel;
+
+    private final BatchChannel<Artifact> mArtifactChannel;
+
+    private RecorderClient(Boolean isStaging) {
         try {
-            mCredentials = GoogleCredentials.getApplicationDefault();
+            mCredentials =
+                    GoogleCredentials.getApplicationDefault()
+                            .createScoped("https://www.googleapis.com/auth/userinfo.email");
         } catch (IOException e) {
             throw new RuntimeException("Failed to get application default credentials", e);
         }
         ManagedChannel channel =
-                ManagedChannelBuilder.forAddress(SERVER_ADDRESS, SERVER_PORT)
+                ManagedChannelBuilder.forAddress(getServerAddress(isStaging), SERVER_PORT)
                         .executor(Executors.newCachedThreadPool())
-                        .maxInboundMessageSize(32 * 1024)
                         .build();
         RecorderGrpc.RecorderBlockingStub stub =
                 RecorderGrpc.newBlockingStub(channel)
                         .withCallCredentials(MoreCallCredentials.from(mCredentials))
                         .withInterceptors(recorderInterceptor());
         mStub = stub;
-        mUploader = new Uploader();
-        mUploadThread = new Thread(mUploader, "Recorder upload thread");
-        mUploadThread.setDaemon(true);
-        mUploadThread.start();
+        mTestResultChannel =
+                new BatchChannel<TestResult>(500, "test results", this::batchUploadTestResults);
+
+        mArtifactChannel = new BatchChannel<Artifact>(500, "artifacts", this::batchUploadArtifacts);
     }
 
-    public static IRecorderClient create(String invocationId, String updateToken) {
-        Client client = new Client();
+    public static IRecorderClient create(
+            String invocationId, String updateToken, Boolean isStaging) {
+        RecorderClient client = new RecorderClient(isStaging);
         client.mInvocationId = invocationId;
         client.mUpdateToken = updateToken;
         return client;
     }
 
-    public static IRecorderClient createWithNewInvocation(CreateInvocationRequest request) {
-        Client client = new Client();
+    public static IRecorderClient createWithNewInvocation(
+            CreateInvocationRequest request, Boolean isStaging) {
+        RecorderClient client = new RecorderClient(isStaging);
         Invocation invocation = client.createInvocation(request);
         client.mInvocationId = invocation.getName().replace("invocations/", "");
         return client;
     }
 
+    private String getServerAddress(Boolean isStaging) {
+        if (isStaging) {
+            return "staging.results.api.cr.dev";
+        }
+        return "results.api.cr.dev";
+    }
+
     // Interceptor that adds the update token to requests.
     private ClientInterceptor recorderInterceptor() {
         ClientInterceptor clientInterceptor =
@@ -174,109 +186,54 @@ public class Client implements IRecorderClient {
 
     @Override
     public void uploadTestResult(TestResult result) {
-        mUploader.enqueue(result);
+        try {
+            mTestResultChannel.enqueue(result);
+        } catch (InterruptedException e) {
+            CLog.e("Failed to enqueue test result: " + e.getMessage());
+        }
     }
 
     @Override
-    public void finalizeTestResults() {
-        mUploader.cancel();
+    public void uploadArtifact(Artifact artifact) {
         try {
-            mUploadThread.join();
+            mArtifactChannel.enqueue(artifact);
         } catch (InterruptedException e) {
-            CLog.e("Error joining upload thread: %s", e);
+            CLog.e("Failed to enqueue artifact: " + e.getMessage());
         }
     }
 
-    private class Uploader implements Runnable {
-        private static final int BATCH_SIZE = 500;
-
-        private final List<List<TestResult>> mPendingBatches = new ArrayList<>();
-        private List<TestResult> currentBatch = new ArrayList<>();
-        private volatile boolean mCanceled = false;
-
-        public void enqueue(TestResult result) {
-            if (mCanceled) {
-                throw new IllegalStateException(
-                        "Attempted to upload results after upload thread was cancelled");
-            }
-            synchronized (this) {
-                if (currentBatch.size() + 1 >= BATCH_SIZE) {
-                    mPendingBatches.add(currentBatch);
-                    currentBatch = new ArrayList<>();
-                    this.notifyAll();
-                }
-                currentBatch.add(result);
-            }
+    @Override
+    public void finalizeUpload() {
+        try {
+            mTestResultChannel.finalizeUpload();
+            mArtifactChannel.finalizeUpload();
+        } catch (InterruptedException e) {
+            CLog.e("Failed to finalize result or artifact upload: " + e.getMessage());
         }
+    }
 
-        public synchronized void forceUpload() {
-            synchronized (this) {
-                if (!currentBatch.isEmpty()) {
-                    mPendingBatches.add(currentBatch);
-                }
-                while (!mPendingBatches.isEmpty()) {
-                    int lastIndex = mPendingBatches.size() - 1;
-                    upload(mPendingBatches.remove(lastIndex));
-                }
-            }
+    private void batchUploadTestResults(List<TestResult> allResults) throws StatusRuntimeException {
+        BatchCreateTestResultsRequest.Builder request =
+                BatchCreateTestResultsRequest.newBuilder()
+                        .setInvocation(String.format("invocations/%s", mInvocationId))
+                        .setRequestId(UUID.randomUUID().toString());
+        for (TestResult result : allResults) {
+            request.addRequests(CreateTestResultRequest.newBuilder().setTestResult(result).build());
         }
 
-        public synchronized void cancel() {
-            CLog.i("Canceling recorder uploader");
-            mCanceled = true;
-            this.notifyAll();
-        }
+        mStub.batchCreateTestResults(request.build());
+        CLog.i("Uploaded %d results to invocation %s", allResults.size(), mInvocationId);
+    }
 
-        @Override
-        public void run() {
-            List<TestResult> uploadBatch = new ArrayList<TestResult>();
-            while (!mCanceled) {
-                synchronized (this) {
-                    // Wait with a timeout of 10 seconds when nothing to upload.
-                    if (mPendingBatches.isEmpty()) {
-                        try {
-                            this.wait(10000L);
-                        } catch (InterruptedException e) {
-                            // ignore
-                        }
-                    }
-                    if (!mPendingBatches.isEmpty()) {
-                        int lastIndex = mPendingBatches.size() - 1;
-                        CLog.i(
-                                "Starting batch upload of %d results",
-                                mPendingBatches.get(lastIndex).size());
-                        uploadBatch.addAll(mPendingBatches.remove(lastIndex));
-                    }
-                }
-                if (!uploadBatch.isEmpty()) {
-                    upload(uploadBatch);
-                    uploadBatch.clear();
-                }
-            }
-            // Upload any remaining results.
-            synchronized (this) {
-                if (!currentBatch.isEmpty()) {
-                    mPendingBatches.add(currentBatch);
-                }
-                while (!mPendingBatches.isEmpty()) {
-                    int lastIndex = mPendingBatches.size() - 1;
-                    upload(mPendingBatches.remove(lastIndex));
-                }
-            }
-            CLog.i("Uploader terminating");
+    private void batchUploadArtifacts(List<Artifact> allArtifacts) throws StatusRuntimeException {
+        BatchCreateArtifactsRequest.Builder request =
+                BatchCreateArtifactsRequest.newBuilder()
+                        .setParent(String.format("invocations/%s", mInvocationId));
+        for (Artifact artifact : allArtifacts) {
+            request.addRequests(CreateArtifactRequest.newBuilder().setArtifact(artifact).build());
         }
 
-        private void upload(List<TestResult> allResults) {
-            BatchCreateTestResultsRequest.Builder request =
-                    BatchCreateTestResultsRequest.newBuilder()
-                            .setInvocation(String.format("invocations/%s", mInvocationId))
-                            .setRequestId(UUID.randomUUID().toString());
-            for (TestResult result : allResults) {
-                request.addRequests(
-                        CreateTestResultRequest.newBuilder().setTestResult(result).build());
-            }
-            mStub.batchCreateTestResults(request.build());
-            CLog.i("Uploaded %d results to invocation %s", allResults.size(), mInvocationId);
-        }
+        mStub.batchCreateArtifacts(request.build());
+        CLog.i("Uploaded %d artifacts to invocation %s", allArtifacts.size(), mInvocationId);
     }
 }
diff --git a/src/com/android/tradefed/result/resultdb/ResultDBReporter.java b/src/com/android/tradefed/result/resultdb/ResultDBReporter.java
index 5f288e31c..fd3fbf0e4 100644
--- a/src/com/android/tradefed/result/resultdb/ResultDBReporter.java
+++ b/src/com/android/tradefed/result/resultdb/ResultDBReporter.java
@@ -15,10 +15,13 @@
  */
 package com.android.tradefed.result.resultdb;
 
+import com.android.resultdb.proto.Artifact;
 import com.android.resultdb.proto.CreateInvocationRequest;
 import com.android.resultdb.proto.FailureReason;
 import com.android.resultdb.proto.Invocation;
 import com.android.resultdb.proto.StringPair;
+import com.android.resultdb.proto.TestIdentifier;
+import com.android.resultdb.proto.TestIdentifierBase;
 import com.android.resultdb.proto.TestResult;
 import com.android.resultdb.proto.TestStatus;
 import com.android.resultdb.proto.Variant;
@@ -28,6 +31,7 @@ import com.android.tradefed.config.IConfigurationReceiver;
 import com.android.tradefed.config.Option;
 import com.android.tradefed.config.OptionClass;
 import com.android.tradefed.invoker.IInvocationContext;
+import com.android.tradefed.log.Log.LogLevel;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.metrics.proto.MetricMeasurement;
 import com.android.tradefed.result.FailureDescription;
@@ -43,14 +47,18 @@ import com.android.tradefed.result.proto.TestRecordProto.FailureStatus;
 import com.android.tradefed.result.retry.ISupportGranularResults;
 import com.android.tradefed.result.skipped.SkipReason;
 import com.android.tradefed.testtype.suite.ModuleDefinition;
+import com.android.tradefed.testtype.suite.SuiteTestFilter;
 import com.android.tradefed.util.MultiMap;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Strings;
 import com.google.common.collect.ImmutableSet;
+import com.google.protobuf.ByteString;
 import com.google.protobuf.util.Durations;
 import com.google.protobuf.util.Timestamps;
 
+import java.net.URI;
+import java.net.URISyntaxException;
 import java.security.NoSuchAlgorithmException;
 import java.security.SecureRandom;
 import java.util.Arrays;
@@ -58,21 +66,29 @@ import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 
-@OptionClass(alias = "resultdb-reporter")
 /** Result reporter that uploads test results to ResultDB. */
+@OptionClass(alias = "resultdb-reporter")
 public class ResultDBReporter
         implements ITestSummaryListener,
                 ILogSaverListener,
                 ISupportGranularResults,
                 IConfigurationReceiver {
 
-    public static final int MAX_SUMMARY_HTML_BYTES = 4096;
+    private static final String BUILD_ENV_INVOCATION_CONTEXT_KEY = "android-build-environment";
+
+    private static final int MAX_SUMMARY_HTML_BYTES = 4096;
+
+    private static final int MAX_PRIMARY_ERROR_MESSAGE_BYTES = 1024;
 
-    public static final int MAX_PRIMARY_ERROR_MESSAGE_BYTES = 1024;
+    // Link to redirect to the result page.
+    private static final String RESULT_LINK = "https://ci.chromium.org/ui/inv/invocations/%s";
 
     // Set containing the allowed variant module parameter keys
     private static final Set<String> ALLOWED_MODULE_PARAMETERS =
@@ -80,6 +96,11 @@ public class ResultDBReporter
     // Tag name for the test mapping source
     private static final String TEST_MAPPING_TAG = "test_mapping_source";
 
+    // Pattern to extract artifact id from logsaver URL.
+    private static final Pattern LOGSAVER_PATTERN =
+            Pattern.compile(
+                    "https:\\/\\/android-build.googleplex.com\\/builds\\/.+\\/.+\\/.+\\/.+\\/tests\\/\\d+\\/(.+)");
+
     @Option(name = "disable", description = "Set to true if reporter is disabled")
     private boolean mDisable = false;
 
@@ -89,7 +110,8 @@ public class ResultDBReporter
             description = "Create a local invocation if invocation is not provided in the context")
     private boolean mCreateLocalInvocation = false;
 
-    private Invocation mInvocation;
+    private IConfiguration mConfiguration;
+    private String mInvocationId;
     // Set to true if the reporter is responsible for updating and finalizing the invocation.
     private boolean mManageInvocation = false;
     private IRecorderClient mRecorder;
@@ -99,15 +121,18 @@ public class ResultDBReporter
     // Module level variant for test in the same test module.
     private Variant mModuleVariant;
     private String mCurrentModule;
+    private IInvocationContext mModuleContext;
     private TestResult mCurrentTestResult;
     // Counter for generate test result ID.
     private AtomicInteger mResultCounter = new AtomicInteger(0);
     // Base for generate test result ID.
     private String mResultIdBase;
+    // No more log associations can be uploaded with in Result reporter after this set to true.
+    private boolean mLogAssociationTerminated = false;
 
     @Override
     public void setConfiguration(IConfiguration configuration) {
-        // TODO: implement this method.
+        mConfiguration = configuration;
     }
 
     @Override
@@ -117,7 +142,61 @@ public class ResultDBReporter
 
     @Override
     public void logAssociation(String dataName, LogFile logFile) {
-        // TODO: implement this method.
+        if (mDisable) {
+            return;
+        }
+        CLog.v("Received association %s %s %s", dataName, logFile.getPath(), logFile.getUrl());
+        if (mLogAssociationTerminated) {
+            // TODO: Tradefed still upload logs after invocationEnd is called. We need to figure out
+            // how to upload these logs to ResultDB.
+            return;
+        }
+        String contentType = logFile.getType().getContentType();
+        Artifact.Builder artifactBuilder =
+                Artifact.newBuilder()
+                        .setArtifactId(getArtifactId(logFile))
+                        .setContentType(contentType)
+                        .setContents(ByteString.EMPTY);
+
+        if (mCurrentTestResult != null) {
+            TestIdentifier testId = mCurrentTestResult.getTestIdStructured();
+
+            artifactBuilder
+                    .setTestIdStructured(
+                            TestIdentifierBase.newBuilder()
+                                    .setModuleName(testId.getModuleName())
+                                    .setModuleScheme(testId.getModuleScheme())
+                                    .setCoarseName(testId.getCoarseName())
+                                    .setFineName(testId.getFineName())
+                                    .setCaseName(testId.getCaseName()))
+                    .setResultId(mCurrentTestResult.getResultId())
+                    .setTestStatus(mCurrentTestResult.getStatus());
+        }
+        mRecorder.uploadArtifact(artifactBuilder.build());
+    }
+
+    private String getArtifactId(LogFile logFile) {
+        String artifactId = "";
+        // Fallback to use the file name in the logFile path.
+        String[] pathSegments = logFile.getPath().split("/");
+        if (pathSegments.length > 0) {
+            artifactId = pathSegments[pathSegments.length - 1];
+        }
+        if (logFile.getUrl() == null) {
+            return artifactId;
+        }
+        Matcher m = LOGSAVER_PATTERN.matcher(logFile.getUrl());
+        if (!m.find()) {
+            return artifactId;
+        }
+        try {
+            // We need to decode the resourceId because the backend expects that it is unencoded,
+            // but TF gives as the url that is already encoded.
+            artifactId = new URI(m.group(1)).getPath();
+        } catch (URISyntaxException e) {
+            // ignore
+        }
+        return artifactId;
     }
 
     @Override
@@ -132,13 +211,14 @@ public class ResultDBReporter
     }
 
     @VisibleForTesting
-    IRecorderClient createRecorderClient(String invocationId, String updateToken) {
-        return Client.create(invocationId, updateToken);
+    IRecorderClient createRecorderClient(
+            String invocationId, String updateToken, Boolean isStaging) {
+        return RecorderClient.create(invocationId, updateToken, isStaging);
     }
 
     @VisibleForTesting
-    IRecorderClient createRecorderClient(CreateInvocationRequest request) {
-        return Client.createWithNewInvocation(request);
+    IRecorderClient createRecorderClient(CreateInvocationRequest request, Boolean isStaging) {
+        return RecorderClient.createWithNewInvocation(request, isStaging);
     }
 
     // Generate a random hexadecimal string of length 8.
@@ -161,16 +241,22 @@ public class ResultDBReporter
             String invocationId = context.getAttribute("resultdb_invocation_id");
             String updateToken = context.getAttribute("resultdb_invocation_update_token");
             if (!invocationId.isEmpty() && !updateToken.isEmpty()) {
-                mRecorder = createRecorderClient(invocationId, updateToken);
+                mInvocationId = invocationId;
+                mRecorder = createRecorderClient(invocationId, updateToken, isStaging(context));
             } else if (mCreateLocalInvocation) {
-                mInvocation = Invocation.newBuilder().setRealm("android:ants-experiment").build();
-                invocationId = randomUUIDString().toString();
+                Invocation invocation =
+                        Invocation.newBuilder()
+                                .setRealm("android:ants-experiment")
+                                .setIsExportRoot(true)
+                                .build();
+                mInvocationId = "u-" + randomUUIDString().toString();
                 mRecorder =
                         createRecorderClient(
                                 CreateInvocationRequest.newBuilder()
-                                        .setInvocation(mInvocation)
-                                        .setInvocationId("u-" + invocationId)
-                                        .build());
+                                        .setInvocation(invocation)
+                                        .setInvocationId(mInvocationId)
+                                        .build(),
+                                isStaging(context));
                 mManageInvocation = true;
 
             } else {
@@ -186,7 +272,8 @@ public class ResultDBReporter
             if (mRecorder != null) {
                 // Make sure we cancel the client, otherwise it will leak a thread since
                 // invocationEnded will be skipped.
-                mRecorder.finalizeTestResults();
+                mRecorder.finalizeUpload();
+                mLogAssociationTerminated = true;
             }
             throw new RuntimeException(e);
         }
@@ -214,6 +301,13 @@ public class ResultDBReporter
                             .putDef("target", Strings.nullToEmpty(primaryBuild.getBuildFlavor()));
         }
         mBaseVariant = mBaseVariantBuilder.build();
+        CLog.logAndDisplay(
+                LogLevel.INFO, "Result link: %s", String.format(RESULT_LINK, mInvocationId));
+    }
+
+    private Boolean isStaging(IInvocationContext context) {
+        String buildEnvironment = context.getAttribute(BUILD_ENV_INVOCATION_CONTEXT_KEY);
+        return !buildEnvironment.equals("prod");
     }
 
     @Override
@@ -236,10 +330,13 @@ public class ResultDBReporter
         if (mDisable) {
             return;
         }
-        mRecorder.finalizeTestResults();
+        mRecorder.finalizeUpload();
+        mLogAssociationTerminated = true;
         if (mManageInvocation) {
             mRecorder.finalizeInvocation();
         }
+        CLog.logAndDisplay(
+                LogLevel.INFO, "Result link: %s", String.format(RESULT_LINK, mInvocationId));
         // TODO: Update ResultDB invocation with information from TF invocation.
     }
 
@@ -248,6 +345,7 @@ public class ResultDBReporter
         if (mDisable) {
             return;
         }
+        mModuleContext = moduleContext;
         // Extract module informations.
         mCurrentModule = moduleContext.getConfigurationDescriptor().getModuleName();
         mModuleVariant = getModuleVariant(moduleContext.getAttributes());
@@ -269,14 +367,79 @@ public class ResultDBReporter
 
     @Override
     public void testModuleEnded() {
-        // Clear module variant.
+        // Clear module context.
+        mModuleContext = null;
         mModuleVariant = null;
     }
 
     @Override
     public void testRunEnded(
             long elapsedTimeMillis, HashMap<String, MetricMeasurement.Metric> runMetrics) {
-        // TODO: implement this method.
+        if (mDisable) {
+            return;
+        }
+        try {
+            reportDemotedTests();
+        } catch (RuntimeException e) {
+            CLog.e("error during skip reporting:");
+            CLog.e(e);
+        }
+    }
+
+    private void reportDemotedTests() {
+        String moduleAbi = null;
+        String moduleName = null;
+        if (mModuleContext != null) {
+            moduleAbi = mModuleContext.getAttribute(ModuleDefinition.MODULE_ABI);
+            moduleName = mModuleContext.getAttribute(ModuleDefinition.MODULE_NAME);
+        }
+        Variant.Builder variantBuilder = Variant.newBuilder();
+        if (mModuleVariant != null) {
+            variantBuilder = variantBuilder.mergeFrom(mModuleVariant);
+        }
+        if (mBaseVariant != null) {
+            variantBuilder = variantBuilder.mergeFrom(mBaseVariant);
+        }
+        for (Entry<String, SkipReason> entry :
+                mConfiguration.getSkipManager().getDemotedTests().entrySet()) {
+            String key = entry.getKey();
+            SuiteTestFilter filter = SuiteTestFilter.createFrom(key);
+            // If module filter has an ABI, we expect the filter to match it to be applicable
+            // not having it is a bit ambiguous so we default to report for all abi similar
+            // to how filters are applied.
+            if (filter.getAbi() != null && !filter.getAbi().equals(moduleAbi)) {
+                continue;
+            }
+            if (!filter.getName().equals(moduleName)) {
+                continue;
+            }
+            if (filter.getTest() == null) {
+                continue;
+            }
+            TestDescription test = TestDescription.fromString(filter.getTest());
+            SkipReason skippedReason = entry.getValue();
+            String summaryHtml =
+                    ResultDBUtil.testSkipReasonToSummaryHtml(skippedReason, "Demotion");
+
+            TestResult currentTest =
+                    TestResult.newBuilder()
+                            .setTestIdStructured(
+                                    ResultDBUtil.toTestIdentifier(
+                                            mCurrentModule, variantBuilder.build(), test))
+                            .setResultId(
+                                    String.format(
+                                            "%s-%05d",
+                                            mResultIdBase, mResultCounter.incrementAndGet()))
+                            .setStartTime(Timestamps.fromMillis(currentTimestamp()))
+                            .setStatus(TestStatus.SKIP)
+                            .setExpected(true)
+                            .setSummaryHtml(
+                                    ResultDBUtil.truncateString(
+                                            summaryHtml, MAX_SUMMARY_HTML_BYTES))
+                            .build();
+            mRecorder.uploadTestResult(currentTest);
+            CLog.d("Backfilled %s SKIPPED", currentTest);
+        }
     }
 
     @Override
@@ -336,20 +499,18 @@ public class ResultDBReporter
         if (mBaseVariant != null) {
             variantBuilder = variantBuilder.mergeFrom(mBaseVariant);
         }
+
         mCurrentTestResult =
                 TestResult.newBuilder()
-                        // TODO: Use test id format designed in go/resultdb-test-hierarchy-proposal
-                        .setTestId(
-                                String.format(
-                                        "ants://%s/%s/%s",
-                                        mCurrentModule, test.getClassName(), test.getTestName()))
+                        .setTestIdStructured(
+                                ResultDBUtil.toTestIdentifier(
+                                        mCurrentModule, variantBuilder.build(), test))
                         .setResultId(
                                 String.format(
                                         "%s-%05d", mResultIdBase, mResultCounter.incrementAndGet()))
                         .setStartTime(Timestamps.fromMillis(startTime))
                         .setStatus(TestStatus.PASS)
                         .setExpected(true)
-                        .setVariant(variantBuilder.build())
                         .build();
     }
 
@@ -394,15 +555,8 @@ public class ResultDBReporter
             return;
         }
 
-        // ResultDB does not yet have a skip reason field, we put them in the
-        // summary HTML field and test artifact for now.
-        String summaryHtml = "";
-        if (!Strings.isNullOrEmpty(reason.getBugId())) {
-            summaryHtml += "bug_id: " + reason.getBugId() + "<br>";
-        }
-        if (!Strings.isNullOrEmpty(reason.getTrigger())) {
-            summaryHtml += "trigger: " + reason.getTrigger() + "<br>";
-        }
+        String summaryHtml = ResultDBUtil.testSkipReasonToSummaryHtml(reason, null);
+
         // TODO: Skip reason can be too long to fit in any test result field.
         // Upload it as test artifact.
 
@@ -410,7 +564,8 @@ public class ResultDBReporter
                 mCurrentTestResult.toBuilder()
                         .setStatus(TestStatus.SKIP)
                         .setExpected(true)
-                        .setSummaryHtml(summaryHtml)
+                        .setSummaryHtml(
+                                ResultDBUtil.truncateString(summaryHtml, MAX_SUMMARY_HTML_BYTES))
                         .build();
     }
 
diff --git a/src/com/android/tradefed/result/resultdb/ResultDBUtil.java b/src/com/android/tradefed/result/resultdb/ResultDBUtil.java
index a01aec4d6..f0b48d0e2 100644
--- a/src/com/android/tradefed/result/resultdb/ResultDBUtil.java
+++ b/src/com/android/tradefed/result/resultdb/ResultDBUtil.java
@@ -15,6 +15,13 @@
  */
 package com.android.tradefed.result.resultdb;
 
+import com.android.resultdb.proto.TestIdentifier;
+import com.android.resultdb.proto.Variant;
+import com.android.tradefed.result.TestDescription;
+import com.android.tradefed.result.skipped.SkipReason;
+
+import com.google.common.base.Strings;
+
 import java.nio.charset.StandardCharsets;
 
 /** Utility class for ResultDB reporter. */
@@ -89,4 +96,68 @@ public final class ResultDBUtil {
         }
         return validKey;
     }
+
+    /**
+     * Converts a test skip reason to a summary HTML string. ResultDB does not yet have a skip
+     * reason field, we put them in the summary HTML field and test artifact for now. The return
+     * string can be longer than the summary HTML field limit, caller should truncate it if needed.
+     */
+    public static String testSkipReasonToSummaryHtml(SkipReason reason, String skipReasonType) {
+        StringBuilder summaryHtml = new StringBuilder();
+        if (!Strings.isNullOrEmpty(reason.getBugId())) {
+            summaryHtml.append("bug_id: ").append(reason.getBugId()).append("<br>");
+        }
+        if (!Strings.isNullOrEmpty(reason.getTrigger())) {
+            summaryHtml.append("trigger: ").append(reason.getTrigger()).append("<br>");
+        }
+        if (!Strings.isNullOrEmpty(skipReasonType)) {
+            summaryHtml.append("skip_reason_type: ").append(skipReasonType).append("<br>");
+        }
+        if (!Strings.isNullOrEmpty(reason.getReason())) {
+            summaryHtml.append("reason: ").append(reason.getReason()).append("<br>");
+        }
+        return summaryHtml.toString();
+    }
+
+    /**
+     * Converts a TestDescription to a TestIdentifier.
+     *
+     * @param moduleName the module name
+     * @param moduleVariant the module variant
+     * @param testDescription the test description
+     * @return the ResultDB test identifier. This test identifier is not guaranteed to be valid
+     *     (i.e. ResultDB may reject it, returning a invalid_argument error). This is because
+     *     ResultDB has more strict requirements on the test identifier, such as the field length
+     *     and character set.
+     */
+    public static TestIdentifier toTestIdentifier(
+            String moduleName, Variant moduleVariant, TestDescription testDescription) {
+
+        String fullClassName = testDescription.getClassName();
+        int lastDotIndex = fullClassName.lastIndexOf('.');
+
+        String packageName;
+        String className;
+        if (fullClassName.isEmpty()) {
+            packageName = "empty-package";
+            className = "empty-class";
+        } else if (lastDotIndex == -1) {
+            packageName = "empty-package";
+            className = fullClassName;
+        } else {
+            packageName = fullClassName.substring(0, lastDotIndex);
+            className = fullClassName.substring(lastDotIndex + 1);
+        }
+        if (Strings.isNullOrEmpty(moduleName)) {
+            moduleName = "empty-module";
+        }
+        return TestIdentifier.newBuilder()
+                .setModuleName(moduleName)
+                .setModuleScheme("junit")
+                .setModuleVariant(moduleVariant)
+                .setCoarseName(packageName)
+                .setFineName(className)
+                .setCaseName(testDescription.getTestName())
+                .build();
+    }
 }
diff --git a/src/com/android/tradefed/result/resultdb/StubClient.java b/src/com/android/tradefed/result/resultdb/StubClient.java
index 7a50ea07c..dfd3da3cf 100644
--- a/src/com/android/tradefed/result/resultdb/StubClient.java
+++ b/src/com/android/tradefed/result/resultdb/StubClient.java
@@ -15,6 +15,7 @@
  */
 package com.android.tradefed.result.resultdb;
 
+import com.android.resultdb.proto.Artifact;
 import com.android.resultdb.proto.Invocation;
 import com.android.resultdb.proto.TestResult;
 import com.android.resultdb.proto.UpdateInvocationRequest;
@@ -25,6 +26,7 @@ import java.util.List;
 /** Stub implementation of IRecorderClient for testing. */
 class StubClient implements IRecorderClient {
     private List<TestResult> mTestResults = new ArrayList<>();
+    private List<Artifact> mArtifacts = new ArrayList<>();
     private Invocation mInvocation;
 
     public static StubClient create() {
@@ -49,16 +51,25 @@ class StubClient implements IRecorderClient {
         mTestResults.add(result);
     }
 
+    @Override
+    public void uploadArtifact(Artifact artifact) {
+        mArtifacts.add(artifact);
+    }
+
     public List<TestResult> getTestResults() {
         return mTestResults;
     }
 
+    public List<Artifact> getArtifacts() {
+        return mArtifacts;
+    }
+
     public Invocation getInvocation() {
         return mInvocation;
     }
 
     @Override
-    public void finalizeTestResults() {
+    public void finalizeUpload() {
         // Do nothing.
     }
 }
diff --git a/src/com/android/tradefed/result/skipped/SkipFeature.java b/src/com/android/tradefed/result/skipped/SkipFeature.java
index 898ad3922..75c102811 100644
--- a/src/com/android/tradefed/result/skipped/SkipFeature.java
+++ b/src/com/android/tradefed/result/skipped/SkipFeature.java
@@ -81,30 +81,40 @@ public class SkipFeature
     public FeatureResponse execute(FeatureRequest request) {
         FeatureResponse.Builder responseBuilder = FeatureResponse.newBuilder();
         if (mConfig != null) {
-            boolean presubmit = InvocationContext.isPresubmit(mInfo.getContext());
-            MultiPartResponse.Builder multiPartBuilder = MultiPartResponse.newBuilder();
-            multiPartBuilder.addResponsePart(
-                    PartResponse.newBuilder().setKey(DELIMITER_NAME).setValue(ESCAPED_DELIMITER));
-            multiPartBuilder.addResponsePart(
-                    PartResponse.newBuilder()
-                            .setKey(PRESUBMIT)
-                            .setValue(Boolean.toString(presubmit)));
-            multiPartBuilder.addResponsePart(
-                    PartResponse.newBuilder()
-                            .setKey(SKIPPED_MODULES)
-                            .setValue(
-                                    Joiner.on(DELIMITER)
-                                            .join(mConfig.getSkipManager().getUnchangedModules())));
-            multiPartBuilder.addResponsePart(
-                    PartResponse.newBuilder()
-                            .setKey(IMAGE_DIGESTS)
-                            .setValue(
-                                    Joiner.on(DELIMITER)
-                                            .join(
-                                                    serializeDigest(
-                                                            mConfig.getSkipManager()
-                                                                    .getImageToDigest()))));
-            responseBuilder.setMultiPartResponse(multiPartBuilder);
+            if (!mConfig.getSkipManager().isConsideredForContentAnalysis()) {
+                responseBuilder.setErrorInfo(
+                        ErrorInfo.newBuilder()
+                                .setErrorTrace("considered-for-content-analysis=false"));
+            } else {
+                boolean presubmit = InvocationContext.isPresubmit(mInfo.getContext());
+                MultiPartResponse.Builder multiPartBuilder = MultiPartResponse.newBuilder();
+                multiPartBuilder.addResponsePart(
+                        PartResponse.newBuilder()
+                                .setKey(DELIMITER_NAME)
+                                .setValue(ESCAPED_DELIMITER));
+                multiPartBuilder.addResponsePart(
+                        PartResponse.newBuilder()
+                                .setKey(PRESUBMIT)
+                                .setValue(Boolean.toString(presubmit)));
+                multiPartBuilder.addResponsePart(
+                        PartResponse.newBuilder()
+                                .setKey(SKIPPED_MODULES)
+                                .setValue(
+                                        Joiner.on(DELIMITER)
+                                                .join(
+                                                        mConfig.getSkipManager()
+                                                                .getUnchangedModules())));
+                multiPartBuilder.addResponsePart(
+                        PartResponse.newBuilder()
+                                .setKey(IMAGE_DIGESTS)
+                                .setValue(
+                                        Joiner.on(DELIMITER)
+                                                .join(
+                                                        serializeDigest(
+                                                                mConfig.getSkipManager()
+                                                                        .getImageToDigest()))));
+                responseBuilder.setMultiPartResponse(multiPartBuilder);
+            }
         } else {
             responseBuilder.setErrorInfo(
                     ErrorInfo.newBuilder().setErrorTrace("Configuration not set."));
diff --git a/src/com/android/tradefed/result/skipped/SkipManager.java b/src/com/android/tradefed/result/skipped/SkipManager.java
index d4190fdf6..0fbdced69 100644
--- a/src/com/android/tradefed/result/skipped/SkipManager.java
+++ b/src/com/android/tradefed/result/skipped/SkipManager.java
@@ -360,4 +360,8 @@ public class SkipManager implements IDisableable {
     public boolean reportInvocationSkippedModule() {
         return mReportInvocationModuleSkipped;
     }
+
+    public boolean isConsideredForContentAnalysis() {
+        return mConsideredForContent;
+    }
 }
diff --git a/src/com/android/tradefed/retry/BaseRetryDecision.java b/src/com/android/tradefed/retry/BaseRetryDecision.java
index a612aa673..490e17341 100644
--- a/src/com/android/tradefed/retry/BaseRetryDecision.java
+++ b/src/com/android/tradefed/retry/BaseRetryDecision.java
@@ -20,6 +20,7 @@ import com.android.tradefed.config.IConfigurationReceiver;
 import com.android.tradefed.config.Option;
 import com.android.tradefed.device.DeviceNotAvailableException;
 import com.android.tradefed.device.ITestDevice;
+import com.android.tradefed.device.NativeDevice;
 import com.android.tradefed.device.StubDevice;
 import com.android.tradefed.device.internal.DeviceResetHandler;
 import com.android.tradefed.device.internal.DeviceSnapshotHandler;
@@ -213,7 +214,9 @@ public class BaseRetryDecision
         if (mRebootAtLastRetry) {
             args.add("--reboot-at-last-retry");
         }
-        args.addAll(List.of("--retry-isolation-grade", mRetryIsolationGrade.toString()));
+        if (!IsolationGrade.NOT_ISOLATED.equals(mRetryIsolationGrade)) {
+            args.addAll(List.of("--retry-isolation-grade", mRetryIsolationGrade.toString()));
+        }
         for (String filterEntry : mSkipRetryingSet) {
             args.add("--skip-retrying-list");
             args.add(filterEntry);
@@ -376,31 +379,25 @@ public class BaseRetryDecision
             moduleSkipList.addAll(mSkipRetryingSet);
         }
 
-        boolean shouldRetry = false;
         long retryStartTime = System.currentTimeMillis();
-        if (test instanceof ITestFilterReceiver || test instanceof ITestFileFilterReceiver) {
-            // Record the attempt for the previous failed tests.
-            mRetryTracker.recordTestRun(previousResults, attemptJustExecuted, moduleSkipList);
 
+        // Record the attempt for the previous failed tests.
+        mRetryTracker.recordTestRun(previousResults, attemptJustExecuted, moduleSkipList);
+
+        // Check if we should retry.
+        boolean shouldRetry = mRetryTracker.shouldRetry();
+
+        if (test instanceof ITestFilterReceiver || test instanceof ITestFileFilterReceiver) {
             // Setup exclude filters.
             mExcludeManager.resetDefaultFilters();
             mExcludeManager.addExcludeFilters(mRetryTracker.getExcludedTests());
-
-            // Check if we should retry.
-            shouldRetry = mRetryTracker.shouldRetry();
-
-            if (shouldRetry && !isAlreadyRecovered) {
-                // In case of retry, go through the recovery routine
-                recoverStateOfDevices(getDevices(), attemptJustExecuted, module);
-            }
         } else if (test instanceof IAutoRetriableTest) {
             // Routine for IRemoteTest that don't support filters but still needs retry.
             IAutoRetriableTest autoRetryTest = (IAutoRetriableTest) test;
-            shouldRetry =
-                    autoRetryTest.shouldRetry(attemptJustExecuted, previousResults, moduleSkipList);
-            if (shouldRetry && !isAlreadyRecovered) {
-                recoverStateOfDevices(getDevices(), attemptJustExecuted, module);
-            }
+            shouldRetry = (
+                shouldRetry &&
+                autoRetryTest.shouldRetry(attemptJustExecuted, previousResults, moduleSkipList)
+            );
         } else {
             CLog.d(
                     "%s does not implement ITestFilterReceiver or ITestFileFilterReceiver or "
@@ -408,6 +405,11 @@ public class BaseRetryDecision
                     test);
             return false;
         }
+
+        if (shouldRetry && !isAlreadyRecovered) {
+            recoverStateOfDevices(getDevices(), attemptJustExecuted, module);
+        }
+
         long retryCost = System.currentTimeMillis() - retryStartTime;
         if (!shouldRetry) {
             retryCost = 0L;
@@ -514,6 +516,11 @@ public class BaseRetryDecision
             try (CloseableTraceScope ignored = new CloseableTraceScope("reboot_isolation")) {
                 for (ITestDevice device : devices) {
                     device.reboot();
+                    // Force content provider to re-issue an install to ensure readiness for tests
+                    // retrying
+                    if (device instanceof NativeDevice) {
+                        ((NativeDevice) device).resetContentProviderSetup();
+                    }
                 }
                 CurrentInvocation.setModuleIsolation(IsolationGrade.REBOOT_ISOLATED);
                 CurrentInvocation.setRunIsolation(IsolationGrade.REBOOT_ISOLATED);
@@ -553,6 +560,13 @@ public class BaseRetryDecision
                                     .getInvocationData()
                                     .containsKey(SubprocessTfLauncher.SUBPROCESS_TAG_NAME)
                             && !mUseSnapshotForReset));
+            for (ITestDevice device : devices) {
+                // Force content provider to re-issue an install to ensure readiness for tests
+                // retrying
+                if (device instanceof NativeDevice) {
+                    ((NativeDevice) device).resetContentProviderSetup();
+                }
+            }
         } finally {
             InvocationMetricLogger.addInvocationPairMetrics(
                     InvocationMetricKey.RESET_RETRY_ISOLATION_PAIR,
@@ -589,6 +603,7 @@ public class BaseRetryDecision
         if (module.getId() != null) {
             InvocationMetricLogger.addInvocationMetrics(
                     InvocationMetricKey.DEVICE_RESET_MODULES, module.getId());
+            module.getModuleTestInformation().properties().clear();
         }
         // Run all preparers including optionally suite level ones.
         Throwable preparationException =
diff --git a/src/com/android/tradefed/retry/ResultAggregator.java b/src/com/android/tradefed/retry/ResultAggregator.java
index e4da4dab0..5784582d3 100644
--- a/src/com/android/tradefed/retry/ResultAggregator.java
+++ b/src/com/android/tradefed/retry/ResultAggregator.java
@@ -125,6 +125,7 @@ public class ResultAggregator extends CollectingTestListener {
         mRetryStrategy = strategy;
         MergeStrategy mergeStrategy = MergeStrategy.getMergeStrategy(mRetryStrategy);
         setMergeStrategy(mergeStrategy);
+        setIsAggregrateMetrics(true);
     }
 
     /** Sets the new reporting. */
diff --git a/src/com/android/tradefed/retry/RetryLogSaverResultForwarder.java b/src/com/android/tradefed/retry/RetryLogSaverResultForwarder.java
index 26c5f1f45..1039c3096 100644
--- a/src/com/android/tradefed/retry/RetryLogSaverResultForwarder.java
+++ b/src/com/android/tradefed/retry/RetryLogSaverResultForwarder.java
@@ -30,7 +30,20 @@ public class RetryLogSaverResultForwarder extends LogSaverResultForwarder {
 
     public RetryLogSaverResultForwarder(
             ILogSaver logSaver, List<ITestInvocationListener> listeners, IConfiguration config) {
+        this(logSaver, listeners, config, 0);
+    }
+
+    /**
+     * Constructor with prevAttempts not tracked already. prevAttempts will likely come from setup
+     * retries.
+     */
+    public RetryLogSaverResultForwarder(
+            ILogSaver logSaver,
+            List<ITestInvocationListener> listeners,
+            IConfiguration config,
+            int prevAttempts) {
         super(logSaver, listeners, config);
+        mAttemptNumber = prevAttempts;
     }
 
     @Override
@@ -54,4 +67,9 @@ public class RetryLogSaverResultForwarder extends LogSaverResultForwarder {
     public void incrementAttempt() {
         mAttemptNumber++;
     }
+
+    // returns the current attempt number so that events can be back-filled manually if needed.
+    public int getCurrentAttempt() {
+        return mAttemptNumber;
+    }
 }
diff --git a/src/com/android/tradefed/targetprep/DeviceFlashPreparer.java b/src/com/android/tradefed/targetprep/DeviceFlashPreparer.java
index c263a2b07..d745df556 100644
--- a/src/com/android/tradefed/targetprep/DeviceFlashPreparer.java
+++ b/src/com/android/tradefed/targetprep/DeviceFlashPreparer.java
@@ -45,6 +45,7 @@ import com.android.tradefed.result.error.DeviceErrorIdentifier;
 import com.android.tradefed.result.error.InfraErrorIdentifier;
 import com.android.tradefed.retry.BaseRetryDecision;
 import com.android.tradefed.targetprep.IDeviceFlasher.UserDataFlashOption;
+import com.android.tradefed.testtype.ITestInformationReceiver;
 import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
 import com.android.tradefed.util.IRunUtil;
@@ -55,7 +56,9 @@ import com.android.tradefed.util.image.IncrementalImageUtil;
 import java.io.File;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.HashMap;
 import java.util.HashSet;
+import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
 
@@ -114,6 +117,18 @@ public abstract class DeviceFlashPreparer extends BaseTargetPreparer
             description = "whether or not to skip post-flashing setup steps")
     private boolean mSkipPostFlashingSetup = false;
 
+    @Option(
+            name = "skip-bootloader-version-check",
+            description = "Allows to ignore bootloader version and force it installed.")
+    private boolean mSkipBootloaderVersionCheck = false;
+
+    @Option(
+            name = "ignore-fastboot-failed-message",
+            description =
+                    "Allows to ignore any FAILED message in fastboot output. This shouldn't be used"
+                            + " without a good reason.")
+    private boolean mIgnoreFastbootFailedMessage = false;
+
     @Option(name = "wipe-timeout",
             description = "the timeout for the command of wiping user data.", isTimeVal = true)
     private long mWipeTimeout = 4 * 60 * 1000;
@@ -141,7 +156,7 @@ public abstract class DeviceFlashPreparer extends BaseTargetPreparer
     @Option(
             name = "cancel-ota-snapshot",
             description = "In case an OTA snapshot is in progress, cancel it.")
-    private boolean mCancelSnapshot = false;
+    private boolean mCancelSnapshot = true;
 
     @Option(
             name = "incremental-flashing",
@@ -223,6 +238,11 @@ public abstract class DeviceFlashPreparer extends BaseTargetPreparer
             description = "Generate snapshot using the merkle tree on device instead of baseline.")
     private boolean mUseMerkleTreeComparison = true;
 
+    @Option(
+            name = "flasher-extra-metadata",
+            description = "Key values that will be passed to the flasher implementation.")
+    private Map<String, String> mFlasherMetadata = new HashMap<>();
+
     private IncrementalImageUtil mIncrementalImageUtil;
     private IConfiguration mConfig;
     private Set<String> mAllowedTransition = new HashSet<>();
@@ -363,6 +383,12 @@ public abstract class DeviceFlashPreparer extends BaseTargetPreparer
                 // Re-entry can occur during reset isolation.
                 reEntry = true;
             } else {
+                if (TestDeviceState.ONLINE.equals(device.getDeviceState())) {
+                    CommandResult verityOutput = device.executeShellV2Command("enable-verity");
+                    CLog.d(
+                            "Verity output: stdout:%s\nstderr:%s",
+                            verityOutput.getStdout(), verityOutput.getStderr());
+                }
                 mIncrementalImageUtil =
                         IncrementalImageUtil.initialize(
                                 device,
@@ -371,21 +397,16 @@ public abstract class DeviceFlashPreparer extends BaseTargetPreparer
                                 isIsolated,
                                 mAllowTrackerlessUpdate,
                                 mAllowedTransition,
-                                mNewIncrementalFlow,
                                 mUpdateBootloaderFromUserspace,
-                                mWaitPhase,
-                                mUseMerkleTreeComparison);
+                                mWaitPhase);
                 if (mIncrementalImageUtil == null) {
                     useIncrementalFlashing = false;
                 } else {
+                    mIncrementalImageUtil.setSkipBootloaderVersionCheck(
+                            mSkipBootloaderVersionCheck);
                     if (mAllowIncrementalOnSameBuild) {
                         mIncrementalImageUtil.allowSameBuildFlashing();
                     }
-                    if (TestDeviceState.ONLINE.equals(device.getDeviceState())) {
-                        // No need to reboot yet, it will happen later in the sequence
-                        String verityOutput = device.executeAdbCommand("enable-verity");
-                        CLog.d("%s", verityOutput);
-                    }
                 }
             }
         }
@@ -398,12 +419,24 @@ public abstract class DeviceFlashPreparer extends BaseTargetPreparer
                 CLog.d("Reusing flasher object.");
             } else {
                 flasher = createFlasher(device);
+                flasher.setExtraMetadata(mFlasherMetadata);
                 mFlasher = flasher;
+                if (mIncrementalImageUtil != null
+                        && checkAntiRollback(flasher, device, deviceBuild)) {
+                    CLog.d("Avoid incremental flashing due to Anti-rollback situation");
+                    useIncrementalFlashing = false;
+                    mIncrementalImageUtil = null;
+                    InvocationMetricLogger.addInvocationMetrics(
+                            InvocationMetricKey.INCREMENTAL_FLASHING_ANTI_ROLLBACK_DETECTED, 1);
+                }
             }
             flasher.setWipeTimeout(mWipeTimeout);
             boolean tookPermit = false;
             // only surround fastboot related operations with flashing permit restriction
             try {
+                if (flasher instanceof ITestInformationReceiver) {
+                    ((ITestInformationReceiver) flasher).setTestInformation(testInfo);
+                }
                 flasher.overrideDeviceOptions(device);
                 flasher.setUserDataFlashOption(mUserDataFlashOption);
                 flasher.setForceSystemFlash(mForceSystemFlash);
@@ -413,6 +446,10 @@ public abstract class DeviceFlashPreparer extends BaseTargetPreparer
                     flasher.setRamdiskPartition(mRamdiskPartition);
                 }
                 if (flasher instanceof FastbootDeviceFlasher) {
+                    ((FastbootDeviceFlasher) flasher)
+                            .setSkipBootloaderVersionCheck(mSkipBootloaderVersionCheck);
+                    ((FastbootDeviceFlasher) flasher)
+                            .setSkipFastbootFailedMessage(mIgnoreFastbootFailedMessage);
                     ((FastbootDeviceFlasher) flasher).setFlashOptions(mFastbootFlashOptions);
                     if (!reEntry) {
                         // Avoid using incremental during re-entry since it will just wipe
@@ -459,11 +496,26 @@ public abstract class DeviceFlashPreparer extends BaseTargetPreparer
                         InvocationMetricKey.FLASHING_METHOD,
                         FlashingMethod.FASTBOOT_UNCATEGORIZED.toString());
                 flasher.flash(device, deviceBuild);
-            } catch (DeviceNotAvailableException | TargetSetupError | RuntimeException e) {
+            } catch (DeviceNotAvailableException | RuntimeException e) {
                 CLog.e(e);
                 // Clear tracking in case of error
                 DeviceImageTracker.getDefaultCache().invalidateTracking(device.getSerialNumber());
                 throw e;
+            } catch (TargetSetupError e) {
+                CLog.e(e);
+                // Clear tracking in case of error
+                DeviceImageTracker.getDefaultCache().invalidateTracking(device.getSerialNumber());
+                if (InfraErrorIdentifier.ANTI_ROLLBACK_ERROR.equals(e.getErrorId())) {
+                    device.setRecoveryMode(RecoveryMode.NONE);
+                    try {
+                        device.reboot();
+                    } catch (DeviceNotAvailableException dnae) {
+                        // Ignore, this is best effort
+                        CLog.w("Failed reboot out of anti-rollback error.");
+                        CLog.w(dnae);
+                    }
+                }
+                throw e;
             } finally {
                 flashingTime = System.currentTimeMillis() - start;
                 if (tookPermit) {
@@ -571,6 +623,12 @@ public abstract class DeviceFlashPreparer extends BaseTargetPreparer
         }
     }
 
+    protected boolean checkAntiRollback(
+            IDeviceFlasher flasher, ITestDevice device, IDeviceBuildInfo deviceBuild)
+            throws DeviceNotAvailableException {
+        return false;
+    }
+
     /**
      * Possible check before flashing to ensure the device is as expected compare to the build info.
      *
@@ -638,9 +696,6 @@ public abstract class DeviceFlashPreparer extends BaseTargetPreparer
             RecoveryMode mode = testInfo.getDevice().getRecoveryMode();
             try {
                 testInfo.getDevice().setRecoveryMode(RecoveryMode.NONE);
-                if (mAllowUnzippedBaseline) {
-                    mIncrementalImageUtil.allowUnzipBaseline();
-                }
                 mIncrementalImageUtil.teardownDevice(testInfo);
             } finally {
                 testInfo.getDevice().setRecoveryMode(mode);
@@ -748,4 +803,8 @@ public abstract class DeviceFlashPreparer extends BaseTargetPreparer
     public void useMerkleTreeComparison(boolean enableMerkleTreeComparison) {
         mUseMerkleTreeComparison = enableMerkleTreeComparison;
     }
+
+    public void addFlasherExtraMetadata(Map<String, String> metadata) {
+        mFlasherMetadata.putAll(metadata);
+    }
 }
diff --git a/src/com/android/tradefed/targetprep/FastbootDeviceFlasher.java b/src/com/android/tradefed/targetprep/FastbootDeviceFlasher.java
index f7acf5e94..201a36998 100644
--- a/src/com/android/tradefed/targetprep/FastbootDeviceFlasher.java
+++ b/src/com/android/tradefed/targetprep/FastbootDeviceFlasher.java
@@ -74,11 +74,14 @@ public class FastbootDeviceFlasher implements IDeviceFlasher {
     private static final int MAX_RETRY_ATTEMPTS = 3;
     private static final int RETRY_SLEEP = 2 * 1000; // 2s sleep between retries
 
+    private static final String FORCE_FLASH_PARAM = "--force";
     private static final String SLOT_PROP = "ro.boot.slot_suffix";
     private static final String SLOT_VAR = "current-slot";
     private static final String SKIP_REBOOT_PARAM = "--skip-reboot";
     private static final ImmutableSet<String> DISK_SPACE_ERRORS =
-        ImmutableSet.of("No space left on device", "failed to create temporary file");
+            ImmutableSet.of("No space left on device", "failed to create temporary file");
+    private static final Pattern BOOTLOADER_VERSION_ERROR =
+            Pattern.compile("Checking\\s+'version-bootloader'\\s+FAILED");
 
     private long mWipeTimeout = 4 * 60 * 1000;
 
@@ -99,6 +102,8 @@ public class FastbootDeviceFlasher implements IDeviceFlasher {
     private CommandStatus mSystemFlashStatus;
 
     private boolean mShouldFlashRamdisk = false;
+    private boolean mSkipBootloaderVersionCheck = false;
+    private boolean mSkipFastbootFailedMessage = false;
 
     private String mRamdiskPartition = "root";
 
@@ -261,6 +266,10 @@ public class FastbootDeviceFlasher implements IDeviceFlasher {
                 cmdArgs.add(SKIP_REBOOT_PARAM);
             }
             cmdArgs.addAll(mFlashOptions);
+            if (mSkipBootloaderVersionCheck) {
+                CLog.d("Adding --force to fastboot command to skip bootloader version check");
+                cmdArgs.add(FORCE_FLASH_PARAM);
+            }
         }
         cmdArgs.add(action);
         cmdArgs.addAll(Arrays.asList(args));
@@ -485,13 +494,11 @@ public class FastbootDeviceFlasher implements IDeviceFlasher {
     protected boolean checkAndFlashBootloader(ITestDevice device, IDeviceBuildInfo deviceBuild)
             throws DeviceNotAvailableException, TargetSetupError {
         String currentBootloaderVersion = getImageVersion(device, "bootloader");
-        if (deviceBuild.getBootloaderVersion() != null &&
-                !deviceBuild.getBootloaderVersion().equals(currentBootloaderVersion)) {
+        if (mSkipBootloaderVersionCheck
+                || (deviceBuild.getBootloaderVersion() != null
+                        && !deviceBuild.getBootloaderVersion().equals(currentBootloaderVersion))) {
             CLog.i("Flashing bootloader %s", deviceBuild.getBootloaderVersion());
             flashBootloader(device, deviceBuild.getBootloaderImageFile());
-            if (mIncrementalFlashing != null) {
-                mIncrementalFlashing.notifyBootloaderNeedsRevert();
-            }
             return true;
         } else {
             CLog.i("Bootloader is already version %s, skipping flashing", currentBootloaderVersion);
@@ -557,9 +564,6 @@ public class FastbootDeviceFlasher implements IDeviceFlasher {
         if (checkShouldFlashBaseband(device, deviceBuild)) {
             CLog.i("Flashing baseband %s", deviceBuild.getBasebandVersion());
             flashBaseband(device, deviceBuild.getBasebandImageFile());
-            if (mIncrementalFlashing != null) {
-                mIncrementalFlashing.notifyBasebadNeedsRevert();
-            }
         }
     }
 
@@ -1002,8 +1006,15 @@ public class FastbootDeviceFlasher implements IDeviceFlasher {
         while (attempts < MAX_RETRY_ATTEMPTS) {
             CLog.v("Executing short fastboot command 'getvar %s'", versionQuery);
             CommandResult result = device.executeFastbootCommand("getvar", versionQuery);
+            boolean skipBootloaderVersionCheck = false; // Doesn't apply to "getvar"
             String queryOutput =
-                    internalHandleFastbootResult(device, result, "getvar", versionQuery);
+                    internalHandleFastbootResult(
+                            device,
+                            result,
+                            skipBootloaderVersionCheck,
+                            false,
+                            "getvar",
+                            versionQuery);
             Matcher matcher = versionOutputPattern.matcher(queryOutput);
             if (matcher.find()) {
                 return matcher.group(1);
@@ -1128,7 +1139,13 @@ public class FastbootDeviceFlasher implements IDeviceFlasher {
     String handleFastbootResult(ITestDevice device, CommandResult result, String... cmdArgs)
             throws TargetSetupError {
         try {
-            String res = internalHandleFastbootResult(device, result, cmdArgs);
+            String res =
+                    internalHandleFastbootResult(
+                            device,
+                            result,
+                            mSkipBootloaderVersionCheck,
+                            mSkipFastbootFailedMessage,
+                            cmdArgs);
             mFbCmdStatus = CommandStatus.SUCCESS;
             return res;
         } catch (TargetSetupError e) {
@@ -1137,23 +1154,52 @@ public class FastbootDeviceFlasher implements IDeviceFlasher {
         }
     }
 
+    public static boolean stderrContainsFailed(String stderr, boolean skipBootloaderVersionCheck) {
+        return stderrContainsFailed(stderr, skipBootloaderVersionCheck, false);
+    }
+
+    public static boolean stderrContainsFailed(
+            String stderr, boolean skipBootloaderVersionCheck, boolean skipFastbootFailedMessage) {
+        if (skipFastbootFailedMessage) {
+            return false;
+        }
+        if (skipBootloaderVersionCheck) {
+            CLog.d("Ignore bootloader version check failures");
+            stderr = BOOTLOADER_VERSION_ERROR.matcher(stderr).replaceAll("");
+        }
+        return stderr.contains("FAILED");
+    }
+
     private static String internalHandleFastbootResult(
-            ITestDevice device, CommandResult result, String... cmdArgs) throws TargetSetupError {
+            ITestDevice device,
+            CommandResult result,
+            boolean skipBootloaderVersionCheck,
+            boolean skipFastbootFailedMessage,
+            String... cmdArgs)
+            throws TargetSetupError {
         CLog.v("fastboot stdout: " + result.getStdout());
         CLog.v("fastboot stderr: " + result.getStderr());
         CommandStatus status = result.getStatus();
         ErrorIdentifier errorIdentifier = null;
-        boolean diskErrorIdentified = false;
+        boolean specialErrorIdentified = false;
         for (String diskError : DISK_SPACE_ERRORS) {
             if (result.getStderr().contains(diskError)) {
                 errorIdentifier = InfraErrorIdentifier.NO_DISK_SPACE;
                 status = CommandStatus.FAILED;
-                diskErrorIdentified = true;
+                specialErrorIdentified = true;
                 break;
             }
         }
-
-        if (!diskErrorIdentified && result.getStderr().contains("FAILED")) {
+        if (result.getStderr().contains("rejected, anti-rollback")) {
+            specialErrorIdentified = true;
+            errorIdentifier = InfraErrorIdentifier.ANTI_ROLLBACK_ERROR;
+            status = CommandStatus.FAILED;
+        }
+        if (!specialErrorIdentified
+                && stderrContainsFailed(
+                        result.getStderr(),
+                        skipBootloaderVersionCheck,
+                        skipFastbootFailedMessage)) {
             // if output contains "FAILED", just override to failure
             status = CommandStatus.FAILED;
         }
@@ -1268,4 +1314,16 @@ public class FastbootDeviceFlasher implements IDeviceFlasher {
     IHostOptions getHostOptions() {
         return GlobalConfiguration.getInstance().getHostOptions();
     }
+
+    protected void setSkipBootloaderVersionCheck(boolean skipBootloaderVersionCheck) {
+        mSkipBootloaderVersionCheck = skipBootloaderVersionCheck;
+    }
+
+    protected void setSkipFastbootFailedMessage(boolean skipFastbootFailedMessage) {
+        mSkipFastbootFailedMessage = skipFastbootFailedMessage;
+    }
+
+    public boolean shouldSkipBootloaderVersionCheck() {
+        return mSkipBootloaderVersionCheck;
+    }
 }
diff --git a/src/com/android/tradefed/targetprep/IDeviceFlasher.java b/src/com/android/tradefed/targetprep/IDeviceFlasher.java
index ce109fc04..fa8b8c05f 100644
--- a/src/com/android/tradefed/targetprep/IDeviceFlasher.java
+++ b/src/com/android/tradefed/targetprep/IDeviceFlasher.java
@@ -23,6 +23,7 @@ import com.android.tradefed.util.CommandStatus;
 
 import java.util.Collection;
 import java.util.Collections;
+import java.util.Map;
 import java.util.Set;
 
 /**
@@ -205,4 +206,9 @@ public interface IDeviceFlasher {
     public default void tearDownFlasher() {
         // Empty on purpose
     }
+
+    /** Allows flasher to receive extra metadata options. */
+    public default void setExtraMetadata(Map<String, String> metadata) {
+        // Empty on purpose
+    }
 }
diff --git a/src/com/android/tradefed/targetprep/OtaUpdateDeviceFlasher.java b/src/com/android/tradefed/targetprep/OtaUpdateDeviceFlasher.java
index 59679e1f7..c7e98b589 100644
--- a/src/com/android/tradefed/targetprep/OtaUpdateDeviceFlasher.java
+++ b/src/com/android/tradefed/targetprep/OtaUpdateDeviceFlasher.java
@@ -142,19 +142,6 @@ public class OtaUpdateDeviceFlasher implements IDeviceFlasher {
         InvocationMetricLogger.addInvocationMetrics(
                 InvocationMetricKey.FLASHING_METHOD, FlashingMethod.USERSPACE_OTA.toString());
         device.enableAdbRoot();
-        // TODO(guangzhu): Remove this once wipe via OTA script is properly supported
-        if (UserDataFlashOption.WIPE.equals(mUserDataFlashOptions)) {
-            // starts the framework in case it was stopped (or no-op)
-            // this is still not the ideal solution as it needs a functioning framework
-            device.executeShellCommand("start");
-            device.waitForDeviceAvailable();
-            device.executeShellCommand("cmd recovery wipe");
-            // device will reboot from the above command
-            device.waitForDeviceAvailable();
-            device.enableAdbRoot();
-            // ensure that the device won't enter suspend mode
-            device.executeShellCommand("svc power stayon true");
-        }
         // allow OTA downgrade since it can't be assumed that incoming builds are always newer
         device.setProperty(OTA_DOWNGRADE_PROP, "1");
         // trigger the actual flashing
diff --git a/src/com/android/tradefed/targetprep/TestAppInstallSetup.java b/src/com/android/tradefed/targetprep/TestAppInstallSetup.java
index 6004b6746..9084e0f96 100644
--- a/src/com/android/tradefed/targetprep/TestAppInstallSetup.java
+++ b/src/com/android/tradefed/targetprep/TestAppInstallSetup.java
@@ -19,11 +19,6 @@ import static com.android.tradefed.targetprep.UserHelper.RUN_TESTS_AS_USER_KEY;
 import static com.android.tradefed.targetprep.VisibleBackgroundUserPreparer.INSTALL_TEST_APK_FOR_ALL_USERS;
 
 import com.android.annotations.VisibleForTesting;
-import com.android.incfs.install.IncrementalInstallSession;
-import com.android.incfs.install.IncrementalInstallSession.Builder;
-import com.android.incfs.install.PendingBlock;
-import com.android.incfs.install.adb.ddmlib.DeviceConnection;
-import com.android.incfs.install.adb.ddmlib.DeviceLogger;
 import com.android.tradefed.build.IBuildInfo;
 import com.android.tradefed.build.IDeviceBuildInfo;
 import com.android.tradefed.config.Option;
@@ -47,7 +42,6 @@ import com.android.tradefed.util.AaptParser;
 import com.android.tradefed.util.AaptParser.AaptVersion;
 import com.android.tradefed.util.AbiFormatter;
 import com.android.tradefed.util.BuildTestsZipUtils;
-import com.android.utils.StdLogger;
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableListMultimap;
@@ -57,20 +51,16 @@ import java.io.File;
 import java.io.IOException;
 import java.nio.file.Files;
 import java.nio.file.Path;
-import java.nio.file.Paths;
-import java.security.SecureRandom;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.Random;
 import java.util.Set;
-import java.util.concurrent.Executors;
-import java.util.concurrent.TimeUnit;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
@@ -97,6 +87,13 @@ public class TestAppInstallSetup extends BaseTargetPreparer
     // device so that installation can continue like normal.
     private static final String INSTALL_FAILED_UPDATE_INCOMPATIBLE =
             "INSTALL_FAILED_UPDATE_INCOMPATIBLE";
+    // An error message that occurs when the test APK fails to be installed because the provider
+    // name is used by an old package. When this occurs, the old package is removed from the device
+    // so that installation can continue like normal.
+    private static final String INSTALL_FAILED_CONFLICTING_PROVIDER =
+            "INSTALL_FAILED_CONFLICTING_PROVIDER";
+    private static final Pattern CONFLICTING_PROVIDER_PATTERN =
+        Pattern.compile("is already used by (?<packageName>[A-Za-z0-9\\.]+)");
 
     @VisibleForTesting static final String TEST_FILE_NAME_OPTION = "test-file-name";
 
@@ -232,7 +229,6 @@ public class TestAppInstallSetup extends BaseTargetPreparer
 
     private Set<String> mPackagesInstalled = new HashSet<>();
     private TestInformation mTestInfo;
-    @VisibleForTesting protected IncrementalInstallSession incrementalInstallSession;
     private ApkChangeDetector mApkChangeDetector = null;
 
     protected void setTestInformation(TestInformation testInfo) {
@@ -382,7 +378,9 @@ public class TestAppInstallSetup extends BaseTargetPreparer
             CLog.d("Using abi %s from abi option.", mAbi.getName());
             abiName = mAbi.getName();
         } else if (mForceAbiBitness != null) {
-            CLog.d("Using abi %s from force-abi option.", AbiFormatter.getDefaultAbi(getDevice(), mForceAbiBitness));
+            CLog.d(
+                    "Using abi %s from force-abi option.",
+                    AbiFormatter.getDefaultAbi(getDevice(), mForceAbiBitness));
             abiName = AbiFormatter.getDefaultAbi(getDevice(), mForceAbiBitness);
         }
         // Set all the extra install args outside the loop to avoid adding them several times.
@@ -551,33 +549,13 @@ public class TestAppInstallSetup extends BaseTargetPreparer
         ImmutableListMultimap<String, File> packageToFiles =
                 ImmutableListMultimap.copyOf(appFilesAndPackages.entrySet()).inverse();
 
-        Builder builder = null;
-        if (mIncrementalInstallation) {
-            builder = getIncrementalInstallSessionBuilder();
-        }
-
         for (Map.Entry<String, List<File>> e : Multimaps.asMap(packageToFiles).entrySet()) {
             if (mApkChangeDetector != null
                 && mApkChangeDetector.handleTestAppsPreinstall(
                     e.getKey(), e.getValue(), getDevice(), mUserId, mInstallForAllUsers)) {
                 continue;
             }
-
-            if (mIncrementalInstallation) {
-                CLog.d(
-                        "Performing incremental installation of apk %s with %s ...",
-                        e.getKey(), e.getValue());
-                addPackageToIncrementalInstallSession(builder, e.getKey(), e.getValue());
-                if (mCleanup) {
-                    mPackagesInstalled.add(e.getKey());
-                }
-            } else {
-                installSinglePackage(device, e.getKey(), e.getValue());
-            }
-        }
-
-        if (mIncrementalInstallation && builder != null) {
-            installPackageIncrementally(builder);
+            installSinglePackage(device, e.getKey(), e.getValue());
         }
     }
 
@@ -600,6 +578,18 @@ public class TestAppInstallSetup extends BaseTargetPreparer
             }
         }
 
+        if (result != null) {
+            if (result.startsWith(INSTALL_FAILED_CONFLICTING_PROVIDER)) {
+                // Try to uninstall the conflicting package and reinstall this package.
+                Matcher matcher = CONFLICTING_PROVIDER_PATTERN.matcher(result);
+                if (matcher.find()) {
+                    String oldPackageName = matcher.group("packageName");
+                    uninstallPackage(testDevice, oldPackageName);
+                    result = installPackage(testDevice, apkFiles);
+                }
+            }
+        }
+
         if (result != null) {
             throw new TargetSetupError(
                     String.format(
@@ -778,9 +768,6 @@ public class TestAppInstallSetup extends BaseTargetPreparer
         if (msg != null) {
             CLog.w(String.format("error uninstalling package '%s': %s", packageName, msg));
         }
-        if (mIncrementalInstallation) {
-            incrementalInstallSession.close();
-        }
     }
 
     /** Get the package name from the test app. */
@@ -799,105 +786,6 @@ public class TestAppInstallSetup extends BaseTargetPreparer
         return parser.getPackageName();
     }
 
-    /**
-     * Add APKs from package to incremental installation session builder object.
-     *
-     * @param builder The Builder object for the incremental install session.
-     * @param packageName The name of the package to be added.
-     * @param packageFiles List of files to be added to builder object.
-     * @throws TargetSetupError
-     */
-    private void addPackageToIncrementalInstallSession(
-            Builder builder, String packageName, List<File> packageFiles) throws TargetSetupError {
-        for (File apk : packageFiles) {
-            Path apkPath = apk.toPath();
-            Path apkSignaturePath = Paths.get(String.format("%s.idsig", apkPath.toString()));
-            if (!apkSignaturePath.toFile().exists()) {
-                throw new TargetSetupError(
-                        String.format(
-                                "Unable to retrieve v4 signature for file: %s",
-                                apkPath.getFileName()),
-                        getDevice().getDeviceDescriptor(),
-                        InfraErrorIdentifier.CONFIGURED_ARTIFACT_NOT_FOUND);
-            }
-            builder.addApk(apkPath, apkSignaturePath);
-        }
-    }
-
-    /**
-     * Start the incremental installation session for a test app.
-     *
-     * @param builder The Builder object for the incremental install session.
-     * @throws TargetSetupError
-     */
-    @VisibleForTesting
-    protected void installPackageIncrementally(Builder builder) throws TargetSetupError {
-        try {
-            incrementalInstallSession = builder.build();
-            String deviceSerialNumber = getDevice().getSerialNumber();
-            DeviceConnection.Factory deviceConnection =
-                    DeviceConnection.getFactory(deviceSerialNumber);
-            incrementalInstallSession.start(Executors.newCachedThreadPool(), deviceConnection);
-            incrementalInstallSession.waitForInstallCompleted(
-                    mIncrementalInstallTimeout, TimeUnit.SECONDS);
-        } catch (InterruptedException | IOException e) {
-            throw new TargetSetupError(
-                    String.format("Failed to start incremental install session."),
-                    e,
-                    getDevice().getDeviceDescriptor(),
-                    DeviceErrorIdentifier.APK_INSTALLATION_FAILED);
-        }
-    }
-
-    /** Initialize the session builder for installing a test app incrementally. */
-    @VisibleForTesting
-    protected Builder getIncrementalInstallSessionBuilder() {
-        if (mGrantPermission != null && mGrantPermission) {
-            mInstallArgs.add("-g");
-        }
-
-        if (mUserId != null) {
-            mInstallArgs.add("--user");
-            mInstallArgs.add(Integer.toString(mUserId));
-        }
-
-        Builder incrementalInstallSessionBuilder =
-                new Builder()
-                        .setLogger(new DeviceLogger(new StdLogger(StdLogger.Level.ERROR)))
-                        .addExtraArgs(mInstallArgs.toArray(new String[] {}));
-
-        // Add block filter to installation if a block filter percentage is specified.
-        if (mBlockFilterPercentage > 0) {
-            long randomSeed = new SecureRandom().nextLong();
-            Random randomBlock = new Random(randomSeed);
-            Map<Path, Set<Integer>> apkBlockMappings = new HashMap<>();
-
-            CLog.i("Block filter seed: %d.", randomSeed);
-
-            incrementalInstallSessionBuilder.setBlockFilter(
-                    (PendingBlock b) -> {
-                        Path apkPath = b.getPath();
-                        synchronized (apkBlockMappings) {
-                            // Generate block indexs to filter for APK installation.
-                            if (!apkBlockMappings.containsKey(apkPath)) {
-                                int blockCount = b.getFileBlockCount();
-                                int numBlocks = (int) (blockCount * mBlockFilterPercentage);
-                                Set<Integer> blocksToFilter = new HashSet<Integer>(numBlocks);
-                                while (blocksToFilter.size() < numBlocks) {
-                                    int blockIndex = randomBlock.nextInt(blockCount);
-                                    blocksToFilter.add(blockIndex);
-                                }
-                                apkBlockMappings.put(apkPath, blocksToFilter);
-                            }
-
-                            return !apkBlockMappings.get(apkPath).contains(b.getBlockIndex());
-                        }
-                    });
-        }
-
-        return incrementalInstallSessionBuilder;
-    }
-
     @Override
     public Set<String> reportDependencies() {
         Set<String> deps = new HashSet<String>();
diff --git a/src/com/android/tradefed/testtype/SubprocessTfLauncher.java b/src/com/android/tradefed/testtype/SubprocessTfLauncher.java
index 687f7c5af..c72262eea 100644
--- a/src/com/android/tradefed/testtype/SubprocessTfLauncher.java
+++ b/src/com/android/tradefed/testtype/SubprocessTfLauncher.java
@@ -423,6 +423,7 @@ public abstract class SubprocessTfLauncher
             } else if (protoReceiver != null) {
                 if (!protoReceiver.joinReceiver(EVENT_THREAD_JOIN_TIMEOUT_MS)) {
                     elapsedTime = -1L;
+                    protoReceiver.completeModuleEvents();
                     throw new RuntimeException(
                             String.format(
                                     "Event receiver thread did not complete:" + "\n%s",
diff --git a/src/com/android/tradefed/testtype/suite/BaseTestSuite.java b/src/com/android/tradefed/testtype/suite/BaseTestSuite.java
index a08fd5da6..81d18efd2 100644
--- a/src/com/android/tradefed/testtype/suite/BaseTestSuite.java
+++ b/src/com/android/tradefed/testtype/suite/BaseTestSuite.java
@@ -128,6 +128,13 @@ public class BaseTestSuite extends ITestSuite {
             importance = Importance.ALWAYS)
     private List<String> mTestArgs = new ArrayList<>();
 
+    @Option(
+            name = "runtime-exclude-module",
+            description =
+                    "Exclude a module from running right before it should. This is not meant for"
+                        + " configuration. This is intended to control some of the module order.")
+    private Set<String> mRuntimeExcludeModule = new LinkedHashSet<String>();
+
     @Option(
             name = "run-suite-tag",
             description =
@@ -702,6 +709,16 @@ public class BaseTestSuite extends ITestSuite {
     @Override
     protected boolean shouldModuleRun(ModuleDefinition module) {
         String moduleId = module.getId();
+        if (mRuntimeExcludeModule.contains(moduleId)
+                || mRuntimeExcludeModule.contains(
+                        module.getModuleInvocationContext()
+                                .getConfigurationDescriptor()
+                                .getModuleName())) {
+            CLog.d("Skipping '%s' as requested by runtime-exclude-module", moduleId);
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricKey.RUNTIME_EXCLUDE_FILTER, 1);
+            return false;
+        }
         LinkedHashSet<SuiteTestFilter> excludeFilters = mExcludeFiltersParsed.get(moduleId);
         CLog.d("Filters for '%s': %s", moduleId, excludeFilters);
         if (excludeFilters == null || excludeFilters.isEmpty()) {
diff --git a/src/com/android/tradefed/testtype/suite/GranularRetriableTestWrapper.java b/src/com/android/tradefed/testtype/suite/GranularRetriableTestWrapper.java
index 080d01f75..cc031383d 100644
--- a/src/com/android/tradefed/testtype/suite/GranularRetriableTestWrapper.java
+++ b/src/com/android/tradefed/testtype/suite/GranularRetriableTestWrapper.java
@@ -93,9 +93,10 @@ public class GranularRetriableTestWrapper implements IRemoteTest, ITestCollector
     private IInvocationContext mModuleInvocationContext;
     private IConfiguration mModuleConfiguration;
     private ModuleListener mMainGranularRunListener;
+    private ITestInvocationListener mAllListeners;
     private RetryLogSaverResultForwarder mRetryAttemptForwarder;
     private ITestInvocationListener mRemoteTestTimeOutEnforcer;
-    private ModuleResultsAndMetricsForwarder listenerWithModuleMetricsForwarder;
+    private ModuleResultsAndMetricsForwarder mListenerWithModuleMetricsForwarder;
     private ILogSaver mLogSaver;
     private String mModuleId;
     private int mMaxRunLimit;
@@ -107,6 +108,10 @@ public class GranularRetriableTestWrapper implements IRemoteTest, ITestCollector
     private int mCountRetryUsed = 0;
 
     private boolean mUseModuleResultsForwarder = false;
+    private boolean mRemoveModuleBuffering = false;
+    private boolean mIsEventsBackFilled = false;
+    private int mTargetPreparerRetryCount;
+    private StartEndCollector mCurrentStartEndCollector;
 
     public GranularRetriableTestWrapper(
             IRemoteTest test,
@@ -120,7 +125,7 @@ public class GranularRetriableTestWrapper implements IRemoteTest, ITestCollector
             ModuleDefinition module,
             ITestInvocationListener mainListener,
             int maxRunLimit) {
-        this(test, module, mainListener, maxRunLimit, false);
+        this(test, module, mainListener, maxRunLimit, false, false, 0);
     }
 
     public GranularRetriableTestWrapper(
@@ -128,10 +133,14 @@ public class GranularRetriableTestWrapper implements IRemoteTest, ITestCollector
             ModuleDefinition module,
             ITestInvocationListener mainListener,
             int maxRunLimit,
-            boolean useModuleResultsForwarder) {
+            boolean useModuleResultsForwarder,
+            boolean removeModuleBuffering,
+            int targetPreparerRetryCount) {
         mTest = test;
         mModule = module;
         mUseModuleResultsForwarder = useModuleResultsForwarder;
+        mRemoveModuleBuffering = removeModuleBuffering;
+        mTargetPreparerRetryCount = targetPreparerRetryCount;
         IInvocationContext context = null;
         if (module != null) {
             context = module.getModuleInvocationContext();
@@ -162,6 +171,9 @@ public class GranularRetriableTestWrapper implements IRemoteTest, ITestCollector
      */
     public void setMarkTestsSkipped(boolean skipTestCases) {
         mMainGranularRunListener.setMarkTestsSkipped(skipTestCases);
+        if (mUseModuleResultsForwarder) {
+            mListenerWithModuleMetricsForwarder.setMarkTestsSkipped(skipTestCases);
+        }
     }
 
     /**
@@ -212,13 +224,15 @@ public class GranularRetriableTestWrapper implements IRemoteTest, ITestCollector
      */
     private void initializeGranularRunListener(
             ITestInvocationListener listener, IInvocationContext moduleContext) {
-        ModuleResultsAndMetricsForwarder mListenerWithModuleMetricsForwarder = null;
         if (mUseModuleResultsForwarder) {
             mListenerWithModuleMetricsForwarder = new ModuleResultsAndMetricsForwarder(listener);
-            mListenerWithModuleMetricsForwarder.setModuleId(mModuleId);
             listener = mListenerWithModuleMetricsForwarder;
         }
-        mMainGranularRunListener = new ModuleListener(listener, moduleContext);
+        if (mRemoveModuleBuffering) {
+            mMainGranularRunListener = new ModuleListener(null, moduleContext);
+        } else {
+            mMainGranularRunListener = new ModuleListener(listener, moduleContext);
+        }
         mMainGranularRunListener.setUseModuleResultsForwarder(mUseModuleResultsForwarder);
         if (mModule != null) {
             ConfigurationDescriptor configDesc =
@@ -228,8 +242,19 @@ public class GranularRetriableTestWrapper implements IRemoteTest, ITestCollector
                 Duration duration = Duration.parse(
                         configDesc.getMetaData(
                                 RemoteTestTimeOutEnforcer.REMOTE_TEST_TIMEOUT_OPTION).get(0));
-                mRemoteTestTimeOutEnforcer = new RemoteTestTimeOutEnforcer(
-                        mMainGranularRunListener, mModule, mTest, duration);
+                RemoteTestTimeOutEnforcer remoteTestTimeOutEnforcer;
+                if (mRemoveModuleBuffering) {
+                    remoteTestTimeOutEnforcer =
+                            new RemoteTestTimeOutEnforcer(
+                                    Arrays.asList(listener), mModule, mTest, duration);
+                    listener = remoteTestTimeOutEnforcer;
+                } else {
+                    remoteTestTimeOutEnforcer =
+                            new RemoteTestTimeOutEnforcer(
+                                    new ArrayList<>(), mModule, mTest, duration);
+                }
+                remoteTestTimeOutEnforcer.setGranularListener(mMainGranularRunListener);
+                mRemoteTestTimeOutEnforcer = remoteTestTimeOutEnforcer;
             }
             List<String> testMappingSources =
                     configDesc.getMetaData(Integer.toString(mTest.hashCode()));
@@ -240,6 +265,7 @@ public class GranularRetriableTestWrapper implements IRemoteTest, ITestCollector
                 }
             }
         }
+        mAllListeners = listener;
     }
 
     /**
@@ -252,15 +278,28 @@ public class GranularRetriableTestWrapper implements IRemoteTest, ITestCollector
      */
     private ITestInvocationListener initializeListeners() throws DeviceNotAvailableException {
         List<ITestInvocationListener> currentTestListener = new ArrayList<>();
-        currentTestListener.add(mMainGranularRunListener);
-
-        if (mRemoteTestTimeOutEnforcer != null) {
-            currentTestListener.add(mRemoteTestTimeOutEnforcer);
+        if (mRemoveModuleBuffering) {
+            currentTestListener.add(mAllListeners);
+            currentTestListener.add(mMainGranularRunListener);
+        } else {
+            currentTestListener.add(mMainGranularRunListener);
+            if (mRemoteTestTimeOutEnforcer != null) {
+                currentTestListener.add(mRemoteTestTimeOutEnforcer);
+            }
         }
 
-        mRetryAttemptForwarder =
-                new RetryLogSaverResultForwarder(
-                        mLogSaver, currentTestListener, mModuleConfiguration);
+        if (mRemoveModuleBuffering) {
+            mRetryAttemptForwarder =
+                    new RetryLogSaverResultForwarder(
+                            mLogSaver,
+                            currentTestListener,
+                            mModuleConfiguration,
+                            mTargetPreparerRetryCount);
+        } else {
+            mRetryAttemptForwarder =
+                    new RetryLogSaverResultForwarder(
+                            mLogSaver, currentTestListener, mModuleConfiguration);
+        }
         ITestInvocationListener runListener = mRetryAttemptForwarder;
 
         // The module collectors itself are added: this list will be very limited.
@@ -294,6 +333,9 @@ public class GranularRetriableTestWrapper implements IRemoteTest, ITestCollector
     public void run(TestInformation testInfo, ITestInvocationListener listener)
             throws DeviceNotAvailableException {
         mMainGranularRunListener.setCollectTestsOnly(mCollectTestsOnly);
+        if (mUseModuleResultsForwarder) {
+            mListenerWithModuleMetricsForwarder.setModuleId(mModuleId);
+        }
         ITestInvocationListener allListeners = initializeListeners();
         // First do the regular run, not retried.
         DeviceNotAvailableException dnae = intraModuleRun(testInfo, allListeners, 0);
@@ -366,12 +408,12 @@ public class GranularRetriableTestWrapper implements IRemoteTest, ITestCollector
             TestInformation testInfo, ITestInvocationListener runListener, int attempt) {
         DeviceNotAvailableException exception = null;
         mMainGranularRunListener.setAttemptIsolation(CurrentInvocation.runCurrentIsolation());
-        if (listenerWithModuleMetricsForwarder != null) {
-            listenerWithModuleMetricsForwarder.setAttemptIsolation(
+        if (mListenerWithModuleMetricsForwarder != null) {
+            mListenerWithModuleMetricsForwarder.setAttemptIsolation(
                     CurrentInvocation.runCurrentIsolation());
         }
-        StartEndCollector startEndCollector = new StartEndCollector(runListener);
-        runListener = startEndCollector;
+        mCurrentStartEndCollector = new StartEndCollector(runListener);
+        runListener = mCurrentStartEndCollector;
         try (CloseableTraceScope ignored =
                 new CloseableTraceScope(
                         "attempt " + attempt + " " + mTest.getClass().getCanonicalName())) {
@@ -409,14 +451,18 @@ public class GranularRetriableTestWrapper implements IRemoteTest, ITestCollector
             CLog.e("Module '%s' - test '%s' threw exception:", mModuleId, mTest.getClass());
             CLog.e(re);
             CLog.e("Proceeding to the next test.");
-            if (!startEndCollector.mRunStartReported) {
-                CLog.e("Event mismatch ! the test runner didn't report any testRunStart.");
-                runListener.testRunStarted(mModule.getId(), 0);
-            }
-            runListener.testRunFailed(createFromException(re));
-            if (!startEndCollector.mRunEndedReported) {
-                CLog.e("Event mismatch ! the test runner didn't report any testRunEnded.");
-                runListener.testRunEnded(0L, new HashMap<String, Metric>());
+            if (mRemoveModuleBuffering) {
+                backfillMissingEvents(runListener, createFromException(re));
+            } else {
+                if (!mCurrentStartEndCollector.mRunStartReported) {
+                    CLog.e("Event mismatch ! the test runner didn't report any testRunStart.");
+                    runListener.testRunStarted(mModule.getId(), 0);
+                }
+                runListener.testRunFailed(createFromException(re));
+                if (!mCurrentStartEndCollector.mRunEndedReported) {
+                    CLog.e("Event mismatch ! the test runner didn't report any testRunEnded.");
+                    runListener.testRunEnded(0L, new HashMap<String, Metric>());
+                }
             }
         } catch (DeviceUnresponsiveException due) {
             // being able to catch a DeviceUnresponsiveException here implies that recovery was
@@ -426,17 +472,25 @@ public class GranularRetriableTestWrapper implements IRemoteTest, ITestCollector
                             + "successful, proceeding with next module. Stack trace:");
             CLog.w(due);
             CLog.w("Proceeding to the next test.");
-            // If it already was marked as failure do not remark it.
-            if (!mMainGranularRunListener.hasLastAttemptFailed()) {
-                runListener.testRunFailed(createFromException(due));
+            if (mRemoveModuleBuffering) {
+                backfillMissingEvents(runListener, createFromException(due));
+            } else {
+                // If it already was marked as failure do not remark it.
+                if (!mMainGranularRunListener.hasLastAttemptFailed()) {
+                    runListener.testRunFailed(createFromException(due));
+                }
             }
         } catch (DeviceNotAvailableException dnae) {
             // TODO: See if it's possible to report IReportNotExecuted
             CLog.e("Run in progress was not completed due to:");
             CLog.e(dnae);
-            // If it already was marked as failure do not remark it.
-            if (!mMainGranularRunListener.hasLastAttemptFailed()) {
-                runListener.testRunFailed(createFromException(dnae));
+            if (mRemoveModuleBuffering) {
+                backfillMissingEvents(runListener, createFromException(dnae));
+            } else {
+                // If it already was marked as failure do not remark it.
+                if (!mMainGranularRunListener.hasLastAttemptFailed()) {
+                    runListener.testRunFailed(createFromException(dnae));
+                }
             }
             exception = dnae;
         } finally {
@@ -447,6 +501,41 @@ public class GranularRetriableTestWrapper implements IRemoteTest, ITestCollector
         return exception;
     }
 
+    public void backfillMissingEvents(
+            ITestInvocationListener listener, FailureDescription failure) {
+        if (mCurrentStartEndCollector == null || mIsEventsBackFilled) {
+            // module never started. No need to backfill.
+            return;
+        }
+        if (mCurrentStartEndCollector.mRunEndedReported) {
+            // previous run events were completed. report a new run for the failure.
+            listener.testRunStarted(
+                    mModuleId,
+                    0,
+                    mRetryAttemptForwarder.getCurrentAttempt(),
+                    System.currentTimeMillis());
+            listener.testRunFailed(failure);
+            listener.testRunEnded(0, new HashMap<String, Metric>());
+        } else {
+            // either previous run events are not complete or the run has not started yet .
+            if (!mCurrentStartEndCollector.mRunStartReported) {
+                listener.testRunStarted(
+                        mModuleId,
+                        0,
+                        mRetryAttemptForwarder.getCurrentAttempt(),
+                        System.currentTimeMillis());
+            }
+            if (mCurrentStartEndCollector.mTestInProgress) {
+                listener.testFailed(mCurrentStartEndCollector.mCurrentTest, failure);
+                listener.testEnded(
+                        mCurrentStartEndCollector.mCurrentTest, new HashMap<String, Metric>());
+            }
+            listener.testRunFailed(failure);
+            listener.testRunEnded(0, new HashMap<String, Metric>());
+        }
+        mIsEventsBackFilled = true;
+    }
+
     /** Get the merged TestRunResults from each {@link IRemoteTest} run. */
     public final List<TestRunResult> getFinalTestRunResults() {
         MergeStrategy strategy = MergeStrategy.getMergeStrategy(mRetryDecision.getRetryStrategy());
@@ -528,6 +617,8 @@ public class GranularRetriableTestWrapper implements IRemoteTest, ITestCollector
 
         public boolean mRunStartReported = false;
         public boolean mRunEndedReported = false;
+        public boolean mTestInProgress = false;
+        public TestDescription mCurrentTest = null;
 
         StartEndCollector(ITestInvocationListener listener) {
             super(listener);
@@ -537,12 +628,14 @@ public class GranularRetriableTestWrapper implements IRemoteTest, ITestCollector
         public void testRunStarted(String runName, int testCount) {
             super.testRunStarted(runName, testCount);
             mRunStartReported = true;
+            mRunEndedReported = false;
         }
 
         @Override
         public void testRunStarted(String runName, int testCount, int attemptNumber) {
             super.testRunStarted(runName, testCount, attemptNumber);
             mRunStartReported = true;
+            mRunEndedReported = false;
         }
 
         @Override
@@ -550,18 +643,64 @@ public class GranularRetriableTestWrapper implements IRemoteTest, ITestCollector
                 String runName, int testCount, int attemptNumber, long startTime) {
             super.testRunStarted(runName, testCount, attemptNumber, startTime);
             mRunStartReported = true;
+            mRunEndedReported = false;
         }
 
         @Override
         public void testRunEnded(long elapsedTime, HashMap<String, Metric> runMetrics) {
             super.testRunEnded(elapsedTime, runMetrics);
             mRunEndedReported = true;
+            mRunStartReported = false;
         }
 
         @Override
         public void testRunEnded(long elapsedTimeMillis, Map<String, String> runMetrics) {
             super.testRunEnded(elapsedTimeMillis, runMetrics);
             mRunEndedReported = true;
+            mRunStartReported = false;
+        }
+
+        @Override
+        public void testStarted(TestDescription test) {
+            super.testStarted(test);
+            mTestInProgress = true;
+            mCurrentTest = test;
+        }
+
+        @Override
+        public void testStarted(TestDescription test, long startTime) {
+            super.testStarted(test, startTime);
+            mTestInProgress = true;
+            mCurrentTest = test;
+        }
+
+        @Override
+        public void testEnded(TestDescription test, HashMap<String, Metric> testMetrics) {
+            super.testEnded(test, testMetrics);
+            mTestInProgress = false;
+            mCurrentTest = null;
+        }
+
+        @Override
+        public void testEnded(
+                TestDescription test, long endTime, HashMap<String, Metric> testMetrics) {
+            super.testEnded(test, endTime, testMetrics);
+            mTestInProgress = false;
+            mCurrentTest = null;
+        }
+
+        @Override
+        public void testEnded(TestDescription test, Map<String, String> testMetrics) {
+            super.testEnded(test, testMetrics);
+            mTestInProgress = false;
+            mCurrentTest = null;
+        }
+
+        @Override
+        public void testEnded(TestDescription test, long endTime, Map<String, String> testMetrics) {
+            super.testEnded(test, endTime, testMetrics);
+            mTestInProgress = false;
+            mCurrentTest = null;
         }
     }
 }
diff --git a/src/com/android/tradefed/testtype/suite/ITestSuite.java b/src/com/android/tradefed/testtype/suite/ITestSuite.java
index 73108fb9e..d1d673f16 100644
--- a/src/com/android/tradefed/testtype/suite/ITestSuite.java
+++ b/src/com/android/tradefed/testtype/suite/ITestSuite.java
@@ -415,6 +415,18 @@ public abstract class ITestSuite
                             + " or the new forwarder.")
     private boolean mUseModuleResultsForwarder = true;
 
+    @Option(
+            name = "remove-module-buffering",
+            description = "Feature flag to remove module buffering.")
+    private boolean mRemoveModuleBuffering = true;
+
+    @Option(
+            name = "keep-post-processor-order",
+            description =
+                    "Whether to apply post processors in the order they are mentioned in the"
+                            + " config.")
+    private boolean mKeepPostProcessorOrder = false;
+
     public enum IsolatedModuleGrade {
         REBOOT_ISOLATED, // Reboot was done before the test.
         FULLY_ISOLATED; // Test received a fresh device.
@@ -1173,6 +1185,11 @@ public abstract class ITestSuite
         if (modulePostProcessors.size() > 0 && topLevelPostProcessors.size() > 0) {
             CLog.w("Post processors specified at both top level and module level (%s)", module);
         }
+        if (!modulePostProcessors.isEmpty() && mKeepPostProcessorOrder) {
+            // reverse the post-processor list so that the first post-processor in the list
+            // becomes the outermost post-processor and the first to receive events.
+            Collections.reverse(modulePostProcessors);
+        }
         // set log saver for module level post postprocessor manually to allow chained log
         // processing at module level. Do this before init() to avoid passing down the log saver
         // to invocation level listeners/reporters.
@@ -1332,6 +1349,9 @@ public abstract class ITestSuite
             if (mUseModuleResultsForwarder) {
                 module.setUseModuleResultsForwarder(mUseModuleResultsForwarder);
             }
+            if (mRemoveModuleBuffering) {
+                module.setRemoveModuleBuffering(mRemoveModuleBuffering);
+            }
             // Pass the run defined collectors to be used.
             module.setMetricCollectors(CollectorHelper.cloneCollectors(mMetricCollectors));
             // Pass the main invocation logSaver
@@ -2065,4 +2085,8 @@ public abstract class ITestSuite
     protected void setPrioritizeHostConfig(boolean prioritizeHostConfig) {
         mPrioritizeHostConfig = prioritizeHostConfig;
     }
+
+    public boolean isRemoveModuleBuffering() {
+        return mRemoveModuleBuffering;
+    }
 }
diff --git a/src/com/android/tradefed/testtype/suite/ModuleDefinition.java b/src/com/android/tradefed/testtype/suite/ModuleDefinition.java
index 5d22909f1..b1cb7a3f6 100644
--- a/src/com/android/tradefed/testtype/suite/ModuleDefinition.java
+++ b/src/com/android/tradefed/testtype/suite/ModuleDefinition.java
@@ -216,6 +216,8 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
 
     private boolean mUseModuleResultsForwarder = false;
 
+    private boolean mRemoveModuleBuffering = false;
+
     @VisibleForTesting
     public ModuleDefinition() {
         mModuleInvocationContext = null;
@@ -598,13 +600,6 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
                 if (!mPassThroughFilters.isEmpty()) {
                     applyFilterToTest(test, mPassThroughFilters);
                 }
-                mCurrentTestWrapper =
-                        prepareGranularRetriableWrapper(
-                                test,
-                                listener,
-                                skipTestCases,
-                                perModuleRetryQuota);
-                mCurrentTestWrapper.setCollectTestsOnly(mCollectTestsOnly);
                 // Resolve the dynamic options for that one test.
                 preparationException =
                         invokeRemoteDynamic(moduleInfo.getDevice(), mInternalTestConfiguration);
@@ -616,6 +611,10 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
                             true);
                     return;
                 }
+                mCurrentTestWrapper =
+                        prepareGranularRetriableWrapper(
+                                test, listener, skipTestCases, perModuleRetryQuota);
+                mCurrentTestWrapper.setCollectTestsOnly(mCollectTestsOnly);
                 try (CloseableTraceScope ignored = new CloseableTraceScope("module_test")) {
                     mCurrentTestWrapper.run(moduleInfo, listener);
                 } catch (DeviceNotAvailableException dnae) {
@@ -716,6 +715,16 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
                 CLog.e("Exception while running tearDown:");
                 CLog.e(e);
                 tearDownException = e;
+                if (mRemoveModuleBuffering) {
+                    // report the error as a new run failure
+                    mInvocationListener.testRunStarted(
+                            getId(), 0, mTargetPreparerRetryCount, System.currentTimeMillis());
+                    FailureDescription failure =
+                            CurrentInvocation.createFailure(StreamUtil.getStackTrace(e), null)
+                                    .setCause(e);
+                    mInvocationListener.testRunFailed(failure);
+                    mInvocationListener.testRunEnded(0, new HashMap<String, Metric>());
+                }
             } finally {
                 InvocationMetricLogger
                         .addInvocationPairMetrics(InvocationMetricKey.MODULE_TEARDOWN_PAIR,
@@ -724,49 +733,53 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
                 // finalize results
                 if (preparationException == null) {
                     mModuleConfiguration.cleanConfigurationData();
-                    if (mMergeAttempts) {
-                        reportFinalResults(
-                                mInvocationListener,
-                                mExpectedTests,
-                                mTestsResults,
-                                null,
-                                tearDownException);
-                        mTestsResults.clear();
-                        mExpectedTests = 0;
-                    } else {
-                        boolean reported = false;
-                        // Push the attempts one by one
-                        for (int i = 0; i < maxRunLimit; i++) {
-                            // Get all the results for the attempt
-                            List<TestRunResult> runResultList = new ArrayList<TestRunResult>();
-                            int expectedCount = 0;
-                            for (ModuleListener attemptListener : mRunListenersResults) {
-                                for (String runName : attemptListener.getTestRunNames()) {
-                                    TestRunResult run =
-                                            attemptListener.getTestRunAtAttempt(runName, i);
-                                    if (run != null) {
-                                        runResultList.add(run);
-                                        expectedCount += run.getExpectedTestCount();
+                    if (!mRemoveModuleBuffering) {
+                        if (mMergeAttempts) {
+                            reportFinalResults(
+                                    mInvocationListener,
+                                    mExpectedTests,
+                                    mTestsResults,
+                                    null,
+                                    tearDownException);
+                            mTestsResults.clear();
+                            mExpectedTests = 0;
+                        } else {
+                            boolean reported = false;
+                            // Push the attempts one by one
+                            for (int i = 0; i < maxRunLimit; i++) {
+                                // Get all the results for the attempt
+                                List<TestRunResult> runResultList = new ArrayList<TestRunResult>();
+                                int expectedCount = 0;
+                                for (ModuleListener attemptListener : mRunListenersResults) {
+                                    for (String runName : attemptListener.getTestRunNames()) {
+                                        TestRunResult run =
+                                                attemptListener.getTestRunAtAttempt(runName, i);
+                                        if (run != null) {
+                                            runResultList.add(run);
+                                            expectedCount += run.getExpectedTestCount();
+                                        }
                                     }
                                 }
-                            }
 
-                            if (!runResultList.isEmpty() || (
-                                !reported && mRetriedModulePreparationSuccess)) {
-                                if (runResultList.isEmpty()) {
-                                    reported = true;
-                                    CLog.i("Module preparation retry pass but no test cases were " +
-                                            "executed. Keep reporting the result to notify it " +
-                                            "failed in the 1st run but passed after retrying.");
+                                if (!runResultList.isEmpty()
+                                        || (!reported && mRetriedModulePreparationSuccess)) {
+                                    if (runResultList.isEmpty()) {
+                                        reported = true;
+                                        CLog.i(
+                                                "Module preparation retry pass but no test cases"
+                                                    + " were executed. Keep reporting the result to"
+                                                    + " notify it failed in the 1st run but passed"
+                                                    + " after retrying.");
+                                    }
+                                    reportFinalResults(
+                                            mInvocationListener,
+                                            expectedCount,
+                                            runResultList,
+                                            i,
+                                            tearDownException);
+                                } else {
+                                    CLog.d("No results to be forwarded for attempt %s.", i);
                                 }
-                                reportFinalResults(
-                                        mInvocationListener,
-                                        expectedCount,
-                                        runResultList,
-                                        i,
-                                        tearDownException);
-                            } else {
-                                CLog.d("No results to be forwarded for attempt %s.", i);
                             }
                         }
                     }
@@ -795,7 +808,13 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
             int maxRunLimit) {
         GranularRetriableTestWrapper retriableTest =
                 new GranularRetriableTestWrapper(
-                        test, this, listener, maxRunLimit, mUseModuleResultsForwarder);
+                        test,
+                        this,
+                        listener,
+                        maxRunLimit,
+                        mUseModuleResultsForwarder,
+                        mRemoveModuleBuffering,
+                        mTargetPreparerRetryCount);
         retriableTest.setModuleId(getId());
         retriableTest.setMarkTestsSkipped(skipTestCases);
         retriableTest.setMetricCollectors(mRunMetricCollectors);
@@ -868,13 +887,13 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
         // put metrics from the preparation
         metricsProto.put(
                 PREPARATION_TIME,
-                TfMetricProtoUtil.createSingleValue(mElapsedPreparation, "milliseconds"));
+                TfMetricProtoUtil.numericToMetric(mElapsedPreparation, "milliseconds"));
         metricsProto.put(
                 TEAR_DOWN_TIME,
-                TfMetricProtoUtil.createSingleValue(mElapsedTearDown, "milliseconds"));
+                TfMetricProtoUtil.numericToMetric(mElapsedTearDown, "milliseconds"));
         metricsProto.put(
-                TEST_TIME, TfMetricProtoUtil.createSingleValue(elapsedTime, "milliseconds"));
-        metricsProto.put(MODULE_TEST_COUNT, TfMetricProtoUtil.createSingleValue(numResults, "int"));
+                TEST_TIME, TfMetricProtoUtil.numericToMetric(elapsedTime, "milliseconds"));
+        metricsProto.put(MODULE_TEST_COUNT, TfMetricProtoUtil.numericToMetric(numResults, "int"));
         // Report all the retry informations
         if (!mRetryStats.isEmpty()) {
             if (attempt != null) {
@@ -882,19 +901,19 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
                 if (cost != 0L) {
                     metricsProto.put(
                             ISOLATION_COST,
-                            TfMetricProtoUtil.createSingleValue(cost, "milliseconds"));
+                            TfMetricProtoUtil.numericToMetric(cost, "milliseconds"));
                 }
             } else {
                 RetryStatistics agg = RetryStatistics.aggregateStatistics(mRetryStats);
                 metricsProto.put(
                         RETRY_TIME,
-                        TfMetricProtoUtil.createSingleValue(agg.mRetryTime, "milliseconds"));
+                        TfMetricProtoUtil.numericToMetric(agg.mRetryTime, "milliseconds"));
                 metricsProto.put(
                         RETRY_SUCCESS_COUNT,
-                        TfMetricProtoUtil.createSingleValue(agg.mRetrySuccess, ""));
+                        TfMetricProtoUtil.numericToMetric(agg.mRetrySuccess, ""));
                 metricsProto.put(
                         RETRY_FAIL_COUNT,
-                        TfMetricProtoUtil.createSingleValue(agg.mRetryFailure, ""));
+                        TfMetricProtoUtil.numericToMetric(agg.mRetryFailure, ""));
             }
         }
 
@@ -1359,6 +1378,10 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
         return mModuleConfiguration;
     }
 
+    public TestInformation getModuleTestInformation() {
+        return mModuleInfo;
+    }
+
     public void setReportModuleStart(boolean shouldReportModuleStart) {
         mReportModuleStart = shouldReportModuleStart;
     }
@@ -1373,31 +1396,46 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
             listener.testModuleStarted(getModuleInvocationContext());
         }
         if (mCurrentTestWrapper != null)  {
-            // do not report results if already reported once
-            if (!mFinalResultsReported) {
-                mRunListenersResults.add(mCurrentTestWrapper.getResultListener());
+            if (mRemoveModuleBuffering) {
                 HarnessRuntimeException interruptedException =
                         new HarnessRuntimeException(
                                 message, TestErrorIdentifier.MODULE_DID_NOT_EXECUTE);
-                for (int i = 0; i < mMaxRetry; i++) {
-                    // Get all the results for the attempt
-                    List<TestRunResult> runResultList = new ArrayList<TestRunResult>();
-                    int expectedCount = 0;
-                    for (ModuleListener attemptListener : mRunListenersResults) {
-                        for (String runName : attemptListener.getTestRunNames()) {
-                            TestRunResult run = attemptListener.getTestRunAtAttempt(runName, i);
-                            if (run != null) {
-                                runResultList.add(run);
-                                expectedCount += run.getExpectedTestCount();
+                FailureDescription description =
+                        CurrentInvocation.createFailure(
+                                        StreamUtil.getStackTrace(interruptedException), null)
+                                .setCause(interruptedException);
+                mCurrentTestWrapper.backfillMissingEvents(listener, description);
+            } else {
+                // do not report results if already reported once
+                if (!mFinalResultsReported) {
+                    mRunListenersResults.add(mCurrentTestWrapper.getResultListener());
+                    HarnessRuntimeException interruptedException =
+                            new HarnessRuntimeException(
+                                    message, TestErrorIdentifier.MODULE_DID_NOT_EXECUTE);
+                    for (int i = 0; i < mMaxRetry; i++) {
+                        // Get all the results for the attempt
+                        List<TestRunResult> runResultList = new ArrayList<TestRunResult>();
+                        int expectedCount = 0;
+                        for (ModuleListener attemptListener : mRunListenersResults) {
+                            for (String runName : attemptListener.getTestRunNames()) {
+                                TestRunResult run = attemptListener.getTestRunAtAttempt(runName, i);
+                                if (run != null) {
+                                    runResultList.add(run);
+                                    expectedCount += run.getExpectedTestCount();
+                                }
                             }
                         }
-                    }
 
-                    if (!runResultList.isEmpty()) {
-                        reportFinalResults(
-                                listener, expectedCount, runResultList, i, interruptedException);
-                    } else {
-                        CLog.d("No results to be forwarded for attempt %s.", i);
+                        if (!runResultList.isEmpty()) {
+                            reportFinalResults(
+                                    listener,
+                                    expectedCount,
+                                    runResultList,
+                                    i,
+                                    interruptedException);
+                        } else {
+                            CLog.d("No results to be forwarded for attempt %s.", i);
+                        }
                     }
                 }
             }
@@ -1579,7 +1617,7 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
         failureDescription.setCause(setupException);
         invocListener.testRunFailed(failureDescription);
         HashMap<String, Metric> metricsProto = new HashMap<>();
-        metricsProto.put(TEST_TIME, TfMetricProtoUtil.createSingleValue(0L, "milliseconds"));
+        metricsProto.put(TEST_TIME, TfMetricProtoUtil.numericToMetric(0L, "milliseconds"));
         invocListener.testRunEnded(0, metricsProto);
         // If it was a not available exception rethrow it to signal the new device state.
         if (setupException instanceof DeviceNotAvailableException) {
@@ -1618,4 +1656,8 @@ public class ModuleDefinition implements Comparable<ModuleDefinition>, ITestColl
     public void setUseModuleResultsForwarder(boolean useModuleResultsForwarder) {
         mUseModuleResultsForwarder = useModuleResultsForwarder;
     }
+
+    public void setRemoveModuleBuffering(boolean removeModuleBuffering) {
+        mRemoveModuleBuffering = removeModuleBuffering;
+    }
 }
diff --git a/src/com/android/tradefed/testtype/suite/RemoteTestTimeOutEnforcer.java b/src/com/android/tradefed/testtype/suite/RemoteTestTimeOutEnforcer.java
index ee641bdfe..32d051f1a 100644
--- a/src/com/android/tradefed/testtype/suite/RemoteTestTimeOutEnforcer.java
+++ b/src/com/android/tradefed/testtype/suite/RemoteTestTimeOutEnforcer.java
@@ -18,11 +18,13 @@ package com.android.tradefed.testtype.suite;
 import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
 import com.android.tradefed.result.FailureDescription;
 import com.android.tradefed.result.ITestInvocationListener;
+import com.android.tradefed.result.ResultAndLogForwarder;
 import com.android.tradefed.result.proto.TestRecordProto.FailureStatus;
 import com.android.tradefed.testtype.IRemoteTest;
 
 import java.time.Duration;
 import java.util.HashMap;
+import java.util.List;
 import java.util.concurrent.TimeUnit;
 
 /**
@@ -31,7 +33,7 @@ import java.util.concurrent.TimeUnit;
  *
  * <p>Note that this enforcer doesn't interrupt the tests, but will make them fail.
  */
-public class RemoteTestTimeOutEnforcer implements ITestInvocationListener {
+public class RemoteTestTimeOutEnforcer extends ResultAndLogForwarder {
 
     // The option name & description we want to share across class that uses the enforcer.
     public static final String REMOTE_TEST_TIMEOUT_OPTION = "remote-test-timeout";
@@ -41,7 +43,7 @@ public class RemoteTestTimeOutEnforcer implements ITestInvocationListener {
     private IRemoteTest mIRemoteTest;
     private Duration mTimeOut;
     private ModuleDefinition mModuleDefinition;
-    private ModuleListener mListener;
+    private ModuleListener mGranularListener;
 
     /**
      * Create the {@link RemoteTestTimeOutEnforcer} with the given timeout to enforce.
@@ -52,16 +54,20 @@ public class RemoteTestTimeOutEnforcer implements ITestInvocationListener {
      * @param timeOut The {@link Duration} of the time out per test run.
      */
     public RemoteTestTimeOutEnforcer(
-            ModuleListener listener,
+            List<ITestInvocationListener> allListeners,
             ModuleDefinition moduleDefinition,
             IRemoteTest test,
             Duration timeOut) {
-        mListener = listener;
+        super(allListeners);
         mIRemoteTest = test;
         mModuleDefinition = moduleDefinition;
         mTimeOut = timeOut;
     }
 
+    public void setGranularListener(ModuleListener listener) {
+        mGranularListener = listener;
+    }
+
     @Override
     public void testRunEnded(long elapsedTime, HashMap<String, Metric> runMetrics) {
         if (elapsedTime >= mTimeOut.toMillis()) {
@@ -72,11 +78,13 @@ public class RemoteTestTimeOutEnforcer implements ITestInvocationListener {
                             getMetaData(Integer.toString(mIRemoteTest.hashCode())),
                     TimeUnit.MILLISECONDS.toSeconds(elapsedTime),
                     mTimeOut.toSeconds());
-            if (!mListener.hasLastAttemptFailed()) {
+            if (!mGranularListener.hasLastAttemptFailed()) {
                 FailureDescription failure = FailureDescription.create(
                         failureString, FailureStatus.TIMED_OUT).setRetriable(false);
-                mListener.testRunFailed(failure);
+                mGranularListener.testRunFailed(failure);
+                super.testRunFailed(failure);
             }
         }
+        super.testRunEnded(elapsedTime, runMetrics);
     }
 }
diff --git a/src/com/android/tradefed/testtype/suite/TestMappingSuiteRunner.java b/src/com/android/tradefed/testtype/suite/TestMappingSuiteRunner.java
index 2f5cb5511..efdd391e8 100644
--- a/src/com/android/tradefed/testtype/suite/TestMappingSuiteRunner.java
+++ b/src/com/android/tradefed/testtype/suite/TestMappingSuiteRunner.java
@@ -62,12 +62,11 @@ import java.util.stream.Collectors;
 public class TestMappingSuiteRunner extends BaseTestSuite {
 
     @Option(
-        name = "test-mapping-test-group",
-        description =
-                "Group of tests to run, e.g., presubmit, postsubmit. The suite runner "
-                        + "shall load the tests defined in all TEST_MAPPING files in the source "
-                        + "code, through build artifact test_mappings.zip."
-    )
+            name = "test-mapping-test-group",
+            description =
+                    "Group of tests to run, e.g., presubmit, postsubmit. The suite runner shall"
+                        + " load the tests defined in all TEST_MAPPING files in the source code,"
+                        + " through build artifact test_mappings.zip.")
     private String mTestGroup = null;
 
     @Option(
@@ -92,29 +91,26 @@ public class TestMappingSuiteRunner extends BaseTestSuite {
     private Set<String> mIgnoreKeywords = new LinkedHashSet<>();
 
     @Option(
-        name = "force-test-mapping-module",
-        description =
-                "Run the specified tests only. The tests loaded from all TEST_MAPPING files in "
-                        + "the source code will be filtered again to force run the specified tests."
-    )
+            name = "force-test-mapping-module",
+            description =
+                    "Run the specified tests only. The tests loaded from all TEST_MAPPING files in"
+                        + " the source code will be filtered again to force run the specified"
+                        + " tests.")
     private Set<String> mTestModulesForced = new HashSet<>();
 
     @Option(
-        name = "test-mapping-path",
-        description = "Run tests according to the test mapping path."
-    )
+            name = "test-mapping-path",
+            description = "Run tests according to the test mapping path.")
     private List<String> mTestMappingPaths = new ArrayList<>();
 
     @Option(
-        name = RemoteTestTimeOutEnforcer.REMOTE_TEST_TIMEOUT_OPTION,
-        description = RemoteTestTimeOutEnforcer.REMOTE_TEST_TIMEOUT_DESCRIPTION
-    )
+            name = RemoteTestTimeOutEnforcer.REMOTE_TEST_TIMEOUT_OPTION,
+            description = RemoteTestTimeOutEnforcer.REMOTE_TEST_TIMEOUT_DESCRIPTION)
     private Duration mRemoteTestTimeOut = null;
 
     @Option(
-        name = "use-test-mapping-path",
-        description = "Whether or not to run tests based on the given test mapping path."
-    )
+            name = "use-test-mapping-path",
+            description = "Whether or not to run tests based on the given test mapping path.")
     private boolean mUseTestMappingPath = false;
 
     @Option(
@@ -177,10 +173,23 @@ public class TestMappingSuiteRunner extends BaseTestSuite {
 
     private static final String TEST_MAPPING_EXCLUDE_FILTER = "exclude-filter";
 
+    // Environment variable to indicate if it is in BWYN test discovery mode.
+    public static final String IS_BWYN_ENV_VAR_KEY = "IS_BWYN";
+
     private IBuildInfo mBuildInfo;
 
+    // If the environment variable is set, TestMappingSuiteRunner is in BWYN mode.
+    private boolean isBWYN = System.getenv(IS_BWYN_ENV_VAR_KEY) != null;
+
     public TestMappingSuiteRunner() {
         setSkipjarLoading(true);
+        if (isBWYN) {
+            // If TestMappingSuiteRunner is in BWYN test discovery mode, do include
+            // test mapping imports.
+            mIgnoreTestMappingImports = false;
+            // If TestMappingSuiteRunner is in BWYN test discovery mode, allow empty tests.
+            mAllowEmptyTests = true;
+        }
     }
 
     public Set<TestInfo> loadTestInfos() {
@@ -375,9 +384,8 @@ public class TestMappingSuiteRunner extends BaseTestSuite {
     private void addTestSourcesToConfig(
             IConfiguration config, List<IRemoteTest> tests, Set<String> sources) {
         for (IRemoteTest test : tests) {
-            config.getConfigurationDescription().addMetadata(
-                Integer.toString(test.hashCode()), new ArrayList<>(sources)
-            );
+            config.getConfigurationDescription()
+                    .addMetadata(Integer.toString(test.hashCode()), new ArrayList<>(sources));
         }
     }
 
@@ -421,8 +429,7 @@ public class TestMappingSuiteRunner extends BaseTestSuite {
                             String.format("%s %s", testInfo.getName(), option.getValue()));
                     break;
                 default:
-                    String moduleArg =
-                            String.format("%s:%s", testInfo.getName(), option.getName());
+                    String moduleArg = String.format("%s:%s", testInfo.getName(), option.getName());
                     if (option.getValue() != null && !option.getValue().isEmpty()) {
                         moduleArg = String.format("%s:%s", moduleArg, option.getValue());
                     }
@@ -524,8 +531,7 @@ public class TestMappingSuiteRunner extends BaseTestSuite {
      */
     @VisibleForTesting
     Set<TestInfo> getTestInfos(Set<TestInfo> testInfos, String moduleName) {
-        return testInfos
-                .stream()
+        return testInfos.stream()
                 .filter(testInfo -> moduleName.equals(testInfo.getName()))
                 .collect(Collectors.toSet());
     }
@@ -584,7 +590,7 @@ public class TestMappingSuiteRunner extends BaseTestSuite {
                         e);
             } finally {
                 if (deleteFile) {
-                FileUtil.recursiveDelete(testListFile);
+                    FileUtil.recursiveDelete(testListFile);
                 }
             }
         }
diff --git a/src/com/android/tradefed/util/BuildTestsZipUtils.java b/src/com/android/tradefed/util/BuildTestsZipUtils.java
index 63ab25bae..f4d08fe50 100644
--- a/src/com/android/tradefed/util/BuildTestsZipUtils.java
+++ b/src/com/android/tradefed/util/BuildTestsZipUtils.java
@@ -19,6 +19,7 @@ import com.android.tradefed.build.IBuildInfo;
 import com.android.tradefed.build.IDeviceBuildInfo;
 import com.android.tradefed.invoker.logger.InvocationMetricLogger;
 import com.android.tradefed.invoker.logger.InvocationMetricLogger.InvocationMetricKey;
+import com.android.tradefed.log.LogUtil;
 import com.android.tradefed.targetprep.AltDirBehavior;
 
 import java.io.File;
@@ -50,6 +51,30 @@ public class BuildTestsZipUtils {
     public static File getApkFile(IBuildInfo buildInfo, String apkFileName,
             List<File> altDirs, AltDirBehavior altDirBehavior,
             boolean lookupInResource, String deviceSigningKey) throws IOException {
+        File src = null;
+        try {
+            src =
+                    SearchArtifactUtil.searchFile(
+                            apkFileName,
+                            true,
+                            null,
+                            altDirs,
+                            altDirBehavior,
+                            null,
+                            buildInfo,
+                            false);
+        } catch (Exception e) {
+            // TODO: handle error when migration is complete.
+            LogUtil.CLog.e(e);
+        }
+        if (src != null && src.exists()) {
+            return src;
+        } else {
+            // Silently report not found and fall back to old logic.
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricKey.SEARCH_ARTIFACT_FAILURE_COUNT, 1);
+        }
+
         String apkBase = apkFileName.split("\\.")[0];
 
         List<File> dirs = new ArrayList<>();
@@ -153,6 +178,9 @@ public class BuildTestsZipUtils {
                 return apkFile;
             }
         }
+        // if old logic fails too, do not report search artifact failure
+        InvocationMetricLogger.addInvocationMetrics(
+                InvocationMetricKey.SEARCH_ARTIFACT_FAILURE_COUNT, -1);
         return null;
     }
 }
diff --git a/src/com/android/tradefed/util/PerfettoTraceRecorder.java b/src/com/android/tradefed/util/PerfettoTraceRecorder.java
index 0dcf195ed..763bc8416 100644
--- a/src/com/android/tradefed/util/PerfettoTraceRecorder.java
+++ b/src/com/android/tradefed/util/PerfettoTraceRecorder.java
@@ -60,9 +60,12 @@ public class PerfettoTraceRecorder {
      * PerfettoTraceRecorder#stopTrace(ITestDevice)} afterwards to stop the trace recording.
      *
      * @param device A {@link ITestDevice} where trace will be recorded.
+     * @param traceConfigFileName Name of the trace config file in the test artifacts. If null, use
+     *     the default config instead.
      * @param extraConfigs A map of extra configs that needs to be added in the trace config file.
      */
-    public void startTrace(ITestDevice device, Map<String, String> extraConfigs)
+    public void startTrace(
+            ITestDevice device, String traceConfigFileName, Map<String, String> extraConfigs)
             throws IOException {
         if (deviceMetadataMap.containsKey(device)) {
             CLog.d(
@@ -87,12 +90,27 @@ public class PerfettoTraceRecorder {
         RunUtil.getDefault()
                 .runTimedCmd(10000, "chmod", "u+x", perfettoExecutable.getAbsolutePath());
 
-        // Get the trace config file from resource
-        File traceConfigFile = FileUtil.createTempFile("trace_config", ".textproto");
-        InputStream configStream =
-                PerfettoTraceRecorder.class.getResourceAsStream("/perfetto/trace_config.textproto");
-        String configStr = StreamUtil.getStringFromStream(configStream);
-        // insert extra configs in the trace config file
+        // Read the trace config into a string.
+        String configStr = null;
+        if (traceConfigFileName == null) {
+            // If no file name was given, get the default trace config from resource.
+            InputStream configStream =
+                    PerfettoTraceRecorder.class.getResourceAsStream(
+                            "/perfetto/trace_config.textproto");
+            configStr = StreamUtil.getStringFromStream(configStream);
+        } else {
+            // Otherwise retrieve it from the test artifacts.
+            File file = SearchArtifactUtil.searchFile(traceConfigFileName, true);
+            if (file == null) {
+                CLog.e(
+                        "Failed to retrieve trace config file %s from test artifacts",
+                        traceConfigFileName);
+                return;
+            }
+            configStr = FileUtil.readStringFromFile(file);
+        }
+
+        // insert extra configs in the trace config
         if (extraConfigs != null) {
             StringBuilder sb = new StringBuilder();
             for (Map.Entry<String, String> configKeyValue : extraConfigs.entrySet()) {
@@ -103,6 +121,9 @@ public class PerfettoTraceRecorder {
             String injectedStr = sb.toString();
             configStr = configStr.replace("# {injected_config}", injectedStr);
         }
+
+        // Write the trace config to a temp file.
+        File traceConfigFile = FileUtil.createTempFile("trace_config", ".textproto");
         FileUtil.writeToFile(configStr, traceConfigFile);
 
         deviceTraceMetadata.setTraceConfig(traceConfigFile, true);
diff --git a/src/com/android/tradefed/util/image/IncrementalImageUtil.java b/src/com/android/tradefed/util/image/IncrementalImageUtil.java
index 1f33e2223..70c0a90bd 100644
--- a/src/com/android/tradefed/util/image/IncrementalImageUtil.java
+++ b/src/com/android/tradefed/util/image/IncrementalImageUtil.java
@@ -18,7 +18,6 @@ package com.android.tradefed.util.image;
 import static org.junit.Assert.assertTrue;
 
 import com.android.ddmlib.Log.LogLevel;
-import com.android.tradefed.build.IBuildInfo;
 import com.android.tradefed.build.IDeviceBuildInfo;
 import com.android.tradefed.device.DeviceNotAvailableException;
 import com.android.tradefed.device.IManagedTestDevice;
@@ -51,6 +50,7 @@ import com.android.tradefed.util.ZipUtil2;
 import com.android.tradefed.util.executor.ParallelDeviceExecutor;
 import com.android.tradefed.util.image.DeviceImageTracker.FileCacheTracker;
 
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 
 import java.io.File;
@@ -96,10 +96,8 @@ public class IncrementalImageUtil {
     private final SnapuserdWaitPhase mWaitPhase;
 
     private boolean mAllowSameBuildFlashing = false;
-    private boolean mAllowUnzipBaseline = false;
-    private boolean mBootloaderNeedsFlashing = false;
-    private boolean mBasebandNeedsFlashing = false;
     private boolean mUpdateWasCompleted = false;
+    private boolean mSkipBootloaderVersionCheck = false;
     private File mSourceDirectory;
     private File mTargetDirectory;
 
@@ -113,11 +111,10 @@ public class IncrementalImageUtil {
             boolean isIsolatedSetup,
             boolean allowTrackerlessUpdate,
             Set<String> allowedTransition,
-            boolean newFlow,
             boolean updateBootloaderFromUserspace,
-            SnapuserdWaitPhase waitPhase,
-            boolean useMerkleTree)
+            SnapuserdWaitPhase waitPhase)
             throws DeviceNotAvailableException {
+        boolean useMerkleTree = true;
         String serialNumber = device.getSerialNumber();
         FileCacheTracker tracker =
                 DeviceImageTracker.getDefaultCache().getBaselineDeviceImage(serialNumber);
@@ -179,6 +176,11 @@ public class IncrementalImageUtil {
                         CLog.w("Failed to pull merkle tree");
                         FileUtil.recursiveDelete(merkleTreeDir);
                         merkleTreeDir = null;
+                    } else if (merkleTreeDir.list().length == 0) {
+                        CLog.w("Merkle tree dir is empty. Is verity disabled?");
+                        FileUtil.recursiveDelete(merkleTreeDir);
+                        merkleTreeDir = null;
+                        return null;
                     }
                 } catch (IOException e) {
                     CLog.e(e);
@@ -187,11 +189,14 @@ public class IncrementalImageUtil {
                 }
             }
         }
+        // We need the merkle tree now to compare
+        if (merkleTreeDir == null) {
+            return null;
+        }
         return new IncrementalImageUtil(
                 device,
                 build.getDeviceImageFile(),
                 createSnapshot,
-                newFlow,
                 updateBootloaderFromUserspace,
                 waitPhase,
                 merkleTreeDir);
@@ -201,14 +206,13 @@ public class IncrementalImageUtil {
             ITestDevice device,
             File targetImage,
             File createSnapshot,
-            boolean newFlow,
             boolean updateBootloaderFromUserspace,
             SnapuserdWaitPhase waitPhase,
             File deviceMerkleTree) {
         mDevice = device;
+        mNewFlow = true;
         mApplySnapshot = true;
         mWipeAfterApplySnapshot = true;
-        mNewFlow = newFlow;
         mUpdateBootloaderFromUserspace = updateBootloaderFromUserspace;
         mWaitPhase = waitPhase;
 
@@ -240,27 +244,6 @@ public class IncrementalImageUtil {
         mParallelSetup.start();
     }
 
-    private static File copyImage(File originalImage) throws IOException {
-        if (originalImage.isDirectory()) {
-            CLog.d("Baseline was already unzipped for %s", originalImage);
-            File copy =
-                    FileUtil.createTempDir(
-                            FileUtil.getBaseName(originalImage.getName()),
-                            CurrentInvocation.getWorkFolder());
-            FileUtil.recursiveHardlink(originalImage, copy);
-            return copy;
-        } else {
-            File copy =
-                    FileUtil.createTempFile(
-                            FileUtil.getBaseName(originalImage.getName()),
-                            ".img",
-                            CurrentInvocation.getWorkFolder());
-            copy.delete();
-            FileUtil.hardlinkFile(originalImage, copy);
-            return copy;
-        }
-    }
-
     /** Returns whether or not we can use the snapshot logic to update the device */
     public static boolean isSnapshotSupported(ITestDevice device, boolean useMerkle)
             throws DeviceNotAvailableException {
@@ -285,14 +268,6 @@ public class IncrementalImageUtil {
         return false;
     }
 
-    public void notifyBootloaderNeedsRevert() {
-        mBootloaderNeedsFlashing = true;
-    }
-
-    public void notifyBasebadNeedsRevert() {
-        mBasebandNeedsFlashing = true;
-    }
-
     public void allowSameBuildFlashing() {
         mAllowSameBuildFlashing = true;
     }
@@ -301,14 +276,14 @@ public class IncrementalImageUtil {
         return mAllowSameBuildFlashing;
     }
 
-    public void allowUnzipBaseline() {
-        mAllowUnzipBaseline = true;
-    }
-
     public boolean useUpdatedFlow() {
         return mNewFlow;
     }
 
+    public void setSkipBootloaderVersionCheck(boolean skipBootloaderVersionCheck) {
+        mSkipBootloaderVersionCheck = skipBootloaderVersionCheck;
+    }
+
     /** Returns whether device is currently using snapshots or not. */
     public static boolean isSnapshotInUse(ITestDevice device) throws DeviceNotAvailableException {
         CommandResult dumpOutput = device.executeShellV2Command("snapshotctl dump");
@@ -478,9 +453,9 @@ public class IncrementalImageUtil {
             // Once block comparison is successful, log the information
             logTargetInformation(targetDirectory);
             long totalPatchSizes = logPatchesInformation(workDir);
-            // if we have more than 2.5GB we will overflow super partition size to /data and we
+            // if we have more than 2.0GB we will overflow super partition size to /data and we
             // can't use the feature
-            if (totalPatchSizes > 2300000000L) {
+            if (totalPatchSizes > 2000000000L) {
                 InvocationMetricLogger.addInvocationMetrics(
                         InvocationMetricKey.INCREMENTAL_FALLBACK_REASON, "Patches too large.");
                 throw new TargetSetupError(
@@ -692,38 +667,6 @@ public class IncrementalImageUtil {
         }
     }
 
-    private void revertBootloaderAndBasebandifNeeded(File bootloader, File baseband)
-            throws DeviceNotAvailableException {
-        if (mBootloaderNeedsFlashing) {
-            if (bootloader == null) {
-                CLog.w("No bootloader file to flash.");
-            } else {
-                mDevice.rebootIntoBootloader();
-
-                CommandResult bootloaderFlashTarget =
-                        mDevice.executeFastbootCommand(
-                                "flash", "bootloader", bootloader.getAbsolutePath());
-                CLog.d("Status: %s", bootloaderFlashTarget.getStatus());
-                CLog.d("stdout: %s", bootloaderFlashTarget.getStdout());
-                CLog.d("stderr: %s", bootloaderFlashTarget.getStderr());
-            }
-        }
-        if (mBasebandNeedsFlashing) {
-            if (baseband == null) {
-                CLog.w("No baseband file to flash");
-            } else {
-                mDevice.rebootIntoBootloader();
-
-                CommandResult radioFlashTarget =
-                        mDevice.executeFastbootCommand(
-                                "flash", "radio", baseband.getAbsolutePath());
-                CLog.d("Status: %s", radioFlashTarget.getStatus());
-                CLog.d("stdout: %s", radioFlashTarget.getStdout());
-                CLog.d("stderr: %s", radioFlashTarget.getStderr());
-            }
-        }
-    }
-
     private void blockCompare(File srcImage, File srcMerkleTree, File targetImage, File workDir) {
         try (CloseableTraceScope ignored =
                 new CloseableTraceScope("block_compare:" + srcImage.getName())) {
@@ -770,16 +713,23 @@ public class IncrementalImageUtil {
         }
         Map<String, String> envMap = new HashMap<>();
         envMap.put("ANDROID_PRODUCT_OUT", imageDirectory.getAbsolutePath());
+        ImmutableList.Builder<String> cmdArgsBuilder = new ImmutableList.Builder<>();
+        cmdArgsBuilder.add(
+                "flashall", "--exclude-dynamic-partitions", "--disable-super-optimization");
+        if (mSkipBootloaderVersionCheck) {
+            cmdArgsBuilder.add("--force");
+        }
+        List<String> cmdArgs = cmdArgsBuilder.build();
         CommandResult fastbootResult =
                 mDevice.executeLongFastbootCommand(
                         envMap,
-                        "flashall",
-                        "--exclude-dynamic-partitions",
-                        "--disable-super-optimization");
+                        cmdArgs.toArray(new String[cmdArgs.size()]));
         CLog.d("Status: %s", fastbootResult.getStatus());
         CLog.d("stdout: %s", fastbootResult.getStdout());
         CLog.d("stderr: %s", fastbootResult.getStderr());
-        if (!CommandStatus.SUCCESS.equals(fastbootResult.getStatus())) {
+        if ((!CommandStatus.SUCCESS.equals(fastbootResult.getStatus())
+                && FastbootDeviceFlasher.stderrContainsFailed(
+                        fastbootResult.getStderr(), mSkipBootloaderVersionCheck))) {
             return false;
         }
         RecoveryMode recoveryMode = mDevice.getRecoveryMode();
@@ -865,25 +815,6 @@ public class IncrementalImageUtil {
         }
     }
 
-    private static String getSplVersion(IBuildInfo build) {
-        File buildProp = build.getFile("build.prop");
-        if (buildProp == null) {
-            CLog.d("No target build.prop found for comparison.");
-            return null;
-        }
-        try {
-            String props = FileUtil.readStringFromFile(buildProp);
-            for (String line : props.split("\n")) {
-                if (line.startsWith("ro.build.version.security_patch=")) {
-                    return line.split("=")[1];
-                }
-            }
-        } catch (IOException e) {
-            CLog.e(e);
-        }
-        return null;
-    }
-
     private class ParallelPreparation extends Thread {
 
         private final File mDeviceOriginMerkleTree;
diff --git a/src/com/android/tradefed/util/testmapping/TestMapping.java b/src/com/android/tradefed/util/testmapping/TestMapping.java
index 88ef9b7cd..f6fcfbd22 100644
--- a/src/com/android/tradefed/util/testmapping/TestMapping.java
+++ b/src/com/android/tradefed/util/testmapping/TestMapping.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2018 The Android Open Source Project
+ * Copyright (C) 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -309,13 +309,17 @@ public class TestMapping {
             return;
         }
 
-        if (Files.notExists(testMappingDir)) {
-            CLog.d("TEST_MAPPING path not found: %s.", testMappingDir);
+        if (Files.notExists(testMappingDir) || !Files.isDirectory(testMappingDir)) {
+            CLog.d("TEST_MAPPING path not found or not a directory: %s.", testMappingDir);
             return;
         }
 
         try {
             Path testMappingPath = testMappingDir.resolve(TEST_MAPPING);
+            if (!Files.exists(testMappingPath)) {
+                CLog.d("TEST_MAPPING path not found: %s.", testMappingPath);
+                return;
+            }
             filePaths.add(testMappingPath);
             String content =
                     removeComments(
@@ -335,13 +339,23 @@ public class TestMapping {
                     Path normImportPath =
                             Paths.get(testMappingsRootDir.toString(), importPath.toString());
 
+                    if (!Files.exists(normImportPath)) {
+                        continue;
+                    }
+                    // Force to import a directory to align with the search logic.
+                    if (Files.isRegularFile(normImportPath)){
+                        normImportPath = normImportPath.getParent();
+                    }
+
                     Path importPathTestMappingPath = normImportPath.resolve(TEST_MAPPING);
-                    if (!filePaths.contains(importPathTestMappingPath)) {
-                        if (Files.exists(importPathTestMappingPath)) {
-                            filePaths.add(importPathTestMappingPath);
-                        }
-                        listTestMappingFiles(importPath, testMappingsRootDir, filePaths);
+                    if (!Files.exists(importPathTestMappingPath)) {
+                        continue;
+                    }
+                    if (filePaths.contains(importPathTestMappingPath)) {
+                        continue;
                     }
+                    filePaths.add(importPathTestMappingPath);
+                    listTestMappingFiles(normImportPath, testMappingsRootDir, filePaths);
                 }
             }
 
diff --git a/src/com/google/android/tradefed/build/AbLocalBuildProvider.java b/src/com/google/android/tradefed/build/AbLocalBuildProvider.java
new file mode 100644
index 000000000..4685eb6fb
--- /dev/null
+++ b/src/com/google/android/tradefed/build/AbLocalBuildProvider.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.tradefed.build;
+
+import static com.google.android.tradefed.util.androidbuildapi.AndroidBuildAPIHelper.BUILD_ENV_INVOCATION_CONTEXT_KEY;
+
+import com.android.tradefed.build.BuildRetrievalError;
+import com.android.tradefed.build.IBuildInfo;
+import com.android.tradefed.build.StubBuildProvider;
+import com.android.tradefed.invoker.IInvocationContext;
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.result.error.InfraErrorIdentifier;
+import com.android.tradefed.testtype.IInvocationContextReceiver;
+
+import com.google.android.tradefed.result.teststorage.Client;
+import com.google.android.tradefed.result.teststorage.ITestStorageClient;
+import com.google.api.services.androidbuildinternal.v3.model.Build;
+import com.google.api.services.androidbuildinternal.v3.model.Target;
+
+import java.io.IOException;
+import java.security.GeneralSecurityException;
+import java.util.UUID;
+
+/**
+ * Local build provider that creates a local build on Android build. TODO: Update this to also be
+ * able to bootstrap device build info.
+ */
+public class AbLocalBuildProvider extends StubBuildProvider implements IInvocationContextReceiver {
+
+    public static final String LOCAL_BUILD = "local_build";
+
+    private IInvocationContext mContext;
+
+    @Override
+    public void setInvocationContext(IInvocationContext invocationContext) {
+        mContext = invocationContext;
+    }
+
+    @Override
+    public IBuildInfo getBuild() throws BuildRetrievalError {
+        IBuildInfo info = super.getBuild();
+        try {
+            Build localBuild =
+                    createLocalBuild(mContext, info.getBuildBranch(), info.getBuildFlavor());
+            CLog.d("Created the following local build: %s", localBuild);
+            info.setBuildId(localBuild.getBuildId());
+        } catch (IOException | GeneralSecurityException e) {
+            throw new BuildRetrievalError(
+                    "Failed to create storage client", e, InfraErrorIdentifier.UNDETERMINED);
+        }
+        return info;
+    }
+
+    private static ITestStorageClient createTestStorageClient(IInvocationContext context)
+            throws GeneralSecurityException, IOException {
+        String buildEnvironment = context.getAttribute(BUILD_ENV_INVOCATION_CONTEXT_KEY);
+        if (buildEnvironment.isEmpty()) {
+            buildEnvironment = "prod";
+        }
+        return Client.create(buildEnvironment, false, false, false);
+    }
+
+    private static Build newBuild(String branch, String buildFlavor) {
+        Build build = new Build().setExternalId(UUID.randomUUID().toString());
+        build.setCreationTimestamp(System.currentTimeMillis());
+        build.setBranch(branch);
+        // Build id will be created when build is created
+        build.setBuildId("");
+        Target target = new Target();
+        target.setName(buildFlavor);
+        target.setTarget(buildFlavor);
+        build.setTarget(target);
+        build.setBuildAttemptStatus("complete");
+        build.setCompletionTimestamp(System.currentTimeMillis());
+        return build;
+    }
+
+    /** Create a local build on the remote AB server and returns its reference. */
+    public static Build createLocalBuild(
+            IInvocationContext context, String branch, String buildFlavor)
+            throws IOException, GeneralSecurityException {
+        ITestStorageClient client = createTestStorageClient(context);
+        Build localBuild = newBuild(branch, buildFlavor);
+        return client.createLocalBuild(localBuild);
+    }
+}
diff --git a/src/com/google/android/tradefed/build/RemoteBuildInfo.java b/src/com/google/android/tradefed/build/RemoteBuildInfo.java
new file mode 100644
index 000000000..f64b63f48
--- /dev/null
+++ b/src/com/google/android/tradefed/build/RemoteBuildInfo.java
@@ -0,0 +1,298 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.tradefed.build;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/** Container for launch control build info response. */
+public class RemoteBuildInfo {
+
+    public static final String UNKNOWN_BUILD_ID = "0";
+    static final String DEFAULT_BUILD_ATTEMPT_ID = "0";
+
+    public enum BuildType {
+        /** external build. */
+        EXTERNAL("external"),
+
+        /** local build. */
+        LOCAL("local"),
+
+        /** presubmit build. */
+        PENDING("pending"),
+
+        /** postsubmit build. */
+        SUBMITTED("submitted"),
+
+        /** train build. */
+        TRAIN("train");
+
+        private final String mBuildType;
+
+        private BuildType(String buildType) {
+            mBuildType = buildType;
+        }
+
+        @Override
+        public String toString() {
+            return mBuildType;
+        }
+    }
+
+    public enum BuildAttributeKey {
+        /** The unique identifier of the build. */
+        BUILD_ID("bid"),
+
+        /** The branch of the build */
+        BRANCH("branch"),
+
+        /** An alias for the build. Typically used for release-branch builds. ie IMM76 */
+        BUILD_ALIAS("rc"),
+
+        /**
+         * The build name aka target. Format is currently <branch>-<platform>-<build-flavor> e.g.
+         * git_donut-linux-opal-userdebug.
+         */
+        BUILD_TARGET_NAME("target"),
+
+        /** The build type */
+        BUILD_TYPE("build_type"),
+
+        /** The build attempt ID */
+        BUILD_ATTEMPT_ID("build_attempt_id"),
+
+        /** The device image zip */
+        DEVICE_IMAGE("updater"),
+
+        /** User data image */
+        USER_DATA("userdata"),
+
+        /** Emulator binary zip file path */
+        EMULATOR("emulator"),
+
+        /** Additional files. */
+        FILES("files"),
+
+        /** Sdk zip file path */
+        SDK("sdk"),
+
+        /** Tests zip file path */
+        TESTS_ZIP("tests-zip"),
+
+        /** Target files path */
+        TARGET_FILES("target_files"),
+
+        /** application apk and test apk file paths. */
+        APP_APKS("apks"),
+
+        /** The device OTA package (a zip) */
+        OTA_PACKAGE("ota"),
+
+        /** The CTS zip file path */
+        CTS("cts"),
+
+        /** The VTS zip file path */
+        VTS("vts"),
+
+        /** The mkbootimg path */
+        MKBOOTIMG("mkbootimg"),
+
+        /** The ramdisk path */
+        RAMDISK("ramdisk"),
+
+        /** The bootloader path */
+        BOOTLOADER("bootloader"),
+
+        /** The baseband path */
+        BASEBAND("baseband"),
+
+        /** The google-tradefed.zip file path */
+        TF("tf");
+
+        private String mRemoteValue;
+
+        /**
+         * Create a {@link BuildAttributeKey}.
+         *
+         * @param remoteValue the {@link String} value that represents the actual value passed to
+         *     launch control.
+         */
+        BuildAttributeKey(String remoteValue) {
+            mRemoteValue = remoteValue;
+        }
+
+        /** Gets the internal value for the {@link BuildAttributeKey}. */
+        public String getRemoteValue() {
+            return mRemoteValue;
+        }
+    }
+
+    /** Thrown if server response is not recognized. */
+    @SuppressWarnings("serial")
+    static class InvalidResponseException extends Exception {
+        InvalidResponseException(String msg) {
+            super(msg);
+        }
+    }
+
+    private Map<String, String> mAttributeMap;
+
+    /** Package private for use in tests without calling parse */
+    RemoteBuildInfo() {
+        mAttributeMap = new HashMap<String, String>();
+    }
+
+    /**
+     * Parse a remote build info from the server response.
+     *
+     * <p>Expected return result is one or more lines of <code>build_attribute_name:value</code>
+     * pairs
+     *
+     * @param serverResponse the {@link String} launch control response to be parsed
+     * @return a {@link RemoteBuildInfo} or <code>null</code> if no build is available.
+     * @throws InvalidResponseException if server response is invalid
+     */
+    public static RemoteBuildInfo parseRemoteBuildInfo(String serverResponse)
+            throws InvalidResponseException {
+        // an empty response means no build available
+        // TODO: change protocol so lc returns explicit code for 'no build available'
+        if (serverResponse.trim().length() == 0) {
+            return null;
+        }
+        final String[] responseLines = serverResponse.split("\n");
+        RemoteBuildInfo buildInfo = new RemoteBuildInfo();
+        for (String responsePair : responseLines) {
+            final String[] pair = responsePair.split(":", 2);
+            if (pair.length >= 2) {
+                buildInfo.addAttribute(pair[0], pair[1]);
+            }
+        }
+        if (buildInfo.getBuildId() == null || buildInfo.getBuildId().equals(UNKNOWN_BUILD_ID)) {
+            throw new InvalidResponseException(
+                    String.format("Server response %s is missing build id", serverResponse));
+        }
+        // Set default build attempt id and build type.
+        if (buildInfo.getAttribute(BuildAttributeKey.BUILD_ATTEMPT_ID) == null) {
+            buildInfo.addAttribute(BuildAttributeKey.BUILD_ATTEMPT_ID, DEFAULT_BUILD_ATTEMPT_ID);
+        }
+        if (buildInfo.getAttribute(BuildAttributeKey.BUILD_TYPE) == null) {
+            buildInfo.addAttribute(
+                    BuildAttributeKey.BUILD_TYPE,
+                    parseBuildType(buildInfo.getBuildId()).toString());
+        }
+        return buildInfo;
+    }
+
+    /**
+     * Parse build type from build id.
+     *
+     * <p>There are a number of different built types supported by the build server. External builds
+     * are prefixed by "E", local builds by "L", pending builds by "P", and mainline train builds by
+     * "T". All other builds are treated as submitted or post submit.
+     *
+     * @param buildId The build ID
+     * @return The {@link BuildType}.
+     */
+    public static BuildType parseBuildType(String buildId) {
+        if (buildId == null) {
+            // Default to submitted.
+            return BuildType.SUBMITTED;
+        }
+        if (buildId.startsWith("E")) {
+            return BuildType.EXTERNAL;
+        }
+        if (buildId.startsWith("L")) {
+            return BuildType.LOCAL;
+        }
+        if (buildId.startsWith("P")) {
+            return BuildType.PENDING;
+        }
+        if (buildId.startsWith("T")) {
+            return BuildType.TRAIN;
+        }
+        // Default to submitted.
+        return BuildType.SUBMITTED;
+    }
+
+    /**
+     * Add a build attribute.
+     *
+     * @param key the unique {@link String} name of the attribute.
+     * @param value the {@link String} value of the attribute.
+     */
+    private void addAttribute(String key, String value) {
+        mAttributeMap.put(key, value);
+    }
+
+    /**
+     * Add a build attribute.
+     *
+     * @param key the unique {@link BuildAttributeKey} name of the attribute.
+     * @param value the {@link String} value of the attribute.
+     */
+    void addAttribute(BuildAttributeKey key, String value) {
+        addAttribute(key.getRemoteValue(), value);
+    }
+
+    /**
+     * Retrieve a build attribute value from a pre-defined key.
+     *
+     * @param key the {@link BuildAttributeKey}.
+     * @return the {@link String} build attribute value, or <code>null</code> if it cannot be found.
+     */
+    public String getAttribute(BuildAttributeKey key) {
+        return getAttribute(key.getRemoteValue());
+    }
+
+    /**
+     * Retrieve a build attribute value from its launch control defined name.
+     *
+     * <p>Its preferable to use {@link #getAttribute(BuildAttributeKey)} instead.
+     *
+     * @param key the {@link String} unique name of the attribute.
+     * @return the {@link String} build attribute value, or <code>null</code> if it cannot be found.
+     */
+    public String getAttribute(String key) {
+        return mAttributeMap.get(key);
+    }
+
+    /**
+     * Helper method to retrieve the build id.
+     *
+     * @return the build id or {@link #UNKNOWN_BUILD_ID} if build id was missing from server
+     *     response.
+     */
+    public String getBuildId() {
+        String idString = getAttribute(BuildAttributeKey.BUILD_ID);
+        if (idString == null) {
+            return UNKNOWN_BUILD_ID;
+        }
+        return idString;
+    }
+
+    @Override
+    public String toString() {
+        return mAttributeMap.toString();
+    }
+
+    @Override
+    public RemoteBuildInfo clone() {
+        RemoteBuildInfo clone = new RemoteBuildInfo();
+        clone.mAttributeMap = new HashMap<>(mAttributeMap);
+        return clone;
+    }
+}
diff --git a/src/com/google/android/tradefed/result/AndroidBuildApiLogSaver.java b/src/com/google/android/tradefed/result/AndroidBuildApiLogSaver.java
new file mode 100644
index 000000000..f72d88e0c
--- /dev/null
+++ b/src/com/google/android/tradefed/result/AndroidBuildApiLogSaver.java
@@ -0,0 +1,1596 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.tradefed.result;
+
+import static com.google.android.tradefed.util.androidbuildapi.AndroidBuildAPIHelper.BUILD_ENV_INVOCATION_CONTEXT_KEY;
+
+import com.android.tradefed.build.BuildInfo;
+import com.android.tradefed.build.IBuildInfo;
+import com.android.tradefed.config.Option;
+import com.android.tradefed.config.OptionClass;
+import com.android.tradefed.invoker.IInvocationContext;
+import com.android.tradefed.invoker.TestInvocation;
+import com.android.tradefed.invoker.logger.InvocationMetricLogger;
+import com.android.tradefed.invoker.logger.InvocationMetricLogger.InvocationMetricKey;
+import com.android.tradefed.invoker.tracing.CloseableTraceScope;
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.result.ILogSaver;
+import com.android.tradefed.result.LogDataType;
+import com.android.tradefed.result.LogFile;
+import com.android.tradefed.result.LogFileSaver;
+import com.android.tradefed.sandbox.TradefedSandbox;
+import com.android.tradefed.testtype.SubprocessTfLauncher;
+import com.android.tradefed.util.FileUtil;
+import com.android.tradefed.util.IRunUtil;
+import com.android.tradefed.util.RunInterruptedException;
+import com.android.tradefed.util.RunUtil;
+import com.android.tradefed.util.StreamUtil;
+import com.android.tradefed.util.executor.ParallelDeviceExecutor;
+
+import com.google.android.tradefed.build.AbLocalBuildProvider;
+import com.google.android.tradefed.build.RemoteBuildInfo;
+import com.google.android.tradefed.result.teststorage.ObjectUpdater;
+import com.google.android.tradefed.util.androidbuildapi.AndroidBuildAPIHelper;
+import com.google.api.client.googleapis.json.GoogleJsonResponseException;
+import com.google.api.client.http.AbstractInputStreamContent;
+import com.google.api.client.http.FileContent;
+import com.google.api.client.http.HttpResponseException;
+import com.google.api.services.androidbuildinternal.Androidbuildinternal;
+import com.google.api.services.androidbuildinternal.Androidbuildinternal.Testartifact;
+import com.google.api.services.androidbuildinternal.model.BuildArtifactMetadata;
+import com.google.api.services.androidbuildinternal.model.TestResult;
+import com.google.api.services.androidbuildinternal.v3.model.Build;
+import com.google.api.services.androidbuildinternal.v3.model.TestArtifactListResponse;
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.base.Strings;
+import com.google.common.net.UrlEscapers;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.HttpURLConnection;
+import java.security.GeneralSecurityException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.LinkedHashSet;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.concurrent.TimeUnit;
+
+/** A class that saves log files to the Android Build API. */
+@OptionClass(alias = "android-build-api-log-saver")
+public class AndroidBuildApiLogSaver implements ILogSaver {
+    private static final String ANDROID_BUILD_API_PATHSEP = "/";
+    private static final String BUILD_ATTEMPT_ID = "build_attempt_id";
+    private static final String DEFAULT_BUILD_ATTEMPT_ID = "0";
+    private static final String BUILD_TARGET = "build_target";
+    private static final String TEST_RESULT_ID = "test_result_id";
+    private static final int DEFAULT_MAX_UPLOAD_ATTEMPTS = 3;
+    private static final int INIT_ATTEMPTS_WAIT_TIME = 500; // ms
+    private static final long UPLOAD_THREAD_JOIN_TIMEOUT_MS = 10 * 60 * 1000;
+    static final String URL_TEMPLATE =
+            "https://android-build.googleplex.com/builds/%s/%s/%s/%s/tests/%s/";
+    private static final String INVOCATION_ID_KEY = "invocation_id";
+    private static final String WORK_UNIT_ID_KEY = "work_unit_id";
+    // Key that determines if we are using legacy V2 api or only v3 api for logs
+    private static final String ARTIFACT_UPLOAD_KEY = "use_artifact_v3_api";
+
+    // Some test invocation (special subprocess invocation) do not have full build infos.
+    // Without full build infos, uploading to Android Build Api may fail. Should use stub build
+    // infos in this case.
+    static final String DEFAULT_STUB_BUILD_ID = "3136476";
+    static final String DEFAULT_STUB_BUILD_TARGET = "build";
+    static final String DEFAULT_STUB_BUILD_BRANCH = "ub-treehugger-prod";
+    static final String DEFAULT_STUB_BUILD_ATTEMPT_ID = "latest";
+
+    @Option(
+            name = "compress-files",
+            description = "whether to compress files which are not already compressed")
+    private boolean mCompressFiles = true;
+
+    @Option(
+            name = "log-root-path",
+            description =
+                    "root local path to hold logfiles during the invocation.  Files will be moved"
+                            + " from here to android build api after the invocation completes.")
+    private File mLogRootPath =
+            new File(System.getProperty("java.io.tmpdir"), "stage-android-build-api");
+
+    @Option(
+            name = "remove-staged-files",
+            description =
+                    "Whether to remove staged log files after "
+                            + "they were successfully exported to Android Build API.")
+    private boolean mRemoveStagedFiles = true;
+
+    @Option(
+            name = "max-upload-attempts",
+            description = "Max attempts to upload files to the Android Build API.")
+    private int mMaxUploadAttempts = DEFAULT_MAX_UPLOAD_ATTEMPTS;
+
+    @Option(name = "use-stub-build", description = "Report the test result to a stub build or not.")
+    private boolean mUseStubBuild = false;
+
+    @Option(name = "stub-build-id", description = "Use this build id if use stub build is enabled.")
+    private String mStubBuildId = DEFAULT_STUB_BUILD_ID;
+
+    @Option(
+            name = "stub-build-target",
+            description = "Use this build target if use stub build is enabled.")
+    private String mStubBuildTarget = DEFAULT_STUB_BUILD_TARGET;
+
+    @Option(
+            name = "stub-build-branch",
+            description = "Use this build branch if use stub build is enabled.")
+    private String mStubBuildBranch = DEFAULT_STUB_BUILD_BRANCH;
+
+    @Option(
+            name = "stub-build-attempt-id",
+            description = "Use this build attempt id if use stub build is enabled.")
+    private String mStubBuildAttemptId = DEFAULT_STUB_BUILD_ATTEMPT_ID;
+
+    @Option(
+            name = "periodic-upload",
+            description =
+                    "Periodically upload a couple of files to avoid one large upload at the end.")
+    private boolean mPeriodicUpload = true;
+
+    /**
+     * @deprecated remove when cleaned
+     */
+    @Deprecated
+    @Option(
+            name = "periodic-upload-file-count",
+            description = "Max number of files to upload at each periodic upload.")
+    private int mPeriodicUploadCount = 20;
+
+    @Option(
+            name = "periodic-upload-interval",
+            isTimeVal = true,
+            description = "Interval to which we run the periodic upload of files.")
+    private long mPeriodicUploadFreq = 2 * 60 * 1000;
+
+    @Option(name = "parallel-upload", description = "Whether or not to upload on path in parallel.")
+    private boolean mParallelUpload = true;
+
+    /** The base path used for showing in Android Build Api. */
+    private String mRemotePath = null;
+
+    /** Generated local staging directory for log files */
+    private File mLogStagingDir = null;
+
+    /** a {link {@link LogFileSaver} to save the log locally. */
+    private LogFileSaver mLogFileSaver = null;
+
+    /**
+     * A counter to control access to methods which modify this class's directories. Acting as a
+     * non-blocking reentrant lock, this int blocks access to sharded child invocations from
+     * attempting to create or delete directories.
+     */
+    private int mShardingLock = 0;
+
+    /** Thread in charge of uploading files. */
+    private UploadThread mUploadThread = null;
+
+    /** Track if the object has reach the end of its lifecycle */
+    private boolean mLifecycleDone = false;
+
+    private Androidbuildinternal mClient;
+    private com.google.api.services.androidbuildinternal.v3.Androidbuildinternal mClientV3;
+    private boolean mClientInitialized;
+    private IBuildInfo mBuildInfo;
+    private String mBuildEnvironment = "prod";
+    private TestResultIdentity mTestResultIdentity;
+
+    private File mHostLogFile = null;
+
+    private String mInvocationId = "";
+    private String mWorkUnitId = "";
+    private boolean mUpdateMetadata = true;
+    private Map<String, LogDataType> mFilePathToLogDataTypeMap = new HashMap<>();
+    private boolean mUseLegacyMigration;
+    private IInvocationContext mInvocationContext;
+
+    /** Stores all the log files that have been already handled for upload to Android Build API. */
+    private Set<String> mUploadedLogs = new LinkedHashSet<>();
+
+    /**
+     * This is a class for full test result identify. It include the build info for the test result
+     * id and the test result id.
+     */
+    static class TestResultIdentity {
+        public final Long mTestResultId;
+        public final String mTestResultBuildId;
+        public final String mTestResultBuildTarget;
+        public final String mTestResultBuildAttemptId;
+        public final RemoteBuildInfo.BuildType mTestResultBuildType;
+
+        public TestResultIdentity(
+                Long testResultId,
+                String buildId,
+                String buildTarget,
+                String attemptId,
+                RemoteBuildInfo.BuildType buildType) {
+            mTestResultId = testResultId;
+            mTestResultBuildId = buildId;
+            mTestResultBuildTarget = buildTarget;
+            mTestResultBuildAttemptId = attemptId;
+            mTestResultBuildType = buildType;
+        }
+
+        @Override
+        public String toString() {
+            return String.format(
+                    "%d %s %s", mTestResultId, mTestResultBuildTarget, mTestResultBuildId);
+        }
+    }
+
+    @Override
+    public void init(IInvocationContext context) {
+        // buildinfo doesn't exist yet at this point, but LogFileSaver only really need some
+        // metadata
+        BuildInfo fakeBuildMetadata = new BuildInfo();
+        fakeBuildMetadata.setTestTag(context.getTestTag());
+        String buildId = context.getAttribute("test_result.build_id");
+        if (Strings.isNullOrEmpty(buildId)) {
+            buildId = "stub";
+        }
+        String flavor = context.getAttribute("test_result.build_target");
+        if (Strings.isNullOrEmpty(flavor)) {
+            buildId = "stub";
+        }
+        fakeBuildMetadata.setBuildId(buildId);
+        fakeBuildMetadata.setBuildFlavor(flavor);
+        initLogSaver(fakeBuildMetadata);
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public void invocationStarted(IInvocationContext context) {
+        try (CloseableTraceScope start =
+                new CloseableTraceScope("ab-log-uploader:invocationStart")) {
+            List<String> buildEnvironments =
+                    context.getAttributes().get(BUILD_ENV_INVOCATION_CONTEXT_KEY);
+            if (buildEnvironments != null && !buildEnvironments.isEmpty()) {
+                mBuildEnvironment = buildEnvironments.get(0);
+            }
+
+            String subprocess = context.getAttribute(SubprocessTfLauncher.SUBPROCESS_TAG_NAME);
+            if (!Strings.isNullOrEmpty(subprocess)) {
+                // Don't update metadata in subprocess, let parent do it.
+                mUpdateMetadata = false;
+            }
+
+            mInvocationContext = context;
+            mUseLegacyMigration = !"false".equals(context.getAttribute(ARTIFACT_UPLOAD_KEY));
+
+            IBuildInfo build = context.getBuildInfos().get(0);
+            // Limit build creation to local auth for now
+            if (System.getenv("LOCAL_AUTH") != null) {
+                build = build.clone();
+                try {
+                    Build localbuild =
+                            AbLocalBuildProvider.createLocalBuild(
+                                    context, build.getBuildBranch(), build.getBuildFlavor());
+                    build.setBuildId(localbuild.getBuildId());
+                    CLog.d("Local build %s was created to store results.", build);
+                    CLog.d("Original build info: %s", context.getBuildInfos().get(0));
+                    context.addDeviceBuildInfo(AbLocalBuildProvider.LOCAL_BUILD, build);
+                } catch (IOException | GeneralSecurityException e) {
+                    CLog.e(e);
+                }
+            }
+
+            setBuildInfo(build);
+            initLogSaver(getBuildInfo());
+            try {
+                mTestResultIdentity = fetchTestResultId(context, mUseStubBuild);
+                // Propagate the test_result_id for log saving
+                if (mTestResultIdentity != null
+                        && !context.getAttributes().containsKey(TEST_RESULT_ID)) {
+                    context.addInvocationAttribute(
+                            TEST_RESULT_ID, Long.toString(mTestResultIdentity.mTestResultId));
+                }
+            } catch (RuntimeException e) {
+                CLog.e("Failed to init the test result id:");
+                CLog.e(e);
+                return;
+            }
+
+            if (mPeriodicUpload) {
+                mUploadThread = new UploadThread(mPeriodicUploadFreq);
+                mUploadThread.start();
+            }
+        }
+    }
+
+    /**
+     * Initialize the log saver.
+     *
+     * @param buildInfo
+     */
+    private void initLogSaver(IBuildInfo buildInfo) {
+        if (mLogFileSaver != null) {
+            return;
+        }
+        synchronized (this) {
+            if (mShardingLock == 0) {
+                mLogFileSaver = new LogFileSaver(buildInfo, getLogRootPath());
+                mRemotePath =
+                        generateAndroidBuildApiPath(mLogFileSaver.getInvocationLogPathSegments());
+                setLogStagingDir(mLogFileSaver.getFileDir());
+            }
+            mShardingLock++;
+        }
+    }
+
+    /**
+     * Fetch test result id by following priority order:
+     *
+     * <p>1. If explicitly set use stub build, then create a test result id for the stub build. 2.
+     * Try to get the test result id and related build info from invocation context. 3. If there is
+     * no build info in invocation context, use the local primary (the first) build. 4. If the test
+     * result id and local primary build doesn't match, create a new test result id for local
+     * primary build. 5. If failed to create test result id for local build, create test result id
+     * for stub build.
+     *
+     * <p>1, 3, 4, 5 should never happen. They are just backups.
+     */
+    TestResultIdentity fetchTestResultId(IInvocationContext context, boolean useStubBuild) {
+        TestResultIdentity testResultIdentity = null;
+        try {
+            if (useStubBuild) {
+                return fetchTestResultIdFromStubBuild();
+            } else if (context != null) {
+                testResultIdentity = fetchTestResultIdFromContext(context);
+            }
+            if (testResultIdentity == null) {
+                testResultIdentity = fetchTestResultIdFromLocalBuild();
+            }
+            if (testResultIdentity == null) {
+                testResultIdentity = fetchTestResultIdFromStubBuild();
+            }
+            return testResultIdentity;
+        } catch (GoogleJsonResponseException e) {
+            CLog.w(
+                    "Error fetching result: %s. This is not critical but log uploading will be"
+                            + " disabled.",
+                    e.getMessage());
+        }
+        return null;
+    }
+
+    /** Fetch test result and related build info with stub build. */
+    TestResultIdentity fetchTestResultIdFromStubBuild() throws GoogleJsonResponseException {
+        Long testResultId = createTestResult(mStubBuildId, mStubBuildTarget, mStubBuildAttemptId);
+        if (testResultId != null) {
+            return new TestResultIdentity(
+                    testResultId,
+                    mStubBuildId,
+                    mStubBuildTarget,
+                    mStubBuildAttemptId,
+                    RemoteBuildInfo.parseBuildType(mStubBuildId));
+        }
+        return null;
+    }
+
+    /**
+     * Fetch test result from context. If there is no test result build info, use the local build
+     * and check if the test result belong to the build or not. If not, return null
+     *
+     * @param context
+     * @return test result identify
+     */
+    TestResultIdentity fetchTestResultIdFromContext(IInvocationContext context) {
+        CLog.i("Fetching test result from context");
+        String testResultIdStr = context.getAttribute(TEST_RESULT_ID);
+        if (Strings.isNullOrEmpty(testResultIdStr)) {
+            return null;
+        }
+        Long testResultId = null;
+        try {
+            testResultId = Long.parseLong(testResultIdStr);
+        } catch (NumberFormatException e) {
+            CLog.e("%s is not a valid test result id, will create a new one", testResultIdStr);
+            CLog.e(e);
+            return null;
+        }
+        String buildId = context.getAttribute("test_result.build_id");
+        String buildTarget = context.getAttribute("test_result.build_target");
+        String attemptId = context.getAttribute("test_result.build_attempt_id");
+        RemoteBuildInfo.BuildType buildType = RemoteBuildInfo.parseBuildType(buildId);
+
+        if (Strings.isNullOrEmpty(buildId)
+                || Strings.isNullOrEmpty(buildTarget)
+                || Strings.isNullOrEmpty(attemptId)) {
+            CLog.i("There is no test result build info in context, use local build info.");
+            buildId = getBuildInfo().getBuildId();
+            buildTarget = getBuildTarget();
+            attemptId = getBuildAttemptId();
+            buildType = getBuildType();
+        }
+        TestResultIdentity testResultIdentity =
+                new TestResultIdentity(testResultId, buildId, buildTarget, attemptId, buildType);
+        if (checkTestResultExist(testResultIdentity)) {
+            return testResultIdentity;
+        }
+        return null;
+    }
+
+    /**
+     * Generate test result from local build.
+     *
+     * @return test result identify
+     */
+    TestResultIdentity fetchTestResultIdFromLocalBuild() throws GoogleJsonResponseException {
+        String buildId = getBuildInfo().getBuildId();
+        String buildTarget = getBuildTarget();
+        String attemptId = getBuildAttemptId();
+        RemoteBuildInfo.BuildType buildType = getBuildType();
+        CLog.i(
+                "Creating new test result from local build (%s %s %s %s)",
+                buildId, buildTarget, attemptId, buildType);
+        Long testResultId = createTestResult(buildId, buildTarget, attemptId);
+        if (testResultId == null) {
+            return null;
+        }
+        return new TestResultIdentity(testResultId, buildId, buildTarget, attemptId, buildType);
+    }
+
+    /**
+     * Check a build exists in Android Build Api or not.
+     *
+     * @param buildId
+     * @param buildTarget
+     * @return true if the build exist, otherwise false.
+     */
+    boolean checkBuildExist(String buildId, String buildTarget) {
+        if (getClient() == null) {
+            CLog.w("There is no Android Build Api client.");
+            return false;
+        }
+        try {
+            getClient().build().get(buildId, buildTarget).execute();
+            return true;
+        } catch (IOException e) {
+            CLog.e("Build %s %s doesn't exist.", buildId, buildTarget);
+            return false;
+        }
+    }
+
+    /**
+     * Check a test result exists or not.
+     *
+     * @param testResultIdentity testResultIdentity
+     * @return true if the test result exists, otherwise false.
+     */
+    boolean checkTestResultExist(TestResultIdentity testResultIdentity) {
+        if (getClient() == null) {
+            CLog.w("There is no Android Build Api client.");
+            return false;
+        }
+        try {
+            getClient()
+                    .testresult()
+                    .get(
+                            testResultIdentity.mTestResultBuildId,
+                            testResultIdentity.mTestResultBuildTarget,
+                            testResultIdentity.mTestResultBuildAttemptId,
+                            testResultIdentity.mTestResultId)
+                    .execute();
+            return true;
+        } catch (IOException e) {
+            CLog.w("There is no test result id %s", testResultIdentity);
+            return false;
+        }
+    }
+
+    /**
+     * Create a test result in Android Build Api.
+     *
+     * @param buildId
+     * @param buildTarget
+     * @param buildAttemptId
+     * @return test result id
+     */
+    Long createTestResult(String buildId, String buildTarget, String buildAttemptId)
+            throws GoogleJsonResponseException {
+        if (getClient() == null) {
+            CLog.w("There is no Android Build Api client.");
+            return null;
+        }
+
+        CLog.i(
+                "Creating new test result from build (%s %s %s)",
+                buildId, buildTarget, buildAttemptId);
+        TestResult testResult = new TestResult();
+        testResult.setTestTag(getBuildInfo().getTestTag());
+        try {
+            testResult =
+                    getClient()
+                            .testresult()
+                            .insert(buildId, buildTarget, buildAttemptId, testResult)
+                            .execute();
+            return testResult.getId();
+        } catch (GoogleJsonResponseException gre) {
+            throw gre;
+        } catch (IOException e) {
+            CLog.e("Failed to create test result, will not upload logs to Android Build Api.");
+            CLog.e(e);
+        }
+        return null;
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public void invocationEnded(long elapsedTime) {
+        if (!shouldUpload()) {
+            return;
+        }
+        mLifecycleDone = true;
+
+        try (CloseableTraceScope end = new CloseableTraceScope("ab-log-uploader:invocationEnded")) {
+            // Make sure we stop the periodic upload thread first, then proceed to finishing
+            // uploading
+            // everything.
+            waitForUploadThread();
+
+            List<String> stagedPaths = listStagedFiles(getLogStagingDir());
+            if (stagedPaths == null) {
+                // It is uncommon that we don't even have a host log to save, so log something
+                CLog.w("No log files were saved; skipping export to Android Build Api.");
+                return;
+            }
+
+            CLog.d("Start uploadOnPath");
+            if (mParallelUpload) {
+                int poolSize = Math.min(stagedPaths.size(), 50);
+                if (poolSize != 0) {
+                    ParallelDeviceExecutor<Boolean> executor =
+                            new ParallelDeviceExecutor<>(poolSize);
+                    List<Callable<Boolean>> callableTasks = new ArrayList<>();
+                    for (String stagedPath : stagedPaths) {
+                        Callable<Boolean> callableTask =
+                                () -> {
+                                    uploadOnPath(stagedPath);
+                                    return true;
+                                };
+                        callableTasks.add(callableTask);
+                        // mark this log file as handled for upload, so that it's not considered for
+                        // upload during next rounds of periodic upload.
+                        mUploadedLogs.add(stagedPath);
+                    }
+                    executor.invokeAll(callableTasks, 0L, TimeUnit.MINUTES);
+                }
+            } else {
+                for (String stagedPath : stagedPaths) {
+                    // mark this log file as handled for upload, so that it's not considered for
+                    // upload during next rounds of periodic upload.
+                    mUploadedLogs.add(stagedPath);
+                    uploadOnPath(stagedPath);
+                }
+            }
+            CLog.d("Start updateArtifactMetadata");
+            updateArtifactMetadata();
+
+            synchronized (this) {
+                if (--mShardingLock == 0) {
+                    List<String> remainingPaths = listStagedFiles(getLogStagingDir());
+                    if (mRemoveStagedFiles
+                            && remainingPaths != null
+                            && remainingPaths.size() == 0) {
+                        FileUtil.recursiveDelete(getLogStagingDir());
+                    }
+                }
+                if (mShardingLock < 0) {
+                    CLog.w(
+                            "Sharding lock exited more times than entered, possible "
+                                    + "unbalanced invocationStarted/Ended calls");
+                }
+            }
+            CLog.d("Done uploading with AndroidBuildApiLogSaver");
+        }
+    }
+
+    /** Routine to upload a given stagedPath */
+    private void uploadOnPath(String stagedPath) {
+        try (CloseableTraceScope ignored =
+                new CloseableTraceScope("ab-upload:" + new File(stagedPath).getName())) {
+            uploadFileToAndroidBuildApiWithMultiAttempts(stagedPath);
+            if (mRemoveStagedFiles) {
+                FileUtil.deleteFile(new File(stagedPath));
+            }
+        } catch (IOException e) {
+            CLog.e("Failed to upload %s to Android Build Api.", stagedPath);
+            String message = e.getMessage();
+            if (!Strings.isNullOrEmpty(message)) {
+                // Outputting the whole message is too verbose.
+                // The first line have a brief error message.
+                CLog.e(message.split("\n", 2)[0]);
+            }
+            // In case of exception, if periodic upload is enabled, instead of re-trying again at
+            // the next round, delete right away to match non-periodic behavior.
+            // TODO: Consider leaving a trace/snippet somewhere for debugging
+            if (mRemoveStagedFiles && mPeriodicUpload) {
+                FileUtil.deleteFile(new File(stagedPath));
+            }
+        }
+    }
+
+    /**
+     * Check if the log saver should upload the log files. Used for testing.
+     *
+     * @return should upload
+     */
+    boolean shouldUpload() {
+        if (getTestResultIdentity() == null) {
+            CLog.w(
+                    "There is no test result id for this invocation, can not upload tests files "
+                            + "to Android Build Api. The logs are saved under %s.",
+                    getLogStagingDir());
+            return false;
+        }
+
+        if (getClient() == null) {
+            CLog.w(
+                    "No Android Build Api client set, can not upload tests files to "
+                            + "Android Build Api. The logs are saved under %s.",
+                    getLogStagingDir());
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * Upload staged file to Android Build Api with multiple attempts.
+     *
+     * @param filePath the staged file path
+     * @throws IOException
+     */
+    void uploadFileToAndroidBuildApiWithMultiAttempts(String filePath) throws IOException {
+        // TODO(b/143365209): Remove this method once we switch to v3 api.
+        // ObjectUpdater library already implements retries and error handling.
+        IOException exception = null;
+        int waitTimeMS = INIT_ATTEMPTS_WAIT_TIME;
+        for (int i = 1; i <= mMaxUploadAttempts; ++i) {
+            try {
+                uploadFileToAndroidBuildApi(filePath);
+                return;
+            } catch (IOException e) {
+                exception = e;
+                String message = e.getMessage();
+                if (e instanceof GoogleJsonResponseException) {
+                    GoogleJsonResponseException respException = (GoogleJsonResponseException) e;
+                    // Get the scotty id for debugging purpose.
+                    String value =
+                            respException
+                                    .getHeaders()
+                                    .getFirstHeaderStringValue("x-guploader-uploadid");
+                    if (!Strings.isNullOrEmpty(value)) {
+                        CLog.w("More info at http://go/scottydash/lookup.html?uploadId=%s", value);
+                    } else {
+                        CLog.w("There is no \"x-guploader-uploadid\" in the response.");
+                    }
+                    message = respException.getStatusMessage();
+                }
+                CLog.w(
+                        "Failed to upload file %s to the Android Build API due to %s in attempt"
+                                + " %d.",
+                        filePath, message, i);
+                if (i < mMaxUploadAttempts) {
+                    CLog.w("Wait %dms for another retry.", waitTimeMS);
+                    getRunUtil().sleep(waitTimeMS);
+                    waitTimeMS *= 2;
+                }
+            }
+        }
+        throw exception;
+    }
+
+    @VisibleForTesting
+    protected IInvocationContext getInvocationContext() {
+        return mInvocationContext;
+    }
+
+    private synchronized void fetchInvocationAndWorkUnitId() {
+        if (Strings.isNullOrEmpty(mInvocationId)) {
+            mInvocationId = getInvocationContext().getAttribute(INVOCATION_ID_KEY);
+        }
+        if (Strings.isNullOrEmpty(mWorkUnitId)) {
+            mWorkUnitId = getInvocationContext().getAttribute(WORK_UNIT_ID_KEY);
+        }
+    }
+
+    /**
+     * Upload staged file to Android Build Api.
+     *
+     * @param filePath the staged file path
+     * @throws IOException
+     */
+    void uploadFileToAndroidBuildApi(String filePath) throws IOException {
+        long startUpload = System.currentTimeMillis();
+        try {
+            fetchInvocationAndWorkUnitId();
+
+            if (!mUseLegacyMigration) {
+                legacyUploadFileToAndroidBuildApi(filePath);
+                return;
+            }
+
+            if (Strings.isNullOrEmpty(mInvocationId) || Strings.isNullOrEmpty(mWorkUnitId)) {
+                CLog.w("Unable to upload logs because invocation id or work unit id are not set");
+                return;
+            }
+
+            File f = new File(filePath);
+            if (f.length() <= 0) {
+                // Android Build API doesn't accept empty file
+                FileUtil.writeToFile("empty", f);
+            }
+
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricKey.ARTIFACTS_UPLOAD_SIZE, f.length());
+
+            com.google.api.services.androidbuildinternal.v3.Androidbuildinternal client =
+                    getV3Client();
+            String contentType = FileUtil.getContentType(filePath);
+            String md5 = FileUtil.calculateMd5(f);
+            LogDataType type = getFilePathToLogDataTypeMap().get(filePath);
+            String resourceId = getRemoteFilePath(f.getName());
+            FileContent fileContent = new FileContent(contentType, f);
+
+            runUpdate(client, filePath, resourceId, md5, fileContent, type, contentType);
+        } finally {
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricKey.AB_LOG_SAVER_UPLOAD_TIME,
+                    System.currentTimeMillis() - startUpload);
+        }
+    }
+
+    @VisibleForTesting
+    protected void runUpdate(
+            com.google.api.services.androidbuildinternal.v3.Androidbuildinternal client,
+            String filePath,
+            String resourceId,
+            String md5,
+            FileContent fileContent,
+            LogDataType type,
+            String contentType)
+            throws IOException {
+        ObjectUpdater updater = ObjectUpdater.create(client);
+        updater.runUpdate(
+                mInvocationId,
+                resourceId,
+                getTestResultId(),
+                new ObjectUpdater.TestArtifactUpdate() {
+                    @Override
+                    public com.google.api.services.androidbuildinternal.v3.model
+                                    .BuildArtifactMetadata
+                            doUpdate(
+                                    com.google.api.services.androidbuildinternal.v3.model
+                                                    .BuildArtifactMetadata
+                                            current) {
+                        if (current == null) {
+                            // If we are creating artifact for the first time, we will set work unit
+                            // to the work unit that got passed to tf. It will be updated when
+                            // associations are uploaded.
+                            current =
+                                    new com.google.api.services.androidbuildinternal.v3.model
+                                                    .BuildArtifactMetadata()
+                                            .setInvocationId(mInvocationId)
+                                            .setWorkUnitId(mWorkUnitId)
+                                            .setName(resourceId);
+                        }
+                        if (md5.equals(current.getMd5())) {
+                            // if the file is the same skip upload.
+                            return null;
+                        }
+                        CLog.i(
+                                "File %s with different md5 exists in Android Build Api. "
+                                        + "Will overwrite contents.\n",
+                                filePath);
+                        current.setContentType(contentType);
+                        if (type != null) {
+                            current.setArtifactType(type.name());
+                        }
+                        return current;
+                    }
+
+                    @Override
+                    public AbstractInputStreamContent getContent() {
+                        return fileContent;
+                    }
+                });
+    }
+
+    private void legacyUploadFileToAndroidBuildApi(String filePath) throws IOException {
+        File f = new File(filePath);
+        if (f.length() <= 0) {
+            // Android Build API doesn't accept empty file
+            FileUtil.writeToFile("empty", f);
+        }
+        String contentType = FileUtil.getContentType(filePath);
+        BuildArtifactMetadata metadata = new BuildArtifactMetadata().setContentType(contentType);
+        BuildArtifactMetadata artifact = getTestArtifact(getRemoteFilePath(f.getName()));
+        if (artifact != null) {
+            String md5 = FileUtil.calculateMd5(f);
+            if (md5.equals(artifact.getMd5())) {
+                CLog.i(
+                        "File %s with same md5 exists in Android Build Api." + " Skip uploading.",
+                        filePath);
+                return;
+            } else {
+                CLog.i(
+                        "File %s with different md5 exists in Android Build Api. "
+                                + "Will overwrite contents.\n",
+                        filePath);
+                metadata.setRevision(artifact.getRevision());
+            }
+        }
+        LogDataType type = getFilePathToLogDataTypeMap().get(filePath);
+        if (type != null) {
+            metadata.setArtifactType(type.name());
+        }
+        FileContent fileContent = new FileContent(contentType, f);
+        TestResultIdentity testResultIdentity = getTestResultIdentity();
+
+        InvocationMetricLogger.addInvocationMetrics(
+                InvocationMetricKey.ARTIFACTS_UPLOAD_SIZE, f.length());
+
+        getClient()
+                .testartifact()
+                .update(
+                        testResultIdentity.mTestResultBuildType.toString(),
+                        testResultIdentity.mTestResultBuildId,
+                        testResultIdentity.mTestResultBuildTarget,
+                        testResultIdentity.mTestResultBuildAttemptId,
+                        testResultIdentity.mTestResultId,
+                        getRemoteFilePath(f.getName()),
+                        metadata,
+                        fileContent)
+                .execute();
+        CLog.i("Finished uploading %s", filePath);
+    }
+
+    /**
+     * Get test artifact for a file from Android Build API.
+     *
+     * @param resourceId test artifact's resource id
+     * @throws IOException
+     */
+    BuildArtifactMetadata getTestArtifact(String resourceId) throws IOException {
+        // TODO(b/143365209): We can remove this method when switching over to v3 api.
+        try {
+            return getClient()
+                    .testartifact()
+                    .get(
+                            mTestResultIdentity.mTestResultBuildType.toString(),
+                            mTestResultIdentity.mTestResultBuildId,
+                            mTestResultIdentity.mTestResultBuildTarget,
+                            mTestResultIdentity.mTestResultBuildAttemptId,
+                            mTestResultIdentity.mTestResultId,
+                            resourceId)
+                    .execute();
+        } catch (HttpResponseException e) {
+            if (e.getStatusCode() == 404) {
+                CLog.i("File %s doesn't exist in Android Build API. Expected.", resourceId);
+                return null;
+            } else {
+                throw e;
+            }
+        }
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public LogFile saveLogData(String dataName, LogDataType dataType, InputStream dataStream)
+            throws IOException {
+        if (isSandbox()) {
+            dataName = "sandbox-" + dataName;
+        }
+        File log = null;
+        long stagingStart = System.currentTimeMillis();
+        // Handle host_log specifically: we are tracking the main host_log location file to be
+        // able to write the end_host_log to it.
+        // We write directly the end_host_log to it because it's too late for it to be reported
+        // and displayed in AnTS. So before host_log is uploaded, we complete the physical
+        // log file.
+        // We will still upload the end_host_log no matter what.
+        try {
+            if (TestInvocation.TRADEFED_END_HOST_LOG.equals(dataName) && mHostLogFile != null) {
+                if (mHostLogFile.exists()) {
+                    try (OutputStream output = new FileOutputStream(mHostLogFile, true)) {
+                        StreamUtil.copyStreams(dataStream, output);
+                    }
+                    // We will use it again so reset the stream.
+                    if (dataStream.markSupported()) {
+                        dataStream.reset();
+                    } else if (dataStream instanceof FileInputStream) {
+                        ((FileInputStream) dataStream).getChannel().position(0L);
+                    }
+                }
+            }
+
+            if (!mCompressFiles) {
+                log = mLogFileSaver.saveLogData(dataName, dataType, dataStream);
+                mFilePathToLogDataTypeMap.put(log.getAbsolutePath(), dataType);
+                LogFile logFile =
+                        new LogFile(
+                                log.getAbsolutePath(), getRemoteFileUrl(log.getName()), dataType);
+                return logFile;
+            }
+            log = mLogFileSaver.saveAndGZipLogData(dataName, dataType, dataStream);
+            mFilePathToLogDataTypeMap.put(log.getAbsolutePath(), dataType);
+            return new LogFile(
+                    log.getAbsolutePath(),
+                    getRemoteFileUrl(log.getName()),
+                    true /* compressed */,
+                    dataType,
+                    log.length());
+        } finally {
+            if (TestInvocation.TRADEFED_LOG_NAME.equals(dataName) && mHostLogFile == null) {
+                mHostLogFile = log;
+            }
+            if (mLifecycleDone) {
+                if (log != null) {
+                    // Special case where we receive a log after the upload lifecycle
+                    // is supposed to be done.
+                    mUploadedLogs.add(log.getAbsolutePath());
+                    uploadFileToAndroidBuildApi(log.getAbsolutePath());
+                    if (mRemoveStagedFiles) {
+                        FileUtil.recursiveDelete(getLogStagingDir());
+                    }
+                }
+            }
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricKey.AB_LOG_SAVER_STAGING_TIME,
+                    System.currentTimeMillis() - stagingStart);
+        }
+    }
+
+    @Override
+    public LogFile saveLogFile(String dataName, LogDataType dataType, File fileToLog)
+            throws IOException {
+        if (isSandbox()) {
+            dataName = "sandbox-" + dataName;
+        }
+        File log = null;
+        long stagingStart = System.currentTimeMillis();
+        try {
+            if (!mCompressFiles) {
+                log = mLogFileSaver.saveLogFile(dataName, dataType, fileToLog);
+                mFilePathToLogDataTypeMap.put(log.getAbsolutePath(), dataType);
+                return new LogFile(
+                        log.getAbsolutePath(), getRemoteFileUrl(log.getName()), dataType);
+            }
+            // saveAndGZip already handles dataType that do not need compression.
+            log = mLogFileSaver.saveAndGZipLogFile(dataName, dataType, fileToLog);
+            mFilePathToLogDataTypeMap.put(log.getAbsolutePath(), dataType);
+            return new LogFile(
+                    log.getAbsolutePath(),
+                    getRemoteFileUrl(log.getName()),
+                    true,
+                    dataType,
+                    log.length());
+        } finally {
+            if (mLifecycleDone) {
+                if (log != null) {
+                    // Special case where we receive a log after the upload lifecycle
+                    // is supposed to be done.
+                    mUploadedLogs.add(log.getAbsolutePath());
+                    uploadFileToAndroidBuildApi(log.getAbsolutePath());
+                    if (mRemoveStagedFiles) {
+                        FileUtil.recursiveDelete(getLogStagingDir());
+                    }
+                }
+            }
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricKey.AB_LOG_SAVER_STAGING_TIME,
+                    System.currentTimeMillis() - stagingStart);
+        }
+    }
+
+    private void updateArtifactMetadata() {
+        fetchInvocationAndWorkUnitId();
+
+        // TODO(b/143365209): Remove this method once we switch to v3 api.
+        if (mUseLegacyMigration) {
+            CLog.i("Not updating metadata because we are using v3 api for upload.");
+            return;
+        }
+        if (mInvocationId == null || mInvocationId.isEmpty()) {
+            CLog.i("Invocation id is empty, skipping metadata update.");
+            return;
+        }
+        if (!mUpdateMetadata) {
+            CLog.i("Metadata update is skipped in subprocess");
+            return;
+        }
+        try {
+            Map<String, BuildArtifactMetadata> correctMetadata = new HashMap<>();
+            for (BuildArtifactMetadata artifact : listArtifacts()) {
+                correctMetadata.put(artifact.getName(), artifact);
+            }
+            CLog.i("Got %d v2 artifacts", correctMetadata.size());
+            com.google.api.services.androidbuildinternal.v3.Androidbuildinternal client =
+                    AndroidBuildAPIHelper.getTestStorageClient(mBuildEnvironment);
+            List<com.google.api.services.androidbuildinternal.v3.model.BuildArtifactMetadata>
+                    artifacts = listArtifacts(client, mInvocationId);
+            CLog.i("ArtifactList returnd %d artifacts", artifacts.size());
+
+            for (com.google.api.services.androidbuildinternal.v3.model.BuildArtifactMetadata
+                    artifact : artifacts) {
+                BuildArtifactMetadata uploadedArtifact = correctMetadata.get(artifact.getName());
+                if (uploadedArtifact == null) {
+                    continue;
+                }
+                CLog.i("Update metadata for %s\nCorrect: %s", artifact, uploadedArtifact);
+                try {
+                    updateMetadata(client, artifact, uploadedArtifact);
+                } catch (IOException e) {
+                    CLog.e(e);
+                }
+            }
+        } catch (IOException | GeneralSecurityException e) {
+            CLog.e(e);
+        }
+    }
+
+    private List<BuildArtifactMetadata> listArtifacts() throws IOException {
+        // TODO(b/143365209): Remove this method once we switch to v3 api.
+        String pageToken = "";
+        List<BuildArtifactMetadata> artifacts = new ArrayList<>();
+        do {
+            Testartifact.List request =
+                    getClient()
+                            .testartifact()
+                            .list(
+                                    mTestResultIdentity.mTestResultBuildType.toString(),
+                                    mTestResultIdentity.mTestResultBuildId,
+                                    mTestResultIdentity.mTestResultBuildTarget,
+                                    mTestResultIdentity.mTestResultBuildAttemptId,
+                                    mTestResultIdentity.mTestResultId)
+                            .setMaxResults(1000L);
+            if (!pageToken.isEmpty()) {
+                request.setPageToken(pageToken);
+            }
+            com.google.api.services.androidbuildinternal.model.TestArtifactListResponse response =
+                    request.execute();
+            pageToken = response.getNextPageToken();
+            if (response.getTestArtifacts() != null) {
+                artifacts.addAll(response.getTestArtifacts());
+            }
+        } while (pageToken != null && !pageToken.isEmpty());
+
+        return artifacts;
+    }
+
+    private List<com.google.api.services.androidbuildinternal.v3.model.BuildArtifactMetadata>
+            listArtifacts(
+                    com.google.api.services.androidbuildinternal.v3.Androidbuildinternal client,
+                    String invocationId)
+                    throws IOException {
+        // TODO(b/143365209): Remove this method once we switch to v3 api.
+        String pageToken = "";
+        List<com.google.api.services.androidbuildinternal.v3.model.BuildArtifactMetadata>
+                artifacts = new ArrayList<>();
+        do {
+            com.google.api.services.androidbuildinternal.v3.Androidbuildinternal.Testartifact.List
+                    request =
+                            client.testartifact()
+                                    .list()
+                                    .setInvocationId(invocationId)
+                                    .setMaxResults(1000L);
+            if (!pageToken.isEmpty()) {
+                request.setPageToken(pageToken);
+            }
+            TestArtifactListResponse response = request.execute();
+            pageToken = response.getNextPageToken();
+            if (response.getTestArtifacts() != null) {
+                artifacts.addAll(response.getTestArtifacts());
+            }
+        } while (pageToken != null && !pageToken.isEmpty());
+
+        return artifacts;
+    }
+
+    private void updateMetadata(
+            com.google.api.services.androidbuildinternal.v3.Androidbuildinternal client,
+            com.google.api.services.androidbuildinternal.v3.model.BuildArtifactMetadata
+                    staleArtifact,
+            BuildArtifactMetadata correctMetadata)
+            throws IOException {
+        // TODO(b/143365209): Remove this method once we switch to v3 api.
+
+        int attempts = 0;
+        do {
+            com.google.api.services.androidbuildinternal.v3.model.BuildArtifactMetadata update =
+                    new com.google.api.services.androidbuildinternal.v3.model
+                            .BuildArtifactMetadata();
+            String artifactType = correctMetadata.getArtifactType();
+            if (artifactType != null && !artifactType.isEmpty()) {
+                update.setArtifactType(artifactType);
+            }
+            update.setContentType(correctMetadata.getContentType());
+            update.setRevision(staleArtifact.getRevision());
+            try {
+                attempts++;
+                client.testartifact()
+                        .patch(staleArtifact.getName(), update)
+                        .setInvocationId(mInvocationId)
+                        .execute();
+                break;
+            } catch (GoogleJsonResponseException e) {
+                if (e.getStatusCode() != HttpURLConnection.HTTP_CONFLICT) {
+                    throw e;
+                }
+                // We detected a conflicting write. It might be the artifact was already updated.
+                // Get the latest version.
+                if (attempts >= DEFAULT_MAX_UPLOAD_ATTEMPTS) {
+                    CLog.i("Too many attempts failed to update metadata for %s", staleArtifact);
+                    continue;
+                }
+                staleArtifact =
+                        client.testartifact()
+                                .get(staleArtifact.getName())
+                                .setInvocationId(mInvocationId)
+                                .setWorkUnitId(staleArtifact.getWorkUnitId())
+                                .setResultId(staleArtifact.getTestResultId())
+                                .execute();
+            }
+        } while (attempts < DEFAULT_MAX_UPLOAD_ATTEMPTS);
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public LogFile getLogReportDir() {
+        return new LogFile(getRemoteFilePath(""), getRemoteFileUrl(""), LogDataType.DIR);
+    }
+
+    /**
+     * Generate base path in Android Build Api, used as prefix of resource id for testaritifact api.
+     *
+     * @param invPathSegments
+     * @return path in Android Build Api.
+     */
+    String generateAndroidBuildApiPath(List<String> invPathSegments) {
+        return String.join(ANDROID_BUILD_API_PATHSEP, invPathSegments.toArray(new String[] {}));
+    }
+
+    /**
+     * List the files which are staged for upload to Android Build Api.
+     *
+     * <p>Exposed for unit testing
+     */
+    List<String> listStagedFiles(File parentDir) {
+        final File[] files = parentDir.listFiles();
+        if (files == null) {
+            return null;
+        }
+
+        List<String> paths = new LinkedList<>();
+        for (int i = 0; i < files.length; ++i) {
+            String filepath = files[i].getPath();
+            if (!mUploadedLogs.contains(filepath)) {
+                paths.add(files[i].getPath());
+            }
+        }
+
+        return paths;
+    }
+
+    /**
+     * A helper method that returns a URL for a given file name.
+     *
+     * @param fileName the filename of the log
+     * @return A URL that should allow visitors to view the logfile with the specified name
+     */
+    String getRemoteFileUrl(String fileName) {
+        if (mTestResultIdentity == null) {
+            return null;
+        }
+        String baseUrl =
+                String.format(
+                        URL_TEMPLATE,
+                        mTestResultIdentity.mTestResultBuildType,
+                        mTestResultIdentity.mTestResultBuildId,
+                        mTestResultIdentity.mTestResultBuildTarget,
+                        mTestResultIdentity.mTestResultBuildAttemptId,
+                        String.valueOf(mTestResultIdentity.mTestResultId));
+        fileName = sanitizeUrlFileName(fileName);
+        return baseUrl + getRemoteFilePath(fileName);
+    }
+
+    /** Escape special url character (like spaces and #) to have a proper link. */
+    private static String sanitizeUrlFileName(String filename) {
+        return UrlEscapers.urlPathSegmentEscaper().escape(filename);
+    }
+
+    /**
+     * A helper method that returns the remote path for a given file name.
+     *
+     * @param fileName the filename of the log
+     * @return remote path as an resource id of the log file in the Android Build API.
+     */
+    String getRemoteFilePath(String fileName) {
+        return String.format("%s%s%s", getRemotePath(), ANDROID_BUILD_API_PATHSEP, fileName);
+    }
+
+    /**
+     * Get the Androidbuildinternal client.
+     *
+     * @return a Androidbuildinternal
+     */
+    Androidbuildinternal getClient() {
+        // Prevent multiple threads from trying to initialize a client at the same time.
+        synchronized (this) {
+            if (!mClientInitialized) {
+                mClientInitialized = true;
+                try {
+                    setClient(AndroidBuildAPIHelper.getLegacyClient(mBuildEnvironment));
+                } catch (GeneralSecurityException | IOException e) {
+                    CLog.e("Failed to create Android Build Api client.");
+                    CLog.e(e);
+                    CLog.e("Logs will be saved locally.");
+                }
+            }
+        }
+        return mClient;
+    }
+
+    synchronized com.google.api.services.androidbuildinternal.v3.Androidbuildinternal
+            getV3Client() {
+        if (mClientV3 != null) {
+            return mClientV3;
+        }
+        try {
+            mClientV3 = AndroidBuildAPIHelper.getTestStorageClient(mBuildEnvironment);
+        } catch (GeneralSecurityException | IOException e) {
+            CLog.e("Failed to create Android Build Api V3 client");
+            CLog.e(e);
+            CLog.e("Logs will be saved locally");
+        }
+        return mClientV3;
+    }
+
+    /**
+     * Get build attempt id for the current build.
+     *
+     * @return build attempt id
+     */
+    String getBuildAttemptId() {
+        String buildAttemptId = getBuildInfo().getBuildAttributes().get(BUILD_ATTEMPT_ID);
+        if (buildAttemptId == null) {
+            return DEFAULT_BUILD_ATTEMPT_ID;
+        }
+        return buildAttemptId;
+    }
+
+    /**
+     * Get build type.
+     *
+     * @return build type.
+     */
+    RemoteBuildInfo.BuildType getBuildType() {
+        return RemoteBuildInfo.parseBuildType(getBuildInfo().getBuildId());
+    }
+
+    /**
+     * Get build target. If there is no build target attribute, return build flavor.
+     *
+     * @return build target.
+     */
+    String getBuildTarget() {
+        String buildTarget = getBuildInfo().getBuildAttributes().get(BUILD_TARGET);
+        if (buildTarget == null) {
+            String build_flavor = getBuildInfo().getBuildFlavor();
+            CLog.w("No build target, fall back to build flavor %s", build_flavor);
+            return build_flavor;
+        }
+        return buildTarget;
+    }
+
+    /**
+     * Set the Androidbuildinternal client. Exposed for testing.
+     *
+     * @param client
+     */
+    void setClient(Androidbuildinternal client) {
+        mClient = client;
+    }
+
+    /** Get IBuildInfo. Exposed for testing. */
+    IBuildInfo getBuildInfo() {
+        return mBuildInfo;
+    }
+
+    /**
+     * Set IBuildInfo. Exposed for testing.
+     *
+     * @param buildInfo
+     */
+    void setBuildInfo(IBuildInfo buildInfo) {
+        mBuildInfo = buildInfo;
+    }
+
+    /**
+     * Get test result identify.
+     *
+     * @return test result identify.
+     */
+    @VisibleForTesting
+    TestResultIdentity getTestResultIdentity() {
+        return mTestResultIdentity;
+    }
+
+    /**
+     * Get file path to log data type map.
+     *
+     * @return the file path to log data type map.
+     */
+    @VisibleForTesting
+    Map<String, LogDataType> getFilePathToLogDataTypeMap() {
+        return mFilePathToLogDataTypeMap;
+    }
+
+    /**
+     * Get test result id.
+     *
+     * @return test result id
+     */
+    Long getTestResultId() {
+        return mTestResultIdentity.mTestResultId;
+    }
+
+    /**
+     * Get test result build id.
+     *
+     * @return test result build id
+     */
+    String getTestResultBuildId() {
+        return mTestResultIdentity.mTestResultBuildId;
+    }
+
+    /**
+     * Get test result build target.
+     *
+     * @return test result build target
+     */
+    String getTestResultBuildTarget() {
+        return mTestResultIdentity.mTestResultBuildTarget;
+    }
+
+    /**
+     * Set log root path Exposed for testing.
+     *
+     * @param logRootPath
+     */
+    void setLogRootPath(File logRootPath) {
+        mLogRootPath = logRootPath;
+    }
+
+    /**
+     * Get log root path Exposed for testing.
+     *
+     * @return the log root path
+     */
+    File getLogRootPath() {
+        return mLogRootPath;
+    }
+
+    /**
+     * Set log staging dir. Exposed for testing.
+     *
+     * @param logStagingDir
+     */
+    void setLogStagingDir(File logStagingDir) {
+        mLogStagingDir = logStagingDir;
+    }
+
+    /**
+     * Get log staging dir. Exposed for testing.
+     *
+     * @return the log staing dir.
+     */
+    File getLogStagingDir() {
+        return mLogStagingDir;
+    }
+
+    /**
+     * Get remote path. Exposed for testing.
+     *
+     * @return the remote path
+     */
+    String getRemotePath() {
+        return mRemotePath;
+    }
+
+    /**
+     * Set compress. Exposed for testing.
+     *
+     * @param compress
+     */
+    void setCompressFiles(boolean compress) {
+        mCompressFiles = compress;
+    }
+
+    /**
+     * Set use stub build. Exposed for testing.
+     *
+     * @param useStubBuild
+     */
+    void setUseStubBuild(boolean useStubBuild) {
+        mUseStubBuild = useStubBuild;
+    }
+
+    /** Sets whether or not to use periodic uploads. */
+    void setUsePeriodicUpload(boolean usePeriodicUpload) {
+        mPeriodicUpload = usePeriodicUpload;
+    }
+
+    /** Sets the frequency at which periodic upload should run. */
+    void setPeriodicUploadFrequency(long freq) {
+        mPeriodicUploadFreq = freq;
+    }
+
+    /**
+     * Get the log file saver. Exposed for testing.
+     *
+     * @return log file saver
+     */
+    LogFileSaver getLogFilerSaver() {
+        return mLogFileSaver;
+    }
+
+    /**
+     * @return the default RunUtil.
+     */
+    @VisibleForTesting
+    IRunUtil getRunUtil() {
+        return RunUtil.getDefault();
+    }
+
+    /**
+     * Set the client initialized flag. Exposed for testing.
+     *
+     * @param clientInitialized
+     */
+    void setClientInitialized(boolean clientInitialized) {
+        mClientInitialized = clientInitialized;
+    }
+
+    @VisibleForTesting
+    void waitForUploadThread() {
+        if (mUploadThread != null) {
+            mUploadThread.cancel();
+            try {
+                CLog.d("Waiting for the periodic upload thread.");
+                mUploadThread.join(UPLOAD_THREAD_JOIN_TIMEOUT_MS);
+                CLog.d("Done waiting for the periodic upload thread.");
+            } catch (InterruptedException e) {
+                CLog.e(e);
+            }
+        }
+    }
+
+    boolean isSandbox() {
+        return System.getenv(TradefedSandbox.SANDBOX_ENABLED) != null;
+    }
+
+    /** Threads that execute an upload then sleeps and so on until cancelled. */
+    @VisibleForTesting
+    class UploadThread extends Thread {
+
+        private boolean mCancel = false;
+        private final long mFrequency;
+
+        public UploadThread(long frequency) {
+            setDaemon(true);
+            setName("AndroidBuildApiLogSaver-UploadThread");
+            mFrequency = frequency;
+        }
+
+        @Override
+        public void run() {
+            RunUtil.getDefault().allowInterrupt(true);
+            while (!mCancel) {
+                if (!shouldUpload()) {
+                    return;
+                }
+                fetchInvocationAndWorkUnitId();
+                if (!Strings.isNullOrEmpty(mInvocationId) && !Strings.isNullOrEmpty(mWorkUnitId)) {
+                    List<String> stagedPaths = listStagedFiles(getLogStagingDir());
+                    if (stagedPaths == null) {
+                        // It is uncommon that we don't even have a host log to save, so log
+                        // something
+                        CLog.w("No log files were saved; skipping export to Android Build Api.");
+                        return;
+                    }
+                    RunUtil.getDefault().allowInterrupt(false);
+                    if (mParallelUpload) {
+                        int poolSize = Math.min(stagedPaths.size(), 50);
+                        if (poolSize != 0) {
+                            ParallelDeviceExecutor<Boolean> executor =
+                                    new ParallelDeviceExecutor<>(poolSize);
+                            List<Callable<Boolean>> callableTasks = new ArrayList<>();
+                            for (String stagedPath : stagedPaths) {
+                                // Only upload files that have artifact type in the map already
+                                // Files with no artifact type will be uploaded at invocationEnded
+                                // or in later rounds when the type is included in the map.
+                                if (getFilePathToLogDataTypeMap().get(stagedPath) != null) {
+                                    Callable<Boolean> callableTask =
+                                            () -> {
+                                                uploadOnPath(stagedPath);
+                                                return true;
+                                            };
+                                    callableTasks.add(callableTask);
+                                    // mark this log file as handled for upload, so that it's not
+                                    // considered for upload during next rounds of periodic upload.
+                                    mUploadedLogs.add(stagedPath);
+                                }
+                            }
+                            executor.invokeAll(callableTasks, 0L, TimeUnit.MINUTES);
+                        }
+                    } else {
+                        for (String stagedPath : stagedPaths) {
+                            if (mCancel) {
+                                return;
+                            }
+                            if (getFilePathToLogDataTypeMap().get(stagedPath) != null) {
+                                // mark this log file as handled for upload, so that it's not
+                                // considered
+                                // for upload during next rounds of periodic upload.
+                                mUploadedLogs.add(stagedPath);
+                                uploadOnPath(stagedPath);
+                            }
+                        }
+                    }
+                } else {
+                    CLog.i(
+                            "Delaying log upload due to empty invocation or work unit id. If this"
+                                + " message repeats, the id might not have been set correctly.");
+                }
+
+                try {
+                    RunUtil.getDefault().allowInterrupt(true);
+                    if (mCancel) {
+                        return;
+                    }
+                    RunUtil.getDefault().sleep(mFrequency);
+                } catch (RunInterruptedException e) {
+                    if (!mCancel) {
+                        // If it wasn't interrupted due to cancel, then let the exception bubble up
+                        throw e;
+                    }
+                    return;
+                }
+            }
+        }
+
+        public void cancel() {
+            mCancel = true;
+            CLog.d("Marking UploadThread as canceled for end of invocation.");
+            // This should only really interrupt the sleeping
+            RunUtil.getDefault().interrupt(this, "Canceling ants upload thread");
+        }
+    }
+}
diff --git a/src/com/google/android/tradefed/result/teststorage/Client.java b/src/com/google/android/tradefed/result/teststorage/Client.java
new file mode 100644
index 000000000..09a1dfe22
--- /dev/null
+++ b/src/com/google/android/tradefed/result/teststorage/Client.java
@@ -0,0 +1,784 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.tradefed.result.teststorage;
+
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.util.FileUtil;
+import com.android.tradefed.util.executor.ParallelDeviceExecutor;
+
+import com.google.android.tradefed.util.androidbuildapi.AndroidBuildAPIHelper;
+import com.google.api.client.googleapis.batch.BatchCallback;
+import com.google.api.client.googleapis.batch.BatchRequest;
+import com.google.api.client.googleapis.json.GoogleJsonErrorContainer;
+import com.google.api.client.googleapis.json.GoogleJsonResponseException;
+import com.google.api.client.http.AbstractInputStreamContent;
+import com.google.api.client.http.ByteArrayContent;
+import com.google.api.client.http.HttpContent;
+import com.google.api.client.http.HttpHeaders;
+import com.google.api.client.http.HttpRequest;
+import com.google.api.services.androidbuildinternal.v3.Androidbuildinternal;
+import com.google.api.services.androidbuildinternal.v3.Androidbuildinternal.Testartifact.Get;
+import com.google.api.services.androidbuildinternal.v3.model.BatchInsertEntry;
+import com.google.api.services.androidbuildinternal.v3.model.BatchInsertError;
+import com.google.api.services.androidbuildinternal.v3.model.Build;
+import com.google.api.services.androidbuildinternal.v3.model.BuildArtifactMetadata;
+import com.google.api.services.androidbuildinternal.v3.model.BuildAttempt;
+import com.google.api.services.androidbuildinternal.v3.model.Invocation;
+import com.google.api.services.androidbuildinternal.v3.model.TestArtifactListResponse;
+import com.google.api.services.androidbuildinternal.v3.model.TestResult;
+import com.google.api.services.androidbuildinternal.v3.model.TestResultBatchInsertRequest;
+import com.google.api.services.androidbuildinternal.v3.model.TestResultBatchInsertResponse;
+import com.google.api.services.androidbuildinternal.v3.model.WorkUnit;
+import com.google.common.collect.ImmutableList;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.security.GeneralSecurityException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+/** Android Test storage client that uploads test results to the Test Storage service. */
+public final class Client implements ITestStorageClient {
+    private final Androidbuildinternal mAndroidbuildClient;
+    private final com.google.api.services.androidbuildinternal.Androidbuildinternal mLegacyClient;
+    private final Uploader mUploader;
+    private final Thread mUploadThread;
+    private final int mMaxBatchSize;
+    private final int mInsertBatchSize;
+
+    // TODO(b/143365209): Remove the flag once we fully switch over to v3 api.
+    private final boolean mUseLegacyMigration;
+
+    private final boolean mUseBatchApi;
+
+    private static final String OP_WORK_UNIT = "work_unit";
+    private static final String OP_INVOCATION = "invocation";
+    private static final String OP_BATCH_UPLOAD = "batch_upload";
+
+    private static final int HTTP_BATCH_SIZE = 1024;
+    private static final int DEFAULT_BATCH_SIZE = 200;
+    private static final int DEADLINE_EXCEEDED_ERROR = 4;
+
+    public static ITestStorageClient create(
+            String buildEnvironment, boolean useLegacyMigration, boolean useBatchApi)
+            throws GeneralSecurityException, IOException {
+        return new Client(
+                AndroidBuildAPIHelper.getTestStorageClient(buildEnvironment),
+                AndroidBuildAPIHelper.getLegacyClient(buildEnvironment),
+                useLegacyMigration,
+                true,
+                useBatchApi,
+                DEFAULT_BATCH_SIZE,
+                0);
+    }
+
+    public static ITestStorageClient create(
+            String buildEnvironment,
+            boolean useLegacyMigration,
+            boolean enableUploadThread,
+            boolean useBatchApi)
+            throws GeneralSecurityException, IOException {
+        return new Client(
+                AndroidBuildAPIHelper.getTestStorageClient(buildEnvironment),
+                AndroidBuildAPIHelper.getLegacyClient(buildEnvironment),
+                useLegacyMigration,
+                enableUploadThread,
+                useBatchApi,
+                DEFAULT_BATCH_SIZE,
+                0);
+    }
+
+    public static ITestStorageClient create(
+            String buildEnvironment,
+            boolean useLegacyMigration,
+            boolean enableUploadThread,
+            boolean useBatchApi,
+            int maxBatchSize,
+            int insertBatchSize)
+            throws GeneralSecurityException, IOException {
+        return new Client(
+                AndroidBuildAPIHelper.getTestStorageClient(buildEnvironment),
+                AndroidBuildAPIHelper.getLegacyClient(buildEnvironment),
+                useLegacyMigration,
+                enableUploadThread,
+                useBatchApi,
+                maxBatchSize,
+                insertBatchSize);
+    }
+
+    public static ITestStorageClient create(Androidbuildinternal client) {
+        return new Client(client);
+    }
+
+    private Client(
+            Androidbuildinternal client,
+            com.google.api.services.androidbuildinternal.Androidbuildinternal legacyClient,
+            boolean useLegacyMigration,
+            boolean withUploadThread,
+            boolean useBatchApi,
+            int maxBatchSize,
+            int insertBatchSize) {
+        mMaxBatchSize = maxBatchSize;
+        mInsertBatchSize = insertBatchSize;
+        mAndroidbuildClient = client;
+        mLegacyClient = legacyClient;
+        if (withUploadThread) {
+            mUploader = new Uploader();
+            mUploadThread = new Thread(mUploader, "AnTS upload thread");
+            mUploadThread.setDaemon(true);
+            mUploadThread.start();
+        } else {
+            mUploader = null;
+            mUploadThread = null;
+        }
+        mUseLegacyMigration = useLegacyMigration;
+        mUseBatchApi = useBatchApi;
+    }
+
+    private Client(Androidbuildinternal client) {
+        mMaxBatchSize = DEFAULT_BATCH_SIZE;
+        mInsertBatchSize = 0;
+        mAndroidbuildClient = client;
+        mLegacyClient = null;
+        mUploader = null;
+        mUploadThread = null;
+        mUseLegacyMigration = true;
+        mUseBatchApi = false;
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public void uploadResult(TestResult result) {
+        mUploader.enqueue(result);
+    }
+
+    @Override
+    public void finalizeTestResults() {
+        mUploader.cancel();
+        try {
+            mUploadThread.join();
+        } catch (InterruptedException e) {
+            // ignore
+        }
+    }
+
+    @Override
+    public void uploadAssociations(List<LogAssociation> associations, int poolSize)
+            throws IOException {
+        // Ensure we uploaded last few results before log associations
+        mUploader.forceUpload();
+        if (mUseLegacyMigration) {
+            uploadMigratedAssociations(associations, poolSize);
+        } else {
+            legacyUploadAssociations(associations);
+        }
+    }
+
+    // Will upload log association using the migration api available in V3 client.
+    // This will still make logs available using V2 api, but migration will
+    // be made automatically on the backend.
+    private void uploadMigratedAssociations(List<LogAssociation> associations, int poolSize)
+            throws IOException {
+        // TODO(b/143365209): rename to uploadAssociations once we fully switched over to v3
+        List<Callable<Boolean>> toBeUploaded = new ArrayList<>();
+        for (LogAssociation association : associations) {
+            if (!association.isSupported()) {
+                CLog.w("Log saver does not support association for %s", association);
+                continue;
+            }
+            LogAssociationUpload oneUpload = new LogAssociationUpload(association, this);
+            toBeUploaded.add(oneUpload);
+        }
+        if (toBeUploaded.isEmpty()) {
+            return;
+        }
+        if (poolSize > 0) {
+            int poolSizeMin = Math.min(poolSize, toBeUploaded.size());
+            ParallelDeviceExecutor<Boolean> executor = new ParallelDeviceExecutor<>(poolSizeMin);
+            executor.invokeAll(toBeUploaded, 0, TimeUnit.MILLISECONDS);
+        } else {
+            // Call sequentially with blocking call.
+            for (Callable<Boolean> callable : toBeUploaded) {
+                ((LogAssociationUpload) callable).call();
+            }
+        }
+    }
+
+    /** A Callable implementation that upload a single logAssociation. */
+    private class LogAssociationUpload implements Callable<Boolean> {
+
+        private final LogAssociation mAssociation;
+        private final ITestStorageClient mClient;
+
+        LogAssociationUpload(LogAssociation association, ITestStorageClient client) {
+            mAssociation = association;
+            mClient = client;
+        }
+
+        @Override
+        public Boolean call() throws IOException {
+            CLog.v("Updating association %s name: %s:", mAssociation, mAssociation.getResourceId());
+            ObjectUpdater updater = ObjectUpdater.create(mClient);
+            updater.runUpdate(
+                    mAssociation.getInvocationId(),
+                    mAssociation.getResourceId(),
+                    mAssociation.getLegacyResultId(),
+                    new ObjectUpdater.TestArtifactUpdate() {
+                        @Override
+                        public BuildArtifactMetadata doUpdate(BuildArtifactMetadata current) {
+                            if (current == null) { // We are creating a new artifact here.
+                                current =
+                                        new BuildArtifactMetadata()
+                                                .setName(mAssociation.getResourceId());
+                            }
+                            current.setInvocationId(mAssociation.getInvocationId())
+                                    .setWorkUnitId(mAssociation.getWorkUnitId())
+                                    .setTestResultId(mAssociation.getTestResultId());
+                            return current;
+                        }
+                    });
+            return true;
+        }
+    }
+
+    @Override
+    public TestArtifactListResponse listTestArtifact(String invocationId, String artifactType)
+            throws IOException {
+        return mAndroidbuildClient
+                .testartifact()
+                .list()
+                .setInvocationId(invocationId)
+                .setArtifactType(artifactType)
+                .execute();
+    }
+
+    @Override
+    public File fetchTestArtifact(String invocationId, String resourceId) throws IOException {
+        File f = FileUtil.createTempFile("tmp-fetch-artifact", "");
+        try (FileOutputStream outputStream = new FileOutputStream(f)) {
+            Get getObject =
+                    mAndroidbuildClient
+                            .testartifact()
+                            .get(resourceId)
+                            .setInvocationId(invocationId);
+            getObject.executeMediaAndDownloadTo(outputStream);
+        } catch (IOException e) {
+            FileUtil.deleteFile(f);
+            throw e;
+        }
+        return f;
+    }
+
+    @Override
+    public BuildArtifactMetadata getTestArtifact(String invocationId, String resourceId)
+            throws IOException {
+        return mAndroidbuildClient
+                .testartifact()
+                .get(resourceId)
+                .setInvocationId(invocationId)
+                .execute();
+    }
+
+    @Override
+    public BuildArtifactMetadata updateTestArtifact(
+            String invocationId,
+            String workUnitId,
+            String testResultId,
+            BuildArtifactMetadata artifact,
+            long legacyId)
+            throws IOException {
+        return mAndroidbuildClient
+                .testartifact()
+                .update(artifact.getName(), artifact)
+                .setInvocationId(invocationId)
+                .setWorkUnitId(workUnitId)
+                .setResultId(testResultId)
+                .setLegacyTestResultId(legacyId)
+                .execute();
+    }
+
+    @Override
+    public BuildArtifactMetadata updateTestArtifact(
+            BuildArtifactMetadata artifact, long legacyId, AbstractInputStreamContent content)
+            throws IOException {
+        return mAndroidbuildClient
+                .testartifact()
+                .update(artifact.getName(), artifact, content)
+                .setInvocationId(artifact.getInvocationId())
+                .setWorkUnitId(artifact.getWorkUnitId())
+                .setResultId(artifact.getTestResultId())
+                .setLegacyTestResultId(legacyId)
+                .execute();
+    }
+
+    private void legacyUploadAssociations(List<LogAssociation> associations) throws IOException {
+        for (LogAssociation association : associations) {
+            if (!association.isSupported()) {
+                CLog.w("Log saver does not support association for %s", association);
+                continue;
+            }
+            CLog.v("Updating association %s name: %s", association, association.getResourceId());
+            BuildArtifactMetadata artifact = null;
+            try {
+                artifact =
+                        mAndroidbuildClient
+                                .testartifact()
+                                .get(association.getResourceId())
+                                .setInvocationId(association.getInvocationId())
+                                .setWorkUnitId(association.getWorkUnitId())
+                                .setResultId(association.getTestResultId())
+                                .execute();
+            } catch (GoogleJsonResponseException e) {
+                if (e.getStatusCode() != 404) {
+                    // We received an unexpected error.
+                    throw e;
+                }
+            }
+            BuildArtifactMetadata update =
+                    new BuildArtifactMetadata().setName(association.getResourceId());
+            if (artifact != null) {
+                update.setRevision(artifact.getRevision());
+            } else {
+                // To be compatible with the V2 logs uploaded by AndroidLogSaver, we need to create
+                // an empty log file using v2 API, then link that file with the log created by V3
+                // api.
+                createLegacyArtifact(association);
+            }
+            CLog.v(
+                    "Updating test artifact %s %s %s %s",
+                    association.getResourceId(),
+                    association.getInvocationId(),
+                    association.getWorkUnitId(),
+                    association.getTestResultId());
+            BuildArtifactMetadata result =
+                    mAndroidbuildClient
+                            .testartifact()
+                            .update(association.getResourceId(), update)
+                            .setInvocationId(association.getInvocationId())
+                            .setWorkUnitId(association.getWorkUnitId())
+                            .setResultId(association.getTestResultId())
+                            .execute();
+        }
+    }
+
+    private void createLegacyArtifact(LogAssociation association) throws IOException {
+        try {
+            mLegacyClient
+                    .testartifact()
+                    .get(
+                            association.getBuildType(),
+                            association.getBuildId(),
+                            association.getBuildTarget(),
+                            association.getAttemptId(),
+                            association.getLegacyResultId(),
+                            association.getResourceId())
+                    .execute();
+            // If the get was successful that means that legacy artifact already exists
+            // and we can proceed.
+            return;
+        } catch (GoogleJsonResponseException e) {
+            if (e.getStatusCode() != 404) {
+                // If we get an exception other than 404 report it.
+                throw e;
+            }
+            // If we got 404 means that artifact does not exist, attempt to create it.
+        }
+        try {
+            mLegacyClient
+                    .testartifact()
+                    .update(
+                            association.getBuildType(),
+                            association.getBuildId(),
+                            association.getBuildTarget(),
+                            association.getAttemptId(),
+                            association.getLegacyResultId(),
+                            association.getResourceId(),
+                            new com.google.api.services.androidbuildinternal.model
+                                    .BuildArtifactMetadata(),
+                            ByteArrayContent.fromString(
+                                    "text/plain", "A")) // Empty file is not accepted.
+                    .execute();
+        } catch (GoogleJsonResponseException e) {
+            // We can ignore 409 Conflict response because it means the log was already created for
+            // us by periodic uploader in AndroidBuildLogSaver.
+            if (e.getStatusCode() != 409) {
+                throw e;
+            }
+        }
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public WorkUnit createWorkUnit(WorkUnit workUnit) throws IOException {
+        return mAndroidbuildClient.workunit().insert(workUnit).execute();
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public WorkUnit updateWorkUnit(WorkUnit workUnit) throws IOException {
+        return mAndroidbuildClient.workunit().update(workUnit.getId(), workUnit).execute();
+    }
+
+    @Override
+    public WorkUnit getWorkUnit(String workUnitId) throws IOException {
+        return mAndroidbuildClient.workunit().get(workUnitId).execute();
+    }
+
+    @Override
+    public ImmutableList<WorkUnit> createWorkUnits(List<WorkUnit> workUnits) throws IOException {
+        ImmutableList.Builder<WorkUnit> results = ImmutableList.builder();
+        BatchRequest batch =
+                mAndroidbuildClient.batch(mAndroidbuildClient.getRequestFactory().getInitializer());
+        for (WorkUnit workUnit : workUnits) {
+            HttpRequest request =
+                    mAndroidbuildClient.workunit().insert(workUnit).buildHttpRequest();
+            batch.queue(
+                    request,
+                    WorkUnit.class,
+                    GoogleJsonErrorContainer.class,
+                    new BatchCallback<WorkUnit, GoogleJsonErrorContainer>() {
+                        @Override
+                        public void onFailure(GoogleJsonErrorContainer error, HttpHeaders headers) {
+                            CLog.e(error.getError().getMessage());
+                        }
+
+                        @Override
+                        public void onSuccess(WorkUnit result, HttpHeaders headers) {
+                            results.add(result);
+                        }
+                    });
+            if (batch.size() >= HTTP_BATCH_SIZE) {
+                batch.execute();
+                batch =
+                        mAndroidbuildClient.batch(
+                                mAndroidbuildClient.getRequestFactory().getInitializer());
+            }
+        }
+
+        if (batch.size() > 0) {
+            batch.execute();
+        }
+
+        return results.build();
+    }
+
+    /** See go/local_build_guide for details. */
+    @Override
+    public Build createLocalBuild(Build localBuild) throws IOException {
+        Build build = mAndroidbuildClient.build().insert("LOCAL", localBuild).execute();
+        // Once build is created, it needs an attempt to be inserted too.
+        BuildAttempt attempt = new BuildAttempt();
+        attempt.setId(0);
+        attempt.setTimestampStart(System.currentTimeMillis());
+        attempt.setTimestampEnd(System.currentTimeMillis());
+        attempt.setStatus("complete");
+        attempt.setSuccessful(true);
+        attempt =
+                mAndroidbuildClient
+                        .buildattempt()
+                        .insert(build.getBuildId(), build.getTarget().getName(), attempt)
+                        .execute();
+        return build;
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public Invocation createInvocation(Invocation invocation) throws IOException {
+        return mAndroidbuildClient.invocation().insert(invocation).execute();
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public Invocation updateInvocation(Invocation invocation) throws IOException {
+        return mAndroidbuildClient
+                .invocation()
+                .update(invocation.getInvocationId(), invocation)
+                .execute();
+    }
+
+    @Override
+    public Invocation getInvocation(String invocationId) throws IOException {
+        return mAndroidbuildClient.invocation().get(invocationId).execute();
+    }
+
+    private class Uploader implements Runnable {
+
+        // API has a request size limit of 10mb. We will prevent batch requests from going
+        // over this size. Since we can't measure the size of the batch request directly,
+        // put the limit for content to 8mb to give the batch request itself some room for
+        // overhead.
+        private static final int MAX_CONTENT_SIZE = 8388608; // 8mb
+
+        private final List<TestResult> mResultQueue = new ArrayList<TestResult>();
+        private volatile boolean mCanceled = false;
+
+        public void enqueue(TestResult result) {
+            if (mCanceled) {
+                throw new IllegalStateException(
+                        "Attempted to upload results after upload thread was cancelled");
+            }
+            synchronized (this) {
+                mResultQueue.add(result);
+                if (mResultQueue.size() >= HTTP_BATCH_SIZE) {
+                    this.notifyAll();
+                }
+            }
+        }
+
+        public synchronized void forceUpload() {
+            List<TestResult> results = new ArrayList<TestResult>();
+            if (mResultQueue.isEmpty()) {
+                return;
+            }
+            CLog.i("Starting force batch upload of %d results", mResultQueue.size());
+            results.addAll(mResultQueue);
+            mResultQueue.clear();
+            if (results.isEmpty()) {
+                return;
+            }
+            try {
+                upload(results);
+                results.clear();
+            } catch (IOException e) {
+                CLog.e("Error uploading results:");
+                CLog.e(e);
+            }
+        }
+
+        public synchronized void cancel() {
+            CLog.i("Canceling ants uploader");
+            mCanceled = true;
+            this.notifyAll();
+        }
+
+        @Override
+        public void run() {
+            List<TestResult> results = new ArrayList<TestResult>();
+            while (!mCanceled) {
+                synchronized (this) {
+                    try {
+                        this.wait(10000L);
+                    } catch (InterruptedException e) {
+                        // ignore
+                    }
+                    if (mResultQueue.size() >= HTTP_BATCH_SIZE) {
+                        CLog.i("Starting batch upload of %d results", mResultQueue.size());
+                        results.addAll(mResultQueue);
+                        mResultQueue.clear();
+                    }
+                }
+                if (!results.isEmpty()) {
+                    try {
+                        upload(results);
+                        results.clear();
+                    } catch (IOException e) {
+                        CLog.e("Error uploading results:");
+                        CLog.e(e);
+                    }
+                }
+            }
+            synchronized (this) {
+                if (!mResultQueue.isEmpty()) {
+                    try {
+                        upload(mResultQueue);
+                        mResultQueue.clear();
+                    } catch (IOException e) {
+                        CLog.e("Error uploading results:");
+                        CLog.e(e);
+                    }
+                }
+            }
+            CLog.i("Uploader terminating");
+        }
+
+        private void upload(List<TestResult> allResults) throws IOException {
+            if (mUseBatchApi) {
+                batchUpload(allResults);
+            } else {
+                httpBatchUpload(allResults);
+            }
+        }
+
+        private void batchUpload(List<TestResult> allResults) throws IOException {
+            ArrayList<BatchInsertEntry> buffer = new ArrayList<>();
+            int counter = 0;
+            String invocationId = "";
+            Map<Integer, TestResult> resultMap = new HashMap<>();
+            long totalSize = 0;
+            for (TestResult result : allResults) {
+                BatchInsertEntry entry = new BatchInsertEntry();
+                entry.setTestResult(result);
+                entry.setToken(counter);
+                buffer.add(entry);
+                invocationId = result.getInvocationId();
+                resultMap.put(counter, result);
+                totalSize = totalSize + entry.toString().length();
+                if (buffer.size() >= mMaxBatchSize || totalSize >= MAX_CONTENT_SIZE) {
+                    TestResultBatchInsertRequest request =
+                            new TestResultBatchInsertRequest()
+                                    .setTestResults(buffer)
+                                    .setInsertBatchSize(mInsertBatchSize);
+                    handleResponse(
+                            executeBatchInsert(request, invocationId),
+                            resultMap,
+                            invocationId,
+                            true);
+                    buffer.clear();
+                    resultMap.clear();
+                    totalSize = 0;
+                }
+                counter++;
+            }
+            if (!buffer.isEmpty()) {
+                TestResultBatchInsertRequest request =
+                        new TestResultBatchInsertRequest().setTestResults(buffer);
+                handleResponse(
+                        executeBatchInsert(request, invocationId), resultMap, invocationId, true);
+            }
+        }
+
+        private void handleResponse(
+                TestResultBatchInsertResponse response,
+                Map<Integer, TestResult> resultMap,
+                String invocationId,
+                boolean doRetry)
+                throws IOException {
+            if (response.getTestResults() != null) {
+                for (BatchInsertEntry entry : response.getTestResults()) {
+                    TestResult result = resultMap.getOrDefault(entry.getToken(), null);
+                    if (result == null) {
+                        CLog.w(
+                                "Received a token with no matching test result %d %s",
+                                entry.getToken(), entry.getTestResult());
+                        continue;
+                    }
+                    result.setTestResultId(entry.getTestResult().getTestResultId());
+                }
+            }
+
+            if (response.getInsertErrors() == null || response.getInsertErrors().isEmpty()) {
+                // There were no errors so return.
+                return;
+            }
+
+            Set<Integer> errorCodes = new HashSet<Integer>();
+            ArrayList<BatchInsertEntry> retries = new ArrayList<>();
+            CLog.w("Failed to upload %d results from a batch.", response.getInsertErrors().size());
+            for (BatchInsertError error : response.getInsertErrors()) {
+                if (!resultMap.containsKey(error.getToken())) {
+                    CLog.w("Received error token with no matching result %d", error.getToken());
+                    continue;
+                }
+                TestResult result = resultMap.get(error.getToken());
+                if (!errorCodes.contains(error.getErrorCode())) {
+                    // Only print one message per error code, so that we don't spam the log too
+                    // much.
+                    CLog.w("Upload error %d for test %s", error.getErrorCode(), result);
+                }
+                errorCodes.add(error.getErrorCode());
+                if (error.getErrorCode() == DEADLINE_EXCEEDED_ERROR) {
+                    // It is unlikelly other errors can be successfully retried.
+                    BatchInsertEntry entry =
+                            new BatchInsertEntry().setTestResult(result).setToken(error.getToken());
+                    retries.add(entry);
+                }
+            }
+            if (retries.isEmpty() || !doRetry) {
+                return;
+            }
+            TestResultBatchInsertRequest req =
+                    new TestResultBatchInsertRequest()
+                            .setTestResults(retries)
+                            .setInsertBatchSize(mInsertBatchSize);
+            handleResponse(executeBatchInsert(req, invocationId), resultMap, invocationId, false);
+        }
+
+        private TestResultBatchInsertResponse executeBatchInsert(
+                TestResultBatchInsertRequest request, String invocationId) throws IOException {
+            CLog.i("Executing batch of size %d", request.getTestResults().size());
+            return mAndroidbuildClient
+                    .testresult()
+                    .batchinsert(request)
+                    .setInvocationId(invocationId)
+                    .execute();
+        }
+
+        private void httpBatchUpload(List<TestResult> allResults) throws IOException {
+            long size = 0;
+            BatchRequest batch =
+                    mAndroidbuildClient.batch(
+                            mAndroidbuildClient.getRequestFactory().getInitializer());
+            for (TestResult result : allResults) {
+                long length = 0;
+                HttpRequest insert =
+                        mAndroidbuildClient.testresult().insert(result).buildHttpRequest();
+                HttpContent content = insert.getContent();
+                if (content != null) {
+                    length = content.getLength();
+                    if (length > 0) {
+                        size += length;
+                    }
+                }
+                if (size >= MAX_CONTENT_SIZE || batch.size() >= HTTP_BATCH_SIZE) {
+                    executeUploadBatch(batch);
+                    batch =
+                            mAndroidbuildClient.batch(
+                                    mAndroidbuildClient.getRequestFactory().getInitializer());
+                    size = length;
+                }
+                AtomicBoolean printedError = new AtomicBoolean(false);
+                batch.queue(
+                        insert,
+                        TestResult.class,
+                        GoogleJsonErrorContainer.class,
+                        new BatchCallback<TestResult, GoogleJsonErrorContainer>() {
+                            @Override
+                            public void onFailure(
+                                    GoogleJsonErrorContainer error, HttpHeaders headers)
+                                    throws IOException {
+                                if (!printedError.get()) {
+                                    CLog.e(error.getError().getMessage());
+                                    printedError.set(true);
+                                }
+                            }
+
+                            @Override
+                            public void onSuccess(TestResult updatedResult, HttpHeaders headers)
+                                    throws IOException {
+                                result.setTestResultId(updatedResult.getTestResultId());
+                            }
+                        });
+            }
+            if (batch.size() > 0) {
+                executeUploadBatch(batch);
+            }
+        }
+
+        private void executeUploadBatch(BatchRequest batch) throws IOException {
+            CLog.i("Executing batch of size %d to %s", batch.size(), batch.getBatchUrl());
+            batch.execute();
+        }
+    }
+}
diff --git a/src/com/google/android/tradefed/result/teststorage/ErrorType.java b/src/com/google/android/tradefed/result/teststorage/ErrorType.java
new file mode 100644
index 000000000..1b9ad81b8
--- /dev/null
+++ b/src/com/google/android/tradefed/result/teststorage/ErrorType.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.tradefed.result.teststorage;
+
+import com.android.tradefed.result.proto.TestRecordProto;
+
+// This should be kept in sync with AnTS api (wireless.android.busytown.proto.ErrorType).
+enum ErrorType {
+    ERROR_TYPE_UNSPECIFIED("errorTypeUnspecified"),
+    // The test in progress was the reason for the failure.
+    TEST_FAILURE("testFailure"),
+    // A timeout condition on the operation in progress occurred.
+    TIMEOUT("timeout"),
+    // The test in progress was cancelled.
+    TEST_CANCELLED("testCancelled"),
+    // A failure attributed to something not functioning properly.
+    INFRA_ERROR("infraError"),
+    // System under test crashed and caused the test to fail.
+    SYSTEM_UNDER_TEST_CRASHED("systemUnderTestCrashed"),
+    // The test was expected to run but did not.
+    NOT_EXECUTED("notExecuted"),
+    // System under test became unavailable and never came back available again.
+    LOST_SYSTEM_UNDER_TEST("lostSystemUnderTest"),
+    // Represent an error caused by an unmet dependency that the current infra
+    // depends on. For example: Unfound resources, Device error, Hardware issue
+    // (lab host, device wear), Underlying tools
+    DEPENDENCY_ISSUE("dependencyIssue"),
+    // Represent an error caused by the input from the end user. For example:
+    // Unexpected option combination, Configuration error, Bad flags
+    CUSTOMER_ISSUE("customerIssue");
+
+    private final String value;
+
+    private ErrorType(String value) {
+        this.value = value;
+    }
+
+    public static ErrorType create(TestRecordProto.FailureStatus status) {
+        if (status == null) {
+            return ErrorType.ERROR_TYPE_UNSPECIFIED;
+        }
+        switch (status) {
+            case TEST_FAILURE:
+                return ErrorType.TEST_FAILURE;
+            case TIMED_OUT:
+                return ErrorType.TIMEOUT;
+            case CANCELLED:
+                return ErrorType.TEST_CANCELLED;
+            case INFRA_FAILURE:
+                return ErrorType.INFRA_ERROR;
+            case SYSTEM_UNDER_TEST_CRASHED:
+                return ErrorType.SYSTEM_UNDER_TEST_CRASHED;
+            case NOT_EXECUTED:
+                return ErrorType.NOT_EXECUTED;
+            case LOST_SYSTEM_UNDER_TEST:
+                return ErrorType.LOST_SYSTEM_UNDER_TEST;
+            case DEPENDENCY_ISSUE:
+                return ErrorType.DEPENDENCY_ISSUE;
+            case CUSTOMER_ISSUE:
+                return ErrorType.CUSTOMER_ISSUE;
+            default:
+                return ErrorType.ERROR_TYPE_UNSPECIFIED;
+        }
+    }
+
+    @Override
+    public String toString() {
+        return this.value;
+    }
+}
diff --git a/src/com/google/android/tradefed/result/teststorage/ExtraBuildsBuilder.java b/src/com/google/android/tradefed/result/teststorage/ExtraBuildsBuilder.java
new file mode 100644
index 000000000..ec6722f5e
--- /dev/null
+++ b/src/com/google/android/tradefed/result/teststorage/ExtraBuildsBuilder.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.tradefed.result.teststorage;
+
+import static java.util.stream.Collectors.toList;
+
+import com.android.tradefed.invoker.IInvocationContext;
+import com.android.tradefed.log.LogUtil.CLog;
+
+import com.google.api.services.androidbuildinternal.v3.model.BuildDescriptor;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+/** A helper class to parse the extra builds args and update the invocation's extra builds field. */
+final class ExtraBuildsBuilder {
+
+    private static final String EXTRA_BUILDS_ATTR = "extra_builds";
+    private static final String DEFAULT_BUILDPROVIDER = "androidbuild";
+
+    private String extraBuildsAttribute;
+
+    /**
+     * Creates a builder object from the extra-builds argument of the current invocation context.
+     */
+    public ExtraBuildsBuilder(IInvocationContext context) {
+        List<String> extraBuilds = context.getAttributes().get(EXTRA_BUILDS_ATTR);
+        if (extraBuilds == null || extraBuilds.isEmpty()) {
+            extraBuildsAttribute = "";
+            return;
+        }
+        extraBuildsAttribute = extraBuilds.get(0);
+    }
+
+    /**
+     * Creates an extra builds field for an invocation. Takes the current extra builds and add the
+     * builds found in the extra-builds command line argument. Will only add builds that are missing
+     * from the invocation.
+     */
+    public List<BuildDescriptor> build(List<BuildDescriptor> currentBuilds) {
+        if (extraBuildsAttribute.isEmpty()) {
+            return Collections.emptyList();
+        }
+
+        Set<BuildDescriptor> newBuilds = new HashSet<>();
+        Set<BuildDescriptor> result = new HashSet<>();
+        if (currentBuilds != null) {
+            result.addAll(currentBuilds);
+        }
+
+        try {
+            JSONArray extraBuildsArray = tryParseJSONArray(extraBuildsAttribute);
+            for (int i = 0; i < extraBuildsArray.length(); i++) {
+                JSONObject extraBuild = extraBuildsArray.getJSONObject(i);
+                newBuilds.add(toBuild(extraBuild));
+            }
+        } catch (JSONException e) {
+            CLog.e("Could not parse extra builds");
+            CLog.e("%s", e);
+        }
+
+        result.addAll(newBuilds);
+        return Collections.unmodifiableList(result.stream().collect(toList()));
+    }
+
+    /** Returns true if there are no extra builds in the invocation attributes. */
+    public boolean isEmpty() {
+        return extraBuildsAttribute.isEmpty();
+    }
+
+    private static BuildDescriptor toBuild(JSONObject arg) throws JSONException {
+        return new BuildDescriptor()
+                .setBuildProvider(DEFAULT_BUILDPROVIDER)
+                .setBuildId(arg.getString("build_id"))
+                .setBranch(arg.getString("branch"))
+                .setBuildTarget(arg.getString("build_target"));
+    }
+
+    // Will parse extra builds in json array. This is a workaround for
+    // b/157228161. Sometimes the json string is escaped too many times, so
+    // when it gets here quotes around strings still have a slash in front of them.
+    private static JSONArray tryParseJSONArray(String in) throws JSONException {
+        JSONException error = null;
+        try {
+            return new JSONArray(in);
+        } catch (JSONException e) {
+            error = e;
+        }
+
+        // If the parsing failed unescape and try again.
+        String escaped = in.replace("\\\"", "\"");
+        try {
+            return new JSONArray(escaped);
+        } catch (JSONException e) {
+            // ignore
+        }
+        // If the unescape failed we want to throw an error that
+        // contains the initial string.
+        throw error;
+    }
+}
diff --git a/src/com/google/android/tradefed/result/teststorage/ITestStorageClient.java b/src/com/google/android/tradefed/result/teststorage/ITestStorageClient.java
new file mode 100644
index 000000000..e985b3fe4
--- /dev/null
+++ b/src/com/google/android/tradefed/result/teststorage/ITestStorageClient.java
@@ -0,0 +1,170 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.tradefed.result.teststorage;
+
+import com.google.api.client.http.AbstractInputStreamContent;
+import com.google.api.services.androidbuildinternal.v3.model.Build;
+import com.google.api.services.androidbuildinternal.v3.model.BuildArtifactMetadata;
+import com.google.api.services.androidbuildinternal.v3.model.Invocation;
+import com.google.api.services.androidbuildinternal.v3.model.TestArtifactListResponse;
+import com.google.api.services.androidbuildinternal.v3.model.TestResult;
+import com.google.api.services.androidbuildinternal.v3.model.WorkUnit;
+import com.google.common.collect.ImmutableList;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.List;
+
+/**
+ * Interface for communicating with Android Test Storage backend. The interface contains methods to
+ * create and update invocations and work units and upload test results. In order to create or
+ * update work units or test results, they must belong to an invocation that was either created by
+ * this client or the invocation must be added using addInvocation method.
+ */
+public interface ITestStorageClient {
+
+    /**
+     * Creates an invocation in Test Storage using the data in the provided invocation.
+     *
+     * @param invocation - describes the invocation to be created.
+     * @return invocation that was created in Test Storage.
+     * @throws IOException
+     */
+    public Invocation createInvocation(Invocation invocation) throws IOException;
+
+    /**
+     * Updates an invocation in Test Storage using the data in the provided invocation.
+     *
+     * @param invocation - invocation with updated data.
+     * @return an updated invocation.
+     * @throws IOException
+     */
+    public Invocation updateInvocation(Invocation invocation) throws IOException;
+
+    /**
+     * Returns an invocation that has the provided invocation id.
+     *
+     * @param invocationId - id of the invocation to return.
+     * @throws IOException - if the provided invocation is not found or if there is an error
+     *     communicating with the back end.
+     */
+    public Invocation getInvocation(String invocationId) throws IOException;
+
+    /**
+     * Upload provided test result to Test Storage. Test result must be part of a previously created
+     * invocation.
+     *
+     * @param result - result to upload.
+     * @throws IOException
+     */
+    public void uploadResult(TestResult result);
+
+    /**
+     * Uploads associations between logs and tests/work units. Associations allow Android Test
+     * Storage to keep track of which test produced a log.
+     *
+     * @param associations a list of log files and their associations.
+     * @param poolSize The size of the worker pool used to parallel upload. 0 for no parallel
+     *     upload.
+     * @throws IOException
+     */
+    public void uploadAssociations(List<LogAssociation> associations, int poolSize)
+            throws IOException;
+
+    /**
+     * Creates a work unit in Test Storage.
+     *
+     * @param workUnit - describes the work unit to create.
+     * @return a new work unit.
+     * @throws IOException
+     */
+    public WorkUnit createWorkUnit(WorkUnit workUnit) throws IOException;
+
+    /**
+     * Updates a provided work unit in Test Storage.
+     *
+     * @param workUnit - work unit to update.
+     * @return updated work unit.
+     * @throws IOException
+     */
+    public WorkUnit updateWorkUnit(WorkUnit workUnit) throws IOException;
+
+    /**
+     * Returns a workunit matching the provided id.
+     *
+     * @param workUnitId - id of the work unit.
+     * @throws IOException - if the provided work unit is not found or there is an error
+     *     communicating with backend services.
+     */
+    public WorkUnit getWorkUnit(String workUnitId) throws IOException;
+
+    /**
+     * Creates all work units in a provided list in TestStorage.
+     *
+     * @param workUnits - list of work units to create.
+     * @return a list of workunits that were created.
+     * @throws IOException
+     */
+    public ImmutableList<WorkUnit> createWorkUnits(List<WorkUnit> workUnits) throws IOException;
+
+    /** Waits until all test results are uploaded. */
+    public void finalizeTestResults();
+
+    /**
+     * Insert a local build in the backend.
+     *
+     * @param localBuild description of the local build
+     * @return a {@link Build}
+     * @throws IOException
+     */
+    public Build createLocalBuild(Build localBuild) throws IOException;
+
+    /** Searches and list all test artifacts matching the type provided. */
+    public TestArtifactListResponse listTestArtifact(String invocationId, String artifactType)
+            throws IOException;
+
+    /** Returns a test artifact matching provided invocation and resource id. */
+    public BuildArtifactMetadata getTestArtifact(String invocationId, String resourceId)
+            throws IOException;
+
+    /**
+     * Updates the provided artifact. This method only updates the association and does not modify
+     * the content. When calling this method provide the original invocation id, work unit id, and
+     * test result id as the arguments. Put the new work unit, and test result id in the
+     * BuildArtifactMetadata object. When work unit id and/or test resutlt as not used in the
+     * association they should be set to empty string ("").
+     */
+    public BuildArtifactMetadata updateTestArtifact(
+            String invocationId,
+            String workUnitId,
+            String testResultId,
+            BuildArtifactMetadata artifact,
+            long legacyId)
+            throws IOException;
+
+    /** Fetches and return the actually test artifact file requested. */
+    public File fetchTestArtifact(String invocationId, String resourceId) throws IOException;
+
+    /**
+     * Updates the provided artifact and uploads provided content. When uploading content, it is not
+     * possible to update association data. Do not modify the work unit id and test result id
+     * already set in the BuildArtifactMetadata argument.
+     */
+    public BuildArtifactMetadata updateTestArtifact(
+            BuildArtifactMetadata artifact, long legacyId, AbstractInputStreamContent content)
+            throws IOException;
+}
diff --git a/src/com/google/android/tradefed/result/teststorage/InvocationProperties.java b/src/com/google/android/tradefed/result/teststorage/InvocationProperties.java
new file mode 100644
index 000000000..8e920183c
--- /dev/null
+++ b/src/com/google/android/tradefed/result/teststorage/InvocationProperties.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.tradefed.result.teststorage;
+
+import com.android.tradefed.invoker.IInvocationContext;
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.util.MultiMap;
+
+import com.google.api.services.androidbuildinternal.v3.model.Property;
+import com.google.common.collect.ImmutableList;
+
+import java.util.List;
+
+final class InvocationProperties {
+
+    private static final String PROPERTY_ATTR = "invocation-property";
+
+    private InvocationProperties() {}
+
+    /**
+     * Parses AnTS invocation properties from an invocation context. Properties are stored in
+     * invocation-property attribute in the "key:value" format.
+     */
+    public static ImmutableList<Property> parse(IInvocationContext context) {
+        ImmutableList.Builder<Property> builder = ImmutableList.builder();
+        MultiMap<String, String> attributes = context.getAttributes();
+        if (attributes == null || !attributes.containsKey(PROPERTY_ATTR)) {
+            return builder.build();
+        }
+        List<String> properties = attributes.get(PROPERTY_ATTR);
+        for (String property : properties) {
+            Property p = parse(property);
+            if (isValid(p)) {
+                builder.add(p);
+            } else {
+                CLog.i("Invalid property: %s. Format must be \"name:value\"", property);
+            }
+        }
+        return builder.build();
+    }
+
+    private static Property parse(String property) {
+        return new Property().setName(name(property)).setValue(value(property));
+    }
+
+    private static String name(String property) {
+        int index = property.indexOf(':');
+        if (index == -1) {
+            return "";
+        }
+        return property.substring(0, index);
+    }
+
+    private static String value(String property) {
+        int index = property.indexOf(':');
+        if (index == -1 || index == property.length() - 1) {
+            return "";
+        }
+        return property.substring(index + 1);
+    }
+
+    private static boolean isValid(Property p) {
+        return !p.getName().isEmpty() && !p.getValue().isEmpty();
+    }
+}
diff --git a/src/com/google/android/tradefed/result/teststorage/LocalInstructions.java b/src/com/google/android/tradefed/result/teststorage/LocalInstructions.java
new file mode 100644
index 000000000..b016456c9
--- /dev/null
+++ b/src/com/google/android/tradefed/result/teststorage/LocalInstructions.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.tradefed.result.teststorage;
+
+import com.android.tradefed.config.ConfigurationDescriptor.LocalTestRunner;
+import com.android.tradefed.invoker.IInvocationContext;
+import com.android.tradefed.result.TestDescription;
+import com.android.tradefed.util.LocalRunInstructionBuilder;
+
+import java.util.List;
+
+/**
+ * A helper class for generating instructions for running tests using atest. To enable instructions
+ * invocation attribute "local-test-runner" must be set.
+ */
+final class LocalInstructions {
+
+    private static final String LOCAL_RUNNER = "local-test-runner";
+
+    private final LocalTestRunner mRunner;
+    private final IInvocationContext mModuleContext;
+
+    public LocalInstructions(IInvocationContext invContext, IInvocationContext moduleContext) {
+        mRunner = getRunner(invContext);
+        mModuleContext = moduleContext;
+    }
+
+    /** Returns true if the local instructions are available for the current module. */
+    private boolean available() {
+        return mRunner != null && mModuleContext != null;
+    }
+
+    /**
+     * Generates local instructions for a given test if available. If instructions are not available
+     * will return an empty String.
+     */
+    public String forTest(TestDescription test) {
+        if (!available()) {
+            return "";
+        }
+
+        return LocalRunInstructionBuilder.getCommand(
+                mModuleContext.getConfigurationDescriptor(), test, mRunner);
+    }
+
+    /** Checks invocation context to figure out which local runner is being used. */
+    private static LocalTestRunner getRunner(IInvocationContext context) {
+        List<String> values = context.getAttributes().get(LOCAL_RUNNER);
+        if (values == null || values.isEmpty()) {
+            return null;
+        }
+
+        try {
+            return LocalTestRunner.valueOf(values.get(0).toUpperCase());
+        } catch (IllegalArgumentException e) {
+            return null;
+        }
+    }
+}
diff --git a/src/com/google/android/tradefed/result/teststorage/LogAssociation.java b/src/com/google/android/tradefed/result/teststorage/LogAssociation.java
new file mode 100644
index 000000000..92448512e
--- /dev/null
+++ b/src/com/google/android/tradefed/result/teststorage/LogAssociation.java
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.tradefed.result.teststorage;
+
+import com.android.tradefed.result.LogFile;
+
+import com.google.android.tradefed.build.RemoteBuildInfo;
+import com.google.api.client.util.Preconditions;
+import com.google.api.services.androidbuildinternal.v3.model.Invocation;
+import com.google.api.services.androidbuildinternal.v3.model.TestResult;
+
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.Objects;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * A class to represent a link between a log file and a test. An association represents that a
+ * particular log file was created by a particular test.
+ */
+public class LogAssociation {
+    private static final Pattern LOGSAVER_PATTERN =
+            Pattern.compile(
+                    "https:\\/\\/android-build.googleplex.com\\/builds\\/.+\\/.+\\/.+\\/.+\\/tests\\/\\d+\\/(.+)");
+
+    private final Invocation mInvocation;
+    private final String mWorkUnitId;
+    private final TestResult mTestResult;
+    private final LogFile mLog;
+    private String mResourceId;
+    private final long mLegacyResultId;
+
+    /**
+     * Create an association for a log file. A log file can be associated to an individual test, or
+     * to a test run or a module. If a log is associated with a test then a TestReseult object for
+     * that test needs to be provided. Otherwise only provide invocation and work unit.
+     *
+     * @param invocation invocation to which the log file belongs to.
+     * @param workUnitId work unit id representing the stage of the test that produced the log.
+     * @param testResult if a log was produced by a test, testResult object that represents that
+     *     test.
+     * @param log log file that needs to be associated.
+     */
+    public LogAssociation(
+            Invocation invocation,
+            String workUnitId,
+            TestResult testResult,
+            long legacyResultId,
+            LogFile log) {
+        this.mInvocation = Preconditions.checkNotNull(invocation);
+        this.mWorkUnitId = Preconditions.checkNotNull(workUnitId);
+        this.mTestResult = testResult;
+        this.mLog = Preconditions.checkNotNull(log);
+        this.mLegacyResultId = legacyResultId;
+
+        // We need to decode the resourceId because the backend expects that it is unencoded,
+        // but TF gives as the url that is already encoded.
+        mResourceId = "";
+        if (mLog.getUrl() == null) {
+            mResourceId = "";
+        } else {
+            Matcher m = LOGSAVER_PATTERN.matcher(mLog.getUrl());
+            if (!m.find()) {
+                mResourceId = "";
+            } else {
+                try {
+                    mResourceId = new URI(m.group(1)).getPath();
+                } catch (URISyntaxException e) {
+                    // ignore
+                }
+            }
+        }
+    }
+
+    public String getInvocationId() {
+        return mInvocation.getInvocationId();
+    }
+
+    public String getWorkUnitId() {
+        return mWorkUnitId;
+    }
+
+    public String getTestResultId() {
+        return mTestResult == null ? "" : mTestResult.getTestResultId();
+    }
+
+    public LogFile getLog() {
+        return mLog;
+    }
+
+    /**
+     * Returns true if log association is supported for this entry. Logs without resource id do not
+     * have a valid association.
+     */
+    public boolean isSupported() {
+        return !mResourceId.isEmpty();
+    }
+
+    /**
+     * Returns resource id for the log which uniquely identifies the log on the remote server in
+     * this particular invocation.
+     */
+    public String getResourceId() {
+        return mResourceId;
+    }
+
+    /**
+     * Returns the legacy result id used to upload the log. For backward compatibility the logs are
+     * uploaded using V2 version of the api which requires legacy result id. After the log is
+     * uploaded we create an associating using the v3 api, using invocation id and work unit id, but
+     * we still want the logs to be accessible using the legacy tools which rely on the legacy
+     * result id.
+     */
+    @Deprecated
+    public long getLegacyResultId() {
+        return this.mLegacyResultId;
+    }
+
+    /**
+     * Returns the build type. This is required for v2 log upload, where build info is required to
+     * upload the log. V3 does not need this because that information is already available in
+     * invocation.
+     */
+    @Deprecated
+    public String getBuildType() {
+        return RemoteBuildInfo.parseBuildType(getBuildId()).toString();
+    }
+
+    /** Returns build id. This is required for v2 log upload which needs build info. */
+    @Deprecated
+    public String getBuildId() {
+        return mInvocation.getPrimaryBuild().getBuildId();
+    }
+
+    /** Returns the name of the build target. This is required for v2 log upload. */
+    @Deprecated
+    public String getBuildTarget() {
+        return mInvocation.getPrimaryBuild().getBuildTarget();
+    }
+
+    /** Returns attempt id which is required for v2 log upload. */
+    @Deprecated
+    public String getAttemptId() {
+        return "0";
+    }
+
+    @Override
+    public String toString() {
+        return String.format(
+                "LogAssociation{%s %s %s %s %d}",
+                mInvocation,
+                mWorkUnitId,
+                mTestResult != null ? mTestResult.getTestResultId() : "(none)",
+                mLog,
+                mLegacyResultId);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null) return false;
+        if (getClass() != o.getClass()) return false;
+        LogAssociation other = (LogAssociation) o;
+        if (!bothNullOrEqual(mInvocation, other.mInvocation)) return false;
+        if (!bothNullOrEqual(mWorkUnitId, other.mWorkUnitId)) return false;
+        if (!bothNullOrEqual(getTestResultId(), other.getTestResultId())) return false;
+        if (!bothNullOrEqual(mLog, other.mLog)) return false;
+        if (!bothNullOrEqual(mResourceId, other.mResourceId)) return false;
+        if (mLegacyResultId != other.mLegacyResultId) return false;
+        return true;
+    }
+
+    private boolean bothNullOrEqual(Object a, Object b) {
+        return (a == null && b == null) || (a != null && a.equals(b));
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(
+                mInvocation, mWorkUnitId, getTestResultId(), mLog, mResourceId, mLegacyResultId);
+    }
+}
diff --git a/src/com/google/android/tradefed/result/teststorage/MetricFileUtil.java b/src/com/google/android/tradefed/result/teststorage/MetricFileUtil.java
new file mode 100644
index 000000000..c731c13cf
--- /dev/null
+++ b/src/com/google/android/tradefed/result/teststorage/MetricFileUtil.java
@@ -0,0 +1,351 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.tradefed.result.teststorage;
+
+import com.android.annotations.VisibleForTesting;
+import com.android.tradefed.config.IConfiguration;
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.metrics.proto.MetricMeasurement;
+import com.android.tradefed.result.FileInputStreamSource;
+import com.android.tradefed.result.ILogSaver;
+import com.android.tradefed.result.ILogSaverListener;
+import com.android.tradefed.result.ITestInvocationListener;
+import com.android.tradefed.result.InputStreamSource;
+import com.android.tradefed.result.LogDataType;
+import com.android.tradefed.result.LogFile;
+import com.android.tradefed.result.TestDescription;
+import com.android.tradefed.util.FileUtil;
+import com.android.tradefed.util.proto.TfMetricProtoUtil;
+
+import com.google.common.base.Joiner;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.regex.Pattern;
+
+/**
+ * Utility to store the test run and test metrics at the end of invocation in a text file and upload
+ * it to Android Build API.
+ */
+public class MetricFileUtil {
+
+    private static final String TEST_HEADER_SEPARATOR = "\n\n";
+    private static final String METRIC_SEPARATOR = "\n";
+    private static final String METRIC_KEY_VALUE_SEPARATOR = ":";
+    private static final String SEPARATOR = "#";
+
+    private ILogSaver mLogSaver;
+    private IConfiguration mConfiguration;
+
+    // To keep track of test run name and test run details.
+    private Map<String, List<TestRunMetrics>> mTestRunDetailsMap = new LinkedHashMap<>();
+    // To keep track test run and multiple test metrics in a test run.
+    private Map<String, Map<String, String>> mTestMetricsMap;
+
+    private String mCurrentRunName;
+
+    public void setLogSaver(ILogSaver logSaver) {
+        mLogSaver = logSaver;
+    }
+
+    @VisibleForTesting
+    ILogSaver getLogSaver() {
+        return mLogSaver;
+    }
+
+    public void setConfiguration(IConfiguration configuration) {
+        mConfiguration = configuration;
+    }
+
+    public void testRunStarted(String runName) {
+        mCurrentRunName = runName;
+        mTestMetricsMap = new LinkedHashMap<>();
+    }
+
+    public void testEnded(
+            TestDescription test, HashMap<String, MetricMeasurement.Metric> testMetrics) {
+        // Add the test metrics only if it's not empty.
+        if (null != testMetrics && !testMetrics.isEmpty()) {
+            Joiner joiner = Joiner.on(SEPARATOR).skipNulls();
+            String testName = joiner.join(test.getClassName(), test.getTestName());
+            mTestMetricsMap.put(testName, TfMetricProtoUtil.compatibleConvert(testMetrics));
+        }
+    }
+
+    public void testRunEnded(HashMap<String, MetricMeasurement.Metric> runMetrics) {
+        if (null != mCurrentRunName) {
+            // Do not update the run details map if both run and test metrics are empty.
+            if ((null == runMetrics || runMetrics.isEmpty()) && mTestMetricsMap.isEmpty()) {
+                return;
+            }
+
+            if (mTestRunDetailsMap.containsKey(mCurrentRunName)) {
+                mTestRunDetailsMap
+                        .get(mCurrentRunName)
+                        .add(
+                                new TestRunMetrics(
+                                        runMetrics != null
+                                                ? TfMetricProtoUtil.compatibleConvert(runMetrics)
+                                                : null,
+                                        mTestMetricsMap));
+            } else {
+                List<TestRunMetrics> testRunMetricsList = new LinkedList<>();
+                testRunMetricsList.add(
+                        new TestRunMetrics(
+                                runMetrics != null
+                                        ? TfMetricProtoUtil.compatibleConvert(runMetrics)
+                                        : null,
+                                mTestMetricsMap));
+                mTestRunDetailsMap.put(mCurrentRunName, testRunMetricsList);
+            }
+        }
+    }
+
+    public void invocationEnded(Set<String> metricFilterRegEx) {
+        try {
+            if (!mTestRunDetailsMap.isEmpty()) {
+                List<Pattern> metricFilterPatterns = buildMetricFilterPatterns(metricFilterRegEx);
+                // Write metrics matching the filter patterns. If metric filter pattern is
+                // empty write all the metric.
+                upload(writeResultsToFile(metricFilterPatterns));
+            }
+        } catch (IOException e) {
+            CLog.e("Not able to create test results file due to : %s", e.getMessage());
+        }
+    }
+
+    public boolean isMetricAvailable() {
+        return !mTestRunDetailsMap.isEmpty();
+    }
+
+    /**
+     * Write the test run metrics and test metrics into a file.
+     *
+     * @param metricPatterns used to filter the metrics written into the test results file.
+     * @return File containing the metrics.
+     * @throws IOException
+     */
+    private File writeResultsToFile(List<Pattern> metricPatterns) throws IOException {
+        File resultsFile = FileUtil.createTempFile("test_results", "");
+
+        // loops over all test runs
+        try (FileOutputStream outputStream = new FileOutputStream(resultsFile)) {
+            for (Map.Entry<String, List<TestRunMetrics>> testRunEntry :
+                    mTestRunDetailsMap.entrySet()) {
+                for (TestRunMetrics runMmetric : testRunEntry.getValue()) {
+                    // Parse run metrics
+                    if (runMmetric.getRunMetrics() != null
+                            && runMmetric.getRunMetrics().size() > 0) {
+                        // Write the test run name.
+                        outputStream.write(
+                                String.format("%s%s", testRunEntry.getKey(), TEST_HEADER_SEPARATOR)
+                                        .getBytes());
+                        // Write the test run metrics.
+                        for (Entry<String, String> entry : runMmetric.getRunMetrics().entrySet()) {
+
+                            // If filter patterns are available and if it does not matches any of
+                            // the pattern do not write the metric to a file. Otherwise write the
+                            // metric to a file.
+                            if (!metricPatterns.isEmpty()
+                                    && !isMetricKeyMatchesFilter(metricPatterns, entry.getKey())) {
+                                continue;
+                            }
+                            String test_metric =
+                                    String.format(
+                                            "%s%s%s",
+                                            entry.getKey(),
+                                            METRIC_KEY_VALUE_SEPARATOR,
+                                            entry.getValue());
+                            outputStream.write(
+                                    String.format("%s%s", test_metric, METRIC_SEPARATOR)
+                                            .getBytes());
+                        }
+                        outputStream.write(TEST_HEADER_SEPARATOR.getBytes());
+                    }
+
+                    // Parse test metrics
+                    Map<String, Map<String, String>> testResultMap = runMmetric.getTestMetricsMap();
+                    for (Entry<String, Map<String, String>> entry : testResultMap.entrySet()) {
+                        // Write the test description name.
+                        outputStream.write(
+                                String.format("%s%s", entry.getKey(), TEST_HEADER_SEPARATOR)
+                                        .getBytes());
+                        // Write the test metrics.
+                        if (entry.getValue().size() > 0) {
+                            for (Entry<String, String> metric : entry.getValue().entrySet()) {
+                                // If filter patterns are available and if it does not matches any
+                                // of the pattern do not write the metric to a file. Otherwise
+                                // write the metric to a file.
+                                if (!metricPatterns.isEmpty()
+                                        && !isMetricKeyMatchesFilter(
+                                                metricPatterns, metric.getKey())) {
+                                    continue;
+                                }
+                                String test_metric =
+                                        String.format(
+                                                "%s%s%s",
+                                                metric.getKey(),
+                                                METRIC_KEY_VALUE_SEPARATOR,
+                                                metric.getValue());
+                                outputStream.write(
+                                        String.format("%s%s", test_metric, METRIC_SEPARATOR)
+                                                .getBytes());
+                            }
+                        }
+                        outputStream.write(TEST_HEADER_SEPARATOR.getBytes());
+                    }
+                }
+            }
+            outputStream.flush();
+        }
+        return resultsFile;
+    }
+
+    /**
+     * Check if the given metric matches the metric filters.
+     *
+     * @param metricPatterns
+     * @param metricKey
+     * @return true if the metric key matches the pattern otherwise return false.
+     */
+    private boolean isMetricKeyMatchesFilter(List<Pattern> metricPatterns, String metricKey) {
+        for (Pattern pattern : metricPatterns) {
+            if (pattern.matcher(metricKey).matches()) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Upload the test result file in the Android Build API.
+     *
+     * @param resultsFile which contains the run and test metrics.
+     * @throws IOException
+     */
+    private void upload(File resultsFile) throws IOException {
+
+        if (resultsFile == null) {
+            CLog.e("Skip uploading the test metric file.");
+            return;
+        }
+
+        // This is temporary until all the use cases can read the metrics
+        // from ANTS.
+        CLog.i(FileUtil.readStringFromFile(resultsFile));
+
+        try (InputStreamSource inputStreamSrc = new FileInputStreamSource(resultsFile)) {
+            LogFile log =
+                    mLogSaver.saveLogData(
+                            resultsFile.getName(),
+                            LogDataType.CB_METRICS_FILE,
+                            inputStreamSrc.createInputStream());
+            if (null != log) {
+                CLog.i("Uploading file: %s.", resultsFile.getName());
+                for (ITestInvocationListener listener :
+                        mConfiguration.getTestInvocationListeners()) {
+                    if (listener instanceof ILogSaverListener) {
+                        try {
+                            ((ILogSaverListener) listener)
+                                    .testLogSaved(
+                                            resultsFile.getName(),
+                                            LogDataType.CB_METRICS_FILE,
+                                            inputStreamSrc,
+                                            log);
+                            ((ILogSaverListener) listener)
+                                    .logAssociation(resultsFile.getName(), log);
+                        } catch (Exception e) {
+                            CLog.e("Error while logging metric file on %s", listener);
+                            CLog.e(e);
+                        }
+                    }
+                }
+            } else {
+                CLog.i("Results or log file is null");
+            }
+        } catch (IOException e) {
+            CLog.e("Not able to save log file due to : %s", e.getMessage());
+        } finally {
+            FileUtil.deleteFile(resultsFile);
+        }
+    }
+
+    public class TestRunMetrics {
+
+        private Map<String, String> mRunMetrics;
+        private Map<String, Map<String, String>> mTestMetricsMap;
+
+        TestRunMetrics(
+                Map<String, String> runMetrics, Map<String, Map<String, String>> testMetricsMap) {
+            mRunMetrics = runMetrics;
+            mTestMetricsMap = testMetricsMap;
+        }
+
+        /**
+         * @return the mRunMetrics
+         */
+        public Map<String, String> getRunMetrics() {
+            return mRunMetrics;
+        }
+
+        /**
+         * @param runMetrics the mRunMetrics to set
+         */
+        public void setRunMetrics(Map<String, String> runMetrics) {
+            this.mRunMetrics = runMetrics;
+        }
+
+        /**
+         * @return the mTestMetricsMap
+         */
+        public Map<String, Map<String, String>> getTestMetricsMap() {
+            return mTestMetricsMap;
+        }
+
+        /**
+         * @param testMetricsMap the mTestMetricsMap to set
+         */
+        public void setTestMetricsMap(Map<String, Map<String, String>> testMetricsMap) {
+            this.mTestMetricsMap = testMetricsMap;
+        }
+    }
+
+    /**
+     * Build regular expression patterns to filter the metrics written into the test results file.
+     */
+    private List<Pattern> buildMetricFilterPatterns(Set<String> metricFilterRegex) {
+        List<Pattern> mMetricPatterns = new ArrayList<>();
+        if (!metricFilterRegex.isEmpty() && mMetricPatterns.isEmpty()) {
+            for (String regEx : metricFilterRegex) {
+                try {
+                    mMetricPatterns.add(Pattern.compile(regEx));
+                } catch (IllegalArgumentException e) {
+                    CLog.d("Invalid regex pattern: %s", e.getMessage());
+                }
+            }
+        }
+        return mMetricPatterns;
+    }
+}
diff --git a/src/com/google/android/tradefed/result/teststorage/MetricUtils.java b/src/com/google/android/tradefed/result/teststorage/MetricUtils.java
new file mode 100644
index 000000000..a35fe5dfb
--- /dev/null
+++ b/src/com/google/android/tradefed/result/teststorage/MetricUtils.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.tradefed.result.teststorage;
+
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.metrics.proto.MetricMeasurement;
+import com.android.tradefed.metrics.proto.MetricMeasurement.Measurements;
+import com.android.tradefed.metrics.proto.MetricMeasurement.Measurements.MeasurementCase;
+
+import com.google.api.services.androidbuildinternal.v3.model.Metric;
+import com.google.api.services.androidbuildinternal.v3.model.MetricGroup;
+import com.google.api.services.androidbuildinternal.v3.model.Metrics;
+import com.google.api.services.androidbuildinternal.v3.model.Statistics;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+
+/** Class to hold helper methods for dealing with Metric format conversion. */
+public final class MetricUtils {
+    /**
+     * Converts a HashMap of metric key to Tradefed Metric mappings to an Android Build API Metrics
+     * model.
+     *
+     * @param tfMetrics a HashMap of metric key to Tradefed Metric
+     * @return the Metrics model
+     */
+    public static Metrics toMetrics(HashMap<String, MetricMeasurement.Metric> tfMetrics) {
+        HashMap<String, Double> doubleMetrics = convertValueToDouble(tfMetrics);
+        List<MetricGroup> metricGroups = new ArrayList<MetricGroup>();
+        for (String metricKey : doubleMetrics.keySet()) {
+            double metricValue = doubleMetrics.get(metricKey);
+            Metric metric =
+                    new Metric()
+                            .setMetadataId(0L)
+                            .setStatistics(
+                                    new Statistics()
+                                            .setCount(1L)
+                                            .setMean(metricValue)
+                                            .setStandardDeviation(0D)
+                                            .setMinimum(metricValue)
+                                            .setMedian(metricValue)
+                                            .setMaximum(metricValue));
+            MetricGroup metricGroup =
+                    new MetricGroup().setName(metricKey).setMetrics(Arrays.asList(metric));
+            metricGroups.add(metricGroup);
+        }
+
+        Metrics metrics = new Metrics().setMetricGroups(metricGroups);
+        return metrics;
+    }
+
+    /**
+     * Conversion of Map<String, MetricMeasurement.Metric> to Map<String, Double>. Single values of
+     * int and double are kept, lists of values are not converted and will be lost.
+     *
+     * @param tfMetrics a HashMap of metric key to Tradefed Metric
+     * @return a HashMap of metric key to double value
+     */
+    public static HashMap<String, Double> convertValueToDouble(
+            HashMap<String, MetricMeasurement.Metric> tfMetrics) {
+        HashMap<String, Double> metrics = new HashMap<>();
+        List<String> metricsNotConverted = new ArrayList<>();
+        List<String> metricsWithoutMeasurement = new ArrayList<>();
+        for (String key : tfMetrics.keySet()) {
+            Measurements measures = tfMetrics.get(key).getMeasurements();
+            MeasurementCase set = measures.getMeasurementCase();
+            double value;
+            switch (set) {
+                case SINGLE_DOUBLE:
+                    value = measures.getSingleDouble();
+                    break;
+                case SINGLE_INT:
+                    value = measures.getSingleInt();
+                    break;
+                case SINGLE_STRING:
+                    try {
+                        value = Double.parseDouble(measures.getSingleString());
+                        break;
+                    } catch (NumberFormatException e) {
+                        metricsNotConverted.add(
+                                String.format("metric key: %s, type: %s", key, set));
+                        continue;
+                    }
+                case MEASUREMENT_NOT_SET:
+                    metricsWithoutMeasurement.add(key);
+                    continue;
+                default:
+                    metricsNotConverted.add(String.format("metric key: %s, type: %s", key, set));
+                    continue;
+            }
+            metrics.put(key, value);
+        }
+        if (!metricsNotConverted.isEmpty()) {
+            CLog.d(
+                    String.format(
+                            "Could not convert complex types to double. %s.",
+                            String.join("; ", metricsNotConverted)));
+        }
+        if (!metricsWithoutMeasurement.isEmpty()) {
+            CLog.d(
+                    String.format(
+                            "No measurements was set for metric keys: %s.",
+                            String.join(", ", metricsWithoutMeasurement)));
+        }
+        return metrics;
+    }
+}
diff --git a/src/com/google/android/tradefed/result/teststorage/ObjectUpdater.java b/src/com/google/android/tradefed/result/teststorage/ObjectUpdater.java
new file mode 100644
index 000000000..d6520768d
--- /dev/null
+++ b/src/com/google/android/tradefed/result/teststorage/ObjectUpdater.java
@@ -0,0 +1,205 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.tradefed.result.teststorage;
+
+import com.android.tradefed.log.LogUtil.CLog;
+
+import com.google.api.client.googleapis.json.GoogleJsonResponseException;
+import com.google.api.client.http.AbstractInputStreamContent;
+import com.google.api.services.androidbuildinternal.v3.Androidbuildinternal;
+import com.google.api.services.androidbuildinternal.v3.model.BuildArtifactMetadata;
+import com.google.api.services.androidbuildinternal.v3.model.Invocation;
+import com.google.api.services.androidbuildinternal.v3.model.WorkUnit;
+
+import java.io.IOException;
+
+/**
+ * Helper class to manage updates to AnTS objects.
+ *
+ * <p>When updating an AnTS object first we need to make sure that we are updating the correct
+ * version. The helper class will automatically fetch the latest version of the object and will
+ * automatically update it retrying in case there are errors and/or versions conflicts.
+ */
+public class ObjectUpdater {
+
+    /**
+     * Interface to encapsulte an update. The doUpdate method will be called with the latest version
+     * of the WorkUnit in the api. Will be automatically retried if there are any errors in the
+     * update or the version changes.
+     *
+     * <p>Must return a work unit that will be committed to the AnTS api.
+     */
+    public interface WorkUnitUpdate {
+        public WorkUnit doUpdate(WorkUnit current);
+    }
+
+    /** Perform an update of the provided invocation. Works same as the WorkUnitUpdate. */
+    public interface InvocationUpdate {
+        public Invocation doUpdate(Invocation current);
+    }
+
+    /**
+     * Perform an update on the returned BuildArtifact. Works same as the other Update interfaces.
+     * Since update call is used to both create and update artifacts, a null argument means that
+     * there is no current artifact and a new artifact will be created.
+     */
+    public abstract static class TestArtifactUpdate {
+        public abstract BuildArtifactMetadata doUpdate(BuildArtifactMetadata current);
+
+        /** Return the content that will be uploaded. */
+        public AbstractInputStreamContent getContent() {
+            return null;
+        }
+    }
+
+    private final ITestStorageClient mClient;
+
+    private ObjectUpdater(ITestStorageClient client) {
+        mClient = client;
+    }
+
+    public static ObjectUpdater create(ITestStorageClient client) {
+        return new ObjectUpdater(client);
+    }
+
+    public static ObjectUpdater create(Androidbuildinternal apiClient) {
+        return new ObjectUpdater(Client.create(apiClient));
+    }
+
+    /**
+     * Executes the provided update operation. Takes an id of the work unit that needs to be
+     * updated. Will fetch the latest version and will retry the update operation if there are any
+     * errors.
+     */
+    public WorkUnit runUpdate(String id, WorkUnitUpdate update) throws IOException {
+        IOException exception = null;
+        for (int i = 0; i < 3; i++) {
+            exception = null;
+            WorkUnit workUnit = mClient.getWorkUnit(id);
+            WorkUnit newWorkUnit = update.doUpdate(workUnit);
+            if (newWorkUnit == null) {
+                return null;
+            }
+            try {
+                return mClient.updateWorkUnit(newWorkUnit);
+            } catch (GoogleJsonResponseException e) {
+                exception = e;
+                if (e.getStatusCode() == 409) {
+                    CLog.w("Detected a conflict when updating work unit %s", id);
+                    continue;
+                }
+                CLog.w("Error updating work unit %s", newWorkUnit);
+                CLog.w(e);
+            } catch (IOException e) {
+                exception = e;
+                CLog.w("Error updating work unit %s", newWorkUnit);
+                CLog.w(e);
+            }
+        }
+
+        throw exception;
+    }
+
+    /**
+     * Executes the provided update operation. Takes an id of the invocation that needs to be
+     * updated. Will fetch the latest version and will retry the update operation if there are any
+     * errors.
+     */
+    public Invocation runUpdate(String id, InvocationUpdate update) throws IOException {
+        IOException exception = null;
+        for (int i = 0; i < 3; i++) {
+            exception = null;
+            Invocation latest = mClient.getInvocation(id);
+            Invocation updated = update.doUpdate(latest);
+            if (updated == null) {
+                return null;
+            }
+            try {
+                return mClient.updateInvocation(updated);
+            } catch (GoogleJsonResponseException e) {
+                exception = e;
+                if (e.getStatusCode() == 409) {
+                    CLog.w("Detected a conflict when updating invocation %s", id);
+                    continue;
+                }
+                CLog.w("Error updating invocation %s", updated);
+                CLog.w(e);
+            } catch (IOException e) {
+                exception = e;
+                CLog.w("Error updating invocation %s", updated);
+                CLog.w(e);
+            }
+        }
+
+        throw exception;
+    }
+
+    public BuildArtifactMetadata runUpdate(
+            String invocationId, String resourceId, long legacyId, TestArtifactUpdate update)
+            throws IOException {
+        IOException exception = null;
+        for (int i = 0; i < 3; i++) {
+            exception = null;
+            BuildArtifactMetadata latest = null;
+            try {
+                latest = mClient.getTestArtifact(invocationId, resourceId);
+            } catch (GoogleJsonResponseException e) {
+                if (e.getStatusCode() != 404) {
+                    exception = e;
+                    CLog.w("Error retrieving test artifact %s %s", invocationId, resourceId);
+                    continue;
+                }
+                // Else we got a 404 which is expected, ignore it.
+            }
+
+            String workUnitId = latest == null ? "" : latest.getWorkUnitId();
+            String testResultId = latest == null ? "" : latest.getTestResultId();
+            BuildArtifactMetadata updated = update.doUpdate(latest);
+            if (updated == null) {
+                return null;
+            }
+            AbstractInputStreamContent content = update.getContent();
+            try {
+                if (content == null) {
+                    return mClient.updateTestArtifact(
+                            invocationId, workUnitId, testResultId, updated, legacyId);
+                } else {
+                    return mClient.updateTestArtifact(updated, legacyId, content);
+                }
+            } catch (GoogleJsonResponseException e) {
+                exception = e;
+                if (e.getStatusCode() == 413) {
+                    CLog.w("Payload is too big. aborting upload of %s", resourceId);
+                    CLog.w(e);
+                    // Don't retry since file above a certain limit will never succeed
+                    break;
+                }
+                if (e.getStatusCode() == 409) {
+                    CLog.w("Detected a conflict when updating test artifact %s", resourceId);
+                    continue;
+                }
+                CLog.w("Error updating test artifact %s", resourceId);
+                CLog.w(e);
+            } catch (IOException e) {
+                exception = e;
+                CLog.w("Error updating test artifact %s", resourceId);
+                CLog.w(e);
+            }
+        }
+        throw exception;
+    }
+}
diff --git a/src/com/google/android/tradefed/result/teststorage/ResultReporter.java b/src/com/google/android/tradefed/result/teststorage/ResultReporter.java
new file mode 100644
index 000000000..b12132474
--- /dev/null
+++ b/src/com/google/android/tradefed/result/teststorage/ResultReporter.java
@@ -0,0 +1,2082 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.tradefed.result.teststorage;
+
+import static com.google.android.tradefed.util.androidbuildapi.AndroidBuildAPIHelper.BUILD_ENV_INVOCATION_CONTEXT_KEY;
+
+import com.android.ddmlib.Log.LogLevel;
+import com.android.tradefed.build.IBuildInfo;
+import com.android.tradefed.cluster.ClusterOptions;
+import com.android.tradefed.cluster.IClusterOptions;
+import com.android.tradefed.config.GlobalConfiguration;
+import com.android.tradefed.config.IConfiguration;
+import com.android.tradefed.config.IConfigurationReceiver;
+import com.android.tradefed.config.IGlobalConfiguration;
+import com.android.tradefed.config.Option;
+import com.android.tradefed.config.OptionClass;
+import com.android.tradefed.config.proxy.TradefedDelegator;
+import com.android.tradefed.invoker.DelegatedInvocationExecution;
+import com.android.tradefed.invoker.IInvocationContext;
+import com.android.tradefed.invoker.logger.InvocationMetricLogger;
+import com.android.tradefed.invoker.logger.InvocationMetricLogger.InvocationMetricKey;
+import com.android.tradefed.invoker.tracing.CloseableTraceScope;
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.metrics.proto.MetricMeasurement;
+import com.android.tradefed.result.FailureDescription;
+import com.android.tradefed.result.ILogSaver;
+import com.android.tradefed.result.ILogSaverListener;
+import com.android.tradefed.result.ITestSummaryListener;
+import com.android.tradefed.result.LogFile;
+import com.android.tradefed.result.TestDescription;
+import com.android.tradefed.result.TestSummary;
+import com.android.tradefed.result.retry.ISupportGranularResults;
+import com.android.tradefed.result.skipped.SkipReason;
+import com.android.tradefed.testtype.suite.ITestSuite;
+import com.android.tradefed.testtype.suite.ModuleDefinition;
+import com.android.tradefed.testtype.suite.SuiteTestFilter;
+import com.android.tradefed.util.MultiMap;
+import com.android.tradefed.util.StreamUtil;
+import com.android.tradefed.util.SystemUtil;
+import com.android.tradefed.util.UniqueMultiMap;
+import com.android.tradefed.util.VersionParser;
+
+import com.google.android.tradefed.build.AbLocalBuildProvider;
+import com.google.android.tradefed.result.AndroidBuildApiLogSaver;
+import com.google.api.services.androidbuildinternal.v3.model.AconfigFlag;
+import com.google.api.services.androidbuildinternal.v3.model.AconfigFlags;
+import com.google.api.services.androidbuildinternal.v3.model.BuildDescriptor;
+import com.google.api.services.androidbuildinternal.v3.model.DebugInfo;
+import com.google.api.services.androidbuildinternal.v3.model.Invocation;
+import com.google.api.services.androidbuildinternal.v3.model.Metrics;
+import com.google.api.services.androidbuildinternal.v3.model.ModuleInfo;
+import com.google.api.services.androidbuildinternal.v3.model.Property;
+import com.google.api.services.androidbuildinternal.v3.model.SkippedReason;
+import com.google.api.services.androidbuildinternal.v3.model.TestDefinition;
+import com.google.api.services.androidbuildinternal.v3.model.TestIdentifier;
+import com.google.api.services.androidbuildinternal.v3.model.TestResult;
+import com.google.api.services.androidbuildinternal.v3.model.Timing;
+import com.google.api.services.androidbuildinternal.v3.model.WorkUnit;
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.base.Splitter;
+import com.google.common.base.Strings;
+import com.google.common.collect.HashMultimap;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Multimap;
+import com.google.common.collect.Multimaps;
+
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.security.GeneralSecurityException;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Deque;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Optional;
+import java.util.Set;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
+@OptionClass(alias = "ants-result-reporter")
+public class ResultReporter
+        implements ITestSummaryListener,
+                ILogSaverListener,
+                ISupportGranularResults,
+                IConfigurationReceiver {
+
+    // Additional property names set for the work unit.
+    private static final String ATTEMPT_PROPERTY = "attempt";
+    private static final String TF_VERSION_PROPERTY = "tradefed_version";
+    private static final String USER_PROPERTY = "user";
+    private static final String HOSTNAME_PROPERTY = "hostname";
+    private static final String BUILD_FLAVOR_PROPERTY = "build_flavor";
+    private static final String CLUSTER_OPTIONS_HOST_LABEL_PROPERTY = "host_label";
+    private static final String CLUSTER_OPTIONS_LAB_NAME_PROPERTY = "lab_name";
+    private static final String CLUSTER_OPTIONS_CLUSTER_ID_PROPERTY = "cluster";
+
+    /** Key of the command line args attributes */
+    private static final String COMMAND_ARGS_KEY = "command_line_args";
+
+    // Property name for the test mapping source
+    private static final String TEST_MAPPING_PROPERTY = "test_mapping_source";
+
+    // Property name for Sponge invocation id.
+    private static final String SPONGE_INVOCATION_ID_PROPERTY = "sponge_invocation_id";
+
+    // Property name for local instructions
+    private static final String LOCAL_INSTRUCTION_PROPERTY = "local_repro_instruction";
+
+    private static final String LOCAL_RUNNER = "local-test-runner";
+    private static final String LOCAL_RUNNER_PROPERTY = "local_test_runner";
+
+    // Property name for crystalball.
+    private static final String CRYSTALBALL_INGEST_PROPERTY = "crystalball_ingest";
+    private static final String CRYSTALBALL_HAS_DATA_PROPERTY = "crystalball_has_data";
+
+    // Property name for mainline.
+    private static final String MAINLINE_MODULE_PROPERTY = "module_installed";
+
+    private static final String MAINLINE_VERSION_SUFFIX = "_version_used";
+    private static final String MAINLINE_MODULE_PREFIX = "com.google.android";
+
+    // Label to use for TF invocation work Unit.
+    private static final String TF_INVOCATION_LABEL = "tf_invocation";
+
+    // Short-link to redirect to the result page.
+    // Full-link: https://android-build.googleplex.com/builds/tests/view?invocationId=
+    private static final String RESULT_LINK = "http://ab/%s";
+
+    // Settings to use when TF is creating a Test Storage invocation.
+    public static final String DEFAULT_BUILDPROVIDER = "androidbuild";
+    public static final String EXPERIMENTAL = "experimental";
+    public static final String TRADEFED = "tradefed";
+    public static final String SYSTEM_CHECKER = "system_checker";
+
+    // Key that determines if we are using legacy V2 api or only v3 api for logs
+    private static final String ARTIFACT_UPLOAD_KEY = "use_artifact_v3_api";
+
+    private static final String TEST_RESULT_ID = "test_result_id";
+
+    // Set containing the properties that should only be set once on the workunit
+    private static final Set<String> UNIQUE_PROPERTIES =
+            ImmutableSet.of(
+                    COMMAND_ARGS_KEY,
+                    TF_VERSION_PROPERTY,
+                    USER_PROPERTY,
+                    HOSTNAME_PROPERTY,
+                    CLUSTER_OPTIONS_LAB_NAME_PROPERTY);
+
+    // Module property if set will add modules in one batch.
+    private static final String SPARSE_MODULE_PROPERTY = "sparse-module";
+    // Set containing the allowed module property keys
+    private static final Set<String> ALLOWED_MODULE_PROPERTIES =
+            ImmutableSet.of(
+                    ModuleDefinition.MODULE_ABI,
+                    ModuleDefinition.MODULE_PARAMETERIZATION,
+                    ModuleDefinition.MODULE_ISOLATED,
+                    ModuleDefinition.MODULE_EXTERNAL_DEPENDENCIES,
+                    ModuleDefinition.MODULE_CACHED,
+                    ModuleDefinition.SPARSE_MODULE,
+                    ModuleDefinition.MODULE_INVOCATION_ATTRIBUTE_FLAG_OVERRIDES_KEY);
+    private static final Pattern ACONFIG_FLAG_PATTERN =
+            Pattern.compile("(\\w+)/(.+\\..+)=(false|true)");
+    private static final char FLAG_SEPARATOR = ' ';
+
+    // Set containing the allowed test identifier module parameter keys
+    private static final Set<String> ALLOWED_MODULE_PARAMETERS =
+            ImmutableSet.of(ModuleDefinition.MODULE_ABI, ModuleDefinition.MODULE_PARAMETERIZATION);
+
+    private static final ImmutableSet<String> METRIC_STRING_TO_PROPERTIES =
+            ImmutableSet.of("run-isolated");
+    private static final ImmutableSet<String> METRIC_INT_TO_PROPERTIES =
+            ImmutableSet.of(
+                    ModuleDefinition.PREPARATION_TIME,
+                    ModuleDefinition.TEAR_DOWN_TIME,
+                    ModuleDefinition.ISOLATION_COST,
+                    ModuleDefinition.MODULE_TEST_COUNT);
+
+    @Option(name = "disable", description = "Set to true if reporter is disabled")
+    private boolean mDisable = false;
+
+    @Option(name = "root-url", description = "Root url of the Test Storage service")
+    private String mRootUrl = "https://www.googleapis.com/";
+
+    @Option(name = "service-path", description = "Service path of the Test Storage service")
+    private String mServicePath = "android/internal/build/v3";
+
+    @Option(
+            name = "create-local-invocation",
+            description = "Create an invocation, if one is not provided")
+    private boolean mCreateInvocation = SystemUtil.isLocalMode();
+
+    @Option(
+            name = "disable-associations",
+            description = "Set to true to disable uploading test artifact associations")
+    private boolean mDisableAssociations = false;
+
+    @Option(name = "support-granular-results", description = "Enable support for granular results.")
+    private boolean mSupportGranularResults = true;
+
+    @Option(
+            name = "enable-metrics",
+            description = "Flag to control whether metrics are uploaded or not.")
+    private boolean mEnableMetrics = false;
+
+    @Option(
+            name = "enable-sponge",
+            description = "Flag to control whether upload results to Sponge.")
+    private boolean mEnableSponge = true;
+
+    // TODO: remove the flag once deployment is complete and verified.
+    @Option(
+            name = "enable-error-types",
+            description = "Flag to enable setting error types for results and work units.")
+    private boolean mEnableErrorTypes = true;
+
+    @Option(
+            name = "save-metric-file",
+            description = "Flag to control whether to save the metric file or not.")
+    private boolean mEnableMetricFile = false;
+
+    @Option(
+            name = "parallel-update-actions",
+            description = "Feature flag to test parallelizing some update actions for speed.")
+    private boolean mParallelOperations = true;
+
+    @Option(
+            name = "parallel-log-association-upload-pool",
+            description =
+                    "Feature flag to test parallelizing the log association upload for v3 api"
+                            + " only. 0 meaning no parallel upload.")
+    private int mParallelLogUploadPool = 10;
+
+    @Option(
+            name = "log-association-with-work-unit",
+            description =
+                    "Feature flag to experiment reporting associated "
+                            + "logAssociation when the work unit is done.")
+    private boolean mUploadLogAssociationWithWorkUnit = true;
+
+    @Option(
+            name = "metric-filter-regex",
+            description =
+                    "Regular expression that will be used for filtering the metrics written"
+                            + " in to the test results file.")
+    private Set<String> mMetricFilterRegEx = new HashSet<>();
+
+    @Option(
+            name = "enable-filter-property",
+            description = "Feature flag to enable reading and using 'ignored' properties.")
+    private boolean mEnableFilterProperty = true;
+
+    @Option(
+            name = "use-batch-insert",
+            description = "Use BatchInsert api rather than http batch when uploading results")
+    private boolean mUseBatchInsert = false;
+
+    @Option(
+            name = "max-batch-size",
+            description = "Max number of test results sent in a single BatchInsert api call.")
+    private int mMaxBatchSize = 200;
+
+    // Default is 0, to let the server pick the best number.
+    @Option(
+            name = "insert-batch-size",
+            description =
+                    "How many results will be written to the database at once when using BatchInser"
+                            + " api")
+    private int mInsertBatchSize = 0;
+
+    @Option(
+            name = "enable-sparse-modules-batching",
+            description = "Enable uploading of sparse modules in batches, rather than individually")
+    private boolean mEnableModuleBatching = true;
+
+    @Option(
+            name = "enable-skip-method-reporting",
+            description = "Enable the reporting of methods that are skipped.")
+    private boolean mEnableSkipMethodReporting = true;
+
+    @Option(
+            name = "enable-skip-workunit-reporting",
+            description = "Enable the reporting of workunits that are skipped.")
+    private boolean mEnableSkipWorkUnitReporting = true;
+
+    private TestResult mCurrentTestResult;
+    private String mSummaryUrl;
+    private DebugInfo mFailureInfo; // Contains invocation failure message.
+    private SkipReason mInvocationSkipReason;
+
+    private boolean mDelegatedMode = false;
+
+    // Set to true if the result reporter created its own invocation
+    // and will be updating it.
+    // Set to false if invocation was created somewhere else and will not be updated.
+    private boolean mManagingInvocation;
+    private Invocation mInvocation;
+    private String mWorkUnitId;
+
+    // We keep work units in a stack, so that we can build them as a tree
+    // when modules and test runs start. When a module or a test run starts, we
+    // create a WorkUnit and push it on this stack. When test run or module ends
+    // we pop units off the stack.
+    // When uploading results and we want to associate result with the work unit,
+    // the correct one is obtained by calling mWorkUnits.peek.
+    private Deque<WorkUnit> mWorkUnits;
+
+    // List that stores cached work units. Cached work units are for tests where result is known
+    // ahead of time
+    // from a previous run. These work units are expected to be module level, and should not contain
+    // any child work units, artifacts or test results. Since no tests runs for these work units
+    // it is much more efficient to collect them and upload them all at once in a batch.
+    private List<WorkUnit> mCachedWorkUnits = new ArrayList<WorkUnit>();
+
+    private String mCurrentModule = null;
+    // All properties which should be reported to the work unit.
+    private List<Property> mModuleProperties = Collections.emptyList();
+    // Filtered module properties to use in the test identifier (module-abi & module-param)
+    private List<Property> mModuleParameters = Collections.emptyList();
+
+    // A map to keep track which test generated which log.
+    private Multimap<String, LogAssociation> mLogAssociations =
+            Multimaps.synchronizedMultimap(HashMultimap.create());
+
+    // Legacy test result it for interacting with v2 log upload api. We need this id
+    // to ensure compatibility with logs uploaded using the legacy v2 api.
+    private long mLegacyResultId;
+
+    // BuildInfo attributes are added to work unit properties so need to keep a reference to it.
+    private IBuildInfo mBuildInfo;
+
+    // Same for invocation context
+    private IInvocationContext mContext;
+    private IConfiguration mConfiguration;
+
+    // Need module context for atest instructions
+    private IInvocationContext mModuleContext;
+
+    private ITestStorageClient mClient;
+
+    private String mSpongeInvocationId;
+
+    private MetricFileUtil mMetricFileUtil = new MetricFileUtil();
+
+    private List<Thread> mUpdateActions = new ArrayList<>();
+
+    protected ITestStorageClient createTestStorageClient(IInvocationContext context)
+            throws GeneralSecurityException, IOException {
+        String buildEnvironment = context.getAttribute(BUILD_ENV_INVOCATION_CONTEXT_KEY);
+        if (buildEnvironment.isEmpty()) {
+            buildEnvironment = "prod";
+        }
+        String artifactLegacyMigration = context.getAttribute(ARTIFACT_UPLOAD_KEY);
+        return Client.create(
+                buildEnvironment,
+                !"false".equals(artifactLegacyMigration),
+                true,
+                mUseBatchInsert,
+                mMaxBatchSize,
+                mInsertBatchSize);
+    }
+
+    @Override
+    public void setLogSaver(ILogSaver logSaver) {
+
+        if (mEnableMetricFile) {
+            mMetricFileUtil.setLogSaver(logSaver);
+        }
+
+        if (logSaver instanceof AndroidBuildApiLogSaver) {
+            return;
+        }
+
+        CLog.w("Not using AndroidBuildApiLogSaver, log associations will be disabled.");
+        mDisableAssociations = true;
+    }
+
+    @Override
+    public void invocationStarted(IInvocationContext context) {
+        if (mDisable) {
+            return;
+        }
+        long invocationStart = System.currentTimeMillis();
+        try (CloseableTraceScope start = new CloseableTraceScope("ants:invocationStart")) {
+            mDelegatedMode =
+                    mConfiguration.getConfigurationObject(TradefedDelegator.DELEGATE_OBJECT)
+                            != null;
+            mContext = context;
+            mWorkUnits = new ArrayDeque<>();
+            String invocationId = context.getAttribute("invocation_id");
+            String workUnitId = context.getAttribute("work_unit_id");
+            String testResultId = context.getAttribute(TEST_RESULT_ID);
+            try {
+                mLegacyResultId = Long.parseLong(testResultId);
+            } catch (NumberFormatException e) {
+                CLog.w("Could not parse legacy test result id. Log associations will be disabled.");
+                mDisableAssociations = true;
+            }
+            if (!context.getBuildInfos().isEmpty()) {
+                mBuildInfo = context.getBuildInfos().get(0);
+            }
+            try {
+                if (!invocationId.isEmpty()) {
+                    // We received invocation and work unit from scheduler.
+                    mClient = createTestStorageClient(context);
+                    mInvocation = getInvocation(invocationId);
+                    WorkUnit workUnit = null;
+                    if (workUnitId.isEmpty()) {
+                        workUnit =
+                                newWorkUnit(
+                                        mInvocation.getInvocationId(), WorkUnitType.TF_INVOCATION);
+                        workUnit = mClient.createWorkUnit(workUnit);
+                        mWorkUnitId = workUnit.getId();
+                        CLog.d("Created WU %s", mWorkUnitId);
+                    } else {
+                        mWorkUnitId = workUnitId;
+                        workUnit = newWorkUnit(mInvocation.getInvocationId()).setId(workUnitId);
+                        if (mEnableSponge) {
+                            try {
+                                List<Property> properties =
+                                        mClient.getWorkUnit(workUnitId).getProperties();
+                                if (properties != null) {
+                                    for (Property p : properties) {
+                                        if (p.getName().equals(SPONGE_INVOCATION_ID_PROPERTY)) {
+                                            mSpongeInvocationId = p.getValue();
+                                            break;
+                                        }
+                                    }
+                                }
+                            } catch (IOException e) {
+                                CLog.d("Can't find WorkUnit: %s", workUnitId);
+                            }
+                        }
+                    }
+                    if (mEnableSponge && mSpongeInvocationId == null) {
+                        // TFC will set sponge id property when test is
+                        // scheduled by ATP.
+                        mSpongeInvocationId = SpongeUtils.createInvocationId();
+                        WorkUnit updated =
+                                ObjectUpdater.create(mClient)
+                                        .runUpdate(
+                                                mWorkUnitId,
+                                                new ObjectUpdater.WorkUnitUpdate() {
+                                                    @Override
+                                                    public WorkUnit doUpdate(WorkUnit current) {
+                                                        addWorkUnitProperty(
+                                                                current,
+                                                                newProperty(
+                                                                        SPONGE_INVOCATION_ID_PROPERTY,
+                                                                        mSpongeInvocationId));
+                                                        return current;
+                                                    }
+                                                });
+                    }
+                    if (mConfiguration.getCommandOptions().getShardCount() != null) {
+                        workUnit.setShardCount(mConfiguration.getCommandOptions().getShardCount());
+                        workUnit.setChildShardNumber(
+                                mConfiguration.getCommandOptions().getShardIndex());
+                    }
+                    mWorkUnits.push(workUnit);
+                } else if (invocationId.isEmpty() && workUnitId.isEmpty()) {
+                    // we did not receive invocation, so we need to create one.
+                    // check if we want to upload locally.
+                    if (!mCreateInvocation) {
+                        CLog.d(
+                                "No invocation_id and work_unit_id was provided, skipping"
+                                        + " reporting.");
+                        mDisable = true;
+                        return;
+                    }
+                    mClient = createTestStorageClient(context);
+                    mInvocation = newInvocation(context);
+                    mInvocation = mClient.createInvocation(mInvocation);
+                    WorkUnit workUnit =
+                            newWorkUnit(mInvocation.getInvocationId(), WorkUnitType.TF_INVOCATION);
+                    if (mEnableSponge) {
+                        mSpongeInvocationId = SpongeUtils.createInvocationId();
+                        addWorkUnitProperty(
+                                workUnit,
+                                newProperty(SPONGE_INVOCATION_ID_PROPERTY, mSpongeInvocationId));
+                    }
+                    mWorkUnits.push(mClient.createWorkUnit(workUnit));
+                    mManagingInvocation = true;
+                    invocationId = mInvocation.getInvocationId();
+                    mWorkUnitId = mWorkUnits.peek().getId();
+                    context.addInvocationAttribute("invocation_id", invocationId);
+                    context.addInvocationAttribute("work_unit_id", mWorkUnitId);
+                    CLog.i("Created invocation %s and WU %s", invocationId, mWorkUnitId);
+                } else {
+                    mDisable = true;
+                    throw new RuntimeException(
+                            "You must either pass both invocation id and work unit id, or pass"
+                                    + " none");
+                }
+            } catch (GeneralSecurityException | IOException e) {
+                mDisable = true;
+                if (mClient != null) {
+                    // Make sure we cancel the client, otherwise it will leak a thread since
+                    // invocationEnded will be skipped.
+                    mClient.finalizeTestResults();
+                }
+                throw new RuntimeException(e);
+            }
+            if (mInvocation != null) {
+                CLog.logAndDisplay(
+                        LogLevel.INFO,
+                        "Result link: %s",
+                        String.format(RESULT_LINK, mInvocation.getInvocationId()));
+                if (mEnableFilterProperty && mInvocation.getProperties() != null) {
+                    List<Property> ignoredProperty =
+                            mInvocation.getProperties().stream()
+                                    .filter(p -> p.getName().equals("ignored"))
+                                    .collect(Collectors.toList());
+                    if (!ignoredProperty.isEmpty()) {
+                        CLog.d("Read properties: %s", ignoredProperty);
+                        for (Property p : ignoredProperty) {
+                            if (Strings.isNullOrEmpty(p.getValue())) {
+                                continue;
+                            }
+                            mConfiguration
+                                    .getRetryDecision()
+                                    .addToSkipRetryList(p.getValue().trim());
+                        }
+                    }
+                }
+            }
+        } finally {
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricKey.ANTS_INVOCATION_START_TIME,
+                    System.currentTimeMillis() - invocationStart);
+        }
+    }
+
+    @Override
+    public TestSummary getSummary() {
+        if (mInvocation == null || mWorkUnitId == null) {
+            return null;
+        }
+        return new TestSummary(
+                String.format(
+                        "https://android-build.googleplex.com/"
+                                + "builds/tests/view?invocationId=%s&tab=artifacts&workunit_id=%s",
+                        mInvocation.getInvocationId(), mWorkUnitId));
+    }
+
+    private void setInvocationError(String message, String trace) {
+        // In general we can't expect TF to correctly set
+        // error message in the invocation and WorkUnit because we are
+        // not going to make it here in some crashes. If TF is started
+        // by an external service, then that service should set the error message.
+
+        // In cases where TF is run locally, we will set the error message
+        // on the 'best effort' basis.
+        mInvocation.setSchedulerState(SchedulerState.ERROR.toString());
+        mInvocation.setSummary(message);
+        mFailureInfo = new DebugInfo().setErrorMessage(message);
+        if (!trace.isEmpty()) {
+            mFailureInfo.setTrace(trace);
+        }
+    }
+
+    private static String getStackTrace(Throwable cause) {
+        StringWriter w = new StringWriter();
+        cause.printStackTrace(new PrintWriter(w));
+        return w.toString();
+    }
+
+    @Override
+    public void invocationSkipped(SkipReason reason) {
+        if (mDisable) {
+            return;
+        }
+        if (!mEnableSkipWorkUnitReporting) {
+            CLog.d("Not reporting %s. skip status reporting not enabled.", reason);
+            return;
+        }
+        CLog.d("Received #invocationSkipped: %s", reason);
+        mInvocation.setSchedulerState(SchedulerState.SKIPPED.toString());
+        mInvocationSkipReason = reason;
+    }
+
+    @Override
+    public void invocationFailed(Throwable cause) {
+        if (mDisable) {
+            return;
+        }
+        setInvocationError(cause.getMessage(), getStackTrace(cause));
+    }
+
+    @Override
+    public void invocationFailed(FailureDescription failure) {
+        if (mDisable) {
+            return;
+        }
+
+        String errorMessage = "";
+        String stackTrace = "";
+        if (failure.getCause() != null) {
+            errorMessage = failure.getCause().getMessage();
+            stackTrace = getStackTrace(failure.getCause());
+        }
+        if (Strings.isNullOrEmpty(errorMessage)) {
+            errorMessage = failure.getFormattedErrorMessage();
+        }
+        if (Strings.isNullOrEmpty(errorMessage)) {
+            // Default to a standard message if error really doesn't have a message
+            errorMessage = "invocation failure with no detailed message.";
+        }
+        setInvocationError(errorMessage, stackTrace);
+        if (mEnableErrorTypes) {
+            setErrorType(mFailureInfo, failure);
+            String errorDebug = "";
+            if (failure.getErrorIdentifier() != null) {
+                mFailureInfo.setErrorCode(failure.getErrorIdentifier().code());
+                errorDebug += String.format("code: %s", failure.getErrorIdentifier().code());
+                mFailureInfo.setErrorName(failure.getErrorIdentifier().name());
+                errorDebug += String.format(",name: %s", failure.getErrorIdentifier().name());
+            }
+            if (failure.getOrigin() != null) {
+                mFailureInfo.setErrorOrigin(failure.getOrigin());
+            }
+            CLog.d("invocationFailed with '%s' and '%s'", errorMessage, errorDebug);
+        }
+    }
+
+    @Override
+    public void invocationEnded(long elapsedTime) {
+        if (mDisable) {
+            return;
+        }
+        long invocationEnd = System.currentTimeMillis();
+        try (CloseableTraceScope end = new CloseableTraceScope("ants:invocationEnded")) {
+            if (mEnableSponge && mSpongeInvocationId != null) {
+                CLog.i(
+                        String.format(
+                                "Stored invocation results in sponge Url: %s",
+                                SpongeUtils.getInvocationUrl(mSpongeInvocationId)));
+            }
+            if (mEnableMetricFile) {
+                try {
+                    mMetricFileUtil.invocationEnded(mMetricFilterRegEx);
+                } catch (RuntimeException e) {
+                    // Avoid any impact from bug in MetricFileUtil
+                    CLog.e(e);
+                }
+            }
+
+            mClient.finalizeTestResults();
+            try (CloseableTraceScope update =
+                    new CloseableTraceScope(
+                            InvocationMetricKey.wait_for_results_update.toString())) {
+                for (Thread t : mUpdateActions) {
+                    if (t.isAlive()) {
+                        t.join(20 * 60000L); // Wait 20 minutes max for final result upload
+                    }
+                }
+            } catch (InterruptedException e) {
+                CLog.e(e);
+            }
+            try {
+                CLog.i("Uploading %d cached modules", mCachedWorkUnits.size());
+                mClient.createWorkUnits(mCachedWorkUnits);
+                uploadLogAssociations(new ArrayList<>(mLogAssociations.values()));
+                finalizeTfWorkUnit();
+                updateInvocation();
+                CLog.logAndDisplay(
+                        LogLevel.INFO,
+                        "Result link: %s",
+                        String.format(RESULT_LINK, mInvocation.getInvocationId()));
+                if (mManagingInvocation) {
+                    mInvocation = finalizeInvocation(mInvocation);
+                }
+            } catch (IOException e) {
+                throw new RuntimeException(e);
+            }
+            CLog.d("Done with AnTs ResultReporter");
+        } finally {
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricKey.ANTS_INVOCATION_END_TIME,
+                    System.currentTimeMillis() - invocationEnd);
+        }
+    }
+
+    @Override
+    public void testModuleStarted(IInvocationContext moduleContext) {
+        if (mDisable | mDelegatedMode) {
+            return;
+        }
+        long startModule = System.currentTimeMillis();
+        try (CloseableTraceScope ignored = new CloseableTraceScope("ants:testModuleStarted")) {
+            mModuleContext = moduleContext;
+            mCurrentModule = moduleContext.getConfigurationDescriptor().getModuleName();
+            mModuleProperties = getModuleProperties(moduleContext);
+            mModuleParameters = getModuleParameters(mModuleProperties);
+            long currentTimeStamp = currentTimestamp();
+            if (!Strings.isNullOrEmpty(moduleContext.getAttribute(ITestSuite.MODULE_START_TIME))) {
+                try {
+                    currentTimeStamp =
+                            Long.parseLong(
+                                    moduleContext.getAttribute(ITestSuite.MODULE_START_TIME));
+                } catch (NumberFormatException nfe) {
+                    CLog.e(nfe);
+                }
+            }
+
+            ModuleInfo moduleInfo = new ModuleInfo().setName(mCurrentModule);
+            if (!mModuleParameters.isEmpty()) {
+                moduleInfo.setModuleParameters(mModuleParameters);
+            }
+            WorkUnit workUnit =
+                    new WorkUnit()
+                            .setName(mCurrentModule)
+                            .setParentId(mWorkUnits.peek().getId())
+                            .setInvocationId(mInvocation.getInvocationId())
+                            .setTiming(new Timing().setCreationTimestamp(currentTimeStamp))
+                            .setType(WorkUnitType.TF_MODULE.name())
+                            .setState(SchedulerState.RUNNING.toString())
+                            .setModuleInfo(moduleInfo);
+            workUnit.setProperties(mModuleProperties);
+            AconfigFlags flagOverrides =
+                    addOrUpdateFlagOverrides(
+                            null,
+                            moduleContext.getAttribute(
+                                    ModuleDefinition
+                                            .MODULE_INVOCATION_ATTRIBUTE_FLAG_OVERRIDES_KEY));
+
+            workUnit.setAconfigFlagOverrides(flagOverrides);
+            if (mEnableModuleBatching
+                    && containsProperty(mModuleProperties, SPARSE_MODULE_PROPERTY, "true")) {
+                // batch sparsely reported modules together, upload at the end of the invocation.
+                mCachedWorkUnits.add(workUnit);
+                mWorkUnits.push(workUnit);
+                return;
+            }
+            try {
+                mWorkUnits.push(mClient.createWorkUnit(workUnit));
+            } catch (IOException e) {
+                CLog.w("%s\n", workUnit);
+                throw new RuntimeException(e);
+            }
+        } finally {
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricKey.ANTS_MODULE_START_TIME,
+                    System.currentTimeMillis() - startModule);
+        }
+    }
+
+    @Override
+    public void testModuleEnded() {
+        if (mDisable | mDelegatedMode) {
+            return;
+        }
+        long moduleEnd = System.currentTimeMillis();
+        try (CloseableTraceScope ignored = new CloseableTraceScope("ants:testModuleEnded")) {
+            List<Property> moduleCheckerProperties = getModuleCheckerProperties(mModuleContext);
+            long value = currentTimestamp();
+            if (!Strings.isNullOrEmpty(mModuleContext.getAttribute(ITestSuite.MODULE_END_TIME))) {
+                try {
+                    value = Long.parseLong(mModuleContext.getAttribute(ITestSuite.MODULE_END_TIME));
+                } catch (NumberFormatException nfe) {
+                    CLog.e(nfe);
+                }
+            }
+            SkipReason moduleSkip = null;
+            if (mModuleContext != null
+                    && !Strings.isNullOrEmpty(
+                            mModuleContext.getAttribute(ModuleDefinition.MODULE_SKIPPED))) {
+                moduleSkip =
+                        new SkipReason(
+                                mModuleContext.getAttribute(ModuleDefinition.MODULE_SKIPPED), "");
+                CLog.d("Received a module skipped: %s", moduleSkip);
+            }
+            final long currentTimeStamp = value;
+            mModuleContext = null;
+            mCurrentModule = null;
+            mModuleProperties = Collections.emptyList();
+            mModuleParameters = Collections.emptyList();
+            WorkUnit workUnit = mWorkUnits.peek();
+            if (!workUnit.getType().equals(WorkUnitType.TF_MODULE.name())) {
+                CLog.w("Unexpected work unit in testModuleEnded %s, expected TF_MODULE.", workUnit);
+                CLog.w("Skipping AnTS work unit update.");
+                return;
+            }
+            final WorkUnit update = mWorkUnits.pop();
+            if (mEnableModuleBatching
+                    && containsProperty(update.getProperties(), SPARSE_MODULE_PROPERTY, "true")) {
+                // batch sparsely reported modules together, upload at the end of the invocation.
+                updateModuleWorkUnit(update, currentTimeStamp, moduleCheckerProperties, moduleSkip);
+                return;
+            }
+            final SkipReason finalModuleSkip = moduleSkip;
+            Runnable updater =
+                    new Runnable() {
+
+                        @Override
+                        public void run() {
+                            String workUnitId = update.getId();
+                            try {
+                                ObjectUpdater.create(mClient)
+                                        .runUpdate(
+                                                workUnitId,
+                                                new ObjectUpdater.WorkUnitUpdate() {
+                                                    @Override
+                                                    public WorkUnit doUpdate(WorkUnit current) {
+                                                        return updateModuleWorkUnit(
+                                                                current,
+                                                                currentTimeStamp,
+                                                                moduleCheckerProperties,
+                                                                finalModuleSkip);
+                                                    }
+                                                });
+                            } catch (IOException e) {
+                                CLog.w("%s\n", update);
+                                throw new RuntimeException(e);
+                            }
+                            if (mUploadLogAssociationWithWorkUnit) {
+                                Collection<LogAssociation> logs =
+                                        mLogAssociations.removeAll(workUnitId);
+                                try {
+                                    uploadLogAssociations(new ArrayList<>(logs));
+                                } catch (IOException e) {
+                                    throw new RuntimeException(e);
+                                }
+                            }
+                        }
+                    };
+            if (mParallelOperations) {
+                // Run updater non-blocking
+                Thread updaterThread = new Thread(updater);
+                updaterThread.setName("ants-updater-thread");
+                updaterThread.setDaemon(false);
+                updaterThread.start();
+                mUpdateActions.add(updaterThread);
+                // Removing already done updates.
+                mUpdateActions.removeIf(t -> !t.isAlive());
+            } else {
+                // Run blocking
+                updater.run();
+            }
+        } finally {
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricKey.ANTS_MODULE_END_TIME,
+                    System.currentTimeMillis() - moduleEnd);
+        }
+    }
+
+    private WorkUnit updateModuleWorkUnit(
+            WorkUnit workUnit,
+            long currentTimeStamp,
+            List<Property> properties,
+            SkipReason reason) {
+        if (reason != null) {
+            workUnit.setSkippedReason(convertTfToAnTS(reason, SkipReasonType.REASON_UNSPECIFIED))
+                    .setState(SchedulerState.SKIPPED.toString());
+        } else {
+            workUnit.setState(SchedulerState.COMPLETED.toString());
+        }
+        workUnit.getTiming().setCompleteTimestamp(currentTimeStamp);
+        workUnit.setProperties(
+                new ListBuilder<>(workUnit.getProperties()).addAll(properties).build());
+        return workUnit;
+    }
+
+    @Override
+    public void testRunStarted(String runName, int testCount) {
+        if (mDisable | mDelegatedMode) {
+            return;
+        }
+        testRunStarted(runName, testCount, 0);
+    }
+
+    @Override
+    public void testRunStarted(String runName, int testCount, int attemptNumber) {
+        if (mDisable | mDelegatedMode) {
+            return;
+        }
+        testRunStarted(runName, testCount, attemptNumber, currentTimestamp());
+    }
+
+    @Override
+    public void testRunStarted(String runName, int testCount, int attemptNumber, long startTime) {
+        if (mDisable | mDelegatedMode) {
+            return;
+        }
+        long runStart = System.currentTimeMillis();
+        try {
+            if (mEnableMetricFile) {
+                mMetricFileUtil.testRunStarted(runName);
+            }
+
+            WorkUnit workUnit = new WorkUnit();
+            workUnit.setName(runName)
+                    .setInvocationId(mInvocation.getInvocationId())
+                    .setParentId(mWorkUnits.peek().getId())
+                    .setTiming(new Timing().setCreationTimestamp(startTime))
+                    // Keep the property & the child attempt number for backward compatibility
+                    .setProperties(
+                            Arrays.asList(
+                                    new Property()
+                                            .setName(ATTEMPT_PROPERTY)
+                                            .setValue(Integer.toString(attemptNumber))))
+                    .setChildAttemptNumber(attemptNumber)
+                    .setType(WorkUnitType.TF_TEST_RUN.name())
+                    .setState(SchedulerState.RUNNING.toString());
+            try {
+                mWorkUnits.push(mClient.createWorkUnit(workUnit));
+            } catch (IOException e) {
+                CLog.w("%s\n", workUnit);
+                throw new RuntimeException(e);
+            }
+        } finally {
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricKey.ANTS_RUN_START_TIME, System.currentTimeMillis() - runStart);
+        }
+    }
+
+    @Override
+    public void testRunFailed(String errorMessage) {
+        testRunFailed(FailureDescription.create(errorMessage));
+    }
+
+    @Override
+    public void testRunFailed(FailureDescription failure) {
+        if (mDisable | mDelegatedMode) {
+            return;
+        }
+        if (!mEnableErrorTypes) {
+            testRunFailed(failure.toString());
+            return;
+        }
+        WorkUnit workUnit = mWorkUnits.peek();
+        if (!workUnit.getType().equals(WorkUnitType.TF_TEST_RUN.name())) {
+            CLog.w("Unexpected work unit in testRunFailed %s, expected TF_TEST_RUN", workUnit);
+            CLog.w("Skipping AnTS update");
+            return;
+        }
+        DebugInfo debugInfo = new DebugInfo().setErrorMessage(failure.getFormattedErrorMessage());
+        setErrorType(debugInfo, failure);
+        if (failure.getErrorIdentifier() != null) {
+            debugInfo.setErrorCode(failure.getErrorIdentifier().code());
+            debugInfo.setErrorName(failure.getErrorIdentifier().name());
+        }
+        if (failure.getOrigin() != null) {
+            debugInfo.setErrorOrigin(failure.getOrigin());
+        }
+        workUnit.setDebugInfo(debugInfo).setState(SchedulerState.ERROR.toString());
+        CLog.i("Set work unit %s state to error due to test run failure", workUnit.getId());
+    }
+
+    @Override
+    public void testRunEnded(
+            long elapsedTimeMillis, HashMap<String, MetricMeasurement.Metric> runMetrics) {
+        if (mDisable | mDelegatedMode) {
+            return;
+        }
+        long runEnded = System.currentTimeMillis();
+        try {
+            if (mEnableSkipMethodReporting) {
+                try {
+                    reportSkippedMethod();
+                } catch (RuntimeException e) {
+                    CLog.e("error during skip reporting:");
+                    CLog.e(e);
+                }
+            }
+            if (mEnableMetricFile) {
+                mMetricFileUtil.testRunEnded(runMetrics);
+            }
+
+            WorkUnit workUnit = mWorkUnits.peek();
+            if (!workUnit.getType().equals(WorkUnitType.TF_TEST_RUN.name())) {
+                CLog.w("Unexpected work unit in testRunFailed %s, expected TF_TEST_RUN", workUnit);
+                CLog.w("Skipping AnTS update");
+                return;
+            }
+            final WorkUnit update = mWorkUnits.pop();
+            if (SchedulerState.RUNNING.toString().equals(update.getState())) {
+                update.setState(SchedulerState.COMPLETED.toString());
+            }
+
+            CLog.i(
+                    "TestRunEnded setting work unit %s state to %s",
+                    update.getId(), update.getState());
+            Runnable updater =
+                    new Runnable() {
+                        @Override
+                        public void run() {
+                            String workUnitId = update.getId();
+                            try {
+                                ObjectUpdater.create(mClient)
+                                        .runUpdate(
+                                                workUnitId,
+                                                new ObjectUpdater.WorkUnitUpdate() {
+                                                    @Override
+                                                    public WorkUnit doUpdate(WorkUnit current) {
+                                                        current.setState(update.getState());
+                                                        long startTime =
+                                                                current.getTiming()
+                                                                        .getCreationTimestamp();
+                                                        current.getTiming()
+                                                                .setCompleteTimestamp(
+                                                                        startTime
+                                                                                + elapsedTimeMillis);
+                                                        if (update.getDebugInfo() != null) {
+                                                            current.setDebugInfo(
+                                                                    update.getDebugInfo());
+                                                        }
+                                                        if (mEnableMetrics) {
+                                                            current.setMetrics(
+                                                                    MetricUtils.toMetrics(
+                                                                            runMetrics));
+                                                        }
+                                                        if (!runMetrics.isEmpty()) {
+                                                            ListBuilder<Property> propertyBuilder =
+                                                                    getRunMetrics(
+                                                                            current.getProperties(),
+                                                                            runMetrics);
+                                                            current.setProperties(
+                                                                    propertyBuilder.build());
+                                                        }
+                                                        return current;
+                                                    }
+                                                });
+                            } catch (IOException e) {
+                                CLog.w("%s\n", workUnit);
+                                throw new RuntimeException(e);
+                            }
+                            if (mUploadLogAssociationWithWorkUnit) {
+                                Collection<LogAssociation> logs =
+                                        mLogAssociations.removeAll(workUnitId);
+                                try {
+                                    uploadLogAssociations(new ArrayList<>(logs));
+                                } catch (IOException e) {
+                                    throw new RuntimeException(e);
+                                }
+                            }
+                        }
+                    };
+            if (mParallelOperations) {
+                // Run updater non-blocking
+                Thread updaterThread = new Thread(updater);
+                updaterThread.setName("ants-updater-thread");
+                updaterThread.setDaemon(false);
+                updaterThread.start();
+                mUpdateActions.add(updaterThread);
+                // Removing already done updates.
+                mUpdateActions.removeIf(t -> !t.isAlive());
+            } else {
+                // Run blocking
+                updater.run();
+            }
+        } finally {
+            InvocationMetricLogger.addInvocationMetrics(
+                    InvocationMetricKey.ANTS_RUN_END_TIME, System.currentTimeMillis() - runEnded);
+        }
+    }
+
+    private ListBuilder<Property> getRunMetrics(
+            List<Property> current, HashMap<String, MetricMeasurement.Metric> runMetrics) {
+        ListBuilder<Property> propertyBuilder = new ListBuilder<Property>(current);
+        for (String key : METRIC_STRING_TO_PROPERTIES) {
+            if (runMetrics.containsKey(key)) {
+                String value = runMetrics.get(key).getMeasurements().getSingleString();
+                propertyBuilder.add(newProperty(key, value));
+            }
+        }
+        for (String key : METRIC_INT_TO_PROPERTIES) {
+            if (runMetrics.containsKey(key)) {
+                long value = runMetrics.get(key).getMeasurements().getSingleInt();
+                propertyBuilder.add(newProperty(key, Long.toString(value)));
+            }
+        }
+        return propertyBuilder;
+    }
+
+    @Override
+    public void testStarted(TestDescription test) {
+        if (mDisable | mDelegatedMode) {
+            return;
+        }
+        testStarted(test, currentTimestamp());
+    }
+
+    @Override
+    public void testStarted(TestDescription test, long startTime) {
+        if (mDisable | mDelegatedMode) {
+            return;
+        }
+
+        WorkUnit peek = mWorkUnits.peek();
+        if (peek == null) {
+            CLog.e("testStarted(%s) didn't find a parent work unit.", test);
+            return;
+        }
+
+        mCurrentTestResult = new TestResult();
+        mCurrentTestResult
+                .setWorkUnitId(peek.getId())
+                // Set initial state to pass, because we only upload
+                // test results at the end and this way we don't need
+                // to check the test status in testEnded.
+                .setTestStatus(TestStatus.PASS.toString())
+                .setInvocationId(mInvocation.getInvocationId())
+                .setTiming(new Timing().setCreationTimestamp(startTime))
+                .setTestIdentifier(
+                        new TestIdentifier()
+                                .setModule(mCurrentModule)
+                                .setTestClass(test.getClassName())
+                                .setModuleParameters(mModuleParameters)
+                                .setMethod(test.getTestName()));
+    }
+
+    @Override
+    public void testFailed(TestDescription test, String trace) {
+        handleTestFailed(test, trace);
+
+        // Log stacktrace.
+        CLog.e(
+                "Received #testFailed(%s, %s) - should NEVER happen.\n%s",
+                test, trace, StreamUtil.getStackTrace(new Exception()));
+    }
+
+    private void handleTestFailed(TestDescription test, String trace) {
+        if (mDisable | mDelegatedMode) {
+            return;
+        }
+        if (mCurrentTestResult == null) {
+            CLog.e("Received #testFailed(%s) without a valid testStart before.", test);
+            return;
+        }
+        final DebugInfo debugInfo = new DebugInfo().setTrace(trace);
+        final String message = extractErrorMessage(trace);
+        if (message != null && !message.isEmpty()) {
+            debugInfo.setErrorMessage(message);
+        }
+        mCurrentTestResult.setTestStatus(TestStatus.FAIL.toString()).setDebugInfo(debugInfo);
+        String localInstructions = getLocalInstructions(test);
+        ListBuilder<Property> propertyBuilder =
+                new ListBuilder<>(mCurrentTestResult.getProperties());
+        if (!localInstructions.isEmpty()) {
+            propertyBuilder.add(newProperty(LOCAL_INSTRUCTION_PROPERTY, localInstructions));
+        }
+        mCurrentTestResult.setProperties(propertyBuilder.build());
+    }
+
+    @Override
+    public void testFailed(TestDescription test, FailureDescription failure) {
+        if (mDisable | mDelegatedMode) {
+            return;
+        }
+        if (!mEnableErrorTypes) {
+            CLog.d("Option \"enable-error-types\" is false, bypassing testStatus converting.");
+            handleTestFailed(test, failure.toString());
+            return;
+        }
+
+        handleTestFailed(test, failure.toString());
+
+        mCurrentTestResult.setTestStatus(
+                TestStatus.fromDescription(failure.getFailureStatus()).toString());
+        // Add additional error type from the FailureDescription
+        DebugInfo info = mCurrentTestResult.getDebugInfo();
+        setErrorType(info, failure);
+        mCurrentTestResult.setDebugInfo(info);
+    }
+
+    private String getLocalInstructions(TestDescription test) {
+        LocalInstructions instructions = new LocalInstructions(mContext, mModuleContext);
+        return instructions.forTest(test);
+    }
+
+    @Override
+    public void testAssumptionFailure(TestDescription test, String trace) {
+        if (mDisable | mDelegatedMode) {
+            return;
+        }
+        testAssumptionFailure(test, FailureDescription.create(trace));
+    }
+
+    @Override
+    public void testAssumptionFailure(TestDescription test, FailureDescription failure) {
+        if (mDisable | mDelegatedMode) {
+            return;
+        }
+        if (mCurrentTestResult == null) {
+            CLog.e("Received #testAssumptionFailure(%s) without a valid testStart before.", test);
+            return;
+        }
+        final DebugInfo debugInfo = new DebugInfo().setTrace(failure.getErrorMessage());
+        final String message = extractErrorMessage(failure.getErrorMessage());
+        if (message != null && !message.isEmpty()) {
+            debugInfo.setErrorMessage(message);
+        }
+        mCurrentTestResult
+                .setTestStatus(TestStatus.ASSUMPTION_FAILURE.toString())
+                .setDebugInfo(debugInfo);
+    }
+
+    @Override
+    public void testSkipped(TestDescription test, SkipReason reason) {
+        if (mDisable | mDelegatedMode) {
+            return;
+        }
+        if (mCurrentTestResult == null) {
+            CLog.e("Received #testIgnored(%s) without a valid testStart before.", test);
+            return;
+        }
+        mCurrentTestResult
+                .setTestStatus(TestStatus.TEST_SKIPPED.toString())
+                .setSkippedReason(convertTfToAnTS(reason, SkipReasonType.REASON_UNSPECIFIED));
+    }
+
+    @Override
+    public void testIgnored(TestDescription test) {
+        if (mDisable | mDelegatedMode) {
+            return;
+        }
+        if (mCurrentTestResult == null) {
+            CLog.e("Received #testIgnored(%s) without a valid testStart before.", test);
+            return;
+        }
+        mCurrentTestResult.setTestStatus(TestStatus.IGNORED.toString());
+    }
+
+    @Override
+    public void testEnded(
+            TestDescription test,
+            long endTime,
+            HashMap<String, MetricMeasurement.Metric> testMetrics) {
+        if (mDisable | mDelegatedMode) {
+            return;
+        }
+        if (mCurrentTestResult == null) {
+            CLog.e("Received #testEnded(%s) without a valid testStart before.", test);
+            return;
+        }
+
+        if (mEnableMetricFile) {
+            mMetricFileUtil.testEnded(test, testMetrics);
+        }
+
+        mCurrentTestResult.getTiming().setCompleteTimestamp(endTime);
+        if (mEnableMetrics) {
+            Metrics metrics = MetricUtils.toMetrics(testMetrics);
+            mCurrentTestResult.setMetrics(metrics);
+        }
+
+        if (testMetrics.get(TEST_MAPPING_PROPERTY) != null) {
+            // Get Test Mapping sources from string formatting with list such as "[path1, path2]".
+            // Note: Some test mapping sources may not be recorded. This is because a test module
+            // can be defined across multiple TEST_MAPPING files, and TF doesn't run it again if
+            // it's passed in the previous run.
+            String testMappingMeasurement =
+                    testMetrics
+                            .get(TEST_MAPPING_PROPERTY)
+                            .getMeasurements()
+                            .getSingleString()
+                            .replaceAll("^\\[| |\\]$", "");
+            List<String> testMappingSources = Arrays.asList(testMappingMeasurement.split(","));
+            ListBuilder<Property> propertyBuilder = new ListBuilder<>(Collections.emptyList());
+            for (String testMappingSource : testMappingSources) {
+                propertyBuilder.add(newProperty(TEST_MAPPING_PROPERTY, testMappingSource));
+            }
+            mCurrentTestResult.setProperties(propertyBuilder.build());
+        }
+        mClient.uploadResult(mCurrentTestResult);
+        mCurrentTestResult = null;
+    }
+
+    @Override
+    public void testEnded(TestDescription test, HashMap<String, MetricMeasurement.Metric> metrics) {
+        if (mDisable | mDelegatedMode) {
+            return;
+        }
+        testEnded(test, currentTimestamp(), metrics);
+    }
+
+    private void reportSkippedMethod() {
+        if (mDisable | mDelegatedMode) {
+            return;
+        }
+
+        WorkUnit peek = mWorkUnits.peek();
+        if (peek == null) {
+            CLog.e("Didn't find a parent work unit for skipped method.");
+            return;
+        }
+        String moduleAbi = null;
+        String moduleName = null;
+        if (mModuleContext != null) {
+            moduleAbi = mModuleContext.getAttribute(ModuleDefinition.MODULE_ABI);
+            moduleName = mModuleContext.getAttribute(ModuleDefinition.MODULE_NAME);
+        }
+        for (Entry<String, SkipReason> entry :
+                getConfiguration().getSkipManager().getDemotedTests().entrySet()) {
+            String key = entry.getKey();
+            SuiteTestFilter filter = SuiteTestFilter.createFrom(key);
+            // If module filter has an ABI, we expect the filter to match it to be applicable
+            // not having it is a bit ambiguous so we default to report for all abi similar
+            // to how filters are applied.
+            if (filter.getAbi() != null && !filter.getAbi().equals(moduleAbi)) {
+                continue;
+            }
+            if (!filter.getName().equals(moduleName)) {
+                continue;
+            }
+            if (filter.getTest() == null) {
+                continue;
+            }
+            TestDescription test = TestDescription.fromString(filter.getTest());
+            TestResult currentTest = new TestResult();
+            currentTest
+                    .setWorkUnitId(peek.getId())
+                    .setTestStatus(TestStatus.TEST_SKIPPED.toString())
+                    .setInvocationId(mInvocation.getInvocationId())
+                    .setTiming(new Timing().setCreationTimestamp(System.currentTimeMillis()))
+                    .setTestIdentifier(
+                            new TestIdentifier()
+                                    .setModule(mCurrentModule)
+                                    .setTestClass(test.getClassName())
+                                    .setModuleParameters(mModuleParameters)
+                                    .setMethod(test.getTestName()));
+            SkippedReason reason =
+                    convertTfToAnTS(entry.getValue(), SkipReasonType.REASON_DEMOTION);
+            currentTest.setSkippedReason(reason);
+            mClient.uploadResult(currentTest);
+            CLog.d("Backfilled %s SKIPPED", currentTest);
+        }
+    }
+
+    @Override
+    public void logAssociation(String dataName, LogFile log) {
+        if (mDisable) {
+            return;
+        }
+        if (mDisableAssociations) {
+            return;
+        }
+        if (mWorkUnits == null) {
+            CLog.d("Workunit isn't initialized yet.");
+            return;
+        }
+        CLog.v("Received association %s %s %s", dataName, log.getPath(), log.getUrl());
+        String workUnitId = mWorkUnits.peek().getId();
+        mLogAssociations.put(
+                workUnitId,
+                new LogAssociation(
+                        mInvocation, workUnitId, mCurrentTestResult, mLegacyResultId, log));
+    }
+
+    private WorkUnit newWorkUnit(String invocationId) {
+        return new WorkUnit()
+                .setName(TF_INVOCATION_LABEL)
+                .setType("")
+                .setTiming(new Timing().setCreationTimestamp(currentTimestamp()))
+                .setState(SchedulerState.RUNNING.toString())
+                .setInvocationId(invocationId);
+    }
+
+    private WorkUnit newWorkUnit(String invocationId, WorkUnitType type) {
+        return newWorkUnit(invocationId).setType(type.name());
+    }
+
+    private void updateInvocation() {
+        String localRunner = mContext.getAttribute(LOCAL_RUNNER);
+        List<Property> invocationProperties = InvocationProperties.parse(mContext);
+        ExtraBuildsBuilder extraBuildsBuilder = new ExtraBuildsBuilder(mContext);
+        List<String> tags = mConfiguration.getCommandOptions().reportingTags();
+        if (invocationProperties.isEmpty()
+                && localRunner.isEmpty()
+                && extraBuildsBuilder.isEmpty()
+                && tags.isEmpty()
+                && mBuildInfo == null) {
+            return;
+        }
+
+        CLog.d("Updating invocation. invoc properties=%s, tags=%s", invocationProperties, tags);
+        // When updating labels and properties, we will not append them if
+        // an identical label or property already exists.
+        try {
+            ObjectUpdater.create(mClient)
+                    .runUpdate(
+                            mInvocation.getInvocationId(),
+                            new ObjectUpdater.InvocationUpdate() {
+                                @Override
+                                public Invocation doUpdate(Invocation current) {
+                                    boolean updated = false;
+
+                                    ListBuilder<Property> propertyBuilder =
+                                            new ListBuilder<>(current.getProperties());
+                                    for (Property p : invocationProperties) {
+                                        if (!propertyBuilder.contains(p)) {
+                                            propertyBuilder.add(p);
+                                            updated = true;
+                                        }
+
+                                        // Set crystalball_has_data to yes if crystalball ingest
+                                        // property is set and metrics are available.
+                                        if (p.getName()
+                                                        .equalsIgnoreCase(
+                                                                CRYSTALBALL_INGEST_PROPERTY)
+                                                && p.getValue().equalsIgnoreCase("yes")
+                                                && mMetricFileUtil.isMetricAvailable()) {
+                                            Property metricAvailableProperty =
+                                                    newProperty(
+                                                            CRYSTALBALL_HAS_DATA_PROPERTY, "yes");
+                                            if (!propertyBuilder.contains(
+                                                    metricAvailableProperty)) {
+                                                propertyBuilder.add(metricAvailableProperty);
+                                                updated = true;
+                                            }
+                                        }
+                                    }
+                                    // Add flag overrides if they exist in build info.
+                                    if (mBuildInfo != null) {
+                                        String flagOverrides =
+                                                mBuildInfo
+                                                        .getBuildAttributes()
+                                                        .getOrDefault(
+                                                                ITestSuite
+                                                                        .BUILD_ATTRIBUTE_FLAG_OVERRIDES_KEY,
+                                                                "");
+                                        AconfigFlags currentFlags =
+                                                current.getAconfigFlagOverrides();
+                                        if (!flagOverrides.isEmpty()) {
+                                            AconfigFlags newFlags =
+                                                    addOrUpdateFlagOverrides(
+                                                            currentFlags, flagOverrides);
+                                            if (newFlags != null
+                                                    && !newFlags.equals(currentFlags)) {
+                                                current.setAconfigFlagOverrides(newFlags);
+                                                updated = true;
+                                            }
+                                        }
+                                    }
+
+                                    // If it's mainline invocation, update mainline module
+                                    // properties(i.e. module_installed) to
+                                    // prepend the version of the specific module to its build info.
+                                    // e.g., module installed:
+                                    // <version_module_1><module_1_build_info>
+                                    //       module installed:
+                                    // <version_module_2><module_2_build_info>
+                                    if (mContext.getBuildInfos().size() > 0) {
+                                        // Keep updated to true if already set
+                                        updated |= updateMainlineProperties(current);
+                                    }
+
+                                    if (!tags.isEmpty()) {
+                                        Set<String> currentTags = new HashSet<>();
+                                        if (current.getTags() != null) {
+                                            currentTags.addAll(current.getTags());
+                                        }
+                                        currentTags.addAll(tags);
+                                        current.setTags(new ArrayList<>(currentTags));
+                                        updated = true;
+                                    }
+
+                                    if (!localRunner.isEmpty()) {
+                                        Property localRunnerProp =
+                                                newProperty(LOCAL_RUNNER_PROPERTY, localRunner);
+                                        if (!propertyBuilder.contains(localRunnerProp)) {
+                                            propertyBuilder.add(localRunnerProp);
+                                            updated = true;
+                                        }
+                                    }
+                                    current.setProperties(propertyBuilder.build());
+
+                                    List<BuildDescriptor> extraBuilds =
+                                            new ArrayList<>(
+                                                    extraBuildsBuilder.build(
+                                                            current.getExtraBuilds()));
+                                    if (!extraBuilds.isEmpty()) {
+                                        updated = true;
+                                        current.setExtraBuilds(extraBuilds);
+                                    }
+                                    if (updated) {
+                                        return current;
+                                    }
+                                    return null;
+                                }
+                            });
+        } catch (IOException e) {
+            CLog.w("Failed to update invocation %s", mInvocation);
+            CLog.w(e);
+        }
+    }
+
+    private boolean updateMainlineProperties(Invocation current) {
+        boolean updated = false;
+        Map<String, String> attributes = mContext.getBuildInfos().get(0).getBuildAttributes();
+        for (String attributeName : attributes.keySet()) {
+            if (attributeName.contains(MAINLINE_VERSION_SUFFIX)) {
+                for (Property p : current.getProperties()) {
+                    // Update invocation properties to prepend version number, skip if
+                    // version already prepended
+                    if (isMainlineProperty(p)) {
+                        String modulePkgName =
+                                attributeName.substring(
+                                        0,
+                                        attributeName.length() - MAINLINE_VERSION_SUFFIX.length());
+                        if (p.getValue().contains(modulePkgName)
+                                && p.getValue().startsWith(MAINLINE_MODULE_PREFIX)) {
+                            String version =
+                                    mContext.getBuildInfos()
+                                            .get(0)
+                                            .getBuildAttributes()
+                                            .get(attributeName);
+                            p.setValue(String.format("[%s] %s", version, p.getValue()));
+                            if (!updated) {
+                                updated = true;
+                            }
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+        return updated;
+    }
+
+    private boolean isMainlineProperty(Property p) {
+        return p.getName().equals(MAINLINE_MODULE_PROPERTY);
+    }
+
+    private void finalizeTfWorkUnit() {
+        WorkUnit workUnit = mWorkUnits.pop();
+
+        MultiMap<String, String> configurationProperties = createConfigurationMap(mContext);
+
+        try {
+            ObjectUpdater.create(mClient)
+                    .runUpdate(
+                            workUnit.getId(),
+                            new ObjectUpdater.WorkUnitUpdate() {
+                                @Override
+                                public WorkUnit doUpdate(WorkUnit current) {
+
+                                    if (mManagingInvocation) {
+                                        current.getTiming()
+                                                .setCompleteTimestamp(currentTimestamp());
+                                        if (!mInvocation
+                                                        .getSchedulerState()
+                                                        .equals(SchedulerState.ERROR.toString())
+                                                && !mInvocation
+                                                        .getSchedulerState()
+                                                        .equals(
+                                                                SchedulerState.SKIPPED
+                                                                        .toString())) {
+                                            current.setState(SchedulerState.COMPLETED.toString());
+                                        }
+                                    }
+                                    if (mInvocationSkipReason != null) {
+                                        current.setSkippedReason(
+                                                convertTfToAnTS(
+                                                        mInvocationSkipReason,
+                                                        SkipReasonType.REASON_UNSPECIFIED));
+                                        current.setState(SchedulerState.SKIPPED.toString());
+                                        current.getTiming()
+                                                .setCompleteTimestamp(currentTimestamp());
+                                    }
+                                    // Avoid duplicate property reporting, report properties in the
+                                    // parent
+                                    if (System.getenv(
+                                                    DelegatedInvocationExecution.DELEGATED_MODE_VAR)
+                                            != null) {
+                                        CLog.d("Delegated mode. Skipping properties.");
+                                    } else {
+                                        addWorkUnitProperties(current, configurationProperties);
+                                    }
+                                    if (mFailureInfo != null) {
+                                        current.setDebugInfo(mFailureInfo);
+                                    }
+                                    return current;
+                                }
+                            });
+        } catch (IOException e) {
+            CLog.w("Failed to update work unit %s", workUnit);
+            CLog.w(e);
+        }
+
+        mWorkUnits.push(workUnit);
+    }
+
+    /**
+     * Returns a map with configuration settings which might be interesting to clients. For example
+     * device serial number, TF version, transponder link, jvm settings and so on.
+     */
+    private MultiMap<String, String> createConfigurationMap(IInvocationContext context) {
+        // Use UniqueMultiMap to dedup attributes values
+        UniqueMultiMap<String, String> result = new UniqueMultiMap<>();
+        // These excluded properties are already present as the work unit id and
+        // invocation id fields
+        Set<String> excluded_properties =
+                new HashSet<>(
+                        Arrays.asList("work_unit_id", "invocation_id", "invocation-property"));
+
+        String serial = null;
+        if (mBuildInfo != null) {
+            serial = mBuildInfo.getDeviceSerial();
+        }
+        if (serial != null) {
+            result.put("serial", serial);
+        }
+
+        String testTag = context.getTestTag();
+        if (testTag != null) {
+            result.put("test_tag", testTag);
+        }
+
+        // Add configuration attributes.
+        for (String attributeKey : context.getAttributes().keySet()) {
+            if (excluded_properties.contains(attributeKey)) {
+                continue;
+            }
+
+            List<String> values = context.getAttributes().get(attributeKey);
+            for (String value : values) {
+                result.put(attributeKey, value);
+            }
+        }
+
+        // Add build attributes
+        if (mBuildInfo != null) {
+            for (Map.Entry<String, String> buildAttribute :
+                    mBuildInfo.getBuildAttributes().entrySet()) {
+                result.put(buildAttribute.getKey(), buildAttribute.getValue());
+            }
+            final String buildFlavor = mBuildInfo.getBuildFlavor();
+            if (buildFlavor != null && !buildFlavor.isEmpty()) {
+                result.put(BUILD_FLAVOR_PROPERTY, buildFlavor);
+            }
+        }
+
+        final String tfVersion = getVersion();
+        if (!tfVersion.isEmpty()) {
+            result.put(TF_VERSION_PROPERTY, tfVersion);
+        }
+
+        final String user = getUser();
+        if (user != null && !user.isEmpty()) {
+            result.put(USER_PROPERTY, user);
+        }
+
+        final String hostname = getHostName();
+        if (hostname != null && !hostname.isEmpty()) {
+            result.put(HOSTNAME_PROPERTY, hostname);
+        }
+
+        // Carry tags to property for plx tracking
+        for (String tag : mConfiguration.getCommandOptions().reportingTags()) {
+            result.put(tag, "true");
+        }
+
+        // add cluster options to sponge configure values.
+        IClusterOptions clusterOptions =
+                (IClusterOptions)
+                        getGlobalConfig().getConfigurationObject(ClusterOptions.TYPE_NAME);
+        if (clusterOptions != null) {
+            // add host labels to sponge configure values.
+            for (String label : clusterOptions.getLabels()) {
+                if (label != null && !label.isEmpty()) {
+                    result.put(CLUSTER_OPTIONS_HOST_LABEL_PROPERTY, label);
+                }
+            }
+
+            final String labName = clusterOptions.getLabName();
+            if (labName != null && !labName.isEmpty()) {
+                result.put(CLUSTER_OPTIONS_LAB_NAME_PROPERTY, labName);
+            }
+
+            final String clusterId = clusterOptions.getClusterId();
+            if (clusterId != null && !clusterId.isEmpty()) {
+                result.put(CLUSTER_OPTIONS_CLUSTER_ID_PROPERTY, clusterId);
+            }
+        }
+
+        return result;
+    }
+
+    private Invocation newInvocation(IInvocationContext context, String invocationId) {
+        // To post results we need to keep track of invocation id, and build id and build target.
+        // Even if invocation was created by the scheduler we must still set build id and target
+        // here so we can post results to it.
+        Invocation invocation = new Invocation().setInvocationId(invocationId);
+        List<IBuildInfo> buildInfos;
+        if (context.getBuildInfo(AbLocalBuildProvider.LOCAL_BUILD) != null) {
+            buildInfos = Arrays.asList(context.getBuildInfo(AbLocalBuildProvider.LOCAL_BUILD));
+        } else {
+            buildInfos = context.getBuildInfos();
+        }
+        for (int i = 0; i < buildInfos.size(); i++) {
+            IBuildInfo buildInfo = buildInfos.get(i);
+            BuildDescriptor build = new BuildDescriptor().setBuildProvider(DEFAULT_BUILDPROVIDER);
+            if (buildInfo.getBuildBranch() != null) {
+                build.setBranch(buildInfo.getBuildBranch());
+            }
+            if (buildInfo.getBuildFlavor() != null) {
+                build.setBuildTarget(buildInfo.getBuildFlavor());
+            }
+            if (buildInfo.getBuildId() != null) {
+                build.setBuildId(buildInfo.getBuildId());
+            }
+            if (i == 0) {
+                invocation.setPrimaryBuild(build);
+            } else {
+                invocation.setExtraBuilds(
+                        new ListBuilder<>(invocation.getExtraBuilds()).add(build).build());
+            }
+        }
+        return invocation;
+    }
+
+    private Invocation newInvocation(IInvocationContext context) {
+        Invocation invocation =
+                newInvocation(context, null)
+                        .setSchedulerState(SchedulerState.RUNNING.toString())
+                        .setTest(new TestDefinition().setName(context.getTestTag()))
+                        .setTags(Arrays.asList(TF_INVOCATION_LABEL))
+                        .setTiming(new Timing().setCreationTimestamp(currentTimestamp()))
+                        .setRunner(TRADEFED);
+        return invocation;
+    }
+
+    private Invocation getInvocation(String invocationId) {
+        try {
+            return mClient.getInvocation(invocationId);
+        } catch (IOException e) {
+            mDisable = true;
+            throw new RuntimeException(e);
+        }
+    }
+
+    private Invocation finalizeInvocation(Invocation invocation) throws IOException {
+        return ObjectUpdater.create(mClient)
+                .runUpdate(
+                        invocation.getInvocationId(),
+                        new ObjectUpdater.InvocationUpdate() {
+                            @Override
+                            public Invocation doUpdate(Invocation current) {
+                                if (current.getSchedulerState()
+                                        .equals(SchedulerState.RUNNING.toString())) {
+                                    current.setSchedulerState(SchedulerState.COMPLETED.toString());
+                                    return current;
+                                }
+                                return null;
+                            }
+                        });
+    }
+
+    private Property newProperty(String key, String value) {
+        return new Property().setName(key).setValue(value);
+    }
+
+    private List<Property> toProperties(MultiMap<String, String> propertyMap) {
+        ArrayList<Property> properties = new ArrayList<>();
+        for (Map.Entry<String, String> entry : propertyMap.entries()) {
+            properties.add(newProperty(entry.getKey(), entry.getValue()));
+        }
+        return properties;
+    }
+
+    private boolean containsProperty(List<Property> properties, String name, String value) {
+        return properties.stream()
+                .anyMatch(p -> p.getName().equals(name) && p.getValue().equals(value));
+    }
+
+    private List<Property> getModuleProperties(IInvocationContext context) {
+        List<Property> result = new ArrayList<>();
+        for (Map.Entry<String, String> entry : context.getAttributes().entries()) {
+            if (ALLOWED_MODULE_PROPERTIES.contains(entry.getKey())) {
+                result.add(newProperty(entry.getKey(), entry.getValue()));
+            }
+        }
+        return result;
+    }
+
+    private List<Property> getModuleCheckerProperties(IInvocationContext context) {
+        List<Property> result = new ArrayList<>();
+        for (Map.Entry<String, String> entry : context.getAttributes().entries()) {
+            String key = entry.getKey();
+            if (key.startsWith(SYSTEM_CHECKER)) {
+                result.add(
+                        newProperty(key.substring(SYSTEM_CHECKER.length() + 1), entry.getValue()));
+            }
+        }
+        return result;
+    }
+
+    /*
+     * Only module-abi and module-param are used in the module identifier, so filter other
+     * values.
+     */
+    private List<Property> getModuleParameters(List<Property> properties) {
+        List<Property> result = new ArrayList<>();
+        for (Property property : properties) {
+            if (ALLOWED_MODULE_PARAMETERS.contains(property.getName())) {
+                result.add(property);
+            }
+        }
+        return result;
+    }
+
+    /*
+     * Add a property to WorkUnit.
+     */
+    private void addWorkUnitProperty(WorkUnit workUnit, Property property) {
+        workUnit.setProperties(new ListBuilder<>(workUnit.getProperties()).add(property).build());
+    }
+
+    /*
+     * Add a list of properties to WorkUnit.
+     */
+    private void addWorkUnitProperties(WorkUnit workUnit, MultiMap<String, String> properties) {
+        workUnit.setProperties(
+                uniqueProperties(new ListBuilder<>(workUnit.getProperties()), properties).build());
+    }
+
+    /*
+     * Some properties like 'tradefed_version' shouldn't be re-added
+     */
+    private ListBuilder<Property> uniqueProperties(
+            ListBuilder<Property> currentProperties, MultiMap<String, String> properties) {
+        for (Property prop : currentProperties.entries) {
+            if (UNIQUE_PROPERTIES.contains(prop.getName())) {
+                properties.remove(prop.getName());
+            }
+        }
+        return currentProperties.addAll(toProperties(properties));
+    }
+
+    private void setErrorType(DebugInfo info, FailureDescription failure) {
+        ErrorType errorType = ErrorType.create(failure.getFailureStatus());
+        if (errorType != ErrorType.ERROR_TYPE_UNSPECIFIED) {
+            info.setErrorType(errorType.toString());
+        }
+    }
+
+    @Override
+    public void putEarlySummary(List<TestSummary> summaries) {
+        for (TestSummary summary : summaries) {
+            if (TestSummary.Type.URI.equals(summary.getSummary().getType())) {
+                mSummaryUrl = summary.getSummary().getString();
+            }
+        }
+
+        if (mSummaryUrl == null || mSummaryUrl.isEmpty()) {
+            CLog.w("putSummary was called but summary was not provided");
+        }
+    }
+
+    private void uploadLogAssociations(List<LogAssociation> logAssociations) throws IOException {
+        if (logAssociations.isEmpty()) {
+            return;
+        }
+        try (CloseableTraceScope ignored = new CloseableTraceScope("uploadLogAssociations")) {
+            mClient.uploadAssociations(logAssociations, mParallelLogUploadPool);
+        }
+    }
+
+    @VisibleForTesting
+    long currentTimestamp() {
+        return System.currentTimeMillis();
+    }
+
+    @VisibleForTesting
+    String getSpongeV2InvocationId() {
+        return mSpongeInvocationId;
+    }
+
+    @VisibleForTesting
+    void setMetricFileUtil(MetricFileUtil fileUtil) {
+        mMetricFileUtil = fileUtil;
+    }
+
+    protected String getVersion() {
+        String version = VersionParser.fetchVersion();
+        if (version == null) {
+            return "";
+        }
+        return version;
+    }
+
+    private AconfigFlags addOrUpdateFlagOverrides(AconfigFlags currentFlags, String flagOverrides) {
+        if (flagOverrides == null || flagOverrides.isEmpty()) {
+            return currentFlags;
+        }
+
+        List<String> flagStrings =
+                Splitter.on(FLAG_SEPARATOR)
+                        .trimResults()
+                        .omitEmptyStrings()
+                        .splitToList(flagOverrides);
+        if (flagStrings.isEmpty()) {
+            return currentFlags;
+        }
+
+        Map<String, AconfigFlag> allFlags = new LinkedHashMap<>();
+        if (currentFlags == null) {
+            currentFlags = new AconfigFlags();
+        }
+        List<AconfigFlag> flagList = currentFlags.getAconfigFlags();
+        if (flagList == null) {
+            flagList = Collections.emptyList();
+        }
+        for (AconfigFlag f : flagList) {
+            allFlags.put(getFlagKey(f), f);
+        }
+
+        for (String flagString : flagStrings) {
+            Optional<AconfigFlag> override = parseFlag(flagString);
+            if (override.isEmpty()) {
+                continue;
+            }
+            if (!override.get().equals(allFlags.get(getFlagKey(override.get())))) {
+                allFlags.put(getFlagKey(override.get()), override.get());
+            }
+        }
+        if (allFlags.isEmpty()) {
+            return null;
+        }
+        AconfigFlags newFlags = new AconfigFlags();
+        newFlags.setAconfigFlags(new ArrayList<>(allFlags.values()));
+        return newFlags;
+    }
+
+    private static Optional<AconfigFlag> parseFlag(String flagOverride) {
+        Matcher m = ACONFIG_FLAG_PATTERN.matcher(flagOverride);
+        if (!m.find()) {
+            return Optional.empty();
+        }
+        String namespace = m.group(1);
+        String fullName = m.group(2);
+        String valueString = m.group(3);
+        Optional<String> parsedValue = parseFlagState(valueString);
+        if (parsedValue.isEmpty()) {
+            return Optional.empty();
+        }
+
+        List<String> parts = Splitter.on('.').splitToList(fullName);
+        if (parts.size() < 2) {
+            return Optional.empty();
+        }
+        String flagName = parts.get(parts.size() - 1);
+        String flagPackage = String.join(".", parts.subList(0, parts.size() - 1));
+        AconfigFlag flag =
+                new AconfigFlag()
+                        .setFlagNamespace(namespace)
+                        .setFlagPackage(flagPackage)
+                        .setFlagName(flagName)
+                        .setState(parsedValue.get());
+        return Optional.of(flag);
+    }
+
+    private static Optional<String> parseFlagState(String valueString) {
+        return Optional.ofNullable(
+                ImmutableMap.of("true", "enabled", "false", "disabled").get(valueString));
+    }
+
+    private static String getFlagKey(AconfigFlag flag) {
+        return String.format(
+                "namespace:%s package:%s name:%s",
+                flag.getFlagNamespace(), flag.getFlagPackage(), flag.getFlagName());
+    }
+
+    @VisibleForTesting
+    String getHostName() {
+        try {
+            return InetAddress.getLocalHost().getHostName();
+        } catch (UnknownHostException e) {
+            CLog.w("Unable to get hostname");
+        }
+        return null;
+    }
+
+    @VisibleForTesting
+    String getUser() {
+        return System.getProperty("user.name");
+    }
+
+    @VisibleForTesting
+    IGlobalConfiguration getGlobalConfig() {
+        return GlobalConfiguration.getInstance();
+    }
+
+    /**
+     * Extract the first line of the stack trace as the error message.
+     *
+     * <p>In most cases, this ends up being the exception + error message.
+     */
+    @VisibleForTesting
+    String extractErrorMessage(String trace) {
+        String firstLine = trace.split("[\\r\\n]+")[0];
+        if (!firstLine.trim().isEmpty()) {
+            return firstLine;
+        }
+        return null;
+    }
+
+    @Override
+    public boolean supportGranularResults() {
+        return mSupportGranularResults;
+    }
+
+    protected static class ListBuilder<T> {
+        private List<T> entries;
+
+        public ListBuilder(Collection<T> entries) {
+            this.entries = new ArrayList<>();
+            if (entries != null) {
+                this.entries.addAll(entries);
+            }
+        }
+
+        public ListBuilder<T> add(T p) {
+            this.entries.add(p);
+            return this;
+        }
+
+        public ListBuilder<T> addAll(Collection<? extends T> collection) {
+            this.entries.addAll(collection);
+            return this;
+        }
+
+        public List<T> build() {
+            return this.entries;
+        }
+
+        public boolean contains(T e) {
+            return entries.contains(e);
+        }
+    }
+
+    @Override
+    public void setConfiguration(IConfiguration configuration) {
+        mConfiguration = configuration;
+        mMetricFileUtil.setConfiguration(configuration);
+    }
+
+    public IConfiguration getConfiguration() {
+        return mConfiguration;
+    }
+
+    public void enableFilterProperty(boolean enableFilterProperty) {
+        mEnableFilterProperty = enableFilterProperty;
+    }
+
+    private SkippedReason convertTfToAnTS(SkipReason reason, SkipReasonType type) {
+        SkippedReason antsReason =
+                new SkippedReason()
+                        .setReasonMessage(reason.getReason())
+                        .setBugId(reason.getBugId())
+                        .setTrigger(reason.getTrigger())
+                        .setReasonType(type.toString());
+        return antsReason;
+    }
+}
diff --git a/src/com/google/android/tradefed/result/teststorage/SchedulerState.java b/src/com/google/android/tradefed/result/teststorage/SchedulerState.java
new file mode 100644
index 000000000..d3316260b
--- /dev/null
+++ b/src/com/google/android/tradefed/result/teststorage/SchedulerState.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.tradefed.result.teststorage;
+
+/** Enum representing a list of states Invocations and WorkUnits can be in. */
+public enum SchedulerState {
+    QUEUED("queued"),
+    RUNNING("running"),
+    ERROR("error"),
+    COMPLETED("completed"),
+    CANCELLED("cancelled"),
+    PENDING("pending"),
+    SKIPPED("skipped");
+
+    private final String value;
+
+    private SchedulerState(String value) {
+        this.value = value;
+    }
+
+    @Override
+    public String toString() {
+        return this.value;
+    }
+}
diff --git a/src/com/google/android/tradefed/result/teststorage/SkipReasonType.java b/src/com/google/android/tradefed/result/teststorage/SkipReasonType.java
new file mode 100644
index 000000000..9f645b8f1
--- /dev/null
+++ b/src/com/google/android/tradefed/result/teststorage/SkipReasonType.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2023 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.tradefed.result.teststorage;
+
+// This should be kept in sync with AnTS api (wireless.android.busytown.proto.SkippedReasonType).
+enum SkipReasonType {
+    REASON_UNSPECIFIED("reasonUnspecified"),
+    REASON_DEMOTION("reasonDemotion");
+
+    private final String value;
+
+    private SkipReasonType(String value) {
+        this.value = value;
+    }
+
+    @Override
+    public String toString() {
+        return this.value;
+    }
+}
diff --git a/src/com/google/android/tradefed/result/teststorage/SpongeUtils.java b/src/com/google/android/tradefed/result/teststorage/SpongeUtils.java
new file mode 100644
index 000000000..8c38afd95
--- /dev/null
+++ b/src/com/google/android/tradefed/result/teststorage/SpongeUtils.java
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.tradefed.result.teststorage;
+
+import com.android.tradefed.util.MultiMap;
+import com.android.tradefed.util.net.HttpHelper;
+
+import java.util.UUID;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/** Class to hold helper methods for dealing with Sponge. */
+public final class SpongeUtils {
+
+    private static final Pattern SPONGE_V1_URL_PATTERN =
+            Pattern.compile(
+                    "(http[s]?:\\/\\/sponge(-qa)?.corp.google.com)\\/([^\\?\\s]+)\\?"
+                            + "([^\\s]*&)?id=([^&\\s]*)(&[^\\s]*)?");
+
+    private static final String BASE_SPONGE_URL = "https://sponge2.corp.google.com";
+
+    /**
+     * Creates a Sponge V1 URL for a test run. It adds target=runName URL parameter to the base
+     * Sponge URL.
+     *
+     * @param url - base Sponge URL.
+     * @param runName name of a test run
+     * @return A sponge URL with additional target parameter set to runName.
+     */
+    public static String createSpongeV1Url(String url, String runName) {
+        if (url == null || url.isEmpty()) {
+            return "";
+        }
+        Matcher m = SPONGE_V1_URL_PATTERN.matcher(url);
+        if (!m.matches()) {
+            return url;
+        }
+
+        String baseSpongeUrl = m.group(1);
+        String invocationId = m.group(5);
+
+        if (baseSpongeUrl == null || invocationId == null || runName == null) {
+            return url;
+        }
+
+        MultiMap<String, String> paramMap = new MultiMap<>();
+        paramMap.put("show", "FAILED");
+        paramMap.put("sortBy", "STATUS");
+        paramMap.put("id", invocationId);
+        paramMap.put("target", runName);
+        return new HttpHelper().buildUrl(String.format("%s/target", baseSpongeUrl), paramMap);
+    }
+
+    /**
+     * Creates a Sponge V2 URL for a test run. It sets target to runName.
+     *
+     * @param invocationId - Sponge invocation id.
+     * @param runName name of a test run
+     * @return A sponge URL with additional target set to runName.
+     */
+    public static String createSpongeV2Url(String invocationId, String runName) {
+        if (invocationId == null || invocationId.isEmpty()) {
+            return "";
+        }
+
+        if (runName == null) {
+            return String.format("%s/%s", BASE_SPONGE_URL, invocationId);
+        }
+
+        return String.format("%s/%s/targets/%s/tests", BASE_SPONGE_URL, invocationId, runName);
+    }
+
+    /**
+     * Create a Sponge invocation id.
+     *
+     * @return A random Sponge invocation id.
+     */
+    public static String createInvocationId() {
+        return UUID.randomUUID().toString();
+    }
+
+    /**
+     * Gets the https url to the invocation displayed on sponge v2 UI.
+     *
+     * @return the https url or {@code null} if not available
+     */
+    public static String getInvocationUrl(String invocationId) {
+        if (invocationId == null) {
+            return null;
+        }
+        return String.format("%s/%s", BASE_SPONGE_URL, invocationId);
+    }
+}
diff --git a/src/com/google/android/tradefed/result/teststorage/StubClient.java b/src/com/google/android/tradefed/result/teststorage/StubClient.java
new file mode 100644
index 000000000..d25d566a1
--- /dev/null
+++ b/src/com/google/android/tradefed/result/teststorage/StubClient.java
@@ -0,0 +1,202 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.tradefed.result.teststorage;
+
+import com.google.api.client.http.AbstractInputStreamContent;
+import com.google.api.services.androidbuildinternal.v3.model.Build;
+import com.google.api.services.androidbuildinternal.v3.model.BuildArtifactMetadata;
+import com.google.api.services.androidbuildinternal.v3.model.Invocation;
+import com.google.api.services.androidbuildinternal.v3.model.TestArtifactListResponse;
+import com.google.api.services.androidbuildinternal.v3.model.TestResult;
+import com.google.api.services.androidbuildinternal.v3.model.WorkUnit;
+import com.google.common.collect.ImmutableList;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/** Test storage client that does not upload results. Useful for testing and debugging. */
+class StubClient implements ITestStorageClient {
+
+    private List<TestResult> mTestResults = new ArrayList<>();
+    private Map<String, WorkUnit> mWorkUnits = new HashMap<>();
+    private List<LogAssociation> mAssociations = new ArrayList<>();
+    private Invocation mInvocation;
+    private Map<String, BuildArtifactMetadata> mArtifacts = new HashMap<>();
+
+    public static StubClient create() {
+        return new StubClient();
+    }
+
+    StubClient() {
+        // ignore
+    }
+
+    @Override
+    public void uploadResult(TestResult result) {
+        String id = String.format("test-result-%03d", mTestResults.size());
+        if (result.getTestIdentifier().getModuleParameters().isEmpty()) {
+            result.getTestIdentifier().setModuleParameters(new ArrayList<>());
+        }
+        mTestResults.add(result.clone());
+        result.setTestResultId(id);
+    }
+
+    @Override
+    public void uploadAssociations(List<LogAssociation> associations, int poolSize) {
+        for (LogAssociation association : associations) {
+            mAssociations.add(association);
+        }
+    }
+
+    @Override
+    public WorkUnit createWorkUnit(WorkUnit workUnit) throws IOException {
+        String id = String.format("work-unit-%03d", mWorkUnits.size());
+        WorkUnit result = workUnit.clone();
+        result.setId(id);
+        mWorkUnits.put(id, result);
+        return result.clone();
+    }
+
+    @Override
+    public WorkUnit updateWorkUnit(WorkUnit workUnit) throws IOException {
+        WorkUnit result = workUnit.clone();
+        if (!mWorkUnits.containsKey(workUnit.getId())) {
+            throw new IOException("Can only update created work unit");
+        }
+        mWorkUnits.put(workUnit.getId(), result);
+        return result.clone();
+    }
+
+    @Override
+    public WorkUnit getWorkUnit(String workUnitId) throws IOException {
+        WorkUnit out = mWorkUnits.get(workUnitId);
+        if (out == null) {
+            throw new IOException(String.format("Could not find work unit %s", workUnitId));
+        }
+        return out.clone();
+    }
+
+    @Override
+    public ImmutableList<WorkUnit> createWorkUnits(List<WorkUnit> workUnits) throws IOException {
+        ImmutableList.Builder<WorkUnit> result = ImmutableList.builder();
+        for (WorkUnit workUnit : workUnits) {
+            result.add(createWorkUnit(workUnit));
+        }
+        return result.build();
+    }
+
+    @Override
+    public Invocation createInvocation(Invocation invocation) throws IOException {
+        Invocation result = invocation.clone();
+        result.setInvocationId("stub-invocation-id");
+        mInvocation = result.clone();
+        return result.clone();
+    }
+
+    @Override
+    public Invocation updateInvocation(Invocation invocation) throws IOException {
+        mInvocation = invocation.clone();
+        return invocation.clone();
+    }
+
+    @Override
+    public Invocation getInvocation(String invocationId) {
+        Invocation result = getInvocation();
+        if (result == null) {
+            return new Invocation().setInvocationId(invocationId);
+        }
+        return result;
+    }
+
+    @Override
+    public Build createLocalBuild(Build localBuild) throws IOException {
+        return localBuild.clone();
+    }
+
+    /** Returns last created or updated invocation. */
+    public Invocation getInvocation() {
+        if (mInvocation == null) {
+            return null;
+        }
+        return mInvocation.clone();
+    }
+
+    public List<TestResult> getTestResults() {
+        return mTestResults;
+    }
+
+    public Map<String, WorkUnit> getWorkUnits() {
+        return mWorkUnits;
+    }
+
+    public List<LogAssociation> getAssociations() {
+        return mAssociations;
+    }
+
+    @Override
+    public void finalizeTestResults() {
+        // ignore
+    }
+
+    @Override
+    public TestArtifactListResponse listTestArtifact(String invocationId, String artifactType)
+            throws IOException {
+        return null;
+    }
+
+    @Override
+    public BuildArtifactMetadata getTestArtifact(String invocationId, String resourceId)
+            throws IOException {
+        String key = String.format("%s-%s", invocationId, resourceId);
+        if (!mArtifacts.containsKey(key)) {
+            throw new IOException(String.format("Artifact %s not found", key));
+        }
+        return mArtifacts.get(key).clone();
+    }
+
+    @Override
+    public BuildArtifactMetadata updateTestArtifact(
+            String invocationId,
+            String workUnitId,
+            String testResultId,
+            BuildArtifactMetadata artifact,
+            long legacyId) {
+        String key = String.format("%s-%s", artifact.getInvocationId(), artifact.getName());
+        mArtifacts.put(key, artifact.clone());
+        return artifact.clone();
+    }
+
+    @Override
+    public File fetchTestArtifact(String invocationId, String resourceId) throws IOException {
+        return null;
+    }
+
+    @Override
+    public BuildArtifactMetadata updateTestArtifact(
+            BuildArtifactMetadata artifact, long legacyId, AbstractInputStreamContent content) {
+        return updateTestArtifact(
+                artifact.getInvocationId(),
+                artifact.getWorkUnitId(),
+                artifact.getTestResultId(),
+                artifact,
+                legacyId);
+    }
+}
diff --git a/src/com/google/android/tradefed/result/teststorage/TestStatus.java b/src/com/google/android/tradefed/result/teststorage/TestStatus.java
new file mode 100644
index 000000000..e64ba18b8
--- /dev/null
+++ b/src/com/google/android/tradefed/result/teststorage/TestStatus.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.tradefed.result.teststorage;
+
+import com.android.tradefed.result.proto.TestRecordProto;
+
+/** Enum representing possible outcomes of a test. */
+public enum TestStatus {
+    PASS("pass"),
+    FAIL("fail"),
+    IGNORED("ignored"),
+    ASSUMPTION_FAILURE("assumptionFailure"),
+    TEST_ERROR("testError"),
+    TEST_SKIPPED("testSkipped");
+
+    private final String value;
+
+    private TestStatus(String value) {
+        this.value = value;
+    }
+
+    @Override
+    public String toString() {
+        return value;
+    }
+
+    public static TestStatus fromDescription(TestRecordProto.FailureStatus status) {
+        if (status == null) {
+            return FAIL;
+        }
+        switch (status) {
+            case TEST_FAILURE:
+                return FAIL;
+            case TIMED_OUT:
+                return TEST_ERROR;
+            case CANCELLED:
+                return TEST_ERROR;
+            case INFRA_FAILURE:
+                return TEST_ERROR;
+            case SYSTEM_UNDER_TEST_CRASHED:
+                return TEST_ERROR;
+            case NOT_EXECUTED:
+                return FAIL;
+            default:
+                return FAIL;
+        }
+    }
+}
diff --git a/src/com/google/android/tradefed/result/teststorage/WorkUnitType.java b/src/com/google/android/tradefed/result/teststorage/WorkUnitType.java
new file mode 100644
index 000000000..c13c1853f
--- /dev/null
+++ b/src/com/google/android/tradefed/result/teststorage/WorkUnitType.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.tradefed.result.teststorage;
+
+/** Enum representing possible work unit types. */
+public enum WorkUnitType {
+    ATP_INVOCATION,
+    TF_INVOCATION,
+    TFC_COMMAND,
+    TFC_COMMAND_TASK,
+    TF_MODULE,
+    TF_TEST_RUN;
+}
diff --git a/src/com/google/android/tradefed/util/androidbuildapi/AndroidBuildAPIException.java b/src/com/google/android/tradefed/util/androidbuildapi/AndroidBuildAPIException.java
new file mode 100644
index 000000000..75a273bfc
--- /dev/null
+++ b/src/com/google/android/tradefed/util/androidbuildapi/AndroidBuildAPIException.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.tradefed.util.androidbuildapi;
+
+/** An exception class for Android Build API related error. */
+public class AndroidBuildAPIException extends Exception {
+
+    private static final long serialVersionUID = 1L;
+
+    public AndroidBuildAPIException(String msg) {
+        super(msg);
+    }
+
+    public AndroidBuildAPIException(String msg, Throwable cause) {
+        super(msg, cause);
+    }
+}
diff --git a/src/com/google/android/tradefed/util/androidbuildapi/AndroidBuildAPIHelper.java b/src/com/google/android/tradefed/util/androidbuildapi/AndroidBuildAPIHelper.java
new file mode 100644
index 000000000..0f32f5ff1
--- /dev/null
+++ b/src/com/google/android/tradefed/util/androidbuildapi/AndroidBuildAPIHelper.java
@@ -0,0 +1,208 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.tradefed.util.androidbuildapi;
+
+import com.android.tradefed.config.GlobalConfiguration;
+import com.android.tradefed.host.HostOptions;
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.util.FileUtil;
+import com.android.tradefed.util.GoogleApiClientUtil;
+
+import com.google.api.client.googleapis.javanet.GoogleNetHttpTransport;
+import com.google.api.client.http.HttpRequestInitializer;
+import com.google.api.client.json.gson.GsonFactory;
+import com.google.api.services.androidbuildinternal.v3.Androidbuildinternal;
+import com.google.auth.Credentials;
+import com.google.auth.http.HttpCredentialsAdapter;
+import com.google.auth.oauth2.AccessToken;
+import com.google.auth.oauth2.GoogleCredentials;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.security.GeneralSecurityException;
+import java.util.Collection;
+import java.util.Collections;
+
+/** Helper method used to create an Android Build client. */
+public class AndroidBuildAPIHelper {
+    private static final Collection<String> ACCESS_SCOPE =
+            Collections.singleton("https://www.googleapis.com/auth/androidbuild.internal");
+
+    public static final String BUILD_ENV_INVOCATION_CONTEXT_KEY = "android-build-environment";
+
+    /** This is the key for {@link HostOptions}'s service-account-json-key-file option. */
+    private static final String HOST_OPTION_KEY_NAME = "android-build-api-json-key";
+
+    // Time out for android build client v3.
+    private static final int CLIENT_V3_TIMEOUT = 3 * 60000; // 3 minutes
+
+    private static String getEnvServicePath(String environment) {
+        if (environment.equals("treehugger")) {
+            return "android/internal/build/v2beta1_qa_treehugger";
+        } else if (environment.equals("atp")) {
+            return "android/internal/build/v2beta1_qa_atp";
+        } else {
+            return "android/internal/build/v2beta1";
+        }
+    }
+
+    private static String getEnvServicePathV3(String environment) {
+        if (environment.equals("treehugger")) {
+            return "android/internal/build/v3_qa_treehugger";
+        } else if (environment.equals("atp")) {
+            return "android/internal/build/v3_qa_atp";
+        } else {
+            return "android/internal/build/v3";
+        }
+    }
+
+    private static String getEnvRootUrl(String environment) {
+        if (environment.equals("build")) {
+            return "https://www-googleapis-staging.sandbox.google.com/";
+        } else {
+            return "https://www.googleapis.com/";
+        }
+    }
+
+    /** Create V2 version of client */
+    public static com.google.api.services.androidbuildinternal.Androidbuildinternal getLegacyClient(
+            String environment) throws GeneralSecurityException, IOException {
+        // Avoid querying the build API options several times
+        AndroidBuildAPIOptions abOptions = getAndroidBuildAPIOptions();
+        com.google.api.services.androidbuildinternal.Androidbuildinternal client = null;
+        if (environment == null) {
+            environment = abOptions.getEnvironment();
+            CLog.w(
+                    "No environment was specified. Defaulting to '%s' environment configuration.",
+                    environment);
+        }
+        String rootUrl = getEnvRootUrl(environment);
+        String servicePath = getEnvServicePath(environment);
+        CLog.i("Creating client with base URL: %s%s", rootUrl, servicePath);
+        Credentials credential = createCredential();
+        HttpRequestInitializer requestInitializer = new HttpCredentialsAdapter(credential);
+        client =
+                new com.google.api.services.androidbuildinternal.Androidbuildinternal.Builder(
+                                GoogleNetHttpTransport.newTrustedTransport(),
+                                GsonFactory.getDefaultInstance(),
+                                GoogleApiClientUtil.configureRetryStrategyAndTimeout(
+                                        requestInitializer,
+                                        abOptions.getConnectTimeout(),
+                                        abOptions.getReadTimeout()))
+                        .setApplicationName(GoogleApiClientUtil.APP_NAME)
+                        .setRootUrl(rootUrl)
+                        .setServicePath(servicePath)
+                        .build();
+        return client;
+    }
+
+    // FIXME: Pass the invocation context instead of the environment string, so that logic for
+    // parsing the environment is not spread in multiple classes.
+    public static Androidbuildinternal getClient(String environment)
+            throws GeneralSecurityException, IOException {
+        return getClient(environment, createCredential());
+    }
+
+    private static Androidbuildinternal getClient(String environment, Credentials credential)
+            throws GeneralSecurityException, IOException {
+        // Avoid querying the build API options several times
+        AndroidBuildAPIOptions abOptions = getAndroidBuildAPIOptions();
+        Androidbuildinternal client = null;
+        if (environment == null) {
+            environment = abOptions.getEnvironment();
+            CLog.w(
+                    "No environment was specified. Defaulting to '%s' environment configuration.",
+                    environment);
+        }
+        String rootUrl = getEnvRootUrl(environment);
+        String servicePath = getEnvServicePathV3(environment);
+        CLog.i("Creating client with base URL: %s%s", rootUrl, servicePath);
+        HttpRequestInitializer requestInitializer = new HttpCredentialsAdapter(credential);
+        client =
+                new Androidbuildinternal.Builder(
+                                GoogleNetHttpTransport.newTrustedTransport(),
+                                GsonFactory.getDefaultInstance(),
+                                GoogleApiClientUtil.configureRetryStrategyAndTimeout(
+                                        requestInitializer,
+                                        abOptions.getConnectTimeout(),
+                                        abOptions.getReadTimeout()))
+                        .setApplicationName(GoogleApiClientUtil.APP_NAME)
+                        .setRootUrl(rootUrl)
+                        .setServicePath(servicePath)
+                        .build();
+        return client;
+    }
+
+    private static Credentials createCredential()
+            throws FileNotFoundException, IOException, GeneralSecurityException {
+
+        AndroidBuildAPIOptions abOptions = getAndroidBuildAPIOptions();
+        if (abOptions != null
+                && abOptions.getAuthTokenFile() != null
+                && abOptions.getAuthTokenFile().exists()) {
+            String accessToken = FileUtil.readStringFromFile(abOptions.getAuthTokenFile());
+            return GoogleCredentials.create(new AccessToken(accessToken, null));
+        }
+
+        File abOptionJsonKey = null;
+        if (abOptions != null) {
+            abOptionJsonKey = abOptions.getJsonKeyFile();
+        }
+        return GoogleApiClientUtil.createCredential(
+                ACCESS_SCOPE, true, abOptionJsonKey, HOST_OPTION_KEY_NAME);
+    }
+
+    public static com.google.api.services.androidbuildinternal.v3.Androidbuildinternal
+            getTestStorageClient(String rootUrl, String servicePath)
+                    throws FileNotFoundException, IOException, GeneralSecurityException {
+        Credentials credential = createCredential();
+        HttpRequestInitializer requestInitializer = new HttpCredentialsAdapter(credential);
+        com.google.api.services.androidbuildinternal.v3.Androidbuildinternal client =
+                new com.google.api.services.androidbuildinternal.v3.Androidbuildinternal.Builder(
+                                GoogleNetHttpTransport.newTrustedTransport(),
+                                GsonFactory.getDefaultInstance(),
+                                GoogleApiClientUtil.configureRetryStrategy(
+                                        GoogleApiClientUtil.setHttpTimeout(
+                                                requestInitializer,
+                                                CLIENT_V3_TIMEOUT,
+                                                CLIENT_V3_TIMEOUT)))
+                        .setApplicationName(GoogleApiClientUtil.APP_NAME)
+                        .setRootUrl(rootUrl)
+                        .setServicePath(servicePath)
+                        .build();
+        return client;
+    }
+
+    public static com.google.api.services.androidbuildinternal.v3.Androidbuildinternal
+            getTestStorageClient(String environment)
+                    throws FileNotFoundException, IOException, GeneralSecurityException {
+        return getTestStorageClient(getEnvRootUrl(environment), getEnvServicePathV3(environment));
+    }
+
+    public static AndroidBuildAPIOptions getAndroidBuildAPIOptions() {
+        AndroidBuildAPIOptions options =
+                (AndroidBuildAPIOptions)
+                        GlobalConfiguration.getInstance()
+                                .getConfigurationObject(AndroidBuildAPIOptions.TYPE_NAME);
+        if (options == null) {
+            CLog.w("No 'android-build' global object was configured. Using default one.");
+            // Return default values if object is not configured
+            options = new AndroidBuildAPIOptions();
+        }
+        return options;
+    }
+}
diff --git a/src/com/google/android/tradefed/util/androidbuildapi/AndroidBuildAPIOptions.java b/src/com/google/android/tradefed/util/androidbuildapi/AndroidBuildAPIOptions.java
new file mode 100644
index 000000000..9f548964a
--- /dev/null
+++ b/src/com/google/android/tradefed/util/androidbuildapi/AndroidBuildAPIOptions.java
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.tradefed.util.androidbuildapi;
+
+import com.android.tradefed.config.Option;
+import com.android.tradefed.config.OptionClass;
+
+import java.io.File;
+import java.util.LinkedHashSet;
+import java.util.Set;
+
+/** Hostwide configuration options for the Android Build API client. */
+@OptionClass(alias = "android-build", global_namespace = false)
+public class AndroidBuildAPIOptions {
+    public static final String TYPE_NAME = "android-build";
+
+    @Deprecated
+    @Option(
+            name = "service-account",
+            description =
+                    "The service account to authenticate as."
+                            + "Deprecated. Use json-key-file instead.")
+    private String mServiceAccount;
+
+    @Deprecated
+    @Option(
+            name = "key-file",
+            description =
+                    "The key file to authenticate with. Deprecated. Use json-key-file instead.")
+    private File mKeyFile;
+
+    @Option(
+            name = "json-key-file",
+            description =
+                    "The json key file to authenticate with."
+                            + "The json key file already has the service account.")
+    private File mJsonKeyFile;
+
+    @Option(
+            name = "auth-token-file",
+            description = "The file contains the token to authenticate with.")
+    private File mAuthTokenFile;
+
+    // FIXME(b/71646294): Consolidate build environment default values into a single location, and
+    // pass build environment as an android-build option instead of a invocation context option.
+    @Option(name = "environment", description = "The build environment to communicate with")
+    private String mEnvironment = "prod";
+
+    @Option(name = "connect-timeout", description = "HTTP connect timeout in ms.")
+    private int mConnectTimeout = 60000;
+
+    @Option(name = "read-timeout", description = "HTTP read timeout in ms.")
+    private int mReadTimeout = 60000;
+
+    @Option(name = "ab-direct-download", description = "Enable direct download for AB downloads")
+    private boolean mDirectDownload = false;
+
+    private static final int MB = 0x100000;
+
+    @Option(
+            name = "ab-chunk-size",
+            description =
+                    "Chunk size to use when downloading through AB, inop when direct download is"
+                            + " set.")
+    private int mChunkSize = 32 * MB;
+
+    @Option(
+            name = "download-exclusion-patterns",
+            description =
+                    "List of file patterns that will be excluded from candidate download list")
+    private Set<String> mDownloadExclusionPatterns =
+            new LinkedHashSet<>(
+                    Set.of(
+                            "^attempts/",
+                            "^licensetexts/",
+                            "^shareprojects/",
+                            "^apilint/",
+                            "^soong_ui/",
+                            ".*-symbols(-mapping)?-.*\\.(zip|textproto)$"));
+
+    @Deprecated
+    public String getServiceAccount() {
+        return mServiceAccount;
+    }
+
+    @Deprecated
+    public File getKeyFile() {
+        return mKeyFile;
+    }
+
+    public String getEnvironment() {
+        return mEnvironment;
+    }
+
+    public File getJsonKeyFile() {
+        return mJsonKeyFile;
+    }
+
+    public int getConnectTimeout() {
+        return mConnectTimeout;
+    }
+
+    public int getReadTimeout() {
+        return mReadTimeout;
+    }
+
+    public File getAuthTokenFile() {
+        return mAuthTokenFile;
+    }
+
+    public boolean isDirectDownload() {
+        return mDirectDownload;
+    }
+
+    public int getChunkSize() {
+        return mChunkSize;
+    }
+
+    public Set<String> getDownloadExclusionPatterns() {
+        return mDownloadExclusionPatterns;
+    }
+}
diff --git a/src/com/google/android/tradefed/util/androidbuildapi/AndroidBuildTestResult.java b/src/com/google/android/tradefed/util/androidbuildapi/AndroidBuildTestResult.java
new file mode 100644
index 000000000..226303024
--- /dev/null
+++ b/src/com/google/android/tradefed/util/androidbuildapi/AndroidBuildTestResult.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.tradefed.util.androidbuildapi;
+
+import com.android.tradefed.build.IBuildInfo;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
+/** Container object to store the test result to post to the Android Build API. */
+public class AndroidBuildTestResult {
+    public static final String STATUS_IN_PROGRESS = "inProgress";
+    public static final String STATUS_PASS = "completePass";
+    public static final String STATUS_FAIL = "completeFail";
+    public static final String STATUS_ERROR = "error";
+
+    private Long mId = null;
+    private String mTestTag;
+    private String mStatus;
+    private String mSummary;
+    private String mBuildType;
+    private String mBuildId;
+    private String mTarget;
+    private String mAttemptId;
+
+    public AndroidBuildTestResult() {}
+
+    public AndroidBuildTestResult(
+            String testTag, String buildType, String buildId, String target, String attemptId) {
+        mTestTag = testTag;
+        mBuildType = buildType;
+        mAttemptId = attemptId;
+        mBuildId = buildId;
+        mTarget = target;
+    }
+
+    public AndroidBuildTestResult(IBuildInfo build) {
+        this(
+                build.getTestTag(),
+                build.getBuildAttributes().get("build_type"),
+                build.getBuildId(),
+                build.getBuildFlavor(),
+                build.getBuildAttributes().get("build_attempt_id"));
+    }
+
+    public JSONObject toJson() throws JSONException {
+        JSONObject data = new JSONObject();
+        data.putOpt("id", mId);
+        data.putOpt("testTag", mTestTag);
+        data.putOpt("status", mStatus);
+        data.putOpt("summary", mSummary);
+        return data;
+    }
+
+    public Long id() {
+        return mId;
+    }
+
+    public void setId(Long id) {
+        mId = id;
+    }
+
+    public String status() {
+        return mStatus;
+    }
+
+    public void setStatus(String status) {
+        mStatus = status;
+    }
+
+    public String summary() {
+        return mSummary;
+    }
+
+    public void setSummary(String summary) {
+        mSummary = summary;
+    }
+
+    public String testTag() {
+        return mTestTag;
+    }
+
+    public void setTestTag(String testTag) {
+        this.mTestTag = testTag;
+    }
+
+    public String buildType() {
+        return mBuildType;
+    }
+
+    public void setBuildType(String buildType) {
+        this.mBuildType = buildType;
+    }
+
+    public String buildId() {
+        return mBuildId;
+    }
+
+    public void setBuildId(String buildId) {
+        this.mBuildId = buildId;
+    }
+
+    public String target() {
+        return mTarget;
+    }
+
+    public void setTarget(String target) {
+        this.mTarget = target;
+    }
+
+    public String attemptId() {
+        return mAttemptId;
+    }
+
+    public void setAttemptId(String attemptId) {
+        this.mAttemptId = attemptId;
+    }
+}
diff --git a/test_framework/com/android/tradefed/device/metric/PerfettoFilePullerCollector.java b/test_framework/com/android/tradefed/device/metric/PerfettoFilePullerCollector.java
new file mode 100644
index 000000000..e10544203
--- /dev/null
+++ b/test_framework/com/android/tradefed/device/metric/PerfettoFilePullerCollector.java
@@ -0,0 +1,156 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.device.metric;
+
+import com.android.tradefed.config.Option;
+import com.android.tradefed.config.OptionClass;
+import com.android.tradefed.device.DeviceNotAvailableException;
+import com.android.tradefed.device.ITestDevice;
+import com.android.tradefed.device.LargeOutputReceiver;
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.result.FileInputStreamSource;
+import com.android.tradefed.result.InputStreamSource;
+import com.android.tradefed.result.LogDataType;
+import com.android.tradefed.util.FileUtil;
+import com.android.tradefed.util.StreamUtil;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * A collector which pulls perfetto trace files from the device, optionally compresses them, and
+ * adds them to the test logs.
+ */
+@OptionClass(alias = "perfetto-file-puller-collector")
+public class PerfettoFilePullerCollector extends FilePullerDeviceMetricCollector {
+
+    @Option(
+            name = "compress-perfetto",
+            description =
+                    "If enabled retrieves the perfetto compressed content,"
+                            + "decompress for processing and upload the compressed file. If"
+                            + "this flag is not enabled uncompressed version of perfetto file is"
+                            + "pulled, processed and uploaded.")
+    private boolean mCompressPerfetto = false;
+
+    @Option(
+            name = "max-compressed-file-size",
+            description =
+                    "Max size of the compressed"
+                            + " perfetto file. If the compressed file size exceeds the max then"
+                            + " post processing and uploading the compressed file will not happen.")
+    private long mMaxCompressedFileSize = 10000L * 1024 * 1024;
+
+    @Option(
+            name = "compressed-trace-shell-timeout",
+            description = "Timeout for retrieving compressed trace content through shell",
+            isTimeVal = true)
+    private long mCompressedTimeoutMs = TimeUnit.MINUTES.toMillis(20);
+
+    @Option(
+            name = "compress-response-timeout",
+            description = "Timeout to receive the shell response when running the gzip command.",
+            isTimeVal = true)
+    private long mCompressResponseTimeoutMs = TimeUnit.SECONDS.toMillis(30);
+
+    /**
+     * Pull the file from the specified path in the device. Pull the compressed content of the
+     * perfetto file if the compress perfetto option is enabled.
+     *
+     * @param device which has the file.
+     * @param remoteFilePath location in the device.
+     * @return compressed or decompressed version of perfetto file based on mCompressPerfetto option
+     *     is set or not.
+     * @throws DeviceNotAvailableException
+     */
+    @Override
+    protected File retrieveFile(ITestDevice device, String remoteFilePath, int userId)
+            throws DeviceNotAvailableException {
+        if (!mCompressPerfetto) {
+            return super.retrieveFile(device, remoteFilePath, userId);
+        }
+        File perfettoCompressedFile = null;
+        String filePathInDevice = remoteFilePath;
+        CLog.i("Retrieving the compressed perfetto trace content from device.");
+        LargeOutputReceiver compressedOutputReceiver =
+                new LargeOutputReceiver(
+                        "perfetto_compressed_temp",
+                        device.getSerialNumber(),
+                        mMaxCompressedFileSize);
+        device.executeShellCommand(
+                String.format("gzip -c %s", filePathInDevice),
+                compressedOutputReceiver,
+                mCompressedTimeoutMs,
+                mCompressResponseTimeoutMs,
+                TimeUnit.MILLISECONDS,
+                1);
+        compressedOutputReceiver.flush();
+        compressedOutputReceiver.cancel();
+
+        // Copy to temp file which will be used for decompression, perfetto
+        // metrics extraction and uploading the file later.
+        try (InputStreamSource largeStreamSrc = compressedOutputReceiver.getData();
+                InputStream inputStream = largeStreamSrc.createInputStream()) {
+            // Preserve the original file name including the .perfetto-trace extension, so that
+            // PerfettoTracePostProcessor can identify it as a trace file for processing.
+            // This also has the advantage of preserving the test name in the file name.
+            String perfettoFileName = new File(filePathInDevice).getName();
+            perfettoCompressedFile = FileUtil.createTempFile(perfettoFileName, ".gz");
+
+            FileOutputStream outStream = new FileOutputStream(perfettoCompressedFile);
+            byte[] buffer = new byte[4096];
+            int bytesRead = -1;
+            while ((bytesRead = inputStream.read(buffer)) > -1) {
+                outStream.write(buffer, 0, bytesRead);
+            }
+            StreamUtil.close(outStream);
+            CLog.i("Successfully copied the compressed content from device to" + " host.");
+        } catch (IOException e) {
+            if (perfettoCompressedFile != null) {
+                perfettoCompressedFile.delete();
+            }
+            CLog.e("Failed to copy compressed perfetto to temporary file.");
+            CLog.e(e);
+        } finally {
+            compressedOutputReceiver.delete();
+        }
+        return perfettoCompressedFile;
+    }
+
+    /**
+     * Take the perfetto trace file pulled from the device, which can be either raw or compressed,
+     * and add it to the test logs.
+     *
+     * @param key the option key associated to the file that was pulled.
+     * @param metricFile the {@link File} pulled from the device matching the option key.
+     * @param data the {@link DeviceMetricData} where metrics can be stored.
+     */
+    @Override
+    public void processMetricFile(String key, File metricFile, DeviceMetricData data) {
+        try (InputStreamSource source = new FileInputStreamSource(metricFile, true)) {
+            LogDataType type = mCompressPerfetto ? LogDataType.GZIP : LogDataType.PERFETTO;
+            testLog(metricFile.getName(), type, source);
+        }
+    }
+
+    @Override
+    public void processMetricDirectory(String key, File metricDirectory, DeviceMetricData runData) {
+        // Implement if all the files under specific directory have to be post processed.
+    }
+}
diff --git a/test_framework/com/android/tradefed/device/metric/PerfettoPullerMetricCollector.java b/test_framework/com/android/tradefed/device/metric/PerfettoPullerMetricCollector.java
index f12910d49..7aa969887 100644
--- a/test_framework/com/android/tradefed/device/metric/PerfettoPullerMetricCollector.java
+++ b/test_framework/com/android/tradefed/device/metric/PerfettoPullerMetricCollector.java
@@ -50,10 +50,14 @@ import java.util.List;
 import java.util.concurrent.TimeUnit;
 
 /**
- * Base implementation of {@link FilePullerDeviceMetricCollector} that allows
- * pulling the perfetto files from the device and collect the metrics from it.
- * Also used for converting the raw trace file into perfetto metric file.
+ * Base implementation of {@link FilePullerDeviceMetricCollector} that allows pulling the perfetto
+ * files from the device and collect the metrics from it. Also used for converting the raw trace
+ * file into perfetto metric file.
+ *
+ * @deprecated Use {@link PerfettoFilePullerCollector} and {@link PerfettoTracePostProcessor}
+ *     instead.
  */
+@Deprecated
 @OptionClass(alias = "perfetto-metric-collector")
 public class PerfettoPullerMetricCollector extends FilePullerDeviceMetricCollector {
 
diff --git a/test_framework/com/android/tradefed/postprocessor/PerfettoGenericPostProcessor.java b/test_framework/com/android/tradefed/postprocessor/PerfettoGenericPostProcessor.java
index 0ef0ec633..59ff8b11f 100644
--- a/test_framework/com/android/tradefed/postprocessor/PerfettoGenericPostProcessor.java
+++ b/test_framework/com/android/tradefed/postprocessor/PerfettoGenericPostProcessor.java
@@ -684,26 +684,48 @@ public class PerfettoGenericPostProcessor extends BasePostProcessor {
      */
     private Map<String, Metric.Builder> convertPerfettoProtoMessageV2(TraceSummary reportMessage) {
         CLog.d("convertPerfettoProtoMessageV2 reportMessage : " + reportMessage);
-        Map<String, Metric.Builder> convertedMetrics = new HashMap<String, Metric.Builder>();
+        Map<String, Metric.Builder> convertedMetrics = new HashMap<>();
+        Map<String, ArrayList<Double>> collectedValuesForKey = new HashMap<>();
+
         for (TraceMetricV2 metric : reportMessage.getMetricList()) {
+            String baseKey = metric.getSpec().getId();
             for (MetricRow row : metric.getRowList()) {
-                String rowKey = metric.getSpec().getId();
-                double rowValue = row.getValue();
+                StringBuilder currentKeyBuilder = new StringBuilder(baseKey);
                 for (Dimension dimension : row.getDimensionList()) {
                     Map<FieldDescriptor, Object> fields = dimension.getAllFields();
-                    for (Entry<FieldDescriptor, Object> entry : fields.entrySet()) {
-                        if (!(entry.getValue() instanceof Message)) {
-                            rowKey = rowKey.concat("-").concat(entry.getValue().toString());
+                    for (Entry<FieldDescriptor, Object> fieldEntry : fields.entrySet()) {
+                        if (!(fieldEntry.getValue() instanceof Message)) {
+                            currentKeyBuilder.append("-").append(fieldEntry.getValue().toString());
                         }
                     }
                 }
+                String finalRowKey = currentKeyBuilder.toString();
+                double rowValue = row.getValue();
+
+                // Store the value in a list associated with its fully constructed key.
+                collectedValuesForKey
+                        .computeIfAbsent(finalRowKey, k -> new ArrayList<>())
+                        .add(rowValue);
+            }
+        }
+
+        for (Entry<String, ArrayList<Double>> entry : collectedValuesForKey.entrySet()) {
+            String key = entry.getKey();
+            ArrayList<Double> values = entry.getValue();
+
+            if (values.size() == 1) {
+                double singleValue = values.get(0);
+                convertedMetrics.put(
+                        key, TfMetricProtoUtil.doubleToMetric(singleValue).toBuilder());
+                CLog.d(
+                        "Perfetto trace v2 metric (single): key: %s, value: %s",
+                        key, Double.toString(singleValue));
+            } else {
                 convertedMetrics.put(
-                        rowKey,
-                        TfMetricProtoUtil.stringToMetric(String.format("%f", rowValue))
-                                .toBuilder());
+                        key, TfMetricProtoUtil.doubleArrayToMetric(values).toBuilder());
                 CLog.d(
-                        "Perfetto trace v2 metric: key: %s value: %s",
-                        rowKey, Double.toString(rowValue));
+                        "Perfetto trace v2 metric (array): key: %s, values: %s",
+                        key, values.toString());
             }
         }
         return convertedMetrics;
diff --git a/test_framework/com/android/tradefed/postprocessor/PerfettoTracePostProcessor.java b/test_framework/com/android/tradefed/postprocessor/PerfettoTracePostProcessor.java
new file mode 100644
index 000000000..fa565bb51
--- /dev/null
+++ b/test_framework/com/android/tradefed/postprocessor/PerfettoTracePostProcessor.java
@@ -0,0 +1,649 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.postprocessor;
+
+import com.android.annotations.Nullable;
+import com.android.annotations.VisibleForTesting;
+import com.android.tradefed.config.Option;
+import com.android.tradefed.config.OptionClass;
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.metrics.proto.MetricMeasurement.DataType;
+import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
+import com.android.tradefed.result.FileInputStreamSource;
+import com.android.tradefed.result.InputStreamSource;
+import com.android.tradefed.result.LogDataType;
+import com.android.tradefed.result.LogFile;
+import com.android.tradefed.result.TestDescription;
+import com.android.tradefed.util.CommandResult;
+import com.android.tradefed.util.CommandStatus;
+import com.android.tradefed.util.FileUtil;
+import com.android.tradefed.util.RunUtil;
+import com.android.tradefed.util.SearchArtifactUtil;
+import com.android.tradefed.util.ZipUtil;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.TimeUnit;
+import java.util.regex.Pattern;
+
+/**
+ * A post processor which retrieves perfetto trace files from the test logs and runs the trace
+ * processor on them to produce a perfetto metric proto.
+ */
+@OptionClass(alias = "perfetto-trace-processor")
+public class PerfettoTracePostProcessor extends BasePostProcessor {
+
+    private static final String PROCESSOR_STATUS_V1 = "trace_processor_status";
+    private static final String PROCESSOR_STATUS_V2 = "trace_processor_status_v2";
+    private static final String STATUS_SUCCESS = "1";
+    private static final String STATUS_FAILURE = "0";
+    private static final String PROCESSOR_RUNTIME_V1 = "trace_processor_runtime";
+    private static final String PROCESSOR_RUNTIME_V2 = "trace_processor_runtime_v2";
+    private static final String RAW_TRACE_FILE_SIZE = "perfetto_trace_file_size_bytes";
+    private static final String METRIC_VERSION_V1 = "v1";
+    private static final String METRIC_VERSION_V2 = "v2";
+
+    public enum METRIC_FILE_FORMAT {
+        text,
+        binary,
+        json,
+    }
+
+    @Option(
+            name = "decompress-perfetto-timeout",
+            description = "Timeout to decompress perfetto compressed file.",
+            isTimeVal = true)
+    private long mDecompressTimeoutMs = TimeUnit.MINUTES.toMillis(20);
+
+    @Option(
+            name = "perfetto-metric-prefix",
+            description = "Prefix to be used with the metrics collected from perfetto.")
+    @Deprecated
+    private String mMetricPrefix = "perfetto";
+
+    @Option(
+            name = "convert-metric-file",
+            description = "Convert the raw trace file to perfetto metric file.")
+    private boolean mConvertToMetricFile = true;
+
+    @Option(
+            name = "collect-perfetto-file-size",
+            description =
+                    "Set it to true to collect the perfetto file size as part" + " of the metrics.")
+    private boolean mCollectPerfettoFileSize = false;
+
+    @Option(
+            name = "trace-processor-binary",
+            description =
+                    "Path to the trace processor shell. This will"
+                            + " override the trace-processor-name which is used to "
+                            + " lookup in build artifacts. Used for converting the raw"
+                            + " trace into perfetto metric file.")
+    private File mTraceProcessorBinary = null;
+
+    @Option(
+            name = "trace-processor-name",
+            description =
+                    "Trace processor name to look up from the test artifacts"
+                            + " or module artifacts.")
+    private String mTraceProcessorName = "trace_processor_shell";
+
+    @Option(
+            name = "perfetto-v1-metrics",
+            description = "This flag is to control the metric v1 computation.")
+    private boolean mMetricV1 = true;
+
+    @Option(
+            name = "perfetto-v2-metrics",
+            description = "This flag is to control the metric v2 computation.")
+    private boolean mMetricV2 = false;
+
+    @Option(
+            name = "trace-processor-run-metrics",
+            description =
+                    "Comma separated list of metrics to extract from raw trace file."
+                            + " For example android_mem.")
+    private String mTraceProcessorMetrics = "android_mem";
+
+    @Option(
+            name = "trace-processor-output-format",
+            description = "Trace processor output format. [binary|text|json]")
+    private METRIC_FILE_FORMAT mTraceProcessorOutputFormat = METRIC_FILE_FORMAT.text;
+
+    @Option(
+            name = "trace-processor-timeout",
+            description = "Timeout to convert the raw trace file to metric proto file.",
+            isTimeVal = true)
+    private long mTraceConversionTimeout = TimeUnit.MINUTES.toMillis(20);
+
+    @Option(
+            name = "perfetto-v2-metrics-ids",
+            description =
+                    "Specifies that the given v2 metrics (as defined by a comma separated set of"
+                        + " ids) should be computed and returned as part of the trace summary. The"
+                        + " spec for every metric must exist in one of the files passed to"
+                        + " --summary-spec.")
+    private String mComputeMetricsV2Ids = "memory_per_process-avg_rss_and_swap";
+
+    @Option(name = "summary-spec-files", description = "Summary spec files abusolutle paths.")
+    private List<File> mSummarySpecFiles = new ArrayList<File>();
+
+    @Option(
+            name = "add-sql-packages",
+            description =
+                    "Path to the directory of additional SQL packages to load when running the"
+                        + " trace processor. A path can be either absolute or relative to the test"
+                        + " artifacts. The Files from the directory will be treated as a new SQL"
+                        + " package and can be used for INCLUDE PERFETTO MODULE statements.")
+    private List<File> mAddSqlPackages = new ArrayList<File>();
+
+    @Option(
+            name = "summary-spec-file-name",
+            description =
+                    "Parses the spec at the specified path and makes it available to other"
+                        + " summarization operators (--summary-metrics-v2). Spec files must be"
+                        + " instances of the perfetto.protos.TraceSummarySpec proto. If the file"
+                        + " extension is `.textproto` then the spec file will be parsed as a"
+                        + " textproto. If the file extension is `.pb` then it will be parsed as a"
+                        + " binary protobuf. Otherwise, heureustics will be used to determine the"
+                        + " format.")
+    private String mSummarySpecFileName = "memory_per_process-avg_rss_and_swap.textproto";
+
+    @Option(
+            name = "perfetto-trace-file-regex",
+            description =
+                    "Regex pattern specifying the trace file names to be processed."
+                            + " By default uses the .perfetto-trace extension since this works for"
+                            + " both raw and compressed traces.")
+    private String mPerfettoTraceFileRegex = ".*\\.perfetto\\-trace.*";
+
+    private Map<String, File> mTestArtifactFilePathMap = new HashMap<>();
+
+    private Map<String, File> mTestArtifactDirectoryMap = new HashMap<>();
+
+    @Override
+    public Map<String, Metric.Builder> processTestMetricsAndLogs(
+            TestDescription testDescription,
+            HashMap<String, Metric> testMetrics,
+            Map<String, LogFile> testLogs) {
+        return processLogs(testLogs);
+    }
+
+    @Override
+    public Map<String, Metric.Builder> processRunMetricsAndLogs(
+            HashMap<String, Metric> rawMetrics, Map<String, LogFile> runLogs) {
+        return processLogs(runLogs);
+    }
+
+    /**
+     * Find any perfetto trace files in the logs and run the trace processor on them to produce a
+     * perfetto metric proto.
+     *
+     * @param logs log files from the test or test run.
+     * @return metrics produced while processing trace files in the logs.
+     */
+    private Map<String, Metric.Builder> processLogs(Map<String, LogFile> logs) {
+        Map<String, Metric.Builder> metrics = new HashMap<>();
+        Pattern pattern = Pattern.compile(mPerfettoTraceFileRegex);
+        for (String fileName : logs.keySet()) {
+            if (pattern.matcher(fileName).matches()) {
+                metrics.putAll(processTraceFile(logs.get(fileName)));
+            }
+        }
+        return metrics;
+    }
+
+    /**
+     * Takes a perfetto trace file and runs the trace processor on it to produce a perfetto metric
+     * proto.
+     *
+     * @param logFile the perfetto trace file to process, either raw or compressed.
+     * @return metrics produced while processing trace file.
+     */
+    private Map<String, Metric.Builder> processTraceFile(LogFile logFile) {
+        Map<String, Metric.Builder> metrics = new HashMap<>();
+
+        // The trace file from the test logs, either raw or compressed.
+        File traceFile = new File(logFile.getPath());
+        boolean isCompressed = logFile.getType().isCompressed();
+
+        // If the trace is compressed, decompress it before processing.
+        File processSrcFile = traceFile;
+        if (isCompressed) {
+            processSrcFile = decompressFile(traceFile);
+        }
+
+        // Update the file size metrics.
+        if (processSrcFile != null && mCollectPerfettoFileSize) {
+            double perfettoFileSizeInBytes = processSrcFile.length();
+            Metric.Builder metricDurationBuilder = Metric.newBuilder();
+            metricDurationBuilder.getMeasurementsBuilder().setSingleDouble(perfettoFileSizeInBytes);
+            metrics.put(RAW_TRACE_FILE_SIZE, metricDurationBuilder.setType(DataType.RAW));
+        }
+
+        // Convert to perfetto metric format.
+        if (mConvertToMetricFile) {
+            if (mMetricV1) {
+                metrics.putAll(
+                        wrapConvertedMetricFile(
+                                convertToMetricProto(processSrcFile, METRIC_VERSION_V1),
+                                METRIC_VERSION_V1));
+            }
+            if (mMetricV2) {
+                metrics.putAll(
+                        wrapConvertedMetricFile(
+                                convertToMetricProto(processSrcFile, METRIC_VERSION_V2),
+                                METRIC_VERSION_V2));
+            }
+        }
+
+        // Clean up the temporary decompressed file if needed.
+        if (isCompressed && processSrcFile != null) {
+            processSrcFile.delete();
+        }
+
+        return metrics;
+    }
+
+    private static class TraceProcessorResult {
+        public final File file;
+        // runtime is set to -1 if the trace processor was never run.
+        public final long runtime;
+        public final String status;
+
+        public TraceProcessorResult(File file, long runtime, String status) {
+            this.file = file;
+            this.runtime = runtime;
+            this.status = status;
+        }
+    }
+
+    /**
+     * Converts the raw trace file into perfetto metric file.
+     *
+     * @param perfettoRawTraceFile Raw perfetto trace file that needs to be converted.
+     * @param metricVersion The version of the metric fileto be generated.
+     * @return The result of the conversion.
+     */
+    private TraceProcessorResult convertToMetricProto(
+            File perfettoRawTraceFile, String metricVersion) {
+
+        // Use absolute path to the trace file if it is available otherwise
+        // resolve the trace processor name from the test or module artifacts.
+        if (mTraceProcessorBinary == null || !mTraceProcessorBinary.exists()) {
+            mTraceProcessorBinary = getFileFromTestArtifacts(mTraceProcessorName);
+        }
+
+        File metricOutputFile = null;
+        String metricOutputFilePrefix = "";
+        long runtime = -1L;
+
+        if (mTraceProcessorBinary == null) {
+            CLog.e("Failed to locate the trace processor shell binary file.");
+            return new TraceProcessorResult(metricOutputFile, runtime, STATUS_FAILURE);
+        }
+
+        FileUtil.chmodGroupRWX(mTraceProcessorBinary);
+        List<String> commandArgsList = new ArrayList<String>();
+        commandArgsList.add(mTraceProcessorBinary.getAbsolutePath());
+
+        for (File sqlPackage : mAddSqlPackages) {
+            commandArgsList.add("--add-sql-package");
+            // Resolve the SQL package directory from the absolute path or from the test artifacts.
+            File resolvedSqlPackage = maybeResolveTestDir(sqlPackage);
+            if (resolvedSqlPackage == null) {
+                CLog.e(
+                        "Failed to locate the SQL package directory for %s",
+                        sqlPackage.getAbsolutePath());
+                return new TraceProcessorResult(metricOutputFile, runtime, STATUS_FAILURE);
+            }
+            commandArgsList.add(resolvedSqlPackage.getAbsolutePath());
+        }
+
+        if (metricVersion.contains(METRIC_VERSION_V1)) {
+            metricOutputFilePrefix = "metric_";
+
+            // Comma separated list of metrics to extract.
+            if (!mTraceProcessorMetrics.isEmpty()) {
+                commandArgsList.add("--run-metrics");
+                commandArgsList.add(mTraceProcessorMetrics);
+            }
+        }
+
+        if (metricVersion.contains(METRIC_VERSION_V2)) {
+            metricOutputFilePrefix = "metric_v2_";
+            // Turn on the summary metrics v2 flag.
+            commandArgsList.add("--summary");
+
+            // Comma separated list of metrics ids to extract.
+            if (!mComputeMetricsV2Ids.isEmpty()) {
+                commandArgsList.add("--summary-metrics-v2");
+                commandArgsList.add(mComputeMetricsV2Ids);
+            }
+
+            // resolve the summary spec names from the test or module artifacts.
+            if (mSummarySpecFiles.isEmpty() && !mSummarySpecFileName.isEmpty()) {
+                String[] FileNames = mSummarySpecFileName.split(",");
+                for (String name : FileNames) {
+                    mSummarySpecFiles.add(getFileFromTestArtifacts(name));
+                }
+            }
+
+            if (mSummarySpecFiles.isEmpty()) {
+                CLog.e("Failed to locate the summary spec file.");
+                return new TraceProcessorResult(metricOutputFile, runtime, STATUS_FAILURE);
+            }
+
+            for (File summarySpecFile : mSummarySpecFiles) {
+                commandArgsList.add("--summary-spec");
+                commandArgsList.add(summarySpecFile.getAbsolutePath());
+            }
+        }
+
+        // Metric file output format.
+        commandArgsList.add("--metrics-output=" + mTraceProcessorOutputFormat);
+        commandArgsList.add(perfettoRawTraceFile.getAbsolutePath());
+
+        try {
+            metricOutputFile =
+                    FileUtil.createTempFile(
+                            metricOutputFilePrefix
+                                    + getRawTraceFileName(perfettoRawTraceFile.getName()),
+                            "");
+        } catch (IOException e) {
+            CLog.e("Not able to create metric perfetto output file.");
+            CLog.e(e);
+            return new TraceProcessorResult(null, runtime, STATUS_FAILURE);
+        }
+
+        // Running the trace conversion.
+        CLog.i("Run the trace convertor.");
+        boolean isConversionSuccess = true;
+        try (FileOutputStream outStream = new FileOutputStream(metricOutputFile);
+                ByteArrayOutputStream errStream = new ByteArrayOutputStream()) {
+            long startTime = System.currentTimeMillis();
+            CommandResult conversionResult =
+                    runHostCommand(
+                            mTraceConversionTimeout,
+                            commandArgsList.toArray(new String[commandArgsList.size()]),
+                            outStream,
+                            errStream);
+            runtime = System.currentTimeMillis() - startTime;
+            if (!CommandStatus.SUCCESS.equals(conversionResult.getStatus())) {
+                CLog.e(
+                        "Unable to convert the raw trace - %s to metric file due to"
+                                + " %s - Status - %s ",
+                        perfettoRawTraceFile.getName(),
+                        errStream.toString(),
+                        conversionResult.getStatus());
+                isConversionSuccess = false;
+            } else if (mTraceProcessorOutputFormat.equals(METRIC_FILE_FORMAT.text)
+                    || mTraceProcessorOutputFormat.equals(METRIC_FILE_FORMAT.json)) {
+                File compressedFile = compressFile(metricOutputFile);
+                metricOutputFile.delete();
+                return new TraceProcessorResult(compressedFile, runtime, STATUS_SUCCESS);
+            }
+        } catch (FileNotFoundException e) {
+            CLog.e("Not able to find the result metric file to write the " + "metric output.");
+            CLog.e(e);
+            isConversionSuccess = false;
+        } catch (IOException e1) {
+            CLog.e("Unable to close the streams.");
+            CLog.e(e1);
+            isConversionSuccess = false;
+        } finally {
+            if (!isConversionSuccess) {
+                metricOutputFile.delete();
+                return new TraceProcessorResult(null, runtime, STATUS_FAILURE);
+            }
+        }
+        return new TraceProcessorResult(metricOutputFile, runtime, STATUS_SUCCESS);
+    }
+
+    /**
+     * Wraps the converted metric file into test artifacts.
+     *
+     * @param result TraceProcessorResult
+     * @param version The version of the metric file.
+     * @return metrics for the processor runtime and status.
+     */
+    private Map<String, Metric.Builder> wrapConvertedMetricFile(
+            TraceProcessorResult result, String version) {
+        Map<String, Metric.Builder> metrics = new HashMap<>();
+
+        File convertedMetricFile = result.file;
+        if (convertedMetricFile != null) {
+            try (InputStreamSource source = new FileInputStreamSource(convertedMetricFile, true)) {
+                testLog(convertedMetricFile.getName(), getLogDataType(), source);
+            }
+        }
+
+        Metric.Builder processorRuntimeBuilder = Metric.newBuilder();
+        processorRuntimeBuilder.getMeasurementsBuilder().setSingleDouble((double) result.runtime);
+        String runtimeKey =
+                version.equals(METRIC_VERSION_V2) ? PROCESSOR_RUNTIME_V2 : PROCESSOR_RUNTIME_V1;
+        metrics.put(
+                String.format("%s_%s", mMetricPrefix, runtimeKey),
+                processorRuntimeBuilder.setType(DataType.RAW));
+
+        Metric.Builder processorStatusBuilder = Metric.newBuilder();
+        processorStatusBuilder.getMeasurementsBuilder().setSingleString(result.status);
+        String statusKey =
+                version.equals(METRIC_VERSION_V2) ? PROCESSOR_STATUS_V2 : PROCESSOR_STATUS_V1;
+        metrics.put(
+                String.format("%s_%s", mMetricPrefix, statusKey),
+                processorStatusBuilder.setType(DataType.RAW));
+
+        return metrics;
+    }
+
+    /**
+     * Decompress the file to a temporary file in the host.
+     *
+     * @param compressedFile file to be decompressed.
+     * @return decompressed file used for postprocessing.
+     */
+    @VisibleForTesting
+    File decompressFile(File compressedFile) {
+        File decompressedFile = null;
+        try {
+            decompressedFile = FileUtil.createTempFile("perfetto_decompressed", ".pb");
+        } catch (IOException e) {
+            CLog.e("Not able to create decompressed perfetto file.");
+            CLog.e(e);
+            return null;
+        }
+        // Keep the original file for uploading.
+        List<String> decompressArgsList = new ArrayList<String>();
+        decompressArgsList.add("gzip");
+        decompressArgsList.add("-k");
+        decompressArgsList.add("-c");
+        decompressArgsList.add("-d");
+        decompressArgsList.add(compressedFile.getAbsolutePath());
+
+        // Decompress perfetto trace file.
+        CLog.i("Start decompressing the perfetto trace file.");
+        try (FileOutputStream outStream = new FileOutputStream(decompressedFile);
+                ByteArrayOutputStream errStream = new ByteArrayOutputStream()) {
+            CommandResult decompressResult =
+                    runHostCommand(
+                            mDecompressTimeoutMs,
+                            decompressArgsList.toArray(new String[decompressArgsList.size()]),
+                            outStream,
+                            errStream);
+
+            if (!CommandStatus.SUCCESS.equals(decompressResult.getStatus())) {
+                CLog.e(
+                        "Unable decompress the metric file %s due to %s - Status - %s ",
+                        compressedFile.getName(),
+                        errStream.toString(),
+                        decompressResult.getStatus());
+                decompressedFile.delete();
+                return null;
+            }
+        } catch (FileNotFoundException e) {
+            CLog.e(
+                    "Not able to find the decompressed file to copy the"
+                            + " decompressed contents.");
+            CLog.e(e);
+            return null;
+        } catch (IOException e1) {
+            CLog.e("Unable to close the streams.");
+            CLog.e(e1);
+        }
+        CLog.i("Successfully decompressed the perfetto trace file.");
+        return decompressedFile;
+    }
+
+    /**
+     * Resolve the directory from the absolute path or from the test artifacts.
+     *
+     * @param directory directory to be resolved.
+     * @return resolved directory. Returns null if directory is not found.
+     */
+    @Nullable
+    File maybeResolveTestDir(File directory) {
+        // If the path is absolute, check if the file exists.
+        if (directory.isAbsolute()) {
+            return directory.exists() ? directory : null;
+        }
+        return getDirectoryFromTestArtifacts(directory.getName());
+    }
+
+    @VisibleForTesting
+    @Nullable
+    File getDirectoryFromTestArtifacts(String directoryName) {
+        if (mTestArtifactDirectoryMap.containsKey(directoryName)) {
+            return mTestArtifactDirectoryMap.get(directoryName);
+        }
+        // A relative path is searched from the test artifact dir.
+        File testArtifactDirectory =
+                SearchArtifactUtil.searchFile(
+                        directoryName, false, null, null, null, null, /* includeDirectory= */ true);
+        if (testArtifactDirectory == null || !testArtifactDirectory.exists()) {
+            CLog.e("Failed to retrieve directory %s from test artifacts", directoryName);
+            return null;
+        }
+
+        CLog.i(
+                "Using directory %s from %s",
+                directoryName, testArtifactDirectory.getAbsolutePath());
+        mTestArtifactDirectoryMap.put(directoryName, testArtifactDirectory);
+        return testArtifactDirectory;
+    }
+
+    /**
+     * Retrieve the file from the test artifacts or module artifacts and cache it in a map for the
+     * subsequent calls.
+     *
+     * @param fileName name of the file to look up in the artifacts.
+     * @return File from the test artifact or module artifact. Returns null if file is not found.
+     */
+    @VisibleForTesting
+    File getFileFromTestArtifacts(String fileName) {
+        if (mTestArtifactFilePathMap.containsKey(fileName)) {
+            return mTestArtifactFilePathMap.get(fileName);
+        }
+
+        File resolvedFile = SearchArtifactUtil.searchFile(fileName, true);
+        if (resolvedFile == null || !resolvedFile.exists()) {
+            CLog.e("Failed to retrieve file %s from test artifacts", fileName);
+            return null;
+        }
+
+        CLog.i("Using file %s from %s", fileName, resolvedFile.getAbsolutePath());
+        mTestArtifactFilePathMap.put(fileName, resolvedFile);
+        return resolvedFile;
+    }
+
+    /**
+     * Run a host command with the given array of command args.
+     *
+     * @param commandArgs args to be used to construct the host command.
+     * @param stdout output of the command.
+     * @param stderr error message if any from the command.
+     * @return return the command results.
+     */
+    @VisibleForTesting
+    CommandResult runHostCommand(
+            long timeOut, String[] commandArgs, OutputStream stdout, OutputStream stderr) {
+        if (stdout != null && stderr != null) {
+            return RunUtil.getDefault().runTimedCmd(timeOut, stdout, stderr, commandArgs);
+        }
+        return RunUtil.getDefault().runTimedCmd(timeOut, commandArgs);
+    }
+
+    /**
+     * Get the log data type based on the output metric perfetto file.
+     *
+     * @return LogDataType type of the file used for uploading the artifacts.
+     */
+    private LogDataType getLogDataType() {
+        // text option in perfetto trace processor means text proto.
+        if (mTraceProcessorOutputFormat.equals(METRIC_FILE_FORMAT.text)) {
+            return LogDataType.ZIP;
+        } else if (mTraceProcessorOutputFormat.equals(METRIC_FILE_FORMAT.binary)) {
+            return LogDataType.PB;
+        } else {
+            return LogDataType.TEXT;
+        }
+    }
+
+    /**
+     * Extract the raw trace file name used for constructing the output perfetto metric file name
+     *
+     * @param rawTraceFileName
+     * @return String name of the raw trace file name excluding the UUID.
+     */
+    private String getRawTraceFileName(String rawTraceFileName) {
+        // For example return perfetto_<test_name>-1_ from
+        // perfetto_<test_name>-1_13388308985625987330.pb excluding the UID.
+        int lastIndex = rawTraceFileName.lastIndexOf("_");
+        if (lastIndex != -1) {
+            return rawTraceFileName.substring(0, lastIndex + 1);
+        }
+        return rawTraceFileName;
+    }
+
+    /**
+     * Compress the given file.
+     *
+     * @return File compressed version of the file.
+     */
+    @VisibleForTesting
+    File compressFile(File metricOutputFile) throws IOException {
+        return ZipUtil.createZip(metricOutputFile, metricOutputFile.getName());
+    }
+
+    /**
+     * Set the metric type to RAW so that metrics will be processed by subsequent post processors.
+     *
+     * <p>This is necessary for MetricFilePostProcessor to write the metrics to the results file.
+     */
+    @Override
+    protected DataType getMetricType() {
+        return DataType.RAW;
+    }
+}
diff --git a/test_framework/com/android/tradefed/targetprep/DynamicSystemPreparer.java b/test_framework/com/android/tradefed/targetprep/DynamicSystemPreparer.java
index 879ff0544..2cf141df0 100644
--- a/test_framework/com/android/tradefed/targetprep/DynamicSystemPreparer.java
+++ b/test_framework/com/android/tradefed/targetprep/DynamicSystemPreparer.java
@@ -204,26 +204,37 @@ public class DynamicSystemPreparer extends BaseTargetPreparer implements ILabPre
             throws DeviceNotAvailableException, TargetSetupError {
         File pvmfwImg = null;
         try {
-            // Unzip pvmfw.img and save to temp file
-            CLog.i("Unzip pvmfw.img from %s", systemImageZipFile.getAbsolutePath());
-            try (ZipFile zipFile = new ZipFile(systemImageZipFile)) {
-                ZipEntry pvmfwEntry = zipFile.getEntry("pvmfw.img");
-                if (pvmfwEntry == null) {
+            if (systemImageZipFile.isDirectory()) {
+                pvmfwImg = systemImageZipFile.toPath().resolve("pvmfw.img").toFile();
+                if (!pvmfwImg.isFile()) {
                     throw new TargetSetupError(
-                            String.format("Cannot find pvmfw.img in %s", systemImageZipFile),
+                            String.format(
+                                    "Cannot find pvmfw.img in directory %s", systemImageZipFile),
                             device.getDeviceDescriptor(),
                             InfraErrorIdentifier.CONFIGURED_ARTIFACT_NOT_FOUND);
                 }
-                pvmfwImg = FileUtil.createTempFile("pvmfw", ".img");
-                try (InputStream in = zipFile.getInputStream(pvmfwEntry);
-                        OutputStream out = new FileOutputStream(pvmfwImg)) {
-                    StreamUtil.copyStreams(in, out);
+            } else {
+                // Unzip pvmfw.img and save to temp file
+                CLog.i("Unzip pvmfw.img from %s", systemImageZipFile.getAbsolutePath());
+                try (ZipFile zipFile = new ZipFile(systemImageZipFile)) {
+                    ZipEntry pvmfwEntry = zipFile.getEntry("pvmfw.img");
+                    if (pvmfwEntry == null) {
+                        throw new TargetSetupError(
+                                String.format("Cannot find pvmfw.img in %s", systemImageZipFile),
+                                device.getDeviceDescriptor(),
+                                InfraErrorIdentifier.CONFIGURED_ARTIFACT_NOT_FOUND);
+                    }
+                    pvmfwImg = FileUtil.createTempFile("pvmfw", ".img");
+                    try (InputStream in = zipFile.getInputStream(pvmfwEntry);
+                            OutputStream out = new FileOutputStream(pvmfwImg)) {
+                        StreamUtil.copyStreams(in, out);
+                    }
+                } catch (IOException e) {
+                    throw new TargetSetupError(
+                            String.format("Fail unzip pvmfw.img from %s", systemImageZipFile),
+                            device.getDeviceDescriptor(),
+                            InfraErrorIdentifier.FAIL_TO_CREATE_FILE);
                 }
-            } catch (IOException e) {
-                throw new TargetSetupError(
-                        String.format("Fail unzip pvmfw.img from %s", systemImageZipFile),
-                        device.getDeviceDescriptor(),
-                        InfraErrorIdentifier.FAIL_TO_CREATE_FILE);
             }
 
             device.waitForDeviceOnline();
diff --git a/test_framework/com/android/tradefed/targetprep/FutilityCommandPreparer.java b/test_framework/com/android/tradefed/targetprep/FutilityCommandPreparer.java
new file mode 100644
index 000000000..3ad7854bd
--- /dev/null
+++ b/test_framework/com/android/tradefed/targetprep/FutilityCommandPreparer.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.targetprep;
+
+import com.android.tradefed.config.Option;
+import com.android.tradefed.device.DeviceNotAvailableException;
+import com.android.tradefed.device.ITestDevice;
+import com.android.tradefed.invoker.TestInformation;
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.util.CommandResult;
+import com.android.tradefed.util.CommandStatus;
+
+/** Preparer to execute futility commands. */
+public class FutilityCommandPreparer extends BaseTargetPreparer {
+
+    @Option(
+            name = "gbb-flag-value",
+            description = "The value of the gbb flag to write to the device.")
+    private String mGbbFlag = "0x80000018";
+
+    @Override
+    public void setUp(TestInformation testInformation)
+            throws TargetSetupError, BuildError, DeviceNotAvailableException {
+        ITestDevice device = testInformation.getDevice();
+        if (!device.enableAdbRoot()) {
+            CLog.w("Root is required to write Gbb flags");
+            return;
+        }
+        CommandResult originalStatus = device.executeShellV2Command("su root crossystem");
+        CLog.d("exit code: %s", originalStatus.getExitCode());
+        CLog.d("stdout: %s", originalStatus.getStdout());
+        CLog.d("stderr: %s", originalStatus.getStderr());
+
+        CommandResult writeGbb =
+                device.executeShellV2Command(
+                        "su root futility gbb --set --flash --flags +" + mGbbFlag);
+        CLog.d("stdout: %s", writeGbb.getStdout());
+        CLog.d("stderr: %s", writeGbb.getStderr());
+        if (!CommandStatus.SUCCESS.equals(writeGbb.getStatus())) {
+            throw new TargetSetupError("Failed to write gbb flag.", device.getDeviceDescriptor());
+        }
+        device.reboot();
+
+        CommandResult afterStatus = device.executeShellV2Command("su root crossystem");
+        CLog.d("exit code: %s", afterStatus.getExitCode());
+        CLog.d("stdout: %s", afterStatus.getStdout());
+        CLog.d("stderr: %s", afterStatus.getStderr());
+    }
+}
diff --git a/test_framework/com/android/tradefed/targetprep/MixKernelTargetPreparer.java b/test_framework/com/android/tradefed/targetprep/MixKernelTargetPreparer.java
index b89b07f37..64d5add90 100644
--- a/test_framework/com/android/tradefed/targetprep/MixKernelTargetPreparer.java
+++ b/test_framework/com/android/tradefed/targetprep/MixKernelTargetPreparer.java
@@ -288,23 +288,53 @@ public class MixKernelTargetPreparer extends BaseTargetPreparer
     @VisibleForTesting
     void setNewDeviceImage(IBuildInfo buildInfo, File newDeviceDir)
             throws TargetSetupError, IOException {
-        CLog.i(
-                "Before mixing kernel, the device image %s is of size %d",
-                buildInfo.getFile(BuildInfoFileKey.DEVICE_IMAGE.getFileKey()).toString(),
-                buildInfo.getFile(BuildInfoFileKey.DEVICE_IMAGE.getFileKey()).length());
+        File oldDeviceImage = buildInfo.getFile(BuildInfoFileKey.DEVICE_IMAGE.getFileKey());
+        if (oldDeviceImage.isFile()) {
+            CLog.i(
+                    "Before mixing kernel, the device image %s is a file of size %d",
+                    oldDeviceImage.toString(), oldDeviceImage.length());
+            File newDeviceImage = FileUtil.findFile(newDeviceDir, ".*-img-.*.zip.*");
+            if (newDeviceImage == null || !newDeviceImage.exists()) {
+                throw new TargetSetupError(
+                        "Failed to get a new device image after mixing",
+                        InfraErrorIdentifier.OPTION_CONFIGURATION_ERROR);
+            }
+            CLog.i(
+                    "After mixing kernel, the device image %s is a file of size %d",
+                    newDeviceImage.toString(), newDeviceImage.length());
+            String oldPath = oldDeviceImage.getAbsolutePath();
+            CLog.i("Delete old device image %s", oldDeviceImage);
+            oldDeviceImage.delete();
+            CLog.i("Create hardlink %s for %s", oldPath, newDeviceImage);
+            FileUtil.hardlinkFile(newDeviceImage, new File(oldPath));
 
-        File newDeviceImage = FileUtil.findFile(newDeviceDir, ".*-img-.*.zip$");
-        if (newDeviceImage == null || !newDeviceImage.exists()) {
+        } else if (oldDeviceImage.isDirectory()) {
+            CLog.i(
+                    "Before mixing kernel, the device image %s is a directory of size %d",
+                    oldDeviceImage.toString(), FileUtil.sizeOfDirectory(oldDeviceImage));
+            CLog.i(
+                    "After mixing kernel, the device image %s is a directory of size %d",
+                    newDeviceDir.toString(), FileUtil.sizeOfDirectory(newDeviceDir));
+            for (File image : oldDeviceImage.listFiles()) {
+                String imgName = image.getName();
+                File newImage = FileUtil.findFile(newDeviceDir, imgName);
+                if (newImage == null || !newImage.exists()) {
+                    throw new TargetSetupError(
+                            String.format(
+                                    "Failed to find device image %s in %s", imgName, newDeviceDir),
+                            InfraErrorIdentifier.OPTION_CONFIGURATION_ERROR);
+                }
+                String oldPath = image.getAbsolutePath();
+                CLog.i("Delete old device image file %s", image);
+                image.delete();
+                CLog.i("Create hardlink %s for %s", oldPath, newImage);
+                FileUtil.hardlinkFile(newImage, new File(oldPath));
+            }
+        } else {
             throw new TargetSetupError(
-                    "Failed to get a new device image after mixing",
+                    String.format("Device image %s does not exist", oldDeviceImage.toString()),
                     InfraErrorIdentifier.OPTION_CONFIGURATION_ERROR);
         }
-        CLog.i(
-                "Successfully generated new device image %s of size %d",
-                newDeviceImage, newDeviceImage.length());
-        String deviceImagePath = buildInfo.getFile(BuildInfoFileKey.DEVICE_IMAGE).getAbsolutePath();
-        buildInfo.getFile(BuildInfoFileKey.DEVICE_IMAGE.getFileKey()).delete();
-        FileUtil.hardlinkFile(newDeviceImage, new File(deviceImagePath));
 
         try {
             // Modifying device image cannot work with incremental flashing so
@@ -312,14 +342,10 @@ public class MixKernelTargetPreparer extends BaseTargetPreparer
             CLog.d("Disabling incremental flashing.");
             mConfig.injectOptionValue("incremental-flashing", "false");
             mConfig.injectOptionValue("force-disable-incremental-flashing", "true");
+            mConfig.injectOptionValue("skip-bootloader-version-check", "true");
         } catch (ConfigurationException ignore) {
             CLog.e(ignore);
         }
-
-        CLog.i(
-                "After mixing kernel, the device image %s is of size %d",
-                buildInfo.getFile(BuildInfoFileKey.DEVICE_IMAGE.getFileKey()).toString(),
-                buildInfo.getFile(BuildInfoFileKey.DEVICE_IMAGE.getFileKey()).length());
     }
 
     /**
@@ -358,10 +384,10 @@ public class MixKernelTargetPreparer extends BaseTargetPreparer
                     "Failed to run mix kernel tool. Exit code: %s, stdout: %s, stderr: %s",
                     result.getStatus(), result.getStdout(), result.getStderr());
             throw new TargetSetupError(
-                    "Failed to run mix kernel tool. Stderr: " + result.getStderr());
+                    "Failed to run mix kernel tool.");
         }
         CLog.i(
-                "Successfully mixed kernel to new device image in %s with files %s",
-                newDeviceDir.toString(), Arrays.toString(newDeviceDir.list()));
+                "%s\nSuccessfully mixed kernel to new device image in %s with files %s.",
+                result.getStdout(), newDeviceDir.toString(), Arrays.toString(newDeviceDir.list()));
     }
 }
diff --git a/test_framework/com/android/tradefed/targetprep/MixRadioTargetPreparer.java b/test_framework/com/android/tradefed/targetprep/MixRadioTargetPreparer.java
new file mode 100644
index 000000000..52a00bc0e
--- /dev/null
+++ b/test_framework/com/android/tradefed/targetprep/MixRadioTargetPreparer.java
@@ -0,0 +1,271 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.tradefed.targetprep;
+
+import com.android.tradefed.build.IBuildInfo;
+import com.android.tradefed.build.IDeviceBuildInfo;
+import com.android.tradefed.build.VersionedFile;
+import com.android.tradefed.config.Option;
+import com.android.tradefed.config.OptionClass;
+import com.android.tradefed.device.DeviceNotAvailableException;
+import com.android.tradefed.device.ITestDevice;
+import com.android.tradefed.invoker.IInvocationContext;
+import com.android.tradefed.invoker.TestInformation;
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.util.FileUtil;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.UncheckedIOException;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.util.stream.Stream;
+import java.util.zip.GZIPInputStream;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipInputStream;
+import java.util.zip.ZipOutputStream;
+
+/** A {@link ITargetPreparer} that allows to mix a radio image with the device image. */
+@OptionClass(alias = "mix-radio-target-preparer")
+public class MixRadioTargetPreparer extends BaseTargetPreparer implements ILabPreparer {
+
+    @Option(name = "radio-file-key", description = "The key of the downloaded radio image file.")
+    private String radioFileKey = "radio.img.gz";
+
+    private static final String ANDROID_INFO_FILE_NAME = "android-info.txt";
+
+    @Override
+    public void setUp(TestInformation testInfo)
+            throws TargetSetupError, BuildError, DeviceNotAvailableException {
+        IInvocationContext context = testInfo.getContext();
+        ITestDevice device = testInfo.getDevice();
+        IBuildInfo buildInfo = testInfo.getBuildInfo();
+        IDeviceBuildInfo deviceBuild = (IDeviceBuildInfo) buildInfo;
+        File tmpRadioDir = null;
+        try {
+            tmpRadioDir = FileUtil.createTempDir("radio_dir");
+            File downloadedRadioFile = new File(tmpRadioDir, "radio.img");
+            File srcFile;
+            if (buildInfo.getFile(radioFileKey) == null) {
+                throw new TargetSetupError(
+                        radioFileKey
+                                + " is not provided in the gcl file. Can not generate radio image.",
+                        device.getDeviceDescriptor());
+            } else {
+                srcFile = buildInfo.getFile(radioFileKey);
+            }
+
+            String suffix = FileUtil.getExtension(srcFile.getName());
+            if (suffix.contains("gz")) {
+                CLog.i("File was requested to be ungzipped.");
+                // File was requested to be ungzipped.
+                try (FileInputStream stream = new FileInputStream(srcFile)) {
+                    try (GZIPInputStream gzip = new GZIPInputStream(stream)) {
+                        FileUtil.writeToFile(gzip, downloadedRadioFile, true);
+                        FileUtil.deleteFile(srcFile);
+                    }
+                }
+            } else {
+                FileUtil.hardlinkFile(srcFile, downloadedRadioFile);
+                FileUtil.deleteFile(srcFile);
+            }
+
+            if (tmpRadioDir.listFiles().length == 0) {
+                throw new TargetSetupError(
+                        "Could not find radio images", device.getDeviceDescriptor());
+            }
+            mixRadio(device, deviceBuild, downloadedRadioFile);
+        } catch (IOException e) {
+            throw new TargetSetupError(
+                    "Could not mix device and radio images", e, device.getDeviceDescriptor());
+        } finally {
+            FileUtil.recursiveDelete(tmpRadioDir);
+        }
+    }
+
+    /**
+     * Functional interface to update a zip entry. The update method should return true if the name
+     * passed to it is a file you want to scan.
+     */
+    @FunctionalInterface
+    interface PatchEntryFn {
+        boolean update(String name, InputStream in, OutputStream out) throws IOException;
+    }
+
+    /**
+     * Copy zip entries from src to dst with a PatchEntryFn.
+     *
+     * <p>Entries in the zip are processed by patchFn. If the patchFn returns false, this function
+     * will copy the entry by transferTo(), otherwise do nothing.
+     *
+     * @param src the source file
+     * @param dst the destination file
+     * @param patchFn the PatchEntryFn to be applied on each entry
+     */
+    private static void copyZipEntries(File src, File dst, PatchEntryFn patchFn)
+            throws IOException {
+        // Fallbacks to ZipOutputStream to update the zip entry; the latest jdk.zipfs has an
+        // issue that the jdk.zipfs doesn't write a valid UNX_IFMT in "external file attributes"
+        // for the entries it's updating (see 'writeCEN()' for details), so some zip tools
+        // (e.g.: fuse-zip) couldn't handle such entries well. Replaces the updating procedure
+        // with ZipOutputStream to workaround it.
+
+        try (ZipInputStream zis = new ZipInputStream(new FileInputStream(src));
+                ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(dst))) {
+            ZipEntry sourceFile;
+
+            while ((sourceFile = zis.getNextEntry()) != null) {
+                zos.putNextEntry(new ZipEntry(sourceFile.getName()));
+                if (!patchFn.update(sourceFile.getName(), zis, zos)) {
+                    zis.transferTo(zos);
+                }
+                zos.closeEntry();
+            }
+        }
+    }
+
+    private static void uncheckedWrite(OutputStream out, String data) {
+        try {
+            out.write(data.getBytes());
+        } catch (IOException e) {
+            throw new UncheckedIOException(e);
+        }
+    }
+
+    private static boolean isAndroidInfo(String name) {
+        return name.equals(ANDROID_INFO_FILE_NAME);
+    }
+
+    private static void processAndroidInfo(InputStream in, OutputStream out) throws IOException {
+        InputStreamReader inr = new InputStreamReader(in, StandardCharsets.UTF_8);
+        try (Stream<String> lines = new BufferedReader(inr).lines()) {
+            lines.filter(line -> !line.startsWith("require version-baseband="))
+                    .forEach(line -> uncheckedWrite(out, line + "\n"));
+        }
+    }
+
+    private static boolean patchAndroidInfoFn(String name, InputStream in, OutputStream out)
+            throws IOException {
+        if (!isAndroidInfo(name)) {
+            return false;
+        }
+
+        processAndroidInfo(in, out);
+        return true;
+    }
+
+    /**
+     * Create new device image by mixing new radio image to device image.
+     *
+     * @param device the test device
+     * @param deviceBuildInfo the device build info
+     * @param downloadedRadioImage the downloaded radio image
+     */
+    private void mixRadio(
+            ITestDevice device, IDeviceBuildInfo deviceBuildInfo, File downloadedRadioImage)
+            throws TargetSetupError, BuildError, DeviceNotAvailableException {
+        File newDeviceImage = null;
+
+        try {
+            File deviceImage = deviceBuildInfo.getDeviceImageFile();
+            int linkCount =
+                    ((Integer) Files.getAttribute(deviceImage.toPath(), "unix:nlink")).intValue();
+            CLog.d(
+                    "The link count is %s for device image: %s",
+                    linkCount, deviceImage.getAbsolutePath());
+            if (deviceImage.isDirectory()) {
+                CLog.i("deviceImage is a directory");
+                Path androidInfoPath = deviceImage.toPath().resolve(ANDROID_INFO_FILE_NAME);
+                if (!Files.exists(androidInfoPath)) {
+                    throw new TargetSetupError(
+                            "Failed to find " + ANDROID_INFO_FILE_NAME,
+                            device.getDeviceDescriptor());
+                }
+                File newAndroidInfoFile = FileUtil.createTempFile("android-info", ".txt");
+                try (FileInputStream fis = new FileInputStream(androidInfoPath.toFile());
+                        FileOutputStream fos = new FileOutputStream(newAndroidInfoFile)) {
+                    processAndroidInfo(fis, fos);
+                }
+                androidInfoPath.toFile().delete();
+                FileUtil.hardlinkFile(newAndroidInfoFile, androidInfoPath.toFile());
+            } else {
+                CLog.i("deviceImage is a file");
+                newDeviceImage = FileUtil.createTempFile("device-img", ".zip");
+
+                // Clone deviceImage to newDeviceImage, and remove lines
+                // /^require version-baseband=/ within 'android-info.txt' of newDeviceImage.
+                copyZipEntries(
+                        deviceImage,
+                        newDeviceImage,
+                        (name, in, out) -> patchAndroidInfoFn(name, in, out));
+
+                // The deviceBuildInfo ImageFiles are files hardlink'd to cached Android build
+                // files. Replace them for this device and without polluting the cached files,
+                // delete() the hardlink file first, then copy the new file to original hardlink
+                // file path.
+                // Replace device image of deviceBuildInfo w/ the android-info.txt-patched one.
+                String deviceImagePath = deviceImage.getAbsolutePath();
+                deviceImage.delete();
+                FileUtil.hardlinkFile(newDeviceImage, new File(deviceImagePath));
+            }
+
+            // Clean up radio image.
+            String radioImageFilePath = deviceBuildInfo.getBasebandImageFile().getAbsolutePath();
+            File radioImageFile = deviceBuildInfo.getBasebandImageFile();
+            String basebandVersion = deviceBuildInfo.getBasebandVersion();
+
+            ArrayList<File> doNotClean = new ArrayList<File>();
+            for (VersionedFile fileRecord : deviceBuildInfo.getFiles()) {
+                if (!radioImageFile.equals(fileRecord.getFile()))
+                    doNotClean.add(fileRecord.getFile());
+            }
+            deviceBuildInfo.cleanUp(doNotClean);
+
+            // Replace build ID in baseband version with `basebandVersion`.
+            // This is a fake version to make sure the radio image is flashed.
+            Matcher versionMatcher = Pattern.compile("(.*-)[^-]+").matcher(basebandVersion);
+            String versionReplacement = "$1" + basebandVersion;
+
+            // Replace radio image of deviceBuildInfo w/ the new one and update version.
+            radioImageFile.delete();
+
+            File testRadioImageFile = new File(radioImageFilePath);
+            FileUtil.hardlinkFile(downloadedRadioImage, testRadioImageFile);
+
+            deviceBuildInfo.setBasebandImage(
+                    testRadioImageFile, versionMatcher.replaceAll(versionReplacement));
+            CLog.i(
+                    "Successfully generated new device image %s out of device %s and radio image"
+                            + " %s",
+                    newDeviceImage, deviceBuildInfo, basebandVersion);
+        } catch (IOException e) {
+            throw new TargetSetupError(
+                    "Could not mix device and radio images", e, device.getDeviceDescriptor());
+        } finally {
+            FileUtil.deleteFile(newDeviceImage);
+        }
+    }
+}
diff --git a/test_framework/com/android/tradefed/targetprep/SwitchUserTargetPreparer.java b/test_framework/com/android/tradefed/targetprep/SwitchUserTargetPreparer.java
index 9db628885..e969bfd6f 100644
--- a/test_framework/com/android/tradefed/targetprep/SwitchUserTargetPreparer.java
+++ b/test_framework/com/android/tradefed/targetprep/SwitchUserTargetPreparer.java
@@ -25,7 +25,7 @@ import com.android.tradefed.error.HarnessRuntimeException;
 import com.android.tradefed.invoker.TestInformation;
 import com.android.tradefed.log.LogUtil.CLog;
 
-import java.util.Map;
+import java.util.Locale;
 
 /**
  * A {@link ITargetPreparer} that switches to the specified user kind in setUp. By default it
@@ -50,36 +50,31 @@ public class SwitchUserTargetPreparer extends BaseTargetPreparer {
         setUserToSwitchTo(device);
 
         mPreExecutionCurrentUser = device.getCurrentUser();
-        Map<Integer, UserInfo> userInfos = device.getUserInfos();
 
-        if (userInfos
-                .get(mPreExecutionCurrentUser)
-                .isUserType(mUserToSwitchTo, mPreExecutionCurrentUser)) {
+        int userIdToSwitch = getUserIdOfType(device, mUserToSwitchTo);
+        if (userIdToSwitch == UserInfo.USER_NULL) {
+            throw new TargetSetupError(
+                    String.format(
+                            Locale.ENGLISH,
+                            "Failed to switch to user type %s: No user of this type was found on"
+                                    + " the device.",
+                            mUserToSwitchTo),
+                    device.getDeviceDescriptor());
+        }
+
+        if (userIdToSwitch == mPreExecutionCurrentUser) {
             CLog.i(
-                    "User %d is already user type %s, no action.",
-                    mPreExecutionCurrentUser, mUserToSwitchTo.toString());
+                    "Current user %d is already the target user; no switch required.",
+                    mPreExecutionCurrentUser);
             return;
         }
 
-        for (UserInfo userInfo : userInfos.values()) {
-            if (userInfo.isUserType(mUserToSwitchTo, mPreExecutionCurrentUser)) {
-                CLog.i(
-                        "User %d is user type %s, switching from %d",
-                        userInfo.userId(), mUserToSwitchTo.toString(), mPreExecutionCurrentUser);
-                if (!device.switchUser(userInfo.userId())) {
-                    throw new TargetSetupError(
-                            String.format("Device failed to switch to user %d", userInfo.userId()),
-                            device.getDeviceDescriptor());
-                }
-                return;
-            }
+        if (!device.switchUser(userIdToSwitch)) {
+            throw new TargetSetupError(
+                    String.format(
+                            Locale.ENGLISH, "Device failed to switch to user %d.", userIdToSwitch),
+                    device.getDeviceDescriptor());
         }
-
-        throw new TargetSetupError(
-                String.format(
-                        "Failed switch to user type %s, no user of that type exists",
-                        mUserToSwitchTo),
-                device.getDeviceDescriptor());
     }
 
     @Override
@@ -96,18 +91,36 @@ public class SwitchUserTargetPreparer extends BaseTargetPreparer {
     /**
      * In some form factors running on headless system user mode, it is restricted to switch to the
      * {@link UserInfo.UserType#SYSTEM SYSTEM} user. In such cases, change the {@link
-     * #mUserToSwitchTo} to the {@link UserInfo.UserType#MAIN MAIN} user.
+     * #mUserToSwitchTo} to the first {@link UserInfo.UserType#FULL FULL} user.
      */
     private void setUserToSwitchTo(ITestDevice device) throws DeviceNotAvailableException {
         try {
             if (UserInfo.UserType.SYSTEM.equals(mUserToSwitchTo)
-                    && device.isHeadlessSystemUserMode()
-                    && !device.canSwitchToHeadlessSystemUser()) {
-                mUserToSwitchTo = UserInfo.UserType.MAIN;
-                CLog.i("SwitchUserTargetPreparer is configured to switch to the MAIN user.");
+                    && device.isHeadlessSystemUserMode()) {
+                mUserToSwitchTo = UserInfo.UserType.FULL;
+                CLog.i("SwitchUserTargetPreparer is configured to switch to a FULL user.");
             }
         } catch (HarnessRuntimeException e) {
             CLog.w("Unable to get the main user switch-ability. Error: ", e);
         }
     }
+
+    /**
+     * Returns the ID of the first user matching the specified {@link UserInfo.UserType}. Returns
+     * {@code UserInfo.USER_NULL} if no such user is found.
+     */
+    private int getUserIdOfType(ITestDevice device, UserInfo.UserType userType)
+            throws DeviceNotAvailableException {
+        int currentUser = device.getCurrentUser();
+        for (UserInfo userInfo : device.getUserInfos().values()) {
+            if (userInfo.isUserType(userType, currentUser)) {
+                CLog.i(
+                        "Found user %d (type: %s) as the target for switching.",
+                        userInfo.userId(), userType.toString());
+                return userInfo.userId();
+            }
+        }
+        CLog.w("No user found matching the type: %s.", userType.toString());
+        return UserInfo.USER_NULL;
+    }
 }
diff --git a/test_framework/com/android/tradefed/testtype/ArtRunTest.java b/test_framework/com/android/tradefed/testtype/ArtRunTest.java
index 07dc25acf..5defbbbd0 100644
--- a/test_framework/com/android/tradefed/testtype/ArtRunTest.java
+++ b/test_framework/com/android/tradefed/testtype/ArtRunTest.java
@@ -82,6 +82,7 @@ public class ArtRunTest
     private static final String STDERR_FILE_NAME = "stderr.txt";
 
     // Name of the Checker Python Archive (PAR) file.
+    public static final Boolean RUN_CHECKER = false;
     public static final String CHECKER_PAR_FILENAME = "art-run-test-checker";
     private static final long CHECKER_TIMEOUT_MS = 5 * 60 * 1000; // 5 minutes.
 
@@ -340,7 +341,7 @@ public class ArtRunTest
             }
 
             // If the test is a Checker test, run Checker and check its output.
-            if (mRunTestName.contains("-checker-")) {
+            if (RUN_CHECKER && mRunTestName.contains("-checker-")) {
                 Optional<String> checkerError = executeCheckerTest(testInfo, listener);
                 checkerError.ifPresent(errors::add);
             }
diff --git a/test_framework/com/android/tradefed/testtype/ArtTest.java b/test_framework/com/android/tradefed/testtype/ArtTest.java
new file mode 100644
index 000000000..1dc6dbb59
--- /dev/null
+++ b/test_framework/com/android/tradefed/testtype/ArtTest.java
@@ -0,0 +1,286 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.testtype;
+
+import com.android.tradefed.config.ConfigurationException;
+import com.android.tradefed.config.OptionCopier;
+import com.android.tradefed.device.DeviceNotAvailableException;
+import com.android.tradefed.device.ITestDevice;
+import com.android.tradefed.invoker.TestInformation;
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.result.ITestInvocationListener;
+import com.android.tradefed.result.TestDescription;
+import com.android.tradefed.util.CommandResult;
+import com.android.tradefed.util.CommandStatus;
+import com.android.tradefed.util.FileUtil;
+import com.android.tradefed.util.SearchArtifactUtil;
+import com.android.tradefed.util.TarUtil;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Queue;
+import java.util.Set;
+import java.util.TreeMap;
+
+/* Generic test runner for ART.
+ *  - It receives all needed data as one tarball(produced as build step of ART).
+ *  - Information/metadata about the individual tests is stored in JSON file(s).
+ *  - The tests are exectued as sequence of 'adb push' and 'adb shell' commands.
+ *  - In general, we just execute a single BASH file per test using 'adb shell'.
+ *  - ART translates any test-specific python steps into a per-test BASH script.
+ *
+ *  The JSON file might look like the following (subject to change):
+ *  {
+ *    "001-HelloWorld#1f5cdb07": {
+ *       "adb push": [
+ *         [ "../target/001-HelloWorld", "/data/local/tmp/art/test/1f5cdb07" ],
+ *         [ "001-HelloWorld/1f5cdb07.sh", "/data/local/tmp/art/test/1f5cdb07/run.sh" ]
+ *       ],
+ *       "adb shell": [
+ *         [ "sh", "/data/local/tmp/art/test/1f5cdb07/run.sh" ]
+ *       ],
+ *       "dependencies": [
+ *         "setup#compile-boot-image"
+ *       ]
+ *    },
+ *    "setup#compile-boot-image": {
+ *       "adb push": [
+ *         [ "setup.sh", "/data/local/tmp/art/setup.sh" ]
+ *       ],
+ *       "adb shell": [
+ *         [ "rm", "-rf", "/data/local/tmp/art/test" ],
+ *         [ "sh", "/data/local/tmp/art/setup.sh" ]
+ *       ]
+ *    }
+ *  }
+ */
+public class ArtTest implements IRemoteTest, IShardableTest {
+    protected TestInformation mTestInfo;
+    protected File mRunnerDir;
+    protected Map<String, JSONObject> mTests = new TreeMap<String, JSONObject>();
+    protected Set<String> mExecutedTestNames = new HashSet<String>();
+    protected int mShardIndex = 0;
+    protected int mShardCount = 1;
+
+    @Override
+    public void run(TestInformation testInfo, ITestInvocationListener listener)
+            throws DeviceNotAvailableException {
+        mTestInfo = testInfo;
+        File tmp_dir = null;
+        try {
+            try {
+                tmp_dir = FileUtil.createTempDir("art-tf-");
+                mRunnerDir = extractTarBall(tmp_dir);
+                mTests = loadTests();
+            } catch (IOException | JSONException e) {
+                throw new RuntimeException(e);
+            }
+
+            long startTime = System.currentTimeMillis();
+            try {
+                listener.testRunStarted("ArtTest", mTests.size());
+                for (Map.Entry<String, JSONObject> entry : mTests.entrySet()) {
+                    runTest(entry.getKey(), entry.getValue(), listener);
+                }
+            } catch (JSONException e) {
+                listener.testRunFailed(e.toString());
+                throw new RuntimeException(e);
+            } catch (DeviceNotAvailableException e) {
+                listener.testRunFailed(e.toString());
+                throw e;
+            } finally {
+                listener.testRunEnded(
+                        System.currentTimeMillis() - startTime, Collections.emptyMap());
+            }
+        } finally {
+            FileUtil.recursiveDelete(tmp_dir);
+        }
+    }
+
+    File extractTarBall(File dst_dir) throws IOException {
+        File archive = SearchArtifactUtil.searchFile("art-test-target.tgz", false);
+        TarUtil.unTar(TarUtil.unGzip(archive, dst_dir), dst_dir);
+        return new File(dst_dir, "runner");
+    }
+
+    TreeMap<String, JSONObject> loadTests() throws IOException, JSONException {
+        TreeMap<String, JSONObject> allTests = new TreeMap<String, JSONObject>();
+        for (File jsonFile : mRunnerDir.listFiles((d, n) -> n.endsWith(".json"))) {
+            JSONObject jsonData = new JSONObject(FileUtil.readStringFromFile(jsonFile));
+            for (Iterator<String> it = jsonData.keys(); it.hasNext(); ) {
+                String name = it.next();
+                allTests.put(name, jsonData.getJSONObject(name));
+            }
+        }
+
+        TreeMap<String, JSONObject> shardedTests = new TreeMap<String, JSONObject>();
+        Queue<String> dependencyQueue = new ArrayDeque<>();
+
+        // Select tests for this shard based on index modulo shardCount
+        ArrayList<String> sortedTestNames = new ArrayList<>(allTests.keySet());
+        for (int i = 0; i < sortedTestNames.size(); i++) {
+            if (i % mShardCount == mShardIndex) {
+                String testName = sortedTestNames.get(i);
+                shardedTests.put(testName, allTests.get(testName));
+                dependencyQueue.add(testName);
+            }
+        }
+
+        // Include dependencies recursively
+        while (!dependencyQueue.isEmpty()) {
+            String testName = dependencyQueue.remove();
+            JSONObject test = allTests.get(testName);
+            JSONArray dependencies = test.optJSONArray("dependencies");
+            for (int i = 0; dependencies != null && i < dependencies.length(); i++) {
+                String depName = dependencies.getString(i);
+                if (!shardedTests.containsKey(depName)) {
+                    shardedTests.put(depName, allTests.get(depName));
+                    dependencyQueue.add(depName);
+                }
+            }
+        }
+
+        return shardedTests;
+    }
+
+    void runTest(String name, JSONObject test, ITestInvocationListener listener)
+            throws JSONException, DeviceNotAvailableException {
+        if (mExecutedTestNames.contains(name)) {
+            return;
+        }
+        mExecutedTestNames.add(name);
+
+        JSONArray dependencies = test.optJSONArray("dependencies");
+        for (int i = 0; dependencies != null && i < dependencies.length(); i++) {
+            String dep = dependencies.getString(i);
+            runTest(dep, mTests.get(dep), listener);
+        }
+
+        TestDescription testId = TestDescription.fromString(name);
+        try {
+            listener.testStarted(testId);
+            clean(test);
+            adbPush(test);
+            String error = adbShell(test);
+            if (error != null) {
+                listener.testFailed(testId, error);
+            }
+            clean(test);
+        } catch (JSONException | DeviceNotAvailableException e) {
+            listener.testFailed(testId, e.toString());
+            throw e;
+        } finally {
+            listener.testEnded(testId, Collections.emptyMap());
+        }
+    }
+
+    void clean(JSONObject test) throws JSONException, DeviceNotAvailableException {
+        JSONArray cmds = test.optJSONArray("adb push");
+        for (int i = 0; cmds != null && i < cmds.length(); i++) {
+            JSONArray cmd = cmds.getJSONArray(i);
+            if (cmd.length() != 2) {
+                throw new RuntimeException("Invalid adb push command: " + cmd.toString());
+            }
+            String dst = cmd.getString(1);
+
+            ITestDevice device = mTestInfo.getDevice();
+            device.deleteFile(dst);
+        }
+    }
+
+    void adbPush(JSONObject test) throws JSONException, DeviceNotAvailableException {
+        JSONArray cmds = test.optJSONArray("adb push");
+        for (int i = 0; cmds != null && i < cmds.length(); i++) {
+            JSONArray cmd = cmds.getJSONArray(i);
+            if (cmd.length() != 2) {
+                throw new RuntimeException("Invalid adb push command: " + cmd.toString());
+            }
+            File src = new File(mRunnerDir, cmd.getString(0));
+            String dst = cmd.getString(1);
+
+            ITestDevice device = mTestInfo.getDevice();
+            if (src.isDirectory()) {
+                device.pushDir(src, dst);
+            } else {
+                device.pushFile(src, dst);
+            }
+        }
+    }
+
+    String adbShell(JSONObject test) throws JSONException, DeviceNotAvailableException {
+        JSONArray cmds = test.optJSONArray("adb shell");
+        for (int i = 0; cmds != null && i < cmds.length(); i++) {
+            JSONArray args = cmds.getJSONArray(i);
+            StringBuilder cmdBuilder = new StringBuilder();
+            for (int j = 0; j < args.length(); j++) {
+                if (j > 0) {
+                    cmdBuilder.append(" ");
+                }
+                cmdBuilder.append(args.getString(j));
+            }
+            String cmd = cmdBuilder.toString();
+            CLog.i("Executing adb shell command: %s", cmd);
+            CommandResult res = mTestInfo.getDevice().executeShellV2Command(cmd);
+            if (res.getStatus() != CommandStatus.SUCCESS) {
+                CLog.i("Stdout from failed command '%s': %s", cmd, res.getStdout());
+                CLog.e("Stderr from failed command '%s': %s", cmd, res.getStderr());
+                CLog.e("Failed adb shell command: %s", cmd);
+                return res.getStderr();
+            }
+        }
+        return null;
+    }
+
+    @Override
+    public Collection<IRemoteTest> split(int shardCount) {
+        Collection<IRemoteTest> shards = new ArrayList<>(shardCount);
+        for (int i = 0; i < shardCount; i++) {
+            // Clone this class, even if it is derived class (used for testing).
+            ArtTest shard;
+            try {
+                shard = this.getClass().getDeclaredConstructor().newInstance();
+            } catch (InstantiationException
+                    | IllegalAccessException
+                    | InvocationTargetException
+                    | NoSuchMethodException e) {
+                throw new RuntimeException(e);
+            }
+            try {
+                OptionCopier.copyOptions(this, shard);
+            } catch (ConfigurationException e) {
+                CLog.e("failed to copy ART test options: %s", e.getMessage());
+                throw new RuntimeException(e);
+            }
+            shard.mShardIndex = i;
+            shard.mShardCount = shardCount;
+            shards.add(shard);
+        }
+        return shards;
+    }
+}
diff --git a/test_framework/com/android/tradefed/testtype/HostTest.java b/test_framework/com/android/tradefed/testtype/HostTest.java
index c387975cf..297e6d086 100644
--- a/test_framework/com/android/tradefed/testtype/HostTest.java
+++ b/test_framework/com/android/tradefed/testtype/HostTest.java
@@ -201,13 +201,19 @@ public class HostTest
     private ShardUnit mShardUnit = ShardUnit.CLASS;
 
     @Option(
-        name = "enable-pretty-logs",
-        description =
-                "whether or not to enable a logging for each test start and end on both host and "
-                        + "device side."
-    )
+            name = "enable-pretty-logs",
+            description =
+                    "whether or not to enable a logging for each run start and end on both host and"
+                            + " device side.")
     private boolean mEnableHostDeviceLogs = true;
 
+    @Option(
+            name = "enable-pretty-logs-method",
+            description =
+                    "whether or not to enable a logging for each test start and end on both host"
+                            + " and device side.")
+    private boolean mEnableHostDeviceLogsForMethod = false;
+
     @Option(
             name = TestTimeoutEnforcer.TEST_CASE_TIMEOUT_OPTION,
             description = TestTimeoutEnforcer.TEST_CASE_TIMEOUT_DESCRIPTION)
@@ -586,7 +592,9 @@ public class HostTest
 
             // Add a pretty logger to the events to mark clearly start/end of test cases.
             if (mEnableHostDeviceLogs) {
-                PrettyTestEventLogger logger = new PrettyTestEventLogger(mTestInfo.getDevices());
+                PrettyTestEventLogger logger =
+                        new PrettyTestEventLogger(
+                                mTestInfo.getDevices(), mEnableHostDeviceLogsForMethod);
                 listener = new ResultForwarder(logger, listener);
             }
             if (mTestMethods != null) {
diff --git a/test_framework/com/android/tradefed/testtype/InstrumentationListener.java b/test_framework/com/android/tradefed/testtype/InstrumentationListener.java
index defcf9363..5c200f778 100644
--- a/test_framework/com/android/tradefed/testtype/InstrumentationListener.java
+++ b/test_framework/com/android/tradefed/testtype/InstrumentationListener.java
@@ -63,8 +63,8 @@ final class InstrumentationListener extends LogcatCrashResultForwarder {
     private final Collection<TestDescription> mExpectedTests;
     private boolean mDisableDuplicateCheck = false;
     private boolean mReportUnexecutedTests = false;
+    private boolean mUnexecutedTestsReported = false;
     private ProcessInfo mSystemServerProcess = null;
-    private String runLevelError = null;
     private TestDescription mLastTest = null;
     private TestDescription mLastStartedTest = null;
 
@@ -104,7 +104,7 @@ final class InstrumentationListener extends LogcatCrashResultForwarder {
 
     @Override
     public void testRunStarted(String runName, int testCount) {
-        runLevelError = null;
+        mUnexecutedTestsReported = false;
         // In case of crash, run will attempt to report with 0
         if (testCount == 0 && mExpectedTests != null && !mExpectedTests.isEmpty()) {
             CLog.e("Run reported 0 tests while we collected %s", mExpectedTests.size());
@@ -203,8 +203,10 @@ final class InstrumentationListener extends LogcatCrashResultForwarder {
             error.setFailureStatus(FailureStatus.TEST_FAILURE);
             error.setErrorIdentifier(InfraErrorIdentifier.EXPECTED_TESTS_MISMATCH);
         }
-        // Use error before injecting the crashes
-        runLevelError = error.getErrorMessage();
+        String runLevelError =
+                String.format("Run level error reported reason: '%s", error.getErrorMessage());
+        reportUnexecutedTestsIfNeeded(runLevelError);
+        mUnexecutedTestsReported = true;
         super.testRunFailed(error);
     }
 
@@ -222,7 +224,18 @@ final class InstrumentationListener extends LogcatCrashResultForwarder {
             error.setFailureStatus(FailureStatus.TEST_FAILURE)
                     .setRetriable(false); // Don't retry duplicate tests.
             super.testRunFailed(error);
-        } else if (mReportUnexecutedTests
+        } else {
+            String runLevelError = "Method was expected to run but didn't.";
+            reportUnexecutedTestsIfNeeded(runLevelError);
+            mUnexecutedTestsReported = true;
+        }
+        mClassAssumptionFailure = new HashMap<String, String>();
+        super.testRunEnded(elapsedTime, runMetrics);
+    }
+
+    private void reportUnexecutedTestsIfNeeded(String runLevelError) {
+        if (mReportUnexecutedTests
+                && !mUnexecutedTestsReported
                 && mExpectedTests != null
                 && (mExpectedTests.size() > mTests.size() || !mExpectedTests.isEmpty())) {
             Set<TestDescription> missingTests = new LinkedHashSet<>(mExpectedTests);
@@ -233,12 +246,6 @@ final class InstrumentationListener extends LogcatCrashResultForwarder {
             if (lastTest != null) {
                 lastExecutedLog = "Last executed test was " + lastTest.toString() + ".";
             }
-            if (runLevelError == null) {
-                runLevelError = "Method was expected to run but didn't.";
-            } else {
-                runLevelError =
-                        String.format("Run level error reported reason: '%s", runLevelError);
-            }
             for (TestDescription miss : missingTests) {
                 super.testStarted(miss);
                 if (mClassAssumptionFailure.containsKey(miss.getClassName())) {
@@ -256,8 +263,5 @@ final class InstrumentationListener extends LogcatCrashResultForwarder {
                 super.testEnded(miss, new HashMap<String, Metric>());
             }
         }
-        runLevelError = null;
-        mClassAssumptionFailure = new HashMap<String, String>();
-        super.testRunEnded(elapsedTime, runMetrics);
     }
 }
diff --git a/test_framework/com/android/tradefed/testtype/InstrumentationTest.java b/test_framework/com/android/tradefed/testtype/InstrumentationTest.java
index 4d4f1fbce..998f0cedc 100644
--- a/test_framework/com/android/tradefed/testtype/InstrumentationTest.java
+++ b/test_framework/com/android/tradefed/testtype/InstrumentationTest.java
@@ -109,6 +109,7 @@ public class InstrumentationTest
     public static final String RUN_TESTS_AS_USER_KEY = "RUN_TESTS_AS_USER";
     public static final String RUN_TESTS_ON_SDK_SANDBOX = "RUN_TESTS_ON_SDK_SANDBOX";
     private static final String SKIP_TESTS_REASON_KEY = "skip-tests-reason";
+    private static final String SAFE_PUNCTUATION = "@%-_+:,./";
 
     @Option(
             name = "package",
@@ -902,7 +903,29 @@ public class InstrumentationTest
             runner.setRunName(mRunName);
         }
         for (Map.Entry<String, String> argEntry : mInstrArgMap.entrySet()) {
-            runner.addInstrumentationArg(argEntry.getKey(), argEntry.getValue());
+            runner.addInstrumentationArg(argEntry.getKey(), parseShellSyntax(argEntry.getValue()));
+        }
+    }
+
+    /** Helper method parse the shell syntax */
+    private String parseShellSyntax(String value) {
+        if (value == null || value.isBlank()) {
+            return "''";
+        }
+        boolean needsQuoting =
+                value.chars()
+                        .anyMatch(
+                                c ->
+                                        !Character.isLetterOrDigit(c)
+                                                && SAFE_PUNCTUATION.indexOf(c) == -1);
+
+        if (needsQuoting) {
+            // If the value needs quoting, we escape any single quotes within it.
+            final String escapedValue = value.replace("'", "'\\''");
+            return "'" + escapedValue + "'";
+        } else {
+            // If the value contains no shell syntax, simply return it unquoted.
+            return value;
         }
     }
 
diff --git a/test_framework/com/android/tradefed/testtype/IsolatedHostTest.java b/test_framework/com/android/tradefed/testtype/IsolatedHostTest.java
index 5f87d4249..fb2bbf015 100644
--- a/test_framework/com/android/tradefed/testtype/IsolatedHostTest.java
+++ b/test_framework/com/android/tradefed/testtype/IsolatedHostTest.java
@@ -20,11 +20,13 @@ import static com.android.tradefed.util.EnvironmentVariableUtil.buildMinimalLdLi
 import com.android.tradefed.build.BuildInfoKey.BuildInfoFileKey;
 import com.android.tradefed.build.IBuildInfo;
 import com.android.tradefed.cache.ICacheClient;
+import com.android.tradefed.config.ConfigurationException;
 import com.android.tradefed.config.IConfiguration;
 import com.android.tradefed.config.IConfigurationReceiver;
 import com.android.tradefed.config.Option;
 import com.android.tradefed.config.Option.Importance;
 import com.android.tradefed.config.OptionClass;
+import com.android.tradefed.config.OptionCopier;
 import com.android.tradefed.device.DeviceNotAvailableException;
 import com.android.tradefed.error.HarnessRuntimeException;
 import com.android.tradefed.invoker.TestInformation;
@@ -70,6 +72,7 @@ import java.time.Duration;
 import java.time.Instant;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collection;
 import java.util.Comparator;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -78,6 +81,8 @@ import java.util.List;
 import java.util.Set;
 import java.util.TreeSet;
 import java.util.concurrent.TimeUnit;
+import java.util.function.Predicate;
+import java.util.regex.Pattern;
 import java.util.stream.Collectors;
 
 /**
@@ -96,7 +101,8 @@ public class IsolatedHostTest
                 ITestAnnotationFilterReceiver,
                 ITestFilterReceiver,
                 IConfigurationReceiver,
-                ITestCollector {
+                ITestCollector,
+                IShardableTest {
     @Option(
             name = "class",
             description =
@@ -230,6 +236,9 @@ public class IsolatedHostTest
 
     private boolean mCached = false;
 
+    private int mTotalShards = 0;
+    private int mShardIndex = 0;
+
     public void setDebug(boolean debug) {
         this.debug = debug;
     }
@@ -281,6 +290,9 @@ public class IsolatedHostTest
             if (mRavenwoodResources) {
                 runner.setEnvVariable("LANG", mRavenwoodLocale);
                 runner.setEnvVariable("LC_ALL", mRavenwoodLocale);
+                runner.setEnvVariable(
+                        "RAVENWOOD_RUNTIME_DIR",
+                        getRavenwoodRuntimeDir(findTestDirectory()).getAbsolutePath() + "/");
             }
 
             runner.setWorkingDir(mWorkDir);
@@ -295,7 +307,9 @@ public class IsolatedHostTest
                             .addAllTestClasses(new TreeSet<>(mClasses))
                             .addAllTestJarAbsPaths(testJarAbsPaths)
                             .addAllExcludePaths(new TreeSet<>(mExcludePaths))
-                            .setDryRun(mCollectTestsOnly);
+                            .setDryRun(mCollectTestsOnly)
+                            .setTotalShards(mTotalShards)
+                            .setShardIndex(mShardIndex);
 
             if (!mIncludeFilters.isEmpty()
                     || !mExcludeFilters.isEmpty()
@@ -440,8 +454,11 @@ public class IsolatedHostTest
             cmdArgs.addAll(compileRobolectricOptions(artifactsDir));
         }
         if (mRavenwoodResources) {
-            // For the moment, swap in the default JUnit upstream runner
-            cmdArgs.add("-Dandroid.junit.runner=org.junit.runners.JUnit4");
+            // Set the runtime path.
+            cmdArgs.add(
+                    "-Dandroid.ravenwood.runtime_path="
+                            + getRavenwoodRuntimeDir(findTestDirectory()).getAbsolutePath()
+                            + "/");
         }
 
         if (this.debug) {
@@ -571,6 +588,9 @@ public class IsolatedHostTest
             Arrays.asList(mClasspathOverride.split(java.io.File.pathSeparator)).stream()
                     .forEach(p -> paths.add(new File(p)));
         } else {
+            // The jar files that should be put after the test jar in the classpath.
+            List<File> jarsAfterTest = new ArrayList<>();
+
             if (mRobolectricResources) {
                 // This is contingent on the current android-all version.
                 File androidAllJar = FileUtil.findFile(testDir, mAndroidAllName);
@@ -581,23 +601,50 @@ public class IsolatedHostTest
                 }
                 paths.add(androidAllJar);
             } else if (mRavenwoodResources) {
-                addAllFilesUnder(paths, getRavenwoodRuntimeDir(testDir));
+                // Find all the jars in the runtime dir.
+                Set<File> runtimeJars = getJarFilesUnder(getRavenwoodRuntimeDir(testDir));
+
+                // We have a lot of jar files in "ravenwood-runtime"
+                // (see frameworks/base/ravenwood/Android.bp), and almost all of them should
+                // be put before the test jar to prevent the test jar from overriding them.
+                // However, some of them are used as sort of "fallback", and we _do_ want to
+                // let the test jar to override them.
+                // We use this special naming prefix for them ("z" + digits) to control it.
+                var lowPrioJarMatcher = Pattern.compile("^z\\d+");
+
+                Predicate<File> lowPrioJarFilter =
+                        (file) -> lowPrioJarMatcher.matcher(file.getName()).find();
+
+                // Add the high-prio ones to the classpath.
+                paths.addAll(runtimeJars.stream().filter(lowPrioJarFilter.negate()).toList());
+
+                // Keep the low-prio ones here, so we'll add them later.
+                jarsAfterTest.addAll(runtimeJars.stream().filter(lowPrioJarFilter).toList());
             }
 
             for (String jar : mJars) {
                 File f = FileUtil.findFile(testDir, jar);
                 if (f != null && f.exists()) {
                     paths.add(f);
-                    addAllFilesUnder(paths, f.getParentFile());
+                    addJarFilesUnder(paths, f.getParentFile());
                 }
             }
+
+            paths.addAll(jarsAfterTest);
         }
 
         return paths;
     }
 
+    /** Returns an ordered set containing all the jar files under a given directory. */
+    private static Set<File> getJarFilesUnder(File parentDirectory) {
+        Set<File> paths = new LinkedHashSet<>();
+        addJarFilesUnder(paths, parentDirectory);
+        return paths;
+    }
+
     /** Add all files under {@code File} sorted by filename to {@code paths}. */
-    private static void addAllFilesUnder(Set<File> paths, File parentDirectory) {
+    private static void addJarFilesUnder(Set<File> paths, File parentDirectory) {
         var files = parentDirectory.listFiles((f) -> f.isFile() && f.getName().endsWith(".jar"));
         Arrays.sort(files, Comparator.comparing(File::getName));
 
@@ -996,6 +1043,42 @@ public class IsolatedHostTest
         return mConfig != null && mConfig.getCoverageOptions().isCoverageEnabled();
     }
 
+    /** {@inheritDoc} */
+    @Override
+    public Collection<IRemoteTest> split(int shardCount) {
+        if (shardCount < 2) {
+            return null;
+        }
+        CLog.v("The shardCound is: %s", shardCount);
+        Collection<IRemoteTest> shards = new ArrayList<>(shardCount);
+        for (int index = 0; index < shardCount; index++) {
+            shards.add(getTestShard(shardCount, index));
+        }
+        return shards;
+    }
+
+    private IRemoteTest getTestShard(int shardCount, int shardIndex) {
+        IsolatedHostTest shard = new IsolatedHostTest();
+        try {
+            OptionCopier.copyOptions(this, shard);
+        } catch (ConfigurationException e) {
+            CLog.e("Failed to copy IsolatedHostTest options: %s", e.getMessage());
+        }
+        shard.mShardIndex = shardIndex;
+        shard.mTotalShards = shardCount;
+        shard.mIncludeFilters.addAll(mIncludeFilters);
+        shard.mExcludeFilters.addAll(mExcludeFilters);
+        shard.mConfig = mConfig;
+        shard.mBuildInfo = mBuildInfo;
+        shard.mCollectTestsOnly = mCollectTestsOnly;
+        return shard;
+    }
+
+    void setClassName(String className) {
+        mClasses.clear();
+        mClasses.add(className);
+    }
+
     /** {@inheritDoc} */
     @Override
     public void setBuild(IBuildInfo build) {
diff --git a/test_framework/com/android/tradefed/testtype/OWNERS b/test_framework/com/android/tradefed/testtype/OWNERS
new file mode 100644
index 000000000..157907b25
--- /dev/null
+++ b/test_framework/com/android/tradefed/testtype/OWNERS
@@ -0,0 +1 @@
+per-file Art*=dsrbecky@google.com,ngeoffray@google.com
\ No newline at end of file
diff --git a/test_framework/com/android/tradefed/testtype/PythonUnitTestResultParser.java b/test_framework/com/android/tradefed/testtype/PythonUnitTestResultParser.java
index dc7a74857..43f3264de 100644
--- a/test_framework/com/android/tradefed/testtype/PythonUnitTestResultParser.java
+++ b/test_framework/com/android/tradefed/testtype/PythonUnitTestResultParser.java
@@ -454,8 +454,17 @@ public class PythonUnitTestResultParser extends MultiLineReceiver {
     private void reportToListeners() {
         for (ITestInvocationListener listener : mListeners) {
             listener.testRunStarted(mRunName, mTotalTestCount);
-
+            boolean testRunFailed = false;
+            String errorMsg = null;
             for (Entry<TestDescription, String> test : mTestResultCache.entrySet()) {
+                if (test.getValue() != null
+                        && !SKIPPED_ENTRY.equals(test.getValue())
+                        && !test.getKey().getTestName().startsWith("test")) {
+                    // report non-test failures as test run failure
+                    testRunFailed = true;
+                    errorMsg = test.getValue();
+                    continue;
+                }
                 listener.testStarted(test.getKey());
                 if (SKIPPED_ENTRY.equals(test.getValue())) {
                     listener.testIgnored(test.getKey());
@@ -464,6 +473,9 @@ public class PythonUnitTestResultParser extends MultiLineReceiver {
                 }
                 listener.testEnded(test.getKey(), new HashMap<String, Metric>());
             }
+            if (testRunFailed) {
+                listener.testRunFailed(errorMsg);
+            }
             listener.testRunEnded(mTotalElapsedTime, new HashMap<String, Metric>());
         }
     }
diff --git a/test_framework/com/android/tradefed/testtype/UiAutomatorRunner.java b/test_framework/com/android/tradefed/testtype/UiAutomatorRunner.java
index 487b960ef..187e12c6c 100644
--- a/test_framework/com/android/tradefed/testtype/UiAutomatorRunner.java
+++ b/test_framework/com/android/tradefed/testtype/UiAutomatorRunner.java
@@ -22,8 +22,8 @@ import com.android.ddmlib.ShellCommandUnresponsiveException;
 import com.android.ddmlib.TimeoutException;
 import com.android.ddmlib.testrunner.IRemoteAndroidTestRunner;
 import com.android.ddmlib.testrunner.ITestRunListener;
-import com.android.ddmlib.testrunner.InstrumentationResultParser;
 import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.result.ddmlib.InstrumentationResultParser;
 import com.android.tradefed.util.ArrayUtil;
 
 import java.io.IOException;
diff --git a/test_framework/com/android/tradefed/testtype/UiAutomatorTest.java b/test_framework/com/android/tradefed/testtype/UiAutomatorTest.java
index 0b1fd0560..8391262e1 100644
--- a/test_framework/com/android/tradefed/testtype/UiAutomatorTest.java
+++ b/test_framework/com/android/tradefed/testtype/UiAutomatorTest.java
@@ -18,7 +18,6 @@ package com.android.tradefed.testtype;
 
 import com.android.ddmlib.FileListingService;
 import com.android.ddmlib.testrunner.IRemoteAndroidTestRunner;
-import com.android.ddmlib.testrunner.RemoteAndroidTestRunner;
 import com.android.tradefed.config.Option;
 import com.android.tradefed.device.DeviceNotAvailableException;
 import com.android.tradefed.device.IFileEntry;
@@ -32,6 +31,7 @@ import com.android.tradefed.result.ITestLifeCycleReceiver;
 import com.android.tradefed.result.InputStreamSource;
 import com.android.tradefed.result.LogDataType;
 import com.android.tradefed.result.TestDescription;
+import com.android.tradefed.result.ddmlib.RemoteAndroidTestRunner;
 import com.android.tradefed.util.FileUtil;
 import com.android.tradefed.util.IRunUtil;
 import com.android.tradefed.util.RunUtil;
diff --git a/test_framework/com/android/tradefed/testtype/binary/ExecutableTargetTest.java b/test_framework/com/android/tradefed/testtype/binary/ExecutableTargetTest.java
index 1937fe94f..27501ce5b 100644
--- a/test_framework/com/android/tradefed/testtype/binary/ExecutableTargetTest.java
+++ b/test_framework/com/android/tradefed/testtype/binary/ExecutableTargetTest.java
@@ -154,10 +154,18 @@ public class ExecutableTargetTest extends ExecutableBaseTest implements IDeviceT
         if (mDevice == null) {
             throw new IllegalArgumentException("Device has not been set");
         }
-        CommandResult result =
-                mDevice.executeShellV2Command(
-                        binaryPath, getTimeoutPerBinaryMs(), TimeUnit.MILLISECONDS);
-        checkCommandResult(result, listener, description);
+        try {
+            CommandResult result =
+                    mDevice.executeShellV2Command(
+                            binaryPath,
+                            getTimeoutPerBinaryMs(),
+                            TimeUnit.MILLISECONDS,
+                            0 /* No retry at that level */);
+            checkCommandResult(result, listener, description);
+        } catch (DeviceNotAvailableException dnae) {
+            listener.testRunFailed(dnae.getMessage());
+            throw dnae;
+        }
     }
 
     /**
diff --git a/test_framework/com/android/tradefed/testtype/host/PrettyTestEventLogger.java b/test_framework/com/android/tradefed/testtype/host/PrettyTestEventLogger.java
index ac5164a5f..371d3c37d 100644
--- a/test_framework/com/android/tradefed/testtype/host/PrettyTestEventLogger.java
+++ b/test_framework/com/android/tradefed/testtype/host/PrettyTestEventLogger.java
@@ -23,6 +23,7 @@ import com.android.tradefed.device.StubDevice;
 import com.android.tradefed.device.TestDeviceState;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
+import com.android.tradefed.result.FailureDescription;
 import com.android.tradefed.result.ITestInvocationListener;
 import com.android.tradefed.result.TestDescription;
 
@@ -38,10 +39,28 @@ public class PrettyTestEventLogger implements ITestInvocationListener {
 
     private static final String TAG = "TradefedEventsTag";
     private final List<ITestDevice> mDevices;
+    private final boolean mMethodLevel;
     private String mTrace = null;
+    private String mRunTrace = null;
 
-    public PrettyTestEventLogger(List<ITestDevice> devices) {
+    public PrettyTestEventLogger(List<ITestDevice> devices, boolean methodLevelLogging) {
         mDevices = devices;
+        mMethodLevel = methodLevelLogging;
+    }
+
+    @Override
+    public void testRunStarted(String runName, int testCount) {
+        if (mMethodLevel) {
+            return;
+        }
+        Date date = new Date();
+        mRunTrace = null;
+        String message =
+                String.format(
+                        "==================== %s RUN STARTED: %s ====================",
+                        runName, date.toString());
+        CLog.logAndDisplay(LogLevel.DEBUG, "\n" + message);
+        logOnAllDevices(message);
     }
 
     @Override
@@ -53,12 +72,21 @@ public class PrettyTestEventLogger implements ITestInvocationListener {
                         "==================== %s STARTED: %s ====================",
                         test.toString(), date.toString());
         CLog.logAndDisplay(LogLevel.DEBUG, "\n" + message);
-        logOnAllDevices(message);
+        if (mMethodLevel) {
+            logOnAllDevices(message);
+        }
     }
 
     @Override
     public void testFailed(TestDescription test, String trace) {
         mTrace = trace;
+        mRunTrace = trace;
+    }
+
+    @Override
+    public void testFailed(TestDescription test, FailureDescription failure) {
+        mTrace = failure.getErrorMessage();
+        mRunTrace = failure.getErrorMessage();
     }
 
     @Override
@@ -74,6 +102,26 @@ public class PrettyTestEventLogger implements ITestInvocationListener {
             CLog.d("Skip logging device side, device was unavailable.");
             return;
         }
+        if (mMethodLevel) {
+            logOnAllDevices(message);
+        }
+    }
+
+    @Override
+    public void testRunEnded(long elapsedTimeMillis, HashMap<String, Metric> runMetrics) {
+        if (mMethodLevel) {
+            return;
+        }
+        Date date = new Date();
+        String message =
+                String.format(
+                        "==================== RUN ENDED: %s ====================", date.toString());
+        CLog.logAndDisplay(LogLevel.DEBUG, "\n" + message);
+        if (mRunTrace != null
+                && mRunTrace.contains(DeviceNotAvailableException.class.getCanonicalName())) {
+            CLog.d("Skip logging device side, device was unavailable.");
+            return;
+        }
         logOnAllDevices(message);
     }
 
diff --git a/test_framework/com/android/tradefed/testtype/mobly/MoblyArtifactReporter.java b/test_framework/com/android/tradefed/testtype/mobly/MoblyArtifactReporter.java
new file mode 100644
index 000000000..6597b5a5a
--- /dev/null
+++ b/test_framework/com/android/tradefed/testtype/mobly/MoblyArtifactReporter.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2025 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.tradefed.testtype.mobly;
+
+import com.android.tradefed.result.ITestInvocationListener;
+import com.android.tradefed.result.FileInputStreamSource;
+import com.android.tradefed.result.InputStreamSource;
+import com.android.tradefed.result.LogDataType;
+
+import java.io.File;
+
+/** Mobly artifact reporter. */
+public class MoblyArtifactReporter {
+    private final File mLogDir;
+
+    public MoblyArtifactReporter(File logDir) {
+        mLogDir = logDir;
+    }
+
+    public void reportRunArtifacts(ITestInvocationListener listener) {
+        reportArtifactsForRecord(listener, null);
+    }
+
+    public void reportArtifactsForRecord(
+            ITestInvocationListener listener, MoblyYamlResultRecordHandler.Record record) {
+        reportArtifactsForRecord(mLogDir, listener, record);
+    }
+
+    private void reportArtifactsForRecord(
+            File logDir,
+            ITestInvocationListener listener,
+            MoblyYamlResultRecordHandler.Record record) {
+        for (File subFile : logDir.listFiles()) {
+            if (subFile.isDirectory()) {
+                reportArtifactsForRecord(subFile, listener, record);
+            } else {
+                if (!subFile.exists()) {
+                    continue;
+                }
+
+                if (record != null) {
+                    String absolutePath = subFile.getAbsolutePath();
+                    if (absolutePath != null
+                            && absolutePath.contains(record.getTestClass())
+                            && absolutePath.contains(record.getTestName())) {
+                        reportFile(subFile, listener);
+                    }
+                } else {
+                    reportFile(subFile, listener);
+                }
+            }
+        }
+    }
+
+    private void reportFile(File file, ITestInvocationListener listener) {
+        if (!file.exists()) {
+            return;
+        }
+
+        // Report and delete the file.
+        try (InputStreamSource dataStream = new FileInputStreamSource(file, true)) {
+            String cleanName = file.getName().replace(",", "_");
+            LogDataType type = LogDataType.TEXT;
+            if (cleanName.contains("trace")) {
+                type = LogDataType.PERFETTO;
+            } else if (cleanName.contains("logcat")) {
+                type = LogDataType.LOGCAT;
+            } else if (cleanName.contains("btsnoop")) {
+                type = LogDataType.BT_SNOOP_LOG;
+            } else if (cleanName.contains("mp4")) {
+                type = LogDataType.MP4;
+            } else if (cleanName.contains("bugreport") && cleanName.endsWith("zip")) {
+                type = LogDataType.BUGREPORTZ;
+            } else if (cleanName.endsWith("png")) {
+                type = LogDataType.PNG;
+            }
+
+            listener.testLog(cleanName, type, dataStream);
+        }
+    }
+}
diff --git a/test_framework/com/android/tradefed/testtype/mobly/MoblyBinaryHostTest.java b/test_framework/com/android/tradefed/testtype/mobly/MoblyBinaryHostTest.java
index ae1ecd69d..01f9db154 100644
--- a/test_framework/com/android/tradefed/testtype/mobly/MoblyBinaryHostTest.java
+++ b/test_framework/com/android/tradefed/testtype/mobly/MoblyBinaryHostTest.java
@@ -28,10 +28,7 @@ import com.android.tradefed.invoker.TestInformation;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
 import com.android.tradefed.result.FailureDescription;
-import com.android.tradefed.result.FileInputStreamSource;
 import com.android.tradefed.result.ITestInvocationListener;
-import com.android.tradefed.result.InputStreamSource;
-import com.android.tradefed.result.LogDataType;
 import com.android.tradefed.result.error.TestErrorIdentifier;
 import com.android.tradefed.result.proto.TestRecordProto.FailureStatus;
 import com.android.tradefed.testtype.IBuildReceiver;
@@ -146,6 +143,7 @@ public class MoblyBinaryHostTest
     private ITestDevice mDevice;
     private IBuildInfo mBuildInfo;
     private File mLogDir;
+    private MoblyArtifactReporter mArtifactReporter;
     private TestInformation mTestInfo;
     private IRunUtil mRunUtil;
     private Set<String> mIncludeFilters = new LinkedHashSet<>();
@@ -264,10 +262,16 @@ public class MoblyBinaryHostTest
                 continue;
             }
             parFile.setExecutable(true);
+            MoblyArtifactReporter artifactReporter = getArtifactReporter();
             try {
-                runSingleParFile(parFile.getAbsolutePath(), parFile.getName(), listener);
+                runSingleParFile(
+                        parFile.getAbsolutePath(), parFile.getName(), listener, artifactReporter);
             } finally {
-                reportLogs(getLogDir(), listener);
+                artifactReporter.reportRunArtifacts(listener);
+                // reset log dir and artifact reporter to be recreated for retries
+                FileUtil.recursiveDelete(mLogDir);
+                mLogDir = null;
+                mArtifactReporter = null;
             }
         }
     }
@@ -377,7 +381,10 @@ public class MoblyBinaryHostTest
     }
 
     private void runSingleParFile(
-            String parFilePath, String runName, ITestInvocationListener listener) {
+            String parFilePath,
+            String runName,
+            ITestInvocationListener listener,
+            MoblyArtifactReporter artifactReporter) {
         if (mInjectAndroidSerialVar) {
             getRunUtil().setEnvVariable(ANDROID_SERIAL_VAR, getDevice().getSerialNumber());
         }
@@ -477,7 +484,8 @@ public class MoblyBinaryHostTest
                             return getRunUtil().runTimedCmd(getTestTimeout(), command);
                         },
                         executor);
-        MoblyYamlResultParser parser = new MoblyYamlResultParser(listener, runName, !mListTests);
+        MoblyYamlResultParser parser =
+                new MoblyYamlResultParser(listener, runName, !mListTests, artifactReporter);
         File yamlSummaryFile = null;
         InputStream inputStream = null;
         boolean reportRunFailed = true;
@@ -682,6 +690,14 @@ public class MoblyBinaryHostTest
         return new_filters;
     }
 
+    @VisibleForTesting
+    protected MoblyArtifactReporter getArtifactReporter() {
+        if (mArtifactReporter == null) {
+            mArtifactReporter = new MoblyArtifactReporter(getLogDir());
+        }
+        return mArtifactReporter;
+    }
+
     @VisibleForTesting
     protected String getLogDirAbsolutePath() {
         return getLogDir().getAbsolutePath();
@@ -738,39 +754,6 @@ public class MoblyBinaryHostTest
         return commandLine.toArray(new String[0]);
     }
 
-    @VisibleForTesting
-    protected void reportLogs(File logDir, ITestInvocationListener listener) {
-        for (File subFile : logDir.listFiles()) {
-            if (subFile.isDirectory()) {
-                reportLogs(subFile, listener);
-            } else {
-                if (!subFile.exists()) {
-                    continue;
-                }
-                try (InputStreamSource dataStream = new FileInputStreamSource(subFile, true)) {
-                    String cleanName = subFile.getName().replace(",", "_");
-                    LogDataType type = LogDataType.TEXT;
-                    if (cleanName.contains("trace")) {
-                        type = LogDataType.PERFETTO;
-                    }
-                    if (cleanName.contains("logcat")) {
-                        type = LogDataType.LOGCAT;
-                    }
-                    if (cleanName.contains("btsnoop")) {
-                        type = LogDataType.BT_SNOOP_LOG;
-                    }
-                    if (cleanName.contains("mp4")) {
-                        type = LogDataType.MP4;
-                    }
-                    listener.testLog(cleanName, type, dataStream);
-                }
-            }
-        }
-        FileUtil.recursiveDelete(logDir);
-        // reset log dir to be recreated for retries
-        mLogDir = null;
-    }
-
     @VisibleForTesting
     List<String> getTestOptions() {
         return mTestOptions;
diff --git a/test_framework/com/android/tradefed/testtype/mobly/MoblyYamlResultParser.java b/test_framework/com/android/tradefed/testtype/mobly/MoblyYamlResultParser.java
index 2d45efe79..222bcf54b 100644
--- a/test_framework/com/android/tradefed/testtype/mobly/MoblyYamlResultParser.java
+++ b/test_framework/com/android/tradefed/testtype/mobly/MoblyYamlResultParser.java
@@ -19,6 +19,7 @@ package com.android.tradefed.testtype.mobly;
 import com.android.tradefed.log.LogUtil;
 import com.android.tradefed.result.FailureDescription;
 import com.android.tradefed.result.ITestInvocationListener;
+import com.android.tradefed.result.ResultForwarder;
 import com.android.tradefed.result.TestDescription;
 import com.android.tradefed.result.proto.TestRecordProto;
 import com.android.tradefed.result.skipped.SkipReason;
@@ -52,12 +53,17 @@ public class MoblyYamlResultParser {
     private boolean mEnded;
     private boolean mRunFailed;
     private StringBuilder mYamlString = new StringBuilder();
+    private MoblyArtifactReporter mArtifactReporter;
 
     public MoblyYamlResultParser(
-            ITestInvocationListener listener, String runName, boolean reportRunStart) {
+            ITestInvocationListener listener,
+            String runName,
+            boolean reportRunStart,
+            MoblyArtifactReporter artifactReporter) {
         mListenersBuilder.add(listener);
         mRunName = runName;
         mReportRunStart = reportRunStart;
+        mArtifactReporter = artifactReporter;
     }
 
     public boolean parse(InputStream inputStream)
@@ -65,17 +71,14 @@ public class MoblyYamlResultParser {
                     IllegalAccessException,
                     InstantiationException,
                     IOException {
-        if (mEnded)
-            return mEnded;
+        if (mEnded) return mEnded;
         int available = inputStream.available();
-        if (available == 0)
-            return false;
+        if (available == 0) return false;
         byte[] bytes = new byte[available];
         inputStream.read(bytes);
         mYamlString.append(new String(bytes, 0, available, StandardCharsets.UTF_8));
         int yamlEnd = mYamlString.lastIndexOf("\n...");
-        if (yamlEnd == -1)
-            return false;
+        if (yamlEnd == -1) return false;
         ArrayList<ITestResult> resultCache = new ArrayList<>();
         Yaml yaml = new Yaml(new SafeConstructor(new LoaderOptions()));
         try {
@@ -105,19 +108,27 @@ public class MoblyYamlResultParser {
         return resultHandler.handle(docMap);
     }
 
+    private boolean isTimeout(MoblyYamlResultRecordHandler.Record record) {
+        String stackTrace = record.getStackTrace();
+        return MoblyYamlResultRecordHandler.RecordResult.SKIP.equals(record.getResult())
+                && record.getEndTime() == 0L
+                && stackTrace.contains("timeout")
+                && stackTrace.contains("Test received a SIGTERM.");
+    }
+
     @VisibleForTesting
     protected void reportToListeners(
             List<ITestInvocationListener> listeners,
             List<IMoblyYamlResultHandler.ITestResult> resultCache) {
+        ITestInvocationListener listener = new ResultForwarder(listeners);
+
         for (IMoblyYamlResultHandler.ITestResult result : resultCache) {
             switch (result.getType()) {
                 case TEST_NAME_LIST:
                     if (mReportRunStart) {
                         MoblyYamlResultTestNameListHandler.TestNameList testList =
                                 (MoblyYamlResultTestNameListHandler.TestNameList) result;
-                        for (ITestInvocationListener listener : listeners) {
-                            listener.testRunStarted(mRunName, testList.getTestList().size());
-                        }
+                        listener.testRunStarted(mRunName, testList.getTestList().size());
                     }
                     break;
                 case RECORD:
@@ -133,9 +144,7 @@ public class MoblyYamlResultParser {
                             record.getResult())) {
                         // Non-test failure reports indicates some early failure so we fail the run
                         if (!testDescription.getTestName().startsWith("test_")) {
-                            for (ITestInvocationListener listener : listeners) {
-                                listener.testRunFailed(failureDescription);
-                            }
+                            listener.testRunFailed(failureDescription);
                             mRunFailed = true;
                             continue;
                         }
@@ -145,26 +154,31 @@ public class MoblyYamlResultParser {
                                     ? record.getBeginTime()
                                     : Math.min(mRunStartTime, record.getBeginTime());
                     mRunEndTime = Math.max(mRunEndTime, record.getEndTime());
-                    for (ITestInvocationListener listener : listeners) {
-                        listener.testStarted(testDescription, record.getBeginTime());
-                        if (MoblyYamlResultRecordHandler.RecordResult.SKIP.equals(
-                                record.getResult())) {
-                            // In case of run failed, the most likely is that test did not execute
-                            if (mRunFailed) {
-                                SkipReason reason = new SkipReason(record.getStackTrace(), "");
-                                listener.testSkipped(testDescription, reason);
-                            } else {
-                                listener.testIgnored(testDescription);
-                            }
-                        } else if (!MoblyYamlResultRecordHandler.RecordResult.PASS.equals(
-                                record.getResult())) {
-                            listener.testFailed(testDescription, failureDescription);
+                    listener.testStarted(testDescription, record.getBeginTime());
+                    mArtifactReporter.reportArtifactsForRecord(listener, record);
+                    if (MoblyYamlResultRecordHandler.RecordResult.SKIP.equals(
+                            record.getResult())) {
+                        // In case of run failed, the most likely is that test did not execute
+                        if (mRunFailed) {
+                            SkipReason reason = new SkipReason(record.getStackTrace(), "");
+                            listener.testSkipped(testDescription, reason);
+                        } else if (isTimeout(record)) {
+                            FailureDescription timeoutFailureDescription =
+                                    FailureDescription.create(
+                                            record.getStackTrace(),
+                                            TestRecordProto.FailureStatus.TIMED_OUT);
+                            listener.testFailed(testDescription, timeoutFailureDescription);
+                        } else {
+                            listener.testIgnored(testDescription);
                         }
-                        listener.testEnded(
-                                testDescription,
-                                record.getEndTime(),
-                                new HashMap<String, String>());
+                    } else if (!MoblyYamlResultRecordHandler.RecordResult.PASS.equals(
+                            record.getResult())) {
+                        listener.testFailed(testDescription, failureDescription);
                     }
+                    listener.testEnded(
+                            testDescription,
+                            record.getEndTime(),
+                            new HashMap<String, String>());
                     break;
                 case USER_DATA:
                     long timestamp =
diff --git a/test_framework/com/android/tradefed/testtype/rust/RustTestBase.java b/test_framework/com/android/tradefed/testtype/rust/RustTestBase.java
index 231ceab34..a78adad28 100644
--- a/test_framework/com/android/tradefed/testtype/rust/RustTestBase.java
+++ b/test_framework/com/android/tradefed/testtype/rust/RustTestBase.java
@@ -29,6 +29,7 @@ import com.android.tradefed.testtype.IRemoteTest;
 import com.android.tradefed.testtype.ITestFilterReceiver;
 
 import com.google.common.annotations.VisibleForTesting;
+import com.google.common.base.Strings;
 
 import java.io.File;
 import java.util.ArrayList;
@@ -213,8 +214,12 @@ public abstract class RustTestBase
             CLog.w("b/294857452 -- filters are not yet supported for rust benchmarks");
             return;
         }
-        if (!"".equals(filter)) {
-            args.add(cleanFilter(filter));
+        if (!Strings.isNullOrEmpty(filter)) {
+            if (!filter.contains("#")) {
+                CLog.w("Filter: %s isn't formatted like a method", filter);
+            } else {
+                args.add(cleanFilter(filter));
+            }
         }
         args.add("--exact");
         for (String s : mExcludeFilters) {
diff --git a/test_framework/com/google/android/tradefed/targetprep/GoogleAccountPreparer.java b/test_framework/com/google/android/tradefed/targetprep/GoogleAccountPreparer.java
new file mode 100644
index 000000000..7c36fb017
--- /dev/null
+++ b/test_framework/com/google/android/tradefed/targetprep/GoogleAccountPreparer.java
@@ -0,0 +1,532 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.tradefed.targetprep;
+
+import com.android.tradefed.build.IBuildInfo;
+import com.android.tradefed.config.Option;
+import com.android.tradefed.config.Option.Importance;
+import com.android.tradefed.config.OptionClass;
+import com.android.tradefed.device.DeviceNotAvailableException;
+import com.android.tradefed.device.ITestDevice;
+import com.android.tradefed.invoker.TestInformation;
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.result.error.DeviceErrorIdentifier;
+import com.android.tradefed.result.error.InfraErrorIdentifier;
+import com.android.tradefed.targetprep.BuildError;
+import com.android.tradefed.targetprep.DeviceFailedToBootError;
+import com.android.tradefed.targetprep.ITargetPreparer;
+import com.android.tradefed.targetprep.TargetSetupError;
+import com.android.tradefed.targetprep.WaitForDeviceDatetimePreparer;
+import com.android.tradefed.util.FileUtil;
+import com.android.tradefed.util.SearchArtifactUtil;
+
+import com.google.android.tradefed.util.GoogleAccountUtil;
+
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Random;
+import java.util.Set;
+
+/**
+ * A {@link ITargetPreparer} that supports configuring google accounts. If no account is specified
+ * and gaia account creation is enable, then a gaia account will be created and added to the device.
+ */
+@OptionClass(alias = "google-account")
+public class GoogleAccountPreparer extends WaitForDeviceDatetimePreparer {
+    @Option(
+            name = "initial-wait-time",
+            description =
+                    "initial wait in ms between failed add account attempts. Wait time will"
+                            + " increase quadratically for each attempt")
+    private long mInitialWaitTimeMs = 2000;
+
+    @Option(name = "max-attempts", description = "maximum number of add account attempts.")
+    private int mMaxAttempts = 5;
+
+    @SuppressWarnings("unused") // kept for backwards compatibility
+    @Deprecated
+    @Option(
+            name = "wait-for-data",
+            description =
+                    "wait for data connectivity before adding account."
+                            + " (deprecated, data connection no longer verified here)")
+    private boolean mWaitForData = false;
+
+    @Option(
+            name = "account-name",
+            description = "the full name of Google account to configure.",
+            importance = Importance.IF_UNSET)
+    private String mAccountName = null;
+
+    @Option(
+            name = "account-password",
+            description =
+                    "the password of the Google account "
+                            + "(specified in account-name) to configure.",
+            importance = Importance.IF_UNSET)
+    private String mAccountPassword = null;
+
+    @Option(name = "account-sync", description = "enable sync on Google account.")
+    private boolean mAccountSync = false;
+
+    @Option(
+            name = "use-account-range",
+            description =
+                    "If set, format the provided account name "
+                            + "with a random value from the provided account range.")
+    private boolean mUseAccountRange = false;
+
+    @Option(
+            name = "account-range-start",
+            description = "Lowest number in the range of accounts, inclusive.")
+    private int mAccountRangeStart = 1;
+
+    @Option(
+            name = "account-range-end",
+            description = "Highest number in the range of accounts, inclusive.")
+    private int mAccountRangeEnd = 10;
+
+    @Option(name = "account-blacklist", description = "Blacklisted numbers within range to avoid.")
+    private Set<Integer> mAccountBlacklist = new HashSet<>();
+
+    @Option(
+            name = "wait-for-checkin",
+            description = "wait for checkin to complete after adding Google account.")
+    private boolean mWaitForCheckin = false;
+
+    @Option(
+            name = "sync-then-off",
+            description = "after adding account, allow for sync then turn sync off, in secs")
+    private long mSyncThenOff = 0;
+
+    @Option(name = "remove-accounts", description = "Remove all accounts on test completion")
+    private boolean mRemoveAccounts = false;
+
+    @Option(
+            name = "remove-account",
+            description = "Remove account that was added on test completion")
+    private boolean mRemoveAccount = false;
+
+    @Option(name = "verify-only", description = "Only verify that an account exists on the device")
+    private boolean mVerifyOnly = false;
+
+    @Option(
+            name = "wait-for-sync",
+            description = "Wait for the account to finish all sync operations before proceeding.")
+    private boolean mWaitForSync = false;
+
+    @Option(
+            name = "wait-for-sync-timeout",
+            description = "The timeout associated with wait-for-sync in milliseconds.")
+    private long mWaitForSyncTimeout = 5 * 60 * 1000;
+
+    @Option(
+            name = "wait-for-sync-poll-interval",
+            description = "The polling interval associated with wait-for-sync in milliseconds.")
+    private long mWaitForSyncInterval = 10 * 1000;
+
+    // This is a best-effort option to force a sync on the device that is as complete as possible.
+    // It does not ensure deterministic behavior with regards to ensuring completion of all syncs.
+    @Option(
+            name = "force-account-sync",
+            description = "Force a complete sync of the account on all available sync adapters.")
+    private boolean mForceAccountSync = false;
+
+    @Option(
+            name = "credentials-file",
+            description =
+                    "Json file containing credentaial information that will be used to supply"
+                        + " maching options including: account-name, account-password,"
+                        + " use-account-range, account-range-start, account-range-end,"
+                        + " account-blacklist. All fields in this file are optional. Provided value"
+                        + " will override already set options.")
+    private File mCredentialFile = null;
+
+    @Option(
+            name = "google-account-apk-file",
+            description = "Alternative GoogleAccountUtil.apk to use.")
+    private File mAccountAltApk = null;
+
+    /** {@inheritDoc} */
+    @Override
+    public void setUp(TestInformation testInfo)
+            throws TargetSetupError, DeviceNotAvailableException, BuildError {
+        // don't run this preparer if it's disabled.
+        if (isDisabled()) {
+            return;
+        }
+
+        IBuildInfo buildInfo = testInfo.getBuildInfo();
+
+        processCredentialFile(buildInfo);
+
+        // Infer if we should update the account name to reflect monkey-style.
+        if (mUseAccountRange) {
+            if (mAccountRangeStart >= mAccountRangeEnd) {
+                throw new TargetSetupError("Start of range must be less than end");
+            }
+
+            List<Integer> accountNumbers = new ArrayList<>();
+            for (int i = mAccountRangeStart; i <= mAccountRangeEnd; i++) {
+                if (!mAccountBlacklist.contains(i)) {
+                    accountNumbers.add(i);
+                }
+            }
+
+            if (accountNumbers.isEmpty()) {
+                throw new TargetSetupError("No accounts in range to be added.");
+            }
+
+            int index = new Random().nextInt(accountNumbers.size());
+            mAccountName = String.format(mAccountName, accountNumbers.get(index));
+        }
+
+        ITestDevice device = testInfo.getDevice();
+
+        // Ignore pre-checks and pre-setup if in verify-only mode.
+        if (!mVerifyOnly) {
+            if (mAccountName == null && mAccountPassword == null) {
+                // Keeping the previous behavior for backward compatibility
+                CLog.i("No account name or password specified, skipping GooglePreparer.");
+                return;
+            }
+            // throw for the error state where account name is defined and account password is not
+            if (mAccountName != null && mAccountPassword == null) {
+                throw new TargetSetupError(
+                        "account-password is not defined", device.getDeviceDescriptor());
+            }
+
+            // Force setup errors for preparing Google accounts if the datetime is not properly set,
+            // because a synced datetime is required to successfully add a Google account.
+            setForceSetupError(true);
+
+            buildInfo.addBuildAttribute("account", mAccountName);
+
+            super.setUp(testInfo);
+        }
+
+        if (!GoogleAccountUtil.installUtil(device, mAccountAltApk)) {
+            throw new TargetSetupError(
+                    String.format(
+                            "Failed to install account util on device %s",
+                            device.getSerialNumber()),
+                    device.getDeviceDescriptor(),
+                    DeviceErrorIdentifier.APK_INSTALLATION_FAILED);
+        }
+
+        try {
+            if (mVerifyOnly) {
+                if (GoogleAccountUtil.hasAccount(device, device.getPrimaryUserId())) {
+                    return;
+                } else {
+                    throw new TargetSetupError(
+                            "Unable to verify any accounts on device.",
+                            device.getDeviceDescriptor(),
+                            InfraErrorIdentifier.GOOGLE_ACCOUNT_SETUP_FAILED);
+                }
+            }
+
+            // remove accounts first just in case
+            if (mRemoveAccounts
+                    && !GoogleAccountUtil.removeAccountAttempt(
+                            device, device.getPrimaryUserId(), mAccountName)) {
+                throw new TargetSetupError(
+                        String.format(
+                                "Failed to remove accounts on device %s", device.getSerialNumber()),
+                        device.getDeviceDescriptor(),
+                        InfraErrorIdentifier.GOOGLE_ACCOUNT_SETUP_FAILED);
+            }
+
+            if (!addAccount(device)) {
+                throw new TargetSetupError(
+                        String.format(
+                                "Failed to add account %s on device %s after %d attempts",
+                                mAccountName, device.getSerialNumber(), mMaxAttempts),
+                        device.getDeviceDescriptor(),
+                        InfraErrorIdentifier.GOOGLE_ACCOUNT_SETUP_FAILED);
+            }
+
+            if (mWaitForSync
+                    && !GoogleAccountUtil.waitForAccountSync(
+                            device,
+                            device.getPrimaryUserId(),
+                            mWaitForSyncInterval,
+                            mWaitForSyncTimeout,
+                            mForceAccountSync)) {
+                CLog.w("Not all sync operations are completed before continuing.");
+            }
+        } finally {
+            GoogleAccountUtil.uninstallUtil(device);
+        }
+    }
+
+    /** Sets the Google account to create. */
+    public void setAccount(String accountName, String accountPassword) {
+        mAccountName = accountName;
+        mAccountPassword = accountPassword;
+    }
+
+    /** Sets whether to enable sync on the account */
+    public void setAccountSync(boolean value) {
+        mAccountSync = value;
+    }
+
+    /** Sets whether to wait for checkin to complete after adding account */
+    public void setWaitForCheckin(boolean value) {
+        mWaitForCheckin = value;
+    }
+
+    /** Sets whether to enable sync on the account */
+    public void setSyncThenOff(long syncThenOff) {
+        mSyncThenOff = syncThenOff;
+    }
+
+    /**
+     * Add account specified in options to device, attempting multiple times if necessary. Does
+     * nothing if no account is specified.
+     *
+     * <p>Exposed for unit testing.
+     *
+     * @param device the {@link ITestDevice}
+     * @return <code>true</code> if account was created successfully, <code>false</code> otherwise
+     * @throws TargetSetupError
+     */
+    boolean addAccount(ITestDevice device) throws DeviceNotAvailableException, TargetSetupError {
+        CLog.i("Adding account %s on device %s", mAccountName, device.getSerialNumber());
+        for (int i = 0; i < mMaxAttempts; i++) {
+            if (GoogleAccountUtil.addAccountAttempt(
+                    device,
+                    device.getPrimaryUserId(),
+                    mAccountName,
+                    mAccountPassword,
+                    mAccountSync,
+                    mWaitForCheckin)) {
+                if (mSyncThenOff != 0 && mAccountSync) {
+                    // if sync and off is set and the sync is On on the account
+                    if (!GoogleAccountUtil.syncAndOff(
+                            device, device.getPrimaryUserId(), mAccountName, mSyncThenOff)) {
+                        CLog.w("Failed to turn off sync");
+                    }
+                }
+                return true;
+            }
+
+            // pause a short, escalating time before retrying
+            long increaseFactor = (long) Math.pow(2, i);
+            getRunUtil().sleep(mInitialWaitTimeMs * increaseFactor);
+        }
+
+        return false;
+    }
+
+    /** {@inheritDoc} */
+    @Override
+    public void tearDown(TestInformation testInfo, Throwable e) throws DeviceNotAvailableException {
+        if (isDisabled() || mVerifyOnly) {
+            return;
+        }
+        if (e instanceof DeviceNotAvailableException || e instanceof DeviceFailedToBootError) {
+            return;
+        }
+        if (mAccountName == null && mAccountPassword == null) {
+            return;
+        }
+        removeAccount(testInfo.getDevice());
+    }
+
+    /**
+     * Remove the account from the device provided. Remove all accounts from the device if
+     * --remove-accounts flag is on.
+     *
+     * @param device target to remove the account(s)
+     * @throws DeviceNotAvailableException
+     */
+    void removeAccount(ITestDevice device) throws DeviceNotAvailableException {
+        if (mRemoveAccounts || mRemoveAccount) {
+            if (!GoogleAccountUtil.installUtil(device, mAccountAltApk)) {
+                // cannot remove accounts! Bad things may happen, just remove device from queue for
+                // now
+                throw new DeviceNotAvailableException(
+                        String.format(
+                                "Failed to install account util on device %s",
+                                device.getSerialNumber()),
+                        device.getSerialNumber(),
+                        DeviceErrorIdentifier.APK_INSTALLATION_FAILED);
+            }
+            try {
+                if (mRemoveAccounts) {
+                    if (!GoogleAccountUtil.removeAllAccountAttempt(
+                            device, device.getPrimaryUserId())) {
+                        // cannot remove accounts! Bad things may happen
+                        // just remove device from queue for now
+                        throw new DeviceNotAvailableException(
+                                String.format(
+                                        "Failed to remove accounts on device %s",
+                                        device.getSerialNumber()),
+                                device.getSerialNumber(),
+                                InfraErrorIdentifier.GOOGLE_ACCOUNT_SETUP_FAILED);
+                    }
+                } else {
+                    if (mRemoveAccount) {
+                        if (!GoogleAccountUtil.removeAccountAttempt(
+                                device, device.getPrimaryUserId(), mAccountName)) {
+                            // cannot remove accounts! Bad things may happen
+                            // just remove device from queue for now
+                            throw new DeviceNotAvailableException(
+                                    String.format(
+                                            "Failed to remove accounts on device %s",
+                                            device.getSerialNumber()),
+                                    device.getSerialNumber(),
+                                    InfraErrorIdentifier.GOOGLE_ACCOUNT_SETUP_FAILED);
+                        }
+                    }
+                }
+            } finally {
+                GoogleAccountUtil.uninstallUtil(device);
+            }
+        }
+    }
+
+    void setRemoveAccount(boolean b) {
+        mRemoveAccount = b;
+    }
+
+    protected String getAccountName() {
+        return mAccountName;
+    }
+
+    protected String getAccountPassword() {
+        return mAccountPassword;
+    }
+
+    protected File getCredentialFile() {
+        return mCredentialFile;
+    }
+
+    protected void setCredentialFile(File file) {
+        mCredentialFile = file;
+    }
+
+    protected boolean getUseAccountRange() {
+        return mUseAccountRange;
+    }
+
+    protected int getAccountRangeStart() {
+        return mAccountRangeStart;
+    }
+
+    protected int getAccountRangeEnd() {
+        return mAccountRangeEnd;
+    }
+
+    protected Set<Integer> getAccountBlacklist() {
+        return mAccountBlacklist;
+    }
+
+    protected void processCredentialFile(IBuildInfo buildInfo) throws TargetSetupError {
+        if (mCredentialFile == null) {
+            return; // Skip if no credential file was provided.
+        }
+
+        if (!mCredentialFile.isAbsolute()) {
+            mCredentialFile = resolveRelativeFilePath(buildInfo, mCredentialFile.getPath());
+        }
+
+        if (!mCredentialFile.exists() || !mCredentialFile.canRead()) {
+            throw new TargetSetupError("Credential file could not be accessed.");
+        }
+
+        // Override options specified in the credential file.
+        JSONObject credentialJson = loadCredentialsFromFile(mCredentialFile);
+        Iterator<String> credentialsIterator = credentialJson.keys();
+        try {
+            while (credentialsIterator.hasNext()) {
+                String optionName = credentialsIterator.next();
+                switch (optionName) {
+                    case "account-name":
+                        String accountName = credentialJson.getString(optionName);
+                        mAccountName = accountName;
+                        break;
+                    case "account-password":
+                        String accountPassword = credentialJson.getString(optionName);
+                        mAccountPassword = accountPassword;
+                        break;
+                    case "use-account-range":
+                        Boolean useAccountRange = credentialJson.getBoolean(optionName);
+                        mUseAccountRange = useAccountRange;
+                        break;
+                    case "account-range-start":
+                        int accountRangeStart = credentialJson.getInt(optionName);
+                        mAccountRangeStart = accountRangeStart;
+                        break;
+                    case "account-range-end":
+                        int accountRangeEnd = credentialJson.getInt(optionName);
+                        mAccountRangeEnd = accountRangeEnd;
+                        break;
+                    case "account-blacklist":
+                        Set<Integer> accountBlacklist = new HashSet<>();
+                        JSONArray accountBlacklistArray = credentialJson.getJSONArray(optionName);
+                        for (int i = 0; i < accountBlacklistArray.length(); i++) {
+                            accountBlacklist.add(accountBlacklistArray.getInt(i));
+                        }
+                        mAccountBlacklist = accountBlacklist;
+                        break;
+                    default:
+                        throw new TargetSetupError(
+                                String.format("Unrecognized credential key: %s", optionName));
+                }
+            }
+        } catch (JSONException e) {
+            // Error meesage not included to avoid leaking password in the logs.
+            throw new TargetSetupError("Invalid data format in JSON file.");
+        }
+    }
+
+    protected JSONObject loadCredentialsFromFile(File file) throws TargetSetupError {
+        JSONObject credentialJson = null;
+        try {
+            String data = FileUtil.readStringFromFile(file);
+            credentialJson = new JSONObject(data);
+        } catch (IOException e) {
+            throw new TargetSetupError(
+                    String.format("Failed to read JSON key file %s: %s", file.toString(), e));
+        } catch (JSONException e) {
+            throw new TargetSetupError(
+                    String.format("Failed to parse JSON data from file %s", file.toString()), e);
+        }
+        return credentialJson;
+    }
+
+    protected File resolveRelativeFilePath(IBuildInfo buildInfo, String fileName)
+            throws TargetSetupError {
+        File fileAbsPaths;
+        try {
+            fileAbsPaths = SearchArtifactUtil.searchFile(fileName, false);
+        } catch (Exception e) {
+            throw new TargetSetupError(
+                    String.format("Could not located the file: %s.", fileName), e);
+        }
+        return fileAbsPaths;
+    }
+}
diff --git a/test_framework/com/google/android/tradefed/util/GoogleAccountUtil.java b/test_framework/com/google/android/tradefed/util/GoogleAccountUtil.java
new file mode 100644
index 000000000..f8a1f5cec
--- /dev/null
+++ b/test_framework/com/google/android/tradefed/util/GoogleAccountUtil.java
@@ -0,0 +1,432 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.tradefed.util;
+
+import com.android.tradefed.device.DeviceNotAvailableException;
+import com.android.tradefed.device.ITestDevice;
+import com.android.tradefed.log.LogUtil.CLog;
+import com.android.tradefed.util.FileUtil;
+import com.android.tradefed.util.IRunUtil;
+import com.android.tradefed.util.ResourceUtil;
+import com.android.tradefed.util.RunUtil;
+
+import java.io.File;
+import java.io.IOException;
+
+/** A Utility that supports configuring google accounts on a device */
+public class GoogleAccountUtil {
+    private static final String ADD_ACCOUNT_INSTRUMENTATION_CLASS = ".AddAccount";
+    private static final String HAS_ACCOUNT_INSTRUMENTATION_CLASS = ".HasAccount";
+    private static final String REMOVE_ACCOUNTS_INSTRUMENTATION_CLASS = ".RemoveAccounts";
+    private static final String REMOVE_ACCOUNT_INSTRUMENTATION_CLASS = ".RemoveAccount";
+    private static final String GOOGLE_ACCOUNT_SYNC_INSTRUMENTATION_CLASS = ".GoogleAccountSync";
+
+    private static final String GOOGLE_ACCOUNT_SYNC_COMMAND =
+            "-w -e interval %d -e timeout %d -e force-account-sync %b %s/%s";
+
+    public static final String ACCOUNT_PKG_NAME = "com.google.android.tradefed.account";
+    public static final String CHECK_INSTRUMENTATION_CMD =
+            String.format("pm list instrumentation %s", ACCOUNT_PKG_NAME);
+    public static final String UTIL_APK_NAME = "GoogleAccountUtil";
+
+    private static final String UTIL_APK_PATH = "/GoogleAccountUtil.apk";
+    private static final String UTIL_APK_PATH_FALLBACK =
+            "/com/google/android/tradefed/account/GoogleAccountUtil.apk";
+
+    public static boolean installUtil(ITestDevice device) throws DeviceNotAvailableException {
+        return installUtil(device, null);
+    }
+
+    /**
+     * Install the account utility apk contained in jar if necessary
+     *
+     * @param device on which to install the utility.
+     * @throws DeviceNotAvailableException
+     */
+    public static boolean installUtil(ITestDevice device, File altApk)
+            throws DeviceNotAvailableException {
+        if (isAccountUtilInstalled(device)) {
+            return true;
+        } else {
+            // Attempt to install utility
+            File apkTempFile = null;
+            try {
+                File toInstall = null;
+                if (altApk != null) {
+                    if (altApk.exists()) {
+                        toInstall = altApk;
+                    } else {
+                        CLog.e("Failed to find alternative apk for account: %s", altApk);
+                        return false;
+                    }
+                } else {
+                    apkTempFile = FileUtil.createTempFile(UTIL_APK_NAME, ".apk");
+                    boolean res =
+                            ResourceUtil.extractResourceWithAltAsFile(
+                                    UTIL_APK_PATH, UTIL_APK_PATH_FALLBACK, apkTempFile);
+                    if (!res) {
+                        CLog.e("Failed to unpack AccountUtil utility");
+                        return false;
+                    }
+                    toInstall = apkTempFile;
+                }
+                CLog.i("Installing %s on %s", UTIL_APK_NAME, device.getSerialNumber());
+                final String result = device.installPackage(toInstall, false);
+                if (result != null) {
+                    CLog.e("Unable to install AccountUtil utility: %s", result);
+                    return false;
+                }
+            } catch (IOException e) {
+                CLog.e("Failed to unpack AccountUtil utility: %s", e.getMessage());
+                CLog.e(e);
+                return false;
+            } finally {
+                FileUtil.deleteFile(apkTempFile);
+            }
+            return isAccountUtilInstalled(device);
+        }
+    }
+
+    /**
+     * Uninstall the account utility apk contained in jar
+     *
+     * @param device to uninstall the account utility from.
+     * @throws DeviceNotAvailableException
+     */
+    public static boolean uninstallUtil(ITestDevice device) throws DeviceNotAvailableException {
+        if (device.uninstallPackage(ACCOUNT_PKG_NAME) != null) {
+            return false;
+        } else {
+            return true;
+        }
+    }
+
+    /**
+     * Check if the account utility is currently installed
+     *
+     * @param device on which to check if the account utility is installed
+     * @throws DeviceNotAvailableException
+     */
+    public static boolean isAccountUtilInstalled(ITestDevice device)
+            throws DeviceNotAvailableException {
+        final String inst = device.executeShellCommand(CHECK_INSTRUMENTATION_CMD);
+        if ((inst != null) && inst.contains(ACCOUNT_PKG_NAME)) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Check if there is an account on the device.
+     *
+     * @param device the {@link ITestDevice} checked for an account
+     * @param userId the user ID id to check
+     * @throws DeviceNotAvailableException
+     */
+    public static boolean hasAccount(ITestDevice device, int userId)
+            throws DeviceNotAvailableException {
+        String hasAccountCmd =
+                buildInstrumentationCmdForUser(
+                        device,
+                        userId,
+                        String.format(
+                                "-w %s/%s", ACCOUNT_PKG_NAME, HAS_ACCOUNT_INSTRUMENTATION_CLASS));
+        final String inst = device.executeShellCommand(hasAccountCmd);
+        // expected result format on success:
+        //
+        // INSTRUMENTATION_RESULT: result=SUCCESS
+        // INSTRUMENTATION_CODE: -1
+        if (inst.contains("result=SUCCESS")) {
+            return true;
+        } else {
+            CLog.e(
+                    "Failed to find registered Google account on %s. Command output: %s",
+                    device.getSerialNumber(), inst);
+            return false;
+        }
+    }
+
+    /**
+     * Builds the instrumentation command to add the account
+     *
+     * @param accountName name of the account to be targeted by the command
+     * @param password associated with the account
+     * @param sync flag to enable account sync after log in with the account
+     * @param waitForCheckin true to enable wait for checking after adding the account
+     * @param userId the user ID of the user profile to add the account to
+     */
+    private static String buildAddAccountCmd(
+            String accountName,
+            String password,
+            boolean sync,
+            boolean waitForCheckin,
+            int userId,
+            ITestDevice device)
+            throws DeviceNotAvailableException {
+        return buildInstrumentationCmdForUser(
+                device,
+                userId,
+                String.format(
+                        "-w -e account \"%s\" -e password \"%s\" -e sync %s "
+                                + "-e wait-for-checkin %s %s/%s",
+                        accountName,
+                        password,
+                        Boolean.toString(sync),
+                        Boolean.toString(waitForCheckin),
+                        ACCOUNT_PKG_NAME,
+                        ADD_ACCOUNT_INSTRUMENTATION_CLASS));
+    }
+
+    /**
+     * Attempt to configures device under test with given Google account.
+     *
+     * <p>Account must already exist on server.
+     *
+     * <p>Exposed for unit testing.
+     *
+     * @param device the {@link ITestDevice}
+     * @param userId the ID of user to which the account will be added
+     * @param accountName full name of Google account to add
+     * @param password password of account
+     * @param sync <code>true</code> if automatic sync should be enabled for this account
+     * @param waitForCheckin <code>true</code> to wait for checkin after adding account
+     * @return <code>true</code> if account was created successfully, <code>false</code> otherwise
+     */
+    public static boolean addAccountAttempt(
+            ITestDevice device,
+            int userId,
+            String accountName,
+            String password,
+            boolean sync,
+            boolean waitForCheckin)
+            throws DeviceNotAvailableException {
+        String instrCmd =
+                buildAddAccountCmd(accountName, password, sync, waitForCheckin, userId, device);
+        return runAddAccountInstrumentation(device, userId, instrCmd, accountName);
+    }
+
+    /** Utility function for running the AddAccount instrumentation */
+    private static boolean runAddAccountInstrumentation(
+            ITestDevice device, int userId, String instrCmd, String accountName)
+            throws DeviceNotAvailableException {
+        CLog.v(instrCmd);
+        String result = device.executeShellCommand(instrCmd);
+        // expected result format is (on error):
+        //
+        // INSTRUMENTATION_RESULT: result=SUCCESS
+        // INSTRUMENTATION_CODE: -1
+        //
+        // where errorCode will be present only on failure
+        if (result.contains("result=SUCCESS")) {
+            return true;
+        } else {
+            reportFailure(device, userId, accountName, "Failed to add account: " + result);
+            return false;
+        }
+    }
+
+    /** Builds the instrumentation command to turn off sync */
+    private static String buildSyncOffCmd(ITestDevice device, int userId, String accountName)
+            throws DeviceNotAvailableException {
+        return buildInstrumentationCmdForUser(
+                device,
+                userId,
+                String.format(
+                        "-w -e account \"%s\" -e sync false %s/%s",
+                        accountName, ACCOUNT_PKG_NAME, ADD_ACCOUNT_INSTRUMENTATION_CLASS));
+    }
+
+    /** Builds the instrumentation command to turn off sync */
+    private static String buildSyncOnCmd(ITestDevice device, int userId, String accountName)
+            throws DeviceNotAvailableException {
+        return buildInstrumentationCmdForUser(
+                device,
+                userId,
+                String.format(
+                        "-w -e account \"%s\" -e sync true %s/%s",
+                        accountName, ACCOUNT_PKG_NAME, ADD_ACCOUNT_INSTRUMENTATION_CLASS));
+    }
+
+    private static void reportFailure(
+            ITestDevice device, int userId, String accountName, String reason)
+            throws DeviceNotAvailableException {
+        CLog.w(
+                "Failed to add account %s to user %d(%s) on device %s: %s",
+                accountName,
+                userId,
+                device.getUserInfos().get(userId).userName(),
+                device.getSerialNumber(),
+                reason);
+    }
+
+    private static void reportRemoveFailure(ITestDevice device, int userId, String reason)
+            throws DeviceNotAvailableException {
+        CLog.w(
+                "Failed to remove accounts from user %d(%s) on device %s: %s",
+                userId,
+                device.getUserInfos().get(userId).userName(),
+                device.getSerialNumber(),
+                reason);
+    }
+
+    /** Builds the instrumentation command for a user. */
+    private static String buildInstrumentationCmdForUser(ITestDevice device, int userId, String cmd)
+            throws DeviceNotAvailableException {
+        // Only specify the user for the work profile.
+        return String.format(
+                "am instrument %s%s",
+                device.getPrimaryUserId().equals(userId) ? "" : String.format("--user %d ", userId),
+                cmd);
+    }
+
+    /**
+     * Remove the single account specified
+     *
+     * @param device
+     * @param userId
+     * @return true if removal is a success, false otherwise.
+     * @throws DeviceNotAvailableException
+     */
+    public static boolean removeAccountAttempt(ITestDevice device, int userId, String accountName)
+            throws DeviceNotAvailableException {
+        String removeCmd =
+                buildInstrumentationCmdForUser(
+                        device,
+                        userId,
+                        String.format(
+                                "-w -e account \"%s\" %s/%s",
+                                accountName,
+                                ACCOUNT_PKG_NAME,
+                                REMOVE_ACCOUNT_INSTRUMENTATION_CLASS));
+
+        CLog.v(removeCmd);
+        String result = device.executeShellCommand(removeCmd);
+        // expected result format is (on success):
+        //
+        // INSTRUMENTATION_RESULT: result=SUCCESS
+        // INSTRUMENTATION_CODE: -1
+        //
+        if (result.contains("result=SUCCESS")) {
+            return true;
+        } else {
+            reportRemoveFailure(device, userId, result);
+            return false;
+        }
+    }
+
+    /**
+     * Remove all accounts of the device
+     *
+     * @param device
+     * @param userId
+     * @return true if removal is a success, false otherwise.
+     * @throws DeviceNotAvailableException
+     */
+    public static boolean removeAllAccountAttempt(ITestDevice device, int userId)
+            throws DeviceNotAvailableException {
+        String removeCmd =
+                buildInstrumentationCmdForUser(
+                        device,
+                        userId,
+                        String.format(
+                                "-w %s/%s",
+                                ACCOUNT_PKG_NAME, REMOVE_ACCOUNTS_INSTRUMENTATION_CLASS));
+
+        CLog.v(removeCmd);
+        String result = device.executeShellCommand(removeCmd);
+        // expected result format is (on success):
+        //
+        // INSTRUMENTATION_RESULT: result=SUCCESS
+        // INSTRUMENTATION_CODE: -1
+        //
+        if (result.contains("result=SUCCESS")) {
+            return true;
+        } else {
+            reportRemoveFailure(device, userId, result);
+            return false;
+        }
+    }
+
+    /**
+     * Turns off syncing with the given Google account. Assume syncing is On.
+     *
+     * @param device the {@link ITestDevice}
+     * @param userId the ID of the user to run this operation on
+     * @param accountName full name of Google account to turn sync off
+     * @param syncThenOff seconds to allow sync to run before turning it off
+     * @return <code>true</code> if the sync was turned off successfully
+     * @throws DeviceNotAvailableException
+     */
+    public static boolean syncAndOff(
+            ITestDevice device, int userId, String accountName, long syncThenOff)
+            throws DeviceNotAvailableException {
+        CLog.i("Sleeping for %d seconds to allow for syncing...", syncThenOff);
+        getRunUtil().sleep(syncThenOff * 1000);
+        CLog.i("Done sleeping. Turning sync off...");
+        String instrCmd = buildSyncOffCmd(device, userId, accountName);
+        return runAddAccountInstrumentation(device, userId, instrCmd, accountName);
+    }
+
+    /**
+     * Turns on syncing with the given Google account. Assume syncing is false;
+     *
+     * @param device the {@link ITestDevice}
+     * @param userId the ID of the user to run this operation on
+     * @param accountName full name of Google account to turn sync on
+     * @return <code>true</code> if the sync was turned off successfully
+     * @throws DeviceNotAvailableException
+     */
+    public static boolean syncOn(ITestDevice device, int userId, String accountName)
+            throws DeviceNotAvailableException {
+        String instrCmd = buildSyncOnCmd(device, userId, accountName);
+        return runAddAccountInstrumentation(device, userId, instrCmd, accountName);
+    }
+
+    /** Wait for the device to finish syncing. */
+    public static boolean waitForAccountSync(
+            ITestDevice device, int userId, long interval, long timeout, boolean forceSync)
+            throws DeviceNotAvailableException {
+        String instrCmd =
+                String.format(
+                        buildInstrumentationCmdForUser(device, userId, GOOGLE_ACCOUNT_SYNC_COMMAND),
+                        interval,
+                        timeout,
+                        forceSync,
+                        ACCOUNT_PKG_NAME,
+                        GOOGLE_ACCOUNT_SYNC_INSTRUMENTATION_CLASS);
+        CLog.v(instrCmd);
+        String result = device.executeShellCommand(instrCmd);
+        // Success result format:
+        //
+        // INSTRUMENTATION_RESULT: result=SUCCESS
+        // INSTRUMENTATION_CODE: -1
+        //
+        if (result.contains("result=SUCCESS")) {
+            return true;
+        } else {
+            reportRemoveFailure(device, userId, result);
+            return false;
+        }
+    }
+
+    /**
+     * @return the {@link IRunUtil} to use
+     */
+    private static IRunUtil getRunUtil() {
+        return RunUtil.getDefault();
+    }
+}
diff --git a/test_observatory/com/android/tradefed/observatory/TestDiscoveryInvoker.java b/test_observatory/com/android/tradefed/observatory/TestDiscoveryInvoker.java
index 263d07e12..9a372eb3f 100644
--- a/test_observatory/com/android/tradefed/observatory/TestDiscoveryInvoker.java
+++ b/test_observatory/com/android/tradefed/observatory/TestDiscoveryInvoker.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2022 The Android Open Source Project
+ * Copyright (C) 2025 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -29,6 +29,7 @@ import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.result.FileInputStreamSource;
 import com.android.tradefed.result.LogDataType;
 import com.android.tradefed.result.error.InfraErrorIdentifier;
+import com.android.tradefed.testtype.suite.TestMappingSuiteRunner;
 import com.android.tradefed.util.CommandResult;
 import com.android.tradefed.util.CommandStatus;
 import com.android.tradefed.util.FileUtil;
@@ -78,6 +79,7 @@ public class TestDiscoveryInvoker {
     private File mTestMappingZip;
     private IBuildInfo mBuildInfo;
     private ITestLogger mLogger;
+    private boolean mIsBWYN = false;
 
     private static final TestDiscoveryUtil mTestDiscoveryUtil = new TestDiscoveryUtil();
 
@@ -140,6 +142,10 @@ public class TestDiscoveryInvoker {
         mBuildInfo = buildInfo;
     }
 
+    public void setIsBWYN(boolean isBWYN) {
+        mIsBWYN = isBWYN;
+    }
+
     public void setTestLogger(ITestLogger logger) {
         mLogger = logger;
     }
@@ -332,6 +338,12 @@ public class TestDiscoveryInvoker {
                 getRunUtil()
                         .setEnvVariable(TEST_MAPPING_ZIP_FILE, mTestMappingZip.getAbsolutePath());
             }
+            // If it is in BWYN test discovery mode, we should always not ignore test mapping
+            // imports through setting the env var that consumed by TestMappingSuiteRunner.
+            if (mIsBWYN) {
+                CLog.i("Setting BWYN test discovery mode to avoid skip test mapping imports.");
+                getRunUtil().setEnvVariable(TestMappingSuiteRunner.IS_BWYN_ENV_VAR_KEY, "true");
+            }
             if (mBuildInfo != null) {
                 if (mBuildInfo.getFile(TestMapping.TEST_MAPPINGS_ZIP) != null) {
                     getRunUtil()
@@ -487,11 +499,6 @@ public class TestDiscoveryInvoker {
         // Parse to collect all values of --cts-params as well config name
         ctsOptionParser.parseBestEffort(fullCommandLineArgs, true);
 
-        List<String> ctsParams = ctsParserSettings.mCtsParams;
-        for (String globalFilter : ctsParserSettings.mStrictIncludeFilters) {
-            ctsParams.add("--" + GlobalTestFilter.STRICT_INCLUDE_FILTER_OPTION);
-            ctsParams.add(globalFilter);
-        }
         String configName = ctsParserSettings.mConfigName;
 
         if (configName == null) {
@@ -528,7 +535,13 @@ public class TestDiscoveryInvoker {
         args.add(configName);
 
         // Tokenize args to be passed to CtsTest/XtsTest
+        List<String> ctsParams = ctsParserSettings.mCtsParams;
         args.addAll(StringEscapeUtils.paramsToArgs(ctsParams));
+        // Add global filters as-is to avoid breaking down their escaping
+        for (String globalFilter : ctsParserSettings.mStrictIncludeFilters) {
+            args.add("--" + GlobalTestFilter.STRICT_INCLUDE_FILTER_OPTION);
+            args.add(globalFilter);
+        }
 
         return args;
     }
diff --git a/test_observatory/com/android/tradefed/observatory/TestMappingDiscoveryAgent.java b/test_observatory/com/android/tradefed/observatory/TestMappingDiscoveryAgent.java
index 4e3a9b2aa..c2baddef7 100644
--- a/test_observatory/com/android/tradefed/observatory/TestMappingDiscoveryAgent.java
+++ b/test_observatory/com/android/tradefed/observatory/TestMappingDiscoveryAgent.java
@@ -179,6 +179,9 @@ public class TestMappingDiscoveryAgent {
                                 false,
                                 true);
             }
+            // Set TestDiscoveryInvoker to BWYN mode.
+            mTestDiscoveryInvoker.setIsBWYN(true);
+
             if (mTestDiscoveryUtil.getTestMappingFilePath() != null) {
                 mTestDiscoveryInvoker.setTestMappingZip(
                         new File(mTestDiscoveryUtil.getTestMappingFilePath()));
diff --git a/test_observatory/com/android/tradefed/observatory/TestZipDiscoveryExecutor.java b/test_observatory/com/android/tradefed/observatory/TestZipDiscoveryExecutor.java
index 43c14ed26..04a91a3dd 100644
--- a/test_observatory/com/android/tradefed/observatory/TestZipDiscoveryExecutor.java
+++ b/test_observatory/com/android/tradefed/observatory/TestZipDiscoveryExecutor.java
@@ -188,10 +188,16 @@ public class TestZipDiscoveryExecutor {
         Set<String> testsZipRegex = new LinkedHashSet<String>();
         // special setup by camera team
         if ("unused".equals(args[0])) {
-            for (String arg : args) {
-                if (arg.contains("liblyric")) {
+            for (int i = 1; i < args.length; i++) {
+                if (args[i].contains("liblyric")) {
                     testsZipRegex.add("camera-hal-tests.zip");
                 }
+                // Some camera configs have specific test zip specified by
+                // --artifact_with_config. Ensure we return it so it doesn't
+                // get optimized.
+                if (args[i].contains("--artifact_with_config")) {
+                    testsZipRegex.add(args[i + 1]);
+                }
             }
             return formatResults(false, testsZipRegex);
         }
diff --git a/test_result_interfaces/Android.bp b/test_result_interfaces/Android.bp
index da4e22f8f..df270afbd 100644
--- a/test_result_interfaces/Android.bp
+++ b/test_result_interfaces/Android.bp
@@ -29,7 +29,6 @@ java_library_host {
         "com/**/*.java",
     ],
     libs: [
-        "ddmlib-prebuilt",
         "jsr305",
         "tradefed-common-util",
         "tradefed-protos",
diff --git a/test_result_interfaces/com/android/tradefed/util/proto/TfMetricProtoUtil.java b/test_result_interfaces/com/android/tradefed/util/proto/TfMetricProtoUtil.java
index a548ccb1e..e3164ea02 100644
--- a/test_result_interfaces/com/android/tradefed/util/proto/TfMetricProtoUtil.java
+++ b/test_result_interfaces/com/android/tradefed/util/proto/TfMetricProtoUtil.java
@@ -18,21 +18,25 @@ package com.android.tradefed.util.proto;
 import com.android.tradefed.log.LogUtil.CLog;
 import com.android.tradefed.metrics.proto.MetricMeasurement.DataType;
 import com.android.tradefed.metrics.proto.MetricMeasurement.Directionality;
+import com.android.tradefed.metrics.proto.MetricMeasurement.DoubleValues;
+import com.android.tradefed.metrics.proto.MetricMeasurement.StringValues;
 import com.android.tradefed.metrics.proto.MetricMeasurement.Measurements;
 import com.android.tradefed.metrics.proto.MetricMeasurement.Measurements.MeasurementCase;
 import com.android.tradefed.metrics.proto.MetricMeasurement.Metric;
 import com.android.tradefed.metrics.proto.MetricMeasurement.Metric.Builder;
+import com.android.tradefed.metrics.proto.MetricMeasurement.NumericValues;
 
 import java.util.HashMap;
 import java.util.LinkedHashMap;
+import java.util.List;
 import java.util.Map;
+import java.util.stream.Collectors;
 
 /** Utility class to help with the Map<String, String> to Map<String, Metric> transition. */
 public class TfMetricProtoUtil {
 
     /**
-     * Conversion of Map<String, Metric> to Map<String, String>. All the single value string
-     * representation are used, list representation are not converted and will be lost.
+     * Conversion of Map<String, Metric> to Map<String, String>.
      */
     public static Map<String, String> compatibleConvert(Map<String, Metric> map) {
         Map<String, String> oldFormat = new LinkedHashMap<>();
@@ -50,6 +54,17 @@ public class TfMetricProtoUtil {
                 case SINGLE_STRING:
                     value = measures.getSingleString();
                     break;
+                case DOUBLE_VALUES:
+                    value = measures.getDoubleValues().getDoubleValueList().stream()
+                        .map(String::valueOf).collect(Collectors.joining(","));
+                    break;
+                case NUMERIC_VALUES:
+                    value = measures.getNumericValues().getNumericValueList().stream()
+                        .map(String::valueOf).collect(Collectors.joining(","));
+                    break;
+                case STRING_VALUES:
+                    value = String.join(",", measures.getStringValues().getStringValueList());
+                    break;
                 case MEASUREMENT_NOT_SET:
                     CLog.d("No measurements was set for key '%s'", key);
                     continue;
@@ -90,7 +105,7 @@ public class TfMetricProtoUtil {
             if (smartNumbers) {
                 Long numMetric = isLong(stringMetric);
                 if (numMetric != null) {
-                    metric = createSingleValue(numMetric.longValue(), null);
+                    metric = numericToMetric(numMetric.longValue());
                 }
             }
             // Default to String metric
@@ -113,6 +128,14 @@ public class TfMetricProtoUtil {
         }
     }
 
+    private static Metric measurementToMetric(Measurements measures) {
+        return Metric.newBuilder()
+                .setMeasurements(measures)
+                .setDirection(Directionality.DIRECTIONALITY_UNSPECIFIED)
+                .setType(DataType.RAW)
+                .build();
+    }
+
     /**
      * Convert a simple String metric (old format) to a {@link Metric} (new format).
      *
@@ -121,13 +144,67 @@ public class TfMetricProtoUtil {
      */
     public static Metric stringToMetric(String metric) {
         Measurements measures = Measurements.newBuilder().setSingleString(metric).build();
-        Metric m =
-                Metric.newBuilder()
-                        .setMeasurements(measures)
-                        .setDirection(Directionality.DIRECTIONALITY_UNSPECIFIED)
-                        .setType(DataType.RAW)
-                        .build();
-        return m;
+        return measurementToMetric(measures);
+    }
+
+    /**
+     * Convert a simple Double metric to a {@link Metric}.
+     *
+     * @param metric The double containing a metric.
+     * @return The created {@link Metric}
+     */
+    public static Metric doubleToMetric(Double metric) {
+        Measurements measures = Measurements.newBuilder().setSingleDouble(metric).build();
+        return measurementToMetric(measures);
+    }
+
+    /**
+     * Convert a list of strings to a {@link Metric}.
+     *
+     * @param metric The list containing metric.
+     * @return The created {@link Metric}
+     */
+    public static Metric stringArrayToMetric(List<String> metric) {
+        StringValues.Builder stringValues = StringValues.newBuilder();
+        stringValues.addAllStringValue(metric);
+        Measurements measures = Measurements.newBuilder().setStringValues(stringValues).build();
+        return measurementToMetric(measures);
+    }
+
+    /**
+     * Convert a list of doubles to a {@link Metric}.
+     *
+     * @param metric The list containing metric.
+     * @return The created {@link Metric}
+     */
+    public static Metric doubleArrayToMetric(List<Double> metric) {
+        DoubleValues.Builder doubleValues = DoubleValues.newBuilder();
+        doubleValues.addAllDoubleValue(metric);
+        Measurements measures = Measurements.newBuilder().setDoubleValues(doubleValues).build();
+        return measurementToMetric(measures);
+    }
+
+    /**
+     * Convert a list of numeric (int64)to a {@link Metric}.
+     *
+     * @param metric The list containing metric.
+     * @return The created {@link Metric}
+     */
+    public static Metric numericArrayToMetric(List<Long> metric) {
+        NumericValues.Builder numericValues = NumericValues.newBuilder();
+        numericValues.addAllNumericValue(metric);
+        Measurements measures = Measurements.newBuilder().setNumericValues(numericValues).build();
+        return measurementToMetric(measures);
+    }
+
+    /**
+     * Convert a simple numeric metric to a {@link Metric}.
+     *
+     * @param metric The double containing a metric.
+     * @return The created {@link Metric}
+     */
+    public static Metric numericToMetric(Long metric) {
+        return numericToMetric(metric, null);
     }
 
     /**
@@ -137,7 +214,7 @@ public class TfMetricProtoUtil {
      * @param unit the unit of the value, or null if no unit.
      * @return a {@link Metric} populated with the informations.
      */
-    public static Metric createSingleValue(long value, String unit) {
+    public static Metric numericToMetric(long value, String unit) {
         Measurements measure = Measurements.newBuilder().setSingleInt(value).build();
         Builder metricBuilder = Metric.newBuilder().setType(DataType.RAW).setMeasurements(measure);
         if (unit != null) {
diff --git a/tools/content_uploader/artifact_manager.py b/tools/content_uploader/artifact_manager.py
index a4025e300..63175112d 100644
--- a/tools/content_uploader/artifact_manager.py
+++ b/tools/content_uploader/artifact_manager.py
@@ -98,9 +98,11 @@ class ArtifactManager:
         """
         tokens = source_path_str.split()
         source_path = tokens[0]
-        action = "update" if name in self._artifacts else "add"
+        action = 'update' if name in self._artifacts else 'add'
         artifact = self._artifacts.get(name, ArtifactConfig(source_path, unzip=False))
-        artifact.source_path = source_path
+        # Update the source path only if specified
+        if action == 'update' and source_path:
+            artifact.source_path = source_path
 
         if len(tokens) > 1:
             artifact.unzip = self._get_artifact_attribute(
diff --git a/tools/content_uploader/content_uploader_script.py b/tools/content_uploader/content_uploader_script.py
index 8929ddd69..13c40470b 100644
--- a/tools/content_uploader/content_uploader_script.py
+++ b/tools/content_uploader/content_uploader_script.py
@@ -32,7 +32,7 @@ from uploader import CasInfo
 from uploader import Uploader
 
 
-VERSION = '1.8'
+VERSION = '1.9'
 
 CAS_UPLOADER_PREBUILT_PATH = 'tools/tradefederation/prebuilts/'
 CAS_UPLOADER_PATH = 'tools/content_addressed_storage/prebuilts/'
diff --git a/tools/content_uploader/test_artifact_manager.py b/tools/content_uploader/test_artifact_manager.py
index 020d56e13..46b7c8725 100644
--- a/tools/content_uploader/test_artifact_manager.py
+++ b/tools/content_uploader/test_artifact_manager.py
@@ -70,6 +70,18 @@ class ArtifactManagerTest(unittest.TestCase):
             self.artifacts['apex'].source_path = 'new_path'
             self.assertDictEqual(artifacts, expected)
 
+    def test_override_artifacts_update_artifact_source_path_unspecified(self):
+        """Flag --artifact 'ARTIFACT_NAME= chunk' retains the default source path."""
+        test_args = ['content_uploader', '--artifacts', 'apex= chunk']
+        with patch.object(sys, 'argv', test_args):
+            args = self.parser.parse_args()
+            self.artifact_manager.override_artifacts(args)
+            artifacts = self.artifact_manager.artifacts()
+            expected = self.artifacts.copy()
+            expected['apex'].source_path = '*.apex'
+            expected['apex'].chunk = True
+            self.assertDictEqual(artifacts, expected)
+
     def test_override_artifacts_add_artifact(self):
         """Flag --artifact 'NEW_ARTIFACT=PATH' adds a new artifact."""
         test_args = ['content_uploader', '--artifacts', 'new_artifact=path/to/new']
diff --git a/tools/content_uploader/test_uploader.py b/tools/content_uploader/test_uploader.py
index 6f7452fbe..24931e095 100644
--- a/tools/content_uploader/test_uploader.py
+++ b/tools/content_uploader/test_uploader.py
@@ -87,6 +87,19 @@ done
         uploader.upload(artifacts, dist_dir, max_workers, dryrun)
         return Uploader.read_file(self.command_file)
 
+    def _upload_failed(self, artifacts, test_dir: str, dist_dir: str):
+        log_dir = os.path.join(dist_dir, 'logs')
+        os.makedirs(log_dir, 0o777)
+        max_workers = 1
+        dryrun = False
+        client_path = self._create_fake_uploader(test_dir, f"""#!/bin/bash
+echo 'Output from casuploader (failed)'
+exit 1
+""")
+        cas_info = CasInfo('INSTANCE', 'SERVICE', client_path, (1, 4))
+        uploader = Uploader(cas_info)
+        uploader.upload(artifacts, dist_dir, max_workers, dryrun)
+
     def _verify(self, command: str, has_flags: list[str], no_flags: list[str]):
         for flag in has_flags:
             if not flag in command:
@@ -189,5 +202,21 @@ done
             self.assertEqual(len(commands.split('\n')) - 1, 1)
             self.assertNotIn('/sub/', commands)
 
+    def test_upload_failed(self):
+        """Log and casuploader output from failed upload task are logged."""
+        standard_image = ArtifactConfig(
+            '*-img-*zip',
+            unzip = False,
+        )
+        with tempfile.TemporaryDirectory() as dist_dir:
+            artifacts = [standard_image]
+            self._create_fake_imagefile(dist_dir, 'oriole-img-123.zip')
+            with self.assertLogs(level=logging.INFO) as cm:
+                self._upload_failed(artifacts, self.test_dir, dist_dir)
+                log_lines = '\n'.join(cm.output)
+                self.assertIn('Failed to upload', log_lines)
+                self.assertIn('Output from casuploader (failed)', log_lines)
+
+
 if __name__ == '__main__':
     unittest.main()
diff --git a/tools/content_uploader/uploader.py b/tools/content_uploader/uploader.py
index 324ba3d6c..e5085e4a3 100644
--- a/tools/content_uploader/uploader.py
+++ b/tools/content_uploader/uploader.py
@@ -26,7 +26,7 @@ import subprocess
 import tempfile
 import uuid
 import time
-from typing import Tuple
+from typing import TextIO, Tuple
 
 import cas_metrics_pb2  # type: ignore
 from google.protobuf import json_format
@@ -130,20 +130,17 @@ class Uploader:
             return f"Error: {e}"
 
     @staticmethod
-    def _run_uploader_command(cmd: str, working_dir: str) -> str:
-        """"Run the uploader command using working_dir and returns the output."""
-        log_file = os.path.join(working_dir, f'_casuploader_{uuid.uuid4()}.log')
-        with open(log_file, 'w', encoding='utf8') as outfile:
-            subprocess.run(
-                cmd,
-                check=True,
-                text=True,
-                stdout=outfile,
-                stderr=subprocess.STDOUT,
-                encoding='utf-8',
-                timeout=UPLOADER_TIMEOUT_SECS
-            )
-        return Uploader.read_file(log_file)
+    def _run_uploader_command(cmd: str, outfile: TextIO):
+        """"Run the uploader command and output to outfile."""
+        subprocess.run(
+            cmd,
+            check=True,
+            text=True,
+            stdout=outfile,
+            stderr=subprocess.STDOUT,
+            encoding='utf-8',
+            timeout=UPLOADER_TIMEOUT_SECS
+        )
 
     def _upload_artifact(self,
             artifact: ArtifactConfig,
@@ -203,20 +200,24 @@ class Uploader:
             if dump_metrics:
                 cmd = cmd + ['-dump-metrics', metrics_file]
 
-            try:
-                logger.info('Running command: %s', cmd)
-                output = Uploader._run_uploader_command(cmd, working_dir)
-                logger.info('Command output:\n %s', output)
-            except (subprocess.CalledProcessError, subprocess.TimeoutExpired) as e:
-                logger.warning(
-                    'Failed to upload %s to CAS instance %s. Skip.\nError message: %s\nLog: %s',
-                    artifact.source_path, self._cas_info.cas_instance, e, e.stdout,
-                )
-                return None
-            except subprocess.SubprocessError as e:
-                logger.warning('Failed to upload %s to CAS instance %s. Skip.\n. Error %s',
-                    artifact.source_path, self._cas_info.cas_instance, e)
-                return None
+            cmd_output_file = os.path.join(working_dir, f'_casuploader_{uuid.uuid4()}.log')
+            with open(cmd_output_file, 'w', encoding='utf8') as outfile:
+                try:
+                    logger.info('Running command: %s', cmd)
+                    Uploader._run_uploader_command(cmd, outfile)
+                    logger.info('Command output:\n%s', Uploader.read_file(cmd_output_file))
+                except (subprocess.CalledProcessError, subprocess.TimeoutExpired) as e:
+                    logger.info('Command output:\n%s', Uploader.read_file(cmd_output_file))
+                    logger.warning(
+                        'Failed to upload %s to CAS instance %s. Skip.\nError message: %s',
+                        artifact.source_path, self._cas_info.cas_instance, e
+                    )
+                    return UploadResult(None, None, log_file)
+                except subprocess.SubprocessError as e:
+                    logger.info('Command output:\n%s', Uploader.read_file(cmd_output_file))
+                    logger.warning('Failed to upload %s to CAS instance %s. Skip.\n. Error: %s',
+                        artifact.source_path, self._cas_info.cas_instance, e)
+                    return UploadResult(None, None, log_file)
 
             # Read digest of the root directory or file from dumped digest file.
             digest = digest_file.read()
@@ -227,7 +228,7 @@ class Uploader:
                     'No digest is dumped for file %s, the uploading may fail.',
                     artifact.source_path,
                 )
-                return None
+                return UploadResult(None, None, log_file)
 
             content_details = None
             if dump_file_details:
@@ -361,20 +362,17 @@ class Uploader:
                 index = 1
                 for future in concurrent.futures.as_completed(futures):
                     result, task = future.result()
-                    if result:
-                        output = Uploader.read_file(result.log_file) if result else ''
-                        logging.info('---- %s: %s ----\n\n%s', index, task.path, output)
-                    else:
-                        logging.info('---- %s: %s ----\n\n', index, task.path)
+                    output = Uploader.read_file(result.log_file)
+                    logging.info('---- %s: %s ----\n\n%s', index, task.path, output)
                     index += 1
-                    if result and result.digest:
+                    if result.digest:
                         file_digests[task.path] = result.digest
                     else:
                         logging.warning(
                             'Skip to save the digest of file %s, the uploading may fail',
                             task.path,
                         )
-                    if result and result.content_details:
+                    if result.content_details:
                         content_details.append({"artifact": task.path,
                                                 "details": result.content_details})
                     else:
@@ -396,7 +394,7 @@ class Uploader:
     def _add_artifact_metrics(metrics_file: str, cas_metrics: cas_metrics_pb2.CasMetrics):
         """Adds artifact metrics from metrics_file to cas_metrics."""
         try:
-            with open(metrics_file, "r", encoding='utf8') as file:
+            with open(metrics_file, 'r', encoding='utf8') as file:
                 json_str = file.read()  # Read the file contents here
                 if json_str:
                     json_metrics = json.loads(json_str)
@@ -404,13 +402,13 @@ class Uploader:
                         json_format.ParseDict(json_metrics, cas_metrics_pb2.ArtifactMetrics())
                     )
                 else:
-                    logging.exception("Empty file: %s", metrics_file)
+                    logging.warning('Empty metrics file: %s', metrics_file)
         except FileNotFoundError:
-            logging.exception("File not found: %s", metrics_file)
+            logging.exception('File not found: %s', metrics_file)
         except json.JSONDecodeError as e:
-            logging.exception("Jason decode error: %s for json contents:\n%s", e, json_str)
+            logging.exception('Json decode error: %s', e)
         except json_format.ParseError as e:  # Catch any other unexpected errors
-            logging.exception("Error converting Json to protobuf: %s", e)
+            logging.exception('Error converting Json to protobuf: %s', e)
 
     @staticmethod
     def _get_relative_path(dir: str, path: str) -> str:
diff --git a/tradefed.sh b/tradefed.sh
index 46345e47b..77cc57c5f 100755
--- a/tradefed.sh
+++ b/tradefed.sh
@@ -39,7 +39,7 @@ if [ -n "${LOCAL_AUTH}" ]; then
   ${TF_JAVA} -cp "${TF_PATH}" com.android.tradefed.command.LocalDeveloper
   local_client=$?
   if [ "${local_client}" -eq 0 ]; then
-    gcloud auth application-default login --scopes=https://www.googleapis.com/auth/androidbuild.internal --client-id-file "$LOCAL_CLIENT_FILE"
+    gcloud auth application-default login --scopes="https://www.googleapis.com/auth/cloud-platform,https://www.googleapis.com/auth/androidbuild.internal" --client-id-file "$LOCAL_CLIENT_FILE"
     gcloud_res=$?
     if [ "${gcloud_res}" -ne 0 ]; then
         echo "Error with auth. aborting tradefed.sh"
diff --git a/util_apps/AccountUtil/Android.bp b/util_apps/AccountUtil/Android.bp
new file mode 100644
index 000000000..15d556425
--- /dev/null
+++ b/util_apps/AccountUtil/Android.bp
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package {
+    // See: http://go/android-license-faq
+    //   legacy_proprietary
+    default_applicable_licenses: [
+        "Android-Apache-2.0",
+    ],
+}
+
+// Java library for the actual code shared by the utility and its tests.
+java_library {
+    name: "google-account-util-lib",
+    srcs: ["src/**/*.java"],
+    sdk_version: "14",
+    min_sdk_version: "14",
+    target_sdk_version: "31",
+    visibility: [
+        "//tools/tradefederation/core/util_apps/AccountUtil/tests",
+    ],
+}
+
+// Build instructions for the utility APK.
+android_app {
+    name: "GoogleAccountUtil",
+    sdk_version: "14",
+    // This modules depends on cert unbundled_google.app which is not available in some branches like git_main-without-vendor,
+    // so we enable it only when the cert is available.
+    enabled: select(soong_config_variable("ANDROID", "unbundled_google_certs_available"), {
+        true: true,
+        default: false,
+    }),
+    certificate: ":unbundled_google.app",
+    static_libs: ["google-account-util-lib"],
+    manifest: "src/com/google/android/tradefed/account/AndroidManifest.xml",
+    optimize: {
+        enabled: false,
+    },
+    visibility: [
+        "//tools/tradefederation/core",
+        "//vendor:__subpackages__",
+    ],
+}
diff --git a/util_apps/AccountUtil/src/com/google/android/tradefed/account/AddAccount.java b/util_apps/AccountUtil/src/com/google/android/tradefed/account/AddAccount.java
new file mode 100644
index 000000000..16942def6
--- /dev/null
+++ b/util_apps/AccountUtil/src/com/google/android/tradefed/account/AddAccount.java
@@ -0,0 +1,318 @@
+/*
+ * Copyright (C) 2007 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.tradefed.account;
+
+import android.accounts.Account;
+import android.accounts.AccountManager;
+import android.accounts.AccountManagerCallback;
+import android.accounts.AccountManagerFuture;
+import android.accounts.AuthenticatorException;
+import android.accounts.OperationCanceledException;
+import android.app.Activity;
+import android.app.Instrumentation;
+import android.content.BroadcastReceiver;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.SyncAdapterType;
+import android.os.Build;
+import android.os.Bundle;
+import android.text.TextUtils;
+import android.util.Log;
+
+import java.io.IOException;
+import java.util.Locale;
+
+/**
+ * An instrumentation utility to add accounts and, while so doing, enable or disable automatic sync
+ *
+ * Current abilities:
+ *   - Run with "-e account ... -e password ..." to add that account, defaulting to sync off
+ *   - Run with "-e account ... -e password ... -e sync (bool)" to add that account, if it doesn't
+ *     already exist, and set the autosync settings to the bool specified
+ *   - Add a "-e wait-for-checkin true" argument to block until checkin has been performed
+ *
+ * Current known limitations:
+ *   - Doesn't support accounts of types other than com.google
+ *   - Doesn't do anything useful if you run it with an account that already exists, but without
+ *     specifying "-e sync (bool)"
+ *   - Error messages could be more useful
+ *
+ * adb shell am instrument -e account test_account@gmail.com -e password ******
+ * -w com.google.android.tests.utilities/.AddAccount
+ *
+ * Copied from vendor/google/tests/Util
+ */
+public class AddAccount extends Instrumentation {
+
+    private Bundle mArguments;
+    private static final String TAG = "AddAccount";
+    private static final String AUTH_TOKEN_TYPE = "mail";
+    /** the maximum time to wait for a checkin update in seconds */
+    private static final int CHECKIN_WAIT_TIME_SEC = 60;
+    private static final long WAIT_BEFORE_UPDATE_SYNC = 15 * 1000;
+    protected AccountManager mAccountManager;
+    static final String GOOGLE_ACCOUNT = "com.google";
+
+    @Override
+    public void onCreate(Bundle arguments) {
+        super.onCreate(arguments);
+        mArguments = arguments;
+        start();
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+
+        Bundle results = new Bundle();
+
+        final String username = mArguments.getString("account");
+        final String password = mArguments.getString("password");
+        final boolean sync = Boolean.parseBoolean(mArguments.getString("sync"));
+        final boolean waitForCheckin = Boolean.parseBoolean(mArguments.getString(
+                "wait-for-checkin"));
+        Account account = new Account(username, GOOGLE_ACCOUNT);
+
+        if (TextUtils.isEmpty(username)) {
+            Log.e(TAG, "Error: must specify account");
+            results.putString("error", "must specify account");
+            finish(Activity.RESULT_CANCELED, results);
+        }
+
+        mAccountManager = AccountManager.get(getContext());
+
+        // If the account already exists, set sync settings if specified, otherwise bail
+        for(Account acct : mAccountManager.getAccountsByType(GOOGLE_ACCOUNT)) {
+            Log.v(TAG, String.format("Checking if username %s matches account %s", username,
+                    acct.toString()));
+            if(acct.name.equals(username) && acct.type.equals(GOOGLE_ACCOUNT)) {
+                if (mArguments.containsKey("sync")) {
+                    Log.d(TAG, String.format("Found existing account %s, setting sync to %s",
+                            acct.name, sync));
+                    // They passed a sync argument; set sync options and call it a day
+                    setSyncAutomatically(acct, sync);
+                    results.putString("result", "SUCCESS");
+                    finish(Activity.RESULT_OK, results);
+                    return;
+                } else {
+                    // No sync passed; bail out
+                    String errMsg =
+                            String.format(
+                                    Locale.ENGLISH, "Error: account %s already exists", username);
+                    Log.e(TAG, errMsg);
+                    results.putString("error", errMsg);
+                    finish(Activity.RESULT_CANCELED, results);
+                    return;
+                }
+            }
+        }
+
+        CheckinReceiver receiver = null;
+        if (waitForCheckin) {
+            IntentFilter intentFilter = new IntentFilter();
+            intentFilter.addAction("com.google.android.checkin.CHECKIN_COMPLETE");
+            receiver = new CheckinReceiver();
+            getContext().registerReceiver(receiver, intentFilter);
+        }
+
+        // At this point, we're adding a new account.
+        Bundle options = new Bundle();
+        options.putString("username", username);
+        options.putString("password", password);
+        AuthenticationCallback authCallback = new AuthenticationCallback();
+        mAccountManager.addAccount(GOOGLE_ACCOUNT, AUTH_TOKEN_TYPE,
+                null /* required features */, options,
+                null /* don't spawn activity */, authCallback, null /* handler */);
+        Log.i(TAG, "Attempting to add account");
+
+        Bundle authResult = authCallback.waitForAuthCompletion();
+        if (authResult.containsKey(AccountManager.KEY_ERROR_CODE)) {
+            int errorCode = ((Integer) authResult.get(AccountManager.KEY_ERROR_CODE)).intValue();
+            // workaround for b/11774229 where in KLP account is added but errorCode 8 is returned
+            if (Build.VERSION.SDK_INT > 18 && errorCode == 8) {
+                authResult.remove(AccountManager.KEY_ERROR_CODE);
+            } else {
+                Log.e(TAG, String.format("AddAccount failed. Reason: %s",
+                        authResult.get(AccountManager.KEY_ERROR_MESSAGE)));
+                finish(Activity.RESULT_CANCELED, authResult);
+                return;
+            }
+        }
+
+        String authToken = authResult.getString(AccountManager.KEY_AUTHTOKEN);
+
+        if (authToken == null) {
+            Log.d(TAG, "Auth Token is null; trying to fetch");
+            authToken = fetchAuthToken(account);
+            if (authToken == null) {
+                // still failed, abort
+                results.putString("error", "Failed to get auth token");
+                finish(Activity.RESULT_CANCELED, results);
+                return;
+            }
+            // add retrieved auth token back to bundle
+            authResult.putString(AccountManager.KEY_AUTHTOKEN, authToken);
+        }
+
+        Log.i(TAG, String.format("Got authtoken %s", authToken));
+
+        // Wait until all the sync adapters are registered before trying to turn sync off
+        try {
+            Thread.sleep(WAIT_BEFORE_UPDATE_SYNC);
+        } catch (InterruptedException e){
+            Thread.currentThread().interrupt();
+        }
+        // turn on/off sync
+        setSyncAutomatically(account, sync);
+
+        // wait for checkin
+        if (receiver != null && !receiver.waitForCheckin(CHECKIN_WAIT_TIME_SEC * 1000)) {
+            String errMsg = String.format(
+                Locale.ENGLISH,
+                    "Error: checkin did not complete within %d seconds after adding account %s",
+                    CHECKIN_WAIT_TIME_SEC, username);
+            Log.e(TAG, errMsg);
+            results.putString("error", errMsg);
+            finish(Activity.RESULT_CANCELED, results);
+            return;
+        }
+        authResult.putString("result", "SUCCESS");
+        finish(Activity.RESULT_OK, authResult);
+    }
+
+    /**
+     * Perform a blocking call to get authentication token.
+     * <p/>
+     * This method must not be called from main thread.
+     *
+     * @param account
+     * @return the authentication token, or null if it could not be retrieved
+     */
+    private String fetchAuthToken(Account account) {
+        try {
+            return mAccountManager.blockingGetAuthToken(account, AUTH_TOKEN_TYPE,
+                    true /* return null on authentication failure */);
+        } catch (OperationCanceledException e) {
+            Log.e(TAG, "Failed to get auth token", e);
+        } catch (IOException e) {
+            Log.e(TAG, "Failed to get auth token", e);
+        } catch (AuthenticatorException e) {
+            Log.e(TAG, "Failed to get auth token", e);
+        }
+        return null;
+    }
+
+    private static void setSyncAutomatically(Account account, boolean sync) {
+        for (SyncAdapterType adapter : ContentResolver.getSyncAdapterTypes()) {
+            if (adapter.accountType.equals(account.type)) {
+                ContentResolver.setSyncAutomatically(account, adapter.authority, sync);
+                Log.v(TAG, String.format("Auto sync for %s -> %s", adapter.authority,
+                        String.valueOf(sync)));
+            }
+        }
+    }
+
+    private class AuthenticationCallback implements AccountManagerCallback<Bundle> {
+        /** stores the result of account authentication. null means not finished */
+        private Bundle mResultBundle = null;
+
+        /**
+         * Block and wait for the authentication callback to complete.
+         *
+         * @return the {@link Bundle} result from the authentication.
+         */
+        public synchronized Bundle waitForAuthCompletion() {
+            while (mResultBundle == null) {
+                try {
+                    wait();
+                } catch (InterruptedException e) {
+                    // ignore
+                }
+            }
+            return mResultBundle;
+        }
+
+        @Override
+        public void run(AccountManagerFuture<Bundle> future) {
+            try {
+                mResultBundle = future.getResult();
+            } catch (OperationCanceledException e) {
+                mResultBundle = buildExceptionBundle(e);
+            } catch (IOException e) {
+                mResultBundle = buildExceptionBundle(e);
+            } catch (AuthenticatorException e) {
+                mResultBundle = buildExceptionBundle(e);
+            }
+            synchronized (this) {
+                notifyAll();
+            }
+        }
+
+        /**
+         * Create a result bundle for given exception
+         */
+        private Bundle buildExceptionBundle(Exception e) {
+            Bundle bundle = new Bundle();
+            bundle.putInt(AccountManager.KEY_ERROR_CODE,
+                    AccountManager.ERROR_CODE_INVALID_RESPONSE);
+            bundle.putString(AccountManager.KEY_ERROR_MESSAGE, e.toString());
+            return bundle;
+        }
+    }
+
+    private static class CheckinReceiver extends BroadcastReceiver {
+
+        private boolean mCheckinComplete = false;
+        private boolean mCheckinFailed = false;
+        private static final String EXTRA_CHECKIN_SUCCESS = "success";
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            Log.d(TAG, "Received checkin complete broadcast");
+            synchronized (this) {
+                if (intent != null && intent.getExtras() != null &&
+                        intent.getExtras().getBoolean(EXTRA_CHECKIN_SUCCESS, false)) {
+                    mCheckinComplete = true;
+                } else {
+                    Log.e(TAG, "Checkin has failed");
+                }
+                notifyAll();
+            }
+        }
+
+        /**
+         * Block until a checkin complete intent was received.
+         *
+         * @param time the max number of milliseconds to wait
+         * @return <code>true</code> if checkin was completed, <code>false</code> otherwise
+         */
+        public synchronized boolean waitForCheckin(long time) {
+            Log.d(TAG, "Waiting for checkin");
+            long endTime = System.currentTimeMillis() + time;
+            while (!mCheckinComplete && time > 0 && !mCheckinFailed) {
+                try {
+                    wait(time);
+                } catch (InterruptedException e) {
+                    // ignore
+                }
+                time = endTime - System.currentTimeMillis();
+            }
+            return mCheckinComplete;
+        }
+    }
+}
diff --git a/util_apps/AccountUtil/src/com/google/android/tradefed/account/AndroidManifest.xml b/util_apps/AccountUtil/src/com/google/android/tradefed/account/AndroidManifest.xml
new file mode 100644
index 000000000..38ca1df8c
--- /dev/null
+++ b/util_apps/AccountUtil/src/com/google/android/tradefed/account/AndroidManifest.xml
@@ -0,0 +1,63 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2013 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.google.android.tradefed.account" >
+
+    <uses-permission android:name="android.permission.AUTHENTICATE_ACCOUNTS" />
+    <uses-permission android:name="android.permission.GET_ACCOUNTS" />
+    <uses-permission android:name="android.permission.MANAGE_ACCOUNTS" />
+    <uses-permission android:name="android.permission.WRITE_SETTINGS" />
+    <uses-permission android:name="android.permission.WRITE_SYNC_SETTINGS" />
+    <uses-permission android:name="android.permission.READ_SYNC_SETTINGS" />
+    <uses-permission android:name="android.permission.READ_SYNC_STATS" />
+    <uses-permission android:name="android.permission.USE_CREDENTIALS" />
+    <uses-permission android:name="com.google.android.googleapps.permission.GOOGLE_AUTH" android:maxSdkVersion="34"/>
+    <uses-permission android:name="com.google.android.googleapps.permission.GOOGLE_AUTH.ALL_SERVICES" android:maxSdkVersion="34"/>
+    <uses-permission android:name="com.google.android.googleapps.permission.ACCESS_GOOGLE_PASSWORD" />
+
+    <application android:label="Google Account Util" />
+
+    <instrumentation
+        android:name=".AddAccount"
+        android:label="Add Account"
+        android:targetPackage="com.google.android.tradefed.account" >
+    </instrumentation>
+    <instrumentation
+        android:name=".HasAccount"
+        android:label="Has Account"
+        android:targetPackage="com.google.android.tradefed.account" >
+    </instrumentation>
+    <instrumentation
+        android:name=".RemoveAccounts"
+        android:label="Remove All Accounts"
+        android:targetPackage="com.google.android.tradefed.account" >
+    </instrumentation>
+    <instrumentation
+        android:name=".RemoveAccount"
+        android:label="Remove Account"
+        android:targetPackage="com.google.android.tradefed.account" >
+    </instrumentation>
+    <instrumentation
+        android:name=".GoogleAccountSync"
+        android:label="Sync Account"
+        android:targetPackage="com.google.android.tradefed.account" >
+    </instrumentation>
+
+    <uses-sdk android:minSdkVersion="19"
+              android:targetSdkVersion="31" />
+
+</manifest>
diff --git a/util_apps/AccountUtil/src/com/google/android/tradefed/account/GoogleAccountSync.java b/util_apps/AccountUtil/src/com/google/android/tradefed/account/GoogleAccountSync.java
new file mode 100644
index 000000000..4a58b52e5
--- /dev/null
+++ b/util_apps/AccountUtil/src/com/google/android/tradefed/account/GoogleAccountSync.java
@@ -0,0 +1,395 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.tradefed.account;
+
+import android.accounts.Account;
+import android.accounts.AccountManager;
+import android.app.Activity;
+import android.app.Instrumentation;
+import android.content.ContentResolver;
+import android.content.SyncAdapterType;
+import android.content.SyncInfo;
+import android.os.Bundle;
+import android.os.SystemClock;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
+
+/**
+ * A utility for Google account syncing
+ */
+public class GoogleAccountSync extends Instrumentation {
+    private static final String LOG_TAG = GoogleAccountSync.class.getSimpleName();
+
+    // Option: long to indicate the sync-checking interval. Visible for testing.
+    static final String PARAM_INTERVAL = "interval";
+    // Option: total timeout to quit sync-checking. Visible for testing.
+    static final String PARAM_TIMEOUT = "timeout";
+    // Option: force a sync on all sync authorities. Visible for testing.
+    static final String PARAM_FORCE_SYNC = "force-account-sync";
+    // TODO(b/130175486): Explore additional options such as whitelists for more deterministic
+    // behavior.
+
+    // Keys for Bundle messages
+    private static final String BUNDLE_RESULT_KEY = "result";
+    private static final String BUNDLE_MESSAGE_KEY = "message";
+    // Values for Bundle messages
+    private static final String BUNDLE_ERROR_MESSAGE = "ERROR";
+    private static final String BUNDLE_SUCCESS_MESSAGE = "SUCCESS";
+
+    // Small sleep value used to ensure that the system won't sleep for <=0 msecs when polling.
+    private static final long SHORT_DELAY_MS = 10;
+
+    // Account type for triggering Google account sync. Visible for testing.
+    static final String ACCOUNT_TYPE_GOOGLE = "com.google";
+
+    private long mInterval;
+    private long mTimeout;
+    private boolean mForceSyncAll = false;
+
+    @Override
+    public void onCreate(Bundle arguments) {
+        super.onCreate(arguments);
+
+        parseArguments(arguments);
+        start();
+    }
+
+    /**
+     * Enable tests to initialize the utility without having to trigger the {@code start()} call,
+     * which would run the utility in a separate thread.
+     *
+     * <p>Visible for testing.
+     */
+    void parseArguments(Bundle arguments) {
+        String intervalString = arguments.getString(PARAM_INTERVAL);
+        if (intervalString != null) {
+            mInterval = Long.parseLong(intervalString);
+        } else {
+            finishInstrumentation(Activity.RESULT_CANCELED, "No polling interval specified.");
+        }
+
+        String timeoutString = arguments.getString(PARAM_TIMEOUT);
+        if (timeoutString != null) {
+            mTimeout = Long.parseLong(timeoutString);
+        } else {
+            finishInstrumentation(Activity.RESULT_CANCELED, "No polling timeout specified.");
+        }
+
+        String forceSyncString = arguments.getString(PARAM_FORCE_SYNC);
+        if (forceSyncString != null) {
+            mForceSyncAll = Boolean.valueOf(forceSyncString);
+        }
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+
+        runSyncCheck();
+    }
+
+    /**
+     * Poll for the sync status periodically until all the pending and active syncs are completed or
+     * the operation times out.
+     *
+     * <p>Visible for testing.
+     */
+    void runSyncCheck() {
+        List<SyncInfoHolder> initialPendingSyncs = getPendingSyncs(ACCOUNT_TYPE_GOOGLE);
+        sendStatusMessage(
+                Activity.RESULT_OK,
+                String.format("Existing pending syncs : %s.", initialPendingSyncs));
+        List<SyncInfoHolder> additionalPendingSyncs = new ArrayList<>();
+        // If configured, trigger all syncs on the Google account.
+        if (mForceSyncAll) {
+            List<SyncInfoHolder> allPossibleSyncs =
+                    getAllPossibleSyncsForAccountType(ACCOUNT_TYPE_GOOGLE);
+            for (SyncInfoHolder sync : allPossibleSyncs) {
+                if (!initialPendingSyncs.contains(sync)) {
+                    sendStatusMessage(
+                            Activity.RESULT_OK,
+                            String.format(
+                                    "Requesting sync for authority %s in account %s.",
+                                    sync.authority, sync.account.name));
+                    requestSync(sync.account, sync.authority, new Bundle());
+                    additionalPendingSyncs.add(sync);
+                }
+            }
+        }
+        long startTime = SystemClock.uptimeMillis();
+        // Loop for the interval duration or until all syncs successful.
+        while (SystemClock.uptimeMillis() - startTime < mTimeout) {
+            removeNoLongerPendingSyncs(initialPendingSyncs);
+            removeNoLongerPendingSyncs(additionalPendingSyncs);
+            List<SyncInfoHolder> activeSyncs = getCurrentSyncs();
+            // If the number of polls with no active or pending syncs meets the
+            // threshold, declare success and quit.
+            if (activeSyncs.isEmpty()
+                    && initialPendingSyncs.isEmpty()
+                    && additionalPendingSyncs.isEmpty()) {
+                finishInstrumentation(Activity.RESULT_OK, "All syncs completed.");
+                return;
+            }
+            // If syncs are still active or pending, list them for debugging.
+            logCurrentSyncInfo(activeSyncs, initialPendingSyncs, additionalPendingSyncs);
+            // Continue sleeping until the next polling event.
+            long syncPollDelay =
+                    Math.min(mInterval, mTimeout - (SystemClock.uptimeMillis() - startTime));
+            SystemClock.sleep(Math.max(syncPollDelay, SHORT_DELAY_MS));
+        }
+        // If we reach here, there are pending syncs or active syncs. Log them for debugging.
+        sendStatusMessage(Activity.RESULT_OK, "Sync utility timed out.");
+        List<SyncInfoHolder> activeSyncs = getCurrentSyncs();
+        logCurrentSyncInfo(activeSyncs, initialPendingSyncs, additionalPendingSyncs);
+        finishInstrumentation(Activity.RESULT_CANCELED, "Sync utility timed out.");
+        // Cancel all additionally triggered syncs so that the forced syncs do not leave the device
+        // in a different state than if it were left to sync naturally.
+        if (!additionalPendingSyncs.isEmpty()) {
+            sendStatusMessage(
+                    Activity.RESULT_OK,
+                    String.format(
+                            "Cancelling still-pending forced syncs: %s.",
+                            additionalPendingSyncs.toString()));
+            for (SyncInfoHolder sync : additionalPendingSyncs) {
+                cancelSync(sync.account, sync.authority);
+            }
+        }
+        return;
+    }
+
+    /**
+     * Get the current syncs on the system from the {@link ContentResolver} and return them in the
+     * custom {@link GoogleAccountSync.SyncInfoHolder} format.
+     *
+     * <p>Visible for testing.
+     *
+     * @hide
+     */
+    protected List<SyncInfoHolder> getCurrentSyncs() {
+        List<SyncInfo> syncInfo = getContext().getContentResolver().getCurrentSyncs();
+        List<SyncInfoHolder> convertedSyncInfo = new ArrayList<>();
+        for (SyncInfo item : syncInfo) {
+            convertedSyncInfo.add(new SyncInfoHolder(item.account, item.authority));
+        }
+        return convertedSyncInfo;
+    }
+
+    /**
+     * Convenience data holder class for sync info.
+     *
+     * <p>{@link SyncInfo} is not used here as the API is intended to be hidden.
+     *
+     * <p>Visible for testing.
+     */
+    static class SyncInfoHolder {
+        public final Account account;
+        public final String authority;
+
+        public SyncInfoHolder(Account account, String authority) {
+            if (account == null || authority == null) {
+                throw new IllegalArgumentException("Account or sync authority should not be null");
+            }
+            this.account = account;
+            this.authority = authority;
+        }
+
+        @Override
+        public int hashCode() {
+            int hash = 7;
+            hash = 31 * hash + account.hashCode();
+            hash = 31 * hash + authority.hashCode();
+            return hash;
+        }
+
+        @Override
+        public boolean equals(Object other) {
+            if (other == null) {
+                return false;
+            }
+            if (other instanceof SyncInfoHolder) {
+                SyncInfoHolder otherInfo = (SyncInfoHolder) other;
+                return this.account.equals(otherInfo.account)
+                        && this.authority.equals(otherInfo.authority);
+            }
+            return false;
+        }
+
+        @Override
+        public String toString() {
+            return String.format("{%s: %s}", account.name, authority);
+        }
+    }
+
+    /**
+     * Allows tests to provide a stubbed {@link AccountManager}.
+     *
+     * <p>Visible for testing.
+     *
+     * @hide
+     */
+    protected AccountManager getAccountManager() {
+        return AccountManager.get(getContext());
+    }
+
+    /**
+     * Forwarding logic for {@link ContentResolver}'s static methods for stubbing in tests.
+     *
+     * <p>Visible for testing.
+     *
+     * @hide
+     */
+    protected SyncAdapterType[] getSyncAdapterTypes() {
+        return ContentResolver.getSyncAdapterTypes();
+    }
+
+    /**
+     * Forwarding logic for {@link ContentResolver}'s static methods for stubbing in tests.
+     *
+     * <p>Visible for testing.
+     *
+     * @hide
+     */
+    protected boolean isSyncPending(Account account, String authority) {
+        return ContentResolver.isSyncPending(account, authority);
+    }
+
+    /**
+     * Forwarding logic for {@link ContentResolver}'s static methods for stubbing in tests.
+     *
+     * <p>Visible for testing.
+     *
+     * @hide
+     */
+    protected void cancelSync(Account account, String authority) {
+        ContentResolver.cancelSync(account, authority);
+    }
+
+    /**
+     * Forwarding logic for {@link ContentResolver}'s static methods for stubbing in tests.
+     *
+     * <p>Visible for testing.
+     *
+     * @hide
+     */
+    protected void requestSync(Account account, String authority, Bundle extras) {
+        ContentResolver.requestSync(account, authority, extras);
+    }
+
+    /** Returns all currently pending syncs in a map of accounts to list of sync authorities. */
+    List<SyncInfoHolder> getPendingSyncs(String accountType) {
+        List<SyncInfoHolder> pendingSyncs = new ArrayList<>();
+        List<SyncAdapterType> supportedSyncAdapterTypes = getSupportedSyncAdapterTypes(accountType);
+        for (Account account : getAccountManager().getAccountsByType(accountType)) {
+            for (SyncAdapterType adapterType : supportedSyncAdapterTypes) {
+                if (isSyncPending(account, adapterType.authority)) {
+                    pendingSyncs.add(new SyncInfoHolder(account, adapterType.authority));
+                }
+            }
+        }
+        return pendingSyncs;
+    }
+
+    /**
+     * Trigger a sync on the request account type on all supported {@link SyncAdapterType}s.
+     *
+     * <p>Visible for testing.
+     *
+     * @return List of additional syncs triggered by this method.
+     */
+    List<SyncInfoHolder> getAllPossibleSyncsForAccountType(String accountType) {
+        List<SyncInfoHolder> possibleSyncs = new ArrayList<>();
+        List<SyncAdapterType> supportedSyncAdapterTypes = getSupportedSyncAdapterTypes(accountType);
+        for (Account account : getAccountManager().getAccountsByType(accountType)) {
+            for (SyncAdapterType adapterType : supportedSyncAdapterTypes) {
+                possibleSyncs.add(new SyncInfoHolder(account, adapterType.authority));
+            }
+        }
+        return possibleSyncs;
+    }
+
+    private List<SyncAdapterType> getSupportedSyncAdapterTypes(String accountType) {
+        List<SyncAdapterType> supportedSyncAdapterTypes = new ArrayList<>();
+        for (SyncAdapterType adapterType : getSyncAdapterTypes()) {
+            if (accountType.equals(adapterType.accountType)) {
+                supportedSyncAdapterTypes.add(adapterType);
+            }
+        }
+        return supportedSyncAdapterTypes;
+    }
+
+    private void removeNoLongerPendingSyncs(List<SyncInfoHolder> currentInfo) {
+        List<SyncInfoHolder> infoToRemove = new ArrayList<>();
+        for (SyncInfoHolder sync : currentInfo) {
+            if (!isSyncPending(sync.account, sync.authority)) {
+                infoToRemove.add(sync);
+            }
+        }
+        currentInfo.removeAll(infoToRemove);
+    }
+
+    public void sendStatusMessage (int result, String message) {
+        Bundle bundle = new Bundle();
+        bundle.putString(BUNDLE_MESSAGE_KEY, message);
+        sendStatus(result, bundle);
+    }
+
+    private void logCurrentSyncInfo(
+            List<SyncInfoHolder> activeSyncs,
+            List<SyncInfoHolder> initialPendingSyncs,
+            List<SyncInfoHolder> additionalPendingSyncs) {
+        if (!activeSyncs.isEmpty()) {
+            sendStatusMessage(
+                    Activity.RESULT_OK,
+                    String.format(
+                            Locale.ENGLISH,
+                            "There are active syncs (%d): %s.",
+                            activeSyncs.size(),
+                            activeSyncs));
+        }
+        if (!initialPendingSyncs.isEmpty()) {
+            sendStatusMessage(
+                    Activity.RESULT_OK,
+                    String.format(
+                            Locale.ENGLISH,
+                            "There are pending syncs (%d): %s.",
+                            initialPendingSyncs.size(),
+                            initialPendingSyncs));
+        }
+        if (!additionalPendingSyncs.isEmpty()) {
+            sendStatusMessage(
+                    Activity.RESULT_OK,
+                    String.format(
+                            Locale.ENGLISH,
+                            "There are pending forced syncs (%d): %s.",
+                            additionalPendingSyncs.size(),
+                            additionalPendingSyncs));
+        }
+    }
+
+    public void finishInstrumentation (int result, String message) {
+        Bundle bundle = new Bundle();
+        bundle.putString(BUNDLE_MESSAGE_KEY, message);
+        if (result == Activity.RESULT_OK) {
+            bundle.putString(BUNDLE_RESULT_KEY, BUNDLE_SUCCESS_MESSAGE);
+        } else {
+            bundle.putString(BUNDLE_RESULT_KEY, BUNDLE_ERROR_MESSAGE);
+        }
+        finish(result, bundle);
+    }
+}
diff --git a/util_apps/AccountUtil/src/com/google/android/tradefed/account/HasAccount.java b/util_apps/AccountUtil/src/com/google/android/tradefed/account/HasAccount.java
new file mode 100644
index 000000000..d708e9ab2
--- /dev/null
+++ b/util_apps/AccountUtil/src/com/google/android/tradefed/account/HasAccount.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.tradefed.account;
+
+import android.accounts.Account;
+import android.accounts.AccountManager;
+import android.app.Activity;
+import android.app.Instrumentation;
+import android.os.Bundle;
+import android.text.TextUtils;
+
+/**
+ * An instrumentation utility to check for the existence of a Google account on the device using adb
+ * shell am instrument -w com.google.android.tradefed.account/.HasAccount
+ */
+public class HasAccount extends Instrumentation {
+
+    static final String GOOGLE_ACCOUNT = "com.google";
+
+    @Override
+    public void onCreate(Bundle arguments) {
+        super.onCreate(arguments);
+        start();
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+
+        Bundle results = new Bundle();
+
+        Account[] accounts = AccountManager.get(getContext()).getAccounts();
+        for (int i = 0; i < accounts.length; ++i) {
+            if (accounts[i].type.equals(GOOGLE_ACCOUNT)) {
+                results.putString("result", "SUCCESS");
+                finish(Activity.RESULT_OK, results);
+                return;
+            }
+        }
+        String errorMsg =
+                String.format(
+                        "Did not find a registered Google account in the list: %s",
+                        TextUtils.join(", ", accounts));
+        results.putString("error", errorMsg);
+        finish(Activity.RESULT_CANCELED, results);
+    }
+}
diff --git a/util_apps/AccountUtil/src/com/google/android/tradefed/account/RemoveAccount.java b/util_apps/AccountUtil/src/com/google/android/tradefed/account/RemoveAccount.java
new file mode 100644
index 000000000..63dae6e5c
--- /dev/null
+++ b/util_apps/AccountUtil/src/com/google/android/tradefed/account/RemoveAccount.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.tradefed.account;
+
+import android.accounts.Account;
+import android.accounts.AccountManager;
+import android.app.Activity;
+import android.app.Instrumentation;
+import android.os.Bundle;
+import android.util.Log;
+
+import com.google.android.tradefed.account.RemoveAccounts.RemoveCallback;
+
+/**
+ * An instrumentation utility to remove a single Google account from device adb shell am instrument
+ * -w -e account accountName com.google.android.tests.utilities/.RemoveAccount
+ */
+public class RemoveAccount extends Instrumentation {
+
+    private static final String TAG = "RemoveAccount";
+
+    private String mAccount;
+
+    @Override
+    public void onCreate(Bundle arguments) {
+        super.onCreate(arguments);
+        mAccount = arguments.getString("account");
+        start();
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+
+        Log.d(TAG, "Attempting to remove Google account");
+        Bundle results = new Bundle();
+
+        AccountManager accountManager = AccountManager.get(getContext());
+        Account[] accounts = accountManager.getAccountsByType(AddAccount.GOOGLE_ACCOUNT);
+        for (Account account : accounts) {
+            if (account.name.equals(mAccount)) {
+                Log.i(TAG, String.format("Removing account %s", account.name));
+                RemoveCallback callback = new RemoveCallback();
+                accountManager.removeAccount(account, callback, null /* handler */);
+                if (!callback.waitForRemoveCompletion()) {
+                    results.putString("error", String.format(
+                            "Failed to remove account %s: Reason: %s", account.name,
+                            callback.getErrorMessage()));
+                    finish(Activity.RESULT_CANCELED, results);
+                    return;
+                }
+            }
+        }
+        results.putString("result", "SUCCESS");
+        finish(Activity.RESULT_OK, results);
+    }
+}
diff --git a/util_apps/AccountUtil/src/com/google/android/tradefed/account/RemoveAccounts.java b/util_apps/AccountUtil/src/com/google/android/tradefed/account/RemoveAccounts.java
new file mode 100644
index 000000000..0ae6d5b7d
--- /dev/null
+++ b/util_apps/AccountUtil/src/com/google/android/tradefed/account/RemoveAccounts.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.tradefed.account;
+
+import android.accounts.Account;
+import android.accounts.AccountManager;
+import android.accounts.AccountManagerCallback;
+import android.accounts.AccountManagerFuture;
+import android.accounts.AuthenticatorException;
+import android.accounts.OperationCanceledException;
+import android.app.Activity;
+import android.app.Instrumentation;
+import android.os.Build;
+import android.os.Bundle;
+import android.util.Log;
+
+import java.io.IOException;
+
+/**
+ * An instrumentation utility to remove all Google accounts from device adb shell am instrument -w
+ * com.google.android.tests.utilities/.RemoveAccounts
+ */
+public class RemoveAccounts extends Instrumentation {
+
+    private static final String TAG = "RemoveAccounts";
+
+    private static final boolean IS_GB_OR_OLDER = (Build.VERSION.SDK_INT <= 10);
+
+    private boolean mIsFirstFailure = true;
+
+    @Override
+    public void onCreate(Bundle arguments) {
+        super.onCreate(arguments);
+        start();
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+
+        Log.d(TAG, "Attempting to remove Google accounts");
+        Bundle results = new Bundle();
+
+        AccountManager accountManager = AccountManager.get(getContext());
+        Account[] accounts = accountManager.getAccountsByType(AddAccount.GOOGLE_ACCOUNT);
+        for (Account account : accounts) {
+            Log.i(TAG, String.format("Removing account %s", account.name));
+            RemoveCallback callback = new RemoveCallback();
+            accountManager.removeAccount(account, callback, null /* handler */);
+            if (!callback.waitForRemoveCompletion()) {
+                // Assume the failure is for the primary account if this is the first failure
+                // for GB and older devices and the error message is null.
+                if (IS_GB_OR_OLDER && mIsFirstFailure && callback.getErrorMessage() == null) {
+                    mIsFirstFailure = false;
+                    continue;
+                }
+                results.putString("error", String.format("Failed to remove account %s: Reason: %s",
+                        account.name, callback.getErrorMessage()));
+                finish(Activity.RESULT_CANCELED, results);
+                return;
+            }
+        }
+        results.putString("result", "SUCCESS");
+        finish(Activity.RESULT_OK, results);
+    }
+
+    static class RemoveCallback implements AccountManagerCallback<Boolean> {
+        /** stores the result of account removal. null means not finished */
+        private Boolean mResult = null;
+
+        private String mErrorMessage = null;
+
+        /**
+         * Block and wait for the remove callback to complete.
+         * 
+         * @return the {@link Bundle} result from the remove op.
+         */
+        public synchronized Boolean waitForRemoveCompletion() {
+            while (mResult == null) {
+                try {
+                    wait();
+                } catch (InterruptedException e) {
+                    // ignore
+                }
+            }
+            return mResult;
+        }
+
+        @Override
+        public void run(AccountManagerFuture<Boolean> future) {
+            try {
+                mResult = future.getResult();
+            } catch (OperationCanceledException e) {
+                handleException(e);
+            } catch (IOException e) {
+                handleException(e);
+            } catch (AuthenticatorException e) {
+                handleException(e);
+            }
+            synchronized (this) {
+                notifyAll();
+            }
+        }
+
+        public String getErrorMessage() {
+            return mErrorMessage;
+        }
+
+        /**
+         * Create a result bundle for given exception
+         */
+        private void handleException(Exception e) {
+            Log.e(TAG, "Failed to remove account", e);
+            mResult = false;
+            mErrorMessage = e.toString();
+        }
+    }
+}
diff --git a/util_apps/AccountUtil/tests/Android.bp b/util_apps/AccountUtil/tests/Android.bp
new file mode 100644
index 000000000..440510184
--- /dev/null
+++ b/util_apps/AccountUtil/tests/Android.bp
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package {
+    // See: http://go/android-license-faq
+    //   legacy_proprietary
+    default_applicable_licenses: [
+        "Android-Apache-2.0",
+    ],
+}
+
+android_test {
+    name: "GoogleAccountUtilTests",
+    srcs: ["src/**/*.java"],
+    static_libs: [
+        "androidx.test.runner",
+        "google-account-util-lib",
+        "guava",
+        "junit",
+        "mockito-target-minus-junit4",
+    ],
+    sdk_version: "14",
+    // This modules depends on cert unbundled_google.app which is not available in some branches like git_main-without-vendor,
+    // so we enable it only when the cert is available.
+    enabled: select(soong_config_variable("ANDROID", "unbundled_google_certs_available"), {
+        true: true,
+        default: false,
+    }),
+    certificate: ":unbundled_google.app",
+    optimize: {
+        enabled: false,
+    },
+    test_suites: ["device-tests"],
+    visibility: ["//visibility:private"],
+}
diff --git a/util_apps/AccountUtil/tests/AndroidManifest.xml b/util_apps/AccountUtil/tests/AndroidManifest.xml
new file mode 100644
index 000000000..1f234168f
--- /dev/null
+++ b/util_apps/AccountUtil/tests/AndroidManifest.xml
@@ -0,0 +1,43 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.google.android.tradefed.account.tests" >
+
+    <uses-permission android:name="android.permission.AUTHENTICATE_ACCOUNTS" />
+    <uses-permission android:name="android.permission.GET_ACCOUNTS" />
+    <uses-permission android:name="android.permission.MANAGE_ACCOUNTS" />
+    <uses-permission android:name="android.permission.WRITE_SETTINGS" />
+    <uses-permission android:name="android.permission.WRITE_SYNC_SETTINGS" />
+    <uses-permission android:name="android.permission.READ_SYNC_SETTINGS" />
+    <uses-permission android:name="android.permission.READ_SYNC_STATS" />
+    <uses-permission android:name="android.permission.USE_CREDENTIALS" />
+    <uses-permission android:name="com.google.android.googleapps.permission.GOOGLE_AUTH" android:maxSdkVersion="34"/>
+    <uses-permission android:name="com.google.android.googleapps.permission.GOOGLE_AUTH.ALL_SERVICES" android:maxSdkVersion="34"/>
+    <uses-permission android:name="com.google.android.googleapps.permission.ACCESS_GOOGLE_PASSWORD" />
+
+    <application android:label="Google Account Util Test">
+        <uses-library android:name="android.test.runner" />
+    </application>
+
+    <instrumentation
+        android:name="androidx.test.runner.AndroidJUnitRunner"
+        android:targetPackage="com.google.android.tradefed.account.tests"
+        android:label="Tests for GoogleAccountUtil" />
+
+    <uses-sdk android:minSdkVersion="21" />
+
+</manifest>
diff --git a/util_apps/AccountUtil/tests/AndroidTest.xml b/util_apps/AccountUtil/tests/AndroidTest.xml
new file mode 100644
index 000000000..dccd74e52
--- /dev/null
+++ b/util_apps/AccountUtil/tests/AndroidTest.xml
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<configuration description="Config for Tradefed Google account utility">
+    <option name="test-suite-tag" value="tradefed_google_account_util" />
+    <target_preparer class="com.android.tradefed.targetprep.TestAppInstallSetup">
+        <option name="test-file-name" value="GoogleAccountUtilTests.apk" />
+    </target_preparer>
+    <test class="com.android.tradefed.testtype.AndroidJUnitTest">
+        <option name="package" value="com.google.android.tradefed.account.tests" />
+    </test>
+</configuration>
diff --git a/util_apps/AccountUtil/tests/src/com/google/android/tradefed/account/GoogleAccountSyncTest.java b/util_apps/AccountUtil/tests/src/com/google/android/tradefed/account/GoogleAccountSyncTest.java
new file mode 100644
index 000000000..04922e7a4
--- /dev/null
+++ b/util_apps/AccountUtil/tests/src/com/google/android/tradefed/account/GoogleAccountSyncTest.java
@@ -0,0 +1,418 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.google.android.tradefed.account;
+
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.anyInt;
+import static org.mockito.Mockito.doNothing;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+import static org.mockito.MockitoAnnotations.initMocks;
+
+import android.accounts.Account;
+import android.accounts.AccountManager;
+import android.app.Activity;
+import android.content.SyncAdapterType;
+import android.os.Bundle;
+
+import com.google.common.collect.ImmutableList;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.Mock;
+
+import java.util.Arrays;
+
+/** Unit tests for {@link GoogleAccountSync}. */
+@RunWith(JUnit4.class)
+public class GoogleAccountSyncTest {
+    private static final String ACCOUNT_EMAIL = "test@gmail.com";
+    private static final long SYNC_TIMEOUT = 1500;
+    private static final long SYNC_POLL_INTERVAL = 100;
+    // A long-ish leeway is used here as the clean up steps when the utility times out have a lot of
+    // overhead, and the test itself takes additional time with the verify() calls, etc. However a
+    // disproportionately short sync polling interval is still used to keep the test reasonably
+    // short. In actual use when the timeout is much longer, the leeway is more negligible.
+    private static final long TIMEOUT_LEEWAY = 300;
+    private static final String AUTHORITY_SLOW = "slow";
+    private static final String AUTHORITY_SLOWER = "slower";
+    private static final String AUTHORITY_SLOWEST = "slowest";
+    private static final String AUTHORITY_OTHER = "other";
+    private static final ImmutableList<SyncAdapterType> SYNC_ADAPTERS =
+            ImmutableList.of(
+                    SyncAdapterType.newKey(AUTHORITY_SLOW, GoogleAccountSync.ACCOUNT_TYPE_GOOGLE),
+                    SyncAdapterType.newKey(AUTHORITY_SLOWER, GoogleAccountSync.ACCOUNT_TYPE_GOOGLE),
+                    SyncAdapterType.newKey(
+                            AUTHORITY_SLOWEST, GoogleAccountSync.ACCOUNT_TYPE_GOOGLE),
+                    SyncAdapterType.newKey(AUTHORITY_OTHER, "not.google"));
+    private static final Account ACCOUNT =
+            new Account(ACCOUNT_EMAIL, GoogleAccountSync.ACCOUNT_TYPE_GOOGLE);
+    private static final GoogleAccountSync.SyncInfoHolder SYNC_INFO_SLOW =
+            new GoogleAccountSync.SyncInfoHolder(ACCOUNT, AUTHORITY_SLOW);
+    private static final GoogleAccountSync.SyncInfoHolder SYNC_INFO_SLOWER =
+            new GoogleAccountSync.SyncInfoHolder(ACCOUNT, AUTHORITY_SLOWER);
+    private static final GoogleAccountSync.SyncInfoHolder SYNC_INFO_SLOWEST =
+            new GoogleAccountSync.SyncInfoHolder(ACCOUNT, AUTHORITY_SLOWEST);
+    private static final ImmutableList<GoogleAccountSync.SyncInfoHolder> EMPTY_SYNC_INFO_LIST =
+            ImmutableList.of();
+
+    @Mock private AccountManager mAccountManager;
+
+    private GoogleAccountSync mGoogleAccountSync;
+
+    @Before
+    public void setUp() {
+        initMocks(this);
+        doReturn(new Account[] {ACCOUNT})
+                .when(mAccountManager)
+                .getAccountsByType(eq(GoogleAccountSync.ACCOUNT_TYPE_GOOGLE));
+
+        mGoogleAccountSync = spy(new GoogleAccountSync());
+        // Stub to substitute the real AccountManager for the mocked one.
+        doReturn(mAccountManager).when(mGoogleAccountSync).getAccountManager();
+        // Stub out instrumentation-related calls.
+        doNothing().when(mGoogleAccountSync).finish(anyInt(), any(Bundle.class));
+        doNothing().when(mGoogleAccountSync).sendStatus(anyInt(), any(Bundle.class));
+        // Stub out calls that are forwarded to the ContentResolver.
+        doNothing()
+                .when(mGoogleAccountSync)
+                .requestSync(any(Account.class), any(String.class), any(Bundle.class));
+        doNothing().when(mGoogleAccountSync).cancelSync(any(Account.class), any(String.class));
+        doReturn(SYNC_ADAPTERS.toArray(new SyncAdapterType[SYNC_ADAPTERS.size()]))
+                .when(mGoogleAccountSync)
+                .getSyncAdapterTypes();
+    }
+
+    /*
+     * Notes:
+     *
+     * 1. The following tests use Mockito's iterator-style stubbing where "the last stub wins"
+     * according to the documentation. Therefore when the number of the stubbed method calls are
+     * larger than the list of return values specified, the last stubbed return value is used.
+     *
+     * 2. The timeout is set individually for each test as this way the execution time of setUp(),
+     * which is not negligible relative to the sync poll interval set here, is taken into account if
+     * the JUnit Timeout rule is used instead, which would further confuse test timing as the first
+     * execution of setUp() usually takes much longer than subsequent ones.
+     */
+
+    /** Test that the utility terminates correctly when no sync activity is present. */
+    @Test(timeout = SYNC_TIMEOUT + TIMEOUT_LEEWAY)
+    public void testNoForcedSync_noSyncActivity() {
+        // No pending syncs.
+        doReturn(false)
+                .when(mGoogleAccountSync)
+                .isSyncPending(any(Account.class), any(String.class));
+        // No active syncs.
+        doReturn(EMPTY_SYNC_INFO_LIST).when(mGoogleAccountSync).getCurrentSyncs();
+
+        mGoogleAccountSync.parseArguments(getNoForcedSyncArgs());
+        mGoogleAccountSync.runSyncCheck();
+
+        // We should only check once and terminate.
+        verify(mGoogleAccountSync, times(1)).getCurrentSyncs();
+        // Each of the sync authorities should be checked once for whether they are pending prior
+        // to polling.
+        verify(mGoogleAccountSync, times(1)).isSyncPending(eq(ACCOUNT), eq(AUTHORITY_SLOW));
+        verify(mGoogleAccountSync, times(1)).isSyncPending(eq(ACCOUNT), eq(AUTHORITY_SLOWER));
+        verify(mGoogleAccountSync, times(1)).isSyncPending(eq(ACCOUNT), eq(AUTHORITY_SLOWEST));
+
+        // Utility should report success.
+        verify(mGoogleAccountSync, times(1))
+                .finishInstrumentation(eq(Activity.RESULT_OK), any(String.class));
+    }
+
+    /** Test that the utility terminates correctly when the initial state only has active syncs. */
+    @Test(timeout = SYNC_TIMEOUT + TIMEOUT_LEEWAY)
+    public void testNoForcedSync_startingWithActiveSyncsOnly() {
+        // No pending syncs.
+        doReturn(false)
+                .when(mGoogleAccountSync)
+                .isSyncPending(any(Account.class), any(String.class));
+        // Schedule two poll cycles where there are active syncs and no active syncs after.
+        doReturn(
+                        Arrays.asList(SYNC_INFO_SLOWER, SYNC_INFO_SLOWEST),
+                        Arrays.asList(SYNC_INFO_SLOWEST),
+                        EMPTY_SYNC_INFO_LIST)
+                .when(mGoogleAccountSync)
+                .getCurrentSyncs();
+
+        mGoogleAccountSync.parseArguments(getNoForcedSyncArgs());
+        mGoogleAccountSync.runSyncCheck();
+
+        verify(mGoogleAccountSync, times(3)).getCurrentSyncs();
+        // Each of the sync authorities should be checked once for whether they are pending prior
+        // to polling.
+        verify(mGoogleAccountSync, times(1)).isSyncPending(eq(ACCOUNT), eq(AUTHORITY_SLOW));
+        verify(mGoogleAccountSync, times(1)).isSyncPending(eq(ACCOUNT), eq(AUTHORITY_SLOWER));
+        verify(mGoogleAccountSync, times(1)).isSyncPending(eq(ACCOUNT), eq(AUTHORITY_SLOWEST));
+
+        // Utility should report success.
+        verify(mGoogleAccountSync, times(1))
+                .finishInstrumentation(eq(Activity.RESULT_OK), any(String.class));
+    }
+
+    /** Test that the utility terminates correctly when the initial state only has pending syncs. */
+    @Test(timeout = SYNC_TIMEOUT + TIMEOUT_LEEWAY)
+    public void testNoForcedSync_startingWithPendingSyncsOnly() {
+        // No pending or active syncs for the "slow" sync.
+        doReturn(false)
+                .when(mGoogleAccountSync)
+                .isSyncPending(any(Account.class), eq(AUTHORITY_SLOW));
+        // Pending syncs for one cycle on the "slower" sync.
+        doReturn(true, false)
+                .when(mGoogleAccountSync)
+                .isSyncPending(any(Account.class), eq(AUTHORITY_SLOWER));
+        // Pending syncs for two cycles on the "slowest" sync.
+        doReturn(true, true, false)
+                .when(mGoogleAccountSync)
+                .isSyncPending(any(Account.class), eq(AUTHORITY_SLOWEST));
+        // No active syncs in the beginning, but the slower and slowest sync comes online at the
+        // second and third cycle, respectively, and lasts for two and one cycles respectively.
+        doReturn(
+                        EMPTY_SYNC_INFO_LIST,
+                        Arrays.asList(SYNC_INFO_SLOWEST),
+                        Arrays.asList(SYNC_INFO_SLOWER, SYNC_INFO_SLOWEST),
+                        EMPTY_SYNC_INFO_LIST)
+                .when(mGoogleAccountSync)
+                .getCurrentSyncs();
+
+        mGoogleAccountSync.parseArguments(getNoForcedSyncArgs());
+        mGoogleAccountSync.runSyncCheck();
+
+        verify(mGoogleAccountSync, times(4)).getCurrentSyncs();
+        // "Slow" sync is only checked for pending once.
+        verify(mGoogleAccountSync, times(1)).isSyncPending(eq(ACCOUNT), eq(AUTHORITY_SLOW));
+        // "Slower" and "slowest" syncs are checked each poll until they are no longer pending,
+        // resulting in 2 and 3 cycles respectively.
+        verify(mGoogleAccountSync, times(2)).isSyncPending(eq(ACCOUNT), eq(AUTHORITY_SLOWER));
+        verify(mGoogleAccountSync, times(3)).isSyncPending(eq(ACCOUNT), eq(AUTHORITY_SLOWEST));
+
+        // Utility should report success.
+        verify(mGoogleAccountSync, times(1))
+                .finishInstrumentation(eq(Activity.RESULT_OK), any(String.class));
+    }
+
+    /**
+     * Test that the utility terminates correctly when the initial state has both active and pending
+     * syncs.
+     */
+    @Test(timeout = SYNC_TIMEOUT + TIMEOUT_LEEWAY)
+    public void testNoForcedSync_startingWithPendingAndActiveSyncs() {
+        // "Slow" sync starts out active and not pending.
+        doReturn(false)
+                .when(mGoogleAccountSync)
+                .isSyncPending(any(Account.class), eq(AUTHORITY_SLOW));
+        // "Slower" and "slowest" sync starts out pending for one and two cycles, respectively.
+        doReturn(true, false)
+                .when(mGoogleAccountSync)
+                .isSyncPending(any(Account.class), eq(AUTHORITY_SLOWER));
+        doReturn(true, true, false)
+                .when(mGoogleAccountSync)
+                .isSyncPending(any(Account.class), eq(AUTHORITY_SLOWEST));
+        // Assume once started, "slow", "slower" and "slowest" last 2 cycles each.
+        doReturn(
+                        Arrays.asList(SYNC_INFO_SLOW),
+                        Arrays.asList(SYNC_INFO_SLOW, SYNC_INFO_SLOWER),
+                        Arrays.asList(SYNC_INFO_SLOWER, SYNC_INFO_SLOWEST),
+                        Arrays.asList(SYNC_INFO_SLOWEST),
+                        EMPTY_SYNC_INFO_LIST)
+                .when(mGoogleAccountSync)
+                .getCurrentSyncs();
+
+        mGoogleAccountSync.parseArguments(getNoForcedSyncArgs());
+        mGoogleAccountSync.runSyncCheck();
+
+        verify(mGoogleAccountSync, times(5)).getCurrentSyncs();
+        // Each sync is checked each poll until it is no longer pending resulting in 1, 2 and 3
+        // cycles for "slow", "slower" and "sloweest" respectively.
+        verify(mGoogleAccountSync, times(1)).isSyncPending(eq(ACCOUNT), eq(AUTHORITY_SLOW));
+        verify(mGoogleAccountSync, times(2)).isSyncPending(eq(ACCOUNT), eq(AUTHORITY_SLOWER));
+        verify(mGoogleAccountSync, times(3)).isSyncPending(eq(ACCOUNT), eq(AUTHORITY_SLOWEST));
+
+        // Utility should report success.
+        verify(mGoogleAccountSync, times(1))
+                .finishInstrumentation(eq(Activity.RESULT_OK), any(String.class));
+    }
+
+    /** Test that syncing is terminated once the sync activity dies down. */
+    @Test(timeout = SYNC_TIMEOUT + TIMEOUT_LEEWAY)
+    public void testNoForcedSync_terminatesOnceSyncsAreDoneAndNoneActive() {
+        // No pending syncs.
+        doReturn(false)
+                .when(mGoogleAccountSync)
+                .isSyncPending(any(Account.class), any(String.class));
+        doReturn(
+                        Arrays.asList(SYNC_INFO_SLOW),
+                        EMPTY_SYNC_INFO_LIST,
+                        // Any activity after this should no longer matter.
+                        EMPTY_SYNC_INFO_LIST,
+                        Arrays.asList(SYNC_INFO_SLOWER),
+                        EMPTY_SYNC_INFO_LIST)
+                .when(mGoogleAccountSync)
+                .getCurrentSyncs();
+
+        mGoogleAccountSync.parseArguments(getNoForcedSyncArgs());
+        mGoogleAccountSync.runSyncCheck();
+
+        // The syncs should terminate on the second try.
+        verify(mGoogleAccountSync, times(2)).getCurrentSyncs();
+
+        // Utility should report success.
+        verify(mGoogleAccountSync, times(1))
+                .finishInstrumentation(eq(Activity.RESULT_OK), any(String.class));
+    }
+
+    /** Test that the utility terminates correctly when it times out with syncs still active. */
+    @Test(timeout = SYNC_TIMEOUT + TIMEOUT_LEEWAY)
+    public void testNoForcedSync_timesOutWithUnfinishedActiveSyncs() {
+        // No pending syncs (does not matter in this test).
+        doReturn(false)
+                .when(mGoogleAccountSync)
+                .isSyncPending(any(Account.class), any(String.class));
+        // "Slowest" sync is always active during the polling period.
+        doReturn(Arrays.asList(SYNC_INFO_SLOWEST)).when(mGoogleAccountSync).getCurrentSyncs();
+
+        mGoogleAccountSync.parseArguments(getNoForcedSyncArgs());
+        mGoogleAccountSync.runSyncCheck();
+
+        // Because of the timeout, the test only passes if the utility times out as expected.
+
+        // Utility should report failure.
+        verify(mGoogleAccountSync, times(1))
+                .finishInstrumentation(eq(Activity.RESULT_CANCELED), any(String.class));
+    }
+
+    /** Test that the utility terminates correctly when it times out with syncs still pending. */
+    @Test(timeout = SYNC_TIMEOUT + TIMEOUT_LEEWAY)
+    public void testNoForcedSync_timesOutWithUnfinishedPendingSyncs() {
+        // Make the "slowest" sync always pending.
+        doReturn(true)
+                .when(mGoogleAccountSync)
+                .isSyncPending(any(Account.class), eq(AUTHORITY_SLOWEST));
+        doReturn(false)
+                .when(mGoogleAccountSync)
+                .isSyncPending(any(Account.class), eq(AUTHORITY_SLOW));
+        doReturn(false)
+                .when(mGoogleAccountSync)
+                .isSyncPending(any(Account.class), eq(AUTHORITY_SLOWER));
+        // No active syncs (does not matter in this test).
+        doReturn(EMPTY_SYNC_INFO_LIST).when(mGoogleAccountSync).getCurrentSyncs();
+
+        mGoogleAccountSync.parseArguments(getNoForcedSyncArgs());
+        mGoogleAccountSync.runSyncCheck();
+
+        // Because of the timeout, the test only passes if the utility times out as expected.
+
+        // Utility should report failure.
+        verify(mGoogleAccountSync, times(1))
+                .finishInstrumentation(eq(Activity.RESULT_CANCELED), any(String.class));
+    }
+
+    /**
+     * Test that when a forced sync is requested, it does not request duplicate syncs for syncs that
+     * are already pending and only request the non-pending ones.
+     */
+    @Test(timeout = SYNC_TIMEOUT + TIMEOUT_LEEWAY)
+    public void testForcedSync_requestsSyncsForNonPendingSyncsOnly() {
+        // Make the "slow" sync pending in the beginning.
+        doReturn(true, false)
+                .when(mGoogleAccountSync)
+                .isSyncPending(any(Account.class), eq(AUTHORITY_SLOW));
+        // Make the "slower" and "slowest" syncs not pending in the beginning. They should thus
+        // be requested. However we can always return "false" here and pretend that they are
+        // completed between poll cycles.
+        doReturn(false)
+                .when(mGoogleAccountSync)
+                .isSyncPending(any(Account.class), eq(AUTHORITY_SLOWER));
+        doReturn(false)
+                .when(mGoogleAccountSync)
+                .isSyncPending(any(Account.class), eq(AUTHORITY_SLOWEST));
+        // No active syncs (does not matter in this test; assume that all syncs are finished
+        // between polling cycles).
+        doReturn(EMPTY_SYNC_INFO_LIST).when(mGoogleAccountSync).getCurrentSyncs();
+
+        mGoogleAccountSync.parseArguments(getForceSyncArgs());
+        mGoogleAccountSync.runSyncCheck();
+
+        // No sync should be requested for the "slow" sync.
+        verify(mGoogleAccountSync, never())
+                .requestSync(eq(ACCOUNT), eq(AUTHORITY_SLOW), any(Bundle.class));
+        // The "slow" and "slower" syncs should each get a sync request.
+        verify(mGoogleAccountSync, times(1))
+                .requestSync(eq(ACCOUNT), eq(AUTHORITY_SLOWER), any(Bundle.class));
+        verify(mGoogleAccountSync, times(1))
+                .requestSync(eq(ACCOUNT), eq(AUTHORITY_SLOWEST), any(Bundle.class));
+
+        // Utility should report success.
+        verify(mGoogleAccountSync, times(1))
+                .finishInstrumentation(eq(Activity.RESULT_OK), any(String.class));
+    }
+
+    /**
+     * Test that when a forced sync is requested and some forced syncs are not complete by the time
+     * the utility times out, the utility will cancel these forced syncs.
+     */
+    @Test(timeout = SYNC_TIMEOUT + TIMEOUT_LEEWAY)
+    public void testForcedSync_cancelsUnfinishedForcedSyncWhenTimesOut() {
+        // Make the "slow" sync pending in the beginning.
+        doReturn(true, false)
+                .when(mGoogleAccountSync)
+                .isSyncPending(any(Account.class), eq(AUTHORITY_SLOW));
+        // Make the "slower" and "slowest" syncs not pending in the beginning. They should thus
+        // be requested. We keep the "slower" sync at false and pretend that it finished during
+        // the polling cycle, but change the "slowest" to be always pending afterwards.
+        doReturn(false)
+                .when(mGoogleAccountSync)
+                .isSyncPending(any(Account.class), eq(AUTHORITY_SLOWER));
+        doReturn(false, true)
+                .when(mGoogleAccountSync)
+                .isSyncPending(any(Account.class), eq(AUTHORITY_SLOWEST));
+        // No active syncs (does not matter in this test; assume that all triggered syncs are
+        // finished between polling cycles).
+        doReturn(EMPTY_SYNC_INFO_LIST).when(mGoogleAccountSync).getCurrentSyncs();
+
+        mGoogleAccountSync.parseArguments(getForceSyncArgs());
+        mGoogleAccountSync.runSyncCheck();
+
+        verify(mGoogleAccountSync, never()).cancelSync(eq(ACCOUNT), eq(AUTHORITY_SLOW));
+        verify(mGoogleAccountSync, never()).cancelSync(eq(ACCOUNT), eq(AUTHORITY_SLOWER));
+        verify(mGoogleAccountSync, times(1)).cancelSync(eq(ACCOUNT), eq(AUTHORITY_SLOWEST));
+
+        // Utility should report failure.
+        verify(mGoogleAccountSync, times(1))
+                .finishInstrumentation(eq(Activity.RESULT_CANCELED), any(String.class));
+    }
+
+    private Bundle getNoForcedSyncArgs() {
+        Bundle args = new Bundle();
+        args.putString(GoogleAccountSync.PARAM_INTERVAL, String.valueOf(SYNC_POLL_INTERVAL));
+        args.putString(GoogleAccountSync.PARAM_TIMEOUT, String.valueOf(SYNC_TIMEOUT));
+        return args;
+    }
+
+    private Bundle getForceSyncArgs() {
+        Bundle args = getNoForcedSyncArgs();
+        args.putString(GoogleAccountSync.PARAM_FORCE_SYNC, String.valueOf(true));
+        return args;
+    }
+}
```

